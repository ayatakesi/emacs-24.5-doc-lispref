<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Writing Emacs Primitives</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Writing-Emacs-Primitives"/>Writing Emacs Primitives</h1></div></div></div><a id="idm84091856" class="indexterm"/><a id="idm84091088" class="indexterm"/><p>Lispプリミティブとは、Cで実装されたLisp関数です。Lispから呼び出せるように、C関数インターフェースの詳細は、Cのマクロで処理されます。新たなCコードの記述のしかたを真に理解するには、ソースを読むのが唯一の方法ですが、ここではいくつかの事について説明します。
</p><p>スペシャルフォームの例として、以下は<code class="filename">eval.c</code>の<code class="literal">or</code>です(通常の関数は、同様の一般的な外観をもつ)。
</p><a id="idm84088528" class="indexterm"/><pre class="screen">DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
  doc: /* Eval args until one of them yields non-nil, then return
that value.
The remaining args are not evalled at all.
If all args return nil, return nil.
</pre><pre class="screen">usage: (or CONDITIONS ...)  */)
  (Lisp_Object args)
{
  register Lisp_Object val = Qnil;
  struct gcpro gcpro1;
</pre><pre class="screen">
</pre><pre class="screen">  GCPRO1 (args);
</pre><pre class="screen">
</pre><pre class="screen">  while (CONSP (args))
    {
      val = eval_sub (XCAR (args));
      if (!NILP (val))
        break;
      args = XCDR (args);
    }
</pre><pre class="screen">
</pre><pre class="screen">  UNGCPRO;
  return val;
}
</pre><a id="idm88209104" class="indexterm"/><p>では<code class="literal">DEFUN</code>マクロの引数について、詳細に説明しましょう。以下は、それらのテンプレートです:
</p><pre class="screen">DEFUN (<em class="replaceable"><code>lname</code></em>, <em class="replaceable"><code>fname</code></em>, <em class="replaceable"><code>sname</code></em>, <em class="replaceable"><code>min</code></em>, <em class="replaceable"><code>max</code></em>, <em class="replaceable"><code>interactive</code></em>, <em class="replaceable"><code>doc</code></em>)
</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>lname</code></em>
</span></dt><dd><p>これは、関数名として定義する、Lispシンボル名である。上記例では<code class="literal">or</code>。
</p></dd><dt><span class="term"><em class="replaceable"><code>fname</code></em>
</span></dt><dd><p>これは、その関数のC関数名である。これはCコードでその関数を呼び出すために使用される名前である。名前は慣習として‘<code class="literal">F</code>’の後にLisp名をつけ、Lisp名のすべてのダッシュ(‘<code class="literal">-</code>’)は、アンダースコアに変更する。つまりCコードから呼び出す場合は、<code class="literal">For</code>を呼び出す。
</p></dd><dt><span class="term"><em class="replaceable"><code>sname</code></em>
</span></dt><dd><p>これは、Lispでその関数を表すsubrオブジェクト用に、データ保持のための構造体に使用されるC変数名である。この構造体は、そのシンボルを作成してそれの定義にsubrオブジェクトを格納する初期化ルーチンにおいて、Lispシンボル名を伝達する。慣習により、これは常に<em class="replaceable"><code>fname</code></em>の‘<code class="literal">F</code>’を‘<code class="literal">S</code>’に置き換えた名前になる
</p></dd><dt><span class="term"><em class="replaceable"><code>min</code></em>
</span></dt><dd><p>これは、その関数が要求する、引数の最小個数である。関数<code class="literal">or</code>は、最小で0個の関数を受け入れる。
</p></dd><dt><span class="term"><em class="replaceable"><code>max</code></em>
</span></dt><dd><p>これは、その関数が受け入れる引数の最大個数が定数なら、引数の最大個数である。または<code class="literal">UNEVALLED</code>ならそれは未評価の引数を受け取るスペシャルフォームを示し、<code class="literal">MANY</code>なら評価される引数の個数に制限がないことを意味する(<code class="literal">&amp;rest</code>と等価)。<code class="literal">UNEVALLED</code>と<code class="literal">MANY</code>は、いずれもマクロである。<em class="replaceable"><code>max</code></em>が数字ならそれは<em class="replaceable"><code>min</code></em>より大きく、8より小さいこと。
</p><a id="idm88178128" class="indexterm"/></dd><dt><span class="term"><em class="replaceable"><code>interactive</code></em>
</span></dt><dd><p>これはLisp関数で<code class="literal">interactive</code>の引数として使用されるような、インタラクティブ仕様である(文字列)。<code class="literal">or</code>の場合は0(nullポインター)で、それは<code class="literal">or</code>がインタラクティブに呼び出せないことを示す。値<code class="literal">""</code>は、インタラクティブに呼び出し時、関数が引き受けるべきではないことを示す。値が‘<code class="literal">"(</code>’で始まる場合、その文字列はLispフォームとして評価される。たとえば:
</p><pre class="screen">DEFUN ("foo", Ffoo, Sfoo, 0, UNEVALLED,
       "(list (read-char-by-name \"Insert character: \")\
              (prefix-numeric-value current-prefix-arg)\
              t))",
  doc: /* … /*)
</pre></dd><dt><span class="term"><em class="replaceable"><code>doc</code></em>
</span></dt><dd><p>これはドキュメント文字列である。複数行を含むために特別なことを要しないので、これにはCの文字列構文ではなく、Cコメント構文を使用する。‘<code class="literal">doc:</code>’の後のコメントは、ドキュメント文字列として認識する。コメントの開始と終了の区切り文字‘<code class="literal">/*</code>’と‘<code class="literal">*/</code>’は、ドキュメント文字列の一部にはならない。
</p><p>ドキュメント文字列の最後の行がキーワード‘<code class="literal">usage:</code>’で始まる場合、その行の残りの部分は引数リストをドキュメント化するためのものとして扱われる。この方法により、Cコード内で使用される引数名とは異なる引数名を、ドキュメント文字列内で使用することができる。その関数の引数の個数に制限がない場合、‘<code class="literal">usage:</code>’は必須。
</p><p>Lispコードでのドキュメント文字列にたいする通常ルールのすべて(<a class="link" href="apds06.html" title="Tips for Documentation Strings">Documentation
Tips</a>を参照)は、Cコードのドキュメント文字列にも適用される。
</p></dd></dl></div><p><code class="literal">DEFUN</code>マクロ呼び出しの後には、そのC関数にたいする引数リストを、その引数のタイプを含めて記述しなければなりません。そのプリミティブがLispで固定された最大個数をもつ引数を受け入れるなら、Lisp引数それぞれにたいして1つのC引数をもち、各引数のタイプは<code class="literal">Lisp_Object</code>でなければなりません(ファイル<code class="filename">lisp.h</code>では、タイプ<code class="literal">Lisp_Object</code>の値を作成する種々のマクロと関数が宣言されている)。そのプリミティブのLispの最大引数個数に上限がない場合、それは正確に2つのC引数をもたなければなりません。1つ目はLisp引数の個数で、2つ目はそれらの値を含むブロックのアドレスです。これらはそれぞれ<code class="literal">int</code>、<code class="literal">Lisp_Object
*</code>のタイプをもちます。<code class="literal">Lisp_Object</code>は任意のデータ型と任意のLispオブジェクトを保持できるので、実行時のみ実際のデータ型を判断できます。特定のタイプの引数だけを受け入れるプリミティブを記述したい場合は、適切な述語を使用してタイプを明確にチェックしなければなりません(<a class="link" href="ch03s06.html" title="Type Predicates">Type
Predicates</a>を参照)。
<a id="idm88159568" class="indexterm"/>
</p><a id="idm88138192" class="indexterm"/><a id="idm88136656" class="indexterm"/><p>関数<code class="literal">For</code>自身の中では、マクロ<code class="literal">GCPRO1</code>と<code class="literal">UNGCPRO</code>の使用に注意してください。これらのマクロは、Emacsのデフォルトであるスタックマーキングを使用したガーベージコレクションを使用しない、いくつかのプラットフォームのために定義されています。<code class="literal">GCPRO1</code>マクロは、ガーベージコレクションにその変数とコンテンツすべてがアクセス可能でなければならないと、明示的にガーベージコレクションに通知して、ガーベージコレクションから変数を“保護”します。直接または間接的に、サブルーチンとして<code class="literal">eval_sub</code>か<code class="literal">Feval</code>を呼び出してLisp評価を行うかもしれないすべての関数で、GC保護は必要です。
</p><p>各オブジェクトにたいして、それを指すポインターが少なくとも1つあれば、GCからの保護を確実に満足することができます。つまり、ある特定のローカル変数が、(<code class="literal">GCPRO</code>をもつ別のローカル変数のような)別のポインターにより保護されるであろうオブジュクトを指すことが確実なら、保護なしでこれを行うことができます。それ以外なら、そのローカル変数には<code class="literal">GCPRO</code>が必要になります。
</p><p>マクロ<code class="literal">GCPRO1</code>は、ただ1つのローカル変数を保護します。2つの変数を保護したい場合には、かわりに<code class="literal">GCPRO2</code>を使用します。<code class="literal">GCPRO1</code>を繰り返しても、機能しないでしょう。<code class="literal">GCPRO3</code>、<code class="literal">GCPRO4</code>、<code class="literal">GCPRO5</code>、<code class="literal">GCPRO6</code>のマクロもあります。これらのマクロのすべては、<code class="literal">gcpro1</code>のようなローカル変数を暗黙に使用します。あなたはこれらをタイプ<code class="literal">struct
gcpro</code>で、明示的に宣言しなければなりません。つまり<code class="literal">GCPRO2</code>を使用するなら、<code class="literal">gcpro1</code>と<code class="literal">gcpro2</code>を宣言しなければなりません。
</p><p><code class="literal">UNGCPRO</code>は、カレントの関数内で保護された、変数の保護を取り消します。これは明示的に行う必要があります。
</p><p>一度Emacsがダンプされた後に、その変数に何か書き込まれているときには、その静的変数またはグローバル変数に、Cの初期化を使用してはなりません。初期化されたこれらの変数は、Emacsのダンプの結果として、(特定のオペレーティングシステムでは)読み取り専用となるメモリーエリアに割り当てられます。<a class="link" href="apes02.html" title="Pure Storage">Pure
Storage</a>を参照してください。
</p><a id="idm88122704" class="indexterm"/><p>C関数の定義だけでは、Lispプリミティブを利用可能にするのに十分ではありません。そのプリミティブにたいしてLispシンボルを作成して、その関数セルに適切なsubrオブジェクトを格納しなければなりません。このコードは以下のようになるでしょう:
</p><pre class="screen">defsubr (&amp;<em class="replaceable"><code>sname</code></em>);
</pre><p>ここで<em class="replaceable"><code>sname</code></em>は、<code class="literal">DEFUN</code>の3つ目の引数として使用する名前です。
</p><p>すでにLispプリミティブが定義されたファイルにプリミティブを追加する場合には、(そのファイル終端付近にある)<code class="literal">syms_of_<em class="replaceable"><code>something</code></em></code>という名前の関数を探して、そこに<code class="literal">defsubr</code>の呼び出しを追加してください。そのファイルにこの関数がない、または新たなファイルを作成する場合には、それに<code class="literal">syms_of_<em class="replaceable"><code>filename</code></em></code>(例:
<code class="literal">syms_of_myfile</code>)を追加します。それから<code class="filename">emacs.c</code>で、それらの関数すべてが呼び出されるが呼び出される箇所を探して、そこに<code class="literal">syms_of_<em class="replaceable"><code>filename</code></em></code>の呼び出しを追加してください。
</p><a id="Defining-Lisp-variables-in-C"/><a id="idm88114512" class="indexterm"/><a id="idm88113744" class="indexterm"/><a id="idm88112976" class="indexterm"/><p>関数<code class="literal">syms_of_<em class="replaceable"><code>filename</code></em></code>は、Lisp変数として可視となるすべてのC変数を定義する場所でもあります。<code class="literal">DEFVAR_LISP</code>はタイプ<code class="literal">Lisp_Object</code>のC変数を、Lispから可視にします。<code class="literal">DEFVAR_INT</code>はタイプ<code class="literal">int</code>のC変数を、常に整数となる値をもつようにして、Lispから可視にします。<code class="literal">DEFVAR_BOOL</code>はタイプ<code class="literal">int</code>のC変数を、常に<code class="literal">t</code>か<code class="literal">nil</code>のいずれかとなる値をもつようにして、Lispから可視にします。<code class="literal">DEFVAR_BOOL</code>で定義された変数は、バイトコンパイラーに使用されるリスト<code class="literal">byte-boolean-vars</code>に、自動的に追加されることに注意してください。
</p><a id="idm88104656" class="indexterm"/><p>Cで定義されたLisp変数を、<code class="literal">defcustom</code>で宣言された変数のように振る舞わせたい場合は、<code class="filename">cus-start.el</code>に適切なエントリーを追加してください。
</p><a id="idm88102480" class="indexterm"/><p>タイプ<code class="literal">Lisp_Object</code>のファイルをスコープとするC変数を定義する場合には、以下のように<code class="literal">syms_of_<em class="replaceable"><code>filename</code></em></code>内で<code class="literal">staticpro</code>を呼び出して、ガーベージコレクションからそれを保護しなければなりません:
</p><pre class="screen">staticpro (&amp;<em class="replaceable"><code>variable</code></em>);
</pre><p>以下は、より複雑な引数をもつ別の関数例です。これは<code class="filename">window.c</code>からのコードで、Lispオブジェクトを操作するためのマクロと関数の使用を示すものです。
</p><pre class="screen">DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
  Scoordinates_in_window_p, 2, 2, 0,
  doc: /* Return non-nil if COORDINATES are in WINDOW.
  ...
</pre><pre class="screen">  or `right-margin' is returned.  */)
  (register Lisp_Object coordinates, Lisp_Object window)
{
  struct window *w;
  struct frame *f;
  int x, y;
  Lisp_Object lx, ly;
</pre><pre class="screen">
</pre><pre class="screen">  CHECK_LIVE_WINDOW (window);
  w = XWINDOW (window);
  f = XFRAME (w-&gt;frame);
  CHECK_CONS (coordinates);
  lx = Fcar (coordinates);
  ly = Fcdr (coordinates);
  CHECK_NUMBER_OR_FLOAT (lx);
  CHECK_NUMBER_OR_FLOAT (ly);
  x = FRAME_PIXEL_X_FROM_CANON_X (f, lx) + FRAME_INTERNAL_BORDER_WIDTH(f);
  y = FRAME_PIXEL_Y_FROM_CANON_Y (f, ly) + FRAME_INTERNAL_BORDER_WIDTH(f);
</pre><pre class="screen">
</pre><pre class="screen">  switch (coordinates_in_window (w, x, y))
    {
    case ON_NOTHING:            /* NOT in window at all. */
      return Qnil;
</pre><pre class="screen">
    ...

</pre><pre class="screen">    case ON_MODE_LINE:          /* In mode line of window. */
      return Qmode_line;
</pre><pre class="screen">
    ...

</pre><pre class="screen">    case ON_SCROLL_BAR:         /* On scroll-bar of window.  */
      /* Historically we are supposed to return nil in this case.  */
      return Qnil;
</pre><pre class="screen">
</pre><pre class="screen">    default:
      abort ();
    }
}
</pre><p>Cコードは、それらがCで記述されていなければ、名前で呼び出すことはできないことに注意してください。Lispで記述された関数を呼び出すには、関数<code class="literal">funcall</code>を具現化した<code class="literal">Ffuncall</code>を使用します。Lisp関数<code class="literal">funcall</code>は個数制限なしの引数を受け付けるので、Cでの引数はLispレベルでの引数個数と、それらの値を含む1次元配列という、2個の引数になります。Lispレベルでの1つ目の引数は呼び出す関数で、残りはそれに渡す引数です。<code class="literal">Ffuncall</code>は評価機能(evaluator)を呼び出すかもしれないので、<code class="literal">Ffuncall</code>の呼び出し前後でガーベージコレクションからポインターを保護しなければなりません。
</p><p>C関数<code class="literal">call0</code>、<code class="literal">call1</code>、<code class="literal">call2</code>、...は個数が固定された引数でLisp関数を手軽に呼び出す、便利な方法を提供します。これらは<code class="literal">Ffuncall</code>を呼び出すことにより機能します。
</p><p><code class="filename">eval.c</code>は例を探すには、よいファイルです。<code class="filename">lisp.h</code>には、重要なマクロと関数の定義がいくつか含まれています。
</p><p>副作用をもたない関数を定義する場合には、コンパイラーのオプティマイザーに知らせるために<code class="literal">side-effect-free-fns</code>と<code class="literal">side-effect-and-error-free-fns</code>をバインドする、<code class="filename">byte-opt.el</code>内のコードを更新してください。
</p></div></body></html>