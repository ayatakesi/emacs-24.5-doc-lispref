<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>C Integer Types</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="C-Integer-Types"/>C Integer Types</h1></div></div></div><a id="idm87724368" class="indexterm"/><p>以下はEmacsのCソースコード内で、整数タイプを使用する際のガイドラインです。これらのガイドラインはときに相反するアドバイスを与えることがありますが、一般的な常識に沿ったものがアドバイスです。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>任意の制限の使用を避ける。たとえば、<code class="literal">s</code>の長さを<code class="literal">int</code>の範囲に収めることが要求されるのでなければ、<code class="literal">int len
= strlen (s);</code>を使用しないこと。
</p></li><li class="listitem"><p>符号付き整数の算術演算のオーバーフローのラップアラウンドを前提としてはならない。Emacsのポート対象先によっては、これは成り立たない。実際には、符号付き整数のオーバーフローは未定義であり、コアダンプや、早晩に“非論理的”な振る舞いさえ起こし得る。符号なし整数のオーバーフローは、2のべき乗の剰余に確実にラップアラウンドされることが保証されています。
</p></li><li class="listitem"><p>符号なしタイプと符号付きタイプを組み合わせるとコードが混乱するので、符号なしタイプより符号付きタイプを優先すること。他のガイドラインの多くはタイプが符号付きだとみなしている。符号なしタイプを要する稀なケースでは、符号付きの符号なし版(<code class="literal">ptrdiff_t</code>のかわりに<code class="literal">size_t</code>、<code class="literal">intptr_t</code>のかわりに<code class="literal">uintptr_t</code>)にたいして同様のアドバイスを適用できる。
</p></li><li class="listitem"><p>Emacsの文字コードでは、0から0x3FFFFFを優先すること。
</p></li><li class="listitem"><p>サイズ(たとえばすべての個別のCオブジェクトの最大サイズや、すべてのC配列の最大要素数にバインドされる整数)にたいしては、<code class="literal">ptrdiff_t</code>を優先すること。これは符号付きタイプにたいする、Emacsの一般的な優先事項である。<code class="literal">ptrdiff_t</code>の使用によりオブジェクトは<code class="literal">PTRDIFF_MAX</code>に制限されるが、より大きいオブジェクトはポインター減算を破壊するかもしれず、結局のところ問題を起こす可能性があるので、これは一方的に制限を課すものではない。
</p></li><li class="listitem"><p>ポインターの内部表現や、与えられた任意のタイミングで存在可能なオブジェクト数や割り当て可能な総バイト数にのみバインドされる整数には、<code class="literal">intptr_t</code>を優先すること。現在のことこEmacsは<code class="literal">intptr_t</code>の使用したほうがよいときに、別のタイプを使用する場合がある。現在のEmacsのカレント移植先にたいして未修正でコードが動作するので、これの修正の優先度は低い。
</p></li><li class="listitem"><p>Emacs
Lispのfixnumへの変換や逆変換を表す値では、fixnum演算が<code class="literal">EMACS_INT</code>にもとづくので、Emacsで定義されたタイプ<code class="literal">EMACS_INT</code>を優先すること。
</p></li><li class="listitem"><p>(ファイルサイズやエポック以降の経過秒数等の)システム値を表す際は、(<code class="literal">off_t</code>や<code class="literal">time_t</code>等の)システムタイプを優先すること。安全だと解っていなければ、システムタイプが符号付きだと仮定してはならない。たとえば<code class="literal">off_t</code>は常に符号付きだが、<code class="literal">time_t</code>は符号付きである必要はない。
</p></li><li class="listitem"><p><code class="literal">printf</code>族の関数を使用してプリントされ得る任意の符号付き整数であるかもしれない値を表す場合は、Emacsの定義タイプ<code class="literal">printmax_t</code>を優先すること。
</p></li><li class="listitem"><p>任意の符号付き整数であるかもしれない値を表す場合は、<code class="literal">intmax_t</code>を優先すること。
</p></li><li class="listitem"><p>ブーリーンには<code class="literal">bool</code>、<code class="literal">false</code>、<code class="literal">true</code>を使用すること。<code class="literal">bool</code>の使用によりプログラムの可読性が増し、<code class="literal">int</code>を使用するより若干高速になる。<code class="literal">int</code>、<code class="literal">0</code>、<code class="literal">1</code>を使用しても大丈夫だが、この旧スタイルは段階的に廃止される。<code class="literal">bool</code>を使用する際には、ソースファイル<code class="filename">lib/stdbool.in.h</code>に文書化されている<code class="literal">bool</code>の代替実装の制限を尊重すれば、C99以前のプラットフォームにたいするEmacsの可搬性か保たれる。特にブーリーンのビットフィールドは<code class="literal">bool</code>ではなく、<code class="literal">bool_bf</code>タイプであること。そうすれば標準のGCCでObjective
Cをコンパイルするときでさえ、正しく機能する。
</p></li><li class="listitem"><p>ビットフィールドでは、<code class="literal">int</code>は可搬性に劣るので、<code class="literal">int</code>より<code class="literal">unsigned int</code>か<code class="literal">signed
int</code>を優先すること。単一ビットのビットフィールドの値は0か1なので、<code class="literal">unsigned
int</code>か<code class="literal">bool_bf</code>を使用すること。
</p></li></ul></div></div></body></html>