<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Programming Types</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Programming-Types"/>Programming Types</h1></div></div></div><a id="idm47458512" class="indexterm"/><p>Emacs
Lispには2種類の一般的な型があります。1つはLispプログラミングに関わるもので、もう1つは編集に関わるものです。前者はさまざまな形で多くのLisp実装に存在します。後者はEmacs
Lispに固有です。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Integer-Type"/>Integer Type</h2></div></div></div><p>整数の値の範囲はマシンに依存します、最小のレンジは−536,870,912から536,870,911(30ビットでは
−2**29
から
2**29 − 1)
ですが、多くのマシンはこれより広い範囲を提供します。Emacs
Lispの数学関数は整数のオーバーフローをチェックしません。したがってEmacsのh整数が30ビットの場合、<code class="literal">(1+
536870911)</code>は−536,870,912になります。
</p><p>整数にたいする入力構文は、(10を基数とする)数字のシーケンスで、オプションで先頭に符号、最後にピリオドがつきます。Lispインタープリターにより生成されるプリント表記には、先頭の
‘<code class="literal">+</code>’や、最後の‘<code class="literal">.</code>’はありません。
</p><pre class="screen">-1               ; 整数の−1.
1                ; 整数の1.
1.               ; これも整数の1.
+1               ; これも整数の1.
</pre><p>特別な例外として、数字シーケンスが有効なオブジェクトとしては大きすぎる、または小さすぎる整数を指定する場合、Lispリーダーはそれを浮動小数点数(<a class="link" href="ch03s03.html#Floating_002dPoint-Type" title="Floating-Point Type">Floating-Point
Type</a>を参照してください)として読み取ります。たとえば、Emacsの整数が30ビットの場合、<code class="literal">536870912</code>は浮動小数点数の<code class="literal">536870912.0</code>として読み取られます。
</p><p>詳細は、<a class="link" href="ch04.html" title="Chapter 3. Numbers">Numbers</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Floating_002dPoint-Type"/>Floating-Point Type</h2></div></div></div><p>浮動小数点数は、コンピューターにおける科学表記に相当するものです。浮動小数点数を10の指数をともなう有理数として考えることができます。正確な有効桁数と可能な指数は、マシン固有です。Emacsは値の保存にCデータ型の<code class="literal">double</code>を使用し、内部的には10の指数ではなく、2の指数として記録します。
</p><p>浮動小数点数のプリント表現には、(後に最低1つの数字をともなう)小数点と、指数のどちらか一方、または両方が必要です。たとえば‘<code class="literal">1500.0</code>’、‘<code class="literal">+15e2</code>’、‘<code class="literal">15.0e+2</code>’、‘<code class="literal">+1500000e-3</code>’、‘<code class="literal">.15e4</code>’は、いずれも浮動小数点数の1500を記述し、これらはすべて等価です。
</p><p>詳細は、<a class="link" href="ch04.html" title="Chapter 3. Numbers">Numbers</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Character-Type"/>Character Type</h2></div></div></div><a id="idm47443920" class="indexterm"/><p>Emacs
Lispでの<em class="firstterm">文字(character)</em>は、整数以外の何者でもありません。他の言い方をすると、文字は文字コードで表現されます。たとえば文字<strong class="userinput"><code>A</code></strong>は、整数の65として表現されます。
</p><p>プログラムで文字を個別に使用するのは稀であり、文字のシーケンスとして構成される<span class="emphasis"><em>文字列(strings)</em></span>として扱われるのがより一般的です。<a class="link" href="ch03s03.html#String-Type" title="String Type">String
Type</a>を参照してください。
</p><p>文字列やバッファーの中の文字は、現在のところ0から4194303の範囲 — つまり22ビットに制限されています(<a class="link" href="ch33s05.html" title="Character Codes">Character
Codes</a>を参照してください)。0から127のコードは<acronym class="acronym">ASCII</acronym>コードで、残りは非<acronym class="acronym">ASCII</acronym>です(<a class="link" href="ch33.html" title="Chapter 32. Non-ASCII Characters">Non-ASCII
Characters</a>を参照してください)。キーボード入力を表す文字は、Control、Meta、Shiftなどの修飾キーをエンコードするために、より広い範囲をもちます。
</p><p>メッセージのために、文字にたいして人間が読むことができるテキストによる説明を生成する特別な関数が存在します。<a class="link" href="ch24s04.html" title="Describing Characters for Help Messages">Describing
Characters</a>を参照してください。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Basic-Char-Syntax"/>Basic Char Syntax</h3></div></div></div><a id="idm47435984" class="indexterm"/><a id="idm47435216" class="indexterm"/><a id="idm47434448" class="indexterm"/><a id="idm47433680" class="indexterm"/><a id="idm47432400" class="indexterm"/><p>文字は実際には整数なので、文字のプリント表現は10進数です。文字にたいする入力構文も利用可能ですが、Lispプログラムでこの方法により文字を記述するのは、明解なプログラミングではありません。文字にたいしては、Emacs
Lispが提供する、特別な入力構文を<span class="emphasis"><em>常に</em></span>使用するべきです。これらの構文フォーマットはクエスチョンマークで開始されます。
</p><p>英数字にたいする通常の入力構文は、クエスチョンマークと、その後にその文字を記述します。したがって文字<strong class="userinput"><code>A</code></strong>にたいしては‘<code class="literal">?A</code>’、文字<strong class="userinput"><code>B</code></strong>にたいしては‘<code class="literal">?B</code>’、文字<strong class="userinput"><code>a</code></strong>にたいしては‘<code class="literal">?a</code>’となります。
</p><p>たとえば:
</p><pre class="screen">?Q ⇒ 81     ?q ⇒ 113
</pre><p>句読点文字にも同じ構文を使用できますが、Lispコードを編集するためのEmacsコマンドが混乱しないように、‘<code class="literal">\</code>’を追加するのがよい場合がしばしばあります。たとえば開きカッコを記述するために‘<code class="literal">?\(</code>’と記述します。その文字が‘<code class="literal">\</code>’の場合、それをクォートするために、‘<code class="literal">?\\</code>’のように2つ目の‘<code class="literal">\</code>’を使用しなければ<span class="emphasis"><em>なりません</em></span>。
</p><a id="idm47423056" class="indexterm"/><a id="idm47422288" class="indexterm"/><a id="idm47421520" class="indexterm"/><a id="idm47420240" class="indexterm"/><a id="idm47419472" class="indexterm"/><a id="idm47418192" class="indexterm"/><a id="idm47417424" class="indexterm"/><a id="idm47416144" class="indexterm"/><a id="idm47415376" class="indexterm"/><a id="idm47414096" class="indexterm"/><a id="idm47413328" class="indexterm"/><a id="idm47412048" class="indexterm"/><a id="idm47411280" class="indexterm"/><a id="idm47410000" class="indexterm"/><a id="idm47409232" class="indexterm"/><a id="idm47395664" class="indexterm"/><a id="idm47394896" class="indexterm"/><a id="idm47393616" class="indexterm"/><a id="idm47392848" class="indexterm"/><p>control-g、backspace、tab、newline、vertical
tab、formfeed、space、return、del、escapeはそれぞれ‘<code class="literal">?\a</code>’、‘<code class="literal">?\b</code>’、‘<code class="literal">?\t</code>’、‘<code class="literal">?\n</code>’、‘<code class="literal">?\v</code>’、‘<code class="literal">?\f</code>’、‘<code class="literal">?\s</code>’、‘<code class="literal">?\r</code>’、‘<code class="literal">?\d</code>’、‘<code class="literal">?\e</code>’と表すことができます(後にダッシュのついた‘<code class="literal">?\s</code>’は違う意味をもちます
— これは後続の文字にたいして“super”の修飾を適用します)。したがって、
</p><pre class="screen">?\a ⇒ 7                 ; control-g, <strong class="userinput"><code>C-g</code></strong>
?\b ⇒ 8                 ; backspace, <span class="keycap"><strong>BS</strong></span>, <strong class="userinput"><code>C-h</code></strong>
?\t ⇒ 9                 ; tab, <span class="keycap"><strong>TAB</strong></span>, <strong class="userinput"><code>C-i</code></strong>
?\n ⇒ 10                ; newline, <strong class="userinput"><code>C-j</code></strong>
?\v ⇒ 11                ; vertical tab, <strong class="userinput"><code>C-k</code></strong>
?\f ⇒ 12                ; formfeed character, <strong class="userinput"><code>C-l</code></strong>
?\r ⇒ 13                ; carriage return, <span class="keycap"><strong>RET</strong></span>, <strong class="userinput"><code>C-m</code></strong>
?\e ⇒ 27                ; escape character, <span class="keycap"><strong>ESC</strong></span>, <strong class="userinput"><code>C-[</code></strong>
?\s ⇒ 32                ; space character, <span class="keycap"><strong>SPC</strong></span>
?\\ ⇒ 92                ; backslash character, <strong class="userinput"><code>\</code></strong>
?\d ⇒ 127               ; delete character, <span class="keycap"><strong>DEL</strong></span>
</pre><a id="idm47376848" class="indexterm"/><p>バックスラッシュが“エスケープ文字(escape
character)”の役割を果たすので、これらのバックスラッシュで始まるシーケンスは<em class="firstterm">エスケープシーケンス(escape
sequences)</em>とも呼ばれます。この用語法は、文字<span class="keycap"><strong>ESC</strong></span>とは関係ありません。‘<code class="literal">\s</code>’は文字定数としての使用を意図しており、文字定数の内部では、単にスペースを記述します。
</p><p>エスケープという特別な意味を与えずに、任意の文字の前にバックスラッシュの使用することは許されており、害もありませんしたがって‘<code class="literal">?\+</code>’は‘<code class="literal">?+</code>’と等価です。ほとんどの文字の前にバックスラッシュを追加することに理由はありません。しかし、Lispコードを編集するEmacsコマンドが混乱するのを避けるために、文字‘<code class="literal">()\|;'`"#.,</code>’の前にはバックスラッシュを追加するべきです。space、tab、newline、formfeedのような空白文字の前にもバックスラッシュを追加できます。しかし、tabやspaceのような実際の空白文字のかわりに、‘<code class="literal">\t</code>’や‘<code class="literal">\s</code>’のような可読性のあるエスケープシーケンスを使用するほうが明解です(スペースを後にともなうバックスラッシュを記述する場合、後続のテキストと区別するために、文字定数の後に余分なスペースを記述するべきです)。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="General-Escape-Syntax"/>General Escape Syntax</h3></div></div></div><p>特に重要なコントロール文字にたいする特別なエスケープシーケンスに加えて、Emacsは非<acronym class="acronym">ASCII</acronym>テキスト文字の指定に使用できる、何種類かのエスケープ構文を提供します。
</p><a id="idm47369424" class="indexterm"/><a id="idm47368144" class="indexterm"/><a id="idm47367376" class="indexterm"/><p>最初に、文字をUnicodeの値で指定することができます。<code class="literal">?\u<em class="replaceable"><code>nnnn</code></em></code>はUnicodeのコードポイント‘<code class="literal">U+<em class="replaceable"><code>nnnn</code></em></code>’の文字を表します。ここで<em class="replaceable"><code>nnnn</code></em>は、(慣例により)正確に4桁の16進数です。バックスラッシュは、後続の文字がエスケープシーケンスを形成することを示し、‘<code class="literal">u</code>’はUnicodeエスケープシーケンスを指定します。
</p><p><code class="literal">U+<em class="replaceable"><code>ffff</code></em></code>より大きなコードポイントをもつUnicode文字を指定するために、若干異なる構文が存在します。<code class="literal">?\U00<em class="replaceable"><code>nnnnnn</code></em></code>はコードポイント‘<code class="literal">U+<em class="replaceable"><code>nnnnnn</code></em></code>’の文字を表します。ここで<em class="replaceable"><code>nnnnnn</code></em>は6桁の16進数です。Unicode
Standardは‘<code class="literal">U+<em class="replaceable"><code>10ffff</code></em></code>’までのコードポイントだけを定義するので、これより大きいコードポイントを指定すると、Emacsはエラーをシグナルします。
</p><p>次に、文字を16進の文字コードで指定できます。16進エスケープシーケンスは、バックスラッシュ、‘<code class="literal">x</code>’、および16進の文字コードにより構成されます。したがって‘<code class="literal">?\x41</code>’は文字<strong class="userinput"><code>A</code></strong>、‘<code class="literal">?\x1</code>’は文字<strong class="userinput"><code>C-a</code></strong>、<code class="literal">?\xe0</code>は
grave accentつきの文字‘<code class="literal">a</code>’を表します。
任意の数の16進数を使用できるので、この方法により任意の文字コードを表すことができます。
</p><a id="idm47351888" class="indexterm"/><p>最後に、8進の文字コードにより文字を指定できます。8進エスケープシーケンスは、3桁までの8進数字をともなうバックスラッシュにより形成されます。したがって‘<code class="literal">?\101</code>’は文字<strong class="userinput"><code>A</code></strong>、‘<code class="literal">?\001</code>’は文字<strong class="userinput"><code>C-a</code></strong>、<code class="literal">?\002</code>は文字<strong class="userinput"><code>C-b</code></strong>を表します。この方法で指定できるのは、8進コード777までの文字だけです。
</p><p>これらのエスケープシーケンスは、文字列内でも使用されます。<a class="link" href="ch03s03.html#Non_002dASCII-in-Strings" title="Non-ASCII Characters in Strings">Non-ASCII in Strings</a>を参照してください。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Ctl_002dChar-Syntax"/>Control-Character Syntax</h3></div></div></div><a id="idm47345744" class="indexterm"/><p>他の入力構文を使用してコントロール文字を表すことができます。これは後にバックスラッシュ、カレット、対応する非コントロール文字(大文字か小文字)をともなうクエスチョンマークから構成されます。たとえば‘<code class="literal">?\^I</code>’と‘<code class="literal">?\^i</code>’はどちらも、値が9である文字<strong class="userinput"><code>C-i</code></strong>にたいする、有効な入力構文です。
</p><p>‘<code class="literal">^</code>’のかわりに、‘<code class="literal">C-</code>’を使用することもできます。したがって‘<code class="literal">?\C-i</code>’は、‘<code class="literal">?\^I</code>’や‘<code class="literal">?\^i</code>’と等価です。
</p><pre class="screen">?\^I ⇒ 9     ?\C-I ⇒ 9
</pre><p>文字列やバッファーの中では、<acronym class="acronym">ASCII</acronym>のコントロール文字だけが許されますが、キーボード入力にたいしては‘<code class="literal">C-</code>’により任意の文字をコントロール文字にすることができます。これらの非<acronym class="acronym">ASCII</acronym>のコントロール文字にたいするコントロール文字には
非コントロール文字にたいするコードと同様に、2**26
ビットが含まれます。通常のテキスト端末には、非<acronym class="acronym">ASCII</acronym>コントロール文字を生成する方法がありませんが、Xおよび他のウィンドウシステムを使用することにより、簡単に生成することができます。
</p><p>歴史的な理由により、Emacsは<span class="keycap"><strong>DEL</strong></span>文字を、<strong class="userinput"><code>?</code></strong>のコントロール文字として扱います:
</p><pre class="screen">?\^? ⇒ 127     ?\C-? ⇒ 127
</pre><p>結果として、Xでは有意な入力文字である<strong class="userinput"><code>Control-?</code></strong>文字を、‘<code class="literal">\C-</code>’を使用して表現することは今のところできません。さまざまなLispファイルがこの方法により<span class="keycap"><strong>DEL</strong></span>を参照するため、これを変更するのは簡単ではありません。
</p><p>コントロール文字の表現はファイルや文字列のなかで見ることができますが、わたしたちは‘<code class="literal">^</code>’構文を推奨します。キーボード入力にたいするコントロール文字に好ましいのは、‘<code class="literal">C-</code>’構文です。どちらを使用するかはプログラムの意味に影響しませんが、プログラムを読む人の理解を助けるでしょう。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Meta_002dChar-Syntax"/>Meta-Character Syntax</h3></div></div></div><a id="idm47331152" class="indexterm"/><p><em class="firstterm">メタ文字(meta character)</em>とは、<span class="keycap"><strong>META</strong></span>修飾キーとともにタイプされた文字です。そのような文字を表す整数には
2**27
のビットがセットされています。基本的な文字コードの広い範囲を利用可能にするために、メタや他の修飾にたいして上位ビットを使用します。
</p><p>文字列では、メタ文字を示す<acronym class="acronym">ASCII</acronym>文字に、
2**7
ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の<acronym class="acronym">ASCII</acronym>文字のメタ修飾されたバージョンとなります。文字列内での<span class="keycap"><strong>META</strong></span>処理の詳細については、<a class="link" href="ch21s07.html#Strings-of-Events" title="Putting Keyboard Events in Strings">Strings
of Events</a>を参照してください。
</p><p>メタ文字の入力構文には‘<code class="literal">\M-</code>’を使用します。たとえば‘<code class="literal">?\M-A</code>’は<strong class="userinput"><code>M-A</code></strong>を意味します。8進文字コード(以下参照)や、‘<code class="literal">\C-</code>’、その他の文字にたいする他の構文とともに‘<code class="literal">\M-</code>’を使用できます。したがって、<strong class="userinput"><code>M-A</code></strong>は‘<code class="literal">?\M-A</code>’や‘<code class="literal">?\M-\101</code>’と記述できます。同様に、<strong class="userinput"><code>C-M-b</code></strong>は‘<code class="literal">?\M-\C-b</code>’、‘<code class="literal">?\C-\M-b</code>’、‘<code class="literal">?\M-\002</code>’と記述することができます。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Other-Char-Bits"/>Other Character Modifier Bits</h3></div></div></div><p>グラフィック文字(graphic
character)の大文字小文字は、文字コードで示されます。たとえば<acronym class="acronym">ASCII</acronym>では、文字‘<code class="literal">a</code>’と文字‘<code class="literal">A</code>’は区別されます。しかし<acronym class="acronym">ASCII</acronym>にはコントロール文字が大文字なのか小文字なのかを表現する方法がありません。コントロール文字がタイプされたときシフトキーが使用されたかを示すために、Emacsは
2**25
のビットを使用します。この区別は、X端末や、他の特別な端末を使用しているときだけ可能です。通常のテキスト端末は、これらの違いを報告しません。シフトをあらわすビットのためのLisp構文は‘<code class="literal">\S-</code>’です。したがって‘<code class="literal">?\C-\S-o</code>’や‘<code class="literal">?\C-\S-O</code>’は、shifted-control-o文字を表します。
</p><a id="idm47303120" class="indexterm"/><a id="idm47302352" class="indexterm"/><a id="idm47301584" class="indexterm"/><p>Xウィンドウシステムは文字にセットできる、他に3つ<a id="modifier-bits"/>修飾ビット —
<em class="firstterm">hyper</em>、<em class="firstterm">super</em>、<em class="firstterm">alt</em>を定義します。これらのビットにたいする構文は、‘<code class="literal">\H-</code>’、‘<code class="literal">\s-</code>’、‘<code class="literal">\A-</code>’です(これらのプレフィクスでは、大文字小文字は意味があります)。したがって‘<code class="literal">?\H-\M-\A-x</code>’は<strong class="userinput"><code>Alt-Hyper-Meta-x</code></strong>を表します(‘<code class="literal">-</code>’が後にない‘<code class="literal">\s</code>’は、スペース文字を表すことに注意してください)。
数値的には、ビット値2**22はalt、2**23はsuper、2**24はhyperです。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Symbol-Type"/>Symbol Type</h2></div></div></div><p>GNU Emacs
Lispでの<em class="firstterm">シンボル(symbol)</em>とは、名前をもつオブジェクトです。シンボル名は、そのシンボルのプリント表現としての役割があります。Lispの通常の使用では、1つのobarray(<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照してください)により、シンボル名は一意です — 2つのシンボルが同じ名前をもつことはありません。
</p><p>シンボルは、変数、関数名としての役割や、プロパティーリストを保持する役割をもつことができます。他のすべてのLispオブジェクトから区別するためだけの役割をもつ場合もあり、データ構造内にそのようなシンボルが存在することは、確実に認識されるでしょう。与えられたコンテキストにおいて、通常はこれらのうちの1つの使用だけが意図されます。しかし3つすべての方法で、1つのシンボルを独立して使用することもできます。
</p><p>名前がコロン(‘<code class="literal">:</code>’)で開始されるシンボルは、<em class="firstterm">キーワードシンボル(keyword
symbol)</em>と呼ばれます。これらのシンボルは自動的に定数として振る舞い、通常は未知のシンボルと、いくつかの特定の候補を比較することだけに使用されます。<a class="link" href="ch12s02.html" title="Variables that Never Change">Constant
Variables</a>を参照してください。
</p><a id="idm47290704" class="indexterm"/><a id="idm47289424" class="indexterm"/><p>シンボル名にはどんな文字でも含めることができます。ほとんどのシンボル名は英字、数字、‘<code class="literal">-+=*/</code>’などの句読点文字で記述されます。このような名前には、特別な句読点文字は必要ありません。名前が数字のように見えない限りは、名前にはどのような文字も使用できます(名前が数字のように見える場合は、名前の先頭に‘<code class="literal">\</code>’を記述して、強制的にシンボルとして解釈させます)。文字‘<code class="literal">_~!@$%^&amp;:&lt;&gt;{}?</code>’はあまり使用されませんが、これらも特別な句読点文字を必要としません。他の文字も、バックスラッシュでエスケープすることにより、シンボル名に含めることができます。しかし、文字列内でのバックスラッシュの使用とは対照的に、シンボル名でのバックスラッシュは、バックスラッシュの後の1文字をエスケープするだけです。たとえば文字列内では、‘<code class="literal">\t</code>’はタブ文字を表します。しかしシンボル名の中では、‘<code class="literal">\t</code>’は英字‘<code class="literal">t</code>’をクォートするに過ぎません。
名前にタブ文字をもつシンボルを記述するには、(バックスラッシュを前置した)実際のタブを使用しなければなりません。しかし、そのようなことを行なうことは、めったにありません。
</p><a id="idm47264720" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意:</strong></span>Common
Lispでは、明示的にエスケープされない限り、小文字は常に大文字に“フォールドされ(folded)”ます。Emacs
Lispでは大文字と小文字は区別されます。
</p></blockquote></div><p>以下はシンボル名の例です。4番目の例の中の‘<code class="literal">+</code>’は、シンボルが数字として読み取られるのを防ぐために、エスケープされていることに注意してください。6番目の例では、名前の残りの部分により数字としては不正なので、エスケープの必要はありません。
</p><pre class="screen">foo                 ; ‘<code class="literal">foo</code>’という名前のシンボル。
FOO                 ; ‘<code class="literal">foo</code>’とは別の、‘<code class="literal">FOO</code>’という名前のシンボル。
</pre><pre class="screen">1+                  ; ‘<code class="literal">1+</code>’という名前のシンボル
                    ;   (整数の‘<code class="literal">+1</code>’ではありません)。
</pre><pre class="screen">\+1                 ; ‘<code class="literal">+1</code>’という名前のシンボル
                    ;   (とても読みやすい名前とはいえません)。
</pre><pre class="screen">

\(*\ 1\ 2\)         ; ‘<code class="literal">(* 1 2)</code>’という名前のシンボル(悪い名前)。
+-*/_~!@$%^&amp;=:&lt;&gt;{}  ; ‘<code class="literal">+-*/_~!@$%^&amp;=:&lt;&gt;{}</code>’という名前のシンボル。
                    ;   これらの文字はエスケープする必要はありません。
</pre><a id="idm47255760" class="indexterm"/><a id="idm47254480" class="indexterm"/><p>シンボル名がプリント表現としての役割をもつというルールの例外として、‘<code class="literal">##</code>’があります。これは、名前が空文字列の、internされたシンボルのプリント表現です。さらに‘<code class="literal">#:<em class="replaceable"><code>foo</code></em></code>’は、internされていない<em class="replaceable"><code>foo</code></em>という名前のシンボルにたいするプリント表現です(通常、Lispリーダーはすべてのシンボルをinternします。<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照してください)。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Sequence-Type"/>Sequence Types</h2></div></div></div><p><em class="firstterm">シーケンス(sequence)</em>とは、要素の順序セットを表現する、Lispオブジェクトです。Emacs Lispには、2種類のシーケンス
— <em class="firstterm">リスト(lists)</em>と<em class="firstterm">配列(arrays)</em>があります。
</p><p>リストはもっとも一般的に使用されるシーケンスです。リストは任意の型の要素を保持でき、要素の追加・削除により簡単に長さを変更できます。リストについては、次のサブセクションを参照してください。
</p><p>配列は固定長のシーケンスです。配列はさらに文字列(strings)、ベクター(vectors)、文字テーブル(char-tables)、ブールベクター(bool-vectors)に細分されます。ベクターは任意の型の要素を保持できますが、文字列の要素は文字でなければならず、ブールベクターの要素は<code class="literal">t</code>か<code class="literal">nil</code>でなければなりません。文字テーブルはベクターと似ていますが、有効な文字によりインデックスづけされる点が異なります。文字列内の文字は、バッファー内の文字のようにテキストプロパティーをもつことができます(<a class="link" href="ch32s19.html" title="Text Properties">Text
Properties</a>を参照してください)。しかしベクターは、その要素が文字のときでも、テキストプロパティーをサポートしません。
</p><p>リスト、文字列、およびその他の配列型も、重要な類似点を共有します。たとえば、それらはすべて長さ<em class="replaceable"><code>l</code></em>をもち、要素は0から<em class="replaceable"><code>l</code></em>−1でインデックスづけされます。いくつかの関数はシーケンス関数と呼ばれ、これらは任意の種類のシーケンスを許容します。たとえば、関数<code class="literal">length</code>は、任意の種類のシーケンスの長さを報告します。<a class="link" href="ch07.html" title="Chapter 6. Sequences, Arrays, and Vectors">Sequences
Arrays Vectors</a>を参照してください。
</p><p>シーケンスは読み取りにより常に新たに作成されるので、同じシーケンスを2回読み取るのは、一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト<code class="literal">()</code>は、常に同じオブジェクト<code class="literal">nil</code>を表します。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Cons-Cell-Type"/>Cons Cell and List Types</h2></div></div></div><a id="idm47237200" class="indexterm"/><a id="idm47236432" class="indexterm"/><a id="idm47235664" class="indexterm"/><p><em class="firstterm">コンスセル(cons
cell)</em>は、CARスロット、CDRスロットと呼ばれる2つのスロットから構成されるオブジェクトです。各スロットは、任意のLispオブジェクトを<em class="firstterm">保持</em>できます。そのときCARスロットに保持されるオブジェクトが何であれ、わたしたちは“このコンスセルのCAR”のような言い方をします。これはCDRの場合も同様です。
</p><a id="idm47233872" class="indexterm"/><p><em class="firstterm">リスト(list)</em>は、コンスセルの連続するシリーズで、各コンスセルのCDRスロットは、次のコンスセル、または空リストを保持します。空リストは実際にはシンボル<code class="literal">nil</code>です。詳細については、<a class="link" href="ch06.html" title="Chapter 5. Lists">Lists</a>を参照してください。ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルにより構成される任意の構造を、<em class="firstterm">リスト構造(list
structure)</em>という用語で参照します。
</p><a id="idm47231056" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p>Cプログラマーにたいする注意: Lispのリストはコンスセルにより構築される、<em class="firstterm">リンクリスト(linked
list)</em>として機能します。Lispではポインターは暗黙的なので、わたしたちはコンスセルのスロットが、値を“保持(hold)”するのか、それとも値を“指す(point)”のかを区別しません。
</p></blockquote></div><a id="idm47229392" class="indexterm"/><p>コンスセルはLispの中心なので、“コンスセルではないオブジェクト”にたいする単語もあります。これらのオブジェクトは<em class="firstterm">アトム(atoms)</em>と呼ばれます。
</p><a id="idm47227856" class="indexterm"/><a id="idm47227088" class="indexterm"/><p>リストにたいする入力構文とプリント表現は等しく、それは左カッコ、任意の数の要素、右カコから構成されます。以下はリストの例です:
</p><pre class="screen">(A 2 "A")            ; 3要素のリスト。
()                   ; 要素がないリスト(空リスト)。
nil                  ; 要素がないリスト(空リスト)。
("A ()")             ; 1要素のリスト: 文字列<code class="literal">"A ()"</code>。
(A ())               ; 2要素のリスト: <code class="literal">A</code>と空リスト。
(A nil)              ; 同上
((A B C))            ; 1要素のリスト
                     ;   (この要素は、3要素のリスト)。
</pre><p>読み取りにおいては、カッコの内側は、リストの要素になります。つまり、コンスセルは各要素から作成されます。コンスセルのCARスロットは要素を保持し、CDRスロットはリスト内の次のコンスセル(このコンスセルはリスト内の次の要素を保持します)を参照します。最後のコンスセルのCDRスロットは、<code class="literal">nil</code>を保持するようにセットされます。
</p><p>CAR、CDRという名称は、Lispの歴史に由来します。オリジナルのLisp実装はIBM
704コンピューターで実行されていました。ワードを2つの部分、つまり“address”と呼ばれる部分と、“decrement”と呼ばれる部分に分割していて、その際CARはaddress部から内容を取り出す命令で、CDRはdecrement部から内容を取り出す命令でした。対照的に“cons
cells”は、これらを作成する関数<code class="literal">cons</code>から命名されました。この関数は関数の目的、すなわちセルを作る(construction of
cells)という目的から命名されました。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Box-Diagrams"/>Drawing Lists as Box Diagrams</h3></div></div></div><a id="idm47216848" class="indexterm"/><a id="idm47216080" class="indexterm"/><p>コンスセルを表現するドミノのような1対のボックスによる図により、リストを説明することができます(Lispリーダーがこのような図を読み取ることはできません。人間およびコンピューターが理解できるテキスト表記と異なり、ボックスの図は人間だけが理解できます)。この図は3要素のリスト<code class="literal">(rose
violet buttercup)</code>を表したものです:
</p><pre class="screen">    --- ---      --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --&gt; rose     --&gt; violet   --&gt; buttercup
</pre><p>この図では、ボックスは任意のLispオブジェクトへの参照を保持できるスロットを表します。ボックスのペアはコンスセルを表します。矢印はLispオブジェクト(アトム、または他のコンスセル)への参照を表します。
</p><p>この例では、1番目のボックスは1番目のコンスセルで、それのCARは<code class="literal">rose</code>(シンボル)を参照または“保持(holds)”します。2番目のボックスは1番目のコンスセルのCDRを保持し、次のボックスペア、すなわち2番目のコンスセルを参照します。2番目のコンスセルのCARは<code class="literal">violet</code>で、CDRは3番目のコンスセルです。(最後の)3番目のコンスセルのCDRは、<code class="literal">nil</code>です。
</p><p>同じリスト<code class="literal">(rose violet buttercup)</code>を、違うやり方で描いた別の図で表してみましょう:
</p><pre class="screen"> ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o--------&gt;| violet |   o--------&gt;| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
</pre><a id="idm47210192" class="indexterm"/><a id="idm47209040" class="indexterm"/><p>要素がないリストは<em class="firstterm">空リスト(empty
list)</em>で、これはシンボル<code class="literal">nil</code>と同じです。別の言い方をすると、<code class="literal">nil</code>はシンボルであり、リストでもあります。
</p><p>以下は、リスト<code class="literal">(A ())</code>、または等価な<code class="literal">(A nil)</code>をボックスと矢印で描いたものです:
</p><pre class="screen">    --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; nil
    --- ---      --- ---
     |            |
     |            |
      --&gt; A        --&gt; nil
</pre><p>以下はもっと複雑な例です。これは、1番目の要素が2等疎のリスとである、3要素のリスト<code class="literal">((pine needles) oak
maple)</code>を表します:
</p><pre class="screen">    --- ---      --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --&gt; oak      --&gt; maple
     |
     |     --- ---      --- ---
      --&gt; |   |   |--&gt; |   |   |--&gt; nil
           --- ---      --- ---
            |            |
            |            |
             --&gt; pine     --&gt; needles
</pre><p>同じリストを2番目のボックス表記で表すと、以下のようになります:
</p><pre class="screen"> --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o-------&gt;| oak   |   o-------&gt;| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------&gt;| pine  |   o-------&gt;| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------
</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Dotted-Pair-Notation"/>Dotted Pair Notation</h3></div></div></div><a id="idm47184720" class="indexterm"/><a id="idm47183952" class="indexterm"/><p><em class="firstterm">ドットペア表記(dotted pair
notation)</em>はCARとCDRが明示的に表されたコンスセルにたいする、一般的な構文です。この構文では、<code class="literal">(<em class="replaceable"><code>a</code></em>
.
<em class="replaceable"><code>b</code></em>)</code>は、CARがオブジェクト<em class="replaceable"><code>a</code></em>で、CDRがオブジェクト<em class="replaceable"><code>b</code></em>という意味になります。CDRがリスとである必要がないので、ドットペア表記は、より一般的なリスト構文です。しかしキスと構文が機能するでような場合には、より扱いにくくなります。ドットペア表記では、リスト‘<code class="literal">(1
2 3)</code>’は、‘<code class="literal">(1 .  (2 . (3
.
nil)))</code>’と記述されます。<code class="literal">nil</code>で終端されたリストにたいしては、どちらの表記法も使用できますが、リスト表記の方が、通常は明解で便利です。リストをプリントする場合、コンスセルのCDRがリスとでないときだけ、ドットペア表記が使用されます。
</p><p>以下はボックスを使用してドットペア表記を表した例です。この例はペア<code class="literal">(rose . violet)</code>を表します。
</p><pre class="screen">    --- ---
   |   |   |--&gt; violet
    --- ---
     |
     |
      --&gt; rose
</pre><p>最後のCDRが非<code class="literal">nil</code>のコンスセルのチェーンを表すために、ドットペア表記とリスト表記を組み合わせることができます。リストの最後の要素の後にドットを記述して、その後に最後のコンスセルのCDRを記述します。たとえば、<code class="literal">(rose
violet . buttercup)</code>は、<code class="literal">(rose . (violet
. buttercup))</code>と等価です。オブジェクトは以下のようになります:
</p><pre class="screen">    --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; buttercup
    --- ---      --- ---
     |            |
     |            |
      --&gt; rose     --&gt; violet
</pre><p>構文<code class="literal">(rose . violet .
buttercup)</code>は無効です。なぜならこれが意味することは何もないからです。何かあるにしても、<code class="literal">violet</code>のためにCDRがすでに使用されているコンスセルのCDRに<code class="literal">buttercup</code>を置く、ということになります。
</p><p>リスト<code class="literal">(rose violet)</code>は<code class="literal">(rose . (violet))</code>と等価であり、以下のようになります:
</p><pre class="screen">    --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; nil
    --- ---      --- ---
     |            |
     |            |
      --&gt; rose     --&gt; violet
</pre><p>同様に3要素のリスト<code class="literal">(rose violet buttercup)</code>は、<code class="literal">(rose . (violet
. (buttercup)))</code>と等価です。
これは以下のようになります:
</p><pre class="screen">    --- ---      --- ---      --- ---
   |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --&gt; rose     --&gt; violet   --&gt; buttercup
</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Association-List-Type"/>Association List Type</h3></div></div></div><p><em class="firstterm">連想リスト(association
list)</em>または<em class="firstterm">alist</em>は、要素がコンスセルであるように特別に構成されたリストです。各要素においては、CARが<em class="firstterm">キー(key)</em>で、CDRが<em class="firstterm">連想値(associated
value)</em>であると考えます(連想値がCDRのCARに保存される場合もあります)。リストの先頭に連想値を追加したり削除するのが簡単なので、連想リストはスタック(stack)にしばしば使用されます。
</p><p>たとえば、
</p><pre class="screen">(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
</pre><p>これは変数<code class="literal">alist-of-colors</code>に3葉疎のalistをセットします。最初の要素では、<code class="literal">rose</code>がキーで、<code class="literal">red</code>が値になります。
</p><p>alistと、alistに関数についての詳細な説明は、<a class="link" href="ch06s08.html" title="Association Lists">Association
Lists</a>を参照してください。テーブルを照合する、(多くのキーの操作を、より速く行なう)他の手段については、<a class="link" href="ch08.html" title="Chapter 7. Hash Tables">Hash
Tables</a>を参照してください。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Array-Type"/>Array Type</h2></div></div></div><p><em class="firstterm">配列(array)</em>は、他のLispオブジェクトを保持または参照する、任意の数のスロットから構成され、メモリーの連続ブロックに配列されます。配列の任意の要素へのアクセス時間は、大体同じです。対照的に、リストの要素にたいするアクセスは、リスト内でのその要素の位置に比例した時間を要します(リストの最後の要素にアクセスするには、リストの最初の要素にアクセスするより、長い時間を要します)。
</p><p>Emacsは文字列(strings)、ベクター(vectors)、ブールベクター(bool-vectors)、文字テーブル(char-tables)という、4種の配列を定義します。
</p><p>文字列は文字の配列で、ベクターは任意のオブジェクトの配列です。ブールベクターは<code class="literal">t</code>か<code class="literal">nil</code>だけを保持できます。この種の配列は、もっとも大きい整数までの、任意の長さをもつことができます。文字テーブルは、任意の有効な文字コードによりインデックスづけされる疎な配列で、任意のオブジェクトを保持することができます。
</p><p>配列の最初の要素はインデックス0、2番目の要素はインデックス1、...となります。これは0基準<em class="firstterm">zero-origin</em>のインデックスづけと呼ばれます。たとえば、4要素の配列は、インデックス0、1、2、3をもちます。利用できる最大のインデックス値は、配列の長さより1小さくなります。1度配列が作成されると、長さは固定されます。
</p><p>Emacs
Lispのすべての配列は、1次元です(他のほとんどのプログラミング言語は多次元配列をサポートしますが、これらは必須ではありません。ネストされた1次元配列により同じ効果を得ることができます)。各種の配列のは、独自の入力構文をもちます。詳細は以降のセクションを参照してください。
</p><p>配列型はシーケンス型のサブセットであり、文字列型、ベクター型、ブールベクター型、文字テーブル型が含まれます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="String-Type"/>String Type</h2></div></div></div><p><em class="firstterm">文字列(string)</em>とは、文字の配列です。Emacsがテキストエディターであることから予想できるように、文字列は、たとえばLispシンボルの名前、ユーザーへのメッセージ、バッファーから抽出されたテキストの表現など、多くの目的のために使用されます。Lispの文字列は定数です。文字列を評価すると、それと同じ文字列がreturnされます。
</p><p>文字列を操作する関数については、<a class="link" href="ch05.html" title="Chapter 4. Strings and Characters">Strings and Characters</a>を参照してください。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Syntax-for-Strings"/>Syntax for Strings</h3></div></div></div><a id="idm47144272" class="indexterm"/><a id="idm47142992" class="indexterm"/><a id="idm47142224" class="indexterm"/><a id="idm47140944" class="indexterm"/><p>文字列にたいする入力構文は、<code class="literal">"like
this"</code>のように、ダブルクォート、任意個の文字、もう1つのダブルクォートから構成されます。文字列内にダブルクォートを含める場合は、それの前にバックスラッシュを記述します。したがって、<code class="literal">"\""</code>は1つのダブルクォート文字だけを含む文字列です。同様に、バックスラッシュを含める場合は、<code class="literal">"this
\\ is a single embedded backslash"</code>のように、それの前にもう1つのバックスラッシュを記述します。
</p><a id="idm47138256" class="indexterm"/><p>文字列にたいする入力構文では、改行(newline)は特別ではありません。ダブルクォートの間に改行を記述すれば、その改行は文字列内の文字となります。しかしエスケープされた改行
— 前に‘<code class="literal">\</code>’をともなう改行 —は文字列の一部とはなりません。同様に、エスケープされたスペース‘<code class="literal">\ 
</code>’も無視されます。
</p><pre class="screen">"It is useful to include newlines
in documentation strings,
but the newline is \
ignored if escaped."
     ⇒ "It is useful to include newlines
in documentation strings,
but the newline is ignored if escaped."
</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Non_002dASCII-in-Strings"/>Non-<acronym class="acronym">ASCII</acronym> Characters in Strings</h3></div></div></div><p>Emacdの文字列内の非<acronym class="acronym">ASCII</acronym>文字にたいしては、2つのテキスト表現 —
マルチバイト(multibyte)とユニバイト(unibyte)があります(<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text
Representations</a>を参照してください)。大まかに言うと、ユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的に、マルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(<a class="link" href="ch03s03.html#Character-Type" title="Character Type">Character
Type</a>を参照してください)。両方とも、127より上の文字は非<acronym class="acronym">ASCII</acronym>です。
</p><p>文字をリテラルとして記述することにより、文字列に非<acronym class="acronym">ASCII</acronym>文字を含めることができます。マルチバイトのバッファーや文字列、あるいはマルチバイトとしてvisitされたファイル等の、マルチバイトのソースから文字列定数を読み込む場合、Emacsは非<acronym class="acronym">ASCII</acronym>文字をマルチバイト文字として読み取り、その文字列を自動的にマルチバイト文字列にします。ユニバイトのソースから文字列定数を読み込む場合、Emacsは非<acronym class="acronym">ASCII</acronym>文字をユニバイト文字として読み取り、その文字列を湯にバイト文字列にします。
</p><p>マルチバイト文字列内にリテラルとして文字を記述するかわりに、エスケープシーケンスを使用して文字コードとして記述できます。エスケープシーケンスについての詳細は、<a class="link" href="ch03s03.html#General-Escape-Syntax" title="General Escape Syntax">General
Escape Syntax</a>を参照してください。
</p><p>文字列定数内でUnicodeスタイルのエスケープシーケンス‘<code class="literal">\uNNNN</code>’または‘<code class="literal">\U00NNNNNN</code>’を使用する場合、(たとえ<acronym class="acronym">ASCII</acronym>文字の場合でも)Emacsは自動的に文字列をマルチバイトとみなします。
</p><p>文字列定数内で、16進エスケープシーケンス(‘<code class="literal">\x<em class="replaceable"><code>n</code></em></code>’)、および8進エスケープシーケンス(‘<code class="literal">\<em class="replaceable"><code>n</code></em></code>’)を使用することもできます。<span class="bold"><strong>しかし注意してください:
</strong></span>文字列定数が16進または8進のエスケープシーケンスを含み、それらのエスケープシーケンスすべてがユニバイト文字(256より小)を指定していて、その文字列内に他にリテラルの非<acronym class="acronym">ASCII</acronym>文字またはUnicodeスタイルのエスケープシーケンスが存在しない場合、Emacsは自動的に文字列をユニバイト文字列とみなします。つまり文字列内のすべての非<acronym class="acronym">ASCII</acronym>文字は8ビットのrawバイトとみなされます。
</p><p>16進および8進のエスケープシーケンスではエスケープされた文字コードは可変個の数字を含むかもしれないので、それに続く文字で、16進および8進として有効ではない最初の文字は、エスケープシーケンスを終了させます。文字列内の次の文字が16進または8進として解釈できる文字の場合は、‘<code class="literal">\ 
</code>’(バックスラッシュとスペース)を記述して、エスケープシーケンスを終了できます。たとえば‘<code class="literal">\xe0\ </code>’はgrave
accentつきの‘<code class="literal">a</code>’という、1文字を表します。文字列内の‘<code class="literal">\ 
</code>’は、バックスラッシュー改行と同様です。これは文字列内の文字とはなりませんが、先行する16進エスケープを終了します。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Nonprinting-Characters"/>Nonprinting Characters in Strings</h3></div></div></div><p>リテラル文字と同様に、文字列定数内でバックスラッシュによるエスケープシーケンスを使用できます(ただし文字定数を開始するクエスチョンマークは使用しません)。たとえば、非プリント文字のタブと<strong class="userinput"><code>C-a</code></strong>を含む文字列は、<code class="literal">"\t,
\C-a"</code>のように、それらの間にカンマとスペースを記述します。文字にたいする入力構文の説明は、<a class="link" href="ch03s03.html#Character-Type" title="Character Type">Character
Type</a>を参照してください。
</p><p>しかし、バックスラッシュによるエスケープシーケンスとともに記述できるすべての文字が、文字列内で有効というわけではありません。文字列が保持できるコントロール文字は、<acronym class="acronym">ASCII</acronym>コントロール文字だけです。<acronym class="acronym">ASCII</acronym>コントロール文字では、文字列の大文字小文字は区別されません。
</p><p>正確に言うと、文字列はメタ文字を保持できません。しかし文字列がキーシーケンスとして使用される場合、文字列内でメタで修飾された<acronym class="acronym">ASCII</acronym>文字を表現するための方法を提供する、特別な慣習があります。文字列定数内でメタ文字を示すために‘<code class="literal">\M-</code>’構文を使用した場合、これは文字列内の文字の
2**7
のビットをセットします。その文字列が<code class="literal">define-key</code>または<code class="literal">lookup-key</code>で使用される場合、この数字コードは等価なメタ文字に変換されます。<a class="link" href="ch03s03.html#Character-Type" title="Character Type">Character
Type</a>を参照してください。
</p><p>文字列はhyper、super、altで修飾された文字を保持できません。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Text-Props-and-Strings"/>Text Properties in Strings</h3></div></div></div><a id="idm47108176" class="indexterm"/><a id="idm47106896" class="indexterm"/><p>文字列は、その文字自身に加えて、文字のプロパティーも保持することができます。これにより、特別なことをしなくても、文字列とバッファーとの間でテキストをコピーするプログラムが、テキストプロパティーをコピーすることが可能になります。テキストプロパティーが何を意味するかについての説明は、<a class="link" href="ch32s19.html" title="Text Properties">Text
Properties</a>を参照してください。テキストプロパティーをもつ文字列は、特別な入力構文とプリント構文を使用します。
</p><pre class="screen">#("<em class="replaceable"><code>characters</code></em>" <em class="replaceable"><code>property-data</code></em>...)
</pre><p>ここで<em class="replaceable"><code>property-data</code></em>は3個でグループ化された、0個以上の要素から構成されます:
</p><pre class="screen"><em class="replaceable"><code>beg</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>plist</code></em>
</pre><p>要素<em class="replaceable"><code>beg</code></em>および<em class="replaceable"><code>end</code></em>は整数で、文字列内のインデックスの範囲を指定します。<em class="replaceable"><code>plist</code></em>はその範囲にたいするプロパティーリストです。たとえば、
</p><pre class="screen">#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
</pre><p>これはテキスト内容が‘<code class="literal">foo
bar</code>’で、最初の3文字は<code class="literal">face</code>プロパティーに値<code class="literal">bold</code>をもち、最後の3文字は<code class="literal">face</code>プロパティーに値<code class="literal">italic</code>をもつことを表します。(4番目の文字にはテキストプロパティーはないので、プロパティーリストは<code class="literal">nil</code>です。実際には、範囲の中の指定されていない文字はデフォルトではプロパティーをもたないので、範囲のプロパティーリストを<code class="literal">nil</code>と指定する必要ありません)。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Vector-Type"/>Vector Type</h2></div></div></div><p><em class="firstterm">ベクター(vector)</em>は、任意の型の要素からなる1次元の配列です。ベクター内の任意の要素へのアクセスに要す時間は、一定です(リストの場合、要素へのアクセスに要す時間は、リストの先頭からその要素までの距離に比例します)。
</p><p>ベクターのプリント表現は、左角カッコ(left square bracket)、要素、右角カッコ(right square
bracket)から構成されます。これは入力構文でもあります。数字や文字列と同様に、ベクターは評価において定数と判断されます。
</p><pre class="screen">[1 "two" (three)]      ; 3要素のベクター。
     ⇒ [1 "two" (three)]
</pre><p>ベクターに作用する関数については、<a class="link" href="ch07s04.html" title="Vectors">Vectors</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Char_002dTable-Type"/>Char-Table Type</h2></div></div></div><p><em class="firstterm">文字テーブル(char-table)</em>は、任意の型の要素をもつ1次元の配列で、文字コードによりインデックスづけされます。文字テーブルは、文字コードに情報を割り当てることを必要とする多くの処理を簡単にするための、特別な追加の機能をもちます
—
たとえば、文字テーブルは、継承するための親、デフォルト値、特別な目的のために使用する少数の余分なスロットをもつことができます。文字テーブルは、文字セット全体にたいして1つの値を指定することもできます。
</p><a id="idm47069904" class="indexterm"/><p>文字テーブルのプリント表現はベクターと似ていますが、最初に余分な‘<code class="literal">#^</code>’があります<a href="#ftn.idm47067856" class="footnote" id="idm47067856"><sup class="footnote">[1]</sup></a>。
</p><p>文字テーブルを操作する特別な関数については、<a class="link" href="ch07s06.html" title="Char-Tables">Char-Tables</a>を参照してください。文字テーブルの使用には以下が含まれます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>大文字小文字テーブル(<a class="link" href="ch05s09.html" title="The Case Table">Case Tables</a>を参照してください)。
</p></li><li class="listitem"><p>文字カテゴリーテーブル(<a class="link" href="ch35s08.html" title="Categories">Categories</a>を参照してください)。
</p></li><li class="listitem"><p>ディスプレーテーブル(<a class="link" href="ch38s21.html#Display-Tables" title="Display Tables">Display Tables</a>を参照してください)。
</p></li><li class="listitem"><p>構文テーブル(<a class="link" href="ch35.html" title="Chapter 34. Syntax Tables">Syntax Tables</a>を参照してください)。
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Bool_002dVector-Type"/>Bool-Vector Type</h2></div></div></div><p><em class="firstterm">ブールベクター(bool-vector)</em>は、要素が<code class="literal">t</code>か<code class="literal">nil</code>でなければならない、1次元の配列です。
</p><p>ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した‘<code class="literal">#&amp;</code>’で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです
—
文字列定数内のそれぞれの“文字”は8ビットを含み、これはブールベクターの次の8要素を指定します(1は<code class="literal">t</code>、0は<code class="literal">nil</code>です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。
</p><pre class="screen">(make-bool-vector 3 t)
     ⇒ #&amp;3"^G"
(make-bool-vector 3 nil)
     ⇒ #&amp;3"^@"
</pre><p>‘<code class="literal">C-g</code>’の2進コードは111、‘<code class="literal">C-@</code>’はコード0の文字なので、この結果は道理にかなっています。
</p><p>長さが8の倍数でない場合、プリント表現には余分な要素が表示されますが、これらの余分な要素に意味はありません。たとえば以下の例では、最初の3ビットだけが使用されるので、2つのブールベクターは等価です:
</p><pre class="screen">(equal #&amp;3"\377" #&amp;3"\007")
     ⇒ t
</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Hash-Table-Type"/>Hash Table Type</h2></div></div></div><p>ハッシュテーブルは非常に高速な照合テーブルの一種で、キーを対応する値にマップするalistと似ていますが、より高速です。ハッシュテーブルのプリント表現、以下のようにハッシュテーブルのプロパティーと内容を指定します:
</p><pre class="screen">(make-hash-table)
     ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8 data ())
</pre><p>ハッシュテーブルについての詳細な情報は、<a class="link" href="ch08.html" title="Chapter 7. Hash Tables">Hash Tables</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Function-Type"/>Function Type</h2></div></div></div><p>他のプログラミング言語の関数と同様に、Lisp関数は実行可能なコードです。他の言語とは異なり、Lispの関数はLispオブジェクトでもあります。Lispのコンパイルされていない関数はラムダ式
— つまり1番目の要素がシンボル<code class="literal">lambda</code>であるリストです(<a class="link" href="ch13s02.html" title="Lambda Expressions">Lambda Expressions</a>を参照してください)。
</p><p>ほとんどのプログラミング言語では、名前のないの関数はありません。Lispでは、関数に本質的な名前はありません。名前がなくても、ラムダ式を関数として呼び出すことができます。これを強調するために、わたしたちはこれを<em class="firstterm">無名関数(anonymous
function)</em>とも呼びます(<a class="link" href="ch13s07.html" title="Anonymous Functions">Anonymous
Functions</a>を参照してください)。Lispの名前つき関数は、関数セルに有効な関数がセットされた単なるシンボルです(<a class="link" href="ch13s04.html" title="Defining Functions">Defining
Functions</a>を参照してください)。
</p><p>ほとんどの場合、関数はLispプログラム内のLisp式に名前が記述されたところで呼び出されます。しかし、実行時に関数オブジェクトを構築または取得してから、基本関数<code class="literal">funcall</code>および<code class="literal">apply</code>により呼び出すことができます。<a class="link" href="ch13s05.html" title="Calling Functions">Calling
Functions</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Macro-Type"/>Macro Type</h2></div></div></div><p><em class="firstterm">Lispマクロ(Lisp
macro)</em>は。Lisp言語を拡張する、ユーザー定義の構成です。これはオブジェクトとしてではなく関数のように表現されますが、引数の渡し方の意味が異なります。Lispマクロの形式はリストです。これは、最初の要素が<code class="literal">macro</code>で、(<code class="literal">lambda</code>シンボルを含む)CDRがLisp関数オブジェクトであるようなリストです。
</p><p>Lispマクロオブジェクトは通常、ビルトインの<code class="literal">defmacro</code>関数で定義されますが、<code class="literal">macro</code>で始まる任意のリストも、Emacsにとってはマクロです。マクロを記述する方法の説明は、<a class="link" href="ch14.html" title="Chapter 13. Macros">Macros</a>を参照してください。
</p><p><span class="bold"><strong>警告</strong></span>: Lispマクロとキーボードマクロ(<a class="link" href="ch21s16.html" title="Keyboard Macros">Keyboard
Macros</a>を参照してください)は、完全に別物です。修飾なしで“マクロ”という単語を使用したときは、キーボードマクロではなく、Lispマクロのことを指します。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Primitive-Function-Type"/>Primitive Function Type</h2></div></div></div><a id="idm47021392" class="indexterm"/><p><em class="firstterm">基本関数(primitive
function)</em>とは、Cプログラミング言語で記述された、Lispから呼び出せる関数です。基本関数は<em class="firstterm">subrs</em>や<em class="firstterm">ビルと陰関数(built-in
functions)</em>とも呼ばれます(単語“subr”は、“サブルーチン(subroutine)”が由来です)。ほとんどの基本関数、呼び出されたとき、すべての引数を評価します。すべての引数を評価しない基本関数は、<em class="firstterm">スペシャルフォーム(special
form)</em>と呼ばれます(<a class="link" href="ch10s02.html#Special-Forms" title="Special Forms">Special Forms</a>を参照してください)。
</p><p>呼び出す側からすれば、その関数が基本関数かどうかは、問題になりません。しかし、基本関数をLispで記述された関数で再定義した場合は、問題になります。理由は、その基本関数がCコードから直接呼び出されているかもしれないからです。Lispから再定義した関数を呼び出すと、これは新しい定義を使用するでしょうが、Cコードから呼び出すと、ビルトインの定義が使用されるでしょう。したがって、<span class="bold"><strong>基本関数の再定義はしないでください</strong></span>。
</p><p><em class="firstterm">関数(function)</em>という用語により、LispやCで記述された、すべてのEmacs関数を参照します。Lispで記述された関数についての情報は、<a class="link" href="ch03s03.html#Function-Type" title="Function Type">Function
Type</a>を参照してください。
</p><p>基本関数に入力構文はなく、サブルーチン名とともにハッシュ表記でプリントします。
</p><pre class="screen">(symbol-function 'car)          ; そのシンボルの関数セルに
                                ;     アクセスします。
     ⇒ #&lt;subr car&gt;
(subrp (symbol-function 'car))  ; これは基本関数か?
     ⇒ t                ;    イェース。
</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Byte_002dCode-Type"/>Byte-Code Function Type</h2></div></div></div><p><em class="firstterm">バイトコード関数オブジェクト(byte-code function
objects)</em>は、Lispコードをバイトコンパイルすることにより生成されます(<a class="link" href="ch17.html" title="Chapter 16. Byte Compilation">Byte
Compilation</a>を参照してください)。内部的には、バイトコード関数オブジェクトは、ベクターによく似ています。しかしバイトコード関数オブジェクトが関数呼び出しのように見える場合、評価プロセスにより、このデータ型は特別に処理されます。<a class="link" href="ch17s07.html" title="Byte-Code Function Objects">Byte-Code
Objects</a>を参照してください。
</p><p>バイトコード関数オブジェクトのプリント表現と入力構文は、ベクターのものと似ていますが、開き角カッコ‘<code class="literal">[</code>’の前に‘<code class="literal">#</code>’があります。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Autoload-Type"/>Autoload Type</h2></div></div></div><p><em class="firstterm">autoloadオブジェクト(autoload
object)</em>は、最初の要素がシンボル<code class="literal">autoload</code>のリストです。これはシンボルの関数定義として保存され、実際の定義にたいする代替としての役割をもちます。autoloadオブジェクトは、必要な時にロードされるLispコードファイルのなかで、実際の定義を見つけることができることを宣言します。これにはファイル名と、加えて実際の定義についての他のいくつかの情報が含まれます。
</p><p>ファイルがロードされた後、そのシンボルは、autoloadオブジェクトではない、新しい関数定義をもつはずです。新しい定義は、最初からそこにあったかのように呼び出されます。ユーザーの観点からは、関数呼び出しは期待された動作、つまりロードされたファイル内の関数定義を使用します。
</p><p>autoloadオブジェクトは通常、シンボルの関数セルにオブジェクトを保存する、関数<code class="literal">autoload</code>により作成されます。詳細は、<a class="link" href="ch16s05.html" title="Autoload">Autoload</a>を参照してください。
</p></div><div class="footnotes"><br/><hr/><div id="ftn.idm47067856" class="footnote"><p><a href="#idm47067856" class="para"><sup class="para">[1] </sup></a>“サブ文字テーブル(sub-char-tables)”に使用される‘<code class="literal">#^^</code>’を目にすることがあるかもしれません。</p></div></div></div></body></html>