<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Equality Predicates</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Equality-Predicates"/>Equality Predicates</h1></div></div></div><a id="idm46780624" class="indexterm"/><p>ここでは、2つのオブジェクトの同一性をテストする関数を説明します。(たとえば文字列などの)特定の型のオブジェクト同士で、内容の同一性をテストするのは、別の関数を使用します。これらの述語にたいしては、そのデータ型を説明する、適切なチャプターを参照してください。
</p><pre class="synopsis"><a id="idm46779216" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">eq</code> <em class="replaceable"><code>object1</code></em> <em class="replaceable"><code>object2</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>object1</code></em>と<em class="replaceable"><code>object2</code></em>が同じオブジェクトの場合は<code class="literal">t</code>、それ以外は<code class="literal">nil</code>をreturnします。
</p><p><em class="replaceable"><code>object1</code></em>と<em class="replaceable"><code>object2</code></em>が、同じ値をもつ整数の場合、これらは同じオブジェクトと判断されます(<code class="literal">eq</code>は<code class="literal">t</code>をreturnします)。<em class="replaceable"><code>object1</code></em>と<em class="replaceable"><code>object2</code></em>が、同じ名前のシンボルの場合、通常は同じオブジェクトです。しかし例外もあります。<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照してください。(リスト、ベクター文字列などの)他の型にたいしては、同じ内容(または要素)の2つの引数が、両者<code class="literal">eq</code>である必要はありません。これらが同じオブジェクトの場合だけ<code class="literal">eq</code>であり、その場合は、一方の内容を変更すると、もう一方の内容にも同じ変更が反映されます。
</p><pre class="screen">(eq 'foo 'foo)
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(eq 456 456)
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(eq "asdf" "asdf")
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(eq "" "")
     ⇒ t
;; この例外は省スペースのためにEmacs Lispが
;; ただ1つのマルチバイトの空文字列を作成するためです。
</pre><pre class="screen">
</pre><pre class="screen">(eq '(1 (2 (3))) '(1 (2 (3))))
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(setq foo '(1 (2 (3))))
     ⇒ (1 (2 (3)))
(eq foo foo)
     ⇒ t
(eq foo '(1 (2 (3))))
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(eq [(1 2) 3] [(1 2) 3])
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(eq (point-marker) (point-marker))
     ⇒ nil
</pre><p><code class="literal">make-symbol</code>関数は、internされていないシンボルをreturnします。これはLisp式内で、その名前を記述したシンボルとは区別されます。同じ名前の、異なるシンボルは、<code class="literal">eq</code>ではありません。<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照してください。
</p><pre class="screen">(eq (make-symbol "foo") 'foo)
     ⇒ nil
</pre></blockquote></div><pre class="synopsis"><a id="idm46761168" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">equal</code> <em class="replaceable"><code>object1</code></em> <em class="replaceable"><code>object2</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>object1</code></em>と<em class="replaceable"><code>object2</code></em>が同じ構成要素をもつ場合は<code class="literal">t</code>、それ以外は<code class="literal">nil</code>をreturnします。<code class="literal">eq</code>は引数が同じオブジェクトなのかテストするのにたいして、<code class="literal">equal</code>は同一でない引数の内部を調べて、それらの要素または内容が同一化をテストします。したがって2つのオブジェクトが<code class="literal">eq</code>ならば、それらは<code class="literal">equal</code>です。しかし、その逆は常に真ではありません。
</p><pre class="screen">(equal 'foo 'foo)
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(equal 456 456)
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(equal "asdf" "asdf")
     ⇒ t
</pre><pre class="screen">(eq "asdf" "asdf")
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(equal '(1 (2 (3))) '(1 (2 (3))))
     ⇒ t
</pre><pre class="screen">(eq '(1 (2 (3))) '(1 (2 (3))))
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(equal [(1 2) 3] [(1 2) 3])
     ⇒ t
</pre><pre class="screen">(eq [(1 2) 3] [(1 2) 3])
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">(equal (point-marker) (point-marker))
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(eq (point-marker) (point-marker))
     ⇒ nil
</pre><p>文字列の比較は大文字小文字を区別しますが、テキストプロパティーは考慮しません — これは文字列内の文字だけを比較します。<a class="link" href="ch32s19.html" title="Text Properties">Text
Properties</a>を参照してください。テキストプロパティーも比較する場合は、<code class="literal">equal-including-properties</code>を使用します。記述的な理由により、ユニバイト文字列とマルチバイト文字列は、それらが同じ文字シーケンスを含み、それらすべてのコードが0から127(<acronym class="acronym">ASCII</acronym>)、または160から255(<code class="literal">8ビットグラフィック</code>)の場合に限り、<code class="literal">equal</code>です(<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text
Representations</a>を参照してください)。
</p><pre class="screen">(equal "asdf" "ASDF")
     ⇒ nil
</pre><p>しかし2つの別のバッファーは、それらのテキスト内容が同じでも、<code class="literal">equal</code>と判断されることはありません。
</p></blockquote></div><p><code class="literal">equal</code>のテストは再帰により実装されています。たとえば2つのコンスセル<em class="replaceable"><code>x</code></em>と<em class="replaceable"><code>y</code></em>を与えると、<code class="literal">(equal
<em class="replaceable"><code>x</code></em> <em class="replaceable"><code>y</code></em>)</code>は、以下の式の両方が<code class="literal">t</code>をreturnする場合に限り、<code class="literal">t</code>をreturnします:
</p><pre class="screen">(equal (car <em class="replaceable"><code>x</code></em>) (car <em class="replaceable"><code>y</code></em>))
(equal (cdr <em class="replaceable"><code>x</code></em>) (cdr <em class="replaceable"><code>y</code></em>))
</pre><p>これは再帰処理なので、循環するリストがあると無限再帰となります(エラーとなります)。
</p><pre class="synopsis"><a id="idm46719952" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">equal-including-properties</code> <em class="replaceable"><code>object1</code></em> <em class="replaceable"><code>object2</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はすべてのケースにおいて<code class="literal">equal</code>と同様に振る舞いますが、2つの文字列が<code class="literal">equal</code>になるためには、それらが同じテキストプロパティーをもつ必要があります。
</p><pre class="screen">(equal "asdf" (propertize "asdf" 'asdf t))
     ⇒ t
</pre><pre class="screen">(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     ⇒ nil
</pre></blockquote></div></div></body></html>