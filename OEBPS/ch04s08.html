<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bitwise Operations on Integers</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Bitwise-Operations"/>Bitwise Operations on Integers</h1></div></div></div><a id="idm46470480" class="indexterm"/><a id="idm46469712" class="indexterm"/><p>コンピューターの中では、整数は<em class="firstterm">ビット(bit:
0か1の数字)</em>のシーケンスである、2進数で表されます。ビット演算は、そのようなシーケンスの中の個々のビットに作用します。たとえば、<em class="firstterm">シフト(shifting)</em>はシーケンス全体を1つ以上左または右に移動して、“移動された”のと同じパターンを再生します。
</p><p>Emacs Lispのビット演算は、整数だけに適用されます。
</p><pre class="synopsis"><a id="idm46467152" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">lsh</code> <em class="replaceable"><code>integer1</code></em> <em class="replaceable"><code>count</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm46464208" class="indexterm"/><p><code class="literal">lsh</code>は<em class="firstterm">logical
shift</em>の略で、<em class="replaceable"><code>integer1</code></em>のビットを左に<em class="replaceable"><code>count</code></em>個シフトします。<em class="replaceable"><code>count</code></em>が負の場合は右にシフトし、シフトにより空きになったビットには0がセットされます。<em class="replaceable"><code>count</code></em>
isが負の場合、<code class="literal">lsh</code>は左端(最上位)に0をシフトするので、<em class="replaceable"><code>integer1</code></em>が負の場合でも、正の結果が生成されます。これと対照的なのが、以下で説明する<code class="literal">ash</code>です。
</p><p>以下に、<code class="literal">lsh</code>でビットパターンの位置を1つ左にシフトする例を2つ紹介します。ここでは下位8ビットの2進パターンだけを表示しており、残りのビットはすべて0です。
</p><pre class="screen">(lsh 5 1)
     ⇒ 10
;; 10進の5は、10進の10になります。
00000101 ⇒ 00001010

(lsh 7 1)
     ⇒ 14
;; 10進の7は、10進の14になります。
00000111 ⇒ 00001110
</pre><p>この例が説明するように、ビットパターンを左に1シフトすると、生成される数は、元の数の2倍になります。
</p><p>ビットパターンを左に2シフトすると、以下(8ビット2進数)の結果が生成されます:
</p><pre class="screen">(lsh 3 2)
     ⇒ 12
;; 10進の3は、10進の12になります。
00000011 ⇒ 00001100
</pre><p>一方、右に1シフトすると、以下のようになります:
</p><pre class="screen">(lsh 6 -1)
     ⇒ 3
;; 10進の6は10進の3になります。
00000110 ⇒ 00000011
</pre><pre class="screen">
</pre><pre class="screen">(lsh 5 -1)
     ⇒ 2
;; 10進の5は、10進の2になります。
00000101 ⇒ 00000010
</pre><p>例が明かにするように、右に1シフトすることにより、正の整数の値が2で除され、下方に丸められます。
</p><p>関数<code class="literal">lsh</code>は、他のEmacs
Lisp算術関数と同様、オーバーフローをチェックしないので、左にシフトすることにより上位ビットが捨てられ、その数の符号が変化するかもしれません。たとえば30ビットの実装では、536,870,911を左にシフトすると、−2が生成されます。
</p><pre class="screen">(lsh 536870911 1)          ; 左シフト
     ⇒ -2
</pre><p>2進では、この引数は以下のようになります:
</p><pre class="screen">;; 10進の536,870,911
0111...111111 (全部で30ビット)
</pre><p>これを左にシフトすると、以下のようになります:
</p><pre class="screen">;; 10進の−2
1111...111110 (全部で30ビット)
</pre></blockquote></div><pre class="synopsis"><a id="idm46442576" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">ash</code> <em class="replaceable"><code>integer1</code></em> <em class="replaceable"><code>count</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm46439632" class="indexterm"/><p><code class="literal">ash</code> (<em class="firstterm">算術シフト(arithmetic
shift)</em>)は、<em class="replaceable"><code>integer1</code></em>の中のビット位置を左に<em class="replaceable"><code>count</code></em>シフトします。<em class="replaceable"><code>count</code></em>が負の場合は右にシフトします。
</p><p><code class="literal">ash</code>は<code class="literal">lsh</code>と同じ結果を与えますが、例外は<em class="replaceable"><code>integer1</code></em>と<em class="replaceable"><code>count</code></em>がとみに負の場合です。この場合、<code class="literal">lsh</code>は左にできる空きビットに0を置きますが、<code class="literal">ash</code>は1を置きます。
</p><p>したがって<code class="literal">ash</code>でビットパターンの位置を右に1シフトすると、以下のようになります:
</p><pre class="screen">(ash -6 -1) ⇒ -3
;; 10進の−6は、10進の−3になります
1111...111010 (30 bits total)
     ⇒
1111...111101 (30 bits total)
</pre><p>対照的に、<code class="literal">lsh</code>でビットパターンの位置を1右にシフトすると、以下のようになります:
</p><pre class="screen">(lsh -6 -1) ⇒ 536870909
;; 10進の−6は、10進の536,870,909になります。
1111...111010 (30 bits total)
     ⇒
0111...111101 (30 bits total)
</pre><p>他にも例を示します:
</p><pre class="screen">                   ;         30ビットの2進数

(lsh 5 2)          ;   5  =  0000...000101
     ⇒ 20         ;      =  0000...010100
</pre><pre class="screen">(ash 5 2)
     ⇒ 20
(lsh -5 2)         ;  -5  =  1111...111011
     ⇒ -20        ;      =  1111...101100
(ash -5 2)
     ⇒ -20
</pre><pre class="screen">(lsh 5 -2)         ;   5  =  0000...000101
     ⇒ 1          ;      =  0000...000001
</pre><pre class="screen">(ash 5 -2)
     ⇒ 1
</pre><pre class="screen">(lsh -5 -2)        ;  -5  =  1111...111011
     ⇒ 268435454
                   ;      =  0011...111110
</pre><pre class="screen">(ash -5 -2)        ;  -5  =  1111...111011
     ⇒ -2         ;      =  1111...111110
</pre></blockquote></div><pre class="synopsis"><a id="idm46427088" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">logand</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>ints-or-markers</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、引数の“論理積(logical
and)”をreturnします。すべての引数の<em class="replaceable"><code>n</code></em>番目のビットがセットされている場合に限り、結果の<em class="replaceable"><code>n</code></em>番目のビットがセットされます(“セット”とは、そのビットの値が0ではなく1であることを意味します)。
</p><p>たとえば、13と12の“論理積”は —
4ビット2進数を使用すると1101と1100の論理積は1100を生成します。この2進数では両方とも、左の2ビットがセット(つまり1)されているので、returnされる値の左2ビットがセットされます。しかし右の2ビットにたいしては、少なくとも1つの引数でそのビットが0なので、returnされる値の右2ビットは0になります。
</p><p>したがって、
</p><pre class="screen">(logand 13 12)
     ⇒ 12
</pre><p><code class="literal">logand</code>に何の引数も綿さない場合は、値−1がreturnされます。−1を2進数で表すとすべてのビットが1なので、−1は<code class="literal">logand</code>にたいする単位元(identity
element)です。
</p><pre class="screen">                   ;        30ビット2進数

(logand 14 13)     ; 14  =  0000...001110
                   ; 13  =  0000...001101
     ⇒ 12         ; 12  =  0000...001100
</pre><pre class="screen">
</pre><pre class="screen">(logand 14 13 4)   ; 14  =  0000...001110
                   ; 13  =  0000...001101
                   ;  4  =  0000...000100
     ⇒ 4          ;  4  =  0000...000100
</pre><pre class="screen">
</pre><pre class="screen">(logand)
     ⇒ -1         ; -1  =  1111...111111
</pre></blockquote></div><pre class="synopsis"><a id="idm46418128" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">logior</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>ints-or-markers</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、引数の“論理和(inclusive
or)”をreturnします。少なくとも1つの引数で<em class="replaceable"><code>n</code></em>番目のビットがセットされていれば、結果の<em class="replaceable"><code>n</code></em>番目のビットがセットされます。引数を与えない場合の結果は、この処理にたいする単位元である0です。<code class="literal">logior</code>に渡す引数が1つだけの場合、その引数がreturnされます。
</p><pre class="screen">                   ;        30ビット2進数

(logior 12 5)      ; 12  =  0000...001100
                   ;  5  =  0000...000101
     ⇒ 13         ; 13  =  0000...001101
</pre><pre class="screen">
</pre><pre class="screen">(logior 12 5 7)    ; 12  =  0000...001100
                   ;  5  =  0000...000101
                   ;  7  =  0000...000111
     ⇒ 15         ; 15  =  0000...001111
</pre></blockquote></div><pre class="synopsis"><a id="idm46411984" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">logxor</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>ints-or-markers</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、引数の“排他的論理和(exclusive
or)”をreturnします。<em class="replaceable"><code>n</code></em>番目のビットがセットされている引数の数が奇数個の場合だけ、結果の<em class="replaceable"><code>n</code></em>番目のビットがセットされます。引数を与えない場合の結果は、この処理の単位元である0となります。<code class="literal">logxor</code>に渡す引数が1つだけの場合、その引数がreturnされます。
</p><pre class="screen">                   ;        30ビット2進数

(logxor 12 5)      ; 12  =  0000...001100
                   ;  5  =  0000...000101
     ⇒ 9          ;  9  =  0000...001001
</pre><pre class="screen">
</pre><pre class="screen">(logxor 12 5 7)    ; 12  =  0000...001100
                   ;  5  =  0000...000101
                   ;  7  =  0000...000111
     ⇒ 14         ; 14  =  0000...001110
</pre></blockquote></div><pre class="synopsis"><a id="idm46405840" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">lognot</code> <em class="replaceable"><code>integer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は引数の論理的な補数(logical
complement)をreturnします。<em class="replaceable"><code>integer</code></em>の<em class="replaceable"><code>n</code></em>番目のビットが0の場合に限り、結果の<em class="replaceable"><code>n</code></em>番目のビットが1になります。逆も成り立ちます。
</p><pre class="screen">(lognot 5)
     ⇒ -6
;;  5  =  0000...000101 (全部で30ビット)
;; becomes
;; -6  =  1111...111010 (全部で30ビット)
</pre></blockquote></div></div></body></html>