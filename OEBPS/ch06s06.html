<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Modifying Existing List Structure</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Modifying-Lists"/>Modifying Existing List Structure</h1></div></div></div><a id="idm49484240" class="indexterm"/><p>基本関数<code class="literal">setcar</code>および<code class="literal">setcdr</code>により、コンスセルのCARおよびCDRの内容を変更できます。わたしたちは、これらが既存のリスト構造を変更することから、これらを“破壊的”処理と呼びます。
</p><a id="idm49482064" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><a id="idm46645840" class="indexterm"/><a id="idm46645072" class="indexterm"/><p><span class="bold"><strong>Common Lispに関する注意: </strong></span>Common
Lispはリスト構造の変更に<code class="literal">rplaca</code>および<code class="literal">rplacd</code>を使用します。これらは<code class="literal">setcar</code>や<code class="literal">setcdr</code>と同じ方法でリスト構造を変更しますが、<code class="literal">setcar</code>と<code class="literal">setcdr</code>は新しいCARまたはCDRをreturnするのにたいし、Common
Lispの関数はコンスセルをreturnします。
</p></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Setcar"/>Altering List Elements with <code class="literal">setcar</code></h2></div></div></div><a id="idm49477584" class="indexterm"/><a id="idm49476816" class="indexterm"/><p>コンスセルのCARの変更は、<code class="literal">setcar</code>により行なわれます。リストにたいして使用された場合、<code class="literal">setcar</code>はリストの1つの要素を、他の要素に置き換えます。
</p><pre class="synopsis"><a id="idm49474384" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">setcar</code> <em class="replaceable"><code>cons</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、以前のCARを置き換えて、<em class="replaceable"><code>cons</code></em>の新しいCARに<em class="replaceable"><code>object</code></em>を格納します。他の言い方をすると、この関数は<em class="replaceable"><code>cons</code></em>のCARスロットを、<em class="replaceable"><code>object</code></em>を参照するように変更します。この関数は値<em class="replaceable"><code>object</code></em>をreturnします。たとえば:
</p><pre class="screen">(setq x '(1 2))
     ⇒ (1 2)
</pre><pre class="screen">(setcar x 4)
     ⇒ 4
</pre><pre class="screen">x
     ⇒ (4 2)
</pre></blockquote></div><p>コンスセルが、複数のリストが共有された構造の一部の場合、コンスに新しいCARを格納することにより、これら共有されたリストの各1つの要素を変更します。以下は例です:
</p><pre class="screen">;; 部分的に共有された2つのリストを作成。
(setq x1 '(a b c))
     ⇒ (a b c)
(setq x2 (cons 'z (cdr x1)))
     ⇒ (z b c)
</pre><pre class="screen">
</pre><pre class="screen">;; 共有されたリンクのCARを置き換え。
(setcar (cdr x1) 'foo)
     ⇒ foo
x1                           ; 両方のリストが変更された。
     ⇒ (a foo c)
x2
     ⇒ (z foo c)
</pre><pre class="screen">
</pre><pre class="screen">;; 共有されていないリンクのCARを置き換え。
(setcar x1 'baz)
     ⇒ baz
x1                           ; 1つのリストだけが変更された。
     ⇒ (baz foo c)
x2
     ⇒ (z foo c)
</pre><p>なぜ<code class="literal">b</code>を置き換えると両方が変更されるのかを説明するために、変数<code class="literal">x1</code>と<code class="literal">x2</code>の2つのリストによる共有構造を視覚化してみましょう:
</p><pre class="screen">        --- ---        --- ---      --- ---
x1---&gt; |   |   |----&gt; |   |   |--&gt; |   |   |--&gt; nil
        --- ---        --- ---      --- ---
         |        --&gt;   |            |
         |       |      |            |
          --&gt; a  |       --&gt; b        --&gt; c
                 |
       --- ---   |
x2--&gt; |   |   |--
       --- ---
        |
        |
         --&gt; z
</pre><p>同じ関係を別のボックス図で示すと、以下のようになります:
</p><pre class="screen">x1:
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   a   |   o-------&gt;|   b   |   o-------&gt;|   c   |  nil |
|       |      |  --&gt;|       |      |     |       |      |
 --------------  |    --------------       --------------
                 |
x2:              |
 --------------  |
| car   | cdr  | |
|   z   |   o----
|       |      |
 --------------
</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Setcdr"/>Altering the CDR of a List</h2></div></div></div><a id="idm49461072" class="indexterm"/><p>CDRを変更するもっとも低レベルの基本関数は、<code class="literal">setcdr</code>です:
</p><pre class="synopsis"><a id="idm49454928" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">setcdr</code> <em class="replaceable"><code>cons</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は前のCDRを置き換えて、<em class="replaceable"><code>cons</code></em>の新しいCDRに<em class="replaceable"><code>object</code></em>を格納します。他の言い方をすると、この関数は<em class="replaceable"><code>cons</code></em>のCDRを、<em class="replaceable"><code>object</code></em>を参照するように変更します。この関数は値<em class="replaceable"><code>object</code></em>をreturnします。
</p></blockquote></div><p>以下はリストのCDRを、他のリストに置き換える例です。1番目の要素以外のすべての要素は、別のシーケンスまたは要素のために取り除かれます。1番目の要素はリストのCARなので変更されず、CDRを通じて到達することもできないからです。
</p><pre class="screen">(setq x '(1 2 3))
     ⇒ (1 2 3)
</pre><pre class="screen">(setcdr x '(4))
     ⇒ (4)
</pre><pre class="screen">x
     ⇒ (1 4)
</pre><p>リスト内のコンスセルのCDRを変更することにより、リストの途中から要素を削除できます。たとえば以下では、1番目のコンスセルのCDRを変更することにより、2番目の要素<code class="literal">b</code>を、リスト<code class="literal">(a
b c)</code>から削除します。
</p><pre class="screen">(setq x1 '(a b c))
     ⇒ (a b c)
(setcdr x1 (cdr (cdr x1)))
     ⇒ (c)
x1
     ⇒ (a c)
</pre><p>以下に結果をボックス表記で示します:
</p><pre class="screen">                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   --&gt;| car   | cdr  |
|   a   |   o-----   |   b   |   o--------&gt;|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------
</pre><p>以前は要素<code class="literal">b</code>を保持していた2番目のコンスセルは、依然として存在して、そのCARも<code class="literal">b</code>のままですが、すでにこのリストの一部を形成していません。
</p><p>CDRを変更して、新しい要素を挿入するのも、同じくらい簡単です:
</p><pre class="screen">(setq x1 '(a b c))
     ⇒ (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     ⇒ (d b c)
x1
     ⇒ (a d b c)
</pre><p>以下に結果をボックス表記で示します:
</p><pre class="screen"> --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   --&gt;|   b  |   o-------&gt;|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     --&gt;|   d   |   o------
        |       |       |
         ---------------
</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Rearrangement"/>Functions that Rearrange Lists</h2></div></div></div><a id="idm49424592" class="indexterm"/><a id="idm49423824" class="indexterm"/><a id="idm49423056" class="indexterm"/><p>以下では、リストの構成要素であるコンスセルのCDRを変更することにより、リストを“破壊的”に再配置する関数をいくつか示します。これらの関数が“破壊的”だという理由は、これらの関数が引数として渡された元のリストを処理して、return値となる新しいリストを形成するために、リストのコンスセルを再リンクするからです。
</p><p>コンスセルを変更する他の関数については、<a class="link" href="ch06s07.html" title="Using Lists as Sets">Sets And Lists</a>の<code class="literal">delq</code>を参照してください。
</p><pre class="synopsis"><a id="idm49420240" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">nconc</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>lists</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm49417296" class="indexterm"/><a id="idm49416528" class="indexterm"/><p>この関数は、<em class="replaceable"><code>lists</code></em>の要素すべてを含むリストをreturnします。<code class="literal">append</code> (<a class="link" href="ch06s04.html" title="Building Cons Cells and Lists">Building
Lists</a>を参照してください)とは異なり、<em class="replaceable"><code>lists</code></em>はコピー<span class="emphasis"><em>されません</em></span>。かわりに<em class="replaceable"><code>lists</code></em>の各リストの最後のCDRが、次のリストを参照するように変更されます。<em class="replaceable"><code>lists</code></em>の最後のリストは、変更されません。たとえば:
</p><pre class="screen">(setq x '(1 2 3))
     ⇒ (1 2 3)
</pre><pre class="screen">(nconc x '(4 5))
     ⇒ (1 2 3 4 5)
</pre><pre class="screen">x
     ⇒ (1 2 3 4 5)
</pre><p><code class="literal">nconc</code>の最後の引数は変更されないので、上記の例のように、<code class="literal">'(4
5)</code>のような定数リストを使用するのが理に適っています。また、同じ理由により、最後の引数がリスとである必要はありません。
</p><pre class="screen">(setq x '(1 2 3))
     ⇒ (1 2 3)
</pre><pre class="screen">(nconc x 'z)
     ⇒ (1 2 3 . z)
</pre><pre class="screen">x
     ⇒ (1 2 3 . z)
</pre><p>しかし、(最後を除くすべての)他の引数はリストでなければなりません。
</p><p>一般的な落とし穴としては、<code class="literal">nconc</code>にたいしてクォートされたリスト定数を、最後以外の引数として使用したときです。これを行なう場合、実行するごとにプログラムはリスト定数を変更するでしょう!
何が起こるのかを以下に示します:
</p><pre class="screen">(defun add-foo (x)            ; この関数では<code class="literal">foo</code>
  (nconc '(foo) x))           ;   を引数の前に追加させたい。
</pre><pre class="screen">
</pre><pre class="screen">(symbol-function 'add-foo)
     ⇒ (lambda (x) (nconc (quote (foo)) x))
</pre><pre class="screen">
</pre><pre class="screen">(setq xx (add-foo '(1 2)))    ; 動いているように見える。
     ⇒ (foo 1 2)
</pre><pre class="screen">(setq xy (add-foo '(3 4)))    ; 何が起きているのか?
     ⇒ (foo 1 2 3 4)
</pre><pre class="screen">(eq xx xy)
     ⇒ t
</pre><pre class="screen">
</pre><pre class="screen">(symbol-function 'add-foo)
     ⇒ (lambda (x) (nconc (quote (foo 1 2 3 4) x)))
</pre></blockquote></div><pre class="synopsis"><a id="idm49382480" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">nreverse</code> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm49379920" class="indexterm"/><p>この関数は、<em class="replaceable"><code>list</code></em>の要素の順番を逆転します。<code class="literal">reverse</code>とは異なり、<code class="literal">nreverse</code>はリストを形成するCDR内のコンスセルを逆転することにより、引数を変更します。<em class="replaceable"><code>list</code></em>の最後に使用されているコンスセルは、最初のコンスセルになります。
</p><p>たとえば:
</p><pre class="screen">(setq x '(a b c))
     ⇒ (a b c)
</pre><pre class="screen">x
     ⇒ (a b c)
(nreverse x)
     ⇒ (c b a)
</pre><pre class="screen">;; 最初のコンスセルが最後になった。
x
     ⇒ (a)
</pre><p>わたしたちは通常、混乱を避けるために、<code class="literal">nreverse</code>の結果を、元のリストを保持していたのと同じ変数に格納します:
</p><pre class="screen">(setq x (nreverse x))
</pre><p>以下は、<code class="literal">(a b c)</code>を視覚的に表した、<code class="literal">nreverse</code>の例です:
</p><pre class="screen">元のリストの先頭:                         逆転されたリスト:
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |&lt;--   |   b  |   o  |&lt;--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
</pre></blockquote></div><pre class="synopsis"><a id="idm49367504" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">sort</code> <em class="replaceable"><code>list</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm49364560" class="indexterm"/><a id="idm49363792" class="indexterm"/><p>この関数は、<em class="replaceable"><code>list</code></em>を安定的(しかし破壊的)にソートして、ソートされたリストをreturnします。この関数は<em class="replaceable"><code>predicate</code></em>を使用して要素を比較します。安定ソート(stable
sort)では、同じソートキーをもつ要素が、ソートの前後で相対的に同じ順序が維持されます。安定性は、異なる条件によりソートするために要素を並び替えるために、連続したソートが使用されるときに重要です。
</p><p>引数<em class="replaceable"><code>predicate</code></em>は、2つの引数をとる関数でなければなりません。この関数は<em class="replaceable"><code>list</code></em>の2つの要素を引数として呼び出されます。昇順のソートを得るための<em class="replaceable"><code>predicate</code></em>は、1番目の引数が、2番目の引数より“小さい”ときは非<code class="literal">nil</code>、それ以外は<code class="literal">nil</code>をreturnするようにします。
</p><p>比較関数<em class="replaceable"><code>predicate</code></em>は、少なくとも単独の<code class="literal">sort</code>呼び出しにおいて、任意の与えられた引数にたいして信頼できる結果を与えなければありません。比較関数は<em class="firstterm">非対称的(antisymmetric)</em>
— つまり<em class="replaceable"><code>a</code></em>が<em class="replaceable"><code>b</code></em>より小さいとき、<em class="replaceable"><code>b</code></em>は<em class="replaceable"><code>a</code></em>より小さくない —
でなければなりません。比較関数は<em class="firstterm">推移的(transitive)</em> —
つまり<em class="replaceable"><code>a</code></em>が<em class="replaceable"><code>b</code></em>より小さく、<em class="replaceable"><code>b</code></em>が<em class="replaceable"><code>c</code></em>より小さい場合、<em class="replaceable"><code>c</code></em>は<em class="replaceable"><code>a</code></em>より小さい —
でなければなりません。これらの要求を満たさない比較関数を使用した場合、<code class="literal">sort</code>の結果は予測できません。
</p><p><code class="literal">sort</code>の破壊的な側面は、CDRを変更することにより、<em class="replaceable"><code>list</code></em>を形成するコンスセルを再配置することです。非破壊的なソート関数の場合は、ソートされた要素を格納するために、あたらしいコンスセルを作成します。元のリストを破壊せずにソートされたコピーを作成したい場合は、<code class="literal">copy-sequence</code>で最初にコピーしてから、それをソートします。
</p><p>ソートは<em class="replaceable"><code>list</code></em>内のコンスセルのCARは変更しません。<em class="replaceable"><code>list</code></em>内でCARに要素<code class="literal">a</code>を保持していたコンスセル、ソート後にも<code class="literal">a</code>を保持しますが、CDRは変更されるので、ソート後の位置は異なります。たとえば:
</p><pre class="screen">(setq nums '(1 3 2 6 5 4 0))
     ⇒ (1 3 2 6 5 4 0)
</pre><pre class="screen">(sort nums '&lt;)
     ⇒ (0 1 2 3 4 5 6)
</pre><pre class="screen">nums
     ⇒ (1 2 3 4 5 6)
</pre><p><span class="bold"><strong>警告</strong></span>:
<code class="literal">nums</code>のリストには0が含まれていないことに注意してください。これは前と同じコンスセルですが、リストの1番目ではなくなります。引数を保持するように形成された変数が、ソートされたリストでも保持されると仮定しないでください!
かわりに<code class="literal">sort</code>の結果を保存して、それを使用してください。元のリストを保持していた変数に、結果を書き戻すことはよく行なわれます。
</p><pre class="screen">(setq nums (sort nums '&lt;))
</pre><p>ソート処理を行なう他の関数については、<a class="link" href="ch32s15.html" title="Sorting Text">Sorting</a>を参照してください。<code class="literal">sort</code>の有用な例は、<a class="link" href="ch24s02.html" title="Access to Documentation Strings">Accessing
Documentation</a>の<code class="literal">documentation</code>を参照してください。
</p></blockquote></div></div></div></body></html>