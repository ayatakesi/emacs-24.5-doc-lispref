<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Using Lists as Sets</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Sets-And-Lists"/>Using Lists as Sets</h1></div></div></div><a id="idm49325392" class="indexterm"/><a id="idm49324624" class="indexterm"/><p>リストは順序なしの数学的集合 — リスト内に要素があれば集合の要素の値とされ、リスト内の順序は無視される —
を表すことができます。2つの集合を結合(union)するには、(重複する要素を気にしない場合は)<code class="literal">append</code>を使用します。<code class="literal">equal</code>である重複を取り除くには、<code class="literal">delete-dups</code>を使用します。集合にたいする他の有用な関数には、<code class="literal">memq</code>や<code class="literal">delq</code>、およびこれらの<code class="literal">equal</code>バージョンである<code class="literal">member</code>と<code class="literal">delete</code>が含まれます。
</p><a id="idm49319376" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意:</strong></span> 集合を処理するために、Common
Lispには(要素の重複がない)関数<code class="literal">union</code>があります。これらの関数は標準のGNU Emacs
Lispにはありませんが、<code class="filename">cl-lib</code>はこれらを提供します。section “Lists as Sets” in <em class="citetitle">Common Lisp
Extensions</em>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm49315152" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">memq</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm49312208" class="indexterm"/><p>この関数は、<em class="replaceable"><code>object</code></em>が<em class="replaceable"><code>list</code></em>のメンバーかどうかをテストします。メンバーの場合、<code class="literal">memq</code>は<em class="replaceable"><code>object</code></em>で最初に見つかった要素から開始されるリストをreturnします。メンバーでない場合は、<code class="literal">nil</code>をreturnします。<code class="literal">memq</code>の文字‘<code class="literal">q</code>’は、この関数が<em class="replaceable"><code>object</code></em>とリスト内の要素の比較に、<code class="literal">eq</code>を使用することを示します。たとえば:
</p><pre class="screen">(memq 'b '(a b c b a))
     ⇒ (b c b a)
</pre><pre class="screen">(memq '(2) '((1) (2)))    ; <code class="literal">(2)</code>と<code class="literal">(2)</code>は<code class="literal">eq</code>ではない。
     ⇒ nil
</pre></blockquote></div><pre class="synopsis"><a id="idm49291856" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">delq</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm49288912" class="indexterm"/><p>この関数<em class="replaceable"><code>list</code></em>からは<em class="replaceable"><code>object</code></em>と<code class="literal">eq</code>なすべての要素を破壊的に取り除いて、結果のリストをreturnします。<code class="literal">delq</code>の文字‘<code class="literal">q</code>’は、この関数が<em class="replaceable"><code>object</code></em>とリスト内の要素の比較に、<code class="literal">eq</code>を使用することを示します(<code class="literal">memq</code>や<code class="literal">remq</code>と同様)。
</p><p><code class="literal">delq</code>を呼び出すときは通常、元のリストを保持していた変数にreturn値を割り当てて使用する必要があります(理由は以下参照)。
</p></blockquote></div><p><code class="literal">delq</code>関数がリストの銭湯にある要素を削除する場合は、単にリストを読み進めて、この要素の後から開始される部分リストをreturnします。つまり:
</p><pre class="screen">(delq 'a '(a b c)) ≡ (cdr '(a b c))
</pre><p>リストの途中にある要素を削除するときは、必要なCDR(<a class="link" href="ch06s06.html#Setcdr" title="Altering the CDR of a List">Setcdr</a>を参照してください)を変更することにより削除します。
</p><pre class="screen">(setq sample-list '(a b c (4)))
     ⇒ (a b c (4))
</pre><pre class="screen">(delq 'a sample-list)
     ⇒ (b c (4))
</pre><pre class="screen">sample-list
     ⇒ (a b c (4))
</pre><pre class="screen">(delq 'c sample-list)
     ⇒ (a b (4))
</pre><pre class="screen">sample-list
     ⇒ (a b (4))
</pre><p><code class="literal">(delq 'a sample-list)</code>は何も取り除きませんが(これは単に短いリストをreturnします)、<code class="literal">(delq 'c
sample-list)</code>は3番目の要素を取り除いて、<code class="literal">sample-list</code>を変更することに注意してください。引数<em class="replaceable"><code>list</code></em>を保持するように形成された変数が、実行後にもっと少ない要素になる、または元のリストを保持すると仮定しないでください!
かわりに<code class="literal">delq</code>の結果を保存して、それを使用してください。元のリストを保持していた変数に、結果を書き戻すことはよく行なわれます。
</p><pre class="screen">(setq flowers (delq 'rose flowers))
</pre><p>以下の例では、<code class="literal">delq</code>が比較しようとしている<code class="literal">(4)</code>と、<code class="literal">sample-list</code>内の<code class="literal">(4)</code>は、<code class="literal">eq</code>ではありません:
</p><pre class="screen">(delq '(4) sample-list)
     ⇒ (a c (4))
</pre><p>与えられた値と<code class="literal">equal</code>な要素を削除したい場合は、<code class="literal">delete</code>(以下参照)を使用してください。
</p><pre class="synopsis"><a id="idm49266128" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">remq</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>object</code></em>と<code class="literal">eq</code>なすべての要素が除かれた、<em class="replaceable"><code>list</code></em>のコピーをreturnします。<code class="literal">remq</code>の文字‘<code class="literal">q</code>’は、この関数が<em class="replaceable"><code>object</code></em>とリスト内の要素の比較に、<code class="literal">eq</code>を使用することを示します。
</p><pre class="screen">(setq sample-list '(a b c a b c))
     ⇒ (a b c a b c)
</pre><pre class="screen">(remq 'a sample-list)
     ⇒ (b c b c)
</pre><pre class="screen">sample-list
     ⇒ (a b c a b c)
</pre></blockquote></div><pre class="synopsis"><a id="idm49258064" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">memql</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>関数<code class="literal">memql</code>は、<code class="literal">eql</code>(浮動少数の要素は値で比較される)を使用してメンバーと<code class="literal">eql</code>を比較することにより、<em class="replaceable"><code>object</code></em>が<em class="replaceable"><code>list</code></em>のメンバーかどうかをテストします。<em class="replaceable"><code>object</code></em>がメンバーの場合、<code class="literal">memql</code>は<em class="replaceable"><code>list</code></em>内で最初に見つかった要素から開始されるリストをreturnします。それ以外は<code class="literal">nil</code>をreturnします。
</p><p>これを<code class="literal">memq</code>と比較してみましょう:
</p><pre class="screen">(memql 1.2 '(1.1 1.2 1.3))  ; <code class="literal">1.2</code>と<code class="literal">1.2</code>は<code class="literal">eql</code>。
     ⇒ (1.2 1.3)
</pre><pre class="screen">(memq 1.2 '(1.1 1.2 1.3))  ; <code class="literal">1.2</code>と<code class="literal">1.2</code>は<code class="literal">eq</code>ではない。
     ⇒ nil
</pre></blockquote></div><p>以下の3つの関数は<code class="literal">memq</code>、<code class="literal">delq</code>、<code class="literal">remq</code>と似ていますが、要素の比較に<code class="literal">eq</code>ではなく、<code class="literal">equal</code>を使用します。<a class="link" href="ch03s07.html" title="Equality Predicates">Equality
Predicates</a>を参照してください。
</p><pre class="synopsis"><a id="idm49242064" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">member</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>関数<code class="literal">member</code>は、メンバーと<em class="replaceable"><code>object</code></em>を<code class="literal">equal</code>を使用して比較して、<em class="replaceable"><code>object</code></em>が<em class="replaceable"><code>list</code></em>のメンバーかどうかをテストします。<em class="replaceable"><code>object</code></em>がメンバーの場合、<code class="literal">member</code>は<em class="replaceable"><code>list</code></em>で最初に見つかったところから開始されるリストをreturnします。それ以外は<code class="literal">nil</code>を参照してください。
</p><p>これを<code class="literal">memq</code>と比較してみましょう:
</p><pre class="screen">(member '(2) '((1) (2)))  ; <code class="literal">(2)</code> and <code class="literal">(2)</code> are <code class="literal">equal</code>.
     ⇒ ((2))
</pre><pre class="screen">(memq '(2) '((1) (2)))    ; <code class="literal">(2)</code>と<code class="literal">(2)</code>は<code class="literal">eq</code>ではない。
     ⇒ nil
</pre><pre class="screen">;; 同じ内容の2つの文字列は<code class="literal">equal</code>。
(member "foo" '("foo" "bar"))
     ⇒ ("foo" "bar")
</pre></blockquote></div><pre class="synopsis"><a id="idm49200080" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">delete</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>sequence</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>sequence</code></em>から<em class="replaceable"><code>object</code></em>と<code class="literal">equal</code>な要素を取り除いて、結果のシーケンスをreturnします。
</p><p><em class="replaceable"><code>sequence</code></em>がリストの場合、<code class="literal">delete</code>が<code class="literal">delq</code>に対応するように、<code class="literal">member</code>は<code class="literal">memq</code>に対応します。つまり、この関数は<code class="literal">member</code>と同様、要素と<em class="replaceable"><code>object</code></em>の比較に<code class="literal">equal</code>を使用します。マッチする要素が見つかったら、<code class="literal">delq</code>が行なうように、その要素を取り除きます。<code class="literal">delq</code>と同様、通常は元のリストを保持していた変数にreturn値を割り当てて使用します。
</p><p><code class="literal">sequence</code>がベクターまたは文字列の場合、<code class="literal">delete</code>は<code class="literal">object</code>と<code class="literal">equal</code>なすべての要素を取り除いた、<code class="literal">sequence</code>のコピーをreturnします。
</p><p>たとえば:
</p><pre class="screen">(setq l '((2) (1) (2)))
(delete '(2) l)
     ⇒ ((1))
l
     ⇒ ((2) (1))
;; <code class="literal">l</code>の変更に信頼性を要するときは
;; <code class="literal">(setq l (delete '(2) l))</code>と記述する。
</pre><pre class="screen">(setq l '((2) (1) (2)))
(delete '(1) l)
     ⇒ ((2) (2))
l
     ⇒ ((2) (2))
;; このケースでは<code class="literal">l</code>のセットの有無に違いはない
;; しかし他のケースに倣ってセットするべき。
</pre><pre class="screen">(delete '(2) [(2) (1) (2)])
     ⇒ [(1)]
</pre></blockquote></div><pre class="synopsis"><a id="idm49171664" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">remove</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>sequence</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<code class="literal">delete</code>に対応する非破壊的な関数です。この関数は、<code class="literal">object</code>と<code class="literal">equal</code>な要素を取り除いた、<code class="literal">sequence</code>(リスト、ベクター、文字列)のコピーをreturnします。たとえば:
</p><pre class="screen">(remove '(2) '((2) (1) (2)))
     ⇒ ((1))
</pre><pre class="screen">(remove '(2) [(2) (1) (2)])
     ⇒ [(1)]
</pre></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意:</strong></span> GNU Emacs
Lispの関数<code class="literal">member</code>、<code class="literal">delete</code>、<code class="literal">remove</code>は、Common
Lispではなく、Maclispを継承しています。Common Lispでは、比較に<code class="literal">equal</code>を使用しません。
</p></blockquote></div><pre class="synopsis"><a id="idm49158096" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">member-ignore-case</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<code class="literal">member</code>と同様ですが、<em class="replaceable"><code>object</code></em>が文字列で、大文字小文字とテキスト表現の違いを無視します。文字の大文字と小文字は等しいものとして扱われ、比較に先立ちユニバイト文字列はマルチバイト文字列に変換されます。
</p></blockquote></div><pre class="synopsis"><a id="idm49153616" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">delete-dups</code> <em class="replaceable"><code>list</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>list</code></em>からすべての<code class="literal">equal</code>な重複を、破壊的に取り除いて。、結果を<em class="replaceable"><code>list</code></em>に保管して、それをreturnします。<em class="replaceable"><code>list</code></em>内の要素に<code class="literal">equal</code>な要素がいくつかある場合、<code class="literal">delete-dups</code>は最初の要素を残します。
</p></blockquote></div><p>変数に格納されたリストに要素を追加したり、それを集合として使用する方法については、<a class="link" href="ch06s05.html" title="Modifying List Variables">List
Variables</a>の関数<code class="literal">add-to-list</code>も参照してください。
</p></div></body></html>