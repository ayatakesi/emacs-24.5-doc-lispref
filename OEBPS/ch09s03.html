<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Creating and Interning Symbols</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Creating-Symbols"/>Creating and Interning Symbols</h1></div></div></div><a id="idm52342096" class="indexterm"/><p>GNU Emacs
Lispでシンボルが作成される方法を理解するには、Lispがシンボルを読み取る方法を理解しなければなりません。Lispは、同じ文字綴りを読み取ったら、毎回同じシンボルを見つけることを保証しなければなりません。これに失敗すると、完全な混乱を招くでしょう。
</p><a id="idm52340944" class="indexterm"/><a id="idm52340176" class="indexterm"/><a id="idm52339408" class="indexterm"/><a id="idm52338640" class="indexterm"/><p>Lispリーダーがシンボルに出会うと、Lispリーダーは名前のすべての文字を読み取ります。その後Lispリーダーは、<em class="firstterm">obarray(オブジェクト配列)</em>と呼ばれるテーブル内のインデックスを決めるために、これらの文字を“ハッシュ(hash)”します。ハッシュ化(hashing)は何かを照合するのに効果的な方法です。たとえば、Jan
Jonesを見つけるときは、電話帳を表紙から1頁ずつ探すのではなく、Jから探し始めます。これは簡単なバージョンのハッシュ化です。obarrayの各要素は、与えられたハッシュコードとともにすべてのシンボルを保持する、<em class="firstterm">バケット(bucket)</em>です。与えられた名前を探すためには、バケットの中からその名前のハッシュコードのすべてのシンボルを探すのが効果的です(同じアイデアは一般的なEmacsのハッシュテーブルでも使用されていますが、これらは異なるデータ型です。<a class="link" href="ch08.html" title="Chapter 7. Hash Tables">Hash
Tables</a>を参照してください)。
</p><a id="idm52336208" class="indexterm"/><p>探している名前のシンボルが見つかったら、リーダーはそのシンボルを使用します。obarrayにその名前のシンボルが含まれない場合、リーダーは新しいシンボルを作成して、それをobarrayに追加します。特定の名前のシンボルを探して追加することを、<em class="firstterm">インターン(intern)</em>すると言い、これが行なわれた後、そのシンボルは<em class="firstterm">インターンされたシンボル(interned
symbol)</em>と呼ばれます。
</p><p>インターンすることにより、ある特定の名前のシンボルは、それぞれのobarrayに1つだけであることが保証されます。同じ名前のシンボルは他に存在するかもしれませんが、同じobarrayではありません。したがってリーダーは、(同じobarrayを読みつづける限り)同じ名前にたいして、同じシンボルを取得します。
</p><p>インターンは通常、リーダー内で自動的に発生しますが、他のプログラムがこれを行なう必要がある場合もあります。たとえば、<strong class="userinput"><code>M-x</code></strong>コマンドは、その後ミニバッファーを使用してコマンド名を文字列として取得し、その文字列をインターンして、インターンされたその名前のシンボルを得ます。
</p><a id="idm52333008" class="indexterm"/><a id="idm52332240" class="indexterm"/><p>すべてのシンボルを含むobarrayはありません。実際、どのobarrayにも含まれないシンボルがいくつかあります。これらは、<em class="firstterm">インターンされていないシンボル(uninterned
symbols)</em>と呼ばれます。インターンされていないシンボルも、他のシンボルと同じく4つのセルをもちます。しかし、インターンされていないシンボルへのアクセスを得る唯一の方法は、他の何らかのオブジェクトとして探すか、変数の値として探す方法だけです。
</p><p>インターンされていないシンボルの作成は、Lispコードを生成するとき有用です。なぜなら、作成されたコード内で変数として使用されているインターンされていないシンボルは、他のLispプログラムで使用されている任意の変数と競合することはありえないからです。
</p><p>Emacs
Lispでは、obarrayはベクターです。ベクター内の各要素がバケットになります。要素の値は、名前がそのバケットにハッシュされるインターンされたシンボル、またはバケットが空のときは0です。インターンされたシンボルは、そのバケット内の次のシンボルへの、内部リンク(ユーザーからは見えない)をもちます。これらのリンクは不可視なので、<code class="literal">mapatoms</code>を使用する方法をのぞき(以下参照)、obarray内のすべてのシンボルを探す方法はありません。バケット内のシンボルの順番に、意味はありません。
</p><p>空のobarrayでは、すべての要素が0なので、<code class="literal">(make-vector <em class="replaceable"><code>length</code></em>
0)</code>でobarrayを作成することができます。<span class="bold"><strong>obarrayを作成する有効な方法は、これだけです。</strong></span>長さに素数を指定すると、よいハッシュ化がされる傾向があります。2の累乗から1減じた長さも、よい結果を生む傾向があります。
</p><p><span class="bold"><strong>自分でobarrayにシンボルを置かないでください。</strong></span>これはうまくいきません —
obarrayに正しくシンボルを入力できるのは、<code class="literal">intern</code>だけです。
</p><a id="idm52314064" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意: </strong></span>Common Lispとは異なり、Emacs
Lispは1つのシンボルを複数のobarrayにインターンする方法を提供しません。
</p></blockquote></div><p>以下の関数のほとんどは、引数に名前とobarrayをとります。名前が文字列ではない、またはobarrayがベクターでない場合は、<code class="literal">wrong-type-argument</code>エラーがシグナルされます。
</p><pre class="synopsis"><a id="idm52307152" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">symbol-name</code> <em class="replaceable"><code>symbol</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>symbol</code></em>の名前を文字列としてreturnします。たとえば:
</p><pre class="screen">(symbol-name 'foo)
     ⇒ "foo"
</pre><p><span class="bold"><strong>警告:
</strong></span>文字の置き換えにより文字列を変更すると、それはシンボルの名前を変更しますが、obarrayの更新には失敗するので、行なわないでください!
</p></blockquote></div><pre class="synopsis"><a id="idm52302288" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">make-symbol</code> <em class="replaceable"><code>name</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、新たに割り当てられた、名前が<em class="replaceable"><code>name</code></em>(文字列でなかればならない)のインターンされていないシンボルをreturnします。このシンボルの値と関数はvoidで、プロパティーリストは<code class="literal">nil</code>です。以下の例では、<code class="literal">sym</code>の値は<code class="literal">foo</code>と<code class="literal">eq</code>ではありません。なぜなら、これは名前が‘<code class="literal">foo</code>’のインターンされていないシンボルだからです。
</p><pre class="screen">(setq sym (make-symbol "foo"))
     ⇒ foo
(eq sym 'foo)
     ⇒ nil
</pre></blockquote></div><pre class="synopsis"><a id="idm52291408" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">intern</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>obarray</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、名前が<em class="replaceable"><code>name</code></em>の、インターンされたシンボルをreturnします。オブジェクト配列<em class="replaceable"><code>obarray</code></em>の中にそのようなシンボルが存在しない場合、<code class="literal">intern</code>はあたらしいシンボルを作成してobarrayに追加し、それをreturnします。<em class="replaceable"><code>obarray</code></em>が省略された場合、グローバル変数<code class="literal">obarray</code>の値が使用されます。
</p><pre class="screen">(setq sym (intern "foo"))
     ⇒ foo
(eq sym 'foo)
     ⇒ t

(setq sym1 (intern "foo" other-obarray))
     ⇒ foo
(eq sym1 'foo)
     ⇒ nil
</pre></blockquote></div><a id="idm52285008" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意: </strong></span>Common Lispでは、既存のシンボルをobarrayにインターンできます。Emacs
Lispでは、<code class="literal">intern</code>の引数はシンボルではなく文字列なので、これを行なうことはできません。
</p></blockquote></div><pre class="synopsis"><a id="idm52262096" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">intern-soft</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>obarray</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>obarray</code></em>内の名前が<em class="replaceable"><code>name</code></em>のシンボル、<em class="replaceable"><code>obarray</code></em>にその名前のシンボルが存在しない場合は<code class="literal">nil</code>をreturnします。したがって、与えられた名前のシンボルがすでにインターンされているかテストするために、<code class="literal">intern-soft</code>を使用することができます。<em class="replaceable"><code>obarray</code></em>が省略された場合は、グローバル変数<code class="literal">obarray</code>の値が使用されます。
</p><p>引数<em class="replaceable"><code>name</code></em>にはシンボルも使用できます。この場合、指定されたobarrayに<em class="replaceable"><code>name</code></em>がインターンされていれば<em class="replaceable"><code>name</code></em>、それ以外は<code class="literal">nil</code>をreturnします。
</p><pre class="screen">(intern-soft "frazzle")        ; そのようなシンボルは存在しない。
     ⇒ nil
(make-symbol "frazzle")        ; インターンされていないシンボルを作成する。
     ⇒ frazzle
</pre><pre class="screen">(intern-soft "frazzle")        ; そのようなシンボルは見つからない。
     ⇒ nil
</pre><pre class="screen">(setq sym (intern "frazzle"))  ; インターンされたシンボルを作成する。
     ⇒ frazzle
</pre><pre class="screen">(intern-soft "frazzle")        ; シンボルが見つかった!
     ⇒ frazzle
</pre><pre class="screen">(eq sym 'frazzle)              ; そして、それは同じシンボル。
     ⇒ t
</pre></blockquote></div><pre class="synopsis"><a id="idm52250960" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">obarray</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、<code class="literal">intern</code>および<code class="literal">read</code>で使用される、標準のobarrayです。
</p></blockquote></div><pre class="synopsis"><a id="idm52247248" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">mapatoms</code> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>obarray</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-mapatoms"/><p>この関数は、オブジェクト配列<em class="replaceable"><code>obarray</code></em>の中のシンボルに1つにたいして、1度ずつ<em class="replaceable"><code>function</code></em>を呼び出し、その後<code class="literal">nil</code>をreturnします。<em class="replaceable"><code>obarray</code></em>が省略された場合は、通常のシンボルにたいする標準のオブジェクト配列<code class="literal">obarray</code>の値がデフォルトになります。
</p><pre class="screen">(setq count 0)
     ⇒ 0
(defun count-syms (s)
  (setq count (1+ count)))
     ⇒ count-syms
(mapatoms 'count-syms)
     ⇒ nil
count
     ⇒ 1871
</pre><p><code class="literal">mapatoms</code>を使用する他の例については、<a class="link" href="ch24s02.html" title="Access to Documentation Strings">Accessing
Documentation</a>の<code class="literal">documentation</code>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm52226256" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">unintern</code> <em class="replaceable"><code>symbol</code></em> <em class="replaceable"><code>obarray</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、オブジェクト配列<em class="replaceable"><code>obarray</code></em>から、<em class="replaceable"><code>symbol</code></em>を削除します。obarrayの中に<code class="literal">symbol</code>が存在しない場合、<code class="literal">unintern</code>は何も行ないません。<em class="replaceable"><code>obarray</code></em>が<code class="literal">nil</code>の場合は、現在のobarrayが使用されます。
</p><p><em class="replaceable"><code>symbol</code></em>にシンボルではなく文字列を与えた場合、それはシンボルの名前を意味します。この場合、<code class="literal">unintern</code>は、(もしあれば)obarrayからその名前のシンボルを削除します。そのようなシンボルが存在する場合、<code class="literal">unintern</code>は何も行ないません。
</p><p><code class="literal">unintern</code>がシンボルを削除した場合は<code class="literal">t</code>、それ以外は<code class="literal">nil</code>をreturnします。
</p></blockquote></div></div></body></html>