<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Conditionals</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Conditionals"/>Conditionals</h1></div></div></div><a id="idm51722576" class="indexterm"/><p>条件による制御構造は、候補の中から選択を行ないます。Emacs
Lispは4つの条件フォームをもちます。<code class="literal">if</code>は他の言語のものとほとんど同じです。<code class="literal">when</code>と<code class="literal">unless</code>は、<code class="literal">if</code>の変種です。<code class="literal">cond</code>は一般化されたcase命令です。
</p><pre class="synopsis"><a id="idm51718608" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">if</code> <em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>then-form</code></em> <em class="replaceable"><code>else-forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">if</code>は、<em class="replaceable"><code>condition</code></em>の値にもとづいて、<em class="replaceable"><code>then-form</code></em>と<em class="replaceable"><code>else-forms</code></em>を選択します。評価された<em class="replaceable"><code>condition</code></em>が非<code class="literal">nil</code>の場合は、<em class="replaceable"><code>then-form</code></em>が評価されて、その結果がreturnされます。それ以外は、<em class="replaceable"><code>else-forms</code></em>がテキスト順に評価されて、最後のフォームの値がreturnされます(<code class="literal">if</code>の<em class="replaceable"><code>else</code></em>パートは、暗黙の<code class="literal">progn</code>の例です。<a class="link" href="ch11.html#Sequencing" title="Sequencing">Sequencing</a>を参照してください)。
</p><p><em class="replaceable"><code>condition</code></em>の値が<code class="literal">nil</code>で、<em class="replaceable"><code>else-forms</code></em>が与えられない場合、<code class="literal">if</code>は<code class="literal">nil</code>をreturnします。
</p><p>選択されなかったブランチは決して評価されない — 無視される —
ので、<code class="literal">if</code>はスペシャルフォームです。したがって、以下の例では<code class="literal">print</code>は呼び出されることはないので、<code class="literal">true</code>はプリントされません。
</p><pre class="screen">(if nil
    (print 'true)
  'very-false)
⇒ very-false
</pre></blockquote></div><pre class="synopsis"><a id="idm51687888" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">when</code> <em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>then-forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、<em class="replaceable"><code>else-forms</code></em>がなく、複数の<em class="replaceable"><code>then-forms</code></em>があるかもしれない、<code class="literal">if</code>の変種です。特に、
</p><pre class="screen">(when <em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>c</code></em>)
</pre><p>は以下と完全に等価です
</p><pre class="screen">(if <em class="replaceable"><code>condition</code></em> (progn <em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>c</code></em>) nil)
</pre></blockquote></div><pre class="synopsis"><a id="idm51678288" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">unless</code> <em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<em class="replaceable"><code>then-form</code></em>がない、<code class="literal">if</code>の変種です:
</p><pre class="screen">(unless <em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>c</code></em>)
</pre><p>は以下と完全に等価です
</p><pre class="screen">(if <em class="replaceable"><code>condition</code></em> nil
   <em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>c</code></em>)
</pre></blockquote></div><pre class="synopsis"><a id="idm51669072" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">cond</code> <em class="replaceable"><code>clause</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">cond</code>は、任意の数の候補から選択を行ないます。<code class="literal">cond</code>内の各<em class="replaceable"><code>clause</code></em>は、リストでなければなりません。このリストのCARは<em class="replaceable"><code>condition</code></em>で、(もしあれば)残りの要素は<em class="replaceable"><code>body-forms</code></em>です。したがって、条項は以下のようになります:
</p><pre class="screen">(<em class="replaceable"><code>condition</code></em> <em class="replaceable"><code>body-forms</code></em>…)
</pre><p><code class="literal">cond</code>は、各条項の<em class="replaceable"><code>condition</code></em>を評価することにより、テキスト順で条項を試験します。<em class="replaceable"><code>condition</code></em>の値が非<code class="literal">nil</code>の場合、その条項は“成り立ち”ます。その後、<code class="literal">cond</code>は、その条項の<em class="replaceable"><code>body-forms</code></em>を評価して、<em class="replaceable"><code>body-forms</code></em>の最後の値をreturnします。残りの条項は無視されます。
</p><p><em class="replaceable"><code>condition</code></em>の値が<code class="literal">nil</code>の場合、その条項は“成り立たず”、<code class="literal">cond</code>は次の条項に移動して、その条項の<em class="replaceable"><code>condition</code></em>を試験します。
</p><p>以下のようなものも、条項になります:
</p><pre class="screen">(<em class="replaceable"><code>condition</code></em>)
</pre><p><em class="replaceable"><code>condition</code></em>がテストされたときに非<code class="literal">nil</code>なら、<code class="literal">cond</code>フォームは<em class="replaceable"><code>condition</code></em>の値をreturnします。
</p><p>すべての<em class="replaceable"><code>condition</code></em>が<code class="literal">nil</code>に評価された場合 —
つまりすべての条項が不成立の場合、<code class="literal">cond</code>は<code class="literal">nil</code>をreturnします。
</p><p>以下の例は4つの条項をもち、<code class="literal">x</code>の値が数字か、文字列化、バッファーか、シンボルかをテストします:
</p><pre class="screen">(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; 1つの条項に
       (buffer-name x))        ; 複数bodyフォーム。
      ((symbolp x) (symbol-value x)))
</pre><p>前の条項が不成立のとき、最後の条項を実行したいときがよくあります。これを行なうには、<code class="literal">(t
<em class="replaceable"><code>body-forms</code></em>)</code>のように、<em class="replaceable"><code>condition</code></em>の最後の条項に<code class="literal">t</code>を使用します。フォーム<code class="literal">t</code>は<code class="literal">t</code>に評価され、決して<code class="literal">nil</code>にならないので、この条項が不成立になることはなく、最終的に<code class="literal">cond</code>はこの条項に到達します。たとえば:
</p><pre class="screen">(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
⇒ "default"
</pre><p>この<code class="literal">cond</code>式は、<code class="literal">a</code>の値が<code class="literal">hack</code>の場合は<code class="literal">foo</code>、それ以外は文字列<code class="literal">"default"</code>をreturnします。
</p></blockquote></div><p>任意の条件構成は、<code class="literal">cond</code>か<code class="literal">if</code>で表すことができます。したがって、どちらを選択するかは、スタイルの問題です、たとえば:
</p><pre class="screen">(if <em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>c</code></em>)
≡
(cond (<em class="replaceable"><code>a</code></em> <em class="replaceable"><code>b</code></em>) (t <em class="replaceable"><code>c</code></em>))
</pre><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Pattern-matching-case-statement"/>Pattern matching case statement</h2></div></div></div><a id="idm51633104" class="indexterm"/><a id="idm51632336" class="indexterm"/><p>特定の値を、可能なさまざまの場合にたいして比較するには、マクロ<code class="literal">pcase</code>が便利です。これは以下のフォームをとります:
</p><pre class="screen">(pcase <em class="replaceable"><code>exp</code></em> <em class="replaceable"><code>branch</code></em>1 <em class="replaceable"><code>branch</code></em>2 <em class="replaceable"><code>branch</code></em>3 …)
</pre><p>各<em class="replaceable"><code>branch</code></em>は、<code class="literal">(<em class="replaceable"><code>upattern</code></em> <em class="replaceable"><code>body-forms</code></em>…)</code>というフォームです。
</p><p>これは最初に<em class="replaceable"><code>exp</code></em>を評価してから、どの<em class="replaceable"><code>branch</code></em>を使用するか、その値を各<em class="replaceable"><code>upattern</code></em>と比較して、その後で対応する<em class="replaceable"><code>body-forms</code></em>実行します。一般的なのは、少数の異なる定数値を区別するために使用される場合です:
</p><pre class="screen">(pcase (get-return-code x)
  (`success       (message "Done!"))
  (`would-block   (message "Sorry, can't do it now"))
  (`read-only     (message "The shmliblick is read-only"))
  (`access-denied (message "You do not have the needed rights"))
  (code           (message "Unknown return code %S" code)))
</pre><p>最後の条項の<code class="literal">code</code>は、<code class="literal">(get-return-code x)</code>からreturnされた値にバインドされる変数です。
</p><p>もっと複雑な例として、以下のような小さな式言語のための単純なインタープリターを示します(この例ではレキシカルバインディングが必要なことに注意してください):
</p><pre class="screen">(defun evaluate (exp env)
  (pcase exp
    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val) env))))
    ((pred numberp)     exp)
    ((pred symbolp)     (cdr (assq exp env)))
    (_                  (error "Unknown expression %S" exp))))
</pre><p><code class="literal">`(add ,x
,y)</code>は、<code class="literal">exp</code>がシンボル<code class="literal">add</code>で始まる3要素のリストかチェックして、その後2番目と3番目の要素を抽出し、それらを変数<code class="literal">x</code>と<code class="literal">y</code>にバインドするパターンです。<code class="literal">(pred
numberp)</code>は<code class="literal">exp</code>が数字かを単にチェックし、<code class="literal">_</code>はすべてのものにマッチするcatch-allパターンです。
</p><p>以下に、いくつかの例を評価した結果とともに示します:
</p><pre class="screen">(evaluate '(add 1 2) nil)                 ;=&gt; 3
(evaluate '(add x y) '((x . 1) (y . 2)))  ;=&gt; 3
(evaluate '(call (fn x (add 1 x)) 2) nil) ;=&gt; 3
(evaluate '(sub 1 2) nil)                 ;=&gt; error
</pre><p><code class="literal">pcase</code>に関係する2種類のパターンがあり、それらは<span class="emphasis"><em>U-patterns</em></span>、<span class="emphasis"><em>Q-patterns</em></span>と呼ばれます。上述の<em class="replaceable"><code>upattern</code></em>はU-patternsで、以下の形式をもつことができます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">`<em class="replaceable"><code>qpattern</code></em></code>
</span></dt><dd><p>これは、もっとも一般的なパターンの1つです。このパターンの意図は、バッククォートマクロの模倣です。このパターンは、バッククォート式により構築されるような値にマッチします。わたしたちが行なうのは値の構築ではなくパターンマッチングなので、非クォートは式をどこに挿入するか示すのではなく、かわりにその位置で値にマッチすべき1つのU-patternを指定します。
</p><p>より具体的には、Q-patternは以下のフォームをもつことができます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">(<em class="replaceable"><code>qpattern1</code></em> . <em class="replaceable"><code>qpattern2</code></em>)</code>
</span></dt><dd><p>このパターンは、<code class="literal">car</code>が<em class="replaceable"><code>qpattern1</code></em>、<code class="literal">cdr</code>が<em class="replaceable"><code>pattern2</code></em>にマッチする、任意のコンスセルにマッチします。
</p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>atom</code></em></code>
</span></dt><dd><p>このパターンは、<em class="replaceable"><code>atom</code></em>に<code class="literal">equal</code>な任意のアトムにマッチします。
</p></dd><dt><span class="term"><code class="literal">,<em class="replaceable"><code>upattern</code></em></code>
</span></dt><dd><p>このパターンは、<em class="replaceable"><code>upattern</code></em>にマッチする任意のオブジェクトにマッチします。
</p></dd></dl></div></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>symbol</code></em></code>
</span></dt><dd><p>U-pattern内の単なるシンボルはすべてにマッチし、さらにマッチした値にそのシンボルをバインドするので、<em class="replaceable"><code>body-forms</code></em>や皇族のパターンから、それを参照することができます。
</p></dd><dt><span class="term"><code class="literal">_</code>
</span></dt><dd><p>このパターン — いわゆる<span class="emphasis"><em>don’t care</em></span>パターン —
はシンボルパターンと同様、すべてのものにマッチしますが、シンボルパターンとは異なり、変数へのバインドを行ないません。
</p></dd><dt><span class="term"><code class="literal">(pred <em class="replaceable"><code>pred</code></em>)</code>
</span></dt><dd><p>このパターンは、マッチされるオブジェクトで関数<em class="replaceable"><code>pred</code></em>が呼び出したとき、非<code class="literal">nil</code>をreturnするものにマッチします。
</p></dd><dt><span class="term"><code class="literal">(or <em class="replaceable"><code>upattern1</code></em> <em class="replaceable"><code>upattern2</code></em>…)</code>
</span></dt><dd><p>このパターンは、引数のパターンから最初に成立したパターンにマッチします。すべての引数パターンは、同じ変数にバインドされるべきです。
</p></dd><dt><span class="term"><code class="literal">(and <em class="replaceable"><code>upattern1</code></em> <em class="replaceable"><code>upattern2</code></em>…)</code>
</span></dt><dd><p>このパターンは、すべての引数パターンが成立したときだけマッチします。
</p></dd><dt><span class="term"><code class="literal">(guard <em class="replaceable"><code>exp</code></em>)</code>
</span></dt><dd><p>このパターンは調べられるオブジェクトを無視して、<em class="replaceable"><code>exp</code></em>が非<code class="literal">nil</code>に評価されたときは成立、それ以外は不成立となります。これは通常、<code class="literal">and</code>パターンの内部で使用されます。たとえば、<code class="literal">(and
x (guard (&lt; x 10)))</code>は10より小さい任意の数字にマッチして、それを変数<code class="literal">x</code>にバインドします。
</p></dd></dl></div></div></div></body></html>