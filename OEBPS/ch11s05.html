<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nonlocal Exits</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Nonlocal-Exits"/>Nonlocal Exits</h1></div></div></div><a id="idm51474256" class="indexterm"/><p><em class="firstterm">非ローカル脱出(nonlocal exit)</em>とは、プログラム内のある位置から、別の離れた位置へ、制御を移します。Emacs
Lispでは、エラーの結果として非ローカル脱出が発生することがあります。明示的な制御の下で非ローカル脱出を使用することもできます。非ローカル脱出は、脱出しようとしている構成により作成された、すべての変数バインディングのバインドを外します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Catch-and-Throw"/>Explicit Nonlocal Exits: <code class="literal">catch</code> and <code class="literal">throw</code></h2></div></div></div><p>ほとんどの制御構造は、そのコンストラクト自身内部の制御フローだけに影響します。関数<code class="literal">throw</code>は、通常のプログラム実行でのこのルールの例外です。これは、リクエストにより非ローカル脱出を行ないます(他にも例外はありますが、それらはエラー処理だけのものです)。<code class="literal">throw</code>は<code class="literal">catch</code>の内部で試用され、<code class="literal">catch</code>に制御を戻します。たとえば:
</p><pre class="screen">(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  …
  (if x
      (throw 'foo t))
  …)
</pre><p><code class="literal">throw</code>フォームが実行された場合は、対応する<code class="literal">catch</code>に制御を移し、<code class="literal">catch</code>は即座にreturnします。<code class="literal">throw</code>の後のコードは実行されません。<code class="literal">throw</code>の2番目の引数は、<code class="literal">catch</code>のreturn値として使用されます。
</p><p>関数<code class="literal">throw</code>は、1番目の引数にもとづいて、それにマッチする<code class="literal">catch</code>を探します。<code class="literal">throw</code>は、1番目の引数が、<code class="literal">throw</code>で指定されたものと<code class="literal">eq</code>な<code class="literal">catch</code>を検索します。複数の該当する<code class="literal">catch</code>がある場合、最内のものが優先されます。したがって、上記の例では<code class="literal">throw</code>が<code class="literal">foo</code>を指定し、<code class="literal">foo-outer</code>内の<code class="literal">catch</code>が同じシンボルを指定しているので、(この間に他のマッチする<code class="literal">catch</code>は存在しないと仮定すると)<code class="literal">catch</code>が該当します。
</p><p><code class="literal">throw</code>の実行により、マッチする<code class="literal">catch</code>までのすべてのリスプ構成(関数呼び出しを含む)を脱出します。この方法により<code class="literal">let</code>や関数呼び出しのようなバインディング構成を脱出する場合、これらの構成を正常にexitしたときのように、そのバインディングは解かれます(<a class="link" href="ch12s03.html" title="Local Variables">Local
Variables</a>を参照してください)。同様に<code class="literal">throw</code>は、<code class="literal">save-excursion</code>(<a class="link" href="ch30s03.html" title="Excursions">Excursions</a>を参照してください)により保存されたバッファーと位置を復元します。<code class="literal">throw</code>が、スペシャルフォーム<code class="literal">unwind-protect</code>を脱出した場合、<code class="literal">unwind-protect</code>により設定されたいくつかのクリーンアップも実行します。
</p><p>ジャンプ先となる<code class="literal">catch</code>内にレキシカル(局所的)である必要はありません。<code class="literal">throw</code>は、<code class="literal">catch</code>内で呼び出された別の関数から、同じようにに呼び出すことができます。<code class="literal">throw</code>が行なわれたのが、順序的に、<code class="literal">catch</code>に入った後でexitする前である限り、その<code class="literal">throw</code>は<code class="literal">catch</code>にアクセスできます。エディターのコマンドループから戻る<code class="literal">exit-recursive-edit</code>のようなコマンドで、<code class="literal">throw</code>が使用されるのは、これが理由です。
</p><a id="idm51430864" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意: </strong></span>Common
Lispを含む、他のほとんどのバージョンのLispは、非シーケンシャルに制御を移す、いくつかの方法 —
たとえば<code class="literal">return</code>、<code class="literal">return-from</code>、<code class="literal">go</code> — をもちます。Emacs
Lispの場合は、<code class="literal">throw</code>だけです。<code class="filename">cl-lib</code>ライブラリーは、これらのうちいくつかを提供します。section “Blocks
and Exits” in <em class="citetitle">Common Lisp Extensions</em>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm51425488" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">catch</code> <em class="replaceable"><code>tag</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm51422288" class="indexterm"/><p><code class="literal">catch</code>は、<code class="literal">throw</code>関数にたいするreturn位置を確立します。return位置は<em class="replaceable"><code>tag</code></em>により、そのような他のreturn位置と区別されます。<em class="replaceable"><code>tag</code></em>は、<code class="literal">nil</code>以外の任意のLispオブジェクトです。引数<em class="replaceable"><code>tag</code></em>はreturn位置が確立される前に、通常どおり評価されます。
</p><p>return位置が効果をもつことにより、<code class="literal">catch</code>は<em class="replaceable"><code>body</code></em>のフォームをテキスト順に評価します。フォームが(エラーは非ローカル脱出なしで)通常に実行された場合、bodyの最後のフォームの値が、<code class="literal">catch</code>からreturnされます。
</p><p><em class="replaceable"><code>body</code></em>の実効の間に<code class="literal">throw</code>が実行された場合、<em class="replaceable"><code>tag</code></em>と同じ値を指定すると、<code class="literal">catch</code>フォームは即座にexitします。returnされる値は、それが何であれ、<code class="literal">throw</code>の2番目の引数に指定された値です。
</p></blockquote></div><pre class="synopsis"><a id="idm51413968" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">throw</code> <em class="replaceable"><code>tag</code></em> <em class="replaceable"><code>value</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">throw</code>の目的は、以前に<code class="literal">catch</code>により確立されたreturn位置に戻ることです。引数<em class="replaceable"><code>tag</code></em>は、既存のさまざまなreturn位置からrturn位置を選択するために使用されます。複数のreturn位置が<em class="replaceable"><code>tag</code></em>にマッチする場合、最内のものが使用されます。
</p><p>引数<em class="replaceable"><code>value</code></em>は、<code class="literal">catch</code>からreturnされる値として使用されます。
</p><a id="idm51407696" class="indexterm"/><p>タグ<em class="replaceable"><code>tag</code></em>のreturn位置が存在しない場合、データ<code class="literal">(<em class="replaceable"><code>tag</code></em>
<em class="replaceable"><code>value</code></em>)</code>とともに、<code class="literal">no-catch</code>エラーがシグナルされます。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Examples-of-Catch"/>Examples of <code class="literal">catch</code> and <code class="literal">throw</code></h2></div></div></div><p>2重にネストされたループから脱出する1つの方法は、<code class="literal">catch</code>と<code class="literal">throw</code>を使うことです(ほとんどの言語では、これは“goto”により行なわれるでしょう)。ここでは、<em class="replaceable"><code>i</code></em>と<em class="replaceable"><code>j</code></em>を、0から9に変化させて<code class="literal">(foo
<em class="replaceable"><code>i</code></em> <em class="replaceable"><code>j</code></em>)</code>を計算します:
</p><pre class="screen">(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (&lt; i 10)
        (let ((j 0))
          (while (&lt; j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
</pre><p><code class="literal">foo</code>が非<code class="literal">nil</code>をreturnした場合、即座に処理を止めて、<em class="replaceable"><code>i</code></em>と<em class="replaceable"><code>j</code></em>のリストをreturnしています。<code class="literal">foo</code>が常に<code class="literal">nil</code>をreturnする場合、<code class="literal">catch</code>は通常どおりreturnし、その値は<code class="literal">while</code>の結果である<code class="literal">nil</code>となります。
</p><p>以下では、2つのreturn位置を1度に表す、微妙に異なるトリッキーな例を2つ示します。最初に、同じタグ<code class="literal">hack</code>にたいする2つのreturn位置があります:
</p><pre class="screen">(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
⇒ catch2
</pre><pre class="screen">
</pre><pre class="screen">(catch 'hack
  (print (catch2 'hack))
  'no)
⊣ yes
⇒ no
</pre><p>どちらのreturn位置も<code class="literal">throw</code>にマッチするタグをもつので、内側のもの、つまり<code class="literal">catch2</code>で確立されたものにgotoします。したがって<code class="literal">catch2</code>は通常どおり値<code class="literal">yes</code>をreturnするので、その値がプリントされます。最後に外側の<code class="literal">catch</code>の2番目のbody、つまり<code class="literal">'no</code>が評価されて、外側の<code class="literal">catch</code>からそれがreturnされます。
</p><p>ここで、<code class="literal">catch2</code>に与える引数を変更してみます:
</p><pre class="screen">(catch 'hack
  (print (catch2 'quux))
  'no)
⇒ yes
</pre><p>この場合も2つのreturn位置がありますが、今回は外側だけがタグ<code class="literal">hack</code>をもち、内側のものは、かわりにタグ<code class="literal">quux</code>をもちます。したがって、<code class="literal">throw</code>により、外側の<code class="literal">catch</code>が値<code class="literal">yes</code>をreturnします。関数<code class="literal">print</code>が呼び出されることはなく、bodyのフォーム<code class="literal">'no</code>も決して評価されません。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Errors"/>Errors</h2></div></div></div><a id="idm51377104" class="indexterm"/><p>Emacs
Lispが、何らかの理由により評価できないようなフォームの評価を試みた場合には、<em class="firstterm">エラー(error)</em>が<em class="firstterm">シグナル(signal)</em>されます。
</p><p>エラーがシグナルされた場合、エラーメッセージの表示とカレントこまんどの実行の終了が、Emacsデフォルトの反応です。たとえばバッファーの最後で<strong class="userinput"><code>C-f</code></strong>とタイプしたときのように、ほとんどの場合、これは正しい反応です。
</p><p>複雑なプログラムでは、単なる終了が望ましくない場合もあるでしょう。たとえば、そのプログラムはデータ構造に一時的に変更を行なっていたり、プログラム終了前に削除すべき一時バッファーを作成しているかもしれません。このような場合、エラー時に評価される<em class="firstterm">クリーンアップ式(cleanup
expressions)</em>を設定するために、<code class="literal">unwind-protect</code>を使用するでしょう(<a class="link" href="ch11s05.html#Cleanups" title="Cleaning Up from Nonlocal Exits">Cleanups</a>を参照してください)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。この場合、エラー時のリカバリーを制御するための<em class="firstterm">エラーハンドラー(error
handlers)</em>を設定するために、<code class="literal">condition-case</code>を使用するでしょう。
</p><p>エラーハンドリングを使用せずに、プログラムの一部から別の部分へ制御を移すためには、<code class="literal">catch</code>と<code class="literal">throw</code>を使用します。<a class="link" href="ch11s05.html#Catch-and-Throw" title="Explicit Nonlocal Exits: catch and throw">Catch
and Throw</a>を参照してください。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Signaling-Errors"/>How to Signal an Error</h3></div></div></div><a id="idm51364560" class="indexterm"/><p>エラーの<em class="firstterm">シグナリング(signaling)</em>とは、エラーの処理を開始することを意味します。エラー処理は通常、実行中のプログラムのすべて、または一部をアボート(abort)して、エラーをハンドルするためにセットアップされた位置にreturnします。ここでは、エラーをシグナルする方法を記述します。
</p><p>ほとんどのエラーは、たとえば、整数にたいしてCARを求めたり、バッファーの最後で1文字前方に移動したときなどのように、他の目的のために呼び出したLisp基本関数の中で、“自動的”にシグナルされます。関数<code class="literal">error</code>と<code class="literal">signal</code>で、明示的にエラーをシグナルすることもできます。
</p><p>ユーザーが<strong class="userinput"><code>C-g</code></strong>をタイプしたときに発生するquitは、エラーとは判断されませんが、ほとんどはエラーと同様に扱われます。<a class="link" href="ch21s11.html" title="Quitting">Quitting</a>を参照してください。
</p><p>すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージは、何が悪いのか(“File does not
exist”)、物事がどうしてそうあるべきではない(“File must exist”)かを示すべきです。Emacs
Lispの監修では、エラーメッセージは大文字で開始され、句読点で終わるべきではありません。
</p><pre class="synopsis"><a id="idm51347280" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">error</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>format-string</code></em>と<em class="replaceable"><code>args</code></em>にたいして、<code class="literal">format</code>(<a class="link" href="ch05s07.html" title="Formatting Strings">Formatting
Strings</a>を参照してください)を適用することにより構築されたエラーメッセージとともに、エラーをシグナルします。
</p><p>以下は、<code class="literal">error</code>を使用する典型的な例です:
</p><pre class="screen">(error "That is an error -- try something else")
     error→ That is an error -- try something else
</pre><pre class="screen">
</pre><pre class="screen">(error "You have committed %d errors" 10)
     error→ You have committed 10 errors
</pre><p>2つの引数 — エラーシンボル<code class="literal">error</code>と、<code class="literal">format</code>によりreturnされる文字列を含むリスト —
で<code class="literal">signal</code>を呼び出すことにより、<code class="literal">error</code>は機能します。
</p><p><span class="bold"><strong>警告: </strong></span>エラーメッセージとして固定の文字列を使用したい場合、単に<code class="literal">(error
<em class="replaceable"><code>string</code></em>)</code>とは記述しないでください。もし<em class="replaceable"><code>string</code></em>が‘<code class="literal">%</code>’を含む場合、それはフォーマット指定子(format
specifier)として解釈されてしまうので、望む結果は得られません。かわりに、<code class="literal">(error "%s"
<em class="replaceable"><code>string</code></em>)</code>を使用してください。
</p></blockquote></div><pre class="synopsis"><a id="idm51333456" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">signal</code> <em class="replaceable"><code>error-symbol</code></em> <em class="replaceable"><code>data</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-signal"/><p>この関数は、<em class="replaceable"><code>error-symbol</code></em>により命名されるエラーをシグナルします。引数<em class="replaceable"><code>data</code></em>は、エラーの状況に関連する追加のLispオブジェクトのリストです。
</p><p>引数<em class="replaceable"><code>error-symbol</code></em>は、<em class="firstterm">エラーシンボル(error symbol)</em> —
<code class="literal">define-error</code>により定義されYたシンボル — でなければなりません。これはEmacs
Lispが異なる種類のエラーをクラス分けする方法です。エラーシンボル(error symbol)、エラーコンディション(error
condition)、コンディション名(condition name)の説明については、<a class="link" href="ch11s05.html#Error-Symbols" title="Error Symbols and Condition Names">Error Symbols</a>を参照してください。
</p><p>エラーが処理されない場合、エラーメッセージをプリントするために2つの引数が使用されます。このエラーメッセージは通常、<em class="replaceable"><code>error-symbol</code></em>の<code class="literal">error-message</code>プロパティーにより提供されます。<em class="replaceable"><code>data</code></em>が非<code class="literal">nil</code>の場合、その後にコロンと、<em class="replaceable"><code>data</code></em>の評価されていない要素を、カンマで区切ったリストが続きます。<code class="literal">error</code>が発生した場合、エラーメッセージは、<em class="replaceable"><code>data</code></em>のCAR(文字列でなければなりません)です。<code class="literal">file-error</code>のサブカテゴリーは、特別に処理されます。
</p><p><em class="replaceable"><code>data</code></em>内のオブジェクトの数と重要性は、<em class="replaceable"><code>error-symbol</code></em>に依存します。たとえば、<code class="literal">wrong-type-argument</code>エラーでは、リスト内には2つのオブジェクト
— 期待する型を記述する述語と、その型への適合に失敗したオブジェクト — であるべきです。
</p><p>エラーを処理する任意のエラーハンドラーにたいして、<em class="replaceable"><code>error-symbol</code></em>と<em class="replaceable"><code>data</code></em>の両方を利用できます。<code class="literal">condition-case</code>は、ローカル変数を<code class="literal">(<em class="replaceable"><code>error-symbol</code></em>
. <em class="replaceable"><code>data</code></em>)</code>というフォームでバインドします(<a class="link" href="ch11s05.html#Handling-Errors" title="Writing Code to Handle Errors">Handling Errors</a>を参照してください)。
</p><p>関数<code class="literal">signal</code>は、決してreturnしません。
</p><pre class="screen">(signal 'wrong-number-of-arguments '(x y))
     error→ Wrong number of arguments: x, y
</pre><pre class="screen">
</pre><pre class="screen">(signal 'no-such-error '("My unknown error condition"))
     error→ peculiar error: "My unknown error condition"
</pre></blockquote></div><a id="idm51303120" class="indexterm"/><pre class="synopsis"><a id="idm51302096" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">user-error</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<code class="literal">error</code>とまったく同じように振る舞いますが、<code class="literal">error</code>ではなく、<code class="literal">user-error</code>というエラーシンボルを使用します。名前が示唆するように、このエラーはコード自身のエラーではなく、ユーザーパートのエラーの報告を意図しています。たとえば、Infoの閲覧履歴の開始を超えて履歴を遡るためにコマンド<code class="literal">Info-history-back</code>
(<strong class="userinput"><code>l</code></strong>)を使用した場合、Emacsは<code class="literal">user-error</code>をシグナルします。このようなエラーでは、たとえ<code class="literal">debug-on-error</code>が非<code class="literal">nil</code>であっても、デバッガーへのエントリーは発生しません。<a class="link" href="ch18.html#Error-Debugging" title="Entering the Debugger on an Error">Error
Debugging</a>を参照してください。
</p></blockquote></div><a id="idm51293776" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意: </strong></span>Emacs Lispには、Common Lispのような継続可能なエラーのような概念は存在しません。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Processing-of-Errors"/>How Emacs Processes Errors</h3></div></div></div><a id="idm51291088" class="indexterm"/><p>エラーがシグナルされたとき、<code class="literal">signal</code>は、そのエラーにたいするアクティブな<em class="firstterm">ハンドラー(handler)</em>を検索します。ハンドラーとは、Lispプログラムの一部でエラーが発生したときに実行するよう意図された、Lisp式のシーケンスです。そのエラーが適切なハンドラーをもつ場合、そのハンドラーが実行され、そのハンドラーの後から実行が再開されます。ハンドラーは、そのハンドラーが設定された<code class="literal">condition-case</code>の環境内で実行されます。<code class="literal">condition-case</code>内のすべての関数呼び出しはすでに終了しているので、ハンドラーがそれらにreturnすることはありません。
</p><p>そのエラーにたいする適切なハンドラーが存在しない場合は、カレントコマンドを終了して、エディターのコマンドループに制御をreturnします(コマンドループは、すべての種類のエラーにたいする暗黙のハンドラーをもちます)。コマンドループのハンドラーは、エラーメッセージをプリントするために、エラーシンボルと、関連付けられたデータを使用します。変数<code class="literal">command-error-function</code>を使用して、これが行なわれる方法を制御できます:
</p><pre class="synopsis"><a id="idm51286864" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">command-error-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、もし非<code class="literal">nil</code>の場合はEmacsのコマンドループに制御をreturnしたエラーの処理に使用する関数を指定します。この関数は3つの引数をとります。1つ目は<em class="replaceable"><code>data</code></em>で、<code class="literal">condition-case</code>が自身の変数にバインドするのと同じフォームです。2つ目は<em class="replaceable"><code>context</code></em>で、これはエラーが発生した状況を記述する文字列、または<code class="literal">nil</code>（よくある）です。3つ目は<em class="replaceable"><code>caller</code></em>で、これはエラーをシグナルした基本関数を呼び出したLisp関数です。
</p></blockquote></div><a id="idm51281744" class="indexterm"/><p>明示的なハンドラーのないエラーは、Lispデバッガーを呼び出すかもしれません。変数<code class="literal">debug-on-error</code> (<a class="link" href="ch18.html#Error-Debugging" title="Entering the Debugger on an Error">Error
Debugging</a>を参照してください)が非<code class="literal">nil</code>の場合、デバッガーが有効です。エラーハンドラーとは異なり、デバッガーはそのエラーの環境内で実行されるので、エラー時の変数の値を正確に調べることができます。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Handling-Errors"/>Writing Code to Handle Errors</h3></div></div></div><a id="idm51277520" class="indexterm"/><a id="idm51276752" class="indexterm"/><p>エラーをシグナルすることによる通常の効果は、実行されていたコマンドを終了して、Emacsエディターのコマンドループに即座にreturnすることです。スペシャルフォーム<code class="literal">condition-case</code>を使用して、エラーハンドラーを設定することにより、プログラム内の一部で発生するエラーのをトラップを調整することができます。以下は単純な例です:
</p><pre class="screen">(condition-case nil
    (delete-file filename)
  (error nil))
</pre><p>これは、<em class="replaceable"><code>filename</code></em>という名前のファイルを削除して、任意のエラーをcatchして、エラーが発生した場合は<code class="literal">nil</code>を参照してください(このような単純なケースでは、マクロ<code class="literal">ignore-errors</code>を使用することもできます。以下を参照してください)。
</p><p><code class="literal">condition-case</code>構成は、<code class="literal">insert-file-contents</code>呼び出しでのファイルオープンの失敗のような、予想できるエラーをトラップするために多用されます。<code class="literal">condition-case</code>構成は、ユーザーからの読み取った式を評価するプログラムのような、完全に予測できないエラーのトラップにも使用されます。
</p><p><code class="literal">condition-case</code>の2番目の引数は、<em class="firstterm">保護されたフォーム(protected
form)</em>と呼ばれます(上記の例では、保護されたフォームは、<code class="literal">delete-file</code>の呼び出しです)。このフォームの実行が開始されると、エラーハンドラーは効果をもち、このフォームがreturnすると不活性になります。その間のすべてにおいて、エラーハンドラーは効果をもちます。特に、このフォームで呼び出された関数、およびそのサブルーチンなどを実行する間、エラーハンドラーは効果をもちます。厳密にいうと、保護されたフォーム自身ではなく、保護されたフォームにより呼び出されたLisp基本関数(<code class="literal">signal</code>と<code class="literal">error</code>を含む)だけがシグナルされるというのは、よいことです。
</p><p>保護されたフォームの後の引数はハンドラーです。各ハンドラーは、どのエラーを処理するかを指定する、1つ以上の<em class="firstterm">コンディション名(condition
names)</em>(シンボル)をリストします。エラーがシグナルされたとき、エラーシンボルはコンディション名のリストも定義します。エラーが共通の条件名をもつ場合、そのハンドラーはそのエラーに適用されます。上記の例では、1つのハンドラーがあり、それはすべてのエラーをカバーする条件名<code class="literal">error</code>を指定しています。
</p><p>適切なハンドラーの検索は、もっとも最近に設定されたハンドラーから開始して、設定されたすべてのハンドラーをチェックします。したがって、ネストされた<code class="literal">condition-case</code>フォームに同じエラー処理がある場合、内側のハンドラーがそれを処理します。
</p><p>何らかの<code class="literal">condition-case</code>によりエラーが処理された場合、<code class="literal">debug-on-error</code>でエラーによりデバッガーが呼び出されるようにしていても、通常はデバッガーの実行が抑制されます。
</p><p><code class="literal">condition-case</code>により補足されるようなエラーをデバッグできるようにしたい場合は、変数<code class="literal">debug-on-signal</code>に非<code class="literal">nil</code>値をセットします。以下のようにコンディションの中に<code class="literal">debug</code>を記述することにより、最初にデバッガーを実行するような、特定のハンドラーを指定することもできます:
</p><pre class="screen">(condition-case nil
    (delete-file filename)
  ((debug error) nil))
</pre><p>ここでの<code class="literal">debug</code>の効果は、デバッガー呼び出しを抑制する<code class="literal">condition-case</code>を防ぐことだけです。<code class="literal">debug-on-error</code>およびその他のフィルタリングメカニズムがデバッガーを呼び出すように指定されているときだけ、エラーによりデバッガーが呼び出されます。<a class="link" href="ch18.html#Error-Debugging" title="Entering the Debugger on an Error">Error
Debugging</a>を参照してください。
</p><pre class="synopsis"><a id="idm51238608" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">condition-case-unless-debug</code> <em class="replaceable"><code>var</code></em> <em class="replaceable"><code>protected-form</code></em> <em class="replaceable"><code>handlers</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>マクロ<code class="literal">condition-case-unless-debug</code>は、そのようなフォームのデバッギングを処理する、別の方法を提供します。このマクロは、変数<code class="literal">debug-on-error</code>が<code class="literal">nil</code>の場合、つまり任意のエラーを処理しないようなケース以外は、<code class="literal">condition-case</code>とまったく同様に振る舞います。
</p></blockquote></div><p>特定のハンドラーがそのエラーを処理するとEmacsが判断すると、Emacsは制御をそのハンドラーにreturnします。これを行うために、Emacsはそのとき脱出しつつあるバインディング構成により作成されたすべての変数のバインドを解き、そのとき脱出しつつあるすべての<code class="literal">unwind-protect</code>フォームを実行します。制御がそのハンドラーに達すると、そのハンドラーのbodyが通常どおり実行されます。
</p><p>そのハンドラーのbodyを実行した後、<code class="literal">condition-case</code>フォームから実行がreturnされます。保護されたフォームは、そのハンドラーの実行の前に完全にexitしているので、そのハンドラーはそのエラーの位置から実行を再開することはできず、その保護されたフォーム内で作られた変数のバインディングを調べることもできません。ハンドラーが行なえることは、クリーンアップと、処理を進行させることだけです。
</p><p>エラーのシグナルとハンドルには、<code class="literal">throw</code>と<code class="literal">catch</code>(<a class="link" href="ch11s05.html#Catch-and-Throw" title="Explicit Nonlocal Exits: catch and throw">Catch and
Throw</a>)に類似する点がいくつかありますが、これらは完全に別の機能です。エラーは<code class="literal">catch</code>でキャッチできず、<code class="literal">throw</code>をエラーハンドラーで処理することはできません(しかし対応する<code class="literal">catch</code>が存在しないときに<code class="literal">throw</code>を仕様することによりシグナルされるエラーは、処理できます)。
</p><pre class="synopsis"><a id="idm51210192" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">condition-case</code> <em class="replaceable"><code>var</code></em> <em class="replaceable"><code>protected-form</code></em> <em class="replaceable"><code>handlers</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このスペシャルフォームは、<em class="replaceable"><code>protected-form</code></em>の実行を囲い込むエラーハンドラー<em class="replaceable"><code>handlers</code></em>を確立します。エラーなしで<em class="replaceable"><code>protected-form</code></em>が実行された場合、returnされる値は<code class="literal">condition-case</code>フォームの値になります。この場合、<code class="literal">condition-case</code>は効果をもちません。<em class="replaceable"><code>protected-form</code></em>の間にエラーが発生した場合、<code class="literal">condition-case</code>は違いをもちます。
</p><p>それぞれの<em class="replaceable"><code>handlers</code></em>は、<code class="literal">(<em class="replaceable"><code>conditions</code></em>
<em class="replaceable"><code>body</code></em>…)</code>というフォームのリストです。ここで<em class="replaceable"><code>conditions</code></em>は、ハンドルされるエラーコンディション名、またはそのハンドラーの前にデバッガーを実行するためのコンディション名(<code class="literal">debug</code>を含みます)です。<em class="replaceable"><code>body</code></em>は、このハンドラーがエラーを処理するときに実行される、1つ以上のLisp式です。
</p><pre class="screen">(error nil)

(arith-error (message "Division by zero"))

((arith-error file-error)
 (message
  "Either division by zero or failure to open a file"))
</pre><p>発生するエラーはそれぞれ、それが何の種類のエラーかを記述する<em class="firstterm">エラーシンボル(error
symbol)</em>をもち、これはコンディション名のリストも記述します(<a class="link" href="ch11s05.html#Error-Symbols" title="Error Symbols and Condition Names">Error
Symbols</a>を参照してください)。Emacsは、1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな<code class="literal">condition-case</code>フォームを検索します。<code class="literal">condition-case</code>の最内のマッチは、そのエラーを処理します。この<code class="literal">condition-case</code>では、最初に適合したハンドラーが、そのエラーを処理します。
</p><p>ハンドラーのbodyを実行した後、<code class="literal">condition-case</code>は通常どおりreturnし、ハンドラーのbodyの最後の値を、ハンドラー全体の値として使用します。
</p><a id="idm51195600" class="indexterm"/><p>引数<em class="replaceable"><code>var</code></em>は変数です。<em class="replaceable"><code>protected-form</code></em>を実行するとき、<code class="literal">condition-case</code>はこの変数をバインドせず、エラーを処理するときだけバインドします。その場合は、<em class="replaceable"><code>var</code></em>を<em class="firstterm">エラー記述(error
description)</em>にバインドします。これはエラーの詳細を与えるリストです。このエラー記述は、<code class="literal">(<em class="replaceable"><code>error-symbol</code></em>
.
<em class="replaceable"><code>data</code></em>)</code>というフォームをもちます。ハンドラーは、何を行なうか決定するために、このリストを参照することができます。たとえば、ファイルオープンの失敗にたいするエラーの場合、ファイル名が<em class="replaceable"><code>data</code></em>(エラー記述の3番目の要素)の2番目の要素になります。
</p><p><em class="replaceable"><code>var</code></em>が<code class="literal">nil</code>の場合、それはバインドされた変数がないことを意味します。この場合、エラーシンボルおよび関連するデータは、そのハンドラーでは利用できません。
</p><a id="idm51189456" class="indexterm"/><p>より外側のレベルのハンドラーにcatchさせるために、<code class="literal">condition-case</code>によりcatchされたシグナルを再度throwする必要がある場合もあります。以下はこれを行なう方法です:
</p><pre class="screen">  (signal (car err) (cdr err))
</pre><p>ここで<code class="literal">err</code>はエラー記述変数(error description
variable)で、<code class="literal">condition-case</code>の1番目の引数は、再throwしたいエラーコンディションです。<a class="link" href="ch11s05.html#Definition-of-signal">Definition
of signal</a>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm51185104" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">error-message-string</code> <em class="replaceable"><code>error-descriptor</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、与えられたエラー記述子(error
descriptor)にたいするエラーメッセージ文字列をreturnします。これは、そのエラーにたいする通常のエラーメッセージをプリントすることにより、エラーを処理したい場合に有用です。<a class="link" href="ch11s05.html#Definition-of-signal">Definition
of signal</a>を参照してください。
</p></blockquote></div><a id="idm51181648" class="indexterm"/><p>以下は、0除算の結果によるエラーを処理するために、<code class="literal">condition-case</code>を使用する例です。このハンドラーは、(beepなしで)エラーメッセージを表示して、非常に大きい数をreturnします。
</p><pre class="screen">(defun safe-divide (dividend divisor)
  (condition-case err
      ;; 保護されたフォーム。
      (/ dividend divisor)
</pre><pre class="screen">    ;; ハンドラー。
    (arith-error                        ; Condition.
     ;; このエラーにたいする、通常のメッセージを表示する。
     (message "%s" (error-message-string err))
     1000000)))
⇒ safe-divide
</pre><pre class="screen">
</pre><pre class="screen">(safe-divide 5 0)
     ⊣ Arithmetic error: (arith-error)
⇒ 1000000
</pre><p>このハンドラーはコンディション名<code class="literal">arith-error</code>を指定するので、division-by-zero(0除算)エラーだけを処理します。他の種類のエラーは(この<code class="literal">condition-case</code>によっては)、処理されません。したがって:
</p><pre class="screen">(safe-divide nil 3)
     error→ Wrong type argument: number-or-marker-p, nil
</pre><p>以下は、<code class="literal">error</code>によるエラーを含む、すべての種類のエラーをcatchする<code class="literal">condition-case</code>です:
</p><pre class="screen">(setq baz 34)
     ⇒ 34
</pre><pre class="screen">
</pre><pre class="screen">(condition-case err
    (if (eq baz 35)
        t
      ;; 関数<code class="literal">error</code>の呼び出し
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; フォームではないハンドラー。
  (error (princ (format "The error was: %s" err))
         2))
⊣ The error was: (error "Rats!  The variable baz was 34, not 35")
⇒ 2
</pre><pre class="synopsis"><a id="idm51172432" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">ignore-errors</code> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、その実行中に発生する任意のエラーを無視して、<em class="replaceable"><code>body</code></em>の実行を構築します。その実行にエラーがなかった場合、<code class="literal">ignore-errors</code>は<em class="replaceable"><code>body</code></em>内の最後のフォームの値をreturnし、それ以外は<code class="literal">nil</code>をreturnします。
</p><p>以下は、このセクションの最初の例を、<code class="literal">ignore-errors</code>を使用して記述する例です:
</p><pre class="screen">  (ignore-errors
   (delete-file filename))
</pre></blockquote></div><pre class="synopsis"><a id="idm51165776" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">with-demoted-errors</code> <em class="replaceable"><code>format</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは、いわば<code class="literal">ignore-errors</code>の穏やかなバージョンです。これはエラーを完全に抑止するのではなく、エラーをメッセージに変換します。これはメッセージのフォーマットに、文字列<em class="replaceable"><code>format</code></em>を使用します。<em class="replaceable"><code>format</code></em>は、<code class="literal">"Error:
%S"</code>のように、単一の‘<code class="literal">%</code>’シーケンスを含むべきです。エラーをシグナルすると予測されないが、もし発生した場合は堅牢であるべきようなコードの周囲に、<code class="literal">with-demoted-errors</code>を使用します。このマクロは、<code class="literal">condition-case</code>ではなく、<code class="literal">condition-case-unless-debug</code>を使用することに注意してください。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Error-Symbols"/>Error Symbols and Condition Names</h3></div></div></div><a id="idm51157328" class="indexterm"/><a id="idm51156560" class="indexterm"/><a id="idm51155792" class="indexterm"/><a id="idm51155024" class="indexterm"/><a id="idm51154256" class="indexterm"/><a id="idm51153488" class="indexterm"/><p>エラーをシグナルするとき、想定するエラーの種類を指定するために、<em class="firstterm">エラーシンボル(error
symbol)</em>を指定します。エラーはそれぞれ、それをカテゴリー分けするために、ただ1つのエラーシンボルをもちます。これはEmacs
Lisp言語で定義されるエラーの、もっとも良い分類方法です。
</p><p>これら狭義の分類は、<em class="firstterm">エラー条件(error
conditions)</em>と呼ばれる、より広義のクラス階層にグループ化され、それらは<em class="firstterm">コンディション名(condition
names)</em>により識別されます。そのようなもっとも狭義なクラスは、エラーシンボル自体に属します。つまり各エラーシンボルは、コンディション名でもあるのです。すべての種類のエラー(<code class="literal">quit</code>を除く)を引き受けるコンディション名<code class="literal">error</code>に至る、より広義のクラスにたいするコンディション名も存在します。したがって、各エラーは1つ以上のコンディション名をもちます。つまり、<code class="literal">error</code>、<code class="literal">error</code>とは区別されるエラーシンボル、もしかしたらその中間に分類されるものかもしれません。
</p><pre class="synopsis"><a id="idm51148368" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">define-error</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>message</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>parent</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>シンボルをエラーシンボルとするために、シンボルは親コンディションをとる<code class="literal">define-error</code>で定義されなければなりません。この親は、この種のエラーが属するコンディションを定義します。親の推移的な集合は、常にそのエラーシンボルと、シンボル<code class="literal">error</code>を含みます。quitはエラーと判断されないので、<code class="literal">quit</code>の親の集合は、単なる<code class="literal">(quit)</code>です。
</p></blockquote></div><a id="idm51142224" class="indexterm"/><p>親のコンディションに加えて、エラーシンボルは<em class="replaceable"><code>メッセージ(message)</code></em>をもち、これは処理されないエラーがシグナルされたときプリントされる文字列です。そのメッセージが有効でない場合、エラーメッセージ‘<code class="literal">peculiar
error</code>’が使用されます。<a class="link" href="ch11s05.html#Definition-of-signal">Definition of signal</a>を参照してください。
</p><p>内部的には、親の集合はエラーシンボルの<code class="literal">error-conditions</code>プロパティーに格納され、メッセージはエラーシンボルの<code class="literal">error-message</code>プロパティーに格納されます。
</p><p>以下は、新しいエラーシンボル<code class="literal">new-error</code>を定義する例です:
</p><pre class="screen">(define-error 'new-error "A new error" 'my-own-errors)
</pre><p>このエラーは複数のコンディション名 —
もっとも狭義の分類<code class="literal">new-error</code>、より広義の分類を想定する<code class="literal">my-own-errors</code>、および<code class="literal">my-own-errors</code>のコンディションすべてを含む<code class="literal">error</code>で、これはすべての中でもっとも広義なものです。
</p><p>エラー文字列は大文字で開始されるべきですが、ピリオドで終了すべきではありません。これはEmacsの他の部分との整合性のためです。
</p><p>もちろんEmacs自身が<code class="literal">new-error</code>をシグナルすることはありません。あなたのコード内で明示的に<code class="literal">signal</code>(<a class="link" href="ch11s05.html#Definition-of-signal">Definition
of signal</a>を参照してください)を呼び出すことにより、これを行なうことができるのです。
</p><pre class="screen">(signal 'new-error '(x y))
     error→ A new error: x, y
</pre><p>このエラーは、エラーの任意のコンディション名により処理することができます。以下の例は、<code class="literal">new-error</code>とクラス<code class="literal">my-own-errors</code>内の他の任意のエラーを処理します:
</p><pre class="screen">(condition-case foo
    (bar nil t)
  (my-own-errors nil))
</pre><p>エラーが分類される有効な方法は、コンディション名による方法で、その名前はハンドラーのエラーのマッチに使用されます。エラーシンボルは、意図されたエラーメッセージと、コンディション名のリストを指定する便利な方法であるという役割だけです。1つのエラーシンボルではなく、コンディション名のリストを<code class="literal">signal</code>に与えるのは、面倒でしょう。
</p><p>対照的に、コンディション名を伴わずにエラーシンボルだけを使用した場合、それは<code class="literal">condition-case</code>の効果を著しく減少させるでしょう。コンディション名は、エラーハンドラーを記述するとき、一般性のさまざまなレベルにおいて、エラーをカテゴリー分けすることを可能にします。エラーシンボルを単独で使用することは、もっとも狭義なレベルの分類を除くすべてを捨てることです。
</p><p>主要なエラーシンボルと、それらのコンディションについては、<a class="link" href="apf.html" title="Appendix F. Standard Errors">Standard Errors</a>を参照してください。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Cleanups"/>Cleaning Up from Nonlocal Exits</h2></div></div></div><a id="idm51113424" class="indexterm"/><p><code class="literal">unwind-protect</code>構成は、データ構造を一時的に不整合な状態に置くときは、重要です。これはエラーやthrouのイベントにより、再びデータを整合された状態にすることができます(バッファー内容の変更だけに使用される、他のクリーンアップ構成は、アトミックな変更グループです。<a class="link" href="ch32s27.html" title="Atomic Change Groups">Atomic
Changes</a>を参照してください)。
</p><pre class="synopsis"><a id="idm51111120" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">unwind-protect</code> <em class="replaceable"><code>body-form</code></em> <em class="replaceable"><code>cleanup-forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm51107920" class="indexterm"/><a id="idm51107152" class="indexterm"/><a id="idm51106384" class="indexterm"/><a id="idm51105616" class="indexterm"/><p><code class="literal">unwind-protect</code>は、制御が<em class="replaceable"><code>body-form</code></em>を離れる場合に、<em class="replaceable"><code>cleanup-forms</code></em>が評価されるという保証の下、なにが起こった可に関わらず、<em class="replaceable"><code>body-form</code></em>を実行します。<em class="replaceable"><code>body-form</code></em>は通常どおり完了するかもしれず、<code class="literal">unwind-protect</code>の外で<code class="literal">throw</code>が実行されたり、エラーが発生するかもしれませんが、<em class="replaceable"><code>cleanup-forms</code></em>は評価されます。
</p><p><em class="replaceable"><code>body-form</code></em>が正常に終了した場合、<code class="literal">unwind-protect</code>は<em class="replaceable"><code>cleanup-forms</code></em>を評価した後で、<em class="replaceable"><code>body-form</code></em>の値をreturnします。<em class="replaceable"><code>body-form</code></em>が終了しなかった場合、<code class="literal">unwind-protect</code>は通常の意味における値は、returnしません。
</p><p><code class="literal">unwind-protect</code>により保護されるのは、<em class="replaceable"><code>body-form</code></em>だけです。<em class="replaceable"><code>cleanup-forms</code></em>自体の任意のフォームが、(<code class="literal">throw</code>またはエラーにより)非ローカルにexitした場合、<code class="literal">unwind-protect</code>は残りのフォームが評価されることを保証<span class="emphasis"><em>しません</em></span>。<em class="replaceable"><code>cleanup-forms</code></em>の中の1つが失敗することが問題となる場合は、そのフォームの周囲に他の<code class="literal">unwind-protect</code>を配して保護します。
</p><p>現在アクティブな<code class="literal">unwind-protect</code>フォーム数と、ローカルの変数バインディング数の和は、<code class="literal">max-specpdl-size</code>(<a class="link" href="ch12s03.html#Definition-of-max_002dspecpdl_002dsize">Local Variables</a>を参照してください)により制限されます。
</p></blockquote></div><p>たとえば、以下は一時的な使用のために不可視のバッファーを作成して、終了する前に確実にそのバッファーをkillする例です:
</p><pre class="screen">(let ((buffer (get-buffer-create " *temp*")))
  (with-current-buffer buffer
    (unwind-protect
        <em class="replaceable"><code>body-form</code></em>
      (kill-buffer buffer))))
</pre><p><code class="literal">(kill-buffer
(current-buffer))</code>のように記述して、変数<code class="literal">buffer</code>を使用せずに、同様のことを行えると思うかもしれません。しかし上の例は、別のバッファーにスイッチしたときに<em class="replaceable"><code>body-form</code></em>でエラーが発生した場合、より安全なのです(一時的なバッファーをkillするとき、そのバッファーがカレントとなることを確実にするために、かわりに<em class="replaceable"><code>body-form</code></em>の周囲に<code class="literal">save-current-buffer</code>を記述することもできます)。
</p><p>Emacsには、上のコードとおおよそ等しいコードに展開される、<code class="literal">with-temp-buffer</code>という標準マクロが含まれます(<a class="link" href="ch27s02.html#Definition-of-with_002dtemp_002dbuffer">Current
Buffer</a>を参照してください)。このマニュアル中で定義されるいくつかのマクロは、この方法で<code class="literal">unwind-protect</code>を使用します。
</p><a id="idm51078480" class="indexterm"/><p>以下は、FTPパッケージ由来の、実際の例です。これは、リモートマシンへの接続の確立を試みるために、プロセス(<a class="link" href="ch37.html" title="Chapter 36. Processes">Processes</a>を参照してください)を作成します。関数<code class="literal">ftp-login</code>は、関数のライター(writer)が予想できないことによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないと、Emacsは無用なサブプロセスで一杯になってしまうでしょう。
</p><pre class="screen">(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
</pre><p>この例には小さなバグがあります。ユーザーがquitするために<strong class="userinput"><code>C-g</code></strong>とタイプした場合、関数<code class="literal">ftp-setup-buffer</code>がreturnした後、即座にquitが発生しますが、それは変数<code class="literal">process</code>がセットされる前なので、そのプロセスはkillされないでしょう。このバグを簡単に訂正する方法はありませんが、少なくともこれは非常に稀なことだと言えます。









</p></div></div></body></html>