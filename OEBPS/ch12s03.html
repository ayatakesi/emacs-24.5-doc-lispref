<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Local Variables</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Local-Variables"/>Local Variables</h1></div></div></div><a id="idm51016528" class="indexterm"/><a id="idm51015760" class="indexterm"/><a id="idm51014992" class="indexterm"/><a id="idm51014224" class="indexterm"/><p>グローバル変数は、新しい値で明示的に置き換えるまで値が持続します。変数に<em class="firstterm">ローカル値(local value)</em> —
Lispプログラム内の特定の部分で効果をもつを与えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数がその値に<em class="firstterm">ローカルにバインド(locally
bound)</em>と言い、その変数を<em class="firstterm">ローカル変数(local variable)</em>と呼びます。
</p><p>たとえば、関数が呼び出されるとき、関数の引数となる変数はローカル値(その関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これらのローカルバインディングは、その関数のbody内で効果をもちます。他にも、たとえばスペシャルフォーム<code class="literal">let</code>は特定の変数にたいして明示的にローカルなバインディングを確立し、これは<code class="literal">let</code>フォームのbody内で効果を持ちます。
</p><p>これにたいして<em class="firstterm">グローバルなバインディング(global binding)</em>とは、(概念的には)グローバルな値が保持される場所です。
</p><a id="idm51009744" class="indexterm"/><p>ローカルバインディングを確立すると、その変数の以前の値は他の場所に保存されます(または失われます)。わたしたちはこれを、以前の値が<em class="firstterm">シャドーされた(shadowed)</em>と言います。シャドーはグローバル変数とローカル変数の両方で発生し得ます。ローカルバインディングが効果を持つとき、ローカル変数に<code class="literal">setq</code>を使用することにより、ローカルバインディングに指定された値を格納します。ローカルバインディングが効果を持たなくなったとき、以前にシャドーされた値が復元されます(または失われます)。
</p><a id="idm51007696" class="indexterm"/><p>変数は同時に複数のローカルバインディングを持つことができます(たとえばその変数をバインドするネストされた<code class="literal">let</code>)。<em class="firstterm">カレントバインディング(current
binding)</em>とは、実際に効果を持つローカルバインディングのことです。カレントバインディングは、その変数の評価によりreturnされる値を決定し、<code class="literal">setq</code>により影響を受けるバインディングです。
</p><p>ほとんどの用途において、“最内(innermost)”のローカルバインディング、ローカルバインディングがないときはグローバルバインディングを、カレントバインディングと考えることができます。より正確に言うと、<em class="firstterm">スコープルール(scoping
rule)</em>と呼ばれるルールは、プログラム内でローカルバインディングが効果を持つ任意の与えられた場所を決定します。Emacs
Lispのスコープルールは<em class="firstterm">ダイナミックスコープ(dynamic
scoping)</em>と呼ばれ、これは単に実行中のプログラム内の与えられた位置でのカレントバインディングを示し、その変数がまだ存在する場合は、その変数にたいしてもっとも最近作成されたバインディングです。ダイナミックスコープについての詳細と、その代替である<em class="firstterm">レキシカルスコープ(lexical
scoping)</em>と呼ばれるスコープルールについては、<a class="link" href="ch12s09.html" title="Scoping Rules for Variable Bindings">Variable Scoping</a>を参照してください。
</p><p>スペシャルフォーム<code class="literal">let</code>および<code class="literal">let*</code>は、ローカルバインディングを作成するために存在します:
</p><pre class="synopsis"><a id="idm51001424" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">let</code> (<em class="replaceable"><code>bindings</code></em><em class="replaceable"><code>…</code></em>) <em class="replaceable"><code>forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このスペシャルフォームは、<em class="replaceable"><code>bindings</code></em>により指定される特定の変数セットにたいするローカルバインディングをセットアップしてから、<em class="replaceable"><code>forms</code></em>のすべてをテキスト順に評価します。これは<em class="replaceable"><code>forms</code></em>内の最後のフォームの値をreturnします。
</p><p><em class="replaceable"><code>bindings</code></em>の各バインディングは2つの形式のどちらかです。(i)
シンボルの場合。この場合、そのシンボルは<code class="literal">nil</code>にローカルにバインドされます。(ii)
フォーム<code class="literal">(<em class="replaceable"><code>symbol</code></em>
<em class="replaceable"><code>value-form</code></em>)</code>のリストの場合。この場合<em class="replaceable"><code>symbol</code></em>は<em class="replaceable"><code>value-form</code></em>を評価した結果にローカルにバインドされます。<em class="replaceable"><code>value-form</code></em>が省略された場合は、<code class="literal">nil</code>が使用されます。
</p><p><em class="replaceable"><code>bindings</code></em>内のすべての<em class="replaceable"><code>value-form</code></em>は、シンボルがそれらにバインドされる<span class="emphasis"><em>前</em></span>に、記述された順番に評価されます。以下は例では、<code class="literal">z</code>は<code class="literal">y</code>の新しい場合(つまり1)にではなく、古い値(つまり2)にバインドされます。
</p><pre class="screen">(setq y 2)
     ⇒ 2
</pre><pre class="screen">
</pre><pre class="screen">(let ((y 1)
      (z y))
  (list y z))
     ⇒ (1 2)
</pre></blockquote></div><pre class="synopsis"><a id="idm50987728" class="indexterm"/><span class="category"><span class="bold"><strong>Special Form</strong></span>:</span> <code class="function">let*</code> (<em class="replaceable"><code>bindings</code></em><em class="replaceable"><code>…</code></em>) <em class="replaceable"><code>forms</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このスペシャルフォームは<code class="literal">let</code>と似ていますが、次の変数値にたいするローカル値を計算する前に、ローカル値を計算してそれを変数にバインドします。したがて、<em class="replaceable"><code>bindings</code></em>内の式は、この<code class="literal">let*</code>フォーム内の前のシンボルのバインドを参照できます。以下の例を、上記<code class="literal">let</code>の例と比較してください。
</p><pre class="screen">(setq y 2)
     ⇒ 2
</pre><pre class="screen">
</pre><pre class="screen">(let* ((y 1)
       (z y))    ; <code class="literal">y</code>の値に今計算されたばかりの値を使用する。
  (list y z))
     ⇒ (1 1)
</pre></blockquote></div><p>以下は、ローカルバインディングを作成する、他の機能のリストです:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>関数呼び出し(<a class="link" href="ch13.html" title="Chapter 12. Functions">Functions</a>を参照してください)。
</p></li><li class="listitem"><p>マクロ呼び出し(<a class="link" href="ch14.html" title="Chapter 13. Macros">Macros</a>を参照してください)。
</p></li><li class="listitem"><p><code class="literal">condition-case</code> (<a class="link" href="ch11s05.html#Errors" title="Errors">Errors</a>を参照してください)。
</p></li></ul></div><p>変数はバッファーローカルなバインディングを持つこともできます(<a class="link" href="ch12s10.html" title="Buffer-Local Variables">Buffer-Local
Variables</a>を参照してください)。数は多くありませんが、端末ローカル(terminal-local)なバインディングをもつ変数もあります(<a class="link" href="ch29s02.html" title="Multiple Terminals">Multiple
Terminals</a>を参照してください)これらの種類のバインディングは、通常のローカルバインディングのように機能することもありますが、これらはEmacs内の“どこ”であるかに依存してローカライズされます。
</p><pre class="synopsis"><a id="idm50974544" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">max-specpdl-size</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-max_002dspecpdl_002dsize"/><a id="idm50972240" class="indexterm"/><a id="idm50971472" class="indexterm"/><a id="idm50970704" class="indexterm"/><p>この変数は、ローカルな変数バインディングと、<code class="literal">unwind-protect</code>にゆるクリーンアップ(<a class="link" href="ch11s05.html#Cleanups" title="Cleaning Up from Nonlocal Exits">Cleaning Up from Nonlocal
Exits</a>の総数にたいする制限を定義し、この変数を越えるとEmacsはエラー(データに関するエラー<code class="literal">"Variable binding
depth exceeds max-specpdl-size"</code>)をシグナルします。
</p><p>このリミットは、もし超過したときにエラーが関連付けられている場合には、誤って定義された関数による無限再起を避けるための1つの方法になります。ネストの深さにたいする他の制限としては、<code class="literal">max-lisp-eval-depth</code>があります。<a class="link" href="ch10s05.html#Definition-of-max_002dlisp_002deval_002ddepth">Eval</a>を参照してください。
</p><p>デフォルト値は1300です。Lispデバッガーのエントリーしたとき、もし残りが少ないときは、デバッガーを実行するための空きを作るために、値は増加されます。
</p></blockquote></div></div></body></html>