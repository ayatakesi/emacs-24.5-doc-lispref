<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>When a Variable is “Void”</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Void-Variables"/>When a Variable is “Void”</h1></div></div></div><a id="idm50965072" class="indexterm"/><a id="idm50963920" class="indexterm"/><p>シンボルの値セル(<a class="link" href="ch09.html#Symbol-Components" title="Symbol Components">Symbol
Components</a>を参照してください)に値が割り当てられていない場合、その変数はvoid(空)であると言います。
</p><p>Emacs Lispのデフォルトであるダイナミックスコープルール(see <a class="link" href="ch12s09.html" title="Scoping Rules for Variable Bindings">Variable
Scoping</a>)の下では、値セルはその変数のカレント値(ローカルまたはグローバル)を保持します。値が割り当てられていない値セルは、値セルに<code class="literal">nil</code>をもつのとは<span class="emphasis"><em>異なる</em></span>ことに注意してください。シンボル<code class="literal">nil</code>はLispオブジェクトであり、他のオブジェクトと同様に変数の値となることができます。<code class="literal">nil</code>は値なのです。変数がvoidの場合、その変数の評価を試みると、値をreturnするかわりに、<code class="literal">void-variable</code>エラーがシグナルされます。
</p><p>オプションであるレキシカルスコープルール(lexical scoping rule)の下では、値セル保持できるのは、その変数のグローバル値 —
任意のレキシカルバインディング構造の外側の値だけです。変数がレキシカルにバインドされている場合、ローカル値はそのレキシカル環境により決定されます。したがって、これらのシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つことができます。
</p><pre class="synopsis"><a id="idm50958032" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">makunbound</code> <em class="replaceable"><code>symbol</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>symbol</code></em>の値セルを空にして、その変数をvoidにします。この関数は<em class="replaceable"><code>symbol</code></em>をreturnします。
</p><p><em class="replaceable"><code>symbol</code></em>がダイナミックなローカルバインディングを持つ場合、<code class="literal">makunbound</code>はカレントのバインディングをvoidにし、そのローカルバインディングが効果を持つ限りvoidにします。その後、前にシャドーされたローカル値(またはグローバル値)が再び有効になり、再び有効になった値がvoidでなければ、その変数はvoidでなくなります。
</p><p>いくつか例を示します(ダイナミックバインディングが有効だとします):
</p><pre class="screen">(setq x 1)               ; グローバルバインディングに値をセットする。
     ⇒ 1
(let ((x 2))             ; それをローカルにバインドする。
  (makunbound 'x)        ; ローカルバインディングをvoidにする。
  x)
error→ Symbol's value as variable is void: x
</pre><pre class="screen">x                        ; グローバルバインディングは変更されない。
     ⇒ 1

(let ((x 2))             ; ローカルにバインドする。
  (let ((x 3))           ; もう1度。
    (makunbound 'x)      ; 最内のローカルバインディングをvoidにする。
    x))                  ; それを参照すると、void。
error→ Symbol's value as variable is void: x
</pre><pre class="screen">
</pre><pre class="screen">(let ((x 2))
  (let ((x 3))
    (makunbound 'x))     ; 内側のバインディングをvoidにしてから取り除く。
  x)                     ; 外側の<code class="literal">let</code>バインディングが有効になる。
     ⇒ 2
</pre></blockquote></div><pre class="synopsis"><a id="idm50950352" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">boundp</code> <em class="replaceable"><code>variable</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>variable</code></em>(シンボル)がvoidでなければ<code class="literal">t</code>をreturnし、voidのときは<code class="literal">nil</code>をreturnします。
</p><p>いくつか例を示します(ダイナミックバインディングが有効だとします):
</p><pre class="screen">(boundp 'abracadabra)          ; 最初はvoid。
     ⇒ nil
</pre><pre class="screen">(let ((abracadabra 5))         ; ローカルにバインドする。
  (boundp 'abracadabra))
     ⇒ t
</pre><pre class="screen">(boundp 'abracadabra)          ; グローバルではまだvoid。
     ⇒ nil
</pre><pre class="screen">(setq abracadabra 5)           ; グローバルで非voidにする。
     ⇒ 5
</pre><pre class="screen">(boundp 'abracadabra)
     ⇒ t
</pre></blockquote></div></div></body></html>