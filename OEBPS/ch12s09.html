<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Scoping Rules for Variable Bindings</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Variable-Scoping"/>Scoping Rules for Variable Bindings</h1></div></div></div><a id="idm50761424" class="indexterm"/><p>ある変数にたいするローカルバインディングを作成するとき、そのバインディングはプログラムの限られた一部だけに効果をもちます(see <a class="link" href="ch12s03.html" title="Local Variables">Local
Variables</a>)。このセクションでは、これが正確には何を意味するかについて説明します。
</p><a id="idm50759760" class="indexterm"/><a id="idm50758992" class="indexterm"/><p>ローカルバインディングはそれぞれ、個別に<em class="firstterm">スコープ(scope: 範囲という意味)</em>と<em class="firstterm">エクステント(extent:
これも範囲を意味する)</em>をもちます。<em class="firstterm">スコープ</em>は、そのバインディングにアクセスできるのが、テキストのソースコードの<span class="emphasis"><em>どこ(where)</em></span>であるかを示します。<em class="firstterm">エクステント</em>は、プログラムの実行中に、そのバインディングが存在するのが<span class="emphasis"><em>いつ(when)</em></span>であるかを示します。
</p><a id="idm50755536" class="indexterm"/><a id="idm50754768" class="indexterm"/><a id="idm50754000" class="indexterm"/><p>デフォルトでは、Emacsが作成したローカルバインディングは、<em class="firstterm">ダイナミックバインディング(dynamic
binding)</em>です。このようなバインディングは、<em class="firstterm">ダイナミックスコープ(dynamic
scope)</em>をもち、それはプログラムの任意の範囲が、その変数バインディングにアクセスするかもしれないことを意味します。これは<em class="firstterm">ダイナミックエクステント(dynamic
extent)</em>ももちます。これはそのバインディング構造(<code class="literal">let</code>フォームのbodyなど)が実行される間だけ、そのバインディングが存続することを意味します。
</p><a id="idm50751056" class="indexterm"/><a id="idm50750288" class="indexterm"/><a id="idm50749520" class="indexterm"/><p>Emacsはオプションで<em class="firstterm">レキシカルバインディング(lexical
binding)</em>を作成することができます。レキシカルバインディングは<em class="firstterm">レキシカルスコープ(lexical
scope)</em>をもち、これはその変数にたいする任意の参照が、バインディング構造内にテキスト的に配置されなければならないことを意味します<a href="#ftn.idm50747728" class="footnote" id="idm50747728"><sup class="footnote">[7]</sup></a>。レキシカルバインディングは<em class="firstterm">不定エクステント(indefinite
extent)</em>ももちます。これは、ある状況下において、<em class="firstterm">クロージャー(closures)</em>と呼ばれるスペシャルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続を続けることを意味します。
</p><p>以降のサブセクションでは、ダイナミックバインディングとレキシカルバインディング、およびEmacs
Lispプログラムでレキシカルバインディングを有効にする方法について、より詳細に説明します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Dynamic-Binding"/>Dynamic Binding</h2></div></div></div><p>デフォルトでは、Emacsにより作成されるローカル変数のバインディングは、ダイナミックバインディングです。ある変数がダイナミックにバインドされていると、Lispプログラムの実行における任意のポイントでのカレントバインディングは、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカルバインディングか、そのようなローカルバインディングが存在しない場合はグローバルバインディングになります。
</p><p>以下の例のように、ダイナミックバインディングはダイナミックスコープとダイナミック&lt;エクステントをもちます:
</p><pre class="screen">(defvar x -99)  ; <code class="literal">x</code>は初期値として−99を受け取る。

(defun getx ()
  x)            ; この関数内では、<code class="literal">x</code>は“自由”に使用される。

(let ((x 1))    ; <code class="literal">x</code>はダイナミックにバインドされている。
  (getx))
     ⇒ 1

;; <code class="literal">let</code>フォームが終了した後、
;; <code class="literal">x</code>は前の値−99にリバートされる。

(getx)
     ⇒ -99
</pre><p>関数<code class="literal">getx</code>は<code class="literal">x</code>を参照します。<code class="literal">defun</code>構造自体の中に<code class="literal">x</code>にたいするバインディングが存在しないと意味において、これは“自由”な参照です。<code class="literal">x</code>が(ダイナミックに)バインドされている<code class="literal">let</code>フォーム内から<code class="literal">getx</code>を呼び出すと、ローカル値(つまり1)が取得されます。しかし、その後<code class="literal">let</code>フォームの外側から<code class="literal">getx</code>を呼び出すと、グローバル値(つまり−99)が取得されます。
</p><p>以下は、<code class="literal">setq</code>を使用してダイナミックに変数をバインドする、例をです:
</p><pre class="screen">(defvar x -99)      ; <code class="literal">x</code>は初期値として−99を受け取る。

(defun addx ()
  (setq x (1+ x)))  ; <code class="literal">x</code>に1追加して、新しい値をreturnする。

(let ((x 1))
  (addx)
  (addx))
     ⇒ 3           ; <code class="literal">addx</code>を2回呼び出すと、<code class="literal">x</code>に2回追加される。

;; <code class="literal">let</code>フォームが終了した後、
;; <code class="literal">x</code>は前の値−99にリバートされる。

(addx)
     ⇒ -98
</pre><p>Emacs
Lispでは、ダイナミックバインディングは、シンプルな方法で実装されています。それぞれのシンボルは、シンボルのカレントのダイナミック値(または値の不在)を指定する値セルをもちます。<a class="link" href="ch09.html#Symbol-Components" title="Symbol Components">Symbol
Components</a>を参照してください。あるシンボルがダイナミックなローカル値を与えられたとき、Emacsは値セルの内容(または値の不在)をスタックに記録し、新しいローカル値を値セルに格納します。バインディング構造が実行を終えたとき、Emacsはスタックから古い値をpopして、値セルにそれを置きます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Dynamic-Binding-Tips"/>Proper Use of Dynamic Binding</h2></div></div></div><p>ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルスコープ内で定義されていない変数を参照することを許す、強力な機能です。しかし、無制限に使用した場合は、プログラムの理解しにくくしてしまうこともあります。このテクニックを使用するために、2つの明解な方法があります:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ある変数がグローバルな定義をもたない場合は、ローカル変数としてバインディング構造内だけ(その変数がバインドされる<code class="literal">let</code>フォームのbodyなどの場所)でそれを使用します。プログラムでこの慣習に一貫してしたがえば、プログラム内の他の場所の同じ変数シンボルの任意の使用が、その変数の値に影響を与えたり、影響を受けることがなくなります。
</p></li><li class="listitem"><p>それ以外では、<code class="literal">defvar</code>、<code class="literal">defconst</code>、<code class="literal">defcustom</code>で変数を定義します。<a class="link" href="ch12s05.html" title="Defining Global Variables">Defining
Variables</a>を参照してください。この定義は通常、Emacs
Lispファイル内のトップレベルにあるべきです。この定義には可能な限り、変数の意味と目的を説明するドキュメント文字列を含めるべきです。名前の衝突を避けるように、変数を命名することも行うべきです(<a class="link" href="apd.html#Coding-Conventions" title="Emacs Lisp Coding Conventions">Coding
Conventions</a>を参照してください)。
</p><p>その後は、プログラム内のどこか別の場所で、それが何に影響するか確信をもって、変数をバインドすることができます。その変数にどこで出会っても、(たとえば、変数の定義がEmacsにロードされていれば、<strong class="userinput"><code>C-h
v</code></strong>コマンドを通じて)定義を参照するのが簡単になります。section “Name Help” in <em class="citetitle">The GNU Emacs
Manual</em>を参照してください。
</p><p>たとえば、<code class="literal">case-fold-search</code>のようなカスタマイズ可能な変数にたいしてローカルバインディングを使用するのは一般的です:
</p><pre class="screen">(defun search-for-abc ()
  "Search for the string \"abc\", ignoring case differences."
  (let ((case-fold-search nil))
    (re-search-forward "abc")))
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Lexical-Binding"/>Lexical Binding</h2></div></div></div><p>Emacsのバージョン24.1から、オプションの機能としてレキシカルバインディングが導入されました。わたしたちは、この機能の重要さが、将来において重要になることを期待します。レキシカルバインディングは最適化の機会をより広げるので、この機能を使用するプログラムはおそらく、将来のEmacsバージョンで高速に実行されるようになるでしょう。レキシカルバインディングは、わたしたちがEmacsに将来追加したいと考える並列性(concurrency)とも互換をもっています。
</p><p>レキシカルにバインドされた変数は<em class="firstterm">レキシカルスコープ(lexical scope)</em>をもいます。
これは、その変数にたいする参照は、そのバインディング構造内にテキスト的に配置されなければならないことを意味します。以下は例です
(実際にレキシカルバインディングを有功にする方法は、<a class="link" href="ch12s09.html#Using-Lexical-Binding" title="Using Lexical Binding">Using Lexical Binding</a>を参照してください):
</p><pre class="screen">(let ((x 1))    ; <code class="literal">x</code>はレキシカルにバインドされる。
  (+ x 3))
     ⇒ 4

(defun getx ()
  x)            ; この関数内では、<code class="literal">x</code>は“自由”に使用される。

(let ((x 1))    ; <code class="literal">x</code>はレキシカルにバインドされる。
  (getx))
error→ Symbol's value as variable is void: x
</pre><p>ここでは、<code class="literal">x</code>はグローバル値をもちません。<code class="literal">let</code>フォーム内でレキシカルにバインドされたとき、この変数は<code class="literal">let</code>のテキスト境界内で使用できます。しかし、この<code class="literal">let</code>内から呼び出される<code class="literal">getx</code>関数からは、<code class="literal">getx</code>の関数定義が<code class="literal">let</code>フォームの外側にあるので、使用することが<span class="emphasis"><em>できません</em></span>。
</p><a id="idm50705232" class="indexterm"/><p>レキシカルバインディングが機能する方法を説明します。各バインディング構造は、その構造および構造のローカル値でバインドされるシンボルを指定することにより、<em class="firstterm">レキシカル環境(lexical
environment)</em>を定義します。Lispの評価機能(Lisp
evaluator)がある変数のカレント値を得たいときは、最初にレキシカル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が格納されるシンボルの値セルを探します。
</p><p>(内部的には、レキシカル環境はシンボルと値がペアになったalistで、alistの最後の要素はコンスセルではなく、シンボル<code class="literal">t</code>です。そのようなalistは、フォームを評価するためのレキシカル環境を指定するために、<code class="literal">eval</code>関数の2番目の引数として渡すことができます。<a class="link" href="ch10s05.html" title="Eval">Eval</a>を参照してください。しかし、ほとんどのEmacs
Lispプログラムは、この方法で直接レキシカル環境を使用するべきではありません。デバッガーのような特化されたプログラムだけが使用すべきです。)
</p><a id="idm50701648" class="indexterm"/><p>レキシカルバインディングは、不定エクステント(indefinite
extent)をもちます。バインディング構造が終了した後でも、そのレキシカル環境は<em class="firstterm">クロージャー(closures)</em>と呼ばれるLispオブジェクト内に“保持”されます。クロージャーは、レキシカルバインディングが有効な、名前つきまたは無名(anonymous)の関数が作成されたときに作成されます。詳細は、<a class="link" href="ch13s09.html" title="Closures">Closures</a>を参照してください。
</p><p>クロージャーが関数として呼び出されたとき、その関数の定義内のレキシカル変数にたいする任意の参照は、レキシカル環境を維持するために使用されます。以下は例です:
</p><pre class="screen">(defvar my-ticker nil)   ; クロージャーを格納するために
                         ; この変数を使用する。

(let ((x 0))             ; <code class="literal">x</code>はレキシカルにバインドされる。
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    ⇒ (closure ((x . 0) t) ()
          (setq x (1+ x)))

(funcall my-ticker)
    ⇒ 1

(funcall my-ticker)
    ⇒ 2

(funcall my-ticker)
    ⇒ 3

x                        ; <code class="literal">x</code>はグローバル値をもたないことに注意。
error→ Symbol's value as variable is void: x
</pre><p><code class="literal">let</code>バインディングは、内部に変数<code class="literal">x</code>をもつレキシカル環境を定義し、これは0にローカルにバインドされます。このバインディング構造内で、<code class="literal">x</code>を1層化し、増加された値をreturnするクロージャーを定義しています。このラムダ式は自動的にクロージャーになり、たとえ<code class="literal">let</code>構造を抜けた後でも、その内部ではレキシカル環境が存続します。クロージャーを評価するときは毎回、レキシカル環境内の<code class="literal">x</code>のバインディングが使用され、<code class="literal">x</code>が増加されます。
</p><p><code class="literal">symbol-value</code>、<code class="literal">boundp</code>、<code class="literal">set</code>のような関数は、変数のダイナミックバインディング(つまりそのシンボルの値セル)だけを取得(または変更)することに注意してください。<code class="literal">defun</code>(または<code class="literal">defmacro</code>)のbody内のコードも、周囲のレキシカル変数は参照できません。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Using-Lexical-Binding"/>Using Lexical Binding</h2></div></div></div><p>Emacs
Lispファイルをロードしたり、Lispバッファーを評価するとき、バッファーローカルな変数<code class="literal">lexical-binding</code>が非<code class="literal">nil</code>の場合は、レキシカルバインディングが有効になります:
</p><pre class="synopsis"><a id="idm50676432" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">lexical-binding</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このバッファーローカルな変数が非<code class="literal">nil</code>の場合、Emacs
Lispファイルおよびバッファーは、ダイナミックバインディングではなくレキシカルバインディングを使用して評価されます(しかし、特別な変数はダイナミックにバインドされたままです。以下を参照してください)。<code class="literal">nil</code>の場合、すべてのローカル変数にたいしてダイナミックバインディングが使用されます。この変数は通常、ファイルローカル変数として、Emacs
Lispファイル全体にたいしてセットされます(<a class="link" href="ch12s11.html" title="File Local Variables">File Local
Variables</a>を参照してください)。他のファイルローカル変数などとは異なり、ファイルの最初の行でセットされなければならないことに注意してください。
</p></blockquote></div><p><code class="literal">eval</code>呼び出しを使用して、Emacs
Lispコードを直接評価するとき、<code class="literal">eval</code>の<em class="replaceable"><code>lexical</code></em>引数が非<code class="literal">nil</code>の場合は、レキシカルバインディングが有効になります。<a class="link" href="ch10s05.html" title="Eval">Eval</a>を参照してください。
</p><a id="idm50669776" class="indexterm"/><p>レキシカルバインディングが有効な場合でも、特定の変数はダイナミックにバインドされたままです。これらは<em class="firstterm">スペシャル変数(special
variable)</em>と呼ばれます。<code class="literal">defvar</code>、<code class="literal">defcustom</code>、<code class="literal">defconst</code>で定義されたすべての変数は、スペシャル変数です(<a class="link" href="ch12s05.html" title="Defining Global Variables">Defining
Variables</a>を参照してください)。その他のすべての変数はレキシカルバインディングの対象になります。
</p><pre class="synopsis"><a id="idm50665936" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">special-variable-p</code> <em class="replaceable"><code>symbol</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>symbol</code></em>がスペシャル変数(つまり変数が<code class="literal">defvar</code>、<code class="literal">defcustom</code>、<code class="literal">defconst</code>による定義をもつ)の場合は非<code class="literal">nil</code>をreturnします。それ以外では、return値は<code class="literal">nil</code>になります。
</p></blockquote></div><p>関数内での通常の引数としてスペシャル変数を使用することは、推奨されません。レキシカルバインディングモードが有効なときにこれを行うと、不定な動作が起こります(あるときはレキシカルバインディング、またあるときはダイナミックバインディングのように)。
</p><p>Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です。最初にEmacs
Lispソースファイルのヘッダー行で<code class="literal">lexical-binding</code>を<code class="literal">t</code>して、ファイルローカル変数を追加します(<a class="link" href="ch12s11.html" title="File Local Variables">File
Local
Variables</a>を参照してください)。次に、意図せずレキシカルにバインドしてしまわないように、ダイナミックなバインドをもつ必要がある変数が変数定義をもつことを、各変数ごとにチェックします。
</p><a id="idm50657744" class="indexterm"/><a id="idm50656976" class="indexterm"/><p>どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソースファイルをバイトコンパイルすることです。<a class="link" href="ch17.html" title="Chapter 16. Byte Compilation">Byte
Compilation</a>を参照してください。<code class="literal">let</code>フォームの外で非スペシャル変数が使用されている場合、バイトコンパイラーは“free
variable”にたいする参照または割り当てについて警告するでしょう。非スペシャル変数がバインドされているが、<code class="literal">let</code>フォーム内で使用されていない場合、バイトコンパイラーは“unused
lexical
variable”に関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数として使用している場合も、問題を警告します。
</p><p>(使用されていない変数についての警告を抑制するためには、単に変数名をアンダースコアーで開始します。そうすれば、バイトコンパイラーはこれを、変数が使用されないことを示すと解釈します。)
</p></div><div class="footnotes"><br/><hr/><div id="ftn.idm50747728" class="footnote"><p><a href="#idm50747728" class="para"><sup class="para">[7] </sup></a>これには、いくつか例外があります。たとえば、レキシカルバインディングは、Lispデバッガーからもアクセスできます。</p></div></div></div></body></html>