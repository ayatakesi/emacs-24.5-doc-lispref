<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Generalized Variables</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Generalized-Variables"/>Generalized Variables</h1></div></div></div><a id="idm54325072" class="indexterm"/><a id="idm54324304" class="indexterm"/><p><em class="firstterm">ジェネリック変数(generalized variable： 汎変数)</em>または<em class="firstterm">place
form</em>は、値が格納されるLispメモリー内の多くの場所のうちの1つです。1番シンプルなplace
formは、通常のLisp変数です。しかし、リストのCARとCDR、配列の要素、シンボルのプロパティー、その他多くのロケーション(location)も、Lisp値が格納される場所です。
</p><p>ジェネリック変数は、C言語の“lvalues(左辺値)”と類似しています。C言語のlvalueでは、‘<code class="literal">x =
a[i]</code>’で配列から要素を取得し、同じ表記を使用して、‘<code class="literal">a[i] =
x</code>’で要素を格納します。<code class="literal">a[i]</code>のような特定のフォームが、Cではlvalueになれるように、Lispでジェネリック変数になることができる一連のフォームが存在します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Setting-Generalized-Variables"/>The <code class="literal">setf</code> Macro</h2></div></div></div><p><code class="literal">setf</code>マクロは、ジェネリック変数を操作する、もっとも基本的な方法です。<code class="literal">setf</code>フォームは<code class="literal">setq</code>と似ていますが、シンボルだけでなく、左辺の任意のplace
formを受け入れます。たとえば<code class="literal">(setf (car a)
b)</code>は<code class="literal">a</code>のcarを<code class="literal">b</code>にセットして、<code class="literal">(setcar a
b)</code>と同じ操作を行いますが、すべてのplaceのタイプにセットおよびアクセスするために2つの別個の関数を覚える必要はありません。
</p><pre class="synopsis"><a id="idm54314960" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">setf</code> [<em class="replaceable"><code>place</code></em> <em class="replaceable"><code>form</code></em>]<em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは<em class="replaceable"><code>form</code></em>を評価して、それを<em class="replaceable"><code>place</code></em>に格納します。<em class="replaceable"><code>place</code></em>は有効なジェネリック変数フォームでなければなりません。複数の<em class="replaceable"><code>place</code></em>/<em class="replaceable"><code>form</code></em>ペアーがある場合、割り当ては<code class="literal">setq</code>のときと同様です。<code class="literal">setf</code>は最後の<em class="replaceable"><code>form</code></em>の値をreturnします。
</p></blockquote></div><p>以下のLispフォームはジェネリック変数として機能するので、<code class="literal">setf</code>の<em class="replaceable"><code>place</code></em>引数にすることができます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>変数を命名するシンボル。他の言い方をすると、<code class="literal">(setf x y)</code>は完全に<code class="literal">(setq x
y)</code>と等しく、厳密に言うと<code class="literal">setq</code>自体は<code class="literal">setf</code>が存在するので冗長です。これは純粋にスタイルと歴史的な理由によりますが、多くのプログラマーは依然として単純な変数へのセットには<code class="literal">setq</code>の方を好みます。マクロ<code class="literal">(setf
x y)</code>は、実際には<code class="literal">(setq x
y)</code>に展開されるので、コンパイルされたコードでこれを使用することにパフォーマンス的な不利はありません。
</p></li><li class="listitem"><p>以下の標準的なLisp関数の呼び出し:
</p><pre class="screen">aref      cddr      symbol-function
car       elt       symbol-plist
caar      get       symbol-value
cadr      gethash
cdr       nth
cdar      nthcdr
</pre></li><li class="listitem"><p>以下のEmacs特有な関数の呼び出し:
</p><pre class="screen">default-value                 process-get
frame-parameter               process-sentinel
terminal-parameter            window-buffer
keymap-parent                 window-display-table
match-data                    window-dedicated-p
overlay-get                   window-hscroll
overlay-start                 window-parameter
overlay-end                   window-point
process-buffer                window-start
process-filter
</pre></li></ul></div><p>どのように処理すれば良いか知られていない<em class="replaceable"><code>place</code></em>フォームを渡した場合、<code class="literal">setf</code>はエラーをシグナルします。
</p><p><code class="literal">nthcdr</code>の場合、関数のリスト引数は、それ自体が有効な<em class="replaceable"><code>place</code></em>フォームでなければならないことに注意してください。たとえば、<code class="literal">(setf
(nthcdr 0 foo) 7)</code>は、<code class="literal">foo</code>自体に7をセットするでしょう。
</p><p>マクロ<code class="literal">push</code>(<a class="link" href="ch06s05.html" title="Modifying List Variables">List Variables</a>を参照してください)、および<code class="literal">pop</code>(<a class="link" href="ch06s03.html" title="Accessing Elements of Lists">List
Elements</a>を参照してください)は、リストだけでなくジェネリック変数を操作できます。<code class="literal">(pop
<em class="replaceable"><code>place</code></em>)</code>は、<em class="replaceable"><code>place</code></em>内に格納されたリストの最初の要素を削除してreturnします。これは<code class="literal">(prog1
(car <em class="replaceable"><code>place</code></em>) (setf <em class="replaceable"><code>place</code></em> (cdr
<em class="replaceable"><code>place</code></em>)))</code>と類似していますが、すべてのサブフォームを1度だけ評価します。<code class="literal">(push <em class="replaceable"><code>x</code></em>
<em class="replaceable"><code>place</code></em>)</code>は、<em class="replaceable"><code>place</code></em>内に格納されたリストの1番前に、<em class="replaceable"><code>x</code></em>を挿入します。これは<code class="literal">(setf
<em class="replaceable"><code>place</code></em> (cons <em class="replaceable"><code>x</code></em>
<em class="replaceable"><code>place</code></em>))</code>と類似していますが、サブフォームの評価を除きます。<code class="literal">nthcdr</code>
placeへの<code class="literal">push</code>および<code class="literal">pop</code>は、リスト内の任意の位置での挿入および削除に使用できることに注意してください。
</p><p><code class="filename">cl-lib</code>ライブラリーは、追加の<code class="literal">setf</code>
placeを含む、ジェネリック変数ニタイスルサマザマナ拡張を定義します。section “Generalized Variables” in <em class="citetitle">Common
Lisp Extensions</em>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Adding-Generalized-Variables"/>Defining new <code class="literal">setf</code> forms</h2></div></div></div><p>このセクションでは、<code class="literal">setf</code>が操作できる新たなフォームを定義する方法を説明します。
</p><pre class="synopsis"><a id="idm54264144" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">gv-define-simple-setter</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>setter</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>fix-return</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは、単純なケースにたいして<code class="literal">setf</code>メソッドを簡単に定義することを可能にします。<em class="replaceable"><code>name</code></em>は、関数、マクロ、スペシャルフォームの名前です。<em class="replaceable"><code>name</code></em>が、それを更新するための対応する<em class="replaceable"><code>setter</code></em>関数をもつときは、このマクロを使用できます(たとえば<code class="literal">(gv-define-simple-setter
car setcar)</code>)。
</p><p>このマクロをフォーム以下の呼び出しを
</p><pre class="screen">(setf (<em class="replaceable"><code>name</code></em> <em class="replaceable"><code>args</code></em>…) <em class="replaceable"><code>value</code></em>)
</pre><p>以下のように変換します。
</p><pre class="screen">(<em class="replaceable"><code>setter</code></em> <em class="replaceable"><code>args</code></em>… <em class="replaceable"><code>value</code></em>)
</pre><p><code class="literal">setf</code>のような呼び出しは、<em class="replaceable"><code>value</code></em>をreturnするようにドキュメントされます。これに問題はありません。たとえば<code class="literal">car</code>と<code class="literal">setcar</code>では、<code class="literal">setcar</code>はそれがセットする値をreturnするからです。<em class="replaceable"><code>setter</code></em>関数が<em class="replaceable"><code>value</code></em>をreturnしない場合は、<code class="literal">gv-define-simple-setter</code>の<em class="replaceable"><code>fix-return</code></em>引数に、非<code class="literal">nil</code>値を使用してください。これは以下のようなものに展開されます
</p><pre class="screen">(let ((temp <em class="replaceable"><code>value</code></em>))
  (<em class="replaceable"><code>setter</code></em> <em class="replaceable"><code>args</code></em>… temp)
  temp)
</pre><p>これで正しい結果がreturnされることが保証されます。
</p></blockquote></div><pre class="synopsis"><a id="idm54246992" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">gv-define-setter</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>arglist</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>body</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは、上述のフォームより複雑な<code class="literal">setf</code>展開を可能にします。たとえば、呼び出すべきシンプルなsetter関数が存在しないときや、もしそれが存在してもplace
formとは異なる引数を要求する場合には、このフォームを使う必要があるかもしれません。
</p><p>このマクロは最初に<code class="literal">setf</code>引数フォーム<code class="literal">(<em class="replaceable"><code>value</code></em>
<em class="replaceable"><code>args</code></em>…)</code>を<em class="replaceable"><code>arglist</code></em>にバインドして、その後<em class="replaceable"><code>body</code></em>を実行することにより、フォーム<code class="literal">(setf
(<em class="replaceable"><code>name</code></em> <em class="replaceable"><code>args</code></em>…)
<em class="replaceable"><code>value</code></em>)</code>を展開します。<em class="replaceable"><code>body</code></em>は割り当てを行うLispフォームをreturnし、最後にセットされた値をreturnするべきです。以下はこのマクロの使用例です:
</p><pre class="screen">(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
</pre></blockquote></div><a id="idm54236880" class="indexterm"/><a id="idm54236112" class="indexterm"/><p>展開をさらに制御するには、マクロ<code class="literal">gv-define-expander</code>を参照してください。マクロ<code class="literal">gv-letplace</code>は、<code class="literal">setf</code>のように処理を行うマクロを定義するのに有用です。詳細は、<code class="filename">gv.el</code>のソースファイルを参照してください。
</p><a id="idm54232400" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意:</strong></span> Common
Lispは関数の<code class="literal">setf</code>、すなわち“<code class="literal">setf</code>関数”の挙動を指定するための別の方法を定義します。<code class="literal">setf</code>関数の名前はシンボルではなく。リスト<code class="literal">(setf
<em class="replaceable"><code>name</code></em>)</code>です。たとえば<code class="literal">(defun (setf foo)
…)</code>は、<code class="literal">setf</code>が<code class="literal">foo</code>に適用されるときに使用される関数を定義します。Emacsはこれをサポートしません。適切な展開が定義されていないフォームに<code class="literal">setf</code>を使用すると、コンパイル時にエラーとなります。Common
Lispでは、関数<code class="literal">(setf <em class="replaceable"><code>func</code></em>)</code>が後で定義されるので、エラーにはなりません。
</p></blockquote></div></div></div></body></html>