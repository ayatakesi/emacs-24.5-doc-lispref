<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lambda Expressions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Lambda-Expressions"/>Lambda Expressions</h1></div></div></div><a id="idm54117712" class="indexterm"/><p>ラムダ式(lambda expression)は、Lispで記述された関数オブジェクトです。以下は例です:
</p><pre class="screen">(lambda (x)
  "Xの双曲線コサインをreturnする。"
  (* 0.5 (+ (exp x) (exp (- x)))))
</pre><p>Emacs Lispでは、このようなリストは、関数オブジェクトに評価される、有効な式です。
</p><p>ラムダ式自身は名前をもたない、<em class="firstterm">無名関数(anonymous
function)</em>です。ラムダ式をこの方法で使用できますが(<a class="link" href="ch13s07.html" title="Anonymous Functions">Anonymous
Functions</a>を参照してください)、<em class="firstterm">名前付き関数(named
functions)</em>を作成するためにシンボルに関連付けられる方が一般的です(see <a class="link" href="ch13s03.html" title="Naming a Function">Function
Names</a>)。これらの詳細に触れる前に、以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Lambda-Components"/>Components of a Lambda Expression</h2></div></div></div><p>ラムダ式は、以下のようなリストです:
</p><pre class="screen">(lambda (<em class="replaceable"><code>arg-variables</code></em>…)
  [<em class="replaceable"><code>documentation-string</code></em>]
  [<em class="replaceable"><code>interactive-declaration</code></em>]
  <em class="replaceable"><code>body-forms</code></em>…)
</pre><a id="idm54110032" class="indexterm"/><p>ラムダ式の1番目の要素は常にシンボル<code class="literal">lambda</code>です。これは、そのリストが関数を表すことを示します。<code class="literal">lambda</code>で関数定義を開始する理由は、他の目的のたまえの使用が意図された他のリストが、意図せず関数として評価されないようにするためです。
</p><p>2番目の要素は、シンボル — 引数変数名のリストです。これは<em class="firstterm">ラムダリスト(lambda
list)</em>と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストは、与えられた値にたいするローカルバインディングが付与されます。<a class="link" href="ch12s03.html" title="Local Variables">Local
Variables</a>を参照してください。
</p><p>ドキュメント文字列(documentation string)はEmacs
Lispのヘルプ機能にたいしてその、関数を説明する、関数定義に配されたLisp文字列オブジェクトです。<a class="link" href="ch13s02.html#Function-Documentation" title="Documentation Strings of Functions">Function
Documentation</a>を参照してください。
</p><p>インタラクティブ宣言(interactive declaration)は、<code class="literal">(interactive
<em class="replaceable"><code>code-string</code></em>)</code>という形式のリストです。これは、この関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、<em class="firstterm">コマンド(command)</em>と呼ばれます。コマンドは<strong class="userinput"><code>M-x</code></strong>を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、See <a class="link" href="ch21s02.html" title="Defining Commands">Defining
Commands</a>を参照してください。
</p><a id="idm54098896" class="indexterm"/><p>残りの要素は、その関数の<em class="firstterm">body(本体)</em> —
その関数が処理を行うためのLispコード(Lispプログラマーは“評価されるLispフォームのリスト”と言うでしょう)です。この関数からreturnされる値は、bodyの最後の要素によりreturnされる値です。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Simple-Lambda"/>A Simple Lambda Expression Example</h2></div></div></div><p>以下の例を考えてみてください:
</p><pre class="screen">(lambda (a b c) (+ a b c))
</pre><p>以下のように、<code class="literal">funcall</code>に渡すことにより、この関数を呼び出すことができます:
</p><pre class="screen">(funcall (lambda (a b c) (+ a b c))
         1 2 3)
</pre><p>この呼び出しは、変数<code class="literal">a</code>に1、<code class="literal">b</code>に2、<code class="literal">c</code>に3をバインドして、ラムダ式のbodyを評価します。bodyの評価により、これら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより、6がreturnされます。
</p><p>以下のように、引数は他の関数の結果であってもよいことに注意してください:
</p><pre class="screen">(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
</pre><p>これは引数<code class="literal">1</code>、<code class="literal">(* 2 3)</code>、<code class="literal">(- 5
4)</code>を左から右に評価します。その後、ラムダ式に引数1、6、1を適用して、値8が生成されます。
</p><p>これらの例が示すように、ローカル変数を作成して、それらに値を与えるフォームとして、CARがラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在では、この目的にはフォーム<code class="literal">let</code>を使用するほうが明解です(<a class="link" href="ch12s03.html" title="Local Variables">Local
Variables</a>を参照してください)。ラムダ式は主に、他の関数の引数として渡される無名関数(<a class="link" href="ch13s07.html" title="Anonymous Functions">Anonymous
Functions</a>を参照してください)として、あるいは名前つき関数(<a class="link" href="ch13s03.html" title="Naming a Function">Function
Names</a>を参照してください)を生成するためにシンボルの関数定義に格納するために使用されます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Argument-List"/>Other Features of Argument Lists</h2></div></div></div><a id="idm54081488" class="indexterm"/><a id="idm54080720" class="indexterm"/><a id="idm54079952" class="indexterm"/><a id="idm54079184" class="indexterm"/><p>シンプルなサンプル関数<code class="literal">(lambda (a b c) (+ a b
c))</code>は、3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合は、<code class="literal">wrong-number-of-arguments</code>エラーとなります。
</p><p>特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数<code class="literal">substring</code>は3つの引数 —
文字列、開始インデックス、終了インデックス —
を受け取りますが、3つ目の引数を省略した場合、デフォルトでその文字列の<em class="replaceable"><code>length</code></em>となります。関数<code class="literal">list</code>や<code class="literal">+</code>が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。
</p><a id="idm54074576" class="indexterm"/><a id="idm54073808" class="indexterm"/><a id="idm54073040" class="indexterm"/><a id="idm54072272" class="indexterm"/><p>関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード<code class="literal">&amp;optional</code>を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード<code class="literal">&amp;rest</code>を含めます。
</p><p>したがって、引数リストの完全な構文は以下のようになります:
</p><pre class="screen">(<em class="replaceable"><code>required-vars</code></em>…
 [&amp;optional <em class="replaceable"><code>optional-vars</code></em>…]
 [&amp;rest <em class="replaceable"><code>rest-var</code></em>])
</pre><p>角カッコ(square
bracket)は、<code class="literal">&amp;optional</code>と<code class="literal">&amp;rest</code>、およびそれらに続く変数が省略できることを示します。
</p><p>この関数の呼び出しには、<em class="replaceable"><code>required-vars</code></em>のそれぞれにたいして、実際の引数が要求されます。0個以上の<em class="replaceable"><code>optional-vars</code></em>にたいして実際の引数があるかもしれませんが、ラムダ式が<code class="literal">&amp;rest</code>を使用していなければ、その個数を超えて実際の引数を記述することはできません。<code class="literal">&amp;rest</code>が記述されている場合、追加で任意個の実際の引数があるかもしれません。
</p><p>optionaやrest変数にたいして実際の引数が省略された場合、それらのデフォルトは常に<code class="literal">nil</code>になります。関数にたいして引数に明示的に<code class="literal">nil</code>が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、<code class="literal">nil</code>を他の有意な値が省略されたと判断することは自由です。これは<code class="literal">substring</code>が行っていることです。<code class="literal">substring</code>の3つ目の引数が<code class="literal">nil</code>の場合、それは文字列の長さを使用することを意味します。
</p><a id="idm54060624" class="indexterm"/><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>Common Lispに関する注意:</strong></span> Common
Lispでは、オプションの引数が省略されたときに使用するデフォルト値を指定できます。Emacs
Lispは、引数が明示的に渡されたかを調べる、“supplied-p”変数はサポートしません。
</p></blockquote></div><p>例えば、引数リストは以下のようになります:
</p><pre class="screen">(a b &amp;optional c d &amp;rest e)
</pre><p>これは<code class="literal">a</code>と<code class="literal">b</code>は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合、それらは順番に<code class="literal">c</code>と<code class="literal">d</code>にバインドされます。1つ目から4つ目の引数の後の引数は、リストにまとめられて、<code class="literal">e</code>にそのリストがバインドされます。2つしか引数が指定されなかった場合、<code class="literal">c</code>は<code class="literal">nil</code>になります。2つまたは3つの引数の場合、<code class="literal">d</code>は<code class="literal">nil</code>です。引数が4つ以下の場合、<code class="literal">e</code>は<code class="literal">nil</code>になります。
</p><p>オプションの引数の後ろに必須の引数を指定する方法はありません —
これは意味を成さないからです。なぜそうなるかは、この例で<code class="literal">c</code>がオプションで<code class="literal">d</code>が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか?
この引数は<em class="replaceable"><code>c</code></em>なのでしょうか、それとも<em class="replaceable"><code>d</code></em>に使用されるのでしょうか?
両方の場合が考えられます。同様に、<code class="literal">&amp;rest</code>引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。
</p><p>以下に引数リストと、それを正しく呼び出す例をいくつか示します:
</p><pre class="screen">(funcall (lambda (n) (1+ n))        ; 1つの必須:
         1)                         ; これは正確に1つの引数を要求する。
     ⇒ 2
(funcall (lambda (n &amp;optional n1)   ; 1つは必須で、1つはオプション:
           (if n1 (+ n n1) (1+ n))) ; 1つまたは2つの引数。
         1 2)
     ⇒ 3
(funcall (lambda (n &amp;rest ns)       ; 1つは必須で、後は残り:
           (+ n (apply '+ ns)))     ; 1つ以上の引数。
         1 2 3 4 5)
     ⇒ 15
</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Function-Documentation"/>Documentation Strings of Functions</h2></div></div></div><a id="idm54035024" class="indexterm"/><p>ラムダ式は、ラムダリストの食後に、オプションで<em class="firstterm">ドキュメント文字列(documentation
string)</em>をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですが、Lisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、<a class="link" href="ch24.html" title="Chapter 23. Documentation">Documentation</a>を参照してください。
</p><p>たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。
</p><p>ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら<code class="literal">apropos</code>は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する、1つまたは2つの完全なセンテンスで構成されるべきです。
</p><p>ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。<span class="emphasis"><em>これは、間違いです。</em></span>後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。
</p><p>ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれません。なぜなら、ドキュメント文字列の後には必須となる関数の構成要素であるbodyが続くからです。文字列を評価するとその文字列自身がれつｒｎされるので、それがbody内の最後のフォームでない限りなんの効果もありません。したがって、実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません。bodyの唯一のフォームが文字列の場合、それはreturn値とドキュメントの両方の役目を果たします。
</p><p>ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します
</p><pre class="screen">\(fn <em class="replaceable"><code>arglist</code></em>)
</pre><p>ただし、このテキストの前に空行があり、テキスト自身が行頭から記述されていて、ドキュメント文字列内でこのテキストの後に改行が続かない場合です(‘<code class="literal">\</code>’はEmacsの移動コマンドが混乱するのを避けるために使用されます)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。
</p><p>マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法と合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。
</p></div></div></body></html>