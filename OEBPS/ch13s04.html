<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Defining Functions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Defining-Functions"/>Defining Functions</h1></div></div></div><a id="idm54015312" class="indexterm"/><p>わたしたちは通常、関数を最初に作成したときに名前を与えます。これは<em class="firstterm">関数の定義(defining a
function)</em>と呼ばれ、<code class="literal">defun</code>マクロにより行われます。
</p><pre class="synopsis"><a id="idm54013008" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">defun</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>args</code></em> [<em class="replaceable"><code>doc</code></em>] [<em class="replaceable"><code>declare</code></em>] [<em class="replaceable"><code>interactive</code></em>] <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">defun</code>は新たなLisp関数を定義する通常の方法です。これは、引数リスト<em class="replaceable"><code>args</code></em>、および<em class="replaceable"><code>body</code></em>により与えられるbodyフォームとともに、シンボル<em class="replaceable"><code>name</code></em>を関数として定義します。<em class="replaceable"><code>name</code></em>と<em class="replaceable"><code>args</code></em>を、クォートする必要はありません。
</p><p><em class="replaceable"><code>doc</code></em>が与えられた場合、それはその関数のドキュメント文字列を指定する文字列であるべきです(<a class="link" href="ch13s02.html#Function-Documentation" title="Documentation Strings of Functions">Function
Documentation</a>を参照してください)。<em class="replaceable"><code>declare</code></em>が与えられた場合、それは関数のメタデータを指定する、<code class="literal">declare</code>フォームであるべきです(<a class="link" href="ch13s13.html" title="The declare Form">Declare
Form</a>を参照してください)。<em class="replaceable"><code>interactive</code></em>が与えられた場合、それは関数が対話的に呼び出される方法を指定する<code class="literal">interactive</code>フォームであるべきです(<a class="link" href="ch21s03.html" title="Interactive Call">Interactive
Call</a>を参照してください)。
</p><p><code class="literal">defun</code>のreturn値は定義されていません。
</p><p>以下にいくつか例を示します:
</p><pre class="screen">(defun foo () 5)
(foo)
     ⇒ 5
</pre><pre class="screen">
</pre><pre class="screen">(defun bar (a &amp;optional b &amp;rest c)
    (list a b c))
(bar 1 2 3 4 5)
     ⇒ (1 2 (3 4 5))
</pre><pre class="screen">(bar 1)
     ⇒ (1 nil nil)
</pre><pre class="screen">(bar)
error→ Wrong number of arguments.
</pre><pre class="screen">
</pre><pre class="screen">(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
</pre><p>意図せず既存の関数を再定義しないように、注意してください。<code class="literal">defun</code>は<code class="literal">car</code>のようなプリミティブ関数でさえ、躊躇なく問い合わせもなしに再定義します。Emacsががががこれを妨げることはありません。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はないからです。
</p></blockquote></div><a id="idm54000080" class="indexterm"/><a id="idm53999312" class="indexterm"/><pre class="synopsis"><a id="idm53998288" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">defalias</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>definition</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>doc</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-defalias"/><p>この関数は、定義<em class="replaceable"><code>definition</code></em>(任意の有効なLisp関数)とともに、シンボル<em class="replaceable"><code>name</code></em>を関数として定義します。この関数のreturn値は<span class="emphasis"><em>未定義</em></span>です。
</p><p><em class="replaceable"><code>doc</code></em>が非<code class="literal">nil</code>の場合、それは関数<em class="replaceable"><code>name</code></em>のドキュメントになります。それ以外は、<em class="replaceable"><code>definition</code></em>により提供されるドキュメントが使用されます。
</p><a id="idm53990736" class="indexterm"/><p>内部的には、<code class="literal">defalias</code>は通常、定義のセットに<code class="literal">fset</code>を使用します。しかし<em class="replaceable"><code>name</code></em>が<code class="literal">defalias-fset-function</code>プロパティーをもつ場合、<code class="literal">fset</code>を呼び出すかわりに、それに割り当てられた値が使用されます。
</p><p><code class="literal">defalias</code>を使う正しい場所は、特定の関数名がまさに定義される場所 —
特にソースファイルがロードされるとき明示的にその名前が出現する場所です。これは<code class="literal">defalias</code>が、<code class="literal">defun</code>と同じように、どれが関数を定義するファイルなのか記録するからです(<a class="link" href="ch16s09.html" title="Unloading">Unloading</a>を参照してください)。
</p><p>それとは対象的に、他の目的のために関数を操作するプログラムでは、そのような記録を保持しない<code class="literal">fset</code>を使用するほうがよいでしょう。<a class="link" href="ch13s08.html" title="Accessing Function Cell Contents">Function
Cells</a>を参照してください。
</p></blockquote></div><p><code class="literal">defun</code>や<code class="literal">defalias</code>で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである<code class="literal">car</code>や<code class="literal">x-popup-menu</code>のような関数でさえ変更することができます。しかし、これは危険なことです。たとえば、Lispの完全性を損なうことなく、<code class="literal">car</code>を再定義するのはほとんど不可能だからです。それほど有名ではない<code class="literal">x-popup-menu</code>のような関数の再定義では、危険は減るものの、それでも期待したとおりに機能しないかもしれません。Cコードにこのプリミティブの呼び出しがある場合、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更しても、それらに影響はありません。
</p><p><code class="literal">defsubst</code>も参照してください。これは<code class="literal">defun</code>のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。<a class="link" href="ch13s12.html" title="Inline Functions">Inline
Functions</a>を参照してください。
</p></div></body></html>