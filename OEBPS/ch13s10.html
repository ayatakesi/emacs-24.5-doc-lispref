<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Advising Emacs Lisp Functions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Advising-Functions"/>Advising Emacs Lisp Functions</h1></div></div></div><a id="idm53739728" class="indexterm"/><a id="idm53738960" class="indexterm"/><p>他のライブラリーの関数定義を変更する必要があるとき、または<code class="literal"><em class="replaceable"><code>foo</code></em>-function</code>oのようなフックやプロセスフィルター(process
filter)、または関数を値としてもつ任意の変数またはオブジェクトを変更する必要があるときには、名前つきの関数には<code class="literal">fset</code>か<code class="literal">defun</code>、フック変数には<code class="literal">setq</code>、プロセスフィルターには<code class="literal">set-process-filter</code>のように、適切なセッター関数(setter
function)を使用することができます。しかし、これらが以前の値を完全に破棄してしまうのが好ましくない場合もあります。
</p><p><em class="firstterm">アドバイス(advice)</em>機能により、<em class="firstterm">関数にアドバイス</em>することにより、既存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手法です。
</p><p>Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コアとなるセットは、変数やオブジェクトのフィールドに保持された関数値にたいするものです(対応するプリミティブは<code class="literal">add-function</code>と<code class="literal">remove-function</code>です)。もう1つのセットは、名前つき関数の最上位のレイヤーとなるものです(主要なプリミティブは<code class="literal">advice-add</code>と<code class="literal">advice-remove</code>です)。
</p><p>たとえば、プロセス<em class="replaceable"><code>proc</code></em>のプロセスフィルターの呼び出しをトレースするためには、以下を使用できます:
</p><pre class="screen">(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter <em class="replaceable"><code>proc</code></em>) #'my-tracing-function)
</pre><p>これにより、そのプロセスの出力は、元のプロセスフィルターに渡される前に、<code class="literal">my-tracing-function</code>に渡されるようになります。<code class="literal">my-tracing-function</code>は元の関数と同じ引数を受け取ります。これを行った場合、以下のようにしてトレースを行わない振る舞いにリバートすることができます。
</p><pre class="screen">(remove-function (process-filter <em class="replaceable"><code>proc</code></em>) #'my-tracing-function)
</pre><p>同様に、<code class="literal">display-buffer</code>という名前つきの関数の実行をトレースしたい場合は、以下を使用できます:
</p><pre class="screen">(defun his-tracing-function (orig-fun &amp;rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
</pre><p>ここで、<code class="literal">his-tracing-function</code>は元の関数のかわりに呼び出され、元の関数(加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び出すことができます。出力を確認し終えたら、以下のようにしてトレースしない振る舞いにリバートできます:
</p><pre class="screen">(advice-remove 'display-buffer #'his-tracing-function)
</pre><p>上記の例で使用されている引数<code class="literal">:before</code>と<code class="literal">:around</code>は、2つの関数が構成される方法を指定します(これを行うには多くの方法があるからです)。追加された関数も、<span class="emphasis"><em>アドバイス(advice)</em></span>と呼ばれます。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Core-Advising-Primitives"/>Primitives to manipulate advices</h2></div></div></div><a id="idm53717968" class="indexterm"/><pre class="synopsis"><a id="idm53716944" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">add-function</code> <em class="replaceable"><code>where</code></em> <em class="replaceable"><code>place</code></em> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>props</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは<em class="replaceable"><code>place</code></em>(<a class="link" href="ch12s15.html" title="Generalized Variables">Generalized
Variables</a>を参照してください)に格納された関数に、アドバイス<em class="replaceable"><code>function</code></em>を追加する手軽な方法です。
</p><p><em class="replaceable"><code>where</code></em>は、既存の関数のどこに — たとえば元の関数の前、または後に —
<em class="replaceable"><code>function</code></em>が構成されるかを決定します。2つの関数を構成するために利用可能な方法のリストは、<a class="link" href="ch13s10.html#Advice-combinators" title="Ways to compose advices">Advice
combinators</a>を参照してください。
</p><p>(通常は名前が<code class="literal">-function</code>で終わる)変数を変更するときには、<em class="replaceable"><code>function</code></em>がグローバルに使用されるか、あるいはカレントバッファーだけに使用されるか選ぶことができます。<em class="replaceable"><code>place</code></em>が単にシンボルの場合、<em class="replaceable"><code>function</code></em>は<em class="replaceable"><code>place</code></em>のグローバル値に追加されます。<em class="replaceable"><code>place</code></em>が<code class="literal">(local
<em class="replaceable"><code>symbol</code></em>)</code>というフォームの場合、<em class="replaceable"><code>symbol</code></em>はその変数の名前をreturnする式なので、<em class="replaceable"><code>function</code></em>はカレントバッファーだけに追加されます。最後に、レキシカル変数を変更したい場合には、<code class="literal">(var
<em class="replaceable"><code>variable</code></em>)</code>を使用する必要があるでしょう。
</p><p><code class="literal">add-function</code>で追加されたすべての関数は、自動的にプロパティー<em class="replaceable"><code>props</code></em>の関連リストに加えることができます。現在のところ、特別な意味をもつのは2つのプロパティーだけです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">name</code>
</span></dt><dd><p>これはアドバイスの名前を与えます。この名前は、<code class="literal">remove-function</code>が取り除く関数を識別するのに使用できます。これは通常、<em class="replaceable"><code>function</code></em>が無名関数のときに使用されます。
</p></dd><dt><span class="term"><code class="literal">depth</code>
</span></dt><dd><p>これは複数のアドバイスが与えられたときに、どのようにアドバイスを順番づけるかを指定します。depthのデフォルト0です。depthが100のとき、このアドバイスは可能な限りの深さを保持すべきことを意味し、-100のときは最外のアドバイスに留めることを意味します。同じdepthで2つのアドバイスが指定された場合、もっとも最近に追加されたアドバイスが最外になります。
</p><p><code class="literal">:before</code>アドバイスにたいしては、最外(outermost)になるということは、このアドバイスが他のアドバイスの前、つまり1番目に実行されることを意味し、最内(innermost)とは元の関数が実行される直前、すなわちこのアドバイスと元の関数の間に実行されるアドバイスは存在しないことを意味します。同様に<code class="literal">:after</code>アドバイスにたいしては、最内とは元の関数の直後、つまりこの元の関数とアドバイスの間に実行される他のアドバイスは存在せず、最外とは他のすべてのアドバイスが実行された後にこのアドバイスが実行されることを意味します。<code class="literal">:override</code>の最内アドバイスは、元の関数だけをオーバーライドし、他のアドバイスは適用されませんが、<code class="literal">:override</code>の最外アドバイスは元の関数だけではなく。その他すべての適用済みのアドバイスををオーバーライドします。
</p></dd></dl></div><p><em class="replaceable"><code>function</code></em>がインタラクティブでない場合、欠オグされた関数は、(もしあれば)元の関数のインタラクティブ指定(interactive
spec)を継承します。それ以外は、結合された関数はインタラクティブになり、<em class="replaceable"><code>function</code></em>のインタラクティブ指定を使用します。1つ例外があります。<em class="replaceable"><code>function</code></em>のインタラクティブ指定が、(式や文字列ではない)関数の場合、元の関数のインタラクティブ指定を唯一の引数として、その関数を呼び出して、それが結合された関数のインタラクティブ指定になります。引数として受け取ったインタラクティブ指定を解釈するためには、<code class="literal">advice-eval-interactive-spec</code>を使用します。
</p><p>注意:
<em class="replaceable"><code>function</code></em>のインタラクティブ指定は結合された関数に適用され、<em class="replaceable"><code>function</code></em>ではなく、結合された関数の呼び出し規約に従うべきです。多くの場合、これらは等しいので差異は生じませんが、<em class="replaceable"><code>function</code></em>の<code class="literal">:around</code>、<code class="literal">:filter-args</code>、<code class="literal">filter-return</code>では、重要になります。
</p></blockquote></div><pre class="synopsis"><a id="idm53667152" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">remove-function</code> <em class="replaceable"><code>place</code></em> <em class="replaceable"><code>function</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは<em class="replaceable"><code>place</code></em>に格納された関数から、<em class="replaceable"><code>function</code></em>を取り除きます。これは、<code class="literal">add-function</code>を使用して、<em class="replaceable"><code>function</code></em>が<em class="replaceable"><code>place</code></em>に追加されたときだけ機能します。
</p><p><em class="replaceable"><code>function</code></em>は、<em class="replaceable"><code>place</code></em>に追加された関数にたいして、ラムダ式にたいしても機能するように、<code class="literal">equal</code>を使用して比較を試みます。これは追加で<em class="replaceable"><code>place</code></em>に追加された関数の<code class="literal">name</code>プロパティーも比較します。これは<code class="literal">equal</code>を使用してラムダ式を比較するより信頼性があります。
</p></blockquote></div><pre class="synopsis"><a id="idm53658576" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-function-member-p</code> <em class="replaceable"><code>advice</code></em> <em class="replaceable"><code>function-def</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><em class="replaceable"><code>advice</code></em>がすでに<em class="replaceable"><code>function-def</code></em>内にある場合は、非<code class="literal">nil</code>をreturnします。上記の<code class="literal">remove-function</code>と同様、実際の関数<em class="replaceable"><code>advice</code></em>のかわりに、アドバイス断片(piece
of advice)の<code class="literal">name</code>も使用できます。
</p></blockquote></div><pre class="synopsis"><a id="idm53652432" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-function-mapc</code> <em class="replaceable"><code>f</code></em> <em class="replaceable"><code>function-def</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><em class="replaceable"><code>function-def</code></em>に追加されたすべてのアドバイスに対して、関数<em class="replaceable"><code>f</code></em>を呼び出します。<em class="replaceable"><code>f</code></em>は2つの引数 —
アドバイス関数と、それのプロパティーで呼びだされます。
</p></blockquote></div><pre class="synopsis"><a id="idm53647824" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-eval-interactive-spec</code> <em class="replaceable"><code>spec</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>そのような指定で関数がインタラクティブに呼び出されたように、インタラクティブ指定<em class="replaceable"><code>spec</code></em>を評価して、構築された引数のリストに対応するリストをreturnします。たとえば、<code class="literal">(advice-eval-interactive-spec
"r\nP")</code>は、リージョンの境界、カレントプレフィクス引数を含む、3つの要素からなるリストをreturnします。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Advising-Named-Functions"/>Advising Named Functions</h2></div></div></div><a id="idm53642832" class="indexterm"/><p>アドバイスの一般的な使い方は、名前つき関数やマクロにたいして使用する方法です。これは単に<code class="literal">add-function</code>を使用して以下のように行うことができます:
</p><pre class="screen">(add-function :around (symbol-function '<em class="replaceable"><code>fun</code></em>) #'his-tracing-function)
</pre><p>しかし、かわりに<code class="literal">advice-add</code>と<code class="literal">advice-remove</code>を使うべきです。この別の関数セットは名前つき関数に適用されるアドバイス断片を操作するためのもので、<code class="literal">add-function</code>と比較して以下の追加機能があります。まず、これらはマクロおよびオートロードされた関数を扱う方法を知っています。次に、<code class="literal">describe-function</code>にたいして、追加されたアドバイスと同様に、元のドキュメント文字列を維持します。さらに、関数が定義される前でも、アドバイスの追加と削除ができます。
</p><p>既存の関数を関数全体を再定義せずに、既存の呼び出しを変更するために、<code class="literal">advice-add</code>は有用になります。しかし、その関数の既存の呼び出し元は、古い振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更されたときに正しく機能しないかもしれないので、これはソースのバグにもなり得ます。アドバイスはデバッグを難しくする可能性もあります。デバッグを行う人は、その関数がアドバイスにより変更されたことに気づかなかったり、失念しているかもしれません。
</p><p>これらの理由により、他の方法で関数の振る舞いを変更できない場合のために、アドバイスの使用は控えるべきです。フックを通じて同じことが行えるなら、フック(<a class="link" href="ch23.html#Hooks" title="Hooks">Hooks</a>を参照してください)の使用が望ましい方法です。特定のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマンドのキーバインドを新しいコマンドにリマップ(<a class="link" href="ch22s13.html" title="Remapping Commands">Remapping
Commands</a>を参照してください)するのが、おそらくより良い方法です。特に、Emacs自身のソースファイルは、Emacs内の関数をアドバイスするべきではありません(現在のところこの慣習には数少ない例外がありますが、わたしたちはこれを改善しようと思っています)。
</p><p>スペシャルフォーム(<a class="link" href="ch10s02.html#Special-Forms" title="Special Forms">Special
Forms</a>を参照してください)はアドバイスできませんが、マクロは関数と同じ方法でアドバイスできます。もちろん、これはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバイスが確実にインストールされる必要があります。
</p><p>プリミティブ(<a class="link" href="ch13.html#What-Is-a-Function" title="What Is a Function?">What Is a
Function</a>を参照してください)にアドバイスするのは可能ですが、2つの理由により通常は行うべきでは<span class="emphasis"><em>ありません</em></span>。1つ目の理由は、いくつかのプリミティブはアドバイスのメカニズム内で使用されているため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。2つ目の理由は、多くのプリミティブがCから直接呼び出されていて、そのような呼び出しはアドバイスを無視するからです。したがって、プリミティブにたいしてアドバイスの使用を控えることは、ある呼び出しはアドバイスにしたがい(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわない(Cコードから呼び出されたため)という混乱した状況を解決します。
</p><pre class="synopsis"><a id="idm53628880" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-add</code> <em class="replaceable"><code>symbol</code></em> <em class="replaceable"><code>where</code></em> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>props</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>名前つき関数<em class="replaceable"><code>symbol</code></em>に、アドバイス<em class="replaceable"><code>function</code></em>を追加します。<em class="replaceable"><code>where</code></em>と<em class="replaceable"><code>props</code></em>は、<code class="literal">add-function</code>(<a class="link" href="ch13s10.html#Core-Advising-Primitives" title="Primitives to manipulate advices">Core
Advising Primitives</a>を参照してください)のときと同じ意味をもちます。
</p></blockquote></div><pre class="synopsis"><a id="idm53621584" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-remove</code> <em class="replaceable"><code>symbol</code></em> <em class="replaceable"><code>function</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>名前つき関数<em class="replaceable"><code>symbol</code></em>からアドバイス<em class="replaceable"><code>function</code></em>を取り除きます。<em class="replaceable"><code>function</code></em>にアドバイスの<code class="literal">name</code>を指定することもできます。
</p></blockquote></div><pre class="synopsis"><a id="idm53616336" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-member-p</code> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>symbol</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>名前つき関数<em class="replaceable"><code>symbol</code></em>内にすでにアドバイス<em class="replaceable"><code>function</code></em>がある場合は、非<code class="literal">nil</code>をreturnします。<em class="replaceable"><code>function</code></em>にアドバイスの<code class="literal">name</code>を指定することもできます。
</p></blockquote></div><pre class="synopsis"><a id="idm53610576" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">advice-mapc</code> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>symbol</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>名前つき関数<em class="replaceable"><code>symbol</code></em>にすでに追加されたすべての関数にたいして、<em class="replaceable"><code>function</code></em>を呼び出します。<em class="replaceable"><code>function</code></em>は2つの引数、アドバイス関数と、そのプロパティーで呼び出されます。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Advice-combinators"/>Ways to compose advices</h2></div></div></div><p>以下は<code class="literal">add-function</code>および<code class="literal">advice-add</code>の<em class="replaceable"><code>where</code></em>引数に可能な値で、そのアドバイス<em class="replaceable"><code>function</code></em>と元の関数が構成されるべき方法を指定します。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:before</code>
</span></dt><dd><p>古い関数の前に<em class="replaceable"><code>function</code></em>を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (apply <em class="replaceable"><code>function</code></em> r) (apply <em class="replaceable"><code>oldfun</code></em> r))
</pre><p><code class="literal">(add-function :before <em class="replaceable"><code>funvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>は、ノーマルフックにたいする<code class="literal">(add-hook '<em class="replaceable"><code>hookvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:after</code>
</span></dt><dd><p>古い関数の後に<em class="replaceable"><code>function</code></em>を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (prog1 (apply <em class="replaceable"><code>oldfun</code></em> r) (apply <em class="replaceable"><code>function</code></em> r)))
</pre><p><code class="literal">(add-function :after <em class="replaceable"><code>funvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>は、ノーマルフックにたいする<code class="literal">(add-hook '<em class="replaceable"><code>hookvar</code></em> <em class="replaceable"><code>function</code></em>
'append)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:override</code>
</span></dt><dd><p>これは古い関数を新しい関数に完全に置き換えます。もちろん、<code class="literal">remove-function</code>を呼び出した後に、古い関数は復元されます。
</p></dd><dt><span class="term"><code class="literal">:around</code>
</span></dt><dd><p>古い関数のかわりに<em class="replaceable"><code>function</code></em>を呼び出しますが、古い関数は<em class="replaceable"><code>function</code></em>の追加の引数になります。これはもっとも柔軟な結合です。たとえば、古い関数を異なる引数で呼び出したり、複数回呼び出したり、letバインディングで呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完全にオーバーライドすることが可能になります。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (apply <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>oldfun</code></em> r))
</pre></dd><dt><span class="term"><code class="literal">:before-while</code>
</span></dt><dd><p>古い関数の前に<em class="replaceable"><code>function</code></em>を呼び出し、<em class="replaceable"><code>function</code></em>が<code class="literal">nil</code>をreturnした場合は古い関数を呼び出しません。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (and (apply <em class="replaceable"><code>function</code></em> r) (apply <em class="replaceable"><code>oldfun</code></em> r)))
</pre><p><code class="literal">(add-function :before-while <em class="replaceable"><code>funvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>は、<code class="literal">run-hook-with-args-until-failure</code>を通じて<em class="replaceable"><code>hookvar</code></em>が実行されたときの<code class="literal">(add-hook
'<em class="replaceable"><code>hookvar</code></em> <em class="replaceable"><code>function</code></em>)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:before-until</code>
</span></dt><dd><p>古い関数の前に<em class="replaceable"><code>function</code></em>を呼び出し、<em class="replaceable"><code>function</code></em>が<code class="literal">nil</code>をreturnした場合だけ古い関数を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (or (apply <em class="replaceable"><code>function</code></em> r) (apply <em class="replaceable"><code>oldfun</code></em> r)))
</pre><p><code class="literal">(add-function :before-until <em class="replaceable"><code>funvar</code></em> <em class="replaceable"><code>function</code></em>)</code>
は、<code class="literal">run-hook-with-args-until-success</code>を通じて<em class="replaceable"><code>hookvar</code></em>が実行されたときの<code class="literal">(add-hook
'<em class="replaceable"><code>hookvar</code></em> <em class="replaceable"><code>function</code></em>)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:after-while</code>
</span></dt><dd><p>古い関数が非<code class="literal">nil</code>をreturnした場合だけ、古い関数の後に<em class="replaceable"><code>function</code></em>を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、<em class="replaceable"><code>function</code></em>のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (and (apply <em class="replaceable"><code>oldfun</code></em> r) (apply <em class="replaceable"><code>function</code></em> r)))
</pre><p><code class="literal">(add-function :after-while <em class="replaceable"><code>funvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>は、<code class="literal">run-hook-with-args-until-failure</code>を通じて<em class="replaceable"><code>hookvar</code></em>が実行されたときの<code class="literal">(add-hook
'<em class="replaceable"><code>hookvar</code></em> <em class="replaceable"><code>function</code></em> 'append)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:after-until</code>
</span></dt><dd><p>古い関数が<code class="literal">nil</code>をreturnした場合だけ、古い関数の後に<em class="replaceable"><code>function</code></em>を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (or  (apply <em class="replaceable"><code>oldfun</code></em> r) (apply <em class="replaceable"><code>function</code></em> r)))
</pre><p><code class="literal">(add-function :after-until <em class="replaceable"><code>funvar</code></em>
<em class="replaceable"><code>function</code></em>)</code>は、<code class="literal">run-hook-with-args-until-success</code>を通じて<em class="replaceable"><code>hookvar</code></em>が実行されたときの<code class="literal">(add-hook
'<em class="replaceable"><code>hookvar</code></em> <em class="replaceable"><code>function</code></em> 'append)</code>のような、1関数のフックと同等です。
</p></dd><dt><span class="term"><code class="literal">:filter-args</code>
</span></dt><dd><p>最初に<em class="replaceable"><code>function</code></em>を呼び出し、その結果(リスト)を新たな引数として古い関数に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (apply <em class="replaceable"><code>oldfun</code></em> (funcall <em class="replaceable"><code>function</code></em> r)))
</pre></dd><dt><span class="term"><code class="literal">:filter-return</code>
</span></dt><dd><p>最初に古い関数を呼び出し、その結果を<em class="replaceable"><code>function</code></em>に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
</p><pre class="screen">(lambda (&amp;rest r) (funcall <em class="replaceable"><code>function</code></em> (apply <em class="replaceable"><code>oldfun</code></em> r)))
</pre></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Porting-old-advices"/>Adapting code using the old defadvice</h2></div></div></div><a id="idm53538640" class="indexterm"/><p>多くのコードは古い<code class="literal">defadvice</code>メカニズムを使用しており、これらの大半は<code class="literal">advice-add</code>により陳腐化しました。<code class="literal">advice-add</code>の実装と意味は、とてもシンプルです。
</p><p>古いアドバイスは以下のようなものです:
</p><pre class="screen">(defadvice previous-line (before next-line-at-end
                                 (&amp;optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
</pre><p>新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できます:
</p><pre class="screen">(defun previous-line--next-line-at-end (&amp;optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
</pre><p>これが実際の<code class="literal">previous-line</code>を変更しないことは明確です。古いアドバイスには、以下が必要です:
</p><pre class="screen">(ad-activate 'previous-line)
</pre><p>一方、新しいアドバイスメカニズムでは、以下が必要です:
</p><pre class="screen">(advice-add 'previous-line :before #'previous-line--next-line-at-end)
</pre><p><code class="literal">ad-activate</code>はグローバルな効果をもつことに注意してください。これは、指定された関数にたいして、アドバイスのすべての断片を有効にします。特定のアドバイスだけをアクティブ、または非アクティブにしたい場合、<code class="literal">ad-enable-advice</code>、または<code class="literal">ad-disable-advice</code>により、<span class="emphasis"><em>有効</em></span>または<span class="emphasis"><em>無効</em></span>にする必要があります。新しいメカニズムではこの区別はなくなりました。
</p><p>以下のようなaroundのアドバイスがあるとします:
</p><pre class="screen">(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
</pre><p>これは以下のように変換できます:
</p><pre class="screen">(defun foo--foo-around (orig-fun &amp;rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
</pre><p>アドバイスの<span class="emphasis"><em>クラス</em></span>について、新たな<code class="literal">:before</code>は、古い<code class="literal">before</code>は完全に等価ではないことに注意してください。なぜなら古いアドバイス内では、(たとえば<code class="literal">ad-set-arg</code>を使って)その関数の引数を変更できそれは元の関数が参照する引数値に影響します。しかし新しい<code class="literal">:before</code>は、<code class="literal">setq</code>を通じてアドバイス内の引数をし、その変更は元の関数からの参照に影響しません。この振る舞いにもとづいて<code class="literal">before</code>アドバイスを移行するときは、代わりにそれを新たなアドバイス<code class="literal">:around</code>または<code class="literal">:filter-args</code>に変更する必要があるでしょう。
</p><p>同様に、古い<code class="literal">after</code>アドバイスは、<code class="literal">ad-return-value</code>を変更することによりreturn値を変更できますが、新しい<code class="literal">:after</code>は変更できないので、そのような<code class="literal">after</code>を移行するときは、かわりにそれらを新しいアドバイス<code class="literal">:around</code>または<code class="literal">:filter-return</code>に変更する必要があるでしょう。
</p></div></div></body></html>