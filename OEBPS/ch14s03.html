<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Macros and Byte Compilation</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Compiling-Macros"/>Macros and Byte Compilation</h1></div></div></div><a id="idm53230288" class="indexterm"/><p>なぜわざわざマクロにたいする展開形を計算して、その後に展開形を評価する手間をかけるのか、不思議に思うかもしれません。なぜマクロbodyは直接望ましい結果を生成しないのでしょうか?
それはコンパイルする必要があるからです。
</p><p>コンパイルされるLispプログラム内にマクロ呼び出しがあるとき、Lispコンパイラーはインタープリターが行うようにマクロ定義を呼び出して、展開形を受け取ります。しかし展開形を評価するかわりに、コンパイラーは展開形が直接プログラム内にあるかのようにコンパイルを行います。結果として、コンパイルされたコードはそのマクロにたいする値と副作用を生成しますが、実行速度は完全にコンパイルされた行されたときと同じになります。もしマクロbody自身が値と副作用を計算したら。このようには機能しません
— コンパイル時に計算されることになり、それは有用ではありません。
</p><p>マクロ呼び出しのコンパイルが機能するためには、マクロを呼び出すコードがコンパイルされるとき、そのマクロがLisp内ですでに定義されていなければなりません。コンパイラーには、これを行うのを助ける特別な機能があります。コンパイルされるファイルが<code class="literal">defmacro</code>フォームを含む場合、そのファイルの残りの部分をコンパイルするために、そのマクロが一時的に定義されます。
</p><p>ファイルをバイトコンパイルすると、ファイル内のトップレベルにある任意の<code class="literal">require</code>呼び出しも実行されるので、それらを定義しているファイルをrequireすることにより、コンパイルの間、必要なマクロ定義が利用できることが確実になります(<a class="link" href="ch16s07.html" title="Features">Named
Features</a>を参照してください)。誰かがコンパイルされたプログラムを<span class="emphasis"><em>実行</em></span>するときに、マクロ定義ファイルのロードをしないようにするには、<code class="literal">require</code>呼び出しの周囲に<code class="literal">eval-when-compile</code>を記述します(<a class="link" href="ch17s05.html" title="Evaluation During Compilation">Eval
During Compile</a>を参照してください)。
</p></div></body></html>