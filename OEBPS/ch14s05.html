<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Common Problems Using Macros</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Problems-with-Macros"/>Common Problems Using Macros</h1></div></div></div><a id="idm53184208" class="indexterm"/><p>マクロ展開が、直感に反する結果となることがあり得ます。このセクションでは、問題になりかねない重要な結果と、問題を避けるためにしたがうべきルールをいくつか説明します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Wrong-Time"/>Wrong Time</h2></div></div></div><p>マクロを記述する際のもっとも一般的な問題は、展開形の中ではなく、マクロ展開中に、早まって実際に何らかの作業を行ってしまうことがあります。たとえば、実際のパッケージが以下のマクロ定義をもつとします:
</p><pre class="screen">(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      (set-buffer-multibyte arg)))
</pre><p>この誤ったマクロ定義は、解釈(interpret)されるときは正常に機能しますが、コンパイル時に失敗します。このマクロ定義はコンパイル時に<code class="literal">set-buffer-multibyte</code>を呼び出してしまいますが、それは間違っています。その後でコンパイルされたパッケージを実行しても何も行いません。プログラマーが実際に望むのは、以下の定義です:
</p><pre class="screen">(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      `(set-buffer-multibyte ,arg)))
</pre><p>このマクロは、もし適切なら<code class="literal">set-buffer-multibyte</code>の呼び出しに展開され、それはコンパイルされたプログラム実行時に実行されるでしょう。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Argument-Evaluation"/>Evaluating Macro Arguments Repeatedly</h2></div></div></div><p>マクロを定義する場合、展開形が実行されるときに引数が何回評価されるか注意を払わなければなりません。以下の(繰り返し処理を用意にする)マクロで、この問題を示してみましょう。このマクロで“for”によるループ構造を記述できます。
</p><a id="idm53177168" class="indexterm"/><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (list 'let (list (list var init))
        (cons 'while
              (cons (list '&lt;= var final)
                    (append body (list (list 'inc var)))))))
</pre><pre class="screen">
</pre><pre class="screen">(for i from 1 to 3 do
   (setq square (* i i))
   (princ (format "\n%d %d" i square)))
↦
</pre><pre class="screen">(let ((i 1))
  (while (&lt;= i 3)
    (setq square (* i i))
    (princ (format "\n%d %d" i square))
    (inc i)))
</pre><pre class="screen">
     ⊣1       1
     ⊣2       4
     ⊣3       9
⇒ nil
</pre><p>マクロ内の引数<code class="literal">from</code>、<code class="literal">to</code>、<code class="literal">do</code>は、“構文糖(syntactic
sugar)”であり、完全に無視されます。このアイデアは、マクロ呼び出し中で(<code class="literal">from</code>, <code class="literal">to</code>, and
<code class="literal">do</code>のような)余計な単語を、これらの位置に記述できるようにするというものです。
</p><p>以下は、バッククォートの使用により、より単純化された等価の定義です:
</p><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  `(let ((,var ,init))
     (while (&lt;= ,var ,final)
       ,@body
       (inc ,var))))
</pre><p>この定義のフォームは両方(バッククォートのあるものと、ないもの)とも、各繰り返しにおいて毎回<em class="replaceable"><code>final</code></em>が評価されるという欠点をもちます。<em class="replaceable"><code>final</code></em>が定数のときには、問題はありません。しかし、これがより複雑な、たとえば<code class="literal">(long-complex-calculation
x)</code>のようなフォームの場合、実効速度は顕著に低下し得ます。<em class="replaceable"><code>final</code></em>が副作用をもつ場合には、複数回実行すると、おそらく正しくなくなります。
</p><a id="idm53167952" class="indexterm"/><p>うまく設計されたマクロ定義は、繰り返し評価することがそのマクロの意図された目的でない限り、引数を正確に1回評価を行う展開形を生成することにより、この問題を避けるためにステップを費やします。以下は<code class="literal">for</code>マクロの正しい展開形です:
</p><pre class="screen">(let ((i 1)
      (max 3))
  (while (&lt;= i max)
    (setq square (* i i))
    (princ (format "%d      %d" i square))
    (inc i)))
</pre><p>以下はこの展開形を生成するためのマクロ定義です:
</p><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
  `(let ((,var ,init)
         (max ,final))
     (while (&lt;= ,var max)
       ,@body
       (inc ,var))))
</pre><p>残念なことに、この訂正により、以下のセクションで説明する、別の問題が発生します。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Surprising-Local-Vars"/>Local Variables in Macro Expansions</h2></div></div></div><p>前のセクションでは、<code class="literal">for</code>の定義を、展開形がマクロ引数を正しい回数評価するように訂正しました:
</p><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
</pre><pre class="screen">  `(let ((,var ,init)
         (max ,final))
     (while (&lt;= ,var max)
       ,@body
       (inc ,var))))
</pre><p><code class="literal">for</code>の新しい定義には、新たな問題があります。この定義は、ユーザーが意識していない、<code class="literal">max</code>という名前のローカル変数を導入しています。これは、以下の例で示すようなトラブルを招きます:
</p><pre class="screen">(let ((max 0))
  (for x from 0 to 10 do
    (let ((this (frob x)))
      (if (&lt; max this)
          (setq max this)))))
</pre><p><code class="literal">for</code>のbodyの内部の<code class="literal">max</code>への参照は、<code class="literal">max</code>のユーサーバインディングの参照を意図したものですが、実際には<code class="literal">for</code>により作られたバインディングにアクセスします。
</p><p>これを修正する方法は、<code class="literal">max</code>のかわりにinternされていない(uninterned)シンボルを使用することです(<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照してください)。internされていないシンボルは他のシンボルと同じようにバインドして参照することができますが、<code class="literal">for</code>により作成されるので、わたしたちはすでにユーザーのプログラムに存在するはずがないことを知ることができます。これはinternされていないので、プログラムの後続の部分でそれを配置する方法はありません。これは<code class="literal">for</code>により配置された場所をのぞき、他の場所で配置されることはありません。以下はこの方法で機能する<code class="literal">for</code>の定義です:
</p><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
  (let ((tempvar (make-symbol "max")))
    `(let ((,var ,init)
           (,tempvar ,final))
       (while (&lt;= ,var ,tempvar)
         ,@body
         (inc ,var)))))
</pre><p>作成されたinternされていないシンボルの名前は<code class="literal">max</code>で、これを通常のinternされたシンボル<code class="literal">max</code>のかわりに、式内のその位置に記述します。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Eval-During-Expansion"/>Evaluating Macro Arguments in Expansion</h2></div></div></div><p>マクロ定義自体が、<code class="literal">eval</code>(<a class="link" href="ch10s05.html" title="Eval">Eval</a>を参照してください)の呼び出しなどによりマクロ引数式を評価した場合には、別の問題が発生します。その引数がユーザーの変数を参照する場合、ユーザーがマクロ引数と同じな前で変数をしようとした場合に問題となるでしょう。マクロのbodyないでは、マクロ引数のバインディングは、その変数のもっともローカルなバインディングなので、そのフォーム内部の任意の参照は、それを参照するように評価されます。以下は例です:
</p><pre class="screen">(defmacro foo (a)
  (list 'setq (eval a) t))
</pre><pre class="screen">(setq x 'b)
(foo x) ↦ (setq b t)
     ⇒ t                  ; <code class="literal">b</code>がセットされる。
;; but
(setq a 'c)
(foo a) ↦ (setq a t)
     ⇒ t                  ; しかし、これは<code class="literal">c</code>ではなく<code class="literal">a</code>がセットされる。

</pre><p>ユーザーの変数の名前が<code class="literal">a</code>か<code class="literal">x</code>かということで、違いが生じています。これは<code class="literal">a</code>が、マクロの引数変数<code class="literal">a</code>と競合しているからです。
</p><p>マクロ定義内での<code class="literal">eval</code>の呼び出しにまつわる別の問題は、それがおそらくコンパイル時にあなたが意図したことを行わないだろうということです。バイトコンパイラーは、そのプログラム自身の(あなたが<code class="literal">eval</code>でアクセスしたいと望む)計算は発生せず、ローカル変数バインディングも存在しないプログラムのコンパイル時にマクロ定義を実行します。
</p><p>この問題を避けるためには、<span class="bold"><strong>マクロ展開形の計算では引数式を評価しないでください</strong></span>。かわりにその式をマクロ展開形の中に置き換えれば、その値は展開形の実行の一部として計算されます。これは、このチャプターの他の例が機能する方法です。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Repeated-Expansion"/>How Many Times is the Macro Expanded?</h2></div></div></div><p>マクロ呼び出しは逐次解釈される関数で毎回マクロ呼び出しが展開されるが、コンパイルされた関数では(コンパイル時に)1回だけしか展開されないという事実にもとづく問題が、時折発生します。そのマクロ定義が副作用をもつ場合、それらのマクロは、そのマクロが難解展開されたかにより、異なる動作をとるでしょう。
</p><p>したがって、あなたが何をしているか本当に判っていないのであれば、マクロ展開形の計算での副作用は避けるべきです。
</p><p>避けることのできない特殊な副作用が1つあります。それはLispオブジェクトの構築です。ほとんどすべてのマクロ展開形には、リストの構築が含まれます。リスト構築はほとんどのマクロの核心部分です。これは通常は安全です。用心しなければならないケースが1つだけあります。それは構築するオブジェクトが、マクロ展開形の中でクォートされた定数の一部となるときです。
</p><p>そのマクロが1回だけ — コンパイル時 —
しか展開されない場合、そのオブジェクトの構築もコンパイル時の1回です。しかし逐次実行では、そのマクロはマクロ呼び出しが実行されるたびに展開され、これは毎回新たなオブジェクトが構築されることを意味します。
</p><p>クリーンなLispコードのほとんどでは、この違いは問題になりません。しかし、マクロ定義によるオブジェクト構築の副作用を処理する場合には、問題になるかもしれません。したがって問題を避けるために、<span class="bold"><strong>マクロ定義によるオブジェクト構築の副作用を避けてください</strong></span>。以下は副作用により問題が起こる例です:
</p><pre class="programlisting">(defmacro empty-object ()
  (list 'quote (cons nil nil)))
</pre><pre class="programlisting">
</pre><pre class="programlisting">(defun initialize (condition)
  (let ((object (empty-object)))
    (if condition
        (setcar object condition))
    object))
</pre><p><code class="literal">initialize</code>が解釈された場合、<code class="literal">initialize</code>が呼び出されるたびに、新しいリスト<code class="literal">(nil)</code>が構築されます。したがって、各呼び出しの間において、副作用は存続しません。しかし<code class="literal">initialize</code>がコンパイルされた場合、マクロ<code class="literal">empty-object</code>はコンパイル時に展開され、これは1つの“定数”<code class="literal">(nil)</code>を生成し、この定数は<code class="literal">initialize</code>の毎回の呼び出しで、再利用・変更されます。
</p><p>このような異常な状態を避ける1つの方法は、<code class="literal">empty-object</code>を、メモリー割り当て構造ではなく、一種の奇妙な変数と考えることです。<code class="literal">'(nil)</code>のような定数にたいして<code class="literal">setcar</code>を使うことはないでしょうから、当然<code class="literal">(empty-object)</code>にも使うことはないでしょう。
</p></div></div></body></html>