<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Customization Types</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Customization-Types"/>Customization Types</h1></div></div></div><a id="idm52741584" class="indexterm"/><p><code class="literal">defcustom</code>でユーザーオプションを定義するときは、ユーザーオプションの<em class="firstterm">カスタマイズ型(customization
type)</em>を指定しなければなりません。これは、(1)値が適正か、(2)編集のためにカスタマイズバッファーで値を表示する方法、を記述するLispオブジェクトです。
</p><a id="idm52739664" class="indexterm"/><p>カスタマイズ型は、<code class="literal">defcustom</code>内の<code class="literal">:type</code>キーワードで指定します。<code class="literal">:type</code>の引数は評価されますが、<code class="literal">defcustom</code>が実行されるとき1回だけ評価されるので、さまざまな値をとる場合には有用でありません。通常はクォートされた定数を使用します。たとえば:
</p><pre class="screen">(defcustom diff-command "diff"
  "The command to use to run diff."
  :type '(string)
  :group 'diff)
</pre><p>一般的に、カスタマイズ型は、最初の要素が以降のセクションで定義されるカスタマイズ型の1つであるような、リストです。このシンボルの後にいくつかの引数があり、それはそのシンボルに依存します。型シンボルと引数の間には、オプションでkeyword-valueペアー(<a class="link" href="ch15s04.html#Type-Keywords" title="Type Keywords">Type
Keywords</a>を参照してください)を記述できます。
</p><p>いくつかの型シンボルは引数を使用しません。これらは<em class="firstterm">シンプル型(simple
types)</em>と呼ばれます。シンプル型にたいしては、keyword-valueペアーを使用しない場合は、型シンボルの周囲のカッコ(parentheses)を省略できます。たとえばカスタマイズ型として単に<code class="literal">string</code>と記述すると、それは<code class="literal">(string)</code>と等価です。
</p><p>すべてのカスタマイズ型はウィジェットとして実装されます。詳細は、section “Introduction” in <em class="citetitle">The Emacs
Widget Library</em>を参照してください。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Simple-Types"/>Simple Types</h2></div></div></div><p>このセクションでは、すべてのシンプルデータ型を説明します。これらのカスタマイズ型のうちのいくつかにたいして、カスタマイズウィジェットは<strong class="userinput"><code>C-M-i</code></strong>または<strong class="userinput"><code>M-<span class="keycap"><strong>TAB</strong></span></code></strong>による、インライン補完を提供します。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sexp</code>
</span></dt><dd><p>値はプリントおよび読み込むことができる任意のLispオブジェクトです。より特化した型の使用するために時間をとりたくない場合は、任意のオプションへのフォールバックとして<code class="literal">sexp</code>を使用することができます。
</p></dd><dt><span class="term"><code class="literal">integer</code>
</span></dt><dd><p>値は整数でなければなりません。
</p></dd><dt><span class="term"><code class="literal">number</code>
</span></dt><dd><p>値は数(浮動小数点数または整数)でなければなりません。
</p></dd><dt><span class="term"><code class="literal">float</code>
</span></dt><dd><p>値は浮動小数点数でなければなりません。
</p></dd><dt><span class="term"><code class="literal">string</code>
</span></dt><dd><p>値は文字列でなければなりません。カスタマイズバッファーはその文字列を区切り文字‘<code class="literal">"</code>’文字および‘<code class="literal">\</code>’クォートなしで表示します。
</p></dd><dt><span class="term"><code class="literal">regexp</code>
</span></dt><dd><p><code class="literal">string</code>文字と同様ですが、その文字列は有効な正規表現でなければなりません。
</p></dd><dt><span class="term"><code class="literal">character</code>
</span></dt><dd><p>値は文字コードでなければなりません。文字コードは実際には整数ですが、この型は数字を表示せずに、バッファー内にその文字を挿入することにより値を表示します。
</p></dd><dt><span class="term"><code class="literal">file</code>
</span></dt><dd><p>値はファイル名でなければなりません。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">(file :must-match t)</code>
</span></dt><dd><p>値は既存のファイル名でなければなりません。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">directory</code>
</span></dt><dd><p>値はディレクトリー名でなければなりません。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">hook</code>
</span></dt><dd><p>値は関数のリストでなければなりません。このカスタマイズ型はフック変数にたいして使用されます。フック内での使用を推奨される関数のリストを指定するために、フック変数の<code class="literal">defcustom</code>内で<code class="literal">:options</code>キーワードを使用できます。<a class="link" href="ch15s03.html" title="Defining Customization Variables">Variable
Definitions</a>を参照してください。
</p></dd><dt><span class="term"><code class="literal">symbol</code>
</span></dt><dd><p>値はシンボルでなければなりません。これはカスタマイズバッファー内でシンボル名として表示されます。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">function</code>
</span></dt><dd><p>値はラムダ式か関数名でなければなりません。ウィジェットは関数名にたいする補完を提供します。
</p></dd><dt><span class="term"><code class="literal">variable</code>
</span></dt><dd><p>値は変数名でなければなりません。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">face</code>
</span></dt><dd><p>値はフェイス名のシンボルでなければなりません。ウィジェットは補完を提供します。
</p></dd><dt><span class="term"><code class="literal">boolean</code>
</span></dt><dd><p>値は真偽値 —
<code class="literal">nil</code>か<code class="literal">t</code>です。<code class="literal">choice</code>と<code class="literal">const</code>を合わせて使用(次のセクションを参照)することにより、値が<code class="literal">nil</code>か<code class="literal">t</code>でなければならず、それぞれの値に固有の意味に適合する説明テキストを指定することもできます。
</p></dd><dt><span class="term"><code class="literal">key-sequence</code>
</span></dt><dd><p>値はキーシーケンスです。カスタマイズバッファーは、<strong class="userinput"><code>kbd</code></strong>関数と同じ構文うぃ使用して、キーシーケンスを表示します。<a class="link" href="ch22.html#Key-Sequences" title="Key Sequences">Key
Sequences</a>を参照してください。
</p></dd><dt><span class="term"><code class="literal">coding-system</code>
</span></dt><dd><p>値はコーディングシステム名でなければならず、<strong class="userinput"><code>M-<span class="keycap"><strong>TAB</strong></span></code></strong>で保管することができます。
</p></dd><dt><span class="term"><code class="literal">color</code>
</span></dt><dd><p>値は有効なカラー名でなければなりません。ウィジェットはカラー名にたいする補完と、同様に<code class="filename">*Colors*</code>バッファーに表示されるカラーサンプルとカラー名のリストからカラー名を選択するボタンを提供します。
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Composite-Types"/>Composite Types</h2></div></div></div><a id="idm52694480" class="indexterm"/><p>適切なシンプル型がないときは、複合型(composite
types)を使うことができます。複合型は特定のデータによる他の型から、新しい型を構築します。指定された型またはデータは、その複合型の<em class="firstterm">引数(argument)</em>と呼ばれます。複合型は通常、以下のようなものです:
</p><pre class="screen">(<em class="replaceable"><code>constructor</code></em> <em class="replaceable"><code>arguments</code></em>…)
</pre><p>しかし、以下のように引数の前にkeyword-valueペアーを追加することもできます。
</p><pre class="screen">(<em class="replaceable"><code>constructor</code></em> {<em class="replaceable"><code>keyword</code></em> <em class="replaceable"><code>value</code></em>}… <em class="replaceable"><code>arguments</code></em>…)
</pre><p>以下のテーブルに、はコンストラクター(constructor)と、複合型を記述するためにそれらを使用する方法を示します:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">(cons <em class="replaceable"><code>car-type</code></em> <em class="replaceable"><code>cdr-type</code></em>)</code>
</span></dt><dd><p>値はコンスセルでなければならず、CARは<em class="replaceable"><code>car-type</code></em>、CDRは<em class="replaceable"><code>cdr-type</code></em>に適合していなければなりません。たとえば、<code class="literal">(cons
string symbol)</code>は、<code class="literal">("foo" . foo)</code>のような値にマッチするデータ型です。
</p><p>カスタマイズバッファーでは、CARとCDRは、それぞれ特定のデータ型に応じて、別々に表示・編集されます。
</p></dd><dt><span class="term"><code class="literal">(list <em class="replaceable"><code>element-types</code></em>…)</code>
</span></dt><dd><p>値は、<em class="replaceable"><code>element-types</code></em>で与えられる要素と数が正確に一致するリストでなければならず、リストの各要素はそれぞれ対応する<em class="replaceable"><code>element-type</code></em>に適合しなければなりません。
</p><p>たとえば、<code class="literal">(list integer string
function)</code>は、３つの要素のリストを示し、１つ目の要素は整数、２つ目の要素は文字列、３つ目の要素は関数です。
</p><p>カスタマイズバッファーでは、各要素は、それぞれ特定のデータ型に応じて、別々に表示・編集されます。
</p></dd><dt><span class="term"><code class="literal">(group <em class="replaceable"><code>element-types</code></em>…)</code>
</span></dt><dd><p>これは<code class="literal">list</code>と似ていますが、Customバッファー内でのテキストのフォーマットが異なります。<code class="literal">list</code>は各要素の値を、そのタグでラベルづけしますが、<code class="literal">group</code>はそれを行いません。
</p></dd><dt><span class="term"><code class="literal">(vector <em class="replaceable"><code>element-types</code></em>…)</code>
</span></dt><dd><p>これは<code class="literal">list</code>と似ていますが、リストではなくベクターでなければなりません。各要素は<code class="literal">list</code>の場合と同様に機能します。
</p></dd><dt><span class="term"><code class="literal">(alist :key-type <em class="replaceable"><code>key-type</code></em> :value-type <em class="replaceable"><code>value-type</code></em>)</code>
</span></dt><dd><p>値はコンスセルのリストでなければならず、各セルのCARはカスタマイズ型<em class="replaceable"><code>key-type</code></em>のキーを表し、同じセルのCDRはカスタマイズ型<em class="replaceable"><code>value-type</code></em>の値を表します。ユーザーはkey/valueペアーの追加や削除ができ、各ペアのキーと値の両方を編集することができます。
</p><p>省略された場合、<em class="replaceable"><code>key-type</code></em>と<em class="replaceable"><code>value-type</code></em>のデフォルトは、<code class="literal">sexp</code>です。
</p><p>ユーザーは指定されたkey-typeにマッチする任意のキーを追加できますが、<code class="literal">:options</code>(<a class="link" href="ch15s03.html" title="Defining Customization Variables">Variable
Definitions</a>を参照してください)で指定することにより、あるキーを優先的に扱うことができます。指定されたキーは、(適切な値とともに)常にカスタマイズバッファーに表示されます。また、alistにkey/valueを含める、除外する、または無効にするかを指定するチェックボックスも一緒に表示されます。ユーザーは<code class="literal">:options</code>キーワード引数により指定された値は、変更できません。
</p><p><code class="literal">:options</code>キーワードにたいする引数は、alist内の適切なキーにたいする仕様のリストであるべきです。これらは通常、単純なアトムであり、それらは自身をを意味します。たとえば:
</p><pre class="screen">:options '("foo" "bar" "baz")
</pre><p>これは、名前が<code class="literal">"foo"</code>、<code class="literal">"bar"</code>、<code class="literal">"baz"</code>の、３つの“既知”のキーがあることを指定し、それらは常に最初に表示されます。
</p><p>たとえば<code class="literal">"bar"</code>キーに対応する値を整数だけにするというように、特定のキーに対して値の型を制限したいときがあるかもしれません。これはリスト内でアトムのかわりにリストを使用することにより、指定することができます。前述のように、１つ目の要素はそのキーを指定し、２つ目の要素は値の型を指定します。たとえば:
</p><pre class="screen">:options '("foo" ("bar" integer) "baz")
</pre><p>最後に、キーが表示される方法を変更したいときもあるかもしれません。デフォルトでは、<code class="literal">:options</code>キーワードで指定された特別なキーはユーザーが変更できないので、キーは単に<code class="literal">const</code>として表示されます。しかし、たとえばそれが関数バインディングをもつシンボルだと知っている場合は<code class="literal">function-item</code>といったように、あるキーの表示のために、より特化した型を使用したいと思うかもしれません。これは、キーに対してシンボルを使うかわりに、カスタマイズ型指定を使用することにより、行うことができます。
</p><pre class="screen">:options '("foo"
           ((function-item some-function) integer)
           "baz")
</pre><p>多くのalistは、コンスセルのかわりに２要素のリストを使用します。たとえば、
</p><pre class="screen">(defcustom cons-alist
  '(("foo" . 1) ("bar" . 2) ("baz" . 3))
  "Each element is a cons-cell (KEY . VALUE).")
</pre><p>のかわりに以下を使用します
</p><pre class="screen">(defcustom list-alist
  '(("foo" 1) ("bar" 2) ("baz" 3))
  "Each element is a list of the form (KEY VALUE).")
</pre><p>リストはコンスセルの最上位に実装されているため、上記の<code class="literal">list-alist</code>を、コンスセルのalist(value-typeが実際の値を含む１要素のリストであるような)として扱うことができます。
</p><pre class="screen">(defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
  "Each element is a list of the form (KEY VALUE)."
  :type '(alist :value-type (group integer)))
</pre><p><code class="literal">list</code>のかわりに<code class="literal">group</code>を使用するのは、その目的に適したフォーマットのためだけです。
</p><p>同様に、以下のようなトリックの類を用いることにより、より多くの値が各キー連づけられたalistを得ることができます:
</p><pre class="screen">(defcustom person-data '(("brian"  50 t)
                         ("dorith" 55 nil)
                         ("ken"    52 t))
  "Alist of basic info about people.
Each element has the form (NAME AGE MALE-FLAG)."
  :type '(alist :value-type (group integer boolean)))
</pre></dd><dt><span class="term"><code class="literal">(plist :key-type <em class="replaceable"><code>key-type</code></em> :value-type <em class="replaceable"><code>value-type</code></em>)</code>
</span></dt><dd><p>このカスタマイズ型は<code class="literal">alist</code>(上位参照)と似ていますが、(1)情報がプロパティーリスト(<a class="link" href="ch06s09.html" title="Property Lists">Property
Lists</a>を参照してください)に格納され、(2)<em class="replaceable"><code>key-type</code></em>が省略された場合、デフォルトは<code class="literal">sexp</code>ではなく、<code class="literal">symbol</code>になります。
</p></dd><dt><span class="term"><code class="literal">(choice <em class="replaceable"><code>alternative-types</code></em>…)</code>
</span></dt><dd><p>値は<em class="replaceable"><code>alternative-types</code></em>のうちの1つに適合しなければなりません。たとえば、<code class="literal">(choice integer
string)</code>では整数か文字列が許されます。
</p><p>カスタマイズバッファーでは、ユーザーはメニューを使用して候補を選択して、それらの候補にたいして通常の方法で値を編集できます。
</p><p>通常この選択からメニューの文字列が自動的に決定されます。しかし候補の中に<code class="literal">:tag</code>キーワードを含めることにより、メニューにたいして異なる文字列を指定できます。たとえば、空白の数を意味する整数と、その通りに使用したいテキストにたいする文字列の場合は、以下のような方法でカスタマイズ型を記述したいかもしれません
</p><pre class="screen">(choice (integer :tag "Number of spaces")
        (string :tag "Literal text"))
</pre><p>この場合メニューは、‘<code class="literal">Number of spaces</code>’と‘<code class="literal">Literal text</code>’を提示します。
</p><p><code class="literal">const</code>以外の<code class="literal">nil</code>が有効な値ではない候補には、<code class="literal">:value</code>キーワードを使用して、有効なデフォルト値を指定するべきです。<a class="link" href="ch15s04.html#Type-Keywords" title="Type Keywords">Type
Keywords</a>を参照してください。
</p><p>複数の候補によりいくつかの値が提供される場合、カスタマイズは適合する値をもつ最初の候補を選択します。これは常に、もっとも特有な型を最初に、もっとも一般的な型を最後にリストすべきことを意味します。以下は適切な使い方の例です:
</p><pre class="screen">(choice (const :tag "Off" nil)
        symbol (sexp :tag "Other"))
</pre><p>この使い方では、特別な値<code class="literal">nil</code>はその他のシンボルとは別に扱われ、シンボルは他のLisp式とは別に扱われます。
</p></dd><dt><span class="term"><code class="literal">(radio <em class="replaceable"><code>element-types</code></em>…)</code>
</span></dt><dd><p>これは<code class="literal">choice</code>と似ていますが、選択はメニューではなく、‘ラジオボタン’で表示されます。これは該当する選択にたいしてドキュメントが表示できる利点があるので、関数定数(<code class="literal">function-item</code>カスタマイズ型)の選択に適す場合があります。
</p></dd><dt><span class="term"><code class="literal">(const <em class="replaceable"><code>value</code></em>)</code>
</span></dt><dd><p>値は<em class="replaceable"><code>value</code></em>でなければならず、他は許されません。
</p><p><code class="literal">const</code>は主に<code class="literal">choice</code>の中で使用されます。たとえば、<code class="literal">(choice integer (const
nil))</code>では、整数か<code class="literal">nil</code>が選択できます。
</p><p><code class="literal">choice</code>の中では、<code class="literal">:tag</code>とともに<code class="literal">const</code>が使用される場合があります。たとえば、
</p><pre class="screen">(choice (const :tag "Yes" t)
        (const :tag "No" nil)
        (const :tag "Ask" foo))
</pre><p>これは<code class="literal">t</code>がyes、<code class="literal">nil</code>がno、<code class="literal">foo</code>が“ask”を意味することを示します。
</p></dd><dt><span class="term"><code class="literal">(other <em class="replaceable"><code>value</code></em>)</code>
</span></dt><dd><p>この候補は任意のLisp値にマッチできますが、ユーザーがこの候補を選択した場合は、値<em class="replaceable"><code>value</code></em>が選択されます。
</p><p><code class="literal">other</code>は主に<code class="literal">choice</code>の最後の要素に使用されます。たとえば、
</p><pre class="screen">(choice (const :tag "Yes" t)
        (const :tag "No" nil)
        (other :tag "Ask" foo))
</pre><p>これは<code class="literal">t</code>がyes、<code class="literal">nil</code>がno、それ以外は“ask”を意味することを示します。ユーザーが候補メニューから‘<code class="literal">Ask</code>’を選択した場合は、値<code class="literal">foo</code>が指定されます。しかし、その他の値(<code class="literal">t</code>、<code class="literal">nil</code>、<code class="literal">foo</code>を除く)では、<code class="literal">foo</code>と同様に‘<code class="literal">Ask</code>’が表示されます。
</p></dd><dt><span class="term"><code class="literal">(function-item <em class="replaceable"><code>function</code></em>)</code>
</span></dt><dd><p><code class="literal">const</code>と同様ですが、値が関数のときに使用されます。これはドキュメント文字列も関数名と同じように表示します。ドキュメント文字列は、<code class="literal">:doc</code>で指定した文字列か、<em class="replaceable"><code>function</code></em>自身のドキュメント文字列です。
</p></dd><dt><span class="term"><code class="literal">(variable-item <em class="replaceable"><code>variable</code></em>)</code>
</span></dt><dd><p><code class="literal">const</code>と同様ですが、値が変数名のときに使用されます。これはドキュメント文字列も変数名と同じように表示します。ドキュメント文字列は、<code class="literal">:doc</code>で指定した文字列か、<em class="replaceable"><code>variable</code></em>自身のドキュメント文字列です。
</p></dd><dt><span class="term"><code class="literal">(set <em class="replaceable"><code>types</code></em>…)</code>
</span></dt><dd><p>値はリストでなければならず、指定された<em class="replaceable"><code>types</code></em>の1つにマッチしなければなりません。
</p><p>これはカスタマイズバッファーではチェックリストとして表示されるので、<em class="replaceable"><code>types</code></em>はそれぞれ対応する要素を1つ、あるいは要素をもちません。同じ1つの<em class="replaceable"><code>types</code></em>にマッチするような、異なる2つの要素を指定することはできません。たとえば、<code class="literal">(set
integer
symbol)</code>は、リスト内で1つの整数、および/または1つのシンボルが許され、複数の整数や複数のシンボルは許されません。結果として、<code class="literal">set</code>内で<code class="literal">integer</code>のような特定的ではない型を使用するのは稀です。
</p><p>以下のように、<code class="literal">const</code>型は<code class="literal">set</code>内の<em class="replaceable"><code>types</code></em>でよく使用されます:
</p><pre class="screen">(set (const :bold) (const :italic))
</pre><p>alist内で利用できる要素を示すために使用されることもあります:
</p><pre class="screen">(set (cons :tag "Height" (const height) integer)
     (cons :tag "Width" (const width) integer))
</pre><p>これによりユーザーにオプションでheightとwidthの値を指定させることができます。
</p></dd><dt><span class="term"><code class="literal">(repeat <em class="replaceable"><code>element-type</code></em>)</code>
</span></dt><dd><p>値はリストでなければならず、リストの各要素は型<em class="replaceable"><code>element-type</code></em>に適合しなければなりません。カスタマイズバッファーでは要素のリストとして表示され、‘<code class="literal">[INS]</code>’および‘<code class="literal">[DEL]</code>’ボタンにより、要素の追加や削除が行われます。
</p></dd><dt><span class="term"><code class="literal">(restricted-sexp :match-alternatives <em class="replaceable"><code>criteria</code></em>)</code>
</span></dt><dd><p>これはもっとも汎用的な複合型の構築方法です。値は<em class="replaceable"><code>criteria</code></em>を満足する任意のLispオブジェクトです。<em class="replaceable"><code>criteria</code></em>はリストで、リストの各要素は以下のうちの1つを満たす必要があります:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>述語 —
つまり、副作用をもたず引数は1つ、その引数に応じて<code class="literal">nil</code>か非<code class="literal">nil</code>のどちらかをリターンする関数。リスト内での述語の使用により、その述語が非<code class="literal">nil</code>をリターンするようなオブジェクトが許されることを意味する。
</p></li><li class="listitem"><p>クォートされた定数 —
つまり、<code class="literal">'<em class="replaceable"><code>object</code></em></code>。リスト内でこの要素は、<em class="replaceable"><code>object</code></em>自身が容認される値であることを示す。
</p></li></ul></div><p>たとえば、
</p><pre class="screen">(restricted-sexp :match-alternatives
                 (integerp 't 'nil))
</pre><p>これは整数、<code class="literal">t</code>、<code class="literal">nil</code>を正当な値として受け入れます。
</p><p>カスタマイズバッファーは適切な値をそれらの入力構文ですべて表示し、ユーザーはこれらをテキストとして編集できます。
</p></dd></dl></div><p>以下は複合型でキーワード/値ペアーとして使用できるキーワードのテーブルです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:tag <em class="replaceable"><code>tag</code></em></code>
</span></dt><dd><p><em class="replaceable"><code>tag</code></em>は、ユーザーとのコミュニケーションのために、その候補の名前として使用される。<code class="literal">choice</code>内に出現する型にたいして有用。
</p></dd><dt><span class="term"><code class="literal">:match-alternatives <em class="replaceable"><code>criteria</code></em></code>
</span></dt><dd><a id="idm56707536" class="indexterm"/><p><em class="replaceable"><code>criteria</code></em>は可能な値とのマッチに使用されます。<code class="literal">restricted-sexp</code>内でのみ有用です。
</p></dd><dt><span class="term"><code class="literal">:args <em class="replaceable"><code>argument-list</code></em></code>
</span></dt><dd><a id="idm56704464" class="indexterm"/><p>型構築の引数として<em class="replaceable"><code>argument-list</code></em>の要素を使用します。たとえば、<code class="literal">(const :args
(foo))</code>は<code class="literal">(const
foo)</code>と等価です。明示的に<code class="literal">:args</code>とく記述する必要があるのは稀です。なぜなら、最後のキーワード/値ペアーの後に続くものは何であれ、引数として認識されるからです。
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Splicing-into-Lists"/>Splicing into Lists</h2></div></div></div><p><code class="literal">:inline</code>機能により、可変個の要素を、カスタマイズ型の<code class="literal">list</code>や<code class="literal">vector</code>の途中にスプライス(splice:
継ぎ足す)することができます。<code class="literal">list</code>や<code class="literal">vector</code>記述を含む型にたいして<code class="literal">:inline
t</code>を追加することによりこれを使用します。
</p><p>通常<code class="literal">list</code>や<code class="literal">vector</code>型の仕様は、単一の要素型を表します。しかしエントリーが<code class="literal">:inline
t</code>を含む場合、マッチする値は、その含まれたシーケンスに直接マージされます。たとえば、エントリーが3要素のリストにマッチする場合、全体が3要素のシーケンスになります。これはバッククォート構文(<a class="link" href="ch10s04.html" title="Backquote">Backquote</a>を参照)の‘<code class="literal">,@</code>’に類似しています。
</p><p>たとえば、最初の要素が<code class="literal">baz</code>で、残りの引数は0個以上の<code class="literal">foo</code>か<code class="literal">bar</code>でなければならないリストを指定する場合は、以下のカスタマイズ型を使用します:
</p><pre class="screen">(list (const baz) (set :inline t (const foo) (const bar)))
</pre><p>これは <code class="literal">(baz)</code>、<code class="literal">(baz foo)</code>、<code class="literal">(baz bar)</code>、<code class="literal">(baz foo
bar)</code>のような値にマッチします。
</p><p>要素の型が<code class="literal">choice</code>の場合は、<code class="literal">choice</code>自身の中で<code class="literal">:inline</code>を使用せずに、<code class="literal">choice</code>の候補(の一部)の中で使用します。たとえば、最初がファイル名で開始され、その後にシンボル<code class="literal">t</code>か2つの文字列を続けなければならないリストにマッチさせるには、以下のカスタマイズ型を使用します:
</p><pre class="screen">(list file
      (choice (const t)
              (list :inline t string string)))
</pre><p>選択においてユーザーが選択肢の1つ目を選んだ場合、リスト全体が2つの要素をもち、2つ目の要素は<code class="literal">t</code>になります。ユーザーが2つ目の候補を選んだ場合、リスト全体が3つの要素をもち、2つ目と3つ目の要素は文字列でなければなりません。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Type-Keywords"/>Type Keywords</h2></div></div></div><p>カスタマイズ型内の型名シンボルの後にキーワード/引数ペアーを指定できます。以下は使用できるキーワードと、それらの意味です:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:value <em class="replaceable"><code>default</code></em></code>
</span></dt><dd><p>デフォルト値を提供する。
</p><p>その候補にたいして<code class="literal">nil</code>が有効な値でない場合は、<code class="literal">:value</code>に有効なデフォルトを指定することが必須になります。
</p><p><code class="literal">choice</code>の内部の候補として出現する型にたいしてこれを使用する場合、ユーザーがカスタマイズバッファー内のメニューによりこの候補を選択したときに、使用するデフォルト値を最初に指定します。
</p><p>もちろんオプションの実際の値がこの候補に適合する場合は、<em class="replaceable"><code>default</code></em>ではなく実際の値が表示されます。
</p></dd><dt><span class="term"><code class="literal">:format <em class="replaceable"><code>format-string</code></em></code>
</span></dt><dd><a id="idm56677584" class="indexterm"/><p>この文字列は、その型に対応する値を説明するために、バッファーに挿入されます。<em class="replaceable"><code>format-string</code></em>内では、以下の‘<code class="literal">%</code>’エスケープが利用できます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">%[<em class="replaceable"><code>button</code></em>%]</code>’
</span></dt><dd><p>ボタンとしてマークされたテキスト<em class="replaceable"><code>button</code></em>を表示する。<code class="literal">:action</code>属性は、ユーザーがそれを呼び出したときに、そのボタンが何を行うか指定する。この属性の値は２つの引数
— ボタンが表示されるのでウィジェットとイベント — をとる関数。
</p><p>異なるアクションを行う2つの異なるボタンを指定する方法はない。
</p></dd><dt><span class="term">‘<code class="literal">%{<em class="replaceable"><code>sample</code></em>%}</code>’
</span></dt><dd><p><code class="literal">:sample-face</code>により指定された、スペシャルフェイス内の<em class="replaceable"><code>sample</code></em>を表示する。
</p></dd><dt><span class="term">‘<code class="literal">%v</code>’
</span></dt><dd><p>そのアイテムの値を代替えする。その値がどのように表示されるかはアイテムの種類と、(カスタマイズ型にたいしては)カスタマイズ型にに依存する。
</p></dd><dt><span class="term">‘<code class="literal">%d</code>’
</span></dt><dd><p>そのアイテムのドキュメント文字列を代替えする。
</p></dd><dt><span class="term">‘<code class="literal">%h</code>’
</span></dt><dd><p>‘<code class="literal">%d</code>’と同様ふぁが、ドキュメント文字列が複数行の場合に、ドキュメント文字列全体か最初の行だけかを制御するボタンを追加する。
</p></dd><dt><span class="term">‘<code class="literal">%t</code>’
</span></dt><dd><p>その位置でタグに置き換える。<code class="literal">:tag</code>キーワードでタグを指定する。
</p></dd><dt><span class="term">‘<code class="literal">%%</code>’
</span></dt><dd><p>リテラル‘<code class="literal">%</code>’を表示する。
</p></dd></dl></div></dd><dt><span class="term"><code class="literal">:action <em class="replaceable"><code>action</code></em></code>
</span></dt><dd><a id="idm56647632" class="indexterm"/><p>ユーザーがボタンをクリックした場合は<em class="replaceable"><code>action</code></em>を実行します。
</p></dd><dt><span class="term"><code class="literal">:button-face <em class="replaceable"><code>face</code></em></code>
</span></dt><dd><a id="idm56644944" class="indexterm"/><p>‘<code class="literal">%[…%]</code>’で表示されたボタンテキストにたいして、フェイス<em class="replaceable"><code>face</code></em>(フェイス名、またはフェイス名のリスト)を使用します。
</p></dd><dt><span class="term"><code class="literal">:button-prefix <em class="replaceable"><code>prefix</code></em></code>
, </span><span class="term"><code class="literal">:button-suffix <em class="replaceable"><code>suffix</code></em></code>
</span></dt><dd><a id="idm56636752" class="indexterm"/><a id="idm56635984" class="indexterm"/><p>これらはボタンの前、または後に表示されるテキストを指定します。以下が指定できます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">nil</code>
</span></dt><dd><p>テキストは挿入されない。
</p></dd><dt><span class="term">文字列
</span></dt><dd><p>その文字列がリテラルに挿入される。
</p></dd><dt><span class="term">シンボル
</span></dt><dd><p>そのシンボルの値が使用される。
</p></dd></dl></div></dd><dt><span class="term"><code class="literal">:tag <em class="replaceable"><code>tag</code></em></code>
</span></dt><dd><p>この型に対応する値(または値の一部)にたいするタグとして<em class="replaceable"><code>tag</code></em>(文字列)を使用する。
</p></dd><dt><span class="term"><code class="literal">:doc <em class="replaceable"><code>doc</code></em></code>
</span></dt><dd><a id="idm56628432" class="indexterm"/><p>この型に対応する値(または値の一部)にたいするドキュメント文字列として<em class="replaceable"><code>doc</code></em>を使用する。これが機能するためには、<code class="literal">:format</code>にたいする値を指定し、その値にたいして‘<code class="literal">%d</code>’か‘<code class="literal">%h</code>’を使用しなければならない。
</p><p>ある型にたいしてドキュメント文字列を指定するのは、<code class="literal">:choice</code>内の候補の型や、他の複合型の一部について情報を提供するのが通常の理由である。
</p></dd><dt><span class="term"><code class="literal">:help-echo <em class="replaceable"><code>motion-doc</code></em></code>
</span></dt><dd><a id="idm56623056" class="indexterm"/><p><code class="literal">widget-forward</code>や<code class="literal">widget-backward</code>でこのアイテムに移動したときに、エコーエリアに文字列<em class="replaceable"><code>motion-doc</code></em>を表示する。さらに、マウスの<code class="literal">help-echo</code>文字列として<em class="replaceable"><code>motion-doc</code></em>が使用され、これは実際にはヘルプ文字列を生成するために評価される関数またはフォームかもしれない。もし関数の場合、これは1つの引数(そのウィジェット)で呼び出される。
</p></dd><dt><span class="term"><code class="literal">:match <em class="replaceable"><code>function</code></em></code>
</span></dt><dd><a id="idm56618576" class="indexterm"/><p>値がその型にマッチするか判断する方法を指定する。対応する値<em class="replaceable"><code>function</code></em>は、2つの引数(ウィジェットと値)をとる関数で、値が適切なら非<code class="literal">nil</code>をリターンすること。
</p></dd><dt><span class="term"><code class="literal">:validate <em class="replaceable"><code>function</code></em></code>
</span></dt><dd><p>入力にたいして検証を行う関数を指定する。<em class="replaceable"><code>function</code></em>は引数としてウィジェットをとり、そのウィジェットのカレント値がウィジェットにたいして有効なら<code class="literal">nil</code>をリターンすること。それ以外は無効なデータを含むウィジェットをリターンして、そのウィジェットの<code class="literal">:error</code>プロパティに、そのエラーを説明する文字列をセットすること。
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Defining-New-Types"/>Defining New Types</h2></div></div></div><a id="idm56612432" class="indexterm"/><a id="idm56611664" class="indexterm"/><p>前のセクションでは、<code class="literal">defcustom</code>にたいして型の詳細な仕様を作成する方法を説明しました。そのような型仕様に名前を与えたい場合があるかもしれません。理解しやすいケースとしては、多くのユーザーオプションに同じ型を使用する場合などです。各オプションにたいして仕様を繰り返すより、その型に名前を与えて、<code class="literal">defcustom</code>それぞれにその名前を使用することができます。他にもユーザーオプションの値が再帰的なデータ構造のケースがあります。あるデータ型がそれ自身を参照できるようにするためには、それが名前をもつ必要があります。
</p><p>カスタマイズ型はウィジェットとして実装されているめ、新しいカスタマイズ型を定義するには、新たにウィジェット型を定義します。ここではウィジェットインターフェイスの詳細は説明しません。section “Introduction” in <em class="citetitle">The Emacs Widget
Library</em>を参照してください。　かわりに、シンプルな例を用いて、カスタマイズ型を新たに定義するのに必要となる、最小限の機能について説明します。
</p><pre class="screen">(define-widget 'binary-tree-of-string 'lazy
  "A binary tree made of cons-cells and strings."
  :offset 4
  :tag "Node"
  :type '(choice (string :tag "Leaf" :value "")
                 (cons :tag "Interior"
                       :value ("" . "")
                       binary-tree-of-string
                       binary-tree-of-string)))

(defcustom foo-bar ""
  "Sample variable holding a binary tree of strings."
  :type 'binary-tree-of-string)
</pre><p>新しいウィジェットを定義するための関数は、<code class="literal">define-widget</code>と呼ばれます。1つ目の引数は、新たなウィジェット型にしたいシンボルです。2つ目の引数は既存のウィジェットを表すシンボルで、新しいウィジェットではこの既存のウィジェットと異なる部分を定義することになります。新たなカスタマイズ型を定義する目的にたいしては、<code class="literal">lazy</code>ウィジェットが最適です。なぜならこれは、<code class="literal">defcustom</code>にたいするキーワード引数と同じ構文、同じ名前でキーワード引数<code class="literal">:type</code>を受け取るからです。3つ目の引数は、新しいウィジェットにたいするドキュメント文字列です。この文字列は、<strong class="userinput"><code>M-x
widget-browse <span class="keycap"><strong>RET</strong></span> binary-tree-of-string
<span class="keycap"><strong>RET</strong></span></code></strong>コマンドで参照することができるようになります。
</p><p>これらの必須の引数の後にキーワード引数が続きます。もっとも重要なのは<code class="literal">:type</code>で、これはこのウィジェットにマッチさせたいデータ型を表します。上記の例では<code class="literal">binary-tree-of-string</code>は文字列、またはcarとcdrが<code class="literal">binary-tree-of-string</code>であるようなコンスセルです。この定義中でのウィジェット型への参照に注意してください。<code class="literal">:tag</code>属性はユーザーインターフェイスでウィジェット名となる文字列、<code class="literal">:offset</code>引数はカスタマイズバッファーでのツリー構造の外観で，子ノードと関連する親ノードの間に4つのスペースを確保します。
</p><p><code class="literal">defcustom</code>は、通常のカスタマイズ型に使用される方法で新しいウィジェットを表示します。
</p><p><code class="literal">lazy</code>という名前の由来は、他のウィジェットの場合、それらがバッファーでインスタンス化されるとき、他の合成されたウィジェットが下位のウィジェットを内部形式に変換するからです。この変換は再帰的なので、下位のウィジェットは、<span class="emphasis"><em>それら自身</em></span>の下位ウィジェットへと変換されます。データ構造自体が再帰的な場合、この変換は無限再帰(infinite
recursion)となります。<code class="literal">lazy</code>ウィジェットは、<code class="literal">:type</code>引数を必要なときだけ変換することにより、この再帰を防ぎます。
</p></div></div></body></html>