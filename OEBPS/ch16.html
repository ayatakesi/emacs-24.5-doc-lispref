<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 15. Loading</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Loading"/>Chapter 15. Loading</h1></div></div></div><a id="idm56452176" class="indexterm"/><a id="idm56451408" class="indexterm"/><a id="idm56450640" class="indexterm"/><p>Lispコードのファイルをロードすることは、その内容をLispオブジェクト形式でLisp環境に取り込むことを意味します。Emacsはファイルを探してオープンし、テキストを読み込んで各フォームを評価してから、そのファイルをクローズします。そのようなファイルは<em class="firstterm">Lispライブラリー(Lisp
library)</em>とも呼ばれます。
</p><p><code class="literal">eval-buffer</code>関数がバッファー内のすべての式を評価するのと同様に、load関数はファイル内のすべての式を評価します。異なるのはEmacsバッファー内のテキストではなく、load関数はディスク上で見つかったファイル内のテキストを読み込み、評価することです。
</p><a id="idm56448336" class="indexterm"/><p>ロードされたファイルは、ソースコードかバイトコンパイルされたコードとしてLisp式を含んでいなければなりません。このファイル内の各フォームは、<em class="firstterm">トップレベルフォーム(top-level
form)</em>と呼ばれます。ロード可能なファイル内のフォームにたいする特別なフォーマットはありません。ファイル内のフォームはどれも、同じように直接バッファーにタイプされ、そこで評価されるでしょう(実際、ほとんどのコードはこの方法でテストされます)。多くの場合、そのフォームは関数定義と変数定義です。
</p><p>外部ライブラリーのオンデマンドローディングについては、<a class="link" href="ch39s20.html" title="Dynamically Loaded Libraries">Dynamic Libraries</a>を参照してください。
</p><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="How-Programs-Do-Loading"/>How Programs Do Loading</h1></div></div></div><p>Emacs
Lispにはロードのためのインターフェイスがいくつかあります。たとえば、<code class="literal">autoload</code>はファイル内で定義された関数にたいしてプレースホルダーとなるオブジェクトを作成します。この関数はオートロードされる関数を呼び出すために、ファイルからその関数の実際の定義の取得を試みます(<a class="link" href="ch16s05.html" title="Autoload">Autoload</a>を参照)。<code class="literal">require</code>は、ファイルがまだロードされていない場合にファイルをロードします(<a class="link" href="ch16s07.html" title="Features">Named
Features</a>を参照)。これらすべての関数は、処理を行うために最終的に<code class="literal">load</code>を呼び出します。
</p><pre class="synopsis"><a id="idm56441808" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">load</code> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>missing-ok</code></em> <em class="replaceable"><code>nomessage</code></em> <em class="replaceable"><code>nosuffix</code></em> <em class="replaceable"><code>must-suffix</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はLispコードのファイルを見つけてオープンし、その中のすべてのフォームを評価して、そのファイルをクローズします。
</p><p>ファイルを見つけるために、まず<code class="literal">load</code>は<code class="filename"><em class="replaceable"><code>filename</code></em>.elc</code>という名前、つまり<em class="replaceable"><code>filename</code></em>に拡張子‘<code class="literal">.elc</code>’を足した名前のファイルを探します。このようなファイルが存在したら、それをロードします。その名前のファイルが存在しない場合、<code class="literal">load</code>は<code class="filename"><em class="replaceable"><code>filename</code></em>.el</code>という名前のファイルを探します。このファイルが存在したら、それをロードします。最後に、もしこれらの名前がどちらも見つからなかった場合、<code class="literal">load</code>は何も付け足さない<em class="replaceable"><code>filename</code></em>という名前のファイルを探して、それが存在したらロードします。(<code class="literal">load</code>関数に<em class="replaceable"><code>filename</code></em>を認識する賢さはありません。<code class="filename">foo.el.el</code>のような正しくない名前のファイルの場合も、<code class="literal">(load
"foo.el")</code>の評価によりそれを見つけてしまいます。)
</p><p>Auto
Compressionモードが有効(残念ながらデフォルトでは有効ですが)の場合、<code class="literal">load</code>は他のファイル名を試みる前に圧縮されたバージョンのファイル名を探すので、ファイルを見つけることができません。圧縮されたファイルが存在したら、それを解凍してロードします。<code class="literal">load</code>はファイル名に<code class="literal">jka-compr-load-suffixes</code>内の各サフィックスを足して、圧縮されたバージョンを探します。この変数の値は、文字列のリストでなければなりません。標準的な値は<code class="literal">(".gz")</code>です。
</p><p>オプション引数<em class="replaceable"><code>nosuffix</code></em>が非<code class="literal">nil</code>の場合<code class="literal">load</code>はサフィックス‘<code class="literal">.elc</code>’と‘<code class="literal">.el</code>’を試みません。この場合、ロードしたいファイルの正確な名前を指定しなければなりません。ただしAuto
Compressionモードが有効な場合には、<code class="literal">load</code>は圧縮されたバージョンを探すために、<code class="literal">jka-compr-load-suffixes</code>を使用します。正確なファイル名の指定と、、<em class="replaceable"><code>nosuffix</code></em>にたいして<code class="literal">t</code>を使用することにより、<code class="filename">foo.el.el</code>のような名前のファイルにたいするロードの試みを抑止できます。
</p><p>オプション引数<em class="replaceable"><code>must-suffix</code></em>が非<code class="literal">nil</code>の場合、<code class="literal">load</code>はロードに使用されるファイルの名前に明示的にディレクトリー名が含まれていなければ、ファイル名が‘<code class="literal">.el</code>’か‘<code class="literal">.elc</code>’で終わること(あるいは圧縮による拡張子が付加されているかもしれません)を要求します。
</p><p>オプション<code class="literal">load-prefer-newer</code>が非<code class="literal">nil</code>の場合、<code class="literal">load</code>はサフィックスを検索するとき、どのファイルであっても(‘<code class="literal">.elc</code>’、‘<code class="literal">.el</code>’など)、もっとも最近変更されたファイルのバージョンを選択します。
</p><p><em class="replaceable"><code>filename</code></em>が<code class="filename">foo</code>や<code class="filename">baz/foo.bar</code>のような相対ファイル名の場合、<code class="literal">load</code>は変数<code class="literal">load-path</code>を使用してそのファイルを探します。これは<code class="literal">load-path</code>内にリストされた各ディレクトリーに<em class="replaceable"><code>filename</code></em>を追加して、最初に見つかったら名前のマッチするファイルをロードします。デフォルトディレクトリーを意味する<code class="literal">nil</code>が<code class="literal">load-path</code>で措定されたときだけ、カレントデフォルトディレクトリーを試みます。<code class="literal">load</code>は<code class="literal">load-path</code>内の最初のディレクトリーで利用可能な3つのサフィックスすべてを試行してから、2つ目のディレクトリーで３つのサフィックスすべてを試行する、というようにファイルを探します。<a class="link" href="ch16s03.html" title="Library Search">Library
Search</a>を参照してください。
</p><p>最終的に見つかったファイル、およびEmacsがそのファイルを見つけたディレクトリーが何であれ、Emacsはそのファイル名を変数<code class="literal">load-file-name</code>の値にセットします。
</p><p><code class="filename">foo.elc</code>が<code class="filename">foo.el</code>より古いと警告された場合、それは<code class="filename">foo.el</code>のリコンパイルを考慮すべきことを意味します。<a class="link" href="ch17.html" title="Chapter 16. Byte Compilation">Byte
Compilation</a>を参照してください
</p><p>(コンパイルされていない)ソースファイルをロードしたとき、Emacsがファイルをvisitしたときと同じように<code class="literal">load</code>は文字セットの変換を行います。<a class="link" href="ch33s10.html" title="Coding Systems">Coding
Systems</a>を参照してください。
</p><a id="idm56389200" class="indexterm"/><p>コンパイルされていないファイルをロードするとき、Emacsはそのファイルに含まれる任意のマクロ(<a class="link" href="ch14.html" title="Chapter 13. Macros">Macros</a>を参照)を展開します。わたしたちはこれを<em class="firstterm">eagerマクロ展開(eager
macro
expansion)</em>と呼んでいます。(関連するコードを実行するまで展開を延期するのではなく)これを行うことにより、コンパイルされていないコード実行のスピードが明らかに向上します。このマクロ展開は、循環参照により行うことができないときもあります。これの一番簡単な例は、ロードしようとしているファイルが他のファイルで定義されているマクロを参照しているが、そのファイルはロードしようとしているファイルを必要としている場合です。これは一般的には無害です。Emacsは問題の詳細を与えるために警告(‘<code class="literal">Eager
macro-expansion skipped due to
cycle…</code>’)をプリントしますが、単にその時点ではマクロを展開せずに、そのファイルはロードされます。あなたはこの問題が発生しないように、コードをリストラクチャーしたいと思うかもしれません。コンパイル済みファイルでは、マクロ展開はコンパイル時に行われるので、ロード時のマクロ展開は行われません。<a class="link" href="ch14s03.html" title="Macros and Byte Compilation">Compiling
Macros</a>を参照してください。
</p><p><em class="replaceable"><code>nomessage</code></em>が非<code class="literal">nil</code>でない場合は、ロードの間、エコーエリアに‘<code class="literal">Loading
foo...</code>’や‘<code class="literal">Loading foo...done</code>’のようなメッセージが表示されます。
</p><a id="idm56383824" class="indexterm"/><p>ファイルをロードする間のハンドルされないエラーは、ロードを終了させます。<code class="literal">autoload</code>のためのロードの場合、ロードの間に定義された任意の関数定義は元に戻されます。
</p><a id="idm56382032" class="indexterm"/><p><code class="literal">load</code>がロードするファイルを見つけられなかった場合、通常は(‘<code class="literal">Cannot open load file
<em class="replaceable"><code>filename</code></em></code>’のメッセージとともに)エラー<code class="literal">file-error</code>がシグナルされます。しかし<em class="replaceable"><code>missing-ok</code></em>が非<code class="literal">nil</code>の場合、<code class="literal">load</code>は単に<code class="literal">nil</code>をリターンします。
</p><p>式の読み取りにたいして<code class="literal">load</code>が<code class="literal">read</code>のかわりに使用する関数を指定するために、変数<code class="literal">load-read-function</code>を使用できます。以下を参照してください。
</p><p>ファイルが正常にロードされた場合、<code class="literal">load</code>は<code class="literal">t</code>をリターンします。
</p></blockquote></div><pre class="synopsis"><a id="idm56373712" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">load-file</code> <em class="replaceable"><code>filename</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、ファイル<em class="replaceable"><code>filename</code></em>をロードします。<em class="replaceable"><code>filename</code></em>が相対ファイル名の場合は、カレントデフォルトディレクトリーとみなされます。このコマンドは、<code class="literal">load-path</code>を使用せず、サフィックスの追加もしません。しかし、(Auto
Compressionモードが有効な場合は)圧縮されたバージョンの検索を行います。ロードするファイル名を正確に指定したい場合は、このコマンドを使用してください。
</p></blockquote></div><pre class="synopsis"><a id="idm56369232" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">load-library</code> <em class="replaceable"><code>library</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは<em class="replaceable"><code>library</code></em>という名前のライブラリーをロードします。このコマンドは、引数を読み取る方法がインタラクティブであることを除き、<code class="literal">load</code>と同じです。section “Lisp
Libraries” in <em class="citetitle">The GNU Emacs Manual</em>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm56364752" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">load-in-progress</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、Emacsがファイルをロード中のときは非<code class="literal">nil</code>、それ以外は<code class="literal">nil</code>です。
</p></blockquote></div><pre class="synopsis"><a id="idm56361040" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">load-file-name</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このセクションの最初に説明した検索でEmacsがファイルを見つけて、そのファイルをロード中のとき、この変数の値はそのファイルの名前です。
</p></blockquote></div><pre class="synopsis"><a id="idm56358352" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">load-read-function</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-load_002dread_002dfunction"/><p>この変数は、<code class="literal">load</code>と<code class="literal">eval-region</code>が式の読み取るために、<code class="literal">read</code>のかわりに使用する関数を指定します。指定する関数は<code class="literal">read</code>と同様、引数が1つの関数です。
</p><p>通常、この変数の値は<code class="literal">nil</code>で、これはそれらの関数が<code class="literal">read</code>を使用すべきことを意味します。
</p><p>この変数を使用するかわりに、別の新たな方法を使用するほうが明確です。<code class="literal">eval-region</code>の<em class="replaceable"><code>read-function</code></em>引数に、その関数を渡す方法です。<a class="link" href="ch10s05.html#Definition-of-eval_002dregion">Eval</a>を参照してください。
</p></blockquote></div><p>Emacsのビルドで<code class="literal">load</code>がどのように使用されているかについての情報は、<a class="link" href="ape.html#Building-Emacs" title="Building Emacs">Building Emacs</a>を参照してください。
</p></div></div></body></html>