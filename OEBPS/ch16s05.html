<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Autoload</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Autoload"/>Autoload</h1></div></div></div><a id="idm56232784" class="indexterm"/><p><em class="firstterm">オートロード(autoload:
自動ロード)</em>の機能により、定義されているファイルをロードすることなく、関数やマクロの存在を登録できます。関数の最初の呼び出しで、実際の定義およびその他の関連するコードをインストールするために適切なライブラリーを自動的にロードし、すべてがすでにロードされていたかのように、実際の定義を実行します。関数やマクロのドキュメントを参照することによっても、オートロードが発生します(<a class="link" href="ch24.html#Documentation-Basics" title="Documentation Basics">Documentation
Basics</a>を参照)。
</p><p>オートロードされた関数をセットアップするには、2つの方法があります。それは<code class="literal">autoload</code>を呼び出す方法と、ソースの実際の定義の前に、特別な“マジック”コメントを記述する方法です。<code class="literal">autoload</code>はオートロードのための低レベルのプリミティブです。任意のLispプログラムが、任意のときに<code class="literal">autoload</code>を呼び出すことができます。Emacsととみにインストールされるパッケージにとって、マジックコメントは関数をオートロードできるようににするための一番便利な方法です。コメント自身は何も行いませんが、コマンド<code class="literal">update-file-autoloads</code>にたいするガイドを努めます。このコマンドは<code class="literal">autoload</code>の呼び出しを構築し、Emacsビルド時に実行されるようアレンジします。
</p><pre class="synopsis"><a id="idm56215248" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">autoload</code> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>docstring</code></em> <em class="replaceable"><code>interactive</code></em> <em class="replaceable"><code>type</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>filename</code></em>から自動的にロードされるように、<em class="replaceable"><code>function</code></em>という名前の関数(またはマクロ)を定義します。文字列<em class="replaceable"><code>filename</code></em>のは、<em class="replaceable"><code>function</code></em>の実際の定義を取得するファイルを指定します。
</p><p><em class="replaceable"><code>filename</code></em>がディレクトリー名とサフィックス<code class="literal">.el</code>と<code class="literal">.elc</code>のどちらも含まない場合、この関数はこれらの強制的にサフィックスを追加します。つまりサフィックスが追加されないただの<em class="replaceable"><code>filename</code></em>という名前のファイルはロードされません。(変数<code class="literal">load-suffixes</code>により要求される正確なサフィックスが指定されます。)
</p><p>引数<em class="replaceable"><code>docstring</code></em>は、その関数のドキュメント文字列です。<code class="literal">autoload</code>の呼び出しでドキュメント文字列を指定することにより、その関数の実際の定義をロードせずにドキュメントを見ることが可能になります。この引数の値は通常、関数定義のドキュメント文字列と等しくあるべきです。もし等しくない場合は、その関数のドキュメント文字列がロード時に有効になります。
</p><p><em class="replaceable"><code>interactive</code></em>が非<code class="literal">nil</code>の場合、その関数はインタラクティブに呼び出すことが可能になります。これにより、<em class="replaceable"><code>function</code></em>の実際の定義をロードせずに、<strong class="userinput"><code>M-x</code></strong>による補完が機能するようになります。。ここでは、完全なインタラクティブ指定は与えられません。完全な指定はユーザーが実際に<em class="replaceable"><code>function</code></em>を呼び出すまで必要ありません。実際にユーザーが呼び出したときに、実際の定義がロードされます。
</p><p>普通の関数と同様、マクロおよびキーマップをオートロードできます。<em class="replaceable"><code>function</code></em>が実際にはマクロの場合は<em class="replaceable"><code>type</code></em>に<code class="literal">macro</code>を指定し、キーマップの場合には<em class="replaceable"><code>type</code></em>に<code class="literal">keymap</code>を指定します。Emacsのさまざまな部分は、実際の定義をロードせずに、これらの情報を知る必要があるのです。
</p><p>オートロードされたキーマップは、あるプレフィクスキーがシンボル<em class="replaceable"><code>function</code></em>にバインドされているときにキーを探す間に、自動的にロードされます。そのキーマップにたいする他の類のアクセスでは、オートロードは発生しません。特に、Lispプログラムが変数の値からそのキーマップを取得して<code class="literal">define-key</code>を呼び出した場合には、たとえその変数の名前がシンボル<em class="replaceable"><code>function</code></em>と同じであっても、オートロードは起こりません。
</p><a id="idm56194128" class="indexterm"/><p><em class="replaceable"><code>function</code></em>が非voidのオートロードされたオブジェクトではない関数定義をもつ場合、その関数は何も行わず<code class="literal">nil</code>をリターンします。それ以外は、オートロードされたオブジェクト(<a class="link" href="ch03s03.html#Autoload-Type" title="Autoload Type">Autoload
Type</a>を参照)を作成して、それを<em class="replaceable"><code>function</code></em>にたいする関数定義として格納します。オートロードされたオブジェクトは、以下の形式をもちます:
</p><pre class="screen">(autoload <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>docstring</code></em> <em class="replaceable"><code>interactive</code></em> <em class="replaceable"><code>type</code></em>)
</pre><p>たとえば、
</p><pre class="screen">(symbol-function 'run-prolog)
     ⇒ (autoload "prolog" 169681 t nil)
</pre><p>このような場合、<code class="literal">"prolog"</code>はロードするファイルの名前、169681は<code class="filename">emacs/etc/DOC</code>ファイル(<a class="link" href="ch24.html#Documentation-Basics" title="Documentation Basics">Documentation
Basics</a>を参照)内のドキュメント文字列への参照で、<code class="literal">t</code>はその関数がインタラクティブであり、<code class="literal">nil</code>はそれがマクロやキーマップでないことを意味します。
</p></blockquote></div><pre class="synopsis"><a id="idm56185168" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">autoloadp</code> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>object</code></em>がオートロードされたオブジェクトの場合、非<code class="literal">nil</code>をリターンします。たとえば、<code class="literal">run-prolog</code>がオートロードされたオブジェクトかチェックするには、以下を評価します
</p><pre class="screen">(autoloadp (symbol-function 'run-prolog))
</pre></blockquote></div><a id="idm56180304" class="indexterm"/><p>オートロードされたファイルは、通常は他の定義を含み、1つ以上の機能を必要あるいは提供するかもしれません。(内容の評価でのエラーにより)そのファイルが完全にロードされていない場合、そのロードの間に行われた関数定義や<code class="literal">provide</code>の呼び出しはアンドゥされます。これは、このファイルからオートロードされる関数にたいして再度呼び出しを試みたときに、そのファイルを確実に再ロードさせるためです。このようにしないと、そのファイル内のいくつかの関数はアボートしたロードにより定義されていて、それらはロードされなかった修正後のファイルで提供される正しいサブルーチンを欠くため、正しく機能しないからです。
</p><p>オートロードされたファイルが意図したLisp関数、またはマクロの定義に失敗した場合には、データ<code class="literal">"Autoloading failed to
define function <em class="replaceable"><code>function-name</code></em>"</code>とともにエラーがシグナルされます。
</p><a id="idm56156880" class="indexterm"/><a id="idm56156112" class="indexterm"/><a id="idm56155344" class="indexterm"/><a id="idm56154576" class="indexterm"/><a id="autoload-cookie"/><p>オートロードのマジックコメント(<em class="firstterm">autoload
cookie</em>とも呼ばれる)は、オートロード可能なソースファイル内の実際の定義の直前にある、‘<code class="literal">;;;###autoload</code>’だけの行から構成されます。コマンド<strong class="userinput"><code>M-x
update-file-autoloads</code></strong>は、対応する<code class="literal">autoload</code>呼び出しを<code class="filename">loaddefs.el</code>内に書き込みます。(autoload
cookieとなる文字列と、<code class="literal">update-file-autoloads</code>により生成されるファイルの名前は、上述のデフォルトから変更可能です。以下を参照。)
Emacsのビルドでは<code class="filename">loaddefs.el</code>をロードするために<code class="literal">autoload</code>を呼び出します。<strong class="userinput"><code>M-x
update-directory-autoloads</code></strong>は、より強力です。このコマンドはカレントディレクトリー内のすべてのファイルにたいするオートロードを更新します。
</p><p>このマジックコメントは、任意の種類のフォームを、<code class="filename">loaddefs.el</code>内にコピーできます。このマジックコメントに続くフォームは、そのままコピーされます。しかしオートロード機能が特別に処理するフォームの場合は<span class="emphasis"><em>除外</em></span>されます(たとえば<code class="literal">autoload</code>内への変換)。以下は、そのままコピーされないフォームです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">関数、または関数のようなオブジェクトにたいする定義:
</span></dt><dd><p><code class="literal">defun</code>と<code class="literal">defmacro</code>。<code class="literal">cl-defun</code>と<code class="literal">cl-defmacro</code>(section “Argument
Lists” in <em class="citetitle">Common Lisp
Extensions</em>を参照)、および<code class="literal">define-overloadable-function</code>
(<code class="filename">mode-local.el</code>内のコメントを参照)も該当
</p></dd><dt><span class="term">メジャーモードおよびマイナーモードにたいする定義:
</span></dt><dd><p><code class="literal">define-minor-mode</code>、<code class="literal">define-globalized-minor-mode</code>、<code class="literal">define-generic-mode</code>、<code class="literal">define-derived-mode</code>、<code class="literal">easy-mmode-define-minor-mode</code>、<code class="literal">easy-mmode-define-global-mode</code>、<code class="literal">define-compilation-mode</code>、<code class="literal">define-global-minor-mode</code>。
</p></dd><dt><span class="term">その他のタイプの定義:
</span></dt><dd><p><code class="literal">defcustom</code>、<code class="literal">defgroup</code>、<code class="literal">defclass</code>
(section “EIEIO” in <em class="citetitle">EIEIO</em>を参照)、および<code class="literal">define-skeleton</code>
(<code class="filename">skeleton.el</code>内のコメントを参照)。
</p></dd></dl></div><p>ビルド時に、そのファイル自身をロードするときにフォームを<span class="emphasis"><em>実行しないように</em></span>、マジックコメントを使用することもできます。これを行なうには、マジックコメントと同じ行にフォームを記述します。これはコメントなので、ソースファイルをロードするとき何も行いません。ただし<strong class="userinput"><code>M-x
update-file-autoloads</code></strong>は、Emacsビルド時に実行されたものは、<strong class="userinput"><code>M-x
update-file-autoloads</code></strong>にコピーします。
</p><p>以下は、マジックコメントによるオートロードのために<code class="literal">doctor</code>を準備する例です:
</p><pre class="screen">;;;###autoload
(defun doctor ()
  "Switch to *doctor* buffer and start giving psychotherapy."
  (interactive)
  (switch-to-buffer "*doctor*")
  (doctor-mode))
</pre><p>これにより、以下が<code class="filename">loaddefs.el</code>内に書き込まれます:
</p><pre class="screen">(autoload (quote doctor) "doctor" "\
Switch to *doctor* buffer and start giving psychotherapy.

\(fn)" t nil)
</pre><p><a id="idm56129232" class="indexterm"/>
ダブルクォートの直後のバックスラッシュまたは改行は、<code class="filename">loaddefs.el</code>のようなプリロードされた未コンパイルだけに使用される慣習です。これは、<code class="literal">make-docfile</code>にたいして、ドキュメント文字列を<code class="filename">etc/DOC</code>ファイルに配するよう指示します。<a class="link" href="ape.html#Building-Emacs" title="Building Emacs">Building
Emacs</a>を参照してください。また、<code class="filename">lib-src/make-docfile.c</code>内のコメントも参照してください。ドキュメント文字列の使い方(usage
part)の中の‘<code class="literal">(fn)</code>’は、種々のヘルプ関数(<a class="link" href="ch24s05.html" title="Help Functions">Help
Functions</a>を参照)が表示するとき、その関数の名前に置き換えられます。
</p><p>関数定義手法として既知ではなく、認められてもいないような、通常とは異なるマクロにより関数定義を記述した場合、通常のオートロードのマジックコメントの使用により、定義全体が<code class="literal">loaddefs.el</code>内にコピーされるでしょう。これは期待した動作ではありません。かわりに以下を記述することにより、意図した<code class="literal">autoload</code>呼び出しを<code class="literal">loaddefs.el</code>内に配することができます。
</p><pre class="screen">;;;###autoload (autoload 'foo "myfile")
(mydefunmacro foo
  ...)
</pre><p>autoload
cookieとして、デフォルト以外の文字列を使用して、デフォルトの<code class="filename">loaddefs.el</code>とは異なるファイル内に、対応するオートロード呼び出しを記述できます。これを制御するために、Emacsは2つの変数を提供します:
</p><pre class="synopsis"><a id="idm56092112" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">generate-autoload-cookie</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、Lispコメントの文法に準じた文字列です。<strong class="userinput"><code>M-x
update-file-autoloads</code></strong>は、そのcookieの後のLispフォームを、cookieが生成したオートロードファイル内にコピーします。この変数のデフォルト値は、<code class="literal">";;;###autoload"</code>です。
</p></blockquote></div><pre class="synopsis"><a id="idm56084304" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">generated-autoload-file</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、オートロード呼び出しが書き込まれるEmacs
Lispファイルを命名します。デフォルト値は<code class="filename">loaddefs.el</code>ですが、(たとえば<code class="filename">.el</code>ファイル内のセクション“Local
Variables”))をオーバーライドできます。オートロードファイルは、フォームフィード文字で開始される終端を含んでいると仮定されます。
</p></blockquote></div><p>以下の関数は、オートロードオブジェクトにより指定されたライブラリーを明示的にロードするために使用されるかもしれません:
</p><pre class="synopsis"><a id="idm56080208" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">autoload-do-load</code> <em class="replaceable"><code>autoload</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>macro-only</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はオートロードオブジェクト<em class="replaceable"><code>autoload</code></em>により指定されたロードを処理します。オプション引数<em class="replaceable"><code>name</code></em>に非<code class="literal">nil</code>を指定する場合は、関数値が<em class="replaceable"><code>autoload</code></em>となるシンボルを指定します。この場合、この関数のリターン値は、そのシンボルの新しい関数値になります。オプション引数<em class="replaceable"><code>macro-only</code></em>の値が<code class="literal">macro</code>の場合、この関数は関数ではなくマクロのロードだけを有効にします。
</p></blockquote></div></div></body></html>