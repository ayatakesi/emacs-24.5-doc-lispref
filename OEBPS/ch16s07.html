<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Features</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Named-Features"/>Features</h1></div></div></div><a id="idm56048720" class="indexterm"/><a id="idm56047952" class="indexterm"/><a id="idm56047184" class="indexterm"/><p><code class="literal">provide</code>と<code class="literal">require</code>は、<code class="literal">autoload</code>にかわるファイルを自動的にロードする関数です。これらは名前付きの<em class="firstterm">フィーチャ(feature:
機能)</em>という面で機能します。オートロードは特定の関数の呼び出しをトリガーにしますが、フィーチャーは最初は他のプログラムが名前により問い合わせたときにロードされます。
</p><p>フィーチャ名とは、関数、変数などのコレクションを表すシンボルです。これらを定義するファイルは、そのフィーチャを<em class="firstterm">プロバイド(provide:
提供)</em>すべきです。これらのフィーチャを使用する他のプログラムは、その機能を<em class="firstterm">リクワイア(require:
要求)</em>することにより、それらが定義されているか確認できるでしょう。これは、定義がまだロードされていなければ、定義ファイルをロードします。
</p><a id="idm56043088" class="indexterm"/><p>フィーチャをリクワイアするには、フィーチャ名を引数として<code class="literal">require</code>を呼び出します。<code class="literal">require</code>は、意図する機能がすでにプロバイドされているか確認するために、グローバル変数<code class="literal">features</code>を調べます。もしプロバイドされていなければ、適切なファイルからそのフィーチャをロードします。このファイルは、そのフィーチャを<code class="literal">features</code>に追加するために、トップレベルで<code class="literal">provide</code>を呼び出すべきです。これに失敗すると、<code class="literal">require</code>はエラーをシグナルします。
</p><p>たとえば、<code class="filename">idlwave.el</code>内の<code class="literal">idlwave-complete-filename</code>にたいする定義には、以下のコードが含まれます:
</p><pre class="screen">(defun idlwave-complete-filename ()
  "Use the comint stuff to complete a file name."
   (require 'comint)
   (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
          (comint-completion-addsuffix nil)
          ...)
       (comint-dynamic-complete-filename)))
</pre><p>式<code class="literal">(require
'comint)</code>は、<code class="filename">comint.el</code>がまだロードされていなければ、<code class="literal">comint-dynamic-complete-filename</code>が確実に定義されるように、そのファイルをロードします。フィーチャは通常、それらを提供するファイルにしたがって命名されるため、<code class="literal">require</code>にファイル名を与える必要はありません。(<code class="literal">require</code>命令文が<code class="literal">let</code>のボディーの外側にあるのが重要なことに注意してください。変数がletバインドされているライブラリーをロードすることにより、意図せぬ結果、つまりletをexitした後にその変数がアンバインドされます。)
</p><p><code class="filename">comint.el</code>には以下のトップレベル式が含まれます:
</p><pre class="screen">(provide 'comint)
</pre><p>これは<code class="literal">comint</code>はグローバルなリスト<code class="literal">features</code>に追加するので、<code class="literal">(require
'comint)</code>は今後何も行う必要がないことを知ることができます。
</p><a id="idm56030160" class="indexterm"/><p>ファイルのトップレベル<code class="literal">require</code>が使用されたときは、それをロードしたときと同様、そのファイルをバイトコンパイル(<a class="link" href="ch17.html" title="Chapter 16. Byte Compilation">Byte
Compilation</a>を参照)したときにも効果が表れます。これはリクワイアされたパッケージがマクロを含み、バイトコンパイラーがそれを知らなければならない場合です。これは<code class="literal">require</code>によりロードされるファイルで定義される関数と変数にたいするバイトコンパイラーの警告も無効にします。
</p><p>バイトコンパイルの間にトップレベルの<code class="literal">require</code>が評価されるとしても、<code class="literal">provide</code>呼び出しは評価されません。したがって、以下の例のように<code class="literal">provide</code>の後に同じ機能にたいする<code class="literal">require</code>を含めることにより、バイトコンパイル前に定義しているファイルを確実にロードできます。
</p><pre class="screen">(provide 'my-feature)  ; バイトコンパイラーには無視され、
                       ;   <code class="literal">load</code>には評価される。
(require 'my-feature)  ; バイトコンパイラーにより評価される。
</pre><p>コンパイラーは<code class="literal">provide</code>を無視して、その後に対象のファイルをロードすることにより<code class="literal">require</code>が処理されます。ファイルのロードは<code class="literal">provide</code>呼び出しを実行するので、後続の<code class="literal">require</code>はファイルがロードされているときは何も行いません。
</p><pre class="synopsis"><a id="idm56020688" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">provide</code> <em class="replaceable"><code>feature</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>subfeatures</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントEmacsセッションに<em class="replaceable"><code>feature</code></em>がロードされた、あるいはロードされつつあることをアナウンスします。これは、<em class="replaceable"><code>feature</code></em>に関連する機能が他のLispプログラムから利用可能できる、あるいは利用可能になることを意味します。
</p><p><code class="literal">provide</code>を呼び出すことによる直接的な効果は、まだ<em class="replaceable"><code>feature</code></em>が<em class="replaceable"><code>features</code></em>内に存在しない場合はリストの先頭に追加して、それを必要としている<code class="literal">eval-after-load</code>コードを呼び出します(<a class="link" href="ch16s10.html" title="Hooks for Loading">Hooks
for
Loading</a>を参照)。引数<em class="replaceable"><code>feature</code></em>はシンボルでなければなりません。<code class="literal">provide</code>は<em class="replaceable"><code>feature</code></em>をリターンします。
</p><p><em class="replaceable"><code>subfeatures</code></em>が与えられた場合、それは<em class="replaceable"><code>feature</code></em>の当該バージョンによりプロバイドされる特定のサブフィーチャのセットを示すシンボルのリストであるべきです。<code class="literal">featurep</code>を使用して、サブフィーチャの存在をテストできます。あるパッケージの、ロードされるか、あるいはそのバージョンに存在するか不明なさまざまな部分や機能に名前を与えて使いやすくするには、そのパッケージが複雑すぎるときにサブフィーチャを使用するというのがサブフィーチャというアイデアです。例としては、<a class="link" href="ch37s17.html#Network-Feature-Testing" title="Testing Availability of Network Features">Network
Feature Testing</a>を参照してください。
</p><pre class="screen">features
     ⇒ (bar bish)

(provide 'foo)
     ⇒ foo
features
     ⇒ (foo bar bish)
</pre><p>オートロードによりあるファイルがロードされて、その内容の評価エラーによりストップいたとき、そのロードの間に発生した関数定義や<code class="literal">provide</code>呼び出しはアンドゥされます。<a class="link" href="ch16s05.html" title="Autoload">Autoload</a>を参照してください。
</p></blockquote></div><pre class="synopsis"><a id="idm56008144" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">require</code> <em class="replaceable"><code>feature</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>noerror</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はカレントEmacsセッションにおいて、<em class="replaceable"><code>feature</code></em>が存在するかどうかを、(<code class="literal">(featurep
<em class="replaceable"><code>feature</code></em>)</code>を使用して。以下を参照)をチェックします。引数<em class="replaceable"><code>feature</code></em>はシンボルでなければなりません。
</p><p>そのフィーチャが存在しない場合、<code class="literal">require</code>は<code class="literal">load</code>により<em class="replaceable"><code>filename</code></em>をロードします。<em class="replaceable"><code>filename</code></em>が与えられなかった場合は、シンボル<em class="replaceable"><code>feature</code></em>の名前がロードするファイル名のベースとして使用されます。しかしこの場合、<code class="literal">require</code>は<em class="replaceable"><code>feature</code></em>を探すためにサフィックス‘<code class="literal">.el</code>’および‘<code class="literal">.elc</code>’の追加を強制します(圧縮ファイルのサフィックスに拡張されるかもしれません)。名前がただの<em class="replaceable"><code>feature</code></em>というファイルは使用されません。(変数<code class="literal">load-suffixes</code>は要求されるLispサフィックスを正確に指定します。)
</p><p><em class="replaceable"><code>noerror</code></em>が非<code class="literal">nil</code>の場合は、ファイルの実際のロードにおけるエラーを抑止します。この場合、そのファイルのロードが失敗すると、<code class="literal">require</code>は<code class="literal">nil</code>をリターンします。通常では、<code class="literal">require</code>は<em class="replaceable"><code>feature</code></em>をリターンします。
</p><p>ファイルのロードは成功したが<em class="replaceable"><code>feature</code></em>をプロバイドしていない場合、<code class="literal">require</code>は‘<code class="literal">Required
feature <em class="replaceable"><code>feature</code></em> was not provided</code>’のようにエラーをシグナルします。
</p></blockquote></div><pre class="synopsis"><a id="idm55991504" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">featurep</code> <em class="replaceable"><code>feature</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>subfeature</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントEmacsセッション<em class="replaceable"><code>feature</code></em>がプロバイドされている場合(たとえば<em class="replaceable"><code>feature</code></em><code class="literal">features</code>のメンバーの場合)は<code class="literal">t</code>をリターンします。<em class="replaceable"><code>subfeature</code></em>が非<code class="literal">nil</code>の場合、この関数はサブフィーチャも同様にプロバイドされているとき(たとえば<em class="replaceable"><code>subfeature</code></em>がシンボル<em class="replaceable"><code>feature</code></em>のプロパティ<code class="literal">subfeature</code>のメンバーのとき)だけ<code class="literal">t</code>をリターンします。
</p></blockquote></div><pre class="synopsis"><a id="idm55983184" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">features</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値はシンボルのリストで、このシンボルはカレントEmacsセッションにロードされたフィーチャです。シンボルはそれぞれ<code class="literal">provide</code>を呼び出すことにより、このリストにputされたものです。リスト<code class="literal">features</code>内の要素の順番に意味はありません。
</p></blockquote></div></div></body></html>