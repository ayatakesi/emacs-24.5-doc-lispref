<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Disassembled Byte-Code</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Disassembly"/>Disassembled Byte-Code</h1></div></div></div><a id="idm55656016" class="indexterm"/><p>人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しかし、好奇心を満たすために、わたしたちはディスアセンブラを提供しています。ディスアセンブラは、バイトコードを人間が読めるフォームに変換します。
</p><p>バイトコードインタープリターは、シンプルなスタックマシンとして実装されています。これは値を自身のスタックにpushして、計算で使用するためにそれらをpopして取り出し、おの結果を再びそのスタックにpushして戻します。バイトコード関数がリターンするときは、スタックから値をpopして取り出し、その関数の値としてリターンします。
</p><p>それに加えてスタックとバイトコード関数は、値を変数とスタックの間で転送することにより、普通のLisp変数を使用したり、バインドおよびセットすることができます。
</p><pre class="synopsis"><a id="idm55653840" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">disassemble</code> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer-or-name</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、<em class="replaceable"><code>object</code></em>にたいするディスアセンブルされたコードを表示します。インタラクティブに使用した場合、または<em class="replaceable"><code>buffer-or-name</code></em>が<code class="literal">nil</code>か省略された場合は、<code class="filename">*Disassemble*</code>という名前のバッファーに出力します。<em class="replaceable"><code>buffer-or-name</code></em>が非<code class="literal">nil</code>の場合は、バッファーもしくは既存のバッファーの名前でなければなりません。その場合は、そのバッファーのポイント位置に出力され、ポイントは出力の前に残りされます。
</p><p>引数<em class="replaceable"><code>object</code></em>には関数名、ラムダ式(<a class="link" href="ch13s02.html" title="Lambda Expressions">Lambda
Expressions</a>を参照)、またはバイトコードオブジェクト(<a class="link" href="ch17s07.html" title="Byte-Code Function Objects">Byte-Code
Objects</a>を参照)を指定できます。ラムダ式の場合、<code class="literal">disassemble</code>はそれをコンパイルしてから、そのコンパイル済みコードをディスアセンブルします。
</p></blockquote></div><p>以下に<code class="literal">disassemble</code>関数を使用した例を2つ示します。バイトコードとLispソースを関連付ける助けとなるように、説明的なコメントを追加してあります。これらのコメントは、<code class="literal">disassemble</code>の出力にはありません。
</p><pre class="screen">(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     ⇒ factorial
</pre><pre class="screen">
</pre><pre class="screen">(factorial 4)
     ⇒ 24
</pre><pre class="screen">
</pre><pre class="screen">(disassemble 'factorial)
     ⊣ byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
</pre><pre class="screen">
</pre><pre class="screen">0   varref   integer      ; <code class="literal">integer</code>の値を取得して
                          ;   それをスタック上にpushする。
1   constant 1            ; スタック上に1をpushする。
</pre><pre class="screen">2   eqlsign               ; 2つの値をスタックからpopして取り出し、
                          ;   それらを比較して結果をスタック上にpushする。
</pre><pre class="screen">3   goto-if-nil 1         ; スタックのトップをpopしてテストする。
                          ;   <code class="literal">nil</code>なら1へ、それ以外はcontinue。
6   constant 1            ; スタックのトップに1をpushする。
7   return                ; スタックのトップの要素をリターンする。
</pre><pre class="screen">8:1 varref   integer      ; <code class="literal">integer</code>の値をスタック上にpushする。
9   constant factorial    ; <code class="literal">factorial</code>をスタック上にpushする。
10  varref   integer      ; <code class="literal">integer</code>の値をスタック上にpushする。
11  sub1                  ; <code class="literal">integer</code>をpopして値をデクリメントする。
                          ;   スタック上に新しい値をpushする。
12  call     1            ; スタックの最初(トップ)の要素を引数として
                          ;   関数<code class="literal">factorial</code>を呼び出す。
                          ;   リターン値をスタック上にpushする。
</pre><pre class="screen">13 mult                   ; スタックのトップ2要素をpopして取り出し乗じ
                          ;   結果をスタック上にpushする。
14 return                 ; スタックのトップ要素をリターンする。
</pre><p><code class="literal">silly-loop</code>は幾分複雑です:
</p><pre class="screen">(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (&gt; (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     ⇒ silly-loop
</pre><pre class="screen">
</pre><pre class="screen">(disassemble 'silly-loop)
     ⊣ byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
</pre><pre class="screen">
</pre><pre class="screen">0   constant current-time-string  ; <code class="literal">current-time-string</code>を
                                  ;   スタック上のトップにpushする。
</pre><pre class="screen">1   call     0            ; 引数なしで<code class="literal">current-time-string</code>を呼び出し
                          ;   結果をスタック上にpushする。
</pre><pre class="screen">2   varbind  t1           ; スタックをpopして<code class="literal">t1</code>にpopされた値をバインドする。
</pre><pre class="screen">3:1 varref   n            ; 環境から<code class="literal">n</code>の値を取得して
                          ;   その値をスタック上にpushする。
4   sub1                  ; スタックのトップから1を減ずる。
</pre><pre class="screen">5   dup                   ; スタックのトップを複製する。
                          ;   たとえばスタックのトップをコピーしてスタック上にpushする。
6   varset   n            ; スタックのトップをpopして
                          ;   <code class="literal">n</code>をその値にバインドする。

;; (要はシーケンス<code class="literal">dup varset</code>はpopせずに
;;  スタックのトップを<code class="literal">n</code>の値にコピーする。)
</pre><pre class="screen">
</pre><pre class="screen">7   constant 0            ; スタック上に0をpushする。
8   gtr                   ; スタックのトップ2値をpopして取り出し
                          ;   <em class="replaceable"><code>n</code></em>が0より大かテストし
                          ;   結果をスタック上にpushする。
</pre><pre class="screen">9   goto-if-not-nil 1     ; <code class="literal">n</code> &gt; 0なら1へ
                          ;   (これはwhile-loopを継続する)
                          ;   それ以外はcontinue。
</pre><pre class="screen">12  varref   t1           ; <code class="literal">t1</code>の値をスタック上にpushする。
13  constant current-time-string  ; <code class="literal">current-time-string</code>を
                                  ;   スタックのトップにpushする。
14  call     0            ; 再度<code class="literal">current-time-string</code>を呼び出す。
</pre><pre class="screen">15  unbind   1            ; ローカル環境の<code class="literal">t1</code>をアンバインドする。
16  list2                 ; スタックのトップ2要素をpopして取り出し
                          ;   それらのリストを作りスタック上にpushする。
17  return                ; スタックのトップの値をリターンする。
</pre></div></body></html>