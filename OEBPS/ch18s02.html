<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Edebug</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Edebug"/>Edebug</h1></div></div></div><a id="idm55273680" class="indexterm"/><p>EdebugはEmacs Lispプログラムにたいするソースレベルデバッガです。これにより、以下のことができます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>式の前や後でストップして、評価をステップで実行する。
</p></li><li class="listitem"><p>条件付き、または無条件のbreakpointのセット。
</p></li><li class="listitem"><p>指定された条件がtrueのときにストップする(グローバルbreakpoint)。
</p></li><li class="listitem"><p>ストップポイントごとに停止したり、breakpointごとに簡単に停止して、低速または高速にトレースを行う。
</p></li><li class="listitem"><p>Edebug外部であるかのように、式の結果を表示し、式を評価する。
</p></li><li class="listitem"><p>式のリストを自動的に再評価して、Edebugがディスプレイを更新するたびにそれらの結果を表示する。
</p></li><li class="listitem"><p>関数呼び出しとリターンのトレース情報を出力する。
</p></li><li class="listitem"><p>エラー発生時にストップする。
</p></li><li class="listitem"><p>Edebug自身のフレームを除外してbacktraceを表示する。
</p></li><li class="listitem"><p>マクロおよびフォームの定義で引数の評価を指定する。
</p></li><li class="listitem"><p>初歩的なカバレッジテストと頻度数の取得。
</p></li></ul></div><p>以下の初めの3つのセクションは、使用を開始するためにEdebugについて十分説明します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Using-Edebug"/>Using Edebug</h2></div></div></div><p>EdebugでLispプログラムをデバッグするには、最初にデバッグしたいLispコードを<em class="firstterm">インストルメント(instrument:
計装)</em>しなければなりません。これを行なうもっともシンプルな方法は、関数またはマクロの定義に移動して、<strong class="userinput"><code>C-u
C-M-x</code></strong>(プレフィクス引数を指定した<code class="literal">eval-defun</code>)を行います。コードをインストルメントする他の手段については、<a class="link" href="ch18s02.html#Instrumenting" title="Instrumenting for Edebug">Instrumenting</a>を参照してください。
</p><p>一度関数をインストルメントすると、その関数にたいする任意の呼び出しにより、Edebugがアクティブになります。Edebugがアクティブになると、どのEdebug実行モードを選択したかに依存して、その関数をステップ実行できるように実行がストップされるか、ディスプレイを更新してデバッグコマンドにたいするチェックの間、実行が継続されます。デフォルトの実行モードstepで、これは実行をストップします。<a class="link" href="ch18s02.html#Edebug-Execution-Modes" title="Edebug Execution Modes">Edebug
Execution Modes</a>を参照してください。
</p><p>Edebugでは通常、デバッグしているLispコードをEmacsバッファーで閲覧します。これを<em class="firstterm">ソースコードバッファー(source code
buffer)</em>と呼び、バッファーは一時的に読み取り専用になります。
</p><p>左フリンジの矢印は、その関数で実行されている行を示します。最初ポイントはその関数の実行されている行にありますが、ポイントを移動するとこれは真ではなくなります。
</p><p>以下は、<code class="literal">fac</code>の定義(以下を参照)をインストルメントして<code class="literal">(fac
3)</code>を実行した場合に通常目にするものです。ポイントは、<code class="literal">if</code>の前の開きカッコにあります。
</p><pre class="screen">(defun fac (n)
=&gt;★(if (&lt; 0 n)
      (* n (fac (1- n)))
    1))
</pre><a id="idm55250384" class="indexterm"/><p>関数内でEdebugが実行をストップできる位置のことを、<em class="firstterm">ストップポイント(stop
points)</em>と呼びます。ストップポイントは、リストであるような部分式の前後、および変数参照の後でも発生します。以下は、関数<code class="literal">fac</code>内のストップポイントをピリオドで示したものです:
</p><pre class="screen">(defun fac (n)
  .(if .(&lt; 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
</pre><p>Emacs
Lispモードのコマンドに加えて、ソースコードバッファーでは、Edebugのスペシャルコマンドが利用できます。たとえば、Edebugコマンド<span class="keycap"><strong>SPC</strong></span>で次のストップポイントまで実行することができます。<code class="literal">fac</code>にエントリーした後に一度<code class="literal">fac</code>とタイプした場合は、以下のように表示されるでしょう:
</p><pre class="screen">(defun fac (n)
=&gt;(if ★(&lt; 0 n)
      (* n (fac (1- n)))
    1))
</pre><p>式の後でEdebugが実行をストップしたときは、エコーエリアにその式の値が表示されます。
</p><p>他にも頻繁に使用されるコマンドとして、ストップポイントにbreakpointをセットする<strong class="userinput"><code>b</code></strong>、breakpointに達するまで実行する<strong class="userinput"><code>g</code></strong>、Edebugをexitしてトップレベルのコマンドループにリターンする<strong class="userinput"><code>q</code></strong>があります。また、<strong class="userinput"><code>?</code></strong>とタイプするとすべてのEdebugコマンドがリストされます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Instrumenting"/>Instrumenting for Edebug</h2></div></div></div><a id="idm55241296" class="indexterm"/><p>LispコードのデバッグにEdebugを使用するためには、最初にそのコードを<em class="firstterm">インストルメント(instrument:
計装)</em>しなければなりません。コードをインストルメントすると、適切な位置でEdebugを呼び出すために追加コードが挿入されます。
</p><a id="idm55239760" class="indexterm"/><a id="idm55238992" class="indexterm"/><p>関数定義でプレフィクス引数とともにコマンド<strong class="userinput"><code>C-M-x</code></strong>
(<code class="literal">eval-defun</code>)を呼び出すと、それを評価する前にその定義をインストルメントします。(ソースコード自体は変更しません。)
変数<code class="literal">edebug-all-defs</code>が非<code class="literal">nil</code>の場合は、プレフィクス引数の意味を反転します。この場合、<strong class="userinput"><code>C-M-x</code></strong>はプレフィクス引数が<span class="emphasis"><em>なければ</em></span>その定義をインストルメントします。<code class="literal">edebug-all-defs</code>のデフォルト値は<code class="literal">nil</code>です。コマンド<strong class="userinput"><code>M-x
edebug-all-defs</code></strong>は、変数<code class="literal">edebug-all-defs</code>の値を切り替えます。
</p><a id="idm55232848" class="indexterm"/><a id="idm55232080" class="indexterm"/><a id="idm55231312" class="indexterm"/><p><code class="literal">edebug-all-defs</code>が非<code class="literal">nil</code>の場合は<code class="literal">eval-region</code>、<code class="literal">eval-current-buffer</code>、<code class="literal">eval-buffer</code>も、それらが評価する定義をインストルメントします。同様に、<code class="literal">edebug-all-forms</code>は、<code class="literal">eval-region</code>が(非定義フォームさえ含む）<span class="emphasis"><em>あらゆる</em></span>フォームをインストルメントすべきかを制御します。これはミニバッファー内でのロードや評価には適用されません。コマンド<strong class="userinput"><code>M-x
edebug-all-forms</code></strong>は、このオプションを切り替えます。
</p><a id="idm55225808" class="indexterm"/><a id="idm55225040" class="indexterm"/><p>他にもコマンド<strong class="userinput"><code>M-x
edebug-eval-top-level-form</code></strong>が利用可能で、これは<code class="literal">edebug-all-defs</code>や<code class="literal">edebug-all-forms</code>の値に関わらず、トップレベルの任意のフォームをインストルメントします。<code class="literal">edebug-defun</code>は<code class="literal">edebug-eval-top-level-form</code>のエイリアスです。
</p><p>Edebugがアクティブのの間、コマンド<strong class="userinput"><code>I</code></strong>(<code class="literal">edebug-instrument-callee</code>)は、ポイント後のリストフォームに呼び出される関数およびマクロ定義がまだインストルメントされていなければ、それらをインストルメントします。これは、そのファイルのソースの場所をEdebugが知っている場合だけ可能です。この理由によりEdebugロード後は、たとえ評価する定義をインストルメントしない場合でも、<code class="literal">eval-region</code>は評価するすべての定義の位置を記録します。インストルメント済み関数呼び出しにステップインする<strong class="userinput"><code>i</code></strong>コマンド(<a class="link" href="ch18s02.html#Jumping" title="Jumping">Jumping</a>を参照)も参照してください。
</p><p>Edebugはすべての標準スペシャルフォーム、式引数をもつ<code class="literal">interactive</code>フォーム、無名ラムダ式、およびその他の定義フォームのインストルメント方法を知っています。しかし、Edebugはユーザー定義マクロが引数にたいして何を行うかを判断できないので、Edebug仕様を使用してその情報を与えなければなりません。詳細は<a class="link" href="ch18s02.html#Edebug-and-Macros" title="Edebug and Macros">Edebug
and Macros</a>を参照してください。
</p><p>Edebugがセッション内で最初にコードをインストルメントしようとするときは、フック<code class="literal">edebug-setup-hook</code>を実行してから、それに<code class="literal">nil</code>をセットします。使おうとしているパッケージに結びつけてEdebug仕様をロードするためにこれを使用できますが、それはEdebugを使用するときだけ機能します。
</p><a id="idm55203280" class="indexterm"/><p>定義からインストルメントを削除するには、単にインストルメントを行わない方法でその定義を再評価するだけです。フォームを絶対にインストルメントせずに評価するには、2つの方法があります。それはファイルからの<code class="literal">load</code>による評価と、ミニバッファーからの<code class="literal">eval-expression</code>(<strong class="userinput"><code>M-:</code></strong>)による評価です。
</p><p>Edebugがインストルメント中にシンタックスエラー(syntax error:
構文エラー)を検知した場合は、間違ったコードの箇所にポイントを残して<code class="literal">invalid-read-syntax</code>エラーをシグナルします。
</p><p>Edebug内で利用可能な他の評価関数については、<a class="link" href="ch18s02.html#Edebug-Eval" title="Evaluation">Edebug Eval</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-Execution-Modes"/>Edebug Execution Modes</h2></div></div></div><a id="idm55197392" class="indexterm"/><p>Edebugは、デバッグするプログラムの実行にたいして、いくつかの実行モードをサポートします。これらの実行モードを、<em class="firstterm">Edebug実行モード(Edebug
execution
modes)</em>と呼びます。これらをメジャーモードやマイナーモードと混同しないでください。カレントのEdebug実行モードは、プログラムをストップする前にEdebugがどれだけ実行を継続するか
— たとえばストップポイントごとにストップ、あるいは次のbreakpointまで継続など —
と、ストップする前にEdebugがどれだけ進捗を表示するかを決定します。
</p><p>Edebug実行モードは通常、ある特定のモードでプログラムを継続させるコマンドをタイプすることにより指定します。以下は、それらのコマンドのテーブルです。プログラムの実行を再開<strong class="userinput"><code>S</code></strong>以外は、少なくともある長さの間だけ実行を継続します。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>S</code></strong>
</span></dt><dd><p>Stop(ストップ): これ以上プログラムを実行しないで、Edebugのコマンドを待つ(<code class="literal">edebug-stop</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code><span class="keycap"><strong>SPC</strong></span></code></strong>
</span></dt><dd><p>Step(ステップ): 次のストップポイントでストップする(<code class="literal">edebug-step-mode</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>n</code></strong>
</span></dt><dd><p>Next(次へ):
式の後にある次のストップポイントでストップする(<code class="literal">edebug-next-mode</code>)。<a class="link" href="ch18s02.html#Jumping" title="Jumping">Jumping</a>の<code class="literal">edebug-forward-sexp</code>も参照。
</p></dd><dt><span class="term"><strong class="userinput"><code>t</code></strong>
</span></dt><dd><p>Trace(トレース): Edebugのストップポイントごとにpause(通常は1秒)する(<code class="literal">edebug-trace-mode</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>T</code></strong>
</span></dt><dd><p>Rapid
trace(高速でトレース):ストップポイントごとに表示を更新するが、実際にpauseはしない(<code class="literal">edebug-Trace-fast-mode</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>g</code></strong>
</span></dt><dd><p>Go(進む): 次のbreakpointまで実行する(<code class="literal">edebug-go-mode</code>)。<a class="link" href="ch18s02.html#Breakpoints" title="Edebug Breakpoints">Breakpoints</a>を参照。
</p></dd><dt><span class="term"><strong class="userinput"><code>c</code></strong>
</span></dt><dd><p>Continue(継続): breakpointごとにpauseしてから継続する(<code class="literal">edebug-continue-mode</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C</code></strong>
</span></dt><dd><p>Rapid continue(高速で継続):
ポイントを各breakpointへ移動するが、pauseしない(<code class="literal">edebug-Continue-fast-mode</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>G</code></strong>
</span></dt><dd><p>Go non-stop(ストップせず進む):
breakpointを無視する(<code class="literal">edebug-Go-nonstop-mode</code>)。まだ<strong class="userinput"><code>S</code></strong>、またはその他の編集コマンドでプログラムをストップするのは可能。
</p></dd></dl></div><p>一般的に、上記リストの最初のほうにある実行モードは後のほうの実行モードに比べて、プログラムをより低速に実行、またはすぐにストップさせます。
</p><p>実行中、またはトレース中は、任意のEdebugコマンドをタイプすることにより、実行をインタラプト(interrupt:
中断、割り込み)できます。Edebugは次のストップポイントでプログラムをストップしてから、タイプされたコマンドを実行します。たとえば、実行中に<strong class="userinput"><code>t</code></strong>をタイプすると、次のストップポイントでトレースモードに切り替えます。<strong class="userinput"><code>S</code></strong>を使用すれば、他に何も行わずに実行をストップできます。
</p><p>関数でたまたま読み取り入力が発生した場合には、実行のインタラプトを意図してタイプされた文字は、かわりにその関数により読み取られます。そのプログラムが入力を欲するタイミングに注意を払うことで、そのような意図せぬ結果を避けることができます。
</p><a id="idm55169872" class="indexterm"/><p>このセクションのコマンドを含むキーボードマクロは、完全には機能しません。プログラムを再開するためにEdebugからexitすると、キーボードマクロの追跡記録は失われます。これを処理するのは、簡単ではありません。またEdebug外部でキーボードマクロを定義または実行しても、Edebug内部のコマンドに影響しません。通常これは利点です。<a class="link" href="ch18s02.html#Edebug-Options" title="Edebug Options">Edebug
Options</a>内の<code class="literal">edebug-continue-kbd-macro</code>オプションも参照してください。
</p><p>新たなEdebugレベルにエンターしたとき、初期の実行モードは変数<code class="literal">edebug-initial-mode</code>の値により与えられます(<a class="link" href="ch18s02.html#Edebug-Options" title="Edebug Options">Edebug
Options</a>を参照)。デフォルトでこれはstepモードを指定します。たとえば１つのコマンドからインストルメント済みの関数が複数回呼び出された場合は、同じEdebugレベルに再エンターするかもしれないことに注意してください。
</p><pre class="synopsis"><a id="idm55166032" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-sit-for-seconds</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このオプションは、traceモードおよびcontinueモードで実行ステップの間を何秒待つか指定します。デフォルトは1秒です。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Jumping"/>Jumping</h2></div></div></div><p>このセクションで説明するコマンドは、指定された場所に達するまで実行を続けます。<strong class="userinput"><code>i</code></strong>を除くすべてのコマンドは、ストップ場所を確立するために一時的なbreakpointを作成してから、goモードにスイッチします。意図されたストップポイントの前にある他のストップポイントに達した場合も、実行はストップします。breakpointの詳細は、<a class="link" href="ch18s02.html#Breakpoints" title="Edebug Breakpoints">Breakpoints</a>を参照してください。
</p><p>これらのコマンドは、非ローカルexitの場合はプログラムのストップを期待する一時的なbreakpointをバイパスできるので、期待どおり機能しないかもしれません。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>h</code></strong>
</span></dt><dd><p>ポイントがある場所の近くのストップポイントへ実行を進める(<code class="literal">edebug-goto-here</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>f</code></strong>
</span></dt><dd><p>プログラムの式を1つ分実行する(<code class="literal">edebug-forward-sexp</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>o</code></strong>
</span></dt><dd><p>sexpを含む終端までプログラムを実行する(<code class="literal">edebug-step-out</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>i</code></strong>
</span></dt><dd><p>ポイントの後のフォームから呼び出された関数またはマクロにステップインする(<code class="literal">edebug-step-in</code>)。
</p></dd></dl></div><p><strong class="userinput"><code>h</code></strong>コマンドは一時的なbreakpointを使用して、ポイントのカレント位置、またはその後のストップポイントまで処理を進めます。
</p><p><strong class="userinput"><code>f</code></strong>コマンドは式を1つ飛び越してプログラムを実家します。より正確には、<code class="literal">forward-sexp</code>により到達できる位置に一時的なbreakpointをセットしてからgoモードで実行するので、プログラムはそのbreakpointでストップすることになります。
</p><p>プレフィクス引数<em class="replaceable"><code>n</code></em>とともに使用した場合は、ポイントから<em class="replaceable"><code>n</code></em>個のsexp(s-expression:
S式)を超えた場所に一時的なbreakpointをセットします。ポイントを含むリストが<em class="replaceable"><code>n</code></em>より少ない要素で終わるような場合は、ストップ箇所はポイントが含まれる式の後になります。
</p><p><code class="literal">forward-sexp</code>が見つける位置と、プログラムを実際にストップさせたい位置なのかチェックしなければなりません。たとえば<code class="literal">cond</code>内では、これは正しくないかもしれません。
</p><p><strong class="userinput"><code>f</code></strong>コマンドは柔軟性を与えるために、<code class="literal">forward-sexp</code>をストップポイントではなく、ポイント位置から開始します。<span class="emphasis"><em>カレントのストップポイント</em></span>から1つの式を実行したい場合は、まずそこにポイントを移動するために<strong class="userinput"><code>w</code></strong>(<code class="literal">edebug-where</code>)をタイプして、それから<strong class="userinput"><code>f</code></strong>をタイプしてください。
</p><p><strong class="userinput"><code>o</code></strong>コマンドは、式の“外側”で実行を継続します。これは、ポイントを含む式の最後に一時的なbreakpointを配します。ポイントを含むsexpが関数定義の場合、<strong class="userinput"><code>o</code></strong>はその定義内の最後のsexpの直前まで実行を継続します。もし定義内の最後のsexpの直前にポイントがある場合は、その関数からリターンしてからストップします。他の言い方をすると、このコマンドは最後のsexpの後にポイントがない場合は、カレントで実行中の関数からexitしません。
</p><p><strong class="userinput"><code>i</code></strong>コマンドは、ポイントの後のリストフォームに呼び出された関数、またはマクロにステップインします。そのフォームは、評価されようとしているもの1つである必要はないことに注意してください。しかし、そのフォームが評価されようとしている関数呼び出しの場合は、引数が何も評価されないうちにこのコマンドを使用しないと、遅すぎることを覚えておいてください。
</p><p><strong class="userinput"><code>i</code></strong>コマンドは、ステップインしようとしている関数またはマクロがまだインストルメントされていない場合は、それらをインストルメントします。これは便利かもしれませんが、それらを明示的に非インストルメントしない場合、その関数またはマクロはインストルメントされたままになることを覚えておいてください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-Misc"/>Miscellaneous Edebug Commands</h2></div></div></div><p>ここでは、その他のEdebugコマンドを説明します。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>?</code></strong>
</span></dt><dd><p>Edebugのヘルプメッセージを表示する(<code class="literal">edebug-help</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-]</code></strong>
</span></dt><dd><p>1レベルを中断して以前のコマンドレベルへ戻る(<code class="literal">abort-recursive-edit</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>q</code></strong>
</span></dt><dd><p>エディターのトップレベルのコマンドループにリターンする(<code class="literal">top-level</code>)。これは、すべてのレベルのEdebugアクティビティを含む、すべての再帰編集レベルをexitする。しかし、フォーム<code class="literal">unwind-protect</code>または<code class="literal">condition-case</code>で保護されたインストルメント済みのコードはデバッグを再開するかもしれない。
</p></dd><dt><span class="term"><strong class="userinput"><code>Q</code></strong>
</span></dt><dd><p><strong class="userinput"><code>q</code></strong>と同様だが、保護されたコードでもストップしない(<code class="literal">edebug-top-level-nonstop</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>r</code></strong>
</span></dt><dd><p>エコーエリアに、もっとも最近の既知のコマンドを再表示する(<code class="literal">edebug-previous-result</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>d</code></strong>
</span></dt><dd><p>backtraceを表示するが、明確であるようにEdebug自身の関数は除外される(<code class="literal">edebug-backtrace</code>)。
</p><p>Edebugのbacktraceバッファーでは、標準デバッガ内のようにバッガコマンドは使用できない。
</p><p>実行を継続したとき、backtraceバッファーは自動的にkillされる。
</p></dd></dl></div><p>Edebugから再帰的にEdebugをアクティブにするコマンドを呼び出すことができます。Edebugがアクティブなときは常に、<strong class="userinput"><code>q</code></strong>によトップレベルの終了、または<strong class="userinput"><code>C-]</code></strong>による再帰編集1レベルの中断ができます。<strong class="userinput"><code>d</code></strong>により、すべての未解決な評価のbacktraceを表示できます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Breaks"/>Breaks</h2></div></div></div><p>Edebugのstepモードは、次のストップポイントに達したときに、実行をストップします。一度開始されたEdebugの実行をストップするには、他に3つの方法があります。それはbreakpoint、グローバルbreak条件、およびソースbreakpointです。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Breakpoints"/>Edebug Breakpoints</h3></div></div></div><a id="idm55098960" class="indexterm"/><p>Edebugを使用しているときは、テスト中のプログラム内に<em class="firstterm">breakpoint</em>を指定できます。breakpointとは、実行がストップされる場所のことです。<a class="link" href="ch18s02.html#Using-Edebug" title="Using Edebug">Using
Edebug</a>で定義されている任意のストップポイントに、breakpointをセットできます。breakpointをセットおよび解除において影響を受けるストップポイントは、ソースコードバッファー内でポイント位置、またはポイント位置の後の最初のストップポイントです。以下はEdebugのbreakpoint用のコマンドです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>b</code></strong>
</span></dt><dd><p>ポイント位置、またはポイント位置の後のストップポイントに、breakpointをセットする(<code class="literal">edebug-set-breakpoint</code>)。プレフィクス引数を使用した場合、それは一時的なbreakpointになり、プログラムが最初にそこで停止したとき解除される。
</p></dd><dt><span class="term"><strong class="userinput"><code>u</code></strong>
</span></dt><dd><p>(もしあれば)ポイント位置、またはポイント位置の後のストップポイントにあるbreakpointを解除(unset)する(<code class="literal">edebug-unset-breakpoint</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>x <em class="replaceable"><code>condition</code></em> <span class="keycap"><strong>RET</strong></span></code></strong>
</span></dt><dd><p><em class="replaceable"><code>condition</code></em>を評価して非<code class="literal">nil</code>値になる場合だけプログラムをストップする、条件付きbreakpointをセットする(<code class="literal">edebug-set-conditional-breakpoint</code>)。プレフィクス引数を指定した場合は、一時的なbreakpointになる。
</p></dd><dt><span class="term"><strong class="userinput"><code>B</code></strong>
</span></dt><dd><p>カレント定義内の、次のbreakpointにポイントを移動する(<code class="literal">edebug-next-breakpoint</code>)。
</p></dd></dl></div><p>Edebug内では、<strong class="userinput"><code>b</code></strong>でbreakpointをセットして、<strong class="userinput"><code>u</code></strong>でそれを解除できます。最初に望ましいストップポイントにポイントを移動してから、そこにbreakpointをセットまたは解除するために<strong class="userinput"><code>b</code></strong>または<strong class="userinput"><code>u</code></strong>をタイプしますbreakpointがない場所でbreakpointを解除しても、影響はありません。
</p><p>ある定義を再評価、または再インストルメントすると、以前のbreakpointはすべて削除されます。
</p><p><em class="firstterm">条件付きbreakpoint(conditional
breakpoint)</em>は、プログラムがそこに達するたびに条件をテストします。条件を評価した結果エラーが発生した場合、エラーは無視され結果は<code class="literal">nil</code>になります。条件付きbreakpointをセットするには<strong class="userinput"><code>x</code></strong>を使用して、ミニバッファーで条件式を指定します。以前にセットされた条件付きbreakpointがあるストップポイントに条件付きbreakpointをセットすると、以前の条件式がミニバッファーに配されるので、それを編集できます。
</p><p>プレフィクス引数を指定してbreakpointをセットするコマンドを使用することにより、<em class="firstterm">一時的</em>な条件付きbreakpoint、および無条件のbreakpointを作成できます。一時的なbreakpointによりプログラムがストップしたとき、そのbreakpointは自動的に解除されます。
</p><p>Go-nonstopモードを除き、Edebugは常にbreakpointでストップ、またはpauseします。Go-nonstopモードでは、breakpointは完全に無視されます。
</p><p>breakpointがどこにあるか探すには、<strong class="userinput"><code>B</code></strong>コマンドを使用します。このコマンドは同じ関数内から、ポイント以降にある次のbreakpoint(ポイント以降にbreakpointが存在しない場合は最初のbreakpoint)にポイントを移動します。このコマンドは実行を継続せず、単にバッファー内のポイントを移動します。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Global-Break-Condition"/>Global Break Condition</h3></div></div></div><a id="idm55067984" class="indexterm"/><a id="idm55054928" class="indexterm"/><p><em class="firstterm">グローバルbreak条件(global break
condition)</em>は指定された条件が満たされたとき、それがどこで発生したかによらず、実行をストップします。Edebugは、すべてのストップポイントでグローバルbreak条件を評価します。これが非<code class="literal">nil</code>値に評価された場合は、あたかもそのストップポイントにbreakpointがあったかのように、実行をストップまたはpauseします(実行モードによる)。条件の評価でエラーを取得した場合は、実行をストップしません。
</p><a id="idm55053008" class="indexterm"/><p>条件式は<code class="literal">edebug-global-break-condition</code>に格納されます。Edebugがアクティブなときにソースバッファーから<strong class="userinput"><code>X</code></strong>コマンドを使用するか、Edebugがロードされている間は任意のバッファーから任意のタイミングで<strong class="userinput"><code>C-x
X X</code></strong>(<code class="literal">edebug-set-global-break-condition</code>)を使用することにより新たな式を指定できます。
</p><p>グローバルbreak条件は、コード内のどこでイベントが発生したかを見つけるもっともシンプルな方法ですが、コードの実行は遅くなります。そのため、使用しないときは条件を<code class="literal">nil</code>にリセットするべきです。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Source-Breakpoints"/>Source Breakpoints</h3></div></div></div><a id="idm55047888" class="indexterm"/><a id="idm55047120" class="indexterm"/><p>定義内のすべてのbreakpointは、それをインストルメントするたびに失われます。breakpointが失われないようにしたい場合は、ソースコード内で単に関数<code class="literal">edebug</code>を呼び出す<em class="firstterm">ソースbreakpoint(source
breakpoint)</em>を記述できます。もちろん、そのような呼び出しを条件付きすることにもできます。たとえば<code class="literal">fac</code>関数内に以下のような行を1行目に挿入して、引数が0になったときストップさせることができます:
</p><pre class="screen">(defun fac (n)
  (if (= n 0) (edebug))
  (if (&lt; 0 n)
      (* n (fac (1- n)))
    1))
</pre><p><code class="literal">fac</code>の定義がインストルメントされて呼び出されたとき、<code class="literal">edebug</code>呼び出しはbreakpointとして振る舞います。実行モードに応じて、Edebugはそこでストップまたはpauseします。
</p><p><code class="literal">edebug</code>が呼び出されたときにインストルメント済みのコードが実行されていなければ、この関数は<code class="literal">debug</code>を呼び出します。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Trapping-Errors"/>Trapping Errors</h2></div></div></div><p>エラーがシグナルされて、それが<code class="literal">condition-case</code>でハンドルされていないとき、Emacsは通常エラーメッセージを表示します。Edebugがアクティブでインストルメント済みのコードを実行中は、ハンドルされていないエラーには通常Edebugが対応します。オプション<code class="literal">edebug-on-error</code>および<code class="literal">edebug-on-quit</code>で、これをカスタマイズできます。<a class="link" href="ch18s02.html#Edebug-Options" title="Edebug Options">Edebug
Options</a>を参照してください。
</p><p>Edebugがエラーに対応するときは、エラー発生箇所の前にある最後のストップポイントを表示します。この場所はインストルメントされていない関数の呼び出しで、その関数内で実際にエラーが発生したのかもしれません。バインドされていない変数に関するエラーの場合は、最後の既知のストップポイントは、その不正な変数参照から遠く離れた場所かもしれません。そのような場合は、完全なbacktraceを表示したいと思うでしょう(<a class="link" href="ch18s02.html#Edebug-Misc" title="Miscellaneous Edebug Commands">Edebug
Misc</a>を参照)。
</p><p>Edebugがアクティブの間に<code class="literal">debug-on-error</code>、または<code class="literal">debug-on-quit</code>を変更した場合、それらの変更はEdebugが非アクティブになったとき失われます。さらに、Edebugの再帰編集の間、これらの変数はEdebugの外部でもっていた値にバインドされます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-Views"/>Edebug Views</h2></div></div></div><p>これらのEdebugコマンドは、Edebugにエントリーする前のバッファーの外観と、ウィンドウの状態を調べるコマンドです。外部のウィンドウ構成は、ウィンドウのコレクションとその内容であり、これらは実際にEdebugの外部にあります。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>v</code></strong>
</span></dt><dd><p>外部のウィンドウ構成ビューに切り替える(<code class="literal">edebug-view-outside</code>)。Edebugにリターンするには、<strong class="userinput"><code>C-x X
w</code></strong>をタイプする。
</p></dd><dt><span class="term"><strong class="userinput"><code>p</code></strong>
</span></dt><dd><p>一時的に外部のカレントバッファーを表示し、ポイントもその外部の位置になる(<code class="literal">edebug-bounce-point</code>)。Edebugにリターンする前に、1秒pauseする。プレフィクス引数<em class="replaceable"><code>n</code></em>を指定すると、かわりに<em class="replaceable"><code>n</code></em>秒pauseする。
</p></dd><dt><span class="term"><strong class="userinput"><code>w</code></strong>
</span></dt><dd><p>ソースコードバッファー内のカレントストップポイントにポイントを戻す(<code class="literal">edebug-where</code>)。
</p><p>このコマンドを同じバッファーを表示する異なるウィンドウで使用した場合には、そのウィンドウは将来カレント定義を表示するために代用される。
</p></dd><dt><span class="term"><strong class="userinput"><code>W</code></strong>
</span></dt><dd><p>Edebugが外部のウィンドウ構成を保存、およびリストアするかどうかを切り替える(<code class="literal">edebug-toggle-save-windows</code>)。
</p><p>プレフィクス引数を指定すると、<code class="literal">W</code>は選択されたウィンドウの保存とリストアだけを切り替える。ソースコードバッファーを表示していないウィンドウを指定するには、グローバルキーマップから<strong class="userinput"><code>C-x
X W</code></strong>を使用しなければならない。
</p></dd></dl></div><p><strong class="userinput"><code>v</code></strong>、または単に<strong class="userinput"><code>p</code></strong>でカレントバッファーにポイントを反跳させれば、たとえ通常は表示されないウィンドウでも、外部のウィンドウ構成を調べることができます。
</p><p>ポイントを移動した後に、ストップポイントに戻りたいときがあるかもしれません。これは、ソースコードバッファーから<strong class="userinput"><code>w</code></strong>で行うことができます。どのバッファーにいても、<strong class="userinput"><code>C-x
X w</code></strong>を使用すれば、ソースコードバッファー内のストップポイントに戻ることができます。
</p><p>保存を<span class="emphasis"><em>オフ</em></span>にするために<strong class="userinput"><code>W</code></strong>を使用するたびに、Edebugは外部のウィンドウ構成を忘れます。そのため、たとえ保存を<span class="emphasis"><em>オン</em></span>に戻しても、(プログラムを実行することにより)次にEdebugをexitしたとき、カレントウィンドウ構成は変更されないまま残ります。しかし、十分な数のウィンドウをオープンしていない場合は、<code class="filename">*edebug*</code>と<code class="filename">*edebug-trace*</code>の再表示が、あなたが見たいバッファーと競合するかもしれません。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-Eval"/>Evaluation</h2></div></div></div><p>Edebug内では、まるでEdebugが実行されていないかのように、式を評価できます。式の評価とプリントに際して、Edebugが不可視になるよう試みます。。副作用をもつ式の評価は、Edebugが明示的に保存とリストアを行うデータへの変更を除き、期待したとおり機能するでしょう。このプロセスの詳細は、<a class="link" href="ch18s02.html#The-Outside-Context" title="The Outside Context">The
Outside Context</a>を参照してください。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>e <em class="replaceable"><code>exp</code></em> <span class="keycap"><strong>RET</strong></span></code></strong>
</span></dt><dd><p>Edebugのコンテキスト外で、式<em class="replaceable"><code>exp</code></em>を評価する(<code class="literal">edebug-eval-expression</code>)。つまり、Edebugはその式への干渉を最小限にしようと努める。
</p></dd><dt><span class="term"><strong class="userinput"><code>M-: <em class="replaceable"><code>exp</code></em> <span class="keycap"><strong>RET</strong></span></code></strong>
</span></dt><dd><p>Edebug自身のコンテキスト内で、式<em class="replaceable"><code>exp</code></em>を評価する(<code class="literal">eval-expression</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-x C-e</code></strong>
</span></dt><dd><p>Edebugのコンテキスト外で、ポイントの前の式を評価する(<code class="literal">edebug-eval-last-sexp</code>)。
</p></dd></dl></div><a id="idm55003344" class="indexterm"/><p>Edebugは、<code class="filename">cl.el</code>内の構文(<code class="literal">lexical-let</code>、<code class="literal">macrolet</code>、<code class="literal">symbol-macrolet</code>)により作成された、レキシカル(lexical)にバインドされたシンボルへの参照を含む式の評価をサポートします。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Eval-List"/>Evaluation List Buffer</h2></div></div></div><p>式をインタラクティブに評価するために、<code class="filename">*edebug*</code>と呼ばれる<em class="firstterm">評価リストバッファー(evaluation list
buffer)</em>を使用できます。Edebugがディスプレイを更新するたびに自動的に評価される、式の<em class="firstterm">評価リスト(evaluation
list)</em>もセットアップできます。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>E</code></strong>
</span></dt><dd><p>評価リストバッファー<code class="filename">*edebug*</code>に切り替える(<code class="literal">edebug-visit-eval-list</code>)。
</p></dd></dl></div><p><code class="filename">*edebug*</code>バッファーでは、以下の特別なコマンドと同様に、Lisp Interactionモード(see section “Lisp
Interaction” in <em class="citetitle">The GNU Emacs Manual</em>)のコマンドも使用できます。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>C-j</code></strong>
</span></dt><dd><p>ポイントの前の式をコンテキスト外で評価して、その値をバッファーに挿入する(<code class="literal">edebug-eval-print-last-sexp</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-x C-e</code></strong>
</span></dt><dd><p>Edebugのコンテキスト外で、ポイントの前の式を評価する(<code class="literal">edebug-eval-last-sexp</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-c C-u</code></strong>
</span></dt><dd><p>バッファー内のコンテンツから、新たに評価リストを構築する(<code class="literal">edebug-update-eval-list</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-c C-d</code></strong>
</span></dt><dd><p>ポイントのある評価リストグループを削除する(<code class="literal">edebug-delete-eval-item</code>)。
</p></dd><dt><span class="term"><strong class="userinput"><code>C-c C-w</code></strong>
</span></dt><dd><p>ソースコードバッファーに切り替えてカレントストップポイントに戻る(<code class="literal">edebug-where</code>)。
</p></dd></dl></div><p>評価リストウィンドウ内では、<code class="filename">*scratch*</code>にいるときと同様に、<strong class="userinput"><code>C-j</code></strong>や<strong class="userinput"><code>C-x
C-e</code></strong>で式を評価できますが、それらはEdebugのコンテキスト外で評価されます。
</p><p>インタラクティブに入力した式(とその結果)は、実行を継続すると失われます。しかし、実行がストップされるたびに評価されるように、式から構成される<em class="firstterm">評価リスト</em>をセットアップできます。
</p><a id="idm54961360" class="indexterm"/><p>これを行なうには、評価リストバッファー内で1つ以上の<em class="firstterm">評価リストグループ(evaluation list
group)</em>を記述します。評価リストグループは、1つ以上のLisp式から構成されます。グループはコメント行で区切られます。
</p><p>コマンド<strong class="userinput"><code>C-c
C-u</code></strong>(<code class="literal">edebug-update-eval-list</code>)は、バッファーをスキャンして各グループの最初の式を使用して、評価リストを再構築します。(これはグループの2つ目の式は以前に計算、表示されている値だという発想からです。)
</p><p>Edebugにエントリーするたびに、評価リストの各式(および式の後に式のカレント値)をバッファーに挿入して再表示します。これはコメント行も挿入するため、各式はそのグループの一員となります。したがって、バッファーのテキストを変更せずに<strong class="userinput"><code>C-c
C-u</code></strong>とタイプした場合、評価リストは実際には変更されません。
</p><p>評価リストからの評価の間にエラーが発生した場合、それが式の結果であるかのようにエラーメッセージが文字列で表示されます。したがって、カレントで無効な変数を使用する式により、デバッグが中断されることはありません。
</p><p>以下は、いくつかの式を評価リストウィンドウに追加したとき、どのように見えるかの例です:
</p><pre class="screen">(current-buffer)
#&lt;buffer *scratch*&gt;
;---------------------------------------------------------------
(selected-window)
#&lt;window 16 on *scratch*&gt;
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
</pre><p>グループを削除するには、グループ内にポイントを移動して<strong class="userinput"><code>C-c C-d</code></strong>をタイプするか、単にグループのテキストを削除して<strong class="userinput"><code>C-c
C-u</code></strong>で評価リストを更新します。評価リストに新たな式を追加するには、適切な箇所にその式を挿入し、新たなコメント行を挿入してから<strong class="userinput"><code>C-c
C-u</code></strong>をタイプします。コメント行にダッシュを挿入する必要はありません — 内容は関係ないのです。
</p><p><code class="filename">*edebug*</code>を選択した後に、<strong class="userinput"><code>C-c
C-w</code></strong>でソースコードバッファーにリターンできます。<code class="filename">*edebug*</code>は実行を継続したときkillされ、次回必要なとき再作成されます。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Printing-in-Edebug"/>Printing in Edebug</h2></div></div></div><a id="idm54947408" class="indexterm"/><a id="idm54946640" class="indexterm"/><a id="idm54945872" class="indexterm"/><p>プログラム内の式が循環リスト構造(circular list
structure)を含む値を生成する場合は、Edebugがそれをプリントしようとしたときエラーとなるかもしれません。
</p><p>循環構造への対処の1つに、<code class="literal">print-length</code>および<code class="literal">print-level</code>にプリントの切り詰めをセットする方法があります。Edebugは、変数<code class="literal">edebug-print-length</code>および<code class="literal">edebug-print-level</code>の値(非<code class="literal">nil</code>値をもつ場合)を、これらの変数にバインドします。<a class="link" href="ch19s06.html" title="Variables Affecting Output">Output
Variables</a>を参照してください。
</p><pre class="synopsis"><a id="idm54928720" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-print-length</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合は、結果をプリントするときEdebugは<code class="literal">print-length</code>をこの値にバインドする。デフォルト値は<code class="literal">50</code>。
</p></blockquote></div><pre class="synopsis"><a id="idm54924496" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-print-level</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合は、結果をプリントするときEdebugは<code class="literal">print-level</code>をこの値にバインドする。デフォルト値は<code class="literal">50</code>。
</p></blockquote></div><p><code class="literal">print-circle</code>を非<code class="literal">nil</code>値にバインドして、循環構造や要素を共有する構造を、より参考になる情報をプリントすることもできます。
</p><p>以下は循環構造を作成するコードの例です:
</p><pre class="screen">(setq a '(x y))
(setcar a a)
</pre><p>カスタムプリントはこれを、‘<code class="literal">Result: #1=(#1#
y)</code>’のようにプリントします。‘<code class="literal">#1=</code>’という表記はその後の構造をラベル‘<code class="literal">1</code>’とラベル付けし、‘<code class="literal">#1#</code>’表記はその前にラベル付けされた構造を参照しています。この表記は、リストやベクターの任意の共有要素に使用されます。
</p><pre class="synopsis"><a id="idm54915664" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-print-circle</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合は、結果をプリントするときEdebugは<code class="literal">print-circle</code>をこの値にバインドする。デフォルト値は<code class="literal">t</code>。
</p></blockquote></div><p>他にプログラムもカスタムプリントを使用できます。詳細は<code class="filename">cust-print.el</code>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Trace-Buffer"/>Trace Buffer</h2></div></div></div><a id="idm54909776" class="indexterm"/><p>Edebugは実行トレースを<code class="filename">*edebug-trace*</code>という名前のバッファーに格納して記録できます。実行トレースとは関数呼び出しよリターンのログのことで、関数名と引数、および値が確認できます。トレースレコードを有効にするには、<code class="literal">edebug-trace</code>を非<code class="literal">nil</code>値にセットしてください。
</p><p>トレースバッファーの作成は、実行モードのトレースの使用(<a class="link" href="ch18s02.html#Edebug-Execution-Modes" title="Edebug Execution Modes">Edebug Execution Modes</a>を参照)と同じではありません。
</p><p>トレースレコードが有効なときは、関数へのエントリーとexitのたびに、トレースバッファーに行が追加されます。関数エントリーレコードは‘<code class="literal">::::{</code>’、および関数名と引数の値により構成されます。関数exitレコードは‘<code class="literal">::::}</code>’、および関数名と関数の結果により構成されます。
</p><p>‘<code class="literal">:</code>’の数は、関数エントリーの再帰レベルを表します。トレースバッファーでは、関数呼び出しの開始と終了の検索に‘<code class="literal">{</code>’と‘<code class="literal">}</code>’を使用できます。
</p><a id="idm54902864" class="indexterm"/><a id="idm54902096" class="indexterm"/><p>関数<code class="literal">edebug-print-trace-before</code>および<code class="literal">edebug-print-trace-after</code>を再定義することにより、関数エントリーと関数exitのトレースレコードをカスタマイズできます。
</p><pre class="synopsis"><a id="idm54899664" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">edebug-tracing</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは<em class="replaceable"><code>body</code></em>フォーム実行活動にたいする、追加のトレース情報をリクエストする。引数<em class="replaceable"><code>string</code></em>は、トレースバッファーに配す‘<code class="literal">{</code>’または‘<code class="literal">}</code>’の後のテキストを指定する。すべての引数は評価され、<code class="literal">edebug-tracing</code>は<em class="replaceable"><code>body</code></em>内の最後のフォームの値をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm54893136" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">edebug-trace</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>format-args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、トレースバッファーにテキストを挿入する。テキストは、<code class="literal">(apply 'format <em class="replaceable"><code>format-string</code></em>
<em class="replaceable"><code>format-args</code></em>)</code>により計算される。エントリー間の区切りとして改行も付け加える。
</p></blockquote></div><p><code class="literal">edebug-tracing</code>および<code class="literal">edebug-trace</code>は、たとえEdebugが非アクティブでも、呼び出されたときは常にトレースバッファーに行を挿入します。トレースバッファーへのテキストの追加により、挿入された最後の行が見えるようにウィンドウもスクロールします。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Coverage-Testing"/>Coverage Testing</h2></div></div></div><a id="idm54885840" class="indexterm"/><a id="idm54885072" class="indexterm"/><a id="idm54884304" class="indexterm"/><p>Edebugは基本的なカバレッジテスト(coverage test)と実行頻度(execution frequency)の表示を提供します。
</p><p>カバレッジテストは、すべての式の結果と以前の結果を比較することにより機能します。プログラム内のフォームがそれぞれ、カレントEmacsセッション内でカバレッジテストを開始して以降に、2つの異なる値をリターンした場合、それらのフォームは“カバー”されたと判断します。したがって、プログラムにカバレッジテストを行なうには、そのプログラムをさまざまなコンディション下で実行して、プログラムが正しく振る舞うかに注目します。異なるコンディション下で十分にテストして、すべてのフォームが異なる2つの値をリターンしたとき、Edebugはそのことを告げるでしょう。
</p><p>カバレッジテストにより実行速度が低下するので、<code class="literal">edebug-test-coverage</code>が非<code class="literal">nil</code>のときだけカバレッジテストが行なわれます。頻度計数(frequency
count)は、たとえ実行モードがGo-nonstopでも、カバレッジテストが有効か無効かに関わらず、すべての式にたいして処理されます。
</p><a id="idm54881360" class="indexterm"/><a id="idm54880592" class="indexterm"/><p>定義にたいするカバレッジ情報と頻度数の両方を表示するには、<strong class="userinput"><code>C-x X
=</code></strong>(<code class="literal">edebug-display-freq-count</code>)を使用する。単に<strong class="userinput"><code>=</code></strong>(<code class="literal">edebug-temp-display-freq-count</code>)とすると、他のキーをタイプするまでの間だけ、同様な情報を一時的に表示する。
</p><pre class="synopsis"><a id="idm54877136" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">edebug-display-freq-count</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレント定義の各行の頻度数を表示する。
</p><p>このコマンドは、コードの各行の下にコメント行として頻度数を挿入する。1回の<code class="literal">undo</code>コマンドで、すべての挿入をアンドゥできる。頻度数は式の前の‘<code class="literal">(</code>’、または式の後の‘<code class="literal">)</code>’、または変数の最後の文字の下に表示される。表示をシンプルにするために、同一行にたいして式の以前頻度数と頻度数が同じ場合は表示しない。
</p><p>ある式にたいする頻度数の後に文字‘<code class="literal">=</code>’がある場合、それはその式が評価されるたびに毎回同じ値をリターンしていることを表す。他の言い方をすると、カバレッジテストの目的からは、その式はまだ“カバー”されていないということである。
</p><p>ある定義にたいして頻度数とカバレッジデータを明確にするには、単に<code class="literal">eval-defun</code>で再インストルメントすればよい。
</p></blockquote></div><p>たとえば、ソースのbreakpointで<code class="literal">(fac
5)</code>を評価した後、<code class="literal">edebug-test-coverage</code>を<code class="literal">t</code>にセットすると、breakpointに達したときの頻度データは以下のようになります:
</p><pre class="screen">(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (&lt; 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
</pre><p>コメント行は、<code class="literal">fac</code>が6回呼び出されたことを表しています。最初の<code class="literal">if</code>命令は毎回同じ結果を5回リターンしています。同じ結果という意味では、2つ目の<code class="literal">if</code>の条件にも当てはまります。<code class="literal">fac</code>の再帰呼び出しは、結局リターンしません。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="The-Outside-Context"/>The Outside Context</h2></div></div></div><p>Edebugはデバッグ中のプログラムにたいして透過的であろうと努めますが、完全には達成されません。Edebugは、<strong class="userinput"><code>e</code></strong>や評価リストバッファーで式を評価するときも、一時的に外部のコンテキストをリストアして、透明化を試みます。このセクションではEdebugがリストアするコンテキストと、Edebugがいかにして完全に透過的になるのに失敗するかを正確に説明します。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Checking-Whether-to-Stop"/>Checking Whether to Stop</h3></div></div></div><p>Edebugにエンターするときは常に特定のデータの保存とリストアを行なう必要があり、それはトレース情報を作成するか、あるいはプログラムを停止するかを決定する前に行なう必要があります。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">max-lisp-eval-depth</code>および<code class="literal">max-specpdl-size</code>は、Edebugがスタック与える影響の低減効果を高める。しかしそれでも、Edebug使用時にスタック空間を使い切ってしまうことはあり得る。
</p></li><li class="listitem"><p>キーボードマクロの実行状態は保存およびリストアされる。Edebugがアクティブの間、<code class="literal">edebug-continue-kbd-macro</code>が<code class="literal">nil</code>の場合は、<code class="literal">executing-kbd-macro</code>が<code class="literal">nil</code>にバインドされる。
</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Edebug-Display-Update"/>Edebug Display Update</h3></div></div></div><p>(たとえばtraceモードなどで)Edebugが何かを表示する必要があるときは、Edebugの“外部”からカレントウィンドウ構成(<a class="link" href="ch28s24.html" title="Window Configurations">Window
Configurations</a>を参照)を保存します。Edebugをexitするときに、以前のウィンドウ構成がリストアされます。
</p><p>Emacsは、pause時だけ再表示を行います。通常は実行を継続したときに、そのプログラムはbreakpointまたはステップ実行後にEdebugに再エンターし、その間にpauseや入力の読み取りはありません。そのような場合、Emacsが“外部”の構成を再表示する機会は決してありません。結果として、ユーザーが目にするウィンドウ構成は、前回Edebugが中断なしでアクティブだったときのウィンドウ構成と同じになります。
</p><p>何かを表示するためにEdebugにエントリーすることにより、(たとえこれらのうちのいくつかは、エラーやquitがシグナルされたときは、故意にリストアしないデータだとしても)以下のデータも保存およびリストアされます。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><a id="idm54842704" class="indexterm"/><p>どれがカレントバッファーか、そしてカレントバッファー内のポイントとマークの位置が、保存およびリストアされる。
</p></li><li class="listitem"><a id="idm54841424" class="indexterm"/><p><code class="literal">edebug-save-windows</code>が非<code class="literal">nil</code>の場合は、外部のウィンドウ構成が保存およびリストアされる(<a class="link" href="ch18s02.html#Edebug-Options" title="Edebug Options">Edebug
Options</a>を参照)。
</p><p>エラーやquitではウィンドウ構成はリストアされないが、<code class="literal">save-excursion</code>がアクティブな場合は、たとえエラーやquitのとき外部の選択されたウィンドウが再選択<span class="emphasis"><em>される</em></span>。<code class="literal">edebug-save-windows</code>の値がリストの場合は、それにリストされたウィンドウだけが保存およびリストアされる。
</p><p>しかし、ソースコードバッファーのウィンドウの開始位置と水平スクロールはリストアされないので、表示はEdebug内で整合性が保たれたままとなる。
</p></li><li class="listitem"><p><code class="literal">edebug-save-displayed-buffer-points</code>が非<code class="literal">nil</code>の場合、表示されているそれぞれのバッファー内のポイント値は、保存およびリストアされる。
</p></li><li class="listitem"><p>変数<code class="literal">overlay-arrow-position</code>と<code class="literal">overlay-arrow-string</code>は保存およびリストアされるので、同じバッファー内の他の場所の再帰編集から、安全にEdebugを呼び出せる。
</p></li><li class="listitem"><p><code class="literal">cursor-in-echo-area</code>は<code class="literal">nil</code>にローカルにバインドされるので、カーソルはそのウィンドウ内に現れる。
</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Edebug-Recursive-Edit"/>Edebug Recursive Edit</h3></div></div></div><p>Edebugにエンターしてユーザーのコマンドが実際に読み取られるとき、Edebugは以下の追加データを保存(そして後でリストア)します:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>カレントマッチデータ。<a class="link" href="ch34s06.html" title="The Match Data">Match Data</a>を参照。
</p></li><li class="listitem"><p>変数<code class="literal">last-command</code>、<code class="literal">this-command</code>、<code class="literal">last-command-event</code>、<code class="literal">last-input-event</code>、<code class="literal">last-event-frame</code>、<code class="literal">last-nonmenu-event</code>、<code class="literal">track-mouse</code>。Edebug内のコマンドは、Edebug外部のこれらの変数に影響をあたえない。
</p><p>Edebug内でのコマンド実行は、<code class="literal">this-command-keys</code>によりリターンされるキーシーケンスを変更でき、Lispからそのキーシーケンスをリセットする方法はない。
</p><p>Edebugは<code class="literal">unread-command-events</code>の値の保存およびリストアができない。この変数が重要な値をもつときにEdebugにエンターすると、デバッグ中のプログラムの実行に干渉する可能性がある。
</p></li><li class="listitem"><p>Edebug内で実行された複雑なコマンドは、変数<code class="literal">command-history</code>に追加される。これが稀に実行に影響を与える。
</p></li><li class="listitem"><p>Edebug内では、再帰深さがEdebug外部の再帰深さより1つ深くなる。これは自動的に更新される評価リストウィンドウでは異なる。
</p></li><li class="listitem"><p><code class="literal">standard-output</code>と<code class="literal">standard-input</code>は<code class="literal">recursive-edit</code>により<code class="literal">nil</code>にバインドされるが、Edebugは評価の間それらを一時的にリストアする。
</p></li><li class="listitem"><p>キーボードマクロ定義の状態は、保存およびリストアされる。Edebugがアクティブの間、<code class="literal">defining-kbd-macro</code>は<code class="literal">edebug-continue-kbd-macro</code>にバインドされる。
</p></li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-and-Macros"/>Edebug and Macros</h2></div></div></div><p>Edebugが正しくマクロを呼び出す式をインストルメントするには、いくつかの特定な配慮が必要になります。このサブセクションでは、その詳細を説明します。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Instrumenting-Macro-Calls"/>Instrumenting Macro Calls</h3></div></div></div><p>EdebugがLispマクロを呼び出す式をインストルメントするときは、正しくインストルメントを行なうために、そのマクロに関して追加の情報が必要になります。これは、マクロ呼び出しのどの部分式(subexpression)が評価されるフォームなのか推測する方法がないからです。(評価はマクロのbodyで明示的に発生するかもしれないし、展開結果が評価されるとき、または任意のタイミングで行われるかもしれません。)
</p><p>したがって、Edebugが処理するかもしれないすべてのマクロにたいして、そのマクロの呼び出しフォーマットを説明するための、Edebug仕様(Edebug
specification)を定義しなければなりません。これを行なうには、マクロ定義に<code class="literal">debug</code>宣言を追加します。以下はマクロ例<code class="literal">for</code>(<a class="link" href="ch14s05.html#Argument-Evaluation" title="Evaluating Macro Arguments Repeatedly">Argument
Evaluation</a>を参照)にたいする簡単な仕様の例です。
</p><pre class="screen">(defmacro for (var from init to final do &amp;rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &amp;rest form)))
  ...)
</pre><p>このEdebug仕様は、マクロ呼び出しのどの部分が評価されるフォームなのかを示しています。単純なマクロにたいするEdebug仕様は、そのマクロ定義の正式な引数リストに非常に類似している場合がありますが、Edebug仕様はマクロ引数に比べより汎的です。<code class="literal">declare</code>フォームの詳細は、<a class="link" href="ch14s04.html" title="Defining Macros">Defining
Macros</a>を参照してください。
</p><p>コードをインストルメントするときEdebugに仕様が確実に解るよう注意してください。マクロ定義を含む他のファイルを要求するために<code class="literal">eval-when-compile</code>を使用するファイルから関数をインストルメントする場合は、そのファイルを明示的にロードする必要があるかもしれません。
</p><p><code class="literal">def-edebug-spec</code>によりマクロ定義から個々のマクロにたいしてEdebug仕様を定義することもできます。Lispで記述されたマクロ定義にたいしては<code class="literal">debug</code>宣言を追加するほうが好ましく、その方が便利でもありますが、<code class="literal">def-edebug-spec</code>ではCで実装されたスペシャルフォームにたいしてEdebug仕様を定義することが可能になります。
</p><pre class="synopsis"><a id="idm54803152" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">def-edebug-spec</code> <em class="replaceable"><code>macro</code></em> <em class="replaceable"><code>specification</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>マクロ<em class="replaceable"><code>macro</code></em>呼び出しのどの式が評価される式かを指定する。<em class="replaceable"><code>specification</code></em>はEdebug仕様である。どちらの引数も評価されない。
</p><p>引数<em class="replaceable"><code>macro</code></em>は単なるマクロ名ではない、任意の実シンボルを指定できる。
</p></blockquote></div><p>以下は<em class="replaceable"><code>specification</code></em>に指定できるシンボルと、引数を処理する方法のテーブルです。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">t</code>
</span></dt><dd><p>すべての引数は評価のためにインストルメントされる。
</p></dd><dt><span class="term"><code class="literal">0</code>
</span></dt><dd><p>引数はインストルメントされない。
</p></dd><dt><span class="term">シンボル
</span></dt><dd><p>そのシンボルは、かわりに使用されるEdebug仕様をもたなければならない。このインダイレクションは、他の種類の仕様が見つかるまで繰り返される。これにより、他のマクロの仕様を継承できる。
</p></dd><dt><span class="term">リスト
</span></dt><dd><p>リストの要素はフォーム呼び出しの引数の型を記述する。仕様リストに指定できる要素については、以降のセクションを参照。
</p></dd></dl></div><p>マクロがEdebug仕様をもたない場合は、<code class="literal">debug</code>宣言および<code class="literal">def-edebug-spec</code>呼び出しのどちらを通じても、変数<code class="literal">edebug-eval-macro-args</code>が効果を発揮する。
</p><pre class="synopsis"><a id="idm54770384" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-eval-macro-args</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、Edebugが明示的なEdebug仕様をもたないマクロ引数を扱う方法を制御する。<code class="literal">nil</code>(デフォルト)の場合、引数は評価のためにインストルメントされない。それ以外は、すべての引数がインストルメントされる。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Specification-List"/>Specification List</h3></div></div></div><a id="idm54766416" class="indexterm"/><p>あるマクロ呼び出しにおいて、いくつかの引数は評価されるが、それ以外の引数は評価されないような場合には、Edebug仕様のために<em class="firstterm">仕様リスト(specification
list)</em>が要求されます。仕様リスト内のいくつかの要素は1つ以上の引数にマッチしまづが、それ以外の要素は以降に続くすべての引数の処理を変更します。後者は<em class="firstterm">仕様キーワード(specification
keywords)</em>と呼ばれ、(<code class="literal">&amp;optional</code>のように)‘<code class="literal">&amp;</code>’で始まるシンボルです。
</p><p>仕様リストは、それ自身がリストであるような引数にマッチする部分リスト(sublist)、またはグループ化に使用されるベクターを含むかもしれません。したがって部分式とグループは、仕様リストをレベル階層に細分化します。仕様キーワードは、部分式やグループを含むものの残りに適用されます。
</p><p>仕様リストに選択肢や繰り返しが含まれる場合は、実際のマクロの呼び出しにたいしてマッチさせるためにバックトラックが要求されるかもしれません。詳細は、<a class="link" href="ch18s02.html#Backtracking" title="Backtracking in Specifications">Backtracking</a>を参照してください。
</p><p>Edebug仕様は、バランスのとれたカッコで括られた部分式へのマッチ、フォームの再帰処理、インダイレクト仕様を通じた再帰などの、正規表現によるマッチングと、コンテキストに依存しない文法構成を提供します。
</p><p>以下は仕様リストに使用できる要素と、その意味についてのテーブルです(使用例は<a class="link" href="ch18s02.html#Specification-Examples" title="Specification Examples">Specification Examples</a>を参照):
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sexp</code>
</span></dt><dd><p>評価れない単一のLispオブジェクト。インストルメントされない。
</p></dd><dt><span class="term"><code class="literal">form</code>
</span></dt><dd><p>評価される単一のLispオブジェクト。インストルメントされる。
</p></dd><dt><span class="term"><code class="literal">place</code>
</span></dt><dd><p>汎変数(generalized variable)。<a class="link" href="ch12s15.html" title="Generalized Variables">Generalized Variables</a>を参照。
</p></dd><dt><span class="term"><code class="literal">body</code>
</span></dt><dd><p><code class="literal">&amp;rest form</code>の省略形。以下の<code class="literal">&amp;rest</code>を参照。
</p></dd><dt><span class="term"><code class="literal">function-form</code>
</span></dt><dd><p>関数フォーム。クォートされた関数シンボル、クォートされたラムダ式、または(関数シンボルかラムダ式に評価される)フォームのうちのどれか。これはラムダ式のbodyをいずれかの方法でインストルメントするため、<code class="literal">function</code>よりも<code class="literal">quote</code>でクォートされたラムダ式の引数にたいし有用。
</p></dd><dt><span class="term"><code class="literal">lambda-expr</code>
</span></dt><dd><p>クォートされないラムダ式。
</p></dd><dt><span class="term"><code class="literal">&amp;optional</code>
</span></dt><dd><p>仕様リスト内の後続の要素はオプション。マッチしない要素が出現すると、Edebugはこのレベルのマッチングを停止する。
</p><p>後続が非オプションの要素であるような数個の要素をオプションにするだけなら、<code class="literal">[&amp;optional
<em class="replaceable"><code>specs</code></em>…]</code>を使用する。複数の要素すべてのマッチ、または非マッチを指定するには、<code class="literal">&amp;optional
[<em class="replaceable"><code>specs</code></em>…]</code>を使用する。<code class="literal">defun</code>の例を参照。
</p></dd><dt><span class="term"><code class="literal">&amp;rest</code>
</span></dt><dd><p>仕様リスト内の後続のすべての要素は、0回以上繰り返される。しかし、最後の繰り返しでは、仕様リスト内のすべての要素にたいするマッチングの前に式が終了しても問題はない。
</p><p>数個の要素を繰り返すには、<code class="literal">[&amp;rest
<em class="replaceable"><code>specs</code></em>…]</code>を使用する。各繰り返しにおいいてすべてマッチしなければならない複数要素を指定するには、<code class="literal">&amp;rest
[<em class="replaceable"><code>specs</code></em>…]</code>を使用する。
</p></dd><dt><span class="term"><code class="literal">&amp;or</code>
</span></dt><dd><p>仕様リスト内の後続の各要素は選択肢。選択肢の1つがマッチしなければならず、マッチしない場合<code class="literal">&amp;or</code>仕様は失敗する。
</p><p><code class="literal">&amp;or</code>に続く各リスト要素は、単一の選択肢。複数のリスト要素を単一の選択肢にグループ化するには、それらを<code class="literal">[…]</code>で括る。
</p></dd><dt><span class="term"><code class="literal">&amp;not</code>
</span></dt><dd><p>後続の各要素は、<code class="literal">&amp;or</code>が使用されたときのように選択肢にマッチするが、要素がマッチした場合に失敗する。どれもマッチする要素がない場合は何もマッチされないが、<code class="literal">&amp;not</code>仕様は成功する。
</p></dd><dt><span class="term"><code class="literal">&amp;define</code>
</span></dt><dd><p>フォーム定義にたいする仕様であることを示す。フォーム定義自体はインストルメントされない(つまりEdebugはフォーム定義の前後でストップしない)が、フォーム内部は通常はインストルメントされるであろう。<code class="literal">&amp;define</code>キーワードはリスト仕様の最初の要素であること。
</p></dd><dt><span class="term"><code class="literal">nil</code>
</span></dt><dd><p>カレント引数レベルでマッチさせる引数が存在しない場合は成功し、それ以外は失敗する。部分リスト仕様とバッククォートの例を参照。
</p></dd><dt><span class="term"><code class="literal">gate</code>
</span></dt><dd><a id="idm58873040" class="indexterm"/><p>引数はマッチされないがgateを通じたバックトラックは、このレベルの使用の残りをマッチングする間は無効にされる。これは主に、特定の構文エラーメッセージを一般的にするために使用される。詳細は<a class="link" href="ch18s02.html#Backtracking" title="Backtracking in Specifications">Backtracking</a>、および<code class="literal">let</code>の例も参照。
</p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>other-symbol</code></em></code>
</span></dt><dd><a id="idm58869840" class="indexterm"/><p>仕様リスト内のその他の要素は、述語(predicate)かインダイレクト仕様(indirect specification)である。
</p><p>シンボルがEdebug仕様をもつ場合、<em class="firstterm">インダイレクト仕様(indirect
specification)</em>はシンボル位置に使用されるリスト仕様か、引数を処理するための関数のどちらかである。この仕様はマクロにたいする<code class="literal">def-edebug-spec</code>のように定義される。<code class="literal">defun</code>の例を参照。
</p><p>それ以外の場合、シンボルは述語(predicate)である。述語は引数とともに呼び出され、述語が<code class="literal">nil</code>をリターンした場合、その仕様は失敗して引数はインストルメントされない。
</p><p>適切な述語としては<code class="literal">symbolp</code>、<code class="literal">integerp</code>、<code class="literal">stringp</code>、<code class="literal">vectorp</code>、<code class="literal">atom</code>が含まれる。
</p></dd><dt><span class="term"><code class="literal">[<em class="replaceable"><code>elements</code></em>…]</code>
</span></dt><dd><a id="idm58849360" class="indexterm"/><p>要素のベクターは、要素を単一の<em class="firstterm">グループ仕様(group
specification)</em>にグループ化する。このグループ仕様は、ベクター自体に何も行わない。
</p></dd><dt><span class="term"><code class="literal">"<em class="replaceable"><code>string</code></em>"</code>
</span></dt><dd><p>引数は<em class="replaceable"><code>string</code></em>という名前のシンボルである。この仕様は、<em class="replaceable"><code>symbol</code></em>の名前が<em class="replaceable"><code>string</code></em>であるクォートされたシンボル<code class="literal">'<em class="replaceable"><code>symbol</code></em></code>と等価だが、文字列形式のほうが好ましい。
</p></dd><dt><span class="term"><code class="literal">(vector <em class="replaceable"><code>elements</code></em>…)</code>
</span></dt><dd><p>引数は、要素が仕様内の<em class="replaceable"><code>elements</code></em>にマッチするベクターである。バッククォートの例を参照。
</p></dd><dt><span class="term"><code class="literal">(<em class="replaceable"><code>elements</code></em>…)</code>
</span></dt><dd><p>他のリストは<em class="firstterm">部分リスト仕様(sublist
specification)</em>であり、引数は要素が仕様の<em class="replaceable"><code>elements</code></em>にマッチするリストでなければならない。
</p><a id="idm58835664" class="indexterm"/><p>部分リスト仕様はドットリスト(dotted
list)かもしれず、その場合対応するリスト引数はドットリストである。かわりに、ドットリスト仕様の最後のCDRが、(グループ化やインダイレクト仕様による)他の部分リスト仕様かもしれない(たとえば要素が非ドットリストにマッチする<code class="literal">(spec
. [(more
specs…)])</code>))。これはバッククォートの例のような再帰仕様に有用。このような再帰を終了させるには、上述の<code class="literal">nil</code>仕様も参照。
</p><p><code class="literal">(specs .  nil)</code>のように記述された部分リスト仕様は<code class="literal">(specs)</code>、<code class="literal">(specs .
(sublist-elements…))</code>は<code class="literal">(specs
sublist-elements…)</code>と等価であることに注意。
</p></dd></dl></div><p>以下は<code class="literal">&amp;define</code>の後だけに出現する追加仕様のリストです。<code class="literal">defun</code>の例を参照してください。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">name</code>
</span></dt><dd><p>引数(シンボル)は定義フォームの名前。
</p><p>定義フォームは名前フィールドをもつ必要はなく、複数の名前フィールドをもつかもしれない。
</p></dd><dt><span class="term"><code class="literal">:name</code>
</span></dt><dd><p>この構成は引数に実際のマッチは行わない。<code class="literal">:name</code>の後の要素はシンボルであり、その定義の追加の名前要素として使用される。定義名に一意で静的な要素を加えるために、これを使用できる。複数回使用されるかもしれない。
</p></dd><dt><span class="term"><code class="literal">arg</code>
</span></dt><dd><p>引数(シンボル)は定義フォームの引数の名前である。しかし、lambda-listキーワード(‘<code class="literal">&amp;</code>’で始まるシンボル)は許されない。
</p></dd><dt><span class="term"><code class="literal">lambda-list</code>
</span></dt><dd><a id="idm58819152" class="indexterm"/><p>これはラムダリスト(ラムダ式の引数リスト)にマッチする。
</p></dd><dt><span class="term"><code class="literal">def-body</code>
</span></dt><dd><p>引数は定義内のコードのbodyである。これは上述の<code class="literal">body</code>と似ているが、定義のbodyはその定義に関連する情報を照会する別のEdebug呼び出しでインストルメントされていなければならない。定義内のより高位レベルのフォームリストには、<code class="literal">def-body</code>を使用する。
</p></dd><dt><span class="term"><code class="literal">def-form</code>
</span></dt><dd><p>引数は、定義内のもっとも高位レベルの単一フォームである。これは<code class="literal">def-body</code>と似ているが、フォームリストではなく単一フォームのマッチに使用される。特別なケースとして、<code class="literal">def-form</code>はフォームが実行されるときトレース情報を出力しないことも意味する。<code class="literal">interactive</code>の例を参照。
</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Backtracking"/>Backtracking in Specifications</h3></div></div></div><a id="idm58811856" class="indexterm"/><a id="idm58811088" class="indexterm"/><p>あるポイント位置で仕様がマッチに失敗しても、構文エラーがシグナルされるとは限りません。そのかわり<em class="firstterm">バックトラック(backtracking)</em>が開始されます。バックトラックは、すべての選択肢をマッチングするまで行なわれます。最終的に引数リストのすべての要素は仕様内の要素のいずれかとマッチしなければならず、仕様内の必須要素は引数のいずれかとマッチしなければなりません。
</p><p>構文エラーが検出されてもその時点では報告されず、より高位レベルの選択肢のマッチングが終わった後、実際のエラー箇所から離れたポイント位置でエラーが報告されるかもしれません。しかしエラー発生時にバックトラックが無効なら、エラーは即座に報告されるでしょう。ある状況においては、バックトラックも自動的に再有効化されることに注意してください。<code class="literal">&amp;optional</code>、<code class="literal">&amp;rest</code>、<code class="literal">&amp;or</code>により新たな選択肢が設定されたとき、または部分リスト、グループ、インダイレクト仕様が開始されたときは、バックトラックが自動的に有効になります。バックトラックを有効、または無効にした場合の影響は、現在処理中のレベルの残り要素と、低位レベルに限定されます。
</p><p>何らかのフォーム仕様(すなわち<code class="literal">form</code>、<code class="literal">body</code>、<code class="literal">def-form</code>、<code class="literal">def-body</code>)をマッチングする間、バックトラックは無効になっています。これらの仕様は任意のフォームにマッチするので、何らかのエラーが発生するとしたらそれは高位レベルではなく、そのフォーム自体の内部でなければなりません。
</p><p>バックトラックはクォートされたシンボルや文字列仕様とのマッチに成功した後にも無効になります。なぜなら通常これは構成が認識されたことを示すからです。しかし、同じシンボルで始まる一連の選択肢構成がある場合は、たとえば<code class="literal">["foo"
&amp;or [first case] [second case]
...]</code>のように、通常は選択肢の外部にそのシンボルをファクタリングすることにより、この制約に対処できます。
</p><p>ほとんどのニーズは、バックトラックを自動的に無効にする、これら2つの方法で満足させることができますが、<code class="literal">gate</code>仕様を使用して明示的にバックトラックを無効にするほうが便利なときもあります。これは、高位に適用可能な選択肢が存在しないことが分かっている場合に有用です。<code class="literal">let</code>仕様の例を参照してください。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Specification-Examples"/>Specification Examples</h3></div></div></div><p>以下で提供する例から学ぶことにより、Edebug仕様の理解が容易になるかもしれません。
</p><p>スペシャルフォーム<code class="literal">let</code>は、バインディングとbodyのシーケンスをもちます。各バインディングはそシンボル、またはシンボルとオプションの部分リストです。以下の仕様では、部分リストを見つけたらバックトラックを抑止するために、部分リスト内の<code class="literal">gate</code>があることに注目してください。
</p><pre class="screen">(def-edebug-spec let
  ((&amp;rest
    &amp;or symbolp (gate symbolp &amp;optional form))
   body))
</pre><p>Edebugは<code class="literal">defun</code>および関連する引数リスト、<code class="literal">interactive</code>仕様にたいして以下の仕様を使用します。式の引数はその関数bodyの外部で実際に評価されるので、interactiveフォームは特別に処理する必要があります。(<code class="literal">defmacro</code>にたいする仕様は<code class="literal">defun</code>にたいする仕様と非常に似ていますが、<code class="literal">declare</code>命令文が許されます。)
</p><pre class="screen">(def-edebug-spec defun
  (&amp;define name lambda-list
           [&amp;optional stringp]   ; ドキュメント文字列が与えられた場合はマッチする。
           [&amp;optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&amp;rest arg]
    [&amp;optional ["&amp;optional" arg &amp;rest arg]]
    &amp;optional ["&amp;rest" arg]
    )))

(def-edebug-spec interactive
  (&amp;optional &amp;or stringp def-form))    ; Notice: <code class="literal">def-form</code>
</pre><p>以下のバッククォートにたいする仕様は、ドットリストにマッチさせる方法と、<code class="literal">nil</code>を使用して再帰を終了させる方法を説明するための例です。また、ベクターのコンポーネントをマッチさせる方法も示しています。(Edebugにより定義される実際の仕様は少し異なり、ドットリストについては失敗するかもしれない非常に深い再帰を引き起こすためサポートしていません。)
</p><pre class="screen">(def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

(def-edebug-spec backquote-form
  (&amp;or ([&amp;or "," ",@"] &amp;or ("quote" backquote-form) form)
       (backquote-form . [&amp;or nil backquote-form])
       (vector &amp;rest backquote-form)
       sexp))
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Edebug-Options"/>Edebug Options</h2></div></div></div><p>以下のオプションは、Edebugの動作に影響を与えます:
</p><pre class="synopsis"><a id="idm58791504" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-setup-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>Edebugが使用される前に呼び出される関数。この関数は毎回新たな値をセットする。Edebugこれらの関数を一度呼び出したら、その後<code class="literal">edebug-setup-hook</code><code class="literal">nil</code>にリセットする。使用するパッケージに関係するEdebug仕様をロードするために使用ｄきるが、それはEdebugを使用するときだけである。<a class="link" href="ch18s02.html#Instrumenting" title="Instrumenting for Edebug">Instrumenting</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58787408" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-all-defs</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>の場合は<code class="literal">defun</code>や<code class="literal">defmacro</code>のような定義フォームの普通に評価すると、Edebug用にインストルメントされる。これは<code class="literal">eval-defun</code>、<code class="literal">eval-region</code>、<code class="literal">eval-buffer</code>、and
<code class="literal">eval-current-buffer</code>に適用される。
</p><p>このオプションの切り替えには、コマンド<strong class="userinput"><code>M-x edebug-all-defs</code></strong>を使用する。<a class="link" href="ch18s02.html#Instrumenting" title="Instrumenting for Edebug">Instrumenting</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58779600" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-all-forms</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>の場合<code class="literal">eval-defun</code>、<code class="literal">eval-region</code>、<code class="literal">eval-buffer</code>、<code class="literal">eval-current-buffer</code>は、たとえフォームが何も定義していなくても、すべてのフォームをインストルメントする。これはロードとミニバッファー内の評価には適用されない。
</p><p>このオプションの切り替えには、コマンド<strong class="userinput"><code>M-x edebug-all-forms</code></strong>を使用する。<a class="link" href="ch18s02.html#Instrumenting" title="Instrumenting for Edebug">Instrumenting</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58772944" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-save-windows</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>の場合、Edebugはウィンドウ構成の保存とリストアを行なう。これにはある程度時間がかかるので、ウィンドウ構成に何が起こってもプログラムに関係しない場合は、この変数を<code class="literal">nil</code>にセットしたほうがよい。
</p><p>値がリストの場合は、リストされたウィンドウだけが保存およびリストアされる。
</p><p>Edebug内では、この変数をインタラクティブに変更するために<strong class="userinput"><code>W</code></strong>コマンドを使用できる。<a class="link" href="ch18s02.html#Edebug-Display-Update" title="Edebug Display Update">Edebug Display
Update</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58767312" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-save-displayed-buffer-points</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>の場合、Edebugは表示されているすべてのバッファー内のポイントを保存およびリストアする。
</p><p>選択されていないウィンドウ内に表示されているバッファーのポイントを変更するコードをデバッグしている場合は、他のバッファーのポイントを保存およびリストアする必要がある。その後にEdebugまたはユーザーがそのウィンドウを選択した場合は、そのバッファー内のポイントは、そのウィンドウのポイント値に移動される。
</p><p>すべてのバッファー内のポイントの保存とリストアは、それぞれのウィンドウを2回選択する必要があり高価な処理のため、必要なときだけ有効にする。<a class="link" href="ch18s02.html#Edebug-Display-Update" title="Edebug Display Update">Edebug
Display Update</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58762704" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-initial-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>の場合、Edebugが最初にアクティブになったときの、Edebugの最初の実行モードを指定する。指定できる値は<code class="literal">step</code>、<code class="literal">next</code>、<code class="literal">go</code>、<code class="literal">Go-nonstop</code>、<code class="literal">trace</code>、<code class="literal">Trace-fast</code>、<code class="literal">continue</code>、<code class="literal">Continue-fast</code>。
</p><p>デフォルト値は<code class="literal">step</code>。<a class="link" href="ch18s02.html#Edebug-Execution-Modes" title="Edebug Execution Modes">Edebug Execution Modes</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58741712" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-trace</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>の場合が、各関数のエントリーとexitをトレースする。トレース出力は、関数のエントリーとexitを行ごとに、再帰レベルにしたがって<code class="filename">*edebug-trace*</code>という名前のバッファーに表示される。
</p><p><a class="link" href="ch18s02.html#Trace-Buffer" title="Trace Buffer">Trace Buffer</a>の<code class="literal">edebug-tracing</code>も参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm58736720" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-test-coverage</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合、Edebugはデバッグされるすべての式のカバレッジをテストする。<a class="link" href="ch18s02.html#Coverage-Testing" title="Coverage Testing">Coverage Testing</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58733008" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-continue-kbd-macro</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合は、Edebug外で実行されている任意のキーボードマクロの定義または実行を継続する。これはデバッグされないので、慎重に使用すること。<a class="link" href="ch18s02.html#Edebug-Execution-Modes" title="Edebug Execution Modes">Edebug
Execution Modes</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58729296" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-unwrap-results</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合、Edebugは式の結果を表示するときに、その式自体のインストルメント結果の削除を試みる。マクロをデバッグするときは、式の結果自体がインストルメントされた式になるということに関連する。実際的な例ではないが、サンプル例の関数<code class="literal">fac</code>がインストルメントされたとき、そのフォームのマクロを考えてみるとよい。
</p><pre class="screen">(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      …))
</pre><p><code class="literal">test</code>マクロをインストルメントしてステップ実行すると、デフォルトでは<code class="literal">symbol-function</code>呼び出しは多数の<code class="literal">edebug-after</code>フォームと<code class="literal">edebug-before</code>フォームをもつことになり、それにより“実際の”結果の確認が難しくなり得る。<code class="literal">edebug-unwrap-results</code>が非<code class="literal">nil</code>の場合、Edebugは結果からこれらのフォームの削除を試みる。
</p></blockquote></div><pre class="synopsis"><a id="idm58721360" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-on-error</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">debug-on-error</code>の以前が<code class="literal">nil</code>の場合、Edebugは<code class="literal">debug-on-error</code>をこの値にバインドする。<a class="link" href="ch18s02.html#Trapping-Errors" title="Trapping Errors">Trapping
Errors</a>を参照。
</p></blockquote></div><pre class="synopsis"><a id="idm58712656" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-on-quit</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">debug-on-quit</code>の以前の値が<code class="literal">nil</code>の場合、Edebugは<code class="literal">debug-on-quit</code>にこの値をバインドする。<a class="link" href="ch18s02.html#Trapping-Errors" title="Trapping Errors">Trapping
Errors</a>を参照。
</p></blockquote></div><p>Edebugがアクティブな間に<code class="literal">edebug-on-error</code>または<code class="literal">edebug-on-quit</code>の値を変更した場合は、<span class="emphasis"><em>次回</em></span>に新たなコマンドを通じてEdebugが呼び出されるまで、これらの値は使用されない。
</p><pre class="synopsis"><a id="idm58705616" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">edebug-global-break-condition</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合、値はすべてのステップポイントでテストされる式である。式の結果が<code class="literal">nil</code>の場合は、breakする。エラーは無視される。<a class="link" href="ch18s02.html#Global-Break-Condition" title="Global Break Condition">Global
Break Condition</a>を参照。
</p></blockquote></div></div></div></body></html>