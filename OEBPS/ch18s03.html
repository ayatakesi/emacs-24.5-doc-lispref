<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Debugging Invalid Lisp Syntax</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Syntax-Errors"/>Debugging Invalid Lisp Syntax</h1></div></div></div><a id="idm58700496" class="indexterm"/><p>Lispリーダーは無効な構文(invalid
syntax)について報告はしますが、実際の問題箇所は報告しません。たとえば、ある式を評価中のエラー“End of file during
parsing(パース中にファイル終端に達した)”は、開カッコまたは開角カッコ(open parenthese or open square
bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に、“Invalid
read syntax:
")"(無効なread構文:)")"”は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならば、どうやって変更すべき箇所を探せばよいのでしょうか?
</p><p>問題が単なるカッコの不一致でない場合の便利なテクニックは、各defunの先頭で<strong class="userinput"><code>C-M-e</code></strong>とタイプして、そのdefunの最後と思われる箇所に移動するか確認する方法です。もし移動しなければ、問題はそのdefunの内部にあります。
</p><a id="idm58698448" class="indexterm"/><a id="idm58697680" class="indexterm"/><p>マッチしないカッコがLispにおいてもっとも一般的な構文エラーなので、これらのケースにたいしてさらにアドバイスすることができます。(Show
Parenモードを有効にしてコードにポイントを移動するだけで、カッコの不一致を探しやすくなるでしょう。)
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Excess-Open"/>Excess Open Parentheses</h2></div></div></div><a id="idm58695632" class="indexterm"/><p>カッコがマッチしないdefunを探すのが、最初のステップです。過剰な開カッコが存在する場合は、ファイルの終端に移動して<strong class="userinput"><code>C-u
C-M-u</code></strong>とタイプします。これにより、カッコがマッチしない最初のdefunの先頭に移動するでしょう。
</p><p>何が間違っているのか正確に判断するのが次のステップです。これを確実に行なうには、そのプログラムを詳しく調べる以外に方法はありませんが、カッコがあるべき箇所を探すのに、既存のインデントが手掛かりになることが多々あります。<strong class="userinput"><code>C-M-q</code></strong>で再インデントして何が移動されるか確認するのが、この手掛かりを使用するもっとも簡単な方法です。<span class="bold"><strong>しかし、行うのはちょっと待ってください!</strong></span>
まず続きを読んでからにしましょう。
</p><p>これを行なう前に、defunに十分な閉カッコがあるか確認します。十分な閉カッコがない場合、<strong class="userinput"><code>C-M-q</code></strong>がエラーとなるか、そのdefunからファイル終端までの残りすべてが再インデントされます。その場合はdefunの最後に移動して、そこに閉カッコを挿入します。そのdefunのカッコの釣り合いがとれるまでは、defunの最後に移動するのに<strong class="userinput"><code>C-M-e</code></strong>は使用できません(失敗するでしょう)。
</p><p>これでdefunの先頭に移動して<strong class="userinput"><code>C-M-q</code></strong>とタイプすることができます。通常は、一定のポイントからその関数の最後までのすべての行が、右へとシフトされるでしょう。これはおそらくそのポイント付近で閉カッコが欠落しているか、不要な開カッコがあります。(しかし、これを真実と仮定せず、コードを詳しく調べてください。)
不一致箇所が見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、<strong class="userinput"><code>C-_</code></strong>で<strong class="userinput"><code>C-M-q</code></strong>をアンドゥしてください。
</p><p>問題をfixできたと思った後に、再度<strong class="userinput"><code>C-M-q</code></strong>を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、<strong class="userinput"><code>C-M-q</code></strong>は何も変更しないはずです。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Excess-Close"/>Excess Close Parentheses</h2></div></div></div><a id="idm58686544" class="indexterm"/><p>過剰な閉カッコへの対処は、まずファイルの先頭に移動してから、カッコのマッチしないdefunを探すために<strong class="userinput"><code>C-u -1
C-M-u</code></strong>をタイプします。
</p><p>それから、そのdefunの先頭で<strong class="userinput"><code>C-M-f</code></strong>をタイプして、実際にマッチする閉カッコを探します。これにより、そのdefunの終端より幾分手前の箇所に移動するでしょう。その付近に間違った閉カッコが見つかるでしょう。
</p><p>そのポイントに問題が見つからない場合には、そのdefunの先頭で<strong class="userinput"><code>C-M-q</code></strong>をタイプするのが次のステップです。ある行範囲はおそらく左へシフトするでしょう。その場合、欠落している開カッコまたは間違った閉カッコは、おそらくそれらの行の1行目の近くにあるでしょう。
(しかし、これを真実と仮定せず、コードを詳しく調べてください。)不一致箇所が見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、<strong class="userinput"><code>C-_</code></strong>で<strong class="userinput"><code>C-M-q</code></strong>をアンドゥしてください。
</p><p>問題をfixできたと思った後に、再度<strong class="userinput"><code>C-M-q</code></strong>を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、<strong class="userinput"><code>C-M-q</code></strong>は何も変更しないはずです。
</p></div></div></body></html>