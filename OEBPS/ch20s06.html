<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Completion</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Completion"/>Completion</h1></div></div></div><a id="idm57937616" class="indexterm"/><p><em class="firstterm">補完(complete,
ompletion)</em>は省略された形式から始まる名前の残りを充填する機能です。補完はユーザー入力と有効な名前リストを比較して、ユーザーが何をタイプしたかで名前をどの程度一意に判定できるか判断することにより機能します。たとえば<strong class="userinput"><code>C-x
b</code></strong>(<code class="literal">switch-to-buffer</code>)とタイプしてから、スイッチしたいバッファー名の最初の数文字をタイプして、その後に<span class="keycap"><strong>TAB</strong></span>(<code class="literal">minibuffer-complete</code>)をタイプすると、Emacsはその名前を可能な限り展開します。
</p><p>標準的なEmacsコマンドはシンボル、ファイル、バッファー、プロセスの名前にたいして補完を提案します。このセクションの関数により、他の種類の名前にたいしても補完を実装できます。
</p><p><code class="literal">try-completion</code>関数は補完にたいする基本的なプリミティブです。これは初期文字列にたいして文字列セットをマッチして、最長と判定された補完をリターンします。
</p><p>関数<code class="literal">completing-read</code>は、補完にたいする高レベルなインターフェイスを提供します。<code class="literal">completing-read</code>の呼び出しにより、有効な名前リストの判定方法が指定されます。その後にこの関数は補完にたいして有用ないくつかのコマンドにキーバインドするローカルキーマップとともに、ミニバッファーをアクティブ化します。その他の関数は、特定の種類の名前を補完つきで読み取る、簡便なインターフェイスを提供します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Basic-Completion"/>Basic Completion Functions</h2></div></div></div><p>以下の補完関数は、その関数自身ではミニバッファーでなにも行いません。ここでは、ミニバッファーを使用する高レベルの補完機能と並べて、これらの関数について説明します。
</p><pre class="synopsis"><a id="idm57901136" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">try-completion</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>collection</code></em>内の<em class="replaceable"><code>string</code></em>に利用可能なすべての補完の、共通する最長部分文字列をリターンする。
</p><a id="idm57896272" class="indexterm"/><p><em class="replaceable"><code>collection</code></em>は<em class="firstterm">補完テーブル(completion
table)</em>と呼ばれる。値は文字列リスト、コンスセル、obarray、ハッシュテーブル、または補完関数でなければならない。
</p><p><code class="literal">try-completion</code>は補完テーブルにより指定された許容できる補完それぞれにたいして、<em class="replaceable"><code>string</code></em>と比較を行う。許容できる補完マッチが存在しない場合は、<code class="literal">nil</code>をリターンする。マッチする補完が1つだけで、それが完全一致ならば<code class="literal">t</code>をリターンする。それ以外は、すべてのマッチ可能な補完に共通する最長の初期シーケンス(longest
initial sequence)をリターンする。
</p><p><em class="replaceable"><code>collection</code></em>がリストの場合、許容できる補完(permissible
completions)はそのリストの要素により指定される。リストの要素は文字列、またはCARが文字列または(<code class="literal">symbol-name</code>により文字列に変換される)シンボルであるようなコンスセルである。リストに他の型の要素が含まれる場合は無視される。
</p><a id="idm57891152" class="indexterm"/><p><em class="replaceable"><code>collection</code></em>がobarray(<a class="link" href="ch09s03.html" title="Creating and Interning Symbols">Creating
Symbols</a>を参照)の場合、そのobarray内のすべてのシンボル名が許容できる補完セットを形成する。
</p><p><em class="replaceable"><code>collection</code></em>がハッシュテーブルの場合には、文字列のキーが利用可能な補完(possible
completions)になる。他のキーは無視される。
</p><p><em class="replaceable"><code>collection</code></em>として関数を使用することもできる。この場合、この関数だけが補完を処理する役目を担う。つまり<code class="literal">try-completion</code>は、この関数が何をリターンしようとも、それをリターンする。この関数は<em class="replaceable"><code>string</code></em>、<em class="replaceable"><code>predicate</code></em>、<code class="literal">nil</code>の3つの引数で呼び出される(3つ目の引数は同じ関数を<code class="literal">all-completions</code>でも使用して、どちらの場合でも適切なことを行うためである)。<a class="link" href="ch20s06.html#Programmed-Completion" title="Programmed Completion">Programmed
Completion</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>predicate</code></em>が非<code class="literal">nil</code>の場合、<em class="replaceable"><code>collection</code></em>がハッシュテーブルなら1引数、それ以外は2引数の関数でなければならない。これは利用可能なマッチのテストに使用され、マッチは<em class="replaceable"><code>predicate</code></em>が非<code class="literal">nil</code>をリターンしたときだけ受け入れられる。<em class="replaceable"><code>predicate</code></em>に与えられる引数は文字列、alistのコンスセル(CARが文字列)、またはobarrayのシンボル(シンボル名では<span class="emphasis"><em>ない</em></span>)のうちのどれか。<em class="replaceable"><code>collection</code></em>がハッシュテーブルの場合、<em class="replaceable"><code>predicate</code></em>は文字列キー(string
key)と関連値(associated value)の2引数で呼び出される。
</p><p>加えて使いやすいように、補完は<code class="literal">completion-regexp-list</code>内のすべての正規表現にもマッチしなければならない。(<em class="replaceable"><code>collection</code></em>が関数の場合は、その関数自身が<code class="literal">completion-regexp-list</code>を処理する必要がある。)
</p><p>以下の例の1つ目では、文字列‘<code class="literal">foo</code>’がalistのうち3つのCARとマッチされている。すべてのマッチは文字‘<code class="literal">fooba</code>’で始まるので、それが結果となる。2つ目の例では、可能なマッチは1つだけで、しかも完全一致なのでリターン値は<code class="literal">t</code>になる。
</p><pre class="screen">(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
     ⇒ "fooba"
</pre><pre class="screen">
</pre><pre class="screen">(try-completion "foo" '(("barfoo" 2) ("foo" 3)))
     ⇒ t
</pre><p>以下の例では、文字‘<code class="literal">forw</code>’で始まるシンボルが多数あり、それらはすべて単語‘<code class="literal">forward</code>’で始まる。ほとんどのシンボルはその後に‘<code class="literal">-</code>’が続くが、すべてではないので‘<code class="literal">forward</code>’までしか補完できない。
</p><pre class="screen">(try-completion "forw" obarray)
     ⇒ "forward"
</pre><p>最後に、以下の例では述語<code class="literal">test</code>に渡される利用可能なマッチは3つのうち2つだけである(文字列‘<code class="literal">foobaz</code>’は短すぎる)。これらは両方とも文字列‘<code class="literal">foobar</code>’で始まる。
</p><pre class="screen">(defun test (s)
  (&gt; (length (car s)) 6))
     ⇒ test
</pre><pre class="screen">(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     ⇒ "foobar"
</pre></blockquote></div><pre class="synopsis"><a id="idm57857232" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">all-completions</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>string</code></em>の利用可能な補完すべてのリストをリターンする。この関数の引数は<code class="literal">try-completion</code>の引数と同じであり、<code class="literal">try-completion</code>が行うのと同じ方法で<code class="literal">completion-regexp-list</code>を使用する。
</p><p><em class="replaceable"><code>collection</code></em>か関数の場合は<em class="replaceable"><code>string</code></em>、<em class="replaceable"><code>predicate</code></em>、<code class="literal">t</code>の3つの引数で呼び出される。この場合、その関数がリターンするのが何であれ、<code class="literal">all-completions</code>はそれをリターンする。<a class="link" href="ch20s06.html#Programmed-Completion" title="Programmed Completion">Programmed
Completion</a>を参照のこと。
</p><p>以下の例は、<code class="literal">try-completion</code>の例の関数<code class="literal">test</code>を使用している。
</p><pre class="screen">(defun test (s)
  (&gt; (length (car s)) 6))
     ⇒ test
</pre><pre class="screen">
</pre><pre class="screen">(all-completions
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     ⇒ ("foobar1" "foobar2")
</pre></blockquote></div><pre class="synopsis"><a id="idm57845072" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">test-completion</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-test_002dcompletion"/><p>この関数は、<em class="replaceable"><code>string</code></em>が<em class="replaceable"><code>collection</code></em>および<em class="replaceable"><code>predicate</code></em>で指定された有効な補完候補の場合は、<code class="literal">nil</code>をリターンする。引数は<code class="literal">try-completion</code>の引数と同じ。たとえば、<em class="replaceable"><code>collection</code></em>が文字列リストの場合は、<em class="replaceable"><code>string</code></em>がリスト内に存在し、かつ<em class="replaceable"><code>predicate</code></em>を満足すればtrueとなる。
</p><p>この関数は<code class="literal">try-completion</code>が行うのと同じ方法で、<code class="literal">completion-regexp-list</code>を使用する。
</p><p><em class="replaceable"><code>predicate</code></em>が非<code class="literal">nil</code>で、<em class="replaceable"><code>collection</code></em>が同じ文字列を複数含む場合には、<code class="literal">completion-ignore-case</code>にしたがって<code class="literal">compare-strings</code>で判定して、それらすべてをリターンするか、もしくは何もリターンしない。それ以外では、<code class="literal">test-completion</code>のリターン値は基本的に予測不可能である。
</p><p><em class="replaceable"><code>collection</code></em>が関数の場合は<em class="replaceable"><code>string</code></em>、<em class="replaceable"><code>predicate</code></em>、<code class="literal">lambda</code>の3つの引数で呼び出される。それが何をリターンするにせよ、<code class="literal">test-completion</code>はそれをリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm57830096" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">completion-boundaries</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>predicate</code></em> <em class="replaceable"><code>suffix</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はポイントの前のテキストが<em class="replaceable"><code>string</code></em>、ポイントの後が<em class="replaceable"><code>suffix</code></em>と仮定して、<em class="replaceable"><code>collection</code></em>が扱うフィールドの境界(boundary)をリターンする。
</p><p>補完は通常、文字列(string)全体に作用するので、すべての普通のコレクション(collection)にたいして、この関数は常に<code class="literal">(0
. (length
<em class="replaceable"><code>suffix</code></em>))</code>をリターンするだろう。しかしファイルにたいする補完などのより複雑な補完は、1回に1フィールド行われる。たとえば、たとえ<code class="literal">"/usr/share/doc"</code>が存在しても、<code class="literal">"/usr/sh"</code>の補完に<code class="literal">"/usr/share/"</code>は含まれるが、<code class="literal">"/usr/share/doc"</code>は含まれないだろう。また、<code class="literal">"/usr/sh"</code>にたいする<code class="literal">all-completions</code>に<code class="literal">"/usr/share/"</code>は含まれず、<code class="literal">"share/"</code>だけが含まれるだろう。<em class="replaceable"><code>string</code></em>が<code class="literal">"/usr/sh"</code>、<em class="replaceable"><code>suffix</code></em>が<code class="literal">"e/doc"</code>の場合、<code class="literal">completion-boundaries</code>は<code class="literal">(5
.
1)</code>をリターンするだろう。これは、<em class="replaceable"><code>collection</code></em>が<code class="literal">"/usr/"</code>の後ろにあり<code class="literal">"/doc"</code>の前にある領域に関する補完情報だけをリターンするであろうことを告げている。
</p></blockquote></div><p>補完alistを変数に格納した場合は、変数の<code class="literal">risky-local-variable</code>プロパティに非<code class="literal">nil</code>をセットして、その変数が“risky(危険)”だとマークすべきである。<a class="link" href="ch12s11.html" title="File Local Variables">File
Local Variables</a>を参照のこと。
</p><pre class="synopsis"><a id="idm57812944" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completion-ignore-case</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値が非<code class="literal">nil</code>の場合、補完での大文字小文字の違いは意味をもたない。<code class="literal">read-file-name</code>では、この変数は<code class="literal">read-file-name-completion-ignore-case</code>(<a class="link" href="ch20s06.html#Reading-File-Names" title="Reading File Names">Reading
File
Names</a>を参照)にオーバーライドされる。<code class="literal">read-buffer</code>では、この変数は<code class="literal">read-buffer-completion-ignore-case</code>(<a class="link" href="ch20s06.html#High_002dLevel-Completion" title="High-Level Completion Functions">High-Level
Completion</a>を参照)にオーバーライドされる。
</p></blockquote></div><pre class="synopsis"><a id="idm57806672" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completion-regexp-list</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは正規表現のリストである。補完関数はこのリスト内のすべての正規表現にマッチした場合のみ許容できる補完と判断する。<code class="literal">case-fold-search</code>(<a class="link" href="ch34s02.html" title="Searching and Case">Searching
and Case</a>を参照)では<code class="literal">completion-ignore-case</code>の値にバインドされる。
</p></blockquote></div><pre class="synopsis"><a id="idm57798352" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">lazy-completion-table</code> <em class="replaceable"><code>var</code></em> <em class="replaceable"><code>fun</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は変数<em class="replaceable"><code>var</code></em>を補完のためのcollectionとしてlazy(lazy:
力のない、だらけさせる、のろのろした、怠惰な、不精な、眠気を誘う)な方法で初期化する。ここでlazyとは、collection内の実際のコンテンツを必要になるまで計算しないという意味。このマクロは<em class="replaceable"><code>var</code></em>に格納する値の生成に使用する。<em class="replaceable"><code>var</code></em>を使用して最初に補完を行ったとき、真の値が実際に計算される。これは引数なしで<em class="replaceable"><code>fun</code></em>を呼び出すことにより行われる。<em class="replaceable"><code>fun</code></em>がリターンする値は、<em class="replaceable"><code>var</code></em>の永続的な値となる。
</p><p>以下は例である:
</p><pre class="screen">(defvar foo (lazy-completion-table foo make-my-alist))
</pre></blockquote></div><a id="idm57791440" class="indexterm"/><a id="idm57790672" class="indexterm"/><a id="idm57789904" class="indexterm"/><a id="idm57789136" class="indexterm"/><a id="idm57788368" class="indexterm"/><a id="idm57787600" class="indexterm"/><a id="idm57786832" class="indexterm"/><a id="idm57786064" class="indexterm"/><a id="idm57785296" class="indexterm"/><p>既存の補完テーブルを受け取り変更したバージョンをリターンする関数が、いくつかあります。<code class="literal">completion-table-case-fold</code>は大文字小文字を区別しない、case-insensitiveなテーブルをリターンします。<code class="literal">completion-table-in-turn</code>と<code class="literal">completion-table-merge</code>は、複数の入力テーブルを、異なる方法で組み合わせます。<code class="literal">completion-table-subvert</code>はテーブルを異なる初期プレフィックス(initial
prefix)で変更します。<code class="literal">completion-table-with-quoting</code>はクォートされたテキストの処理に適したテーブルをリターンします。<code class="literal">completion-table-with-predicate</code>は述語関数(predicate
function)によりフィルターします。<code class="literal">completion-table-with-terminator</code>は終端文字列(terminating
string)を追加します。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Minibuffer-Completion"/>Completion and the Minibuffer</h2></div></div></div><a id="idm57779536" class="indexterm"/><a id="idm57766480" class="indexterm"/><p>このセクションでは、補完つきでミニバッファーから読み取るための、基本的なインターフェイスを説明します。
</p><pre class="synopsis"><a id="idm57765072" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">completing-read</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>predicate</code></em> <em class="replaceable"><code>require-match</code></em> <em class="replaceable"><code>initial</code></em> <em class="replaceable"><code>history</code></em> <em class="replaceable"><code>default</code></em> <em class="replaceable"><code>inherit-input-method</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、補完の提供によりユーザーを支援して、ミニバッファーから文字列を読み取る。<em class="replaceable"><code>prompt</code></em>(文字列でなければならない)のプロンプトとともに、ミニバッファーをアクティブ化する。
</p><p>実際の補完は、補完テーブル<em class="replaceable"><code>collection</code></em>と補完述語<em class="replaceable"><code>predicate</code></em>を関数<code class="literal">try-completion</code>(<a class="link" href="ch20s06.html#Basic-Completion" title="Basic Completion Functions">Basic
Completion</a>を参照)に渡すことにより行われる。これは補完の使用されるローカルキーマップに特定のコマンドをバインドしたとき発生する。これらのコマンドのいくつかは、<code class="literal">test-completion</code>も呼び出す。したがって、<em class="replaceable"><code>predicate</code></em>が非<code class="literal">nil</code>の場合は、<em class="replaceable"><code>collection</code></em>と<code class="literal">completion-ignore-case</code>が矛盾しないようにすべきである。<a class="link" href="ch20s06.html#Definition-of-test_002dcompletion">Definition
of test-completion</a>を参照のこと。
</p><p>オプション引数<em class="replaceable"><code>require-match</code></em>の値は、ユーザーがミニバッファーをexitする方法を決定する。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">nil</code>の場合、通常のミニバッファーexitコマンドは、ミニバッファーの入力と無関係に機能する。
</p></li><li class="listitem"><p><code class="literal">t</code>の場合は、入力が<em class="replaceable"><code>collection</code></em>の要素に補完されるまで、通常のミニバッファーexitコマンドは機能しない。
</p></li><li class="listitem"><p><code class="literal">confirm</code>の場合、どのような入力でもユーザーはexitできるが、入力が<code class="literal">confirm</code>の要素に補完されていなければ、確認を求められる。
</p></li><li class="listitem"><p><code class="literal">confirm-after-completion</code>の場合、どのような入力でもユーザーはexitできるが、前のコマンドが補完コマンド(たとえば<code class="literal">minibuffer-confirm-exit-commands</code>の中のコマンドの1つの場合)で、入力の結果が<em class="replaceable"><code>collection</code></em>の要素でない場合は、確認を求められる。<a class="link" href="ch20s06.html#Completion-Commands" title="Minibuffer Commands that Do Completion">Completion
Commands</a>を参照のこと。
</p></li><li class="listitem"><p><em class="replaceable"><code>require-match</code></em>にたいする他の値は<code class="literal">t</code>と同じふぁが、exitコマンドは補完処理中はexitしない。
</p></li></ul></div><p>しかし、<em class="replaceable"><code>require-match</code></em>の値に関わらず、空の入力は常に許される。この場合、<code class="literal">completing-read</code>は<em class="replaceable"><code>default</code></em>がリストなら最初の要素、<em class="replaceable"><code>default</code></em>が<code class="literal">nil</code>なら<code class="literal">""</code>、または<em class="replaceable"><code>default</code></em>をリターンする。文字列および<em class="replaceable"><code>default</code></em>内の文字列は、ヒストリーコマンドを通じてユーザーが利用できる。
</p><p>関数<code class="literal">completing-read</code>は<em class="replaceable"><code>require-match</code></em>が<code class="literal">nil</code>の場合はキーマップとして<code class="literal">minibuffer-local-completion-map</code>を、<em class="replaceable"><code>require-match</code></em>が非<code class="literal">nil</code>の場合は<code class="literal">minibuffer-local-must-match-map</code>を使用する。<a class="link" href="ch20s06.html#Completion-Commands" title="Minibuffer Commands that Do Completion">Completion
Commands</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>history</code></em>は入力の保存とミニバッファーヒストリーコマンドに、どのヒストリーリスト変数を使用するか指定する。デフォルトは<code class="literal">minibuffer-history</code>。<a class="link" href="ch20s04.html" title="Minibuffer History">Minibuffer
History</a>を参照のこと。
</p><p><em class="replaceable"><code>initial</code></em>は、ほとんどの場合推奨されない。<em class="replaceable"><code>history</code></em>にたいするコンスセル指定と組み合わせた場合のみ、非<code class="literal">nil</code>値の使用を推奨する。<a class="link" href="ch20s05.html" title="Initial Input">Initial
Input</a>を参照のこと。デフォルト入力にたいしては、かわりに<em class="replaceable"><code>default</code></em>を使用する。
</p><p>引数<em class="replaceable"><code>inherit-input-method</code></em>が非<code class="literal">nil</code>の場合には、ミニバッファーにエンターする前にカレントだったバッファーが何であれ、カレントのインプットメソッド(<a class="link" href="ch33s11.html" title="Input Methods">Input
Methods</a>を参照)、および<code class="literal">enable-multibyte-characters</code>のセッティング(<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text
Representations</a>を参照)が継承される。
</p><p>変数<code class="literal">completion-ignore-case</code>が非<code class="literal">nil</code>の場合、利用可能なマッチにたいして入力を比較するときの補完は、大文字小文字を区別しない。<a class="link" href="ch20s06.html#Basic-Completion" title="Basic Completion Functions">Basic
Completion</a>を参照のこと。このモードでの操作では、<em class="replaceable"><code>predicate</code></em>も大文字小文字を区別してはならない(さもないと驚くべき結果となるであろう)。
</p><p>以下は<code class="literal">completing-read</code>を使用した例である:
</p><pre class="screen">(completing-read
 "Complete a foo: "
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 nil t "fo")
</pre><pre class="screen">
</pre><pre class="screen">;; 前の式を評価後に、
;;   ミニバッファーに以下が表示される。:

---------- Buffer: Minibuffer ----------
Complete a foo: fo★
---------- Buffer: Minibuffer ----------
</pre><p>その後ユーザーが<strong class="userinput"><code><span class="keycap"><strong>DEL</strong></span> <span class="keycap"><strong>DEL</strong></span> b
<span class="keycap"><strong>RET</strong></span></code></strong>をタイプすると、<code class="literal">completing-read</code>は<code class="literal">barfoo</code>をリターンする。
</p><p><code class="literal">completing-read</code>関数は、実際に補完を行うコマンドの情報を渡すために、変数をバインドする。これらの変数は、以降のセクションで説明する。
</p></blockquote></div><pre class="synopsis"><a id="idm57717328" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completing-read-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は関数でなければならず、補完つきの読み取りを実際に行うために<code class="literal">completing-read</code>から呼び出される。この関数は<code class="literal">completing-read</code>と同じ引数を受け入れる。他の関数のバインドして、通常の<code class="literal">completing-read</code>の振る舞いを完全にオーバーライドすることができる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Completion-Commands"/>Minibuffer Commands that Do Completion</h2></div></div></div><p>このセクションでは、補完のためにミニバッファーで使用されるキーマップ、コマンド、ユーザーオプションを説明します。
</p><pre class="synopsis"><a id="idm57711696" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-completion-table</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、ミニバッファー内の補完に使用される補完テーブルである。これは<code class="literal">completing-read</code>が<code class="literal">try-completion</code>に渡す補完テーブルを含むグローバル変数である。<code class="literal">minibuffer-complete-word</code>のような、ミニバッファー補完コマンドにより使用される。
</p></blockquote></div><pre class="synopsis"><a id="idm57707344" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-completion-predicate</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は<code class="literal">completing-read</code>が<code class="literal">try-completion</code>に渡す述語(predicate)である。この変数は、他のミニバッファー補完関数でも使用される。
</p></blockquote></div><pre class="synopsis"><a id="idm57703504" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-completion-confirm</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数はミニバッファーをexitする前に、Emacsが確認を求めるかどうかを決定する。<code class="literal">completing-read</code>はこの変数をバインドして、exitする前に関数<code class="literal">minibuffer-complete-and-exit</code>がこの値をチェックする。値が<code class="literal">nil</code>の場合は、確認は求められない。値が<code class="literal">confirm</code>の場合、入力が有効な補完候補でなくてもユーザーはexitするかもしれないが、Emacsは確認を求めない。値が<code class="literal">confirm-after-completion</code>の場合、入力が有効な補完候補でなくてもユーザーはexitするかもしれないが、ユーザーが<code class="literal">minibuffer-confirm-exit-commands</code>内の任意の補完コマンドの直後に入力を確定した場合、Emacsは確認を求める。
</p></blockquote></div><pre class="synopsis"><a id="idm57697488" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-confirm-exit-commands</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数には、<code class="literal">completing-read</code>の引数<em class="replaceable"><code>require-match</code></em>が<code class="literal">confirm-after-completion</code>の場合は、ミニバッファーをexitする前にEmacsが確認を求めるようにさせるコマンドのリストが保持されている。このリストないのコマンドを呼び出した直後にユーザーがミニバッファーのexitを試みると、Emacsは確認を求める。
</p></blockquote></div><pre class="synopsis"><a id="idm57693392" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">minibuffer-complete-word</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、ただ1つの単語からミニバッファーを補完する。たとえミニバッファーのコンテンツが1つの補完しかもたない場合でも、<code class="literal">minibuffer-complete-word</code>はその単語に属さない最初の文字を超えた追加はしない。<a class="link" href="ch35.html" title="Chapter 34. Syntax Tables">Syntax
Tables</a>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm57689552" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">minibuffer-complete</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、可能な限りミニバッファーのコンテンツを補完する。
</p></blockquote></div><pre class="synopsis"><a id="idm57686736" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">minibuffer-complete-and-exit</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はミニバッファーのコンテンツを補完して、確認が要求されない場合(たとえば<code class="literal">minibuffer-completion-confirm</code>が<code class="literal">nil</code>のとき)はexitする。確認が<span class="emphasis"><em>要求される</em></span>場合には、このコマンドを即座に繰り返すことにより確認が行われないようにする。このコマンドは2回連続で実行された場合は確認なしで機能するようにプログラムされている。
</p></blockquote></div><pre class="synopsis"><a id="idm57682384" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">minibuffer-completion-help</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントのミニバッファーのコンテンツで利用可能な補完のリストを作成する。これは<code class="literal">all-completions</code>の引数<em class="replaceable"><code>collection</code></em>に変数<code class="literal">minibuffer-completion-table</code>の値を、引数<em class="replaceable"><code>predicate</code></em>に<code class="literal">minibuffer-completion-predicate</code>の値を使用して呼び出すことにより機能する。補完リストは、<code class="filename">*Completions*</code>と呼ばれるバッファーのテキストとして表示される。
</p></blockquote></div><pre class="synopsis"><a id="idm57656272" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">display-completion-list</code> <em class="replaceable"><code>completions</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">standard-output</code>内のストリーム(通常はバッファー)に<em class="replaceable"><code>completions</code></em>を表示する(ストリームについての詳細は、<a class="link" href="ch19.html" title="Chapter 18. Reading and Printing Lisp Objects">Read
and
Print</a>を参照)。引数<em class="replaceable"><code>completions</code></em>は通常、<code class="literal">all-completions</code>がリターンする補完リストそのものだが、それである必要はない。要素はシンボルか文字列で、どちらも単にプリントされる。文字列2つのリストでもよく、2つの文字列が結合されたかのようにプリントされる。この場合、1つ目の文字列は実際の補完で、2つ目の文字列は注釈の役目を負う。
</p><p>この関数は<code class="literal">minibuffer-completion-help</code>により呼び出される。一般的には、以下のように<code class="literal">with-output-to-temp-buffer</code>とともに使用される。
</p><pre class="screen">(with-output-to-temp-buffer "*Completions*"
  (display-completion-list
    (all-completions (buffer-string) my-alist)))
</pre></blockquote></div><pre class="synopsis"><a id="idm57648848" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">completion-auto-help</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>の場合には、次の文字が一意でないために決定できず補完が完了しないときは常に、補完コマンドは利用可能な補完リストを自動的に表示する。
</p></blockquote></div><pre class="synopsis"><a id="idm57645648" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-local-completion-map</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">completing-read</code>の値は、補完の1つが完全に一致することを要求されないときにローカルキーマップとして使用される。デフォルトでは、このキーマップは以下のバインディングを作成する:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>?</code></strong>
</span></dt><dd><p><code class="literal">minibuffer-completion-help</code>
</p></dd><dt><span class="term"><span class="keycap"><strong>SPC</strong></span>
</span></dt><dd><p><code class="literal">minibuffer-complete-word</code>
</p></dd><dt><span class="term"><span class="keycap"><strong>TAB</strong></span>
</span></dt><dd><p><code class="literal">minibuffer-complete</code>
</p></dd></dl></div><p>親キーマップとして<code class="literal">minibuffer-local-map</code>を使用する(<a class="link" href="ch20s02.html#Definition-of-minibuffer_002dlocal_002dmap">Definition of
minibuffer-local-map</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm57636048" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-local-must-match-map</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">completing-read</code>は、補完の1つの完全な一致が要求されないときのローカルキーマップとして、この値を使用する。したがって<code class="literal">exit-minibuffer</code>にキーがバインドされていなければ、無条件にミニバッファーをexitする。デフォルトでは、このキーマップは以下のバインディングを作成する:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>C-j</code></strong>
</span></dt><dd><p><code class="literal">minibuffer-complete-and-exit</code>
</p></dd><dt><span class="term"><span class="keycap"><strong>RET</strong></span>
</span></dt><dd><p><code class="literal">minibuffer-complete-and-exit</code>
</p></dd></dl></div><p>親キーマップは<code class="literal">minibuffer-local-completion-map</code>を使用する。
</p></blockquote></div><pre class="synopsis"><a id="idm57628112" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-local-filename-completion-map</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは単に<span class="keycap"><strong>SPC</strong></span>を非バインドするsparseキーマップ(sparse:
疎、希薄、まばら)を作成する。これはファイル名にスペースを含めることができるからである。関数<code class="literal">read-file-name</code>は、このキーマップと<code class="literal">minibuffer-local-completion-map</code>か<code class="literal">minibuffer-local-must-match-map</code>のいずれかを組み合わせる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="High_002dLevel-Completion"/>High-Level Completion Functions</h2></div></div></div><p>このセクションでは、特定の種類の名前を補完つきで読み取る便利な高レベル関数を説明します。
</p><p>ほとんどの場合、Lisp関数の中盤でこれらの関数を呼び出すべきではありません。可能なときは、<code class="literal">interactive</code>指定の内部で呼び出し、ミニバッファーのすべての入力をコマンドの引数読み取りの一部にします。<a class="link" href="ch21s02.html" title="Defining Commands">Defining
Commands</a>を参照してください。
</p><pre class="synopsis"><a id="idm57620560" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-buffer</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>default</code></em> <em class="replaceable"><code>require-match</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はバッファーの名前を読み取り、それを文字列でリターンする。引数<em class="replaceable"><code>default</code></em>は、ミニバッファーが空の状態でユーザーがexitした場合にリターンされるデフォルト名として使用される。非<code class="literal">nil</code>の場合は文字列、文字列リスト、またはバッファーを指定する。リストの場合は、リストの先頭の要素がデフォルト値になる。デフォルト値はプロンプトに示されるが、初期入力としてミニバッファーには挿入されない。
</p><p>引数<em class="replaceable"><code>prompt</code></em>は、コロンかスペースで終わる文字列である。<em class="replaceable"><code>default</code></em>が非<code class="literal">nil</code>の場合、この関数はデフォルト値つきでミニバッファーから読み取る際の慣習にしたがい、コロンの前の<em class="replaceable"><code>prompt</code></em>の中にこれを挿入する。
</p><p>オプション引数<em class="replaceable"><code>require-match</code></em>は、<code class="literal">completing-read</code>のときと同じ。<a class="link" href="ch20s06.html#Minibuffer-Completion" title="Completion and the Minibuffer">Minibuffer
Completion</a>を参照のこと。
</p><p>以下の例で、ユーザーが‘<code class="literal">minibuffer.t</code>’とエンターしてから、<span class="keycap"><strong>RET</strong></span>をタイプする。引数<em class="replaceable"><code>require-match</code></em>は<code class="literal">t</code>であり、与えられた入力で始まるバッファー名は‘<code class="literal">minibuffer.texi</code>’だけなので、その名前が値となる。
</p><pre class="screen">(read-buffer "Buffer name: " "foo" t)
</pre><pre class="screen">;; 前の式を評価した後、
;;   空のミニバッファーに
;;   以下のプロンプトが表示される:
</pre><pre class="screen">
</pre><pre class="screen">---------- Buffer: Minibuffer ----------
Buffer name (default foo): ★
---------- Buffer: Minibuffer ----------
</pre><pre class="screen">
</pre><pre class="screen">;; ユーザーが<strong class="userinput"><code>minibuffer.t <span class="keycap"><strong>RET</strong></span></code></strong>とタイプする。
     ⇒ "minibuffer.texi"
</pre></blockquote></div><pre class="synopsis"><a id="idm57605328" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">read-buffer-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>の場合は、バッファー名を読み取る関数である。<code class="literal">read-buffer</code>は通常行うことを行うかわりに、<code class="literal">read-buffer</code>と同じ引数でその関数を呼び出す。
</p></blockquote></div><pre class="synopsis"><a id="idm57601104" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">read-buffer-completion-ignore-case</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非non-<code class="literal">nil</code>の場合は、補完の処理において<code class="literal">read-buffer</code>は大文字小文字を無視する。
</p></blockquote></div><pre class="synopsis"><a id="idm57597392" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-command</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>default</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はコマンドの名前を読み取り、Lispシンボルとしてそれをリターンする。引数<em class="replaceable"><code>prompt</code></em>は、<code class="literal">read-from-minibuffer</code>で使用される場合と同じ。それが何であれ<code class="literal">commandp</code>が<code class="literal">t</code>をリターンすればコマンドであり、コマンド名とは<code class="literal">commandp</code>が<code class="literal">t</code>をリターンするシンボルだということを思い出してほしい。<a class="link" href="ch21s03.html" title="Interactive Call">Interactive
Call</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>default</code></em>は、ユーザーがnull入力をエンターした場合に何をリターンするか指定する。シンボル、文字列、文字列リストを指定できる。文字列の場合、<code class="literal">read-command</code>はリターンする前にそれをinternする。リストの場合、<code class="literal">read-command</code>はリストの最初の要素をinternする。<em class="replaceable"><code>default</code></em>が<code class="literal">nil</code>の場合は、デフォルトが指定されなかったことを意味する。その場合もしユーザーがnull入力をエンターすると、リターン値は<code class="literal">(intern
"")</code>、つまり名前が空文字列のシンボルとなる。
</p><pre class="screen">(read-command "Command name? ")

</pre><pre class="screen">;; 前の式を評価した後に、
;;   空のミニバッファーに以下のプロンプトが表示される:
</pre><pre class="screen">
</pre><pre class="screen">---------- Buffer: Minibuffer ----------
Command name?
---------- Buffer: Minibuffer ----------
</pre><p>ユーザーが<strong class="userinput"><code>forward-c <span class="keycap"><strong>RET</strong></span></code></strong>とタイプした場合、この関数は<code class="literal">forward-char</code>をリターンする。
</p><p><code class="literal">read-command</code>関数は、<code class="literal">completing-read</code>の簡略化されたインターフェイスである。実在するLisp変数のセットを補完するために変数<code class="literal">obarray</code>を、コマンド名だけを受け入れるために述語<code class="literal">commandp</code>を使用する。
</p><a id="idm57568720" class="indexterm"/><pre class="screen">(read-command <em class="replaceable"><code>prompt</code></em>)
≡
(intern (completing-read <em class="replaceable"><code>prompt</code></em> obarray
                         'commandp t nil))
</pre></blockquote></div><pre class="synopsis"><a id="idm57566032" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-variable</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>default</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="Definition-of-read_002dvariable"/><p>この変数はカスタマイズ可能な変数の名前を読み取り、それをシンボルとしてリターンする。引数の形式は<code class="literal">read-command</code>の引数と同じ。この関数は、<code class="literal">commandp</code>のかわりに<code class="literal">custom-variable-p</code>を述語に使用する点を除き、<code class="literal">read-command</code>と同様に振る舞う。
</p></blockquote></div><pre class="synopsis"><a id="idm57559760" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">read-color</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>convert</code></em> <em class="replaceable"><code>allow-empty</code></em> <em class="replaceable"><code>display</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はカラー指定(カラー名、または<code class="literal">#RRRGGGBBB</code>のような形式のRGB16進値)の文字列を読み取る。これはプロンプトに<em class="replaceable"><code>prompt</code></em>(デフォルトは<code class="literal">"Color
(name or #RGB
triplet):"</code>)を表示して、カラー名にたいする補完を提供する(16進RGB値は補完しない)。標準的なカラー名に加えて、補完候補にはポイント位置のフォアグラウンドカラーとバックグラウンドカラーが含まれる。
</p><p>Valid RGB values are described in <a class="link" href="ch29s20.html" title="Color Names">Color Names</a>.
</p><p>この関数のリターン値は、ミニバッファー内でユーザーがタイプした文字列である。しかし、インタラクティブに呼び出されたとき、またはオプション引数<em class="replaceable"><code>convert</code></em>が非<code class="literal">nil</code>の場合は、入力されたカラー名のかわりに、それに対応するRGB値文字列をリターンする。この関数は、入力に有効なカラー指定を求める。<em class="replaceable"><code>allow-empty</code></em>が非<code class="literal">nil</code>でユーザーがnull入力をエンターした場合は、空のカラー名が許される。
</p><p>インタラクティブに呼び出されたとき、または<em class="replaceable"><code>display</code></em>が非<code class="literal">nil</code>の場合には、エコーエリアにもリターン値が表示される。
</p></blockquote></div><p><a class="link" href="ch33s10.html#User_002dChosen-Coding-Systems" title="User-Chosen Coding Systems">User-Chosen Coding
Systems</a>の関数<code class="literal">read-coding-system</code>と<code class="literal">read-non-nil-coding-system</code>、および<a class="link" href="ch33s11.html" title="Input Methods">Input
Methods</a>の<code class="literal">read-input-method-name</code>も参照のこと。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Reading-File-Names"/>Reading File Names</h2></div></div></div><a id="idm55124944" class="indexterm"/><a id="idm55124176" class="indexterm"/><p>高レベル補完関数<code class="literal">read-file-name</code>、<code class="literal">read-directory-name</code>、<code class="literal">read-shell-command</code>はそれぞれ、ファイル名、ディレクトリー名、シェルコマンドを読み取るようデザインされています。これらはデフォルトディレクトリーの自動挿入を含む特別な機能を提供します。
</p><pre class="synopsis"><a id="idm55121232" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-file-name</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>directory</code></em> <em class="replaceable"><code>default</code></em> <em class="replaceable"><code>require-match</code></em> <em class="replaceable"><code>initial</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はプロンプト<em class="replaceable"><code>prompt</code></em>とともに補完つきでファイル名を読み取る。
</p><p>例外として以下のすべてが真ならば、この関数はミニバッファーのかわりにグラフィカルなファイルダイアログを使用してファイル名を読み取る:
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>マウスコマンドを通じて呼び出された。
</p></li><li class="listitem"><p>グラフィカルなディスプレイ上の選択されたフレームがこの種のダイアログをサポートする。
</p></li><li class="listitem"><p>変数<code class="literal">use-dialog-box</code>が非<code class="literal">nil</code>の場合。section “Dialog Boxes” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p></li><li class="listitem"><p><em class="replaceable"><code>directory</code></em>引数(以下参照)がリモートファイルを指定しない。section “Remote Files” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p></li></ol></div><p>グラフィカルなファイルダイアログを使用したときの正確な振る舞いは、プラットホームに依存する。ここでは単にミニバッファーを使用したときの振る舞いを記す。
</p><p><code class="literal">read-file-name</code>はリターンするファイル名を自動的に展開しない。絶対ファイル名が必要ならば、自分で<code class="literal">expand-file-name</code>を呼び出さなければならない。
</p><p>オプション引数<em class="replaceable"><code>require-match</code></em>は、<code class="literal">completing-read</code>のときと同じ。<a class="link" href="ch20s06.html#Minibuffer-Completion" title="Completion and the Minibuffer">Minibuffer
Completion</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>directory</code></em>は、相対ファイル名の補完に使用するディレクトリーを指定する。値は絶対ディレクトリー名。変数<code class="literal">insert-default-directory</code>が非<code class="literal">nil</code>の場合は、初期入力としてミニバッファーに<em class="replaceable"><code>directory</code></em>も挿入される。デフォルトはカレントバッファーの<code class="literal">default-directory</code>の値。
</p><p><em class="replaceable"><code>initial</code></em>を指定した場合、それはミニバッファーに挿入する初期ファイル名になる(<em class="replaceable"><code>directory</code></em>が挿入された場合はその後に挿入される)。この場合、ポイントは<em class="replaceable"><code>initial</code></em>の先頭に配される。<em class="replaceable"><code>initial</code></em>のデフォルト値は<code class="literal">nil</code>(ファイル名を挿入しない)。<em class="replaceable"><code>initial</code></em>が何を行うか確認するには、ファイルをvisitしているバッファーで<strong class="userinput"><code>C-x
C-v</code></strong>を試すとよい。<span class="bold"><strong>注意: ほとんどの場合、</strong></span><em class="replaceable"><code>initial</code></em>よりも<em class="replaceable"><code>default</code></em>の使用を推奨する。
</p><p><em class="replaceable"><code>default</code></em>が非<code class="literal">nil</code>の場合、ユーザーが最初に<code class="literal">read-file-name</code>が挿入したものと同じ、空以外のコンテンツを残してミニバッファーをexitすると、この関数は<em class="replaceable"><code>default</code></em>をリターンする。<code class="literal">insert-default-directory</code>が非<code class="literal">nil</code>の場合はそれがデフォルトとなるので、ミニバッファーの初期コンテンツは常に空以外になる。<em class="replaceable"><code>require-match</code></em>の値に関わらず、<em class="replaceable"><code>default</code></em>の有効性はチェックされない。とはいえ<em class="replaceable"><code>require-match</code></em>が非<code class="literal">nil</code>の場合、ミニバッファーの初期コンテンツは有効なファイル名(またはディレクトリー名)であるべきだろう。それが有効でない場合、ユーザーがそれを編集せずにexitすると<code class="literal">read-file-name</code>は補完を試み、<em class="replaceable"><code>default</code></em>はリターンされない。<em class="replaceable"><code>default</code></em>はヒストリーコマンドからも利用できる。
</p><p><em class="replaceable"><code>default</code></em>が<code class="literal">nil</code>の場合、<code class="literal">read-file-name</code>はその場所に代用するデフォルトを探そうと試みる。この代用デフォルトは、明示的に<em class="replaceable"><code>default</code></em>にそれが指定されたかのように、<em class="replaceable"><code>default</code></em>とまったく同じ方法で扱われる。<em class="replaceable"><code>default</code></em>が<code class="literal">nil</code>でも<em class="replaceable"><code>initial</code></em>が非<code class="literal">nil</code>の場合、デフォルトは<em class="replaceable"><code>directory</code></em>と<em class="replaceable"><code>initial</code></em>から得られる絶対ファイル名になる。<em class="replaceable"><code>default</code></em>と<em class="replaceable"><code>initial</code></em>の両方が<code class="literal">nil</code>で、そのバッファーがファイルをvisitしているバッファーの場合、<code class="literal">read-file-name</code>はそのファイルの絶対ファイル名をデフォルトとして使用する。バッファーがファイルをvisitしていなければ、デフォルトは存在しない。この場合、ユーザーが編集せずに<span class="keycap"><strong>RET</strong></span>をタイプすると、<code class="literal">read-file-name</code>は前にミニバッファーに挿入されたコンテンツを単にリターンする。
</p><p>空のミニバッファー内でユーザーが<span class="keycap"><strong>RET</strong></span>をタイプした場合、この関数は<em class="replaceable"><code>require-match</code></em>の値に関わらず、空の文字列をリターンする。たとえばユーザーが<strong class="userinput"><code>M-x
set-visited-file-name</code></strong>を使用して、カレントバッファーをファイルをvisitしていないことにするのに、この方法を使用している。
</p><p><em class="replaceable"><code>predicate</code></em>が非<code class="literal">nil</code>の場合、それは補完候補として許容できるファイル名を決定する、1引数の関数である。<em class="replaceable"><code>predicate</code></em>が関数名にたいして非<code class="literal">nil</code>をリターンすれば、それはファイル名として許容できる値である。
</p><p>以下は<code class="literal">read-file-name</code>を使用した例である:
</p><pre class="screen">(read-file-name "The file is ")

;; 前の式を評価した後に、
;;   ミニバッファーに以下が表示される。:
</pre><pre class="screen">
</pre><pre class="screen">---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/★
---------- Buffer: Minibuffer ----------
</pre><p><strong class="userinput"><code>manual <span class="keycap"><strong>TAB</strong></span></code></strong>をタイプすると以下がリターンされる:
</p><pre class="screen">---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/manual.texi★
---------- Buffer: Minibuffer ----------
</pre><p>ここでユーザーが<span class="keycap"><strong>RET</strong></span>をタイプすると、<code class="literal">read-file-name</code>は文字列<code class="literal">"/gp/gnu/elisp/manual.texi"</code>をファイル名としてリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm57483984" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">read-file-name-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>非<code class="literal">nil</code>の場合は、<code class="literal">read-file-name</code>と同じ引数を受け取る関数である。<code class="literal">read-file-name</code>が呼び出されたとき、<code class="literal">read-file-name</code>は通常の処理を行なうかわりに、与えられた引数でこの関数を呼び出す。
</p></blockquote></div><pre class="synopsis"><a id="idm57475152" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">read-file-name-completion-ignore-case</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>の場合、<code class="literal">read-file-name</code>は補完を行なう際に大文字小文字を無視する。
</p></blockquote></div><pre class="synopsis"><a id="idm57467344" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-directory-name</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>directory</code></em> <em class="replaceable"><code>default</code></em> <em class="replaceable"><code>require-match</code></em> <em class="replaceable"><code>initial</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">read-file-name</code>と似ているが、補完候補としてディレクトリーだけを許す。
</p><p><em class="replaceable"><code>default</code></em>が<code class="literal">nil</code>で<em class="replaceable"><code>initial</code></em>が非<code class="literal">nil</code>の場合、<code class="literal">read-directory-name</code>は<em class="replaceable"><code>directory</code></em>(<em class="replaceable"><code>directory</code></em>が<code class="literal">nil</code>ならカレントバッファーのデフォルトディレクトリー)と<em class="replaceable"><code>initial</code></em>を組み合わせて代替えのデフォルトを構築する。<em class="replaceable"><code>default</code></em>と<em class="replaceable"><code>initial</code></em>の両方が<code class="literal">nil</code>の場合、この関数は<em class="replaceable"><code>directory</code></em>、<em class="replaceable"><code>directory</code></em>も<code class="literal">nil</code>の場合はカレントバッファーのデフォルトディレクトリーを代替えのデフォルトとして使用する。
</p></blockquote></div><pre class="synopsis"><a id="idm57442640" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">insert-default-directory</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は<code class="literal">read-file-name</code>により使用されるため、ファイル名を読み取るほとんどのコマンドにより、間接的に使用される。(これらのコマンドにはコマンドのインタラクティブフォームに‘<code class="literal">f</code>’や‘<code class="literal">F</code>’のコードレター(code
letter))をふくむすべてのコマンドが含まれる。<a class="link" href="ch21s02.html#Interactive-Codes" title="Code Characters for interactive">Code Characters for
interactive</a>を参照のこと。)この変数の値は、(もしあれば)デフォルトディレクトリー名をミニバッファー内に配して<code class="literal">read-file-name</code>を開始するかどうかを制御する。変数の値が<code class="literal">nil</code>の場合、<code class="literal">read-file-name</code>はミニバッファーに初期入力を何も配さない(ただし<em class="replaceable"><code>initial</code></em>引数で初期入力を指定しない場合)。この場合、依然としてデフォルトディレクトリーが相対ファイル名の補完に使用されるが、表示はされない。
</p><p>この変数が<code class="literal">nil</code>でミニバッファーの初期コンテンツが空の場合、ユーザーはデフォルト値にアクセスするために次のヒストリー要素を明示的にフェッチする必要があるだろう。この変数が非<code class="literal">nil</code>ならミニバッファーの初期コンテンツは常に空以外となり、ミニバッファーで編集をおこなわず即座に<span class="keycap"><strong>RET</strong></span>をタイプすることにより、常にデフォルト値を要求できる(上記参照)。
</p><p>たとえば:
</p><pre class="screen">;; デフォルトディレクトリーとともにミニバッファーが開始。
(let ((insert-default-directory t))
  (read-file-name "The file is "))
</pre><pre class="screen">
</pre><pre class="screen">---------- Buffer: Minibuffer ----------
The file is ~lewis/manual/★
---------- Buffer: Minibuffer ----------
</pre><pre class="screen">
</pre><pre class="screen">;; ミニバッファーはプロンプトだけで空。
;;   appears on its line.
(let ((insert-default-directory nil))
  (read-file-name "The file is "))
</pre><pre class="screen">
</pre><pre class="screen">---------- Buffer: Minibuffer ----------
The file is ★
---------- Buffer: Minibuffer ----------
</pre></blockquote></div><pre class="synopsis"><a id="idm57426640" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">read-shell-command</code> <em class="replaceable"><code>prompt</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>initial</code></em> <em class="replaceable"><code>history</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、プロンプト<em class="replaceable"><code>prompt</code></em>と優れた補完を提供して、ミニバッファーからのシェルコマンドを読み取る。これはコマンド名にたいして適切な候補を使用してコマンドの最初の単語を補完する。コマンドの残りの単語はファイル名として補完する。
</p><p>この関数はミニバッファー入力にたいするキーマップとして<code class="literal">minibuffer-local-shell-command-map</code>を使用する。<em class="replaceable"><code>history</code></em>引数は使用するヒストリーリストを指定する。省略、または<code class="literal">nil</code>の場合のデフォルトは<code class="literal">shell-command-history</code>(<a class="link" href="ch20s04.html" title="Minibuffer History">shell-command-history</a>を参照)。オプション引数<em class="replaceable"><code>initial</code></em>はミニバッファーの初期コンテンツを指定する(<a class="link" href="ch20s05.html" title="Initial Input">Initial
Input</a>を参照)。もしあれば、残りの<em class="replaceable"><code>args</code></em>は<code class="literal">read-from-minibuffer</code>内の<em class="replaceable"><code>default</code></em>および<em class="replaceable"><code>inherit-input-method</code></em>として使用される(<a class="link" href="ch20s02.html" title="Reading Text Strings with the Minibuffer">Text
from Minibuffer</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm57415248" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">minibuffer-local-shell-command-map</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このキーマップは<code class="literal">read-shell-command</code>により、コマンドおよびシェルコマンドの一部となるファイル名の補完のために使用される。これは親キーマップとして<code class="literal">minibuffer-local-map</code>を使用し、<span class="keycap"><strong>TAB</strong></span>を<code class="literal">completion-at-point</code>にバインドする。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Completion-Variables"/>Completion Variables</h2></div></div></div><p>補完のデフォルト動作を変更するために使用される変数がいくつかあります。
</p><a id="idm57409360" class="indexterm"/><pre class="synopsis"><a id="idm57408336" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">completion-styles</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、補完を行うために使用される補完スタイル(シンボル)である。<em class="firstterm">補完スタイル(completion
style)</em>とは、補完を生成するためのルールセットのこと。このリストにあるシンボルはそれぞれ、<code class="literal">completion-styles-alist</code>内に対応するエントリーをもたなければならない。
</p></blockquote></div><pre class="synopsis"><a id="idm57404624" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completion-styles-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数には補完スタイルのリストが格納される。リスト内の各要素は以下の形式をもつ
</p><pre class="screen">(<em class="replaceable"><code>style</code></em> <em class="replaceable"><code>try-completion</code></em> <em class="replaceable"><code>all-completions</code></em> <em class="replaceable"><code>doc</code></em>)
</pre><p>ここで<em class="replaceable"><code>style</code></em>は補完スタイルの名前(シンボル)であり、そのスタイルを参照するために変数<code class="literal">completion-styles</code>内で使用されるかもしれない。<em class="replaceable"><code>try-completion</code></em>は補完を行なう関数で、<em class="replaceable"><code>all-completions</code></em>補完をリストする関数、<em class="replaceable"><code>doc</code></em>補完スタイルを説明する文字列である。
</p><p>関数<em class="replaceable"><code>try-completion</code></em>および<em class="replaceable"><code>all-completions</code></em>は<em class="replaceable"><code>string</code></em>、<em class="replaceable"><code>collection</code></em>、<em class="replaceable"><code>predicate</code></em>、<em class="replaceable"><code>point</code></em>の4つの引数をとる。引数<em class="replaceable"><code>string</code></em>、<em class="replaceable"><code>collection</code></em>、<em class="replaceable"><code>predicate</code></em>の意味は<code class="literal">try-completion</code>(<a class="link" href="ch20s06.html#Basic-Completion" title="Basic Completion Functions">Basic
Completion</a>を参照)のときと同様。引数<em class="replaceable"><code>point</code></em>は<em class="replaceable"><code>string</code></em>内のポイント位置。各関数は自身の処理を行った場合は非<code class="literal">nil</code>を、行わなかった場合(たとえば補完スタイルに一致するように<em class="replaceable"><code>string</code></em>を行う方法がない場合)は<code class="literal">nil</code>をリターンする。
</p><p>ユーザーが<code class="literal">minibuffer-complete</code>(<a class="link" href="ch20s06.html#Completion-Commands" title="Minibuffer Commands that Do Completion">Completion
Commands</a>を参照)のような補完コマンドを呼び出すと、Emacsは<code class="literal">completion-styles</code>に最初にリストされたスタイルを探して、そのスタイルの<em class="replaceable"><code>try-completion</code></em>関数を呼び出す。この関数が<code class="literal">nil</code>をリターンした場合、Emacsは次にリストされた補完スタイルに移動してそのスタイルの<em class="replaceable"><code>try-completion</code></em>関数を呼び出すといったように、<em class="replaceable"><code>try-completion</code></em>関数の1つが補完の処理に成功して非<code class="literal">nil</code>値をリターンするまで順次これを行なう。同様の手順は<em class="replaceable"><code>all-completions</code></em>関数を通じて、補完のリストにも行われる。
</p><p>利用できる補完スタイルについてはsection “Completion Styles” in <em class="citetitle">The GNU Emacs
Manual</em>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm57384784" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">completion-category-overrides</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は特別な補完スタイルと、特定の種類のテキスト補完時に使用するその他の補完動作を指定する。この変数の値は<code class="literal">(<em class="replaceable"><code>category</code></em>
.
<em class="replaceable"><code>alist</code></em>)</code>という形式の要素をもつalistである。<em class="replaceable"><code>category</code></em>は何が補完されるかを記述するシンボルで、現在のところカテゴリーに<code class="literal">buffer</code>、<code class="literal">file</code>、<code class="literal">unicode-name</code>が定義されているが、これに特化した補完関数(<a class="link" href="ch20s06.html#Programmed-Completion" title="Programmed Completion">Programmed
Completion</a>を参照)を通じて他のカテゴリーを定義できる。<em class="replaceable"><code>alist</code></em>は、そのカテゴリーにたいして補完がどのように振る舞うべきかを記述する連想リスト。以下のalistのキーがサポートされる:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">styles</code>
</span></dt><dd><p>値は補完スタイル(シンボル)のリスト。
</p></dd><dt><span class="term"><code class="literal">cycle</code>
</span></dt><dd><p>値はそのカテゴリーにたいする<code class="literal">completion-cycle-threshold</code>(section “Completion Options” in <em class="citetitle">The GNU Emacs Manual</em>を参照)の値。
</p></dd></dl></div><p>将来、さらにalistエントリーが定義されるかもしれない。
</p></blockquote></div><pre class="synopsis"><a id="idm57374032" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completion-extra-properties</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数はカレント補完コマンドの特別なプロパティの指定に使用される。この変数は補完に特化したコマンドによりletバインドされることを意図している。値はプロパティ/値ペアーのリスト。以下のプロパティがサポートされる:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:annotation-function</code>
</span></dt><dd><p>値は補完バッファー内に注釈(annotation)を加える関数。この関数は引数completionを1つ受け取り<code class="literal">nil</code>、または補完の隣に表示する文字列をリターンしなければならない。
</p></dd><dt><span class="term"><code class="literal">:exit-function</code>
</span></dt><dd><p>値は補完を行った後に実行する関数。この関数は2つの引数<em class="replaceable"><code>string</code></em>と<em class="replaceable"><code>status</code></em>を受け取る。<em class="replaceable"><code>string</code></em>は補完されたフィールドのテキストで、<em class="replaceable"><code>status</code></em>は行われた操作の種類を示す。操作の種類は、テキストの補完が完了したなら<code class="literal">finished</code>、それ以上補完できないが補完が完了していなければ<code class="literal">sole</code>、有効な補完だがさらに補完できるときは<code class="literal">exact</code>となる。
</p></dd></dl></div></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Programmed-Completion"/>Programmed Completion</h2></div></div></div><a id="idm57364176" class="indexterm"/><p>意図した利用可能な補完のすべてを含むalistまたはobarrayを前もって作成するのが不可能または不便なことがあります。このような場合は、与えられた文字列にたいする補完を計算する独自の関数を提供できます。これは<em class="firstterm">プログラム補完(programmed
completion)</em>と呼ばれます。Emacsは数あるケースの中でも特に、ファイル名の補完(<a class="link" href="ch25s08.html#File-Name-Completion" title="File Name Completion">File Name
Completion</a>を参照)でプログラム補完を使用しています。
</p><p>この機能を使用するためには、関数を<code class="literal">completing-read</code>の<em class="replaceable"><code>collection</code></em>引数に渡します。関数<code class="literal">completing-read</code>はその補完関数が<code class="literal">try-completion</code>、<code class="literal">all-completions</code>などの基本的な補完関数に渡されて、その関数がすべてを行えるよう取り計らいます。
</p><p>補完関数は3つの引数を受け取ります:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>補完される文字列。
</p></li><li class="listitem"><p>利用可能なマッチをフィルターする述語関数。もしなければ<code class="literal">nil</code>。関数は利用可能なマッチにたいしてこの述語(predicate)を呼び出し、述語が<code class="literal">nil</code>をリターンした場合はそのマッチを無視する。
</p></li><li class="listitem"><p>実行する補完操作のタイプを指定するフラグ。以下の4つの値のうち1つを指定する:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">nil</code>
</span></dt><dd><p><code class="literal">try-completion</code>を指定する。関数は指定された文字が一意かつ完全一致の場合は、<code class="literal">t</code>をリターンする。マッチが複数の場合、すべてのマッチに共通する部分文字列をリターンする(文字列が補完候補の1つに完全一致するが、より長い他の候補にもマッチする場合、リターン値はその文字列)。マッチがなければ<code class="literal">nil</code>をリターンする。
</p></dd><dt><span class="term"><code class="literal">t</code>
</span></dt><dd><p><code class="literal">all-completions</code>を指定する。関数は指定された文字列の利用可能なすべての補完のリストをリターンする。
</p></dd><dt><span class="term"><code class="literal">lambda</code>
</span></dt><dd><p><code class="literal">test-completion</code>を指定する。関数は指定された文字列がいくつかの補完候補に完全一致する場合は<code class="literal">t</code>、それ以外は<code class="literal">nil</code>をリターンする。
</p></dd><dt><span class="term"><code class="literal">(boundaries . <em class="replaceable"><code>suffix</code></em>)</code>
</span></dt><dd><p><code class="literal">completion-boundaries</code>を指定する。関数は<code class="literal">(boundaries <em class="replaceable"><code>start</code></em>
.
<em class="replaceable"><code>end</code></em>)</code>をリターンする。ここで<em class="replaceable"><code>start</code></em>は指定された文字列内の境界の開始位置、<em class="replaceable"><code>end</code></em>は<em class="replaceable"><code>suffix</code></em>内の境界の終了位置。
</p></dd><dt><span class="term"><code class="literal">metadata</code>
</span></dt><dd><p>カレント補完の状態に関する情報の要求を指定する。リターン値は<code class="literal">(metadata
. <em class="replaceable"><code>alist</code></em>)</code>の形式をもち、<em class="replaceable"><code>alist</code></em>は以下で説明する要素をもつ連想配列。
</p></dd></dl></div><p>フラグに他の値が指定された場合、補完関数は<code class="literal">nil</code>をリターンする。
</p></li></ul></div><p>以下は<code class="literal">metadata</code>フラグ引数への応答として補完関数がリターンするかもしれない、metadataエントリーのリストです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">category</code>
</span></dt><dd><p>値は補完関数が補完を試みているテキストの種類を説明するシンボル。シンボルが<code class="literal">completion-category-overrides</code>内のキーの1つにマッチする場合、通常の補完動作はオーバーライドされる。<a class="link" href="ch20s06.html#Completion-Variables" title="Completion Variables">Completion
Variables</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">annotation-function</code>
</span></dt><dd><p>値は補完に<em class="firstterm">注釈(annotation)</em>を付ける関数。この関数は1つの引数<em class="replaceable"><code>string</code></em>をとり、これは利用可能な補完である。リターン値は文字列で、<code class="filename">*Completions*</code>バッファー内の補完<em class="replaceable"><code>string</code></em>の後に表示される。
</p></dd><dt><span class="term"><code class="literal">display-sort-function</code>
</span></dt><dd><p>値は補完をソートする関数。関数は1つの引数をとる。これは補完文字列のリストで、ソートされた補完文字列リストがリターンされる。その入力のリストは破壊的に変更することが許される。
</p></dd><dt><span class="term"><code class="literal">cycle-sort-function</code>
</span></dt><dd><p>値は<code class="literal">completion-cycle-threshold</code>が非<code class="literal">nil</code>で、ユーザーが補完候補を巡回するときに補完をソートする関数。引数のリストとリターン値は<code class="literal">display-sort-function</code>と同様。
</p></dd></dl></div><pre class="synopsis"><a id="idm57317840" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">completion-table-dynamic</code> <em class="replaceable"><code>function</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はプログラム補完関数として動作する関数を記述する便利な方法である。引数<em class="replaceable"><code>function</code></em>は1つの引数(文字列)をとる関数であり、その文字列の利用可能な補完のalistをリターンする。<code class="literal">completion-table-dynamic</code>は、<em class="replaceable"><code>function</code></em>とプログラム補完関数のインターフェイス変換器と考えることができる。
</p></blockquote></div><pre class="synopsis"><a id="idm57313104" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">completion-table-with-cache</code> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>ignore-case</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは前回の引数/結果ペアーを保存する<code class="literal">completion-table-dynamic</code>にたいするラッパーである。これは同じ引数にたいする複数回の検査に必要なのは、1回の<em class="replaceable"><code>function</code></em>呼び出しだけであることを意味する。これは外部プロセス呼び出しなど、処理が低速のとき有用かもしれない。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Completion-in-Buffers"/>Completion in Ordinary Buffers</h2></div></div></div><a id="idm57307344" class="indexterm"/><a id="idm57306576" class="indexterm"/><p>補完は通常はミニバッファー内で行われますが、補完機能は通常のEmacsバッファー内のテキストにも使用できます。多くのメジャーモードで、コマンド<strong class="userinput"><code>C-M-i</code></strong>または<strong class="userinput"><code>M-<span class="keycap"><strong>TAB</strong></span></code></strong>によりバッファー内補完が行われ、それらは<code class="literal">completion-at-point</code>にバインドされています。section “Symbol
Completion” in <em class="citetitle">The GNU Emacs
Manual</em>を参照してください。このコマンドはアブノーマルフック変数<code class="literal">completion-at-point-functions</code>を使用します:
</p><pre class="synopsis"><a id="idm57302352" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">completion-at-point-functions</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このアブノーマルフックの値は関数のリストである。これらの関数はポイント位置のテキストの補完にたいする補完テーブルの計算に使用される。これはメジャーモードにより、モード特有な補完テーブル(<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照)の提供に使用できる。
</p><p>コマンド<code class="literal">completion-at-point</code>が実行されると、引数なしでリスト内の関数が1つずつ呼び出される。それぞれの関数は、ポイント位置のテキストにたいして補完テーブルを生成できない場合は<code class="literal">nil</code>をリターンする。生成できた場合は、以下の形式のリストをリターンする
</p><pre class="screen">(<em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>collection</code></em> . <em class="replaceable"><code>props</code></em>)
</pre><p>ここで<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>は補完する(ポイントを取り囲む)テキストの区切りである。<em class="replaceable"><code>collection</code></em>はそのテキストを補完する補完テーブルであり、<code class="literal">try-completion</code>(<a class="link" href="ch20s06.html#Basic-Completion" title="Basic Completion Functions">Basic
Completion</a>を参照)の2つ目の引数として渡すのに適した形式である。補完候補は<code class="literal">completion-styles</code>(<a class="link" href="ch20s06.html#Completion-Variables" title="Completion Variables">Completion
Variables</a>を参照)で定義された補完スタイルを通じ、この補完テーブルを通常の方法で使用して生成されるだろう。<em class="replaceable"><code>props</code></em>は追加の情報のためのプロパティリストである。<code class="literal">completion-extra-properties</code>内のすべてのプロパティ(<a class="link" href="ch20s06.html#Completion-Variables" title="Completion Variables">Completion
Variables</a>を参照)と、以下の追加のプロパティが認識される:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:predicate</code>
</span></dt><dd><p>値は補完候補が満足する必要がある述語。
</p></dd><dt><span class="term"><code class="literal">:exclusive</code>
</span></dt><dd><p>値が<code class="literal">no</code>の場合は、もし補完テーブルがポイント位置のテキストのマッチに失敗したなら、補完の失敗を報告するかわりに<code class="literal">completion-at-point</code>は<code class="literal">completion-at-point-functions</code>内の次の関数へ移動する。
</p></dd></dl></div><p><code class="literal">completion-at-point-functions</code>内の関数も関数をリターンするかもしれない。その場合は引数なしでリターンされた関数が呼び出され、その関数が補完処理の全責任を負う。この方法は推奨されない。これは<code class="literal">completion-at-point</code>を使用する古いコードの救済を意図したもののだからである。
</p><p>非<code class="literal">nil</code>値を最初にリターンした<code class="literal">completion-at-point-functions</code>内の関数が、<code class="literal">completion-at-point</code>により使用される。残りの関数は呼び出されない。これの例外は上述の<code class="literal">:exclusive</code>指定があるときである。
</p></blockquote></div><p>以下の関数は、Emacsバッファー内の任意に拡張されたテキストにたいして便利な補完方法を提供します:
</p><pre class="synopsis"><a id="idm57278288" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">completion-in-region</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>collection</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>predicate</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>collection</code></em>を使用して、カレントバッファー内の位置<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストを補完する。引数<em class="replaceable"><code>collection</code></em>は<code class="literal">try-completion</code>(<a class="link" href="ch20s06.html#Basic-Completion" title="Basic Completion Functions">Basic
Completion</a>を参照)のときと同じ意味をもつ。
</p><p>この関数は補完テキストを直接カレントバッファーに挿入する。<code class="literal">completing-read</code>(<a class="link" href="ch20s06.html#Minibuffer-Completion" title="Completion and the Minibuffer">Minibuffer
Completion</a>を参照)とは異なり、ミニバッファーをアクティブにしない。
</p><p>この関数が機能するためには、ポイントが<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間になければならない。
</p></blockquote></div></div></div></body></html>