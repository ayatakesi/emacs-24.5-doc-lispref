<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 20. Command Loop</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Command-Loop"/>Chapter 20. Command Loop</h1></div></div></div><a id="idm56948816" class="indexterm"/><a id="idm56948048" class="indexterm"/><p>Emacsを実行すると、ほぼ即座に<em class="firstterm">エディターコマンドループ(editor command
loop)</em>にエンターします。このループはキーシーケンスを読み取り、それらの定義を実行して、結果を表示します。このチャプターでは、これらが行われる方法と、Lispプログラムがこれらを行えるようにするサブルーチンを説明します。
</p><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Command-Overview"/>Command Loop Overview</h1></div></div></div><p>コマンドループが最初に行わなければならないのはキーシーケンスの読み取りです。キーシーケンスほコマンドに変換される入力イベントのシーケンスです。これは関数<code class="literal">read-key-sequence</code>を呼び出すことにより行われます。Lispプログラムもこの関数を呼び出すことができます(<a class="link" href="ch21s08.html#Key-Sequence-Input" title="Key Sequence Input">Key
Sequence
Input</a>を参照)。これらはより低レベルの<code class="literal">read-key</code>や<code class="literal">read-event</code>(<a class="link" href="ch21s08.html#Reading-One-Event" title="Reading One Event">Reading One
Event</a>)で入力を読み取ったり、<code class="literal">discard-input</code>(<a class="link" href="ch21s08.html#Event-Input-Misc" title="Miscellaneous Event Input Features">Event Input
Misc</a>を参照)で保留中の入力を無視することもできます。
</p><p>キーシーケンスはカレントでアクティブなキーマップを通じてコマンドに変換されます。これが行われる方法については、See <a class="link" href="ch22s10.html" title="Key Lookup">Key
Lookup</a>を参照してください。結果はキーボードマクロかインタラクティブに呼び出し可能な関数になります。キーが<strong class="userinput"><code>M-x</code></strong>の場合は、他のコマンドの名前を読み取り、それを呼び出します。これはコマンド<code class="literal">execute-extended-command</code>(<a class="link" href="ch21s03.html" title="Interactive Call">Interactive
Call</a>を参照)により行われます。
</p><p>コマンドの実行に先立ち、Emacsはアンドゥ境界(undo
boundary)を作成するために<code class="literal">undo-boundary</code>を実行します。<a class="link" href="ch32s10.html" title="Maintaining Undo Lists">Maintaining Undo</a>を参照してください。
</p><p>コマンドを実行するために、Emacsはまず<code class="literal">command-execute</code>を呼び出してコマンドの引数を読み取ります(<a class="link" href="ch21s03.html" title="Interactive Call">Interactive
Call</a>を参照)。Lispで記述されたコマンドについては、<code class="literal">interactive</code>指定で引数を読み取る方法を指定します。これはプレフィクス引数(<a class="link" href="ch21s12.html" title="Prefix Command Arguments">Prefix
Command
Arguments</a>を参照)を使用したり、ミニバッファー内(<a class="link" href="ch20.html" title="Chapter 19. Minibuffers">Minibuffers</a>を参照)で確認を求めて読み取りを行うかもしれません。たとえば、コマンド<code class="literal">find-file</code>には<code class="literal">interactive</code>指定があり、これはミニバッファーを使用してファイル名を読み取ることを指定します。<code class="literal">find-file</code>の関数bodyはミニバッファーを使用しないので、Lispコードから関数として<code class="literal">find-file</code>を呼び出す場合は通常のLisp関数引数としてファイル名を文字列で与えなければなりません。
</p><p>コマンドがキーボードマクロ(文字列やベクター)の場合、Emacsは<code class="literal">execute-kbd-macro</code>を使用してそれを実行します(<a class="link" href="ch21s16.html" title="Keyboard Macros">Keyboard
Macros</a>を参照)。
</p><pre class="synopsis"><a id="idm56926672" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">pre-command-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このノーマルフックはコマンドを実行する前に、エディターコマンドループにより実行される。その際、<code class="literal">this-command</code>
には実行しようとするコマンドが含まれ、<code class="literal">last-command</code>には前のコマンドが記述される。<a class="link" href="ch21s05.html" title="Information from the Command Loop">Command Loop
Info</a>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm56889552" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">post-command-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このノーマルフックはコマンドを実行した後(quitやエラーにより早期に終了させられたコマンドを含む)に、エディターコマンドループにより実行される。その際、<code class="literal">this-command</code>は正に実行されたコマンドを参照し、<code class="literal">last-command</code>は前に実行されたコマンドを参照する。
</p><p>このフックはEmacsが最初にコマンドループにエンターしたときにも実行される(その時点では<code class="literal">this-command</code>と<code class="literal">last-command</code>はどちらも<code class="literal">nil</code>)。
</p></blockquote></div><p><code class="literal">pre-command-hook</code>および<code class="literal">post-command-hook</code>の実行中、quitは抑制されます。これらのフックのどれか1つを実行中にエラーが発生した場合、そのエラーはフックの実行を終了させません。そのかわりにエラーは黙殺され、エラーが発生した関数はそのフックから取り除かれます。
</p><p>Emacsサーバー(section “Emacs Server” in <em class="citetitle">The GNU Emacs
Manual</em>を参照)に届くリクエストは、キーボードコマンドが行うのと同じように、これらの2つのフックを実行します。
</p></div></div></body></html>