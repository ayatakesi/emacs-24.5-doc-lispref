<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Quitting</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Quitting"/>Quitting</h1></div></div></div><a id="idm59573072" class="indexterm"/><a id="idm59572048" class="indexterm"/><a id="idm59571280" class="indexterm"/><p>Lisp関数を実行中に<strong class="userinput"><code>C-g</code></strong>をタイプすると、Emacsが何を行っていてもEmacsを<em class="firstterm">quit(中止、終了)</em>させます。これはアクティブなコマンドループの再内に制御がリターンすることを意味します。
</p><p>コマンドループがキーボード入力待機中に<strong class="userinput"><code>C-g</code></strong>をタイプしてもquitはしません。これは通常の入力文字として機能します。もっともシンプルなケースでは、通常<strong class="userinput"><code>C-g</code></strong>はquitの効果をもつ<code class="literal">keyboard-quit</code>を実行するので、区別できませんしかしプレフィクスキーの後の<strong class="userinput"><code>C-g</code></strong>は、未定義のキー組み合わせになります。これはプレフィクスキーやプレフィクスキーも同様にキャンセルする効果をもちます。
</p><p>ミニバッファー内では、<strong class="userinput"><code>C-g</code></strong>は異なる定義をもち、それはミニバッファーをabort(失敗、中止、中断)します。これは実際にはミニバッファーをexitしてquitします(単にquitするのは<span class="emphasis"><em>ミニバッファー内</em></span>のコマンドループにリターンするだろう)。<strong class="userinput"><code>C-g</code></strong>がなぜコマンドリーダーが入力読み取り時に直接quitしないかという理由は、ミニバッファー内で<strong class="userinput"><code>C-g</code></strong>の意味をこの方法により再定義可能にするためです。プレフィクスキーの後の<strong class="userinput"><code>C-g</code></strong>はミニバッファー内で再定義されておらず、プレフィクスキーおよびプレフィクス引数のキャンセルという通常の効果をもちます。もし<strong class="userinput"><code>C-g</code></strong>ｇヴぁ常に直接quitするなら、これは不可能でしょう。
</p><p><strong class="userinput"><code>C-g</code></strong>が直接quitを行うときは、変数<code class="literal">quit-flag</code>を<code class="literal">t</code>にセットすることによりそれを行います。Emacsは適切なときにこの変数をチェックして、<code class="literal">nil</code>でない場合はquitします。どのような方法でも、<code class="literal">quit-flag</code>を非<code class="literal">nil</code>にセットするとquitが発生します。
</p><p>Cコードのレベルでは、どこでもquitを発生させることはできず、<code class="literal">quit-flag</code>をチェックする特別な場所でのみquitが発生します。この理由は、他の場所でquitすると、Emacsの内部状態が矛盾が生じるかもしれないからです。安全な場所までquitが遅延されるので、quitがEmacsをクラッシュさせることがなくなります。
</p><p><code class="literal">read-key-sequence</code>や<code class="literal">read-quoted-char</code>のような特定の関数は、たとえ入力を待機中でもquitを抑制します。quitするかわりに、<strong class="userinput"><code>C-g</code></strong>は要求された入力として処理されます。<code class="literal">read-key-sequence</code>の場合、これはコマンドループ内での<strong class="userinput"><code>C-g</code></strong>の特別な振る舞いを引き起こすのに役立ちます。<code class="literal">read-quoted-char</code>の場合、これは<strong class="userinput"><code>C-g</code></strong>をクォートするのに<strong class="userinput"><code>C-q</code></strong>を使用できるようにします。
</p><a id="idm59554640" class="indexterm"/><p>変数<code class="literal">inhibit-quit</code>を非<code class="literal">nil</code>値にバインドすることにより、Lisp関数の一部でquitを抑止できます。その場合は、<code class="literal">quit-flag</code>を<code class="literal">t</code>にセットされていても、<strong class="userinput"><code>C-g</code></strong>の通常の結果であるquitは抑止されます。<code class="literal">let</code>フォームの最後でこのバインディングがunwindされるなどして、結果として<code class="literal">inhibit-quit</code>は再び<code class="literal">nil</code>になります。このとき<code class="literal">quit-flag</code>が<code class="literal">nil</code>の場合には、即座に要求されたquitが発生します。この挙動は、プログラム中の“クリティカルセクション”内でquitが発生しないことを確実にしたいときに理想的です。
</p><a id="idm59548368" class="indexterm"/><p>(<code class="literal">read-quoted-char</code>のような)いくつかの関数では、quitを起こさない特別な方法で<strong class="userinput"><code>C-g</code></strong>が処理されます。これは<code class="literal">inhibit-quit</code>を<code class="literal">t</code>にバインドして入力を読み取り、再び<code class="literal">inhibit-quit</code>が<code class="literal">nil</code>になる前に<code class="literal">quit-flag</code>を<code class="literal">nil</code>にセットすることにより行われます。以下は、これを行う方法を示すための<code class="literal">read-quoted-char</code>の抜粋です。この例は入力の最初の文字の後で通常のquitを許す方法も示しています。
</p><pre class="screen">(defun read-quoted-char (&amp;optional prompt)
  "…<em class="replaceable"><code>documentation</code></em>…"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            …)
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      … 変数<code class="literal">code</code>をセット …)
    code))
</pre><pre class="synopsis"><a id="idm59540432" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">quit-flag</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>で<code class="literal">inhibit-quit</code>が<code class="literal">nil</code>の場合、macsは即座にquitする。<strong class="userinput"><code>C-g</code></strong>をタイプすると、通常は<code class="literal">inhibit-quit</code>とは無関係に<code class="literal">quit-flag</code>を非<code class="literal">nil</code>にセットする。
</p></blockquote></div><pre class="synopsis"><a id="idm59534160" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">inhibit-quit</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、<code class="literal">quit-flag</code>が非<code class="literal">nil</code>にセットされているときEmacsがquitするかどうかを決定する。<code class="literal">inhibit-quit</code>が非<code class="literal">nil</code>の場合、<code class="literal">quit-flag</code>は特に効果がない。
</p></blockquote></div><pre class="synopsis"><a id="idm59528912" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">with-local-quit</code> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは<em class="replaceable"><code>body</code></em>を順番に実行するが、たとえこの構成の外部で<code class="literal">inhibit-quit</code>が非<code class="literal">nil</code>でも、少なくともローカルに<em class="replaceable"><code>body</code></em>内でのquitを許す。このマクロはquitによりexitした場合は<code class="literal">nil</code>、それ以外は<em class="replaceable"><code>body</code></em>内の最後のフォームの値をリターンする。
</p><p><code class="literal">inhibit-quit</code>が<code class="literal">nil</code>の場合<code class="literal">with-local-quit</code>へのエントリーで<em class="replaceable"><code>body</code></em>だけが実行され、<code class="literal">quit-flag</code>をセットすることにより通常のquitが発生する。しかし通常のquitが遅延されるように<code class="literal">inhibit-quit</code>が非<code class="literal">nil</code>にセットされている場合、非<code class="literal">nil</code>の<code class="literal">quit-flag</code>は特別な種類のローカルquitを引き起こす。これは<em class="replaceable"><code>body</code></em>の実行を終了して、<code class="literal">quit-flag</code>を非<code class="literal">nil</code>のままで<code class="literal">with-local-quit</code>ボディーをexitするので、許され次第(通常の)他のquitが発生する。<em class="replaceable"><code>body</code></em>の先頭ですでに<code class="literal">quit-flag</code>が非<code class="literal">nil</code>の場合、即座にローカルquitが発生して結局ボディーは実行されない。
</p><p>このマクロは主にタイマー、プロセスフィルター、プロセスセンチネル、<code class="literal">pre-command-hook</code>、<code class="literal">post-command-hook</code>、および<code class="literal">inhibit-quit</code>が通常は<code class="literal">t</code>にバイドされている場所で役に立つ。
</p></blockquote></div><pre class="synopsis"><a id="idm59512144" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">keyboard-quit</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">(signal 'quit
nil)</code>により<code class="literal">quit</code>条件をシグナルする。これはquitが行うことと同じである(<a class="link" href="ch11s05.html#Errors" title="Errors">Errors</a>の<code class="literal">signal</code>を参照)。
</p></blockquote></div><p>quitに使用する<strong class="userinput"><code>C-g</code></strong>以外の文字を指定できます。<a class="link" href="ch39s12.html#Input-Modes" title="Input Modes">Input
Modes</a>内の関数<code class="literal">set-input-mode</code>を参照してください。
</p></div></body></html>