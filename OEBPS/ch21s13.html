<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Recursive Editing</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Recursive-Editing"/>Recursive Editing</h1></div></div></div><a id="idm59446480" class="indexterm"/><a id="idm59445712" class="indexterm"/><a id="idm59444944" class="indexterm"/><p>Emacsスタートアップ時に、自動的にEmacsコマンドループにエンターします。このトップレベルのコマンドループ呼び出しは決してexitせず、Emacs実行中は実行を続けます。Lispプログラムもコマンドループを呼び出せます。これは複数のコマンドループを活性化するため、これを<em class="firstterm">再帰編集(recursive
editing)</em>と呼んでいます。再帰編集レベルは、呼び出したコマンドが何であれそれをサスペンドして、そのコマンドを再開する前にユーザーが任意の編集を行うことを可能にする効果をもちます。
</p><p>再帰編集の間に利用可能なコマンドは、トップレベルの編集ループ内で利用できるコマンドと同じであり、キーマップ内で定義されます。数少ない特別なコマンドだけが再帰編集レベルをexitし、他のコマンドは再帰編集レベルが終了したときに再帰編集レベルからリターンします(exitするための特別なコマンドは常に利用できますが、再帰編集が行われていないときは何も行いません)。
</p><p>再帰コマンドループを含むすべてのコマンドループは、コマンドループから実行されたコマンド内のエラーによりそのループをexitしないように、汎用エラーハンドラーをセットアップします。
</p><a id="idm59442640" class="indexterm"/><p>ミニバッファー入力は、特殊な再帰編集です。これは、ミニバッファーとミニバッファーウィンドウの表示を有効にするなどの欠点をもちますが、それはあなたが思うより少ないでしょう。ミニバッファー内では特定のキーの振る舞いが異なりますが、これははミニバッファーのローカルマップによるものです。ウィンドウを切り替えれば、通常のEmacsコマンドを使用できます。
</p><a id="idm59437392" class="indexterm"/><a id="idm59436240" class="indexterm"/><a id="idm59435472" class="indexterm"/><a id="idm59434704" class="indexterm"/><p>再帰編集レベルを呼び出すには、関数を<code class="literal">recursive-edit</code>を呼び出します。この関数はコマンドループを含んでいます。さらに<code class="literal">exit</code>をthrowすることにより再帰編集レベルのexitを可能にする、タグ<code class="literal">exit</code>をともなう<code class="literal">catch</code>呼び出しも含んでいます(<a class="link" href="ch11s05.html#Catch-and-Throw" title="Explicit Nonlocal Exits: catch and throw">Catch
and
Throw</a>を参照)。<code class="literal">t</code>以外の値をthrowした場合、<code class="literal">recursive-edit</code>は通常それを呼び出した関数にリターンします。コマンド<strong class="userinput"><code>C-M-c</code></strong>(<code class="literal">exit-recursive-edit</code>)がこれを行います。値<code class="literal">t</code>をthrowすることにより<code class="literal">recursive-edit</code>がquitされるので、1レベル上位のコマンドループに制御がリターンされます。これは<em class="firstterm">abort</em>と呼ばれ、<strong class="userinput"><code>C-]</code></strong>(<code class="literal">abort-recursive-edit</code>)がこれを行います。
</p><p>ほとんどのアプリケーションはミニバッファー使用の一部として使用する場合を除き、再帰編集を使用するべきではありません。カレントバッファーのメジャーモードから、特殊なメジャーモードに一時的に変更する場合に、そのモードに戻るコマンドをもつ必要があるときは、通常は再帰編集のほうが便利です(Rmailの<strong class="userinput"><code>e</code></strong>コマンドはこのテクニックを使用している)。またはユーザーが新たなバッファーの特殊なモードで、異なるテキストを“再帰的”に編集・作成・選択できるようにしたい場合が該当します。このモードでは処理を完了させるコマンドを定義して、前のバッファーに戻ります(Rmailの<strong class="userinput"><code>m</code></strong>コマンドはこれを使用している)。
</p><p>再帰編集はデバッグに便利です。一種のブレークポイントとして関数定義内に<code class="literal">debug</code>を挿入して、関数がそこに達したときにその箇所を調べることができます。<code class="literal">debug</code>は再帰編集を呼び出しますが、デバッガのその他の機能も提供します。
</p><p><code class="literal">query-replace</code>内で<strong class="userinput"><code>C-r</code></strong>をタイプしたときや<strong class="userinput"><code>C-x
q</code></strong>(<code class="literal">kbd-macro-query</code>)を使用したときも、再帰編集レベルが使用されます。
</p><pre class="synopsis"><a id="idm59421008" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">recursive-edit</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm59418832" class="indexterm"/><p>この関数はエディターコマンドループを呼び出す。これはユーザーに編集を開始させるために、Emacsの初期化により自動的に呼び出されるLispプログラムから呼び出されたときは、再帰編集レベルにエンターする。
</p><p>カレントバッファーが選択されたウィンドウのバッファーと異なる場合、<code class="literal">recursive-edit</code>はカレントバッファーの保存とリストアを行う。それ以外では、バッファーを切り替えた場合には、<code class="literal">recursive-edit</code>がリターンした後その切り替えたバッファーがカレントになる。
</p><p>以下の例では、関数<code class="literal">simple-rec</code>が最初にポイントを1単語分進めてからメッセージをエコーエリアにプリントして再帰編集にエンターする。その後ユーザーは望む編集を行い、<strong class="userinput"><code>C-M-c</code></strong>をタイプすれば再帰編集をexitして、<code class="literal">simple-rec</code>の実行を継続できる。
</p><pre class="screen">(defun simple-rec ()
  (forward-word 1)
  (message "Recursive edit in progress")
  (recursive-edit)
  (forward-word 1))
     ⇒ simple-rec
(simple-rec)
     ⇒ nil
</pre></blockquote></div><pre class="synopsis"><a id="idm59397200" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">exit-recursive-edit</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は最内の再帰編集(ミニバッファー入力を含む)からexitする。関数の実質的な定義は<code class="literal">(throw 'exit nil)</code>である。
</p></blockquote></div><pre class="synopsis"><a id="idm59393744" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">abort-recursive-edit</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、再帰編集をexitした後に<code class="literal">quit</code>をシグナルすることにより、最内の再帰編集(ミニバッファー入力を含む)を要求したコマンドをabortする。関数の実質的な定義は<code class="literal">(throw
'exit t)</code>である。<a class="link" href="ch21s11.html" title="Quitting">Quitting</a>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm59389392" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">top-level</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はすべての再帰編集レベルをexitする。これはすべての計算を直接抜け出してメインのコマンドループに戻り、値をリターンしない。
</p></blockquote></div><pre class="synopsis"><a id="idm59386576" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">recursion-depth</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は再帰編集のカレントの深さをリターンする。アクティブな再帰編集が存在しない場合は、0をリターンする。
</p></blockquote></div></div></body></html>