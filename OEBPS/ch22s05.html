<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Inheritance and Keymaps</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Inheritance-and-Keymaps"/>Inheritance and Keymaps</h1></div></div></div><a id="idm59128272" class="indexterm"/><a id="idm59127504" class="indexterm"/><p>キーマップは、他のキーマップを継承することができ、この継承元のキーマップを<em class="firstterm">親キーマップ(parent
keymap)</em>と呼びます。そのようなキーマップは、以下のようなキーマップです:
</p><pre class="screen">(keymap <em class="replaceable"><code>elements</code></em>… . <em class="replaceable"><code>parent-keymap</code></em>)
</pre><p>これの効果は、このキーマップがキールックアップ時に<em class="replaceable"><code>parent-keymap</code></em>のすべてのバインディングを継承するが、それらにバインディングを追加したり、<em class="replaceable"><code>elements</code></em>でオーバーライドできるということです。
</p><p><code class="literal">define-key</code>や他のキーバインディング関数を使用して<em class="replaceable"><code>parent-keymap</code></em>内のバインディングを変更した場合、変更されたバインディングは<em class="replaceable"><code>elements</code></em>で作られたバインディングにshadowされない限り、継承されたキーマップ内で可視になります。逆は真ではありません。<code class="literal">define-key</code>を使用して継承されたキーマップ内のバインディングを変更した場合、これらの変更は<em class="replaceable"><code>elements</code></em>内に記録されますが、<em class="replaceable"><code>parent-keymap</code></em>に影響はありません。
</p><p>親キーマップからキーマップを構築するには、<code class="literal">set-keymap-parent</code>を使用するのが正しい方法です。親キーマップから直接キーマップを構築するコードがある場合は、かわりに<code class="literal">set-keymap-parent</code>を使用するようにプログラムを変更してください。
</p><pre class="synopsis"><a id="idm59118928" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">keymap-parent</code> <em class="replaceable"><code>keymap</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、<em class="replaceable"><code>keymap</code></em>の親キーマップをリターンする。<em class="replaceable"><code>keymap</code></em>に親キーマップがない場合、<code class="literal">keymap-parent</code>は<code class="literal">nil</code>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm59093456" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-keymap-parent</code> <em class="replaceable"><code>keymap</code></em> <em class="replaceable"><code>parent</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<em class="replaceable"><code>keymap</code></em>の親キーマップを<em class="replaceable"><code>parent</code></em>にセットして、<em class="replaceable"><code>parent</code></em>をリターンする。<em class="replaceable"><code>parent</code></em>が<code class="literal">nil</code>の場合、この関数は<em class="replaceable"><code>keymap</code></em>に親キーマップを与えない。
</p><p><em class="replaceable"><code>keymap</code></em>がサブマップ(プレフィクスキーにたいするバインディング)をもつ場合は、それらも新たな親キーマップを受け取り、それらのプレフィクスキーにたいして<em class="replaceable"><code>parent</code></em>が何を指定するかが反映される。
</p></blockquote></div><p>以下は<code class="literal">text-mode-map</code>から継承してキーマップを作成する方法を示す例です:
</p><pre class="screen">(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  map)
</pre><p>非sparseキーマップも親キーマップをもつことができますが、便利とは言えません。非sparseキーマップは、修飾ビットをもたないすべての数値文字コードにたいするバインディングとして、たとえそれが<code class="literal">nil</code>であっても常に何かを指定するので、これらの文字のバインディングが親キーマップから継承されることは決してないのです。
</p><a id="idm59084368" class="indexterm"/><p>複数のマップからキーマップを継承したいときがあるかもしれません。これにたいしては、関数<code class="literal">make-composed-keymap</code>が使用できます。
</p><pre class="synopsis"><a id="idm59082448" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">make-composed-keymap</code> <em class="replaceable"><code>maps</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>parent</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、既存のキーマップから構成される新たなキーマップをリターンする。また、オプションで親キーマップ<em class="replaceable"><code>parent</code></em>から継承する。<em class="replaceable"><code>maps</code></em>には単一のキーマップ、または複数のキーマップのリストを指定できる。リターンされた新たなマップ内でキーをルックアップするとき、Emacsは<em class="replaceable"><code>maps</code></em>内のキーマップを順に検索してから<em class="replaceable"><code>parent</code></em>内を検索する。この検索は最初のマッチで停止される。<em class="replaceable"><code>maps</code></em>のどれか1つのキーマップ内の<code class="literal">nil</code>バインディングは、<em class="replaceable"><code>parent</code></em>内の任意のバインディングをオーバーライドするが、<em class="replaceable"><code>maps</code></em>にないキーマップの非<code class="literal">nil</code>バインディングはオーバーライドしない。
</p></blockquote></div><p>For example, here is how Emacs sets the parent of
【FIXME】たとえば、以下は<code class="literal">button-buffer-map</code>と<code class="literal">special-mode-map</code>の両方を継承する<code class="literal">help-mode-map</code>のようなキーマップの親キーマップをEmacsがセットする方法です:
</p><pre class="screen">(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map
      (make-composed-keymap button-buffer-map special-mode-map))
    ... map) ... )
</pre></div></body></html>