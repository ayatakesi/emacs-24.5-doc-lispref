<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Changing Key Bindings</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Changing-Key-Bindings"/>Changing Key Bindings</h1></div></div></div><a id="idm62778064" class="indexterm"/><a id="idm62777296" class="indexterm"/><p>キーのリバインド(rebind:
再バインド、再束縛)は、キーマップ内でそのキーのバインディングエントリーを変更することにより行います。グローバルキーマップ内のバインディングを変更した場合、その変更は(たとえローカルバインディングによりグローバルバインディングをshadowしているバッファーでは直接影響しないとしても)すべてのバッファーに影響します。カレントバッファーのローカルマップを変更した場合は、通常は同じメジャーモードを使用するすべてのバッファーに影響します。関数<code class="literal">global-set-key</code>および<code class="literal">local-set-key</code>は、これらの操作のための使いやすいインターフェイスです(<a class="link" href="ch22s15.html" title="Commands for Binding Keys">Key
Binding
Commands</a>を参照)。より汎用的な関数<code class="literal">define-key</code>を使用することもできます。その場合は、変更するマップを明示的に指定しなければなりません。
</p><p>Lispプログラムでリバインドするキーシーケンスを選択するときは、さまざまなキーの使用についてのEmacsの慣習にしたがうようお願いします(<a class="link" href="apds02.html" title="Key Binding Conventions">Key
Binding Conventions</a>を参照)。
</p><a id="idm62773200" class="indexterm"/><a id="idm62739664" class="indexterm"/><p>リバインドするキーシーケンスの記述では、コントロール文字とメタ文字にたいして、特別なエスケープシーケンスを使用すると良いでしょう(<a class="link" href="ch03s03.html#String-Type" title="String Type">String
Type</a>を参照)。構文‘<code class="literal">\C-</code>’は後続する文字がコントロール文字でることを意味し、‘<code class="literal">\M-</code>’は後続する文字がメタ文字であることを意味します。したがって、文字列<code class="literal">"\M-x"</code>は1つの<strong class="userinput"><code>M-x</code></strong>、<code class="literal">"\C-f"</code>は1つの<strong class="userinput"><code>C-f</code></strong>、<code class="literal">"\M-\C-x"</code>および<code class="literal">"\C-\M-x"</code>は1つの<strong class="userinput"><code>C-M-x</code></strong>として読み取られます。ベクター内でも、このエスケープシーケンス、および文字列では使用できない他のエスケープシーケンスを使用できます。1例は‘<code class="literal">[?\C-\H-x
home]</code>’です。<a class="link" href="ch03s03.html#Character-Type" title="Character Type">Character Type</a>を参照してください。
</p><p>キー定義、およびルックアップ関数は、ベクターであるようなキーシーケンス内のイベント型にたいして、別の構文を受け入れます。修飾名に基本イベント(文字かファンクションキー名)を付加したものを含むリストを使用できます。たとえば、<code class="literal">(control
?a)</code>は<code class="literal">?\C-a</code>、<code class="literal">(hyper control
left)</code>は<code class="literal">C-H-left</code>と等価です。このようなリストの利点の1つは、コンパイル済みファイル内に修飾ビットの正確な数値コードが出現しないことです。
</p><p>以下の関数は、<em class="replaceable"><code>keymap</code></em>がキーマップでない場合、および<em class="replaceable"><code>key</code></em>がキーシーケンスを表す文字列やベクターでない場合はエラーをシグナルします。リストであるようなイベントにたいする略記として、イベント型(シンボル)を使用できます。<code class="literal">kbd</code>関数(<a class="link" href="ch22.html#Key-Sequences" title="Key Sequences">Key
Sequences</a>を参照)は、キーシーケンスを指定するための便利な方法です。
</p><pre class="synopsis"><a id="idm62727504" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">define-key</code> <em class="replaceable"><code>keymap</code></em> <em class="replaceable"><code>key</code></em> <em class="replaceable"><code>binding</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>keymap</code></em>内で<em class="replaceable"><code>key</code></em>にたいするバインディングをセットする(<em class="replaceable"><code>key</code></em>が長さ2以上のイベントの場合、その変更は実際は<em class="replaceable"><code>keymap</code></em>から辿られる他のキーマップで行なわれる)。引数<em class="replaceable"><code>binding</code></em>には任意のLispオブジェクトを指定できるが、意味があるのは特定のオブジェクトだけである(意味のある型のリストは、<a class="link" href="ch22s10.html" title="Key Lookup">Key
Lookup</a>を参照のこと)。<code class="literal">define-key</code>のリターン値は<em class="replaceable"><code>binding</code></em>である。
</p><p><em class="replaceable"><code>key</code></em>が<code class="literal">[t]</code>の場合、これは<em class="replaceable"><code>keymap</code></em>内でデフォルトバインディングをセットする。イベントが自身のバインディングをもたないとき、そのキーマップ内にデフォルトバインディングが存在するなら、Emacsコマンドループはそれを使用する。
</p><a id="idm62714832" class="indexterm"/><a id="idm62714064" class="indexterm"/><p><em class="replaceable"><code>key</code></em>のすべてのプレフィクスは、プレフィクスキー(キーマップにバインドされる)、または未定義でなけらばならず、それ以外はエラーがシグナルされる。<em class="replaceable"><code>key</code></em>のいくつかのプレフィクスが未定義の場合は、<code class="literal">define-key</code>はそれをプレフィクスキーとして定義するので、残りの<em class="replaceable"><code>key</code></em>は指定されたように定義できる。
</p><p>前に<em class="replaceable"><code>keymap</code></em>内で<em class="replaceable"><code>key</code></em>にたいするバインディングが存在しなかった場合は、新たなバインディングが<em class="replaceable"><code>keymap</code></em>の先頭に追加される。キーマップ内のバインディングの順序はキーボード入力にたいし影響を与えないが、メニューキーマップにたいしては問題となる(<a class="link" href="ch22s17.html" title="Menu Keymaps">Menu
Keymaps</a>を参照)。
</p></blockquote></div><p>以下は、sparseキーマップを作成して、その中にバインディングをいくつか作成する例である:
</p><pre class="screen">(setq map (make-sparse-keymap))
    ⇒ (keymap)
</pre><pre class="screen">(define-key map "\C-f" 'forward-char)
    ⇒ forward-char
</pre><pre class="screen">map
    ⇒ (keymap (6 . forward-char))
</pre><pre class="screen">
</pre><pre class="screen">;; <strong class="userinput"><code>C-x</code></strong>にたいしsparseサブマップを作成し、
;; その中で<strong class="userinput"><code>f</code></strong>をバインドする
(define-key map (kbd "C-x f") 'forward-word)
    ⇒ forward-word
</pre><pre class="screen">map
⇒ (keymap
    (24 keymap                ; <strong class="userinput"><code>C-x</code></strong>
        (102 . forward-word)) ;      <strong class="userinput"><code>f</code></strong>
    (6 . forward-char))       ; <strong class="userinput"><code>C-f</code></strong>
</pre><pre class="screen">
</pre><pre class="screen">;; <strong class="userinput"><code>C-p</code></strong>を<code class="literal">ctl-x-map</code>にバインド
(define-key map (kbd "C-p") ctl-x-map)
;; <code class="literal">ctl-x-map</code>
⇒ [nil … find-file … backward-kill-sentence]
</pre><pre class="screen">
</pre><pre class="screen">;; <code class="literal">ctl-x-map</code>内で<strong class="userinput"><code>C-f</code></strong>を<code class="literal">foo</code>にバインド
(define-key map (kbd "C-p C-f") 'foo)
⇒ 'foo
</pre><pre class="screen">map
⇒ (keymap     ; <code class="literal">ctl-x-map</code>内の<code class="literal">foo</code>に注目
    (16 keymap [nil … foo … backward-kill-sentence])
    (24 keymap
        (102 . forward-word))
    (6 . forward-char))
</pre><p><strong class="userinput"><code>C-p
C-f</code></strong>にたいする新たなバインディングの格納は、実際には<code class="literal">ctl-x-map</code>内のエントリーを変更することにより機能し、これはデフォルトグローバルマップ内の<strong class="userinput"><code>C-p
C-f</code></strong>と<strong class="userinput"><code>C-x C-f</code></strong>の両方のバインディングを変更する効果をもつことに注意されたい。
</p><p>関数<code class="literal">substitute-key-definition</code>は、キーマップから特定のバインディングをもつキーをスキャンして、それらを異なるバインディングにリバインドする。より明快で、多くの場合は同じ結果を生成できる他の機能として、あるコマンドから別のコマンドへのリマップがあります(<a class="link" href="ch22s13.html" title="Remapping Commands">Remapping
Commands</a>を参照)。
</p><pre class="synopsis"><a id="idm62689360" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">substitute-key-definition</code> <em class="replaceable"><code>olddef</code></em> <em class="replaceable"><code>newdef</code></em> <em class="replaceable"><code>keymap</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>oldmap</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm62685264" class="indexterm"/><p>この関数は、<em class="replaceable"><code>keymap</code></em>内で<em class="replaceable"><code>olddef</code></em>にバインドされるすべてのキーについて、<em class="replaceable"><code>olddef</code></em>を<em class="replaceable"><code>newdef</code></em>に置き換える。別の言い方をすると、<em class="replaceable"><code>olddef</code></em>が出現する箇所すべてを<em class="replaceable"><code>newdef</code></em>に置き換える。この関数は<code class="literal">nil</code>をリターンする。
</p><p>たとえば、以下をEmacsの標準バインディングで行うと、<strong class="userinput"><code>C-x C-f</code></strong>を再定義する:
</p><pre class="screen">(substitute-key-definition
 'find-file 'find-file-read-only (current-global-map))
</pre><p><em class="replaceable"><code>oldmap</code></em>が非<code class="literal">nil</code>の場合は、どのキーをリバインドするかを<em class="replaceable"><code>oldmap</code></em>内のバインディングが決定するよう、<code class="literal">substitute-key-definition</code>の動作を変更する。リバインディングは依然として<em class="replaceable"><code>oldmap</code></em>ではなく、<em class="replaceable"><code>keymap</code></em>で発生する。したがって、他のマップ内のバインディングの制御下で、マップを変更することができる。たとえば、
</p><pre class="screen">(substitute-key-definition
  'delete-backward-char 'my-funny-delete
  my-map global-map)
</pre><p>これは、標準的な削除コマンドにグローバルにバインドされたキーにたいして、<code class="literal">my-map</code>内の特別な削除コマンドを設定する。
</p><p>以下は、キーマップの置き換え(substitution)の前後を示す例である:
</p><pre class="screen">(setq map '(keymap
            (?1 . olddef-1)
            (?2 . olddef-2)
            (?3 . olddef-1)))
⇒ (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
</pre><pre class="screen">
</pre><pre class="screen">(substitute-key-definition 'olddef-1 'newdef map)
⇒ nil
</pre><pre class="screen">map
⇒ (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
</pre></blockquote></div><pre class="synopsis"><a id="idm62673104" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">suppress-keymap</code> <em class="replaceable"><code>keymap</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>nodigits</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm62669776" class="indexterm"/><p>この関数は、<code class="literal">self-insert-command</code>をコマンド<code class="literal">undefined</code>にリマップ(<a class="link" href="ch22s13.html" title="Remapping Commands">Remapping
Commands</a>を参照)することにより、fullキーマップのコンテンツを変更する。これは、すべてのプリント文字を未定義にする効果をもすので、通常のテキスト挿入は不可能になる。<code class="literal">suppress-keymap</code>は<code class="literal">nil</code>をリターンする。
</p><p><em class="replaceable"><code>nodigits</code></em>が<code class="literal">nil</code>の場合、<code class="literal">suppress-keymap</code>は数字が<code class="literal">digit-argument</code>、<strong class="userinput"><code>-</code></strong>が<code class="literal">negative-argument</code>を実行するように定義する。それ以外は、残りのプリント文字と同じように、それらの文字も未定義にする。
</p><a id="idm62662480" class="indexterm"/><a id="idm62661712" class="indexterm"/><p><code class="literal">suppress-keymap</code>関数は、<code class="literal">yank</code>や<code class="literal">quoted-insert</code>のようなコマンドを抑制(suppress)しないので、バッファーの変更は可能である。バッファーの変更を防ぐには、バッファーを読み取り専用(read-only)にする(<a class="link" href="ch27s07.html" title="Read-Only Buffers">Read
Only Buffers</a>を参照)。
</p><p>この関数は<em class="replaceable"><code>keymap</code></em>を変更するので、通常は新たに作成したキーマップにたいして使用するだろう。するだろう。他の目的のために使用されている既存のキーマップに操作を行うと、恐らくトラブルの原因となる。たとえば、<code class="literal">global-map</code>の抑制は、Emacsの使用をほとんど不可能に
</p><p>この関数は、テキストの挿入が望ましくないメジャーモードの、ローカルキーマップ初期科に使用され得る。しかし、そのようなモードは通常は<code class="literal">special-mode</code>(<a class="link" href="ch23s02.html#Basic-Major-Modes" title="Basic Major Modes">Basic
Major
Modes</a>を参照)から継承される。この場合、そのモードのキーマップは既に抑制済みの<code class="literal">special-mode-map</code>から自動的に受け継がれる。以下に<code class="literal">special-mode-map</code>が定義される方法を示す:
</p><pre class="screen">(defvar special-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (define-key map "q" 'quit-window)
    …
    map))
</pre></blockquote></div></div></body></html>