<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Major Modes</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Major-Modes"/>Major Modes</h1></div></div></div><a id="idm61857616" class="indexterm"/><a id="idm61856848" class="indexterm"/><p>メジャーモードは特定の種類のテキスト編集にEmacsを特化します。すべてのバッファーは1度に1つのメジャーモードをもちます。すべてのメジャーモードは、<em class="firstterm">メジャーモードコマンド(major
mode
command)</em>に関連付けられ、そのコマンド名は‘<code class="literal">-mode</code>’で終わるべきです。このコマンドは、ローカルキーマップのようなさまざまなバッファーローカル変数をセットすることにより、カレントバッファーないでそのモードに切り替える配慮をします。<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照してください。
</p><p><em class="firstterm">Fundamentalモード</em>と呼ばれるはもっとも特化されていないメジャーモードであり、モード特有な定義や変数セッティングをもちません。
</p><pre class="synopsis"><a id="idm61853392" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">fundamental-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、Fundamentalモードにたいするメジャーモードコマンドである。他のモードコマンドと異なり、このモードはカスタマイズしてはならないことになっているので、モードフックは何も実行<span class="emphasis"><em>されない</em></span>(<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照)。
</p></blockquote></div><p>メジャーモードを記述するもっとも簡単な方法は、マクロ<code class="literal">define-derived-mode</code>を使用する方法です。これは、既存のメジャーモードを変形して、新たなモードをセットアップします。<a class="link" href="ch23s02.html#Derived-Modes" title="Defining Derived Modes">Derived
Modes</a>を参照してください。<code class="literal">define-derived-mode</code>は多くのコーディング規約を自動的に強要するので、たとえ新たなモードが他のモードから明示的に派生されない場合でも、わたしたちは<code class="literal">define-derived-mode</code>の使用を推奨します。派生元とするための一般的なモードについては、<a class="link" href="ch23s02.html#Basic-Major-Modes" title="Basic Major Modes">Basic
Major Modes</a>を参照してください。
</p><p>標準的なGNU
EmacsのLispディレクトリーツリーには、いくつかのメジャーモードが<code class="filename">text-mode.el</code>、<code class="filename">texinfo.el</code>、<code class="filename">lisp-mode.el</code>、<code class="filename">rmail.el</code>のようなファイルとして含まれています。モードの記述方法を確認するために、これらのライブラリーを学ぶことができます。
</p><pre class="synopsis"><a id="idm61844304" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">major-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数のバッファーローカル値は、カレントのメジャーモードにたいするシンボルを保持する。この変数のデフォルト値は、新たなバッファーにたいするデフォルトのメジャーモードを保持する。標準的なデフォルト値は、<code class="literal">fundamental-mode</code>である。
</p><p>デフォルト値が<code class="literal">nil</code>の場合、<strong class="userinput"><code>C-x
b</code></strong>(<code class="literal">switch-to-buffer</code>)のようなコマンドを通じてEmacsが新たなバッファーを作成したとき、新たなバッファーは以前カレントだったバッファーのメジャーモードになる。例外として、以前のバッファーのメジャーモードのシンボルプロパティ<code class="literal">mode-class</code>が値<code class="literal">special</code>をもつ場合、新たなバッファーはFundamentalモードになる(<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照)。
</p></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Major-Mode-Conventions"/>Major Mode Conventions</h2></div></div></div><a id="idm61837008" class="indexterm"/><a id="idm61836240" class="indexterm"/><p>メジャーモードにたいするすべてのコードはさまざまなコーディング規約にしたがうべきであり、それらの規約にはローカルキーマップおよび構文テーブルの初期化、関数名や変数名、フックにたいする規約が含まれます。
</p><p><code class="literal">define-derived-mode</code>マクロを使用した場合は、これらの規約を自動的に配慮します。<a class="link" href="ch23s02.html#Derived-Modes" title="Defining Derived Modes">Derived
Modes</a>を参照してください。Fundamentalモードは、Emacsのデフォルト状態を表すモードなにで、これらの規約が当てはまらないことに注意してください。
</p><p>以下の規約リストは、ほんの一部です。一般的に、すべてのメジャーモードは、Emacs全体が首尾一貫するよう、他のEmacsメジャーモードとの一貫性を目指すべきです。ここで、この問題を洗い出すすべての想定される要点をリストするのは不可能です。Emacs開発者が、自身の開発するメジャーモードが通常の規約を逸脱する領域を示す場合は、互換性を保つようにしてください。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>名前が‘<code class="literal">-mode</code>’で終わるようにメジャーモードコマンドを定義する。引数なしで呼び出されたとき、このコマンドはキーマップ、構文テーブル、既存バッファーのバッファーローカル変数をセットアップして、カレントバッファーを新たなモードに切り替えるべきである。そのバッファーのコンテンツを変更するべきではない。
</p></li><li class="listitem"><p>そのモードで利用できる特別なコマンドを説明するドキュメント文字列を記述する。<a class="link" href="ch23s02.html#Mode-Help" title="Getting Help about a Major Mode">Mode Help</a>を参照のこと。
</p><p>そのユーザー自身のキーバインディングに自動的に適合してヘルプが表示されるように、ドキュメント文字列に特別なドキュメントサブストリング‘<code class="literal">\[<em class="replaceable"><code>command</code></em>]</code>’、‘<code class="literal">\{<em class="replaceable"><code>keymap</code></em>}</code>’、‘<code class="literal">\&lt;<em class="replaceable"><code>keymap</code></em>&gt;</code>’を含めるとよいかもしれない。<a class="link" href="ch24s03.html" title="Substituting Key Bindings in Documentation">Keys
in Documentation</a>を参照のこと。
</p></li><li class="listitem"><p>メジャーモードコマンドは、<code class="literal">kill-all-local-variables</code>を呼び出すことにより開始するべきである。これは、ノーマルフック<code class="literal">change-major-mode-hook</code>を実行してから、前のメジャーモードで効力のあったバッファーローカル変数を解放する。<a class="link" href="ch12s10.html#Creating-Buffer_002dLocal" title="Creating and Deleting Buffer-Local Bindings">Creating
Buffer-Local</a>を参照のこと。
</p></li><li class="listitem"><p>メジャーモードコマンドは、変数<code class="literal">major-mode</code>にメジャーモードコマンドのシンボルをセットするべきである。これは、<code class="literal">describe-mode</code>がプリントするドキュメントを探す手掛かりとなる。
</p></li><li class="listitem"><p>メジャーモードコマンドは、変数<code class="literal">mode-name</code>にそのモードの“愛称(pretty
name)”をセットするべきである(これは通常は文字列だが、他の利用可能な形式は、<a class="link" href="ch23s04.html#Mode-Line-Data" title="The Data Structure of the Mode Line">Mode Line
Data</a>を参照のこと)。このモード名は、モードラインに表示される。
</p></li><li class="listitem"><a id="idm61818064" class="indexterm"/><p>すべてのグローバル名は同じネームスペースにあるので、モードの一部であるようなすべてのグローバルな変数、定数、関数は、メジャーモード名(メジャーモード名が長いようなら短縮名)で始まる名前をもつべきである。<a class="link" href="apd.html#Coding-Conventions" title="Emacs Lisp Coding Conventions">Coding
Conventions</a>を参照のこと。
</p></li><li class="listitem"><p>プログラム言語のような、ある種の構造型テキストを編集するためのメジャーモードでは、その構造に応じたテキストのインデントはおそらく有用であろう。したがって、そのようなモードは<code class="literal">indent-line-function</code>に適切な関数をセットするとともに、インデント用のその他の変数をカスタマイズすべきだろう。
</p></li><li class="listitem"><a id="idm61815248" class="indexterm"/><p>メジャーモードは通常、そのモードにあるすべてのバッファーのローカルキーマップとして使用される、自モード身のキーマップをもつべきである。メジャーモードコマンドは、そのローカルマップをインストールするために、<code class="literal">use-local-map</code>を呼び出すべきである。詳細は、<a class="link" href="ch22s07.html" title="Active Keymaps">Active
Keymaps</a>を参照のこと。
</p><p>このキーマップは、<code class="literal"><em class="replaceable"><code>modename</code></em>-mode-map</code>という名前のグローバル変数に永続的に格納されるべきである。通常、そのモードを定義するライブラリーは、この変数をセットする。
</p><p>モード用のキーマップ変数をセットアップするコードの記述する方法に関するアドバイスは、<a class="link" href="ch12s06.html" title="Tips for Defining Variables Robustly">Tips for Defining</a>を参照のこと。
</p></li><li class="listitem"><p>メジャーモードのキーマップ内でバインドされるキーシーケンスは、通常は<strong class="userinput"><code>C-c</code></strong>で始まり、その後にコントロール文字、数字、<strong class="userinput"><code>{</code></strong>、<strong class="userinput"><code>}</code></strong>、<strong class="userinput"><code>&lt;</code></strong>、<strong class="userinput"><code>&gt;</code></strong>、<strong class="userinput"><code>:</code></strong>、<strong class="userinput"><code>;</code></strong>が続くべきである。その他の記号文字(punctuation
characters)はマイナーモードに、通常のアルファベット文字はユーザーのために予約されている。
</p><p>メジャーモードは<strong class="userinput"><code>M-n</code></strong>、<strong class="userinput"><code>M-p</code></strong>、<strong class="userinput"><code>M-s</code></strong>などのキーもリバインドできる。<strong class="userinput"><code>M-n</code></strong>と<strong class="userinput"><code>M-p</code></strong>にたいするバインディングは、通常は
“前方あるいは後方への移動”を意味するような類のものであるべきだが、これは必ずしもカーソル移動を意味する必要はない。
</p><p>そのモードにより適した方法でテキストに“同じ処理”を行うコマンドを提供する場合に、メジャーモードが標準的なキーシーケンスをリバインドするのは正当性がある。たとえば、プログラム言語を編集するためのメジャーモードは、その言語にとって“関数の先頭に移動する”がより良く機能する方法で、<strong class="userinput"><code>C-M-a</code></strong>を再定義するかもしれない。
</p><p>ある標準的なキーシーケンスの標準的な意味が、そのモードではほとんど役に立たないような場合にも、メジャーモードが標準的なキーシーケンスをリバインドする正当性がある。たとえば、ミニバッファーモードは、<strong class="userinput"><code>M-r</code></strong>の標準的な意味はミニバッファーではほとんど使用されないので、このキーシーケンスをリバインドする。テキストの自己挿入を許さないDiredやRmailのようなメジャーモードは、アルファベット文字や、その他のプリント文字を特別なコマンドに再定義する正当性がある。
</p></li><li class="listitem"><p>テキストを編集するメジャーモードは、改行の挿入以外の何かに<span class="keycap"><strong>RET</strong></span>を定義すべきではない。しかし、ユーザーが直接テキストを編集しない、DiredやInfoのような特別なモードにたいしては、完全に異なることを行うように<span class="keycap"><strong>RET</strong></span>を再定義しても構わない。
</p></li><li class="listitem"><p>メジャーモードは、たとえばAuto-Fillモードを有効にするか等の、主にユーザーの好みに関するオプションを変更すべきではない。それらのオプションは、ユーザーに選択に任せること。ただし、<span class="emphasis"><em>もし</em></span>ユーザーがAuto-Fillモードを使用すると決定した場合には、それが便利に機能するように、他の変数をカスタマイズすべきである。
</p></li><li class="listitem"><a id="idm61799504" class="indexterm"/><p>モードは自身の構文テーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身の構文テーブルをもつ場合は、<code class="literal"><em class="replaceable"><code>modename</code></em>-mode-syntax-table</code>という名前の変数にそれを格納すべきである。<a class="link" href="ch35.html" title="Chapter 34. Syntax Tables">Syntax
Tables</a>を参照のこと。
</p></li><li class="listitem"><p>コメントにたいして構文をもつ言語を扱うモードは、コメント構文を定義する変数をセットすべきである。section “Options Controlling Comments” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p></li><li class="listitem"><a id="idm61796048" class="indexterm"/><p>モードは自身のabbrevテーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身のabbrevテーブルをもつ場合は、<code class="literal"><em class="replaceable"><code>modename</code></em>-mode-abbrev-table</code>という名前の変数にそれを格納すべきである。メジャーモードコマンドが自身で何らかのabbrevを定義する場合は、<code class="literal">define-abbrev</code>の<em class="replaceable"><code>system-flag</code></em>引数に<code class="literal">t</code>を渡すべきである。<a class="link" href="ch36s02.html" title="Defining Abbrevs">Defining
Abbrevs</a>を参照のこと。
</p></li><li class="listitem"><p>モードは、変数<code class="literal">font-lock-defaults</code>にバッファーローカルな値をセットすることにより、Font
Lockモードにたいしてハイライトする方法を指定すべきである(<a class="link" href="ch23s06.html" title="Font Lock Mode">Font Lock Mode</a>を参照)。
</p></li><li class="listitem"><p>モードが定義するすべてのフェイスは、もし可能なら既存のEmacsフェイスを継承すべきである。<a class="link" href="ch38s12.html#Basic-Faces" title="Basic Faces">Basic Faces</a>と<a class="link" href="ch23s06.html#Faces-for-Font-Lock" title="Faces for Font Lock">Faces
for Font Lock</a>を参照のこと。
</p></li><li class="listitem"><p>モードは変数<code class="literal">imenu-generic-expression</code>、変数<code class="literal">imenu-prev-index-position-function</code>
and
<code class="literal">imenu-extract-index-name-function</code>、または変数<code class="literal">imenu-create-index-function</code>にバッファーローカルな値をセットすることにより、Imenuがバッファー内の定義、またはセクションを探す方法を指定すべきである(<a class="link" href="ch23s05.html" title="Imenu">Imenu</a>を参照)。
</p></li><li class="listitem"><p>モードは、<code class="literal">eldoc-documentation-function</code>にローカル値を指定して、ElDocモードがそのモードを処理する方法を指定できる。
</p></li><li class="listitem"><p>モードは、スペシャルフック<code class="literal">completion-at-point-functions</code>に1つ以上のバッファーローカルエントリーを追加することにより、さまざまなキーワードの補完方法を指定できる。<a class="link" href="ch20s06.html#Completion-in-Buffers" title="Completion in Ordinary Buffers">Completion
in Buffers</a>を参照のこと。
</p></li><li class="listitem"><a id="idm61783376" class="indexterm"/><p>Emacsのカスタマイズ変数にたいしてバッファーローカルなバインディングを作成するには、<code class="literal">make-variable-buffer-local</code>ではなく、メジャーモードコマンド内で<code class="literal">make-local-variable</code>を使用すること。関数、<code class="literal">make-variable-buffer-local</code>は、それ以降にカスタマイズ変数をセットするすべてのバッファーにたいしてその変数をローカルにし、そのモードを使用しないバッファーにたいしても影響があるだろう。そのようなグローバルな効果は、モードにとって好ましくない。<a class="link" href="ch12s10.html" title="Buffer-Local Variables">Buffer-Local
Variables</a>を参照のこと。
</p><p>稀な例外として、Lispパッケージ内で<code class="literal">make-variable-buffer-local</code>を使用する唯一の正当な方法は、そのパッケージ内でのみ使用される変数にたいして使用をする場合である。他のパッケージにより使用される変数にたいしてこの関数を使用すると、干渉が起こるだろう。
</p></li><li class="listitem"><a id="idm61766864" class="indexterm"/><a id="idm61766096" class="indexterm"/><p>すべてのメジャーモードは、<code class="literal"><em class="replaceable"><code>modename</code></em>-mode-hook</code>という名前のノーマルな<em class="firstterm">モードフック(mode
hook)</em>をもつべきである。メジャーモードコマンドが一番最後に行うべきことは、<code class="literal">run-mode-hooks</code>の呼び出しである。これは、ノーマルフック<code class="literal">change-major-mode-after-body-hook</code>、モードフック、その後に<code class="literal">after-change-major-mode-hook</code>を実行する。<a class="link" href="ch23s02.html#Mode-Hooks" title="Mode Hooks">Mode
Hooks</a>を参照のこと。
</p></li><li class="listitem"><p>メジャーモードコマンドは、<em class="firstterm">親モード(parent
mode)</em>と呼ばれる他のいくつかのメジャーモードを呼び出すことにより開始されるかもしれず、それらのセッティングのいくつかを変更するかもしれない。これを行うモードは、<em class="firstterm">派生モード(derived
mode)</em>と呼ばれる。派生モードを定義する推奨方法は、<code class="literal">define-derived-mode</code>マクロの使用であるが、これは必須ではない。そのようなモードは、<code class="literal">delay-mode-hooks</code>フォーム内で親のモードコマンドを呼び出すべきである(<code class="literal">define-derived-mode</code>は自動的にこれを行う)。<a class="link" href="ch23s02.html#Derived-Modes" title="Defining Derived Modes">Derived
Modes</a>、および<a class="link" href="ch23s02.html#Mode-Hooks" title="Mode Hooks">Mode Hooks</a>を参照のこと。
</p></li><li class="listitem"><p>ユーザーが、そのモードのバッファーから他のモードのバッファーに切り替える際に特別な何かを行う必要がある場合、モードは<code class="literal">change-major-mode-hook</code>にたいしてバッファーローカル値をセットアップできる(<a class="link" href="ch12s10.html#Creating-Buffer_002dLocal" title="Creating and Deleting Buffer-Local Bindings">Creating
Buffer-Local</a>を参照)。
</p></li><li class="listitem"><p>そのモードが、(ユーザーがキーボードでタイプしたテキストや、外部ファイルのテキストではなく)モード自身が生成する特別に用意されたテキストにたいしてのみ適す場合、メジャーモードコマンドのシンボルは、以下のように<code class="literal">mode-class</code>という名前のプロパティに値<code class="literal">special</code>をputすべきである:
</p><a id="idm61754832" class="indexterm"/><a id="idm61754064" class="indexterm"/><pre class="screen">(put 'funny-mode 'mode-class 'special)
</pre><p>これはEmacsにたいして、カレントバッファーがFunnyモードのときに新たなバッファーを作成したとき、たとえ<code class="literal">major-mode</code>のデフォルト値が<code class="literal">nil</code>であっても、そのバッファーをFunnyモードにしないよう指示する。デフォルトでは、<code class="literal">major-mode</code>にたいする値<code class="literal">nil</code>は、新たなバッファー作成時にカレントバッファーのメジャーモードを使用することを意味するが(<a class="link" href="ch23s02.html#Auto-Major-Mode" title="How Emacs Chooses a Major Mode">Auto
Major
Mode</a>を参照)、<code class="literal">special</code>なモードにたいしてはかわりにFundamentalモードが使用される。Dired、Rmail、Buffer
Listのようなモードは、この機能を使用する。
</p><p>関数<code class="literal">view-buffer</code>は、mode-classがspecialであるようなバッファーではViewモードを有効にしない。そのようなモードは、通常は自身でViewに相当するバインディングを提供するからである。
</p><p><code class="literal">define-derived-mode</code>マクロは、親モードがspecialの場合は、自動的に派生モードをspecialにマークする。親モードでspecialモードが有用なら、それを継承したモードでもであろう。<a class="link" href="ch23s02.html#Basic-Major-Modes" title="Basic Major Modes">Basic
Major Modes</a>を参照のこと。
</p></li><li class="listitem"><p>新たなモードを、識別可能な特定のファイルにたいするデフォルトとしたい場合は、そのようなファイル名にたいしてそのモードを選択するために、<code class="literal">auto-mode-alist</code>に要素を追加する。autoload用にモードコマンドを定義する場合は、<code class="literal">autoload</code>を呼び出すのと同じファイル内にその要素を追加すべきである。モードコマンドにたいしてautoload
cookieを使用する場合は、その要素を追加するフォームにたいしてもautoload cookieを使用できる(<a class="link" href="ch16s05.html#autoload-cookie">autoload
cookie</a>を参照)。モードコマンドをautoloadしない場合は、モード定義を含むファイル内で要素を追加すれば十分である。
</p></li><li class="listitem"><a id="idm61744464" class="indexterm"/><p>悪影響を与えることなく1回以上評価されるように、モード定義はファイル内のトップレベルのフォームとして記述すべきである。たとえば、すでに値をもつ変数が再初期化されないように、モードに関連した変数をセットするときは、<code class="literal">defvar</code>か<code class="literal">defcustom</code>を使用する(<a class="link" href="ch12s05.html" title="Defining Global Variables">Defining
Variables</a>を参照)。
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Auto-Major-Mode"/>How Emacs Chooses a Major Mode</h2></div></div></div><a id="idm61736528" class="indexterm"/><p>ファイルをvisitするとき、ファイル名やファイル自体の内容などの情報を元に、Emacsはそのバッファーにたいするメジャーモードを選択します。また、ファイルのテキスト内で指定されたローカル変数も処理します。
</p><pre class="synopsis"><a id="idm61735120" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">normal-mode</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>find-file</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファーにたいして適切なメジャーモードと、バッファーローカル変数のバインディングを設定する。これはまず<code class="literal">set-auto-mode</code>(以下参照)を呼び出し、その後に<code class="literal">hack-local-variables</code>を実行してパース処理を行って、そのファイルのローカル変数(<a class="link" href="ch12s11.html" title="File Local Variables">File
Local Variables</a>を参照)を適切にバインド、または評価する。
</p><p><code class="literal">normal-mode</code>の<em class="replaceable"><code>find-file</code></em>引数が非<code class="literal">nil</code>の場合、<code class="literal">normal-mode</code>は<code class="literal">find-file</code>関数が自身を呼び出したとみなす。この場合、<code class="literal">normal-mode</code>はそのファイル内の‘<code class="literal">-*-</code>’行の、またはファイルの最後にあるローカル変数を処理するかもしれない。これを行うかどうかは、変数<code class="literal">enable-local-variables</code>が制御する。ファイルのローカル変数セクションの構文は、section “Local Variables in Files” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p><p>インタラクティブに<code class="literal">normal-mode</code>を実行した場合、引数<em class="replaceable"><code>find-file</code></em>は通常<code class="literal">nil</code>である。この場合、<code class="literal">normal-mode</code>は無条件に任意のファイルローカル変数を処理する。
</p><p>この関数は、メジャーモードを選択するために<code class="literal">set-auto-mode</code>を呼び出す。この関数がモードを特定しない場合、そのバッファーの<code class="literal">major-mode</code>(以下参照)のデフォルト値により決定されるメジャーモードに留まる。
</p><a id="idm61721936" class="indexterm"/><p><code class="literal">normal-mode</code>は、メジャーモードコマンド呼び出しの周囲に<code class="literal">condition-case</code>を使用するので、エラーはcatchされて、‘<code class="literal">File
mode specification error</code>’とともに、元のエラーメッセージがその後に報告される。
</p></blockquote></div><pre class="synopsis"><a id="idm61718992" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-auto-mode</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>keep-mode-if-same</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm61716048" class="indexterm"/><p>この関数は、カレントバッファーにたいして適切なメジャーモードを選択する。この選択は、関数自身の(優先順位による)決定にもとづく。優先順位は、‘<code class="literal">-*-</code>’行、ファイル終端近傍の任意の‘<code class="literal">mode:</code>’ローカル変数、‘<code class="literal">#!</code>’行(<code class="literal">interpreter-mode-alist</code>を使用)、バッファーの先頭のテキスト(<code class="literal">magic-mode-alist</code>を使用)、最後がvisitされるファイル名(<code class="literal">auto-mode-alist</code>を使用)の順である。section “How Major Modes are Chosen” in <em class="citetitle">The GNU Emacs
Manual</em>を参照のこと。<code class="literal">enable-local-variables</code>が<code class="literal">nil</code>の場合、<code class="literal">set-auto-mode</code>は‘<code class="literal">-*-</code>’行、およびファイル終端近傍にたいして、modeタグのチェックを何もしない。
</p><a id="idm61708624" class="indexterm"/><p>モード特定のためにファイル内容をスキャンするのがふさわしくないファイルタイプがいくつかある。たとえば、tarアーカイブファイルの終わり付近に、特定のファイルにたいしてモードを指定するローカル変数セクションをもつアーカイブメンバーファイルが、たまたま含まれているかもしれない。これは、そのファイルを含むtarファイルに適用されるべきではないだろう。同様に、tiffイメージファイルが、‘<code class="literal">-*-</code>’パターンにマッチするように見える行を、最初の行に偶然含むかもしれない。これらの理由により、これらのファイル拡張子はどちらも<code class="literal">inhibit-local-variables-regexps</code>リストのメンバーになっている。Emacsが、(モード指定に限らず)ファイルから任意の種類のローカル変数を検索することを防ぐには、このリストにパターンを追加する。
</p><p><em class="replaceable"><code>keep-mode-if-same</code></em>が非<code class="literal">nil</code>の場合は、すでにそのバッファーが適切なメジャーモードをもつとき、この関数はモードコマンドを呼び出さない。たとえば<code class="literal">set-visited-file-name</code>は、ユーザーがセットしたかもしれないバッファーローカル変数をkillするのを防ぐために、これを<code class="literal">t</code>にセットする。
</p></blockquote></div><pre class="synopsis"><a id="idm61703760" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-buffer-major-mode</code> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>buffer</code></em>のメジャーモードを、<code class="literal">major-mode</code>のデフォルト値にセットする。<code class="literal">major-mode</code>が<code class="literal">nil</code>の場合は、(それが適切なら)カレントバッファーのメジャーモードを使用する。例外として、<em class="replaceable"><code>buffer</code></em>の名前が<code class="filename">*scratch*</code>の場合は、モードを<code class="literal">initial-major-mode</code>にセットする。
</p><p>バッファーを作成する低レベルのプリミティブはこの関数を使用しないが、<code class="literal">switch-to-buffer</code>や<code class="literal">find-file-noselect</code>のような中位レベルのコマンドは、バッファーを作成するときは、常にこの関数を使用する。
</p></blockquote></div><pre class="synopsis"><a id="idm61695568" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">initial-major-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm61693520" class="indexterm"/><p>この変数の値は、<code class="filename">*scratch*</code>バッファーの初期のメジャーモードを決定する。値は、メジャーモードコマンドであるようなシンボルであること。デフォルト値は<code class="literal">lisp-interaction-mode</code>である。
</p></blockquote></div><pre class="synopsis"><a id="idm61678544" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">interpreter-mode-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、‘<code class="literal">#!</code>’行内のコマンドインタープリターを指定するスクリプトにたいして使用するメジャーモードを指定する。変数の値は、<code class="literal">(<em class="replaceable"><code>regexp</code></em>
.
<em class="replaceable"><code>mode</code></em>)</code>の形式の要素をもつalistである。これは、そのファイルが<code class="literal">\\`<em class="replaceable"><code>regexp</code></em>\\'</code>にマッチするインタープリターを指定する場合は、<em class="replaceable"><code>mode</code></em>を使用することを意味する。たとえば、デフォルト要素の1つは<code class="literal">("python[0-9.]*"
. python-mode)</code>である。
</p></blockquote></div><pre class="synopsis"><a id="idm61672272" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">magic-mode-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、<code class="literal">(<em class="replaceable"><code>regexp</code></em>
<em class="replaceable"><code>function</code></em>)</code>という形式の要素をもつalistである。ここで、<em class="replaceable"><code>regexp</code></em>は正規表現、<em class="replaceable"><code>function</code></em>は関数、または<code class="literal">nil</code>である。ファイルをvisitした後に、バッファーの先頭のテキストが<em class="replaceable"><code>regexp</code></em>にマッチした場合、<em class="replaceable"><code>function</code></em>が非<code class="literal">nil</code>なら<code class="literal">set-auto-mode</code>は<em class="replaceable"><code>function</code></em>を呼び出す。<em class="replaceable"><code>function</code></em>が<code class="literal">nil</code>の場合は、<code class="literal">auto-mode-alist</code>がモードを決定する。
</p></blockquote></div><pre class="synopsis"><a id="idm61663440" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">magic-fallback-mode-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">magic-mode-alist</code>と同様に機能するが、そのファイルにたいして<code class="literal">auto-mode-alist</code>がモードを指定しない場合だけ処理される点が異なる。
</p></blockquote></div><pre class="synopsis"><a id="idm61659728" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">auto-mode-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、ファイル名パターン(正規表現)と対応するメジャーモードコマンドの連想配列を含む。通常、ファイル名パターンは、‘<code class="literal">.el</code>’や‘<code class="literal">.c</code>’のようなサフィックスをテストするが、必須ではない。このalistの通常の要素は<code class="literal">(<em class="replaceable"><code>regexp</code></em>
.  <em class="replaceable"><code>mode-function</code></em>)</code>のようになる。
</p><p>たとえば、
</p><pre class="screen">(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
</pre><pre class="screen"> ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 …)
</pre><p>バージョン番号およびバックアップ用サフィックスをもつファイルをvisitしたとき、それらは<code class="literal">file-name-sans-versions</code>(<a class="link" href="ch25s08.html#File-Name-Components" title="File Name Components">File
Name Components</a>を参照)を使用して展開されたファイル名(<a class="link" href="ch25s08.html#File-Name-Expansion" title="Functions that Expand Filenames">File Name
Expansion</a>を参照)から取り除かれて<em class="replaceable"><code>regexp</code></em>とマッチされて、<code class="literal">set-auto-mode</code>は対応する<em class="replaceable"><code>mode-function</code></em>を呼び出す。この機能により、ほとんどのファイルにたいしてEmacsが適切なメジャーモードを選択することが可能になる。
</p><p><code class="literal">auto-mode-alist</code>の要素が<code class="literal">(<em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>function</code></em>
t)</code>という形式の場合は、<em class="replaceable"><code>function</code></em>を呼び出した後、Emacsは前回マッチしなかったファイル名部分にたいしてマッチするために、再度<code class="literal">auto-mode-alist</code>を検索する。この機能は、圧縮されたパッケージにたいして有用である。<code class="literal">("\\.gz\\'"
<em class="replaceable"><code>function</code></em>
t)</code>という形式のエントリーは、ファイルを解凍してから、‘<code class="literal">.gz</code>’抜きのファイル名にたいして適切なモードに解凍されたファイルを配す。
</p><p>以下は<code class="literal">auto-mode-alist</code>の先頭に、複数のパターンペアーを追加する方法の例である(あなたは、initファイル内でこの種の式を使ったことがあるかもしれない)。
</p><pre class="screen">(setq auto-mode-alist
  (append
   ;; ドットで始まる(ディレクトリー名付きの)ファイル名
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; ドットのないファイル名
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; ‘<code class="literal">.C</code>’で終わるファイル名
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
</pre></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Mode-Help"/>Getting Help about a Major Mode</h2></div></div></div><a id="idm61638992" class="indexterm"/><a id="idm61638224" class="indexterm"/><a id="idm61637456" class="indexterm"/><p><code class="literal">describe-mode</code>関数は、メジャーモードに関する情報を提供します。これは通常、<strong class="userinput"><code>C-h
m</code></strong>にバインドされています。この関数は、変数<code class="literal">major-mode</code>(<a class="link" href="ch23s02.html" title="Major Modes">Major
Modes</a>を参照)の値を使用します。すべてのメジャーモードがこの変数をセットする必要があるのは、これが理由です。
</p><pre class="synopsis"><a id="idm61634128" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">describe-mode</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレントバッファーのメジャーモードとマイナーモードのドキュメントを表示する。この関数は、メジャーモードおよびマイナーモードのコマンドのドキュメント文字列を取得するために、<code class="literal">documentation</code>関数を使用する(<a class="link" href="ch24s02.html" title="Access to Documentation Strings">Accessing
Documentation</a>を参照)。
</p><p><em class="replaceable"><code>buffer</code></em>引数に非<code class="literal">nil</code>を指定してLispから呼び出された場合、この関数はカレントバッファーではなく、そのバッファーのメジャーモードとマイナーモードのドキュメントを表示する。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Derived-Modes"/>Defining Derived Modes</h2></div></div></div><a id="idm61627600" class="indexterm"/><p>新しいメジャーモードを定義する推奨された方法は、<code class="literal">define-derived-mode</code>を使用して既存のメジャーモードから派生させる方法です。それほど近いモードが存在しない場合は<code class="literal">text-mode</code>、<code class="literal">special-mode</code>、または<code class="literal">prog-mode</code>から継承するべきです。<a class="link" href="ch23s02.html#Basic-Major-Modes" title="Basic Major Modes">Basic
Major
Modes</a>を参照してください。これらがどれも適切でない場合は、<code class="literal">fundamental-mode</code>から継承することができます(<a class="link" href="ch23s02.html" title="Major Modes">Major
Modes</a>を参照)。
</p><pre class="synopsis"><a id="idm61622608" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">define-derived-mode</code> <em class="replaceable"><code>variant</code></em> <em class="replaceable"><code>parent</code></em> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>docstring</code></em> <em class="replaceable"><code>keyword-args</code></em><em class="replaceable"><code>…</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは、<em class="replaceable"><code>variant</code></em>をメジャーモードコマンドとして定義し、<em class="replaceable"><code>name</code></em>をモード名の文字列形式とする。<em class="replaceable"><code>variant</code></em>と<em class="replaceable"><code>parent</code></em>は、クォートされていないシンボルであること。
</p><p>新たなコマンド<em class="replaceable"><code>variant</code></em>は、関数<em class="replaceable"><code>parent</code></em>を呼び出すよう定義され、その後その親モードの特定の性質をオーバーライドする。
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>新たなモードは、<code class="literal"><em class="replaceable"><code>variant</code></em>-map</code>という名前の、自身のsparseキーマップ(疎キーマップ)をもつ。<code class="literal">define-derived-mode</code>は、<code class="literal"><em class="replaceable"><code>variant</code></em>-map</code>がすでにセットされていて、かつすでに親をもつ場合を除き、親モードのキーマップを新たなマップの親キーマップにする。
</p></li><li class="listitem"><p>新たなモードは、自身の構文テーブル(syntax
table)をもち、それは変数<code class="literal"><em class="replaceable"><code>variant</code></em>-syntax-table</code>に保持される。ただし、<code class="literal">:syntax-table</code>キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。<code class="literal">define-derived-mode</code>は、<code class="literal"><em class="replaceable"><code>variant</code></em>-syntax-table</code>がすでにセットされていて、かつ標準的な構文テーブルよ異なる親をもつ場合を除き、ペアレントモードの構文テーブルを<code class="literal"><em class="replaceable"><code>variant</code></em>-syntax-table</code>の親とする。
</p></li><li class="listitem"><p>新たなモードは、自身のabbrevテーブル(略語テーブル)をもち、それは変数<code class="literal"><em class="replaceable"><code>variant</code></em>-abbrev-table</code>に保持される。ただし、<code class="literal">:abbrev-table</code>キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。
</p></li><li class="listitem"><p>新たなモードは、自身のモードフック<code class="literal"><em class="replaceable"><code>variant</code></em>-hook</code>をもつ。これは、このフックを実行した後に、最後に<code class="literal">run-mode-hooks</code>により、自身の祖先のモードのフックを実行する。
</p></li></ul></div><p>これらに加えて、<em class="replaceable"><code>body</code></em>で<em class="replaceable"><code>parent</code></em>のその他の性質をオーバーライドする方法を指定できます。コマンド<em class="replaceable"><code>variant</code></em>はー、通常のオーバーライドをセットアップした後、そのモードのフックを実行する直前に<em class="replaceable"><code>body</code></em>内のフォームを評価します。
</p><p><em class="replaceable"><code>parent</code></em>が非<code class="literal">nil</code>の<code class="literal">mode-class</code>シンボルプロパティをもつ場合、<code class="literal">define-derived-mode</code>は<em class="replaceable"><code>variant</code></em>の<code class="literal">mode-class</code>プロパティに、同じ値をセットします。これは、たとえば<em class="replaceable"><code>parent</code></em>がspecialモードの場合は、<em class="replaceable"><code>variant</code></em>もspecialモードになることを保証します(<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照)。
</p><p><em class="replaceable"><code>parent</code></em>にたいして<code class="literal">nil</code>を指定することもできます。これにより、新たなモードは親をもたなくなります。その後、<code class="literal">define-derived-mode</code>は上述のように振る舞いますが、当然<em class="replaceable"><code>parent</code></em>につながるすべてのアクションは省略されます。
</p><p>引数<em class="replaceable"><code>docstring</code></em>は、新たなモードにたいするドキュメント文字列を指定します。<code class="literal">define-derived-mode</code>は、このドキュメント文字列の最後にそのモードフックに関する一般的な情報と、その後にそのモードのキーマップを追加します。<em class="replaceable"><code>docstring</code></em>を省略した場合は、<code class="literal">define-derived-mode</code>がドキュメント文字列を生成します。
</p><p><em class="replaceable"><code>keyword-args</code></em>は、キーワードと値のペアーです。値は評価されます。現在、以下のキーワードがサポートされています:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">:syntax-table</code>
</span></dt><dd><p>新たなモードにたいする構文テーブルを明示的に指定するために、これを使用できる。<code class="literal">nil</code>値を指定した場合、新たなモードは<em class="replaceable"><code>parent</code></em>と同じ構文テーブル、<em class="replaceable"><code>parent</code></em>も<code class="literal">nil</code>の場合は標準的な構文テーブルを使用する(これは、<code class="literal">nil</code>値の非キーワード引数は引数を指定しないのと同じという通常の慣習には<span class="emphasis"><em>したがわない</em></span>ことに注意されたい)。
</p></dd><dt><span class="term"><code class="literal">:abbrev-table</code>
</span></dt><dd><p>新たなモードにたいするabbrevテーブルを明示的に指定するために、これを使用できる。<code class="literal">nil</code>値を指定した場合、新たなモードは<em class="replaceable"><code>parent</code></em>と同じabbrevテーブル、<em class="replaceable"><code>parent</code></em>も<code class="literal">nil</code>の場合は、<code class="literal">fundamental-mode-abbrev-table</code>を使用する(繰り返すが、<code class="literal">nil</code>値はこのキーワードを指定しないことでは<span class="emphasis"><em>ない</em></span>)。
</p></dd><dt><span class="term"><code class="literal">:group</code>
</span></dt><dd><p>これが指定された場合、値はそのモードにたいするカスタマイズグループ(customization
group)であること(すべてのメジャーモードがカスタマイズグループをもつ訳ではない)。(まだ実験的かつ未公表だが)現在のところ、これを使用するのは<code class="literal">customize-mode</code>コマンドだけである。<code class="literal">define-derived-mode</code>は、指定されたカスタマイズグループを自動的に定義<span class="emphasis"><em>しない</em></span>。
</p></dd></dl></div><p>以下は架空の例である:
</p><pre class="screen">(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "ハイパーテキスト用のメジャーモード
\\{hypertext-mode-map}"
  (setq case-fold-search nil))

(define-key hypertext-mode-map
  [down-mouse-3] 'do-hyper-link)
</pre><p><code class="literal">define-derived-mode</code>が自動的に行うので、この定義内に<code class="literal">interactive</code>指定を記述してはならない。
</p></blockquote></div><pre class="synopsis"><a id="idm61558480" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">derived-mode-p</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>modes</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、シンボル<em class="replaceable"><code>modes</code></em>で与えられたメジャーモードのいずれかから、カレントメジャーモードが派生された場合は非<code class="literal">nil</code>をリターンする。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Basic-Major-Modes"/>Basic Major Modes</h2></div></div></div><p>Fundamentalモードは別として、他のメジャーモードの一般的な派生元となるメジャーモードが3つあります。それはTextモード、Progモード、およびSpecialです。Textモードはその本来もつ機能から有用なモードです(たとえば<code class="filename">.txt</code>ファイルの編集など)。一方、ProgモードとSpecialモードは主にそのようなモード以外のモードの派生元として存在します。
</p><a id="idm61552208" class="indexterm"/><p>新たなモードは、直接または間接を問わず、可能な限りれら3つのモードから派生させるべきです。その理由の1つは、関連のあるモードファミリー全体(たとえばすべてのプログラミング言語のモード)にたいして、ユーザーが単一のモードフックをカスタマイズできる空からです。
</p><pre class="synopsis"><a id="idm61550800" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">text-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>Textモードは、人間の言語を編集するためのメジャーモードである。このモードは、文字‘<code class="literal">"</code>’および‘<code class="literal">\</code>’を区切り文字構文(punctuation
syntax: <a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax Class
Table</a>を参照)としてもち、<strong class="userinput"><code>M-<span class="keycap"><strong>TAB</strong></span></code></strong>を<code class="literal">ispell-complete-word</code>にバインドする(section “Spelling” in <em class="citetitle">The GNU Emacs Manual</em>を参照)。
</p><p>Textモードから派生されたメジャーモードの例として、HTMLモードがある。section “SGML and HTML Modes” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm61543888" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">prog-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>Progモードは、プログラミング言語のソースコードを含むバッファーにたいする、基本的なメジャーモードである。Emacsビルトインのプログラミング言語用メジャーモードは、このモードから派生されている。
</p><p>Progモードは、<code class="literal">parse-sexp-ignore-comments</code>を<code class="literal">t</code>(<a class="link" href="ch35s06.html#Motion-via-Parsing" title="Motion Commands Based on Parsing">Motion via
Parsing</a>を参照)にバインドし、<code class="literal">bidi-paragraph-direction</code>を<code class="literal">left-to-right</code>(<a class="link" href="ch38s24.html" title="Bidirectional Display">Bidirectional
Display</a>を参照)にバインドする。
</p></blockquote></div><pre class="synopsis"><a id="idm61537616" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">special-mode</code></pre><div class="blockquote"><blockquote class="blockquote"><p>Specialモードは、ファイルから直接ではなく、Emacsにより特別(specially)に生成されたテキストを含むバッファーにたいする、基本的なメジャーモードである。Specialモードから派生されたメジャーモードは、<code class="literal">mode-class</code>プロパティに<code class="literal">special</code>ーが与えられる(<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照)。
</p><p>Specialモードは、バッファーを読み取り専用にセットする。このモードのキーマップは、いくつかの一般的なバインディングを定義し、それには<code class="literal">quit-window</code>にたいする<strong class="userinput"><code>q</code></strong>、<code class="literal">revert-buffer</code>(<a class="link" href="ch26s03.html" title="Reverting">Reverting</a>を参照)にたいする<strong class="userinput"><code>g</code></strong>が含まれる。
</p><p>Specialから派生されたメジャーモードの例としてはBuffer Menuモードがあり、これは<code class="filename">*Buffer
List*</code>バッファーにより使用される。section “Listing Existing Buffers” in <em class="citetitle">The
GNU Emacs Manual</em>を参照のこと。
</p></blockquote></div><p>これらに加えて、表形式データのバッファーにたいするモードはTabulated
Listモードから継承できます。このモードは、Specialモードから順に派生されているモードです。<a class="link" href="ch23s02.html#Tabulated-List-Mode" title="Tabulated List mode">Tabulated List
Mode</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Mode-Hooks"/>Mode Hooks</h2></div></div></div><p>すべてのメジャーモードコマンドは、モード独自のノーマルフック<code class="literal">change-major-mode-after-body-hook</code>、そのモードのモードフック、ノーマルフック<code class="literal">after-change-major-mode-hook</code>を実行することにより終了すべきです。これは、<code class="literal">run-mode-hooks</code>を呼び出すことにより行われます。もしそのモードが派生モードなら、自身のbody内で他のメジャーモード(親モード)を呼び出す場合は、親モードが自身でこれらのフックを実行しないように、<code class="literal">delay-mode-hooks</code>の中でこれを行うべきです。そのかわりに、派生モードは親のモードフックも実行する、<code class="literal">run-mode-hooks</code>を呼び出すのです。<a class="link" href="ch23s02.html#Major-Mode-Conventions" title="Major Mode Conventions">Major
Mode Conventions</a>を参照してください。
</p><p>Emacs 22より前のバージョンのEmacsには、<code class="literal">delay-mode-hooks</code>がありません。また、Emacs
24より前のバージョンには、<code class="literal">change-major-mode-after-body-hook</code>がありません。ユーザー実装のメジャーモードが<code class="literal">run-mode-hooks</code>を使用せず、これらの新しい機能を使用するようにアップデートされていないときは、これらのメジャーモードは以下の慣習に完全にしたがわないでしょう。それらのモードは、親のモードフックをあまりに早く実行したり、<code class="literal">after-change-major-mode-hook</code>の実行に失敗するかもしれません。そのようなメジャーモードに遭遇した場合は、以下の慣習にしたがって修正をお願いします。
</p><p><code class="literal">define-derived-mode</code>を使用してメジャーモードを定義したときは、自動的にこれらの慣習にしたがうことが確実になります。<code class="literal">define-derived-mode</code>を使用せずにメジャーモードを“手動”で定義した場合は、これらの慣習を自動的に処理するように、以下の関数を使用してください。
</p><pre class="synopsis"><a id="idm61519824" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">run-mode-hooks</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>hookvars</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>メジャーモード、この関数を使用してそれらのモードフックを実行すべきである。これは<code class="literal">run-hooks</code>(<a class="link" href="ch23.html#Hooks" title="Hooks">Hooks</a>を参照)と似ているが、<code class="literal">change-major-mode-after-body-hook</code>と<code class="literal">after-change-major-mode-hook</code>も実行する。
</p><p>この関数が、<code class="literal">delay-mode-hooks</code>フォーム実行中に呼び出されたときは、それらのフックを即座には実行しない。かわりに、次の<code class="literal">run-mode-hooks</code>呼び出しでそれらを実行するようにアレンジする。
</p></blockquote></div><pre class="synopsis"><a id="idm61512656" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">delay-mode-hooks</code> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>あるメジャーモードコマンドが他のメジャーモードコマンドを呼び出すとき、それは<code class="literal">delay-mode-hooks</code>の内部で行われるべきである。
</p><p>このマクロは<em class="replaceable"><code>body</code></em>を実行するが、<em class="replaceable"><code>body</code></em>実行中はすべての<code class="literal">run-mode-hooks</code>呼び出しにたいして、それらのフックの実行を遅延するよう指示する。それらのフックは、実際には<code class="literal">delay-mode-hooks</code>構造の最後の後、次の<code class="literal">run-mode-hooks</code>呼び出しの間に実行されるだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm61505872" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">change-major-mode-after-body-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、<code class="literal">run-mode-hooks</code>により実行されるノーマルフックである。これは、そのモードのフックの前に実行される。
</p></blockquote></div><pre class="synopsis"><a id="idm61502544" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">after-change-major-mode-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、<code class="literal">run-mode-hooks</code>により実行されるノーマルフックである。これは、すべての適切に記述されたメジャーモードコマンドの一番最後に実行される。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Tabulated-List-Mode"/>Tabulated List mode</h2></div></div></div><a id="idm61486288" class="indexterm"/><p>Tabulated
Listモードとは、表形式データ(<em class="firstterm">エントリー</em>から構成されるデータであり、各エントリーはそれぞれテキストの1行を占め、エントリーの内容は列に分割されるようなデータ)を表示するためのメジャーモードです。Tabulated
Listモードは、行列の見栄えよくプリントする機能、および各列の値に応じて行をソートする機能を提供します。これは、Specialモードから派生されたモードです(<a class="link" href="ch23s02.html#Basic-Major-Modes" title="Basic Major Modes">Basic
Major Modes</a>を参照)。
</p><p>Tabulated Listモードは、より特化したメジャーモードの親モードとして使用されることを意図しています。例としては、Process
Menuモード(<a class="link" href="ch37s06.html" title="Process Information">Process Information</a>を参照)や、Package Menuモード(section “Package Menu” in <em class="citetitle">The GNU Emacs Manual</em>を参照)が含まれます。
</p><a id="idm61482960" class="indexterm"/><p>このような派生されたモードは、<code class="literal">tabulated-list-mode</code>を2つ目の引数に指定して、通常の方法で<code class="literal">define-derived-mode</code>を使用するべきです(<a class="link" href="ch23s02.html#Derived-Modes" title="Defining Derived Modes">Derived
Modes</a>を参照)。<code class="literal">define-derived-mode</code>フォームのbodyは、以下にドキュメントされている変数に値を割り当てることにより、表形式データのフォーマットを指定するべきです。その後、ヘッダー行を初期化するために関数<code class="literal">tabulated-list-init-header</code>を呼び出すべきです。
</p><p>派生されたモードは、<em class="firstterm">リスティングコマンド</em>も定義するべきです。これはモードコマンドではなく、(<strong class="userinput"><code>M-x
list-processes</code></strong>のように)ユーザーが呼び出すコマンドです。リスティングコマンドは、バッファーを作成または切り替えて、派生モードをオンにして、表形式データを指定し、最後にそのバッファーを事前設定(populate)するために<code class="literal">tabulated-list-print</code>を呼び出すべきです。
</p><pre class="synopsis"><a id="idm61469008" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">tabulated-list-format</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このバッファーローカル変数は、表形式データのフォーマットを指定する。値はベクターで、ベクターの各要素はデータ列を表すリスト<code class="literal">(<em class="replaceable"><code>name</code></em>
<em class="replaceable"><code>width</code></em> <em class="replaceable"><code>sort</code></em>)</code>である。ここで
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="replaceable"><code>name</code></em>は列の名前(文字列)。
</p></li><li class="listitem"><p><em class="replaceable"><code>width</code></em>は列にたいして予約される文字数幅(整数)。最終列は各行の終端までなので意味がない。
</p></li><li class="listitem"><p><em class="replaceable"><code>sort</code></em>は列によりエントリーをソートする方法を指定する。<code class="literal">nil</code>の場合、その列はソートに使用できない。<code class="literal">t</code>の場合は、列の文字列値を比較することによりソートされる。それ以外の場合は、<code class="literal">tabulated-list-entries</code>の要素と同じ形式の2つの引数をとる、<code class="literal">sort</code>にたいする述語関数(predicate
function)であること。
</p></li></ul></div></blockquote></div><pre class="synopsis"><a id="idm61447760" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">tabulated-list-entries</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このバッファーローカル変数は、Tabulated Listバッファー内に表示されるエントリーを指定する。値にはリスト、または関数のいずれかであること。
</p><p>値がリストの場合、各リスト要素は1つのエントリーに対応し、<code class="literal">(<em class="replaceable"><code>id</code></em>
<em class="replaceable"><code>contents</code></em>)</code>という形式であること。ここで
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="replaceable"><code>id</code></em>は<code class="literal">nil</code>、またはエントリーを識別するLispオブジェクト。Lispオブジェクトの場合には、エントリーを再ソートした際、カーソルは“同じ”エントリー上に留まる。比較は<code class="literal">equal</code>で行われる。
</p></li><li class="listitem"><p><em class="replaceable"><code>contents</code></em>は、<code class="literal">tabulated-list-format</code>と要素数が同じベクター。ベクター要素は文字列、またはリスト。文字列の場合は、バッファーにそのまま挿入される。リスト<code class="literal">(<em class="replaceable"><code>label</code></em>
.
<em class="replaceable"><code>properties</code></em>)</code>の場合には、<em class="replaceable"><code>label</code></em>と<em class="replaceable"><code>properties</code></em>を引数として<code class="literal">insert-text-button</code>を呼び出すことにより、テキストボタンを挿入することを意味する(<a class="link" href="ch38s18.html#Making-Buttons" title="Making Buttons">Making
Buttons</a>を参照)。
</p><p>これらの文字列には、改行を含めるべきではない。
</p></li></ul></div><p>それ以外の場合、値は引数なしで呼び出され上記形式のリストをリターンする関数であること。
</p></blockquote></div><pre class="synopsis"><a id="idm61432144" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">tabulated-list-revert-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このノーマルフックはTabulated
Listバッファーのリバートに先立ち実行される。派生モードは、<code class="literal">tabulated-list-entries</code>を再計算するために、このフックに関数を追加できる。
</p></blockquote></div><pre class="synopsis"><a id="idm61428816" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">tabulated-list-printer</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、ポイント位置にエントリー(エントリーを終端する改行を含む)を挿入するために呼び出される関数である。この関数は、<code class="literal">tabulated-list-entries</code>と同じ意味をもつ2つの引数<em class="replaceable"><code>id</code></em>と<em class="replaceable"><code>contents</code></em>を受け取る。デフォルト値は、エントリーをそのまま挿入する関数である。より複雑な方法によりTabulated
Listモードを使用するモードは、別の関数を指定できる。
</p></blockquote></div><pre class="synopsis"><a id="idm61424848" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">tabulated-list-sort-key</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、Tabulated
Listバッファーにたいするカレントのソートキーを指定する。<code class="literal">nil</code>の場合、ソートは行われていない。それ以外では、<code class="literal">(<em class="replaceable"><code>name</code></em>
.
<em class="replaceable"><code>flip</code></em>)</code>という形式の値をもつ。ここで<em class="replaceable"><code>name</code></em>は<code class="literal">tabulated-list-format</code>内の列目の1つとマッチする文字列、<em class="replaceable"><code>flip</code></em>が非<code class="literal">nil</code>の場合は逆順でのソートを意味する。
</p></blockquote></div><pre class="synopsis"><a id="idm61418448" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">tabulated-list-init-header</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、Tabulated
Listバッファーにたいする<code class="literal">header-line-format</code>を計算してセットし、列ヘッダー上でのクリックでソートを可能にするキーマップをヘッダー行に割り当てる。
</p><p>Tabulated
Listから派生したモードは、上記の変数(特に<code class="literal">tabulated-list-format</code>をセットした後のみ)をセットした後にこれを呼び出すべきである。
</p></blockquote></div><pre class="synopsis"><a id="idm61414224" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">tabulated-list-print</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>remember-pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファーにエントリーを準備(populate)する。これはリスティングコマンドとして呼び出されるべきである。この関数は、バッファーを消去して<code class="literal">tabulated-list-entries</code>で指定されるエントリーを<code class="literal">tabulated-list-sort-key</code>にしたがってソートした後、各エントリーを挿入するために<code class="literal">tabulated-list-printer</code>で指定される関数を呼び出す。
</p><p>オプション引数<em class="replaceable"><code>remember-pos</code></em>が非<code class="literal">nil</code>の場合、この関数はカレント行で<em class="replaceable"><code>id</code></em>要素を探して、もしあればすべてのエントリーを(再)挿入して、その後へそのエントリーの移動を試みる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Generic-Modes"/>Generic Modes</h2></div></div></div><a id="idm61406672" class="indexterm"/><p><em class="firstterm">genericモード (generic mode:汎用モード))</em>とは、コメント構文にたいする基本的なサポートとFont
Lockモードをもつ、シンプルなメジャーモードです。genericモードを定義するには、マクロ<code class="literal">define-generic-mode</code>を使用します。<code class="literal">define-generic-mode</code>の使い方の例は、ファイル<code class="filename">generic-x.el</code>を参照してください。
</p><pre class="synopsis"><a id="idm61403472" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">define-generic-mode</code> <em class="replaceable"><code>mode</code></em> <em class="replaceable"><code>comment-list</code></em> <em class="replaceable"><code>keyword-list</code></em> <em class="replaceable"><code>font-lock-list</code></em> <em class="replaceable"><code>auto-mode-list</code></em> <em class="replaceable"><code>function-list</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>docstring</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このマクロは、<em class="replaceable"><code>mode</code></em>(クォートされていないシンボル)という名前のgenericモードコマンドを定義する。オプション引数<em class="replaceable"><code>docstring</code></em>は、そのモードコマンドにたいするドキュメント文字列である。これを与えない場合は、<code class="literal">define-generic-mode</code>がデフォルトのドキュメント文字列を生成する。
</p><p>引数<em class="replaceable"><code>comment-list</code></em>は、要素が文字、2文字以下の文字列、またはコンスセルである。文字か文字列の場合には、そのモードの構文テーブル内で“コメント開始識別子”としてセットアップされる。エントリーがコンスセルの場合、CARは“コメント開始識別子”、CDRは“コメント終了識別子”としてセットアップされる(行末によりコメントを終端させたい場合は、後者に<code class="literal">nil</code>を使用する)。構文テーブルのメカニズムには、実際にコメントの開始および終了識別子に関する制限があることに注意されたい。
<a class="link" href="ch35.html" title="Chapter 34. Syntax Tables">Syntax Tables</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>keyword-list</code></em>は、<code class="literal">font-lock-keyword-face</code>でハイライトするキーワードのリストである。キーワードは文字列であること。一方、<em class="replaceable"><code>font-lock-list</code></em>はハイライトするための追加の式リストである。このリストの各要素は、<code class="literal">font-lock-keywords</code>の要素と同じ形式をもつべきである。<a class="link" href="ch23s06.html#Search_002dbased-Fontification" title="Search-based Fontification">Search-based
Fontification</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>auto-mode-list</code></em>は、変数<code class="literal">auto-mode-alist</code>に追加する正規表現のリストである。これらの式は、マクロ呼び出しの展開時ではなく、<code class="literal">define-generic-mode</code>の実行時に追加される。
</p><p>最後に<em class="replaceable"><code>function-list</code></em>は、追加セットアップのためにモードコマンドに呼び出される関数のリストである。これらの関数は、モードフック変数<code class="literal"><em class="replaceable"><code>mode</code></em>-hook</code>の実行の直前に呼び出される。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Example-Major-Modes"/>Major Mode Examples</h2></div></div></div><p>Textモードは、Fundamentalを除き、おそらくもっともシンプルなモードです。上述した慣習の多くを説明するために、以下に<code class="filename">text-mode.el</code>の抜粋を示します:
</p><pre class="screen">;; このモード用に構文テーブルを作成
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; M-cで`hello'が`hello'でなく`Hello'になるよう`p'を追加
    (modify-syntax-entry ?' "w p" st)
    st)
  "`text-mode'で使用される構文テーブル")
</pre><pre class="screen">
;; このモード用にキーマップを作成
</pre><pre class="screen">(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "`text-mode'のキーマップ
`mail-mode'、`outline-mode'、`indented-text-mode'のような
他の多くのモードはこのマップ内で定義した全コマンドを継承する")
</pre><p>そして、実際にモードコマンドが定義される方法です:
</p><pre class="screen">(define-derived-mode text-mode nil "Text"
  "人間が読むために記述されたテキストを編集するためのメジャーモード
このモードではパラグラフを区切るのはブランク行か空白行だけである
したがって適応型フィル(adaptive filling)の全恩恵を受けられる
 (変数`adaptive-fill-mode'を参照のこと)
\\{text-mode-map}
Textモードのオンによりノーマルフック`text-mode-hook'が実行される"
</pre><pre class="screen">  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
</pre><p>(<code class="literal">indent-relative</code>がデフォルト値の現在では、最後の行は冗長なので、将来のバージョンで削除するつもりです。)
</p><a id="idm61382992" class="indexterm"/><p>3つのLisp用モード(Lispモード、Emacs Lispモード、Lisp
Interactionモード)は、Textモードより多くの機能をもち、それにふさわしくコードもより複雑です。そのようなモードの記述方法を説明するために、<code class="filename">lisp-mode.el</code>の抜粋を示します。
</p><p>以下は、Lispモードの構文テーブルとabbrevテーブルを定義する方法です:
</p><a id="idm61380688" class="indexterm"/><pre class="screen">;; モード固有のテーブル変数の作成
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "`lisp-mode'で使用される構文テーブル")
</pre><p>Lisp用の3つのモードは、コードの多くを共有します。たとえば、以下の関数呼び出しにより、さまざまな変数がセットされます:
</p><pre class="screen">(defun lisp-mode-variables (&amp;optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  …
</pre><p>その中でも特に、以下の関数はLispコメントを処理するために、変数<code class="literal">comment-start</code>をセットアップします:
</p><pre class="screen">  (make-local-variable 'comment-start)
  (setq comment-start ";")
  …
</pre><p>これら異なるLisp用モードは、微妙に異なるキーマップをもちます。たとえば、Lispモードは<strong class="userinput"><code>C-c
C-z</code></strong>を<code class="literal">run-lisp</code>にバインドしますが、他のLisp用モードはこれを行いません。とはいえ、すべてのLisp用モードに共通なコマンドがいくつかあります。以下のコードは、それらの共通コマンドをセットアップします:
</p><pre class="screen">(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "すべてのLisp用モードでコマンドを共有するためのキーマップ")
</pre><p>そして、以下がLispモードのためのキーマップをセットアップするコードです:
</p><pre class="screen">(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    …
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
</pre><p>最後は、Lispモードのためのメジャーモードコマンドです:
</p><pre class="screen">(define-derived-mode lisp-mode prog-mode "Lisp"
  "GNU Emacs Lisp以外のLispコードを編集するためのメジャーモード
コマンド:
後方に移動させるかのようにタブをスペースに削除変換する。
パラグラフ区切りはブランク行。コメント開始はセミコロン。

\\{lisp-mode-map}
`run-lisp'はinferior Lispジョブの開始と既存ジョブ
から戻るための両方に使われるかもしれないことに注意
</pre><pre class="screen">
</pre><pre class="screen">このモードへのエントリーにより、
`lisp-mode-hook'の値が非nilならそれを呼び出す"
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
</pre></div></div></body></html>