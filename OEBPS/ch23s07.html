<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Automatic Indentation of code</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Auto_002dIndentation"/>Automatic Indentation of code</h1></div></div></div><p>プログラミング言語のメジャーモードにとって、自動的なインデントの提供は、重要な機能です。これには2つのパートがあります。1つ目は正しい行のインデントが何か、そして2つ目はいつ行を再インデントするかの判断です。デフォルトでは、<code class="literal">electric-indent-chars</code>に含まれる文字(デフォルトでは改行のみ)をタイプしたとき、Emacsは常に行を再インデントします。メジャーモードは、その言語の構文に合わせて、<code class="literal">electric-indent-chars</code>に文字を追加できます。
</p><p>正しいインデントの決定は、<code class="literal">indent-line-function</code>によりEmacs内で制御されます(<a class="link" href="ch32s17.html#Mode_002dSpecific-Indent" title="Indentation Controlled by Major Mode">Mode-Specific
Indent</a>を参照)。いくつかのモードでは、<span class="emphasis"><em>右</em></span>へのインデントは信頼性がないことが知られています。これは通常、複数のインデントが有効だが、それぞれが異なる意味をもつので、インデント自体が重要だからです。そのような場合、そのモードは行が常にユーザーの望み通り再インデントされないことを念押しするために、<code class="literal">electric-indent-inhibit</code>をセットするべきです。
</p><p>よいインデント関数の記述は難しく、その広範な領域において、未だ黒魔術の域を脱していません。メジャーモード作者の多くは、単純なケース(たとえば前のテキスト行のインデントとの比較)にたいして機能する、単純な関数の記述からスタートすることでしょう。実際には行ベースではないほとんどのプログラミング言語にたいして、これは貧弱なスケールになりがちです。そのような関数にたいして、より多様な状況を処理するような改良を行うと、関数はより一層複雑になり、最終的な結果は誰にも触れようとする気を起こさせない、巨大で複雑な保守不可能のインデント関数になる傾向があります。
</p><p>よいインデント関数は通常、その言語の構文に応じて、実際にテキストをパースする必要があるでしょう。幸運なことに、このテキストパースはコンパイラーが要するほど詳細である必要はないでしょうが、その一方でインデントコードに埋め込まれたパーサーは、構文的に不正なコードにたいして、コンパイラーより幾分寛容な振る舞いを求められるでしょう。
</p><p>保守可能なよいインデント関数は、通常2つのカテゴリーに落ち着きます。どちらも何らかの“安全”な開始ポイントから、関心のある位置まで前方にパースを行うか、あるいは後方へパースを行います。この2つの方法は、どちらも一方が他方に明快に優る選択ではありません。後方へのパースは、プログラミング言語が前方にパースされるようデザインされているため、前方へのパースに比べて難しいことが多々ありますが、インデントという目的においては“安全”な開始ポイントを推測する必要がないという利点があり、一般的にある行のインデントの判断のために分析を要するのは最小限のテキストだけという特性に恵まれているので、前の無関係なコード片内にある、何らかの構文エラーの影響をインデントが受けにくくなる傾向があります。一方で前方へのパースは、通常はより簡単であり、一度のパースで、リージョン全体を効果的に再インデントすることが可能になるという利点があります。
</p><p>インデント関数をスクラッチから記述するよりも、既存のインデント関数の試用と再利用、または一般的なインデントエンジンに委ねるほうが優る場合が、しばしばあります。しかし、そのようなエンジンは悲しむべきほど少数しかありません。CCモードのインデントコード(C、C++、Java、Awk、およびその類のモードが使用)は年月を経てより一般化されてきているので、あなたの言語にこれらの言語と何らかの相似点があるなら、このエンジンの使用を試みるかもしれません。もう一方のSMIEはLispのsexp精神によるアプローチを採用して、それを非Lisp言語に適応します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="SMIE"/>Simple Minded Indentation Engine</h2></div></div></div><a id="idm64475472" class="indexterm"/><p>SMIEは、一般的な操作とインデントを提供するエンジンです。これは“演算子順位文法(operator precedence
grammar)”を使用する、非常にシンプルなパーサーにもとづいたエンジンであり、メジャーモードがLispのS式ベースの操作を非Lisp言語に拡張するのを助け、同様にシンプルに使用できるにも関わらず、信頼できる自動インデントを提供します。
</p><p>演算子順位文法は、コンパイラー内で使用されるより一般的なパーサーと比較すると、非常に原始的なパーステクノロジーです。このパーサーには次のような特徴があります。このパーサーのパース能力は非常に限定的で、大概は構文エラーを検出できません。しかし、アルゴリズム的に前方パースと同様に後方パースを効果的に行うことが可能です。実際にそれはSMIEが後方パースにもとづくインデントを使用でき、<code class="literal">forward-sexp</code>と<code class="literal">backward-sexp</code>の両方の機能を提供できるとともに、特別な努力を要さずに構文的に不正なコードにたいして自然に機能するであろうことを意味します。欠点は、ほとんどのプログラミング言語は、少なくとも何らかの特別なトリック(<a class="link" href="ch23s07.html#SMIE-Tricks" title="Living With a Weak Parser">SMIE
Tricks</a>を参照)で再分類しなければ、SMIEを使用して正しくパースできないことも意味するからです。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-setup"/>SMIE Setup and Features</h3></div></div></div><p>SMIEは、構造的な操作と、コードの構造的構造にもとづくその他さまざまな機能、特に自動インデントにたいするワンストップショップ(一カ所で必要な全ての買い物ができること、またはそのような場所)であることを意図しています。メインのエントリーポイントは<code class="literal">smie-setup</code>で、これは通常メジャーモードセットアップの間に呼び出される関数です。
</p><pre class="synopsis"><a id="idm64437456" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-setup</code> <em class="replaceable"><code>grammar</code></em> <em class="replaceable"><code>rules-function</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>keywords</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>SMIEの操作とインデントをセットアップする。<em class="replaceable"><code>grammar</code></em>は<code class="literal">smie-prec2-&gt;grammar</code>により生成される文法テーブル(grammar
table)、<em class="replaceable"><code>rules-function</code></em>は<code class="literal">smie-rules-function</code>で使用されるインデントルールのセット、<em class="replaceable"><code>keywords</code></em>は追加の引数であり以下のキーワードを含むことができる:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">:forward-token</code> <em class="replaceable"><code>fun</code></em>: 使用する前方lexer(lexer=lexical analyzer:
字句解析プログラム)を指定する。
</p></li><li class="listitem"><p><code class="literal">:backward-token</code> <em class="replaceable"><code>fun</code></em>: 使用する後方lexerを指定する。
</p></li></ul></div></blockquote></div><p>この関数を呼び出せば、<code class="literal">forward-sexp</code>、<code class="literal">backward-sexp</code>、<code class="literal">transpose-sexps</code>のようなコマンドが、すでに構文テーブルにより処理されている単なるカッコのペアー以外の、構造的な要素を正しく扱うことができるようになります。たとえば、与えられた文法が十分に明快ならば、<code class="literal">transpose-sexps</code>はその言語の優先順位のルールを考慮して、<code class="literal">+</code>演算子の2つの引数を正しく入れ替えることができます。
</p><p>‘smie-setup’の呼び出しもまた、TABによるインデントを期待通り機能させ、<code class="literal">begin...end</code>のような要素に適用するために<code class="literal">blink-matching-paren</code>を拡張し、そのメジャーモードのキーマップ内でバインドできるいくつかのコマンドを提供するのに十分です。
</p><pre class="synopsis"><a id="idm64424016" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-close-block</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、もっとも最近オープンされた(まだクローズされていない)ブロックをクローズする。
</p></blockquote></div><pre class="synopsis"><a id="idm64421200" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-down-list</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>arg</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは<code class="literal">down-list</code>と似ているが、<code class="literal">begin...end</code>のようなカッコ以外のネストされたトークンにも注意を払う。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Operator-Precedence-Grammars"/>Operator Precedence Grammars</h3></div></div></div><p>SMIEの演算子順位文法は、各トークンにたいしてシンプルに左優先(left-precedence)と右優先(right-precedence)という順位ペアーを与えます。トークン<code class="literal">T1</code>の右優先が、トークン<code class="literal">T2</code>の左優先より小さい場合は、<code class="literal">T1
&lt; T2</code>であると言うことにしましょう。これを解読するには、<code class="literal">&lt;</code>をカッコの一種だとみなすのがよい方法です。<code class="literal">... T1
something T2 ...</code>を見つけたら、これは<code class="literal">... T1 something) T2 ...</code>ではなく<code class="literal">... T1
(something T2 ...</code>とパースされるべきです。<code class="literal">... T1 something) T2
...</code>と解釈するのは、<code class="literal">T1 &gt; T2</code>を見つけた場合でしょう。<code class="literal">T1 =
T2</code>を見つけた場合、それはトークンT2とその後のトークンT1が同じ構文構成にあり、通常は<code class="literal">"begin" =
"end"</code>を得ます。このような優先順位のペアーは、2項演算子(infix
operator)、カッコのようなネストされたトークン、およびその他多くのケースにたいして左結合(left-associativity)や右結合(right-associativity)を表現するのに十分です。
</p><pre class="synopsis"><a id="idm64403792" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-prec2-&gt;grammar</code> <em class="replaceable"><code>table</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<span class="emphasis"><em>prec2</em></span>文法<em class="replaceable"><code>table</code></em>を引数にとり、<code class="literal">smie-setup</code>で使用するのに適したalistをリターンする。<span class="emphasis"><em>prec2</em></span>文法<em class="replaceable"><code>table</code></em>は、それ自体が以下の関数のいずれかによりビルドされることを意図している。
</p></blockquote></div><pre class="synopsis"><a id="idm64398544" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-merge-prec2s</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>tables</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、複数の<span class="emphasis"><em>prec2</em></span>文法<em class="replaceable"><code>tables</code></em>を、新たな<span class="emphasis"><em>prec2</em></span>テーブルにマージする。
</p></blockquote></div><pre class="synopsis"><a id="idm64393808" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-precs-&gt;prec2</code> <em class="replaceable"><code>precs</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、順位テーブル<em class="replaceable"><code>precs</code></em>から<span class="emphasis"><em>prec2</em></span>テーブルをビルドする。<em class="replaceable"><code>precs</code></em>は優先順(たとえば<code class="literal">"+"</code>は<code class="literal">"*"</code>より前にくる)にソートされたリストで、要素は<code class="literal">(<em class="replaceable"><code>assoc</code></em>
<em class="replaceable"><code>op</code></em>
...)</code>の形式であること。ここで、<em class="replaceable"><code>op</code></em>は演算子として振る舞うトークン、<em class="replaceable"><code>assoc</code></em>はそれらの結合法則であり、<code class="literal">left</code>、<code class="literal">right</code>、<code class="literal">assoc</code>、<code class="literal">nonassoc</code>のいずれかである。与えられた要素内のすべての演算子は、同じ優先レベルと結合法則を共有する。
</p></blockquote></div><pre class="synopsis"><a id="idm64384336" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-bnf-&gt;prec2</code> <em class="replaceable"><code>bnf</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>resolvers</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数により、BNF記法を使用した文法を指定することができる。これは、その文法の<em class="replaceable"><code>bnf</code></em>表記と、同様に競合解決ルール<em class="replaceable"><code>resolvers</code></em>を受け取り、<span class="emphasis"><em>prec2</em></span>テーブルをリターンする。
</p><p><em class="replaceable"><code>bnf</code></em>は<code class="literal">(<em class="replaceable"><code>nonterm</code></em> <em class="replaceable"><code>rhs1</code></em> <em class="replaceable"><code>rhs2</code></em>
...)</code>という形式の非終端定義で、各<em class="replaceable"><code>rhs</code></em>は終端記号(トークンとも呼ばれる)、または非終端記号の(空でない)リストである。
</p><p>すべての文法が許される訳ではない:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="replaceable"><code>rhs</code></em>に空のリストは指定できない(いずれにせよSMIEは空文字列にマッチさせるためにすべての非終端記号を許すので、空リストが必要になることは決してない)。
</p></li><li class="listitem"><p><em class="replaceable"><code>rhs</code></em>の後に連続する2つの非終端記号は指定できない。非終端記号の各ペアーは終端記号(もしくはトークン)で区切られる必要がある。これは、演算子順位文法の基本的な制約である。
</p></li></ul></div><p>さらに、競合が発生し得る:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>リターンされる<span class="emphasis"><em>prec2</em></span>テーブルはトークンのペアー間の制約を保持し、与えられた任意のペアーはT1 &lt; T2、T1 = T2、T1 &gt;
T2のいずれかのうち、ただ1つの制約を与えることができる。
</p></li><li class="listitem"><p>トークンは、<code class="literal">opener</code>(開きカッコに似た何か)、<code class="literal">closer</code>(閉じカッコのようなもの)、またはこれら2つのいずれでもない<code class="literal">neither</code>(2項演算子や<code class="literal">"else"</code>のようなinnerトークン)である。
</p></li></ul></div><p>順位の競合は、<em class="replaceable"><code>resolvers</code></em>を通じて解決され得る。これは<span class="emphasis"><em>precs</em></span>テーブル(<code class="literal">smie-precs-&gt;prec2</code>を参照)のリストである。それぞれの順位競合にたいして、これらの<code class="literal">precs</code>テーブルが特定の制約を指定している場合は、かわりにこの制約により競合が解決され、それ以外は競合する制約のうち任意の1つが報告され、他は単に無視される。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Grammar"/>Defining the Grammar of a Language</h3></div></div></div><a id="idm64363728" class="indexterm"/><a id="idm64362960" class="indexterm"/><p>ある言語にたいしてSMIE文法を定義する通常の方法は、順位のテーブルを保持する新たなグローバル変数を定義して、BNFルールのセットを与える方法です。たとえば、小規模なPascal風言語の文法定義は、以下のようになるでしょう:
</p><pre class="screen">(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2-&gt;grammar
   (smie-bnf-&gt;prec2
</pre><pre class="screen">    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
</pre><pre class="screen">    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
</pre><p>注意すべき点がいくつかあります:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>上記の文法は、関数呼び出しの構文に明示的に言及していない。SMIEは識別子、対応がとれたカッコ(balanced
parentheses)、または<code class="literal">begin
... end</code>ブロックのようなsexpの任意のシーケンスが、どこに、どのように出現しても、自動的にそれを許容するだろう。
</p></li><li class="listitem"><p>文法カテゴリー<code class="literal">id</code>は、右側に何ももたない。これは、<code class="literal">id</code>が空文字列だけにマッチ可能なことを意味しない。なぜなら上述のように、任意のsexpシーケンスは、どこに、どのような方法でも出現するからである。
</p></li><li class="listitem"><p>BNF文法では非終端記号が連続して出現し得ないので、終端記号として作用するトークンを正しく扱うのが困難なので、上述の文法では、SMIEが容易に扱える<code class="literal">";"</code>を、<span class="emphasis"><em>セパレーター(separator)</em></span>ステートメントのかわりとして扱っている。
</p></li><li class="listitem"><p>シーケンス内で使用される、(上記の<code class="literal">","</code>や<code class="literal">";"</code>のような)セパレーターは、BNFルールでは<code class="literal">(foo (foo
"separator" foo) ...)</code>のように定義するのが最善である。これは、順位の競合を生成するが、明示的に<code class="literal">(assoc
"separator")</code>を与えることにより解決される、
</p></li><li class="listitem"><p>SMIEは、構文テーブル(syntax table)内でカッコ構文(paren
syntax)をもつようにマークされたー任意の文字をペアーにするだろうから、<code class="literal">("(" exps
")")</code>ルールにカッコをペアーにする必要はなかった。(<code class="literal">exps</code>の定義と併せて)このルールはかわりに、<code class="literal">","</code>がカッコの外に出現すべきではないことを明確にする。
</p></li><li class="listitem"><p>競合解決のための<span class="emphasis"><em>precs</em></span>テーブルは、単一のテーブルより複数のテーブルをもつほうが、可能な場合は文法のBNF部分が関連する順位を指定できるので、優れている。
</p></li><li class="listitem"><p><code class="literal">left</code>または<code class="literal">right</code>を選択すること優るという明白な理由がない場合は、通常は<code class="literal">assoc</code>を使用して演算子を結合演算子(associative)とマークするほうが優れている。この理由により、上述の<code class="literal">"+"</code>と<code class="literal">"*"</code>は、たとえその言語がそれらを形式上は左結合(left
associative)と定義していても、<code class="literal">assoc</code>として定義されている。
</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Lexer"/>Defining Tokens</h3></div></div></div><a id="idm64346832" class="indexterm"/><a id="idm64346064" class="indexterm"/><p>SMIEには、事前定義された字句解析プログラムが付属しており、それは次の方法で構文テーブルを使用します:
文字の任意のシーケンスは、トークンとみなせる単語構文(word syntax)、またはシンボル構文(symbol
syntax)をもち、句読点構文(punctuation
syntax)をもつ任意の文字シーケンスもトークンとみなされます。このデフォルトのlexerは、開始ポイントとして適している場合が多々ありますが、任意の与えられた言語にたいして、実際に正しいことは稀です。たとえば、これは<code class="literal">"2,+3"</code>が3つのトークン<code class="literal">"2"</code>、<code class="literal">",+"</code>、<code class="literal">"3"</code>から構成されていると判断するでしょう。
</p><p>あなたの言語のlexerルールをSMIEにたいして説明するためには、次のトークンをfetchする関数と、前のトークンをfetchする関数の、2つの関数が必要になります。これらの関数は通常、最初に空白文字とコメントをスキップして、その後に次のテキストchunk(塊)を調べて、それが特別なトークンか確認します。これは通常、バッファーから単に抽出された文字列ですが、あなたが望む他の何かでも構いません。たとえば:
</p><pre class="screen">(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" "&gt;" "&gt;=" "&lt;" "&lt;=" ":=" "=")))
</pre><pre class="screen">(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
</pre><pre class="screen">(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
</pre><p>これらのlexerがカッコの前にあるとき、空文字列をリターンする方法に注目してください。これは、SMIEが構文テーブル内で定義されているカッコにたいして、自動的に配慮するからです。より厳密には、lexerが<code class="literal">nil</code>、または空文字列をリターンした場合、SMIEは構文テーブルにしたがい、対応するテキストをsexpとして処理します。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Tricks"/>Living With a Weak Parser</h3></div></div></div><p>SMIEが使用するパーステクニックは、異なるコンテキストでトークンが異なる振る舞いをすることを許しません。ほとんどのプログラミング言語にたいして、これは順位の競合によりBNF文法を変換するとき明らかになります。
</p><p>その文法を若干異なるように表現することにより、これらの競合を回避できる場合があります。たとえばModula-2にたいしては、以下のようなBNF文法をもつのが自然に思えるかもしれません:
</p><pre class="screen">  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
</pre><p>しかし、これは<code class="literal">"ELSE"</code>にたいする競合を生み出すでしょう。その一方でIFルールは、(他の多くのものの中でも特に)<code class="literal">"ELSE"
=
"END"</code>を暗示します。しかしその一方では、<code class="literal">"ELSE"</code>は<code class="literal">cases</code>内に出現しますが、<code class="literal">cases</code>は<code class="literal">"END"</code>の左に出現するので、わたしたちは<code class="literal">"ELSE"
&gt; "END"</code>も得ることになります。これは、以下を使用して解決できます:
</p><pre class="screen">  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
</pre><p>または
</p><pre class="screen">  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
</pre><p>文法を書き換えによる競合の解決には欠点があります。なぜなら、SMIEはその文法がコードの論理的構造を反映すると仮定するからです。そのため、BNFと意図する抽象的構文木の関係を密接に保つことが望まれます。
</p><p>注意深く考慮した後に、これらの競合は深刻ではなく、<code class="literal">smie-bnf-&gt;prec2</code>の<em class="replaceable"><code>resolvers</code></em>引数を通じて解決する決心する場合もあるでしょう。これは通常、その文法が単に不明瞭だからです。その文法により記述されるプログラムセットは競合の影響を受けませんが、それらのプログラムにたいする唯一の方法はパースだけです。<code class="literal">'((assoc
"|"))</code>のようなリゾルバ(resolver:
解決するもの)を追加したいと望むような場合、通常それはセパレーターと2項結合演算子にたいするケースです。これが発生し得る他のケースは、<code class="literal">'((assoc
"else" "then"))</code>を使用するような場合における、古典的な<span class="emphasis"><em>ぶら下がりelse問題dangling else
problem</em></span>です。これは実際に競合があり解決不能だが、実際のところ問題が発生しそうにないケースにたいしても、発生し得ます。
</p><p>最後に、多くのケースでは、すべての文法再構築努力にも関わらず、いくつかの競合が残るでしょう。しかし失望しないでください。パーサーをより賢くすることはできませんが、あなたの望むようにlexerをスマートにすることは可能です。その方法は、競合が発生したら競合を引き起こしたトークンを調べて、それらのうちの1つを2つ以上の異なるトークンに分割する方法です。たとえば、トークン<code class="literal">"begin"</code>にたいする互換性のない2つの使用を文法が区別する必要があり、見つかった<code class="literal">"begin"</code>の種類により、lexerに異なるトークン(たとえば<code class="literal">"begin-fun"</code>と<code class="literal">"begin-plain"</code>)をリターンさせる場合です。これはlexerにたいして、異なるケースを区別する処理を強い、そのためにlexerは特別な手がかりを見つけるために、周囲のテキストを調べる必要があるでしょう。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Indentation"/>Specifying Indentation Rules</h3></div></div></div><a id="idm64314192" class="indexterm"/><p>提供された文法にもとづき、他に特別なことを行わなくても、SMIEは自動的なインデントを提供できるでしょう。しかし実際には、このデフォルトのインデントスタイルでは、恐らく十分ではありません。多くの異なる状況において、これを微調整したいと思うかもしれません。
</p><p>SMIEのインデントは、インデントルールは可能な限りローカルであるべきという考えにもとづきます。<span class="emphasis"><em>バーチャルインデント(virtual
indentation)</em></span>という考えによって、この目的を達成します。これは、特定のプログラムポイント(program
point)は行頭にバーチャルインデントがある場合は、それをもつだろう、という発想です。もちろん、そのプログラムポイントが正に行頭にある場合は、そのプログラムポイントのバーチャルインデントは、プログラムポイントのカレントのインデントです。しかしそうでない場合は、SMIEがそのポイントのバーチャルインデントを計算するために、インデントアルゴリズムを使用します。ところで実際には、あるプログラムポイントのバーチャルインデントは、その前に改行を挿入した場合にプログラムポイントがもつであろうインデントと等しい必要はありません。これが機能する方法を確認するためには、Cにおける<code class="literal">{</code>の後のSMIEのインデントルールは、<code class="literal">{</code>がインデントする行自体にあるか、あるいは前の行の終端にあるかを配慮しないことが挙げられます。かわりに、これらの異なるケースは、<code class="literal">{</code>の前のインデントを決定するインデントルール内で処理されます。
</p><p>他の重要な考え方として、<span class="emphasis"><em>parent</em></span>の概念があります。あるトークン<span class="emphasis"><em>parent</em></span>は、周囲にある直近の構文構造の代表トークン(head
token)です。たとえば、<code class="literal">else</code>のparentは、それが属する<code class="literal">if</code>であり、<code class="literal">if</code>のparentは周囲を取り囲む構造の先導トークン(lead
token)です。コマンド<code class="literal">backward-sexp</code>は、あるトークンからトークンのparentにジャンプしますが、注意点がいくつかあります。<span class="emphasis"><em>opener</em></span>(<code class="literal">if</code>のような、ある構造を開始するトークン)にたいしては、他のトークンではそのトークンの後のポイントから開始する必要があるのにたいして、opnerではそのトークンの前のポイントから開始する必要があります。<code class="literal">backward-sexp</code>はparentトークンがそのトークンの<span class="emphasis"><em>opener</em></span>の場合はparentトークンの前のポイントで停止し、それ以外ではparentトークンの後のポイントで停止します。
</p><p>SMIEのインデントルールは、2つの引数<em class="replaceable"><code>method</code></em>と<em class="replaceable"><code>arg</code></em>をとる関数により指定されます。ここで<em class="replaceable"><code>arg</code></em>の値と期待されるリターン値は、<em class="replaceable"><code>method</code></em>に依存します。
</p><p><em class="replaceable"><code>method</code></em>は、以下のいずれかを指定できます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">:after</code>:
この場合、<em class="replaceable"><code>arg</code></em>はトークンであり、関数は<em class="replaceable"><code>arg</code></em>の後に使用するインデントにたいする<em class="replaceable"><code>offset</code></em>をリターンすべきである。
</p></li><li class="listitem"><p><code class="literal">:before</code>:
この場合、<em class="replaceable"><code>arg</code></em>はトークンであり、関数は<em class="replaceable"><code>arg</code></em>自体に使用するインデントの<em class="replaceable"><code>offset</code></em>をリターンすべきである。
</p></li><li class="listitem"><p><code class="literal">:elem</code>:
この場合、関数は関数の引数に使用するインデントのオフセット(<em class="replaceable"><code>arg</code></em>が<code class="literal">arg</code>の場合)、または基本的のインデントステップ(<em class="replaceable"><code>arg</code></em>が<code class="literal">basic</code>の場合)、のいずれかをリターンすべきである。
</p></li><li class="listitem"><p><code class="literal">:list-intro</code>:
この場合、<em class="replaceable"><code>arg</code></em>はトークンであり、関数はそのトークンの後が単一の式ではなく、(任意のトークンにより区切られない)式のリストが続く場合は非<code class="literal">nil</code>をリターンすべきである。
</p></li></ul></div><p><em class="replaceable"><code>arg</code></em>がトークンのとき、関数はそのトークンの直前のポイントで呼び出されます。リターン値<code class="literal">nil</code>は常にデフォルトの振る舞いへのフォールバックを意味するので、関数は期待した引数でないときは<code class="literal">nil</code>をリターンするべきです。
</p><p><em class="replaceable"><code>offset</code></em>は、以下のいずれかを指定できます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">nil</code>: デフォルトのインデントルールを使用する。
</p></li><li class="listitem"><p><code class="literal">(column . <em class="replaceable"><code>column</code></em>)</code>: 列<em class="replaceable"><code>column</code></em>にインデントする。
</p></li><li class="listitem"><p><em class="replaceable"><code>number</code></em>: 基本トークン(base token:
<code class="literal">:after</code>にたいするカレントトークンであり、かつ<code class="literal">:before</code>にたいしてparentであるようなトークン)にたいして相対的な、<em class="replaceable"><code>number</code></em>によるオフセット。
</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Indentation-Helpers"/>Helper Functions for Indentation Rules</h3></div></div></div><p>SMIEは、インデントを決定する関数内で使用するために特別にデザインされた、さまざまな関数を提供します(これらの関数のうちのいくつかは、異なるコンテキスト内で使用された場合は中断する)。これらの関数はすべて、プレフィックス<code class="literal">smie-rule-</code>で始まります。
</p><pre class="synopsis"><a id="idm64281552" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-bolp</code></pre><div class="blockquote"><blockquote class="blockquote"><p>カレントトークンが行の先頭にある場合は、非<code class="literal">nil</code>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm64278224" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-hanging-p</code></pre><div class="blockquote"><blockquote class="blockquote"><p>カレントトークンが<span class="emphasis"><em>hanging(ぶら下がり)</em></span>の場合は、非<code class="literal">nil</code>をリターンする。トークンがその行の最後のトークンであり、他のトークンが先行する場合、そのトークンは<span class="emphasis"><em>hanging</em></span>である。行に単独のトークンはhangingではない。
</p></blockquote></div><pre class="synopsis"><a id="idm64274128" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-next-p</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>tokens</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>次のトークンが<em class="replaceable"><code>tokens</code></em>内にある場合は、非<code class="literal">nil</code>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm64269648" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-prev-p</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>tokens</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>前のトークンが<em class="replaceable"><code>tokens</code></em>内にある場合は、非<code class="literal">nil</code>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm64265168" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-parent-p</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>parents</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>カレントトークンのparentが<em class="replaceable"><code>parents</code></em>内にある場合は、非<code class="literal">nil</code>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm64260688" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-sibling-p</code></pre><div class="blockquote"><blockquote class="blockquote"><p>カレントトークンのparentが実際はsibling(兄弟)の場合は、非<code class="literal">nil</code>をリターンする。たとえば<code class="literal">","</code>のparentが直前の<code class="literal">","</code>のような場合が該当する。
</p></blockquote></div><pre class="synopsis"><a id="idm64256336" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-parent</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>offset</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>カレントトークンをparentとアライン(align:
桁揃え)するための適切なオフセットをリターンする。<em class="replaceable"><code>offset</code></em>が非<code class="literal">nil</code>の場合、それは追加オフセットとして適用される整数であること。
</p></blockquote></div><pre class="synopsis"><a id="idm64251856" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-rule-separator</code> <em class="replaceable"><code>method</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>セパレーター(separator)</em></span>としてカレントトークンをインデントする。
</p><p>ここでの<span class="emphasis"><em>セパレーター</em></span>は、周囲を取り囲む何らかの構文構造内でさまざまな要素を区切ることを唯一の目的とするトークンであり、それ自体は何も意味をもたないトークン(通常は抽象構文木内でノードとして存在しない)を意味する。
</p><p>このようなトークンは結合構文をもち、その構文的parentと密に結び付けられることが期待される。典型的な例としては引数リスト内の<code class="literal">","</code>(カッコで括られた内部)、または命令文シーケンス内の<code class="literal">";"</code>(<code class="literal">{...}</code>や<code class="literal">begin...end</code>で括られたブロックの内部)が挙げられる。
</p><p><em class="replaceable"><code>method</code></em>は、‘smie-rules-function’に渡されるメソッド名であること。
</p></blockquote></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Indentation-Example"/>Sample Indentation Rules</h3></div></div></div><p>以下は、インデント関数の例です:
</p><pre class="screen">(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
</pre><p>注意すべき点がいくつかあります:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>最初のcaseは、使用する基本的なインデントの増分を示す。<code class="literal">sample-indent-basic</code>が<code class="literal">nil</code>の場合、SMIEはグローバルセッティング<code class="literal">smie-indent-basic</code>を使用する。メジャーモードがかわりに<code class="literal">smie-indent-basic</code>をバッファーローカルにセットするかもしれないが、これは勧められない。
</p></li><li class="listitem"><p>トークン<code class="literal">","</code>にたいするルールにより、カンマセパレーターが行頭にある場合に、SMIEをより賢明に振る舞わせようとしている。これはセパレーターのインデントを解除(outdent)、カンマの後のコードにアラインされるよう試みる。たとえば:
</p><pre class="screen">x = longfunctionname (
        arg1
      , arg2
    );
</pre></li><li class="listitem"><p><code class="literal">":="</code>の後のインデントのルールは、そうしなければSMIEが<code class="literal">":="</code>を2項演算子として扱い、左の引数に併せて右の引数をアラインするであろうから、このルールが存在する。
</p></li><li class="listitem"><p><code class="literal">"begin"</code>の前のインデントのルールは、バーチャルインデントの使用例である。このルールは<code class="literal">"begin"</code>がhangingのときだけ使用され、これは<code class="literal">"begin"</code>が行頭にないときのみ発生し得る。そのため、これは<code class="literal">"begin"</code>自体のインデントには使用されないが、この<code class="literal">"begin"</code>に関連する何かをインデントするときだけ使用される。このルールは、具体的には以下のフォームを:
</p><pre class="screen">    if x &gt; 0 then begin
            dosomething(x);
        end
</pre><p>以下に変更する
</p><pre class="screen">    if x &gt; 0 then begin
        dosomething(x);
    end
</pre></li><li class="listitem"><p><code class="literal">"if"</code>の前のインデントのルールは<code class="literal">"begin"</code>のインデントルールと似ているが、ここでの目的は<code class="literal">"else
if"</code>を1単位として扱うことにあり、それにより各テストより右にインデントされずに、一連のテストにアラインされる。この関数は<code class="literal">smie-rule-bolp</code>をテストして、<code class="literal">"if"</code>が別の行にないときだけこれを行う。
</p><p><code class="literal">"else"</code>が、それの属する<code class="literal">"if"</code>にたいして常にアラインされ、かつそれが常に行頭であるることが判っている場合は、より効果的なルールを使用できる:
</p><pre class="screen">((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
</pre><p>この式の利点は、これがシーケンスの最初の<code class="literal">"if"</code>まで戻ってすべてをやり直すのではなく、前の<code class="literal">"else"</code>のインデントを再利用することである。
</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="SMIE-Customization"/>Customizing Indentation</h3></div></div></div><p>SMIEにより提供されるインデントを使用するモードを使っている場合は、好みに合わせてインデントをカスタマイズできます。これはモードごと(オプション<code class="literal">smie-config</code>を使用)、またはファイルごと(ファイルローカル変数指定内で関数<code class="literal">smie-config-local</code>を使用)に行うことができます。
</p><pre class="synopsis"><a id="idm64211408" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">smie-config</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このオプションにより、モードごとにインデントをカスタマイズできる。これは<code class="literal">(<em class="replaceable"><code>mode</code></em>
.
<em class="replaceable"><code>rules</code></em>)</code>という形式の要素をもつalistである。rulesの正確な形式については、変数のドキュメントを参照のこと。しかし、コマンド<code class="literal">smie-config-guess</code>を使用したほうが、より簡単に見つけられるかもしれない。
</p></blockquote></div><pre class="synopsis"><a id="idm64178256" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-config-guess</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、好みのスタイルのインデントを生成する、適切セッティングの解決を試みる。あなたのスタイルでインデントされたファイルをvisitしているときに、単にこのコマンドを呼び出せばよい。
</p></blockquote></div><pre class="synopsis"><a id="idm64175440" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-config-save</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">smie-config-guess</code>を使用した後にこのコマンドを呼び出すと、将来のセッション用にセッティングを保存する。
</p></blockquote></div><pre class="synopsis"><a id="idm64172112" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-config-show-indent</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>move</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレント行のインデントに使用されているルールを表示する。
</p></blockquote></div><pre class="synopsis"><a id="idm64168528" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">smie-config-set-indent</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレント行のインデントに合わせて、ローカルルールを追加する。
</p></blockquote></div><pre class="synopsis"><a id="idm64165584" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">smie-config-local</code> <em class="replaceable"><code>rules</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファーにたいするインデントルールとして、<em class="replaceable"><code>rules</code></em>を追加する。これらのルールは、<code class="literal">smie-config</code>オプションにより定義された、任意のモード固有ルールに追加される。特定のファイルにたいしてカスタムインデントルールを指定するには、<code class="literal">eval:
(smie-config-local '(<em class="replaceable"><code>rules</code></em>))</code>の形式のエントリーを、そのファイルのローカル変数に追加する。
</p></blockquote></div></div></div></div></body></html>