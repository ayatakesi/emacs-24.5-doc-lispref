<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 24. Files</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Files"/>Chapter 24. Files</h1></div></div></div><p>このチャプターでは検索、作成、閲覧、保存、その他ファイルとディレクトリーにたいして機能する、Emacs
Lispの関数および変数について説明します。その他のいくつかのファイルに関する関数については<a class="link" href="ch27.html" title="Chapter 26. Buffers">Buffers</a>、バックアップとauto-save(自動保存)に関する関数については<a class="link" href="ch26.html" title="Chapter 25. Backups and Auto-Saving">Backups
and Auto-Saving</a>で説明されています。
</p><p>ファイル関数の多くは、ファイル名であるような引数を1つ以上とります。このファイル名は文字列です。これらの関数のほとんどは、関数<code class="literal">expand-file-name</code>を使用してファイル名引数を展開するので、<code class="filename">~</code>は相対ファイル名(<code class="filename">../</code>を含む)として正しく処理されます。<a class="link" href="ch25s08.html#File-Name-Expansion" title="Functions that Expand Filenames">File
Name Expansion</a>を参照してください。
</p><p>加えて、特定の<em class="firstterm">magic</em>ファイル名は特別に扱われます。たとえば、リモートファイル名が指定された際、Emacsは適切なプロトコルを通じて、ネットワーク越しにファイルにアクセスします。section “Remote Files” in <em class="citetitle">The GNU Emacs
Manual</em>を参照してください。この処理は非常に低いレベルで行われるので、注記されたものを除き、このチャプターで説明するすべての関数が、ファイル名引数としてmagicファイル名を受け入れると想定しても良いでしょう。詳細は、See <a class="link" href="ch25s11.html" title="Making Certain File Names “Magic”">Magic
File Names</a>を参照してください。
</p><p>ファイルI/O関数がLispエラーをシグナルする際、通常はコンディション<code class="literal">file-error</code>を使用します(<a class="link" href="ch11s05.html#Handling-Errors" title="Writing Code to Handle Errors">Handling
Errors</a>を参照)。ほとんどの場合、オペレーティングシステムからロケール<code class="literal">system-messages-locale</code>に応じたエラーメッセージが取得され、コーディングシステム<code class="literal">locale-coding-system</code>を使用してデコードされます(<a class="link" href="ch33s12.html" title="Locales">Locales</a>を参照)。
</p><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Visiting-Files"/>Visiting Files</h1></div></div></div><a id="idm63768272" class="indexterm"/><a id="idm63755216" class="indexterm"/><p>ファイルのvisitとは、ファイルをバッファーに読み込むことを意味します。一度これを行うと、わたしたちはバッファーがファイルを<em class="firstterm">visit(訪問)</em>していると言い、ファイルのことをバッファーの“visit”されたファイルと呼んでいます。
</p><p>ファイルとバッファーは、2つの異なる事柄です。ファイルとは、(削除しない限り)コンピューター内に永続的に記録された情報です。一方バッファーとは、編集セッションの終了(またはバッファーのkill)とともに消滅する、Emacs内部の情報です。あるバッファーがファイルをvistしているとき、バッファーぬはファイルからコピーされた情報が含まれます。編集コマンドにより変更されるのは、バッファー内のコピーです。バッファーへの変更によりファイルは変更されません。その変更を永続化させるには、バッファーを<em class="firstterm">保存(save)</em>しなければなりません。これは変更されたバッファーのコンテンツをファイルにコピーして戻すことを意味します。
</p><p>ファイルとバッファーは異なるにも関わらず、人はバッファーという意味でファイルを呼んだり、その逆を行うことが多々あります。実際のところ、“わたしは間もなく同じ名前のファイルに保存するバッファーを編集している”ではなく、“わたしはファイルを編集している”と言います。人間がこの違いを明示する必要は、通常はありません。しかし、コンピュータープログラムに対処する際は、この違いを心に留めておくのが良いでしょう。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Visiting-Functions"/>Functions for Visiting Files</h2></div></div></div><a id="idm63751632" class="indexterm"/><a id="idm63750864" class="indexterm"/><p>このセクションでは、ファイルのvisitに通常使用される関数を説明します。歴史的な理由により、これらの関数は‘<code class="literal">visit-</code>’ではなく、‘<code class="literal">find-</code>’で始まる名前をもちます。バッファーをvisitしているファイルの名前へのアクセスや、visitされたファイル名から既存のバッファーを見つける関数および変数については、<a class="link" href="ch27s04.html" title="Buffer File Name">Buffer
File Name</a>を参照してください。
</p><p>Lispプログラム内では、ファイル内容を見たいものの変更したくない場合はテンポラリーバッファー(temporary buffer:
一時的なバッファー)で<code class="literal">insert-file-contents</code>を使用例するのが、もっとも高速な方法です。時間を要するファイルのvisitは必要ありません。<a class="link" href="ch25s03.html" title="Reading from Files">Reading
from Files</a>を参照してください。
</p><pre class="synopsis"><a id="idm63746512" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">find-file</code> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>wildcards</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、ファイル<em class="replaceable"><code>filename</code></em>をvisitしているバッファーを選択する。visitしている既存のバッファーがあればそのバッファーを使用し、なければバッファーを新たに作成して、そのバッファーにファイルを読み込む。これはそのバッファーをリターンする。
</p><p>技術的な詳細を別とすると、<code class="literal">find-file</code>関数のbodyは基本的には以下と等価である:
</p><pre class="screen">(switch-to-buffer (find-file-noselect filename nil nil wildcards))
</pre><p>(<a class="link" href="ch28s11.html" title="Switching to a Buffer in a Window">Switching Buffers</a>の<code class="literal">switch-to-buffer</code>を参照されたい。)
</p><p><em class="replaceable"><code>wildcards</code></em>が非<code class="literal">nil</code>(これはinteractiveに呼び出された場合は常にtrueである)の場合、<code class="literal">find-file</code>は<em class="replaceable"><code>filename</code></em>内のワイルドカード文字を展開して、マッチするすべてのファイルをvisitする。
</p><p><code class="literal">find-file</code>がinteractiveに呼び出された際は、ミニバッファー内で<em class="replaceable"><code>filename</code></em>の入力を求める。
</p></blockquote></div><pre class="synopsis"><a id="idm63736144" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">find-file-literally</code> <em class="replaceable"><code>filename</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、<code class="literal">find-file</code>が行うように<em class="replaceable"><code>filename</code></em>をvisitするが、フォーマット変換(<a class="link" href="ch25s12.html" title="File Format Conversion">Format
Conversion</a>を参照)、文字コード変換(<a class="link" href="ch33s10.html" title="Coding Systems">Coding Systems</a>を参照)、EOL変換(<a class="link" href="ch33s10.html#Coding-System-Basics" title="Basic Concepts of Coding Systems">End of line
conversion</a>を参照)を何も行わない。ファイルをvisitしているバッファーはunibyteになり、ファイル名とは無関係にバッファーのメジャーモードはFundamentalモードになる。ファイル内で指定されたファイルローカル変数(<a class="link" href="ch12s11.html" title="File Local Variables">File
Local
Variables</a>を参照)は無視され、自動的な解凍と<code class="literal">require-final-newline</code>によるファイル終端への改行追加(<a class="link" href="ch25s02.html" title="Saving Buffers">require-final-newline</a>を参照)も無効になる。
</p><p>Emacsがすでにリテラリー(literally:
文字通り、そのまま)でない方法で同じファイルをvisitしているバッファーをもつ場合、Emacsはその同じファイルをリテラリーにvisitせず、単に既存のバッファーに切り替わることに注意されたい。あるファイルのコンテンツにたいして、確実にリテラリーにアクセスしたい場合は、テンポラリーバッファーを作成し、<code class="literal">insert-file-contents-literally</code>を使用してファイルのコンテンツを読み込むべきである(<a class="link" href="ch25s03.html" title="Reading from Files">Reading
from Files</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm63723472" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">find-file-noselect</code> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>nowarn</code></em> <em class="replaceable"><code>rawfile</code></em> <em class="replaceable"><code>wildcards</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、ファイルをvisitするすべての関数の要である。これは、ファイル<em class="replaceable"><code>filename</code></em>をvisitしているバッファーをリターンする。望むならそのバッファーをカレントにしたり、あるウィンドウ内に表示することができるだろうが、この関数はそれを行わない。
</p><p>関数は、既存のバッファーがあればそれをリターンし、なければ新たにバッファーを作成し、それにファイルを読み込む。<code class="literal">find-file-noselect</code>が既存のバッファーを使用する際は、まずファイルがそのバッファーに最後にvisit、または保存したときから変更されていないことを検証する。ファイルが変更されている場合、この関数は変更されたファイルを再読み込みするかどうかをユーザーに尋ねる。ユーザーが‘<code class="literal">yes</code>’と応えた場合、以前に行われたそのバッファー内での編集は失われる。
</p><p>ファイルの読み込みは、EOL変換、フォーマット変換(<a class="link" href="ch25s12.html" title="File Format Conversion">Format
Conversion</a>を参照)を含む、ファイルコンテンツのデコードを要する(<a class="link" href="ch33s10.html" title="Coding Systems">Coding
Systems</a>を参照)。<em class="replaceable"><code>wildcards</code></em>が非<code class="literal">nil</code>の場合、<code class="literal">find-file-noselect</code>は<em class="replaceable"><code>filename</code></em>内のワイルドカード文字を展開して、マッチするすべてのファイルをvisitする。
</p><p>この関数は、オプション引数<em class="replaceable"><code>nowarn</code></em>が<code class="literal">nil</code>の場合は、さまざまな特殊ケースにおいて、警告メッセージ(warning
message)、および注意メッセージ(advisory
message)を表示する。たとえば、関数がバッファーの作成を必要とし、かつ<em class="replaceable"><code>filename</code></em>という名前のファイルが存在しない場合は、エコーエリア内にメッセージ‘<code class="literal">(New
file)</code>’を表示して、そのバッファーを空のままに留める。
</p><p><code class="literal">find-file-noselect</code>関数は通常、ファイルを読み込んだ後に<code class="literal">after-find-file</code>を呼び出す(<a class="link" href="ch25.html#Subroutines-of-Visiting" title="Subroutines of Visiting">Subroutines
of
Visiting</a>を参照)。この関数はバッファーのメジャーモードのセット、ローカル変数のパース、正にvisitしたファイルより新しいauto-saveファイルが存在する場合のユーザーへの警告を行い、<code class="literal">find-file-hook</code>内の関数を実行することにより終了する。
</p><p>オプション引数<em class="replaceable"><code>rawfile</code></em>が非<code class="literal">nil</code>の場合、<code class="literal">after-find-file</code>は呼び出されず、失敗時に<code class="literal">find-file-not-found-functions</code>は呼び出されない。さらに、非<code class="literal">nil</code>値の<em class="replaceable"><code>rawfile</code></em>は、コーディングシステム変換およびフォーマット変換を抑制する。
</p><p><code class="literal">find-file-noselect</code>関数は、通常はファイル<em class="replaceable"><code>filename</code></em>をvisitしているバッファーをリターンする。しかし、ワイルドカードが実際に使用、展開された場合は、それらのファイルをvisitしているバッファーのリストをリターンする。
</p><pre class="screen">(find-file-noselect "/etc/fstab")
     ⇒ #&lt;buffer fstab&gt;
</pre></blockquote></div><pre class="synopsis"><a id="idm63704400" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">find-file-other-window</code> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>wildcards</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、ファイル<em class="replaceable"><code>filename</code></em>をvisitしているバッファーを選択するが、選択されたウィンドウではない他のウィンドウでこれを行う。これは、別の既存ウィンドウを使用したり、ウィンドウを分割するかもしれない。<a class="link" href="ch28s11.html" title="Switching to a Buffer in a Window">Switching
Buffers</a>lを参照のこと。
</p><p>このコマンドがinteractiveに呼び出された際は、<em class="replaceable"><code>filename</code></em>の入力を求める。
</p></blockquote></div><pre class="synopsis"><a id="idm63698768" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">find-file-read-only</code> <em class="replaceable"><code>filename</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>wildcards</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、<code class="literal">find-file</code>のようにファイル<em class="replaceable"><code>filename</code></em>をvisitしているバッファーを選択するが、そのバッファーを読み取り専用(read-only)とマークする。関連する関数および変数については、<a class="link" href="ch27s07.html" title="Read-Only Buffers">Read
Only Buffers</a>を参照のこと。
</p><p>このコマンドがinteractiveに呼び出された際は、<em class="replaceable"><code>filename</code></em>の入力を求める。
</p></blockquote></div><pre class="synopsis"><a id="idm63692624" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">find-file-wildcards</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>の場合、各種<code class="literal">find-file</code>コマンドはワイルドカード文字をチェックして、それらにマッチするすべてのファイルをvisitする(interactiveに呼び出されたとき、または<em class="replaceable"><code>wildcards</code></em>引数が非<code class="literal">nil</code>のとき)。このオプションが<code class="literal">nil</code>の場合、<code class="literal">find-file</code>コマンドはそれらの<em class="replaceable"><code>wildcards</code></em>引数を無視して、ワイルドカード文字を特別に扱うことは決してない。
</p></blockquote></div><pre class="synopsis"><a id="idm63686608" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">find-file-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、ファイルがvisitされた後に呼び出される、関数のリストである。ファイルのローカル変数指定は、(もしあれば)このフックが実行される前に処理されるだろう。フック関数実行時は、そのファイルをvisitしているバッファーがカレントになる。
</p><p>この変数はノーマルフックである。<a class="link" href="ch23.html#Hooks" title="Hooks">Hooks</a>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm63683024" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">find-file-not-found-functions</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、<code class="literal">find-file</code>または<code class="literal">find-file-noselect</code>が存在しないファイル名を受け取った際に呼び出される、関数のリストである。存在しないファイルを検知すると、<code class="literal">find-file-noselect</code>は直ちにこれらの関数を呼び出す。これらのうち、いずれかが非<code class="literal">nil</code>をリターンするまで、リストの順に関数を呼び出す。<code class="literal">buffer-file-name</code>はすでにセットアップ済みである。
</p><p>関数の値が使用され、多くの場合いくつかの関数だけが呼び出されるので、これはノーマルフックではない。
</p></blockquote></div><pre class="synopsis"><a id="idm63673296" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">find-file-literally</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このバッファーローカル変数が非<code class="literal">nil</code>値にセットされた場合、<code class="literal">save-buffer</code>はあたかもそのバッファーがリテラリー、つまり何の変換も行わずにファイルをvisitしていたかのように振る舞う。コマンド<code class="literal">find-file-literally</code>は、この変数のローカル値をセットするが、その他の等価な関数およびコマンドも、たとえばファイル終端への改行の自動追加を避けるために、同様にこれを行うことができる。この変数は恒久的にローカルなので、メジャーモードの変更により影響を受けない。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Subroutines-of-Visiting"/>Subroutines of Visiting</h2></div></div></div><p><code class="literal">find-file-noselect</code>関数は、2つの重要なサブルーチン<code class="literal">create-file-buffer</code>および<code class="literal">after-find-file</code>を使用します。これらはユーザーのLispコードでも役に立つことがあります。このセクションでは、それらの使い方について説明します。
</p><pre class="synopsis"><a id="idm63665488" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">create-file-buffer</code> <em class="replaceable"><code>filename</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>filename</code></em>のvisitにたいして適切な名前のバッファーを作成して、それをリターンする。これは<em class="replaceable"><code>filename</code></em>(ディレクトリー含まず)の名前がフリーならバッファー名にそれを使用し、フリーでなければ未使用の名前を取得するために‘<code class="literal">&lt;2&gt;</code>’のような文字列を付加する。<a class="link" href="ch27s09.html" title="Creating Buffers">Creating
Buffers</a>も参照のこと。<code class="filename">uniquify</code>ライブラリーは、この関数の結果に影響を与えることに注意されたい。section “Uniquify” in <em class="citetitle">The GNU Emacs Manual</em>を参照のこと。
</p><p><span class="bold"><strong>注意してください:</strong></span>
<code class="literal">create-file-buffer</code>はファイルに新たなバッファーを<span class="emphasis"><em>関連付けません</em></span>。バッファーの選択もせず、さらにデフォルトのメジャーモードも使用しません。
</p><pre class="screen">(create-file-buffer "foo")
     ⇒ #&lt;buffer foo&gt;
</pre><pre class="screen">(create-file-buffer "foo")
     ⇒ #&lt;buffer foo&lt;2&gt;&gt;
</pre><pre class="screen">(create-file-buffer "foo")
     ⇒ #&lt;buffer foo&lt;3&gt;&gt;
</pre><p>この関数は、<code class="literal">find-file-noselect</code>により使用される。この関数自身は<code class="literal">generate-new-buffer</code>を使用する(<a class="link" href="ch27s09.html" title="Creating Buffers">Creating
Buffers</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm63642192" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">after-find-file</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>error</code></em> <em class="replaceable"><code>warn</code></em> <em class="replaceable"><code>noauto</code></em> <em class="replaceable"><code>after-find-file-from-revert-buffer</code></em> <em class="replaceable"><code>nomodes</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、バッファーのメジャーモードをセットして、ローカル変数をパースする(<a class="link" href="ch23s02.html#Auto-Major-Mode" title="How Emacs Chooses a Major Mode">Auto Major
Mode</a>を参照)。これは<code class="literal">find-file-noselect</code>、およびデフォルトのリバート関数(<a class="link" href="ch26s03.html" title="Reverting">Reverting</a>を参照)により呼び出される。
</p><a id="idm63635664" class="indexterm"/><a id="idm63634896" class="indexterm"/><p>ファイルが存在しない理由によりファイルの読み込みがエラーを受け取るが、ディレクトリーは存在する場合、呼び出し側は<em class="replaceable"><code>error</code></em>にたいして非<code class="literal">nil</code>値を綿すべきである。この場合、<code class="literal">after-find-file</code>は警告‘<code class="literal">(New
file)</code>’を発する。より深刻なエラーにたいしては、呼び出し側は通常は<code class="literal">after-find-file</code>を呼び出すべきでない。
</p><p><em class="replaceable"><code>warn</code></em>が非<code class="literal">nil</code>の場合、もしauto-saveファイルが存在し、かつそれがvisitされているファイルより新しいなら、この関数は警告を発する。
</p><p><em class="replaceable"><code>noauto</code></em>が非<code class="literal">nil</code>の場合、それはAuto-Saveモードを有効、または無効にしないことを告げる。以前にAuto-Saveモードが有効ならば、有効のまま留まる。
</p><p><em class="replaceable"><code>after-find-file-from-revert-buffer</code></em>が非<code class="literal">nil</code>の場合、それはこの関数が<code class="literal">revert-buffer</code>から呼び出されたことを意味する。これに直接的な効果はないが、モード関数およびフック関数の中には、この変数の値をチェックするものがいくつかある。
</p><p><em class="replaceable"><code>nomodes</code></em>が非<code class="literal">nil</code>の場合、それはバッファーのメジャーモードを変更せず、ファイル内のローカル変数指定を処理せず、<code class="literal">find-file-hook</code>を実行しないことを意味する。この機能は、あるケースにおいて<code class="literal">revert-buffer</code>により使用される。
</p><p><code class="literal">after-find-file</code>が最後に行うのは、リスト<code class="literal">find-file-hook</code>内のすべての関数を呼び出すことである。
</p></blockquote></div></div></div></div></body></html>