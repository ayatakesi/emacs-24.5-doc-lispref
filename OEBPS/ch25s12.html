<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>File Format Conversion</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Format-Conversion"/>File Format Conversion</h1></div></div></div><a id="idm66371792" class="indexterm"/><a id="idm66371024" class="indexterm"/><a id="idm66370256" class="indexterm"/><a id="idm66369488" class="indexterm"/><a id="idm66368720" class="indexterm"/><p>Emacsは、バッファー内のデータ(テキスト、テキストプロパティ、あるいはその他の情報)と、ファイル名に格納するのに適した表現との間で双方向の変換をするために、複数のステップを処理します。このセクションでは、この<em class="firstterm">フォーマット変換(format
conversion)</em>を行う基本的な関数、すなわちファイルをバッファーに読み込む<code class="literal">insert-file-contents</code>と、バッファーをファイルに書き込む<code class="literal">write-region</code>を説明します。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Format-Conversion-Overview"/>Overview</h2></div></div></div><p>関数<code class="literal">insert-file-contents</code>:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>最初に、ファイルからバイトをバッファーに挿入し、
</p></li><li class="listitem"><p>バイトを適切な文字にデコードした後、
</p></li><li class="listitem"><p><code class="literal">format-alist</code>のエントリーにより定義されているようにフォーマット処理して、
</p></li><li class="listitem"><p><code class="literal">after-insert-file-functions</code>内の関数を呼び出す。
</p></li></ul></div><p>関数<code class="literal">write-region</code>:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>最初に、<code class="literal">write-region-annotate-functions</code>内の関数を呼び出し、
</p></li><li class="listitem"><p><code class="literal">format-alist</code>のエントリーにより定義されているようにフォーマット処理して、
</p></li><li class="listitem"><p>文字を適切なバイトにエンコードした後、
</p></li><li class="listitem"><p>そのバイトでファイルを変更する。
</p></li></ul></div><p>これは、もっとも低レベルでの操作を対照的に示したもので、対象の読み取りと書き込みの処理が逆順で対応しています。このセクションの残りでは、上記で名前のでた3つの変数を取り囲む2つの機能と、いくつかの関連する関数を説明します。文字のエンコードとデコードについての詳細は、<a class="link" href="ch33s10.html" title="Coding Systems">Coding
Systems</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Format-Conversion-Round_002dTrip"/>Round-Trip Specification</h2></div></div></div><p>読み取りと書き込みのもっとも一般的な機能は、変数<code class="literal">format-alist</code>で制御されます。これは<em class="firstterm">ファイルフォーマット(file
format)</em>仕様のリストで、Emacsバッファー内のデータにたいして、ファイル内で使用されるテキスト表現を記述します。読み取りと書き込みの仕様記述はペアーになっており、わたしたちがそれを“ラウンドトリップ(round-trip)”仕様と呼ぶのは、これが理由です(非ペアー仕様については、see <a class="link" href="ch25s12.html#Format-Conversion-Piecemeal" title="Piecemeal Specification">Format
Conversion Piecemeal</a>を参照)。
</p><pre class="synopsis"><a id="idm66337872" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">format-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このリストには、定義されるファイルフォーマットごとに、1つのフォーマット定義が含まれる。フォーマット定義はそれぞれ、以下の形式のリストである:
</p><pre class="screen">(<em class="replaceable"><code>name</code></em> <em class="replaceable"><code>doc-string</code></em> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>from-fn</code></em> <em class="replaceable"><code>to-fn</code></em> <em class="replaceable"><code>modify</code></em> <em class="replaceable"><code>mode-fn</code></em> <em class="replaceable"><code>preserve</code></em>)
</pre></blockquote></div><a id="idm66327760" class="indexterm"/><p>以下は、フォーマット定義内で要素がもつ意味である:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em>
</span></dt><dd><p>フォーマットの名前。
</p></dd><dt><span class="term"><em class="replaceable"><code>doc-string</code></em>
</span></dt><dd><p>フォーマットのドキュメント文字列。
</p></dd><dt><span class="term"><em class="replaceable"><code>regexp</code></em>
</span></dt><dd><p>このフォーマットで表現されるファイルの認識に使用される正規表現。<code class="literal">nil</code>の場合、フォーマットが自動的に適用されることは決してない。
</p></dd><dt><span class="term"><em class="replaceable"><code>from-fn</code></em>
</span></dt><dd><p>このフォーマットのデータをデコードする、(ファイルデータを通常のEmacsデータ表現に変換するための)シェルコマンド、または関数。
</p><p>シェルコマンドは文字列として表され、Emacsはそのコマンドを、変換処理のためのフィルターとして実行する。
</p><p><em class="replaceable"><code>from-fn</code></em>が関数の場合、それは変換するべきバッファー部分を指定する2つの引数、<em class="replaceable"><code>begin</code></em>と<em class="replaceable"><code>end</code></em>で呼び出される。これは、インプレースでテキストを編集することにより変換を行うべきである。これはテキスト長を変更する可能性があるので、<em class="replaceable"><code>from-fn</code></em>は変更されたend位置をリターンすること。
</p><p>ファイルの先頭が、この変換により<em class="replaceable"><code>regexp</code></em>にマッチしないようにするのは、<em class="replaceable"><code>from-fn</code></em>の役目の1つである。そうでないと、おそらく再度変換が呼び出される。
</p></dd><dt><span class="term"><em class="replaceable"><code>to-fn</code></em>
</span></dt><dd><p>このフォーマットのデータをエンコード、すなわち通常のEmacsデータ表現をこのフォーマットに変換するためのシェルコマンド、または関数。
</p><p><em class="replaceable"><code>to-fn</code></em>が文字列の場合、それはシェルコマンドである。Emacsは変換処理のためのフィルターとして、このコマンドを実行する。
</p><p><em class="replaceable"><code>to-fn</code></em>が関数の場合、それは3つの引数で呼び出される。<em class="replaceable"><code>begin</code></em>と<em class="replaceable"><code>end</code></em>は変換されるべきバッファー部分、<em class="replaceable"><code>buffer</code></em>でそれがどのバッファーかを指定する。変換を行うには、2つの方法がある:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>そのバッファー内でインプレースで編集を行う。この場合、<em class="replaceable"><code>to-fn</code></em>は変更にしたがい、テキスト範囲のend位置をリターンするべきである。
</p></li><li class="listitem"><p>注釈(annotation)のリストをリターンする。これは、<code class="literal">(<em class="replaceable"><code>position</code></em>
.
<em class="replaceable"><code>string</code></em>)</code>という形式の要素をもつリストで、<em class="replaceable"><code>position</code></em>は書き込まれるテキスト内での相対位置を指定する整数、<em class="replaceable"><code>string</code></em>はそこに追加される注釈である。このリストは、<em class="replaceable"><code>to-fn</code></em>がそれをリターンする際、位置順でソートされていなければならない。
</p><p><code class="literal">write-region</code>が実際にバッファーからファイルにテキストを書き込む際には、指定された注釈を対応する位置に混合する。これはすべて、バッファーを変更せずに行われる。
</p></li></ul></div></dd><dt><span class="term"><em class="replaceable"><code>modify</code></em>
</span></dt><dd><p>フラグ。エンコード関数がバッファーを変更する場合は<code class="literal">t</code>、注釈リストをリターンすることにより機能する場合は<code class="literal">nil</code>。
</p></dd><dt><span class="term"><em class="replaceable"><code>mode-fn</code></em>
</span></dt><dd><p>このフォーマットから変換されたファイルをvisit後に呼び出される、マイナーモード関数。この関数は1つの引数で呼び出され、それが整数1の場合、マイナーモード関数はそのモードを有効にする。
</p></dd><dt><span class="term"><em class="replaceable"><code>preserve</code></em>
</span></dt><dd><p>フラグ。<code class="literal">format-write-file</code>が<code class="literal">buffer-file-format</code>からこのフォーマットを取り除くべきでない場合は<code class="literal">t</code>。
</p></dd></dl></div><p>関数<code class="literal">insert-file-contents</code>は、指定されたファイルを読み込む際にファイルフォーマットを自動的に認識します。これは、フォーマット定義の正規表現にたいしてファイルの先頭テキストをチェックして、マッチが見つかった場合は、そのフォーマットにたいするデコード関数を呼び出します。その後は再度、既知のフォーマットすべてをチェックします。適用できるフォーマットがない間は、チェックを続行します。
</p><p><code class="literal">find-file-noselect</code>、またはそれを使用するコマンドでファイルをvisitすることにより、同じように変換が行われます(内部で<code class="literal">insert-file-contents</code>を呼び出すため)。さらに、それをデコードする各フォーマットのモード関数も呼び出します。これは、バッファーローカル変数<code class="literal">buffer-file-format</code>内に、フォーマット名のリストを格納します。
</p><pre class="synopsis"><a id="idm66280272" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">buffer-file-format</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、visitしているファイルのフォーマットを表す。より正確には、これはカレントバッファーのファイルをvisitに起因するデコードのファイルフォーマット名のリストである。これは、すべてのバッファーにたいして、常にローカルである。
</p></blockquote></div><p><code class="literal">write-region</code>がデータをファイルに書き込む際には、まず<code class="literal">buffer-file-format</code>にリストされたフォーマットにたいするエンコード関数を、リスト内での出現順に呼び出します。
</p><pre class="synopsis"><a id="idm66255824" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">format-write-file</code> <em class="replaceable"><code>file</code></em> <em class="replaceable"><code>format</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>confirm</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレントバッファーのコンテンツを、フォーマット名のリスト<em class="replaceable"><code>format</code></em>にもとづいたフォーマットで、ファイル<em class="replaceable"><code>file</code></em>に書き込む。これは<em class="replaceable"><code>format</code></em>を起点に、<code class="literal">buffer-file-format</code>の値から<em class="replaceable"><code>preserve</code></em>フラグ(上記参照)が非<code class="literal">nil</code>の要素にたいして、それがまだ<em class="replaceable"><code>format</code></em>内に存在しない場合は、任意の個数それらを追加する。その後、将来の保存においてデフォルトとなるよう、このフォーマットで<code class="literal">buffer-file-format</code>を更新する。<em class="replaceable"><code>format</code></em>引数を除き、このコマンドは<code class="literal">write-file</code>と似ている。特に、<em class="replaceable"><code>confirm</code></em>は<code class="literal">write-file</code>での対応する引数と、意味およびinteractiveでの扱いが同じである。<a class="link" href="ch25s02.html#Definition-of-write_002dfile">Definition
of write-file</a>を参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm66245712" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">format-find-file</code> <em class="replaceable"><code>file</code></em> <em class="replaceable"><code>format</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、ファイル<em class="replaceable"><code>file</code></em>を探して、それをフォーマット<em class="replaceable"><code>format</code></em>にしたがって変換する。これは、後でそのバッファーを保存する場合に、<em class="replaceable"><code>format</code></em>をデフォルトにすることも行う。
</p><p>引数<em class="replaceable"><code>format</code></em>は、フォーマット名のリストである。<em class="replaceable"><code>format</code></em>が<code class="literal">nil</code>の場合、何の変換も行われない。interactiveに呼び出した場合は、<em class="replaceable"><code>format</code></em>にたいして単に<span class="keycap"><strong>RET</strong></span>をタイプすると、<code class="literal">nil</code>が指定される。
</p></blockquote></div><pre class="synopsis"><a id="idm66237904" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">format-insert-file</code> <em class="replaceable"><code>file</code></em> <em class="replaceable"><code>format</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>beg</code></em> <em class="replaceable"><code>end</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、ファイル<em class="replaceable"><code>file</code></em>のコンテンツを、フォーマット<em class="replaceable"><code>format</code></em>にしたがって変換して挿入する。<em class="replaceable"><code>beg</code></em>と<em class="replaceable"><code>end</code></em>が非<code class="literal">nil</code>の場合、それは<code class="literal">insert-file-contents</code>と同様、ファイルのどの部分を読み込むかを指定する(<a class="link" href="ch25s03.html" title="Reading from Files">Reading
from Files</a>を参照)。
</p><p>リターン値は、絶対ファイル名のリスト、および挿入されたデータの長さ(変換後)であり、これは<code class="literal">insert-file-contents</code>がリターンするものと同様である。
</p><p>引数<em class="replaceable"><code>format</code></em>は、フォーマット名のリストである。<em class="replaceable"><code>format</code></em>が<code class="literal">nil</code>の場合、何の変換も行われない。interactiveに呼び出した場合は、<em class="replaceable"><code>format</code></em>にたいして単に<span class="keycap"><strong>RET</strong></span>をタイプすると、<code class="literal">nil</code>が指定される。
</p></blockquote></div><pre class="synopsis"><a id="idm66226128" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">buffer-auto-save-file-format</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、自動保存(auto-saving)にたいして使用するフォーマットを指定する。値は<code class="literal">buffer-file-format</code>と同様、ファイル名のリストであるが、これはauto-saveファイルへの書き込みで、<code class="literal">buffer-file-format</code>のかわりに使用される。値が<code class="literal">t</code>(デフォルト)の場合、自動保存は当バッファーの通常の保存時と同じフォーマットを使用する。この変数は、すべてのバッファーにおいて、常にバッファーローカルである。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Format-Conversion-Piecemeal"/>Piecemeal Specification</h2></div></div></div><p>前のサブセクション(<a class="link" href="ch25s12.html#Format-Conversion-Round_002dTrip" title="Round-Trip Specification">Format Conversion
Round-Trip</a>を参照)で説明したラウンドトリップ指定とは対照的に、変数<code class="literal">after-insert-file-functions</code>と<code class="literal">write-region-annotate-functions</code>を使用して、読み取りと書き込みの変換を個別に制御できます。
</p><p>変換は、ある表現を起点として、他の表現を生成します。これを行う変換が1つだけのときは、何を起点とするかに関して競合は存在しません。しかし、複数の変換呼び出しが存在する場合、同じデータを起点にする必要がある2つの変換の間に、競合が発生するかもしれません。
</p><p>この状況を理解するには、<code class="literal">write-region</code>中のテキストプロパティの変換コンテキストが最善です。たとえば、あるバッファーの位置42の文字が‘<code class="literal">X</code>’で、それのテキストプロパティが<code class="literal">foo</code>だとします。<code class="literal">foo</code>にたいする変換が、たとえばそのバッファーに‘<code class="literal">FOO:</code>’を挿入することにより行われる場合、それは位置42の文字‘<code class="literal">X</code>’を‘<code class="literal">F</code>’に変更します。そして次の変換は、間違ったデータを起点に開始されるでしょう。
</p><p>競合を避けるためには、協調的な変換がバッファーを変更せずに、<em class="replaceable"><code>position</code></em>昇順でソートされた、<code class="literal">(<em class="replaceable"><code>position</code></em>
. <em class="replaceable"><code>string</code></em>)</code>という形式の要素をもつリストを、<em class="firstterm">注釈(annotations)</em>に指定します。
</p><p>2つ以上の変換が存在する場合、<code class="literal">write-region</code>はそれらの注釈を、1つのソート済みリストに破壊的にマージします。後でそのバッファーのテキストを実際にファイルに書き込む際に、対応する位置にある指定された注釈を混合します。これはすべて、バッファーを変更せずに行われます。
</p><p>これとは対照的に、読み取り時にはそのテキストの混合された注釈は、即座に処理されます。<code class="literal">insert-file-contents</code>は、変更される何らかのテキストの先頭にポイントをセットしてから、そのテキストの長さで変換関数を呼び出します。これらの関数は常に、挿入されるテキストの先頭のポイントをリターンするべきです。最初の変換により注釈が削除されても、その後の変換が誤って処理することはないので、このアプローチは読み取りに際しては正しく機能します。すべての変換関数は、それが認識する注釈のスキャン、その注釈の削除、バッファーテキストの変更(たとえばテキストプロパティのセット等)、およびそれらの変更に由来する更新されたテキスト長のリターンを行うべきです。１つの関数によりリターンされた値は、次の関数への引数になります。
</p><pre class="synopsis"><a id="idm66209616" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">write-region-annotate-functions</code></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">write-region</code>にたいして呼び出す、関数のリスト。リスト内の各関数は、書き込まれるリージョンの開始と終了の、2つの引数で呼び出される。これらの関数は、そのバッファーのコンテンツを変更するべきではない。かわりに注釈をリターンすること。
</p><p>特別なケースとして、関数がカレントと異なるバッファーをリターンするかもしれない。Emacsはこれを、カレントバッファーが出力される変更されたテキストを含むものとして理解する。つまり、Emacsは<code class="literal">write-region</code>呼び出しの引数<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>を、新たなバッファーの<code class="literal">point-min</code>と<code class="literal">point-max</code>に変更して与える。さらに、以前のすべての注釈はこの関数により処理されるので、Emacsはそれらの破棄も行う。
</p></blockquote></div><pre class="synopsis"><a id="idm66203856" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">write-region-post-annotation-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値が非<code class="literal">nil</code>の場合、それは関数であること。この関数は、<code class="literal">write-region</code>完了後に引数なしで呼び出される。
</p><p><code class="literal">write-region-annotate-functions</code>内のある関数がカレントと異なるバッファーをリターンした場合、Emacsは<code class="literal">write-region-post-annotation-function</code>を複数回呼び出す。Emacsは最後にカレントだったバッファーでそれを呼び出し、その前にカレントだったバッファーで再度これを呼び出す、...のようにして元のバッファーに戻る。
</p><p>したがって、<code class="literal">write-region-annotate-functions</code>内の関数は、バッファーを作成して、<code class="literal">kill-buffer</code>のそのバッファーでのローカル値にこの変数を与え、変更されたテキストでそのバッファーをセットアップして、そのバッファーをカレントにすることができる。そのバッファーは、<code class="literal">write-region</code>完了後にkillされるだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm66196944" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">after-insert-file-functions</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このリスト内の各関数は、挿入されるテキストの先頭にポイントがある状態で、挿入される文字数を１つの引数として、<code class="literal">insert-file-contents</code>により呼び出される。すべての関数はポイントを未変更のまま、その関数によって変更された、挿入後テキストの新たな文字数をリターンするべきである。
</p></blockquote></div><p>わたしたちは、ユーザーがファイル内にテキストプロパティを格納したりそれらを取得するために、そしてさまざまなデータフォーマットを体験することにより、適切なフォーマットを見つけるために、これらのフックを使用してLispプログラムを記述することを推奨します。最終的には、わたしたちがEmacs内にインストールできる、良質で汎用性のある拡張をユーザーが開発することを望みます。
</p><p>わたしたちは、テキストプロパティの名前や値として、任意のLispオブジェクトの処理を試みることは推奨しません —
なぜなら汎用的なプログラムはおそらく記述が困難で、かつ低速だからです。かわりに、十分な柔軟性をもち、エンコードが難しすぎない、想定されるデータ型のセットを選択してください。
</p></div></div></body></html>