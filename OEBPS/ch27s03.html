<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buffer Names</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Buffer-Names"/>Buffer Names</h1></div></div></div><a id="idm65727568" class="indexterm"/><p>それぞれのバッファーは、文字列で表される一意な名前をもちます。バッファーにたいして機能する関数の多くは、引数としてバッファーとバッファー名の両方を受け入れます。<em class="replaceable"><code>buffer-or-name</code></em>という名前の引数がこのタイプで、それが文字列でもバッファーでもない場合は、エラーがシグナルされます。<em class="replaceable"><code>buffer</code></em>という名前の引数は、名前ではなく実際のバッファーオブジェクトでなければなりません。
</p><a id="idm65725520" class="indexterm"/><a id="idm65724752" class="indexterm"/><p>短命でユーザーが関心をもたないようなバッファーは名前がスペースで始まり、それらについては<code class="literal">list-buffers</code>および<code class="literal">buffer-menu</code>コマンドは無視します(が、ファイルをvisitしているようなバッファーは<span class="bold"><strong>無視されない</strong></span>)。スペースで始まる名前は、初期状態ではアンドゥ情報の記録も無効になっています。<a class="link" href="ch32s09.html" title="Undo">Undo</a>を参照してください。
</p><pre class="synopsis"><a id="idm65721296" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">buffer-name</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>buffer</code></em>の名前を文字列としてリターンする。<em class="replaceable"><code>buffer</code></em>のデフォルトは、カレントバッファーである。
</p><p><code class="literal">buffer-name</code>が<code class="literal">nil</code>をリターンした場合、それは<em class="replaceable"><code>buffer</code></em>がkillされていることを意味する。<a class="link" href="ch27s10.html" title="Killing Buffers">Killing
Buffers</a>を参照のこと。
</p><pre class="screen">(buffer-name)
     ⇒ "buffers.texi"
</pre><pre class="screen">
</pre><pre class="screen">(setq foo (get-buffer "temp"))
     ⇒ #&lt;buffer temp&gt;
</pre><pre class="screen">(kill-buffer foo)
     ⇒ nil
</pre><pre class="screen">(buffer-name foo)
     ⇒ nil
</pre><pre class="screen">foo
     ⇒ #&lt;killed buffer&gt;
</pre></blockquote></div><pre class="synopsis"><a id="idm65712208" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">rename-buffer</code> <em class="replaceable"><code>newname</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>unique</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファーを<em class="replaceable"><code>newname</code></em>にリネームする。<em class="replaceable"><code>newname</code></em>が文字列でない場合は、エラーをシグナルする。
</p><p><em class="replaceable"><code>newname</code></em>がすでに使用済みの場合、<code class="literal">rename-buffer</code>は通常はエラーをシグナルする。しかし、<em class="replaceable"><code>unique</code></em>が非<code class="literal">nil</code>の場合は、未使用の名前となるように<em class="replaceable"><code>newname</code></em>を変更する。interactiveに呼び出した場合は、プレフィックス数引数により<em class="replaceable"><code>unique</code></em>に非<code class="literal">nil</code>を指定できる(この方法により、コマンド<code class="literal">rename-uniquely</code>は実装される)。
</p><p>この関数は、実際にバッファーに与えられた名前をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm65694800" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">get-buffer</code> <em class="replaceable"><code>buffer-or-name</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>buffer-or-name</code></em>で指定されたバッファーをリターンする。<em class="replaceable"><code>buffer-or-name</code></em>が文字列で、かつそのような名前のバッファーが存在しない場合、値は<code class="literal">nil</code>になる。<em class="replaceable"><code>buffer-or-name</code></em>がバッファーの場合は、与えられたバッファーをリターンする。これは有用とは言い難く、引数は通常は名前である。たとえば:
</p><pre class="screen">(setq b (get-buffer "lewis"))
     ⇒ #&lt;buffer lewis&gt;
</pre><pre class="screen">(get-buffer b)
     ⇒ #&lt;buffer lewis&gt;
</pre><pre class="screen">(get-buffer "Frazzle-nots")
     ⇒ nil
</pre><p><a class="link" href="ch27s09.html" title="Creating Buffers">Creating Buffers</a>の関数<code class="literal">get-buffer-create</code>も参照のこと。
</p></blockquote></div><pre class="synopsis"><a id="idm65687120" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">generate-new-buffer-name</code> <em class="replaceable"><code>starting-name</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>ignore</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、新たなバッファーにたいして一意となるような名前をリターンする —
が、バッファーは作成しない。この名前は<em class="replaceable"><code>starting-name</code></em>で始まり、内部が数字であるような‘<code class="literal">&lt;…&gt;</code>’を追加することにより、すべてのバッファーでカレントで使用されていない名前を生成する。この数字は2で始まり、既存バッファーの名前でない名前になる数字まで増加される。
</p><p>オプション引数<em class="replaceable"><code>ignore</code></em>が非<code class="literal">nil</code>の場合、それは潜在的にバッファー名であるような文字列であること。これは、たとえそれが(通常は拒絶されるであろう)既存バッファーの名前であっても、試みられた場合は、潜在的に受容可能なバッファーとして考慮することを意味する。つまり‘<code class="literal">foo</code>’、‘<code class="literal">foo&lt;2&gt;</code>’、‘<code class="literal">foo&lt;3&gt;</code>’、‘<code class="literal">foo&lt;4&gt;</code>’という名前のバッファーが存在する場合、
</p><pre class="screen">(generate-new-buffer-name "foo")
     ⇒ "foo&lt;5&gt;"
(generate-new-buffer-name "foo" "foo&lt;3&gt;")
     ⇒ "foo&lt;3&gt;"
(generate-new-buffer-name "foo" "foo&lt;6&gt;")
     ⇒ "foo&lt;5&gt;"
</pre><p><a class="link" href="ch27s09.html" title="Creating Buffers">Creating Buffers</a>の関連する関数<code class="literal">generate-new-buffer</code>も参照のこと。
</p></blockquote></div></div></body></html>