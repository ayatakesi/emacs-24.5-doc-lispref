<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buffer Modification</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Buffer-Modification"/>Buffer Modification</h1></div></div></div><a id="idm65599056" class="indexterm"/><a id="idm65598288" class="indexterm"/><p>Emacsは、各バッファーにたいして、バッファーのテキストを変更したかどうかを記録するために、<em class="firstterm">変更フラグ(modified
flag)</em>と呼ばれるフラグを管理しています。このフラグは、バッファーのコンテンツを変更すると常に<code class="literal">t</code>にセットされ、バッファーを保存したとき<code class="literal">nil</code>にクリアーされます。したがって、このフラグは保存されていない変更があるかどうかを表します。フラグの値は通常、モードライン内(<a class="link" href="ch23s04.html#Mode-Line-Variables" title="Variables Used in the Mode Line">Mode
Line Variables</a>を参照)に表示され、保存(<a class="link" href="ch25s02.html" title="Saving Buffers">Saving
Buffers</a>を参照)と自動保存(<a class="link" href="ch26s02.html" title="Auto-Saving">Auto-Saving</a>を参照)を制御します。
</p><p>いくつかのLispプログラムは、このフラグを明示的にセットします。たとえば、関数<code class="literal">set-visited-file-name</code>は、このフラグを<code class="literal">t</code>にセットします。なぜなら、たとえその前にvisitしていたファイルが変更されていなくても、テキストは新たにvisitされたファイルとマッチしないからです。
</p><p>バッファーのコンテンツを変更する関数については、<a class="link" href="ch32.html" title="Chapter 31. Text">Text</a>で説明されています。
</p><pre class="synopsis"><a id="idm65591504" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">buffer-modified-p</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、バッファー<em class="replaceable"><code>buffer</code></em>が最後にファイルから読み込まれた、あるいは保存されてから変更されていれば<code class="literal">t</code>、それ以外では<code class="literal">nil</code>をリターンする。<em class="replaceable"><code>buffer</code></em>が与えられない場合は、カレントバッファーがテストされる。
</p></blockquote></div><pre class="synopsis"><a id="idm65557456" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-buffer-modified-p</code> <em class="replaceable"><code>flag</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>flag</code></em>が非<code class="literal">nil</code>ならカレントバッファーを変更済みとしてマークし、<code class="literal">nil</code>なら未変更としてマークする。
</p><p>この関数を呼び出すことによる別の効果は、それがカレントバッファーのモードラインの無条件な再表示を引き起こすことである。実際のところ、関数<code class="literal">force-mode-line-update</code>は、以下を行うことにより機能する:
</p><pre class="screen">(set-buffer-modified-p (buffer-modified-p))
</pre></blockquote></div><pre class="synopsis"><a id="idm65551440" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">restore-buffer-modified-p</code> <em class="replaceable"><code>flag</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">set-buffer-modified-p</code>と同様だが、モードラインにたいする強制的な再表示を行わない。
</p></blockquote></div><pre class="synopsis"><a id="idm65547856" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">not-modified</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>arg</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、カレントバッファーが変更されておらず、保存する必要がないとマークする。<em class="replaceable"><code>arg</code></em>が非<code class="literal">nil</code>の場合、これは変更されているとマークするので、次回の適切なタイミングでバッファーは保存されるだろう。interactiveに呼び出された場合、<em class="replaceable"><code>arg</code></em>はプレフィックス引数である。
</p><p>この関数は、エコーエリア内にメッセージをプリントするので、プログラム内で使用してはならない。かわりに、<code class="literal">set-buffer-modified-p</code>(上記)を使用すること。
</p></blockquote></div><pre class="synopsis"><a id="idm65542096" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">buffer-modified-tick</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>buffer</code></em>の変更カウント(modification-count)をリターンする。これは、バッファーが変更されるたびに増加されるカウンターである。<em class="replaceable"><code>buffer</code></em>が<code class="literal">nil</code>(または省略)の場合は、カレントバッファーが使用される。このカウンターは、時折0にクリアーされ得る。
</p></blockquote></div><pre class="synopsis"><a id="idm65524944" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">buffer-chars-modified-tick</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>buffer</code></em>の文字変更に関わる変更カウントをリターンする。テキストプロパティを変更しても、このカウンターは変化しない。しかし、そのバッファーにテキストが挿入、または削除されるたびに、このカウンターは<code class="literal">buffer-modified-tick</code>によりリターンされるであろう値にリセットされる。<code class="literal">buffer-chars-modified-tick</code>を2回呼び出してリターンされる値を比較することにより、その呼び出しの間にバッファー内で文字変更があったかどうかを知ることができる。<em class="replaceable"><code>buffer</code></em>が<code class="literal">nil</code>(または省略)の場合は、カレントバッファーが使用される。
</p></blockquote></div></div></body></html>