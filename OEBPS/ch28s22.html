<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Horizontal Scrolling</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Horizontal-Scrolling"/>Horizontal Scrolling</h1></div></div></div><a id="idm67400912" class="indexterm"/><p><em class="firstterm">水平スクロール(horizontal
scrolling)</em>とは、指定された通常文字幅の倍数でウィンドウ内のイメージを左右にシフトすることを意味します。ウィンドウはそれぞれ、決して0より小さくなることはない、<em class="firstterm">水平スクロール位置(horizontal
scroll
position)</em>という数値をもっています。これは、コンテンツをどれほど左にシフトするかを指定します。ウィンドウのコンテンツを左にシフトすることにより、一般的には左にある文字のすべて、または一部が表示されなくなり、右にある文字のすべて、または一部が表示されることを意味します。通常の値は0です。
</p><p>水平スクロール位置は、通常文字幅を単位として数えられます。したがって値が5なら、それはウィンドウのコンテンツは通常文字幅の5倍左にスクロールされることを意味します。左の何文字が表示されなくなるかは、それらの文字の文字幅とに依存しており、行ごとに異なります。
</p><p>読み取りを行う際は、“inner loop”で横方向に、“outer
loop”で上から下に読み取るため、水平スクロールの効果はテキスト的スクロールや垂直スクロールとは異なります。テキスト的スクロールは表示するためのテキスト範囲の選択を引き起こし、垂直スクロールはウィンドウコンテンツを連続して移動します。しかし、水平スクロールは<span class="emphasis"><em>すべての行</em></span>の一部をスクリーン外へスクロールします。
</p><p>通常は、水平スクロールは行われないので、ウィンドウ左端には最左列があります。この状態では、右スクロールにより左端に新たに表示されるデータは存在しないので、右へのスクロールはできません。左スクロールにより、テキストの1列目がウィンドウ端からウィンドウ外にスクロールされ、右端にはその前は切り詰められていた(truncated)列が新たに表示されるので、左へのスクロールはできます。ウィンドウが左へ非0の量を水平スクロールされていれば、右スクロールしてそれを戻すことができますが、正味の水平スクロールが0に減少するまでの間のみ、右スクロールができます。左へどれほどスクロールできるかに制限はありませんが、最終的にはすべてのテキストが左端の外に消えるでしょう。
</p><a id="idm67397584" class="indexterm"/><p><code class="literal">auto-hscroll-mode</code>がセットされている場合、再表示はポイントが常に可視となることを保証するために、必要に応じて水平スクロールを自動的に変更する。とはいえ、依然として水平スクロール位置を明示的に指定するのは可能である。指定した値は、自動スクロールの下限値としての役目を果たす(自動スクロールは指定された値より小さい列にウィンドウをスクロールしない)。
</p><pre class="synopsis"><a id="idm67395792" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">scroll-left</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>count</code></em> <em class="replaceable"><code>set-minimum</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、選択されたウィンドウを左(<em class="replaceable"><code>count</code></em>が負なら右)に<em class="replaceable"><code>count</code></em>列スクロールする。<em class="replaceable"><code>count</code></em>のデフォルトはウィンドウ幅から2を減じた値である。
</p><p>リターン値は、<code class="literal">window-hscroll</code>(以下参照)がリターンする値と同様、変更後に実際に左に水平スクロールされたトータル量である。
</p><p>ウィンドウを可能な限り右にスクロールした後は、左スクロールの合計が0であるような通常の位置に戻り、右へのそれ以上のスクロールの試みは効果をもたない。
</p><p><em class="replaceable"><code>set-minimum</code></em>が非<code class="literal">nil</code>の場合、新たなスクロール量は自動スクロールの下限値となる。つまり自動スクロールは、この関数がリターンする値より小さい列にウィンドウをスクロールしないだろう。インタラクティブに呼び出すと、<em class="replaceable"><code>set-minimum</code></em>に非<code class="literal">nil</code>を渡す。
</p></blockquote></div><pre class="synopsis"><a id="idm67387344" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">scroll-right</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>count</code></em> <em class="replaceable"><code>set-minimum</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、選択されたウィンドウを右(<em class="replaceable"><code>count</code></em>が負なら左)に<em class="replaceable"><code>count</code></em>列スクロールする。<em class="replaceable"><code>count</code></em>のデフォルトはウィンドウ幅から2を減じた値である。スクロール方向を除けば、これは<code class="literal">scroll-left</code>と同様に機能する。
</p></blockquote></div><pre class="synopsis"><a id="idm67361104" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">window-hscroll</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>window</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>window</code></em>の左への水平スクロールのトータル(左マージンを超えて左にスクロールされた<em class="replaceable"><code>window</code></em>内のテキスト列数)をリターンする。<em class="replaceable"><code>window</code></em>のデフォルトは、選択されたウィンドウである。
</p><p>リターン値が負になることは決してない。<em class="replaceable"><code>window</code></em>で水平スクロールが行われていない場合(これが通常)、リターン値は0である。
</p><pre class="screen">(window-hscroll)
     ⇒ 0
</pre><pre class="screen">(scroll-left 5)
     ⇒ 5
</pre><pre class="screen">(window-hscroll)
     ⇒ 5
</pre></blockquote></div><pre class="synopsis"><a id="idm67354320" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-window-hscroll</code> <em class="replaceable"><code>window</code></em> <em class="replaceable"><code>columns</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>window</code></em>の水平スクロールをセットする。<em class="replaceable"><code>columns</code></em>の値は、スクロール量を左マージンからの列数で指定する。引数<em class="replaceable"><code>columns</code></em>は0または正の数であること。そうでない場合は、0とみなされる。小数値の<em class="replaceable"><code>columns</code></em>は、現在のところサポートされない。
</p><p>シンプルに<strong class="userinput"><code>M-:</code></strong>を呼び出して評価する方法でテストした場合は、<code class="literal">set-window-hscroll</code>が機能していないように見えるかもしれないことに注意されたい。何が発生しているかというと、この関数は水平スクロール値をセットしてリターンするが、その後にポイントを可視にするために水平スクロールを調整するよう再表示が行なわれ、これが関数の行った処理をオーバーライドしている。この関数の効果は、左マージンからポイントまでのスクロール量が、ポイントが可視のまま留まるように関数を呼び出すことにより観察できる。
</p><p>リターン値は<em class="replaceable"><code>columns</code></em>である。
</p><pre class="screen">(set-window-hscroll (selected-window) 10)
     ⇒ 10
</pre></blockquote></div><p>以下は、与えられた位置<em class="replaceable"><code>position</code></em>が水平スクロールによりスクリーン外にあるかどうかを判断する例です:
</p><pre class="screen">(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (&gt;= (- (current-column) (window-hscroll window)) 0)
     (&lt; (- (current-column) (window-hscroll window))
        (window-width window)))))
</pre></div></body></html>