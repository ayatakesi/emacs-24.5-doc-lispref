<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Text Properties</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Text-Properties"/>Text Properties</h1></div></div></div><a id="idm75628496" class="indexterm"/><a id="idm75627728" class="indexterm"/><a id="idm75626960" class="indexterm"/><p>バッファーや文字列内の各文字位置は、シンボルにおけるプロパティリスト(<a class="link" href="ch06s09.html" title="Property Lists">Property
Lists</a>を参照)のように、<em class="firstterm">テキストプロパティリスト(text property
list)</em>をもつことができます。特定の位置の特定の文字に属するプロパティ、たとえばこのセンテンス先頭の文字‘<code class="literal">T</code>’(訳注:
翻訳前のセンテンスは"The properties belong to a
..."で始まる)、または‘<code class="literal">foo</code>’の最初の‘<code class="literal">o</code>’など、もし同じ文字が異なる2箇所に存在する場合、2つの文字は一般的に異なるプロパティをもちます。
</p><p>それぞれのプロパティには、名前と値があります。どちらも任意のLispオブジェクトをもつことができますが、名前は通常はシンボルです。典型的には、それぞれのプロパティ名シンボルは、特定の目的のために使用されます。たとえば、テキストプロパティ<code class="literal">face</code>は、文字を表示するためのフェイスを指定します(<a class="link" href="ch32s19.html#Special-Properties" title="Properties with Special Meanings">Special
Properties</a>を参照)。名前を指定してそれに対応する値を尋ねるのが、このプロパティリストにアクセスするための通常の方法です。
</p><p>ある文字が<code class="literal">category</code>プロパティをもつ場合は、それをその文字の<em class="firstterm">プロパティカテゴリー(property
category)</em>と呼びます。これはシンボルであるべきです。そのシンボルのプロパティは、その文字のプロパティにたいしてデフォルトとしての役割をもちます。
</p><p>文字列とバッファーの間でテキストをコピーには、文字とともにそのプロパティが保持されます。これには<code class="literal">substring</code>、<code class="literal">insert</code>、<code class="literal">buffer-substring</code>のようなさまざまな関数が含まれます。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Examining-Properties"/>Examining Text Properties</h2></div></div></div><a id="idm75617872" class="indexterm"/><a id="idm75617104" class="indexterm"/><p>テキストプロパティを調べるもっともシンプルな方法は、特定の文字の特定のプロパティの値を尋ねる方法です。これを行うには、<code class="literal">get-text-property</code>を使用します。ある文字のプロパティリスト全体を取得するには、<code class="literal">text-properties-at</code>を使用します。複数の文字のプロパティを一度に調べる関数については、<a class="link" href="ch32s19.html#Property-Search" title="Text Property Search Functions">Property
Search</a>を参照してください。
</p><p>以下の関数は、文字列とバッファーの両方を処理します。バッファー内の位置は1から始まりますが、文字列内の位置は0から始まることに留意してください。
</p><pre class="synopsis"><a id="idm75613776" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">get-text-property</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>object</code></em>(バッファーまたは文字列)内の位置<em class="replaceable"><code>pos</code></em>の後にある文字のプロパティ<em class="replaceable"><code>prop</code></em>の値をリターンする。引数<em class="replaceable"><code>object</code></em>はオプションで、デフォルトはカレントバッファー。
</p><p>厳密な意味で<em class="replaceable"><code>prop</code></em>プロパティが存在しないが、その文字がシンボルであるようなプロパティカテゴリーをもつなら、<code class="literal">get-text-property</code>はそのシンボルの<em class="replaceable"><code>prop</code></em>プロパティをリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm75589840" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">get-char-property</code> <em class="replaceable"><code>position</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">get-text-property</code>と似ているが、まずオーバーレイをチェックして、次にテキストプロパティをチェックする点が異なる。<a class="link" href="ch38s09.html" title="Overlays">Overlays</a>を参照のこと。
</p><p>引数<em class="replaceable"><code>object</code></em>は文字列、バッファー、あるいはウィンドウかもしれない。ウィンドウならそのウィンドウ内に表示されているバッファーのテキストプロパティとオーバーレイが使用されるが、そのウィンドウにたいしてアクティブなオーバーレイだけが考慮される。<em class="replaceable"><code>object</code></em>がバッファーなら、そのバッファー内のオーバーレイがまず優先順に考慮され、その後にテキストプロパティが考慮される。<em class="replaceable"><code>object</code></em>が文字列の場合？文字列は決してオーバーレイをもたないので、テキストプロパティだけが考慮される。
</p></blockquote></div><pre class="synopsis"><a id="idm75582928" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">get-pos-property</code> <em class="replaceable"><code>position</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">get-char-property</code>と似ているが、<em class="replaceable"><code>position</code></em>(すぐ右)にある文字のプロパティのかわりに、プロパティのstickiness(粘着性)とオーバーレイのadvancement(前向的)なセッティングに注意を払う点が異なる。
</p></blockquote></div><pre class="synopsis"><a id="idm75577680" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">get-char-property-and-overlay</code> <em class="replaceable"><code>position</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">get-char-property</code>と似ているが、そのプロパティ値が由来するオーバーレイについて追加情報を与える点が異なる。
</p><p>その値はCARがプロパティ値であるようなコンスセルで、同じ引数により<code class="literal">get-char-property</code>がリターンするであろう値と同じである。CDRはそのプロパティが見つかった箇所のオーバーレイ、またはテキストプロパティとして見つかった場合や見つからなかった場合は<code class="literal">nil</code>である。
</p><p><em class="replaceable"><code>position</code></em>が<em class="replaceable"><code>object</code></em>の終端なら、CARとCDRの値はどちらも<code class="literal">nil</code>になる。
</p></blockquote></div><pre class="synopsis"><a id="idm75569872" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">char-property-alias-alist</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、プロパティ名と代替となるプロパティ名リストをマップするalistを保持する。文字があるプロパティにたいして直接値を指定しなければ、順に代替プロパティ名が調べられ、最初の非<code class="literal">nil</code>値が使用される。この変数は<code class="literal">default-text-properties</code>より優先され、この変数より<code class="literal">category</code>プロパティが優先される。
</p></blockquote></div><pre class="synopsis"><a id="idm75565648" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">text-properties-at</code> <em class="replaceable"><code>position</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の位置<em class="replaceable"><code>position</code></em>にある文字のプロパティリスト全体をリターンする。<em class="replaceable"><code>object</code></em>が<code class="literal">nil</code>なら、デフォルトはカレントバッファーとなる。
</p></blockquote></div><pre class="synopsis"><a id="idm75560016" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">default-text-properties</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、テキストプロパティにたいしてデフォルト値を与えるプロパティリストを保持する。あるプロパティにたいして文字が直接、あるいはカテゴリーシンボルまたは<code class="literal">char-property-alias-alist</code>を通じて値を指定しないときは常に、このリストに格納された値がかわりに使用される。以下は例である:
</p><pre class="screen">(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; 文字1は自身のプロパティをもたない
(set-text-properties 1 2 nil)
;; 取得される値はデフォルト値である
(get-text-property 1 'foo)
     ⇒ 69
</pre></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Changing-Properties"/>Changing Text Properties</h2></div></div></div><a id="idm75555536" class="indexterm"/><a id="idm75554768" class="indexterm"/><p>プロパティを変更するプリミティブは、バッファーまたは文字列内の指定されたテキスト範囲に適用されます。関数<code class="literal">set-text-properties</code>(セクションの最後を参照)は、その範囲内のテキストのプロパティリスト全体をセットします。名前を指定することにより特定のプロパティだけを追加、変更、削除するのにも、より有用です。
</p><p>テキストプロパティはバッファー(または文字列)のコンテンツの一部とみなされ、かつスクリーン上でのバッファーの見栄えに影響を与えることができるので、バッファー内のテキストプロパティの変更はすべて、バッファーを変更済みとマークします。バッファーテキストプロパティの変更も、アンドゥできます(<a class="link" href="ch32s09.html" title="Undo">Undo</a>を参照)。バッファー内の位置は1から始まりますが、文字列内の位置は0から始まります。
</p><pre class="synopsis"><a id="idm75523152" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">put-text-property</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>value</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストにたいして、プロパティ<em class="replaceable"><code>prop</code></em>に<em class="replaceable"><code>value</code></em>をセットする。<em class="replaceable"><code>object</code></em>が<code class="literal">nil</code>なら、デフォルトはカレントバッファーである。
</p></blockquote></div><pre class="synopsis"><a id="idm75515216" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">add-text-properties</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>props</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストにたいして、テキストプロパティを追加またはオーバーライドする。<em class="replaceable"><code>object</code></em>が<code class="literal">nil</code>なら、デフォルトはカレントバッファーである。
</p><p>引数<em class="replaceable"><code>props</code></em>は、追加するプロパティを指定する。これはプロパティリストの形式(<a class="link" href="ch06s09.html" title="Property Lists">Property
Lists</a>を参照)、つまりプロパティ名と対応する値が交互に出現するような要素を含むリストであること。
</p><p>関数が実際に何らかのプロパティの値を変更したら<code class="literal">t</code>、それ以外(<em class="replaceable"><code>props</code></em>が<code class="literal">nil</code>、またはプロパティの値がテキスト内のプロパティの値と一致している場合)は<code class="literal">nil</code>がリターン値となる。
</p><p>たとえば、以下はテキストの範囲に<code class="literal">comment</code>と<code class="literal">face</code>のプロパティをセットする例である:
</p><pre class="screen">(add-text-properties <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em>
                     '(comment t face highlight))
</pre></blockquote></div><pre class="synopsis"><a id="idm75502032" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">remove-text-properties</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>props</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストから、指定されたテキストプロパティを削除する。<em class="replaceable"><code>object</code></em>が<code class="literal">nil</code>なら、デフォルトはカレントバッファーとなる。
</p><p>引数<em class="replaceable"><code>props</code></em>は、削除するプロパティを指定する。これはプロパティリストの形式(<a class="link" href="ch06s09.html" title="Property Lists">Property
Lists</a>を参照)、つまりプロパティ名と対応する値が交互に出現するような要素を含むリストであること。しかし問題となるのは名前であり、付随する値は無視される。たとえば<code class="literal">face</code>プロパティを削除するには、以下のようにすればよい。
</p><pre class="screen">(remove-text-properties <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> '(face nil))
</pre><p>関数が実際に何らかのプロパティの値を変更したら<code class="literal">t</code>、それ以外(<em class="replaceable"><code>props</code></em>が<code class="literal">nil</code>、または指定されたテキスト内にそれらのプロパティをもつ文字がない場合)は<code class="literal">nil</code>がリターン値となる。
</p><p>特定のテキストからすべてのテキストプロパティを削除するには、新たなプロパティリストに<code class="literal">nil</code>を指定して、<code class="literal">set-text-properties</code>を使用すればよい。
</p></blockquote></div><pre class="synopsis"><a id="idm75484240" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">remove-list-of-text-properties</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>list-of-properties</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">remove-text-properties</code>と同様だが、<em class="replaceable"><code>list-of-properties</code></em>がプロパティ名と値が交互になったリストではなく、プロパティ名だけのリストである点が異なる。
</p></blockquote></div><pre class="synopsis"><a id="idm75478736" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-text-properties</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>props</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の<em class="replaceable"><code>start</code></em>から<em class="replaceable"><code>end</code></em>の間のテキストにたいするテキストプロパティリストを、完全に置き換える。<em class="replaceable"><code>object</code></em>が<code class="literal">nil</code>なら、デフォルトはカレントバッファーとなる。
</p><p>引数<em class="replaceable"><code>props</code></em>は新たなプロパティリスト。これはプロパティメジャーと対応する値が交互となるような要素のリストであること。
</p><p><code class="literal">set-text-properties</code>のリターン後は、指定された範囲内のすべての文字は、等しいプロパティをもつ。
</p><p><em class="replaceable"><code>props</code></em>が<code class="literal">nil</code>なら、指定されたテキスト範囲からすべてのプロパティを取り除く効果がある。以下は例である:
</p><pre class="screen">(set-text-properties <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> nil)
</pre><p>この関数のリターン値を信用してはならない。
</p></blockquote></div><pre class="synopsis"><a id="idm75463376" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">add-face-text-property</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>face</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>appendp</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストのテキストプロパティ<code class="literal">face</code>にフェイス<em class="replaceable"><code>face</code></em>を追加するよう動作する。<em class="replaceable"><code>face</code></em>はフェイス名もしくはanonymousフェイス(anonymous
face: 無名フェイス)のような、<code class="literal">face</code>プロパティ(<a class="link" href="ch32s19.html#Special-Properties" title="Properties with Special Meanings">Special
Properties</a>を参照)にたいして有効な値であること(<a class="link" href="ch38s12.html" title="Faces">Faces</a>を参照)。
</p><p>リージョン内の任意のテキストがすでに非<code class="literal">nil</code>の<code class="literal">face</code>プロパティをもつ場合、それらのフェイスは保たれる。
If any text in the region already has a non-  property, those face(s) are
retained.
この関数は<code class="literal">face</code>プロパティに、最初の要素(デフォルト)が<em class="replaceable"><code>face</code></em>、以前に存在していたフェイスが残りの要素であるような、フェイスのリストをセットする。オプション引数<em class="replaceable"><code>append</code></em>が非<code class="literal">nil</code>なら、<em class="replaceable"><code>face</code></em>はかわりにリストの最後に追加される。フェイスリスト内では、各属性にたいして最初に出現する値が優先されることに注意。
</p><p>たとえば以下のコードでは、<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間のテキストに、グリーン斜体のフェイスを割り当てるだろう:
</p><pre class="screen">(add-face-text-property <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> 'italic)
(add-face-text-property <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> '(:foreground "red"))
(add-face-text-property <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> '(:foreground "green"))
</pre><p>オプション引数<em class="replaceable"><code>object</code></em>が非<code class="literal">nil</code>なら、それはカレントバッファーではなく、動作するバッファーまたは文字列を指定する。<em class="replaceable"><code>object</code></em>が文字列なら、<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>は0基準で文字列内をインデックス付けする。
</p></blockquote></div><p>文字列にテキストプロパティを付するもっとも簡単な方法は、<code class="literal">propertize</code>です:
</p><pre class="synopsis"><a id="idm75427152" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">propertize</code> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>properties</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、テキストプロパティ<em class="replaceable"><code>properties</code></em>を追加した、<em class="replaceable"><code>string</code></em>のコピーをリターンする。これらのプロパティは、リターンされる文字列内のすべての文字に適用される。以下は、<code class="literal">face</code>プロパティと<code class="literal">mouse-face</code>プロパティとともに文字列を構築する例である:
</p><pre class="screen">(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     ⇒ #("foo" 0 3 (mouse-face bold-italic face italic))
</pre><p>文字列のさまざまな部分に異なるプロパティをputするんは、それぞれの部分を<code class="literal">propertize</code>で構築して、<code class="literal">concat</code>でそれらを結合すればよい:
</p><pre class="screen">(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     ⇒ #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
</pre></blockquote></div><p>プロパティではなくバッファーからテキストをコピーする関数<code class="literal">buffer-substring-no-properties</code>については、<a class="link" href="ch32s02.html" title="Examining Buffer Contents">Buffer
Contents</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Property-Search"/>Text Property Search Functions</h2></div></div></div><a id="idm75416784" class="indexterm"/><a id="idm75416016" class="indexterm"/><p>テキストプロパティの通常の使用では、ほとんどの場合は複数または多くの連続する文字が、同じ値のプロパティをもちます。文字を1つずつ調べるプログラムを記述するよりも、同じプロパティ値をもつテキスト塊(chunks
of text)を処理するほうが、より高速です。
</p><p>以下は、これを行うことに使用できる関数です。これらは、プロパティ値の比較に<code class="literal">eq</code>を使用します。すべての関数において、<em class="replaceable"><code>object</code></em>のデフォルトはカレントバッファーです。
</p><p>より良いパフォーマンスのためには、特に単一のプロパティを検索する関数においては、<em class="replaceable"><code>limit</code></em>引数の使用が重要です。そうしないと、興味のあるプロパティが変化しない場合に、バッファー終端までのスキャンに長い時間を要するでしょう。
</p><p>これらの関数はポイントを移動しません。そのかわりに位置(または<code class="literal">nil</code>)をリターンします。ポイントは常に文字と文字の間にあることを思い出してください。これらの関数によりリターンされる位置は、異なるプロパティをもつ、2つの文字の間にあります。
</p><pre class="synopsis"><a id="idm75411536" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">next-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は文字列またはバッファー<em class="replaceable"><code>object</code></em>内の位置<em class="replaceable"><code>pos</code></em>から、何らかのテキストプロパティの変化が見つかるまで、テキストを前方にスキャンして、変化のあった位置をリターンする。別の言い方をすると、<em class="replaceable"><code>pos</code></em>の直後の文字とプロパティが等しくない、<em class="replaceable"><code>pos</code></em>の先にある最初の文字の位置をリターンする。
</p><p><em class="replaceable"><code>limit</code></em>が非<code class="literal">nil</code>なら、スキャンは位置<em class="replaceable"><code>limit</code></em>で停止する。そのポイントより前にプロパティが変化しなければ、この関数は<em class="replaceable"><code>limit</code></em>をリターンする。
</p><p>プロパティが<em class="replaceable"><code>object</code></em>終端まで変化せず、かつ<em class="replaceable"><code>limit</code></em>が<code class="literal">nil</code>なら、値は<code class="literal">nil</code>となる。値が非<code class="literal">nil</code>なら、それは<em class="replaceable"><code>pos</code></em>以上の位置である。<em class="replaceable"><code>limit</code></em>が<em class="replaceable"><code>pos</code></em>と等しいときのみ、値は<em class="replaceable"><code>pos</code></em>になる。
</p><p>以下は、すべてのプロパティが定数であるようなテキスト塊によりバッファーをスキャンする方法の例である:
</p><pre class="screen">(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    ポイントから<em class="replaceable"><code>next-change</code></em>へテキストを処理…
    (goto-char next-change)))
</pre></blockquote></div><pre class="synopsis"><a id="idm75398224" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">previous-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">next-property-change</code>と似ているが、<em class="replaceable"><code>pos</code></em>から前方ではなく後方にスキャンする点が異なる。値が非<code class="literal">nil</code>なら、それは<em class="replaceable"><code>pos</code></em>以下の位置である。<em class="replaceable"><code>limit</code></em>と<em class="replaceable"><code>pos</code></em>が等しい場合のみ、<em class="replaceable"><code>pos</code></em>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm75390928" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">next-single-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はプロパティ<em class="replaceable"><code>prop</code></em>内の変化についてテキストをスキャンして、変化があった位置をリターンする。このスキャンは、文字列またはバッファー<em class="replaceable"><code>object</code></em>内の位置<em class="replaceable"><code>pos</code></em>から、前方に行われる。別の言い方をすると、<em class="replaceable"><code>pos</code></em>の直後の文字とプロパティ<em class="replaceable"><code>prop</code></em>が等しくない、<em class="replaceable"><code>pos</code></em>の先にある最初の文字の位置をリターンする。
</p><p><em class="replaceable"><code>limit</code></em>が非<code class="literal">nil</code>なら、スキャンは位置<em class="replaceable"><code>limit</code></em>で終了する。そのポイントより前にプロパティの変化がなければ、<code class="literal">next-single-property-change</code>は<em class="replaceable"><code>limit</code></em>をリターンする。
</p><p>プロパティが<em class="replaceable"><code>object</code></em>終端まで変化せず、かつ<em class="replaceable"><code>limit</code></em>が<code class="literal">nil</code>なら、値は<code class="literal">nil</code>となる。値が非<code class="literal">nil</code>なら、それは<em class="replaceable"><code>pos</code></em>以上の位置である。<em class="replaceable"><code>limit</code></em>が<em class="replaceable"><code>pos</code></em>と等しいときのみ、値は<em class="replaceable"><code>pos</code></em>になる。
</p></blockquote></div><pre class="synopsis"><a id="idm75373136" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">previous-single-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">next-single-property-change</code>と似ているが、<em class="replaceable"><code>pos</code></em>から前方ではなく後方にスキャンする点が異なる。値が非<code class="literal">nil</code>なら、それは<em class="replaceable"><code>pos</code></em>以下の位置である。<em class="replaceable"><code>limit</code></em>と<em class="replaceable"><code>pos</code></em>が等しい場合のみ、<em class="replaceable"><code>pos</code></em>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm75365456" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">next-char-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">next-property-change</code>と似ているが、これはテキストプロパティと同様オーバーレイも考慮し、バッファー終端より前に変化が見つからなければ、<code class="literal">nil</code>ではなくバッファー位置の最大をリターンする点が異なる(この点では<code class="literal">next-property-change</code>よりも対応するオーバーレイ関数<code class="literal">next-overlay-change</code>と似る)。この関数はカレントバッファーだけを処理するので、<em class="replaceable"><code>object</code></em>オペランドは存在しない。これは、いずれかの種類のプロパティが変化した、次のアドレスをリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm75359184" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">previous-char-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">next-char-property-change</code>と似ているが、<em class="replaceable"><code>pos</code></em>から前方ではなく後方へスキャンすること、および変化が見つからなければバッファー位置の最小をリターンする点が異なる。
</p></blockquote></div><pre class="synopsis"><a id="idm75354320" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">next-single-char-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">next-single-property-change</code>と似ているが、これはテキストプロパティと同様オーバーレイも考慮し、<em class="replaceable"><code>object</code></em>終端より前に変化が見つからなければ、<code class="literal">nil</code>ではなく<em class="replaceable"><code>object</code></em>内の有効な位置の最大をリターンする点が異なる。<code class="literal">next-char-property-change</code>と異なり、、この関数は<em class="replaceable"><code>object</code></em>オペランドを<span class="emphasis"><em>もつ</em></span>。<em class="replaceable"><code>object</code></em>が非バッファーなら、テキストプロパティだけが考慮される。
</p></blockquote></div><pre class="synopsis"><a id="idm75346256" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">previous-single-char-property-change</code> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">next-single-char-property-change</code>と似ているが、<em class="replaceable"><code>pos</code></em>から前方ではなく後方へスキャンすること、および変化が見つからなければ<em class="replaceable"><code>object</code></em>内の有効な位置の最小をリターンする点が異なる。
</p></blockquote></div><pre class="synopsis"><a id="idm75340240" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">text-property-any</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>value</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間に少なくともプロパティ<em class="replaceable"><code>prop</code></em>に値<em class="replaceable"><code>value</code></em>をもつ文字が1つあれば、非<code class="literal">nil</code>をリターンする。より正確には、これはそのような最初の文字の位置をリターンし、それ以外は<code class="literal">nil</code>をリターンする。
</p><p>5つ目のオプション引数<em class="replaceable"><code>object</code></em>は、スキャンする文字列またはバッファーを指定する。位置は<em class="replaceable"><code>object</code></em>にたいして相対的である。<em class="replaceable"><code>object</code></em>のデフォルトは、カレントバッファー。
</p></blockquote></div><pre class="synopsis"><a id="idm75331024" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">text-property-not-all</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>end</code></em> <em class="replaceable"><code>prop</code></em> <em class="replaceable"><code>value</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>object</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>start</code></em>と<em class="replaceable"><code>end</code></em>の間に少なくともプロパティ<em class="replaceable"><code>prop</code></em>に値<em class="replaceable"><code>value</code></em>をもたない文字が1つあれば、非<code class="literal">nil</code>をリターンする。より正確には、これはそのような最初の文字の位置をリターンし、それ以外は<code class="literal">nil</code>をリターンする。
</p><p>5つ目のオプション引数<em class="replaceable"><code>object</code></em>は、スキャンする文字列またはバッファーを指定する。位置は<em class="replaceable"><code>object</code></em>にたいして相対的である。<em class="replaceable"><code>object</code></em>のデフォルトは、カレントバッファー。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Special-Properties"/>Properties with Special Meanings</h2></div></div></div><p>以下は、ビルトインで特別な意味をもつテキストプロパティ名のテーブルです。以降のセクションでは、フィルとプロパティ継承を制御する特別なプロパティ名をいくつか追加でリストしています。これ以外のすべての名前は特別な意味をもたず、自由に使用できます。
</p><p>注意:
プロパティ<code class="literal">composition</code>、<code class="literal">display</code>、<code class="literal">invisible</code>、<code class="literal">intangible</code>はすべてのEmacsコマンドの後に、好ましい箇所にポイントを移動させることもできます。<a class="link" href="ch21s06.html" title="Adjusting Point After Commands">Adjusting
Point</a>を参照してください。
</p><div class="variablelist"><a id="idm75305168" class="indexterm"/><a id="idm75304144" class="indexterm"/><dl class="variablelist"><dt><span class="term"><code class="literal">category</code>
</span></dt><dd><p>ある文字が<code class="literal">category</code>プロパティをもつ場合は、それをその文字の<em class="firstterm">プロパティカテゴリー(property
category)</em>と呼びます。これはシンボルであること。このシンボルのプロパティは、その文字のプロパティのデフォルトとしての役割をもつ。
</p></dd><dt><span class="term"><code class="literal">face</code>
</span></dt><dd><a id="idm75300304" class="indexterm"/><a id="idm75299536" class="indexterm"/><p><code class="literal">face</code>プロパティはその文字の外観を制御する(<a class="link" href="ch38s12.html" title="Faces">Faces</a>を参照)。このプロパティの値は、以下をとることができる:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>フェイス名(シンボルか文字列)。
</p></li><li class="listitem"><p>anonymousフェイス: <code class="literal">(<em class="replaceable"><code>keyword</code></em> <em class="replaceable"><code>value</code></em>
…)</code>形式のプロパティリスト。<em class="replaceable"><code>keyword</code></em>はそれぞれフェイス属性名で、<em class="replaceable"><code>value</code></em>はその属性の値。
</p></li><li class="listitem"><p>フェイスのリスト。各リスト要素はフェイス名かanonymousフェイスであること。これはリストされた各フェイス属性を集計したフェイスを指定する。このリスト内で最初にあるフェイスが、より高い優先度をもつ。
</p></li><li class="listitem"><p><code class="literal">(foreground-color . <em class="replaceable"><code>color-name</code></em>)</code>または<code class="literal">(background-color
. <em class="replaceable"><code>color-name</code></em>)</code>形式のコンスセル。これは<code class="literal">(:foreground
<em class="replaceable"><code>color-name</code></em>)</code>や<code class="literal">(:background
<em class="replaceable"><code>color-name</code></em>)</code>と同じようにフォアグラウンドまたはバックグラウンドを指定する。この形式は後方互換のためだけにサポートされており、無視するべきである。
</p></li></ul></div><p>Font Lockモード(<a class="link" href="ch23s06.html" title="Font Lock Mode">Font Lock
Mode</a>を参照)はほとんどのバッファーにおいて、コンテキストにもとづき文字の<code class="literal">face</code>プロパティを動的に更新することにより機能する。
</p><p><code class="literal">add-face-text-property</code>関数は、このプロパティをセットする便利な手段を提供する。<a class="link" href="ch32s19.html#Changing-Properties" title="Changing Text Properties">Changing
Properties</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">font-lock-face</code>
</span></dt><dd><a id="idm75286224" class="indexterm"/><p>このプロパティは、Font Lockモードが配下にあるテキストに適用すべき<code class="literal">face</code>プロパティにたいして値を指定する。これはFont
Lockモードに使用されるフォント表示手法の1つであり、独自のハイライトを実装する特別なモードにたいして有用である。<a class="link" href="ch23s06.html#Precalculated-Fontification" title="Precalculated Fontification">Precalculated
Fontification</a>を参照のこと。Font Lockモードが無効なら、<code class="literal">font-lock-face</code>に効果はない。
</p></dd><dt><span class="term"><code class="literal">mouse-face</code>
</span></dt><dd><a id="idm75282640" class="indexterm"/><p>このプロパティは、文字上または近傍にマウスがあるとき、<code class="literal">face</code>のかわりに使用される。この目的にたいして“近傍”とは、文字間のすべてのテキスト、およびマウスが同じ<code class="literal">mouse-face</code>プロパティの値をもつことを意味する。
</p><p>Emacsはテキストサイズ(<code class="literal">:height</code>、<code class="literal">:weight</code>、<code class="literal">:slant</code>)を変更する<code class="literal">mouse-face</code>プロパティ由来の属性すべてを無視する。これらの属性は、ハイライトされていないテキストと常に等しい。
</p></dd><dt><span class="term"><code class="literal">fontified</code>
</span></dt><dd><a id="idm75273040" class="indexterm"/><p>このプロパティはそのテキストの表示準備が整っているかどうかを告げる。<code class="literal">nil</code>ならEmacsの再表示ルーチンは、バッファーの該当部分を表示する前に、準備のために<code class="literal">fontification-functions</code>(<a class="link" href="ch38s12.html#Auto-Faces" title="Automatic Face Assignment">Auto
Faces</a>を参照)の中の関数を呼び出す。これはフォントロックのコードの“just in time”により、内部的に使用される。
</p></dd><dt><span class="term"><code class="literal">display</code>
</span></dt><dd><p>このプロパティは、テキストが表示される方法を変更する、さまざまな機能をアクティブ化する。たとえばこれによりテキスト外観を縦長(taller)または縦短(short)したり、高く(higher)または低く(lower)、太く(wider)または細く(narrower)したり、あるいはイメージに置き換えることができる。<a class="link" href="ch38s16.html" title="The display Property">Display
Property</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">help-echo</code>
</span></dt><dd><a id="idm75267536" class="indexterm"/><a id="idm75266768" class="indexterm"/><a id="Text-help_002decho"/><p>テキストが<code class="literal">help-echo</code>プロパティに文字列をもつ場合、そのテキスト上にマウスを移動した際に、Emacsはエコーエリアかツールチップウィンドウ(section “Tooltips” in <em class="citetitle">The GNU Emacs Manual</em>を参照)にその文字列を表示する。
</p><p><code class="literal">help-echo</code>プロパティの値が関数なら、その関数は<em class="replaceable"><code>window</code></em>、<em class="replaceable"><code>object</code></em>、<em class="replaceable"><code>pos</code></em>の3つの引数で呼び出され、ヘルプ文字列、または存在しない場合は<code class="literal">nil</code>をリターンすること。1つ目の引数<em class="replaceable"><code>window</code></em>は、そのヘルプが見つかったウィンドウである。2つ目の引数<em class="replaceable"><code>object</code></em>は、<code class="literal">help-echo</code>プロパティをもつバッファー、オーバーレイ、または文字列である。<em class="replaceable"><code>pos</code></em>引数は以下のとおり:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="replaceable"><code>object</code></em>がバッファーなら、<em class="replaceable"><code>pos</code></em>はそのバッファー内の位置。
</p></li><li class="listitem"><p><em class="replaceable"><code>object</code></em>がオーバーレイなら、そのオーバーレイは<code class="literal">help-echo</code>プロパティをもち、<em class="replaceable"><code>pos</code></em>はそのオーバーレイのバッファー内の位置である。
</p></li><li class="listitem"><p><em class="replaceable"><code>object</code></em>が文字列(オーバーレイ文字列、または<code class="literal">display</code>プロパティにより表示された文字列)なら、<em class="replaceable"><code>pos</code></em>はその文字列内の位置。
</p></li></ul></div><p><code class="literal">help-echo</code>プロパティの値が関数と文字列のいずれでもない場合、それはヘルプ文字列を得るために評価される。
</p><p>変数<code class="literal">show-help-function</code>をセットすることにより、ヘルプテキストが表示される方法を変更できる(<a class="link" href="ch32s19.html#Help-display">Help
display</a>を参照)。
</p><p>この機能はモードライン内、およびその他のアクティブテキストにたいして使用される。
</p></dd><dt><span class="term"><code class="literal">keymap</code>
</span></dt><dd><a id="idm75252432" class="indexterm"/><a id="idm75251664" class="indexterm"/><p><code class="literal">keymap</code>プロパティは、コマンドにたいして追加のキーマップを指定する。このキーマップを適用する際は、マイナーモードキーマップおよびバッファーのローカルマップの前に、キー照合にこのマップが使用される。<a class="link" href="ch22s07.html" title="Active Keymaps">Active
Keymaps</a>を参照のこと。プロパティ値がシンボルなら、そのシンボルの関数定義がキーマップとして使用される。
</p><p>ポイントの前の文字のプロパティの値は、それが非<code class="literal">nil</code>でrear-stickyであり、かつポイントの後の文字のプロパティ値が非<code class="literal">nil</code>でfront-stickyなら適用される(マウスクリックではポイント位置のかわりにクリック位置が使用される)。
</p></dd><dt><span class="term"><code class="literal">local-map</code>
</span></dt><dd><a id="idm75247312" class="indexterm"/><p>このプロパティは<code class="literal">keymap</code>と同じように機能するが、これはそのバッファーのローカルマップの<span class="emphasis"><em>かわりに</em></span>使用するキーマップを指定する点が異なる。ほとんど(もしかするとすべて)の目的にたいしては、<code class="literal">keymap</code>を使用するほうが良いだろう。
</p></dd><dt><span class="term"><code class="literal">syntax-table</code>
</span></dt><dd><p><code class="literal">syntax-table</code>プロパティは、特定の文字にたいして、どのシンタックステーブルがオーバーライドするかを告げる。<a class="link" href="ch35s04.html" title="Syntax Properties">Syntax
Properties</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">read-only</code>
</span></dt><dd><a id="idm75241680" class="indexterm"/><a id="idm75240912" class="indexterm"/><p>ある文字がプロパティ<code class="literal">read-only</code>をもつなら、その文字の変更は許可されない。これを行おうとするすべてのコマンドは、<code class="literal">text-read-only</code>エラーを受け取る。プロパティの値が文字列なら、その文字列がエラーメッセージとして使用される。
</p><p>read-only文字に隣接する箇所への挿入は、そこに通常のテキストの行うことがstickinessによる<code class="literal">read-only</code>プロパティを継承するなら、エラーとなる。つまりstickinessを制御することにより、read-onlyテキストに隣接する挿入の権限を制御することができる。<a class="link" href="ch32s19.html#Sticky-Properties" title="Stickiness of Text Properties">Sticky
Properties</a>を参照のこと。
</p><p>プロパティ変更はバッファー変更とみなされるので、特別なトリック(<code class="literal">inhibit-read-only</code>を非<code class="literal">nil</code>にバインドしてからプロパティを削除する)を知らないかぎり、<code class="literal">read-only</code>プロパティを取り除くことは不可能である。<a class="link" href="ch27s07.html" title="Read-Only Buffers">Read
Only Buffers</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">invisible</code>
</span></dt><dd><a id="idm75233872" class="indexterm"/><p>非<code class="literal">nil</code>の<code class="literal">invisible</code>プロパティにより、スクリーン上で文字を不可視にできる。詳細は<a class="link" href="ch38s06.html" title="Invisible Text">Invisible
Text</a>を参照されたい。
</p></dd><dt><span class="term"><code class="literal">intangible</code>
</span></dt><dd><a id="idm75230288" class="indexterm"/><p>連続する文字のグループが非<code class="literal">nil</code>の等しい<code class="literal">intangible</code>プロパティをもつなら、それらの文字の間にポイントを置くことは不可能である。そのグループ内に前方へポイントの移動を試みると、ポイントは実際にはそのグループの終端に移動する。そのグループ内に後方へポイントの移動を試みると、ポイントは実際にはそのグループの先頭に移動する。
</p><p>連続する文字のグループが非<code class="literal">nil</code>の等しくない<code class="literal">intangible</code>プロパティをもつなら、それらの文字は個別のグループに属し、各グループは上述のように別のグループとして扱われる。
</p><p>変数<code class="literal">inhibit-point-motion-hooks</code>が非<code class="literal">nil</code>なら、<code class="literal">intangible</code>プロパティは無視される。
</p><p>注意せよ:
このプロパティは非常に低レベルで処理され、予想害の方法により多くのコードに影響する。そのため使用に際しては特別な注意を要する。誤った使用方法としては、不可視のテキストにintangibleプロパティwpeをputするのが一般的であり、コマンドループは各コマンドの終わりに不可視テキストの外部へポイントを移動するだろうから、これは実際には必要ない。<a class="link" href="ch21s06.html" title="Adjusting Point After Commands">Adjusting
Point</a>を参照されたい。
</p></dd><dt><span class="term"><code class="literal">field</code>
</span></dt><dd><a id="idm75222992" class="indexterm"/><p>同じ<code class="literal">field</code>プロパティをもつ連続する文字は、<em class="firstterm">フィールド</em>を構成する。<code class="literal">forward-word</code>や<code class="literal">beginning-of-line</code>を含むいくつかの移動関数は、フィールド境界で移動を停止する。<a class="link" href="ch32s19.html#Fields" title="Defining and Using Fields">Fields</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">cursor</code>
</span></dt><dd><a id="idm75214416" class="indexterm"/><p>カーソルは通常、カレントバッファー位置にあるオーバーレイ、およびテキストプロパティ文字列の先頭か終端に表示される。文字に非<code class="literal">nil</code>の<code class="literal">cursor</code>テキストプロパティを与えることにより、それら文字列内の、任意の望む文字にカーソルを置くことができる。加えて<code class="literal">cursor</code>プロパティの値が整数なら、それはカーソルがその文字上に表示されるように、オーバーレイまたは<code class="literal">display</code>プロパティが始まる位置から数えたバッファーの文字位置の数字を指定する。特に、ある文字の<code class="literal">cursor</code>プロパティの値が数字<em class="replaceable"><code>n</code></em>なら、カーソルは範囲<code class="literal">[<em class="replaceable"><code>ovpos</code></em>..<em class="replaceable"><code>ovpos</code></em>+<em class="replaceable"><code>n</code></em>)</code>内の任意のバッファー位置にあるその文字上に表示されるだろう。ここで<em class="replaceable"><code>ovpos</code></em>は<code class="literal">overlay-start</code>(<a class="link" href="ch38s09.html#Managing-Overlays" title="Managing Overlays">Managing
Overlays</a>を参照)により与えられるオーバーレイ開始位置、またはそのバッファー内で<code class="literal">display</code>プロパティが始まる位置である。
</p><p>他の言い方をすると、文字列の非<code class="literal">nil</code>値の<code class="literal">cursor</code>プロパティをもつ文字は、カーソルが表示される文字である。このプロパティの値は、カーソルを表示するバッファーの位置を告げる。値が整数なら、オーバーレイまたは<code class="literal">display</code>プロパティの始まりから<em class="replaceable"><code>n</code></em>後ろの位置までの間にポイントがあるとき、カーソルはそこに表示される。値がそれ以外の非<code class="literal">nil</code>なら、ポイントが<code class="literal">display</code>プロパティの先頭、または<code class="literal">overlay-start</code>の位置だけに表示される。
</p><a id="idm75190480" class="indexterm"/><p>バッファーに多くのオーバーレイ文字列(<a class="link" href="ch38s09.html#Overlay-Properties" title="Overlay Properties">before-string</a>を参照)や文字列であるような<code class="literal">display</code>プロパティがある場合、それらの文字列を走査する間にカーソルを置く箇所をEmacsに合図するために、<code class="literal">cursor</code>プロパティを使用するのは、よいアイデアである。これはLispプログラムやユーザーがカーソルを配したい箇所で、ディスプレイエンジンと直接通信する。
</p></dd><dt><span class="term"><code class="literal">pointer</code>
</span></dt><dd><a id="idm75186384" class="indexterm"/><p>これはそのテキストやイメージ上にマウスポインターがあるときの、特定のマウスシェイプを指定する。利用できるポインターシェイプについては、<a class="link" href="ch29s17.html" title="Pointer Shape">Pointer
Shape</a>を参照されたい。
</p></dd><dt><span class="term"><code class="literal">line-spacing</code>
</span></dt><dd><a id="idm75183824" class="indexterm"/><p>改行は、改行で終わるディスプレイ行の高さを制御するテキストプロパティまたはオーバーレイプロパティ<code class="literal">line-spacing</code>をもつことができる。このプロパティ値は、デフォルトのフレーム行スペーシングと、バッファーローカル変数<code class="literal">line-spacing</code>をオーバーライドする。<a class="link" href="ch38s11.html" title="Line Height">Line
Height</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">line-height</code>
</span></dt><dd><a id="idm75180240" class="indexterm"/><p>改行は、改行で終わるディスプレイ行のトータル高さを制御するテキストプロパティ、またはオーバーレイプロパティ<code class="literal">line-height</code>をもつことができる。<a class="link" href="ch38s11.html" title="Line Height">Line
Height</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">wrap-prefix</code>
</span></dt><dd><p>テキストが<code class="literal">wrap-prefix</code>プロパティをもつなら、それが定義するプレフィクスは、テキストラッピング(text wrapping:
テキスト折り返し)に由来するすべての継続行の先頭に、表示時に追加されるだろう(行が切り詰められた場合、wrap-prefixが使用されることはない)。これは文字列、イメージ(<a class="link" href="ch38s16.html#Other-Display-Specs" title="Other Display Specifications">Other
Display
Specs</a>を参照)、あるいはディスプレイプロパティ<code class="literal">:width</code>または<code class="literal">:align-to</code>(<a class="link" href="ch38s16.html#Specified-Space" title="Specified Spaces">Specified
Space</a>を参照)により指定されて空白文字範囲かもしれない。
</p><p>wrap-prefixはバッファーローカル変数<code class="literal">wrap-prefix</code>を使用して、バッファー全体にも指定され得る(が、<code class="literal">wrap-prefix</code>テキストプロパティは<code class="literal">wrap-prefix</code>変数の値より優先される)。<a class="link" href="ch38s03.html" title="Truncation">Truncation</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">line-prefix</code>
</span></dt><dd><p>テキストが<code class="literal">line-prefix</code>プロパティをもつなら、それが定義するプレフィクスは表示時に、すべての非継続行の先頭に追加されるだろう。これは文字列、イメージ(<a class="link" href="ch38s16.html#Other-Display-Specs" title="Other Display Specifications">Other
Display
Specs</a>を参照)、あるいはディスプレイプロパティ<code class="literal">:width</code>または<code class="literal">:align-to</code>(<a class="link" href="ch38s16.html#Specified-Space" title="Specified Spaces">Specified
Space</a>を参照)により指定されて空白文字範囲かもしれない。
</p><p>line-prefixはバッファーローカル変数<code class="literal">line-prefix</code>を使用して、バッファー全体にも指定され得る(が、<code class="literal">line-prefix</code>テキストプロパティは<code class="literal">line-prefix</code>変数の値より優先される)。<a class="link" href="ch38s03.html" title="Truncation">Truncation</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">modification-hooks</code>
</span></dt><dd><a id="idm75144144" class="indexterm"/><a id="idm75143376" class="indexterm"/><a id="idm75142608" class="indexterm"/><p>ある文字がプロパティ<code class="literal">modification-hooks</code>をもつなら、その値は関数のリストであること。その文字の変更により、実際の変更前にそれらの関数すべてが呼び出される。それぞれの関数は、変更されようとするバッファー部分の先頭と終端という、2つの引数を受け取る。特定のmodificationフック関数が、単一のプリミティブにより変更されつつある複数の文字に出現する場合は、その関数が呼び出される回数を予測することはできない。さらに挿入は既存の文字を変更しないので、このフックは文字の削除、他の文字への置換、またはそれらのテキストプロパティ変更時のみ実行されるだろう。
</p><p>これらの関数がバッファーを変更する場合には、これらのフックを呼び出す内部的メカニズムの混乱を避けるために、それらの関数はそれを行う前後に<code class="literal">inhibit-modification-hooks</code>を<code class="literal">t</code>にバインドするべきである。
</p><p>オーバーレイも<code class="literal">modification-hooks</code>プロパティをサポートするが、詳細は若干異なる(<a class="link" href="ch38s09.html#Overlay-Properties" title="Overlay Properties">Overlay
Properties</a>を参照)。
</p></dd><dt><span class="term"><code class="literal">insert-in-front-hooks</code>
, </span><span class="term"><code class="literal">insert-behind-hooks</code>
</span></dt><dd><a id="idm75136592" class="indexterm"/><a id="idm75135824" class="indexterm"/><p>あるバッファーへの挿入操作は、後続文字の<code class="literal">insert-in-front-hooks</code>プロパティ、および先行文字の<code class="literal">insert-behind-hooks</code>プロパティにリストされる関数も呼び出す。これらの関数は、挿入されるテキストの先頭と終端という、2つの引数を受け取る。関数は、優先される実際の挿入が行われた<span class="emphasis"><em>後に</em></span>呼び出される。
</p><p>バッファー内のテキスト変更。に呼び出される他のフックについては、<a class="link" href="ch32s28.html" title="Change Hooks">Change Hooks</a>も参照されたい。
</p></dd><dt><span class="term"><code class="literal">point-entered</code>
, </span><span class="term"><code class="literal">point-left</code>
</span></dt><dd><a id="idm75130832" class="indexterm"/><a id="idm75130064" class="indexterm"/><a id="idm75129296" class="indexterm"/><p>スペシャルプロパティ<code class="literal">point-entered</code>および<code class="literal">point-left</code>は、ポイント移動をリポートするフック関数を記録する。ポイントを移動するたびに、Emacsは以下の2つのプロパティ値を比較する:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>古い位置の後の文字の<code class="literal">point-left</code>プロパティ。
</p></li><li class="listitem"><p>新しい位置の後の文字の<code class="literal">point-entered</code>プロパティ。
</p></li></ul></div><p>これらの2つの値が異なる場合、(<code class="literal">nil</code>でなければ)古いポイント値と新しいポイント値という2つの引数とともにそれらそれぞれ呼び出される。
</p><p>同じ比較は古い位置と新しい位置の前の文字にたいしても行われる。この結果、2つの<code class="literal">point-left</code>関数(同じ関数かもしれない)、および/または2つの<code class="literal">point-entered</code>関数(同じ関数かもしれない)が実行される可能性がある。ある場合においては、まずすべての<code class="literal">point-left</code>関数が呼び出されて、その後にすべての<code class="literal">point-entered</code>関数が呼び出される。
</p><p>さまざまなバッファー位置にたいして、そこにポイントを移動することなく文字を調べるために、<code class="literal">char-after</code>を使用することができる。実際のポイント値変更だけが、これらのフック関数を呼び出す。
</p><p>変数<code class="literal">inhibit-point-motion-hooks</code>は<code class="literal">point-left</code>および<code class="literal">point-entered</code>のフック実行を抑制できる。<a class="link" href="ch32s19.html#Inhibit-point-motion-hooks">Inhibit
point motion hooks</a>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">composition</code>
</span></dt><dd><a id="idm75117136" class="indexterm"/><p>このテキストプロパティは、文字シーケンスをコンポーネントから構成される単一グリフ(single
glyph)として表示するために使用される。しかしこのプロパティの値自身は完全にEmacsの内部的なものであり、たとえば<code class="literal">put-text-property</code>などにより直接操作するべくではない。
</p></dd></dl></div><pre class="synopsis"><a id="idm75115088" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">inhibit-point-motion-hooks</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="Inhibit-point-motion-hooks"/><p>この変数が非<code class="literal">nil</code>のときは、<code class="literal">point-left</code>と<code class="literal">point-entered</code>のフックは実行されず、<code class="literal">intangible</code>プロパティは効果をもたない。この変数はグローバルにセットせず<code class="literal">let</code>でバインドすること。
</p></blockquote></div><pre class="synopsis"><a id="idm75109584" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">show-help-function</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="Help-display"/><p>この変数が非<code class="literal">nil</code>なら、それはヘルプ文字列を表示するために呼び出される関数を指定する。これらは<code class="literal">help-echo</code>プロパティ、メニューヘルプ文字列(<a class="link" href="ch22s17.html#Simple-Menu-Items" title="Simple Menu Items">Simple
Menu Items</a>と<a class="link" href="ch22s17.html#Extended-Menu-Items" title="Extended Menu Items">Extended Menu Items</a>を参照)、ツールバーヘルプ文字列(<a class="link" href="ch22s17.html#Tool-Bar" title="Tool bars">Tool
Bar</a>を参照)かもしれない。指定された関数は、表示するためのヘルプ文字列という、単一の引数とともに呼び出される。Tooltipモード(section “Tooltips” in <em class="citetitle">The GNU Emacs Manual</em>を参照)が、例を提供している。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Format-Properties"/>Formatted Text Properties</h2></div></div></div><p>以下のテキストプロパティは、フィルコマンドの挙動に影響を与えます。これらはフォーマットされたテキストを表すために使用されます。<a class="link" href="ch32s11.html" title="Filling">Filling</a>および<a class="link" href="ch32s12.html" title="Margins for Filling">Margins</a>を参照してください。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">hard</code>
</span></dt><dd><p>改行文字がこのプロパティをもつなら、それは“hard”改行である。フィルコマンドはhard改行を変更せず、それらを横断して単語を移動しない。しかしこのプロパティは、マイナーモード<code class="literal">use-hard-newlines</code>が有効な場合のみ影響を与える。section “Hard and Soft Newlines” in <em class="citetitle">The GNU Emacs
Manual</em>を参照のこと。
</p></dd><dt><span class="term"><code class="literal">right-margin</code>
</span></dt><dd><p>このプロパティは、その部分のテキストのフィルにたいして、余分な右マージンを指定する。
</p></dd><dt><span class="term"><code class="literal">left-margin</code>
</span></dt><dd><p>このプロパティは、その部分のテキストのフィルにたいして、余分な左マージンを指定する。
</p></dd><dt><span class="term"><code class="literal">justification</code>
</span></dt><dd><p>このプロパティは、その部分のテキストのフィルにたいして、位置揃え(justification)のスタイルを指定する。
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Sticky-Properties"/>Stickiness of Text Properties</h2></div></div></div><a id="idm75081552" class="indexterm"/><a id="idm75080784" class="indexterm"/><p>自己挿入文字は通常、先行する文字と同じプロパティをもちます。これはプロパティの<em class="firstterm">継承(inheritance)</em>と呼ばれます。
</p><p>Lispプログラムは継承の有無に関わらず挿入を行うことができ、それは挿入プリミティブの選択に依存します。<code class="literal">insert</code>のような通常のテキスト挿入関数は、何もプロパティを継承しません。これらは挿入される文字列と正確に同じプロパティをもち、それ以外のプロパティはもちません。これはたとえばkillリング外部にたいしてのように、あるコンテキストから他のコンテキストにテキストをコピーするプログラムにたいして適正です。継承つきで挿入を行うためには、このセクションで説明するスペシャルプリミティブを使用します。自己挿入文字は、これらのプリミティブを使用するので、プロパティを継承するのです。
</p><p>継承つきで挿入を行う際に、<span class="emphasis"><em>どの</em></span>プロパティがどこから継承されるかは、<em class="firstterm">sticky(スティッキー、粘着する)</em>に依存します。ある文字の後への挿入における、それらのモジノプロパティ継承は<em class="firstterm">rear-sticky(後方スティッキー)</em>です。ある文字の前への挿入における、それらのモジノプロパティ継承は<em class="firstterm">front-sticky(前方スティッキー)</em>です。これら両側のstickyが、同じプロパティにたいして異なるsticky値をもつ場合は、前の文字の値が優先します。
</p><p>デフォルトでは、テキストプロパティはfront-stickyではなく、rear-stickyです。したがってデフォルトでは、すべてのプロパティは前の文字から継承し、後の文字からは何も継承しません。
</p><p>さまざまなテキストプロパティのstickiness(スティッキネス、スティッキー性、粘着性、粘着度)はは、2つのテキストプロパティ<code class="literal">front-sticky</code>および<code class="literal">rear-nonsticky</code>と、変数<code class="literal">text-property-default-nonsticky</code>で制御できます。与えられたプロパティにたいして異なるデフォルトを指定するために、この変数を使用できます。テキストの任意の特定部分に特定のプロパティsticky、または非stickyを指定するために、これら2つのテキストプロパティを使用できます。
</p><p>ある文字の<code class="literal">front-sticky</code>プロパティが<code class="literal">t</code>なら、その文字のすべてのプロパティはfront-stickyです。<code class="literal">front-sticky</code>プロパティがリストなら、その文字のstickyなプロパティは、名前がそのリスト内にあるプロパティです。たとえばある文字が値が<code class="literal">(face
read-only)</code>であるような<code class="literal">front-sticky</code>プロパティをもつなら、その文字の前への挿入ではその文字の<code class="literal">face</code>プロパティと<code class="literal">read-only</code>プロパティは継承できますが、他のプロパティはｐ継承できません。
</p><p><code class="literal">rear-nonsticky</code>は逆の方法で機能します。ほとんどのプロパティはデフォルトでrear-stickyであり、<code class="literal">rear-nonsticky</code>プロパティはどのプロパティがrear-sticky<span class="emphasis"><em>ではない</em></span>かを告げますある文字の<code class="literal">rear-nosticky</code>プロパティが<code class="literal">t</code>なら、その文字のすべてのプロパティはrear-stickyではありません。<code class="literal">rear-nosticky</code>プロパティがリストなら、その文字のstickyなプロパティは、名前がそのリスト内に<span class="emphasis"><em>ない</em></span>プロパティです。
</p><pre class="synopsis"><a id="idm75062096" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">text-property-default-nonsticky</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、さまざまなテキストプロパティのデフォルトのrear-stickinessを定義するalistである。各要素は<code class="literal">(<em class="replaceable"><code>property</code></em>
.
<em class="replaceable"><code>nonstickiness</code></em>)</code>という形式をもち、これは特定のテキストプロパティ<em class="replaceable"><code>property</code></em>のstickinessを定義する。
</p><p><em class="replaceable"><code>nonstickiness</code></em>が非<code class="literal">nil</code>なら、それはプロパティ<em class="replaceable"><code>property</code></em>がデフォルトでrear-nonstickyであることを意味する。すべてのプロパティはデフォルトでfront-nonstickyなので、これにより<em class="replaceable"><code>property</code></em>は両方向にたいしてデフォルトでnonstickyになる。
</p><p>テキストプロパティ<code class="literal">front-sticky</code>および<code class="literal">rear-nonsticky</code>が使用された際には、<code class="literal">text-property-default-nonsticky</code>内で指定されたデフォルトの<em class="replaceable"><code>nonstickiness</code></em>より優先される。
</p></blockquote></div><p>以下はプロパティ継承つきでテキストを挿入する関数です:
</p><pre class="synopsis"><a id="idm75053136" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">insert-and-inherit</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>strings</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>関数<code class="literal">insert</code>と同じように文字列<em class="replaceable"><code>strings</code></em>を挿入するが、隣接するテキストからすべてのstickyなプロパティを継承する。
</p></blockquote></div><pre class="synopsis"><a id="idm75044560" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">insert-before-markers-and-inherit</code> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>strings</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>関数<code class="literal">insert-before-markers</code>と同じように文字列<em class="replaceable"><code>strings</code></em>を挿入するが、隣接するテキストからすべてのstickyなプロパティを継承する。
</p></blockquote></div><p>継承を行わない通常の挿入関数については、<a class="link" href="ch32s04.html" title="Inserting Text">Insertion</a>を参照してください。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Lazy-Properties"/>Lazy Computation of Text Properties</h2></div></div></div><p>バッファー内のすべてのテキストにたいしてテキストプロパティを計算するかわりに、何かがテキスト範囲に依存している場合、その際はテキストプロパティを計算するようにアレンジできます。
</p><p>プロパティとともにバッファーからテキストを抽出するプリミティブは、<code class="literal">buffer-substring</code>です。プロパティを調べる前に、この関数はアブノーマルフック<code class="literal">buffer-access-fontify-functions</code>を実行します。
</p><pre class="synopsis"><a id="idm75032272" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">buffer-access-fontify-functions</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、テキストプロパティ計算用の関数のリストを保持する。<code class="literal">buffer-substring</code>がバッファーの一部のテキストとテキストプロパティをコピーする前に、このリスト内の関数すべてを呼び出す。各関数はアクセスされるバッファー範囲を指定する、2つの引数を受け取る(バッファーは常にカレントバッファーとなる)。
</p></blockquote></div><p>関数<code class="literal">buffer-substring-no-properties</code>はいずれにせよテキストプロパティを無視するので、これらの関数を呼び出さない。
</p><p>同じバッファー部分にたいして複数回フック関数が呼び出されるのを防ぐには、変数<code class="literal">buffer-access-fontified-property</code>を使用できる。
</p><pre class="synopsis"><a id="idm75027024" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">buffer-access-fontified-property</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値が非<code class="literal">nil</code>なら、それはテキストプロパティ名として使用されるシンボルである。そのテキストプロパティにたいする非<code class="literal">nil</code>値は、“その文字にたいする他のテキストプロパティはすでに計算済み”であることを意味する。
</p><p><code class="literal">buffer-substring</code>にたいして指定された範囲内のすべての文字が、このプロパティにたいする値として非<code class="literal">nil</code>をもつなら、<code class="literal">buffer-substring</code>は<code class="literal">buffer-access-fontify-functions</code>の関数を呼び出さない。それらの文字がすでに正しいテキストプロパティをもつとみなし、それらがすでに所有するプロパティを単にコピーする。
</p><p><code class="literal">buffer-access-fontify-functions</code>の関数にこのプロパティ、同様に他のプロパティを処理対象の文字に追加させるのが、この機能の通常の用途である。この方法では、同じテキストにたいして、それらの関数が何度も呼び出されるのを防ぐことができる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Clickable-Text"/>Defining Clickable Text</h2></div></div></div><a id="idm75019344" class="indexterm"/><a id="idm75018576" class="indexterm"/><a id="idm75017808" class="indexterm"/><p><em class="firstterm">クリック可能テキスト(clickable
text)</em>とは何らかの結果を生成するために、マウス、またはキーボードコマンドを通じてクリックできるテキストです。多くのメジャーモードがテキスト的なハイパーリンク、略して<em class="firstterm">リンク(link)</em>を実装するために、クリック可能テキストを使用しています。
</p><p>リンクを挿入および操作するもっとも簡単な方法は、<code class="literal">button</code>パッケージの使用です。<a class="link" href="ch38s18.html" title="Buttons">Buttons</a>を参照してください。このセクションではテキストプロパティを使用して、バッファー内に手作業でクリック可能テキストをセットアップする方法を説明します。簡略にするために、クリック可能テキストを<em class="firstterm">リンク</em>と呼ぶことにします。
</p><p>リンクの実装には、(1)リンク上にマウスが移動した際にクリック可能であることを示し、(2)そのリンク上の<span class="keycap"><strong>RET</strong></span>か<strong class="userinput"><code>Mouse-2</code></strong>で何かを行うようにして、(3)そのリンクが<code class="literal">mouse-1-click-follows-link</code>にしたがうよう<code class="literal">follow-link</code>をセットアップする、という3つのステップが含まれます。
</p><p>クリック可能を示すためには、そのリンクのテキストに<code class="literal">mouse-face</code>プロパティを追加します。すると、以降Emacsはマウスがその上に移動した際にリンクをハイライトするでしょう。加えて<code class="literal">help-echo</code>テキストプロパティを使用して、ツールチップかエコーエリアメッセージを定義するべきです。<a class="link" href="ch32s19.html#Special-Properties" title="Properties with Special Meanings">Special
Properties</a>を参照してください。たとえば以下は、Diredがファイル名がクリック可能なことを示す方法です:
</p><pre class="screen"> (if (dired-move-to-filename)
     (add-text-properties
       (point)
       (save-excursion
         (dired-move-to-end-of-filename)
         (point))
       '(mouse-face highlight
         help-echo "mouse-2: visit this file in other window")))
</pre><p>リンクをクリック可能にするためには、
<span class="keycap"><strong>RET</strong></span>と<strong class="userinput"><code>Mouse-2</code></strong>を望むアクションを行うコマンドにバインドします。各コマンドは、リンク上から呼び出されたかチェックして、それに応じて動作するべきです。たとえばDiredメジャーモードのキーマップは、<strong class="userinput"><code>Mouse-2</code></strong>を以下のコマンドにバインドします:
</p><pre class="screen">(defun dired-mouse-find-file-other-window (event)
  "In Dired, visit the file or directory name you click on."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (progn
              (select-window window)
              (dired-other-window file)))
      (select-window window)
      (find-file-other-window (file-name-sans-versions file t)))))
</pre><p>このコマンドはクリックがどこで発生したかを判断するために、関数<code class="literal">posn-window</code>と<code class="literal">posn-point</code>、visitするファイルの判断に関数<code class="literal">dired-get-file-for-visit</code>を使用します。
</p><p>マウスコマンドをメジャーモードキーマップ内でバインドするかわりに、<code class="literal">keymap</code>プロパティ(<a class="link" href="ch32s19.html#Special-Properties" title="Properties with Special Meanings">Special
Properties</a>を参照)を使用して、リンクテキスト内でバインドできます。たとえば:
</p><pre class="screen">(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property link-start link-end 'keymap map))
</pre><p>この手法では、異なるリンクに異なるコマンドを簡単に定義できます。さらに、そのバッファー内の残りのテキストにたいしては、<span class="keycap"><strong>RET</strong></span>と<strong class="userinput"><code>Mouse-2</code></strong>のグローバル定義を利用可能なまま残すことができます。
</p><a id="idm75001680" class="indexterm"/><p>リンク上でのクリックにたいするEmacsの基本コマンドは、<strong class="userinput"><code>Mouse-2</code></strong>です。しかし他のグラフィカルなアプリケーションとの互換性のために、ユーザーがマウスを動かさずに素早くリンクをクリックするという条件の下、Emacsはリンク上での<strong class="userinput"><code>Mouse-1</code></strong>クリックも認識します。おこ振る舞いは、ユーザーオプション<code class="literal">mouse-1-click-follows-link</code>により制御されます。section “Mouse
References” in <em class="citetitle">The GNU Emacs Manual</em>を参照してください。
</p><a id="idm74986320" class="indexterm"/><p><code class="literal">mouse-1-click-follows-link</code>にしたがうようにリンクをセットアップするには、(1)そのテキストに<code class="literal">follow-link</code>テキストプロパティまたはオーバーレイプロパティを適用する、または(2)<code class="literal">follow-link</code>イベントをキーマップ(<code class="literal">keymap</code>テキストプロパティを通じたメジャーモードキーマップまたはローカルキーマップ)にバインドするかの、いずれかを行わなければなりません。<code class="literal">follow-link</code>プロパティの値、または<code class="literal">follow-link</code>イベントにたいするバインディングはリンクアクションにたいする“コンディション(condition)”として機能します。この条件は、Emacsにたいして2つのことを告げます。それは<strong class="userinput"><code>Mouse-1</code></strong>のクリックがそのリンクの“内側”で発生したとみなすべき状況、そして<strong class="userinput"><code>Mouse-1</code></strong>のクリックを何に変換するかを告げる“アクションコード(action
code)”を計算する方法です。そのリンクのアクション条件は、以下のうちの1つです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">mouse-face</code>
</span></dt><dd><p>コンディションがシンボル<code class="literal">mouse-face</code>の場合、その位置に非<code class="literal">nil</code>の<code class="literal">mouse-face</code>プロパティがあれば、それはリンク内側の位置である。アクションコードは常に<code class="literal">t</code>。
</p><p>以下はInfoモードが<span class="keycap"><strong>Mouse-1</strong></span>を処理する例である:
</p><pre class="screen">(define-key Info-mode-map [follow-link] 'mouse-face)
</pre></dd><dt><span class="term">関数
</span></dt><dd><p>コンディションが関数<em class="replaceable"><code>func</code></em>の場合、<code class="literal">(<em class="replaceable"><code>func</code></em>
<em class="replaceable"><code>pos</code></em>)</code>が非<code class="literal">nil</code>に評価されれば、位置<em class="replaceable"><code>pos</code></em>はリンクの内側である。<em class="replaceable"><code>func</code></em>がリターンする値は、アクションコードとして機能する。
</p><p>以下はpcvsがファイル名の上でのみ<strong class="userinput"><code>Mouse-1</code></strong>によるリンクのフォローを有効にする方法の例である:
</p><pre class="screen">(define-key map [follow-link]
  (lambda (pos)
    (eq (get-char-property pos 'face) 'cvs-filename-face)))
</pre></dd><dt><span class="term">その他
</span></dt><dd><p>コンディション値がそれ以外の場合、その位置はリンク内側であり、そのコンディション自体がアクションコードである。(バッファー全体に適用されないように)リンクテキストのテキストプロパティまたはオーバーレイプロパティを通じてコンディションを適用するときのみ、この類のコンディションを指定すべきなのは明確である。
</p></dd></dl></div><p>アクションコードは、<strong class="userinput"><code>Mouse-1</code></strong>がリンクをフォローする方法を告げます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">文字列またはベクター
</span></dt><dd><p>アクションコードが文字列かベクターなら、<strong class="userinput"><code>Mouse-1</code></strong>イベントは文字列またはベクターの最初の要素に変換される。つまり<strong class="userinput"><code>Mouse-1</code></strong>クリックのアクションは、その文字またはシンボルのローカルまたはグローバルバインディングである。したがってアクションコードが<code class="literal">"foo"</code>なら、<strong class="userinput"><code>Mouse-1</code></strong>は<strong class="userinput"><code>f</code></strong>に変換され、<code class="literal">[foo]</code>なら<strong class="userinput"><code>Mouse-1</code></strong>は<span class="keycap"><strong>foo</strong></span>に変換される。
</p></dd><dt><span class="term">その他
</span></dt><dd><p>その他非<code class="literal">nil</code>のアクションコードでは、<strong class="userinput"><code>Mouse-1</code></strong>イベントは同じ位置の<strong class="userinput"><code>Mouse-2</code></strong>イベントに変換される。
</p></dd></dl></div><p><code class="literal">define-button-type</code>で定義されるボタンをアクティブにするように<strong class="userinput"><code>Mouse-1</code></strong>を定義するには、そのボタンに<code class="literal">follow-link</code>プロパティを与えます。このプロパティの値は、上述したリンクのアクションコンディションであること。<a class="link" href="ch38s18.html" title="Buttons">Buttons</a>を参照のこと。たとえば以下はHelpモードが<strong class="userinput"><code>Mouse-1</code></strong>を処理する例である。
</p><pre class="screen">(define-button-type 'help-xref
  'follow-link t
  'action #'help-button-action)
</pre><p><code class="literal">define-widget</code>で定義されたウィジェットに<strong class="userinput"><code>Mouse-1</code></strong>を定義するには、そのウィジェットに<code class="literal">:follow-link</code>プロパティを与えます。このプロパティの値は、上述したようなリンクのアクションコンディションであるべきです。たとえば、以下は<span class="keycap"><strong>Mouse-1</strong></span>クリックが<span class="keycap"><strong>RET</strong></span>に変換されるように、<code class="literal">link</code>ウィジェットを指定する方法の例をです:
</p><pre class="screen">(define-widget 'link 'item
  "An embedded link."
  :button-prefix 'widget-link-prefix
  :button-suffix 'widget-link-suffix
  :follow-link "\C-m"
  :help-echo "Follow the link."
  :format "%[%t%]")
</pre><pre class="synopsis"><a id="idm74954320" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">mouse-on-link-p</code> <em class="replaceable"><code>pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファー内の位置<em class="replaceable"><code>pos</code></em>がリンク上なら、非<code class="literal">nil</code>をリターンする。<em class="replaceable"><code>pos</code></em>は<code class="literal">event-start</code>がリターンするようなマウスイベント位置でもよい(<a class="link" href="ch21s07.html#Accessing-Mouse" title="Accessing Mouse Events">Accessing
Mouse</a>を参照)。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Fields"/>Defining and Using Fields</h2></div></div></div><a id="idm74948048" class="indexterm"/><p>フィールドとはバッファー内にある連続する文字範囲であり、<code class="literal">field</code>プロパティ(テキストプロパティかオーバーレイプロパティ)に同じ値(<code class="literal">eq</code>で比較)をもつことにより識別されます。このセクションでは、フィールドの操作に利用できるスペシャル関数を説明します。
</p><p>フィールドは、バッファー位置<em class="replaceable"><code>pos</code></em>で指定します。各フィールドはバッファー位置の範囲を含むと考えて、指定した位置はその位置を含むフィールドを表します。
</p><p><em class="replaceable"><code>pos</code></em>の前または後の文字は同じフィールドに属し、どのフィールドが<em class="replaceable"><code>pos</code></em>を含むかという疑問はありません。それらの文字が属するフィールドが、そのフィールドです。<em class="replaceable"><code>pos</code></em>がフィールド境界のときは、それがどのフィールドに属すかは、取り囲む2つの文字の<code class="literal">field</code>プロパティのstickinessに依存します(<a class="link" href="ch32s19.html#Sticky-Properties" title="Stickiness of Text Properties">Sticky
Properties</a>を参照)。<em class="replaceable"><code>pos</code></em>に挿入されたテキストからプロパティが継承されたフィールドが、<em class="replaceable"><code>pos</code></em>を含むフィールドです。
</p><p><em class="replaceable"><code>pos</code></em>に新たに挿入されたテキストが、いずれの側からも<code class="literal">field</code>プロパティを継承しない、異常なケースがあります。これは前の文字の<code class="literal">field</code>プロパティがrear-stickyでなく、後の文字の<code class="literal">field</code>プロパティがfront-stickyでもない場合に発生します。このケースでは、<em class="replaceable"><code>pos</code></em>は前のフィールドと後のフィールドいずれにも属しません。フィールド関数はそれを、開始と終了が<em class="replaceable"><code>pos</code></em>の空フィールドに属するものとして扱います。
</p><p>これらすべての関数では、<em class="replaceable"><code>pos</code></em>が省略または<code class="literal">nil</code>の場合は、ポイントの値がデフォルトとして使用されます。ナローイング(narrowing)が効力をもつ場合、<em class="replaceable"><code>pos</code></em>はアクセス可能部分にあるはずです。<a class="link" href="ch30s04.html" title="Narrowing">Narrowing</a>を参照してください。
</p><pre class="synopsis"><a id="idm74936400" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">field-beginning</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>escape-from-edge</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>pos</code></em>で指定されたフィールドの先頭をリターンする。
</p><p><em class="replaceable"><code>pos</code></em>が自身のフィールド先頭にあり、かつ<em class="replaceable"><code>escape-from-edge</code></em>が非<code class="literal">nil</code>なら、<em class="replaceable"><code>pos</code></em>周辺の<code class="literal">field</code>プロパティのstickinessに関わらず、リターン値は常に<em class="replaceable"><code>pos</code></em>が終端であるような前のフィールドの先頭になる。
</p><p><em class="replaceable"><code>limit</code></em>が非<code class="literal">nil</code>なら、それはバッファーの位置である。そのフィールドの先頭が<em class="replaceable"><code>limit</code></em>より前なら、かわりに<em class="replaceable"><code>limit</code></em>がリターンされるだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm74926928" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">field-end</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em> <em class="replaceable"><code>escape-from-edge</code></em> <em class="replaceable"><code>limit</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>pos</code></em>で指定されるフィールドの終端をリターンする。
</p><p><em class="replaceable"><code>pos</code></em>が自身のフィールド終端にあり、かつ<em class="replaceable"><code>escape-from-edge</code></em>が非<code class="literal">nil</code>なら、<em class="replaceable"><code>pos</code></em>周辺の<code class="literal">field</code>プロパティのstickinessに関わらず、リターン値は常に<em class="replaceable"><code>pos</code></em>が<span class="emphasis"><em>先頭</em></span>であるような後のフィールドの終端になる。
</p><p><em class="replaceable"><code>limit</code></em>が非<code class="literal">nil</code>なら、それはバッファーの位置である。そのフィールドの終端が<em class="replaceable"><code>limit</code></em>より後なら、かわりに<em class="replaceable"><code>limit</code></em>がリターンされるだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm74917072" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">field-string</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>pos</code></em>で指定されるフィールドのコンテンツを、文字列としてリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm74913104" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">field-string-no-properties</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>pos</code></em>で指定されるフィールドのコンテンツを、テキストプロパティを無視して、文字列としてリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm74909136" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">delete-field</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>pos</code></em>で指定されるフィールドのテキストを削除する。
</p></blockquote></div><pre class="synopsis"><a id="idm74905168" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">constrain-to-field</code> <em class="replaceable"><code>new-pos</code></em> <em class="replaceable"><code>old-pos</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>escape-from-edge</code></em> <em class="replaceable"><code>only-in-line</code></em> <em class="replaceable"><code>inhibit-capture-property</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>new-pos</code></em>を<em class="replaceable"><code>old-pos</code></em>が属するフィールドに“拘束(constrain)”する。別の言い方をすると、これは
<em class="replaceable"><code>old-pos</code></em>と同じフィールド内で<em class="replaceable"><code>new-pos</code></em>にもっとも近い位置をリターンする。
</p><p><em class="replaceable"><code>new-pos</code></em>が<code class="literal">nil</code>なら、<code class="literal">constrain-to-field</code>はかわりにポイントの値を使用して、ポイントをリターンすることに加えて、その位置にポイントを移動する。
</p><p><em class="replaceable"><code>old-pos</code></em>が2つのフィールドの境界なら、許容できる最後の位置は引数<em class="replaceable"><code>escape-from-edge</code></em>に依存する。<em class="replaceable"><code>escape-from-edge</code></em>が<code class="literal">nil</code>なら、<em class="replaceable"><code>new-pos</code></em>は新たに文字が<em class="replaceable"><code>old-pos</code></em>が挿入されたときに、継承するであろう値と<code class="literal">field</code>プロパティが等しいフィールドでなければならない<em class="replaceable"><code>escape-from-edge</code></em>がｐ非<code class="literal">nil</code>なら、<em class="replaceable"><code>new-pos</code></em>は隣接する2つのフィールド内のどこでも構わない。さらに、2つのフィールドが特別な値<code class="literal">boundary</code>により、他のフィールドで分割されている場合、このスペシャルフィールド内のすべてのポイントも、“境界上”とみなされる。
</p><p>引数なしの<strong class="userinput"><code>C-a</code></strong>コマンドのように、特別な類の位置に後方へ移動して一度そこに留まるには、おそらく<em class="replaceable"><code>escape-from-edge</code></em>にたいして<code class="literal">nil</code>を指定するべきであろう。フィールドをチェックする他の移動コマンドにたいしては、おそらく<code class="literal">t</code>を渡すべきである。
</p><p>オプション引数<em class="replaceable"><code>only-in-line</code></em>が非<code class="literal">nil</code>、かつ<em class="replaceable"><code>new-pos</code></em>を通常の方法により拘束することにより異なる行へ移動するような場合、<em class="replaceable"><code>new-pos</code></em>は非拘束でリターンされる。これは<code class="literal">next-line</code>や<code class="literal">beginning-of-line</code>のような行単位の移動コマンドで、それらのコマンドが正しい行へ移動できる場合だけフィールド境界を尊重するようにするために用いられる。
</p><p>オプション引数<em class="replaceable"><code>inhibit-capture-property</code></em>が非<code class="literal">nil</code>、かつ<em class="replaceable"><code>old-pos</code></em>がその名前の非<code class="literal">nil</code>なプロパティをもつなら、すべてのフィールド境界は無視される。
</p><p>変数<code class="literal">inhibit-field-text-motion</code>を非<code class="literal">nil</code>値にバインドすることにより、<code class="literal">constrain-to-field</code>にすべてのフィールド境界を無視(何者にも拘束されることがない)させることができる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Not-Intervals"/>Why Text Properties are not Intervals</h2></div></div></div><a id="idm74868944" class="indexterm"/><p>ユーザーにテキスト内の“インターバル(訳注:
原文のインターバルはIT用語としては時間や距離などの間隔を示す用語として用いれることが多いと思いますが、ここでは『範囲』を示す言葉として用いられているようです。他の箇所で『範囲』と訳したrange等と異なる機能なので、ここではそのまま『インターバル』としました)”を指定させて、そのインターバルにプロパティを追加するために、バッファー内のテキストへの属性の追加をサポートするエディターがいくつかあります。それらのエディターは、ユーザーやプログラマーが個別にインターバルの開始と終了を決定することを許可します。わたしたちは、テキスト変更に関連する特定の逆説的振る舞いを避けるために、Emacs
Lisp内に、故意に異なる種類のインターフェイスを提供しました。
</p><p>複数のインターバルに細分化することが実際に意味をもつなら、それは特定のプロパティをもつ単一のインターバルのバッファーと、同じテキストをもち、両方が同じプロパティをもつ2つのインターバルに分割されたバッファーを区別できることを意味します。
</p><p>インターバルを1つだけもつバッファーがあり、その一部をkillすることを考えてみてください。そのそのバッファーに残されるのは1つのインターバルであり、killリング(とundoリスト)内のコピーは別個のインターバルになります。そのkillされたテキストをyankで戻すと、同じプロパティをもつ2つのインターバルを得ることになります。したがって、編集では1つのインターバルと2つのインターバルの違いは保たれません。
</p><p>テキスト挿入時に2つのインターバルを結合することにより、この問題に“対応”したとします。これは、そのバッファーが元々単一のインターバルだったなら、上手く機能します。
しかし、かわりに同じプロパティをもつ隣接する2つのインターバルがあり、そのうちの1つのインターバルからテキストをkillして、それをyankで戻すことを考えてみてください。あるケースを解決する同じインターバル結合機能が、他のケースにおいては問題を引き起こすのです。このyank後、インターバルはただ1つとなります。繰り返します、編集では1つのインターバルと2つのインターバルの違いは保たれないのです。
</p><p>インターバルの間の境界上へのテキスト挿入でも、満足できる回答かない問題が発生します。
</p><p>しかし、“バッファーにあるテキスト位置または文字列位置のプロパティは何?”という形式の問にたいして、編集が一貫した振る舞いをするようアレンジするのは簡単です。そこで、わたしたちはこれらが合理的な唯一の問いであると判断したのです。わたしたちはインターバルの開始と終了の場所を問うような実装をしませんでした。
</p><p>実際には、明白にインターバル境界であるような箇所では、通常はテキストプロパティ検索関数を使用できます。可能であるならインターバルは常に結合されるとみなすことにより、それらがインターバル境界を探すと考えることができます。<a class="link" href="ch32s19.html#Property-Search" title="Text Property Search Functions">Property
Search</a>を参照してください。
</p><p>Emacsはプレゼンテーション機能として、明示的なインターバルも提供します。<a class="link" href="ch38s09.html" title="Overlays">Overlays</a>を参照してください。
</p></div></div></body></html>