<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Atomic Change Groups</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Atomic-Changes"/>Atomic Change Groups</h1></div></div></div><a id="idm74612688" class="indexterm"/><p>データベース用語で<em class="firstterm">アトミック(atomic:
原子的、不可分な)</em>変更とは、全体として成功もしくは失敗することはできるが、部分的にはできない、個別の変更のことです。Lispプログラムは単一もしくは複数のバッファーにたいする一連の変更を<em class="firstterm">アトミック変更グループ(atomic
change
group)</em>にすることができます。これはその一連の変更全体が、それらのバッファーに適用されるか、またはエラーの場合は何も適用されないかの、いずれかであることを意味します。
</p><p>すでにカレントであるような単一のバッファーにたいしてこれを行うには、以下のように変更を行うこーの周りに、単に<code class="literal">atomic-change-group</code>の呼び出しを記述します:
</p><pre class="screen">(atomic-change-group
  (insert foo)
  (delete-region x y))
</pre><p><code class="literal">atomic-change-group</code>のbody内部でエラー(またはその他の非ローカルexit)が発生した場合は、そのbody実行の間にそのバッファーでのすべての変更が行われなかったことになります。この類の変更グループは、他のバッファーには影響を与えず、それらのバッファーにたいする変更はそのまま残されます。
</p><p>さまざまなバッファー内で行った変更から1つのアトミックグループを構成する等、より複雑な何かを必要とする場合は、<code class="literal">atomic-change-group</code>が使用する、より低レベルな関数を直接呼び出さなければなりません。
</p><pre class="synopsis"><a id="idm74603344" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">prepare-change-group</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>buffer</code></em>(デフォルトはカレントバッファー)にたいする変更グループをセットアップする。これは、その変更グループを表す“handle”をリターンする。変更グループをactivateしたり、その後でそれを完了するためには、このhandleを使用しなければならない。
</p></blockquote></div><p>変更グループを使用するためには、それを<em class="firstterm">activate(アクティブ化)</em>しなければなりません。これは<em class="replaceable"><code>buffer</code></em>のテキストを変更する前に行わなければなりません。
</p><pre class="synopsis"><a id="idm74598224" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">activate-change-group</code> <em class="replaceable"><code>handle</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは、<em class="replaceable"><code>handle</code></em>が指定する変更グループをactiveにする。
</p></blockquote></div><p>変更グループをactivateした後は、そのバッファー内で行ったすべての変更は、その変更グループの一部となります。そのバッファー内で目論んでいたすべての変更を行ったら、その変更グループを<em class="firstterm">finish(完了)</em>しなければなりません。すべての変更を受け入れる(確定する)か、すべてをキャンセルするという2つの方法により、これを行うことができます。
</p><pre class="synopsis"><a id="idm74593872" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">accept-change-group</code> <em class="replaceable"><code>handle</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>handle</code></em>により指定される変更グループ内のすべての変更にたいして、finalizeすることにより変更を受け入れる。
</p></blockquote></div><pre class="synopsis"><a id="idm74586192" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">cancel-change-group</code> <em class="replaceable"><code>handle</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>handle</code></em>により指定される変更グループ内のすべての変更をキャンセルしてundoする。
</p></blockquote></div><p>グループが常に確実にfinishされるようにするために、コードでは<code class="literal">unwind-protect</code>を使用するべきです。<code class="literal">activate-change-group</code>の呼び出しは、実行直後にユーザーが<strong class="userinput"><code>C-g</code></strong>をタイプする場合に備え、<code class="literal">unwind-protect</code>内部にあるべきです(これが<code class="literal">prepare-change-group</code>と<code class="literal">activate-change-group</code>が別関数となっている1つの理由である。なぜなら通常は<code class="literal">unwind-protect</code>開始前に<code class="literal">prepare-change-group</code>を呼び出すであろうから)。グループを一度finishしたら、そのhandleを再度使用してはなりません。特に、同じ変更グループを2回finishしないでください。
</p><p>複数バッファー変更グループ(multibuffer change
group)を作成するためには、カバーしたいバッファーそれぞれで<code class="literal">prepare-change-group</code>を一度呼び出してから、以下のようにリターン値を結合するために、<code class="literal">nconc</code>を使用してください:
</p><pre class="screen">(nconc (prepare-change-group buffer-1)
       (prepare-change-group buffer-2))
</pre><p>その後は1回の<code class="literal">activate-change-group</code>呼び出しで複数変更グループをアクティブにして、1回の<code class="literal">accept-change-group</code>または<code class="literal">cancel-change-group</code>呼び出しで、それをfinishしてください。
</p><p>同一バッファーにたいするネストされた複数の変更グループ使用は、あなたが期待するであろう通り機能します。同一バッファーにたいするネストされていない変更グループ使用により、Emacsが混乱した状態になるため、これが発生しないようにしてください。与えられた何らかのバッファーにたいして最初に開始した変更グループは、最後にfinishする変更グループです。
</p></div></body></html>