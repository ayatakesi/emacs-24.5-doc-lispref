<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Regular Expressions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Regular-Expressions"/>Regular Expressions</h1></div></div></div><a id="idm77432912" class="indexterm"/><a id="idm77432144" class="indexterm"/><p><em class="firstterm">正規表現(regular
expression)</em>、略して<em class="firstterm">regexp</em>は、文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索は、とても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。
</p><a id="idm77430352" class="indexterm"/><a id="idm77429584" class="indexterm"/><p>正規表現を対話的に開発するために、<strong class="userinput"><code>M-x
re-builder</code></strong>コマンドを使用できます。このコマンドは、別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともに、ターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Syntax-of-Regexps"/>Syntax of Regular Expressions</h2></div></div></div><a id="idm77427024" class="indexterm"/><a id="idm77426256" class="indexterm"/><p>正規表現は、少数の文字が特別な構成要素で、残りは<em class="firstterm">通常</em>の文字であるような構文をもちます。通常の文字は、その文字自身だけにマッチする、シンプルな正規表現です。特別な文字は‘<code class="literal">.</code>’、‘<code class="literal">*</code>’、‘<code class="literal">+</code>’、‘<code class="literal">?</code>’、‘<code class="literal">[</code>’、‘<code class="literal">^</code>’、‘<code class="literal">$</code>’、および‘<code class="literal">\</code>’です。将来、新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合、‘<code class="literal">]</code>’はスペシャル文字です。文字候補の間では、‘<code class="literal">-</code>’はスペシャル文字です。‘<code class="literal">[:</code>’と、対応する‘<code class="literal">:]</code>’は、文字候補内の文字クラスです。正規表現内に出現する他の文字は、‘<code class="literal">\</code>’が前置されていない限り、通常の文字です。
</p><p>たとえば‘<code class="literal">f</code>’はスペシャル文字ではなく通常文字なので、‘<code class="literal">f</code>’は文字列‘<code class="literal">f</code>’にマッチし、他の文字にはマッチしない正規表現です(これは文字列‘<code class="literal">fg</code>’には<span class="emphasis"><em>マッチしない</em></span>が、その文字列の<span class="emphasis"><em>部分</em></span>にマッチする)。同様に、‘<code class="literal">o</code>’は‘<code class="literal">o</code>’だけにマッチします。
</p><p>任意の2つの正規表現<em class="replaceable"><code>a</code></em>と<em class="replaceable"><code>b</code></em>は、結合することができます。結合した結果は、文字列の先頭からある長さの文字列が<em class="replaceable"><code>a</code></em>にマッチし、残りの文字列が<em class="replaceable"><code>b</code></em>にマッチするような文字列にマッチする正規表現になります。
</p><p>単純な例として、文字列‘<code class="literal">fo</code>’だけにマッチする正規表現の構成要素‘<code class="literal">fo</code>’を取得するために、正規表現‘<code class="literal">f</code>’と‘<code class="literal">o</code>’を結合できます。
</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Regexp-Special"/>Special Characters in Regular Expressions</h3></div></div></div><a id="idm77408208" class="indexterm"/><p>以下は、正規表現内で特別な文字のリストです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">.</code>’ (Period)
</span></dt><dd><a id="idm77405904" class="indexterm"/><p>これは、改行を除く1文字にマッチする。結合を使用して、‘<code class="literal">a.b</code>’のような正規表現を作成できる。これは‘<code class="literal">a</code>’で始まり‘<code class="literal">b</code>’で終わる3文字の文字列にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">*</code>’
</span></dt><dd><a id="idm77401424" class="indexterm"/><p>これは、それ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する、後置演算子である。したがって、‘<code class="literal">o*</code>’は任意の個数の‘<code class="literal">o</code>’にマッチする(‘<code class="literal">o</code>’を含まない場合もマッチする)。
</p><p>‘<code class="literal">*</code>’は常に前置された表現の、<span class="emphasis"><em>最小</em></span>の表現に適用される。つまり‘<code class="literal">fo*</code>’は‘<code class="literal">o</code>’の繰り返しであり、‘<code class="literal">fo</code>’の繰り返しではない。これは‘<code class="literal">f</code>’、‘<code class="literal">fo</code>’、‘<code class="literal">foo</code>’、...にマッチする。
</p><a id="idm77377488" class="indexterm"/><p>マッチを行う処理は構成要素‘<code class="literal">*</code>’を、マッチングにより即座に、見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら、残りのパターンのマッチが可能になるかもしれないという期待のもと、‘<code class="literal">*</code>’の変更された構成のうちいくつかのマッチを破棄することによる、バックトラッキングが発生する。たとえば文字列‘<code class="literal">caaar</code>’にたいして‘<code class="literal">ca*ar</code>’をマッチングすると、‘<code class="literal">a*</code>’はまず3つすべての‘<code class="literal">a</code>’へのマッチを試みる。しかし残りのパターンは‘<code class="literal">ar</code>’であり、マッチ対象に残されているのは‘<code class="literal">r</code>’だけなので、この試みは失敗する。‘<code class="literal">a*</code>’にたいする次の代替策は、2つの‘<code class="literal">a</code>’だけへのマッチである。この選択では、残りのregexpのマッチは成功する。
</p><p><span class="bold"><strong>警告:</strong></span>
ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合は、無期限な長時間の実行となり得る。たとえば文字列‘<code class="literal">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz</code>’にたいして正規表現‘<code class="literal">\(x+y*\)*a</code>’のマッチを試みると、それが最終的に失敗するまでに数時間を要し得る。Emacsはその試みのいずれも機能しないと結論する前に、‘<code class="literal">x</code>’のグループ家のそれぞれを試みなければならない。さらに悪いことに、‘<code class="literal">\(x*\)*</code>’は無数の方法でnull文字列にマッチ可能なので、これは無限ループを引き起こす。これらの問題を避けるには、ネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial
explosion)が発生しないことを確実にするために注意深くチェックすること。
</p></dd><dt><span class="term">‘<code class="literal">+</code>’
</span></dt><dd><a id="idm77363152" class="indexterm"/><p>これは‘<code class="literal">*</code>’のような後置演算子だが、これは前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば‘<code class="literal">ca+r</code>’は文字列‘<code class="literal">car</code>’や‘<code class="literal">caaaar</code>’にマッチするが、文字列‘<code class="literal">cr</code>’にはマッチせず、その一方で‘<code class="literal">ca*r</code>’はこれら3つすべての文字列にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">?</code>’
</span></dt><dd><a id="idm77357264" class="indexterm"/><p>これは‘<code class="literal">*</code>’のような後置演算子だが、これは前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。申‘<code class="literal">ca?r</code>’は‘<code class="literal">car</code>’と‘<code class="literal">cr</code>’にマッチするが、他にはマッチしない。
</p></dd><dt><span class="term">‘<code class="literal">*?</code>’, ‘<code class="literal">+?</code>’, ‘<code class="literal">??</code>’
</span></dt><dd><a id="idm77351376" class="indexterm"/><p>演算子
‘<code class="literal">*</code>’、‘<code class="literal">+</code>’、‘<code class="literal">?</code>’には“非欲張り(non-greedy)”な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。
</p><p>たとえば正規表現‘<code class="literal">c[ad]*a</code>’が文字列‘<code class="literal">cdaaada</code>’に適用されると文字列全体にマッチするが、正規表現‘<code class="literal">c[ad]*?a</code>’を同じ文字列に適用すると‘<code class="literal">cda</code>’だけにマッチする(ここでマッチが許された表現全体にたいする‘<code class="literal">[ad]*?</code>’の可能な最短マッチは‘<code class="literal">d</code>’である)。
</p></dd><dt><span class="term">‘<code class="literal">[ … ]</code>’
</span></dt><dd><a id="idm77327824" class="indexterm"/><a id="idm77327056" class="indexterm"/><a id="idm77325776" class="indexterm"/><p>これは‘<code class="literal">[</code>’で始まり‘<code class="literal">]</code>’で終端される<em class="firstterm">文字候補(character
alternative)</em>である。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字である。
</p><p>したがって‘<code class="literal">[ad]</code>’は1つの‘<code class="literal">a</code>’と1つの‘<code class="literal">d</code>’の両方にマッチし、‘<code class="literal">[ad]*</code>’は‘<code class="literal">a</code>’と‘<code class="literal">d</code>’だけから構成された任意の文字列(空文字列を含む)にマッチする。つまり‘<code class="literal">c[ad]*r</code>’は‘<code class="literal">cr</code>’、‘<code class="literal">car</code>’、‘<code class="literal">cdr</code>’、‘<code class="literal">caddaar</code>’等にマッチする。
</p><p>開始文字と終了文字の間に‘<code class="literal">-</code>’を記述することにより、文字候補内に文字範囲を含めることができる。つまり‘<code class="literal">[a-z]</code>’は小文字の<acronym class="acronym">ASCII</acronym>アルファベット文字にマッチする。範囲は‘<code class="literal">[a-z$%.]</code>’のように個別の文字と自由に組み合わせることができる。これは任意の<acronym class="acronym">ASCII</acronym>小文字アルファベットと‘<code class="literal">$</code>’、‘<code class="literal">%</code>’、またはピリオドとマッチする。
</p><p><code class="literal">case-fold-search</code>が非<code class="literal">nil</code>なら、‘<code class="literal">[a-z]</code>’は大文字アルファベットにもマッチする。‘<code class="literal">[a-z]</code>’のような範囲は、そのlocaleの照合順に影響されず、常に<acronym class="acronym">ASCII</acronym>順のシーケンスを表すことに注意。
</p><p>さらに通常のregexpスペシャル文字は文字候補内では特別ではないことにも注意されたい。文字候補内部では‘<code class="literal">]</code>’、‘<code class="literal">-</code>’、‘<code class="literal">^</code>’という完全に異なる文字セットが特別に扱われる。
</p><p>文字候補内に‘<code class="literal">]</code>’を含めるには、それを最初の文字にしなければならない。たとえば‘<code class="literal">[]a]</code>’は、‘<code class="literal">]</code>’と‘<code class="literal">a</code>’にマッチする。‘<code class="literal">-</code>’を含めるには、文字候補の最初または最後の文字として‘<code class="literal">-</code>’を記述するか、範囲の後に置くこと。つまり‘<code class="literal">[]-]</code>’は‘<code class="literal">]</code>’と‘<code class="literal">-</code>’の両方にマッチする。(以下で説明するように、ここでは‘<code class="literal">\</code>’は特別ではないので、文字候補内に‘<code class="literal">]</code>’を含めるために‘<code class="literal">\]</code>’は使用できない)。
</p><p>文字候補内に‘<code class="literal">^</code>’を含めるには、先頭以外のいずれかの場所に置くこと。
</p><p>ある範囲がユニバイト文字<em class="replaceable"><code>c</code></em>で始まり、マルチバイト文字<em class="replaceable"><code>c2</code></em>でお話場合、その範囲は2つの部分に分割される。1つはユニバイト文字‘<code class="literal"><em class="replaceable"><code>c</code></em>..?\377</code>’、もう1つはマルチバイト文字‘<code class="literal"><em class="replaceable"><code>c1</code></em>..<em class="replaceable"><code>c2</code></em></code>’である。ここで<em class="replaceable"><code>c1</code></em>は<em class="replaceable"><code>c2</code></em>が属する文字セットの最初の文字である。
</p><p>文字候補には、名前付き文字クラスも指定できる(<a class="link" href="ch34s03.html#Char-Classes" title="Character Classes">Char
Classes</a>を参照)。これはPOSIXの機能である。たとえば‘<code class="literal">[[:ascii:]]</code>’は、任意の<acronym class="acronym">ASCII</acronym>文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので、後者は実際は実現可能ではない。
</p></dd><dt><span class="term">‘<code class="literal">[^ … ]</code>’
</span></dt><dd><a id="idm77284176" class="indexterm"/><p>‘<code class="literal">[^</code>’は<em class="firstterm">補完文字候補(complemented character
alternative)</em>を開始する。これは、指定された以外の任意の文字とマッチする。つまり‘<code class="literal">[^a-z0-9A-Z]</code>’はアルファベットと数日前<span class="emphasis"><em>以外</em></span>の、すべての文字にマッチする。
</p><p>‘<code class="literal">^</code>’は文字クラス内では、先頭に記述されない限り特別ではない。‘<code class="literal">^</code>’に続く文字は、あたかもそれが先頭にあるかのように扱われる(別の言い方をすると‘<code class="literal">-</code>’や‘<code class="literal">]</code>’は、ここでは特別ではない)。
</p><p>マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは<code class="literal">grep</code>のようなプログラム内でのregexpの扱いとは、対照的である。
</p><p>文字候補のように、名前付き文字クラスを指定できる。たとえば‘<code class="literal">[^[:ascii:]]</code>’は、任意の非<acronym class="acronym">ASCII</acronym>文字にマッチする。<a class="link" href="ch34s03.html#Char-Classes" title="Character Classes">Char
Classes</a>を参照のこと。
</p></dd><dt><span class="term">‘<code class="literal">^</code>’
</span></dt><dd><a id="idm77274576" class="indexterm"/><p>バッファーのマッチング時、‘<code class="literal">^</code>’は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチは、すべて失敗する。つまり‘<code class="literal">^foo</code>’は、行の先頭に出現する‘<code class="literal">foo</code>’にマッチする。
</p><p>バッファーではなく文字列とマッチする際は、‘<code class="literal">^</code>’は文字列の先頭、または改行文字の後にマッチする。
</p><p>歴史的な互換性という理由により、‘<code class="literal">^</code>’は正規表現の先頭、または‘<code class="literal">\(</code>’、‘<code class="literal">\(?:</code>’、‘<code class="literal">\|</code>’の後だけで使用できる。
</p></dd><dt><span class="term">‘<code class="literal">$</code>’
</span></dt><dd><a id="idm77267536" class="indexterm"/><a id="idm77266256" class="indexterm"/><p>これは‘<code class="literal">^</code>’と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり‘<code class="literal">x+$</code>’は、行末にある1つ以上の‘<code class="literal">x</code>’からなる文字列にマッチする。
</p><p>バッファーではなく文字列とマッチする際は、‘<code class="literal">$</code>’は文字列の終端、または改行文字の前にマッチする。
</p><p>歴史的な互換性という理由により、‘<code class="literal">$</code>’は正規表現の先頭、または‘<code class="literal">\(</code>’、‘<code class="literal">\(?:</code>’、‘<code class="literal">\|</code>’の前だけで使用できる。
</p></dd><dt><span class="term">‘<code class="literal">\</code>’
</span></dt><dd><a id="idm77259216" class="indexterm"/><p>これは2つの機能をもつ。スペシャル文字(‘<code class="literal">\</code>’を含む)のクォートと、追加のスペシャル文字の導入である。
</p><p>‘<code class="literal">\</code>’はスペシャル文字をクォートするので、‘<code class="literal">\$</code>’は‘<code class="literal">$</code>’、‘<code class="literal">\[</code>’は‘<code class="literal">[</code>’だけにマッチする正規表現といったようになる。
</p><p>‘<code class="literal">\</code>’はLisp文字列(<a class="link" href="ch03s03.html#String-Type" title="String Type">String Type</a>を参照)の入力構文(read
syntax)内でも特別な意味をもち、‘<code class="literal">\</code>’でクォートしなければならないことに注意。たとえば文字‘<code class="literal">\</code>’にマッチする正規表現は‘<code class="literal">\\</code>’である。文字‘<code class="literal">\\</code>’を含むLisp文字列を記述するには、別の‘<code class="literal">\\</code>’で‘<code class="literal">\\</code>’をクォートすることをLisp構文は要求する。したがって‘<code class="literal">\</code>’にマッチする正規表現にたいする入力構文は、<code class="literal">"\\\\"</code>となる。
</p></dd></dl></div><p><span class="bold"><strong>注意してください:</strong></span>
歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合は、通常の文字として扱われます。たとえば‘<code class="literal">*foo</code>’は、‘<code class="literal">*</code>’が作用可能な前置された表現がないので、通常の‘<code class="literal">*</code>’として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようと、スペシャル文字はすべてクォートしてください。
</p><p>文字候補内で‘<code class="literal">\</code>’は何ら特別ではないので、‘<code class="literal">-</code>’や‘<code class="literal">]</code>’の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする‘<code class="literal">[^\]</code>’(Lisp文字列構文では<code class="literal">"[^\\]"</code>)内でのように、これらの文字が<span class="emphasis"><em>特別な意味</em></span>をもつ箇所では、これらの文字にバックスラッシュを前置する正当性があるので、それほど何も明解にはしないでしょう。
</p><p>実際には、正規表現内に出現する‘<code class="literal">]</code>’は文字候補に近接しており、それ故にほとんどがスペシャル文字です。しかしリテラルの‘<code class="literal">[</code>’および‘<code class="literal">]</code>’の複雑なパターンにたいして、マッチを試みることも時にはあるかもしれません。そのような状況では、文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析するのが必要なときもあるかもしれません。たとえば‘<code class="literal">[^][]]</code>’は、補完文字候補‘<code class="literal">[^][]</code>’(角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの‘<code class="literal">]</code>’により構成されます。
</p><p>厳密にはregexp先頭の‘<code class="literal">[</code>’は特別で、‘<code class="literal">]</code>’は特別ではないというのがルールです。これはクォートされていない最初の‘<code class="literal">[</code>’で終わり、その後は文字候補になります。(文字クラス開始を除き)‘<code class="literal">[</code>’はもはや特別ではありませんが、‘<code class="literal">]</code>’は直後にスペシャル文字‘<code class="literal">[</code>’があるか、その‘<code class="literal">[</code>’の後に‘<code class="literal">^</code>’がある場合を除き、特別です。これは文字クラス終了ではない次のスペシャル文字‘<code class="literal">]</code>’まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない‘<code class="literal">[</code>’は再び特別となり、‘<code class="literal">]</code>’は特別ではなくなります。
</p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Char-Classes"/>Character Classes</h3></div></div></div><a id="idm77219920" class="indexterm"/><p>以下は文字候補内で使用できるクラスと、その意味についてのテーブルです:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">[:ascii:]</code>’
</span></dt><dd><p>これは任意の<acronym class="acronym">ASCII</acronym>文字(コード0 – 127)にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:alnum:]</code>’
</span></dt><dd><p>これは任意のアルファベットと数字にマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
</p></dd><dt><span class="term">‘<code class="literal">[:alpha:]</code>’
</span></dt><dd><p>これは任意のアルファベットにマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
</p></dd><dt><span class="term">‘<code class="literal">[:blank:]</code>’
</span></dt><dd><p>これはスペースとタブだけにマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:cntrl:]</code>’
</span></dt><dd><p>これは<acronym class="acronym">ASCII</acronym>制御文字にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:digit:]</code>’
</span></dt><dd><p>これは‘<code class="literal">0</code>’から‘<code class="literal">9</code>’までにマッチする。つまり‘<code class="literal">[-+[:digit:]]</code>’は‘<code class="literal">+</code>’と‘<code class="literal">-</code>’同様、任意の数にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:graph:]</code>’
</span></dt><dd><p>これはグラフィック文字(<acronym class="acronym">ASCII</acronym>制御文字、スペース、delete文字を除くすべての文字)を意味する。
</p></dd><dt><span class="term">‘<code class="literal">[:lower:]</code>’
</span></dt><dd><p>これはカレントの大文字小文字テーブル(<a class="link" href="ch05s09.html" title="The Case Table">Case
Tables</a>を参照)で小文字と判断される文字すべてにマッチする。<code class="literal">case-fold-search</code>が非<code class="literal">nil</code>なら、これは大文字にもマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:multibyte:]</code>’
</span></dt><dd><p>これは任意のマルチバイト文字にマッチする(<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text Representations</a>を参照)。
</p></dd><dt><span class="term">‘<code class="literal">[:nonascii:]</code>’
</span></dt><dd><p>これは非<acronym class="acronym">ASCII</acronym>文字にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:print:]</code>’
</span></dt><dd><p>これはプリント文字(<acronym class="acronym">ASCII</acronym>制御文字とdelete文字以外のすべての文字)にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:punct:]</code>’
</span></dt><dd><p>これは任意の句読点文字(punctuation
character)にマッチする(現在のところマルチバイト文字にたいしては、単語構文以外のすべてにマッチする)。
</p></dd><dt><span class="term">‘<code class="literal">[:space:]</code>’
</span></dt><dd><p>これは空白文字構文(<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax Class Table</a>を参照)をもつ任意の文字にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:unibyte:]</code>’
</span></dt><dd><p>これは任意のユニバイト文字(<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text Representations</a>を参照)にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:upper:]</code>’
</span></dt><dd><p>これはカレントの大文字小文字テーブル(<a class="link" href="ch05s09.html" title="The Case Table">Case
Tables</a>を参照)で大文字と判断される文字すべてにマッチする。<code class="literal">case-fold-search</code>が非<code class="literal">nil</code>なら、これは小文字にもマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:word:]</code>’
</span></dt><dd><p>これは単語構文(<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax Class Table</a>を参照)をもつ任意の文字にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">[:xdigit:]</code>’
</span></dt><dd><p>これは16進数の数字‘<code class="literal">0</code>’から‘<code class="literal">9</code>’、‘<code class="literal">a</code>’から‘<code class="literal">f</code>’と‘<code class="literal">A</code>’から‘<code class="literal">F</code>’にマッチする。
</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="Regexp-Backslash"/>Backslash Constructs in Regular Expressions</h3></div></div></div><a id="idm77183056" class="indexterm"/><p>ほとんどの場合、‘<code class="literal">\</code>’の後の任意の文字は、その文字だけにマッチします。しかし、例外もいくつかあります。‘<code class="literal">\</code>’で始まる特定のシーケンスには、特別な意味をもつものがあります。以下は特別な‘<code class="literal">\</code>’構成要素のテーブルです。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">\|</code>’
</span></dt><dd><a id="idm77179216" class="indexterm"/><a id="idm77177936" class="indexterm"/><p>これは選択肢を指定する。2つの正規表現<em class="replaceable"><code>a</code></em>と<em class="replaceable"><code>b</code></em>、その間にある‘<code class="literal">\|</code>’により、<em class="replaceable"><code>a</code></em>または<em class="replaceable"><code>b</code></em>のいずれかにマッチする表現が形成される。
</p><p>つまり‘<code class="literal">foo\|bar</code>’は、‘<code class="literal">foo</code>’か‘<code class="literal">bar</code>’のいずれかにマッチし、他の文字列にはマッチしない。
</p><p>‘<code class="literal">\|</code>’は周囲の適用可能な最大の表現に適用される。‘<code class="literal">\|</code>’を取り囲む‘<code class="literal">\( …
\)</code>’でグループ化することにより、グループ化の効力を制限できる。
</p><p>複数の‘<code class="literal">\|</code>’の処理するための、完全なバックトラッキング互換が必要なら、POSIX正規表現関数を使用すること(<a class="link" href="ch34s05.html" title="POSIX Regular Expression Searching">POSIX
Regexps</a>を参照)。
</p></dd><dt><span class="term">‘<code class="literal">\{<em class="replaceable"><code>m</code></em>\}</code>’
</span></dt><dd><p>これは、前のパターンを正確に<em class="replaceable"><code>m</code></em>回繰り返す、後置演算子である。つまり‘<code class="literal">x\{5\}</code>’は文字列‘<code class="literal">xxxxx</code>’にマッチし、それ以外にはマッチしない。‘<code class="literal">c[ad]\{3\}r</code>’は‘<code class="literal">caaar</code>’、‘<code class="literal">cdddr</code>’、‘<code class="literal">cadar</code>’等にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\{<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>\}</code>’
</span></dt><dd><p>これは最小で<em class="replaceable"><code>m</code></em>回、最大で<em class="replaceable"><code>n</code></em>回繰り返す、より一般的な後置演算子である。<em class="replaceable"><code>m</code></em>省略時の最小は0、<em class="replaceable"><code>n</code></em>省略時の最大は存在しない。
</p><p>たとえば‘<code class="literal">c[ad]\{1,2\}r</code>’は文字列‘<code class="literal">car</code>’、‘<code class="literal">cdr</code>’、‘<code class="literal">caar</code>’、‘<code class="literal">cadr</code>’、‘<code class="literal">cdar</code>’、‘<code class="literal">cddr</code>’にマッチし、それ以外にはマッチしない。
‘<code class="literal">\{0,1\}</code>’または‘<code class="literal">\{,1\}</code>’は、‘<code class="literal">?</code>’と同じ。
‘<code class="literal">\{0,\}</code>’または‘<code class="literal">\{,\}</code>’は‘<code class="literal">*</code>’と同じ。
‘<code class="literal">\{1,\}</code>’は‘<code class="literal">+</code>’と同じ。
</p></dd><dt><span class="term">‘<code class="literal">\( … \)</code>’
</span></dt><dd><a id="idm77151056" class="indexterm"/><a id="idm77149776" class="indexterm"/><a id="idm77148496" class="indexterm"/><p>これは、以下の3つの目的を果たす役目をもつグループ化構成要素である:
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>他の操作のために、一連の‘<code class="literal">\|</code>’選択肢を囲う。つまり正規表現‘<code class="literal">\(foo\|bar\)x</code>’は、‘<code class="literal">foox</code>’か‘<code class="literal">barx</code>’のいずれかにマッチする。
</p></li><li class="listitem"><p>後置演算子‘<code class="literal">*</code>’、‘<code class="literal">+</code>’、‘<code class="literal">?</code>’による複雑な表現を囲う。つまり‘<code class="literal">ba\(na\)*</code>’は‘<code class="literal">ba</code>’、‘<code class="literal">bana</code>’、‘<code class="literal">banana</code>’、‘<code class="literal">bananana</code>’、...等、任意の数(0以上の文字列‘<code class="literal">na</code>’にマッチする。
</p></li><li class="listitem"><p>‘<code class="literal">\<em class="replaceable"><code>digit</code></em></code>’(以下参照)による将来の参照にたいして、マッチする部分文字列を記録する。
</p></li></ol></div><p>この最後の目的は、カッコによるグループ化というアイデアによるものではない。これは同じ構成要素‘<code class="literal">\( …
\)</code>’である2つ目の目的に割当てられた別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が発生することがあり、それが内気(shy)なグループの導入をもたらした。
</p></dd><dt><span class="term">‘<code class="literal">\(?: … \)</code>’
</span></dt><dd><a id="idm77119568" class="indexterm"/><a id="idm77118800" class="indexterm"/><a id="idm77118032" class="indexterm"/><a id="idm77117264" class="indexterm"/><p>これは<em class="firstterm">内気なグループ(shy
group)</em>の構成要素である。内気なグループは通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、これは番号を取得せず‘<code class="literal">\<em class="replaceable"><code>digit</code></em></code>’でその値を後方参照できない。内気なグループは、通常の内気でないグループを変更することなく自動的に追加できるので、機械的に正規表現を構築するのに、特に適している。
</p><p>内気なグループ化は、<em class="firstterm">非キャプチャリング(non-capturing)</em>、あるいは<em class="firstterm">番号なしグループ(unnumbered
groups)</em>とも呼ばれる。
</p></dd><dt><span class="term">‘<code class="literal">\(?<em class="replaceable"><code>num</code></em>: … \)</code>’
</span></dt><dd><p>これは<em class="firstterm">明示的番号付きグループ(explicitly numbered
group)</em>の構成要素である。通常のグループ化では、位置をもとに番号が暗黙で取得されるが、これが不便な場合もあるだろう。この構成要素により、特定のグループに番号を強制できる。番号の付与に特別な制限はなく、複数のグループに同じ番号を付与でき、その場合は最後の1つがマッチ(もっとも右のマッチ)が採用される。暗黙的に番号付けされたグループは常に、前のグループより大きい最小の整数となる番号を取得する。
</p></dd><dt><span class="term">‘<code class="literal">\<em class="replaceable"><code>digit</code></em></code>’
</span></dt><dd><p>これはグループ構成要素(‘<code class="literal">\( … \)</code>’)の、<em class="replaceable"><code>digit</code></em>番目にマッチしたテキストと同じテキストにマッチする。
</p><p>他の言い方をすると、最後のグループの後に、マッチ処理はそのグループによりマッチされたテキストの開始と終了を記憶する。その正規表現の先の箇所で、‘<code class="literal">\</code>’とその後に<em class="replaceable"><code>digit</code></em>を使用すれば、それが何であれ同じテキストにマッチさせることができる。
</p><p>検索またはマッチングを行う関数に渡される、正規表現全体の中で最初の9つのグループ化構成要素にマッチする文字列には、その正規表現内で開きカッコが出現する順に1から9までの番号が割り当てられる。したがって‘<code class="literal">\1</code>’から‘<code class="literal">\9</code>’までを使用して、対応するグループ化構成要素によりマッチされたテキストを参照できる。
</p><p>たとえば‘<code class="literal">\(.*\)\1</code>’は、一方がもう一方と等しいような2つの文字列から構成される、改行を含まない任意の文字列にマッチする。‘<code class="literal">\(.*\)</code>’は前半分にマッチし、これは何でもよいが、それに続く‘<code class="literal">\1</code>’はそれと同じテキストに正確にマッチしなければならない。
</p><p>構成要素‘<code class="literal">\( …
\)</code>’が2回以上マッチする場合(これはたとえば後に‘<code class="literal">*</code>’をしたがえるとき発生し得る)は、最後のマッチだけが記録される。
</p><p>正規表現内の特定のグループ化構成要素がマッチしなかった場合、たとえばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部にあるなら、それに対応する‘<code class="literal">\<em class="replaceable"><code>digit</code></em></code>’構成は何にもマッチしない。人工的な例を用いると、‘<code class="literal">\(foo\(b*\)\|lose\)\2</code>’は‘<code class="literal">lose</code>’にマッチできない。外側のグループ内の2つ目の選択肢がマッチするものの、‘<code class="literal">\2</code>’が未定義となり、何にたいしてもマッチできない。しかし‘<code class="literal">foobb</code>’にたいしては、1つ目の選択肢が‘<code class="literal">foob</code>’にマッチし、‘<code class="literal">\2</code>’が‘<code class="literal">b</code>’にマッチするので、マッチが可能になる。
</p></dd><dt><span class="term">‘<code class="literal">\w</code>’
</span></dt><dd><a id="idm77088464" class="indexterm"/><p>これは任意の単語構成文字にマッチする。エディターの構文テーブルが、どの文字が単語構成文字かを決定する。<a class="link" href="ch35.html" title="Chapter 34. Syntax Tables">Syntax
Tables</a>を参照のこと。
</p></dd><dt><span class="term">‘<code class="literal">\W</code>’
</span></dt><dd><a id="idm77085264" class="indexterm"/><p>これは任意の非単語構成文字にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\s<em class="replaceable"><code>code</code></em></code>’
</span></dt><dd><a id="idm77082320" class="indexterm"/><p>これは、構文が<em class="replaceable"><code>code</code></em>であるような任意の文字にマッチする。ここで<em class="replaceable"><code>code</code></em>は、構文コードを表す文字である。‘<code class="literal">w</code>’は単語構成要素、‘<code class="literal">-</code>’は空白文字、‘<code class="literal">(</code>’は開きカッコ、等である。空白文字構文を表すには、‘<code class="literal">-</code>’かスペース文字のいずれかを使用する。構文コードと、それらを意味する文字のリストは、<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax
Class Table</a>を参照されたい。
</p></dd><dt><span class="term">‘<code class="literal">\S<em class="replaceable"><code>code</code></em></code>’
</span></dt><dd><a id="idm77076048" class="indexterm"/><p>これは、構文が<em class="replaceable"><code>code</code></em>でないような任意の文字にマッチする。
</p><a id="idm77074000" class="indexterm"/></dd><dt><span class="term">‘<code class="literal">\c<em class="replaceable"><code>c</code></em></code>’
</span></dt><dd><p>これは、カテゴリーが<em class="replaceable"><code>c</code></em>であるような任意の文字にマッチする。ここで<em class="replaceable"><code>c</code></em>は、カテゴリーを表す文字である。つまり標準カテゴリーテーブルで、‘<code class="literal">c</code>’はChinese(中国語)、‘<code class="literal">g</code>’はGreek(ギリシャ語)の文字となる。<strong class="userinput"><code>M-x
describe-categories
<span class="keycap"><strong>RET</strong></span></code></strong>で現在定義済みの全カテゴリーのリストを確認できる。<code class="literal">define-category</code>関数を使用すれば、標準カテゴリーに加えて、カテゴリーを独自に定義することもできる(<a class="link" href="ch35s08.html" title="Categories">Categories</a>を参照)。
</p></dd><dt><span class="term">‘<code class="literal">\C<em class="replaceable"><code>c</code></em></code>’
</span></dt><dd><p>これは、カテゴリーが<em class="replaceable"><code>c</code></em>ではない任意の文字にマッチする。
</p></dd></dl></div><p>以下は、空文字列にマッチ(つまり文字を何も消費しない)しますが、マッチするかどうかはコンテキストに依存するような正規表現を構築します。これらすべてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかもそのバッファーの実際の先頭と終端のように扱われます。
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">\`</code>’
</span></dt><dd><a id="idm77064144" class="indexterm"/><p>これは空文字列、ただしバッファー先頭、またはマッチ対象の文字列の先頭だけにマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\'</code>’
</span></dt><dd><a id="idm77057360" class="indexterm"/><p>これは空文字列、ただしバッファー終端、またはマッチ対象の文字列の終端だけにマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\=</code>’
</span></dt><dd><a id="idm77054672" class="indexterm"/><p>これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマッチ対象が文字列なら定義されない)。
</p></dd><dt><span class="term">‘<code class="literal">\b</code>’
</span></dt><dd><a id="idm77051984" class="indexterm"/><p>これは空文字列、ただし単語の先頭だけにマッチする。つまり‘<code class="literal">\bfoo\b</code>’は、個別の単語として出現する‘<code class="literal">foo</code>’だけにマッチする。‘<code class="literal">\bballs?\b</code>’は、個別の単語として‘<code class="literal">ball</code>’または‘<code class="literal">balls</code>’にマッチする。
</p><p>‘<code class="literal">\b</code>’は、隣接するテキストが何であるかと無関係に、バッファー(か文字列)の先頭または終端にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\B</code>’
</span></dt><dd><a id="idm77045840" class="indexterm"/><p>これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭や終端<span class="emphasis"><em>以外</em></span>にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\&lt;</code>’
</span></dt><dd><a id="idm77042768" class="indexterm"/><p>これは空文字列、ただし単語の先頭だけにマッチする。‘<code class="literal">\&lt;</code>’は、後に単語構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\&gt;</code>’
</span></dt><dd><a id="idm77039568" class="indexterm"/><p>これは空文字列、ただし単語の終端だけにマッチする。‘<code class="literal">\&lt;</code>’は、コンテンツが単語構成文字で終わる場合のみ、バッファー(か文字列)の終端にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\_&lt;</code>’
</span></dt><dd><a id="idm77015888" class="indexterm"/><p>これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは1つ以上の単語かシンボル構成文字のシーケンスである。‘<code class="literal">\_&lt;</code>’は、後にシンボル構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチする。
</p></dd><dt><span class="term">‘<code class="literal">\_&gt;</code>’
</span></dt><dd><a id="idm77008592" class="indexterm"/><p>これは空文字列、ただし単語の終端だけにマッチする。‘<code class="literal">\_&gt;</code>’は、コンテンツがシンボル構成文字で終わる場合のみ、バッファー(か文字列)の終端にマッチする。
</p></dd></dl></div><a id="idm77006416" class="indexterm"/><p>すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の‘<code class="literal">]</code>’がない文字選択肢ないで終わる文字列は無効であり、単一の‘<code class="literal">\</code>’で終わる文字列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると、<code class="literal">invalid-regexp</code>エラーがシグナルされます。
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Regexp-Example"/>Complex Regexp Example</h2></div></div></div><p>以下は、後続の空白文字とともにセンテンスの終わりを認識するために、以前のEmacsで使用されていた、複雑な正規表現の例です(現在のEmacsは、関数<code class="literal">sentence-end</code>により構築される、同様だがより複雑なregexpを使用する。<a class="link" href="ch34s08.html" title="Standard Regular Expressions Used in Editing">Standard
Regexps</a>を参照されたい)。
</p><p>以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列としてregexpを示し、それを評価した結果を示します。文字列定数の開始と終了は、ダブルクォーテーションです。‘<code class="literal">\"</code>’は文字列の一部としてのダブルクォーテーション、‘<code class="literal">\\</code>’は文字列の一部としてのバックスラッシュ、‘<code class="literal">\t</code>’はタブ、‘<code class="literal">\n</code>’は改行を意味します。
</p><pre class="screen">"[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
     ⇒ "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
]*"
</pre><p>改行とタブは、それら自身として出力されます。
</p><p>この正規表現は連続する4つのパートを含み、以下のように解読できます:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">[.?!]</code>
</span></dt><dd><p>この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうち、いずれか1つにマッチする文字選択肢である。マッチはこれら3つの文字のいずれかで開始されなければならない(これは旧正規表現と、Emacsが使用する新たなデフォルトregexpが異なる1つのポイントである。新たな値は、後続の空白文字なすでセンテンスを終端する、いくつかの非<acronym class="acronym">ASCII</acronym>文字を許容する)。
</p></dd><dt><span class="term"><code class="literal">[]\"')}]*</code>
</span></dt><dd><p>パターンの2つ目のパートは任意の0個以上の閉じカッコおよびクォーテーションマークで、後にピリオド、疑問符、感嘆符があるかもしれない。<code class="literal">\"</code>は、文字列内でのダブルクォーテーションマークにたいするLisp構文である。最後の‘<code class="literal">*</code>’は、直前の正規表現(この場合は文字選択肢)の0回以上の繰り返しを示す。
</p></dd><dt><span class="term"><code class="literal">\\($\\| $\\|\t\\|  \\)</code>
</span></dt><dd><p>パターンの3つ目のパートは、センテンスの後の空白文字、すなわち行の終端(スペースがあっても可)、タブ、または2つのスペースにマッチする。2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダラー記号は行の終端へのマッチに使用される。
</p></dd><dt><span class="term"><code class="literal">[ \t\n]*</code>
</span></dt><dd><p>最後に、パターンの最終パートはセンテンスを終端させるために必要とされる以上の、余分な空白文字にマッチする。
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Regexp-Functions"/>Regular Expression Functions</h2></div></div></div><p>以下の関数は、正規表現を扱います。
</p><a id="idm76948304" class="indexterm"/><pre class="synopsis"><a id="idm76947280" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">regexp-quote</code> <em class="replaceable"><code>string</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>string</code></em>だけに正確にマッチするような正規表現をリターンする。<code class="literal">looking-at</code>内でのこの正規表現の使用は、そのバッファー内の次の文字が<em class="replaceable"><code>string</code></em>のときだけ成功するだろう。検索関数でのこの正規表現の使用は、検索されるテキストが<em class="replaceable"><code>string</code></em>を含むなら成功するだろう。<a class="link" href="ch34s04.html" title="Regular Expression Searching">Regexp
Search</a>を参照のこと。
</p><p>これにより、その正規表現を求める関数呼び出し時に、正確な文字列マッチまたは検索を要求できる。
</p><pre class="screen">(regexp-quote "^The cat$")
     ⇒ "\\^The cat\\$"
</pre><p>正規表現として記述されたコンテキストにおいて、正確な文字列マッチを結合することが、<code class="literal">regexp-quote</code>の1つの使い方である。たとえば以下は空白文で囲まれた、<em class="replaceable"><code>string</code></em>の値であるような文字列を検索する:
</p><pre class="screen">(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
</pre></blockquote></div><a id="idm76939088" class="indexterm"/><pre class="synopsis"><a id="idm76938064" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">regexp-opt</code> <em class="replaceable"><code>strings</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>paren</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、リスト<em class="replaceable"><code>strings</code></em>の文字列だけにマッチする、効果的な正規表現をリターンする。これはマッチングや検索を可能な限り高速にする必要があるとき、たとえばFont
Lockモードで有用である<a href="#ftn.idm76933840" class="footnote" id="idm76933840"><sup class="footnote">[17]</sup></a>。
</p><p>オプション引数<em class="replaceable"><code>paren</code></em>が非<code class="literal">nil</code>なら、その正規表現は少なくとも1つのカッコによるグループ化構成要素に常に囲まれてリターンされる。<em class="replaceable"><code>paren</code></em>が<code class="literal">words</code>なら、その構成要素は追加で‘<code class="literal">\&lt;</code>’と‘<code class="literal">\&gt;</code>’で囲まれ、<em class="replaceable"><code>paren</code></em>が<code class="literal">symbols</code>なら‘<code class="literal">\_&lt;</code>’と‘<code class="literal">\_&gt;</code>’で囲まれる(プログラミング言語のような文字列をマッチングする際は、<code class="literal">symbols</code>が適切な場合が多々ある)。
</p><p>この単純化された<code class="literal">regexp-opt</code>の定義は、実際の値と等価(だが同程度に効率的ではない)な正規表現を生成する:
</p><pre class="screen">(defun regexp-opt (strings &amp;optional paren)
  (let ((open-paren (if paren "\\(" ""))
        (close-paren (if paren "\\)" "")))
    (concat open-paren
            (mapconcat 'regexp-quote strings "\\|")
            close-paren)))
</pre></blockquote></div><pre class="synopsis"><a id="idm76925520" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">regexp-opt-depth</code> <em class="replaceable"><code>regexp</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>regexp</code></em>内のグループ化された構成要素(カッコで囲まれた正規表現)の総数をリターンする。これには内気なグループは含まれない(<a class="link" href="ch34s03.html#Regexp-Backslash" title="Backslash Constructs in Regular Expressions">Regexp
Backslash</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm76921168" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">regexp-opt-charset</code> <em class="replaceable"><code>chars</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は文字リスト<em class="replaceable"><code>chars</code></em>内の文字にマッチする正規表現をリターンする。
</p><pre class="screen">(regexp-opt-charset '(?a ?b ?c ?d ?e))
     ⇒ "[a-e]"
</pre></blockquote></div></div><div class="footnotes"><br/><hr/><div id="ftn.idm76933840" class="footnote"><p><a href="#idm76933840" class="para"><sup class="para">[17] </sup></a><code class="literal">regexp-opt</code>の結果が絶対的にもっとも効率的であるという保証はないことに注意してください。手作業でチューニングした正規表現のほうがわずかに効率的であることがときにありますが、これに努力する価値はほとんどないでしょう。</p></div></div></div></body></html>