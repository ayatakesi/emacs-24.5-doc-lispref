<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Regular Expression Searching</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Regexp-Search"/>Regular Expression Searching</h1></div></div></div><a id="idm76915920" class="indexterm"/><a id="idm76915152" class="indexterm"/><a id="idm76914384" class="indexterm"/><p>GNU Emacsでは、インクリメンタル、または非インクリメンタルの両方で、正規表現(<a class="link" href="ch34s03.html#Syntax-of-Regexps" title="Syntax of Regular Expressions">Syntax of
Regexps</a>を参照)にたいする次マッチを検索できます。インクリメンタル検索コマンドについては、section “Regular Expression Search” in <em class="citetitle">The GNU Emacs
Manual</em>を参照してください。ここでは、プログラム内で有用な検索関数だけを説明します。重要な関数は<code class="literal">re-search-forward</code>です。
</p><p>これらの検索関数は、バッファーがマルチバイトならルチバイトに、ユニバイトならユニバイトに、正規表現を変換します。<a class="link" href="ch33.html#Text-Representations" title="Text Representations">Text
Representations</a>を参照してください。
</p><pre class="synopsis"><a id="idm76910672" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">re-search-forward</code> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>limit</code></em> <em class="replaceable"><code>noerror</code></em> <em class="replaceable"><code>repeat</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はカレントバッファー内で、正規表現<em class="replaceable"><code>regexp</code></em>にマッチするテキスト文字列を、前方へ検索する。この関数は<em class="replaceable"><code>regexp</code></em>にマッチしない任意の量のテキストをスキップして、見つかった最初のマッチの終端にポイントを残す。これはポイントの新たな値をリターンする。
</p><p><em class="replaceable"><code>limit</code></em>が非<code class="literal">nil</code>なら、それはカレントバッファー内の位置であること。これは検索にたいする上限を指定する。その位置を超えるマッチは受け入れられない。
</p><p><em class="replaceable"><code>repeat</code></em>が与えられたなら、それは正の数でなければならない。検索は、その回数繰り返される。それぞれの繰り返しは、前のマッチの終端から開始される。これら一連の検索すべてが成功したらその検索は成功となり、ポイントを移動してポイントの新たな値をリターンする。それ以外では、検索は失敗となる。検索失敗時に<code class="literal">re-search-forward</code>が何をおこなうかは、<em class="replaceable"><code>noerror</code></em>の値に依存する:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">nil</code>
</span></dt><dd><p><code class="literal">search-failed</code>エラーをシグナルする。
</p></dd><dt><span class="term"><code class="literal">t</code>
</span></dt><dd><p>何もせず<code class="literal">nil</code>をリターンする。
</p></dd><dt><span class="term">その他
</span></dt><dd><p>ポイントを<em class="replaceable"><code>limit</code></em>(またはバッファーのアクセス可能範囲の終端)に移動して、<code class="literal">nil</code>をリターンする。
</p></dd></dl></div><p>以下の例では、ポイントは最初は‘<code class="literal">T</code>’の前にある。この検索を評価することにより、その行の終端(‘<code class="literal">hat</code>’の‘<code class="literal">t</code>’と改行の間)にポイントは移動する。
</p><pre class="screen">---------- Buffer: foo ----------
I read "★The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
</pre><pre class="screen">
</pre><pre class="screen">(re-search-forward "[a-z]+" nil t 5)
     ⇒ 27

---------- Buffer: foo ----------
I read "The cat in the hat★
comes back" twice.
---------- Buffer: foo ----------
</pre></blockquote></div><pre class="synopsis"><a id="idm76894160" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">re-search-backward</code> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>limit</code></em> <em class="replaceable"><code>noerror</code></em> <em class="replaceable"><code>repeat</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はカレントバッファー内で、正規表現<em class="replaceable"><code>regexp</code></em>にマッチするテキスト文字列を、後方へ検索して、見つかった最初のマッチの先頭にポイントを残す。
</p><p>この関数は<code class="literal">re-search-forward</code>と似ているが、単なるミラーイメージ(mirror-image:
鏡像)ではない。<code class="literal">re-search-forward</code>は、先頭が開始ポイントと可能な限り近いマッチを探す。<code class="literal">re-search-backward</code>が完全なミラーイメージなら、終端が可能な限り近いマッチを探すだろう。しかし実際は先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。これは、与えられた位置にたいする正規表現マッチングが常に正規表現の先頭から終端に機能し、指定された開始位置から開始されるのが理由である。
</p><p><code class="literal">re-search-forward</code>の真のミラーイメージには、正規表現を終端から先頭へマッチする特別な機能が要求されるだろう。それを実装するこによる問題に価値はない。
</p></blockquote></div><pre class="synopsis"><a id="idm76886352" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">string-match</code> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>start</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>string</code></em>内で、正規表現<em class="replaceable"><code>regexp</code></em>にたいする最初のマッチの開始位置のインデックスをリターンする。<em class="replaceable"><code>string</code></em>内のそのインデックスから検索は開始される。
</p><p>たとえば、
</p><pre class="screen">(string-match
 "quick" "The quick brown fox jumped quickly.")
     ⇒ 4
</pre><pre class="screen">(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     ⇒ 27
</pre><p>文字列の最初の文字のインデックスは1、2文字目は2、...となる。
</p><p>この関数リターン後、そのマッチの先の最初の文字のインデックスは、<code class="literal">(match-end 0)</code>で利用できる。<a class="link" href="ch34s06.html" title="The Match Data">Match
Data</a>を参照のこと。
</p><pre class="screen">(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     ⇒ 27
</pre><pre class="screen">
</pre><pre class="screen">(match-end 0)
     ⇒ 32
</pre></blockquote></div><pre class="synopsis"><a id="idm76876496" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">string-match-p</code> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>string</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>start</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この述語関数は<code class="literal">string-match</code>と同じことを行うが、マッチデータの変更を避ける。
</p></blockquote></div><pre class="synopsis"><a id="idm76871632" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">looking-at</code> <em class="replaceable"><code>regexp</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファー内のポイント直後のテキストが、正規表現<em class="replaceable"><code>regexp</code></em>にマッチするかどうかを判断する。“直後”の正確な意味は、その検索が“固定”され、ポイントの後の最初の文字からマッチが開始する場合のみ成功するということである。成功なら結果は<code class="literal">t</code>、それ以外は<code class="literal">nil</code>となる。
</p><p>この関数はポイントを移動しないが、マッチデータは更新する。<a class="link" href="ch34s06.html" title="The Match Data">Match
Data</a>を参照のこと。マッチデータを変更することなくテストする必要があるなら、以下で説明する<code class="literal">looking-at-p</code>を使用すること。
</p><p>以下の例では、ポイントは‘<code class="literal">T</code>’の直前にある。それ以外の場所にある場合、結果は<code class="literal">nil</code>となるだろう。
</p><pre class="screen">---------- Buffer: foo ----------
I read "★The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     ⇒ t
</pre></blockquote></div><pre class="synopsis"><a id="idm76838992" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">looking-back</code> <em class="replaceable"><code>regexp</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>limit</code></em> <em class="replaceable"><code>greedy</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、ポイントの直前(ポイントで終わる)テキストが<em class="replaceable"><code>regexp</code></em>とマッチしたら<code class="literal">t</code>、それ以外は<code class="literal">nil</code>をリターンする。
</p><p>正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチを、ポイントから後方へ検索するように実装された。長い距離を検索する必要がある場合、これは極めて低速になり得る。<em class="replaceable"><code>limit</code></em>を指定してその前を検索しないよう告げることにより、要する時間を制限できる。この場合、マッチデータは<em class="replaceable"><code>limit</code></em>、またはその後で始まらなければならない。以下は例である:
</p><pre class="screen">---------- Buffer: foo ----------
I read "★The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     ⇒ t
(looking-back "read \"" 4)
     ⇒ nil
</pre><p><em class="replaceable"><code>greedy</code></em>が非<code class="literal">nil</code>なら、この関数は可能な限り後方へマッチを拡張し、前方の1文字がregexpがマッチの一部とならなければ停止する。マッチが拡張されたときは、マッチ開始位置が<em class="replaceable"><code>limit</code></em>の前にあっても許される。
</p><p>一般的に<code class="literal">looking-back</code>は低速なので、可能な限り使用は避けることを推奨する。この理由により、<code class="literal">looking-back-p</code>の追加は計画されていない。
</p></blockquote></div><pre class="synopsis"><a id="idm76807888" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">looking-at-p</code> <em class="replaceable"><code>regexp</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この述語関数は<code class="literal">looking-at</code>と同様に機能するが、マッチデータを更新しない。
</p></blockquote></div><pre class="synopsis"><a id="idm76804176" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">search-spaces-regexp</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>なら、それは空白文字を検索する方法を告げる正規表現であること。この場合、検索される正規表現内のすべてのスペース属は、この正規表現を使用することを意味する。しかし‘<code class="literal">[…]</code>’、‘<code class="literal">*</code>’‘<code class="literal">+</code>’、‘<code class="literal">?</code>’のような構成要素内のスペースは、<code class="literal">search-spaces-regexp</code>の影響を受けない。
</p><p>この変数はすべての正規表現検索、およびマッチ構成要素に影響するので、コードの可能な限り狭い範囲にたいして、一時的にバインドするべきである。
</p></blockquote></div></div></body></html>