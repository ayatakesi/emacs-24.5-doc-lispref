<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Syntax Table Functions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Syntax-Table-Functions"/>Syntax Table Functions</h1></div></div></div><p>このセクションでは、構文テーブルを作成、アクセス、変更する関数を説明します。
</p><pre class="synopsis"><a id="idm76263504" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">make-syntax-table</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>table</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、新たに構文テーブルを作成する。<em class="replaceable"><code>table</code></em>が非<code class="literal">nil</code>なら、新たな構文テーブルの親は<em class="replaceable"><code>table</code></em>、それ以外なら標準構文テーブルが親になる。
</p><p>新たな構文テーブルでは最初は、すべての文字に構文クラス“inherit”(‘<code class="literal">@</code>’)が与えられ、それらの構文は親テーブルから継承される(<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax
Class Table</a>を参照)。
</p></blockquote></div><pre class="synopsis"><a id="idm76257232" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">copy-syntax-table</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>table</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<em class="replaceable"><code>table</code></em>のコピーを構築して、それをリターンする。<em class="replaceable"><code>table</code></em>が省略または<code class="literal">nil</code>なら、標準構文テーブルのコピーをリターンする。それ以外の場合、<em class="replaceable"><code>table</code></em>が構文テーブルでなければエラーをシグナルする。
</p></blockquote></div><pre class="synopsis"><a id="idm76247888" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">modify-syntax-entry</code> <em class="replaceable"><code>char</code></em> <em class="replaceable"><code>syntax-descriptor</code></em>  <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>table</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm76244176" class="indexterm"/><p>この関数は<em class="replaceable"><code>syntax-descriptor</code></em>に応じて、<em class="replaceable"><code>char</code></em>の構文エントリーをセットする。<em class="replaceable"><code>char</code></em>は文字、または<code class="literal">(<em class="replaceable"><code>min</code></em>
.
<em class="replaceable"><code>max</code></em>)</code>という形式のコンスセルでなければならない。後者の場合、この関数は<em class="replaceable"><code>min</code></em>と<em class="replaceable"><code>max</code></em>(両端を含む)の間のすべての文字にたいして、構文エントリーをセットする。
</p><p>構文は<em class="replaceable"><code>table</code></em>(デフォルトはカレントバッファーの構文テーブル)にたいしてのみ変更され、他のすべての構文テーブルにたいしては変更されない。
</p><p>引数<em class="replaceable"><code>syntax-descriptor</code></em>は構文記述子、すなわち1文字目が構文クラス指定子、2文字目以降がオプションでマッチング文字と構文フラグを指定する文字列である。<a class="link" href="ch35s02.html" title="Syntax Descriptors">Syntax
Descriptors</a>を参照のこと。<em class="replaceable"><code>syntax-descriptor</code></em>が有効な構文記述子でなければ、エラーがシグナルされる。
</p><p>この関数は、常に<code class="literal">nil</code>をリターンする。この文字にたいするテーブル内の古い構文情報は、破棄される。
</p><p>▼例:</p><pre class="screen">
;; 空白文字クラスのスペースをputする
(modify-syntax-entry ?\s " ")
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">;; ‘<code class="literal">$</code>’を開カッコ文字にして、
;;   ‘<code class="literal">^</code>’を対応する閉カッコにする
(modify-syntax-entry ?$ "(^")
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">;; ‘<code class="literal">^</code>’閉カッコ文字にして
;;   ‘<code class="literal">$</code>’を対応する開カッコにする
(modify-syntax-entry ?^ ")$")
     ⇒ nil
</pre><pre class="screen">
</pre><pre class="screen">;; ‘<code class="literal">/</code>’を区切り文字で
;;   コメント開始シーケンス1文字目、
;;   かつコメント終了シーケンス2文字目とする
;;   これはCモードで使用される
(modify-syntax-entry ?/ ". 14")
     ⇒ nil
</pre></blockquote></div><pre class="synopsis"><a id="idm76189392" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">char-syntax</code> <em class="replaceable"><code>character</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、指定子文字(<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax Class
Table</a>を参照)の表現で、<em class="replaceable"><code>character</code></em>の構文クラスをリターンする。これはクラス<span class="emphasis"><em>だけ</em></span>をリターンし、マッチング文字や構文フラグはリターンしない。
</p><p>以下をCモードにたいして適用してみる(<code class="literal">char-syntax</code>がリターンする文字を確認しやすいよう<code class="literal">string</code>を使用する)。
</p><pre class="screen">;; スペース文字は空白文字構文クラスをもつ
(string (char-syntax ?\s))
     ⇒ " "
</pre><pre class="screen">
</pre><pre class="screen">;; スラッシュ文字は区切り文字構文をもつ。
;; コメント開始やコメント終了シーケンスの一部でもある場合、
;; <code class="literal">char-syntax</code>呼び出しはこれを明らかにしないことに注意。
(string (char-syntax ?/))
     ⇒ "."
</pre><pre class="screen">
</pre><pre class="screen">;; 開カッコ文字は開カッコ構文をもつ。
;; これがまっちんぐ文字‘<code class="literal">)</code>’をもつことは
;; <code class="literal">char-syntax</code>呼び出しでは明らかにならないことに注意。
(string (char-syntax ?\())
     ⇒ "("
</pre></blockquote></div><pre class="synopsis"><a id="idm76179792" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-syntax-table</code> <em class="replaceable"><code>table</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファーの構文テーブルを<em class="replaceable"><code>table</code></em>にする。これは<em class="replaceable"><code>table</code></em>をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm76175824" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">syntax-table</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はカレント構文テーブル(カレントバッファーのテーブル)をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm76172880" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">describe-syntax</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このコマンドは、<em class="replaceable"><code>buffer</code></em>(デフォルトはカレントバッファー)の構文テーブルのコンテンツをhelpバッファーに表示する。
</p></blockquote></div><pre class="synopsis"><a id="idm76168912" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">with-syntax-table</code> <em class="replaceable"><code>table</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>このまくろは<em class="replaceable"><code>table</code></em>をカレント構文テーブルとして使用して、<em class="replaceable"><code>body</code></em>を実行する。これは古いカレント構文テーブルのリストア後に、<em class="replaceable"><code>body</code></em>の最後のフォームの値をリターンする。
</p><p>各バッファーは独自にカレント構文テーブルをもつので、マクロはこれを入念に行う。<code class="literal">with-syntax-table</code>はマクロ実行開始時、そのときカレントのバッファーが何であれ、カレント構文テーブルを一時的に変更する。他のバッファーは影響を受けない。
</p></blockquote></div></div></body></html>