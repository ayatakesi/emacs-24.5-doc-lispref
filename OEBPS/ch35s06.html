<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parsing Expressions</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Parsing-Expressions"/>Parsing Expressions</h1></div></div></div><a id="idm76111952" class="indexterm"/><a id="idm76111184" class="indexterm"/><p>このセクションでは、バランスのとれた式の解析やスキャンを行う関数を説明します。たとえこれらの関数がLisp以外の言語にたいして作用可能であったとしても、Lisp用語にしたがい、そのような式のことは<em class="firstterm">sexps</em>という用語で参照することにします。基本的にsexpは、バランスのとれたカッコによるグループ化、または文字列、“symbol”(構文が単語構成要素かシンボル構成要素である文字シーケンス)のいずれかです。しかし式プレフィクス構文(<a class="link" href="ch35s02.html#Syntax-Class-Table" title="Table of Syntax Classes">Syntax
Class Table</a>を参照)の文字は、それらがsexpに隣接する場合は、sexpの一部として扱われます。
</p><p>構文テーブルは文字の解釈を制御するので、これらの関数はLispモードでのLisp式、CモードでのCの式にたいして使用できます。バランスのとれた式にたいする、有用な高レベル関数については、<a class="link" href="ch30s02.html#List-Motion" title="Moving over Balanced Expressions">List
Motion</a>を参照してください。
</p><p>ある文字の構文は、パーサー自身の状態の記述ではなく、パーサー状態の変更方法を制御します。たとえば文字列区切り文字は、“in-string”と“in-code”,の間でパーサー状態をトグルしますが、文字の構文が直接文字列内部にあるかどうかを告げることはありません。たとえば(15は汎用文字列区切りの構文コードであることに注意)、
</p><pre class="screen">(put-text-property 1 9 'syntax-table '(15 . nil))
</pre><p>これはEmacsにたいして、カレントバッファーの最初の8文字が文字列であることを告げますが、それらはすべて文字列区切りです。結果としてEmacsはそれらを、連続する4つの空文字列定数として扱います。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Motion-via-Parsing"/>Motion Commands Based on Parsing</h2></div></div></div><a id="idm76093776" class="indexterm"/><p>このセクションでは、式のパースにもとづいて処理を行う、シンプルなポイント移動関数を説明します。
</p><pre class="synopsis"><a id="idm76092368" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">scan-lists</code> <em class="replaceable"><code>from</code></em> <em class="replaceable"><code>count</code></em> <em class="replaceable"><code>depth</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、位置<em class="replaceable"><code>from</code></em>からバランスのとれたカッコのグループを<em class="replaceable"><code>count</code></em>個、前方にスキャンする。これはスキャンが停止した位置をリターンする。<em class="replaceable"><code>count</code></em>が負なら、スキャンは後方に移動する。
</p><p><em class="replaceable"><code>depth</code></em>が非0なら、開始位置のカッコのネスト深さを<em class="replaceable"><code>depth</code></em>として扱う。スキャナーは、ネスト深さが0になるまで<em class="replaceable"><code>count</code></em>回、繰り返し前方または後方に移動する。そのため、正の<em class="replaceable"><code>depth</code></em>は開始位置からカッコを<em class="replaceable"><code>depth</code></em>レベル抜け出して移動する効果があり、負の<em class="replaceable"><code>depth</code></em>はカッコが<em class="replaceable"><code>depth</code></em>レベル深くなるよう移動する効果をもつ。
</p><p><code class="literal">parse-sexp-ignore-comments</code>が非<code class="literal">nil</code>なら、スキャンはコメントを無視する。
</p><p><em class="replaceable"><code>count</code></em>個のカッコのグループをスキャンする前に、スキャンがバッファーのアクセス可能範囲の先頭か終端に達した場合、そのポイントのネスト深さが0なら、値<code class="literal">nil</code>をリターンする。ネスト深さが非0なら、<code class="literal">scan-error</code>エラーをシグナルする。
</p></blockquote></div><pre class="synopsis"><a id="idm76077264" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">scan-sexps</code> <em class="replaceable"><code>from</code></em> <em class="replaceable"><code>count</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は位置<em class="replaceable"><code>from</code></em>から、<em class="replaceable"><code>count</code></em>個のsexpを前方にスキャンする。これは、スキャンが停止した位置をリターンする。<em class="replaceable"><code>count</code></em>が負なら、スキャンは後方へ移動する。
</p><p><code class="literal">parse-sexp-ignore-comments</code>が非<code class="literal">nil</code>なら、スキャンはコメントを無視する。
</p><p>カッコのグループの中間でバッファー(のアクセス可能範囲)の先頭か終端に達した場合は、エラーをシグナルする。<em class="replaceable"><code>count</code></em>個を消費する前に、カッコのグループの間でバッファーの先頭か終端に達した場合は、<code class="literal">nil</code>をリターンする。ネスト深さが非0なら、<code class="literal">scan-error</code>エラーをシグナルする。
</p></blockquote></div><pre class="synopsis"><a id="idm76069200" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">forward-comment</code> <em class="replaceable"><code>count</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>count</code></em>個の完全なコメント(すなわち、もしあれば開始区切りと終了区切りを含む)、および途中で遭遇する任意の空白文字を横断して、ポイントを前方に移動する。<em class="replaceable"><code>count</code></em>が負なら、後方に移動する。コメントまたは空白文字以外のものに遭遇したら停止して、その停止位置にポイントを残す。これには、(たとえば)前方に移動してコメント開始を調べる際に、コメント終了を探すことも含まれる。この関数は、指定された個数の完全なコメントを横断して移動した後も、即座に停止する。空白以外のものがコメント間に存在せずに、期待どおり<em class="replaceable"><code>count</code></em>個のコメントが見つかったら<code class="literal">t</code>を、それ以外は<code class="literal">nil</code>をリターンする。
</p><p>この関数は、“コメント”を横断する際、それが文字列内に埋め込まれているかどうか区別できない。コメントのように見えれば、それらはコメントとして扱われる。
</p><p>ポイント後のすべてのコメントと空白文字を飛び越して移動するには、<code class="literal">(forward-comment
(buffer-size))</code>を使用する。バッファー内のコメント数は<code class="literal">(buffer-size)</code>を超えることはできないので、これは引数としての使用に適す。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Position-Parse"/>Finding the Parse State for a Position</h2></div></div></div><a id="idm76061264" class="indexterm"/><p>インデントのような構文分析にとっては、与えられたバッファー位置に応じた構文状態の計算が有用なことが多々あります。それを手軽に行うのが、この関数です。
</p><pre class="synopsis"><a id="idm76059856" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">syntax-ppss</code> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>pos</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、パーサーがバッファー先頭から開始して位置<em class="replaceable"><code>pos</code></em>で停止するだろうという、パーサー状態をリターンする。
パーサー状態の説明は、<a class="link" href="ch35s06.html#Parser-State" title="Parser State">Parser State</a>を参照のこと
。
</p><p>リターン値は、バッファー先頭から<em class="replaceable"><code>pos</code></em>までパースするために低レベル関数<code class="literal">parse-partial-sexp</code>(<a class="link" href="ch35s06.html#Low_002dLevel-Parsing" title="Low-Level Parsing">Low-Level
Parsing</a>を参照)を呼び出した場合と同じようになる。しかし<code class="literal">syntax-ppss</code>は、計算速度向上のために、キャッシュを使用する。この最適化のため、リターンされるパーサー状態のうち2つ目の値(前の完全な部分式)と6つ目の値(最小のカッコ深さ)は意味をもたない。
</p><p>この関数は、<code class="literal">syntax-ppss-flush-cache</code>(以下参照)にたいして、<code class="literal">before-change-functions</code>(<a class="link" href="ch32s28.html" title="Change Hooks">Change
Hooks</a>を参照)にバッファーローカルなエントリーを追加するという副作用をもつ。このエントリーは、バッファー変更にたいして、キャッシュの一貫性を保つ。とはいえ、<code class="literal">before-change-functions</code>が一時的にletでバインドされている間に<code class="literal">syntax-ppss</code>が呼び出された場合、または<code class="literal">inhibit-modification-hooks</code>使用時のようにバッファーがフックを実行せずに変更される場合、キャッシュは更新されないかもしれない。そのような場合は、明示的に<code class="literal">syntax-ppss-flush-cache</code>を呼び出す必要がある。
</p></blockquote></div><pre class="synopsis"><a id="idm76048976" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">syntax-ppss-flush-cache</code> <em class="replaceable"><code>beg</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>ignored-args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<code class="literal">syntax-ppss</code>が使用するキャッシュを、位置<em class="replaceable"><code>beg</code></em>からフラッシュする。残りの引数<em class="replaceable"><code>ignored-args</code></em>は無視される。<code class="literal">before-change-functions</code>(<a class="link" href="ch32s28.html" title="Change Hooks">Change
Hooks</a>を参照)のような関数で直接使用できるよう、この関数はそれらの引数を受け入れる。
</p></blockquote></div><p>メジャーモードは、パース開始を要する箇所を指定することにより、<code class="literal">syntax-ppss</code>の実行をより高速にできます。
</p><pre class="synopsis"><a id="idm76037584" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">syntax-begin-function</code></pre><div class="blockquote"><blockquote class="blockquote"><p>これが非<code class="literal">nil</code>なら、それはパーサー状態が<code class="literal">nil</code>であるような以前のバッファー位置(別の言い方をすると任意のコメント、文字列、カッコの外部であるような位置)に移動する関数であること。キャッシュが助けとならない際、<code class="literal">syntax-ppss</code>はその計算をおり最適化するためにこれを使用する。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Parser-State"/>Parser State</h2></div></div></div><a id="idm76032592" class="indexterm"/><p><em class="firstterm">パーサー状態(parser
state)</em>とは、バッファー内の指定された開始位置と終了位置の間のテキストをパースした後の、構文パーサーの状態を記述する10要素のリストです。<code class="literal">syntax-ppss</code>のようなパース関数
(<a class="link" href="ch35s06.html#Position-Parse" title="Finding the Parse State for a Position">Position Parse</a>を参照)
は、値としてパーサー状態をリターンします。いくつかのパース関数は、パースを再開するために、引数としてパーサー状態を受け取ります。
</p><p>以下は、パーサー状態の要素の意味です:
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>0から数えたカッコの深さ。<span class="bold"><strong>警告:</strong></span> パーサーの開始位置と終了位置の間に開カッコより多くの閉カッコがあれば、負になることもある。
</p></li><li class="listitem"><a id="idm76028112" class="indexterm"/><p>停止位置を含む最内のカッコグループの開始文字位置。なければ<code class="literal">nil</code>。
</p></li><li class="listitem"><a id="idm76026320" class="indexterm"/><p>最後の終端された完全な部分式の開始文字位置。なければ<code class="literal">nil</code>。
</p></li><li class="listitem"><a id="idm76024528" class="indexterm"/><p>文字列内部なら非<code class="literal">nil</code>。より正確には、文字列を終端させるであろう文字か、汎用文字列区切りが終端すべきような場合は<code class="literal">t</code>となる。
</p></li><li class="listitem"><a id="idm76022224" class="indexterm"/><p>ネスト不可なコメント(または任意のコメントスタイル。<a class="link" href="ch35s02.html#Syntax-Flags" title="Syntax Flags">Syntax
Flags</a>を参照されたい)の内部なら<code class="literal">t</code>、ネスト可なコメントの内部ならコメントのネストレベル。
</p></li><li class="listitem"><a id="idm76019920" class="indexterm"/><p>終了位置がクォート文字直後なら<code class="literal">t</code>。
</p></li><li class="listitem"><p>当該スキャン中に遭遇した最小のカッコ深さ。
</p></li><li class="listitem"><p>アクティブなコメントの種類。コメント以外、またはスタイル‘<code class="literal">a</code>’のコメント内なら<code class="literal">nil</code>、スタイル‘<code class="literal">b</code>’のコメントなら1、スタイル‘<code class="literal">c</code>’のコメントなら2、汎用コメント区切り文字で終端されるべきコメントなら<code class="literal">syntax-table</code>。
</p></li><li class="listitem"><p>文字列またはコメントの開始位置。コメント内部ならコメントが始まる位置。文字列内部なら文字列が始まる位置。文字列またはコメントの外部なら、この要素は<code class="literal">nil</code>になる。
</p></li><li class="listitem"><p>パースを継続するための内部データ。このデータのもつ意味は、変更され得る。これは、他の呼び出しの<em class="replaceable"><code>state</code></em>引数としてこのリストを渡す場合に使用される。
</p></li></ol></div><p>パース継続のために渡す場合、要素1、2、6は無視され、要素8と9は特に重要ではない場面でのみ使用されます。これらの要素は主に、パーサーコードにより内部的に使用されます。
</p><p>以下の関数を使用することにより、さらに追加でパーサー状態から有用な情報を利用できます:
</p><pre class="synopsis"><a id="idm75999440" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">syntax-ppss-toplevel-pos</code> <em class="replaceable"><code>state</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はパーサー状態<em class="replaceable"><code>state</code></em>から、文法構造上トップレベルでのパースにおける、スキャンした最後の位置をリターンする。“トップレベル”とは、すべてのカッコ、コメント、文字列の外部であることを意味する。
</p><p><em class="replaceable"><code>state</code></em>がトップレベルの位置に到達したパースを表す場合、値は<code class="literal">nil</code>となる。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Low_002dLevel-Parsing"/>Low-Level Parsing</h2></div></div></div><p>式パーサーを使用するもっとも基本的な方法は、特定の状態で与えられた位置からパースを開始して、指定した位置でパースを終了するよう指示する方法です。
</p><pre class="synopsis"><a id="idm75993296" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">parse-partial-sexp</code> <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>limit</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>target-depth</code></em> <em class="replaceable"><code>stop-before</code></em> <em class="replaceable"><code>state</code></em> <em class="replaceable"><code>stop-comment</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、カレントバッファー内のsexpを、<em class="replaceable"><code>start</code></em>から開始して<em class="replaceable"><code>limit</code></em>を超えてスキャンしないようパースを行う。これは位置<em class="replaceable"><code>limit</code></em>、または以下に記述する特定の条件に適合したら停止して、パースが停止した位置にポイントをセットする。これはポイントが停止した位置でのパースの状態を記述するパーサー状態
をリターンする。
</p><a id="idm75974608" class="indexterm"/><p>3つ目の引数<em class="replaceable"><code>target-depth</code></em>が非<code class="literal">nil</code>の場合、カッコの深さが<em class="replaceable"><code>target-depth</code></em>と等しくなったら、パースを停止する。この深さは0、または<em class="replaceable"><code>state</code></em>内で与えられる深さなら何であれ、そこより開始される。
</p><p>4つ目の引数<em class="replaceable"><code>stop-before</code></em>が非<code class="literal">nil</code>の場合、sexp開始となる任意の文字に到達したらパースは停止する。<em class="replaceable"><code>stop-comment</code></em>が非<code class="literal">nil</code>なら、コメントの開始でパースは停止する。<em class="replaceable"><code>stop-comment</code></em>がシンボル<code class="literal">syntax-table</code>なら、コメントか文字列の開始の後、またはコメントか文字列の終了のいずれか先に到達した方でパースは停止する。
</p><p><em class="replaceable"><code>state</code></em>が<code class="literal">nil</code>なら、<em class="replaceable"><code>start</code></em>は関数定義先頭のような、カッコ構造のトップレベルであるとみなされる。かわりにこの構造の中間でパースを再開したいと思うかもしれない。これを行うには、パースの初期状態を記述する<em class="replaceable"><code>state</code></em>引数を提供しなければならない。前の<code class="literal">parse-partial-sexp</code>呼び出しでリターンされた値で、これをうまく行うことができるだろう。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Control-Parsing"/>Parameters to Control Parsing</h2></div></div></div><a id="idm75965264" class="indexterm"/><pre class="synopsis"><a id="idm75964240" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">multibyte-syntax-as-symbol</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数が非<code class="literal">nil</code>なら、構文テーブルがそれらについて何と言っているかに関わらず、<code class="literal">scan-sexps</code>はすべての非<acronym class="acronym">ASCII</acronym>文字をシンボル構成要素として扱う(とはいえ依然としてテキストプロパティは構文をオーバーラードできるが)。
</p></blockquote></div><pre class="synopsis"><a id="idm75960144" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">parse-sexp-ignore-comments</code></pre><div class="blockquote"><blockquote class="blockquote"><a id="idm75958096" class="indexterm"/><p>この値が非<code class="literal">nil</code>なら、このセクション内の関数、および<code class="literal">forward-sexp</code>、<code class="literal">scan-lists</code>、<code class="literal">scan-sexps</code>はコメントを空白文字として扱う。
</p></blockquote></div><a id="idm75950800" class="indexterm"/><p><code class="literal">parse-partial-sexp</code>の振る舞いも、<code class="literal">parse-sexp-lookup-properties</code>の影響を受けます(<a class="link" href="ch35s04.html" title="Syntax Properties">Syntax
Properties</a>を参照)。
</p><p>1つ、または複数のコメントを横断して前方または後方に移動するには、<code class="literal">forward-comment</code>を使用できます。
</p></div></div></body></html>