<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sentinels: Detecting Process Status Changes</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Sentinels"/>Sentinels: Detecting Process Status Changes</h1></div></div></div><a id="idm78856400" class="indexterm"/><a id="idm78855632" class="indexterm"/><p><em class="firstterm">プロセスセンチネル(process sentinel:
プロセス番兵)</em>とは、(Emacsにより送信されたか、そのプロセス自身の動作が原因で送信された)プロセスを終了、停止、継続するシグナルを含む、何らかの理由により関連付けられたプロセスの状態が変化した際は常に呼び出される関数のことです。プロセスがexitする際にも、プロセスセンチネルが呼び出されます。センチネルは、イベントが発生したプロセスと、イベントのタイプを記述する文字列という、2つの引数を受け取ります。
</p><p>イベントを記述する文字列は、以下のいずれかのような外見をもちます:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">"finished\n"</code>.
</p></li><li class="listitem"><p><code class="literal">"exited abnormally with code <em class="replaceable"><code>exitcode</code></em>\n"</code>.
</p></li><li class="listitem"><p><code class="literal">"<em class="replaceable"><code>name-of-signal</code></em>\n"</code>.
</p></li><li class="listitem"><p><code class="literal">"<em class="replaceable"><code>name-of-signal</code></em> (core dumped)\n"</code>.
</p></li></ul></div><p>センチネルは、Emacsが(端末入力や時間経過、またはプロセス出力を)待機している間だけ実行されます。これは、他のLispプログラムの途中のランダムな箇所で実行されるセンチネルが原因となる、タイミングエラーを無視します。プログラムはセンチネルが実行されるように、<code class="literal">sit-for</code>や<code class="literal">sleep-for</code>(<a class="link" href="ch21s10.html" title="Waiting for Elapsed Time or Input">Waiting</a>を参照)、または<code class="literal">accept-process-output</code>(<a class="link" href="ch37s09.html#Accepting-Output" title="Accepting Output from Processes">Accepting
Output</a>を参照)を呼び出すことにより待機することができます。Emacsはコマンドループが入力を読み取る際にも、センチネルの実行を許可します。<code class="literal">delete-process</code>は、実行中のプログラムを終了させる際に、センチネルを呼び出します。
</p><p>Emacsは1つのプロセスのセンチネル呼び出しの理由のために複数のキューを保持しません。これはカレント状態と、変化があった事実だけを記録します。したがって非常に短い間隔で、連続して状態に2つの変化があった場合は、一度だけセンチネルが呼び出されます。しかしプロセスの終了は、常に正確に1回センチネルを実行するでしょう。これは終了後にプロセス状態が再び変更されることはないからです。
</p><p>Emacsはプロセスセンチネル実行の前に、プロセスからの出力をチェックします。プロセス終了によりセンチネルが一度実行されると、そのプロセスから更なる出力は到着しません。
</p><p>プロセスのバッファーに出力を書き込むセンチネルは、そのバッファーがまだ生きているかチェックするべきです。死んだバッファーへの挿入を試みた場合は、エラーとなるでしょう。そのバッファーがすでに死んでいれば、<code class="literal">(buffer-name
(process-buffer <em class="replaceable"><code>process</code></em>))</code>は<code class="literal">nil</code>をリターンします。
</p><p>quitは通常はセンチネル内では抑制されます。さもないと、コマンドレベルでの<strong class="userinput"><code>C-g</code></strong>のタイプ、またはユーザーコマンドのquitは予測できません。センチネル内部でのquitを許可したければ、<code class="literal">inhibit-quit</code>を<code class="literal">nil</code>にバインドしてください。ほとんどの場合において、これを行う正しい方法はマクロ<code class="literal">with-local-quit</code>です。<a class="link" href="ch21s11.html" title="Quitting">Quitting</a>を参照してください。
</p><p>センチネルの実行中にエラーが発生した場合、センチネル開始時に実行中だったプログラムが何であれ実行を停止しないように、自動的にcatchされます。しかし<code class="literal">debug-on-error</code>が非<code class="literal">nil</code>なら、エラーはcatchされません。これにより、Lispデバッガーを使用したセンチネルのデバッグが可能になります。<a class="link" href="ch18.html#Debugger" title="The Lisp Debugger">Debugger</a>を参照してください。
</p><p>センチネル実行中、センチネルが再帰的に実行されないよう、プロセスセンチネルは一時的に<code class="literal">nil</code>にセットされます。この理由により、センチネルが新たにセンチネルを指定することはできません。
</p><p>センチネル実行中、Emacsは自動的にマッチデータの保存とリストアを行うことに注意してください。<a class="link" href="ch34s06.html" title="The Match Data">Match Data</a>を参照してください。
</p><pre class="synopsis"><a id="idm78831184" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">set-process-sentinel</code> <em class="replaceable"><code>process</code></em> <em class="replaceable"><code>sentinel</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>process</code></em>に関連付ける。<em class="replaceable"><code>sentinel</code></em>が<code class="literal">nil</code>なら、そのプロセスはプロセス状態変更時にプロセスのバッファーにメッセージを挿入する、デフォルトのセンチネルをもつことになるだろう。
</p><p>プロセスセンチネルの変更は、即座に効果を発揮する。そのセンチネルが実行される予定だが、まだ呼び出されておらず、かつ新たなセンチネルを指定した場合、最終的なセンチネル呼び出しには、新たなセンチネルが使用されるだろう。
</p><pre class="screen">(defun msg-me (process event)
   (princ
     (format "Process: %s had the event `%s'" process event)))
(set-process-sentinel (get-process "shell") 'msg-me)
     ⇒ msg-me
</pre><pre class="screen">(kill-process (get-process "shell"))
     ⊣ Process: #&lt;process shell&gt; had the event `killed'
     ⇒ #&lt;process shell&gt;
</pre></blockquote></div><pre class="synopsis"><a id="idm78825040" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">process-sentinel</code> <em class="replaceable"><code>process</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<em class="replaceable"><code>process</code></em>のセンチネルをリターンする。
</p></blockquote></div><p>あるプロセス状態の変化を複数のセンチネルに渡す必要がある場合は、既存のセンチネルと新たなセンチネルを組み合わせるために、<code class="literal">add-function</code>を使用できます。<a class="link" href="ch13s10.html" title="Advising Emacs Lisp Functions">Advising
Functions</a>を参照してください。
</p><pre class="synopsis"><a id="idm78820048" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">waiting-for-user-input-p</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、センチネルまたはフィルター関数の実行中、もしEmacsがセンチネルまたはフィルター関数呼び出し時にユーザーのキーボード入力を待機していたら非<code class="literal">nil</code>、そうでなければ<code class="literal">nil</code>をリターンする。
</p></blockquote></div></div></body></html>