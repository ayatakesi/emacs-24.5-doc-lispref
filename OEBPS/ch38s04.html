<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>The Echo Area</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="The-Echo-Area"/>The Echo Area</h1></div></div></div><a id="idm77888976" class="indexterm"/><a id="idm77888208" class="indexterm"/><p><em class="firstterm">エコーエリア(echo
area)</em>はエラーメッセージ(<a class="link" href="ch11s05.html#Errors" title="Errors">Errors</a>)や、<code class="literal">message</code>プリミティブで作成されたメッセージの表示、およびキーストロークをエコーするために使用されます。(アクティブ時には)ミニバッファーがスクリーン上のエコーエリアと同じ場所に表示されるという事実にも関わらず、エコーエリアはミニバッファーと同じではありません。section “The Minibuffer” in <em class="citetitle">The GNU Emacs Manual</em>を参照してください。
</p><p>このセクションに記述された関数とは別に、出力ストリームとして<code class="literal">t</code>を指定することにより、エコーエリアにLispオブジェクトをプリントできます。<a class="link" href="ch19s04.html" title="Output Streams">Output
Streams</a>を参照してください。
</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Displaying-Messages"/>Displaying Messages in the Echo Area</h2></div></div></div><a id="idm77882832" class="indexterm"/><p>このセクションでは、エコーエリア内にメッセージを表示する、標準的な関数を説明します。
</p><pre class="synopsis"><a id="idm77881296" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">message</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>arguments</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、エコーエリア内にメッセージを表示する。<code class="literal">format</code>関数(<a class="link" href="ch05s07.html" title="Formatting Strings">Formatting
Strings</a>を参照)の場合と同様、<em class="replaceable"><code>format-string</code></em>はフォーマット文字列、<em class="replaceable"><code>arguments</code></em>はそのフォーマット仕様にたいするオブジェクトである。フォーマットされた結果文字列は、エコーエリア内に表示される。それに<code class="literal">face</code>テキストプロパティが含まれる場合、指定されたフェイスにより表示される(<a class="link" href="ch38s12.html" title="Faces">Faces</a>を参照)。この文字列は<code class="filename">*Messages*</code>バッファーにも追加されるが、テキストプロパティは含まれない(<a class="link" href="ch38s04.html#Logging-Messages" title="Logging Messages in *Messages*">Logging
Messages</a>を参照)。
</p><p>バッチモードでは、後に改行が付加されたメッセージが、標準エラーストリームにプリントされる。
</p><p><em class="replaceable"><code>format-string</code></em>が<code class="literal">nil</code>か空文字列なら、<code class="literal">message</code>はエコーエリアをクリアーする。エコーエリアが自動的に拡張されていたら、これにより通常のサイズに復元される。ミニバッファーがアクティブなら、これによりスクリーン上に即座にミニバッファーのコンテンツが復元される。
</p><pre class="screen">(message "Minibuffer depth is %d."
         (minibuffer-depth))
 ⊣ Minibuffer depth is 0.
⇒ "Minibuffer depth is 0."
</pre><pre class="screen">
</pre><pre class="screen">---------- Echo Area ----------
Minibuffer depth is 0.
---------- Echo Area ----------
</pre><p>エコーエリアやポップバッファー内に、自動的にメッセージを表示するには、そのサイズに応じて<code class="literal">display-message-or-buffer</code>(以下参照)を使用する。
</p></blockquote></div><pre class="synopsis"><a id="idm77865168" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">with-temp-message</code> <em class="replaceable"><code>message</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>body</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この構成は<em class="replaceable"><code>body</code></em>実行の間、エコーエリア内にメッセージを一時的に表示する。これは<em class="replaceable"><code>message</code></em>を表示して<em class="replaceable"><code>body</code></em>を実行し、それからエコーエリアの前のコンテンツをリストアするとともに、bodyの最後のフォームの値をリターンする。
</p></blockquote></div><pre class="synopsis"><a id="idm77860048" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">message-or-box</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>arguments</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">message</code>と同様にメッセージを表示するが、エコーエリアではなくダイアログボックスにメッセージを表示するかもしれない。この関数があるコマンド内からマウスを使用して呼び出された場合
— より正確には<code class="literal">last-nonmenu-event</code>(<a class="link" href="ch21s05.html" title="Information from the Command Loop">Command Loop
Info</a>を参照)が<code class="literal">nil</code>かリストなら、そのメッセージの表示にダイアログボックスまたはポップアップメニューを使用する。それ以外の場合は、エコーエリアを使用する(これは<code class="literal">y-or-n-p</code>が同様の決定を行う際に使用する条件と同じである。<a class="link" href="ch20s07.html" title="Yes-or-No Queries">Yes-or-No
Queries</a>を参照されたい)。
</p><p>呼び出しの前後で<code class="literal">last-nonmenu-event</code>を適切な値にバインドすることにより、エコーエリアでのマウスの使用を強制できる。
</p></blockquote></div><pre class="synopsis"><a id="idm77851984" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">message-box</code> <em class="replaceable"><code>format-string</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>arguments</code></em></pre><div class="blockquote"><blockquote class="blockquote"><a id="message_002dbox"/><p>この関数は<code class="literal">message</code>と同様にメッセージを表示するが、利用可能なら常にダイアログボックス(かポップアップメニュー)を使用する。端末がサポートしないために、ダイアログボックスまたはポップアップメニューが使用できなければ、<code class="literal">message-box</code>は<code class="literal">message</code>と同様にエコーエリアを使用する。
</p></blockquote></div><pre class="synopsis"><a id="idm77846224" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">display-message-or-buffer</code> <em class="replaceable"><code>message</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>buffer-name</code></em> <em class="replaceable"><code>not-this-window</code></em> <em class="replaceable"><code>frame</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数はメッセージ<em class="replaceable"><code>message</code></em>を表示する。<em class="replaceable"><code>message</code></em>は文字列かバッファーを指定できる。これが<code class="literal">max-mini-window-height</code>で定義されるエコーエリアの最大高さより小さければ、<code class="literal">message</code>を使用してエコーエリアに表示される。それ以外なら、メッセージを表示するために<code class="literal">display-buffer</code>はポップアップバッファーを使用する。
</p><p>エコーエリアに表示したメッセージ、またはポップアップバッファー使用時はその表示に使用したウィンドウをリターンする。
</p><p><em class="replaceable"><code>message</code></em>が文字列なら、オプション引数<em class="replaceable"><code>buffer-name</code></em>はポップアップバッファー使用時にメッセージ表示に使用するバッファー名(デフォルトは<code class="filename">*Message*</code>)である。<em class="replaceable"><code>message</code></em>が文字列でエコーエリアに表示されてる場合は、いずれにせよコンテンツをバッファーに挿入するかどうかは指定されない。
</p><p>オプション引数<em class="replaceable"><code>not-this-window</code></em>と<em class="replaceable"><code>frame</code></em>は、<code class="literal">display-buffer</code>の場合と同様に、バッファーが表示されている場合のみ使用される。
</p></blockquote></div><pre class="synopsis"><a id="idm77830864" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">current-message</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、エコーエリア内にカレントで表示されているメッセージ、またはそれが存在しなければ<code class="literal">nil</code>をリターンする。
</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Progress"/>Reporting Operation Progress</h2></div></div></div><a id="idm77826768" class="indexterm"/><p>処理の完了まで暫く時間を要するかもしれない際は、その進行状況についてユーザーに通知するべきです。これによりユーザーが残り時間を予測するとともに、Emacsがhungしているのではなく、処理中であえうことが明確に確認できます。<em class="firstterm">プログレスリポーター(progress
reporter: 進行状況リポーター)</em>を使用するのが、これを行う便利な方法です。
</p><p>以下は、何も有用なことを行わない、実行可能な例です:
</p><pre class="screen">(let ((progress-reporter
       (make-progress-reporter "Collecting mana for Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
</pre><pre class="synopsis"><a id="idm77811792" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">make-progress-reporter</code> <em class="replaceable"><code>message</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>min-value</code></em> <em class="replaceable"><code>max-value</code></em> <em class="replaceable"><code>current-value</code></em> <em class="replaceable"><code>min-change</code></em> <em class="replaceable"><code>min-time</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、以下に挙げる他の関数として使用されるであろう、プログレスリポーターオブジェクトを作成して、リターンする。これはプログレスリポーターを高速にするように、可能なかぎり多くのデータを事前に計算するというアイデアが元である。
</p><p>この後にこのプログレスリポーターを使用する際は、進行状況のパーセンテージを後に付加して<em class="replaceable"><code>message</code></em>が表示されるだろう。<em class="replaceable"><code>message</code></em>は、単なる文字列として扱われる。たとえばファイル名に依存させる必要があるなら、この関数の呼び出し前に、<code class="literal">format</code>を使えばよい。
</p><p>引数<em class="replaceable"><code>min-value</code></em>と<em class="replaceable"><code>max-value</code></em>は、その処理の開始と終了を意味する数値であること。たとえばバッファーを“スキャン”する処理なら、これらをそれぞれ<code class="literal">point-min</code>と<code class="literal">point-max</code>にセットするべきだろう。<em class="replaceable"><code>max-value</code></em>は<em class="replaceable"><code>min-value</code></em>より大であること。
</p><p>かわりに、<em class="replaceable"><code>min-value</code></em>と<em class="replaceable"><code>max-value</code></em>を<code class="literal">nil</code>にセットすることができる。この場合、プログレスリポーターは進行状況のパーセンテージを報告しない。かわりにプログレスリポーターを更新するたびに刻み(notch)を回転する“スピナー(spinner)”を表示する。
</p><p><em class="replaceable"><code>min-value</code></em>と<em class="replaceable"><code>max-value</code></em>が数値なら、進行状況の初期の数値を与える引数<em class="replaceable"><code>current-value</code></em>を与えることができる。省略時のデフォルトは<em class="replaceable"><code>min-value</code></em>。
</p><p>残りの引数は、エコーエリアの更新レートを制御する。プログレスリポーターは次のメッセージを表示する前に、その処理が少なくとも<em class="replaceable"><code>min-change</code></em>パーセントより多く完了するまで待機する。デフォルトは1パーセント。<em class="replaceable"><code>min-time</code></em>は連続するプリントの間に空ける最小時間をミリ秒単位で指定する(いくつかのオペレーティングシステムでは、プログレスリポーターは秒の少数部をさまざまな制度で処理するかもしれない)。
</p><p>この関数は<code class="literal">progress-reporter-update</code>を呼び出すた、最初のメッセージは即座にプリントされる。
</p></blockquote></div><pre class="synopsis"><a id="idm81941328" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">progress-reporter-update</code> <em class="replaceable"><code>reporter</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>value</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、操作の進行状況報告に関する、主要な機能を担う。これは<em class="replaceable"><code>reporter</code></em>のメッセージと、その後に<em class="replaceable"><code>value</code></em>により決定された進行状況のパーセンテージを表示する。パーセンテージが0、または引数<em class="replaceable"><code>min-change</code></em>と<em class="replaceable"><code>min-time</code></em>に比べて十分0に近ければ、出力は省略される。
</p><p><em class="replaceable"><code>reporter</code></em>は、<code class="literal">make-progress-reporter</code>呼び出しがリターンした結果でなければならない。<em class="replaceable"><code>value</code></em>は処理のカレント状況を指定し、<code class="literal">make-progress-reporter</code>に渡された<em class="replaceable"><code>min-value</code></em>と<em class="replaceable"><code>max-value</code></em>の間(両端を含む)でなければならない。たとえばバッファーのスキャンにおいては、<em class="replaceable"><code>value</code></em>は<code class="literal">point</code>び呼び出し結果であるべきだろう。
</p><p>この関数は<code class="literal">make-progress-reporter</code>に渡された<em class="replaceable"><code>min-change</code></em>と<em class="replaceable"><code>min-time</code></em>にしたがい、毎回の呼び出しで新たなメッセージを出力しない。したがってこれは非常に高速であり、通常はこれを呼び出す回数を減らすことを試みるべきではない。結果として生じるオーバーヘッドは、あなたの努力をほぼ否定するだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm81930192" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">progress-reporter-force-update</code> <em class="replaceable"><code>reporter</code></em> <em class="replaceable"><code>&amp;optional</code></em> <em class="replaceable"><code>value</code></em> <em class="replaceable"><code>new-message</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は<code class="literal">progress-reporter-update</code>と同様だが、これは無条件にメッセージをエコーエリアにプリントする点が異なる。
</p><p>最初の2つの引数は、<code class="literal">progress-reporter-update</code>の場合と同じ意味をもつ。オプションの<em class="replaceable"><code>new-message</code></em>で、<em class="replaceable"><code>reporter</code></em>のメッセージを変更できる。この関数は常にエコーエリアを更新するので、そのような変更は即座にユーザーに示されるだろう。
</p></blockquote></div><pre class="synopsis"><a id="idm81919440" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">progress-reporter-done</code> <em class="replaceable"><code>reporter</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、処理の完了時に呼び出されるべきである。これはエコーエリア内に、単語“done”が付加された<em class="replaceable"><code>reporter</code></em>のメッセージを表示する。
</p><p>あなたは<code class="literal">progress-reporter-update</code>に“100%”とプリントさせようとせず、常にこの関数を呼び出すべきである。まず、この関数は決してそれをプリントしないだろうし、これが発生しないために多くの正当な理由がある。次に“done”はより自明である。
</p></blockquote></div><pre class="synopsis"><a id="idm81890384" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">dotimes-with-progress-reporter</code> (<em class="replaceable"><code>var</code></em> <em class="replaceable"><code>count</code></em> [<em class="replaceable"><code>result</code></em>]) <em class="replaceable"><code>message</code></em> <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<code class="literal">dotimes</code>と同じ方法で機能するが、上述の関数を使用してループ進行状況(loop
progress)の報告も行う、便利なマクロである。これにより、タイプ量を幾分節約できる。
</p><p>以下の方法でこのマクロを使用することにより、このセクション冒頭の例を書き換えることができる:
</p><pre class="screen">(dotimes-with-progress-reporter
    (k 500)
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
</pre></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Logging-Messages"/>Logging Messages in <code class="filename">*Messages*</code></h2></div></div></div><a id="idm81882832" class="indexterm"/><p>エコーエリア内に表示されるほとんどすべてのメッセージは、ユーザーが後で参照できるように、<code class="filename">*Messages*</code>バッファー内にも記録されます。これには<code class="literal">message</code>により出力されたメッセージも含まれます。デフォルトではこのバッファーは読み取り専用で、メジャーモード<code class="literal">messages-buffer-mode</code>を使用します。ユーザーによる<code class="filename">*Messages*</code>バッファーのkillを妨げるものは何もありませんが、次回のメッセージ表示でバッファーは再作成されます。<code class="filename">*Messages*</code>バッファーに直接アクセスする必要があり、それが確実に存在するようにしたいLispコードはすべて、関数<code class="literal">messages-buffer</code>を使用するべきです。
</p><pre class="synopsis"><a id="idm81878352" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">messages-buffer</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この関数は、<code class="filename">*Messages*</code>バッファーをリターンする。バッファーが存在しなければ作成して、そのバッファーを<code class="literal">messages-buffer-mode</code>に切り替える。
</p></blockquote></div><pre class="synopsis"><a id="idm81874384" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">message-log-max</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、<code class="filename">*Messages*</code>バッファー内に保持するべき行数を指定する。値<code class="literal">t</code>は保持すべき行数に制限がないことを意味し、値<code class="literal">nil</code>はメッセージのロギングを完全に無効にする。以下は、メッセージを表示して、それがロギングされることを防ぐ例である:
</p><pre class="screen">(let (message-log-max)
  (message …))
</pre></blockquote></div><p><code class="filename">*Messages*</code>にたいするユーザーの利便性を向上させるために、ロギング機能は連続する同じメッセージを結合します。さらに、2つのケースのために連続する関連メッセージの結合も行います。2つのケースとは、応答を後にともなう質問(question
followed by answer)と、一連のプログレスメッセージ(series of progress messages)です。
</p><p>“応答を後にともなう質問(question followed by an
answer)”とは、<code class="literal">y-or-n-p</code>により生成されるような、これは1つ目が‘<code class="literal"><em class="replaceable"><code>question</code></em></code>’、2つ目が‘<code class="literal"><em class="replaceable"><code>question</code></em>...<em class="replaceable"><code>answer</code></em></code>’のような、2つのメッセージです。1つ目のメッセージには、2つ目のメッセージ以上の追加の情報は伝えないので、2つ目のメッセージをロギングして、1つ目のメッセージは破棄します。
</p><p>“一連のプログレスメッセージ(series of progress
messages)”とは、<code class="literal">make-progress-reporter</code>が生成するような、連続するメッセージを意味します。これらは‘<code class="literal"><em class="replaceable"><code>base</code></em>...<em class="replaceable"><code>how-far</code></em></code>’のような形式をもち、<em class="replaceable"><code>how-far</code></em>は毎回異なりますが、<em class="replaceable"><code>base</code></em>は常に同じです。このシリーズ内の各メッセージのロギングでは、そのメッセージが前のメッセージと連続していれば、前のメッセージを破棄します。
</p><p>関数<code class="literal">make-progress-reporter</code>および<code class="literal">y-or-n-p</code>は、メッセージログ結合機能をアクティブにするために、何ら特別なことを行う必要はありません。これは‘<code class="literal">...</code>’で終わる共通のプレフィックスを共有する、連続する2つのメッセージをログする際は、常にこの処理を行います。
</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="Echo-Area-Customization"/>Echo Area Customization</h2></div></div></div><a id="idm81860816" class="indexterm"/><p>以下の変数は、エコーエリアが機能する方法の詳細を制御します。
</p><pre class="synopsis"><a id="idm81859408" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">cursor-in-echo-area</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、エコーエリア内にメッセージ表示時に、カーソルを表示する場所を制御する。これが非<code class="literal">nil</code>なら、カーソルはメッセージの終端に表示される。それ以外なら、カーソルはエコーエリア内ではなく、ポイント位置に表示される。
</p><p>この値は、通常は<code class="literal">nil</code>である。Lispプログラムは短時間の間、これを<code class="literal">t</code>にバインドする。
</p></blockquote></div><pre class="synopsis"><a id="idm81854800" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">echo-area-clear-hook</code></pre><div class="blockquote"><blockquote class="blockquote"><p>このノーマルフックは<code class="literal">(message nil)</code>、または別の何らかの理由によりエコーエリアが作成されると、常に実行される。
</p></blockquote></div><pre class="synopsis"><a id="idm81851472" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">echo-keystrokes</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数は、コマンド文字をエコーする前に、どれだけの時間を待機するかを決定する。この値は数字でなければならず、エコー前に待機する秒数を指定する。ユーザーが(<strong class="userinput"><code>C-x</code></strong>のような)プレフィックスキーをタイプしてから、継続してタイプを継続するのをこの秒数遅延した場合、エコーエリア内にそのプレフィックスキーがエコーされる(あるキーシーケンスで一度エコーが開始されると、同一のキーシーケンス内の後続するすべての文字は、即座にエコーされる)。
</p><p>値が0なら、コマンド入力はエコーされない。
</p></blockquote></div><pre class="synopsis"><a id="idm81847888" class="indexterm"/><span class="category"><span class="bold"><strong>Variable</strong></span>:</span> <code class="varname">message-truncate-lines</code></pre><div class="blockquote"><blockquote class="blockquote"><p>通常、長いメッセージの表示により、そのメッセージ全体を表示するために、エコーエリアはリサイズされる。しかし変数<code class="literal">message-truncate-lines</code>が非<code class="literal">nil</code>なら、エコーエリアをリサイズせず、エコーエリアに収まるようメッセージは切り詰められる。
</p></blockquote></div><p>ミニバッファーウィンドウのリサイズの最大高さを指定する変数<code class="literal">max-mini-window-height</code>は、エコーエリアにも適用される(エコーエリアは真にミニバッファーウィンドウの特殊な使い方である。<a class="link" href="ch20s14.html" title="Minibuffer Miscellany">Minibuffer
Misc</a>を参照されたい)。
</p></div></div></body></html>