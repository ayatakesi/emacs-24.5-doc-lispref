<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Timers for Delayed Execution</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="Timers"/>Timers for Delayed Execution</h1></div></div></div><a id="idm85689936" class="indexterm"/><p>将来の特定時刻や特定の長さのアイドル時間経過後に関数を呼び出すために、<em class="firstterm">タイマー(timer)</em>をセットアップできます。
</p><p>Emacsは、Lispプログラム内の任意の時点では、タイマーを実行できません。サブプロセスからの出力が受け入れ可能なときだけ、Emacsはタイマーを実行できます。つまり待機中や、待機することが<span class="emphasis"><em>可能</em></span>な、<code class="literal">sit-for</code>や<code class="literal">read-event</code>のような特定のプリミティブ関数内部でのみ、タイマーを実行できます。したがってEmacsがbusyなら、タイマーの実行は遅延するかもしれません。しかしEmacsがidleなら、実行される時刻は非常に正確になります。
</p><p>quitにより、多くのタイマー関数が物事を不整合な状態に放置し得るので、ターマー関数呼び出し前にEmacsは<code class="literal">inhibit-quit</code>に<code class="literal">t</code>をバインドします。ほとんどのタイマー関数は多くの作業を行わないので、これは通常は問題にはなりません。しかし実際には、実行に長時間を要する関数を呼び出すタイマーは問題となる恐れがあります。タイマー関数がquitを許容する必要がある場合は、<code class="literal">with-local-quit</code>を使用するべきです(<a class="link" href="ch21s11.html" title="Quitting">Quitting</a>を参照)。たとえば、外部プロセスから出力を受け取るためにタイマー関数が<code class="literal">accept-process-output</code>を呼び出す場合、外部プロセスのハング時の<strong class="userinput"><code>C-g</code></strong>を確実に機能させるために、その呼び出しを<code class="literal">with-local-quit</code>内部にラップすべきです。
For exam；ple, if a timer function calls  to receive output from an external
process, that call should be wrapped inside , to ensure that  works if the
external process hangs.
</p><p>バッファー内容の変更のためにタイマー関数を呼び出すのは、通常は悪いアイデアです。これを行うときには、そのタイマーによる変更とユーザーのコマンドによる変更を分離して、単一のアンドゥエントリーが巨大になるのを防ぐために、バッファーの変更前後で、通常は<code class="literal">undo-boundary</code>を呼び出すべきです。
</p><p>タイマー関数は<code class="literal">sit-for</code>のようなEmacsに待機を発生させるような関数(<a class="link" href="ch21s10.html" title="Waiting for Elapsed Time or Input">Waiting</a>を参照)の呼び出しも避けるべきです。その待機中に別のタイマー(同じタイマーとう可能性さえある)が実行され得るので、これは予測不可能な効果を導く恐れがあります。特定時間の経過後に処理される必要があるタイマー関数は、新たなタイマーをスケジュールすることにより、これを行うことができます。
</p><p>マッチデータを変更するかもしれない関数を呼び出すタイマー関数は、マッチデータの保存とリストアをするべきです。<a class="link" href="ch34s06.html#Saving-Match-Data" title="Saving and Restoring the Match Data">Saving Match
Data</a>を参照してください。
</p><pre class="synopsis"><a id="idm85679184" class="indexterm"/><span class="category"><span class="bold"><strong>Command</strong></span>:</span> <code class="function">run-at-time</code> <em class="replaceable"><code>time</code></em> <em class="replaceable"><code>repeat</code></em> <em class="replaceable"><code>function</code></em> <em class="replaceable"><code>&amp;rest</code></em> <em class="replaceable"><code>args</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは時刻<em class="replaceable"><code>time</code></em>に、引数<em class="replaceable"><code>args</code></em>で関数<em class="replaceable"><code>function</code></em>を呼び出すタイマーをセットアップする。<em class="replaceable"><code>repeat</code></em>が数値(整数か浮動小数点数)なら、そのタイマーは<em class="replaceable"><code>time</code></em>後の各<em class="replaceable"><code>repeat</code></em>秒ごとに再実行されるようスケジュールされる。<em class="replaceable"><code>repeat</code></em>が<code class="literal">nil</code>なら、そのタイマーは1回だけ実行される。
</p><p><em class="replaceable"><code>time</code></em>には、絶対時刻と相対時刻を指定できる。
</p><p>絶対時刻は限定された種々フォーマットの文字列を使用して指定でき、すでに経過後の時刻であっても<span class="emphasis"><em>当日</em></span>の時刻とみなされる。認識される形式は‘<code class="literal"><em class="replaceable"><code>xxxx</code></em></code>’、‘<code class="literal"><em class="replaceable"><code>x</code></em>:<em class="replaceable"><code>xx</code></em></code>’、or
‘<code class="literal"><em class="replaceable"><code>xx</code></em>:<em class="replaceable"><code>xx</code></em></code>’ (military time)、and
‘<code class="literal"><em class="replaceable"><code>xx</code></em>am</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>AM</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>pm</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>PM</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>:<em class="replaceable"><code>xx</code></em>am</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>:<em class="replaceable"><code>xx</code></em>AM</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>:<em class="replaceable"><code>xx</code></em>pm</code>’、‘<code class="literal"><em class="replaceable"><code>xx</code></em>:<em class="replaceable"><code>xx</code></em>PM</code>’のいずれか。時と分をの部分を区切るのは、コロンのかわりにピリオドも使用できる。
</p><p>相対時刻は単位を付加した数字を、文字列として指定する。たとえば:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">‘<code class="literal">1 min</code>’
</span></dt><dd><p>現在時刻から1分後を表す。
</p></dd><dt><span class="term">‘<code class="literal">1 min 5 sec</code>’
</span></dt><dd><p>現在時刻から65秒後を表す。
</p></dd><dt><span class="term">‘<code class="literal">1 min 2 sec 3 hour 4 day 5 week 6 fortnight 7 month 8 year</code>’
</span></dt><dd><p>現在時刻から丁度103ヵ月123日10862秒後を表す。
</p></dd></dl></div><p>総体time値にたいして、Emacsは月を正確に30日、年を正確に365.25とみなす。
</p><p>有用なフォーマットのすべてが文字列という訳ではない。<em class="replaceable"><code>time</code></em>が数字(整数か浮動小数点数)なら、それは秒で数えた相対時刻を指定する。<code class="literal">encode-time</code>の結果は、<em class="replaceable"><code>time</code></em>にたいする絶対時刻の指定にも使用できる。
</p><p>ほとんどの場合、<span class="emphasis"><em>最初</em></span>に呼び出されている際は<em class="replaceable"><code>repeat</code></em>の効果はなく、<em class="replaceable"><code>time</code></em>単独で時刻を指定する。例外が1つあり<em class="replaceable"><code>time</code></em>が<code class="literal">t</code>なら、エポックから<em class="replaceable"><code>repeat</code></em>の倍数秒ごとに毎回そのタイマーが実行される。これは<code class="literal">display-time</code>のような関数にとって有用である。
</p><p>関数<code class="literal">run-at-time</code>は、スケジュール済みの将来の特定アクションを識別するtime値をリターンする。<code class="literal">cancel-timer</code>(以下参照)の呼び出しに、この値を使用できる。
</p></blockquote></div><p>タイマーのリピートは名目上<em class="replaceable"><code>repeat</code></em>秒ごとに毎回実行されますが、すべてのタイマー呼び出しは遅延する可能性があることを忘れないでください。1つの繰り返しの遅延が、次の繰り返しに影響を与えることはありません。たとえば3回分のスケジュール済みのタイマー繰り返しをカバーするほど計算等によりEmacsがbusyでも、それらは待機を開始して、連続してそのタイマー関数が3回呼び出されることになります(それらの間の別のタイマー呼び出しは想定していない)。最後の呼び出しから<em class="replaceable"><code>n</code></em>秒より短くならずにタイマーを再実行したい場合には、<em class="replaceable"><code>repeat</code></em>引数を使用しないでください。タイマー関数は、かわりにそのタイマーを明示的に再スケジュールするべきです。
</p><pre class="synopsis"><a id="idm85646544" class="indexterm"/><span class="category"><span class="bold"><strong>User Option</strong></span>:</span> <code class="varname">timer-max-repeats</code></pre><div class="blockquote"><blockquote class="blockquote"><p>この変数の値は、以前スケジュールされていた呼び出しが止むを得ずに遅延された際に、タイマー関数がリピートによりまとめて呼び出される最大の回数を指定する
</p></blockquote></div><pre class="synopsis"><a id="idm85639760" class="indexterm"/><span class="category"><span class="bold"><strong>Macro</strong></span>:</span> <code class="function">with-timeout</code> (<em class="replaceable"><code>seconds</code></em> <em class="replaceable"><code>timeout-forms</code></em><em class="replaceable"><code>…</code></em>) <em class="replaceable"><code>body</code></em><em class="replaceable"><code>…</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p><em class="replaceable"><code>body</code></em>を実行するが、<em class="replaceable"><code>seconds</code></em>秒後に実行を諦める。タイムアップ前に<em class="replaceable"><code>body</code></em>が終了したら、<code class="literal">with-timeout</code>は<em class="replaceable"><code>body</code></em>内の最後のフォームの値をリターンする。ただし、タイムアウトにより<em class="replaceable"><code>body</code></em>の実行が打ち切られた場合には、<code class="literal">with-timeout</code>は<em class="replaceable"><code>timeout-forms</code></em>をすべて実行して、それの最後のフォームの値をリターンする。
</p><p>このマクロは、<em class="replaceable"><code>seconds</code></em>秒後に実行するタイマーをセットすることにより機能する。その時刻前に<em class="replaceable"><code>body</code></em>が終了したらそのタイマーを削除し、タイマーが実際に実行されたら<em class="replaceable"><code>body</code></em>の実行を終了して、それから<em class="replaceable"><code>timeout-forms</code></em>を実行する。
</p><p>Lispプログラムでは、待機を行えるプリミティブをプログラムが呼び出している時のみタイマーを実行できるので、<em class="replaceable"><code>body</code></em>が計算途中の間は<code class="literal">with-timeout</code>は実行を停止できない
—
そのプログラムがこれらのプリミティブのいずれかを呼び出したときのみ停止できる。そのため、<em class="replaceable"><code>body</code></em>で長時間の計算を行う場合ではなく、入力を待機する場合だけ<code class="literal">with-timeout</code>を使用すること。
</p></blockquote></div><p>あまりに長時間応答を待機するのを避けるために、関数<code class="literal">y-or-n-p-with-timeout</code>はタイマーを使用するシンプルな方法を提供します。<a class="link" href="ch20s07.html" title="Yes-or-No Queries">Yes-or-No
Queries</a>を参照してください。
</p><pre class="synopsis"><a id="idm85626576" class="indexterm"/><span class="category"><span class="bold"><strong>Function</strong></span>:</span> <code class="function">cancel-timer</code> <em class="replaceable"><code>timer</code></em></pre><div class="blockquote"><blockquote class="blockquote"><p>これは<em class="replaceable"><code>timer</code></em>にたいして要求されたアクションをキャンセルする。ここで<em class="replaceable"><code>timer</code></em>はタイマーであること。これは通常は以前に<code class="literal">run-at-time</code>か<code class="literal">run-with-idle-timer</code>がリターンしたものである。この関数は、これらの関数の1つの呼び出しの効果をキャンセルする。指定した時刻が到来しても、特別ni何も起きないだろう。
</p></blockquote></div></div></body></html>