@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Buffers
@chapter Buffers
@cindex buffer

  @dfn{バッファー(buffer)}とは、編集されるテキストを含むLispオブジェクトのことです。バッファーは、visitされるファイルのコンテンツを保持するために使用されます。しかし、ファイルをvisitしないバッファーも存在するかもしれません。一度に複数のバッファーが存在するかもしれませんが、@dfn{カレントバッファー(current
buffer)}に指定できるのは、常に1つのバッファーだけです。ほとんどの編集コマンドは、カレントバッファーのコンテンツにたいして作用します。カレントバッファーを含むすべてのバッファーは、任意のウィンドウ内に表示されるときも、表示されない場合もあります。

@menu
* Buffer Basics::            バッファーとは?
* Current Buffer::           バッファーをカレントに指定することにより、プリミティブはバッファーのコンテンツにアクセスする。
* Buffer Names::             バッファー名にたいするアクセスと変更。
* Buffer File Name::         バッファーファイル名は、どのファイルをvisitしているかを示す。
* Buffer Modification::      保存が必要なら、バッファーは@dfn{変更されている(modified)}。
* Modification Time::        "Emacsの裏"でvisitされているファイルが変更されたかどうかを判断する。
* Read Only Buffers::        読み取り専用バッファーでのテキスト変更は許されない。
* Buffer List::              すべての既存バッファーを閲覧する方法。
* Creating Buffers::         バッファーを作成する関数。
* Killing Buffers::          明示的にkillされるまで、バッファーは存在する。
* Indirect Buffers::         インダイレクトバッファーは、他のバッファーとテキストを共有する。
* Swapping Text::            2つのバッファー間でのテキストの交換。
* Buffer Gap::               バッファー内のギャップ。
@end menu

@node Buffer Basics
@section Buffer Basics

@ifnottex
  @dfn{バッファー(buffer)}とは、編集されるテキストを含むLispオブジェクトのことです。バッファーは、visitされるファイルのコンテンツを保持するために使用されます。しかし、ファイルをvisitしないバッファーも存在します。一度に複数のバッファーが存在するかもしれませんが、@dfn{カレントバッファー(current
buffer)}に指定できるのは、常に1つのバッファーだけです。ほとんどの編集コマンドは、カレントバッファーのコンテンツにたいして作用します。カレントバッファーを含むすべてのバッファーは、任意のウィンドウ内に表示されるときも、表示されない場合もあります。
@end ifnottex

  Emacs編集におけるバッファーは、個別に名前をもち、編集可能なテキストを保持するオブジェクトです。Lispプログラムにたいして、バッファーはスペシャルデータ型として表されます。バッファーのコンテンツを、拡張可能な文字列と考えることができます。挿入と削除は、バッファー内の任意の箇所で発生し得ます。@ref{Text}を参照してください。

  Lispのバッファーオブジェクトは、多くの情報要素を含んでいます。これらの情報のいくつかは変数を通じてプログラマーが直接アクセスできるのにたいして、その他の情報は特殊な目的のための関数を通じてのみアクセスすることができます。たとえば、visitされているファイルの名前は変数を通じて直接アクセスできますが、ポイント値はプリミティブ関数からのみアクセスできます。

  直接アクセス可能な、バッファー固有の情報は、@dfn{バッファーローカル(buffer-local)}な変数バインディング内に格納されます。これは、特定のバッファー内だけで効力のある変数値のことです。この機能により、それぞれのバッファーは、特定の変数の値をオーバーライドすることができます。ほとんどのメジャーモードは、この方法で@code{fill-column}や@code{comment-column}のような変数をオーバーライドしています。バッファーローカルな変数、およびそれらに関連する関数についての詳細は、@ref{Buffer-Local
Variables}を参照してください。

  バッファーからファイルをvisitする関数および変数については、@ref{Visiting Files}、および@ref{Saving
Buffers}を参照してください。ウィンドウ内へのバッファー表示に関連する関数および変数については、@ref{Buffers and
Windows}を参照してください。

@defun bufferp object
この関数は、@var{object}がバッファーなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@node Current Buffer
@section The Current Buffer
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  一般的に、1つのEmacsセッション内には、多くのバッファーが存在します。常に、それらのうちの1つが@dfn{カレントバッファー(current
buffer)}に指定され、ます。カレントバッファーとは、ほとんどの編集が行われるバッファーのことです。テキストを調べたり変更するプリミティブのほとんどは、暗黙的にカレントバッファーにたいして処理を行います(@ref{Text}を参照)。

  通常は、選択されたウィンドウ内に表示されるバッファーがカレントバッファーですが、常にそうではありません。Lispプログラムは、バッファーのコンテンツを処理するために、スクリーン上に表示されているものを変更することなく、任意のバッファーを一時的にカレントに指定できます。カレントバッファーの指定にたいしてもっとも基本的な関数は、@code{set-buffer}です。

@defun current-buffer
この関数は、カレントバッファーをリターンする関数。

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
この関数は、@var{buffer-or-name}をカレントバッファーにする。@var{buffer-or-name}は既存のバッファー、または既存のバッファーの名前でなければならない。リターン値は、カレントになったバッファーである。

この関数は、そのバッファーをどのウィンドウにも表示しないので、必然的にユーザーはそのバッファーを見ることはできない。しかし、Lispプログラムはその後、そのバッファーにたいして処理を行うことになるだろう。
@end defun

  編集コマンドがエディターコマンドループにリターンする際、Emacsは選択されたウィンドウ内に表示されているバッファーにたいして、自動的に@code{set-buffer}を呼び出します。これは混乱を防ぐためで、これにより、Emacsがコマンドを読み取るときに、カーソルのあるバッファーが、コマンドを適用されるバッファーになるのが保証されます(@ref{Command
Loop}を参照)。したがって、異なるバッファーを指示して切り替える場合に、@code{set-buffer}を使用するべきではありません。これを行うためには、@ref{Switching
Buffers}で説明されているカを使用してください。

  Lisp関数を記述する際は、処理後にカレントバッファーをリストアするために、コマンドループのこの振る舞いに@emph{依存しないでください}。編集コマンドは、コマンドループだけではなく、他のプログラムからLisp関数としても呼び出されます。呼び出し側にとっては、そのサブルーチンがカレントだったバッファーを変更しないほうが便利です(もちろん、それがサブルーチンの目的でない場合ですが)。

  他のバッファーにたいして一時的に処理を行うには、@code{save-current-buffer}フォーム内に@code{set-buffer}を置きます。以下の例は、コマンド@code{append-to-buffer}の簡略版です:

@example
@group
(defun append-to-buffer (buffer start end)
  "リージョンのテキストをBUFFERに追加する"
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
ここでは、カレントバッファーを記録するためにローカル変数にバインドしてから、後で@code{save-current-buffer}がそれを再びカレントにするよう、取り計らっています。次に、@code{set-buffer}が指定されたバッファーをカレントにして、@code{insert-buffer-substring}が元のバッファーの文字列を、指定された(今はカレントの)バッファーにコピーします。

  かわりに、@code{with-current-buffer}マクロを使用することもできます:

@example
@group
(defun append-to-buffer (buffer start end)
  "BUFFERにリージョンのテキストを追加する"
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  どちらの場合でも、追加されるバッファーが偶然他のウィンドウに表示されていた場合には、次回の再表示でそのテキストがどのように変更されたか表示されるでしょう。どのウィンドウにも表示されていない場合には、スクリーン上で即座に変更を目にすることはありません。コマンドはバッファーを一時的にカレントにしますが、そのことがバッファーの表示を誘因する訳ではありません。

  バッファーローカルバインディングをもつ変数にたいして、(@code{let}や関数引数などで)ローカルバインディングを作成する場合は、そのローカルバインディングのスコープの最初と最後で、同じバッファーがカレントとなることを確認してください。そうしないと、あるバッファーではバインドして、他のバッファーではバインドされないことになるかもしれません!

  @code{set-buffer}の使用において、カレントバッファーが戻ることに依存しないでください。なぜなら、間違ったバッファーがカレントのときにquitが発生した場合、その処理は行われないでしょう。たとえば上記の例に倣うと、以下は間違ったやり方です:

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
例で示したように@code{save-current-buffer}、または@code{with-current-buffer}を使用すれば、quitや@code{throw}を、通常の評価と同様に処理できます。

@defspec save-current-buffer body@dots{}
スペシャルフォーム@code{save-current-buffer}は、カレントバッファーの識別を保存して、@var{body}フォームを評価し、最後にそのバッファーをカレントにリストアする。リターン値は、@var{body}内の最後のフォームの値である。@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal
Exits}を参照)。

カレントとして使用されていたバッファーが、@code{save-current-buffer}によるexit時にkillされていた場合は、それが再びカレントとなることは当然ない。かわりに、exit直前にカレントバッファーが何であれ、それがカレントになる。
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
@code{with-current-buffer}マクロは、カレントバッファーの識別を保存して、@var{buffer-or-name}をカレントにし、@var{body}フォームを評価して、最後にカレントバッファーをリストアする。@var{buffer-or-name}には既存のバッファー、または既存のバッファー名を指定しなければならない。

リターン値は、@var{body}内の最後のフォームの値である。@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal
Exits}を参照)。
@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
@code{with-temp-buffer}マクロは、一時的なバッファーをカレントバッファーとして、@var{body}フォームを評価する。これはカレントバッファーの識別を保存して、一時的なバッファーを作成、それをカレントとして、@var{body}フォームを評価し、一時バッファーをkillする間に、以前のカレントバッファーをリストアする。
デフォルトでは、このマクロにより作成されたバッファー内のアンドゥ情報(@ref{Undo}を参照)は記録されない(が、必要なら@var{body}でそれを有効にできる)。

リターン値は、@var{body}内の最後のフォームの値である。最後のフォームとして@code{(buffer-string)}を使用することにより、一時バッファーのコンテンツをリターンできる。

@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal Exits}を参照)。

@ref{Definition of with-temp-file,, Writing to
Files}の@code{with-temp-file}も参照されたい。
@end defmac

@node Buffer Names
@section Buffer Names
@cindex buffer names

  それぞれのバッファーは、文字列で表される一意な名前をもちます。バッファーにたいして機能する関数の多くは、引数としてバッファーとバッファー名の両方を受け入れます。@var{buffer-or-name}という名前の引数がこのタイプで、それが文字列でもバッファーでもない場合は、エラーがシグナルされます。@var{buffer}という名前の引数は、名前ではなく実際のバッファーオブジェクトでなければなりません。

@cindex hidden buffers
@cindex buffers without undo information
  短命でユーザーが関心をもたないようなバッファーは名前がスペースで始まり、それらについては@code{list-buffers}および@code{buffer-menu}コマンドは無視します(が、ファイルをvisitしているようなバッファーは@strong{無視されない})。スペースで始まる名前は、初期状態ではアンドゥ情報の記録も無効になっています。@ref{Undo}を参照してください。

@defun buffer-name &optional buffer
この関数は、@var{buffer}の名前を文字列としてリターンする。@var{buffer}のデフォルトは、カレントバッファーである。

@code{buffer-name}が@code{nil}をリターンした場合、それは@var{buffer}がkillされていることを意味する。@ref{Killing
Buffers}を参照のこと。

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
この関数は、カレントバッファーを@var{newname}にリネームする。@var{newname}が文字列でない場合は、エラーをシグナルする。

@c Emacs 19 feature
@var{newname}がすでに使用済みの場合、@code{rename-buffer}は通常はエラーをシグナルする。しかし、@var{unique}が非@code{nil}の場合は、未使用の名前となるように@var{newname}を変更する。interactiveに呼び出した場合は、プレフィックス数引数により@var{unique}に非@code{nil}を指定できる(この方法により、コマンド@code{rename-uniquely}は実装される)。

この関数は、実際にバッファーに与えられた名前をリターンする。
@end deffn

@defun get-buffer buffer-or-name
この関数は、@var{buffer-or-name}で指定されたバッファーをリターンする。@var{buffer-or-name}が文字列で、かつそのような名前のバッファーが存在しない場合、値は@code{nil}になる。@var{buffer-or-name}がバッファーの場合は、与えられたバッファーをリターンする。これは有用とは言い難く、引数は通常は名前である。たとえば:

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

@ref{Creating Buffers}の関数@code{get-buffer-create}も参照のこと。
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
この関数は、新たなバッファーにたいして一意となるような名前をリターンする ---
が、バッファーは作成しない。この名前は@var{starting-name}で始まり、内部が数字であるような@samp{<@dots{}>}を追加することにより、すべてのバッファーでカレントで使用されていない名前を生成する。この数字は2で始まり、既存バッファーの名前でない名前になる数字まで増加される。

オプション引数@var{ignore}が非@code{nil}の場合、それは潜在的にバッファー名であるような文字列であること。これは、たとえそれが(通常は拒絶されるであろう)既存バッファーの名前であっても、試みられた場合は、潜在的に受容可能なバッファーとして考慮することを意味する。つまり@samp{foo}、@samp{foo<2>}、@samp{foo<3>}、@samp{foo<4>}という名前のバッファーが存在する場合、

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

@ref{Creating Buffers}の関連する関数@code{generate-new-buffer}も参照のこと。
@end defun

@node Buffer File Name
@section Buffer File Name
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  @dfn{バッファーファイル名(buffer file
name)}とは、そのバッファーにvisitされているファイルの名前です。バッファーがファイルをvisiblyしていなければ、バッファーファイル名は@code{nil}です。大抵、バッファー名はバッファーファイル名の非ディレクトリーパートと同じですが、バッファーファイル名とバッファー名は別物であり、個別にセットすることができます。@ref{Visiting
Files}を参照してください。

@defun buffer-file-name &optional buffer
この関数は、@var{buffer}がvisitしているファイルの、絶対ファイル名をリターンする。@var{buffer}がファイルをvisitしていない場合、@code{buffer-file-name}は@code{nil}をリターンする。@var{buffer}が与えられない場合のデフォルトは、カレントバッファーになる。

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
このバッファーローカル変数は、カレントバッファーにvisitされているファイルの名前、ファイルをvisitしていなければ@code{nil}が含まれる。これは永続的なローカル変数であり、@code{kill-all-local-variables}の影響を受けない。

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

他のさまざまな事項を変更せずに、この変数を変更するのは危険である。通常は、@code{set-visited-file-name}を使用するほうがよい(以下参照)。バッファー名の変更などのような、そこで行われることのいくつかは、絶対必要という訳ではないが、その他の事項はEmacsが混乱するのを防ぐために必要不可欠である。
@end defvar

@defvar buffer-file-truename
このバッファーローカル変数は、カレントバッファーにvisitされているファイルの省略された形式の実名(truename)、ファイルをvisitしていない場合は@code{nil}を保持する。これは永続的にローカルであり、@code{kill-all-local-variables}の影響を受けない。@xref{Truenames}、および@ref{abbreviate-file-name}を参照のこと。
@end defvar

@defvar buffer-file-number
このバッファーローカル変数は、カレントバッファーにvisitされているファイルのファイル番号(file number)とデバイス番号(device
number)、ファイルをvisitしていない場合は@code{nil}を保持する。これは永続的にローカルであり、@code{kill-all-local-variables}の影響を受けない。

値は通常、@code{(@var{filenum}
@var{devnum})}のような形式のリストである。この番号ペアーは、システム上でアクセス可能なすべてのファイルの中から、ファイルを一意に識別する。より詳細な情報は、@ref{File
Attributes}の@code{file-attributes}を参照のこと。

@code{buffer-file-name}がシンボリックリンク名の場合は、どちらの番号も再帰的なターゲットを参照する。
@end defvar

@defun get-file-buffer filename
この関数は、ファイル@var{filename}をvisitしているバッファーをリターンする。そのようなバッファーが存在しない場合は、@code{nil}をリターンする。引数@var{filename}は文字列でなければならず、展開(@ref{File
Name
Expansion}を参照)された後、killされていないすべてのバッファーがvisitしているファイル名と比較される。バッファーの@code{buffer-file-name}は、@var{filename}の展開形と正確にマッチしなければならないことに注意。この関数は、同じファイルにたいする他の名前は、認識しないだろう。

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

特殊な状況下では、複数のバッファーが同じファイル名をvisitすることがあり得る。そのような場合、この関数はバッファーリスト内の最初に該当するバッファーをリターンする。
@end defun

@defun find-buffer-visiting filename &optional predicate
これは@code{get-file-buffer}と似ているが、そのファイルを@emph{違う名前}でvisitしているかもしれないすべてのバッファーをリターンする。つまり、バッファーの@code{buffer-file-name}は@var{filename}の展開形式と正確にマッチする必要はなく、同じファイルを参照することだけが要求される。@var{predicate}が非@code{nil}の場合、それは@var{filename}をvisitしているバッファーを1つの引数とする関数であること。そのバッファーにたいして、@var{predicate}が非@code{nil}をリターンした場合のみ、適切なリターン値と判断される。リターンすべき適切なバッファーが見つからない場合、@code{find-buffer-visiting}は@code{nil}をリターンする。
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
@var{filename}が非空文字列の場合、この関数はカレントバッファーにvisitされているファイルの名前を、@var{filename}に変更する(バッファーがファイルをvisitしていない場合は、visitするファイルとして@var{filename}を与える)。そのバッファーにたいする@emph{次回}の保存では、新たに指定されたファイルに保存されるだろう。

このコマンドは、たとえそのバッファーのコンテンツがその前にvisitされていたファイルとマッチしていても、(Emacsが関知するかぎり)@var{filename}のコンテンツとはマッチしないので、バッファーが変更されている(modified)とマークする。これは、その名前がすでに使用されていなければ、新たなファイル名に対応してバッファーをリネームする。

@var{filename}が@code{nil}、または空文字列の場合、それは``visitされているファイルがない''ことを意味する。この場合、@code{set-visited-file-name}はバッファーの変更フラグを変更することなく、そのバッファーがファイルをvisitしていないとマークする。

この関数は@var{filename}をvisitしているバッファーがすでに存在する場合は、通常はユーザーに確認を求める。しかし、@var{no-query}が非@code{nil}の場合は、この質問を行わない。@var{filename}をvisitしているバッファーがすでに存在し、かつユーザーが承認、または@var{no-query}が非@code{nil}の場合、この関数は中に数字が入った@samp{<@dots{}>}を@var{filename}に追加して、新たなバッファーの名前を一意にする。

@var{along-with-file}が非@code{nil}の場合、それは前にvisitされていたファイルが@var{filename}にリネームされたと想定することを意味する。この場合、コマンドはバッファーの修正フラグを変更せず、そのバッファーの記録されている最終ファイル変更時刻を@code{visited-file-modtime}が報告する時刻(@ref{Modification
Time}を参照)で変更もしない。@var{along-with-file}が@code{nil}の場合、この関数は@code{visited-file-modtime}が0をリターンした後に、記録済みの最終ファイル変更時刻をクリアーする。

関数@code{set-visited-file-name}がinteractiveに呼び出されたときは、ミニバッファー内で@var{filename}の入力を求める。
@end deffn

@defvar list-buffers-directory
このバッファーローカル変数は、visitしているファイル名をもたないバッファーにたいして、バッファーリスト中のvisitしているファイル名を表示する場所に表示する文字列を指定する。Diredバッファーは、この変数を使用する。
@end defvar

@node Buffer Modification
@section Buffer Modification
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacsは、各バッファーにたいして、バッファーのテキストを変更したかどうかを記録するために、@dfn{変更フラグ(modified
flag)}と呼ばれるフラグを管理しています。このフラグは、バッファーのコンテンツを変更すると常に@code{t}にセットされ、バッファーを保存したとき@code{nil}にクリアーされます。したがって、このフラグは保存されていない変更があるかどうかを表します。フラグの値は通常、モードライン内(@ref{Mode
Line Variables}を参照)に表示され、保存(@ref{Saving
Buffers}を参照)と自動保存(@ref{Auto-Saving}を参照)を制御します。

  いくつかのLispプログラムは、このフラグを明示的にセットします。たとえば、関数@code{set-visited-file-name}は、このフラグを@code{t}にセットします。なぜなら、たとえその前にvisitしていたファイルが変更されていなくても、テキストは新たにvisitされたファイルとマッチしないからです。

  バッファーのコンテンツを変更する関数については、@ref{Text}で説明されています。

@defun buffer-modified-p &optional buffer
この関数は、バッファー@var{buffer}が最後にファイルから読み込まれた、あるいは保存されてから変更されていれば@code{t}、それ以外では@code{nil}をリターンする。@var{buffer}が与えられない場合は、カレントバッファーがテストされる。
@end defun

@defun set-buffer-modified-p flag
この関数は、@var{flag}が非@code{nil}ならカレントバッファーを変更済みとしてマークし、@code{nil}なら未変更としてマークする。

この関数を呼び出すことによる別の効果は、それがカレントバッファーのモードラインの無条件な再表示を引き起こすことである。実際のところ、関数@code{force-mode-line-update}は、以下を行うことにより機能する:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
@code{set-buffer-modified-p}と同様だが、モードラインにたいする強制的な再表示を行わない。
@end defun

@deffn Command not-modified &optional arg
このコマンドは、カレントバッファーが変更されておらず、保存する必要がないとマークする。@var{arg}が非@code{nil}の場合、これは変更されているとマークするので、次回の適切なタイミングでバッファーは保存されるだろう。interactiveに呼び出された場合、@var{arg}はプレフィックス引数である。

この関数は、エコーエリア内にメッセージをプリントするので、プログラム内で使用してはならない。かわりに、@code{set-buffer-modified-p}(上記)を使用すること。
@end deffn

@defun buffer-modified-tick &optional buffer
この関数は、@var{buffer}の変更カウント(modification-count)をリターンする。これは、バッファーが変更されるたびに増加されるカウンターである。@var{buffer}が@code{nil}(または省略)の場合は、カレントバッファーが使用される。このカウンターは、時折0にクリアーされ得る。
@end defun

@defun buffer-chars-modified-tick &optional buffer
この関数は、@var{buffer}の文字変更に関わる変更カウントをリターンする。テキストプロパティを変更しても、このカウンターは変化しない。しかし、そのバッファーにテキストが挿入、または削除されるたびに、このカウンターは@code{buffer-modified-tick}によりリターンされるであろう値にリセットされる。@code{buffer-chars-modified-tick}を2回呼び出してリターンされる値を比較することにより、その呼び出しの間にバッファー内で文字変更があったかどうかを知ることができる。@var{buffer}が@code{nil}(または省略)の場合は、カレントバッファーが使用される。
@end defun

@node Modification Time
@section Buffer Modification Time
@cindex comparing file modification time
@cindex modification time of buffer

  あるファイルをvisitして、そのバッファー内で変更を行って、その一方ではディスク上でファイル自身が変更されたとします。この時点でバッファーを保存すると、ファイル内の変更は上書きされるでしょう。これが正に望んでいる動作のときもありますが、通常は有用な情報が失われてしまいます。したがって、Emacsはファイルを保存する前に、以下で説明する関数を使用して、ファイルの変更時刻をチェックします(ファイルの変更時刻を調べる方法は、@ref{File
Attributes}を参照)。

@defun verify-visited-file-modtime &optional buffer
この関数は、@var{buffer}(デフォルトはカレントバッファー)にvisitされているファイルにたいして記録されている変更時刻と、オペレーティングシステムにより記録された実際の変更時刻を比較する。これら2つの時刻は、Emacsがそのファイルをvisit、もしくは保存して以降、他のプロセスにより書き込みがされていなければ、等しくなるはずである。

この関数は、実際の最終変更時刻と、Emacsが記録した変更時刻が同じなら@code{t}、それ以外は@code{nil}をリターンする。そのバッファーが記録済みの最終変更時刻をもたない、すなわち@code{visited-file-modtime}が0をリターンするような場合も、@code{t}をリターンする。

これは、たとえ@code{visited-file-modtime}が非0の値をリターンしたとしても、ファイルをvisitしていないバッファーにたいしては、常に@code{t}をリターンする。たとえば、diredバッファーにたいして、この関数は常に@code{t}をリターンする。また、存在せず、
以前に存在したこともなかったファイルをvisitするバッファーにたいして@code{t}をリターンするが、visitしているファイルが削除されたバッファーにたいしては@code{nil}をリターンする。
@end defun

@defun clear-visited-file-modtime
この関数は、カレントバッファーによりvisitされているファイルの最終変更時刻の記録をクリアーする。結果として、このバッファーにを次回の保存では、ファイルの変更時刻の食い違いは報告されなくなる。

この関数は@code{set-visited-file-name}、および変更済みファイルの上書きを防ぐための通常テストを行わない例外的な箇所で呼び出される。
@end defun

@defun visited-file-modtime
この関数は、カレントバッファーの記録された最終ファイル変更時刻を、@code{(@var{high} @var{low} @var{microsec}
@var{picosec})}のような形式のリストでリターンする(これは、@code{file-attributes}が時刻値をリターンするために使用するフォーマットと同じである。@ref{File
Attributes}を参照されたい)。

バッファーが最終変更時刻の記録をもたない場合、この関数は0をリターンする。これが発生するのは、たとえばバッファーがファイルをvisitしていなかったり、@code{clear-visited-file-modtime}で最終変更時刻が明示的にクリアーされた場合である。しかし@code{visited-file-modtime}は、いくつかの非ファイルバッファーにたいするリストをリターンすることに注意。たとえば、ディレクトリーをリストするDiredバッファーでは、Diredが記録するそのディレクトリーの最終変更時刻がリターンされる。

バッファーがファイルをvisitしていない場合、この関数は-1をリターンする。
@end defun

@defun set-visited-file-modtime &optional time
この関数は、バッファーがvisitしているファイルの最終変更時刻の記録を、@var{time}が非@code{nil}、それ以外はvisitしているファイルの最終変更時刻により更新する。

@var{time}が@code{nil}や0でない場合、それは@code{current-time}で使用される形式@code{(@var{high}
@var{low} @var{microsec} @var{picosec})}というフォーマットであること(@ref{Time of
Day}を参照)。

この関数は、バッファーが通常のようにファイルから読み取られたものでない場合や、ファイル自身が害のない既知の理由により変更されている場合に有用である。
@end defun

@defun ask-user-about-supersession-threat filename
これは、visitしているファイル@var{filename}がバッファーのテキストより新しいときにバッファーの変更を試みた後、ユーザーに処理方法を尋ねるために使用する関数である。Emacsはディスク上のファイルの変更時刻が、バッファーを最後に保存した時刻より新しいかどうかで、これを検知する。これはおそらく、他のプログラムがそのファイルを変更したことを意味する。

@kindex file-supersession
この関数が正常にリターンするかどうかは、ユーザーの答えに依存する。関数はバッファーの変更が処理された場合は正常にリターンし、バッファーの変更が許可されなかった場合は、データ@code{(@var{filename})}とともにエラー@code{file-supersession}をシグナルする。

この関数は、適切なタイミングでEmacsにより自動的に呼び出される。これは、再定義することによりEmacsをカスタマイズ可能にするために存在する。標準的な定義は、ファイル@file{userlock.el}を参照されたい。

@ref{File Locks}のファイルロックのメカニズムも参照のこと。
@end defun

@node Read Only Buffers
@section Read-Only Buffers
@cindex read-only buffer
@cindex buffer, read-only

  あるバッファーが@dfn{読み取り専用(read-only)}の場合は、たとえスクロールやナローイングによってファイルのコンテンツのビューを変更しても、そのコンテンツを変更することはできません。

  読み取り専用バッファーは、2つのタイプの状況において使用されます:

@itemize @bullet
@item
書き込み保護されたファイルをvisitするバッファーは、通常は読み取り専用になる。

ここでの目的は、ユーザーにたいしてそのファイルへの保存を意図したバッファーの編集が無益、または望ましくないかもしれないことを伝えることである。それにも関わらずバッファーのテキストの変更を望むユーザーは、@kbd{C-x
C-q}で読み取り専用フラグをクリアーした後、これを行うことができる。

@item
DiredやRmailのようなモードは、通常の編集コマンドによるコンテンツの変更がおそらく間違いであるようなときに、バッファーを読み取り専用にする。

このようなモードのスペシャルコマンドは、@code{buffer-read-only}を(@code{let}により)@code{nil}にバインドしたり、テキストを変更する箇所では@code{inhibit-read-only}を@code{t}にバインドする。
@end itemize

@defvar buffer-read-only
このバッファーローカル変数は、そのバッファーが読み取り専用かどうかを指定する。この変数が非@code{nil}なら、そのバッファーは読み取り専用である。
@end defvar

@defvar inhibit-read-only
この変数が非@code{nil}の場合、読み取り専用バッファー、およびその実際の値に依存して、一部もしくはすべての読み取り専用文字が変更されている。バッファー内の読み取り専用文字とは、テキストプロパティ@code{read-only}が非@code{nil}の文字である。テキストプロパティについての詳細は、@ref{Special
Properties}を参照のこと。

@code{inhibit-read-only}が@code{t}の場合、すべての@code{read-only}文字プロパティは効果がなくなる。@code{inhibit-read-only}がリストの場合、@code{read-only}文字プロパティがリストのメンバーなら効果がなくなる(比較は@code{eq}で行われる)。
@end defvar

@deffn Command read-only-mode &optional arg
これは、バッファーローカルなマイナーモードである、Read
Onlyモードにたいするモードコマンドである。このモードが有効なときは、そのバッファーの@code{buffer-read-only}は非@code{nil}である。無効なときは、そのバッファーの@code{buffer-read-only}は@code{nil}である。呼び出す際の慣習は、他のマイナーモードコマンドの慣習と同じである(@ref{Minor
Mode Conventions}を参照)。

このマイナーモードは他のマイナーモードとは異なり、主に@code{buffer-read-only}にたいするラッパーの役目を果たし、別個に@code{read-only-mode}変数は存在しない。Read
Onlyモードが無効なときでも、@code{read-only}テキストプロパティが非@code{nil}の文字は読み取り専用のままである。一時的にすべての読み取り専用ステータスを無視するには、上述の@code{inhibit-read-only}をバインドすること。

Read
Onlyモードを有効にする際、このモードコマンドはオプション@code{view-read-only}が非@code{nil}なら、Viewモードも有効にする。@ref{Misc
Buffer,,Miscellaneous Buffer Operations, emacs, The GNU Emacs
Manual}を参照のこと。Read Onlyモードを無効にする際に、もしもViewモードが有効なら、Viewモードも無効にする。
@end deffn

@defun barf-if-buffer-read-only
この関数は、カレントバッファーが読み取り専用の場合は、@code{buffer-read-only}エラーをシグナルする。カレントバッファーが読み取り専用の場合にエラーをシグナルする他の方法については、@ref{Using
Interactive}を参照のこと。
@end defun

@node Buffer List
@section The Buffer List
@cindex buffer list
@cindex listing all buffers

  @dfn{バッファーリスト(buffer
list)}とは、すべての生きた(killされていない)バッファーのリストです。このリスト内のバッファーの順序は主に、それぞれのバッファーがウィンドウに表示されたのがどれほど最近なのかにもとづきます。いくつかの関数、特に@code{other-buffer}はこの順序を使用します。ユーザーに表示されるバッファーリストも、この順序にしたがいます。

  バッファーを作成すると、それはバッファーリストの最後に追加され
バッファーをkillすることにより、そのリストから削除されます。ウィンドウに表示するためにバッファーが選択されたとき(@ref{Switching
Buffers}を参照)、あるいはバッファーを表示するウィンドウが選択されたとき(@ref{Selecting
Windows}を参照)、そのバッファーは常にこのリストの先頭に移動します。バッファーがバリー(以下の@code{bury-buffer}を参照)されたときは、このリストの最後に移動します。バッファーリストを直接操作するために利用できる、Lispプログラマー向けの関数は存在しません。

  説明した基本バッファーリスト(fundamental buffer
list)に加えて、Emacsはそれぞれのフレームにたいしてローカルバッファーリスト(local buffer
list)を保守します。ローカルバッファーリストでは、そのフレーム内で表示されていた(または選択されたウィンドウの)バッファーが先頭になります(この順序は、そのフレームのフレームパラメーター@code{buffer-list}に記録される。@ref{Buffer
Parameters}を参照されたい)。そのフレームでは表示されていないフレームは後になるよう、並び順は基本バッファーリストに準じます。

@defun buffer-list &optional frame
この関数は、すべてのバッファーを含むバッファーリストをリターンする(名前がスペースで始まるバッファーも含む)。リストの要素はバッファーの名前ではなく、実際のバッファーである。

@var{frame}がフレームの場合は、@var{frame}のローカルバッファーリストをリターンする。@var{frame}が@code{nil}、または省略された場合は、基本バッファーリストが使用される。その場合、そのバッファーを表示するフレームがどれかとは無関係に、もっとも最近に表示、または選択されたバッファーの順になる。

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{ミニバッファーの名前が}
;;   @r{スペースで始まることに注意!}
(mapcar (function buffer-name) (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  @code{buffer-list}からリターンされるリストは、それ専用に構築されたリストであり、Emacsの内部的なデータ構造ではないし、それを変更してもバッファーの並び順に影響はありません。基本バッファーリスト内のバッファーの並び順を変更したい場合に簡単なのは、以下の方法です:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  この方法により、バッファーを失ったり、有効な生きたバッファー以外の何かを追加する危険を犯さずに、リストに任意の並び順を指定できます。

  特定のフレームのバッファーリストの並び順や値を変更するには、@code{modify-frame-parameters}でそのフレームの@code{buffer-list}パラメーターをセットしてください(@ref{Parameter
Access}を参照)。

@defun other-buffer &optional buffer visible-ok frame
この関数は、バッファーリスト中で@var{buffer}以外の最初のバッファーをリターンする。これは通常選択されたウィンドウ(フレーム@var{frame}、または選択されたフレーム。@ref{Input
Focus}を参照)に、もっとも最近表示された、@var{buffer}以外のバッファーである。名前がスペースで始まるバッファーは、考慮されない。

@var{buffer}が与えられない(または生きたバッファーでない)場合、@code{other-buffer}は選択されたフレームのローカルバッファーリスト内の、最初のバッファーをリターンする(@var{frame}が非@code{nil}の場合は、@var{frame}のローカルバッファーリスト内の最初のバッファーをリターンする)。

@var{frame}が非@code{nil}の@code{buffer-predicate}パラメーターをもつ場合は、どのバッファーを考慮すべきかを決定するために、@code{other-buffer}はその述語を使用する。これはそれぞれのバッファーごとにその述語を一度呼び出して、値が@code{nil}ならそのバッファーは無視される。@ref{Buffer
Parameters}を参照のこと。

@c Emacs 19 feature
@var{visible-ok}が@code{nil}ならば、@code{other-buffer}はやむを得ない場合を除き、任意の可視のフレーム上のウィンドウ内で可視のバッファーをリターンすることを避ける。@var{visible-ok}が非@code{nil}の場合は、バッファーがどこかで表示されているかどうかは問題にしない。

適切なバッファーが存在しない場合は、バッファー@file{*scratch*}を(必要なら作成して)リターンする。
@end defun

@defun last-buffer &optional buffer visible-ok frame
この関数は、@var{frame}のバッファーリスト内から、@var{buffer}以外の最後のバッファーをリターンする。@var{frame}が省略、または@code{nil}の場合は、選択されたフレームのバッファーリストを使用する。

引数@var{visible-ok}は、上述した@code{other-buffer}と同様に扱われる。適切なバッファーを見つけられない場合は、バッファー@file{*scratch*}がリターンされる。
@end defun

@deffn Command bury-buffer &optional buffer-or-name
このコマンドは、バッファーリスト内の他のバッファーの並び順を変更することなく、@var{buffer-or-name}をバッファーリストの最後に置く。つまり、このバッファーは@code{other-buffer}がリターンする候補で、もっとも期待度が低くなる。引数はバッファー自身か、バッファーの名前を指定できる。

この関数は、基本バッファーリストと同様に、それぞれのフレームの@code{buffer-list}パラメーターを操作する。したがってバリー(bury:
埋める、隠す)したバッファーは、@code{(buffer-list
@var{frame})}および@code{(buffer-list)}の値の最後に置かれるだろう。さらに、そのバッファーが選択されたウィンドウに表示されていれば、そのウィンドウのバッファーリストの最後にバッファーを置くことも行う(@ref{Window
History}を参照)。

@var{buffer-or-name}が@code{nil}、または省略された場合は、カレントバッファーをバリーすることを意味する。加えて、カレントバッファーが選択されたウィンドウに表示されている場合は、そのウィンドウを削除するか、他のバッファーを表示する。より正確には、選択されたウィンドウが専用(dedicated)のウィンドウ(@pxref{Dedicated
Windows})であり、かつそのフレーム上に他のウィンドウが存在する場合、専用ウィンドウは削除される。それがフレーム上で唯一のウィンドウであり、かつそのフレームが端末上で唯一のフレームでない場合、そのフレームは@code{frame-auto-hide-function}で指定される関数を呼び出すことにより、``開放''される(@ref{Quitting
Windows}を参照)。それ以外の場合は、他のバッファーをそのウィンドウ内に表示するために、@code{switch-to-prev-buffer}を呼び出す(@ref{Window
History}を参照)。@var{buffer-or-name}が他のウィンドウで表示されていた場合は、そのまま表示され続ける。

あるバッファーにたいして、それを表示するすべてのウィンドウでバッファーを置き換えるには、@code{replace-buffer-in-windows}を使用する。@ref{Buffers
and Windows}を参照のこと。
@end deffn

@deffn Command unbury-buffer
このコマンドは、選択されたフレームのローカルバッファーリストの最後のバッファーに切り替える。より正確には、選択されたウィンドウ内で、@code{last-buffer}(上記参照)がリターンするバッファーを表示するために、関数@code{switch-to-buffer}を呼び出す(@ref{Switching
Buffers}を参照)。
@end deffn

@defvar buffer-list-update-hook
これは、バッファーリストが変更されたときは、常に実行されるノーマルフックである。(暗黙的に)このフックを実行する関数は@code{get-buffer-create}(@ref{Creating
Buffers}を参照)、@code{rename-buffer}(@ref{Buffer
Names}を参照)、@code{kill-buffer}(@ref{Killing
Buffers}を参照)、@code{bury-buffer}(上記参照)、@code{select-window}(@ref{Selecting
Windows}を参照)である。
@end defvar

@node Creating Buffers
@section Creating Buffers
@cindex creating buffers
@cindex buffers, creating

  このセクションでは、バッファーを作成する2つのプリミティブについて説明します。@code{get-buffer-create}は、指定された名前の既存バッファーが見つからない場合は作成します。@code{generate-new-buffer}は、常に新たにバッファーを作成して、それに一意な名前を与えます。

  バッファーを作成するために使用できる他の関数には、@code{with-output-to-temp-buffer}(@ref{Temporary
Displays}を参照)、および@code{create-file-buffer}(@ref{Visiting
Files}を参照)が含まれます。サブプロセスの開始によっても、バッファーを作成することができます(@ref{Processes}を参照)。

@defun get-buffer-create buffer-or-name
この関数は、@var{buffer-or-name}という名前のバッファーをリターンする。リターンされたバッファーはカレントにならない ---
この関数はカレントがどのバッファーであるかを変更しない。

@var{buffer-or-name}は文字列、または既存バッファーのいずれかでなければならない。これが文字列で、かつ既存の生きたバッファーの名前の場合、@code{get-buffer-create}はそのバッファーをリターンする。そのようなバッファーが存在しなければ、新たにバッファーを作成する。@var{buffer-or-name}が文字列ではなくバッファーの場合、たとえそのバッファーが生きていなくても、与えられたバッファーをリターンする。

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

新たに作成されたバッファーにたいするメジャーモードは、Fundamentalモードにセットされる(変数@code{major-mode}のデフォルト値は、より高いレベルで処理される。@ref{Auto
Major
Mode}を参照されたい)。名前がスペースで始まる場合、そのバッファーのアンドゥ情報の記録は、初期状態では無効である(@ref{Undo}を参照)。
@end defun

@defun generate-new-buffer name
この関数は、新たに空のバッファーを作成してリターンするが、それをカレントにはしない。バッファーの名前は、関数@code{generate-new-buffer-name}に@var{name}を渡すことにより生成される(@ref{Buffer
Names}を参照)。つまり、@var{name}という名前のバッファーが存在しなければ、それが新たなバッファーの名前になり、その名前が使用されていた場合は、@samp{<@var{n}>}という形式のサフィックスが@var{name}に追加される。ここで@var{n}は整数である。

@var{name}が文字列でない場合は、エラーがシグナルされる。

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

新たなバッファーにたいするメジャーモードは、Fundamentalモードにセットされる。変数@code{major-mode}のデフォルト値は、より高いレベルで処理される。@ref{Auto
Major Mode}を参照のこと。
@end defun

@node Killing Buffers
@section Killing Buffers
@cindex killing buffers
@cindex buffers, killing

  @dfn{Killing a buffer} makes its name unknown to Emacs and makes the memory
space it occupied available for other use.

  The buffer object for the buffer that has been killed remains in existence
as long as anything refers to it, but it is specially marked so that you
cannot make it current or display it.  Killed buffers retain their identity,
however; if you kill two distinct buffers, they remain distinct according to
@code{eq} although both are dead.

  If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can change the current buffer.  Therefore, when you
kill a buffer, you should also take the precautions associated with changing
the current buffer (unless you happen to know that the buffer being killed
isn't current).  @xref{Current Buffer}.

  If you kill a buffer that is the base buffer of one or more indirect
@iftex
buffers,
@end iftex
@ifnottex
buffers (@pxref{Indirect Buffers}),
@end ifnottex
the indirect buffers are automatically killed as well.

@cindex live buffer
  The @code{buffer-name} of a buffer is @code{nil} if, and only if, the buffer
is killed.  A buffer that has not been killed is called a @dfn{live}
buffer.  To test whether a buffer is live or killed, use the function
@code{buffer-live-p} (see below).

@deffn Command kill-buffer &optional buffer-or-name
This function kills the buffer @var{buffer-or-name}, freeing all its memory
for other uses or to be returned to the operating system.  If
@var{buffer-or-name} is @code{nil} or omitted, it kills the current buffer.

Any processes that have this buffer as the @code{process-buffer} are sent
the @code{SIGHUP} (``hangup'') signal, which normally causes them to
terminate.  @xref{Signals to Processes}.

If the buffer is visiting a file and contains unsaved changes,
@code{kill-buffer} asks the user to confirm before the buffer is killed.  It
does this even if not called interactively.  To prevent the request for
confirmation, clear the modified flag before calling @code{kill-buffer}.
@xref{Buffer Modification}.

This function calls @code{replace-buffer-in-windows} for cleaning up all
windows currently displaying the buffer to be killed.

Killing a buffer that is already dead has no effect.

This function returns @code{t} if it actually killed the buffer.  It returns
@code{nil} if the user refuses to confirm or if @var{buffer-or-name} was
already dead.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
Before confirming unsaved changes, @code{kill-buffer} calls the functions in
the list @code{kill-buffer-query-functions}, in order of appearance, with no
arguments.  The buffer being killed is the current buffer when they are
called.  The idea of this feature is that these functions will ask for
confirmation from the user.  If any of them returns @code{nil},
@code{kill-buffer} spares the buffer's life.
@end defvar

@defvar kill-buffer-hook
This is a normal hook run by @code{kill-buffer} after asking all the
questions it is going to ask, just before actually killing the buffer.  The
buffer to be killed is current when the hook functions run.  @xref{Hooks}.
This variable is a permanent local, so its local binding is not cleared by
changing major modes.
@end defvar

@defopt buffer-offer-save
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} (if the second
optional argument to that function is @code{t}) to offer to save that
buffer, just as they offer to save file-visiting buffers.  @xref{Definition
of save-some-buffers}.  The variable @code{buffer-offer-save} automatically
becomes buffer-local when set for any reason.  @xref{Buffer-Local
Variables}.
@end defopt

@defvar buffer-save-without-query
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} to save this
buffer (if it's modified) without asking the user.  The variable
automatically becomes buffer-local when set for any reason.
@end defvar

@defun buffer-live-p object
This function returns @code{t} if @var{object} is a live buffer (a buffer
which has not been killed), @code{nil} otherwise.
@end defun

@node Indirect Buffers
@section Indirect Buffers
@cindex indirect buffers
@cindex base buffer

  An @dfn{indirect buffer} shares the text of some other buffer, which is
called the @dfn{base buffer} of the indirect buffer.  In some ways it is the
analogue, for buffers, of a symbolic link among files.  The base buffer may
not itself be an indirect buffer.

  The text of the indirect buffer is always identical to the text of its base
buffer; changes made by editing either one are visible immediately in the
other.  This includes the text properties as well as the characters
themselves.

  In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent buffer-local
variable bindings.

  An indirect buffer cannot visit a file, but its base buffer can.  If you try
to save the indirect buffer, that actually saves the base buffer.

  Killing an indirect buffer has no effect on its base buffer.  Killing the
base buffer effectively kills the indirect buffer in that it cannot ever
again be the current buffer.

@deffn Command make-indirect-buffer base-buffer name &optional clone
This creates and returns an indirect buffer named @var{name} whose base
buffer is @var{base-buffer}.  The argument @var{base-buffer} may be a live
buffer or the name (a string) of an existing buffer.  If @var{name} is the
name of an existing buffer, an error is signaled.

If @var{clone} is non-@code{nil}, then the indirect buffer originally shares
the ``state'' of @var{base-buffer} such as major mode, minor modes, buffer
local variables and so on.  If @var{clone} is omitted or @code{nil} the
indirect buffer's state is set to the default state for new buffers.

If @var{base-buffer} is an indirect buffer, its base buffer is used as the
base for the new buffer.  If, in addition, @var{clone} is non-@code{nil},
the initial state is copied from the actual base buffer, not from
@var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
This function creates and returns a new indirect buffer that shares the
current buffer's base buffer and copies the rest of the current buffer's
attributes.  (If the current buffer is not indirect, it is used as the base
buffer.)

If @var{display-flag} is non-@code{nil}, that means to display the new
buffer by calling @code{pop-to-buffer}.  If @var{norecord} is
non-@code{nil}, that means not to put the new buffer to the front of the
buffer list.
@end deffn

@defun buffer-base-buffer &optional buffer
This function returns the base buffer of @var{buffer}, which defaults to the
current buffer.  If @var{buffer} is not indirect, the value is @code{nil}.
Otherwise, the value is another buffer, which is never an indirect buffer.
@end defun

@node Swapping Text
@section Swapping Text Between Two Buffers
@cindex swap text between buffers
@cindex virtual buffers

  Specialized modes sometimes need to let the user access from the same buffer
several vastly different types of text.  For example, you may need to
display a summary of the buffer text, in addition to letting the user access
the text itself.

  This could be implemented with multiple buffers (kept in sync when the user
edits the text), or with narrowing (@pxref{Narrowing}).  But these
alternatives might sometimes become tedious or prohibitively expensive,
especially if each type of text requires expensive buffer-global operations
in order to provide correct display and editing commands.

  Emacs provides another facility for such modes: you can quickly swap buffer
text between two buffers with @code{buffer-swap-text}.  This function is
very fast because it doesn't move any text, it only changes the internal
data structures of the buffer object to point to a different chunk of text.
Using it, you can pretend that a group of two or more buffers are actually a
single virtual buffer that holds the contents of all the individual buffers
together.

@defun buffer-swap-text buffer
This function swaps the text of the current buffer and that of its argument
@var{buffer}.  It signals an error if one of the two buffers is an indirect
buffer (@pxref{Indirect Buffers}) or is a base buffer of an indirect buffer.

All the buffer properties that are related to the buffer text are swapped as
well: the positions of point and mark, all the markers, the overlays, the
text properties, the undo list, the value of the
@code{enable-multibyte-characters} flag (@pxref{Text Representations,
enable-multibyte-characters}), etc.
@end defun

  If you use @code{buffer-swap-text} on a file-visiting buffer, you should set
up a hook to save the buffer's original text rather than what it was swapped
with.  @code{write-region-annotate-functions} works for this purpose.  You
should probably set @code{buffer-saved-size} to @minus{}2 in the buffer, so
that changes in the text it is swapped with will not interfere with
auto-saving.

@node Buffer Gap
@section The Buffer Gap
@cindex buffer gap

  Emacs buffers are implemented using an invisible @dfn{gap} to make insertion
and deletion faster.  Insertion works by filling in part of the gap, and
deletion adds to the gap.  Of course, this means that the gap must first be
moved to the locus of the insertion or deletion.  Emacs moves the gap only
when you try to insert or delete.  This is why your first editing command in
one part of a large buffer, after previously editing in another far-away
part, sometimes involves a noticeable delay.

  This mechanism works invisibly, and Lisp code should never be affected by
the gap's current location, but these functions are available for getting
information about the gap status.

@defun gap-position
This function returns the current gap position in the current buffer.
@end defun

@defun gap-size
This function returns the current gap size of the current buffer.
@end defun
