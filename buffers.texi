@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Buffers
@chapter Buffers
@cindex buffer

  @dfn{バッファー(buffer)}とは、編集されるテキストを含むLispオブジェクトのことです。バッファーは、visitされるファイルのコンテンツを保持するために使用されます。しかし、ファイルをvisitしないバッファーも存在するかもしれません。一度に複数のバッファーが存在するかもしれませんが、@dfn{カレントバッファー(current
buffer)}に指定できるのは、常に1つのバッファーだけです。ほとんどの編集コマンドは、カレントバッファーのコンテンツにたいして作用します。カレントバッファーを含むすべてのバッファーは、任意のウィンドウ内に表示されるときも、表示されない場合もあります。

@menu
* Buffer Basics::            バッファーとは?
* Current Buffer::           バッファーをカレントに指定することにより、プリミティブはバッファーのコンテンツにアクセスする。
* Buffer Names::             バッファー名にたいするアクセスと変更。
* Buffer File Name::         バッファーファイル名は、どのファイルをvisitしているかを示す。
* Buffer Modification::      保存が必要なら、バッファーは@dfn{変更されている(modified)}。
* Modification Time::        "Emacsの裏"でvisitされているファイルが変更されたかどうかを判断する。
* Read Only Buffers::        読み取り専用バッファーでのテキスト変更は許されない。
* Buffer List::              すべての既存バッファーを閲覧する方法。
* Creating Buffers::         バッファーを作成する関数。
* Killing Buffers::          明示的にkillされるまで、バッファーは存在する。
* Indirect Buffers::         インダイレクトバッファーは、他のバッファーとテキストを共有する。
* Swapping Text::            2つのバッファー間でのテキストの交換。
* Buffer Gap::               バッファー内のギャップ。
@end menu

@node Buffer Basics
@section Buffer Basics

@ifnottex
  @dfn{バッファー(buffer)}とは、編集されるテキストを含むLispオブジェクトのことです。バッファーは、visitされるファイルのコンテンツを保持するために使用されます。しかし、ファイルをvisitしないバッファーも存在します。一度に複数のバッファーが存在するかもしれませんが、@dfn{カレントバッファー(current
buffer)}に指定できるのは、常に1つのバッファーだけです。ほとんどの編集コマンドは、カレントバッファーのコンテンツにたいして作用します。カレントバッファーを含むすべてのバッファーは、任意のウィンドウ内に表示されるときも、表示されない場合もあります。
@end ifnottex

  Emacs編集におけるバッファーは、個別に名前をもち、編集可能なテキストを保持するオブジェクトです。Lispプログラムにたいして、バッファーはスペシャルデータ型として表されます。バッファーのコンテンツを、拡張可能な文字列と考えることができます。挿入と削除は、バッファー内の任意の箇所で発生し得ます。@ref{Text}を参照してください。

  Lispのバッファーオブジェクトは、多くの情報要素を含んでいます。これらの情報のいくつかは変数を通じてプログラマーが直接アクセスできるのにたいして、その他の情報は特殊な目的のための関数を通じてのみアクセスすることができます。たとえば、visitされているファイルの名前は変数を通じて直接アクセスできますが、ポイント値はプリミティブ関数からのみアクセスできます。

  直接アクセス可能な、バッファー固有の情報は、@dfn{バッファーローカル(buffer-local)}な変数バインディング内に格納されます。これは、特定のバッファー内だけで効力のある変数値のことです。この機能により、それぞれのバッファーは、特定の変数の値をオーバーライドすることができます。ほとんどのメジャーモードは、この方法で@code{fill-column}や@code{comment-column}のような変数をオーバーライドしています。バッファーローカルな変数、およびそれらに関連する関数についての詳細は、@ref{Buffer-Local
Variables}を参照してください。

  バッファーからファイルをvisitする関数および変数については、@ref{Visiting Files}、および@ref{Saving
Buffers}を参照してください。ウィンドウ内へのバッファー表示に関連する関数および変数については、@ref{Buffers and
Windows}を参照してください。

@defun bufferp object
この関数は、@var{object}がバッファーなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@node Current Buffer
@section The Current Buffer
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  一般的に、1つのEmacsセッション内には、多くのバッファーが存在します。常に、それらのうちの1つが@dfn{カレントバッファー(current
buffer)}に指定され、ます。カレントバッファーとは、ほとんどの編集が行われるバッファーのことです。テキストを調べたり変更するプリミティブのほとんどは、暗黙的にカレントバッファーにたいして処理を行います(@ref{Text}を参照)。

  通常は、選択されたウィンドウ内に表示されるバッファーがカレントバッファーですが、常にそうではありません。Lispプログラムは、バッファーのコンテンツを処理するために、スクリーン上に表示されているものを変更することなく、任意のバッファーを一時的にカレントに指定できます。カレントバッファーの指定にたいしてもっとも基本的な関数は、@code{set-buffer}です。

@defun current-buffer
この関数は、カレントバッファーをリターンする関数。

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
この関数は、@var{buffer-or-name}をカレントバッファーにする。@var{buffer-or-name}は既存のバッファー、または既存のバッファーの名前でなければならない。リターン値は、カレントになったバッファーである。

この関数は、そのバッファーをどのウィンドウにも表示しないので、必然的にユーザーはそのバッファーを見ることはできない。しかし、Lispプログラムはその後、そのバッファーにたいして処理を行うことになるだろう。
@end defun

  編集コマンドがエディターコマンドループにリターンする際、Emacsは選択されたウィンドウ内に表示されているバッファーにたいして、自動的に@code{set-buffer}を呼び出します。これは混乱を防ぐためで、これにより、Emacsがコマンドを読み取るときに、カーソルのあるバッファーが、コマンドを適用されるバッファーになるのが保証されます(@ref{Command
Loop}を参照)。したがって、異なるバッファーを指示して切り替える場合に、@code{set-buffer}を使用するべきではありません。これを行うためには、@ref{Switching
Buffers}で説明されているカを使用してください。

  Lisp関数を記述する際は、処理後にカレントバッファーをリストアするために、コマンドループのこの振る舞いに@emph{依存しないでください}。編集コマンドは、コマンドループだけではなく、他のプログラムからLisp関数としても呼び出されます。呼び出し側にとっては、そのサブルーチンがカレントだったバッファーを変更しないほうが便利です(もちろん、それがサブルーチンの目的でない場合ですが)。

  他のバッファーにたいして一時的に処理を行うには、@code{save-current-buffer}フォーム内に@code{set-buffer}を置きます。以下の例は、コマンド@code{append-to-buffer}の簡略版です:

@example
@group
(defun append-to-buffer (buffer start end)
  "リージョンのテキストをBUFFERに追加する"
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
ここでは、カレントバッファーを記録するためにローカル変数にバインドしてから、後で@code{save-current-buffer}がそれを再びカレントにするよう、取り計らっています。次に、@code{set-buffer}が指定されたバッファーをカレントにして、@code{insert-buffer-substring}が元のバッファーの文字列を、指定された(今はカレントの)バッファーにコピーします。

  かわりに、@code{with-current-buffer}マクロを使用することもできます:

@example
@group
(defun append-to-buffer (buffer start end)
  "BUFFERにリージョンのテキストを追加する"
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  どちらの場合でも、追加されるバッファーが偶然他のウィンドウに表示されていた場合には、次回の再表示でそのテキストがどのように変更されたか表示されるでしょう。どのウィンドウにも表示されていない場合には、スクリーン上で即座に変更を目にすることはありません。コマンドはバッファーを一時的にカレントにしますが、そのことがバッファーの表示を誘因する訳ではありません。

  バッファーローカルバインディングをもつ変数にたいして、(@code{let}や関数引数などで)ローカルバインディングを作成する場合は、そのローカルバインディングのスコープの最初と最後で、同じバッファーがカレントとなることを確認してください。そうしないと、あるバッファーではバインドして、他のバッファーではバインドされないことになるかもしれません!

  @code{set-buffer}の使用において、カレントバッファーが戻ることに依存しないでください。なぜなら、間違ったバッファーがカレントのときにquitが発生した場合、その処理は行われないでしょう。たとえば上記の例に倣うと、以下は間違ったやり方です:

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
例で示したように@code{save-current-buffer}、または@code{with-current-buffer}を使用すれば、quitや@code{throw}を、通常の評価と同様に処理できます。

@defspec save-current-buffer body@dots{}
スペシャルフォーム@code{save-current-buffer}は、カレントバッファーの識別を保存して、@var{body}フォームを評価し、最後にそのバッファーをカレントにリストアする。リターン値は、@var{body}内の最後のフォームの値である。@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal
Exits}を参照)。

カレントとして使用されていたバッファーが、@code{save-current-buffer}によるexit時にkillされていた場合は、それが再びカレントとなることは当然ない。かわりに、exit直前にカレントバッファーが何であれ、それがカレントになる。
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
@code{with-current-buffer}マクロは、カレントバッファーの識別を保存して、@var{buffer-or-name}をカレントにし、@var{body}フォームを評価して、最後にカレントバッファーをリストアする。@var{buffer-or-name}には既存のバッファー、または既存のバッファー名を指定しなければならない。

リターン値は、@var{body}内の最後のフォームの値である。@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal
Exits}を参照)。
@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
@code{with-temp-buffer}マクロは、一時的なバッファーをカレントバッファーとして、@var{body}フォームを評価する。これはカレントバッファーの識別を保存して、一時的なバッファーを作成、それをカレントとして、@var{body}フォームを評価し、一時バッファーをkillする間に、以前のカレントバッファーをリストアする。
デフォルトでは、このマクロにより作成されたバッファー内のアンドゥ情報(@ref{Undo}を参照)は記録されない(が、必要なら@var{body}でそれを有効にできる)。

リターン値は、@var{body}内の最後のフォームの値である。最後のフォームとして@code{(buffer-string)}を使用することにより、一時バッファーのコンテンツをリターンできる。

@code{throw}やエラーを通じた異常exitの場合でも、カレントバッファーはリストアされる(@ref{Nonlocal Exits}を参照)。

@ref{Definition of with-temp-file,, Writing to
Files}の@code{with-temp-file}も参照されたい。
@end defmac

@node Buffer Names
@section Buffer Names
@cindex buffer names

  それぞれのバッファーは、文字列で表される一意な名前をもちます。バッファーにたいして機能する関数の多くは、引数としてバッファーとバッファー名の両方を受け入れます。@var{buffer-or-name}という名前の引数がこのタイプで、それが文字列でもバッファーでもない場合は、エラーがシグナルされます。@var{buffer}という名前の引数は、名前ではなく実際のバッファーオブジェクトでなければなりません。

@cindex hidden buffers
@cindex buffers without undo information
  短命でユーザーが関心をもたないようなバッファーは名前がスペースで始まり、それらについては@code{list-buffers}および@code{buffer-menu}コマンドは無視します(が、ファイルをvisitしているようなバッファーは@strong{無視されない})。スペースで始まる名前は、初期状態ではアンドゥ情報の記録も無効になっています。@ref{Undo}を参照してください。

@defun buffer-name &optional buffer
この関数は、@var{buffer}の名前を文字列としてリターンする。@var{buffer}のデフォルトは、カレントバッファーである。

@code{buffer-name}が@code{nil}をリターンした場合、それは@var{buffer}がkillされていることを意味する。@ref{Killing
Buffers}を参照のこと。

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
この関数は、カレントバッファーを@var{newname}にリネームする。@var{newname}が文字列でない場合は、エラーをシグナルする。

@c Emacs 19 feature
@var{newname}がすでに使用済みの場合、@code{rename-buffer}は通常はエラーをシグナルする。しかし、@var{unique}が非@code{nil}の場合は、未使用の名前となるように@var{newname}を変更する。interactiveに呼び出した場合は、プレフィックス数引数により@var{unique}に非@code{nil}を指定できる(この方法により、コマンド@code{rename-uniquely}は実装される)。

この関数は、実際にバッファーに与えられた名前をリターンする。
@end deffn

@defun get-buffer buffer-or-name
この関数は、@var{buffer-or-name}で指定されたバッファーをリターンする。@var{buffer-or-name}が文字列で、かつそのような名前のバッファーが存在しない場合、値は@code{nil}になる。@var{buffer-or-name}がバッファーの場合は、与えられたバッファーをリターンする。これは有用とは言い難く、引数は通常は名前である。たとえば:

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

@ref{Creating Buffers}の関数@code{get-buffer-create}も参照のこと。
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
この関数は、新たなバッファーにたいして一意となるような名前をリターンする ---
が、バッファーは作成しない。この名前は@var{starting-name}で始まり、内部が数字であるような@samp{<@dots{}>}を追加することにより、すべてのバッファーでカレントで使用されていない名前を生成する。この数字は2で始まり、既存バッファーの名前でない名前になる数字まで増加される。

オプション引数@var{ignore}が非@code{nil}の場合、それは潜在的にバッファー名であるような文字列であること。これは、たとえそれが(通常は拒絶されるであろう)既存バッファーの名前であっても、試みられた場合は、潜在的に受容可能なバッファーとして考慮することを意味する。つまり@samp{foo}、@samp{foo<2>}、@samp{foo<3>}、@samp{foo<4>}という名前のバッファーが存在する場合、

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

@ref{Creating Buffers}の関連する関数@code{generate-new-buffer}も参照のこと。
@end defun

@node Buffer File Name
@section Buffer File Name
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  @dfn{バッファーファイル名(buffer file
name)}とは、そのバッファーにvisitされているファイルの名前です。バッファーがファイルをvisiblyしていなければ、バッファーファイル名は@code{nil}です。大抵、バッファー名はバッファーファイル名の非ディレクトリーパートと同じですが、バッファーファイル名とバッファー名は別物であり、個別にセットすることができます。@ref{Visiting
Files}を参照してください。

@defun buffer-file-name &optional buffer
この関数は、@var{buffer}がvisitしているファイルの、絶対ファイル名をリターンする。@var{buffer}がファイルをvisitしていない場合、@code{buffer-file-name}は@code{nil}をリターンする。@var{buffer}が与えられない場合のデフォルトは、カレントバッファーになる。

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
このバッファーローカル変数は、カレントバッファーにvisitされているファイルの名前、ファイルをvisitしていなければ@code{nil}が含まれる。これは永続的なローカル変数であり、@code{kill-all-local-variables}の影響を受けない。

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

他のさまざまな事項を変更せずに、この変数を変更するのは危険である。通常は、@code{set-visited-file-name}を使用するほうがよい(以下参照)。バッファー名の変更などのような、そこで行われることのいくつかは、絶対必要という訳ではないが、その他の事項はEmacsが混乱するのを防ぐために必要不可欠である。
@end defvar

@defvar buffer-file-truename
このバッファーローカル変数は、カレントバッファーにvisitされているファイルの省略された形式の実名(truename)、ファイルをvisitしていない場合は@code{nil}を保持する。これは永続的にローカルであり、@code{kill-all-local-variables}の影響を受けない。@xref{Truenames}、および@ref{abbreviate-file-name}を参照のこと。
@end defvar

@defvar buffer-file-number
このバッファーローカル変数は、カレントバッファーにvisitされているファイルのファイル番号(file number)とデバイス番号(device
number)、ファイルをvisitしていない場合は@code{nil}を保持する。これは永続的にローカルであり、@code{kill-all-local-variables}の影響を受けない。

値は通常、@code{(@var{filenum}
@var{devnum})}のような形式のリストである。この番号ペアーは、システム上でアクセス可能なすべてのファイルの中から、ファイルを一意に識別する。より詳細な情報は、@ref{File
Attributes}の@code{file-attributes}を参照のこと。

@code{buffer-file-name}がシンボリックリンク名の場合は、どちらの番号も再帰的なターゲットを参照する。
@end defvar

@defun get-file-buffer filename
この関数は、ファイル@var{filename}をvisitしているバッファーをリターンする。そのようなバッファーが存在しない場合は、@code{nil}をリターンする。引数@var{filename}は文字列でなければならず、展開(@ref{File
Name
Expansion}を参照)された後、killされていないすべてのバッファーがvisitしているファイル名と比較される。バッファーの@code{buffer-file-name}は、@var{filename}の展開形と正確にマッチしなければならないことに注意。この関数は、同じファイルにたいする他の名前は、認識しないだろう。

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

特殊な状況下では、複数のバッファーが同じファイル名をvisitすることがあり得る。そのような場合、この関数はバッファーリスト内の最初に該当するバッファーをリターンする。
@end defun

@defun find-buffer-visiting filename &optional predicate
これは@code{get-file-buffer}と似ているが、そのファイルを@emph{違う名前}でvisitしているかもしれないすべてのバッファーをリターンする。つまり、バッファーの@code{buffer-file-name}は@var{filename}の展開形式と正確にマッチする必要はなく、同じファイルを参照することだけが要求される。@var{predicate}が非@code{nil}の場合、それは@var{filename}をvisitしているバッファーを1つの引数とする関数であること。そのバッファーにたいして、@var{predicate}が非@code{nil}をリターンした場合のみ、適切なリターン値と判断される。リターンすべき適切なバッファーが見つからない場合、@code{find-buffer-visiting}は@code{nil}をリターンする。
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
@var{filename}が非空文字列の場合、この関数はカレントバッファーにvisitされているファイルの名前を、@var{filename}に変更する(バッファーがファイルをvisitしていない場合は、visitするファイルとして@var{filename}を与える)。そのバッファーにたいする@emph{次回}の保存では、新たに指定されたファイルに保存されるだろう。

このコマンドは、たとえそのバッファーのコンテンツがその前にvisitされていたファイルとマッチしていても、(Emacsが関知するかぎり)@var{filename}のコンテンツとはマッチしないので、バッファーが変更されている(modified)とマークする。これは、その名前がすでに使用されていなければ、新たなファイル名に対応してバッファーをリネームする。

@var{filename}が@code{nil}、または空文字列の場合、それは``visitされているファイルがない''ことを意味する。この場合、@code{set-visited-file-name}はバッファーの変更フラグを変更することなく、そのバッファーがファイルをvisitしていないとマークする。

この関数は@var{filename}をvisitしているバッファーがすでに存在する場合は、通常はユーザーに確認を求める。しかし、@var{no-query}が非@code{nil}の場合は、この質問を行わない。@var{filename}をvisitしているバッファーがすでに存在し、かつユーザーが承認、または@var{no-query}が非@code{nil}の場合、この関数は中に数字が入った@samp{<@dots{}>}を@var{filename}に追加して、新たなバッファーの名前を一意にする。

@var{along-with-file}が非@code{nil}の場合、それは前にvisitされていたファイルが@var{filename}にリネームされたと想定することを意味する。この場合、コマンドはバッファーの修正フラグを変更せず、そのバッファーの記録されている最終ファイル変更時刻を@code{visited-file-modtime}が報告する時刻(@ref{Modification
Time}を参照)で変更もしない。@var{along-with-file}が@code{nil}の場合、この関数は@code{visited-file-modtime}が0をリターンした後に、記録済みの最終ファイル変更時刻をクリアーする。

関数@code{set-visited-file-name}がinteractiveに呼び出されたときは、ミニバッファー内で@var{filename}の入力を求める。
@end deffn

@defvar list-buffers-directory
このバッファーローカル変数は、visitしているファイル名をもたないバッファーにたいして、バッファーリスト中のvisitしているファイル名を表示する場所に表示する文字列を指定する。Diredバッファーは、この変数を使用する。
@end defvar

@node Buffer Modification
@section Buffer Modification
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacsは、各バッファーにたいして、バッファーのテキストを変更したかどうかを記録するために、@dfn{変更フラグ(modified
flag)}と呼ばれるフラグを管理しています。このフラグは、バッファーのコンテンツを変更すると常に@code{t}にセットされ、バッファーを保存したとき@code{nil}にクリアーされます。したがって、このフラグは保存されていない変更があるかどうかを表します。フラグの値は通常、モードライン内(@ref{Mode
Line Variables}を参照)に表示され、保存(@ref{Saving
Buffers}を参照)と自動保存(@ref{Auto-Saving}を参照)を制御します。

  いくつかのLispプログラムは、このフラグを明示的にセットします。たとえば、関数@code{set-visited-file-name}は、このフラグを@code{t}にセットします。なぜなら、たとえその前にvisitしていたファイルが変更されていなくても、テキストは新たにvisitされたファイルとマッチしないからです。

  バッファーのコンテンツを変更する関数については、@ref{Text}で説明されています。

@defun buffer-modified-p &optional buffer
この関数は、バッファー@var{buffer}が最後にファイルから読み込まれた、あるいは保存されてから変更されていれば@code{t}、それ以外では@code{nil}をリターンする。@var{buffer}が与えられない場合は、カレントバッファーがテストされる。
@end defun

@defun set-buffer-modified-p flag
この関数は、@var{flag}が非@code{nil}ならカレントバッファーを変更済みとしてマークし、@code{nil}なら未変更としてマークする。

この関数を呼び出すことによる別の効果は、それがカレントバッファーのモードラインの無条件な再表示を引き起こすことである。実際のところ、関数@code{force-mode-line-update}は、以下を行うことにより機能する:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
@code{set-buffer-modified-p}と同様だが、モードラインにたいする強制的な再表示を行わない。
@end defun

@deffn Command not-modified &optional arg
このコマンドは、カレントバッファーが変更されておらず、保存する必要がないとマークする。@var{arg}が非@code{nil}の場合、これは変更されているとマークするので、次回の適切なタイミングでバッファーは保存されるだろう。interactiveに呼び出された場合、@var{arg}はプレフィックス引数である。

この関数は、エコーエリア内にメッセージをプリントするので、プログラム内で使用してはならない。かわりに、@code{set-buffer-modified-p}(上記)を使用すること。
@end deffn

@defun buffer-modified-tick &optional buffer
この関数は、@var{buffer}の変更カウント(modification-count)をリターンする。これは、バッファーが変更されるたびに増加されるカウンターである。@var{buffer}が@code{nil}(または省略)の場合は、カレントバッファーが使用される。このカウンターは、時折0にクリアーされ得る。
@end defun

@defun buffer-chars-modified-tick &optional buffer
この関数は、@var{buffer}の文字変更に関わる変更カウントをリターンする。テキストプロパティを変更しても、このカウンターは変化しない。しかし、そのバッファーにテキストが挿入、または削除されるたびに、このカウンターは@code{buffer-modified-tick}によりリターンされるであろう値にリセットされる。@code{buffer-chars-modified-tick}を2回呼び出してリターンされる値を比較することにより、その呼び出しの間にバッファー内で文字変更があったかどうかを知ることができる。@var{buffer}が@code{nil}(または省略)の場合は、カレントバッファーが使用される。
@end defun

@node Modification Time
@section Buffer Modification Time
@cindex comparing file modification time
@cindex modification time of buffer

  Suppose that you visit a file and make changes in its buffer, and meanwhile
the file itself is changed on disk.  At this point, saving the buffer would
overwrite the changes in the file.  Occasionally this may be what you want,
but usually it would lose valuable information.  Emacs therefore checks the
file's modification time using the functions described below before saving
the file.  (@xref{File Attributes}, for how to examine a file's modification
time.)

@defun verify-visited-file-modtime &optional buffer
This function compares what @var{buffer} (by default, the current-buffer)
has recorded for the modification time of its visited file against the
actual modification time of the file as recorded by the operating system.
The two should be the same unless some other process has written the file
since Emacs visited or saved it.

The function returns @code{t} if the last actual modification time and
Emacs's recorded modification time are the same, @code{nil} otherwise.  It
also returns @code{t} if the buffer has no recorded last modification time,
that is if @code{visited-file-modtime} would return zero.

It always returns @code{t} for buffers that are not visiting a file, even if
@code{visited-file-modtime} returns a non-zero value.  For instance, it
always returns @code{t} for dired buffers.  It returns @code{t} for buffers
that are visiting a file that does not exist and never existed, but
@code{nil} for file-visiting buffers whose file has been deleted.
@end defun

@defun clear-visited-file-modtime
This function clears out the record of the last modification time of the
file being visited by the current buffer.  As a result, the next attempt to
save this buffer will not complain of a discrepancy in file modification
times.

This function is called in @code{set-visited-file-name} and other
exceptional places where the usual test to avoid overwriting a changed file
should not be done.
@end defun

@defun visited-file-modtime
This function returns the current buffer's recorded last file modification
time, as a list of the form @code{(@var{high} @var{low} @var{microsec}
@var{picosec})}.  (This is the same format that @code{file-attributes} uses
to return time values; @pxref{File Attributes}.)

If the buffer has no recorded last modification time, this function returns
zero.  This case occurs, for instance, if the buffer is not visiting a file
or if the time has been explicitly cleared by
@code{clear-visited-file-modtime}.  Note, however, that
@code{visited-file-modtime} returns a list for some non-file buffers too.
For instance, in a Dired buffer listing a directory, it returns the last
modification time of that directory, as recorded by Dired.

If the buffer is not visiting a file, this function returns -1.
@end defun

@defun set-visited-file-modtime &optional time
This function updates the buffer's record of the last modification time of
the visited file, to the value specified by @var{time} if @var{time} is not
@code{nil}, and otherwise to the last modification time of the visited file.

If @var{time} is neither @code{nil} nor zero, it should have the form
@code{(@var{high} @var{low} @var{microsec} @var{picosec})}, the format used
by @code{current-time} (@pxref{Time of Day}).

This function is useful if the buffer was not read from the file normally,
or if the file itself has been changed for some known benign reason.
@end defun

@defun ask-user-about-supersession-threat filename
This function is used to ask a user how to proceed after an attempt to
modify an buffer visiting file @var{filename} when the file is newer than
the buffer text.  Emacs detects this because the modification time of the
file on disk is newer than the last save-time of the buffer.  This means
some other program has probably altered the file.

@kindex file-supersession
Depending on the user's answer, the function may return normally, in which
case the modification of the buffer proceeds, or it may signal a
@code{file-supersession} error with data @code{(@var{filename})}, in which
case the proposed buffer modification is not allowed.

This function is called automatically by Emacs on the proper occasions.  It
exists so you can customize Emacs by redefining it.  See the file
@file{userlock.el} for the standard definition.

See also the file locking mechanism in @ref{File Locks}.
@end defun

@node Read Only Buffers
@section Read-Only Buffers
@cindex read-only buffer
@cindex buffer, read-only

  If a buffer is @dfn{read-only}, then you cannot change its contents,
although you may change your view of the contents by scrolling and
narrowing.

  Read-only buffers are used in two kinds of situations:

@itemize @bullet
@item
A buffer visiting a write-protected file is normally read-only.

Here, the purpose is to inform the user that editing the buffer with the aim
of saving it in the file may be futile or undesirable.  The user who wants
to change the buffer text despite this can do so after clearing the
read-only flag with @kbd{C-x C-q}.

@item
Modes such as Dired and Rmail make buffers read-only when altering the
contents with the usual editing commands would probably be a mistake.

The special commands of these modes bind @code{buffer-read-only} to
@code{nil} (with @code{let}) or bind @code{inhibit-read-only} to @code{t}
around the places where they themselves change the text.
@end itemize

@defvar buffer-read-only
This buffer-local variable specifies whether the buffer is read-only.  The
buffer is read-only if this variable is non-@code{nil}.
@end defvar

@defvar inhibit-read-only
If this variable is non-@code{nil}, then read-only buffers and, depending on
the actual value, some or all read-only characters may be modified.
Read-only characters in a buffer are those that have a non-@code{nil}
@code{read-only} text property.  @xref{Special Properties}, for more
information about text properties.

If @code{inhibit-read-only} is @code{t}, all @code{read-only} character
properties have no effect.  If @code{inhibit-read-only} is a list, then
@code{read-only} character properties have no effect if they are members of
the list (comparison is done with @code{eq}).
@end defvar

@deffn Command read-only-mode &optional arg
This is the mode command for Read Only minor mode, a buffer-local minor
mode.  When the mode is enabled, @code{buffer-read-only} is non-@code{nil}
in the buffer; when disabled, @code{buffer-read-only} is @code{nil} in the
buffer.  The calling convention is the same as for other minor mode commands
(@pxref{Minor Mode Conventions}).

This minor mode mainly serves as a wrapper for @code{buffer-read-only};
unlike most minor modes, there is no separate @code{read-only-mode}
variable.  Even when Read Only mode is disabled, characters with
non-@code{nil} @code{read-only} text properties remain read-only.  To
temporarily ignore all read-only states, bind @code{inhibit-read-only}, as
described above.

When enabling Read Only mode, this mode command also enables View mode if
the option @code{view-read-only} is non-@code{nil}.  @xref{Misc
Buffer,,Miscellaneous Buffer Operations, emacs, The GNU Emacs Manual}.  When
disabling Read Only mode, it disables View mode if View mode was enabled.
@end deffn

@defun barf-if-buffer-read-only
This function signals a @code{buffer-read-only} error if the current buffer
is read-only.  @xref{Using Interactive}, for another way to signal an error
if the current buffer is read-only.
@end defun

@node Buffer List
@section The Buffer List
@cindex buffer list
@cindex listing all buffers

  The @dfn{buffer list} is a list of all live buffers.  The order of the
buffers in this list is based primarily on how recently each buffer has been
displayed in a window.  Several functions, notably @code{other-buffer}, use
this ordering.  A buffer list displayed for the user also follows this
order.

  Creating a buffer adds it to the end of the buffer list, and killing a
buffer removes it from that list.  A buffer moves to the front of this list
whenever it is chosen for display in a window (@pxref{Switching Buffers}) or
a window displaying it is selected (@pxref{Selecting Windows}).  A buffer
moves to the end of the list when it is buried (see @code{bury-buffer},
below).  There are no functions available to the Lisp programmer which
directly manipulate the buffer list.

  In addition to the fundamental buffer list just described, Emacs maintains a
local buffer list for each frame, in which the buffers that have been
displayed (or had their windows selected) in that frame come first.  (This
order is recorded in the frame's @code{buffer-list} frame parameter; see
@ref{Buffer Parameters}.)  Buffers never displayed in that frame come
afterward, ordered according to the fundamental buffer list.

@defun buffer-list &optional frame
This function returns the buffer list, including all buffers, even those
whose names begin with a space.  The elements are actual buffers, not their
names.

If @var{frame} is a frame, this returns @var{frame}'s local buffer list.  If
@var{frame} is @code{nil} or omitted, the fundamental buffer list is used:
the buffers appear in order of most recent display or selection, regardless
of which frames they were displayed on.

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{Note that the name of the minibuffer}
;;   @r{begins with a space!}
(mapcar (function buffer-name) (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  The list returned by @code{buffer-list} is constructed specifically; it is
not an internal Emacs data structure, and modifying it has no effect on the
order of buffers.  If you want to change the order of buffers in the
fundamental buffer list, here is an easy way:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  With this method, you can specify any order for the list, but there is no
danger of losing a buffer or adding something that is not a valid live
buffer.

  To change the order or value of a specific frame's buffer list, set that
frame's @code{buffer-list} parameter with @code{modify-frame-parameters}
(@pxref{Parameter Access}).

@defun other-buffer &optional buffer visible-ok frame
This function returns the first buffer in the buffer list other than
@var{buffer}.  Usually, this is the buffer appearing in the most recently
selected window (in frame @var{frame} or else the selected frame,
@pxref{Input Focus}), aside from @var{buffer}.  Buffers whose names start
with a space are not considered at all.

If @var{buffer} is not supplied (or if it is not a live buffer), then
@code{other-buffer} returns the first buffer in the selected frame's local
buffer list. (If @var{frame} is non-@code{nil}, it returns the first buffer
in @var{frame}'s local buffer list instead.)

If @var{frame} has a non-@code{nil} @code{buffer-predicate} parameter, then
@code{other-buffer} uses that predicate to decide which buffers to
consider.  It calls the predicate once for each buffer, and if the value is
@code{nil}, that buffer is ignored.  @xref{Buffer Parameters}.

@c Emacs 19 feature
If @var{visible-ok} is @code{nil}, @code{other-buffer} avoids returning a
buffer visible in any window on any visible frame, except as a last resort.
If @var{visible-ok} is non-@code{nil}, then it does not matter whether a
buffer is displayed somewhere or not.

If no suitable buffer exists, the buffer @file{*scratch*} is returned (and
created, if necessary).
@end defun

@defun last-buffer &optional buffer visible-ok frame
This function returns the last buffer in @var{frame}'s buffer list other
than @var{buffer}.  If @var{frame} is omitted or @code{nil}, it uses the
selected frame's buffer list.

The argument @var{visible-ok} is handled as with @code{other-buffer}, see
above.  If no suitable buffer can be found, the buffer @file{*scratch*} is
returned.
@end defun

@deffn Command bury-buffer &optional buffer-or-name
This command puts @var{buffer-or-name} at the end of the buffer list,
without changing the order of any of the other buffers on the list.  This
buffer therefore becomes the least desirable candidate for
@code{other-buffer} to return.  The argument can be either a buffer itself
or the name of one.

This function operates on each frame's @code{buffer-list} parameter as well
as the fundamental buffer list; therefore, the buffer that you bury will
come last in the value of @code{(buffer-list @var{frame})} and in the value
of @code{(buffer-list)}.  In addition, it also puts the buffer at the end of
the list of buffer of the selected window (@pxref{Window History}) provided
it is shown in that window.

If @var{buffer-or-name} is @code{nil} or omitted, this means to bury the
current buffer.  In addition, if the current buffer is displayed in the
selected window, this makes sure that the window is either deleted or
another buffer is shown in it.  More precisely, if the selected window is
dedicated (@pxref{Dedicated Windows}) and there are other windows on its
frame, the window is deleted.  If it is the only window on its frame and
that frame is not the only frame on its terminal, the frame is ``dismissed''
by calling the function specified by @code{frame-auto-hide-function}
(@pxref{Quitting Windows}).  Otherwise, it calls
@code{switch-to-prev-buffer} (@pxref{Window History}) to show another buffer
in that window.  If @var{buffer-or-name} is displayed in some other window,
it remains displayed there.

To replace a buffer in all the windows that display it, use
@code{replace-buffer-in-windows}, @xref{Buffers and Windows}.
@end deffn

@deffn Command unbury-buffer
This command switches to the last buffer in the local buffer list of the
selected frame.  More precisely, it calls the function
@code{switch-to-buffer} (@pxref{Switching Buffers}), to display the buffer
returned by @code{last-buffer} (see above), in the selected window.
@end deffn

@defvar buffer-list-update-hook
This is a normal hook run whenever the buffer list changes.  Functions
(implicitly) running this hook are @code{get-buffer-create} (@pxref{Creating
Buffers}), @code{rename-buffer} (@pxref{Buffer Names}), @code{kill-buffer}
(@pxref{Killing Buffers}), @code{bury-buffer} (see above) and
@code{select-window} (@pxref{Selecting Windows}).
@end defvar

@node Creating Buffers
@section Creating Buffers
@cindex creating buffers
@cindex buffers, creating

  This section describes the two primitives for creating buffers.
@code{get-buffer-create} creates a buffer if it finds no existing buffer
with the specified name; @code{generate-new-buffer} always creates a new
buffer and gives it a unique name.

  Other functions you can use to create buffers include
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) and
@code{create-file-buffer} (@pxref{Visiting Files}).  Starting a subprocess
can also create a buffer (@pxref{Processes}).

@defun get-buffer-create buffer-or-name
This function returns a buffer named @var{buffer-or-name}.  The buffer
returned does not become the current buffer---this function does not change
which buffer is current.

@var{buffer-or-name} must be either a string or an existing buffer.  If it
is a string and a live buffer with that name already exists,
@code{get-buffer-create} returns that buffer.  If no such buffer exists, it
creates a new buffer.  If @var{buffer-or-name} is a buffer instead of a
string, it is returned as given, even if it is dead.

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

The major mode for a newly created buffer is set to Fundamental mode.  (The
default value of the variable @code{major-mode} is handled at a higher
level; see @ref{Auto Major Mode}.)  If the name begins with a space, the
buffer initially disables undo information recording (@pxref{Undo}).
@end defun

@defun generate-new-buffer name
This function returns a newly created, empty buffer, but does not make it
current.  The name of the buffer is generated by passing @var{name} to the
function @code{generate-new-buffer-name} (@pxref{Buffer Names}).  Thus, if
there is no buffer named @var{name}, then that is the name of the new
buffer; if that name is in use, a suffix of the form @samp{<@var{n}>}, where
@var{n} is an integer, is appended to @var{name}.

An error is signaled if @var{name} is not a string.

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

The major mode for the new buffer is set to Fundamental mode.  The default
value of the variable @code{major-mode} is handled at a higher level.
@xref{Auto Major Mode}.
@end defun

@node Killing Buffers
@section Killing Buffers
@cindex killing buffers
@cindex buffers, killing

  @dfn{Killing a buffer} makes its name unknown to Emacs and makes the memory
space it occupied available for other use.

  The buffer object for the buffer that has been killed remains in existence
as long as anything refers to it, but it is specially marked so that you
cannot make it current or display it.  Killed buffers retain their identity,
however; if you kill two distinct buffers, they remain distinct according to
@code{eq} although both are dead.

  If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can change the current buffer.  Therefore, when you
kill a buffer, you should also take the precautions associated with changing
the current buffer (unless you happen to know that the buffer being killed
isn't current).  @xref{Current Buffer}.

  If you kill a buffer that is the base buffer of one or more indirect
@iftex
buffers,
@end iftex
@ifnottex
buffers (@pxref{Indirect Buffers}),
@end ifnottex
the indirect buffers are automatically killed as well.

@cindex live buffer
  The @code{buffer-name} of a buffer is @code{nil} if, and only if, the buffer
is killed.  A buffer that has not been killed is called a @dfn{live}
buffer.  To test whether a buffer is live or killed, use the function
@code{buffer-live-p} (see below).

@deffn Command kill-buffer &optional buffer-or-name
This function kills the buffer @var{buffer-or-name}, freeing all its memory
for other uses or to be returned to the operating system.  If
@var{buffer-or-name} is @code{nil} or omitted, it kills the current buffer.

Any processes that have this buffer as the @code{process-buffer} are sent
the @code{SIGHUP} (``hangup'') signal, which normally causes them to
terminate.  @xref{Signals to Processes}.

If the buffer is visiting a file and contains unsaved changes,
@code{kill-buffer} asks the user to confirm before the buffer is killed.  It
does this even if not called interactively.  To prevent the request for
confirmation, clear the modified flag before calling @code{kill-buffer}.
@xref{Buffer Modification}.

This function calls @code{replace-buffer-in-windows} for cleaning up all
windows currently displaying the buffer to be killed.

Killing a buffer that is already dead has no effect.

This function returns @code{t} if it actually killed the buffer.  It returns
@code{nil} if the user refuses to confirm or if @var{buffer-or-name} was
already dead.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
Before confirming unsaved changes, @code{kill-buffer} calls the functions in
the list @code{kill-buffer-query-functions}, in order of appearance, with no
arguments.  The buffer being killed is the current buffer when they are
called.  The idea of this feature is that these functions will ask for
confirmation from the user.  If any of them returns @code{nil},
@code{kill-buffer} spares the buffer's life.
@end defvar

@defvar kill-buffer-hook
This is a normal hook run by @code{kill-buffer} after asking all the
questions it is going to ask, just before actually killing the buffer.  The
buffer to be killed is current when the hook functions run.  @xref{Hooks}.
This variable is a permanent local, so its local binding is not cleared by
changing major modes.
@end defvar

@defopt buffer-offer-save
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} (if the second
optional argument to that function is @code{t}) to offer to save that
buffer, just as they offer to save file-visiting buffers.  @xref{Definition
of save-some-buffers}.  The variable @code{buffer-offer-save} automatically
becomes buffer-local when set for any reason.  @xref{Buffer-Local
Variables}.
@end defopt

@defvar buffer-save-without-query
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} to save this
buffer (if it's modified) without asking the user.  The variable
automatically becomes buffer-local when set for any reason.
@end defvar

@defun buffer-live-p object
This function returns @code{t} if @var{object} is a live buffer (a buffer
which has not been killed), @code{nil} otherwise.
@end defun

@node Indirect Buffers
@section Indirect Buffers
@cindex indirect buffers
@cindex base buffer

  An @dfn{indirect buffer} shares the text of some other buffer, which is
called the @dfn{base buffer} of the indirect buffer.  In some ways it is the
analogue, for buffers, of a symbolic link among files.  The base buffer may
not itself be an indirect buffer.

  The text of the indirect buffer is always identical to the text of its base
buffer; changes made by editing either one are visible immediately in the
other.  This includes the text properties as well as the characters
themselves.

  In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent buffer-local
variable bindings.

  An indirect buffer cannot visit a file, but its base buffer can.  If you try
to save the indirect buffer, that actually saves the base buffer.

  Killing an indirect buffer has no effect on its base buffer.  Killing the
base buffer effectively kills the indirect buffer in that it cannot ever
again be the current buffer.

@deffn Command make-indirect-buffer base-buffer name &optional clone
This creates and returns an indirect buffer named @var{name} whose base
buffer is @var{base-buffer}.  The argument @var{base-buffer} may be a live
buffer or the name (a string) of an existing buffer.  If @var{name} is the
name of an existing buffer, an error is signaled.

If @var{clone} is non-@code{nil}, then the indirect buffer originally shares
the ``state'' of @var{base-buffer} such as major mode, minor modes, buffer
local variables and so on.  If @var{clone} is omitted or @code{nil} the
indirect buffer's state is set to the default state for new buffers.

If @var{base-buffer} is an indirect buffer, its base buffer is used as the
base for the new buffer.  If, in addition, @var{clone} is non-@code{nil},
the initial state is copied from the actual base buffer, not from
@var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
This function creates and returns a new indirect buffer that shares the
current buffer's base buffer and copies the rest of the current buffer's
attributes.  (If the current buffer is not indirect, it is used as the base
buffer.)

If @var{display-flag} is non-@code{nil}, that means to display the new
buffer by calling @code{pop-to-buffer}.  If @var{norecord} is
non-@code{nil}, that means not to put the new buffer to the front of the
buffer list.
@end deffn

@defun buffer-base-buffer &optional buffer
This function returns the base buffer of @var{buffer}, which defaults to the
current buffer.  If @var{buffer} is not indirect, the value is @code{nil}.
Otherwise, the value is another buffer, which is never an indirect buffer.
@end defun

@node Swapping Text
@section Swapping Text Between Two Buffers
@cindex swap text between buffers
@cindex virtual buffers

  Specialized modes sometimes need to let the user access from the same buffer
several vastly different types of text.  For example, you may need to
display a summary of the buffer text, in addition to letting the user access
the text itself.

  This could be implemented with multiple buffers (kept in sync when the user
edits the text), or with narrowing (@pxref{Narrowing}).  But these
alternatives might sometimes become tedious or prohibitively expensive,
especially if each type of text requires expensive buffer-global operations
in order to provide correct display and editing commands.

  Emacs provides another facility for such modes: you can quickly swap buffer
text between two buffers with @code{buffer-swap-text}.  This function is
very fast because it doesn't move any text, it only changes the internal
data structures of the buffer object to point to a different chunk of text.
Using it, you can pretend that a group of two or more buffers are actually a
single virtual buffer that holds the contents of all the individual buffers
together.

@defun buffer-swap-text buffer
This function swaps the text of the current buffer and that of its argument
@var{buffer}.  It signals an error if one of the two buffers is an indirect
buffer (@pxref{Indirect Buffers}) or is a base buffer of an indirect buffer.

All the buffer properties that are related to the buffer text are swapped as
well: the positions of point and mark, all the markers, the overlays, the
text properties, the undo list, the value of the
@code{enable-multibyte-characters} flag (@pxref{Text Representations,
enable-multibyte-characters}), etc.
@end defun

  If you use @code{buffer-swap-text} on a file-visiting buffer, you should set
up a hook to save the buffer's original text rather than what it was swapped
with.  @code{write-region-annotate-functions} works for this purpose.  You
should probably set @code{buffer-saved-size} to @minus{}2 in the buffer, so
that changes in the text it is swapped with will not interfere with
auto-saving.

@node Buffer Gap
@section The Buffer Gap
@cindex buffer gap

  Emacs buffers are implemented using an invisible @dfn{gap} to make insertion
and deletion faster.  Insertion works by filling in part of the gap, and
deletion adds to the gap.  Of course, this means that the gap must first be
moved to the locus of the insertion or deletion.  Emacs moves the gap only
when you try to insert or delete.  This is why your first editing command in
one part of a large buffer, after previously editing in another far-away
part, sometimes involves a noticeable delay.

  This mechanism works invisibly, and Lisp code should never be affected by
the gap's current location, but these functions are available for getting
information about the gap status.

@defun gap-position
This function returns the current gap position in the current buffer.
@end defun

@defun gap-size
This function returns the current gap size of the current buffer.
@end defun
