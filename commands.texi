@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Command Loop
@chapter Command Loop
@cindex editor command loop
@cindex command loop

  Emacsを実行すると、ほぼ即座に@dfn{エディターコマンドループ(editor command
loop)}にエンターします。このループはキーシーケンスを読み取り、それらの定義を実行して、結果を表示します。このチャプターでは、これらが行われる方法と、Lispプログラムがこれらを行えるようにするサブルーチンを説明します。

@menu
* Command Overview::         コマンドループがコマンドを読み取る方法。
* Defining Commands::        関数が引数を読み取る方法を指定する。
* Interactive Call::         引数を読み取るようにコマンドを呼び出す。
* Distinguish Interactive::  インタラクティブな呼び出しとコマンドを区別する。
* Command Loop Info::        検証用にコマンドループによりセットされる変数。
* Adjusting Point::          コマンドの後にポイント位置を調整する。
* Input Events::             入力を読み取るとき、入力がどのように見えるか。
* Reading Input::            キーボードやマウスからの入力イベントを読み取る方法。
* Special Events::           即座かつ個別に処理されるイベント。
* Waiting::                  ユーザー入力または経過時間の待機。
* Quitting::                 @kbd{C-g}が機能する方法。quitをcatchまたは延期する方法。
* Prefix Command Arguments::  コマンドがプレフィクス引数が機能するようにセットするための方法。
* Recursive Editing::        再帰編集へのエンター、なぜ通常は再帰編集を行うべきでないのか。
* Disabling Commands::       コマンドループが無効なコマンドを扱う方法。
* Command History::          コマンドヒストリーがセットアップされる方法と、どのようにアクセスされるか。
* Keyboard Macros::          キーボードマクロが実装される方法。
@end menu

@node Command Overview
@section Command Loop Overview

  コマンドループが最初に行わなければならないのはキーシーケンスの読み取りです。キーシーケンスほコマンドに変換される入力イベントのシーケンスです。これは関数@code{read-key-sequence}を呼び出すことにより行われます。Lispプログラムもこの関数を呼び出すことができます(@ref{Key
Sequence
Input}を参照)。これらはより低レベルの@code{read-key}や@code{read-event}(@ref{Reading One
Event})で入力を読み取ったり、@code{discard-input}(@ref{Event Input
Misc}を参照)で保留中の入力を無視することもできます。

  キーシーケンスはカレントでアクティブなキーマップを通じてコマンドに変換されます。これが行われる方法については、@xref{Key
Lookup}を参照してください。結果はキーボードマクロかインタラクティブに呼び出し可能な関数になります。キーが@kbd{M-x}の場合は、他のコマンドの名前を読み取り、それを呼び出します。これはコマンド@code{execute-extended-command}(@ref{Interactive
Call}を参照)により行われます。

  コマンドの実行に先立ち、Emacsはアンドゥ境界(undo
boundary)を作成するために@code{undo-boundary}を実行します。@ref{Maintaining Undo}を参照してください。

  コマンドを実行するために、Emacsはまず@code{command-execute}を呼び出してコマンドの引数を読み取ります(@ref{Interactive
Call}を参照)。Lispで記述されたコマンドについては、@code{interactive}指定で引数を読み取る方法を指定します。これはプレフィクス引数(@ref{Prefix
Command
Arguments}を参照)を使用したり、ミニバッファー内(@ref{Minibuffers}を参照)で確認を求めて読み取りを行うかもしれません。たとえば、コマンド@code{find-file}には@code{interactive}指定があり、これはミニバッファーを使用してファイル名を読み取ることを指定します。@code{find-file}の関数bodyはミニバッファーを使用しないので、Lispコードから関数として@code{find-file}を呼び出す場合は通常のLisp関数引数としてファイル名を文字列で与えなければなりません。

  コマンドがキーボードマクロ(文字列やベクター)の場合、Emacsは@code{execute-kbd-macro}を使用してそれを実行します(@ref{Keyboard
Macros}を参照)。

@defvar pre-command-hook
このノーマルフックはコマンドを実行する前に、エディターコマンドループにより実行される。その際、@code{this-command}
には実行しようとするコマンドが含まれ、@code{last-command}には前のコマンドが記述される。@ref{Command Loop
Info}を参照のこと。
@end defvar

@defvar post-command-hook
このノーマルフックはコマンドを実行した後(quitやエラーにより早期に終了させられたコマンドを含む)に、エディターコマンドループにより実行される。その際、@code{this-command}は正に実行されたコマンドを参照し、@code{last-command}は前に実行されたコマンドを参照する。

このフックはEmacsが最初にコマンドループにエンターしたときにも実行される(その時点では@code{this-command}と@code{last-command}はどちらも@code{nil})。
@end defvar

  @code{pre-command-hook}および@code{post-command-hook}の実行中、quitは抑制されます。これらのフックのどれか1つを実行中にエラーが発生した場合、そのエラーはフックの実行を終了させません。そのかわりにエラーは黙殺され、エラーが発生した関数はそのフックから取り除かれます。

  Emacsサーバー(@ref{Emacs Server,,, emacs, The GNU Emacs
Manual}を参照)に届くリクエストは、キーボードコマンドが行うのと同じように、これらの2つのフックを実行します。

@node Defining Commands
@section Defining Commands
@cindex defining commands
@cindex commands, defining
@cindex functions, making them interactive
@cindex interactive function

  スペシャルフォーム@code{interactive}はLisp関数をコマンドに変えます。@code{interactive}フォームは関数ボディーのトップレベルに置かなければならず、通常はボディー内の最初のフォームとして記述されます。これはラムダ式(@ref{Lambda
Expressions}を参照)と@code{defun}(@ref{Defining
Functions}を参照)の両方を受け入れます。このフォームは、その関数が実際に実行される間は何も行いません。このフォームの存在はフラグとしての役割りをもち、Emacsコマンドループにたいしてその関数がインタラクティブに呼び出せることを告げます。@code{interactive}フォームの引数は、インタラクティブな呼び出しが引数を読み取る方法を指定します。

@cindex @code{interactive-form} property
  @code{interactive}フォームのかわりに、関数シンボルの@code{interactive-form}プロパティで指定されることもあります。このプロパティが非@code{nil}値の場合、関数ボディー内の@code{interactive}フォームより優先されます。この機能はほとんど使用されません。

@cindex @code{interactive-only} property
  インタラクティブに呼び出されることだけを意図していて、決してLispから直接呼び出されない関数が時折あります。この場合は、その関数の@code{interactive-only}プロパティに非@code{nil}を与えます。これにより、そのコマンドがLispから呼び出された場合に、バイトコンパイラーが警告を発します。このプロパティの値には、文字列、@code{t}、または任意のシンボルを指定できます。文字列の場合、それはバイトコンパイラーによる警告内で直接使用されます(最初は大文字でなくピリオドで終端される文字列。たとえば``use
@dots{} instead.'')。シンボルの場合、それはLispコード内で使用されるかわりの関数です。

@menu
* Using Interactive::        @code{interactive}にたいする一般的なルール。
* Interactive Codes::        さまざまな方法で引数を読み取る標準的な文字のコード。
* Interactive Examples::     インタラクティブ引数を読み取る方法の例。
* Generic Commands::         コマンド候補からの選択。
@end menu

@node Using Interactive
@subsection Using @code{interactive}
@cindex arguments, interactive entry
@cindex interactive spec, using

  このセクションでは、Lisp関数をインタラクティブに呼び出し可能なコマンドにする@code{interactive}フォームの記述方法と、コマンドの@code{interactive}フォームの検証方法について説明します。

@defspec interactive arg-descriptor
このスペシャルフォームは関数がコマンドであり、したがって(@kbd{M-x}を通じて、またはそのコマンドにバインドされたキーシーケンスのエンターすることにより)インタラクティブに呼び出されるかもしれないことを宣言する。引数@var{arg-descriptor}は、そのコマンドがインタラクティブに呼び出されたときに引数を計算する方法を宣言する。

コマンドは他の関数と同じようにLisp関数から呼び出されるかもしれないが、その場合呼び出し側は引数を提供し、@var{arg-descriptor}は効果をもたない。

@cindex @code{interactive-form}, symbol property
@code{interactive}フォームは関数ボディー内のトップレベルに置くか、関数シンボルの@code{interactive-form}プロパティ((@ref{Symbol
Properties})を参照)になければならない。これはコマンドループが関数を呼び出す前にinteractiveフォームを調べることにより効果をもつ(@ref{Interactive
Call}を参照)。一度関数が呼び出されると関数ボディー内のすべてのフォームが実行される。このときボディー内に@code{interactive}フォームが出現しても、そのフォームは引数の評価さえされず、単に@code{nil}をリターンする。

慣例により、@code{interactive}フォームは関数ボディー内の最初のトップレベルフォームとするべきである。@code{interactive}フォームがシンボルの@code{interactive-form}プロパティと関数ボディーの両方に存在する場合は、前者が優先される。@code{interactive-form}フォームは既存の関数にinteractiveフォームを追加したり、その関数を再定義することなく引数をインタラクティブに処理する方法を変更するために使用できる。
@end defspec

引数@var{arg-descriptor}には3つの可能性があります:

@itemize @bullet
@item
省略、または@code{nil}の場合、コマンドは引数なしで呼び出される。コマンドが1つ以上の引数を要求する場合は、すぐにエラーとなる。

@item
文字列の場合、その文字列の内容は改行で区切られた要素シーケンスであり、1つの要素が1つの引数に対応する@footnote{いくつかの要素は実際に2つの引数を提供します。}。各要素はコード文字(@ref{Interactive
Codes}を参照)と、オプションでその後のプロンプト(ある文字はコード文字として使用され、コード文字としては無視されるものもある)により構成される。以下は例である:

@smallexample
(interactive "P\nbFrobnicate buffer: ")
@end smallexample

@noindent
コード文字@samp{P}はそのコマンドの1つ目の引数をrawコマンドプレフィクス(@ref{Prefix Command
Arguments}を参照)にセットする。@samp{bFrobnicate buffer: }は、ユーザーに@samp{Frobnicate
buffer: }のプロンプトを示して既存のバッファーの名前の入力を促し、これは2つ目かつ最後の引数になる。

プロンプト文字列には、プロンプト内の前の引数(1つ目の引数から始まる)の値を含めるために@samp{%}を使用できる。これは@code{format}(@ref{Formatting
Strings}を参照)を使用して行われる。たとえば、以下は既存のバッファーの名前を読み取り、その後にそのバッファーに与える新たな名前を読み取る例である:

@smallexample
@group
(interactive "bBuffer to rename: \nsRename buffer %s to: ")
@end group
@end smallexample

@cindex @samp{*} in @code{interactive}
@cindex read-only buffers in interactive
文字列の先頭@samp{*}がある場合、そのバッファーが読み取り専用の場合にエラーがシグナルされる。

@cindex @samp{@@} in @code{interactive}
文字列の先頭が@samp{@@}で、そのコマンドの呼び出しに使用されたキーシーケンスに何らかのマウスイベントが含まれる場合は、そのコマンドを実行する前に、それらのうち最初のイベントに結びつくウィンドウが選択される。

@cindex @samp{^} in @code{interactive}
@cindex shift-selection, and @code{interactive} spec
文字列の先頭が@samp{^}で、そのコマンドが@dfn{シフト転換(shift-translation)}を通じて呼び出された場合は、そのコマンドを実行する前に、マークをセットして一時的にリージョンをアクティブにするか、すでにアクティブなリージョンを拡張する。コマンドがシフト転換なしで呼び出されて、リージョンが一時的にアクティブな場合は、コマンドを実行する前に、そのリージョンを非アクティブにする。シフト転換は@code{shift-select-mode}により、ユーザーレベルで制御される。@ref{Shift
Selection,,, emacs, The GNU Emacs Manual}を参照のこと。

@samp{*}、@samp{@@}、@code{^}はともに使用でき、その場合は順序に意味はない。実際の引数の読み取りは残りのプロンプト文字列(@samp{*}、@samp{@@}、@code{^}以外の最初の文字以降)により制御される。

@item
文字列ではないLisp式の場合は、そのコマンドに渡す引数リストを取得するために評価されるフォームである。このフォームは通常、ユーザーから入力を読み取るためにさまざまな関数を呼び出し、それにはほとんどの場合はミニバッファー(@ref{Minibuffers}を参照)を通じてか、キーボードから直接読み取りを行う(@ref{Reading
Input}を参照)。

引数値としてポイントやマークを提供するのも一般的だが、何かを行い@emph{かつ}(ミニバッファー使用の有無に関わらず)入力を読み取る場合は、読み取りの前にポイント値またはマーク値の整数を確実に取得しておくこと。カレントバッファーはサブプロセスの出力を受信するかもしれず、コマンドが入力を待つ間にサブプロセス出力が到着した場合、ポイントおよびマークの再配置が起こり得る。

以下は行っては@emph{いけない}例である:

@smallexample
(interactive
 (list (region-beginning) (region-end)
       (read-string "Foo: " nil 'my-history)))
@end smallexample

@noindent
これにたいし、以下はキーボード入力を読み取った後にポイントとマークを調べることにより、上記の問題を避ける例である:

@smallexample
(interactive
 (let ((string (read-string "Foo: " nil 'my-history)))
   (list (region-beginning) (region-end) string)))
@end smallexample

@strong{警告:}
引数値にはプリントや読み取りが不可能なデータ型を含めるべきではない。いくつかの機能は後続のセッションに読み込ませるために@code{command-history}をファイルに保存する。コマンドの引数に@samp{#<@dots{}>}構文を使用してプリントされるデータ型が含まれる場合、それらの機能は動作しないだろう。

しかしこれには少数の例外がある。@code{(point)}、@code{(mark)}、@code{(region-beginning)}、@code{(region-end)}などの一連の式に限定して使用するのに問題はない。なぜならEmacsはこれらを特別に認識して、コマンドヒストリー内に(値ではなく)その式を配すからである。記述した式がこれらの例外に含まれるかどうか確認するには、コマンドを実行した後に@code{(car
command-history)}を調べればよい。
@end itemize

@cindex examining the @code{interactive} form
@defun interactive-form function
この関数は@var{function}の@code{interactive}フォームをリターンする。@var{function}がインタラクティブに呼び出し可能な関数(@ref{Interactive
Call}を参照)の場合、値はそのコマンドの引数を計算する方法を指定する@code{interactive}フォーム(@code{(interactive
@var{spec})})である。それ以外では値は@code{nil}である。@var{function}がシンボルの場合は、そのシンボルの関数定義が使用される。
@end defun

@node Interactive Codes
@subsection Code Characters for @code{interactive}
@cindex interactive code description
@cindex description for interactive codes
@cindex codes, interactive, description of
@cindex characters for interactive codes

  ここで説明されているコード文字には、以下で定義されるいくつかのキーワードが含まれています:

@table @b
@item Completion
@cindex interactive completion
補完を提供する。@key{TAB}、@key{SPC}、@key{RET}は@code{completing-read}(@ref{Completion}を参照)を使用して引数を読み取り、名前の補完を行う。@kbd{?}で利用可能な補完リストを表示する。

@item Existing
既存オブジェクトの名前を要求する。無効な名前は受け付けられない。カレント入力が有効でない場合、ミニバッファーをexitするコマンドはexitしない。

@item Default
@cindex default argument string
ユーザーがテキストを何もエンターしなかった場合は、ある種のデフォルト値が使用される。デフォルトはコード文字に依存する。

@item No I/O
このコード文字は入力を読み取らずに引数を計算する。したがってプロンプト文字列を使用せず、与えられたプロンプト文字列は無視される。

たとえこのコード文字がプロンプト文字列を使用しなくても、これが文字列内で最後のコード文字でない場合は、その後に改行を付けなければならない。

@item Prompt
コード文字の直後にプロンプトが続く。プロンプトの終端は文字列の終端、または改行。

@item Special
このコード文字はインタラクティブ文字列の先頭にあるときのみ意味があり、プロンプトおよび改行を要求しない。単一の独立した文字である。
@end table

@cindex reading interactive arguments
  以下は@code{interactive}とともに使用されるコード文字です:

@table @samp
@item *
カレントバッファーが読み取り専用の場合はエラーをシグナルする。[Special]

@item @@
このコマンドを呼び出したキーシーケンス内の最初のマウスイベントに関連するウィンドウを選択する。[Special]

@item ^
シフト転換を通じてコマンドが呼び出された場合はコマンドを実行する前に、マークをセットして一時的にリージョンをアクティブにするか、すでにリージョンがアクティブな場合はリージョンを拡張する。シフト転換を通じずにコマンドが呼び出され、リージョンが一時的にアクティブな場合は、コマンドを実行する前にそのリージョンを非アクティブにする。[Special]

@item a
関数名(たとえば@code{fboundp}を満足するシンボル)。[Existing]、[Completion]、[Prompt]

@item b
既存バッファーの名前。
The name of an existing buffer.
デフォルトではカレントバッファー(@ref{Buffers}を参照)の名前を使用する。[Existing]、[Completion]、[Default]、[Prompt]

@item B
バッファー名。そのバッファーが存在する必要はない。デフォルトではカレントバッファーではなくもっとも最近使用されたバッファーの名前を使用する。[Completion]、[Default]、[Prompt]

@item c
文字。カーソルはエコーエリアに移動しない。[Prompt]

@item C
コマンド名(たとえば@code{commandp}を満足するシンボル)。[Existing]、[Completion]、[Prompt]

@item d
@cindex position argument
ポイント位置の整数(@ref{Point}を参照)。[No I/O]

@item D
ディレクトリー名。デフォルトはカレントバッファーのカレントのデフォルトディレクトリー@code{default-directory}(@ref{File
Name Expansion}を参照)。[Existing]、[Completion]、[Default]、[Prompt]

@item e
そのコマンドを呼び出したキーシーケンス内の1つ目、または2つ目の非キーボードイベント。より正確には、@samp{e}はリストとしてイベントを取得するので、リスト内のデータを調べることができる。@ref{Input
Events}を参照のこと。[No I/O]

@samp{e}はマウスイベント、および特別なシステムイベント(@ref{Misc
Events}を参照)にたいして使用する。コマンドが受け取るイベントリストは、そのイベントに依存する。@ref{Input
Events}ではそれぞれのイベントのリスト形式を、対応するサブセクションでそれぞれ説明しているので、参照のこと。

1つのコマンドのinteractive仕様の中で、@samp{e}を複数回使用できる。そのコマンドを呼び出したキーシーケンスがイベント@var{n}(リスト)をもつ場合は、@samp{e}の@var{n}番目がそのイベントを提供する。関数キーや@acronym{ASCII}文字のようなリスト以外のイベントは、@samp{e}に関連するイベントとしてカウントされない。

@item f
既存ファイルのファイル名(@ref{File
Names}を参照)。デフォルトのディレクトリーは@code{default-directory}。[Existing]、[Completion]、[Default]、[Prompt]

@item F
ファイル名。ファイルが存在している必要はない。[Completion]、[Default]、[Prompt]

@item G
ファイル名。ファイルが存在している必要はない。ユーザーがディレクトリー名だけをエンターした場合、値はそのディレクトリー名となり、そのディレクトリー名にファイル名は追加されない。[Completion]、[Default]、[Prompt]

@item i
無関係な引数。このコード文字は引数値として常に@code{nil}を与える。[No I/O]

@item k
キーシーケンス(@ref{Key
Sequences}を参照)。これはカレントキーマップ内でコマンド(または未定義のコマンド)が見つかるまで、イベントを読み取り続ける。キーシーケンス引数は文字列、またはベクターで表される。カーソルはエコーエリアに移動しない。[Prompt]

@samp{k}が(マウスの)down-eventで終わるキーシーケンスを読み取った場合は、後続の(マウスの)up-eventも読み取り、それを捨てる。コード文字@samp{U}により、up-eventへのアクセスを得ることができる。

この種の入力は、@code{describe-key}や@code{global-set-key}のようなコマンドにより使用される。

@item K
キーシーケンス。その定義は変更されることを意図している。これは@samp{k}と同じように機能するが、キーシーケンス内の最後の入力イベントにたいして、通常(必要なら)使用される未定義キーから定義済みキーへの変換を抑制する。

@item m
@cindex marker argument
マーク位置の整数。[No I/O]

@item M
任意のテキスト。ミニバッファー内でカレントバッファーの入力メソッド(@ref{Input Methods,,, emacs, The GNU Emacs
Manual}を参照)を使用して読み取りを行い、それを文字列でリターンする。[Prompt]

@item n
数字。ミニバッファーで読み取られる。入力が数字でない場合、ユーザーは再試行する必要がある。@samp{n}は決してプレフィクス引数を使用しない。[Prompt]

@item N
数引数(numeric prefix
argument)。ただしプレフィクス引数がない場合は、@kbd{n}のように数字を読み取る。値は常に数字。@ref{Prefix Command
Arguments}を参照のこと。[Prompt]

@item p
@cindex numeric prefix argument usage
数引数()これは小文字の@samp{p}であることに注意)。[No I/O]

@item P
@cindex raw prefix argument usage
rawプレフィクス引数(これは大文字の@samp{P}であることに注意)。[No I/O]

@item r
@cindex region argument
2つの数引数(ポイントとマーク)。小さいほうが先。これは1つではなく連続する2つの引数を指定する唯一のコード文字である。[No I/O]

@item s
任意のテキスト。ミニバッファー内で読み取りを行い文字列としてリターンする(@ref{Text from
Minibuffer}を参照)。@kbd{C-j}か@key{RET}で入力を終端する(これらの文字を入力に含めるために@kbd{C-q}が使用されるかもしれない)。[Prompt]

@item S
インターン済みのシンボル。名前はミニバッファー内で読み取られる。@kbd{C-j}か@key{RET}で入力を終端する。ここでは、その他の通常はシンボルを終端する文字(たとえば空白文字、丸カッコ、角カッコ)では終端されない。[Prompt]

@item U
キーシーケンス、または@code{nil}。@samp{k}(または@samp{K})が読み取った後に、(もしあれば)捨てられる(マウスの)up-eventを取得するために、引数@samp{k}(または@samp{K})の後で使用され得る。捨てられたup-eventが存在しない場合、@samp{U}は引数として@code{nil}を提供する。[No
I/O]

@item v
ユーザーオプションとして宣言された変数(たとえば述語@code{custom-variable-p}を満足する)。これは@code{read-variable}を使用して変数を読み取る。@ref{Definition
of read-variable}を参照のこと。[Existing]、[Completion]、[Prompt]

@item x
Lispオブジェクト。そのオブジェクトの入力構文により指定され、@kbd{C-j}か@key{RET}で終端される。オブジェクトは評価されない。@ref{Object
from Minibuffer}を参照のこと。[Prompt]

@item X
@cindex evaluated expression argument
Lispフォームの値。@samp{X}は@samp{x}のように読み取りを行いフォームを評価して、その値がコマンドの引数になる。[Prompt]

@item z
コーディングシステム名(シンボル)。ユーザーがnull入力をエンターした場合、引数値は@code{nil}になる。@ref{Coding
Systems}を参照のこと。[Completion]、[Existing]、[Prompt]

@item Z
コマンドにプレフィクス引数がある場合はコーディングシステム名。プレフィクス引数がない場合、@samp{Z}は引数値として@code{nil}を提供する。[Completion]、[Existing]、[Prompt]
@end table

@node Interactive Examples
@subsection Examples of Using @code{interactive}
@cindex examples of using @code{interactive}
@cindex @code{interactive}, examples of using

  以下に@code{interactive}の例をいくつか挙げます:

@example
@group
(defun foo1 ()              ; @r{@code{foo1}は1つの引数をとり}
    (interactive)           ;   @r{単に2単語分前に移動する。}
    (forward-word 2))
     @result{} foo1
@end group

@group
(defun foo2 (n)             ; @r{@code{foo2}は引数を1つとる}
    (interactive "^p")      ;   @r{引数は数引数}
                            ; @r{@code{shift-select-mode}では、}
                            ;   @r{リージョンをアクティブにするか、拡張する}
    (forward-word (* 2 n)))
     @result{} foo2
@end group

@group
(defun foo3 (n)             ; @r{@code{foo3}は引数を1つとる}
    (interactive "nCount:") ;   @r{引数はミニバッファーで読み取られる}
    (forward-word (* 2 n)))
     @result{} foo3
@end group

@group
(defun three-b (b1 b2 b3)
  "Select three existing buffers.
Put them into three windows, selecting the last one."
@end group
    (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
    (delete-other-windows)
    (split-window (selected-window) 8)
    (switch-to-buffer b1)
    (other-window 1)
    (split-window (selected-window) 8)
    (switch-to-buffer b2)
    (other-window 1)
    (switch-to-buffer b3))
     @result{} three-b
@group
(three-b "*scratch*" "declarations.texi" "*mail*")
     @result{} nil
@end group
@end example

@node Generic Commands
@subsection Select among Command Alternatives
@cindex generic commands
@cindex alternatives, defining

マクロ@code{define-alternatives}は@dfn{ジェネリックコマンド(generic
command)}を定義するために使用できます。これらはユーザーの選択により複数の候補から選択可能なinteractive関数の実装です。

@defmac define-alternatives command &rest customizations
新たなコマンド@var{command}(シンボル)を定義する。

最初にユーザーが@kbd{M-x @var{command}
@key{RET}}を実行したとき、Emacsはコマンドが使用する実際のフォームにたいして確認を求め、その選択をカスタム変数として記録する。プレフィクス引数を使用すると、候補選択のプロセスを繰り返す。

変数@code{@var{command}-alternatives}には、@var{command}の実装候補がalistで含まれる。この変数がセットされるまで、@code{define-alternatives}は効果をもたない。

@var{customizations}が非@code{nil}の場合は、@code{defcustom}キーワード(典型的には@code{:group}および@code{:version})と、@code{@var{command}-alternatives}の宣言に追加する値により構成される候補である。
@end defmac

@node Interactive Call
@section Interactive Call
@cindex interactive call

  コマンドループはキーシーケンスをコマンドに翻訳した後、関数@code{command-execute}を使用してその関数を呼び出します。そのコマンドが関数の場合、@code{command-execute}は引数を読み取りコマンドを呼び出す@code{call-interactively}を呼び出します。自分でこれらの関数を呼び出すこともできます。

  このコンテキストにおいて用語``command''はインタラクティブにコール可能な関数(または関数likeなオブジェクト)やキーボードマクロを指すことに注意してください。つまりコマンドを呼び出すキーシーケンスのことではありません(@ref{Keymaps}を参照)。

@defun commandp object &optional for-call-interactively
この関数は@var{object}がコマンドの場合は@code{t}、それ以外は@code{nil}をリターンする。

コマンドには文字列とベクター(キーボードマクロとして扱われる)、トップレベル@code{interactive}フォーム(@ref{Using
Interactive}を参照)を含むラムダ式、そのようなラムダ式から作成されたバイトコンパイル関数オブジェクト、interactiveとして宣言(@code{autoload}の4つ目の引数が非@code{nil})されたautoloadオブジェクト、およびいくつかのプリミティブ関数が含まれる。@code{interactive-form}プロパティが非@code{nil}のシンボル、および関数定義が@code{commandp}を満足するシンボルもコマンドとされる。

@var{for-call-interactively}が非@code{nil}の場合は、@code{call-interactively}が呼び出すことができるオブジェクトにたいしてのみ@code{commandp}は@code{t}をリターンする。したがってキーボードマクロは該当しなくなる。

@code{commandp}を使用する現実的な例は、@ref{Accessing
Documentation}内の@code{documentation}を参照のこと。
@end defun

@defun call-interactively command &optional record-flag keys
この関数はinteractive呼び出し仕様にしたがって引数を取得し、インタラクティブに呼び出し可能な関数@var{command}を呼び出す。これは@var{command}がリターンするものが何であれ、それをリターンする。

たとえば、もし以下の署名をもつ関数がある場合:

@example
(defun foo (begin end)
  (interactive "r")
  ...)
@end example

以下を行うと

@example
(call-interactively 'foo)
@end example

これはリージョン(@code{point}と@code{mark})を引数として@code{foo}を呼び出すだろう。

@var{command}が関数でない、またはインタラクティブに呼び出せない(コマンドでない)場合は、エラーをシグナルする。たとえコマンドだとしても、キーボードマクロ(文字列かベクター)は、関数ではないので、許されないことに注意。@var{command}がシンボルの場合、@code{call-interactively}はそれの関数定義を使用する。

@cindex record command history
@var{record-flag}が非@code{nil}の場合は、このコマンドとコマンドの引数は無条件にリスト@code{command-history}に追加される。それ以外では、引数の読み取りにミニバッファーを使用した場合のみコマンドが追加される。@ref{Command
History}を参照のこと。

引数@var{keys}が与えられた場合、それはコマンドを呼び出すためにどのイベントを使用するかコマンドが問い合わせた場合に与えるべき、イベントシーケンスを指定するベクターである。@var{keys}が@code{nil}、または省略された場合のデフォルトは、@code{this-command-keys-vector}のリターン値である。@ref{Definition
of this-command-keys-vector}を参照のこと。
@end defun

@defun command-execute command &optional record-flag keys special
@cindex keyboard macro execution
この関数は@var{command}を実行する。引数@var{command}は述語@code{commandp}を満足しなければならない。つまりインタラクティブに呼び出し可能な関数かキーボードマクロでなければならない。

@var{command}が文字列かベクターの場合は、@code{execute-kbd-macro}により実行される。関数は@var{record-flag}および@var{keys}引数とともに@code{call-interactively}に渡される(上記参照)。

@var{command}がシンボルの場合、その位置にシンボルの関数定義が使用される。@code{autoload}定義のあるシンボルは、インタラクティブに呼び出し可能な関数お意味するよう宣言されている場合は、コマンドとして判断される。そのような宣言は、指定されたライブラリーのロードと、シンボル定義の再チェックにより処理される。

引数@var{special}が与えられた場合、それはプレフィクス引数を無視して、それをクリアーしないという意味である。これはスペシャルイベント(@ref{Special
Events}を参照)を実行する場合に使用される。
@end defun

@deffn Command execute-extended-command prefix-argument
@cindex read command name
この関数は@code{completing-read}(@ref{Completion}を参照)を使用して、ミニバッファーからコマンド名を読み取る。その後、指定されたコマンドを呼び出すために@code{command-execute}を使用する。そのコマンドがリターンするのが何であれ、それが@code{execute-extended-command}の値となる。

@cindex execute with prefix argument
そのコマンドがプレフィクス引数を求める場合は、@var{prefix-argument}のの値を受け取る。@code{execute-extended-command}がインタラクティブに呼び出された場合は、カレントのrawプレフィクス引数が@var{prefix-argument}に使用され、それが何であれ実行するコマンドに渡される。

@c !!! Should this be @kindex?
@cindex @kbd{M-x}
通常、@code{execute-extended-command}は@kbd{M-x}の定義なので、プロンプトとして文字列@w{@samp{M-x
}}を使用する(@code{execute-extended-command}を呼び出したイベントからプロンプトを受け取るほうが良いのだろうが、実装は骨が折れる)。プレフィクス引数の値の説明が、もしあれば、それもプロンプトの一部となる。

@example
@group
(execute-extended-command 3)
---------- Buffer: Minibuffer ----------
3 M-x forward-word RET
---------- Buffer: Minibuffer ----------
     @result{} t
@end group
@end example
@end deffn

@node Distinguish Interactive
@section Distinguish Interactive Calls
@cindex distinguish interactive calls
@cindex is this call interactive

  interactive呼び出しのときは、コマンドが(エコーエリア内の情報メッセージなどのような)視覚的な追加フィードバックを表示すべきときがあります。これを行うためには、3つの方法があります。その関数が@code{call-interactively}を使用して呼び出されたかどうかテストするには、オプション引数@code{print-message}を与えるとともに、interactive呼び出しで非@code{nil}となるように@code{interactive}仕様を使うのが推奨される方法です。以下は例です:

@example
(defun foo (&optional print-message)
  (interactive "p")
  (when print-message
    (message "foo")))
@end example

@noindent
数プレフィクス引数は決して@code{nil}にならないので、わたしたちは@code{"p"}を使用します。この方法で定義された関数は、キーボードマクロから呼び出されたときにメッセージを表示します。

  追加引数による上記の手法は、呼び出し側に``この呼び出しをinteractiveとして扱うように''伝えることができるので、通常は最善です。しかし、@code{called-interactively-p}.をテストすることにより、これを行うこともできます。

@defun called-interactively-p kind
この関数は、呼び出された関数が@code{call-interactively}を使用して呼び出された場合は@code{t}をリターンする。

引数@var{kind}はシンボル@code{interactive}かシンボル@code{any}のどちらかである。これが@code{interactive}の場合、@code{called-interactively-p}はユーザーから直接呼び出しが行われたとき
---
たとえば関数呼び出しにバインドされたキーシーケンスをユーザーがタイプした場合がそれに該当するが、ユーザーがその関数を呼び出すキーボードマクロ(@ref{Keyboard
Macros}を参照)を実行中した場合は@emph{該当しない} ---
だけ@code{t}をリターンする@var{kind}が@code{any}の場合、@code{called-interactively-p}はキーボードマクロを含む任意の種類のinteractive呼び出しにたいして@code{t}をリターンする。

疑わしい場合は@code{any}を使用すること。@code{interactive}の使用が正しいと解っているのは、関数が実行中に役に立つメッセージを表示するかどうか判断が必要な場合だけである。

Lisp評価(または@code{apply}や@code{funcall}))を通じて呼び出された、または場合、関数は決してインタラクティブに呼び出されたとは判断されない。
@end defun

@noindent
以下は@code{called-interactively-p}を使用する例である:

@example
@group
(defun foo ()
  (interactive)
  (when (called-interactively-p 'any)
    (message "Interactive!")
    'foo-called-interactively))
@end group

@group
;; @r{@kbd{M-x foo}とタイプする}
     @print{} Interactive!
@end group

@group
(foo)
     @result{} nil
@end group
@end example

@noindent
以下は@code{called-interactively-p}の直接呼び出しと間接呼び出しを比較した例である。

@example
@group
(defun bar ()
  (interactive)
  (message "%s" (list (foo) (called-interactively-p 'any))))
@end group

@group
;; @r{@kbd{M-x bar}とタイプする}
     @print{} (nil t)
@end group
@end example

@node Command Loop Info
@section Information from the Command Loop
@cindex command loop variables

エディターコマンドループは、自分自身と実行するコマンドのために、いくつかのLisp変数にステータス記録を保持します。@code{this-command}および@code{last-command}以外は、一般的にこれらの変数をLispプログラム内で変更するのは、良いアイデアではありません。

@defvar last-command
この変数は、コマンドループにより実行された以前のコマンド(前にカレントだったコマンド)の名前を記録する。値は通常、関数定義をもつシンボルだが、その保証はない。

コマンドがコマンドループからリターンするとき、@code{this-command}から値がコピーされる。ただしそのコマンドが、後続のコマンドにたいしてプレフィクス引数を指定されたときを除く。

この変数は常にカレント端末にたいしてローカルであり、バッファーローカルにできない。@ref{Multiple Terminals}を参照のこと。
@end defvar

@defvar real-last-command
この変数はEmacsにより@code{last-command}と同様にセットアップされるが、Lispプログラムから決して変更されない。
@end defvar

@defvar last-repeatable-command
この変数は、入力イベントと一部としではなく、もっとも最近実行されたコマンドを格納する。これはコマンド@code{repeat}が再実行を試みるコマンドである。@ref{Repeating,,,
emacs, The GNU Emacs Manual}を参照のこと。
@end defvar

@defvar this-command
@cindex current command
この変数は、コマンドループにより現在実行中のコマンドの名前を記録する。@code{last-command}と同様、通常は関数定義をもつシンボルである。

コマンドループはコマンドを実行する直前にこの変数をセットして、(そのコマンドが後続のコマンドのプレフィクス引数を指定しない場合)そのコマンドが終了したときに、その値を@code{last-command}内にコピーする。

@cindex kill command repetition
いくつかのコマンドは、次に実行されるコマンドが何であれ、それにたいするフラグとして、実行中の間この変数をセットする。特にテキストをkillする関数は@code{this-command}を@code{kill-region}にセットするので、直後に実行された任意のkillコマンドは、killしたテキストを前にkillされたテキストに追加すべきことが解かるだろう。
@end defvar

特定のコマンドにおいて、エラーが発生した場合に前のコマンドとして認識されたくない場合は、これを防ぐようにそのコマンドをコーディングしなければならない。これを行う1つの方法は、以下のようにコマンドの最初で@code{this-command}に@code{t}をセットして、最後に@code{this-command}に正しい値をセットする方法である:

@example
(defun foo (args@dots{})
  (interactive @dots{})
  (let ((old-this-command this-command))
    (setq this-command t)
    @r{@dots{} 処理を行う @dots{}}
    (setq this-command old-this-command)))
@end example

@noindent
エラーの場合、@code{let}は古い値をリストアするので、わたしたちは@code{let}で@code{this-command}をバインドしない。この場合における@code{let}の機能は、わたしたちが避けたいと思っていることを正確に行ってしまうだろう。

@defvar this-original-command
コマンドのリマップ(@ref{Remapping
Commands}を参照)が発生したときを除き、これは@code{this-command}と同じ値をもつ。リマップが発生した場合、@code{this-command}は実際に実行されたコマンド、@code{this-original-command}は実行を指定されたが他のコマンドにリマップされたコマンドを与える。
@end defvar

@defun this-command-keys
この関数は、現在のコマンドを呼び出したキーシーケンスと、加えてそのコマンドにたいするプレフィクス引数を生成した前のコマンドを含む文字列またはベクターをリターンする。@code{read-event}を使用するコマンドにより、タイムアウトせずに読み取られた任意のイベントは最後に加えられる。

しかし、そのコマンドが@code{read-key-sequence}を呼び出していた場合は、最後に読み取られたキーシーケンスをリターンする。@ref{Key
Sequence Input}を参照のこと。シーケンス内のすべてのイベントが文字列として適当な文字の場合は、文字列が値になる。@ref{Input
Events}を参照のこと。

@example
@group
(this-command-keys)
;; @r{これを評価するために@kbd{C-u C-x C-e}を使用すると、}
     @result{} "^U^X^E"
@end group
@end example
@end defun

@defun this-command-keys-vector
@anchor{Definition of this-command-keys-vector}
@code{this-command-keys}と同様だが、常にベクターでイベントをリターンするので、入力イベントを文字列内に格納する複雑さを処理する必要がない(@ref{Strings
of Events}を参照)。
@end defun

@defun clear-this-command-keys &optional keep-record
この関数は、@code{this-command-keys}がリターンするイベントテーブルを空にする。@var{keep-record}が@code{nil}の場合は、その後に関数@code{recent-keys}(@ref{Recording
Input})がリターンするレコードも空にする。これは特定のケースにおいて、パスワードを読み取った後、次のコマンドの一部として不用意にパスワードがエコーされるのを防ぐために有用である。
@end defun

@defvar last-nonmenu-event
この変数はキーシーケンス(マウスメニューからのイベントは勘定しない)の一部として読み取られた最後の入力イベントを保持する。

この変数の1つの使い方は、@code{x-popup-menu}にたいしてどこにメニューをポップアップすべきか告げる場合である。これは内部的に@code{y-or-n-p}(@ref{Yes-or-No
Queries}を参照)にも使用されている。
@end defvar

@defvar last-command-event
この変数には、コマンドの一部としてコマンドループに読み取られた、最後の入力イベントがセットされる。この変数は主に、@code{self-insert-command}内でどの文字が挿入されたか判断するために使用されている。

@example
@group
last-command-event
;; @r{これを評価するために@kbd{C-u C-x C-e}を使用すると、}
     @result{} 5
@end group
@end example

@noindent
@kbd{C-e}の@acronym{ASCII}コードの5が値になる。
@end defvar

@defvar last-event-frame
この変数は、最後の入力イベントが送られたフレームを記録する。これは通常、そのイベントが生成されたときに選択されていたフレームだが、そのフレームの入力が他のフレームにリダイレクトされていた場合は、そのリダイレクトされていたフレームが値となる。@ref{Input
Focus}を参照のこと。

最後のイベントがキーボードマクロ由来の場合、値は@code{macro}になる。
@end defvar

@node Adjusting Point
@section Adjusting Point After Commands
@cindex adjusting point
@cindex invisible/intangible text, and point
@cindex @code{display} property, and point display
@cindex @code{composition} property, and point display

  プロパティ@code{display}や@code{composition}をｍつテキストや、非表示のテキストシーケンスの中間でポイント値を表示するのは、簡単ではありません。したがって、コマンドが終了した後にコマンドループにリターンするとき、そのようなシーケンス中にポイントがある場合、コマンドループは通常ポイントをそのようなシーケンスの端に移動します。

  変数@code{disable-point-adjustment}をセットすることにより、コマンドはこの機能を抑制できます:

@defvar disable-point-adjustment
この変数が非@code{nil}の場合は、コマンドがコマンドループにリターンするとき、コマンドループはこれらのテキストプロパティをチェックせず、これらのプロパティをもつシーケンスの外にポイントを移動しない。

コマンドループはそれぞれのコマンドを実行する前にこの変数を@code{nil}にセットするので、あるコマンドがこれをセットしても、効果が適用されるのはそのコマンドにたいしてだけである。
@end defvar

@defvar global-disable-point-adjustment
この変数を非@code{nil}にセットした場合、これらのシーケンス外にポイントを移動する機能は、完全にオフになる。
@end defvar

@node Input Events
@section Input Events
@cindex events
@cindex input events

Emacsコマンドループは@dfn{入力イベント(input
events)}のシーケンスを読み取ります。入力イベントとは、キーボードやマウスのアクティビティ、またはEmacsに送られるシステムイベントを表します。キーボードアクティビティにたいするイベントは文字、またはシンボルです。それ以外のイベントは、常にリストになります。このセクションでは、入力イベントの表現と意味について詳細を説明します。

@defun eventp object
この関数は、@var{object}が入力イベント、またはイベント型の場合は、非@code{nil}をリターンする。

イベント、またはイベント型として任意のシンボルが使用されるかもしれないことに注意。@code{eventp}は、あるシンボルがLispコードによりイベントとして使用されることを意図しているか否か区別できない。そのかわりに、カレントEmacsセッション内で、そのシンボルが入力として読み取られたイベント内で実際に使用されているか否かを区別する。シンボルがまだそのように使用されていない場合、@code{eventp}は@code{nil}をリターンする。
@end defun

@menu
* Keyboard Events::          通常の文字 --- 
                               自身にシンボルされるキー。
* Function Keys::            ファンクションキー --- 
                               名前をもつがシンボルではない。
* Mouse Events::             マウスイベントの概観。
* Click Events::             マウスボタンのプッシュとリリース。
* Drag Events::              ボタンをリリースする前のマウス移動。
* Button-Down Events::       ボタンがプッシュされて、まだリリースされていない状態。
* Repeat Events::            ダブル、トリプルのクリック(またはドラッグ、ダウン)
* Motion Events::            ボタンを押さずに、マウスだけを移動する。
* Focus Events::             フレーム間のマウス移動。
* Misc Events::              システムが生成可能なその他のイベント。
* Event Examples::           マウスイベントの例。
* Classifying Events::       イベントシンボル内の修飾キーを見つける。イベント型。
* Accessing Mouse::          マウスイベントから情報抽出する関数。
* Accessing Scroll::         スクロールバーイベントから情報取得する関数。
* Strings of Events::        文字列内にキーボード文字イベントを配すための特別な配慮。
@end menu

@node Keyboard Events
@subsection Keyboard Events
@cindex keyboard events

キーボードから取得できる入力には2つの種類があります。それは通常のキーとファンクションキーです。通常のキーは文字に対応し、それらが生成するイベントはLisp内では文字で表現されます。文字イベントのイベント型は文字自身(整数)です。@ref{Classifying
Events}を参照してください。

@cindex modifier bits (of input character)
@cindex basic code (of input character)
入力文字イベントは0から524287までの@dfn{基本コード(basic code)}に加えて、以下の@dfn{修飾ビット(modifier
bits)}の一部、またはすべてにより構成されます:

@table @asis
@item meta
文字コードのビット
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
はメタキーが押下された状態で文字がタイプされたことを示す。

@item control
文字コードのビット
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
は非@acronym{ASCII}コントロール文字を示す。

@kbd{C-a}のような非@sc{ascii}コントロール文字は、自身が特別な基本コードをもつため、それらを示すためにEmacsは特別なビットを必要としない。つまり@kbd{C-a}のコードは単なる1である。

しかし、@kbd{%}のような非@acronym{ASCII}とコントロールを組み合わせてタイプした場合、取得される数値は@kbd{%}に
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
を加えた値となる(端末が非@acronym{ASCII}コントロール文字をサポートすると仮定する)。

@item shift
文字コードのビット
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
はシフトキーが押下された状態で@acronym{ASCII}コントロール文字がタイプされたことを示す。

アルファベット文字にたいしては、基本コード自身が大文字か小文字かを示す。数字と句読点文字にたいしてシフトキーは、異なる基本コードをもつ完全に違う文字を選択する。可能な限り@acronym{ASCII}文字として保つために、Emacsはこれらの文字にたいしてビット
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
を使用しない。

しかし、@acronym{ASCII}は@kbd{C-A}と@kbd{C-a}を区別する方法を提供しないので、Emacsは@kbd{C-A}にたいしてビット
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
を使用し、@kbd{C-a}には使用しない。

@item hyper
文字コードのビット
@tex
@math{2^{24}}
@end tex
@ifnottex
2**24
@end ifnottex
はハイパーキーが押下された状態で文字がタイプされたことを示す。

@item super
文字コードのビット
@tex
@math{2^{23}}
@end tex
@ifnottex
2**23
@end ifnottex
はスーパーキーが押下された状態で文字がタイプされたことを示す。

@item alt
文字コードのビット
@tex
@math{2^{22}}
@end tex
@ifnottex
2**22
@end ifnottex
はアルトキーが押下された状態で文字がタイプされたことを示す(ほとんどのキーボードで@key{Alt}とラベルされたキーは、実際にはアルトキーではなくメタキーとして扱われる)。
@end table

  プログラム内での特定のビット数値の記述は避けるのが最善の方法です。文字の修飾ビットをテストするためには、関数@code{event-modifiers}(@ref{Classifying
Events}を参照)を使用してください。キーバインディングを作成するときは、修飾ビットつきの文字にたいする読み取り構文を使用できます(@samp{\C-}、@samp{\M-}、...など)。@code{define-key}でのキーバインディング作成では、文字を指定するために@code{(control
hyper ?x)}のようなリストを使用できます(@ref{Changing Key
Bindings}を参照)。関数@code{event-convert-list}は、そのようなリストをイベント型に変換します(@ref{Classifying
Events}を参照)。

@node Function Keys
@subsection Function Keys

@cindex function keys
ほとんどのキーボードには@dfn{ファンクションキー(function
keys)}があります。これは名前、または文字以外のシンボルをもつキーです。Emacs
Lispではファンクションキーはシンボルとして表現されます。そのシンボル名はファンクションキーのラベルの小文字です。たとえば@key{F1}とラベルされたキーを押下すると、シンボル@code{f1}で表される入力イベントが生成されます。

ファンクションキーのイベント型は、イベントシンボルそれ自身です。@ref{Classifying Events}を参照してください。

ファンクションキーにたいするシンボルネーミングの慣習には、以下のような特別なケースがいくつかあります:

@table @asis
@item @code{backspace}、@code{tab}、@code{newline}、@code{return}、@code{delete}
これらのキーは、ほとんどのキーボードにおいて特別にキーをもつ、一般的な@acronym{ASCII}コントロール文字に対応する。

@acronym{ASCII}では@kbd{C-i}と@key{TAB}は同じ文字である。端末がこれらを区別できる場合、Emacsは前者を整数の9、後者をシンボル@code{tab}で表現することにより、Lispプログラムにこれらの違いを伝える。

ほとんどの場合、これら2つを区別するのは役に立たない。そのため@code{local-function-key-map}(@ref{Translation
Keymaps}を参照)は@code{tab}を9にマップするようセットアップされている。したがって文字コード9(文字@kbd{C-i})へのキーバインディングは@code{tab}にも適用される。このグループ内の他のシンボルも同様である。関数@code{read-char}が、これらのイベントを文字に変換する場合も同様である。

@acronym{ASCII}では、@key{BS}は実際は@kbd{C-h}である。しかし@code{backspace}は文字コード8(@key{BS})ではなく、文字コード127(@key{DEL})に変換される。ほとんどのユーザーにとって、これは好ましいだろう。

@item @code{left}、@code{up}、@code{right}、@code{down}
矢印カーソルキー
@item @code{kp-add}、@code{kp-decimal}、@code{kp-divide}、@dots{}
キーパッドキー(標準的なキーボードにおいては右側にある)。
@item @code{kp-0}、@code{kp-1}、@dots{}
キーパッド数字キー。
@item @code{kp-f1}、@code{kp-f2}、@code{kp-f3}、@code{kp-f4}
キーパッドPFキー。
@item @code{kp-home}、@code{kp-left}、@code{kp-up}、@code{kp-right}、@code{kp-down}
キーパッド矢印キー。Emacsは通常これらを非キーパッドのキー@code{home}、@code{left}、@dots{}に変換する。
@item @code{kp-prior}、@code{kp-next}、@code{kp-end}、@code{kp-begin}、@code{kp-insert}、@code{kp-delete}
通常は他の箇所にあるキーと重複するキーパッド追加キー。Emacsは通常これらを同じような名前の非キーパッドキーに変換する。
@end table

ファンクションキーにたいしても修飾キー@key{ALT}、@key{CTRL}、@key{HYPER}、@key{META}、@key{SHIFT}、@key{SUPER}を使用できます。シンボル名のプレフィクスとしてこれらを表します:

@table @samp
@item A-
アルト修飾。
@item C-
コントロール修飾。
@item H-
ハイパー修飾。
@item M-
メタ修飾。
@item S-
シフト修飾。
@item s-
スーパー修飾。
@end table

したがって、@key{META}を押下した場合の@key{F3}キーにたいするシンボルは@code{M-f3}になります。複雑のプレフィクスを使用する場合は、アルファベット順に記述することを推奨します。とはいえ、キーバインディングが修飾されたファンクションキーを探す際、引数の順序は関係ありません。

@node Mouse Events
@subsection Mouse Events

Emacsは4つの種類のマウスイベントをサポートします。それはクリックイベント、ドラッグイベント、ボタンダウンイベント、モーションイベントです。すべてのマウスイベントはリストで表現されます。このリストの@sc{car}はイベント型です。イベント型はどのマウスボタンが関与するのか、それにたいしてどの修飾キーが使用されたかを示します。イベント型によりダブル、あるいはトリプルでボタンが押されたかを区別することもできます(@ref{Repeat
Events}を参照)。残りのリスト要素は、位置と時間の情報を提供します。

キーの照合においては、イベント型だけが問題になります。2つのイベントが同じコマンドを実行するためには、同じイベント型が必要です。実行されるコマンドはinteractiveのコード@samp{e}を使用して、これらのイベントの完全な値にアクセスできます。@ref{Interactive
Codes}を参照してください。

マウスイベントで開始されたキーシーケンスはカレントバッファーではなく、マウスのあったウィンドウ内のバッファーのキーマップを使用して読み取られます。これはウィンドウ内でクリックすることによりそのウィンドウやそのウィンドウのバッファーが選択されることを意味しません。つまり、それは完全にそのキーシーケンスのコマンドバインディングの制御下にあるのです。

@node Click Events
@subsection Click Events
@cindex click event
@cindex mouse click event

ユーザーが同じ場所でマウスボタンを押してからリリース(release:
離す)すると、@dfn{click}イベントが生成されます。すべてのマウスクリックイベントは同じフォーマットを共有します:

@example
(@var{event-type} @var{position} @var{click-count})
@end example

@table @asis
@item @var{event-type}
これはマウスボタンが使用されたことを示す。これはシンボル@code{mouse-1}、@code{mouse-2}、@dots{}のうちのどれかで、マウスボタンは左から右に番号が付される。

ファンクションキーにたいして行うのと同様にアルト、コントロール、ハイパー、メタ、シフト、スーパーの修飾にたいしてプレフィクス@samp{A-}、@samp{C-}、@samp{H-}、@samp{M-}、@samp{S-}、@samp{s-}も使用できる。

このシンボルは、イベントのイベント型の役割りももつ。イベントのキーバインディングはこれらの型により示される。したがって、@code{mouse-1}にたいするキーバインディングが存在する場合、そのバインディングは@var{event-type}が@code{mouse-1}であるようなすべてのイベントに適用されるだろう。

@item @var{position}
@cindex mouse position list
これはマウスクリックがどこで発生したかを表す@dfn{マウス位置リスト(mouse position list)}である。詳細は以下を参照のこと。

@item @var{click-count}
これは同じマウスボタンを素早く繰り返し押下したときの回数である。@ref{Repeat Events}を参照のこと。
@end table

  クリックイベントの@var{position}スロット内にあるマウス位置リストの内容にアクセスするためには、一般的には@ref{Accessing
Mouse}にドキュメントされている関数を使用するべきです。このリストの明示的なフォーマットは、どこでクリックが発生したかに依存します。テキストエリア、モードライン、ヘッダーライン、フリンジ、マージンエリアでのクリックにたいして、マウス位置リストは以下のフォーマットをもちます

@example
(@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}
 @var{object} @var{text-pos} (@var{col} . @var{row})
 @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))
@end example

@noindent
以下はこれらのリスト要素がもつ意味です:

@table @asis
@item @var{window}
クリックが発生したウィンドウ。

@item @var{pos-or-area}
テキストエリア内でクリックされた文字のバッファー位置。またはテキストエリア外がクリックされた場合は、クリックが発生したウィンドウエリア。これはシンボル@code{mode-line}、@code{header-line}、@code{vertical-line}、@code{left-margin}、@code{right-margin}、@code{left-fringe}、@code{right-fringe}のどれか。

特別な場合の1つとして、@var{pos-or-area}が単なるシンボルではなく、(上記シンボルのいずれか1つの)シンボルを含むリストの場合がある。これはEmacsにより登録されたイベントにたいする、イマジナリープレフィクスキー(imaginary
prefix key)の後に発生する。@ref{Key Sequence Input}を参照のこと。

@item @var{x}, @var{y}
クリックの相対ピクセル座標(relative pixel
coordinates)。あるウィンドウのテキストエリア内でのクリックにたいする座標原点@code{(0
. 0)}は、テキストエリアの左上隅となる。@ref{Window
Sizes}を参照のこと。モードラインまたはヘッダーライン内でのクリックにたいする座標原点は、そのウィンドウ自身の左上隅となる。フリンジ、マージン、垂直ボーダー(vertical
border)では、@var{x}な有意なデータをもたない。フリンジ、マージンでは、@var{y}はヘッダーラインの最下端からの相対位置である。すべてのケースにおいて@var{x}および@var{y}座標は右方向および下方向で増加する。

@item @var{timestamp}
そのイベントが発生した時刻を、システム依存の初期時刻(initial time)からの経過ミリ秒で表す整数。

@item @var{object}
クリック位置に文字列タイプのテキストプロパティが存在しない場合は@code{nil}、存在する場合は(@var{string}
. @var{string-pos})形式のコンスセル:

@table @asis
@item @var{string}
クリックされた文字列。すべてのテキストプロパティを含む。

@item @var{string-pos}
クリックが発生した文字列内の位置。
@end table

@item @var{text-pos}
マージンエリアまたはフリンジにたいするクリックでは、そのウィンドウ内の対応する行内の最初の可視な文字のバッファー位置となる。他のイベントにたいしては、そのウィンドウ内のカレントバッファーの位置となる。

@item @var{col}, @var{row}
これらは@var{x}、@var{y}の位置にあるグリフ(gliph)の、実際の行と列の座標数値である。行@var{x}がその行の実際のテキストの最後の列を超える場合、@var{col}はデフォルトの文字幅をもつ仮想的な追加列数を加えた値が報告される。そのウィンドウがヘッダーラインをもつ場合、行0はヘッダーラインとなり、ヘッダーラインをもたない場合はテキストエリアの上端ラインが行0となる。ウィンドウのテキストエリアのクリックにたいしては、テキストエリアの左端列が列0となり、モードラインまたはヘッダーラインのクリックにたいしてはそのラインの左端が列0となる。フリンジまたは垂直ボーダーのクリックにたいしては、これらは有意なデータをもたない。マージンのクリックにたいしては、@var{col}はマージンエリアの左端、@var{row}はマージンエリアの上端から測られる。

@item @var{image}
これはクリックが発生した場所のイメージオブジェクトである。クリックされた場所にイメージが存在しない場合は@code{nil}、イメージがクリックされた場合は@code{find-image}によりリターンされるイメージオブジェクトである。

@item @var{dx}, @var{dy}
これらは@var{object}の左上隅@code{(0
. 0)}からの相対的ピクセル座標である。@var{object}が@code{nil}の場合は、クリックされた文字グリフの左上隅からの相対座標である。

@item @var{width}, @var{height}
これらは@var{object}のピクセル幅とピクセル高さであり、@var{object}が@code{nil}の場合はクリックされた文字グリフのピクセル幅とピクセル高さである。
@end table

スクロールバーへのクリックにたいして、@var{position}は以下の形式をもちます:

@example
(@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})
@end example

@table @asis
@item @var{window}
スクロールバーがクリックされたウィンドウ。

@item @var{area}
これはシンボル@code{vertical-scroll-bar}である。

@item @var{portion}
スクロールバーの上端からクリック位置までのピクセル数。GTK+を含むいくつかのツールキットでは、Emacsがこれらのデータを抽出できないので、値は常に@code{0}となる。

@item @var{whole}
スクロールバーの全長のピクセル数。GTK+を含むいくつかのツールキットでは、Emacsがこれらのデータを抽出できないので、値は常に@code{0}となる。

@item @var{timestamp}
イベントが発生したミリ秒時刻。GTK+を含むいくつかのツールキットでは、Emacsがこれらのデータを抽出できないので、値は常に@code{0}となる。

@item @var{part}
@c The `top', `bottom', and `end-scroll' codes don't seem to be used.
クリックが発生したスクロールバー部分。これはシンボル@code{handle}(スクロールバーのハンドル)、@code{above-handle}(ハンドルの上側エリア)、@code{below-handle}(ハンドルの下側エリア)、@code{up}(スクロールバー端の上矢印)、@code{down}(スクロールバー端の下矢印)のいずれかである。
@end table


@node Drag Events
@subsection Drag Events
@cindex drag event
@cindex mouse drag event

Emacsでは、特別なことをしなくてもドラッグイベントを取得できます。@dfn{ドラッグイベント(drag
event)}は、ユーザーがマウスボタンを押下して、ボタンをリリースする前に、マウスを異なる文字位置に移動すると毎回発生します。すべてのマウスイベントと同じように、ドラッグイベントはLispではリストで表現されます。このリストは以下のように、開始マウス位置と最終位置ぼ両方を記録します:

@example
(@var{event-type}
 (@var{window1} START-POSITION)
 (@var{window2} END-POSITION))
@end example

ドラッグイベントにたいしては、シンボル@var{event-type}の名前に、プレフィクス@samp{drag-}が含まれます。たとえば、ボタン2を押下したままマウスをドラッグすると、@code{drag-mouse-2}イベントが生成されます。このイベントの2つ目と3つ目の要素は、マウス位置リスト(@ref{Click
Events}を参照)としてドラッグの開始と終了の位置を与えます。任意のマウスイベントの2つ目の要素には、同じ方法でアクセスできます。しかし、ドラッグイベントは最初に選択されていたフレームの境界外で終了するかもしれません。この場合、3つ目の要素の位置リストに、ウィンドウのかわりにそのフレームが含まれます。

@samp{drag-}プレフィクスは、その後に@samp{C-}や@samp{M-}のような修飾キープレフィクスが続きます。

@code{read-key-sequence}がキーバインディングをもたず、対応するクリックイベントにキーバインディングがあるようなドラッグイベントを受け取った場合、この関数はそのドラッグイベントをドラッグ開始位置でのクリックイベントに変更します。これは、もし望まなければクリックイベントとドラッグイベントを区別する必要がないことを意味します。

@node Button-Down Events
@subsection Button-Down Events
@cindex button-down event

クリックイベントとドラッグイベントは、ユーザーがマウスボタンをリリースしたときに発生します。ボタンがリリースされるまでクリックとドラッグを区別することはできないので、リリース前にイベントが発生することはありません。

ボタンが押下されたらすぐに何か処理したい場合は、@dfn{ボタンダウン(button-down)}イベントを処理する必要があります@footnote{ボタンダウン(button-down)はドラッグ(drag)の保守的なアンチテーゼです(訳注:
原文は``Button-down is the conservative antithesis of
drag.''。ボタンダウンを着るような人種と麻薬を対比させたジョークのような気がしますが、すいません、よく分からないので直訳します)。}。これらは@var{event-type}のシンボル名に@samp{down-}が含まれることを除き、クリックイベントとまったく同じようなリストにより表現されます。@samp{down-}プレフィクスの後には、@samp{C-}や@samp{M-}のような修飾キープレフィクスが続きます。

関数@code{read-key-sequence}は、コマンドバインディングをもたないボタンダウンイベントを無視します。したがって、Emacsコマンドループもこれらを無視します。これは、ボタンダウンイベントで何かしたい場合以外は、ボタンダウンイベントの定義について心配する必要がないことを意味します。ボタンダウンイベントを定義する通常の理由は、ボタンがリリースされるまで(モーションイベントを読み取ることにより)マウスモーションを追跡できるからです。@ref{Motion
Events}を参照してください。

@node Repeat Events
@subsection Repeat Events
@cindex repeat events
@cindex double-click events
@cindex triple-click events
@cindex mouse events, repeated

マウスを移動せずに同じマウスボタンを素早く2回以上連続して押下すると、Emacsは2回目とそれ以降の押下にたいして、特別な@dfn{リピート(repeat)}マウスイベントを生成します。

もっとも一般的なリピートイベントは、@dfn{ダブルクリック(double-click)}イベントです。Emacsはボタンを2回クリックしたときに、ダブルクリックイベントを生成します。このイベントは、(すべてのクリックイベントが通常そうであるように)ボタンをリリースしたときに発生します。

ダブルクリックイベントのイベント型には、プレフィクス@samp{double-}が含まれます。したがって、@key{meta}を押しながら2つ目のマウスボタンをダブルクリックすると、Lispプログラムには@code{M-double-mouse-2}が渡されます。ダブルクリックイベントがバインディングをもたない場合、対応する通常のクリックイベントのバインディングが実行に使用されます。したがって、実際に望んでいなければダブルクリック機能に注意を払う必要はありません。

ユーザーがダブルクリックを行うとき、Emacsはまず通常のクリックイベントを生成し、その後ダブルクリックイベントを生成します。したがって、ダブルクリックイベントのコマンドバインディングは、すでにシングルクリックイベントが実行された想定でデザインしなければなりません。つまりシングルクリックの結果から開始して、ダブルクリックの望むべき結果を生成しなければならないのです。

これはダブルクリックの意味合いが、シングルクリックの意味合いの何らかにもとづいて``構築''される場合は便利です。これはダブルクリックにたいするユーザーインターフェイスにおける推奨されるデザインプラクティスです。

ボタンをクリックした後もう一度ボタンを押下して、そのままマウス一般的を開始した場合、最終的にボタンをリリースしたとき@dfn{ダブルドラッグ(double-drag)}イベントが取得されます。このイベント型には単なる@samp{drag}のかわりに@samp{double-drag}が含まれます。ダブルドラッグイベントがバインディングをもたない場合、それがあたかも通常のドラッグイベントだったかのようにEmacsはかわりのバインディングを探します。

ダブルクリックまたはダブルドラッグイベントの前に、Emacsはユーザーが2回目にボタンを押したタイミングで@dfn{ダブルダウン(double-down)}イベントを生成します。このイベント型には、単なる@samp{down}のかわりに@samp{double-down}が含まれます。ダブルダウンイベントがバインディングをもたない場合、それがあたかも通常のボタンダウンイベントだったかのようにEmacsはかわりのバインディングを探します。どちらの方法でもバインディングが見つからなかった場合、ダブルダウンイベントは無視されます。

要約すると、ボタンをクリックしてすぐにまた押したとき、Emacsは1回目のクリックにたいしてダウンイベントとクリックイベントを生成し、2回目に再度ボタンを押したときにダブルダウンイベント、そして最後にダブルクリックまたはダブルドラッグイベントを生成します。

ボタンを2回クリックした後もう一度押したとき、それらすべてが素早く連続で行われた場合、Emacsは@dfn{トリプルダウン(triple-down)}イベントと、その後続の@dfn{トリプルクリック(triple-click)}または@dfn{トリプルドラッグ(triple-drag)}イベントを生成します。これらイベントのイベント型には、@samp{double}のかわりに@samp{triple}が含まれます。トリプルイベントがバインディングをもたない場合、Emacsは対応するダブルイベントに使用されるであろうバインディングを使用します。

ボタンを3回以上クリックした後、再度ボタンを押した場合、3回を超える押下にたいするイベントはすべてトリプルイベントになります。Emacsはクワドループル(quadruple:
4連)、クインティプル(quintuple:
5連)、...等のイベントにたいして個別のイベント型をもちません。しかし、ボタンが何回押下されたかを正確に見つけるために、イベントリストを調べることができます。

@defun event-click-count event
この関数は@var{event}を誘因した連続したボタン押下の回数をリターンする。@var{event}がダブルダウン、ダブルクリック、ダブルドラッグの場合、値は2である。@var{event}がトリプルイベントの場合、値は3以上になる。@var{event}が(リピートイベントではない)通常のマウスイベントの場合、値は1である。
@end defun

@defopt double-click-fuzz
リピートイベントを生成するためには、ほぼ同じスクリーン位置で連続でマウスボタンを押下しなければならない。@code{double-click-fuzz}の値は、ダブルクリックを生成するために連続する2回のクリック間で、マウスが移動(水平および垂直)するかもしれない最大ピクセル数を指定する。

この変数はドラッグとみなされるマウスモーションの閾値でもある。
@end defopt

@defopt double-click-time
リピートイベントを生成するためには、連続するボタン押下のミリ秒間隔が、@code{double-click-time}の値より小さくなければならない。@code{double-click-time}を@code{nil}にセットすると、複数回クリック検知が完全に無効になる。@code{t}にセットすると、時間制限が取り除かれる。その場合、Emacsは位置だけで複数回クリックを検知する。
@end defopt

@node Motion Events
@subsection Motion Events
@cindex motion event
@cindex mouse motion events

Emacsは、ボタンアクティビティが何もないマウスのモーション(motion: 動き)を記述する@dfn{マウスモーション(mouse
motion)}イベントを生成するときがあります。マウスモーションイベントは、以下のようなリストにより表現されます:

@example
(mouse-movement POSITION)
@end example

@noindent
@var{position}は、マウスカーソルのカレント位置を指定するマウス位置リスト(@pxref{Click
Events})です。ドラッグイベントの終了位置のように、この位置リストは最初に選択されていた境界外の位置を表すかもしれず、その場合はそのフレーム内のその位置のウィンドウが含まれる。

スペシャルフォーム@code{track-mouse}は、ボタン内でのモーションイベントの生成を有効にします。@code{track-mouse}フォームの外側では、Emacsはマウスの単なるモーションにたいするイベントは生成せず、これらのイベントは発生しません。@ref{Mouse
Tracking}を参照してください。

@node Focus Events
@subsection Focus Events
@cindex focus event

ウィンドウシステムは、ユーザーにたいしてどのウィンドウがキーボード入力を受け取るか制御するための、一般的な方法を提供します。このウィンドウ選択は@dfn{フォーカス(focus)}と呼ばれます。Emacsのフレームを切り替えるためにユーザーが何かを行うと、それは@dfn{フォーカスイベント(focus
event)}を生成します。フォーカスイベントの通常の定義はグローバルキーマップ内にあり、ユーザーが期待するようにEmacsで新たなフレームを選択するためのものです。@xref{Input
Focus}を参照してください。

フォーカスイベントは、以下のようにLispのリストで表現されます:

@example
(switch-frame @var{new-frame})
@end example

@noindent
ここで@var{new-frame}は切り替え先のフレームです。

Xウィンドウマネージャーには、あるウィンドウにマウスを移動するだけで、そこにフォーカスされるようにセットアップするものがいくつかあります。通常は、他の種類の入力が到着するまで、Lispプログラムがフォーカスの変更を知る必要はありません。Emacsはユーザーが新たなフレーム内で実際にキーボードのキーをタイプするかマウスボタンを押下したときしか、フォーカスイベントを生成しません。つまりフレーム間でマウスを移動させても、フォーカスイベントは生成されません。

キーシーケンスの途中におけるフォーカスイベントは、そのシーケンスを誤ったものにするかもしれません。そのため、Emacsは決してキーシーケンスの途中でフォーカスイベントを生成しません。ユーザーがキーシーケンスの途中(つまりプレフィクス引数の後)でフォーカスを変更した場合、複数イベントキーシーケンスの前か後にフォーカスイベントが到着するように、Emacsはフォーカスイベントを記録しておきます。

@node Misc Events
@subsection Miscellaneous System Events

他にもシステム内での出来事を表現するイベント型が少数あります。

@table @code
@cindex @code{delete-frame} event
@item (delete-frame (@var{frame}))
このイベントの種類は、ユーザーがウィンドウマネージャーに特定のウィンドウを削除するコマンドを与えたことを示し、Emacsのフレームにたいして発生する。

@code{フレーム削除(delete-frame)}イベントの標準的な定義は、@var{frame}を削除する。

@cindex @code{iconify-frame} event
@item (iconify-frame (@var{frame}))
このイベントの種類は、ウィンドウマネージャーを使用してユーザーが@var{frame}をアイコン化したことを示す。標準的な定義は@code{ignore}である。これは、そのフレームがすでにアイコン化されているので、Emacsが行う必要のことは何もないからである。このイベント型の目的は、望むならこのようなイベントの追跡を可能にしておくためである。

@cindex @code{make-frame-visible} event
@item (make-frame-visible (@var{frame}))
このイベントの種類は、ウィンドウマネージャーを使用してユーザーが@var{frame}を非アイコン化したことを示す。標準的な定義は@code{ignore}である。これは、そのフレームがすでに可視化されているので、Emacsが行う必要のことは何もないからである。

@cindex @code{wheel-up} event
@cindex @code{wheel-down} event
@item (wheel-up @var{position})
@itemx (wheel-down @var{position})
この種類のイベントは、マウスホイールを移動したことにより発生する。@var{position}要素は、そのイベント発生時のマウスカーソル位置を指定するマウス位置リスト(@ref{Click
Events}を参照)である。

@vindex mouse-wheel-up-event
@vindex mouse-wheel-down-event
この種類のイベントは、ある種のシステムでのみ発生する。いくつかのシステムでは、かわりに@code{mouse-4}と@code{mouse-5}が使用される。可搬性のあるコードとするためには、マウスホイールにたいしてどのイベント型が期待されるかを決定するために@file{mwheel.el}内で定義されている変数@code{mouse-wheel-up-event}および@code{mouse-wheel-down-event}を使用する。

@cindex @code{drag-n-drop} event
@item (drag-n-drop @var{position} @var{files})
この種類のイベントは、Emacs外部アプリケーション内でファイルグループが選択され、それがEmacsフレーム内にドラッグアンドドロップされたときに発生する。

要素@var{position}は、そのイベント位置を記述しマウスクリックイベントで使用されるフォーマット(@ref{Click
Events}を参照)と同じである。要素@var{files}はドラッグアンドドロップされたファイル名のリストである。通常は、それらのファイルをvisitすることにより、このイベントは処理される。

この種類のイベントは、現在のところある種のシステムでのみ生成される。

@cindex @code{help-echo} event
@item help-echo
この種類のイベントは、テキストプロパティ@code{help-echo}をもつバッファーテキスト部分上にマウスポインターが移動したときに生成される。生成されるイベントは以下の形式をもつ:

@example
(help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})
@end example

@noindent
イベントパラメーターの正確な意味と、ヘルプテキストを表示するためにこれらのパラメーターを使用する方法は、@ref{Text
help-echo}で説明されているか

@cindex @code{sigusr1} event
@cindex @code{sigusr2} event
@cindex user signals
@item sigusr1
@itemx sigusr2
これらのイベントは、Emacsプロセスがシグナル@code{SIGUSR1}および@code{SIGUSR2}を受け取ったときに生成される。シグナルは追加情報を運搬しないので、追加データは含まれない。これらのシグナルはデバッグに有用である(@ref{Error
Debugging}を参照)。

ユーザーシグナルをcatchするためには、@code{special-event-map}(@ref{Active
Keymaps}を参照)内で対応するイベントにバインドする。そのコマンドは引数なしで呼び出され、@code{last-input-event}内の特定のシグナルイベントが利用できる。たとえば:

@smallexample
(defun sigusr-handler ()
  (interactive)
  (message "Caught signal %S" last-input-event))

(define-key special-event-map [sigusr1] 'sigusr-handler)
@end smallexample

シグナルハンドラーをテストするために、自身でEmacsにシグナルを送信できる:

@smallexample
(signal-process (emacs-pid) 'sigusr1)
@end smallexample

@cindex @code{language-change} event
@item language-change
この種類のイベントは、MS-Windows上で入力言語が変更されたときに生成される。これは通常、キーボードキーが異なる言語の文字でEmacsに送られることを意味する。生成されるイベントは、以下の形式をもつ:

@smallexample
(language-change @var{frame} @var{codepage} @var{language-id})
@end smallexample

@noindent
ここで@var{frame}は言語が変更されたときカレントだったフレームであり、@var{codepage}は新たなコードページ番号(codepage
number)、@var{language-id}は新たな入力言語の数値IDである。@var{codepage}に対応するコーディングシステム(@ref{Coding
Systems}を参照)は、@code{cp@var{codepage}}または@code{windows-@var{codepage}}である。@var{language-id}を文字列に変更する(たとえば@code{set-language-environment}のようなさまざまな言語依存機能にたいしこれを使用する)には、以下のように@code{w32-get-locale-info}関数を使用する:

@smallexample
;; 英語にたいする"ENU"のような言語の省略形を取得する
(w32-get-locale-info language-id)
;; "English (United States)"のような
;; その言語の完全な英語名を取得する
(w32-get-locale-info language-id 4097)
;; その言語の完全なローカライズ名を取得する
(w32-get-locale-info language-id t)
@end smallexample
@end table

  キーシーケンスの途中、つまりプレフィクスキーの後にこれらのイベントの1つが到着した場合、複数イベントキー内ではなくその前または後にそのイベントが到着するように、Emacsはそのイベントを記録する。

@node Event Examples
@subsection Event Examples

ユーザーが同じ場所でマウス左ボタンを押して離した場合、それは以下のようなイベントシーケンスを生成します:

@smallexample
(down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
(mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))
@end smallexample

コントロールキーを押したままユーザーがマウス第2ボタンを押してマウスをある行から次の行へドラッグした場合、以下のような2つのイベントが生成されます:

@smallexample
(C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
(C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                (#<window 18 on NEWS> 3510 (0 . 28) -729648))
@end smallexample

メタキーとシフトキーを押したままユーザーがそのウィンドウのモードライン上でマウス第2ボタンを押して他ウィンドウへマウスをドラッグした場合、以下のようなイベントのペアーが生成されます:

@smallexample
(M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
(M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                   -453816))
@end smallexample

全画面表示されていないフレームに入力フォーカスがあり、ユーザーがマウスをそのフレームのスコープ外へマウスを移動した場合、スペシャルフォーム@code{track-mouse}内では以下のようなイベントが生成されます:

@smallexample
(mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))
@end smallexample

SIGUSR1シグナルを処理するためにはインタラクティブ関数を定義して、それを@code{signal usr1}イベントシーケンスにバインドします:

@smallexample
(defun usr1-handler ()
  (interactive)
  (message "Got USR1 signal"))
(global-set-key [signal usr1] 'usr1-handler)
@end smallexample

@node Classifying Events
@subsection Classifying Events
@cindex event type
@cindex classifying events

  すべてのイベントは@dfn{イベント型(event
type)}をもちます。イベント型はキーバインディング目的でイベントをクラス分けします。キーボードイベントにたいするイベント型はイベント値と等しく、したがって文字のイベント型は文字、ファンクションキーシンボルのイベント型はそのシンボル自身です。リストであるようなイベントのイベント型は、そのリストの@sc{car}内のシンボルです。したがって、イベント型は常にシンボルか文字です。

  同じ型の２つのイベントはキーバインディングに関する限り同じです。したがって、それらは常に同じコマンドを実行します。これらが同じことを行う必要があるという意味ではありませんが、イベント全体を調べてから何を行うか決定するコマンドもいくつかあります。、たとえば、バッファー内でどこに作用するか決定するためにマウスイベントの場所を使用するコマンドもいくつかあります。

  広範なイベントのクラス分けが役に立つときもあります。たとえば、他の修飾キーやマウスボタンが使用されたかとは無関係に、@key{META}キーとともに呼び出されたイベントを尋ねたいと思うかもしれません。

  関数@code{event-modifiers}は@code{event-basic-type}は、そのような情報を手軽に取得するために提供されています。

@defun event-modifiers event
この関数は、@var{event}がもつ修飾子のリストをリターンする。この修飾子はシンボルであり@code{shift}、@code{control}、@code{meta}、@code{alt}、@code{hyper}、@code{super}が含まれる。さらにマウスイベントシンボルの修飾子リストには常に@code{click}、@code{drag}、@code{down}のいずれか1つが含まれる。ダブルイベントまたはトリプルイベントには@code{double}または@code{triple}も含まれる。

引数@var{event}はイベントオブジェクト全体、または単なるイベント型かもしれない。@var{event}がカレントEmacsセッション内で入力として読み取られたイベント内で決して使用されないシンボルの場合は、実際に@var{event}が変更されたときでも、@code{event-modifiers}は@code{nil}をリターンできる。

いくつか例を挙げる:

@example
(event-modifiers ?a)
     @result{} nil
(event-modifiers ?A)
     @result{} (shift)
(event-modifiers ?\C-a)
     @result{} (control)
(event-modifiers ?\C-%)
     @result{} (control)
(event-modifiers ?\C-\S-a)
     @result{} (control shift)
(event-modifiers 'f5)
     @result{} nil
(event-modifiers 's-f5)
     @result{} (super)
(event-modifiers 'M-S-f5)
     @result{} (meta shift)
(event-modifiers 'mouse-1)
     @result{} (click)
(event-modifiers 'down-mouse-1)
     @result{} (down)
@end example

クリックイベントにたいする修飾リストは明示的に@code{click}を含むが、イベントシンボル名自身は@samp{click}を含まない。
@end defun

@defun event-basic-type event
この関数は@var{event}を記述するキー、またはマウスボタンをリターンする。@var{event}引数は@code{event-modifiers}の場合と同様。たとえば:

@example
(event-basic-type ?a)
     @result{} 97
(event-basic-type ?A)
     @result{} 97
(event-basic-type ?\C-a)
     @result{} 97
(event-basic-type ?\C-\S-a)
     @result{} 97
(event-basic-type 'f5)
     @result{} f5
(event-basic-type 's-f5)
     @result{} f5
(event-basic-type 'M-S-f5)
     @result{} f5
(event-basic-type 'down-mouse-1)
     @result{} mouse-1
@end example
@end defun

@defun mouse-movement-p object
@var{object}がマウス移動イベントの場合、この関数は非@code{nil}をリターンする。
@end defun

@defun event-convert-list list
この関数は修飾子名リストと基本イベント型(basic event
type)を、それらすべてを指定するイベント型に変換する。基本イベント型はそのリストの最後の要素でなければならない。たとえば、

@example
(event-convert-list '(control ?a))
     @result{} 1
(event-convert-list '(control meta ?a))
     @result{} -134217727
(event-convert-list '(control super f1))
     @result{} C-s-f1
@end example
@end defun

@node Accessing Mouse
@subsection Accessing Mouse Events
@cindex mouse events, data in
@cindex keyboard events, data in

  このセクションではマウスボタンやモーションイベント内のデータアクセスに役に立つ関数を説明します。同じ関数を使用してキーボードイベントデータにもアクセスできますが、キーボードイベントに不適切なデータ要素は0または@code{nil}になります。

  以下の2つの関数は、マウスイベントの位置を指定するマウス位置リスト(@pxref{Click Events})をリターンします。

@defun event-start event
これは@var{event}の開始位置をリターンする。

@var{event}がクリックイベントまたはボタンダウンイベントの場合、この関数はそのイベントの位置をリターンする。@var{event}がドラッグイベントの場合は、そのドラッグの開始位置をリターンする。
@end defun

@defun event-end event
これは@var{event}の終了位置をリターンする。

@var{event}がドラッグイベントの場合、この関数はユーザーがマウスボタンをリリースした位置をリターンする。@var{event}がクリックイベントまたはボタンダウンイベントの場合、値はそのイベント固有の開始位置となる。
@end defun

@defun posnp object
この関数は@var{object}が(@ref{Click
Events}に記述されたいずれかのフォーマットの)マウス位置リストの場合は非@code{nil}、それ以外では@code{nil}をリターンする。
@end defun

@cindex mouse position list, accessing
  以下の関数は、引数にマウス位置リストをとり、そのリストのさまざまな部分をリターンします:

@defun posn-window position
@var{position}があったウィンドウをリターンする。@var{position}が最初イベントがあったフレーム外の位置を表す場合は、かわりにそのフレームをリターンする。
@end defun

@defun posn-area position
@var{position}内に記録されたウィンドウエリアをリターンする。そのウィンドウのテキストエリアでイベントが発生したときは@code{nil}、それ以外ではイベントがどこで発生したかを識別するシンボルをリターンする。
@end defun

@defun posn-point position
@var{position}内のバッファー位置をリターンする。ウィンドウのテキストエリア、マージンエリア、フリンジでイベントが発生したときは、バッファー位置を識別する整数値、それ以外では値は未定義である。
@end defun

@defun posn-x-y position
@var{position}内のピクセル単位のxy座標を、コンスセル@code{(@var{x}
. @var{y})}でリターンする。これらは@code{posn-window}により与えられるウィンドウにたいする相対座標である。

以下は、あるウィンドウのテキストエリア内のウィンドウ相対座標をフレーム相対座標に変換する方法を示す例である:

@example
(defun frame-relative-coordinates (position)
  "POSITIONのフレーム相対座標をリターンする。
POSITIONはウィンドウのテキストエリアにあるものとする。"
  (let* ((x-y (posn-x-y position))
         (window (posn-window position))
         (edges (window-inside-pixel-edges window)))
    (cons (+ (car x-y) (car edges))
          (+ (cdr x-y) (cadr edges)))))
@end example
@end defun

@defun posn-col-row position
この関数は、@var{position}内のバッファー位置にたいして推定される列と行を含むコンスセル@code{(@var{col}
.
@var{row})}をリターンする。リターン値は、@var{position}にたいする@var{x}と@var{y}の値より計算され、そのフレームのデフォルト文字幅とデフォルト行高(行間スペースを含む)の単位で与えられる(そのため、実際の文字サイズが非デフォルト値の場合には、実際の行と列は、これらの計算された値とは異なるかもしれない)。

@var{row}は、そのテキストエリアの上端から数えられることに注意すること。@var{position}により与えられるウィンドウがヘッダーライン(@pxref{Header
Lines})をもつ場合、そのヘッダーラインは@var{row}の数に@emph{含まない}。
@end defun

@defun posn-actual-col-row position
@var{position}内の実際の行と列を、コンスセル@code{(@var{col}
. @var{row})}でリターンする。値は@var{position}与えられるウィンドウの実際の行と列である。@ref{Click
Events}を参照のこと。@var{position}が実際のポジション値を含まない場合、この関数は@code{nil}をリターンする。この場合、おおよその値を取得するために@code{posn-col-row}を使用できる。

この関数は、タブ文字やイメージによるビジュアル列数のように、ディスプレイ上の文字のビジュアル幅を意味しない。標準的な文字単位の座標が必要ｎ場合は、かわりに@code{posn-col-row}を使用すること。
@end defun

@defun posn-string position
@var{position}内の文字列オブジェクトをを@code{nil}、またはコンスセル@code{(@var{string}
. @var{string-pos})}でリターンする。
@end defun

@defun posn-image position
@var{position}内のイメージオブジェクトを@code{nil}、または@code{(image ...)}でリターンする。
@end defun

@defun posn-object position
@var{position}内のイメージオブジェクト、または文字列オブジェクトを@code{nil}、イメージ@code{(image
...)}、またはコンスセル@code{(@var{string} . @var{string-pos})}でリターンする。
@end defun

@defun posn-object-x-y position
@var{position}内のオブジェクトの左上隅からのピクセル単位のxy座標を、コンスセル@code{(@var{dx}
.
@var{dy})}でリターンする。@var{position}がバッファーテキストの場合は、その位置にもっとも近いバッファーテキストの相対位置をリターンする。
@end defun

@defun posn-object-width-height position
@var{position}内のオブジェクトのピクセル幅とピクセル高さを、コンスセル@code{(@var{width}
. @var{height})}でリターンする。@var{position}がバッファー位置の場合は、その位置の文字のサイズをリターンする。
@end defun

@cindex timestamp of a mouse event
@defun posn-timestamp position
@var{position}内のタイムスタンプをリターンする。これはミリ秒で表されたイベント発生時刻である。
@end defun

  以下の関数は与えられた特定のバッファー、またはスクリーン位置により与えられる位置リストを計算します。上述の関数で、この位置リスト内のデータにアクセスできます。

@defun posn-at-point &optional pos window
この関数は位置@var{pos} in
@var{window}にたいする位置リストをリターンする。@var{pos}のデフォルトは@var{window}内のポイントであり、@var{window}のデフォルトは選択されたウィンドウである。

@var{window}内で@var{pos}が不可視の場合、@code{posn-at-point}は@code{nil}をリターンする。
@end defun

@defun posn-at-x-y x y &optional frame-or-window whole
この関数は、指定されたフレームまたはウィンドウ@var{frame-or-window}(デフォルトは選択されたウィンドウ)内のピクセル座標@var{x}と@var{y}に対応する位置情報をリターンする。@var{x}と@var{y}は、使用されたフレームまたはウィンドウにたいする相対座標である。@var{whole}が@code{nil}の場合、座標はウィンドウのテキストエリアにたいする相対座標であり、それ以外ではスクロールバー、マージン、フリンジを含むウィンドウエリア全体にたいする相対座標である。
@end defun

@node Accessing Scroll
@subsection Accessing Scroll Bar Events
@cindex scroll bar events, data in

  以下の関数は、スクロールバーイベントの解析に役立ちます。

@defun scroll-bar-event-ratio event
この関数はスクロールバーで発生したスクロールバーイベントの位置の垂直位置割り合いをリターンする。値は位置の割り合いを表す2つの整数を含むコンスセル@code{(@var{portion}
. @var{whole})}である。
@end defun

@defun scroll-bar-scale ratio total
この関数は、(実質的には)@var{ratio}に@var{total}を乗じて、結果を整数に丸める。引数@var{ratio}は数字ではなく、@code{scroll-bar-event-ratio}によりリターンされる典型的な値ペアー@code{(@var{num}
. @var{denom})}である。

この関数はスクロールバー位置をバッファー位置にスケーリングするのに便利である。以下のようにこれを行う:

@example
(+ (point-min)
   (scroll-bar-scale
      (posn-x-y (event-start event))
      (- (point-max) (point-min))))
@end example

スクロールバーイベントは、xy座標ペアーのかわりに割り合いを構成する2つの整数をもつことを思い出してほしい。
@end defun

@node Strings of Events
@subsection Putting Keyboard Events in Strings
@cindex keyboard events in strings
@cindex strings with keyboard events

  文字列が使用される場所のほとんどにおいて、わたしたちはテキスト文字を含むもの、つまりバッファーやファイル内で見出すのと同種のものとして、文字列を概念化します。Lispプログラムはときおり、キーボード文字、たとえばキーシーケンスやキーボードマクロ定義かもしれないキーボード文字を概念的に含む文字列を使用します。しかし文字列内へのキーボード文字の格納は、歴史的な互換性の理由により複雑な問題であり、常に可能なわけではありません。

  新たに記述するプログラムでは文字列内にキーボードイベントを格納しないことにより、これらの複雑さを扱うことを避けるよう推奨します。以下はこれを行う方法です:

@itemize @bullet
@item
@code{lookup-key}および@code{define-key}の引数として使用するのでなければ、キーシーケンスにたいして文字列のかわりにベクターを使用する。たとえば、@code{read-key-sequence}のかわりに@code{read-key-sequence-vector}、@code{this-command-keys}のかわりに@code{this-command-keys-vector}を使用できる。

@item
メタ文字を含むキーシーケンス定数を記述する際は、たとえそれを直接@code{define-key}に渡す場合でもベクターを使用する。

@item
文字列かもしれないキーシーケンスの内容を調べる必要があるときは、それをリストに変換するために最初に@code{listify-key-sequence}(@ref{Event
Input Misc}を参照)を使用する。
@end itemize

  複雑さはキーボード入力に含まれるかもしれない修飾ビットに起因します。メタ修飾以外の修飾ビットは文字列に含めることができず、メタ文字も特別な場合だけ許されます。

  GNU
Emacsの初期のバージョンでは、メタ文字を128から255のコードで表していました。その頃は基本文字コードの範囲は0から127だったので、すべてのキーボード文字を文字列内に適合させることができました。Lispプログラムの多くは、特に@code{define-key}やその種の関数の引数として文字列定数内にメタ文字を意味する@samp{\M-}を使用し、キーシーケンスとイベントシーケンスは常に文字列として表現されていました。

  127を超えるより大きい基本文字コードと追加の修飾ビットにたいするサポートを加えたとき、わたしたちはメタ文字の表現を変更する必要がありました。現在では文字のメタ修飾を表すフラグは
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
であり、そのような値は文字列内に含めることができません。

  プログラムで文字列定数内の@samp{\M-}をサポートするために、文字列内に特定のメタ文字を含めるための特別なルールがあります。以下は入力文字シーケンスとして文字列を解釈するためのルールです:

@itemize @bullet
@item
キーボード文字の値の範囲が0から127の場合は、文字列を変更せずに含めることができる。

@item
これらの文字のコード
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
から
@tex
@math{2^{27} + 127},
@end tex
@ifnottex
2**27+127,
@end ifnottex
までの範囲のメタ修飾された変種も文字列に含めることができるが、それらの数値を変更しなければならない。値が128から255の範囲となるように、ビット
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
のかわりにビット
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
をセットしなければならない。ユニバイト文字列だけがこれらの文字を含むことができる。

@item
265を超える非@acronym{ASCII}文字はマルチバイト文字に含めることができる。

@item
その他のキーボード文字イベントは文字列に適合させられない。これには128から255の範囲のキーボードイベントが含まれる。
@end itemize

  キーボード入力文字の文字列定数を構築する@code{read-key-sequence}のような関数は、イベントが文字列内に適合しないときは文字列のかわりにベクターを構築するというルールにしたがいます。

  文字列内で入力構文@samp{\M-}を使用すると、それは128から255の範囲のコード、つまり対応するキーボードイベントを文字列内に配すために変更するとき取得されるのと同じコードが生成されます。したがって文字列内のメタイベントは、それが文字列内にどのように配置されたかと無関係に一貫して機能します。

  しかし、ほとんどのプログラムはこのセクションの冒頭の推奨にしたがって、これらの問題を避けるほうがよいでしょう。

@node Reading Input
@section Reading Input
@cindex read input
@cindex keyboard input

  エディターコマンドループはキーシーケンスの読み取りに関数@code{read-key-sequence}を使用し、この関数は@code{read-event}を使用します。イベント入力にたいしてこれらの関数、およびその他の関数がLisp関数から利用できます。@ref{Temporary
Displays}の@code{momentary-string-display}、および@ref{Waiting}の@code{sit-for}も参照してください。端末の入力モードの制御、および端末入力のデバッグに関する関数と変数については、@ref{Terminal
Input}を参照してください。

  高レベル入力機能については@ref{Minibuffers}を参照してください。

@menu
* Key Sequence Input::       キーシーケンスを読み取る方法。
* Reading One Event::        イベントを1つだけ読み取る方法。
* Event Mod::                Emacsが読み取られたイベントを変更する方法。
* Invoking the Input Method::  入力メソッドを使用するイベントを読み取る方法。
* Quoted Character Input::   文字の指定をユーザーに問い合わせる。
* Event Input Misc::         入力イベントの最読み取りや破棄の方法。
@end menu

@node Key Sequence Input
@subsection Key Sequence Input
@cindex key sequence input

  コマンドループは@code{read-key-sequence}を呼び出すことにより、キーシーケンスの入力を一度に読み取ります。Lisp関数もこの関数を呼び出すことができます。たとえば@code{describe-key}はキーを説明するためにこの関数を使用します。

@defun read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
この関数はキーシーケンスを読み取り、それを文字列またはベクターでリターンする。この関数は完全なキーシーケンスに蓄積されるまで、つまりカレントでアクティブなキーマップを使用してプレフィクスなしでコマンドを指定するのに十分なキーシーケンスとなるまでイベントの読み取りを継続する(マウスイベントで始まるキーシーケンスは、カレントバッファーではなくマウスのあったウィンドウ内のバッファーのキーマップを使用して読み取られることを思い出してほしい)。

イベントがすべて文字で、それらがすべて文字列に適合する場合、@code{read-key-sequence}は文字列をリターンする(@ref{Strings
of
Events}を参照)。それ以外の場合は文字、シンボル、リストなどすべての種類のイベントを保持できるベクターをリターンする。文字列またはベクターの要素は、キーシーケンス内のイベントである。

キーシーケンスのo読み取りには、そのイベントを変換するさまざまな方法が含まれる。@ref{Translation Keymaps}を参照のこと。

引数@var{prompt}はプロンプトとしてエコーエリアに表示される文字列か、プロンプトを表示しない@code{nil}である。引数@var{continue-echo}が非@code{nil}の場合、それは前のキーの継続としてそのキーをエコーすることを意味する。

通常、元となる大文字のイベントが未定義で、それと等価な小文字イベントが定義されている場合、大文字のイベントは小文字のイベントに変換される。引数@var{dont-downcase-last}が非@code{nil}の場合、それは最後のイベントを小文字に変換しないことを意味する。これはキーシーケンスを定義するときに適している。

引数@var{switch-frame-ok}が非@code{nil}の場合は、たとえ何かをタイプする前にユーザーがフレームを切り替えたとしても、この関数が@code{switch-frame}を処理すべきでないことを意味する。キーシーケンスの途中でユーザーがフレームを切り替えた場合、またはシーケンスの最初だが@var{switch-frame-ok}が@code{nil}のときにフレームを切り替えた場合、そのイベントはカレントキーシーケンスの後に延期される。

引数@var{command-loop}が非@code{nil}の場合は、そのキーシーケンスがコマンドを逐次読み取る何かによりa読み取られることを意味する。呼び出し側が1つのキーシーケンスだけを読み取る場合は、@code{nil}を指定すべきである。

以下の例では、Emacsはエコーエリアにプロンプト@samp{?}を表示して、その後ユーザーが@kbd{C-x C-f}をタイプしている。

@example
(read-key-sequence "?")

@group
---------- Echo Area ----------
?@kbd{C-x C-f}
---------- Echo Area ----------

     @result{} "^X^F"
@end group
@end example

関数@code{read-key-sequence}はquitを抑制する。この関数による読み取りの間にタイプされた@kbd{C-g}は他の文字と同じように機能し、@code{quit-flag}をaセットしない。@ref{Quitting}を参照のこと。
@end defun

@defun read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
これは@code{read-key-sequence}と同様だが、キーシーケンスを常にベクターでリターンし、文字列では決してリターンしない点が異なる。@ref{Strings
of Events}を参照のこと。
@end defun

@cindex upper case key sequence
@cindex downcasing in @code{lookup-key}
@cindex shift-translation
入力文字が大文字(またはシフト修飾をもつ)で、キーバインディングをもたないが、等価な小文字はキーバインディングをもつ場合、@code{read-key-sequence}はその文字を小文字に変換します。@code{lookup-key}はこの方法による大文字小文字変換を行わないことに注意してください。

@vindex this-command-keys-shift-translated
入力を読み取った結果が@dfn{シフト変換(shift-translation)}されていたような場合、Emacsは変数@code{this-command-keys-shift-translated}に非@code{nil}値をセットします。シフト変換されたキーにより呼びだされたときは挙動を変更する必要があるLispプログラムは、この変数を調べることができます。たとえば、関数@code{handle-shift-selection}はリージョンをアクティブ、または非アクティブにするか判断するためにこの変数の値を調べます(@ref{The
Mark, handle-shift-selection}を参照)。

この関数@code{read-key-sequence}も、マウスイベントのいくつかを変換します。これはバインドされていないドラッグイベントをクリックイベントに変換し、バインドされていないボタンダウンイベントを完全に破棄します。さらにフォーカスイベントとさまざまなウィンドウイベントの再配置も行うため、これらのイベントはキーシーケンス中に他のイベントとともに決して出現しません。

@cindex @code{header-line} prefix key
@cindex @code{mode-line} prefix key
@cindex @code{vertical-line} prefix key
@cindex @code{horizontal-scroll-bar} prefix key
@cindex @code{vertical-scroll-bar} prefix key
@cindex @code{menu-bar} prefix key
@cindex mouse events, in special parts of frame
モードラインやスクロールバーのようなウィンドウの特別な箇所でマウスイベントが発生したとき、そのイベント型は特別なことは何も示さず、マウスボタンと修飾キーの組み合わせを通常表すのと同じシンボルになります。ウィンドウの箇所についての情報はイベント内の別のどこか、すなわち座標に保持されています。しかし@code{read-key-sequence}はこの情報を仮想的な``プレフィクスキー''に変換します。これらはすべてシンボルであり@code{header-line}、@code{horizontal-scroll-bar}、@code{menu-bar}、@code{mode-line}、@code{vertical-line}、@code{vertical-scroll-bar}です。これらの仮想的なプレフィクスキーを使用してキーシーケンスを定義することにより、ウィンドウの特別な部分でのカウスクリックにたいして意味を定義できます。

たとえば、@code{read-key-sequence}を呼び出した後にそのウィンドウのモードラインをマウスでクリックすると、以下のように2つのマウスイベントが取得されます:

@example
(read-key-sequence "Click on the mode line: ")
     @result{} [mode-line
         (mouse-1
          (#<window 6 on NEWS> mode-line
           (40 . 63) 5959987))]
@end example

@defvar num-input-keys
この変数の値は、そのEmacsセッション内で処理されたキーシーケンスの数である。これには端末からのキーシーケンスと、実行されるキーボードマクロにより読み取られたキーシーケンスが含まれる。
@end defvar

@node Reading One Event
@subsection Reading One Event
@cindex reading a single event
@cindex event, reading only one

  @code{read-event},@code{read-char}、@code{read-char-exclusive}は、コマンド入力にたいするもっとも低レベルの関数です。

@defun read-event &optional prompt inherit-input-method seconds
この関数はコマンド入力の次のイベントを読み取り、リターンする。必要ならイベントが利用可能になるまで待機する。

リターンされるイベントはユーザーから直接のイベントかもしれないし、またはキーボードマクロからのイベントかもしれない。イベントはキーボードの入力コーディングシステム(@ref{Terminal
I/O Encoding}を参照)により復号されない。

オプション引数@var{prompt}が非@code{nil}の場合、それはエコーエリアにプロンプトとして表示される文字列である。@code{nil}の場合、@code{read-event}は入力待ちを示すメッセージを何も表示せず、エコーを行うことによりプロンプトの代用とする。エコーで表示されるのはカレントコマンドに至ったイベントや読み取られたイベントの説明である。@ref{The
Echo Area}を参照のこと。

@var{inherit-input-method}が非@code{nil}の場合、(もしあれば)非@acronym{ASCII}文字の入力を可能にするためにカレントの入力メソッドが採用される。それ以外では、このイベントの読み取りにたいして入力メソッドの処理が無効になる。

@code{cursor-in-echo-area}が非@code{nil}の場合、@code{read-event}はカーソルを一時的にエコーエリアの、そこに表示されているメッセージの終端に移動する。それ以外では、@code{read-event}はカーソルを移動しない。

@var{seconds}が非@code{nil}の場合、それは入力を待つ最大秒数を指定する数値である。その時間内に入力が何も到着しない場合、@code{read-event}は待機を終えて@code{nil}をリターンする。浮動小数点数@var{seconds}は待機する秒の分数を意味する。いくつかのシステムではサポートされるのは整数の秒数だけであり、そのようなシステムでは@var{seconds}は切り捨てられる。@var{seconds}が@code{nil}の場合、@code{read-event}は入力が到着するのに必要なだけ待機する。

@var{seconds}が@code{nil}の場合、ユーザー入力が到着するのを待つ間、Emacsはアイドル状態にあるとみなされる。この期間中にアイドルタイマー
--- @code{run-with-idle-timer}(@ref{Idle Timers}を参照) ---
を実行できる。しかし@var{seconds}が非@code{nil}の場合には、非アイドル状態は変更されずに残る。@code{read-event}が呼び出されたときEmacsが非アイドルだった場合、@code{read-event}の処理を通じて非アイドルのままとなる。Emacsがアイドルだった場合(これはアイドルタイマー内部からその呼び出しが行われた場合に起こり得る)は、アイドルのままとまる。

@code{read-event}がヘルプ文字として定義されたイベントを取得した場合、ある状況においては@code{read-event}がリターンせずに直接イベントを処理することがある。@ref{Help
Functions}を参照のこと。その他の@dfn{スペシャルイベント(special events)}(@ref{Special
Events}を参照)と呼ばれる特定のイベントも@code{read-event}で直接処理される。

以下は@code{read-event}を呼び出してから右矢印キーを押下したとき何が起こるかの例である:

@example
@group
(read-event)
     @result{} right
@end group
@end example
@end defun

@defun read-char &optional prompt inherit-input-method seconds
この関数はコマンド入力の文字を読み取り、それをリターンする。ユーザーが文字以外(たとえばマウスクリックやファンクションキー)のイベントを生成した場合、@code{read-char}はエラーをシグナルする。引数は@code{read-event}と同じように機能する。

1つ目の例では、ユーザーは文字@kbd{1}(@acronym{ASCII}コード49)をタイプしている。2つ目の例では、@code{eval-expression}を使用してミニバッファーから@code{read-char}を呼び出すキーボード定義を示している。@code{read-char}は、キーボードマクロの直後の文字@kbd{1}を読み取る。その後、@code{eval-expression}はリターン値をエコーエリアに表示する。

@example
@group
(read-char)
     @result{} 49
@end group

@group
;; @r{@kbd{M-:}を使用して以下を評価するものとする}
(symbol-function 'foo)
     @result{} "^[:(read-char)^M1"
@end group
@group
(execute-kbd-macro 'foo)
     @print{} 49
     @result{} nil
@end group
@end example
@end defun

@defun read-char-exclusive &optional prompt inherit-input-method seconds
この関数はコマンド入力の文字を読み取り、それをリターンする。ユーザーが文字以外のイベントを生成した場合、@code{read-char-exclusive}はそれを無視して文字を取得するまで他のイベントを読み取る。引数は@code{read-event}と同じように機能する。
@end defun

  上記でquitを抑制する関数はありません。

@defvar num-nonmacro-input-events
この変数は端末から受信した入力イベント(キーボードマクロにより生成されたイベントは勘定されない)の総数を保持する。
@end defvar

  @code{read-key-sequence}と異なり、関数@code{read-event}、@code{read-char}、@code{read-char-exclusive}は@ref{Translation
Keymaps}で説明した変換を行わないことを強調しておきます。単一キー読み取りでこれらの変換を行いたい場合は、関数@code{read-key}を使用してください。

@defun read-key &optional prompt
この関数は1つのキーを読み取る。これは@code{read-key-sequence}と@code{read-event}の間の``中間的''な関数である。@code{read-key-sequence}と異なるのは、キーシーケンスではなく単一キーを読み取ることである。@code{read-event}と異なるのは、rawイベントをリターンせずに@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}(@ref{Translation
Keymaps}を参照)に合わせて復号と変換を行うことである。

引数@var{prompt}はプロンプトとしてエコーエリアに表示する文字列で、@code{nil}はプロンプトを表示しないことを意味する。
@end defun

@defun read-char-choice prompt chars &optional inhibit-quit
この関数は1つの文字を読み取りリターンするために@code{read-key}を使用する。これは@var{chars}(許容される文字のリスト)のメンバー以外の入力を無視する。オプションで、有効な入力を待つ間のquitイベントも無視する。@code{read-char-choice}呼び出しの間に@code{help-form}(@ref{Help
Functions}を参照)を非@code{nil}値にバインドした場合、@code{help-char}の押下により@code{help-form}が評価され結果が表示される。その後、有効な入力文字、またはキーボードquitの待機を継続する。
@end defun

@node Event Mod
@subsection Modifying and Translating Input Events
@cindex modifiers of events
@cindex translating input events
@cindex event translation

  Emacsは@code{extra-keyboard-modifiers}に合わせて読み取ったすべてのイベントを変更して、@code{read-event}からリターンする前に、(もし適切なら)@code{keyboard-translate-table}を通じてそれを変換します。

@defvar extra-keyboard-modifiers
この変数は、Lispプログラムにキーボード上の修飾キーを``押下''させる。値は文字である。文字の修飾子だけが対象となる。ユーザーがキーボードのキーを押下するたびに、その修飾キーがすでに押下されたかのように処理される。たとえば、@code{extra-keyboard-modifiers}を@code{?\C-\M-a}にバインドした場合、このバインディングのスコープ内にある間、すべてのキーボード入力文字はコントロール修飾とメタ修飾を適用されるだろう。文字@code{?\C-@@}は0と等価なので、この目的にたいしてはコントロール文字として勘定されないが、修飾無しの文字として扱われる。したがって@code{extra-keyboard-modifiers}を0にセットすることにより、すべての修飾をキャンセルできる。

ウィンドウシステムを利用する場合は、この方法によりプログラムが任意の修飾キーを``押下''できる。それ以外は@key{CTL}と@key{META}のキーだけを仮想的に押下できる。

この変数は実際にキーボード由来のイベントだけに適用され、マウスイベントやその他のイベントには効果がないことに注意されたい。
@end defvar

@defvar keyboard-translate-table
この端末ローカルな変数はキーボード文字にたいする変換テーブルである。これによりコマンドバインディングを変更することなく、キーボード上のキーを再配置できる。値は通常、文字テーブル、または@code{nil}ある(文字列かベクターも指定できるが、時代遅れとされている)

@code{keyboard-translate-table}が文字テーブル(@ref{Char-Tables}を参照)の場合、キーボードから読み取られたそれぞれの文字はその文字テーブルを調べる。非@code{nil}の値が見つかった場合は、実際の入力文字のかわりにそれを使用する。

この変換は文字が端末から読み取られた後、最初に発生することに注意されたい。@code{recent-keys}のような記録保持機能や文字を記録するdribbleファイルは、この変換の後に処理される。

さらに、この変換は入力メソッド(@ref{Input
Methods}を参照)に文字を提供する前に行われることにも注意されたい。入力メソッド処理の後に文字を変換したい場合は、@code{translation-table-for-input}(@ref{Translation
of Characters}を参照)を使用すること。
@end defvar

@defun keyboard-translate from to
この関数は文字コード@var{from}を文字コード@var{to}に変換するために、@code{keyboard-translate-table}を変更する。
必要な場合は、キーボード変換テーブルを作成する。
@end defun

  以下は@kbd{C-x}でカット、@kbd{C-}でコピー、@kbd{C-v}でペーストを処理するように@code{keyboard-translate-table}を使用する例です:

@example
(keyboard-translate ?\C-x 'control-x)
(keyboard-translate ?\C-c 'control-c)
(keyboard-translate ?\C-v 'control-v)
(global-set-key [control-x] 'kill-region)
(global-set-key [control-c] 'kill-ring-save)
(global-set-key [control-v] 'yank)
@end example

@noindent
拡張@acronym{ASCII}入力をサポートするグラフィカルな端末上では、シフトキーとともにタイプすることにより、標準的なEmacsにおける意味をこれらの文字から依然として取得することが可能です。これはキーボード変換が関与する文字とは異なりますが、それらは通常と同じ意味をもちます。

  @code{read-key-sequence}のレベルでイベントシーケンスを変換するメカニズムについては、@ref{Translation
Keymaps}を参照してください。

@node Invoking the Input Method
@subsection Invoking the Input Method
@cindex invoking input method

  イベント読み取り関数は、もしあればカレント入力メソッドを呼び出します(@ref{Input
Methods}を参照)。@code{input-method-function}の値が非@code{nil}の場合、関数を指定します。@code{read-event}が修飾ビットのないプリント文字(@key{SPC}を含む)を読み取ったときは、その文字を引数としてその関数を呼び出します。

@defvar input-method-function
これが非@code{nil}の場合、その値はカレントの入力メソッド関数を指定する。

@strong{警告:}
この変数は@code{let}でバインドしてはならない。この変数はしばしばバッファーローカルであり、入力の前後(これは正にあなたがバインド@emph{するであろう}タイミングである)でバインドした場合、Emacsが待機中に非同期にバッファーを切り替えると誤ったバッファーに値がリストアされるだろう。
@end defvar

  入力メソッド関数は、入力として使用されるイベントのリストをリターンするべきです(このリストが@code{nil}の場合、それは入力がないことを意味するので、@code{read-event}他のイベントを待機する)。これらのイベントは@code{unread-command-events}(@ref{Event
Input
Misc}を参照)内のイベントの前に処理されます。入力メソッドによりリターンされるイベントは、たとえそれらが修飾ビットのないプリント文字であっても、再度入力メソッドに渡されることはありません。

  入力メソッド関数が@code{read-event}または@code{read-key-sequence}を呼び出した場合は、再帰を防ぐために最初に@code{input-method-function}を@code{nil}にバインドするべきです。

  キーシーケンスの2つ目および後続のイベントを読み取るときは、入力メソッド関数は呼び出されません。したがって、それらの文字は入力メソッドの処理対象ではありません。入力メソッド関数は@code{overriding-local-map}と@code{overriding-terminal-local-map}の値をテストするべきです。これらの変数のいずれかが非@code{nil}の場合、入力メソッドは引数をリストにputして、それ以上の処理を行わずにそのリストをリターンするべきです。

@node Quoted Character Input
@subsection Quoted Character Input
@cindex quoted character input

  ユーザーが手軽にコントロール文字やメタ文字。リテラルや8進文字コードを指定できるように、文字の指定をもとめることができます。コマンド@code{quoted-insert}この関数を使用します。

@defun read-quoted-char &optional prompt
@cindex octal character input
@cindex control characters, reading
@cindex nonprinting characters, reading
この関数は@code{read-char}同様だが、最初に読み取った文字が8進数
(0--7)の場合は任意の個数の8進数(8進数以外の文字を見つけた時点でストップする)を読み取り、その文字コードにより表される文字をリターンする。8進シーケンスを終端させた文字が@key{RET}の場合、それは無視される。他の終端文字は、この関数がリターンした後に入力として使用される。

最初の文字の読み取り時はquitは抑制されるので、ユーザーはは@kbd{C-g}を入力できる。@ref{Quitting}を参照のこと。

@var{prompt}が与えられた場合、それはユーザーへのプロンプトに使用する文字列を指定する。プロンプト文字列は、その後の1つの@samp{-}とともに常にエコーエリアに表示される。

以下の例では、ユーザーは8進数の177(10進数の127)をタイプしている。

@example
(read-quoted-char "What character")

@group
---------- Echo Area ----------
What character @kbd{1 7 7}-
---------- Echo Area ----------

     @result{} 127
@end group
@end example
@end defun

@need 2000
@node Event Input Misc
@subsection Miscellaneous Event Input Features

このセクションでは、イベントを使い切ることなく``先読み''する方法、および入力の保留や保留の破棄の方法について説明します。@ref{Reading a
Password}の関数@code{read-passwd}も参照してください。

@defvar unread-command-events
@cindex next input
@cindex peeking at input
この変数はコマンド入力として読み取り待機中のイベントのリストを保持する。イベントはこのリスト内の出現順に使用され、使用されるごとにリストから取り除かれる。

ある関数がイベントを読み取ってそれを使用するかどうか決定する場合がいくつかあるので、この変数が必要になる。この変数にイベントを格納すると、コマンドループおよにコマンド入力を読み取る関数により、イベントは通常のように処理される。

@cindex prefix argument unreading
たとえば、数引数を実装する関数は、任意の個数の数字を読み取る。数字イベントが見つからないとき、関数はそのイベントを読み戻す(unread)ので、そのイベントはコマンドループにより通常通り読み取られることができる。同様に、インクリメンタル検索は、検索において特別な意味をもたないイベントを読み戻すために、この機能を使用する。なぜなら、それらのイベントは検索をexitして、通常どおり実行されるべきだからである。

@code{unread-command-events}にイベントを置くためにキーシーケンスからイベントを抽出するには、@code{listify-key-sequence}(以下参照)を使用するのが簡単で信頼のおける方法である。

もっとも最近読み戻したイベントが最初に再読み取りされるように、このリストの先頭にイベントを追加するのが通常である。

通常このリストから読み取ったイベントは、そのイベントが最初に読み取られたときにすでに一度追加されたときのように、カレントコマンドのキーシーケンスに(たとえば@code{this-command-keys}にリターンされたとみのように)追加される。フォーム@w{@code{(t
. @var{event})}}の要素は、カレントコマンドのキーシーケンスに@var{event}を強制的に追加する。
@end defvar

@defun listify-key-sequence key
この関数は文字列またはベクターの@var{key}を、@code{unread-command-events}置くことができる個別のイベントのリストに変換する。
@end defun

@defun input-pending-p &optional check-timers
@cindex waiting for command key input
この関数は、コマンド入力がカレントで読み取り可能かどうか判断する。入力が利用可能なら即座に@code{t}を、それ以外は@code{nil}をリターンする。非常に稀だが、入力が利用できないときに@code{t}

オプション引数@var{check-timers}が非@code{nil}の場合、Emacsは順部位ができたら任意のタイマーを実行する。@ref{Timers}を参照のこと。
@end defun

@defvar last-input-event
この変数は最後に読み取られた端末入力イベントがコマンドの一部なのか、それともLispプログラムによる明示的なものなのかを記録する。

以下の例では、文字@kbd{1}(@acronym{ASCII}コード49)をLispプログラムが読み取っている。@kbd{C-e}(@kbd{C-x
C-e}は式を評価するコマンドとする)が@code{last-command-event}に値として残っている間は、それが@code{last-input-event}の値となる。

@example
@group
(progn (print (read-char))
       (print last-command-event)
       last-input-event)
     @print{} 49
     @print{} 5
     @result{} 49
@end group
@end example
@end defvar

@defmac while-no-input body@dots{}
この構成は@var{body}フォームを実行して、入力が何も到着しない場合だけ最後のフォームの値をリターンする。@var{body}フォームを実行する間に何らかの入力が到着した場合は、それらの入力をする(quitのように機能する)。@code{while-no-input}フォームは実際のquitによりabortした場合は@code{nil}、入力の到着によりabortした場合は@code{t}をリターンする。

@var{body}の一部で@code{inhibit-quit}を非@code{nil}にバインドした場合、その部分の間に到着した入力は、その部分が終わるまでabortしない。

両方のabort条件を@var{body}により計算されたすべての可能な値で区別できるようにしたい場合は、以下のようにコードを記述する:

@example
(while-no-input
  (list
    (progn . @var{body})))
@end example
@end defmac

@defun discard-input
@cindex flushing input
@cindex discarding input
@cindex keyboard macro, terminating
この関数は端末入力バッファーの内容を破棄して定義処理中かもしれないキーボードマクロをキャンセルする。この関数は@code{nil}をリターンする。

以下の例では、フォームの評価開始直後にユーザーが数字か文字をタイプするかもしれない。@code{sleep-for}がスリープを終えた後、@code{discard-input}はスリープ中にタイプされた文字を破棄する。

@example
(progn (sleep-for 2)
       (discard-input))
     @result{} nil
@end example
@end defun

@node Special Events
@section Special Events

@cindex special events
特定の@dfn{スペシャルイベント(special
event)}は、読み取られると即座に非常に低レベルで処理されます。@code{read-event}関数はそれらのイベントを自身で処理して、それらを決してリターンしません。かわりに、スペシャルイベント以外の最初のイベントを待ち、それをリターンします。

  スペシャルイベントはエコーされず、決してキーシーケンスにグループ化されず、@code{last-command-event}や@code{(this-command-keys)}の値として出現することもありません。スペシャルイベントは数引数を破棄し、@code{unread-command-events}による読み戻しができず、キーボードマクロ内に出現することもないでしょうし、キーボードマクロ定義中にキーボードマクロに記録されることもありません。

  しかし、スペシャルイベントは読み取られた直後に@code{last-input-event}内に出現するので、これがイベント定義にたいして実際のイベントを探す方法になります。

  イベント型@code{iconify-frame}、@code{make-frame-visible}、@code{delete-frame}、@code{drag-n-drop}、@code{language-change}、および@code{sigusr1}ようなユーザーシグナルは通常この方法により処理されます。何がスペシャルイベントで、スペシャルイベントをどのように処理するかを定義するキーマップは、変数@code{special-event-map}(@ref{Active
Keymaps}を参照)の中にあります。

@node Waiting
@section Waiting for Elapsed Time or Input
@cindex waiting

  待機関数(wait
function)は特定の時間が経過するか、入力があるまで待機するようにデザインされています。たとえば、計算の途中でユーザーがディスプレイを閲覧できるように一時停止したいときがあるかもしれません。@code{sit-for}は一時停止して画面を更新、@code{sleep-for}は画面を更新せずに一時停止して、入力が到着したら即座にリターンします。

@defun sit-for seconds &optional nodisp
この関数は、(ユーザーからの保留中入力がない場合は)再描画を行ってから、@var{seconds}秒、または入力が利用可能になるまで待機する。@code{sit-for}の通常の目的は、ディスプレイしたテキストをユーザーが読み取る時間を与えるためである。入力が何も到着せず(@ref{Event
Input Misc}を参照)、時間をフルに待機した場合は@code{t}、それ以外は@code{nil}が値となる。

引数@var{seconds}は整数である必要はない。浮動小数点数の場合、@code{sit-for}は秒の少数点数を待機する。整数の秒だけをサポートするいくつかのシステムでは、@var{seconds}は切り捨てられる。

保留中の入力が存在しない場合、式@code{(sit-for
0)}は遅延なしに再描画をリクエストする@code{(redisplay)}と等価である。@ref{Forcing Redisplay}を参照のこと。

@var{nodisp}が非@code{nil}の場合@code{sit-for}は再描画を行わないが、それでも入力が利用可能になると(またはタイムアウト時間が経過すると)即座にリターンする。

バッチモード(@ref{Batch
Mode}を参照)では、たとえ標準入力ディスクリプタからの入力でも割り込みできまい。これは以下で説明する@code{sleep-for}でも同じである。

@code{(sit-for @var{seconds} @var{millisec}
@var{nodisp})}のように、3つの引数で@code{sit-for}を呼び出すことも可能だが時代遅れだと考えられている。
@end defun

@defun sleep-for seconds &optional millisec
この関数は表示を更新せず、単に@var{seconds}秒間一時停止する。これは利用可能な入力に注意を払わない。この関数は@code{nil}をリターンする。

引数@var{seconds}は整数である必要はない。浮動小数点数の場合、@code{sleep-for}は秒の少数点数を待機する。整数の秒だけをサポートするいくつかのシステムでは、@var{seconds}は切り捨てられる。

オプション引数@var{millisec}はミリ秒単位で追加の待機期間を指定する。これは@var{seconds}で指定された期間に追加される。システムが小数点の秒数をサポートしない場合、非0の@var{millisec}を指定するとエラーとなる。

遅延を保証したい場合は@code{sleep-for}を使用する。
@end defun

  現在時刻を取得する関数については、@ref{Time of Day}を参照してください。

@node Quitting
@section Quitting
@cindex @kbd{C-g}
@cindex quitting
@cindex interrupt Lisp functions

  Lisp関数を実行中に@kbd{C-g}をタイプすると、Emacsが何を行っていてもEmacsを@dfn{quit(中止、終了)}させます。これはアクティブなコマンドループの再内に制御がリターンすることを意味します。

  コマンドループがキーボード入力待機中に@kbd{C-g}をタイプしてもquitはしません。これは通常の入力文字として機能します。もっともシンプルなケースでは、通常@kbd{C-g}はquitの効果をもつ@code{keyboard-quit}を実行するので、区別できませんしかしプレフィクスキーの後の@kbd{C-g}は、未定義のキー組み合わせになります。これはプレフィクスキーやプレフィクスキーも同様にキャンセルする効果をもちます。

  ミニバッファー内では、@kbd{C-g}は異なる定義をもち、それはミニバッファーをabort(失敗、中止、中断)します。これは実際にはミニバッファーをexitしてquitします(単にquitするのは@emph{ミニバッファー内}のコマンドループにリターンするだろう)。@kbd{C-g}がなぜコマンドリーダーが入力読み取り時に直接quitしないかという理由は、ミニバッファー内で@kbd{C-g}の意味をこの方法により再定義可能にするためです。プレフィクスキーの後の@kbd{C-g}はミニバッファー内で再定義されておらず、プレフィクスキーおよびプレフィクス引数のキャンセルという通常の効果をもちます。もし@kbd{C-g}ｇヴぁ常に直接quitするなら、これは不可能でしょう。

  @kbd{C-g}が直接quitを行うときは、変数@code{quit-flag}を@code{t}にセットすることによりそれを行います。Emacsは適切なときにこの変数をチェックして、@code{nil}でない場合はquitします。どのような方法でも、@code{quit-flag}を非@code{nil}にセットするとquitが発生します。

  Cコードのレベルでは、どこでもquitを発生させることはできず、@code{quit-flag}をチェックする特別な場所でのみquitが発生します。この理由は、他の場所でquitすると、Emacsの内部状態が矛盾が生じるかもしれないからです。安全な場所までquitが遅延されるので、quitがEmacsをクラッシュさせることがなくなります。

  @code{read-key-sequence}や@code{read-quoted-char}のような特定の関数は、たとえ入力を待機中でもquitを抑制します。quitするかわりに、@kbd{C-g}は要求された入力として処理されます。@code{read-key-sequence}の場合、これはコマンドループ内での@kbd{C-g}の特別な振る舞いを引き起こすのに役立ちます。@code{read-quoted-char}の場合、これは@kbd{C-g}をクォートするのに@kbd{C-q}を使用できるようにします。

@cindex preventing quitting
  変数@code{inhibit-quit}を非@code{nil}値にバインドすることにより、Lisp関数の一部でquitを抑止できます。その場合は、@code{quit-flag}を@code{t}にセットされていても、@kbd{C-g}の通常の結果であるquitは抑止されます。@code{let}フォームの最後でこのバインディングがunwindされるなどして、結果として@code{inhibit-quit}は再び@code{nil}になります。このとき@code{quit-flag}が@code{nil}の場合には、即座に要求されたquitが発生します。この挙動は、プログラム中の``クリティカルセクション''内でquitが発生しないことを確実にしたいときに理想的です。

@cindex @code{read-quoted-char} quitting
  (@code{read-quoted-char}のような)いくつかの関数では、quitを起こさない特別な方法で@kbd{C-g}が処理されます。これは@code{inhibit-quit}を@code{t}にバインドして入力を読み取り、再び@code{inhibit-quit}が@code{nil}になる前に@code{quit-flag}を@code{nil}にセットすることにより行われます。以下は、これを行う方法を示すための@code{read-quoted-char}の抜粋です。この例は入力の最初の文字の後で通常のquitを許す方法も示しています。

@example
(defun read-quoted-char (&optional prompt)
  "@dots{}@var{documentation}@dots{}"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            @dots{})
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      @r{@dots{} 変数@code{code}をセット @dots{}})
    code))
@end example

@defvar quit-flag
この変数が非@code{nil}で@code{inhibit-quit}が@code{nil}の場合、macsは即座にquitする。@kbd{C-g}をタイプすると、通常は@code{inhibit-quit}とは無関係に@code{quit-flag}を非@code{nil}にセットする。
@end defvar

@defvar inhibit-quit
この変数は、@code{quit-flag}が非@code{nil}にセットされているときEmacsがquitするかどうかを決定する。@code{inhibit-quit}が非@code{nil}の場合、@code{quit-flag}は特に効果がない。
@end defvar

@defmac with-local-quit body@dots{}
このマクロは@var{body}を順番に実行するが、たとえこの構成の外部で@code{inhibit-quit}が非@code{nil}でも、少なくともローカルに@var{body}内でのquitを許す。このマクロはquitによりexitした場合は@code{nil}、それ以外は@var{body}内の最後のフォームの値をリターンする。

@code{inhibit-quit}が@code{nil}の場合@code{with-local-quit}へのエントリーで@var{body}だけが実行され、@code{quit-flag}をセットすることにより通常のquitが発生する。しかし通常のquitが遅延されるように@code{inhibit-quit}が非@code{nil}にセットされている場合、非@code{nil}の@code{quit-flag}は特別な種類のローカルquitを引き起こす。これは@var{body}の実行を終了して、@code{quit-flag}を非@code{nil}のままで@code{with-local-quit}ボディーをexitするので、許され次第(通常の)他のquitが発生する。@var{body}の先頭ですでに@code{quit-flag}が非@code{nil}の場合、即座にローカルquitが発生して結局ボディーは実行されない。

このマクロは主にタイマー、プロセスフィルター、プロセスセンチネル、@code{pre-command-hook}、@code{post-command-hook}、および@code{inhibit-quit}が通常は@code{t}にバイドされている場所で役に立つ。
@end defmac

@deffn Command keyboard-quit
この関数は@code{(signal 'quit
nil)}により@code{quit}条件をシグナルする。これはquitが行うことと同じである(@ref{Errors}の@code{signal}を参照)。
@end deffn

  quitに使用する@kbd{C-g}以外の文字を指定できます。@ref{Input
Modes}内の関数@code{set-input-mode}を参照してください。

@node Prefix Command Arguments
@section Prefix Command Arguments
@cindex prefix argument
@cindex raw prefix argument
@cindex numeric prefix argument

  ほとんどのEmacsコマンドは@dfn{プレフィクス引数(prefix
argument)}を使用できます。プレフィクス引数はコマンド自身の前に数字を指定するものです(プレフィクス引数とプレフィクスキーを混同しないように)。プレフィクス引数は常に値により表され、@code{nil}のときはカレントでプレフィクス引数が存在しないことを意味します。すべてのコマンドはプレフィクス引数を使用するか、あるいは無視します。

  プレフィクス引数には2つの表現があります。それは@dfn{raw(生の、加工していない、原料のままの、未加工の)}と@dfn{数字(numeric)}です。エディターコマンドループは内部的にraw表現を使用し、Lisp変数もその情報を格納するのにこれを使用しますが、コマンドはどちらかの表現を要求できます。

  以下は利用できるrawプレフィクス引数の値です:

@itemize @bullet
@item
@code{nil}はプレフィクス引数がないことを意味する。これの数値的な値は1だが、多くのコマンドは@code{nil}と整数1を区別する。

@item
整数はそれ自身を意味する。

@item
整数の要素を1つもつリスト。プレフィクス引数のこの形式は、1つまたは数字無しの連続する@kbd{C-u}の結果である。数値的な値はリスト内の整数だが、そのようなリストと単独の整数を区別するコマンドがいくつかある。

@item
シンボル@code{-}。これは後に数字をともなわない@kbd{M--}か@kbd{C-u
-}がタイプされたことを示す。数値的に等価な値は@minus{}1だが、整数の@minus{}1をシンボルの@code{-}を区別するコマンドがいくつかある。
@end itemize

以下の関数をさまざまなプレフィクスで呼び出して、これらの可能なプレフィクスを説明しましょう:

@example
@group
(defun display-prefix (arg)
  "rawプレフィクス引数の値を表示する。"
  (interactive "P")
  (message "%s" arg))
@end group
@end example

@noindent
以下はさまざまなrawプレフィクス引数で@code{display-prefix}を呼び出した結果です:

@example
        M-x display-prefix  @print{} nil

C-u     M-x display-prefix  @print{} (4)

C-u C-u M-x display-prefix  @print{} (16)

C-u 3   M-x display-prefix  @print{} 3

M-3     M-x display-prefix  @print{} 3      ; @r{(@code{C-u 3}と同じ)}

C-u -   M-x display-prefix  @print{} -

M--     M-x display-prefix  @print{} -      ; @r{(@code{C-u -}と同じ)}

C-u - 7 M-x display-prefix  @print{} -7

M-- 7   M-x display-prefix  @print{} -7     ; @r{(@code{C-u -7}と同じ)}
@end example

  Emacsにはプレフィクス引数を格納するための2つの変数@code{prefix-arg}と@code{current-prefix-arg}があります。他のコマンドにたいしてプレフィクス引数をセットアップする@code{universal-argument}のようなコマンドは、プレフィクス引数を@code{prefix-arg}内に格納します。対照的に@code{current-prefix-arg}はカレントコマンドにプレフィクス引数を引き渡すので、これらの変数をセットしても将来のコマンドにたいするプレフィクス引数に効果はありません。

  コマンドは通常は@code{interactive}内で、プレフィクス引数にたいしてrawと数値のどちらの表現を使用するかを指定します(@ref{Using
Interactive}を参照)。そのかわりに関数は変数@code{current-prefix-arg}内のプレフィクス引数の値を直接調べるかもしれませんが、これは明確さで劣ります。

@defun prefix-numeric-value arg
この関数は@var{arg}の有効なrawプレフィクス引数の数値的な意味をリターンする。引数はシンボル、数字、またはリストかもしれない。これが@code{nil}の場合は、値1がリターンsare,@code{-}の場合は@minus{}1がリターンされる。これが数字の場合は、その数字がリターンされる。リスト(数字であるべき)の場合は、そのリストの@sc{car}がリターンされる。
@end defun

@defvar current-prefix-arg
この変数は@emph{カレント}のコマンドにたいするrawプレフィクス引数を保持する。コマンドはこの変数を直接調べるかもしれないが、この変数にたいするアクセスには通常は@code{(interactive
"P")}を使用する。
@end defvar

@defvar prefix-arg
この変数の値は@emph{次}の編集コマンドにたいするrawプレフィクス引数である。後続のコマンドにたいしてプレフィクス引数を指定する@code{universal-argument}のようなコマンドは、この変数をセットすることにより機能する。
@end defvar

@defvar last-prefix-arg
rawプレフィクス引数の値は、前のコマンドにより使用された値である。
@end defvar

  以下のコマンドは、後続のコマンドにたいしてプレフィクス引数をセットアップするために存在します。これらを他の用途で呼び出さないでください。

@deffn Command universal-argument
このコマンドは入力を読み取り。後続のコマンドにたいするプレフィクス引数を指定する。何をしているかわかっているのでなければ、このコマンドを自分で呼び出してはならない。
@end deffn

@deffn Command digit-argument arg
このコマンドは、後続のコマンドにたいしてプレフィクス引数を追加する。引数@var{arg}はこのコマンドの前のrawプレフィクス引数であり、これはプレフィクス引数を更新するために使用される。何をしているかわかっているのでなければ、このコマンドを自分で呼び出してはならない。
@end deffn

@deffn Command negative-argument arg
このコマンドは、次のコマンドにたいして数引数を追加する。引数@var{arg}はこのコマンドの前のrawプレフィクス引数であり、この値に負の符号が付されて新しいプレフィクス引数を構築する。何をしているかわかっているのでなければ、このコマンドを自分で呼び出してはならない。
@end deffn

@node Recursive Editing
@section Recursive Editing
@cindex recursive command loop
@cindex recursive editing level
@cindex command loop, recursive

  Emacsスタートアップ時に、自動的にEmacsコマンドループにエンターします。このトップレベルのコマンドループ呼び出しは決してexitせず、Emacs実行中は実行を続けます。Lispプログラムもコマンドループを呼び出せます。これは複数のコマンドループを活性化するため、これを@dfn{再帰編集(recursive
editing)}と呼んでいます。再帰編集レベルは、呼び出したコマンドが何であれそれをサスペンドして、そのコマンドを再開する前にユーザーが任意の編集を行うことを可能にする効果をもちます。

  再帰編集の間に利用可能なコマンドは、トップレベルの編集ループ内で利用できるコマンドと同じであり、キーマップ内で定義されます。数少ない特別なコマンドだけが再帰編集レベルをexitし、他のコマンドは再帰編集レベルが終了したときに再帰編集レベルからリターンします(exitするための特別なコマンドは常に利用できますが、再帰編集が行われていないときは何も行いません)。

  再帰コマンドループを含むすべてのコマンドループは、コマンドループから実行されたコマンド内のエラーによりそのループをexitしないように、汎用エラーハンドラーをセットアップします。

@cindex minibuffer input
  ミニバッファー入力は、特殊な再帰編集です。これは、ミニバッファーとミニバッファーウィンドウの表示を有効にするなどの欠点をもちますが、それはあなたが思うより少ないでしょう。ミニバッファー内では特定のキーの振る舞いが異なりますが、これははミニバッファーのローカルマップによるものです。ウィンドウを切り替えれば、通常のEmacsコマンドを使用できます。

@cindex @code{throw} example
@kindex exit
@cindex exit recursive editing
@cindex aborting
  再帰編集レベルを呼び出すには、関数を@code{recursive-edit}を呼び出します。この関数はコマンドループを含んでいます。さらに@code{exit}をthrowすることにより再帰編集レベルのexitを可能にする、タグ@code{exit}をともなう@code{catch}呼び出しも含んでいます(@ref{Catch
and
Throw}を参照)。@code{t}以外の値をthrowした場合、@code{recursive-edit}は通常それを呼び出した関数にリターンします。コマンド@kbd{C-M-c}(@code{exit-recursive-edit})がこれを行います。値@code{t}をthrowすることにより@code{recursive-edit}がquitされるので、1レベル上位のコマンドループに制御がリターンされます。これは@dfn{abort}と呼ばれ、@kbd{C-]}(@code{abort-recursive-edit})がこれを行います。

  ほとんどのアプリケーションはミニバッファー使用の一部として使用する場合を除き、再帰編集を使用するべきではありません。カレントバッファーのメジャーモードから、特殊なメジャーモードに一時的に変更する場合に、そのモードに戻るコマンドをもつ必要があるときは、通常は再帰編集のほうが便利です(Rmailの@kbd{e}コマンドはこのテクニックを使用している)。またはユーザーが新たなバッファーの特殊なモードで、異なるテキストを``再帰的''に編集・作成・選択できるようにしたい場合が該当します。このモードでは処理を完了させるコマンドを定義して、前のバッファーに戻ります(Rmailの@kbd{m}コマンドはこれを使用している)。

  再帰編集はデバッグに便利です。一種のブレークポイントとして関数定義内に@code{debug}を挿入して、関数がそこに達したときにその箇所を調べることができます。@code{debug}は再帰編集を呼び出しますが、デバッガのその他の機能も提供します。

  @code{query-replace}内で@kbd{C-r}をタイプしたときや@kbd{C-x
q}(@code{kbd-macro-query})を使用したときも、再帰編集レベルが使用されます。

@deffn Command recursive-edit
@cindex suspend evaluation
この関数はエディターコマンドループを呼び出す。これはユーザーに編集を開始させるために、Emacsの初期化により自動的に呼び出されるLispプログラムから呼び出されたときは、再帰編集レベルにエンターする。

カレントバッファーが選択されたウィンドウのバッファーと異なる場合、@code{recursive-edit}はカレントバッファーの保存とリストアを行う。それ以外では、バッファーを切り替えた場合には、@code{recursive-edit}がリターンした後その切り替えたバッファーがカレントになる。

以下の例では、関数@code{simple-rec}が最初にポイントを1単語分進めてからメッセージをエコーエリアにプリントして再帰編集にエンターする。その後ユーザーは望む編集を行い、@kbd{C-M-c}をタイプすれば再帰編集をexitして、@code{simple-rec}の実行を継続できる。

@example
(defun simple-rec ()
  (forward-word 1)
  (message "Recursive edit in progress")
  (recursive-edit)
  (forward-word 1))
     @result{} simple-rec
(simple-rec)
     @result{} nil
@end example
@end deffn

@deffn Command exit-recursive-edit
この関数は最内の再帰編集(ミニバッファー入力を含む)からexitする。関数の実質的な定義は@code{(throw 'exit nil)}である。
@end deffn

@deffn Command abort-recursive-edit
この関数は、再帰編集をexitした後に@code{quit}をシグナルすることにより、最内の再帰編集(ミニバッファー入力を含む)を要求したコマンドをabortする。関数の実質的な定義は@code{(throw
'exit t)}である。@ref{Quitting}を参照のこと。
@end deffn

@deffn Command top-level
この関数はすべての再帰編集レベルをexitする。これはすべての計算を直接抜け出してメインのコマンドループに戻り、値をリターンしない。
@end deffn

@defun recursion-depth
この関数は再帰編集のカレントの深さをリターンする。アクティブな再帰編集が存在しない場合は、0をリターンする。
@end defun

@node Disabling Commands
@section Disabling Commands
@cindex disabled command

  @dfn{コマンドを無効化(disabling a
command)}とは、それを実行可能にする前にユーザーによる確認を要求するようにコマンドをマークすることです。無効化は初めてのユーザーを混乱させるかもしれないコマンドにたいして、アクシデントによりそのコマンドが使用されるのを防ぐために使用されます。

@kindex disabled
  コマンド無効化の低レベルにおけるメカニズムは、そのコマンドにたいするLispシンボルの@code{disabled}プロパティに非@code{nil}をputすることです。これらのプロパティは、通常はユーザーのinitファイル(@ref{Init
File}を参照)で以下のようなLisp式によりセットアップされます:

@example
(put 'upcase-region 'disabled t)
@end example

@noindent
いくつかのコマンドにたいしては、これらのプロパティがデフォルトで与えられています(これらを削除したい場合はinitファイルで削除できる)。

  @code{disabled}プロパティの値が文字列の場合、そのコマンドが無効化されていることを告げるメッセージにその文字列が含まれます。たとえば:

@example
(put 'delete-region 'disabled
     "この方法で削除されたテキストはyankで戻せない!\n")
@end example

  無効化されたコマンドをインタラクティブに呼び出したときに何が起こるかの詳細は、@xref{Disabling,,, emacs, The GNU
Emacs Manual}を参照してください。コマンドの無効化は、それをLispプログラムから関数として呼び出したときは効果がありません。

@deffn Command enable-command command
その時点より、特別な確認なしで@var{command}(シンボル)が実行されることを許す。さらにユーザーのinitファイル(@ref{Init
File}を参照)も修正するので、将来のセッションにもこれが適用される。
@end deffn

@deffn Command disable-command command
その時点より、@var{command}(シンボル)の実行に特別な確認を要求する。さらにユーザーのinitファイル(@ref{Init
File}を参照)も修正するので、将来のセッションにもこれが適用される。
@end deffn

@defvar disabled-command-function
この変数の値は関数であること。ユーザーが無効化されたコマンドを呼び出したときは、無効化されたコマンドのかわりにその関数が呼び出される。そのコマンドを実行するためにユーザーが何のキーをタイプしたかを判断するために@code{this-command-keys}を使用して、そのコマンド自体を探すことができる。

値が@code{nil}の場合もあり得る。その場合は、たとえ無効化されたコマンドでも、すべてのコマンドが通常に機能する。

デフォルトでは、値はユーザーに処理を行うか尋ねる関数である。
@end defvar

@node Command History
@section Command History
@cindex command history
@cindex complex command
@cindex history of commands

  The command loop keeps a history of the complex commands that have been
executed, to make it convenient to repeat these commands.  A @dfn{complex
command} is one for which the interactive argument reading uses the
minibuffer.  This includes any @kbd{M-x} command, any @kbd{M-:} command, and
any command whose @code{interactive} specification reads an argument from
the minibuffer.  Explicit use of the minibuffer during the execution of the
command itself does not cause the command to be considered complex.

@defvar command-history
This variable's value is a list of recent complex commands, each represented
as a form to evaluate.  It continues to accumulate all complex commands for
the duration of the editing session, but when it reaches the maximum size
(@pxref{Minibuffer History}), the oldest elements are deleted as new ones
are added.

@example
@group
command-history
@result{} ((switch-to-buffer "chistory.texi")
    (describe-key "^X^[")
    (visit-tags-table "~/emacs/src/")
    (find-tag "repeat-complex-command"))
@end group
@end example
@end defvar

  This history list is actually a special case of minibuffer history
(@pxref{Minibuffer History}), with one special twist: the elements are
expressions rather than strings.

  There are a number of commands devoted to the editing and recall of previous
commands.  The commands @code{repeat-complex-command}, and
@code{list-command-history} are described in the user manual
(@pxref{Repetition,,, emacs, The GNU Emacs Manual}).  Within the minibuffer,
the usual minibuffer history commands are available.

@node Keyboard Macros
@section Keyboard Macros
@cindex keyboard macros

  A @dfn{keyboard macro} is a canned sequence of input events that can be
considered a command and made the definition of a key.  The Lisp
representation of a keyboard macro is a string or vector containing the
events.  Don't confuse keyboard macros with Lisp macros (@pxref{Macros}).

@defun execute-kbd-macro kbdmacro &optional count loopfunc
This function executes @var{kbdmacro} as a sequence of events.  If
@var{kbdmacro} is a string or vector, then the events in it are executed
exactly as if they had been input by the user.  The sequence is @emph{not}
expected to be a single key sequence; normally a keyboard macro definition
consists of several key sequences concatenated.

If @var{kbdmacro} is a symbol, then its function definition is used in place
of @var{kbdmacro}.  If that is another symbol, this process repeats.
Eventually the result should be a string or vector.  If the result is not a
symbol, string, or vector, an error is signaled.

The argument @var{count} is a repeat count; @var{kbdmacro} is executed that
many times.  If @var{count} is omitted or @code{nil}, @var{kbdmacro} is
executed once.  If it is 0, @var{kbdmacro} is executed over and over until
it encounters an error or a failing search.

If @var{loopfunc} is non-@code{nil}, it is a function that is called,
without arguments, prior to each iteration of the macro.  If @var{loopfunc}
returns @code{nil}, then this stops execution of the macro.

@xref{Reading One Event}, for an example of using @code{execute-kbd-macro}.
@end defun

@defvar executing-kbd-macro
This variable contains the string or vector that defines the keyboard macro
that is currently executing.  It is @code{nil} if no macro is currently
executing.  A command can test this variable so as to behave differently
when run from an executing macro.  Do not set this variable yourself.
@end defvar

@defvar defining-kbd-macro
This variable is non-@code{nil} if and only if a keyboard macro is being
defined.  A command can test this variable so as to behave differently while
a macro is being defined.  The value is @code{append} while appending to the
definition of an existing macro.  The commands @code{start-kbd-macro},
@code{kmacro-start-macro} and @code{end-kbd-macro} set this variable---do
not set it yourself.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar last-kbd-macro
This variable is the definition of the most recently defined keyboard
macro.  Its value is a string or vector, or @code{nil}.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar kbd-macro-termination-hook
This normal hook is run when a keyboard macro terminates, regardless of what
caused it to terminate (reaching the macro end or an error which ended the
macro prematurely).
@end defvar
