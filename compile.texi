@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 2001-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Byte Compilation
@chapter Byte Compilation
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  Emacs
Lispには、Lispで記述された関数を、より効率的に実行できる@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code
interpreter)}により評価されます。

  バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアにより直接実行されるのではなく、バイトコンパイラーにより評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし、本当にコンパイルされたコードほど高速ではありません。

  一般的に、任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、逆は成り立ちません。

@vindex no-byte-compile
  あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}にバインドするファイルローカル変数を配します:

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル; 
                               バイトコードの読み方。
@end menu

@node Speed of Byte-Code
@section Performance of Byte-Compiled Code

  バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんがLispで記述されたバージョンよりは高速に実行されます。以下は例です:

@example
@group
(defun silly-loop (n)
  "Return the time, in seconds, to run N iterations of a loop."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[コンパイルされたコードは表示されない]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  この例では、インタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。

@node Compilation Functions
@section Byte-Compilation Functions
@cindex compilation functions

  @code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。

  バイトコンパイラーが警告、および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler
Errors}を参照)。これらのメッセージはCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation
Mode,,,emacs, The GNU Emacs Manual}を参照してください。

@cindex macro compilation
  バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際は、注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーは正しく処理しないでしょう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常、コンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際に、マクロ定義ファイルのロードを回避するには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval
During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。

  インライン(@code{defsubst})の関数は、これほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで、正しく機能するでしょう。

@defun byte-compile symbol
この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換えます。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければなりません。@code{byte-compile}はインダイレクト関数を処理しません。リターン値は、@var{symbol}のコンパイルされた定義であるバイトコード関数ブジェクトです(@ref{Byte-Code
Objects}を参照)。

@example
@group
(defun factorial (integer)
  "INTEGERの階乗を計算する。"
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Compute factorial of INTEGER."]
@end group
@end example

@var{symbol}の定義がバイトコード関数オブジェクトの場合、@code{byte-compile}は何も行わず@code{nil}をリターンします。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、``シンボルの定義の再コンパイル''はしません。

@code{byte-compile}の引数として@code{lambda}式も指定できます。この場合、関数は対応するコンパイル済みコードをリターンしますが、それはどこにも格納されません。
@end defun

@deffn Command compile-defun &optional arg
このコマンドはポイントを含むdefunを読み取りそれをコンパイルして、結果を評価します。実際に関数定義であるようなdefunでこれを使用した場合は、その関数のコンパイル済みバージョンをインストールする効果があります。

@code{compile-defun}は通常、評価した結果をエコーエリアに表示しますが、@var{arg}が非@code{nil}の場合は、そのフォームをコンパイルした後にカレントバッファーに結果を挿入します。
@end deffn

@deffn Command byte-compile-file filename &optional load
この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルします。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成されます。@var{filename}が@samp{.el}で終了しない場合は、@samp{.elc}を@var{filename}の最後に付け足します。

コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能します。フォームが関数またはマクロの場合は、コンパイル済みの関数またはマクロが書き込まれます。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされ、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれます。入力ファイルを読み取る際、すべてのコメントは無視されます。

このコマンドはエラーのないときは@code{t}、それ以外は@code{nil}をリターンします。インタラクティブに呼び出されたときは、ファイル名の入力をもとめます。

@var{load}が非@code{nil}の場合、このコマンドはコンパイルした後にコンパイルされたファイルをロードします。インタラクティブに呼び出された場合、@var{load}はプレフィクス引数です。

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
このコマンドは、@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルします。@samp{.elc}ファイルが存在し、それが@samp{.el}より古いファイルは、リコンパイルが必要です。

@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合、何を行うかを@var{flag}で指定します。@code{nil}の場合、このコマンドはこれらのファイルを無視します。@var{flag}が0のときは、それらをコンパイルします。@code{nil}と0以外の場合は、それらのファイルをコンパイルするかユーザーに尋ね、同様にそれぞれのサブディレクトリーについても尋ねます。

インタラクティブに呼び出された場合、@code{byte-recompile-directory}は@var{directory}の入力を求め、@var{flag}はプレフィクス引数になります。

@var{force}が非@code{nil}の場合、このコマンドは@samp{.elc}ファイルのあるすべての@samp{.el}ファイルをリコンパイルします。

リターン値は不定です。
@end deffn

@defun batch-byte-compile &optional noforce
この関数は、コマンドラインで指定されたファイルにたいして、@code{byte-compile-file}を実行します。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行だけで使用しなければなりません。1つのファイルでエラーが発生しても、それにより後続のファイルにたいする処理が妨げられることはありませんが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了します。

@var{noforce}が非@code{nil}の場合、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしません。

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section Documentation Strings and Compilation
@cindex dynamic loading of documentation

  When Emacs loads functions and variables from a byte-compiled file, it
normally does not load their documentation strings into memory.  Each
documentation string is ``dynamically'' loaded from the byte-compiled file
only when needed.  This saves memory, and speeds up loading by skipping the
processing of the documentation strings.

  This feature has a drawback: if you delete, move, or alter the compiled file
(such as by compiling a new version), Emacs may no longer be able to access
the documentation string of previously-loaded functions or variables.  Such
a problem normally only occurs if you build Emacs yourself, and happen to
edit and/or recompile the Lisp source files.  To solve it, just reload each
file after recompilation.

  Dynamic loading of documentation strings from byte-compiled files is
determined, at compile time, for each byte-compiled file.  It can be
disabled via the option @code{byte-compile-dynamic-docstrings}.

@defopt byte-compile-dynamic-docstrings
If this is non-@code{nil}, the byte compiler generates compiled files that
are set up for dynamic loading of documentation strings.

To disable the dynamic loading feature for a specific file, set this option
to @code{nil} in its header line (@pxref{File Variables, , Local Variables
in Files, emacs, The GNU Emacs Manual}), like this:

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

This is useful mainly if you expect to change the file, and you want Emacs
sessions that have already loaded it to keep working when the file changes.
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
Internally, the dynamic loading of documentation strings is accomplished by
writing compiled files with a special Lisp reader construct,
@samp{#@@@var{count}}.  This construct skips the next @var{count}
characters.  It also uses the @samp{#$} construct, which stands for ``the
name of this file, as a string''.  Do not use these constructs in Lisp
source files; they are not designed to be clear to humans reading the file.

@node Dynamic Loading
@section Dynamic Loading of Individual Functions

@cindex dynamic loading of functions
@cindex lazy loading
  When you compile a file, you can optionally enable the @dfn{dynamic function
loading} feature (also known as @dfn{lazy loading}).  With dynamic function
loading, loading the file doesn't fully read the function definitions in the
file.  Instead, each function definition contains a place-holder which
refers to the file.  The first time each function is called, it reads the
full definition from the file, to replace the place-holder.

  The advantage of dynamic function loading is that loading the file becomes
much faster.  This is a good thing for a file which contains many separate
user-callable functions, if using one of them does not imply you will
probably also use the rest.  A specialized mode which provides many keyboard
commands often has that usage pattern: a user may invoke the mode, but use
only a few of the commands it provides.

  The dynamic loading feature has certain disadvantages:

@itemize @bullet
@item
If you delete or move the compiled file after loading it, Emacs can no
longer load the remaining function definitions not already loaded.

@item
If you alter the compiled file (such as by compiling a new version), then
trying to load any function not already loaded will usually yield nonsense
results.
@end itemize

  These problems will never happen in normal circumstances with installed
Emacs files.  But they are quite likely to happen with Lisp files that you
are changing.  The easiest way to prevent these problems is to reload the
new compiled file immediately after each recompilation.

  The byte compiler uses the dynamic function loading feature if the variable
@code{byte-compile-dynamic} is non-@code{nil} at compilation time.  Do not
set this variable globally, since dynamic loading is desirable only for
certain files.  Instead, enable the feature for specific source files with
file-local variable bindings.  For example, you could do it by writing this
text in the source file's first line:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
If this is non-@code{nil}, the byte compiler generates compiled files that
are set up for dynamic function loading.
@end defvar

@defun fetch-bytecode function
If @var{function} is a byte-code function object, this immediately finishes
loading the byte code of @var{function} from its byte-compiled file, if it
is not fully loaded already.  Otherwise, it does nothing.  It always returns
@var{function}.
@end defun

@node Eval During Compile
@section Evaluation During Compilation
@cindex eval during compilation

  These features permit you to write code to be evaluated during compilation
of a program.

@defspec eval-and-compile body@dots{}
This form marks @var{body} to be evaluated both when you compile the
containing code and when you run it (whether compiled or not).

You can get a similar result by putting @var{body} in a separate file and
referring to that file with @code{require}.  That method is preferable when
@var{body} is large.  Effectively @code{require} is automatically
@code{eval-and-compile}, the package is loaded both when compiling and
executing.

@code{autoload} is also effectively @code{eval-and-compile} too.  It's
recognized when compiling, so uses of such a function don't produce ``not
known to be defined'' warnings.

Most uses of @code{eval-and-compile} are fairly sophisticated.

If a macro has a helper function to build its result, and that macro is used
both locally and outside the package, then @code{eval-and-compile} should be
used to get the helper both when compiling and then later when running.

If functions are defined programmatically (with @code{fset} say), then
@code{eval-and-compile} can be used to have that done at compile-time as
well as run-time, so calls to those functions are checked (and warnings
about ``not known to be defined'' suppressed).
@end defspec

@defspec eval-when-compile body@dots{}
This form marks @var{body} to be evaluated at compile time but not when the
compiled program is loaded.  The result of evaluation by the compiler
becomes a constant which appears in the compiled program.  If you load the
source file, rather than compiling it, @var{body} is evaluated normally.

@cindex compile-time constant
If you have a constant that needs some calculation to produce,
@code{eval-when-compile} can do that at compile-time.  For example,

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
If you're using another package, but only need macros from it (the byte
compiler will expand those), then @code{eval-when-compile} can be used to
load it for compiling, but not executing.  For example,

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

The same sort of thing goes for macros and @code{defsubst} functions defined
locally and only for use within the file.  They are needed for compiling the
file, but in most cases they are not needed for execution of the compiled
file.  For example,

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
This is often good for code that's only a fallback for compatibility with
other versions of Emacs.

@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is
analogous to the Common Lisp idiom @code{(eval-when (compile eval)
@dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when
interpreting) is closer to what @code{eval-when-compile} does.
@end defspec

@node Compiler Errors
@section Compiler Errors
@cindex compiler errors

  Error and warning messages from byte compilation are printed in a buffer
named @file{*Compile-Log*}.  These messages include file names and line
numbers identifying the location of the problem.  The usual Emacs commands
for operating on compiler output can be used on these messages.

  When an error is due to invalid syntax in the program, the byte compiler
might get confused about the errors' exact location.  One way to investigate
is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name
starts with a space, so it does not show up in the Buffer Menu.)  This
buffer contains the program being compiled, and point shows how far the byte
compiler was able to read; the cause of the error might be nearby.
@xref{Syntax Errors}, for some tips for locating syntax errors.

  A common type of warning issued by the byte compiler is for functions and
variables that were used but not defined.  Such warnings report the line
number for the end of the file, not the locations where the missing
functions or variables were used; to find these, you must search the file
manually.

  If you are sure that a warning message about a missing function or variable
is unjustified, there are several ways to suppress it:

@itemize @bullet
@item
You can suppress the warning for a specific call to a function @var{func} by
conditionalizing it on an @code{fboundp} test, like this:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
The call to @var{func} must be in the @var{then-form} of the @code{if}, and
@var{func} must appear quoted in the call to @code{fboundp}.  (This feature
operates for @code{cond} as well.)

@item
Likewise, you can suppress the warning for a specific use of a variable
@var{variable} by conditionalizing it on a @code{boundp} test:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
The reference to @var{variable} must be in the @var{then-form} of the
@code{if}, and @var{variable} must appear quoted in the call to
@code{boundp}.

@item
You can tell the compiler that a function is defined using
@code{declare-function}. @xref{Declaring Functions}.

@item
Likewise, you can tell the compiler that a variable is defined using
@code{defvar} with no initial value.  (Note that this marks the variable as
special.)  @xref{Defining Variables}.
@end itemize

  You can also suppress any and all compiler warnings within a certain
expression using the construct @code{with-no-warnings}:

@c This is implemented with a defun, but conceptually it is
@c a special form.

@defspec with-no-warnings body@dots{}
In execution, this is equivalent to @code{(progn @var{body}...)}, but the
compiler does not issue warnings for anything that occurs inside @var{body}.

We recommend that you use this construct around the smallest possible piece
of code, to avoid missing possible warnings other than one you intend to
suppress.
@end defspec

  Byte compiler warnings can be controlled more precisely by setting the
variable @code{byte-compile-warnings}.  See its documentation string for
details.

@node Byte-Code Objects
@section Byte-Code Function Objects
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  Byte-compiled functions have a special data type: they are @dfn{byte-code
function objects}.  Whenever such an object appears as a function to be
called, Emacs uses the byte-code interpreter to execute the byte-code.

  Internally, a byte-code function object is much like a vector; its elements
can be accessed using @code{aref}.  Its printed representation is like that
for a vector, with an additional @samp{#} before the opening @samp{[}.  It
must have at least four elements; there is no maximum number, but only the
first six elements have any normal use.  They are:

@table @var
@item arglist
The list of argument symbols.

@item byte-code
The string containing the byte-code instructions.

@item constants
The vector of Lisp objects referenced by the byte code.  These include
symbols used as function names and variable names.

@item stacksize
The maximum stack size this function needs.

@item docstring
The documentation string (if any); otherwise, @code{nil}.  The value may be
a number or a list, in case the documentation string is stored in a file.
Use the function @code{documentation} to get the real documentation string
(@pxref{Accessing Documentation}).

@item interactive
The interactive spec (if any).  This can be a string or a Lisp expression.
It is @code{nil} for a function that isn't interactive.
@end table

Here's an example of a byte-code function object, in printed
representation.  It is the definition of the command @code{backward-sexp}.

@example
#[(&optional arg)
  "^H\204^F^@@\301^P\302^H[!\207"
  [arg 1 forward-sexp]
  2
  254435
  "^p"]
@end example

  The primitive way to create a byte-code object is with
@code{make-byte-code}:

@defun make-byte-code &rest elements
This function constructs and returns a byte-code function object with
@var{elements} as its elements.
@end defun

  You should not try to come up with the elements for a byte-code function
yourself, because if they are inconsistent, Emacs may crash when you call
the function.  Always leave it to the byte compiler to create these objects;
it makes the elements consistent (we hope).

@node Disassembly
@section Disassembled Byte-Code
@cindex disassembled byte-code

  People do not write byte-code; that job is left to the byte compiler.  But
we provide a disassembler to satisfy a cat-like curiosity.  The disassembler
converts the byte-compiled code into human-readable form.

  The byte-code interpreter is implemented as a simple stack machine.  It
pushes values onto a stack of its own, then pops them off to use them in
calculations whose results are themselves pushed back on the stack.  When a
byte-code function returns, it pops a value off the stack and returns it as
the value of the function.

  In addition to the stack, byte-code functions can use, bind, and set
ordinary Lisp variables, by transferring values between variables and the
stack.

@deffn Command disassemble object &optional buffer-or-name
This command displays the disassembled code for @var{object}.  In
interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the
output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name}
is non-@code{nil}, it must be a buffer or the name of an existing buffer.
Then the output goes there, at point, and point is left before the output.

The argument @var{object} can be a function name, a lambda expression
(@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code
Objects}).  If it is a lambda expression, @code{disassemble} compiles it and
disassembles the resulting compiled code.
@end deffn

  Here are two examples of using the @code{disassemble} function.  We have
added explanatory comments to help you relate the byte-code to the Lisp
source; these do not appear in the output of @code{disassemble}.

@example
@group
(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{Get the value of @code{integer} and}
                          ;   @r{push it onto the stack.}
1   constant 1            ; @r{Push 1 onto stack.}
@end group
@group
2   eqlsign               ; @r{Pop top two values off stack, compare}
                          ;   @r{them, and push result onto stack.}
@end group
@group
3   goto-if-nil 1         ; @r{Pop and test top of stack;}
                          ;   @r{if @code{nil}, go to 1, else continue.}
6   constant 1            ; @r{Push 1 onto top of stack.}
7   return                ; @r{Return the top element of the stack.}
@end group
@group
8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}
9   constant factorial    ; @r{Push @code{factorial} onto stack.}
10  varref   integer      ; @r{Push value of @code{integer} onto stack.}
11  sub1                  ; @r{Pop @code{integer}, decrement value,}
                          ;   @r{push new value onto stack.}
12  call     1            ; @r{Call function @code{factorial} using first}
                          ;   @r{(i.e., top) stack element as argument;}
                          ;   @r{push returned value onto stack.}
@end group
@group
13 mult                   ; @r{Pop top two values off stack, multiply}
                          ;   @r{them, and push result onto stack.}
14 return                 ; @r{Return the top element of the stack.}
@end group
@end example

The @code{silly-loop} function is somewhat more complex:

@example
@group
(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto top of stack.}
@end group
@group
1   call     0            ; @r{Call @code{current-time-string} with no}
                          ;   @r{argument, push result onto stack.}
@end group
@group
2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped value.}
@end group
@group
3:1 varref   n            ; @r{Get value of @code{n} from the environment}
                          ;   @r{and push the value on the stack.}
4   sub1                  ; @r{Subtract 1 from top of stack.}
@end group
@group
5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}
                          ;   @r{of the stack and push copy onto stack.}
6   varset   n            ; @r{Pop the top of the stack,}
                          ;   @r{and bind @code{n} to the value.}

;; @r{(In effect, the sequence @code{dup varset} copies the top of the stack}
;; @r{into the value of @code{n} without popping it.)}
@end group

@group
7   constant 0            ; @r{Push 0 onto stack.}
8   gtr                   ; @r{Pop top two values off stack,}
                          ;   @r{test if @var{n} is greater than 0}
                          ;   @r{and push result onto stack.}
@end group
@group
9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}
                          ;   @r{(this continues the while loop)}
                          ;   @r{else continue.}
@end group
@group
12  varref   t1           ; @r{Push value of @code{t1} onto stack.}
13  constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto the top of the stack.}
14  call     0            ; @r{Call @code{current-time-string} again.}
@end group
@group
15  unbind   1            ; @r{Unbind @code{t1} in local environment.}
16  list2                 ; @r{Pop top two elements off stack, create a}
                          ;   @r{list of them, and push it onto stack.}
17  return                ; @r{Return value of the top of stack.}
@end group
@end example
