@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 2001-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Byte Compilation
@chapter Byte Compilation
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  Emacs
Lispには、Lispで記述された関数を、より効率的に実行できる@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code
interpreter)}により評価されます。

  バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアにより直接実行されるのではなく、バイトコンパイラーにより評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし、本当にコンパイルされたコードほど高速ではありません。

  一般的に、任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、逆は成り立ちません。

@vindex no-byte-compile
  あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}にバインドするファイルローカル変数を配します:

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル; 
                               バイトコードの読み方。
@end menu

@node Speed of Byte-Code
@section Performance of Byte-Compiled Code

  バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんがLispで記述されたバージョンよりは高速に実行されます。以下は例です:

@example
@group
(defun silly-loop (n)
  "Return the time, in seconds, to run N iterations of a loop."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[コンパイルされたコードは表示されない]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  この例では、インタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。

@node Compilation Functions
@section Byte-Compilation Functions
@cindex compilation functions

  @code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。

  バイトコンパイラーが警告、および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler
Errors}を参照)。これらのメッセージはCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation
Mode,,,emacs, The GNU Emacs Manual}を参照してください。

@cindex macro compilation
  バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際は、注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーは正しく処理しないでしょう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常、コンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際に、マクロ定義ファイルのロードを回避するには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval
During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。

  インライン(@code{defsubst})の関数は、これほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで、正しく機能するでしょう。

@defun byte-compile symbol
この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換えます。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければなりません。@code{byte-compile}はインダイレクト関数を処理しません。リターン値は、@var{symbol}のコンパイルされた定義であるバイトコード関数ブジェクトです(@ref{Byte-Code
Objects}を参照)。

@example
@group
(defun factorial (integer)
  "INTEGERの階乗を計算する。"
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Compute factorial of INTEGER."]
@end group
@end example

@var{symbol}の定義がバイトコード関数オブジェクトの場合、@code{byte-compile}は何も行わず@code{nil}をリターンします。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、``シンボルの定義の再コンパイル''はしません。

@code{byte-compile}の引数として@code{lambda}式も指定できます。この場合、関数は対応するコンパイル済みコードをリターンしますが、それはどこにも格納されません。
@end defun

@deffn Command compile-defun &optional arg
このコマンドはポイントを含むdefunを読み取りそれをコンパイルして、結果を評価します。実際に関数定義であるようなdefunでこれを使用した場合は、その関数のコンパイル済みバージョンをインストールする効果があります。

@code{compile-defun}は通常、評価した結果をエコーエリアに表示しますが、@var{arg}が非@code{nil}の場合は、そのフォームをコンパイルした後にカレントバッファーに結果を挿入します。
@end deffn

@deffn Command byte-compile-file filename &optional load
この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルします。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成されます。@var{filename}が@samp{.el}で終了しない場合は、@samp{.elc}を@var{filename}の最後に付け足します。

コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能します。フォームが関数またはマクロの場合は、コンパイル済みの関数またはマクロが書き込まれます。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされ、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれます。入力ファイルを読み取る際、すべてのコメントは無視されます。

このコマンドはエラーのないときは@code{t}、それ以外は@code{nil}をリターンします。インタラクティブに呼び出されたときは、ファイル名の入力をもとめます。

@var{load}が非@code{nil}の場合、このコマンドはコンパイルした後にコンパイルされたファイルをロードします。インタラクティブに呼び出された場合、@var{load}はプレフィクス引数です。

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
このコマンドは、@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルします。@samp{.elc}ファイルが存在し、それが@samp{.el}より古いファイルは、リコンパイルが必要です。

@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合、何を行うかを@var{flag}で指定します。@code{nil}の場合、このコマンドはこれらのファイルを無視します。@var{flag}が0のときは、それらをコンパイルします。@code{nil}と0以外の場合は、それらのファイルをコンパイルするかユーザーに尋ね、同様にそれぞれのサブディレクトリーについても尋ねます。

インタラクティブに呼び出された場合、@code{byte-recompile-directory}は@var{directory}の入力を求め、@var{flag}はプレフィクス引数になります。

@var{force}が非@code{nil}の場合、このコマンドは@samp{.elc}ファイルのあるすべての@samp{.el}ファイルをリコンパイルします。

リターン値は不定です。
@end deffn

@defun batch-byte-compile &optional noforce
この関数は、コマンドラインで指定されたファイルにたいして、@code{byte-compile-file}を実行します。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行だけで使用しなければなりません。1つのファイルでエラーが発生しても、それにより後続のファイルにたいする処理が妨げられることはありませんが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了します。

@var{noforce}が非@code{nil}の場合、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしません。

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section Documentation Strings and Compilation
@cindex dynamic loading of documentation

  Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルから``ダイナミック(dynamic:
動的)''にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約され、ロードが高速になります。

  この機能には欠点があります。コンパイル済みのファイルを削除、移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは前にロードされた関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常、あなた自身がEmacsをビルドした場合に、そのLispファイルを編集、および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。

  バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとに、コンパイル時に決定されます。これはオプション@code{byte-compile-dynamic-docstrings}により、無効にできます。

@defopt byte-compile-dynamic-docstrings
これが非@code{nil}の場合、バイトコンパイラーはドキュメント文字列をダイナミックロードするようセットアップしたコンパイル済みファイルを生成します。

特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行(@ref{File Variables, , Local
Variables in Files, emacs, The GNU Emacs
Manual}を参照)で、このオプションに@code{nil}をセットします。

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

これは主に、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用です。
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
内部的には、ドキュメント文字列のダイナミックロードは、特殊なLispリーダー構成@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことにより達成されます。この構成は、次の@var{count}文字をスキップします。さらに@samp{#$}構成も使用され、これは``このファイルの名前(文字列)''を意味します。これらの構成をLispソースファイル内で使用しないでください。これらは人間がファイルを読む際に明確であるようデザインされていません。

@node Dynamic Loading
@section Dynamic Loading of Individual Functions

@cindex dynamic loading of functions
@cindex lazy loading
  ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function
loading)}機能(@dfn{laxyロード(lazy
loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに、各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときに、そのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。

  ダイナミック関数ロードの利点は、ファイルのロードがより高速になることです。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら、おそらく残りの関数も使用するというのでなければ、これは利点です。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。

  ダイナミックロード機能には、いくつか不利な点があります:

@itemize @bullet
@item
ロード後にコンパイル済みファイルを削除や移動した場合、Emacsはまだロードされていない残りの関数定義をロードできなくなる。

@item
(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合、まだロードされていない関数のロードを試みると、通常は無意味な結果となる。
@end itemize

  このような問題は、通常の状況でインストールされたEmacsファイルでは決して発生しません。しかし、あなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに、新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。

  コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}の場合、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数で、この機能を有効にしてください。たとえば、ソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
これが非@code{nil}の場合、バイトコンパイラーはダイナミック関数ロードのためにセットアップされたコンパイル済みファイルを生成します。
@end defvar

@defun fetch-bytecode function
@var{function}がバイトコード関数オブジェクトの場合、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを終了します。それ以外は、何も行いません。この関数は、常に@var{function}をリターンします。
@end defun

@node Eval During Compile
@section Evaluation During Compilation
@cindex eval during compilation

  These features permit you to write code to be evaluated during compilation
of a program.

@defspec eval-and-compile body@dots{}
This form marks @var{body} to be evaluated both when you compile the
containing code and when you run it (whether compiled or not).

You can get a similar result by putting @var{body} in a separate file and
referring to that file with @code{require}.  That method is preferable when
@var{body} is large.  Effectively @code{require} is automatically
@code{eval-and-compile}, the package is loaded both when compiling and
executing.

@code{autoload} is also effectively @code{eval-and-compile} too.  It's
recognized when compiling, so uses of such a function don't produce ``not
known to be defined'' warnings.

Most uses of @code{eval-and-compile} are fairly sophisticated.

If a macro has a helper function to build its result, and that macro is used
both locally and outside the package, then @code{eval-and-compile} should be
used to get the helper both when compiling and then later when running.

If functions are defined programmatically (with @code{fset} say), then
@code{eval-and-compile} can be used to have that done at compile-time as
well as run-time, so calls to those functions are checked (and warnings
about ``not known to be defined'' suppressed).
@end defspec

@defspec eval-when-compile body@dots{}
This form marks @var{body} to be evaluated at compile time but not when the
compiled program is loaded.  The result of evaluation by the compiler
becomes a constant which appears in the compiled program.  If you load the
source file, rather than compiling it, @var{body} is evaluated normally.

@cindex compile-time constant
If you have a constant that needs some calculation to produce,
@code{eval-when-compile} can do that at compile-time.  For example,

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
If you're using another package, but only need macros from it (the byte
compiler will expand those), then @code{eval-when-compile} can be used to
load it for compiling, but not executing.  For example,

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

The same sort of thing goes for macros and @code{defsubst} functions defined
locally and only for use within the file.  They are needed for compiling the
file, but in most cases they are not needed for execution of the compiled
file.  For example,

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
This is often good for code that's only a fallback for compatibility with
other versions of Emacs.

@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is
analogous to the Common Lisp idiom @code{(eval-when (compile eval)
@dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when
interpreting) is closer to what @code{eval-when-compile} does.
@end defspec

@node Compiler Errors
@section Compiler Errors
@cindex compiler errors

  Error and warning messages from byte compilation are printed in a buffer
named @file{*Compile-Log*}.  These messages include file names and line
numbers identifying the location of the problem.  The usual Emacs commands
for operating on compiler output can be used on these messages.

  When an error is due to invalid syntax in the program, the byte compiler
might get confused about the errors' exact location.  One way to investigate
is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name
starts with a space, so it does not show up in the Buffer Menu.)  This
buffer contains the program being compiled, and point shows how far the byte
compiler was able to read; the cause of the error might be nearby.
@xref{Syntax Errors}, for some tips for locating syntax errors.

  A common type of warning issued by the byte compiler is for functions and
variables that were used but not defined.  Such warnings report the line
number for the end of the file, not the locations where the missing
functions or variables were used; to find these, you must search the file
manually.

  If you are sure that a warning message about a missing function or variable
is unjustified, there are several ways to suppress it:

@itemize @bullet
@item
You can suppress the warning for a specific call to a function @var{func} by
conditionalizing it on an @code{fboundp} test, like this:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
The call to @var{func} must be in the @var{then-form} of the @code{if}, and
@var{func} must appear quoted in the call to @code{fboundp}.  (This feature
operates for @code{cond} as well.)

@item
Likewise, you can suppress the warning for a specific use of a variable
@var{variable} by conditionalizing it on a @code{boundp} test:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
The reference to @var{variable} must be in the @var{then-form} of the
@code{if}, and @var{variable} must appear quoted in the call to
@code{boundp}.

@item
You can tell the compiler that a function is defined using
@code{declare-function}. @xref{Declaring Functions}.

@item
Likewise, you can tell the compiler that a variable is defined using
@code{defvar} with no initial value.  (Note that this marks the variable as
special.)  @xref{Defining Variables}.
@end itemize

  You can also suppress any and all compiler warnings within a certain
expression using the construct @code{with-no-warnings}:

@c This is implemented with a defun, but conceptually it is
@c a special form.

@defspec with-no-warnings body@dots{}
In execution, this is equivalent to @code{(progn @var{body}...)}, but the
compiler does not issue warnings for anything that occurs inside @var{body}.

We recommend that you use this construct around the smallest possible piece
of code, to avoid missing possible warnings other than one you intend to
suppress.
@end defspec

  Byte compiler warnings can be controlled more precisely by setting the
variable @code{byte-compile-warnings}.  See its documentation string for
details.

@node Byte-Code Objects
@section Byte-Code Function Objects
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  Byte-compiled functions have a special data type: they are @dfn{byte-code
function objects}.  Whenever such an object appears as a function to be
called, Emacs uses the byte-code interpreter to execute the byte-code.

  Internally, a byte-code function object is much like a vector; its elements
can be accessed using @code{aref}.  Its printed representation is like that
for a vector, with an additional @samp{#} before the opening @samp{[}.  It
must have at least four elements; there is no maximum number, but only the
first six elements have any normal use.  They are:

@table @var
@item arglist
The list of argument symbols.

@item byte-code
The string containing the byte-code instructions.

@item constants
The vector of Lisp objects referenced by the byte code.  These include
symbols used as function names and variable names.

@item stacksize
The maximum stack size this function needs.

@item docstring
The documentation string (if any); otherwise, @code{nil}.  The value may be
a number or a list, in case the documentation string is stored in a file.
Use the function @code{documentation} to get the real documentation string
(@pxref{Accessing Documentation}).

@item interactive
The interactive spec (if any).  This can be a string or a Lisp expression.
It is @code{nil} for a function that isn't interactive.
@end table

Here's an example of a byte-code function object, in printed
representation.  It is the definition of the command @code{backward-sexp}.

@example
#[(&optional arg)
  "^H\204^F^@@\301^P\302^H[!\207"
  [arg 1 forward-sexp]
  2
  254435
  "^p"]
@end example

  The primitive way to create a byte-code object is with
@code{make-byte-code}:

@defun make-byte-code &rest elements
This function constructs and returns a byte-code function object with
@var{elements} as its elements.
@end defun

  You should not try to come up with the elements for a byte-code function
yourself, because if they are inconsistent, Emacs may crash when you call
the function.  Always leave it to the byte compiler to create these objects;
it makes the elements consistent (we hope).

@node Disassembly
@section Disassembled Byte-Code
@cindex disassembled byte-code

  People do not write byte-code; that job is left to the byte compiler.  But
we provide a disassembler to satisfy a cat-like curiosity.  The disassembler
converts the byte-compiled code into human-readable form.

  The byte-code interpreter is implemented as a simple stack machine.  It
pushes values onto a stack of its own, then pops them off to use them in
calculations whose results are themselves pushed back on the stack.  When a
byte-code function returns, it pops a value off the stack and returns it as
the value of the function.

  In addition to the stack, byte-code functions can use, bind, and set
ordinary Lisp variables, by transferring values between variables and the
stack.

@deffn Command disassemble object &optional buffer-or-name
This command displays the disassembled code for @var{object}.  In
interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the
output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name}
is non-@code{nil}, it must be a buffer or the name of an existing buffer.
Then the output goes there, at point, and point is left before the output.

The argument @var{object} can be a function name, a lambda expression
(@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code
Objects}).  If it is a lambda expression, @code{disassemble} compiles it and
disassembles the resulting compiled code.
@end deffn

  Here are two examples of using the @code{disassemble} function.  We have
added explanatory comments to help you relate the byte-code to the Lisp
source; these do not appear in the output of @code{disassemble}.

@example
@group
(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{Get the value of @code{integer} and}
                          ;   @r{push it onto the stack.}
1   constant 1            ; @r{Push 1 onto stack.}
@end group
@group
2   eqlsign               ; @r{Pop top two values off stack, compare}
                          ;   @r{them, and push result onto stack.}
@end group
@group
3   goto-if-nil 1         ; @r{Pop and test top of stack;}
                          ;   @r{if @code{nil}, go to 1, else continue.}
6   constant 1            ; @r{Push 1 onto top of stack.}
7   return                ; @r{Return the top element of the stack.}
@end group
@group
8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}
9   constant factorial    ; @r{Push @code{factorial} onto stack.}
10  varref   integer      ; @r{Push value of @code{integer} onto stack.}
11  sub1                  ; @r{Pop @code{integer}, decrement value,}
                          ;   @r{push new value onto stack.}
12  call     1            ; @r{Call function @code{factorial} using first}
                          ;   @r{(i.e., top) stack element as argument;}
                          ;   @r{push returned value onto stack.}
@end group
@group
13 mult                   ; @r{Pop top two values off stack, multiply}
                          ;   @r{them, and push result onto stack.}
14 return                 ; @r{Return the top element of the stack.}
@end group
@end example

The @code{silly-loop} function is somewhat more complex:

@example
@group
(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto top of stack.}
@end group
@group
1   call     0            ; @r{Call @code{current-time-string} with no}
                          ;   @r{argument, push result onto stack.}
@end group
@group
2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped value.}
@end group
@group
3:1 varref   n            ; @r{Get value of @code{n} from the environment}
                          ;   @r{and push the value on the stack.}
4   sub1                  ; @r{Subtract 1 from top of stack.}
@end group
@group
5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}
                          ;   @r{of the stack and push copy onto stack.}
6   varset   n            ; @r{Pop the top of the stack,}
                          ;   @r{and bind @code{n} to the value.}

;; @r{(In effect, the sequence @code{dup varset} copies the top of the stack}
;; @r{into the value of @code{n} without popping it.)}
@end group

@group
7   constant 0            ; @r{Push 0 onto stack.}
8   gtr                   ; @r{Pop top two values off stack,}
                          ;   @r{test if @var{n} is greater than 0}
                          ;   @r{and push result onto stack.}
@end group
@group
9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}
                          ;   @r{(this continues the while loop)}
                          ;   @r{else continue.}
@end group
@group
12  varref   t1           ; @r{Push value of @code{t1} onto stack.}
13  constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto the top of the stack.}
14  call     0            ; @r{Call @code{current-time-string} again.}
@end group
@group
15  unbind   1            ; @r{Unbind @code{t1} in local environment.}
16  list2                 ; @r{Pop top two elements off stack, create a}
                          ;   @r{list of them, and push it onto stack.}
17  return                ; @r{Return value of the top of stack.}
@end group
@end example
