# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs 24.5\n"
"POT-Creation-Date: 2018-01-06 03:51+0900\n"
"PO-Revision-Date: 2018-01-07 22:05+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: compile.texi.orig:5 compile.texi.orig:6
#, no-wrap
msgid "Byte Compilation"
msgstr "Byte Compilation"

#. type: cindex
#: compile.texi.orig:7
#, no-wrap
msgid "byte compilation"
msgstr "byte compilation"

#. type: item
#: compile.texi.orig:8 compile.texi.orig:539
#, no-wrap
msgid "byte-code"
msgstr "byte-code"

#. type: cindex
#: compile.texi.orig:9
#, no-wrap
msgid "compilation (Emacs Lisp)"
msgstr "compilation (Emacs Lisp)"

#. type: Plain text
#: compile.texi.orig:16
msgid ""
"Emacs Lisp has a @dfn{compiler} that translates functions written in Lisp "
"into a special representation called @dfn{byte-code} that can be executed "
"more efficiently.  The compiler replaces Lisp function definitions with "
"byte-code.  When a byte-code function is called, its definition is evaluated "
"by the @dfn{byte-code interpreter}."
msgstr "Emacs Lispには、Lispで記述された関数を、より効率的に実行できる@dfn{バイトコード(byte-code)}と呼ばれる特別な表現に翻訳する@dfn{コンパイラー(compiler)}があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義は@dfn{バイトコードインタープリター(byte-code interpreter)}により評価されます。"

#. type: Plain text
#: compile.texi.orig:22
msgid ""
"Because the byte-compiled code is evaluated by the byte-code interpreter, "
"instead of being executed directly by the machine's hardware (as true "
"compiled code is), byte-code is completely transportable from machine to "
"machine without recompilation.  It is not, however, as fast as true compiled "
"code."
msgstr "バイトコンパイルされたコードは、(本当のコンパイル済みコードのように)そのマシンのハードウェアにより直接実行されるのではなく、バイトコンパイラーにより評価されるため、バイトコードはリコンパイルしなくてもマシン間での完全な可搬性を有します。しかし、本当にコンパイルされたコードほど高速ではありません。"

#. type: Plain text
#: compile.texi.orig:25
msgid ""
"In general, any version of Emacs can run byte-compiled code produced by "
"recent earlier versions of Emacs, but the reverse is not true."
msgstr "一般的に、任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより生成されたバイトコンパイル済みコードを実行できますが、逆は成り立ちません。"

#. type: vindex
#: compile.texi.orig:26
#, no-wrap
msgid "no-byte-compile"
msgstr "no-byte-compile"

#. type: Plain text
#: compile.texi.orig:29
msgid ""
"If you do not want a Lisp file to be compiled, ever, put a file-local "
"variable binding for @code{no-byte-compile} into it, like this:"
msgstr "あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように@code{no-byte-compile}にバインドするファイルローカル変数を配します:"

#. type: example
#: compile.texi.orig:32
#, no-wrap
msgid ";; -*-no-byte-compile: t; -*-\n"
msgstr ";; -*-no-byte-compile: t; -*-\n"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:45
#, no-wrap
msgid "Speed of Byte-Code"
msgstr "Speed of Byte-Code"

#. type: menuentry
#: compile.texi.orig:43
msgid "An example of speedup from byte compilation."
msgstr "バイトコンパイルによるスピードアップ例。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:82
#, no-wrap
msgid "Compilation Functions"
msgstr "Compilation Functions"

#. type: menuentry
#: compile.texi.orig:43
msgid "Byte compilation functions."
msgstr "バイトコンパイル関数。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:239
#, no-wrap
msgid "Docs and Compilation"
msgstr "Docs and Compilation"

#. type: menuentry
#: compile.texi.orig:43
msgid "Dynamic loading of documentation strings."
msgstr "ドキュメント文字列のダイナミックロード。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:287
#, no-wrap
msgid "Dynamic Loading"
msgstr "Dynamic Loading"

#. type: menuentry
#: compile.texi.orig:43
msgid "Dynamic loading of individual functions."
msgstr "個々の関数のダイナミックロード。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:348
#, no-wrap
msgid "Eval During Compile"
msgstr "Eval During Compile"

#. type: menuentry
#: compile.texi.orig:43
msgid "Code to be evaluated when you compile."
msgstr "コンパイル時に評価されるコード。"

#. type: section
#: compile.texi.orig:43 compile.texi.orig:430 compile.texi.orig:431
#, no-wrap
msgid "Compiler Errors"
msgstr "Compiler Errors"

#. type: menuentry
#: compile.texi.orig:43
msgid "Handling compiler error messages."
msgstr "コンパイラーのエラーメッセージの扱い。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:517
#, no-wrap
msgid "Byte-Code Objects"
msgstr "Byte-Code Objects"

#. type: menuentry
#: compile.texi.orig:43
msgid "The data type used for byte-compiled functions."
msgstr "バイトコンパイル済み関数に使用されるデータ型。"

#. type: node
#: compile.texi.orig:43 compile.texi.orig:586
#, no-wrap
msgid "Disassembly"
msgstr "Disassembly"

#. type: menuentry
#: compile.texi.orig:43
msgid "Disassembling byte-code; how to read byte-code."
msgstr "バイトコードの逆アセンブル; バイトコードの読み方。"

#. type: section
#: compile.texi.orig:46
#, no-wrap
msgid "Performance of Byte-Compiled Code"
msgstr "Performance of Byte-Compiled Code"

#. type: Plain text
#: compile.texi.orig:51
msgid ""
"A byte-compiled function is not as efficient as a primitive function written "
"in C, but runs much faster than the version written in Lisp.  Here is an "
"example:"
msgstr "バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的ではありませんがLispで記述されたバージョンよりは高速に実行されます。以下は例です:"

#. type: group
#: compile.texi.orig:60
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"
msgstr ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"

#. type: group
#: compile.texi.orig:65
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"

#. type: group
#: compile.texi.orig:70
#, no-wrap
msgid ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[Compiled code not shown]}\n"
msgstr ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[コンパイルされたコードは表示されない]}\n"

#. type: group
#: compile.texi.orig:75
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"
msgstr ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"

#. type: Plain text
#: compile.texi.orig:81
msgid ""
"In this example, the interpreted code required 10 seconds to run, whereas "
"the byte-compiled code required less than 4 seconds.  These results are "
"representative, but actual results may vary."
msgstr "この例では、インタープリターによる実行には10秒を要しますが、バイトコンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結果はさまざまでしょう。"

#. type: section
#: compile.texi.orig:83
#, no-wrap
msgid "Byte-Compilation Functions"
msgstr "Byte-Compilation Functions"

#. type: cindex
#: compile.texi.orig:84
#, no-wrap
msgid "compilation functions"
msgstr "compilation functions"

#. type: Plain text
#: compile.texi.orig:90
msgid ""
"You can byte-compile an individual function or macro definition with the "
"@code{byte-compile} function.  You can compile a whole file with "
"@code{byte-compile-file}, or several files with "
"@code{byte-recompile-directory} or @code{batch-byte-compile}."
msgstr "@code{byte-compile}により、関数やマクロを個別にバイトコンパイルできます。@code{byte-compile-file}でファイル全体、@code{byte-recompile-directory}または@code{batch-byte-compile}で複数ファイルをコンパイルできます。"

#. type: Plain text
#: compile.texi.orig:95
msgid ""
"Sometimes, the byte compiler produces warning and/or error messages "
"(@pxref{Compiler Errors}, for details).  These messages are recorded in a "
"buffer called @file{*Compile-Log*}, which uses Compilation mode.  "
"@xref{Compilation Mode,,,emacs, The GNU Emacs Manual}."
msgstr "バイトコンパイラーが警告、および/またはエラーメッセージを生成することもあります(詳細は@ref{Compiler Errors}を参照)。これらのメッセージはCompilationモードが使用する@file{*Compile-Log*}と呼ばれるバッファーに記録されます。@ref{Compilation Mode,,,emacs, The GNU Emacs Manual}を参照してください。"

#. type: cindex
#: compile.texi.orig:96
#, no-wrap
msgid "macro compilation"
msgstr "macro compilation"

#. type: Plain text
#: compile.texi.orig:109
msgid ""
"Be careful when writing macro calls in files that you intend to "
"byte-compile.  Since macro calls are expanded when they are compiled, the "
"macros need to be loaded into Emacs or the byte compiler will not do the "
"right thing.  The usual way to handle this is with @code{require} forms "
"which specify the files containing the needed macro definitions "
"(@pxref{Named Features}).  Normally, the byte compiler does not evaluate the "
"code that it is compiling, but it handles @code{require} forms specially, by "
"loading the specified libraries.  To avoid loading the macro definition "
"files when someone @emph{runs} the compiled program, write "
"@code{eval-when-compile} around the @code{require} calls (@pxref{Eval During "
"Compile}).  For more details, @xref{Compiling Macros}."
msgstr "バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際は、注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロはEmacsにロードされる必要があります(さもないとバイトコンパイラーは正しく処理しないでしょう)。これを処理する通常の方法は、必要なマクロ定義を含むファイルを@code{require}フォームで指定することです。バイトコンパイラーは通常、コンパイルするコードを評価しませんが、@code{require}フォームは指定されたライブラリーをロードすることにより特別に扱われます。誰かがコンパイルされたプログラムを@emph{実行}する際に、マクロ定義ファイルのロードを回避するには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval During Compile}を参照)。詳細は@ref{Compiling Macros}を参照してください。"

#. type: Plain text
#: compile.texi.orig:113
msgid ""
"Inline (@code{defsubst}) functions are less troublesome; if you compile a "
"call to such a function before its definition is known, the call will still "
"work right, it will just run slower."
msgstr "インライン(@code{defsubst})の関数は、これほど面倒ではありません。定義が判明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは低速になるだけで、正しく機能するでしょう。"

#. type: defun
#: compile.texi.orig:114
#, no-wrap
msgid "byte-compile symbol"
msgstr "byte-compile symbol"

#. type: defun
#: compile.texi.orig:121
msgid ""
"This function byte-compiles the function definition of @var{symbol}, "
"replacing the previous definition with the compiled one.  The function "
"definition of @var{symbol} must be the actual code for the function; "
"@code{byte-compile} does not handle function indirection.  The return value "
"is the byte-code function object which is the compiled definition of "
"@var{symbol} (@pxref{Byte-Code Objects})."
msgstr "この関数は@var{symbol}の関数定義をバイトコンパイルして、以前の定義をコンパイルされた定義に置き換えます。@var{symbol}の関数定義は、その関数にたいする実際のコードでなければなりません。@code{byte-compile}はインダイレクト関数を処理しません。リターン値は、@var{symbol}のコンパイルされた定義であるバイトコード関数ブジェクトです(@ref{Byte-Code Objects}を参照)。"

#. type: group
#: compile.texi.orig:129
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of INTEGER.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"
msgstr ""
"(defun factorial (integer)\n"
"  \"INTEGERの階乗を計算する。\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"

#. type: group
#: compile.texi.orig:138
#, no-wrap
msgid ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"
msgstr ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"

#. type: defun
#: compile.texi.orig:146
msgid ""
"If @var{symbol}'s definition is a byte-code function object, "
"@code{byte-compile} does nothing and returns @code{nil}.  It does not "
"``compile the symbol's definition again'', since the original (non-compiled) "
"code has already been replaced in the symbol's function cell by the "
"byte-compiled code."
msgstr "@var{symbol}の定義がバイトコード関数オブジェクトの場合、@code{byte-compile}は何も行わず@code{nil}をリターンします。そのシンボルの関数セル内の(コンパイルされていない)オリジナルのコードはすでにバイトコンパイルされたコードに置き換えられているので、``シンボルの定義の再コンパイル''はしません。"

#. type: defun
#: compile.texi.orig:150
msgid ""
"The argument to @code{byte-compile} can also be a @code{lambda} expression.  "
"In that case, the function returns the corresponding compiled code but does "
"not store it anywhere."
msgstr "@code{byte-compile}の引数として@code{lambda}式も指定できます。この場合、関数は対応するコンパイル済みコードをリターンしますが、それはどこにも格納されません。"

#. type: deffn
#: compile.texi.orig:152
#, no-wrap
msgid "Command compile-defun &optional arg"
msgstr "Command compile-defun &optional arg"

#. type: deffn
#: compile.texi.orig:157
msgid ""
"This command reads the defun containing point, compiles it, and evaluates "
"the result.  If you use this on a defun that is actually a function "
"definition, the effect is to install a compiled version of that function."
msgstr "このコマンドはポイントを含むdefunを読み取りそれをコンパイルして、結果を評価します。実際に関数定義であるようなdefunでこれを使用した場合は、その関数のコンパイル済みバージョンをインストールする効果があります。"

#. type: deffn
#: compile.texi.orig:161
msgid ""
"@code{compile-defun} normally displays the result of evaluation in the echo "
"area, but if @var{arg} is non-@code{nil}, it inserts the result in the "
"current buffer after the form it compiled."
msgstr "@code{compile-defun}は通常、評価した結果をエコーエリアに表示しますが、@var{arg}が非@code{nil}の場合は、そのフォームをコンパイルした後にカレントバッファーに結果を挿入します。"

#. type: deffn
#: compile.texi.orig:163
#, no-wrap
msgid "Command byte-compile-file filename &optional load"
msgstr "Command byte-compile-file filename &optional load"

#. type: deffn
#: compile.texi.orig:168
msgid ""
"This function compiles a file of Lisp code named @var{filename} into a file "
"of byte-code.  The output file's name is made by changing the @samp{.el} "
"suffix into @samp{.elc}; if @var{filename} does not end in @samp{.el}, it "
"adds @samp{.elc} to the end of @var{filename}."
msgstr "この関数は@var{filename}という名前のLispコードファイルを、バイトコードのファイルにコンパイルします。出力となるファイルの名前は、サフィックス@samp{.el}を@samp{.elc}に変更することにより作成されます。@var{filename}が@samp{.el}で終了しない場合は、@samp{.elc}を@var{filename}の最後に付け足します。\n"

#. type: deffn
#: compile.texi.orig:175
msgid ""
"Compilation works by reading the input file one form at a time.  If it is a "
"definition of a function or macro, the compiled function or macro definition "
"is written out.  Other forms are batched together, then each batch is "
"compiled, and written so that its compiled code will be executed when the "
"file is read.  All comments are discarded when the input file is read."
msgstr "コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機能します。フォームが関数またはマクロの場合は、コンパイル済みの関数またはマクロが書き込まれます。それ以外のフォームはまとめられて、まとめられたものごとにコンパイルされ、そのファイルが読まれたとき実行されるようにコンパイルされたコードが書き込まれます。入力ファイルを読み取る際、すべてのコメントは無視されます。"

#. type: deffn
#: compile.texi.orig:178
msgid ""
"This command returns @code{t} if there were no errors and @code{nil} "
"otherwise.  When called interactively, it prompts for the file name."
msgstr "このコマンドはエラーのないときは@code{t}、それ以外は@code{nil}をリターンします。インタラクティブに呼び出されたときは、ファイル名の入力をもとめます。"

#. type: deffn
#: compile.texi.orig:181
msgid ""
"If @var{load} is non-@code{nil}, this command loads the compiled file after "
"compiling it.  Interactively, @var{load} is the prefix argument."
msgstr "@var{load}が非@code{nil}の場合、このコマンドはコンパイルした後にコンパイルされたファイルをロードします。インタラクティブに呼び出された場合、@var{load}はプレフィクス引数です。"

#. type: group
#: compile.texi.orig:186
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"

#. type: group
#: compile.texi.orig:191
#, no-wrap
msgid ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"
msgstr ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"

#. type: group
#: compile.texi.orig:197
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"
msgstr ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"

#. type: deffn
#: compile.texi.orig:201
#, no-wrap
msgid "Command byte-recompile-directory directory &optional flag force"
msgstr "Command byte-recompile-directory directory &optional flag force"

#. type: cindex
#: compile.texi.orig:202
#, no-wrap
msgid "library compilation"
msgstr "library compilation"

#. type: deffn
#: compile.texi.orig:207
msgid ""
"This command recompiles every @samp{.el} file in @var{directory} (or its "
"subdirectories) that needs recompilation.  A file needs recompilation if a "
"@samp{.elc} file exists but is older than the @samp{.el} file."
msgstr "このコマンドは、@var{directory}(またはそのサブディレクトリー)内の、リコンパイルを要するすべての@samp{.el}ファイルをリコンパイルします。@samp{.elc}ファイルが存在し、それが@samp{.el}より古いファイルは、リコンパイルが必要です。"

#. type: deffn
#: compile.texi.orig:213
msgid ""
"When a @samp{.el} file has no corresponding @samp{.elc} file, @var{flag} "
"says what to do.  If it is @code{nil}, this command ignores these files.  If "
"@var{flag} is 0, it compiles them.  If it is neither @code{nil} nor 0, it "
"asks the user whether to compile each such file, and asks about each "
"subdirectory as well."
msgstr "@samp{.el}ファイルに対応する@samp{.elc}ファイルが存在しない場合、何を行うかを@var{flag}で指定します。@code{nil}の場合、このコマンドはこれらのファイルを無視します。@var{flag}が0のときは、それらをコンパイルします。@code{nil}と0以外の場合は、それらのファイルをコンパイルするかユーザーに尋ね、同様にそれぞれのサブディレクトリーについても尋ねます。"

#. type: deffn
#: compile.texi.orig:216
msgid ""
"Interactively, @code{byte-recompile-directory} prompts for @var{directory} "
"and @var{flag} is the prefix argument."
msgstr "インタラクティブに呼び出された場合、@code{byte-recompile-directory}は@var{directory}の入力を求め、@var{flag}はプレフィクス引数になります。"

#. type: deffn
#: compile.texi.orig:219
msgid ""
"If @var{force} is non-@code{nil}, this command recompiles every @samp{.el} "
"file that has a @samp{.elc} file."
msgstr "@var{force}が非@code{nil}の場合、このコマンドは@samp{.elc}ファイルのあるすべての@samp{.el}ファイルをリコンパイルします。"

#. type: deffn
#: compile.texi.orig:221
msgid "The returned value is unpredictable."
msgstr "リターン値は不定です。"

#. type: defun
#: compile.texi.orig:223
#, no-wrap
msgid "batch-byte-compile &optional noforce"
msgstr "batch-byte-compile &optional noforce"

#. type: defun
#: compile.texi.orig:230
msgid ""
"This function runs @code{byte-compile-file} on files specified on the "
"command line.  This function must be used only in a batch execution of "
"Emacs, as it kills Emacs on completion.  An error in one file does not "
"prevent processing of subsequent files, but no output file will be generated "
"for it, and the Emacs process will terminate with a nonzero status code."
msgstr "この関数は、コマンドラインで指定されたファイルにたいして、@code{byte-compile-file}を実行します。この関数は処理が完了するとEmacsをkillするので、Emacsのバッチ実行だけで使用しなければなりません。1つのファイルでエラーが発生しても、それにより後続のファイルにたいする処理が妨げられることはありませんが、そのファイルにたいする出力ファイルは生成されず、Emacsプロセスは0以外のステータスコードで終了します。"

#. type: defun
#: compile.texi.orig:233
msgid ""
"If @var{noforce} is non-@code{nil}, this function does not recompile files "
"that have an up-to-date @samp{.elc} file."
msgstr "@var{noforce}が非@code{nil}の場合、この関数は最新の@samp{.elc}ファイルがあるファイルをリコンパイルしません。"

#. type: example
#: compile.texi.orig:236
#, no-wrap
msgid "$ emacs -batch -f batch-byte-compile *.el\n"
msgstr "$ emacs -batch -f batch-byte-compile *.el\n"

#. type: section
#: compile.texi.orig:240
#, no-wrap
msgid "Documentation Strings and Compilation"
msgstr "Documentation Strings and Compilation"

#. type: cindex
#: compile.texi.orig:241
#, no-wrap
msgid "dynamic loading of documentation"
msgstr "dynamic loading of documentation"

#. type: Plain text
#: compile.texi.orig:248
msgid ""
"When Emacs loads functions and variables from a byte-compiled file, it "
"normally does not load their documentation strings into memory.  Each "
"documentation string is ``dynamically'' loaded from the byte-compiled file "
"only when needed.  This saves memory, and speeds up loading by skipping the "
"processing of the documentation strings."
msgstr "Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキュメント文字列は、必要なときだけバイトコンパイルされたファイルから``ダイナミック(dynamic: 動的)''にロードされます。ドキュメント文字列の処理をスキップすることにより、メモリーが節約され、ロードが高速になります。"

#. type: Plain text
#: compile.texi.orig:255
msgid ""
"This feature has a drawback: if you delete, move, or alter the compiled file "
"(such as by compiling a new version), Emacs may no longer be able to access "
"the documentation string of previously-loaded functions or variables.  Such "
"a problem normally only occurs if you build Emacs yourself, and happen to "
"edit and/or recompile the Lisp source files.  To solve it, just reload each "
"file after recompilation."
msgstr "この機能には欠点があります。コンパイル済みのファイルを削除、移動、または(新しいバージョンのコンパイル等で)変更した場合、Emacsは前にロードされた関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このような問題は通常、あなた自身がEmacsをビルドした場合に、そのLispファイルを編集、および/またはリコンパイルしたときだけ発生します。この問題は、リコンパイル後にそれぞれのファイルをリロードするだけで解決します。"

#. type: Plain text
#: compile.texi.orig:259
msgid ""
"Dynamic loading of documentation strings from byte-compiled files is "
"determined, at compile time, for each byte-compiled file.  It can be "
"disabled via the option @code{byte-compile-dynamic-docstrings}."
msgstr "バイトコンパイルされたファイルからのドキュメント文字列のダイナミックロードは、バイトコンパイルされたファイルごとに、コンパイル時に決定されます。これはオプション@code{byte-compile-dynamic-docstrings}により、無効にできます。"

#. type: defopt
#: compile.texi.orig:260
#, no-wrap
msgid "byte-compile-dynamic-docstrings"
msgstr "byte-compile-dynamic-docstrings"

#. type: defopt
#: compile.texi.orig:263
msgid ""
"If this is non-@code{nil}, the byte compiler generates compiled files that "
"are set up for dynamic loading of documentation strings."
msgstr "これが非@code{nil}の場合、バイトコンパイラーはドキュメント文字列をダイナミックロードするようセットアップしたコンパイル済みファイルを生成します。"

#. type: defopt
#: compile.texi.orig:267
msgid ""
"To disable the dynamic loading feature for a specific file, set this option "
"to @code{nil} in its header line (@pxref{File Variables, , Local Variables "
"in Files, emacs, The GNU Emacs Manual}), like this:"
msgstr "特定のファイルでダイナミックロード機能を無効にするには、以下のようにヘッダー行(@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照)で、このオプションに@code{nil}をセットします。"

#. type: smallexample
#: compile.texi.orig:270
#, no-wrap
msgid "-*-byte-compile-dynamic-docstrings: nil;-*-\n"
msgstr "-*-byte-compile-dynamic-docstrings: nil;-*-\n"

#. type: defopt
#: compile.texi.orig:275
msgid ""
"This is useful mainly if you expect to change the file, and you want Emacs "
"sessions that have already loaded it to keep working when the file changes."
msgstr "これは主に、あるファイルを変更しようとしていて、そのファイルをすでにロード済みのEmacsセッションがファイルを変更した際にも正しく機能し続けることを望む場合に有用です。"

#. type: samp{#1}
#: compile.texi.orig:277
#, no-wrap
msgid "#@@@var{count}"
msgstr "#@@@var{count}"

#. type: samp{#1}
#: compile.texi.orig:278
#, no-wrap
msgid "#$"
msgstr "#$"

#. type: Plain text
#: compile.texi.orig:286
msgid ""
"Internally, the dynamic loading of documentation strings is accomplished by "
"writing compiled files with a special Lisp reader construct, "
"@samp{#@@@var{count}}.  This construct skips the next @var{count} "
"characters.  It also uses the @samp{#$} construct, which stands for ``the "
"name of this file, as a string''.  Do not use these constructs in Lisp "
"source files; they are not designed to be clear to humans reading the file."
msgstr "内部的には、ドキュメント文字列のダイナミックロードは、特殊なLispリーダー構成@samp{#@@@var{count}}とともにコンパイル済みファイルに書き込むことにより達成されます。この構成は、次の@var{count}文字をスキップします。さらに@samp{#$}構成も使用され、これは``このファイルの名前(文字列)''を意味します。これらの構成をLispソースファイル内で使用しないでください。これらは人間がファイルを読む際に明確であるようデザインされていません。"

#. type: section
#: compile.texi.orig:288
#, no-wrap
msgid "Dynamic Loading of Individual Functions"
msgstr "Dynamic Loading of Individual Functions"

#. type: cindex
#: compile.texi.orig:290
#, no-wrap
msgid "dynamic loading of functions"
msgstr "dynamic loading of functions"

#. type: cindex
#: compile.texi.orig:291
#, no-wrap
msgid "lazy loading"
msgstr "lazy loading"

#. type: Plain text
#: compile.texi.orig:299
msgid ""
"When you compile a file, you can optionally enable the @dfn{dynamic function "
"loading} feature (also known as @dfn{lazy loading}).  With dynamic function "
"loading, loading the file doesn't fully read the function definitions in the "
"file.  Instead, each function definition contains a place-holder which "
"refers to the file.  The first time each function is called, it reads the "
"full definition from the file, to replace the place-holder."
msgstr "ファイルをコンパイルするとき、オプションで@dfn{ダイナミック関数ロード(dynamic function loading)}機能(@dfn{laxyロード(lazy loading)とも呼ばれる})を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイル内の関数定義は完全には読み込まれません。かわりに、各関数定義にはそのファイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出されるときに、そのプレースホルダーを置き換えるために、ファイルから完全な定義が読み込まれます。"

#. type: Plain text
#: compile.texi.orig:306
msgid ""
"The advantage of dynamic function loading is that loading the file becomes "
"much faster.  This is a good thing for a file which contains many separate "
"user-callable functions, if using one of them does not imply you will "
"probably also use the rest.  A specialized mode which provides many keyboard "
"commands often has that usage pattern: a user may invoke the mode, but use "
"only a few of the commands it provides."
msgstr "ダイナミック関数ロードの利点は、ファイルのロードがより高速になることです。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数のうち1つを使用したら、おそらく残りの関数も使用するというのでなければ、これは利点です。多くのキーボードコマンドを提供する特化したモードは、このパターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもしれませんが、使用するのはそのモードが提供するコマンドのわずか一部です。"

#. type: Plain text
#: compile.texi.orig:308
msgid "The dynamic loading feature has certain disadvantages:"
msgstr "ダイナミックロード機能には、いくつか不利な点があります:"

#. type: itemize
#: compile.texi.orig:313
msgid ""
"If you delete or move the compiled file after loading it, Emacs can no "
"longer load the remaining function definitions not already loaded."
msgstr "ロード後にコンパイル済みファイルを削除や移動した場合、Emacsはまだロードされていない残りの関数定義をロードできなくなる。"

#. type: itemize
#: compile.texi.orig:318
msgid ""
"If you alter the compiled file (such as by compiling a new version), then "
"trying to load any function not already loaded will usually yield nonsense "
"results."
msgstr "(新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した場合、まだロードされていない関数のロードを試みると、通常は無意味な結果となる。"

#. type: Plain text
#: compile.texi.orig:324
msgid ""
"These problems will never happen in normal circumstances with installed "
"Emacs files.  But they are quite likely to happen with Lisp files that you "
"are changing.  The easiest way to prevent these problems is to reload the "
"new compiled file immediately after each recompilation."
msgstr "このような問題は、通常の状況でインストールされたEmacsファイルでは決して発生しません。しかし、あなたが変更したLispファイルでは発生し得ます。それぞれのファイルをリコンパイルしたらすぐに、新たなコンパイル済みファイルをリロードするのが、これらの問題を回避する一番簡単な方法です。"

#. type: Plain text
#: compile.texi.orig:331
msgid ""
"The byte compiler uses the dynamic function loading feature if the variable "
"@code{byte-compile-dynamic} is non-@code{nil} at compilation time.  Do not "
"set this variable globally, since dynamic loading is desirable only for "
"certain files.  Instead, enable the feature for specific source files with "
"file-local variable bindings.  For example, you could do it by writing this "
"text in the source file's first line:"
msgstr "コンパイル時に変数@code{byte-compile-dynamic}が非@code{nil}の場合、バイトコンパイラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ましいのは特定のファイルにたいしてだけなので、この変数をグローバルにセットしないでください。そのかわりに、特定のソースファイルのファイルローカル変数で、この機能を有効にしてください。たとえば、ソースファイルの最初の行に以下のテキストを記述することにより、これを行うことができます:"

#. type: example
#: compile.texi.orig:334
#, no-wrap
msgid "-*-byte-compile-dynamic: t;-*-\n"
msgstr "-*-byte-compile-dynamic: t;-*-\n"

#. type: defvar
#: compile.texi.orig:336
#, no-wrap
msgid "byte-compile-dynamic"
msgstr "byte-compile-dynamic"

#. type: defvar
#: compile.texi.orig:339
msgid ""
"If this is non-@code{nil}, the byte compiler generates compiled files that "
"are set up for dynamic function loading."
msgstr "これが非@code{nil}の場合、バイトコンパイラーはダイナミック関数ロードのためにセットアップされたコンパイル済みファイルを生成します。"

#. type: defun
#: compile.texi.orig:341
#, no-wrap
msgid "fetch-bytecode function"
msgstr "fetch-bytecode function"

#. type: defun
#: compile.texi.orig:346
msgid ""
"If @var{function} is a byte-code function object, this immediately finishes "
"loading the byte code of @var{function} from its byte-compiled file, if it "
"is not fully loaded already.  Otherwise, it does nothing.  It always returns "
"@var{function}."
msgstr "@var{function}がバイトコード関数オブジェクトの場合、それがまだ完全にロードされていなければ、バイトコンパイル済みのファイルからの@var{function}のバイトコードのロードを終了します。それ以外は、何も行いません。この関数は、常に@var{function}をリターンします。"

#. type: section
#: compile.texi.orig:349
#, no-wrap
msgid "Evaluation During Compilation"
msgstr ""

#. type: cindex
#: compile.texi.orig:350
#, no-wrap
msgid "eval during compilation"
msgstr ""

#. type: Plain text
#: compile.texi.orig:354
msgid ""
"These features permit you to write code to be evaluated during compilation "
"of a program."
msgstr ""

#. type: defspec
#: compile.texi.orig:355
#, no-wrap
msgid "eval-and-compile body@dots{}"
msgstr ""

#. type: defspec
#: compile.texi.orig:358
msgid ""
"This form marks @var{body} to be evaluated both when you compile the "
"containing code and when you run it (whether compiled or not)."
msgstr ""

#. type: defspec
#: compile.texi.orig:364
msgid ""
"You can get a similar result by putting @var{body} in a separate file and "
"referring to that file with @code{require}.  That method is preferable when "
"@var{body} is large.  Effectively @code{require} is automatically "
"@code{eval-and-compile}, the package is loaded both when compiling and "
"executing."
msgstr ""

#. type: defspec
#: compile.texi.orig:368
msgid ""
"@code{autoload} is also effectively @code{eval-and-compile} too.  It's "
"recognized when compiling, so uses of such a function don't produce ``not "
"known to be defined'' warnings."
msgstr ""

#. type: defspec
#: compile.texi.orig:370
msgid "Most uses of @code{eval-and-compile} are fairly sophisticated."
msgstr ""

#. type: defspec
#: compile.texi.orig:375
msgid ""
"If a macro has a helper function to build its result, and that macro is used "
"both locally and outside the package, then @code{eval-and-compile} should be "
"used to get the helper both when compiling and then later when running."
msgstr ""

#. type: defspec
#: compile.texi.orig:380
msgid ""
"If functions are defined programmatically (with @code{fset} say), then "
"@code{eval-and-compile} can be used to have that done at compile-time as "
"well as run-time, so calls to those functions are checked (and warnings "
"about ``not known to be defined'' suppressed)."
msgstr ""

#. type: defspec
#: compile.texi.orig:382
#, no-wrap
msgid "eval-when-compile body@dots{}"
msgstr ""

#. type: defspec
#: compile.texi.orig:388
msgid ""
"This form marks @var{body} to be evaluated at compile time but not when the "
"compiled program is loaded.  The result of evaluation by the compiler "
"becomes a constant which appears in the compiled program.  If you load the "
"source file, rather than compiling it, @var{body} is evaluated normally."
msgstr ""

#. type: cindex
#: compile.texi.orig:389
#, no-wrap
msgid "compile-time constant"
msgstr ""

#. type: defspec
#: compile.texi.orig:392
msgid ""
"If you have a constant that needs some calculation to produce, "
"@code{eval-when-compile} can do that at compile-time.  For example,"
msgstr ""

#. type: lisp
#: compile.texi.orig:396
#, no-wrap
msgid ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"
msgstr ""

#. type: cindex
#: compile.texi.orig:398
#, no-wrap
msgid "macros, at compile time"
msgstr ""

#. type: defspec
#: compile.texi.orig:402
msgid ""
"If you're using another package, but only need macros from it (the byte "
"compiler will expand those), then @code{eval-when-compile} can be used to "
"load it for compiling, but not executing.  For example,"
msgstr ""

#. type: lisp
#: compile.texi.orig:406
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"
msgstr ""

#. type: defspec
#: compile.texi.orig:412
msgid ""
"The same sort of thing goes for macros and @code{defsubst} functions defined "
"locally and only for use within the file.  They are needed for compiling the "
"file, but in most cases they are not needed for execution of the compiled "
"file.  For example,"
msgstr ""

#. type: lisp
#: compile.texi.orig:418
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"
msgstr ""

#. type: defspec
#: compile.texi.orig:423
msgid ""
"This is often good for code that's only a fallback for compatibility with "
"other versions of Emacs."
msgstr ""

#. type: defspec
#: compile.texi.orig:428
msgid ""
"@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is "
"analogous to the Common Lisp idiom @code{(eval-when (compile eval) "
"@dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when "
"interpreting) is closer to what @code{eval-when-compile} does."
msgstr ""

#. type: cindex
#: compile.texi.orig:432
#, no-wrap
msgid "compiler errors"
msgstr ""

#. type: Plain text
#: compile.texi.orig:439
msgid ""
"Error and warning messages from byte compilation are printed in a buffer "
"named @file{*Compile-Log*}.  These messages include file names and line "
"numbers identifying the location of the problem.  The usual Emacs commands "
"for operating on compiler output can be used on these messages."
msgstr ""

#. type: Plain text
#: compile.texi.orig:448
msgid ""
"When an error is due to invalid syntax in the program, the byte compiler "
"might get confused about the errors' exact location.  One way to investigate "
"is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name "
"starts with a space, so it does not show up in the Buffer Menu.)  This "
"buffer contains the program being compiled, and point shows how far the byte "
"compiler was able to read; the cause of the error might be nearby.  "
"@xref{Syntax Errors}, for some tips for locating syntax errors."
msgstr ""

#. type: Plain text
#: compile.texi.orig:454
msgid ""
"A common type of warning issued by the byte compiler is for functions and "
"variables that were used but not defined.  Such warnings report the line "
"number for the end of the file, not the locations where the missing "
"functions or variables were used; to find these, you must search the file "
"manually."
msgstr ""

#. type: Plain text
#: compile.texi.orig:457
msgid ""
"If you are sure that a warning message about a missing function or variable "
"is unjustified, there are several ways to suppress it:"
msgstr ""

#. type: itemize
#: compile.texi.orig:463
msgid ""
"You can suppress the warning for a specific call to a function @var{func} by "
"conditionalizing it on an @code{fboundp} test, like this:"
msgstr ""

#. type: example
#: compile.texi.orig:466
#, no-wrap
msgid "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"
msgstr ""

#. type: itemize
#: compile.texi.orig:472
msgid ""
"The call to @var{func} must be in the @var{then-form} of the @code{if}, and "
"@var{func} must appear quoted in the call to @code{fboundp}.  (This feature "
"operates for @code{cond} as well.)"
msgstr ""

#. type: itemize
#: compile.texi.orig:477
msgid ""
"Likewise, you can suppress the warning for a specific use of a variable "
"@var{variable} by conditionalizing it on a @code{boundp} test:"
msgstr ""

#. type: example
#: compile.texi.orig:480
#, no-wrap
msgid "(if (boundp '@var{variable}) ...@var{variable}...)\n"
msgstr ""

#. type: itemize
#: compile.texi.orig:486
msgid ""
"The reference to @var{variable} must be in the @var{then-form} of the "
"@code{if}, and @var{variable} must appear quoted in the call to "
"@code{boundp}."
msgstr ""

#. type: itemize
#: compile.texi.orig:490
msgid ""
"You can tell the compiler that a function is defined using "
"@code{declare-function}. @xref{Declaring Functions}."
msgstr ""

#. type: itemize
#: compile.texi.orig:495
msgid ""
"Likewise, you can tell the compiler that a variable is defined using "
"@code{defvar} with no initial value.  (Note that this marks the variable as "
"special.)  @xref{Defining Variables}."
msgstr ""

#. type: Plain text
#: compile.texi.orig:499
msgid ""
"You can also suppress any and all compiler warnings within a certain "
"expression using the construct @code{with-no-warnings}:"
msgstr ""

#. type: defspec
#: compile.texi.orig:503
#, no-wrap
msgid "with-no-warnings body@dots{}"
msgstr ""

#. type: defspec
#: compile.texi.orig:507
msgid ""
"In execution, this is equivalent to @code{(progn @var{body}...)}, but the "
"compiler does not issue warnings for anything that occurs inside @var{body}."
msgstr ""

#. type: defspec
#: compile.texi.orig:511
msgid ""
"We recommend that you use this construct around the smallest possible piece "
"of code, to avoid missing possible warnings other than one you intend to "
"suppress."
msgstr ""

#. type: Plain text
#: compile.texi.orig:516
msgid ""
"Byte compiler warnings can be controlled more precisely by setting the "
"variable @code{byte-compile-warnings}.  See its documentation string for "
"details."
msgstr ""

#. type: section
#: compile.texi.orig:518
#, no-wrap
msgid "Byte-Code Function Objects"
msgstr ""

#. type: cindex
#: compile.texi.orig:519
#, no-wrap
msgid "compiled function"
msgstr ""

#. type: cindex
#: compile.texi.orig:520
#, no-wrap
msgid "byte-code function"
msgstr ""

#. type: cindex
#: compile.texi.orig:521
#, no-wrap
msgid "byte-code object"
msgstr ""

#. type: Plain text
#: compile.texi.orig:527
msgid ""
"Byte-compiled functions have a special data type: they are @dfn{byte-code "
"function objects}.  Whenever such an object appears as a function to be "
"called, Emacs uses the byte-code interpreter to execute the byte-code."
msgstr ""

#. type: Plain text
#: compile.texi.orig:534
msgid ""
"Internally, a byte-code function object is much like a vector; its elements "
"can be accessed using @code{aref}.  Its printed representation is like that "
"for a vector, with an additional @samp{#} before the opening @samp{[}.  It "
"must have at least four elements; there is no maximum number, but only the "
"first six elements have any normal use.  They are:"
msgstr ""

#. type: item
#: compile.texi.orig:536
#, no-wrap
msgid "arglist"
msgstr ""

#. type: table
#: compile.texi.orig:538
msgid "The list of argument symbols."
msgstr ""

#. type: table
#: compile.texi.orig:541
msgid "The string containing the byte-code instructions."
msgstr ""

#. type: item
#: compile.texi.orig:542
#, no-wrap
msgid "constants"
msgstr ""

#. type: table
#: compile.texi.orig:545
msgid ""
"The vector of Lisp objects referenced by the byte code.  These include "
"symbols used as function names and variable names."
msgstr ""

#. type: item
#: compile.texi.orig:546
#, no-wrap
msgid "stacksize"
msgstr ""

#. type: table
#: compile.texi.orig:548
msgid "The maximum stack size this function needs."
msgstr ""

#. type: item
#: compile.texi.orig:549
#, no-wrap
msgid "docstring"
msgstr ""

#. type: table
#: compile.texi.orig:554
msgid ""
"The documentation string (if any); otherwise, @code{nil}.  The value may be "
"a number or a list, in case the documentation string is stored in a file.  "
"Use the function @code{documentation} to get the real documentation string "
"(@pxref{Accessing Documentation})."
msgstr ""

#. type: item
#: compile.texi.orig:555
#, no-wrap
msgid "interactive"
msgstr ""

#. type: table
#: compile.texi.orig:558
msgid ""
"The interactive spec (if any).  This can be a string or a Lisp expression.  "
"It is @code{nil} for a function that isn't interactive."
msgstr ""

#. type: Plain text
#: compile.texi.orig:563
msgid ""
"Here's an example of a byte-code function object, in printed "
"representation.  It is the definition of the command @code{backward-sexp}."
msgstr ""

#. type: example
#: compile.texi.orig:571
#, no-wrap
msgid ""
"#[(&optional arg)\n"
"  \"^H\\204^F^@@\\301^P\\302^H[!\\207\"\n"
"  [arg 1 forward-sexp]\n"
"  2\n"
"  254435\n"
"  \"^p\"]\n"
msgstr ""

#. type: Plain text
#: compile.texi.orig:575
msgid ""
"The primitive way to create a byte-code object is with "
"@code{make-byte-code}:"
msgstr ""

#. type: defun
#: compile.texi.orig:576
#, no-wrap
msgid "make-byte-code &rest elements"
msgstr ""

#. type: defun
#: compile.texi.orig:579
msgid ""
"This function constructs and returns a byte-code function object with "
"@var{elements} as its elements."
msgstr ""

#. type: Plain text
#: compile.texi.orig:585
msgid ""
"You should not try to come up with the elements for a byte-code function "
"yourself, because if they are inconsistent, Emacs may crash when you call "
"the function.  Always leave it to the byte compiler to create these objects; "
"it makes the elements consistent (we hope)."
msgstr ""

#. type: section
#: compile.texi.orig:587
#, no-wrap
msgid "Disassembled Byte-Code"
msgstr ""

#. type: cindex
#: compile.texi.orig:588
#, no-wrap
msgid "disassembled byte-code"
msgstr ""

#. type: Plain text
#: compile.texi.orig:594
msgid ""
"People do not write byte-code; that job is left to the byte compiler.  But "
"we provide a disassembler to satisfy a cat-like curiosity.  The disassembler "
"converts the byte-compiled code into human-readable form."
msgstr ""

#. type: Plain text
#: compile.texi.orig:600
msgid ""
"The byte-code interpreter is implemented as a simple stack machine.  It "
"pushes values onto a stack of its own, then pops them off to use them in "
"calculations whose results are themselves pushed back on the stack.  When a "
"byte-code function returns, it pops a value off the stack and returns it as "
"the value of the function."
msgstr ""

#. type: Plain text
#: compile.texi.orig:604
msgid ""
"In addition to the stack, byte-code functions can use, bind, and set "
"ordinary Lisp variables, by transferring values between variables and the "
"stack."
msgstr ""

#. type: deffn
#: compile.texi.orig:605
#, no-wrap
msgid "Command disassemble object &optional buffer-or-name"
msgstr ""

#. type: deffn
#: compile.texi.orig:612
msgid ""
"This command displays the disassembled code for @var{object}.  In "
"interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the "
"output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name} "
"is non-@code{nil}, it must be a buffer or the name of an existing buffer.  "
"Then the output goes there, at point, and point is left before the output."
msgstr ""

#. type: deffn
#: compile.texi.orig:617
msgid ""
"The argument @var{object} can be a function name, a lambda expression "
"(@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code "
"Objects}).  If it is a lambda expression, @code{disassemble} compiles it and "
"disassembles the resulting compiled code."
msgstr ""

#. type: Plain text
#: compile.texi.orig:622
msgid ""
"Here are two examples of using the @code{disassemble} function.  We have "
"added explanatory comments to help you relate the byte-code to the Lisp "
"source; these do not appear in the output of @code{disassemble}."
msgstr ""

#. type: group
#: compile.texi.orig:630
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"
msgstr ""

#. type: group
#: compile.texi.orig:635
#, no-wrap
msgid ""
"(factorial 4)\n"
"     @result{} 24\n"
msgstr ""

#. type: group
#: compile.texi.orig:642
#, no-wrap
msgid ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"
msgstr ""

#. type: group
#: compile.texi.orig:648
#, no-wrap
msgid ""
"0   varref   integer      ; @r{Get the value of @code{integer} and}\n"
"                          ;   @r{push it onto the stack.}\n"
"1   constant 1            ; @r{Push 1 onto stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:652
#, no-wrap
msgid ""
"2   eqlsign               ; @r{Pop top two values off stack, compare}\n"
"                          ;   @r{them, and push result onto stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:658
#, no-wrap
msgid ""
"3   goto-if-nil 1         ; @r{Pop and test top of stack;}\n"
"                          ;   @r{if @code{nil}, go to 1, else continue.}\n"
"6   constant 1            ; @r{Push 1 onto top of stack.}\n"
"7   return                ; @r{Return the top element of the stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:668
#, no-wrap
msgid ""
"8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"9   constant factorial    ; @r{Push @code{factorial} onto stack.}\n"
"10  varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"11  sub1                  ; @r{Pop @code{integer}, decrement value,}\n"
"                          ;   @r{push new value onto stack.}\n"
"12  call     1            ; @r{Call function @code{factorial} using first}\n"
"                          ;   @r{(i.e., top) stack element as argument;}\n"
"                          ;   @r{push returned value onto stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:673
#, no-wrap
msgid ""
"13 mult                   ; @r{Pop top two values off stack, multiply}\n"
"                          ;   @r{them, and push result onto stack.}\n"
"14 return                 ; @r{Return the top element of the stack.}\n"
msgstr ""

#. type: Plain text
#: compile.texi.orig:677
msgid "The @code{silly-loop} function is somewhat more complex:"
msgstr ""

#. type: group
#: compile.texi.orig:687
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"
msgstr ""

#. type: group
#: compile.texi.orig:694
#, no-wrap
msgid ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"
msgstr ""

#. type: group
#: compile.texi.orig:699
#, no-wrap
msgid ""
"0   constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto top of stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:703
#, no-wrap
msgid ""
"1   call     0            ; @r{Call @code{current-time-string} with no}\n"
"                          ;   @r{argument, push result onto stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:706
#, no-wrap
msgid ""
"2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped "
"value.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:711
#, no-wrap
msgid ""
"3:1 varref   n            ; @r{Get value of @code{n} from the environment}\n"
"                          ;   @r{and push the value on the stack.}\n"
"4   sub1                  ; @r{Subtract 1 from top of stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:717
#, no-wrap
msgid ""
"5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}\n"
"                          ;   @r{of the stack and push copy onto stack.}\n"
"6   varset   n            ; @r{Pop the top of the stack,}\n"
"                          ;   @r{and bind @code{n} to the value.}\n"
"\n"
msgstr ""

#. type: group
#: compile.texi.orig:720
#, no-wrap
msgid ""
";; @r{(In effect, the sequence @code{dup varset} copies the top of the "
"stack}\n"
";; @r{into the value of @code{n} without popping it.)}\n"
msgstr ""

#. type: group
#: compile.texi.orig:727
#, no-wrap
msgid ""
"7   constant 0            ; @r{Push 0 onto stack.}\n"
"8   gtr                   ; @r{Pop top two values off stack,}\n"
"                          ;   @r{test if @var{n} is greater than 0}\n"
"                          ;   @r{and push result onto stack.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:732
#, no-wrap
msgid ""
"9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}\n"
"                          ;   @r{(this continues the while loop)}\n"
"                          ;   @r{else continue.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:738
#, no-wrap
msgid ""
"12  varref   t1           ; @r{Push value of @code{t1} onto stack.}\n"
"13  constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto the top of the stack.}\n"
"14  call     0            ; @r{Call @code{current-time-string} again.}\n"
msgstr ""

#. type: group
#: compile.texi.orig:744
#, no-wrap
msgid ""
"15  unbind   1            ; @r{Unbind @code{t1} in local environment.}\n"
"16  list2                 ; @r{Pop top two elements off stack, create a}\n"
"                          ;   @r{list of them, and push it onto stack.}\n"
"17  return                ; @r{Return value of the top of stack.}\n"
msgstr ""
