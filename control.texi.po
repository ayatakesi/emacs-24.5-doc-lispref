# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-07-03 12:18+0900\n"
"PO-Revision-Date: 2019-10-11 00:06+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: control.texi.orig:6 control.texi.orig:7
#, no-wrap
msgid "Control Structures"
msgstr "Control Structures"

#. type: cindex
#: control.texi.orig:8
#, no-wrap
msgid "special forms for control structures"
msgstr "special forms for control structures"

#. type: cindex
#: control.texi.orig:9
#, no-wrap
msgid "control structures"
msgstr "control structures"

#. type: Plain text
#: control.texi.orig:16
msgid "A Lisp program consists of a set of @dfn{expressions}, or @dfn{forms} (@pxref{Forms}).  We control the order of execution of these forms by enclosing them in @dfn{control structures}.  Control structures are special forms which control when, whether, or how many times to execute the forms they contain."
msgstr "Lispプログラムは、一連の@dfn{式(expressions)}、あるいは@dfn{フォーム(forms)}(@ref{Forms}を参照してください)により形成されます。これらのフォームの実行順は、それらを@dfn{制御構造(control structures)}で囲むことにより制御します。制御構造とは、その制御構造が含むフォームをいつ、どのような条件で、何回実行するかを制御する、スペシャルフォームです。"

#. type: cindex
#: control.texi.orig:17
#, no-wrap
msgid "textual order"
msgstr "textual order"

#. type: Plain text
#: control.texi.orig:26
msgid "The simplest order of execution is sequential execution: first form @var{a}, then form @var{b}, and so on.  This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code---the forms are executed in the order written.  We call this @dfn{textual order}.  For example, if a function body consists of two forms @var{a} and @var{b}, evaluation of the function evaluates first @var{a} and then @var{b}.  The result of evaluating @var{b} becomes the value of the function."
msgstr "もっとも単純な実行順は、1番目は@var{a}、2番目は@var{b}、...という、シーケンシャル実行(sequential execution: 順番に実行)です。これは、関数のbody内の連続する複数のフォームや、Lispコードのファイル内のトップレベルを記述したときに発生します --- つまり、フォームは記述した順に実行されます。わたしたちはこれを@dfn{テキスト順(textual order)}と呼びます。たとえば、関数のbodyが2つのフォーム@var{a}と@var{b}から構成される場合、関数の評価は、最初に@var{a}を評価し、次に@var{b}を評価します。@var{b}を評価した結果が、その関数の値となります。"

#. type: Plain text
#: control.texi.orig:29
msgid "Explicit control structures make possible an order of execution other than sequential."
msgstr "明示的に制御構造を使用することにより、シーケンシャルではない順番での実行が可能になります。"

#. type: Plain text
#: control.texi.orig:36
msgid "Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled)  jumps---all discussed below.  The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially.  You can use macros to define your own control structure constructs (@pxref{Macros})."
msgstr "Emacs Lispは、他の様々な順序づけ、条件、繰り返し、(制御された)ジャンプを含む、複数の種類の制御構造を提供し、以下ではそれらすべてを記述します。ビルトインの制御構造は、制御構造のサブフォームが評価される必要がなかったり、順番に評価される必要がないので、スペシャルフォームです。独自の制御構造を構築するためにマクロを使用することができます(@ref{Macros}を参照してください)。"

#. type: section
#: control.texi.orig:43 control.texi.orig:45 control.texi.orig:46
#, no-wrap
msgid "Sequencing"
msgstr "Sequencing"

#. type: menuentry
#: control.texi.orig:43
msgid "Evaluation in textual order."
msgstr "テキスト順の評価。"

#. type: section
#: control.texi.orig:43 control.texi.orig:144 control.texi.orig:145
#, no-wrap
msgid "Conditionals"
msgstr "Conditionals"

#. type: menuentry
#: control.texi.orig:43
msgid "@code{if}, @code{cond}, @code{when}, @code{unless}."
msgstr "@code{if}、@code{cond}、@code{when}、@code{unless}。"

#. type: node
#: control.texi.orig:43 control.texi.orig:404
#, no-wrap
msgid "Combining Conditions"
msgstr "Combining Conditions"

#. type: menuentry
#: control.texi.orig:43
msgid "@code{and}, @code{or}, @code{not}."
msgstr "@code{and}、@code{or}、@code{not}。"

#. type: section
#: control.texi.orig:43 control.texi.orig:529 control.texi.orig:530
#, no-wrap
msgid "Iteration"
msgstr "Iteration"

#. type: menuentry
#: control.texi.orig:43
msgid "@code{while} loops."
msgstr "@code{while}ループ。"

#. type: section
#: control.texi.orig:43 control.texi.orig:619 control.texi.orig:620
#, no-wrap
msgid "Nonlocal Exits"
msgstr "Nonlocal Exits"

#. type: menuentry
#: control.texi.orig:43
msgid "Jumping out of a sequence."
msgstr "シーケンスの外へジャンプ。"

#. type: cindex
#: control.texi.orig:47
#, no-wrap
msgid "sequencing"
msgstr "sequencing"

#. type: cindex
#: control.texi.orig:48
#, no-wrap
msgid "sequential execution"
msgstr "sequential execution"

#. type: Plain text
#: control.texi.orig:55
msgid "Evaluating forms in the order they appear is the most common way control passes from one form to another.  In some contexts, such as in a function body, this happens automatically.  Elsewhere you must use a control structure construct to do this: @code{progn}, the simplest control construct of Lisp."
msgstr "フォームが出現する順番に評価するのは、あるフォームから別のフォームに制御を渡す、もっとも一般的な制御です。関数のbodyのような、あるコンテキストにおいては、自動的にこれが行なわれます。他の場所では、これを行なうために制御構造を使用しなければなりません。Lispで一単純な制御構造は、@code{progn}です。"

#. type: Plain text
#: control.texi.orig:57
msgid "A @code{progn} special form looks like this:"
msgstr "スペシャルフォーム@code{progn}は、以下のようなものです:"

#. type: group
#: control.texi.orig:61
#, no-wrap
msgid "(progn @var{a} @var{b} @var{c} @dots{})\n"
msgstr "(progn @var{a} @var{b} @var{c} @dots{})\n"

#. type: Plain text
#: control.texi.orig:69
msgid "and it says to execute the forms @var{a}, @var{b}, @var{c}, and so on, in that order.  These forms are called the @dfn{body} of the @code{progn} form.  The value of the last form in the body becomes the value of the entire @code{progn}.  @code{(progn)} returns @code{nil}."
msgstr "これは、順番に@var{a}、@var{b}、@var{c}、...を実行するよう指定します。これらは@code{progn}フォームの@dfn{body}と呼ばれます。body内の最後のフォームの値が、@code{progn}全体の値になります。@code{(progn)}は@code{nil}をreturnします。"

#. type: cindex
#: control.texi.orig:70
#, no-wrap
msgid "implicit @code{progn}"
msgstr "implicit @code{progn}"

#. type: Plain text
#: control.texi.orig:81
msgid "In the early days of Lisp, @code{progn} was the only way to execute two or more forms in succession and use the value of the last of them.  But programmers found they often needed to use a @code{progn} in the body of a function, where (at that time) only one form was allowed.  So the body of a function was made into an ``implicit @code{progn}'': several forms are allowed just as in the body of an actual @code{progn}.  Many other control structures likewise contain an implicit @code{progn}.  As a result, @code{progn} is not used as much as it was many years ago.  It is needed now most often inside an @code{unwind-protect}, @code{and}, @code{or}, or in the @var{then}-part of an @code{if}."
msgstr "初期のLispでは、@code{progn}は、連続で複数のフォームを実行して最後のフォームの値を使用する、唯一の方法でした。しかしプログラマーは、関数のbodyの、(その時点では)1つのフォームだけが許される場所で、@code{progn}を使用する必要が多いことに気づきました。そのため、関数のbodyを``暗黙の@code{progn}''にして、@code{progn}のbodyのように複数のフォームを記述出きるようにしました。他の多くの制御構造も、同様に暗黙の@code{progn}を含みます。結果として、昔ほど@code{progn}は多用されなくなりました。現在では、@code{progn}が必要になるのは、@code{unwind-protect}、@code{and}、@code{or}、@code{if}の@var{then}パートの中がほとんどです。"

#. type: defspec
#: control.texi.orig:82
#, no-wrap
msgid "progn forms@dots{}"
msgstr "progn forms@dots{}"

#. type: defspec
#: control.texi.orig:85
msgid "This special form evaluates all of the @var{forms}, in textual order, returning the result of the final form."
msgstr "このスペシャルフォームは、@var{forms}のすべてをテキスト順に評価して、のフォームの結果をreturnします。"

#. type: group
#: control.texi.orig:95
#, no-wrap
msgid ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"
msgstr ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"

#. type: Plain text
#: control.texi.orig:101
msgid "Two other constructs likewise evaluate a series of forms but return different values:"
msgstr "他の2つの構成は、一連のフォームを同様に評価しますが、異なる値をreturnします:"

#. type: defspec
#: control.texi.orig:102
#, no-wrap
msgid "prog1 form1 forms@dots{}"
msgstr "prog1 form1 forms@dots{}"

#. type: defspec
#: control.texi.orig:105
msgid "This special form evaluates @var{form1} and all of the @var{forms}, in textual order, returning the result of @var{form1}."
msgstr "このスペシャルフォームは、@var{form1}と@var{forms}のすべてをテキスト順に評価して、@var{form1}の結果をreturnします。"

#. type: group
#: control.texi.orig:115
#, no-wrap
msgid ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"
msgstr ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"

#. type: defspec
#: control.texi.orig:120
msgid "Here is a way to remove the first element from a list in the variable @code{x}, then return the value of that former element:"
msgstr "以下の例は、変数@code{x}のリストから1番目の要素を削除して、削除した1番目の要素の値をreturnします:"

#. type: example
#: control.texi.orig:123
#, no-wrap
msgid "(prog1 (car x) (setq x (cdr x)))\n"
msgstr "(prog1 (car x) (setq x (cdr x)))\n"

#. type: defspec
#: control.texi.orig:126
#, no-wrap
msgid "prog2 form1 form2 forms@dots{}"
msgstr "prog2 form1 form2 forms@dots{}"

#. type: defspec
#: control.texi.orig:130
msgid "This special form evaluates @var{form1}, @var{form2}, and all of the following @var{forms}, in textual order, returning the result of @var{form2}."
msgstr "このスペシャルフォームは、@var{form1}、@var{form2}、その後の@var{forms}のすべてをテキスト順で評価して、@var{form2}の結果をreturnします。"

#. type: group
#: control.texi.orig:140
#, no-wrap
msgid ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"
msgstr ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"

#. type: cindex
#: control.texi.orig:146
#, no-wrap
msgid "conditional evaluation"
msgstr "conditional evaluation"

#. type: Plain text
#: control.texi.orig:152
msgid "Conditional control structures choose among alternatives.  Emacs Lisp has four conditional forms: @code{if}, which is much the same as in other languages; @code{when} and @code{unless}, which are variants of @code{if}; and @code{cond}, which is a generalized case statement."
msgstr "条件による制御構造は、候補の中から選択を行ないます。Emacs Lispは4つの条件フォームをもちます。@code{if}は他の言語のものとほとんど同じです。@code{when}と@code{unless}は、@code{if}の変種です。@code{cond}は一般化されたcase命令です。"

#. type: defspec
#: control.texi.orig:153
#, no-wrap
msgid "if condition then-form else-forms@dots{}"
msgstr "if condition then-form else-forms@dots{}"

#. type: defspec
#: control.texi.orig:160
msgid "@code{if} chooses between the @var{then-form} and the @var{else-forms} based on the value of @var{condition}.  If the evaluated @var{condition} is non-@code{nil}, @var{then-form} is evaluated and the result returned.  Otherwise, the @var{else-forms} are evaluated in textual order, and the value of the last one is returned.  (The @var{else} part of @code{if} is an example of an implicit @code{progn}.  @xref{Sequencing}.)"
msgstr "@code{if}は、@var{condition}の値にもとづいて、@var{then-form}と@var{else-forms}を選択します。評価された@var{condition}が非@code{nil}の場合は、@var{then-form}が評価されて、その結果がreturnされます。それ以外は、@var{else-forms}がテキスト順に評価されて、最後のフォームの値がreturnされます(@code{if}の@var{else}パートは、暗黙の@code{progn}の例です。@ref{Sequencing}を参照してください)。"

#. type: defspec
#: control.texi.orig:163
msgid "If @var{condition} has the value @code{nil}, and no @var{else-forms} are given, @code{if} returns @code{nil}."
msgstr "@var{condition}の値が@code{nil}で、@var{else-forms}が与えられない場合、@code{if}は@code{nil}をreturnします。"

#. type: defspec
#: control.texi.orig:167
msgid "@code{if} is a special form because the branch that is not selected is never evaluated---it is ignored.  Thus, in this example, @code{true} is not printed because @code{print} is never called:"
msgstr "選択されなかったブランチは決して評価されない --- 無視される --- ので、@code{if}はスペシャルフォームです。したがって、以下の例では@code{print}は呼び出されることはないので、@code{true}はプリントされません。"

#. type: group
#: control.texi.orig:174
#, no-wrap
msgid ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"
msgstr ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"

#. type: defmac
#: control.texi.orig:178
#, no-wrap
msgid "when condition then-forms@dots{}"
msgstr "when condition then-forms@dots{}"

#. type: defmac
#: control.texi.orig:181
msgid "This is a variant of @code{if} where there are no @var{else-forms}, and possibly several @var{then-forms}.  In particular,"
msgstr "これは、@var{else-forms}がなく、複数の@var{then-forms}があるかもしれない、@code{if}の変種です。特に、"

#. type: example
#: control.texi.orig:184
#, no-wrap
msgid "(when @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(when @var{condition} @var{a} @var{b} @var{c})\n"

#. type: defmac
#: control.texi.orig:188 control.texi.orig:203
msgid "is entirely equivalent to"
msgstr "は以下と完全に等価です"

#. type: example
#: control.texi.orig:191
#, no-wrap
msgid "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"
msgstr "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"

#. type: defmac
#: control.texi.orig:194
#, no-wrap
msgid "unless condition forms@dots{}"
msgstr "unless condition forms@dots{}"

#. type: defmac
#: control.texi.orig:196
msgid "This is a variant of @code{if} where there is no @var{then-form}:"
msgstr "これは@var{then-form}がない、@code{if}の変種です:"

#. type: example
#: control.texi.orig:199
#, no-wrap
msgid "(unless @var{condition} @var{a} @var{b} @var{c})\n"
msgstr "(unless @var{condition} @var{a} @var{b} @var{c})\n"

#. type: example
#: control.texi.orig:207
#, no-wrap
msgid ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"
msgstr ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"

#. type: defspec
#: control.texi.orig:210
#, no-wrap
msgid "cond clause@dots{}"
msgstr "cond clause@dots{}"

#. type: defspec
#: control.texi.orig:215
msgid "@code{cond} chooses among an arbitrary number of alternatives.  Each @var{clause} in the @code{cond} must be a list.  The @sc{car} of this list is the @var{condition}; the remaining elements, if any, the @var{body-forms}.  Thus, a clause looks like this:"
msgstr "@code{cond}は、任意の数の候補から選択を行ないます。@code{cond}内の各@var{clause}は、リストでなければなりません。このリストの@sc{car}は@var{condition}で、(もしあれば)残りの要素は@var{body-forms}です。したがって、条項は以下のようになります:"

#. type: example
#: control.texi.orig:218
#, no-wrap
msgid "(@var{condition} @var{body-forms}@dots{})\n"
msgstr "(@var{condition} @var{body-forms}@dots{})\n"

#. type: defspec
#: control.texi.orig:225
msgid "@code{cond} tries the clauses in textual order, by evaluating the @var{condition} of each clause.  If the value of @var{condition} is non-@code{nil}, the clause ``succeeds''; then @code{cond} evaluates its @var{body-forms}, and returns the value of the last of @var{body-forms}.  Any remaining clauses are ignored."
msgstr "@code{cond}は、各条項の@var{condition}を評価することにより、テキスト順で条項を試験します。@var{condition}の値が非@code{nil}の場合、その条項は``成り立ち''ます。その後、@code{cond}は、その条項の@var{body-forms}を評価して、@var{body-forms}の最後の値をreturnします。残りの条項は無視されます。"

#. type: defspec
#: control.texi.orig:228
msgid "If the value of @var{condition} is @code{nil}, the clause ``fails'', so the @code{cond} moves on to the following clause, trying its @var{condition}."
msgstr "@var{condition}の値が@code{nil}の場合、その条項は``成り立たず''、@code{cond}は次の条項に移動して、その条項の@var{condition}を試験します。"

#. type: defspec
#: control.texi.orig:230
msgid "A clause may also look like this:"
msgstr "以下のようなものも、条項になります:"

#. type: example
#: control.texi.orig:233
#, no-wrap
msgid "(@var{condition})\n"
msgstr "(@var{condition})\n"

#. type: defspec
#: control.texi.orig:238
msgid "Then, if @var{condition} is non-@code{nil} when tested, the @code{cond} form returns the value of @var{condition}."
msgstr "@var{condition}がテストされたときに非@code{nil}なら、@code{cond}フォームは@var{condition}の値をreturnします。"

#. type: defspec
#: control.texi.orig:241
msgid "If every @var{condition} evaluates to @code{nil}, so that every clause fails, @code{cond} returns @code{nil}."
msgstr "すべての@var{condition}が@code{nil}に評価された場合 --- つまりすべての条項が不成立の場合、@code{cond}は@code{nil}をreturnします。"

#. type: defspec
#: control.texi.orig:245
msgid "The following example has four clauses, which test for the cases where the value of @code{x} is a number, string, buffer and symbol, respectively:"
msgstr "以下の例は4つの条項をもち、@code{x}の値が数字か、文字列化、バッファーか、シンボルかをテストします:"

#. type: group
#: control.texi.orig:254
#, no-wrap
msgid ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{multiple body-forms}\n"
"       (buffer-name x))        ; @r{in one clause}\n"
"      ((symbolp x) (symbol-value x)))\n"
msgstr ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{1つの条項に}\n"
"       (buffer-name x))        ; @r{複数bodyフォーム。}\n"
"      ((symbolp x) (symbol-value x)))\n"

#. type: defspec
#: control.texi.orig:263
msgid "Often we want to execute the last clause whenever none of the previous clauses was successful.  To do this, we use @code{t} as the @var{condition} of the last clause, like this: @code{(t @var{body-forms})}.  The form @code{t} evaluates to @code{t}, which is never @code{nil}, so this clause never fails, provided the @code{cond} gets to it at all.  For example:"
msgstr "前の条項が不成立のとき、最後の条項を実行したいときがよくあります。これを行なうには、@code{(t @var{body-forms})}のように、@var{condition}の最後の条項に@code{t}を使用します。フォーム@code{t}は@code{t}に評価され、決して@code{nil}にならないので、この条項が不成立になることはなく、最終的に@code{cond}はこの条項に到達します。たとえば:"

#. type: group
#: control.texi.orig:270
#, no-wrap
msgid ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"
msgstr ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"

#. type: defspec
#: control.texi.orig:276
msgid "This @code{cond} expression returns @code{foo} if the value of @code{a} is @code{hack}, and returns the string @code{\"default\"} otherwise."
msgstr "この@code{cond}式は、@code{a}の値が@code{hack}の場合は@code{foo}、それ以外は文字列@code{\"default\"}をreturnします。"

#. type: Plain text
#: control.texi.orig:281
msgid "Any conditional construct can be expressed with @code{cond} or with @code{if}.  Therefore, the choice between them is a matter of style.  For example:"
msgstr "任意の条件構成は、@code{cond}か@code{if}で表すことができます。したがって、どちらを選択するかは、スタイルの問題です、たとえば:"

#. type: group
#: control.texi.orig:287
#, no-wrap
msgid ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"
msgstr ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"

#. type: subsection
#: control.texi.orig:292 control.texi.orig:294 control.texi.orig:295
#, no-wrap
msgid "Pattern matching case statement"
msgstr "Pattern matching case statement"

#. type: cindex
#: control.texi.orig:296
#, no-wrap
msgid "pcase"
msgstr "pcase"

#. type: cindex
#: control.texi.orig:297
#, no-wrap
msgid "pattern matching"
msgstr "pattern matching"

#. type: Plain text
#: control.texi.orig:301
msgid "To compare a particular value against various possible cases, the macro @code{pcase} can come handy.  It takes the following form:"
msgstr "特定の値を、可能なさまざまの場合にたいして比較するには、マクロ@code{pcase}が便利です。これは以下のフォームをとります:"

#. type: example
#: control.texi.orig:304
#, no-wrap
msgid "(pcase @var{exp} @var{branch}1 @var{branch}2 @var{branch}3 @dots{})\n"
msgstr "(pcase @var{exp} @var{branch}1 @var{branch}2 @var{branch}3 @dots{})\n"

#. type: Plain text
#: control.texi.orig:308
msgid "where each @var{branch} takes the form @code{(@var{upattern} @var{body-forms}@dots{})}."
msgstr "各@var{branch}は、@code{(@var{upattern} @var{body-forms}@dots{})}というフォームです。"

#. type: Plain text
#: control.texi.orig:313
msgid "It will first evaluate @var{exp} and then compare the value against each @var{upattern} to see which @var{branch} to use, after which it will run the corresponding @var{body-forms}.  A common use case is to distinguish between a few different constant values:"
msgstr "これは最初に@var{exp}を評価してから、どの@var{branch}を使用するか、その値を各@var{upattern}と比較して、その後で対応する@var{body-forms}実行します。一般的なのは、少数の異なる定数値を区別するために使用される場合です:"

#. type: example
#: control.texi.orig:321
#, no-wrap
msgid ""
"(pcase (get-return-code x)\n"
"  (`success       (message \"Done!\"))\n"
"  (`would-block   (message \"Sorry, can't do it now\"))\n"
"  (`read-only     (message \"The shmliblick is read-only\"))\n"
"  (`access-denied (message \"You do not have the needed rights\"))\n"
"  (code           (message \"Unknown return code %S\" code)))\n"
msgstr ""
"(pcase (get-return-code x)\n"
"  (`success       (message \"Done!\"))\n"
"  (`would-block   (message \"Sorry, can't do it now\"))\n"
"  (`read-only     (message \"The shmliblick is read-only\"))\n"
"  (`access-denied (message \"You do not have the needed rights\"))\n"
"  (code           (message \"Unknown return code %S\" code)))\n"

#. type: Plain text
#: control.texi.orig:325
msgid "In the last clause, @code{code} is a variable that gets bound to the value that was returned by @code{(get-return-code x)}."
msgstr "最後の条項の@code{code}は、@code{(get-return-code x)}からreturnされた値にバインドされる変数です。"

#. type: Plain text
#: control.texi.orig:329
msgid "To give a more complex example, a simple interpreter for a little expression language could look like (note that this example requires lexical binding):"
msgstr "もっと複雑な例として、以下のような小さな式言語のための単純なインタープリターを示します(この例ではレキシカルバインディングが必要なことに注意してください):"

#. type: example
#: control.texi.orig:340
#, no-wrap
msgid ""
"(defun evaluate (exp env)\n"
"  (pcase exp\n"
"    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))\n"
"    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val) env))))\n"
"    ((pred numberp)     exp)\n"
"    ((pred symbolp)     (cdr (assq exp env)))\n"
"    (_                  (error \"Unknown expression %S\" exp))))\n"
msgstr ""
"(defun evaluate (exp env)\n"
"  (pcase exp\n"
"    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))\n"
"    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val) env))))\n"
"    ((pred numberp)     exp)\n"
"    ((pred symbolp)     (cdr (assq exp env)))\n"
"    (_                  (error \"Unknown expression %S\" exp))))\n"

#. type: Plain text
#: control.texi.orig:347
msgid "Where @code{`(add ,x ,y)} is a pattern that checks that @code{exp} is a three element list starting with the symbol @code{add}, then extracts the second and third elements and binds them to the variables @code{x} and @code{y}.  @code{(pred numberp)} is a pattern that simply checks that @code{exp} is a number, and @code{_} is the catch-all pattern that matches anything."
msgstr "@code{`(add ,x ,y)}は、@code{exp}がシンボル@code{add}で始まる3要素のリストかチェックして、その後2番目と3番目の要素を抽出し、それらを変数@code{x}と@code{y}にバインドするパターンです。@code{(pred numberp)}は@code{exp}が数字かを単にチェックし、@code{_}はすべてのものにマッチするcatch-allパターンです。"

#. type: Plain text
#: control.texi.orig:349
msgid "Here are some sample programs including their evaluation results:"
msgstr "以下に、いくつかの例を評価した結果とともに示します:"

#. type: example
#: control.texi.orig:355
#, no-wrap
msgid ""
"(evaluate '(add 1 2) nil)                 ;=> 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3\n"
"(evaluate '(sub 1 2) nil)                 ;=> error\n"
msgstr ""
"(evaluate '(add 1 2) nil)                 ;=> 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3\n"
"(evaluate '(sub 1 2) nil)                 ;=> error\n"

#. type: Plain text
#: control.texi.orig:360
msgid "There are two kinds of patterns involved in @code{pcase}, called @emph{U-patterns} and @emph{Q-patterns}.  The @var{upattern} mentioned above are U-patterns and can take the following forms:"
msgstr "@code{pcase}に関係する2種類のパターンがあり、それらは@emph{U-patterns}、@emph{Q-patterns}と呼ばれます。上述の@var{upattern}はU-patternsで、以下の形式をもつことができます:"

#. type: item
#: control.texi.orig:362
#, no-wrap
msgid "`@var{qpattern}"
msgstr "`@var{qpattern}"

#. type: table
#: control.texi.orig:369
msgid "This is one of the most common form of patterns.  The intention is to mimic the backquote macro: this pattern matches those values that could have been built by such a backquote expression.  Since we're pattern matching rather than building a value, the unquote does not indicate where to plug an expression, but instead it lets one specify a U-pattern that should match the value at that location."
msgstr "これは、もっとも一般的なパターンの1つです。このパターンの意図は、バッククォートマクロの模倣です。このパターンは、バッククォート式により構築されるような値にマッチします。わたしたちが行なうのは値の構築ではなくパターンマッチングなので、非クォートは式をどこに挿入するか示すのではなく、かわりにその位置で値にマッチすべき1つのU-patternを指定します。"

#. type: table
#: control.texi.orig:371
msgid "More specifically, a Q-pattern can take the following forms:"
msgstr "より具体的には、Q-patternは以下のフォームをもつことができます:"

#. type: item
#: control.texi.orig:372
#, no-wrap
msgid "(@var{qpattern1} . @var{qpattern2})"
msgstr "(@var{qpattern1} . @var{qpattern2})"

#. type: table
#: control.texi.orig:375
msgid "This pattern matches any cons cell whose @code{car} matches @var{qpattern1} and whose @code{cdr} matches @var{pattern2}."
msgstr "このパターンは、@code{car}が@var{qpattern1}、@code{cdr}が@var{pattern2}にマッチする、任意のコンスセルにマッチします。"

#. type: var{#1}
#: control.texi.orig:375
#, no-wrap
msgid "atom"
msgstr "atom"

#. type: table
#: control.texi.orig:377
msgid "This pattern matches any atom @code{equal} to @var{atom}."
msgstr "このパターンは、@var{atom}に@code{equal}な任意のアトムにマッチします。"

#. type: item
#: control.texi.orig:377
#, no-wrap
msgid ",@var{upattern}"
msgstr ",@var{upattern}"

#. type: table
#: control.texi.orig:379
msgid "This pattern matches any object that matches the @var{upattern}."
msgstr "このパターンは、@var{upattern}にマッチする任意のオブジェクトにマッチします。"

#. type: var{#1}
#: control.texi.orig:381
#, no-wrap
msgid "symbol"
msgstr "symbol"

#. type: table
#: control.texi.orig:385
msgid "A mere symbol in a U-pattern matches anything, and additionally let-binds this symbol to the value that it matched, so that you can later refer to it, either in the @var{body-forms} or also later in the pattern."
msgstr "U-pattern内の単なるシンボルはすべてにマッチし、さらにマッチした値にそのシンボルをバインドするので、@var{body-forms}や皇族のパターンから、それを参照することができます。"

#. type: item
#: control.texi.orig:385
#, no-wrap
msgid "_"
msgstr "_"

#. type: table
#: control.texi.orig:388
msgid "This so-called @emph{don't care} pattern matches anything, like the previous one, but unlike symbol patterns it does not bind any variable."
msgstr "このパターン --- いわゆる@emph{don't care}パターン --- はシンボルパターンと同様、すべてのものにマッチしますが、シンボルパターンとは異なり、変数へのバインドを行ないません。"

#. type: item
#: control.texi.orig:388
#, no-wrap
msgid "(pred @var{pred})"
msgstr "(pred @var{pred})"

#. type: table
#: control.texi.orig:391
msgid "This pattern matches if the function @var{pred} returns non-@code{nil} when called with the object being matched."
msgstr "このパターンは、マッチされるオブジェクトで関数@var{pred}が呼び出したとき、非@code{nil}をreturnするものにマッチします。"

#. type: item
#: control.texi.orig:391
#, no-wrap
msgid "(or @var{upattern1} @var{upattern2}@dots{})"
msgstr "(or @var{upattern1} @var{upattern2}@dots{})"

#. type: table
#: control.texi.orig:394
msgid "This pattern matches as soon as one of the argument patterns succeeds.  All argument patterns should let-bind the same variables."
msgstr "このパターンは、引数のパターンから最初に成立したパターンにマッチします。すべての引数パターンは、同じ変数にバインドされるべきです。"

#. type: item
#: control.texi.orig:394
#, no-wrap
msgid "(and @var{upattern1} @var{upattern2}@dots{})"
msgstr "(and @var{upattern1} @var{upattern2}@dots{})"

#. type: table
#: control.texi.orig:396
msgid "This pattern matches only if all the argument patterns succeed."
msgstr "このパターンは、すべての引数パターンが成立したときだけマッチします。"

#. type: item
#: control.texi.orig:396
#, no-wrap
msgid "(guard @var{exp})"
msgstr "(guard @var{exp})"

#. type: table
#: control.texi.orig:402
msgid "This pattern ignores the object being examined and simply succeeds if @var{exp} evaluates to non-@code{nil} and fails otherwise.  It is typically used inside an @code{and} pattern.  For example, @code{(and x (guard (< x 10)))} is a pattern which matches any number smaller than 10 and let-binds it to the variable @code{x}."
msgstr "このパターンは調べられるオブジェクトを無視して、@var{exp}が非@code{nil}に評価されたときは成立、それ以外は不成立となります。これは通常、@code{and}パターンの内部で使用されます。たとえば、@code{(and x (guard (< x 10)))}は10より小さい任意の数字にマッチして、それを変数@code{x}にバインドします。"

#. type: section
#: control.texi.orig:405
#, no-wrap
msgid "Constructs for Combining Conditions"
msgstr "Constructs for Combining Conditions"

#. type: cindex
#: control.texi.orig:406
#, no-wrap
msgid "combining conditions"
msgstr "combining conditions"

#. type: Plain text
#: control.texi.orig:412
msgid "This section describes three constructs that are often used together with @code{if} and @code{cond} to express complicated conditions.  The constructs @code{and} and @code{or} can also be used individually as kinds of multiple conditional constructs."
msgstr "このセクションは、複雑な条件を表現するために、@code{if}や@code{cond}とともによく使用される3つの構成を記述します。@code{and}と@code{or}の構成は、ある種の複数条件の構成として、個別に使用することもできます。"

#. type: defun
#: control.texi.orig:413
#, no-wrap
msgid "not condition"
msgstr "not condition"

#. type: defun
#: control.texi.orig:418
msgid "This function tests for the falsehood of @var{condition}.  It returns @code{t} if @var{condition} is @code{nil}, and @code{nil} otherwise.  The function @code{not} is identical to @code{null}, and we recommend using the name @code{null} if you are testing for an empty list."
msgstr "この関数は、@var{condition}が偽であることをテストします。この関数は@var{condition}が@code{nil}の場合は@code{t}、それ以外は@code{nil}をreturnします。関数@code{not}は@code{null}と等価で、わたしたちは空のリストをテストする場合は、@code{null}の使用を推奨します。"

#. type: defspec
#: control.texi.orig:420
#, no-wrap
msgid "and conditions@dots{}"
msgstr "and conditions@dots{}"

#. type: defspec
#: control.texi.orig:424
msgid "The @code{and} special form tests whether all the @var{conditions} are true.  It works by evaluating the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{and}は、すべての@var{conditions}が真かどうかをテストします。この関数は、@var{conditions}を記述された順に1つずつ評価することにより機能します。"

#. type: defspec
#: control.texi.orig:429
msgid "If any of the @var{conditions} evaluates to @code{nil}, then the result of the @code{and} must be @code{nil} regardless of the remaining @var{conditions}; so @code{and} returns @code{nil} right away, ignoring the remaining @var{conditions}."
msgstr "ある@var{conditions}が@code{nil}に評価された場合、残りの@var{conditions}に関係なく、@code{and}は@code{nil}をreturnしなければなりません。この場合、@code{and}は即座に@code{nil}をreturnし、残りの@var{conditions}は無視されます。"

#. type: defspec
#: control.texi.orig:435
msgid "If all the @var{conditions} turn out non-@code{nil}, then the value of the last of them becomes the value of the @code{and} form.  Just @code{(and)}, with no @var{conditions}, returns @code{t}, appropriate because all the @var{conditions} turned out non-@code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が非@code{nil}の場合、それらの最後の値が@code{and}フォームの値になります。@var{conditions}のない単独の@code{(and)}は、@code{t}をreturnします。なぜなら、すべての@var{conditions}が非@code{nil}となるので(考えてみてください。そうでないのはどれですか?)、これは適切です。"

#. type: defspec
#: control.texi.orig:440
msgid "Here is an example.  The first condition returns the integer 1, which is not @code{nil}.  Similarly, the second condition returns the integer 2, which is not @code{nil}.  The third condition is @code{nil}, so the remaining condition is never evaluated."
msgstr "以下に例を示します。1番目の条件は整数1をretuenし、これは@code{nil}ではありません。同様に2番目の条件は整数2をreturnし、これも@code{nil}ではありません。3番目の条件は@code{nil}なので、のこりの条件が評価されることは決してありません。"

#. type: group
#: control.texi.orig:447
#, no-wrap
msgid ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"
msgstr ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"

#. type: defspec
#: control.texi.orig:451
msgid "Here is a more realistic example of using @code{and}:"
msgstr "以下は、@code{and}を使用した、より現実的な例です:"

#. type: group
#: control.texi.orig:456
#, no-wrap
msgid ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"
msgstr ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"

#. type: defspec
#: control.texi.orig:462
msgid "Note that @code{(car foo)} is not executed if @code{(consp foo)} returns @code{nil}, thus avoiding an error."
msgstr "@code{(consp foo)}が@code{nil}をreturnした場合、@code{(car foo)}は実行されないので、エラーにならないことに注意してください。"

#. type: defspec
#: control.texi.orig:465
msgid "@code{and} expressions can also be written using either @code{if} or @code{cond}.  Here's how:"
msgstr "@code{if}か@code{cond}のどちらかを使用して、@code{and}式を記述することもできます。以下はその方法です:"

#. type: group
#: control.texi.orig:473
#, no-wrap
msgid ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"
msgstr ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"

#. type: defspec
#: control.texi.orig:477
#, no-wrap
msgid "or conditions@dots{}"
msgstr "or conditions@dots{}"

#. type: defspec
#: control.texi.orig:481
msgid "The @code{or} special form tests whether at least one of the @var{conditions} is true.  It works by evaluating all the @var{conditions} one by one in the order written."
msgstr "スペシャルフォーム@code{or}は、少なくとも1つの@var{conditions}が真かどうかをテストします。この関数は、すべての@var{conditions}を1つずつ、記述された順に評価することにより機能します。"

#. type: defspec
#: control.texi.orig:486
msgid "If any of the @var{conditions} evaluates to a non-@code{nil} value, then the result of the @code{or} must be non-@code{nil}; so @code{or} returns right away, ignoring the remaining @var{conditions}.  The value it returns is the non-@code{nil} value of the condition just evaluated."
msgstr "ある@var{conditions}が非@code{nil}値に評価された場合、@code{or}の結果は非@code{nil}でなければなりません。この場合、@code{or}は即座にreturnし、残りの@var{conditions}は無視されます。この関数がreturnする値は、非@code{nil}値に評価された条件の値そのものです。"

#. type: defspec
#: control.texi.orig:492
msgid "If all the @var{conditions} turn out @code{nil}, then the @code{or} expression returns @code{nil}.  Just @code{(or)}, with no @var{conditions}, returns @code{nil}, appropriate because all the @var{conditions} turned out @code{nil}.  (Think about it; which one did not?)"
msgstr "すべての@var{conditions}が@code{nil}になった場合、@code{or}式は@code{nil}をreturnします。@var{conditions}のない単独の@code{(or)}は、@code{nil}をreturnします。なぜなら、すべての@var{conditions}が@code{nil}になるので(考えてみてください。そうでないのはどれですか?)、これは適切です。"

#. type: defspec
#: control.texi.orig:495
msgid "For example, this expression tests whether @code{x} is either @code{nil} or the integer zero:"
msgstr "たとえば、この式は@code{x}が@code{nil}または整数0かどうかをテストします:"

#. type: example
#: control.texi.orig:498
#, no-wrap
msgid "(or (eq x nil) (eq x 0))\n"
msgstr "(or (eq x nil) (eq x 0))\n"

#. type: defspec
#: control.texi.orig:502
msgid "Like the @code{and} construct, @code{or} can be written in terms of @code{cond}.  For example:"
msgstr "@code{and}構成と同様に、@code{or}を@code{cond}に置き換えて記述することができます。たとえば:"

#. type: group
#: control.texi.orig:510
#, no-wrap
msgid ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"
msgstr ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"

#. type: defspec
#: control.texi.orig:514
msgid "You could almost write @code{or} in terms of @code{if}, but not quite:"
msgstr "ほとんどの場合、@code{or}を@code{if}に置き換えて記述できますが、完全ではありません:"

#. type: group
#: control.texi.orig:520
#, no-wrap
msgid ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"
msgstr ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"

#. type: defspec
#: control.texi.orig:527
msgid "This is not completely equivalent because it can evaluate @var{arg1} or @var{arg2} twice.  By contrast, @code{(or @var{arg1} @var{arg2} @var{arg3})} never evaluates any argument more than once."
msgstr "これは完全に同一ではありません。なぜなら@var{arg1}または@var{arg2}を2回評価するかもしれないからです。対照的に、@code{(or @var{arg1} @var{arg2} @var{arg3})}は2回以上引数を評価することは、決してありません。"

#. type: cindex
#: control.texi.orig:531
#, no-wrap
msgid "iteration"
msgstr "iteration"

#. type: cindex
#: control.texi.orig:532
#, no-wrap
msgid "recursion"
msgstr "recursion"

#. type: Plain text
#: control.texi.orig:538
msgid "Iteration means executing part of a program repetitively.  For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to @var{n}.  You can do this in Emacs Lisp with the special form @code{while}:"
msgstr "繰り返し(iteration)とは、プログラムの一部を繰り返し実行することを意味します。たとえば、リストの各要素、または0から@var{n}の整数にたいして、1度ずつ繰り返し何らかの計算をおこないたいとしましょうEmacs Lispでは、スペシャルフォーム@code{while}でこれを行なうことができます:"

#. type: defspec
#: control.texi.orig:539
#, no-wrap
msgid "while condition forms@dots{}"
msgstr "while condition forms@dots{}"

#. type: defspec
#: control.texi.orig:545
msgid "@code{while} first evaluates @var{condition}.  If the result is non-@code{nil}, it evaluates @var{forms} in textual order.  Then it reevaluates @var{condition}, and if the result is non-@code{nil}, it evaluates @var{forms} again.  This process repeats until @var{condition} evaluates to @code{nil}."
msgstr "@code{while}は、最初に@var{condition}を評価します。結果が非@code{nil}の場合は、@var{forms}をテキスト順に評価します。その後@var{condition}を再評価して、結果が非@code{nil}の場合、再度@var{forms}を評価します。この処理は、@var{condition}が@code{nil}に評価されるまで繰り返されます。"

#. type: defspec
#: control.texi.orig:549
msgid "There is no limit on the number of iterations that may occur.  The loop will continue until either @var{condition} evaluates to @code{nil} or until an error or @code{throw} jumps out of it (@pxref{Nonlocal Exits})."
msgstr "繰り返し回数に制限はありません。このループは、@var{condition}が@code{nil}に評価されるか、エラーとなるか、@code{throw}で抜け出す(@ref{Nonlocal Exits}を参照してください)まで計測されるでしょう"

#. type: defspec
#: control.texi.orig:551
msgid "The value of a @code{while} form is always @code{nil}."
msgstr "@code{while}フォームの値は、常に@code{nil}です。"

#. type: group
#: control.texi.orig:556
#, no-wrap
msgid ""
"(setq num 0)\n"
"     @result{} 0\n"
msgstr ""
"(setq num 0)\n"
"     @result{} 0\n"

#. type: group
#: control.texi.orig:566
#, no-wrap
msgid ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"
msgstr ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"

#. type: defspec
#: control.texi.orig:573
msgid "To write a ``repeat...until'' loop, which will execute something on each iteration and then do the end-test, put the body followed by the end-test in a @code{progn} as the first argument of @code{while}, as shown here:"
msgstr "各繰り返しごとに何かを実行して、その後も終了テストを行なう``repeat...until''ループを記述するには、以下のように@code{while}の1番目の引数として、bodyの後に終了テストを記述して、それを@code{progn}の中に配します:"

#. type: group
#: control.texi.orig:579
#, no-wrap
msgid ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"
msgstr ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"

#. type: defspec
#: control.texi.orig:586
msgid "This moves forward one line and continues moving by lines until it reaches an empty line.  It is peculiar in that the @code{while} has no body, just the end test (which also does the real work of moving point)."
msgstr "これは1行前方に移動して、空行に達するまで行単位の移動を継続します。独特なのは、@code{while}がbodyをもたず、終了テスト(これはポイント移動の実処理も行ないます)だけという点です。"

#. type: Plain text
#: control.texi.orig:590
msgid "The @code{dolist} and @code{dotimes} macros provide convenient ways to write two common kinds of loops."
msgstr "マクロ@code{dolist}および@code{dotimes}は、2つの一般的な種類のループを記述する、便利な方法を提供します。"

#. type: defmac
#: control.texi.orig:591
#, no-wrap
msgid "dolist (var list [result]) body@dots{}"
msgstr "dolist (var list [result]) body@dots{}"

#. type: defmac
#: control.texi.orig:597
msgid "This construct executes @var{body} once for each element of @var{list}, binding the variable @var{var} locally to hold the current element.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  For example, here is how you could use @code{dolist} to define the @code{reverse} function:"
msgstr "この構成は、@var{list}の各要素にたいして1度@var{body}を実行し、カレント要素をローカルに保持するように、変数@var{var}にバインドします。その後、@var{result}を評価した値、または@var{result}が省略された場合は@code{nil}をreturnします。たとえば、以下は@code{reverse}関数を定義するために、@code{dolist}を使用する方法の例です:"

#. type: example
#: control.texi.orig:603
#, no-wrap
msgid ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"
msgstr ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"

#. type: defmac
#: control.texi.orig:606
#, no-wrap
msgid "dotimes (var count [result]) body@dots{}"
msgstr "dotimes (var count [result]) body@dots{}"

#. type: defmac
#: control.texi.orig:612
msgid "This construct executes @var{body} once for each integer from 0 (inclusive) to @var{count} (exclusive), binding the variable @var{var} to the integer for the current iteration.  Then it returns the value of evaluating @var{result}, or @code{nil} if @var{result} is omitted.  Here is an example of using @code{dotimes} to do something 100 times:"
msgstr "この構成は、0以上@var{count}未満の各整数にたいして1度@var{body}を実行し、その繰り返しでの整数を、変数@var{var}にバインドします。その後、@var{result}の値、または@var{result}が省略された場合は@code{nil}をreturnします。以下は、@code{dotimes}を使用して、何らかの処理を100回行なう例です:"

#. type: example
#: control.texi.orig:616
#, no-wrap
msgid ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"
msgstr ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"

#. type: cindex
#: control.texi.orig:621
#, no-wrap
msgid "nonlocal exits"
msgstr "nonlocal exits"

#. type: Plain text
#: control.texi.orig:628
msgid "A @dfn{nonlocal exit} is a transfer of control from one point in a program to another remote point.  Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control.  Nonlocal exits unbind all variable bindings made by the constructs being exited."
msgstr "@dfn{非ローカル脱出(nonlocal exit)}とは、プログラム内のある位置から、別の離れた位置へ、制御を移します。Emacs Lispでは、エラーの結果として非ローカル脱出が発生することがあります。明示的な制御の下で非ローカル脱出を使用することもできます。非ローカル脱出は、脱出しようとしている構成により作成された、すべての変数バインディングのバインドを外します。"

#. type: node
#: control.texi.orig:634 control.texi.orig:636
#, no-wrap
msgid "Catch and Throw"
msgstr "Catch and Throw"

#. type: menuentry
#: control.texi.orig:634
msgid "Nonlocal exits for the program's own purposes."
msgstr "プログラム自身の目的による非ローカル脱出。"

#. type: node
#: control.texi.orig:634 control.texi.orig:735
#, no-wrap
msgid "Examples of Catch"
msgstr "Examples of Catch"

#. type: menuentry
#: control.texi.orig:634
msgid "Showing how such nonlocal exits can be written."
msgstr "このような非ローカル脱出が記述される方法。"

#. type: subsection
#: control.texi.orig:634 control.texi.orig:810 control.texi.orig:811
#, no-wrap
msgid "Errors"
msgstr "Errors"

#. type: menuentry
#: control.texi.orig:634
msgid "How errors are signaled and handled."
msgstr "エラーがシグナル・処理される方法。"

#. type: node
#: control.texi.orig:634 control.texi.orig:1368
#, no-wrap
msgid "Cleanups"
msgstr "Cleanups"

#. type: menuentry
#: control.texi.orig:634
msgid "Arranging to run a cleanup form if an error happens."
msgstr "エラーが発生した場合のクリーンアップフォーム実行のアレンジ。"

#. type: subsection
#: control.texi.orig:637
#, no-wrap
msgid "Explicit Nonlocal Exits: @code{catch} and @code{throw}"
msgstr "Explicit Nonlocal Exits: @code{catch} and @code{throw}"

#. type: Plain text
#: control.texi.orig:645
msgid "Most control constructs affect only the flow of control within the construct itself.  The function @code{throw} is the exception to this rule of normal program execution: it performs a nonlocal exit on request.  (There are other exceptions, but they are for error handling only.)  @code{throw} is used inside a @code{catch}, and jumps back to that @code{catch}.  For example:"
msgstr "ほとんどの制御構造は、そのコンストラクト自身内部の制御フローだけに影響します。関数@code{throw}は、通常のプログラム実行でのこのルールの例外です。これは、リクエストにより非ローカル脱出を行ないます(他にも例外はありますが、それらはエラー処理だけのものです)。@code{throw}は@code{catch}の内部で試用され、@code{catch}に制御を戻します。たとえば:"

#. type: group
#: control.texi.orig:651
#, no-wrap
msgid ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"
msgstr ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"

#. type: group
#: control.texi.orig:657
#, no-wrap
msgid ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"
msgstr ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"

#. type: Plain text
#: control.texi.orig:665
msgid "The @code{throw} form, if executed, transfers control straight back to the corresponding @code{catch}, which returns immediately.  The code following the @code{throw} is not executed.  The second argument of @code{throw} is used as the return value of the @code{catch}."
msgstr "@code{throw}フォームが実行された場合は、対応する@code{catch}に制御を移し、@code{catch}は即座にreturnします。@code{throw}の後のコードは実行されません。@code{throw}の2番目の引数は、@code{catch}のreturn値として使用されます。"

#. type: Plain text
#: control.texi.orig:674
msgid "The function @code{throw} finds the matching @code{catch} based on the first argument: it searches for a @code{catch} whose first argument is @code{eq} to the one specified in the @code{throw}.  If there is more than one applicable @code{catch}, the innermost one takes precedence.  Thus, in the above example, the @code{throw} specifies @code{foo}, and the @code{catch} in @code{foo-outer} specifies the same symbol, so that @code{catch} is the applicable one (assuming there is no other matching @code{catch} in between)."
msgstr "関数@code{throw}は、1番目の引数にもとづいて、それにマッチする@code{catch}を探します。@code{throw}は、1番目の引数が、@code{throw}で指定されたものと@code{eq}な@code{catch}を検索します。複数の該当する@code{catch}がある場合、最内のものが優先されます。したがって、上記の例では@code{throw}が@code{foo}を指定し、@code{foo-outer}内の@code{catch}が同じシンボルを指定しているので、(この間に他のマッチする@code{catch}は存在しないと仮定すると)@code{catch}が該当します。"

#. type: Plain text
#: control.texi.orig:684
msgid "Executing @code{throw} exits all Lisp constructs up to the matching @code{catch}, including function calls.  When binding constructs such as @code{let} or function calls are exited in this way, the bindings are unbound, just as they are when these constructs exit normally (@pxref{Local Variables}).  Likewise, @code{throw} restores the buffer and position saved by @code{save-excursion} (@pxref{Excursions}), and the narrowing status saved by @code{save-restriction}.  It also runs any cleanups established with the @code{unwind-protect} special form when it exits that form (@pxref{Cleanups})."
msgstr "@code{throw}の実行により、マッチする@code{catch}までのすべてのリスプ構成(関数呼び出しを含む)を脱出します。この方法により@code{let}や関数呼び出しのようなバインディング構成を脱出する場合、これらの構成を正常にexitしたときのように、そのバインディングは解かれます(@ref{Local Variables}を参照してください)。同様に@code{throw}は、@code{save-excursion}(@ref{Excursions}を参照してください)により保存されたバッファーと位置を復元します。@code{throw}が、スペシャルフォーム@code{unwind-protect}を脱出した場合、@code{unwind-protect}により設定されたいくつかのクリーンアップも実行します。"

#. type: Plain text
#: control.texi.orig:692
msgid "The @code{throw} need not appear lexically within the @code{catch} that it jumps to.  It can equally well be called from another function called within the @code{catch}.  As long as the @code{throw} takes place chronologically after entry to the @code{catch}, and chronologically before exit from it, it has access to that @code{catch}.  This is why @code{throw} can be used in commands such as @code{exit-recursive-edit} that throw back to the editor command loop (@pxref{Recursive Editing})."
msgstr "ジャンプ先となる@code{catch}内にレキシカル(局所的)である必要はありません。@code{throw}は、@code{catch}内で呼び出された別の関数から、同じようにに呼び出すことができます。@code{throw}が行なわれたのが、順序的に、@code{catch}に入った後でexitする前である限り、その@code{throw}は@code{catch}にアクセスできます。エディターのコマンドループから戻る@code{exit-recursive-edit}のようなコマンドで、@code{throw}が使用されるのは、これが理由です。"

#. type: cindex
#: control.texi.orig:693
#, no-wrap
msgid "CL note---only @code{throw} in Emacs"
msgstr "CL note---only @code{throw} in Emacs"

#. type: quotation
#: control.texi.orig:700
msgid "@b{Common Lisp note:} Most other versions of Lisp, including Common Lisp, have several ways of transferring control nonsequentially: @code{return}, @code{return-from}, and @code{go}, for example.  Emacs Lisp has only @code{throw}.  The @file{cl-lib} library provides versions of some of these.  @xref{Blocks and Exits,,,cl,Common Lisp Extensions}."
msgstr "@b{Common Lispに関する注意: }Common Lispを含む、他のほとんどのバージョンのLispは、非シーケンシャルに制御を移す、いくつかの方法 --- たとえば@code{return}、@code{return-from}、@code{go} --- をもちます。Emacs Lispの場合は、@code{throw}だけです。@file{cl-lib}ライブラリーは、これらのうちいくつかを提供します。@ref{Blocks and Exits,,,cl,Common Lisp Extensions}を参照してください。"

#. type: defspec
#: control.texi.orig:702
#, no-wrap
msgid "catch tag body@dots{}"
msgstr "catch tag body@dots{}"

#. type: cindex
#: control.texi.orig:703
#, no-wrap
msgid "tag on run time stack"
msgstr "tag on run time stack"

#. type: defspec
#: control.texi.orig:708
msgid "@code{catch} establishes a return point for the @code{throw} function.  The return point is distinguished from other such return points by @var{tag}, which may be any Lisp object except @code{nil}.  The argument @var{tag} is evaluated normally before the return point is established."
msgstr "@code{catch}は、@code{throw}関数にたいするreturn位置を確立します。return位置は@var{tag}により、そのような他のreturn位置と区別されます。@var{tag}は、@code{nil}以外の任意のLispオブジェクトです。引数@var{tag}はreturn位置が確立される前に、通常どおり評価されます。"

#. type: defspec
#: control.texi.orig:713
msgid "With the return point in effect, @code{catch} evaluates the forms of the @var{body} in textual order.  If the forms execute normally (without error or nonlocal exit) the value of the last body form is returned from the @code{catch}."
msgstr "return位置が効果をもつことにより、@code{catch}は@var{body}のフォームをテキスト順に評価します。フォームが(エラーは非ローカル脱出なしで)通常に実行された場合、bodyの最後のフォームの値が、@code{catch}からreturnされます。"

#. type: defspec
#: control.texi.orig:718
msgid "If a @code{throw} is executed during the execution of @var{body}, specifying the same value @var{tag}, the @code{catch} form exits immediately; the value it returns is whatever was specified as the second argument of @code{throw}."
msgstr "@var{body}の実効の間に@code{throw}が実行された場合、@var{tag}と同じ値を指定すると、@code{catch}フォームは即座にexitします。returnされる値は、それが何であれ、@code{throw}の2番目の引数に指定された値です。"

#. type: defun
#: control.texi.orig:720
#, no-wrap
msgid "throw tag value"
msgstr "throw tag value"

#. type: defun
#: control.texi.orig:726
msgid "The purpose of @code{throw} is to return from a return point previously established with @code{catch}.  The argument @var{tag} is used to choose among the various existing return points; it must be @code{eq} to the value specified in the @code{catch}.  If multiple return points match @var{tag}, the innermost one is used."
msgstr "@code{throw}の目的は、以前に@code{catch}により確立されたreturn位置に戻ることです。引数@var{tag}は、既存のさまざまなreturn位置からrturn位置を選択するために使用されます。複数のreturn位置が@var{tag}にマッチする場合、最内のものが使用されます。"

#. type: defun
#: control.texi.orig:729
msgid "The argument @var{value} is used as the value to return from that @code{catch}."
msgstr "引数@var{value}は、@code{catch}からreturnされる値として使用されます。"

#. type: kindex
#: control.texi.orig:730
#, no-wrap
msgid "no-catch"
msgstr "no-catch"

#. type: defun
#: control.texi.orig:733
msgid "If no return point is in effect with tag @var{tag}, then a @code{no-catch} error is signaled with data @code{(@var{tag} @var{value})}."
msgstr "タグ@var{tag}のreturn位置が存在しない場合、データ@code{(@var{tag} @var{value})}とともに、@code{no-catch}エラーがシグナルされます。"

#. type: subsection
#: control.texi.orig:736
#, no-wrap
msgid "Examples of @code{catch} and @code{throw}"
msgstr "Examples of @code{catch} and @code{throw}"

#. type: Plain text
#: control.texi.orig:742
msgid "One way to use @code{catch} and @code{throw} is to exit from a doubly nested loop.  (In most languages, this would be done with a ``goto''.)  Here we compute @code{(foo @var{i} @var{j})} for @var{i} and @var{j} varying from 0 to 9:"
msgstr "2重にネストされたループから脱出する1つの方法は、@code{catch}と@code{throw}を使うことです(ほとんどの言語では、これは``goto''により行なわれるでしょう)。ここでは、@var{i}と@var{j}を、0から9に変化させて@code{(foo @var{i} @var{j})}を計算します:"

#. type: group
#: control.texi.orig:755
#, no-wrap
msgid ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"
msgstr ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"

#. type: Plain text
#: control.texi.orig:763
msgid "If @code{foo} ever returns non-@code{nil}, we stop immediately and return a list of @var{i} and @var{j}.  If @code{foo} always returns @code{nil}, the @code{catch} returns normally, and the value is @code{nil}, since that is the result of the @code{while}."
msgstr "@code{foo}が非@code{nil}をreturnした場合、即座に処理を止めて、@var{i}と@var{j}のリストをreturnしています。@code{foo}が常に@code{nil}をreturnする場合、@code{catch}は通常どおりreturnし、その値は@code{while}の結果である@code{nil}となります。"

#. type: Plain text
#: control.texi.orig:767
msgid "Here are two tricky examples, slightly different, showing two return points at once.  First, two return points with the same tag, @code{hack}:"
msgstr "以下では、2つのreturn位置を1度に表す、微妙に異なるトリッキーな例を2つ示します。最初に、同じタグ@code{hack}にたいする2つのreturn位置があります:"

#. type: group
#: control.texi.orig:774
#, no-wrap
msgid ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"
msgstr ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"

#. type: group
#: control.texi.orig:782
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"

#. type: Plain text
#: control.texi.orig:791
msgid "Since both return points have tags that match the @code{throw}, it goes to the inner one, the one established in @code{catch2}.  Therefore, @code{catch2} returns normally with value @code{yes}, and this value is printed.  Finally the second body form in the outer @code{catch}, which is @code{'no}, is evaluated and returned from the outer @code{catch}."
msgstr "どちらのreturn位置も@code{throw}にマッチするタグをもつので、内側のもの、つまり@code{catch2}で確立されたものにgotoします。したがって@code{catch2}は通常どおり値@code{yes}をreturnするので、その値がプリントされます。最後に外側の@code{catch}の2番目のbody、つまり@code{'no}が評価されて、外側の@code{catch}からそれがreturnされます。"

#. type: Plain text
#: control.texi.orig:793
msgid "Now let's change the argument given to @code{catch2}:"
msgstr "ここで、@code{catch2}に与える引数を変更してみます:"

#. type: group
#: control.texi.orig:800
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"
msgstr ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"

#. type: Plain text
#: control.texi.orig:809
msgid "We still have two return points, but this time only the outer one has the tag @code{hack}; the inner one has the tag @code{quux} instead.  Therefore, @code{throw} makes the outer @code{catch} return the value @code{yes}.  The function @code{print} is never called, and the body-form @code{'no} is never evaluated."
msgstr "この場合も2つのreturn位置がありますが、今回は外側だけがタグ@code{hack}をもち、内側のものは、かわりにタグ@code{quux}をもちます。したがって、@code{throw}により、外側の@code{catch}が値@code{yes}をreturnします。関数@code{print}が呼び出されることはなく、bodyのフォーム@code{'no}も決して評価されません。"

#. type: cindex
#: control.texi.orig:812
#, no-wrap
msgid "errors"
msgstr "errors"

#. type: Plain text
#: control.texi.orig:816
msgid "When Emacs Lisp attempts to evaluate a form that, for some reason, cannot be evaluated, it @dfn{signals} an @dfn{error}."
msgstr "Emacs Lispが、何らかの理由により評価できないようなフォームの評価を試みた場合には、@dfn{エラー(error)}が@dfn{シグナル(signal)}されます。"

#. type: Plain text
#: control.texi.orig:821
msgid "When an error is signaled, Emacs's default reaction is to print an error message and terminate execution of the current command.  This is the right thing to do in most cases, such as if you type @kbd{C-f} at the end of the buffer."
msgstr "エラーがシグナルされた場合、エラーメッセージの表示とカレントこまんどの実行の終了が、Emacsデフォルトの反応です。たとえばバッファーの最後で@kbd{C-f}とタイプしたときのように、ほとんどの場合、これは正しい反応です。"

#. type: Plain text
#: control.texi.orig:831
msgid "In complicated programs, simple termination may not be what you want.  For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished.  In such cases, you would use @code{unwind-protect} to establish @dfn{cleanup expressions} to be evaluated in case of error.  (@xref{Cleanups}.)  Occasionally, you may wish the program to continue execution despite an error in a subroutine.  In these cases, you would use @code{condition-case} to establish @dfn{error handlers} to recover control in case of error."
msgstr "複雑なプログラムでは、単なる終了が望ましくない場合もあるでしょう。たとえば、そのプログラムはデータ構造に一時的に変更を行なっていたり、プログラム終了前に削除すべき一時バッファーを作成しているかもしれません。このような場合、エラー時に評価される@dfn{クリーンアップ式(cleanup expressions)}を設定するために、@code{unwind-protect}を使用するでしょう(@ref{Cleanups}を参照してください)。サブルーチン内のエラーにもかかわらずに、プログラムの実行を継続したいときがあるかもしれません。この場合、エラー時のリカバリーを制御するための@dfn{エラーハンドラー(error handlers)}を設定するために、@code{condition-case}を使用するでしょう。"

#. type: Plain text
#: control.texi.orig:835
msgid "Resist the temptation to use error handling to transfer control from one part of the program to another; use @code{catch} and @code{throw} instead.  @xref{Catch and Throw}."
msgstr "エラーハンドリングを使用せずに、プログラムの一部から別の部分へ制御を移すためには、@code{catch}と@code{throw}を使用します。@ref{Catch and Throw}を参照してください。"

#. type: node
#: control.texi.orig:841 control.texi.orig:843
#, no-wrap
msgid "Signaling Errors"
msgstr "Signaling Errors"

#. type: menuentry
#: control.texi.orig:841
msgid "How to report an error."
msgstr "エラーを報告する方法。"

#. type: node
#: control.texi.orig:841 control.texi.orig:962
#, no-wrap
msgid "Processing of Errors"
msgstr "Processing of Errors"

#. type: menuentry
#: control.texi.orig:841
msgid "What Emacs does when you report an error."
msgstr "エラーを報告するときEmacsが何を行なうか。"

#. type: node
#: control.texi.orig:841 control.texi.orig:999
#, no-wrap
msgid "Handling Errors"
msgstr "Handling Errors"

#. type: menuentry
#: control.texi.orig:841
msgid "How you can trap errors and continue execution."
msgstr "エラーをトラップして実行を継続する方法。"

#. type: node
#: control.texi.orig:841 control.texi.orig:1270
#, no-wrap
msgid "Error Symbols"
msgstr "Error Symbols"

#. type: menuentry
#: control.texi.orig:841
msgid "How errors are classified for trapping them."
msgstr "エラートラッピングのために、エラーをクラス分けする方法。"

#. type: subsubsection
#: control.texi.orig:844
#, no-wrap
msgid "How to Signal an Error"
msgstr "How to Signal an Error"

#. type: cindex
#: control.texi.orig:845
#, no-wrap
msgid "signaling errors"
msgstr "signaling errors"

#. type: Plain text
#: control.texi.orig:852
msgid "@dfn{Signaling} an error means beginning error processing.  Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (@pxref{Processing of Errors}).  Here we describe how to signal an error."
msgstr "エラーの@dfn{シグナリング(signaling)}とは、エラーの処理を開始することを意味します。エラー処理は通常、実行中のプログラムのすべて、または一部をアボート(abort)して、エラーをハンドルするためにセットアップされた位置にreturnします。ここでは、エラーをシグナルする方法を記述します。"

#. type: Plain text
#: control.texi.orig:858
msgid "Most errors are signaled ``automatically'' within Lisp primitives which you call for other purposes, such as if you try to take the @sc{car} of an integer or move forward a character at the end of the buffer.  You can also signal errors explicitly with the functions @code{error} and @code{signal}."
msgstr "ほとんどのエラーは、たとえば、整数にたいして@sc{car}を求めたり、バッファーの最後で1文字前方に移動したときなどのように、他の目的のために呼び出したLisp基本関数の中で、``自動的''にシグナルされます。関数@code{error}と@code{signal}で、明示的にエラーをシグナルすることもできます。"

#. type: Plain text
#: control.texi.orig:862
msgid "Quitting, which happens when the user types @kbd{C-g}, is not considered an error, but it is handled almost like an error.  @xref{Quitting}."
msgstr "ユーザーが@kbd{C-g}をタイプしたときに発生するquitは、エラーとは判断されませんが、ほとんどはエラーと同様に扱われます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: control.texi.orig:868
msgid "Every error specifies an error message, one way or another.  The message should state what is wrong (``File does not exist''), not how things ought to be (``File must exist'').  The convention in Emacs Lisp is that error messages should start with a capital letter, but should not end with any sort of punctuation."
msgstr "すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定します。そのメッセージは、何が悪いのか(``File does not exist'')、物事がどうしてそうあるべきではない(``File must exist'')かを示すべきです。Emacs Lispの監修では、エラーメッセージは大文字で開始され、句読点で終わるべきではありません。"

#. type: defun
#: control.texi.orig:869
#, no-wrap
msgid "error format-string &rest args"
msgstr "error format-string &rest args"

#. type: defun
#: control.texi.orig:873
msgid "This function signals an error with an error message constructed by applying @code{format} (@pxref{Formatting Strings}) to @var{format-string} and @var{args}."
msgstr "この関数は、@var{format-string}と@var{args}にたいして、@code{format}(@ref{Formatting Strings}を参照してください)を適用することにより構築されたエラーメッセージとともに、エラーをシグナルします。"

#. type: defun
#: control.texi.orig:875
msgid "These examples show typical uses of @code{error}:"
msgstr "以下は、@code{error}を使用する典型的な例です:"

#. type: group
#: control.texi.orig:880
#, no-wrap
msgid ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"
msgstr ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"

#. type: group
#: control.texi.orig:885
#, no-wrap
msgid ""
"(error \"You have committed %d errors\" 10)\n"
"     @error{} You have committed 10 errors\n"
msgstr ""
"(error \"You have committed %d errors\" 10)\n"
"     @error{} You have committed 10 errors\n"

#. type: defun
#: control.texi.orig:891
msgid "@code{error} works by calling @code{signal} with two arguments: the error symbol @code{error}, and a list containing the string returned by @code{format}."
msgstr "2つの引数 --- エラーシンボル@code{error}と、@code{format}によりreturnされる文字列を含むリスト --- で@code{signal}を呼び出すことにより、@code{error}は機能します。"

#. type: defun
#: control.texi.orig:896
msgid "@strong{Warning:} If you want to use your own string as an error message verbatim, don't just write @code{(error @var{string})}.  If @var{string} contains @samp{%}, it will be interpreted as a format specifier, with undesirable results.  Instead, use @code{(error \"%s\" @var{string})}."
msgstr "@strong{警告: }エラーメッセージとして固定の文字列を使用したい場合、単に@code{(error @var{string})}とは記述しないでください。もし@var{string}が@samp{%}を含む場合、それはフォーマット指定子(format specifier)として解釈されてしまうので、望む結果は得られません。かわりに、@code{(error \"%s\" @var{string})}を使用してください。"

#. type: defun
#: control.texi.orig:898
#, no-wrap
msgid "signal error-symbol data"
msgstr "signal error-symbol data"

#. type: anchor{#1}
#: control.texi.orig:903
msgid "Definition of signal"
msgstr "Definition of signal"

#. type: defun
#: control.texi.orig:903
msgid "This function signals an error named by @var{error-symbol}.  The argument @var{data} is a list of additional Lisp objects relevant to the circumstances of the error."
msgstr "この関数は、@var{error-symbol}により命名されるエラーをシグナルします。引数@var{data}は、エラーの状況に関連する追加のLispオブジェクトのリストです。"

#. type: defun
#: control.texi.orig:908
msgid "The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol defined with @code{define-error}.  This is how Emacs Lisp classifies different sorts of errors. @xref{Error Symbols}, for a description of error symbols, error conditions and condition names."
msgstr "引数@var{error-symbol}は、@dfn{エラーシンボル(error symbol)} --- @code{define-error}により定義されYたシンボル --- でなければなりません。これはEmacs Lispが異なる種類のエラーをクラス分けする方法です。エラーシンボル(error symbol)、エラーコンディション(error condition)、コンディション名(condition name)の説明については、@ref{Error Symbols}を参照してください。"

#. type: defun
#: control.texi.orig:916
msgid "If the error is not handled, the two arguments are used in printing the error message.  Normally, this error message is provided by the @code{error-message} property of @var{error-symbol}.  If @var{data} is non-@code{nil}, this is followed by a colon and a comma separated list of the unevaluated elements of @var{data}.  For @code{error}, the error message is the @sc{car} of @var{data} (that must be a string).  Subcategories of @code{file-error} are handled specially."
msgstr "エラーが処理されない場合、エラーメッセージをプリントするために2つの引数が使用されます。このエラーメッセージは通常、@var{error-symbol}の@code{error-message}プロパティーにより提供されます。@var{data}が非@code{nil}の場合、その後にコロンと、@var{data}の評価されていない要素を、カンマで区切ったリストが続きます。@code{error}が発生した場合、エラーメッセージは、@var{data}の@sc{car}(文字列でなければなりません)です。@code{file-error}のサブカテゴリーは、特別に処理されます。"

#. type: defun
#: control.texi.orig:921
msgid "The number and significance of the objects in @var{data} depends on @var{error-symbol}.  For example, with a @code{wrong-type-argument} error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type."
msgstr "@var{data}内のオブジェクトの数と重要性は、@var{error-symbol}に依存します。たとえば、@code{wrong-type-argument}エラーでは、リスト内には2つのオブジェクト --- 期待する型を記述する述語と、その型への適合に失敗したオブジェクト --- であるべきです。"

#. type: defun
#: control.texi.orig:926
msgid "Both @var{error-symbol} and @var{data} are available to any error handlers that handle the error: @code{condition-case} binds a local variable to a list of the form @code{(@var{error-symbol} .@: @var{data})} (@pxref{Handling Errors})."
msgstr "エラーを処理する任意のエラーハンドラーにたいして、@var{error-symbol}と@var{data}の両方を利用できます。@code{condition-case}は、ローカル変数を@code{(@var{error-symbol} .@: @var{data})}というフォームでバインドします(@ref{Handling Errors}を参照してください)。"

#. type: defun
#: control.texi.orig:929
msgid "The function @code{signal} never returns."
msgstr "関数@code{signal}は、決してreturnしません。"

#. type: group
#: control.texi.orig:934
#, no-wrap
msgid ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"
msgstr ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"

#. type: group
#: control.texi.orig:939
#, no-wrap
msgid ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"
msgstr ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"

#. type: cindex
#: control.texi.orig:943
#, no-wrap
msgid "user errors, signaling"
msgstr "user errors, signaling"

#. type: defun
#: control.texi.orig:944
#, no-wrap
msgid "user-error format-string &rest args"
msgstr "user-error format-string &rest args"

#. type: defun
#: control.texi.orig:954
msgid "This function behaves exactly like @code{error}, except that it uses the error symbol @code{user-error} rather than @code{error}.  As the name suggests, this is intended to report errors on the part of the user, rather than errors in the code itself.  For example, if you try to use the command @code{Info-history-back} (@kbd{l}) to move back beyond the start of your Info browsing history, Emacs signals a @code{user-error}.  Such errors do not cause entry to the debugger, even when @code{debug-on-error} is non-@code{nil}.  @xref{Error Debugging}."
msgstr "この関数は、@code{error}とまったく同じように振る舞いますが、@code{error}ではなく、@code{user-error}というエラーシンボルを使用します。名前が示唆するように、このエラーはコード自身のエラーではなく、ユーザーパートのエラーの報告を意図しています。たとえば、Infoの閲覧履歴の開始を超えて履歴を遡るためにコマンド@code{Info-history-back} (@kbd{l})を使用した場合、Emacsは@code{user-error}をシグナルします。このようなエラーでは、たとえ@code{debug-on-error}が非@code{nil}であっても、デバッガーへのエントリーは発生しません。@ref{Error Debugging}を参照してください。"

#. type: cindex
#: control.texi.orig:956
#, no-wrap
msgid "CL note---no continuable errors"
msgstr "CL note---no continuable errors"

#. type: quotation
#: control.texi.orig:960
msgid "@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp concept of continuable errors."
msgstr "@b{Common Lispに関する注意: }Emacs Lispには、Common Lispのような継続可能なエラーのような概念は存在しません。"

#. type: subsubsection
#: control.texi.orig:963
#, no-wrap
msgid "How Emacs Processes Errors"
msgstr "How Emacs Processes Errors"

#. type: cindex
#: control.texi.orig:964
#, no-wrap
msgid "processing of errors"
msgstr "processing of errors"

#. type: Plain text
#: control.texi.orig:974
msgid "When an error is signaled, @code{signal} searches for an active @dfn{handler} for the error.  A handler is a sequence of Lisp expressions designated to be executed if an error happens in part of the Lisp program.  If the error has an applicable handler, the handler is executed, and control resumes following the handler.  The handler executes in the environment of the @code{condition-case} that established it; all functions called within that @code{condition-case} have already been exited, and the handler cannot return to them."
msgstr "エラーがシグナルされたとき、@code{signal}は、そのエラーにたいするアクティブな@dfn{ハンドラー(handler)}を検索します。ハンドラーとは、Lispプログラムの一部でエラーが発生したときに実行するよう意図された、Lisp式のシーケンスです。そのエラーが適切なハンドラーをもつ場合、そのハンドラーが実行され、そのハンドラーの後から実行が再開されます。ハンドラーは、そのハンドラーが設定された@code{condition-case}の環境内で実行されます。@code{condition-case}内のすべての関数呼び出しはすでに終了しているので、ハンドラーがそれらにreturnすることはありません。"

#. type: Plain text
#: control.texi.orig:981
msgid "If there is no applicable handler for the error, it terminates the current command and returns control to the editor command loop.  (The command loop has an implicit handler for all kinds of errors.)  The command loop's handler uses the error symbol and associated data to print an error message.  You can use the variable @code{command-error-function} to control how this is done:"
msgstr "そのエラーにたいする適切なハンドラーが存在しない場合は、カレントコマンドを終了して、エディターのコマンドループに制御をreturnします(コマンドループは、すべての種類のエラーにたいする暗黙のハンドラーをもちます)。コマンドループのハンドラーは、エラーメッセージをプリントするために、エラーシンボルと、関連付けられたデータを使用します。変数@code{command-error-function}を使用して、これが行なわれる方法を制御できます:"

#. type: defvar
#: control.texi.orig:982
#, no-wrap
msgid "command-error-function"
msgstr "command-error-function"

#. type: defvar
#: control.texi.orig:990
msgid "This variable, if non-@code{nil}, specifies a function to use to handle errors that return control to the Emacs command loop.  The function should take three arguments: @var{data}, a list of the same form that @code{condition-case} would bind to its variable; @var{context}, a string describing the situation in which the error occurred, or (more often) @code{nil}; and @var{caller}, the Lisp function which called the primitive that signaled the error."
msgstr "この変数は、もし非@code{nil}の場合はEmacsのコマンドループに制御をreturnしたエラーの処理に使用する関数を指定します。この関数は3つの引数をとります。1つ目は@var{data}で、@code{condition-case}が自身の変数にバインドするのと同じフォームです。2つ目は@var{context}で、これはエラーが発生した状況を記述する文字列、または@code{nil}（よくある）です。3つ目は@var{caller}で、これはエラーをシグナルした基本関数を呼び出したLisp関数です。"

#. type: cindex
#: control.texi.orig:992
#, no-wrap
msgid "@code{debug-on-error} use"
msgstr "@code{debug-on-error} use"

#. type: Plain text
#: control.texi.orig:998
msgid "An error that has no explicit handler may call the Lisp debugger.  The debugger is enabled if the variable @code{debug-on-error} (@pxref{Error Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error."
msgstr "明示的なハンドラーのないエラーは、Lispデバッガーを呼び出すかもしれません。変数@code{debug-on-error} (@ref{Error Debugging}を参照してください)が非@code{nil}の場合、デバッガーが有効です。エラーハンドラーとは異なり、デバッガーはそのエラーの環境内で実行されるので、エラー時の変数の値を正確に調べることができます。"

#. type: subsubsection
#: control.texi.orig:1000
#, no-wrap
msgid "Writing Code to Handle Errors"
msgstr "Writing Code to Handle Errors"

#. type: cindex
#: control.texi.orig:1001
#, no-wrap
msgid "error handler"
msgstr "error handler"

#. type: cindex
#: control.texi.orig:1002
#, no-wrap
msgid "handling errors"
msgstr "handling errors"

#. type: Plain text
#: control.texi.orig:1009
msgid "The usual effect of signaling an error is to terminate the command that is running and return immediately to the Emacs editor command loop.  You can arrange to trap errors occurring in a part of your program by establishing an error handler, with the special form @code{condition-case}.  A simple example looks like this:"
msgstr "エラーをシグナルすることによる通常の効果は、実行されていたコマンドを終了して、Emacsエディターのコマンドループに即座にreturnすることです。スペシャルフォーム@code{condition-case}を使用して、エラーハンドラーを設定することにより、プログラム内の一部で発生するエラーのをトラップを調整することができます。以下は単純な例です:"

#. type: group
#: control.texi.orig:1015
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"

#. type: Plain text
#: control.texi.orig:1022
msgid "This deletes the file named @var{filename}, catching any error and returning @code{nil} if an error occurs.  (You can use the macro @code{ignore-errors} for a simple case like this; see below.)"
msgstr "これは、@var{filename}という名前のファイルを削除して、任意のエラーをcatchして、エラーが発生した場合は@code{nil}を参照してください(このような単純なケースでは、マクロ@code{ignore-errors}を使用することもできます。以下を参照してください)。"

#. type: Plain text
#: control.texi.orig:1028
msgid "The @code{condition-case} construct is often used to trap errors that are predictable, such as failure to open a file in a call to @code{insert-file-contents}.  It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user."
msgstr "@code{condition-case}構成は、@code{insert-file-contents}呼び出しでのファイルオープンの失敗のような、予想できるエラーをトラップするために多用されます。@code{condition-case}構成は、ユーザーからの読み取った式を評価するプログラムのような、完全に予測できないエラーのトラップにも使用されます。"

#. type: Plain text
#: control.texi.orig:1039
msgid "The second argument of @code{condition-case} is called the @dfn{protected form}.  (In the example above, the protected form is a call to @code{delete-file}.)  The error handlers go into effect when this form begins execution and are deactivated when this form returns.  They remain in effect for all the intervening time.  In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on.  This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including @code{signal} and @code{error}) called by the protected form, not by the protected form itself."
msgstr "@code{condition-case}の2番目の引数は、@dfn{保護されたフォーム(protected form)}と呼ばれます(上記の例では、保護されたフォームは、@code{delete-file}の呼び出しです)。このフォームの実行が開始されると、エラーハンドラーは効果をもち、このフォームがreturnすると不活性になります。その間のすべてにおいて、エラーハンドラーは効果をもちます。特に、このフォームで呼び出された関数、およびそのサブルーチンなどを実行する間、エラーハンドラーは効果をもちます。厳密にいうと、保護されたフォーム自身ではなく、保護されたフォームにより呼び出されたLisp基本関数(@code{signal}と@code{error}を含む)だけがシグナルされるというのは、よいことです。"

#. type: Plain text
#: control.texi.orig:1047
msgid "The arguments after the protected form are handlers.  Each handler lists one or more @dfn{condition names} (which are symbols) to specify which errors it will handle.  The error symbol specified when an error is signaled also defines a list of condition names.  A handler applies to an error if they have any condition names in common.  In the example above, there is one handler, and it specifies one condition name, @code{error}, which covers all errors."
msgstr "保護されたフォームの後の引数はハンドラーです。各ハンドラーは、どのエラーを処理するかを指定する、1つ以上の@dfn{コンディション名(condition names)}(シンボル)をリストします。エラーがシグナルされたとき、エラーシンボルはコンディション名のリストも定義します。エラーが共通の条件名をもつ場合、そのハンドラーはそのエラーに適用されます。上記の例では、1つのハンドラーがあり、それはすべてのエラーをカバーする条件名@code{error}を指定しています。"

#. type: Plain text
#: control.texi.orig:1052
msgid "The search for an applicable handler checks all the established handlers starting with the most recently established one.  Thus, if two nested @code{condition-case} forms offer to handle the same error, the inner of the two gets to handle it."
msgstr "適切なハンドラーの検索は、もっとも最近に設定されたハンドラーから開始して、設定されたすべてのハンドラーをチェックします。したがって、ネストされた@code{condition-case}フォームに同じエラー処理がある場合、内側のハンドラーがそれを処理します。"

#. type: Plain text
#: control.texi.orig:1056
msgid "If an error is handled by some @code{condition-case} form, this ordinarily prevents the debugger from being run, even if @code{debug-on-error} says this error should invoke the debugger."
msgstr "何らかの@code{condition-case}によりエラーが処理された場合、@code{debug-on-error}でエラーによりデバッガーが呼び出されるようにしていても、通常はデバッガーの実行が抑制されます。"

#. type: Plain text
#: control.texi.orig:1062
msgid "If you want to be able to debug errors that are caught by a @code{condition-case}, set the variable @code{debug-on-signal} to a non-@code{nil} value.  You can also specify that a particular handler should let the debugger run first, by writing @code{debug} among the conditions, like this:"
msgstr "@code{condition-case}により補足されるようなエラーをデバッグできるようにしたい場合は、変数@code{debug-on-signal}に非@code{nil}値をセットします。以下のようにコンディションの中に@code{debug}を記述することにより、最初にデバッガーを実行するような、特定のハンドラーを指定することもできます:"

#. type: group
#: control.texi.orig:1068
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"
msgstr ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"

#. type: Plain text
#: control.texi.orig:1076
msgid "The effect of @code{debug} here is only to prevent @code{condition-case} from suppressing the call to the debugger.  Any given error will invoke the debugger only if @code{debug-on-error} and the other usual filtering mechanisms say it should.  @xref{Error Debugging}."
msgstr "ここでの@code{debug}の効果は、デバッガー呼び出しを抑制する@code{condition-case}を防ぐことだけです。@code{debug-on-error}およびその他のフィルタリングメカニズムがデバッガーを呼び出すように指定されているときだけ、エラーによりデバッガーが呼び出されます。@ref{Error Debugging}を参照してください。"

#. type: defmac
#: control.texi.orig:1077
#, no-wrap
msgid "condition-case-unless-debug var protected-form handlers@dots{}"
msgstr "condition-case-unless-debug var protected-form handlers@dots{}"

#. type: defmac
#: control.texi.orig:1082
msgid "The macro @code{condition-case-unless-debug} provides another way to handle debugging of such forms.  It behaves exactly like @code{condition-case}, unless the variable @code{debug-on-error} is non-@code{nil}, in which case it does not handle any errors at all."
msgstr "マクロ@code{condition-case-unless-debug}は、そのようなフォームのデバッギングを処理する、別の方法を提供します。このマクロは、変数@code{debug-on-error}が@code{nil}の場合、つまり任意のエラーを処理しないようなケース以外は、@code{condition-case}とまったく同様に振る舞います。"

#. type: Plain text
#: control.texi.orig:1090
msgid "Once Emacs decides that a certain handler handles the error, it returns control to that handler.  To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all @code{unwind-protect} forms that are being exited.  Once control arrives at the handler, the body of the handler executes normally."
msgstr "特定のハンドラーがそのエラーを処理するとEmacsが判断すると、Emacsは制御をそのハンドラーにreturnします。これを行うために、Emacsはそのとき脱出しつつあるバインディング構成により作成されたすべての変数のバインドを解き、そのとき脱出しつつあるすべての@code{unwind-protect}フォームを実行します。制御がそのハンドラーに達すると、そのハンドラーのbodyが通常どおり実行されます。"

#. type: Plain text
#: control.texi.orig:1097
msgid "After execution of the handler body, execution returns from the @code{condition-case} form.  Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form.  All it can do is clean up and proceed."
msgstr "そのハンドラーのbodyを実行した後、@code{condition-case}フォームから実行がreturnされます。保護されたフォームは、そのハンドラーの実行の前に完全にexitしているので、そのハンドラーはそのエラーの位置から実行を再開することはできず、その保護されたフォーム内で作られた変数のバインディングを調べることもできません。ハンドラーが行なえることは、クリーンアップと、処理を進行させることだけです。"

#. type: Plain text
#: control.texi.orig:1104
msgid "Error signaling and handling have some resemblance to @code{throw} and @code{catch} (@pxref{Catch and Throw}), but they are entirely separate facilities.  An error cannot be caught by a @code{catch}, and a @code{throw} cannot be handled by an error handler (though using @code{throw} when there is no suitable @code{catch} signals an error that can be handled)."
msgstr "エラーのシグナルとハンドルには、@code{throw}と@code{catch}(@ref{Catch and Throw})に類似する点がいくつかありますが、これらは完全に別の機能です。エラーは@code{catch}でキャッチできず、@code{throw}をエラーハンドラーで処理することはできません(しかし対応する@code{catch}が存在しないときに@code{throw}を仕様することによりシグナルされるエラーは、処理できます)。"

#. type: defspec
#: control.texi.orig:1105
#, no-wrap
msgid "condition-case var protected-form handlers@dots{}"
msgstr "condition-case var protected-form handlers@dots{}"

#. type: defspec
#: control.texi.orig:1112
msgid "This special form establishes the error handlers @var{handlers} around the execution of @var{protected-form}.  If @var{protected-form} executes without error, the value it returns becomes the value of the @code{condition-case} form; in this case, the @code{condition-case} has no effect.  The @code{condition-case} form makes a difference when an error occurs during @var{protected-form}."
msgstr "このスペシャルフォームは、@var{protected-form}の実行を囲い込むエラーハンドラー@var{handlers}を確立します。エラーなしで@var{protected-form}が実行された場合、returnされる値は@code{condition-case}フォームの値になります。この場合、@code{condition-case}は効果をもちません。@var{protected-form}の間にエラーが発生した場合、@code{condition-case}は違いをもちます。"

#. type: defspec
#: control.texi.orig:1119
msgid "Each of the @var{handlers} is a list of the form @code{(@var{conditions} @var{body}@dots{})}.  Here @var{conditions} is an error condition name to be handled, or a list of condition names (which can include @code{debug} to allow the debugger to run before the handler); @var{body} is one or more Lisp expressions to be executed when this handler handles an error.  Here are examples of handlers:"
msgstr "それぞれの@var{handlers}は、@code{(@var{conditions} @var{body}@dots{})}というフォームのリストです。ここで@var{conditions}は、ハンドルされるエラーコンディション名、またはそのハンドラーの前にデバッガーを実行するためのコンディション名(@code{debug}を含みます)です。@var{body}は、このハンドラーがエラーを処理するときに実行される、1つ以上のLisp式です。"

#. type: group
#: control.texi.orig:1123
#, no-wrap
msgid ""
"(error nil)\n"
"\n"
msgstr ""
"(error nil)\n"
"\n"

#. type: group
#: control.texi.orig:1125
#, no-wrap
msgid ""
"(arith-error (message \"Division by zero\"))\n"
"\n"
msgstr ""
"(arith-error (message \"Division by zero\"))\n"
"\n"

#. type: group
#: control.texi.orig:1129
#, no-wrap
msgid ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"
msgstr ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"

#. type: defspec
#: control.texi.orig:1139
msgid "Each error that occurs has an @dfn{error symbol} that describes what kind of error it is, and which describes also a list of condition names (@pxref{Error Symbols}).  Emacs searches all the active @code{condition-case} forms for a handler that specifies one or more of these condition names; the innermost matching @code{condition-case} handles the error.  Within this @code{condition-case}, the first applicable handler handles the error."
msgstr "発生するエラーはそれぞれ、それが何の種類のエラーかを記述する@dfn{エラーシンボル(error symbol)}をもち、これはコンディション名のリストも記述します(@ref{Error Symbols}を参照してください)。Emacsは、1つ以上のコンディション名を指定するハンドラーにたいして、すべてのアクティブな@code{condition-case}フォームを検索します。@code{condition-case}の最内のマッチは、そのエラーを処理します。この@code{condition-case}では、最初に適合したハンドラーが、そのエラーを処理します。"

#. type: defspec
#: control.texi.orig:1143
msgid "After executing the body of the handler, the @code{condition-case} returns normally, using the value of the last form in the handler body as the overall value."
msgstr "ハンドラーのbodyを実行した後、@code{condition-case}は通常どおりreturnし、ハンドラーのbodyの最後の値を、ハンドラー全体の値として使用します。"

#. type: cindex
#: control.texi.orig:1144
#, no-wrap
msgid "error description"
msgstr "error description"

#. type: defspec
#: control.texi.orig:1154
msgid "The argument @var{var} is a variable.  @code{condition-case} does not bind this variable when executing the @var{protected-form}, only when it handles an error.  At that time, it binds @var{var} locally to an @dfn{error description}, which is a list giving the particulars of the error.  The error description has the form @code{(@var{error-symbol} . @var{data})}.  The handler can refer to this list to decide what to do.  For example, if the error is for failure opening a file, the file name is the second element of @var{data}---the third element of the error description."
msgstr "引数@var{var}は変数です。@var{protected-form}を実行するとき、@code{condition-case}はこの変数をバインドせず、エラーを処理するときだけバインドします。その場合は、@var{var}を@dfn{エラー記述(error description)}にバインドします。これはエラーの詳細を与えるリストです。このエラー記述は、@code{(@var{error-symbol} . @var{data})}というフォームをもちます。ハンドラーは、何を行なうか決定するために、このリストを参照することができます。たとえば、ファイルオープンの失敗にたいするエラーの場合、ファイル名が@var{data}(エラー記述の3番目の要素)の2番目の要素になります。"

#. type: defspec
#: control.texi.orig:1157
msgid "If @var{var} is @code{nil}, that means no variable is bound.  Then the error symbol and associated data are not available to the handler."
msgstr "@var{var}が@code{nil}の場合、それはバインドされた変数がないことを意味します。この場合、エラーシンボルおよび関連するデータは、そのハンドラーでは利用できません。"

#. type: cindex
#: control.texi.orig:1158
#, no-wrap
msgid "rethrow a signal"
msgstr "rethrow a signal"

#. type: defspec
#: control.texi.orig:1162
msgid "Sometimes it is necessary to re-throw a signal caught by @code{condition-case}, for some outer-level handler to catch.  Here's how to do that:"
msgstr "より外側のレベルのハンドラーにcatchさせるために、@code{condition-case}によりcatchされたシグナルを再度throwする必要がある場合もあります。以下はこれを行なう方法です:"

#. type: example
#: control.texi.orig:1165
#, no-wrap
msgid "  (signal (car err) (cdr err))\n"
msgstr "  (signal (car err) (cdr err))\n"

#. type: defspec
#: control.texi.orig:1171
msgid "where @code{err} is the error description variable, the first argument to @code{condition-case} whose error condition you want to re-throw.  @xref{Definition of signal}."
msgstr "ここで@code{err}はエラー記述変数(error description variable)で、@code{condition-case}の1番目の引数は、再throwしたいエラーコンディションです。@ref{Definition of signal}を参照してください。"

#. type: defun
#: control.texi.orig:1173
#, no-wrap
msgid "error-message-string error-descriptor"
msgstr "error-message-string error-descriptor"

#. type: defun
#: control.texi.orig:1177
msgid "This function returns the error message string for a given error descriptor.  It is useful if you want to handle an error by printing the usual error message for that error.  @xref{Definition of signal}."
msgstr "この関数は、与えられたエラー記述子(error descriptor)にたいするエラーメッセージ文字列をreturnします。これは、そのエラーにたいする通常のエラーメッセージをプリントすることにより、エラーを処理したい場合に有用です。@ref{Definition of signal}を参照してください。"

#. type: cindex
#: control.texi.orig:1179
#, no-wrap
msgid "@code{arith-error} example"
msgstr "@code{arith-error} example"

#. type: Plain text
#: control.texi.orig:1183
msgid "Here is an example of using @code{condition-case} to handle the error that results from dividing by zero.  The handler displays the error message (but without a beep), then returns a very large number."
msgstr "以下は、0除算の結果によるエラーを処理するために、@code{condition-case}を使用する例です。このハンドラーは、(beepなしで)エラーメッセージを表示して、非常に大きい数をreturnします。"

#. type: group
#: control.texi.orig:1190
#, no-wrap
msgid ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{Protected form.}\n"
"      (/ dividend divisor)\n"
msgstr ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{保護されたフォーム。}\n"
"      (/ dividend divisor)\n"

#. type: group
#: control.texi.orig:1198
#, no-wrap
msgid ""
"    ;; @r{The handler.}\n"
"    (arith-error                        ; @r{Condition.}\n"
"     ;; @r{Display the usual message for this error.}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"
msgstr ""
"    ;; @r{ハンドラー。}\n"
"    (arith-error                        ; @r{Condition.}\n"
"     ;; @r{このエラーにたいする、通常のメッセージを表示する。}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"

#. type: group
#: control.texi.orig:1204
#, no-wrap
msgid ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"
msgstr ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"

#. type: Plain text
#: control.texi.orig:1211
msgid "The handler specifies condition name @code{arith-error} so that it will handle only division-by-zero errors.  Other kinds of errors will not be handled (by this @code{condition-case}).  Thus:"
msgstr "このハンドラーはコンディション名@code{arith-error}を指定するので、division-by-zero(0除算)エラーだけを処理します。他の種類のエラーは(この@code{condition-case}によっては)、処理されません。したがって:"

#. type: group
#: control.texi.orig:1216
#, no-wrap
msgid ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"
msgstr ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"

#. type: Plain text
#: control.texi.orig:1221
msgid "Here is a @code{condition-case} that catches all kinds of errors, including those from @code{error}:"
msgstr "以下は、@code{error}によるエラーを含む、すべての種類のエラーをcatchする@code{condition-case}です:"

#. type: group
#: control.texi.orig:1226
#, no-wrap
msgid ""
"(setq baz 34)\n"
"     @result{} 34\n"
msgstr ""
"(setq baz 34)\n"
"     @result{} 34\n"

#. type: group
#: control.texi.orig:1239
#, no-wrap
msgid ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{This is a call to the function @code{error}.}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{This is the handler; it is not a form.}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"
msgstr ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{関数@code{error}の呼び出し}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{フォームではないハンドラー。}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"

#. type: defmac
#: control.texi.orig:1242
#, no-wrap
msgid "ignore-errors body@dots{}"
msgstr "ignore-errors body@dots{}"

#. type: defmac
#: control.texi.orig:1247
msgid "This construct executes @var{body}, ignoring any errors that occur during its execution.  If the execution is without error, @code{ignore-errors} returns the value of the last form in @var{body}; otherwise, it returns @code{nil}."
msgstr "これは、その実行中に発生する任意のエラーを無視して、@var{body}の実行を構築します。その実行にエラーがなかった場合、@code{ignore-errors}は@var{body}内の最後のフォームの値をreturnし、それ以外は@code{nil}をreturnします。"

#. type: defmac
#: control.texi.orig:1250
msgid "Here's the example at the beginning of this subsection rewritten using @code{ignore-errors}:"
msgstr "以下は、このセクションの最初の例を、@code{ignore-errors}を使用して記述する例です:"

#. type: group
#: control.texi.orig:1255
#, no-wrap
msgid ""
"  (ignore-errors\n"
"   (delete-file filename))\n"
msgstr ""
"  (ignore-errors\n"
"   (delete-file filename))\n"

#. type: defmac
#: control.texi.orig:1259
#, no-wrap
msgid "with-demoted-errors format body@dots{}"
msgstr "with-demoted-errors format body@dots{}"

#. type: defmac
#: control.texi.orig:1268
msgid "This macro is like a milder version of @code{ignore-errors}.  Rather than suppressing errors altogether, it converts them into messages.  It uses the string @var{format} to format the message.  @var{format} should contain a single @samp{%}-sequence; e.g., @code{\"Error: %S\"}.  Use @code{with-demoted-errors} around code that is not expected to signal errors, but should be robust if one does occur.  Note that this macro uses @code{condition-case-unless-debug} rather than @code{condition-case}."
msgstr "このマクロは、いわば@code{ignore-errors}の穏やかなバージョンです。これはエラーを完全に抑止するのではなく、エラーをメッセージに変換します。これはメッセージのフォーマットに、文字列@var{format}を使用します。@var{format}は、@code{\"Error: %S\"}のように、単一の@samp{%}シーケンスを含むべきです。エラーをシグナルすると予測されないが、もし発生した場合は堅牢であるべきようなコードの周囲に、@code{with-demoted-errors}を使用します。このマクロは、@code{condition-case}ではなく、@code{condition-case-unless-debug}を使用することに注意してください。"

#. type: subsubsection
#: control.texi.orig:1271
#, no-wrap
msgid "Error Symbols and Condition Names"
msgstr "Error Symbols and Condition Names"

#. type: cindex
#: control.texi.orig:1272
#, no-wrap
msgid "error symbol"
msgstr "error symbol"

#. type: cindex
#: control.texi.orig:1273
#, no-wrap
msgid "error name"
msgstr "error name"

#. type: cindex
#: control.texi.orig:1274
#, no-wrap
msgid "condition name"
msgstr "condition name"

#. type: cindex
#: control.texi.orig:1275
#, no-wrap
msgid "user-defined error"
msgstr "user-defined error"

#. type: kindex
#: control.texi.orig:1276
#, no-wrap
msgid "error-conditions"
msgstr "error-conditions"

#. type: kindex
#: control.texi.orig:1277
#, no-wrap
msgid "define-error"
msgstr "define-error"

#. type: Plain text
#: control.texi.orig:1283
msgid "When you signal an error, you specify an @dfn{error symbol} to specify the kind of error you have in mind.  Each error has one and only one error symbol to categorize it.  This is the finest classification of errors defined by the Emacs Lisp language."
msgstr "エラーをシグナルするとき、想定するエラーの種類を指定するために、@dfn{エラーシンボル(error symbol)}を指定します。エラーはそれぞれ、それをカテゴリー分けするために、ただ1つのエラーシンボルをもちます。これはEmacs Lisp言語で定義されるエラーの、もっとも良い分類方法です。"

#. type: Plain text
#: control.texi.orig:1293
msgid "These narrow classifications are grouped into a hierarchy of wider classes called @dfn{error conditions}, identified by @dfn{condition names}.  The narrowest such classes belong to the error symbols themselves: each error symbol is also a condition name.  There are also condition names for more extensive classes, up to the condition name @code{error} which takes in all kinds of errors (but not @code{quit}).  Thus, each error has one or more condition names: @code{error}, the error symbol if that is distinct from @code{error}, and perhaps some intermediate classifications."
msgstr "これら狭義の分類は、@dfn{エラー条件(error conditions)}と呼ばれる、より広義のクラス階層にグループ化され、それらは@dfn{コンディション名(condition names)}により識別されます。そのようなもっとも狭義なクラスは、エラーシンボル自体に属します。つまり各エラーシンボルは、コンディション名でもあるのです。すべての種類のエラー(@code{quit}を除く)を引き受けるコンディション名@code{error}に至る、より広義のクラスにたいするコンディション名も存在します。したがって、各エラーは1つ以上のコンディション名をもちます。つまり、@code{error}、@code{error}とは区別されるエラーシンボル、もしかしたらその中間に分類されるものかもしれません。"

#. type: defun
#: control.texi.orig:1294
#, no-wrap
msgid "define-error name message &optional parent"
msgstr "define-error name message &optional parent"

#. type: defun
#: control.texi.orig:1301
msgid "In order for a symbol to be an error symbol, it must be defined with @code{define-error} which takes a parent condition (defaults to @code{error}).  This parent defines the conditions that this kind of error belongs to.  The transitive set of parents always includes the error symbol itself, and the symbol @code{error}.  Because quitting is not considered an error, the set of parents of @code{quit} is just @code{(quit)}."
msgstr "シンボルをエラーシンボルとするために、シンボルは親コンディションをとる@code{define-error}で定義されなければなりません。この親は、この種のエラーが属するコンディションを定義します。親の推移的な集合は、常にそのエラーシンボルと、シンボル@code{error}を含みます。quitはエラーと判断されないので、@code{quit}の親の集合は、単なる@code{(quit)}です。"

#. type: cindex
#: control.texi.orig:1303
#, no-wrap
msgid "peculiar error"
msgstr "peculiar error"

#. type: Plain text
#: control.texi.orig:1308
msgid "In addition to its parents, the error symbol has a @var{message} which is a string to be printed when that error is signaled but not handled.  If that message is not valid, the error message @samp{peculiar error} is used.  @xref{Definition of signal}."
msgstr "親のコンディションに加えて、エラーシンボルは@var{メッセージ(message)}をもち、これは処理されないエラーがシグナルされたときプリントされる文字列です。そのメッセージが有効でない場合、エラーメッセージ@samp{peculiar error}が使用されます。@ref{Definition of signal}を参照してください。"

#. type: Plain text
#: control.texi.orig:1312
msgid "Internally, the set of parents is stored in the @code{error-conditions} property of the error symbol and the message is stored in the @code{error-message} property of the error symbol."
msgstr "内部的には、親の集合はエラーシンボルの@code{error-conditions}プロパティーに格納され、メッセージはエラーシンボルの@code{error-message}プロパティーに格納されます。"

#. type: Plain text
#: control.texi.orig:1314
msgid "Here is how we define a new error symbol, @code{new-error}:"
msgstr "以下は、新しいエラーシンボル@code{new-error}を定義する例です:"

#. type: group
#: control.texi.orig:1318
#, no-wrap
msgid "(define-error 'new-error \"A new error\" 'my-own-errors)\n"
msgstr "(define-error 'new-error \"A new error\" 'my-own-errors)\n"

#. type: Plain text
#: control.texi.orig:1326
msgid "This error has several condition names: @code{new-error}, the narrowest classification; @code{my-own-errors}, which we imagine is a wider classification; and all the conditions of @code{my-own-errors} which should include @code{error}, which is the widest of all."
msgstr "このエラーは複数のコンディション名 --- もっとも狭義の分類@code{new-error}、より広義の分類を想定する@code{my-own-errors}、および@code{my-own-errors}のコンディションすべてを含む@code{error}で、これはすべての中でもっとも広義なものです。"

#. type: Plain text
#: control.texi.orig:1329
msgid "The error string should start with a capital letter but it should not end with a period.  This is for consistency with the rest of Emacs."
msgstr "エラー文字列は大文字で開始されるべきですが、ピリオドで終了すべきではありません。これはEmacsの他の部分との整合性のためです。"

#. type: Plain text
#: control.texi.orig:1333
msgid "Naturally, Emacs will never signal @code{new-error} on its own; only an explicit call to @code{signal} (@pxref{Definition of signal}) in your code can do this:"
msgstr "もちろんEmacs自身が@code{new-error}をシグナルすることはありません。あなたのコード内で明示的に@code{signal}(@ref{Definition of signal}を参照してください)を呼び出すことにより、これを行なうことができるのです。"

#. type: group
#: control.texi.orig:1338
#, no-wrap
msgid ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"
msgstr ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"

#. type: Plain text
#: control.texi.orig:1344
msgid "This error can be handled through any of its condition names.  This example handles @code{new-error} and any other errors in the class @code{my-own-errors}:"
msgstr "このエラーは、エラーの任意のコンディション名により処理することができます。以下の例は、@code{new-error}とクラス@code{my-own-errors}内の他の任意のエラーを処理します:"

#. type: group
#: control.texi.orig:1350
#, no-wrap
msgid ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"
msgstr ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"

#. type: Plain text
#: control.texi.orig:1358
msgid "The significant way that errors are classified is by their condition names---the names used to match errors with handlers.  An error symbol serves only as a convenient way to specify the intended error message and list of condition names.  It would be cumbersome to give @code{signal} a list of condition names rather than one error symbol."
msgstr "エラーが分類される有効な方法は、コンディション名による方法で、その名前はハンドラーのエラーのマッチに使用されます。エラーシンボルは、意図されたエラーメッセージと、コンディション名のリストを指定する便利な方法であるという役割だけです。1つのエラーシンボルではなく、コンディション名のリストを@code{signal}に与えるのは、面倒でしょう。"

#. type: Plain text
#: control.texi.orig:1364
msgid "By contrast, using only error symbols without condition names would seriously decrease the power of @code{condition-case}.  Condition names make it possible to categorize errors at various levels of generality when you write an error handler.  Using error symbols alone would eliminate all but the narrowest level of classification."
msgstr "対照的に、コンディション名を伴わずにエラーシンボルだけを使用した場合、それは@code{condition-case}の効果を著しく減少させるでしょう。コンディション名は、エラーハンドラーを記述するとき、一般性のさまざまなレベルにおいて、エラーをカテゴリー分けすることを可能にします。エラーシンボルを単独で使用することは、もっとも狭義なレベルの分類を除くすべてを捨てることです。"

#. type: Plain text
#: control.texi.orig:1367
msgid "@xref{Standard Errors}, for a list of the main error symbols and their conditions."
msgstr "主要なエラーシンボルと、それらのコンディションについては、@ref{Standard Errors}を参照してください。"

#. type: subsection
#: control.texi.orig:1369
#, no-wrap
msgid "Cleaning Up from Nonlocal Exits"
msgstr "Cleaning Up from Nonlocal Exits"

#. type: cindex
#: control.texi.orig:1370
#, no-wrap
msgid "nonlocal exits, cleaning up"
msgstr "nonlocal exits, cleaning up"

#. type: Plain text
#: control.texi.orig:1378
msgid "The @code{unwind-protect} construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw.  (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; @ref{Atomic Changes}.)"
msgstr "@code{unwind-protect}構成は、データ構造を一時的に不整合な状態に置くときは、重要です。これはエラーやthrouのイベントにより、再びデータを整合された状態にすることができます(バッファー内容の変更だけに使用される、他のクリーンアップ構成は、アトミックな変更グループです。@ref{Atomic Changes}を参照してください)。"

#. type: defspec
#: control.texi.orig:1379
#, no-wrap
msgid "unwind-protect body-form cleanup-forms@dots{}"
msgstr "unwind-protect body-form cleanup-forms@dots{}"

#. type: cindex
#: control.texi.orig:1380
#, no-wrap
msgid "cleanup forms"
msgstr "cleanup forms"

#. type: cindex
#: control.texi.orig:1381
#, no-wrap
msgid "protected forms"
msgstr "protected forms"

#. type: cindex
#: control.texi.orig:1382
#, no-wrap
msgid "error cleanup"
msgstr "error cleanup"

#. type: cindex
#: control.texi.orig:1383
#, no-wrap
msgid "unwinding"
msgstr "unwinding"

#. type: defspec
#: control.texi.orig:1390
msgid "@code{unwind-protect} executes @var{body-form} with a guarantee that the @var{cleanup-forms} will be evaluated if control leaves @var{body-form}, no matter how that happens.  @var{body-form} may complete normally, or execute a @code{throw} out of the @code{unwind-protect}, or cause an error; in all cases, the @var{cleanup-forms} will be evaluated."
msgstr "@code{unwind-protect}は、制御が@var{body-form}を離れる場合に、@var{cleanup-forms}が評価されるという保証の下、なにが起こった可に関わらず、@var{body-form}を実行します。@var{body-form}は通常どおり完了するかもしれず、@code{unwind-protect}の外で@code{throw}が実行されたり、エラーが発生するかもしれませんが、@var{cleanup-forms}は評価されます。"

#. type: defspec
#: control.texi.orig:1395
msgid "If @var{body-form} finishes normally, @code{unwind-protect} returns the value of @var{body-form}, after it evaluates the @var{cleanup-forms}.  If @var{body-form} does not finish, @code{unwind-protect} does not return any value in the normal sense."
msgstr "@var{body-form}が正常に終了した場合、@code{unwind-protect}は@var{cleanup-forms}を評価した後で、@var{body-form}の値をreturnします。@var{body-form}が終了しなかった場合、@code{unwind-protect}は通常の意味における値は、returnしません。"

#. type: defspec
#: control.texi.orig:1402
msgid "Only @var{body-form} is protected by the @code{unwind-protect}.  If any of the @var{cleanup-forms} themselves exits nonlocally (via a @code{throw} or an error), @code{unwind-protect} is @emph{not} guaranteed to evaluate the rest of them.  If the failure of one of the @var{cleanup-forms} has the potential to cause trouble, then protect it with another @code{unwind-protect} around that form."
msgstr "@code{unwind-protect}により保護されるのは、@var{body-form}だけです。@var{cleanup-forms}自体の任意のフォームが、(@code{throw}またはエラーにより)非ローカルにexitした場合、@code{unwind-protect}は残りのフォームが評価されることを保証@emph{しません}。@var{cleanup-forms}の中の1つが失敗することが問題となる場合は、そのフォームの周囲に他の@code{unwind-protect}を配して保護します。"

#. type: defspec
#: control.texi.orig:1407
msgid "The number of currently active @code{unwind-protect} forms counts, together with the number of local variable bindings, against the limit @code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local Variables})."
msgstr "現在アクティブな@code{unwind-protect}フォーム数と、ローカルの変数バインディング数の和は、@code{max-specpdl-size}(@ref{Definition of max-specpdl-size,, Local Variables}を参照してください)により制限されます。"

#. type: Plain text
#: control.texi.orig:1411
msgid "For example, here we make an invisible buffer for temporary use, and make sure to kill it before finishing:"
msgstr "たとえば、以下は一時的な使用のために不可視のバッファーを作成して、終了する前に確実にそのバッファーをkillする例です:"

#. type: group
#: control.texi.orig:1419
#, no-wrap
msgid ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"
msgstr ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"

#. type: Plain text
#: control.texi.orig:1430
msgid "You might think that we could just as well write @code{(kill-buffer (current-buffer))} and dispense with the variable @code{buffer}.  However, the way shown above is safer, if @var{body-form} happens to get an error after switching to a different buffer! (Alternatively, you could write a @code{save-current-buffer} around @var{body-form}, to ensure that the temporary buffer becomes current again in time to kill it.)"
msgstr "@code{(kill-buffer (current-buffer))}のように記述して、変数@code{buffer}を使用せずに、同様のことを行えると思うかもしれません。しかし上の例は、別のバッファーにスイッチしたときに@var{body-form}でエラーが発生した場合、より安全なのです(一時的なバッファーをkillするとき、そのバッファーがカレントとなることを確実にするために、かわりに@var{body-form}の周囲に@code{save-current-buffer}を記述することもできます)。"

#. type: Plain text
#: control.texi.orig:1435
msgid "Emacs includes a standard macro called @code{with-temp-buffer} which expands into more or less the code shown above (@pxref{Definition of with-temp-buffer,, Current Buffer}).  Several of the macros defined in this manual use @code{unwind-protect} in this way."
msgstr "Emacsには、上のコードとおおよそ等しいコードに展開される、@code{with-temp-buffer}という標準マクロが含まれます(@ref{Definition of with-temp-buffer,, Current Buffer}を参照してください)。このマニュアル中で定義されるいくつかのマクロは、この方法で@code{unwind-protect}を使用します。"

#. type: findex
#: control.texi.orig:1436
#, no-wrap
msgid "ftp-login"
msgstr "ftp-login"

#. type: Plain text
#: control.texi.orig:1444
msgid "Here is an actual example derived from an FTP package.  It creates a process (@pxref{Processes}) to try to establish a connection to a remote machine.  As the function @code{ftp-login} is highly susceptible to numerous problems that the writer of the function cannot anticipate, it is protected with a form that guarantees deletion of the process in the event of failure.  Otherwise, Emacs might fill up with useless subprocesses."
msgstr "以下は、FTPパッケージ由来の、実際の例です。これは、リモートマシンへの接続の確立を試みるために、プロセス(@ref{Processes}を参照してください)を作成します。関数@code{ftp-login}は、関数のライター(writer)が予想できないことによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削除を保証するフォームで保護されています。そうしないと、Emacsは無用なサブプロセスで一杯になってしまうでしょう。"

#. type: group
#: control.texi.orig:1455
#, no-wrap
msgid ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"
msgstr ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"

#. type: Plain text
#: control.texi.orig:1462
msgid "This example has a small bug: if the user types @kbd{C-g} to quit, and the quit happens immediately after the function @code{ftp-setup-buffer} returns but before the variable @code{process} is set, the process will not be killed.  There is no easy way to fix this bug, but at least it is very unlikely."
msgstr "この例には小さなバグがあります。ユーザーがquitするために@kbd{C-g}とタイプした場合、関数@code{ftp-setup-buffer}がreturnした後、即座にquitが発生しますが、それは変数@code{process}がセットされる前なので、そのプロセスはkillされないでしょう。このバグを簡単に訂正する方法はありませんが、少なくともこれは非常に稀なことだと言えます。"
