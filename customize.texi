@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1997-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Customization
@chapter Customization Settings

@cindex customization item
  Emacsのユーザーは、カスタマイズインターフェースにより、Lispコードを記述することなく。変数とフェースをカスタマイズできます。@ref{Easy
Customization,,, emacs, The GNU Emacs
Manual}を参照してください。このチャプターでは、カスタマイズインターフェースを通じて、ユーザーとやりとりするための、@dfn{カスタマイズアイテム（customization
items）}を定義する方法を説明します。

  カスタマイズアイテムには、カスタマイズ可能変数(customizable variable:
@ifinfo
@code{defcustom}マクロで定義される。@ref{Variable Definitions}を参照してください)、
@end ifinfo
@ifnotinfo
@code{defcustom}マクロで定義される。
@end ifnotinfo
カスタマイズ可能フェース(customizable face: @code{defface}で定義される。@ref{Defining
Faces}を参照してください)、および関連するカスタマイズアイテムのグループのためのコンテナーとして働くカスタマイズグループ(customization
group:
@ifinfo
@code{defgroup}で定義される。@ref{Group Definitions}を参照してください)
@end ifinfo
@ifnotinfo
@code{defgroup}で定義される)
@end ifnotinfo
が含まれます。

@menu
* Common Keywords::          すべての種類のカスタマイズ宣言に共通なキーワード。
* Group Definitions::        カスタマイズグループ定義の記述。
* Variable Definitions::     ユーザーオプションの宣言。
* Customization Types::      ユーザーオプションの型指定。
* Applying Customizations::  カスタマイズセッティングを適用する関数。
* Custom Themes::            カスタムテーマの記述。
@end menu

@node Common Keywords
@section Common Item Keywords

@cindex customization keywords
   以降のセクションで説明するカスタマイズ宣言(customization declaration) ---
@code{defcustom}、@code{defgroup}などはすべて、さまざまな情報を指定するためのキーワード引数(@ref{Constant
Variables}を参照してください)を受け取ります。このセクションでは、カスタマイズ宣言のすべての種類に適用されるキーワードを説明します。

  @code{:tag}以外のすべてのキーワードは、与えられたアイテムにたいして複数回使用できます。キーワードの使用はそれぞれ独立した効果をもちます。@code{:tag}は例外で、これはすべての与えられたアイテムは1つの名前だけを表示できるからです。

@table @code
@item :tag @var{label}
@kindex tag@r{, customization keyword}
@var{label}を使用すると、カスタマイズメニュー(customization menu)およびカスタマイズバッファー(customization
buffer)のアイテムのラベルづけに、そのアイテムの名前のかわりに指定された文字列を使用します。@strong{混乱を招くので、そのアイテムの実際の名前と、大きく異なる名前は使用しないでください}。

@kindex group@r{, customization keyword}
@item :group @var{group}
このカスタマイズアイテムを、グループ@var{group}に配します。@code{defgroup}内で@code{:group}を使用した場合、そのアイテムは新しいグループ(@code{:group}のサブグループ)になります。

このキーワードを複数回使用した場合、1つのアイテムを複数のグループに配すことができます。これらのグループのどれかを表示すると、このアイテムが表示されます。煩わしくなるので、多用しないでください。

@item :link @var{link-data}
@kindex link@r{, customization keyword}
このアイテムのドキュメント文字列の後に外部リンクを含めます。これは他のドキュメントを参照する、センテンスを含むボタンです。

@var{link-data}に使用できる複数の候補があります:

@table @code
@item (custom-manual @var{info-node})
infoノードへのリンクです。@var{info-node}は、@code{"(emacs)Top"}のような、ノード名を示す文字列です。このリンクはカスタマイズバッファーの@samp{[Manual]}に表示され、@var{info-node}にたいしてビルトインのinfoリーダーを起動します。

@item (info-link @var{info-node})
@code{custom-manual}と同様ですが、カスタマイズバッファーには、そのinfoノード名が表示されます。

@item (url-link @var{url})
ウェブページヘのリンクです。@var{url}は@acronym{URL}を指定する文字列です。カスタマイズバッファーに表示されるリンクは、@code{browse-url-browser-function}で指定されたWWWブラウザーを呼び出します。

@item (emacs-commentary-link @var{library})
ライブラリーのコメントセクション(commentary
section)へのリンクです。@var{library}はライブラリー名を指定する文字列です。@ref{Library
Headers}を参照してください。

@item (emacs-library-link @var{library})
Emacs Lispライブラリーファイルへのリンクです。@var{library}はライブラリー名を指定する文字列です。

@item (file-link @var{file})
ファイルへのリンクです。@var{file}は、ユーザーがこのリンクを呼び出したときに@code{find-file}でvisitするファイルの名前を指定する文字列です。

@item (function-link @var{function})
関数のドキュメントへのリンクです。@var{function}は、ユーザーがこのリンクを呼び出したときに@code{describe-function}で説明を表示する関数の名前を指定する文字列です。

@item (variable-link @var{variable})
変数のドキュメントへのリンクです。@var{variable}は、ユーザーがこのリンクを呼び出したときに@code{describe-variable}で説明を表示する変数の名前を指定する文字列です。

@item (custom-group-link @var{group})
他のカスタマイズグループへのリンクです。このリンクを呼び出すことにより、@var{group}にたいする新たなカスタマイズバッファーが作成されます。
@end table

@var{link-data}の1つ目の要素の後に@code{:tag
@var{name}}を追加することにより、カスタマイズバッファーで使用するテキストを指定できます。たとえば@code{(info-link :tag
"foo" "(emacs)Top")}は、そのバッファーで@samp{foo}と表示されるEmacs manualへのリンクを作成します。

複数のリンクを追加するために、このキーワードを複数回使用することができます。

@item :load @var{file}
@kindex load@r{, customization keyword}
このカスタマイズアイテムを表示する前に、ファイル@var{file}をロードします(@ref{Loading}を参照してください)。ロードは@code{load}により行われ、そのファイルがまだロードされていないときだけロードします。

@item :require @var{feature}
@kindex require@r{, customization keyword}
保存したカスタマイズが、このアイテム値をセットするとき、@code{(require
'@var{feature})}が実行されます。@var{feature}はシンボルです。

@code{:require}を使用するもっとも一般的な理由は、ある変数がマイナーモードのような機能を有効にするとき、そのモードを実装するコードがロードされていない場合には、変数をセットするだけでは効果がないからです。

@item :version @var{version}
@kindex version@r{, customization keyword}
このキーワードは、そのアイテムが最初に導入されたEmacsバージョン@var{version}、またはそのアイテムのデフォルト値がそのバージョンで変更されたことを指定します。値@var{version}は文字列でなければなりません。

@item :package-version '(@var{package} . @var{version})
@kindex package-version@r{, customization keyword}
このキーワードは、そのアイテムが最初に導入された@var{package}のバージョン@var{version}またはアイテムの意味(またはデフォルト値)が変更されたバージョンを指定します。このキーワードは@code{:version}より優先されます。

@var{package}にはそのパッケージの公式名をシンボルとして指定します(たとえば@code{MH-E})。@var{version}には文字列を指定します。パッケージ@var{package}がEmacsの一部としてリリースされた場合、@var{package}と@var{version}の値は、@code{customize-package-emacs-version-alist}の値に表示されるべきです。
@end table

Emacsの一部として配布された@code{:package-version}キーワードを使用するパッケージは、@code{customize-package-emacs-version-alist}変数も更新しなければなりません。

@defvar customize-package-emacs-version-alist
このalistは、Emacsのバージョンにたいして、@code{:package-version}キーワード内でリストされたパッケージのバージョンへのマッピングを提供します:

@example
(@var{package} (@var{pversion} . @var{eversion})@dots{})
@end example

@var{package}(シンボル)それぞれにたいして、パッケージバージョン@var{pversion}を含む1つ以上の要素と、それに関連づけられるEmacsバージョン@var{eversion}が存在します。これらのバージョンは文字列です。たとえばMH-Eパッケージは、以下でalistを更新します:

@c Must be small else too wide.
@c FIXME obviously this is out of date (in the code).
@smallexample
(add-to-list 'customize-package-emacs-version-alist
             '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                    ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                    ("7.4" . "22.1") ("8.0" . "22.1")))
@end smallexample

@var{package}の値は一意である必要があり、また@code{:package-version}キーワード内に現れる@var{package}の値とマッチする必要があります。おそらくユーザーはエラーメッセージからこの値を見るので、MH-EやGnusのようなパッケージの公式名を選択するのがよいでしょう。
@end defvar

@node Group Definitions
@section Defining Customization Groups
@cindex define customization group
@cindex customization groups, defining

  Emacs Lispパッケージはそれぞれ、1つのメインカスタマイズグループ(main customization
group)をもち、それにはすべてのオプション、フェイス、そのパッケージ内の他のグルーﾌﾟが含まれるべきです。そのパッケージには少数のオプションとフェイスしかない場合は、1つのグループだけを使用して、その中にすべてを置きます。20以上のオプションやフェイスがある場合には、それらをサブグループ内に構造化して、そのサブグループをメインカスタマイズグループの下に配します。そのパッケージ内の任意のオプションまたはフェイスを、サブグループと並行してメイングループに配しても構いません。

  そのパッケージのメイングループ(または唯一のグループ)は、1つ以上の標準カスタムグループ(standard customization
group)のメンバーであるべきです(これらの完全なリストを表示するには、@kbd{M-x
customize}を使用します)。それらの内から1つ以上(多すぎないこと)を選択して、@code{:group}を使用してあなたのグループをそれらに追加します。

  新しいカスタマイズグループは、@code{defgroup}で宣言します。

@defmac defgroup group members doc [keyword value]@dots{}
@var{members}を含む、カスタマイズグループとして、@var{group}を宣言します。シンボル@var{group}はクォートしません。引数@var{doc}は、そのグループにたいするドキュメント文字列を指定します。

引数@var{members}は、そのグループのメンバーとなるカスタマイズアイテムの初期セットを指定するリストです。しかしほとんどの場合は@var{members}を@code{nil}にして、メンバーを定義するときに@code{:group}キーワードを使用することにより、そのグループのメンバーを指定します。

@var{members}を通じてグループのメンバーを指定したい場合、各要素は@code{(@var{name}
@var{widget})}という形式で指定するべきです。ここで@var{name}はシンボル、@var{widget}はそのシンボルを編集するウィジェット型(widget
type)です。有用なウィジェットには、変数にたいする@code{custom-variable}、フェイスにたいする@code{custom-face}、グループにたいする@code{custom-group}があります。

Emacsに新しいグループを導入するときは、@code{defgroup}内で@code{:version}キーワードを使用します。そうすればグループの個別のメンバーに対してそれを使用する必要がなくなります。

一般的なキーワード(@ref{Common
Keywords}を参照してください)に加えて、@code{defgroup}ないでは以下のキーワードも使用できます:

@table @code
@item :prefix @var{prefix}
@kindex prefix@r{, @code{defgroup} keyword}
グループ内のアイテムの名前が@var{prefix}で始まり、カスタマイズ変数@code{custom-unlispify-remove-prefixes}が非@code{nil}の場合、そのアイテムのタグから@var{prefix}が省略されます。グループは任意の数のプレフィクスをもつことができます。
@end table
@end defmac

@defopt custom-unlispify-remove-prefixes
この変数が非@code{nil}の場合、グループの@code{:prefix}キーワードで指定されたプレフィクスは、ユーザーがグループをカスタマイズするときは常に、タグ名から省略されます。

デフォルト値は@code{nil}、つまりプレフィクス省略(prefix-discarding)の機能は無効です。これは、オプションやフェイスの名前にたいしてプレフィクスを省略するのは、混乱を招くことがあるからです。
@end defopt

@node Variable Definitions
@section Defining Customization Variables
@cindex define customization options
@cindex customizable variables, how to define
@cindex user options, how to define

  @dfn{カスタマイズ可能変数(customizable variable)}は@dfn{ユーザーオプション(user
option)}とも呼ばれ、これはCustomizeインターフェースを通じてセットできるグローなるなLisp変数です。@code{defvar}(@ref{Defining
Variables}を参照してください)により定義される他のグローバル変数とは異なり、カスタマイズ可能変数は@code{defcustom}マクロを使用して定義されます。サブルーチンとして@code{defvar}を呼び出すことに加え、@code{defcustom}はCustomizeインターフェースでその変数が表示される方法や、その変数がとることができる値などを明示します。

@defmac defcustom option standard doc [keyword value]@dots{}
このマクロはユーザーオプション(またはカスタマイズ可能変数)として@var{option}を宣言します。@var{option}はクォートするべきではありません。

引数@var{standard}は、@var{option}の標準値を指定する式です。@code{defcustom}フォームの評価により、@var{standard}が評価されますが、その値にオプションをバインドする必要はありません。@var{option}がすでにデフォルト値をもつ場合、それは変更されずに残ります。ユーザーがすでに@var{option}にたいするカスタマイズを保存している場合、ユーザーによりカスタマイズされた値がデフォルト値としてインストールされます。それ以外は、@var{standard}を評価した結果がデフォルト値としてインストールされます。

@code{defvar}と同様、このマクロは@code{option}をスペシャル変数 --- 常にダイナミックにバインドされるべきことを意味する
---
としてマークします。@var{option}がすでにレキシカルバインドをもつ場合、そのレキシカルバインドはバインディング構造を抜けるまで効果をもちます。@ref{Variable
Scoping}を参照してください。

式@var{standard}は別の様々な機会にも --- カスタマイズ機能が@var{option}の標準値を知る必要があるときは常に ---
評価される可能性があります。そのため任意回数評価しても安全な式を使用するように気をつけてください。

引数@var{doc}は、その変数にたいするドキュメント文字列を指定します。

@code{defcustom}が何も@code{:group}を指定しない場合、同じファイル内で@code{defgroup}により最後に定義されたグループが使用されます。この方法では、ほとんどの@code{defcustom}は明示的な@code{:group}が必要なくなります。

Emacs
Lispモードで@kbd{C-M-x}(@code{eval-defun})により@code{defcustom}フォームを評価するとき、@code{eval-defun}の特別な機能は、変数の値がvoidかどうかテストせず、無条件に変数をセットする段取りをします(同じ機能は@code{defvar}にも適用されます。@ref{Defining
Variables}を参照してください)。すでに定義されたdefcustomで@code{eval-defun}を使用することにより、(もしあれば)@code{:set}関数が呼び出されます(以下参照)。

事前ロード( pre-loaded)されたEmacs Lispファイル(@ref{Building
Emacs}を参照してください)に@code{defcustom}を配した場合、ダンプ時にインストールされた標準値は正しくない ---
たとえば依存している他の変数は、まだ正しい値を割り当てられていない
---　かもしれません。この場合、Emacs起動後に標準値を再評価するために、以下で説明する@code{custom-reevaluate-setting}を使用します。
@end defmac

  @ref{Common Keywords}にリストされたキーワードに加え、このマクロには以下のキーワードを指定できます:

@table @code
@item :type @var{type}
このオプションのデータ型として、@var{type}を使用します。これはどんな値が適正なのか、その値をどのように表示するかを指定します(@ref{Customization
Types}を参照してください)。

@item :options @var{value-list}
@kindex options@r{, @code{defcustom} keyword}
このオプションに使用する適正な値のリストを指定します。ユーザーが使用できる値はこれらの値に限定されませんが、これらは便利な候補値を提示します。

これは特定の型にたいしてだけ意味をもち、現在のところ@code{hook}、@code{plist}、@code{alist}が含まれます。@code{:options}の使用法の説明は、個別の型の定義を参照してください。

@item :set @var{setfunction}
@kindex set@r{, @code{defcustom} keyword}
Customizeインターフェースを使用してこのオプションの値を変更する方法として、@var{setfunction}を指定します。関数@var{setfunction}は2つの引数
--- シンボル(オプション名)と新しい値 ---
をとり、このオプションにたいして正しく値を更新するために必要なことは何であれ行うべきです(これはおそらくLisp変数として単にオプションをセットすることを意味しないでしょう)。望ましくは、この関数は引数の値を破壊的に変更するべきではありません。@var{setfunction}のデフォルトは、@code{set-default}です。

このキーワードを指定した場合、その変数のドキュメント文字列には、手入力のLispコードで同じことを行う方法が記載されるべきです。

@item :get @var{getfunction}
@kindex get@r{, @code{defcustom} keyword}
このオプションの値を抽出する方法として、@var{getfunction}を指定します。関数@var{getfunction}は1つの引数(シンボル)をとり、カスタマイズがそのシンボル(シンボルのLisp値である必要はない)にたいする``カレント値''としてそれを使うべきかreturnするべきです。デフォルトは@code{default-value}です。

@code{:get}を正しく使用するためには、Customの機能を真に理解する必要があります。これは変数としてCustom内で扱われる値のためのものですが、実際にはLisp変数に格納されません。実際にLisp変数に格納されている値に@var{getfunction}を指定するのは、ほとんどは誤りです。

@item :initialize @var{function}
@kindex initialize@r{, @code{defcustom} keyword}
@var{function}は、@code{defcustom}が評価されるときに変数を初期化するために使用される関数であるべきです。これは2つの引数
--- オプション名(シンボル)と値をとります。この方法での使用のために事前定義された関数がいくつかあります:

@table @code
@item custom-initialize-set
変数の初期化に、その変数の@code{:set}関数を使用しますが、値がすでに非voidの場合、再処帰化を行いません。

@item custom-initialize-default
@code{custom-initialize-set}と同様ですが、その変数の@code{:set}のかわりに、関数@code{set-default}を使用して変数をセットします。これは変数の@code{:set}関数がマイナーモードを有効または無効にする場合の、通常の選択です。この選択により、変数の定義ではマイナーモード関数を呼び出しませんが、変数をカスタマイズしたときはマイナーモード関数を呼び出します。

@item custom-initialize-reset
変数の初期化に、常に@code{:set}関数を使用します。変数がすでに非voidの場合、(@code{:get}メソッドでreturnされる)カレント値を使用して@code{:set}関数を呼び出して変数をリセットします。これはデフォルトの@code{:initialize}関数です。

@item custom-initialize-changed
変数がすでにセットされている、またはカスタマイズされている場合は、変数の初期化のために@code{:set}関数を使用し、それ以外は単に@code{set-default}を使用します。

@item custom-initialize-safe-set
@itemx custom-initialize-safe-default
これらのn関数は@code{custom-initialize-set}、@code{custom-initialize-default}と同様に振る舞いますが、エラーをcatchします。初期化中にエラーが発生した場合は、@code{set-default}を使用して変数を@code{nil}にセットして、エラーをシグナルしません。

これらの関数は事前ロードされたファイルで定義されたオプションのためのものです(requireされた変数または関数がまだ定義されていないため、@var{standard}式はエラーをシグナルするかもしれない)。その値は通常、@file{startup.el}で更新され、@code{defcustom}により計算された値は無視されます。startup後に、その値をunsetして、@code{defcustom}を再評価すれば、エラーなしで@var{standard}は評価されます。
@end table

@item :risky @var{value}
@kindex risky@r{, @code{defcustom} keyword}
その変数の@code{risky-local-variable}プロパティーを@var{value}にセットします(@ref{File Local
Variables}を参照してください)。

@item :safe @var{function}
@kindex safe@r{, @code{defcustom} keyword}
その変数の@code{safe-local-variable}プロパティーを、@var{function}にセットします(@ref{File Local
Variables}を参照してください)。

@item :set-after @var{variables}
@kindex set-after@r{, @code{defcustom} keyword}
保存されたカスタマイズに合わせて変数をセッティングするときは、その前に変数@var{variables}確実にセット ---
つまり、これら他のものが処理される後までセッティングを遅延 ---
してください。これら他の変数が意図された値をもっていない場合に、この変数のセッティングが正しく機能しないときは、@code{:set-after}を使用してください。
@end table

  特定の機能を``オンに切り替える''オプションにたいしては、@code{:require}キーワードを指定すると便利です。これは、その機能がまだロードされていないときは、そのオプションがセットされるとEmacsがその機能をロードするようにします。@ref{Common
Keywords}を参照してください。以下はライブラリー@file{saveplace.el}の例です:

@example
(defcustom save-place nil
  "Non-nil means automatically save place in each file..."
  :type 'boolean
  :require 'saveplace
  :group 'save-place)
@end example

あるカスタマイズアイテムが、@code{:options}がサポートする@code{hook}や@code{alist}のような型をもつ場合は、@code{custom-add-frequent-value}を呼び出すことにより、@code{defcustom}宣言の外部から、別途値を追加できます。たとえば@code{emacs-lisp-mode-hook}から呼び出されることを意図した関数@code{my-lisp-mode-initialization}を定義する場合は、@code{emacs-lisp-mode-hook}にたいする正当な値として、その定義を編集することなく、その関数をリストに追加したいと思うかもしれません。これは以下のようにして行うことができます:

@example
(custom-add-frequent-value 'emacs-lisp-mode-hook
   'my-lisp-mode-initialization)
@end example

@defun custom-add-frequent-value symbol value
カスタマイズオプション@var{symbol}にたいして正当な値のリストに@var{value}を追加します。

追加による正確な効果は、@var{symbol}のカスタマイズ型に依存します。
@end defun

内部的には、@code{defcustom}は、標準値にたいする式を記録するためにシンボルプロパティー@code{standard-value}を、カスタマイズバッファーでユーザーによりセットされたが保存されていない値を記録するために@code{saved-value}を使用します。@ref{Symbol
Properties}を参照してください。これらのプロパティーは、carがその値を評価する式であるようなリストです。

@defun custom-reevaluate-setting symbol
この関数は、@code{defcustom}を通じて宣言されたユーザーオプション@var{symbol}の標準値を再評価します。変数がカスタマイズされた場合、この関数はかわりに保存された値を再評価します。それからこの関数はユーザーオプションをその値に(もし定義されていればそのオプションの@code{:set}プロパティーを使用して)セットします。

これは値が正しく計算される前に定義されたカスタマイズ可能オプションにたいして有用です。たとえばstartupの間、Emacsは事前ロードされたEmacs
Lispファイルで定義されたユーザーオプションにたいしてこの関数を呼び出しますが、これらの初期値は実行時だけ利用可能な情報に依存します。
@end defun

@defun custom-variable-p arg
この関数は、@var{arg}がカスタマイズ可能変数の場合は、非@code{nil}をreturnします。カスタマイズ可能変数とは、@code{standard-value}か@code{custom-autoload}プロパティーをもつ(通常は@code{defcustom}で宣言されたことを意味する)変数、または別のカスタマイズ可能変数にたいするエイリアスのことです。
@end defun

@node Customization Types
@section Customization Types

@cindex customization types
  @code{defcustom}でユーザーオプションを定義するときは、ユーザーオプションの@dfn{カスタマイズ型(customization
type)}を指定しなければなりません。これは、(1)値が適正か、(2)編集のためにカスタマイズバッファーで値を表示する方法、を記述するLispオブジェクトです。

@kindex type@r{, @code{defcustom} keyword}
  カスタマイズ型は、@code{defcustom}内の@code{:type}キーワードで指定します。@code{:type}の引数は評価されますが、@code{defcustom}が実行されるとき1回だけ評価されるので、さまざまな値をとる場合には有用でありません。通常はクォートされた定数を使用します。たとえば:

@example
(defcustom diff-command "diff"
  "The command to use to run diff."
  :type '(string)
  :group 'diff)
@end example

  一般的に、カスタマイズ型は、最初の要素が以降のセクションで定義されるカスタマイズ型の1つであるような、リストです。このシンボルの後にいくつかの引数があり、それはそのシンボルに依存します。型シンボルと引数の間には、オプションでkeyword-valueペアー(@ref{Type
Keywords}を参照してください)を記述できます。

  いくつかの型シンボルは引数を使用しません。これらは@dfn{シンプル型(simple
types)}と呼ばれます。シンプル型にたいしては、keyword-valueペアーを使用しない場合は、型シンボルの周囲のカッコ(parentheses)を省略できます。たとえばカスタマイズ型として単に@code{string}と記述すると、それは@code{(string)}と等価です。

  すべてのカスタマイズ型はウィジェットとして実装されます。詳細は、@ref{Top, , Introduction, widget, The Emacs
Widget Library}を参照してください。

@menu
* Simple Types::             シンプルなカスタマイズ型(sexp、integerなど)。
* Composite Types::          他の型やデータから新しい型を構築する。
* Splicing into Lists::      @code{:inline}で要素をリストに結合する。
* Type Keywords::            カスタマイズ型でのキーワード／引数ペアー
* Defining New Types::       型に名前をつける。
@end menu

@node Simple Types
@subsection Simple Types

  このセクションでは、すべてのシンプルデータ型を説明します。これらのカスタマイズ型のうちのいくつかにたいして、カスタマイズウィジェットは@kbd{C-M-i}または@kbd{M-@key{TAB}}による、インライン補完を提供します。

@table @code
@item sexp
値はプリントおよび読み込むことができる任意のLispオブジェクトです。より特化した型の使用するために時間をとりたくない場合は、任意のオプションへのフォールバックとして@code{sexp}を使用することができます。

@item integer
値は整数でなければなりません。

@item number
値は数(浮動小数点数または整数)でなければなりません。

@item float
値は浮動小数点数でなければなりません。

@item string
値は文字列でなければなりません。カスタマイズバッファーはその文字列を区切り文字@samp{"}文字および@samp{\}クォートなしで表示します。

@item regexp
@code{string}文字と同様ですが、その文字列は有効な正規表現でなければなりません。

@item character
値は文字コードでなければなりません。文字コードは実際には整数ですが、この型は数字を表示せずに、バッファー内にその文字を挿入することにより値を表示します。

@item file
値はファイル名でなければなりません。ウィジェットは補完を提供します。

@item (file :must-match t)
値は既存のファイル名でなければなりません。ウィジェットは補完を提供します。

@item directory
値はディレクトリー名でなければなりません。ウィジェットは補完を提供します。

@item hook
値は関数のリストでなければなりません。このカスタマイズ型はフック変数にたいして使用されます。フック内での使用を推奨される関数のリストを指定するために、フック変数の@code{defcustom}内で@code{:options}キーワードを使用できます。@ref{Variable
Definitions}を参照してください。

@item symbol
値はシンボルでなければなりません。これはカスタマイズバッファー内でシンボル名として表示されます。ウィジェットは補完を提供します。

@item function
値はラムダ式か関数名でなければなりません。ウィジェットは関数名にたいする補完を提供します。

@item variable
値は変数名でなければなりません。ウィジェットは補完を提供します。

@item face
値はフェイス名のシンボルでなければなりません。ウィジェットは補完を提供します。

@item boolean
値は真偽値 ---
@code{nil}か@code{t}です。@code{choice}と@code{const}を合わせて使用(次のセクションを参照)することにより、値が@code{nil}か@code{t}でなければならず、それぞれの値に固有の意味に適合する説明テキストを指定することもできます。

@item key-sequence
値はキーシーケンスです。カスタマイズバッファーは、@kbd{kbd}関数と同じ構文うぃ使用して、キーシーケンスを表示します。@ref{Key
Sequences}を参照してください。

@item coding-system
値はコーディングシステム名でなければならず、@kbd{M-@key{TAB}}で保管することができます。

@item color
値は有効なカラー名でなければなりません。ウィジェットはカラー名にたいする補完と、同様に@file{*Colors*}バッファーに表示されるカラーサンプルとカラー名のリストからカラー名を選択するボタンを提供します。
@end table

@node Composite Types
@subsection Composite Types
@cindex composite types (customization)

  適切なシンプル型がないときは、複合型(composite
types)を使うことができます。複合型は特定のデータによる他の型から、新しい型を構築します。指定された型またはデータは、その複合型の@dfn{引数(argument)}と呼ばれます。複合型は通常、以下のようなものです:

@example
(@var{constructor} @var{arguments}@dots{})
@end example

@noindent
しかし、以下のように引数の前にkeyword-valueペアーを追加することもできます。

@example
(@var{constructor} @r{@{}@var{keyword} @var{value}@r{@}}@dots{} @var{arguments}@dots{})
@end example

  以下のテーブルに、はコンストラクター(constructor)と、複合型を記述するためにそれらを使用する方法を示します:

@table @code
@item (cons @var{car-type} @var{cdr-type})
値はコンスセルでなければならず、@sc{car}は@var{car-type}、@sc{cdr}は@var{cdr-type}に適合していなければなりません。たとえば、@code{(cons
string symbol)}は、@code{("foo" . foo)}のような値にマッチするデータ型です。

カスタマイズバッファーでは、@sc{car}と@sc{cdr}は、それぞれ特定のデータ型に応じて、別々に表示・編集されます。

@item (list @var{element-types}@dots{})
値は、@var{element-types}で与えられる要素と数が正確に一致するリストでなければならず、リストの各要素はそれぞれ対応する@var{element-type}に適合しなければなりません。

たとえば、@code{(list integer string
function)}は、３つの要素のリストを示し、１つ目の要素は整数、２つ目の要素は文字列、３つ目の要素は関数です。

カスタマイズバッファーでは、各要素は、それぞれ特定のデータ型に応じて、別々に表示・編集されます。

@item (group @var{element-types}@dots{})
これは@code{list}と似ていますが、Customバッファー内でのテキストのフォーマットが異なります。@code{list}は各要素の値を、そのタグでラベルづけしますが、@code{group}はそれを行いません。

@item (vector @var{element-types}@dots{})
これは@code{list}と似ていますが、リストではなくベクターでなければなりません。各要素は@code{list}の場合と同様に機能します。

@item (alist :key-type @var{key-type} :value-type @var{value-type})
値はコンスセルのリストでなければならず、各セルの@sc{car}はカスタマイズ型@var{key-type}のキーを表し、同じセルの@sc{cdr}はカスタマイズ型@var{value-type}の値を表します。ユーザーはkey/valueペアーの追加や削除ができ、各ペアのキーと値の両方を編集することができます。

省略された場合、@var{key-type}と@var{value-type}のデフォルトは、@code{sexp}です。

ユーザーは指定されたkey-typeにマッチする任意のキーを追加できますが、@code{:options}(@ref{Variable
Definitions}を参照してください)で指定することにより、あるキーを優先的に扱うことができます。指定されたキーは、(適切な値とともに)常にカスタマイズバッファーに表示されます。また、alistにkey/valueを含める、除外する、または無効にするかを指定するチェックボックスも一緒に表示されます。ユーザーは@code{:options}キーワード引数により指定された値は、変更できません。

@code{:options}キーワードにたいする引数は、alist内の適切なキーにたいする仕様のリストであるべきです。これらは通常、単純なアトムであり、それらは自身をを意味します。たとえば:

@example
:options '("foo" "bar" "baz")
@end example

@noindent
これは、名前が@code{"foo"}、@code{"bar"}、@code{"baz"}の、３つの``既知''のキーがあることを指定し、それらは常に最初に表示されます。

たとえば@code{"bar"}キーに対応する値を整数だけにするというように、特定のキーに対して値の型を制限したいときがあるかもしれません。これはリスト内でアトムのかわりにリストを使用することにより、指定することができます。前述のように、１つ目の要素はそのキーを指定し、２つ目の要素は値の型を指定します。たとえば:

@example
:options '("foo" ("bar" integer) "baz")
@end example

最後に、キーが表示される方法を変更したいときもあるかもしれません。デフォルトでは、@code{:options}キーワードで指定された特別なキーはユーザーが変更できないので、キーは単に@code{const}として表示されます。しかし、たとえばそれが関数バインディングをもつシンボルだと知っている場合は@code{function-item}といったように、あるキーの表示のために、より特化した型を使用したいと思うかもしれません。これは、キーに対してシンボルを使うかわりに、カスタマイズ型指定を使用することにより、行うことができます。

@example
:options '("foo"
           ((function-item some-function) integer)
           "baz")
@end example

多くのalistは、コンスセルのかわりに２要素のリストを使用します。たとえば、

@example
(defcustom cons-alist
  '(("foo" . 1) ("bar" . 2) ("baz" . 3))
  "Each element is a cons-cell (KEY . VALUE).")
@end example

@noindent
のかわりに以下を使用します

@example
(defcustom list-alist
  '(("foo" 1) ("bar" 2) ("baz" 3))
  "Each element is a list of the form (KEY VALUE).")
@end example

リストはコンスセルの最上位に実装されているため、上記の@code{list-alist}を、コンスセルのalist(value-typeが実際の値を含む１要素のリストであるような)として扱うことができます。

@example
(defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
  "Each element is a list of the form (KEY VALUE)."
  :type '(alist :value-type (group integer)))
@end example

@code{list}のかわりに@code{group}を使用するのは、その目的に適したフォーマットのためだけです。

同様に、以下のようなトリックの類を用いることにより、より多くの値が各キー連づけられたalistを得ることができます:

@example
(defcustom person-data '(("brian"  50 t)
                         ("dorith" 55 nil)
                         ("ken"    52 t))
  "Alist of basic info about people.
Each element has the form (NAME AGE MALE-FLAG)."
  :type '(alist :value-type (group integer boolean)))
@end example

@item (plist :key-type @var{key-type} :value-type @var{value-type})
このカスタマイズ型は@code{alist}(上位参照)と似ていますが、(1)情報がプロパティーリスト(@ref{Property
Lists}を参照してください)に格納され、(2)@var{key-type}が省略された場合、デフォルトは@code{sexp}ではなく、@code{symbol}になります。

@item (choice @var{alternative-types}@dots{})
値は@var{alternative-types}のうちの1つに適合しなければなりません。たとえば、@code{(choice integer
string)}では整数か文字列が許されます。

カスタマイズバッファーでは、ユーザーはメニューを使用して候補を選択して、それらの候補にたいして通常の方法で値を編集できます。

Normally the strings in this menu are determined automatically from the
choices; however, you can specify different strings for the menu by
including the @code{:tag} keyword in the alternatives.  For example, if an
integer stands for a number of spaces, while a string is text to use
verbatim, you might write the customization type this way,

@example
(choice (integer :tag "Number of spaces")
        (string :tag "Literal text"))
@end example

@noindent
so that the menu offers @samp{Number of spaces} and @samp{Literal text}.

In any alternative for which @code{nil} is not a valid value, other than a
@code{const}, you should specify a valid default for that alternative using
the @code{:value} keyword.  @xref{Type Keywords}.

If some values are covered by more than one of the alternatives, customize
will choose the first alternative that the value fits.  This means you
should always list the most specific types first, and the most general
last.  Here's an example of proper usage:

@example
(choice (const :tag "Off" nil)
        symbol (sexp :tag "Other"))
@end example

@noindent
This way, the special value @code{nil} is not treated like other symbols,
and symbols are not treated like other Lisp expressions.

@item (radio @var{element-types}@dots{})
This is similar to @code{choice}, except that the choices are displayed
using `radio buttons' rather than a menu.  This has the advantage of
displaying documentation for the choices when applicable and so is often a
good choice for a choice between constant functions (@code{function-item}
customization types).

@item (const @var{value})
The value must be @var{value}---nothing else is allowed.

The main use of @code{const} is inside of @code{choice}.  For example,
@code{(choice integer (const nil))} allows either an integer or @code{nil}.

@code{:tag} is often used with @code{const}, inside of @code{choice}.  For
example,

@example
(choice (const :tag "Yes" t)
        (const :tag "No" nil)
        (const :tag "Ask" foo))
@end example

@noindent
describes a variable for which @code{t} means yes, @code{nil} means no, and
@code{foo} means ``ask''.

@item (other @var{value})
This alternative can match any Lisp value, but if the user chooses this
alternative, that selects the value @var{value}.

The main use of @code{other} is as the last element of @code{choice}.  For
example,

@example
(choice (const :tag "Yes" t)
        (const :tag "No" nil)
        (other :tag "Ask" foo))
@end example

@noindent
describes a variable for which @code{t} means yes, @code{nil} means no, and
anything else means ``ask''.  If the user chooses @samp{Ask} from the menu
of alternatives, that specifies the value @code{foo}; but any other value
(not @code{t}, @code{nil} or @code{foo}) displays as @samp{Ask}, just like
@code{foo}.

@item (function-item @var{function})
Like @code{const}, but used for values which are functions.  This displays
the documentation string as well as the function name.  The documentation
string is either the one you specify with @code{:doc}, or @var{function}'s
own documentation string.

@item (variable-item @var{variable})
Like @code{const}, but used for values which are variable names.  This
displays the documentation string as well as the variable name.  The
documentation string is either the one you specify with @code{:doc}, or
@var{variable}'s own documentation string.

@item (set @var{types}@dots{})
The value must be a list, and each element of the list must match one of the
@var{types} specified.

This appears in the customization buffer as a checklist, so that each of
@var{types} may have either one corresponding element or none.  It is not
possible to specify two different elements that match the same one of
@var{types}.  For example, @code{(set integer symbol)} allows one integer
and/or one symbol in the list; it does not allow multiple integers or
multiple symbols.  As a result, it is rare to use nonspecific types such as
@code{integer} in a @code{set}.

Most often, the @var{types} in a @code{set} are @code{const} types, as shown
here:

@example
(set (const :bold) (const :italic))
@end example

Sometimes they describe possible elements in an alist:

@example
(set (cons :tag "Height" (const height) integer)
     (cons :tag "Width" (const width) integer))
@end example

@noindent
That lets the user specify a height value optionally and a width value
optionally.

@item (repeat @var{element-type})
The value must be a list and each element of the list must fit the type
@var{element-type}.  This appears in the customization buffer as a list of
elements, with @samp{[INS]} and @samp{[DEL]} buttons for adding more
elements or removing elements.

@item (restricted-sexp :match-alternatives @var{criteria})
This is the most general composite type construct.  The value may be any
Lisp object that satisfies one of @var{criteria}.  @var{criteria} should be
a list, and each element should be one of these possibilities:

@itemize @bullet
@item
A predicate---that is, a function of one argument that has no side effects,
and returns either @code{nil} or non-@code{nil} according to the argument.
Using a predicate in the list says that objects for which the predicate
returns non-@code{nil} are acceptable.

@item
A quoted constant---that is, @code{'@var{object}}.  This sort of element in
the list says that @var{object} itself is an acceptable value.
@end itemize

For example,

@example
(restricted-sexp :match-alternatives
                 (integerp 't 'nil))
@end example

@noindent
allows integers, @code{t} and @code{nil} as legitimate values.

The customization buffer shows all legitimate values using their read
syntax, and the user edits them textually.
@end table

  Here is a table of the keywords you can use in keyword-value pairs in a
composite type:

@table @code
@item :tag @var{tag}
Use @var{tag} as the name of this alternative, for user communication
purposes.  This is useful for a type that appears inside of a @code{choice}.

@item :match-alternatives @var{criteria}
@kindex match-alternatives@r{, customization keyword}
Use @var{criteria} to match possible values.  This is used only in
@code{restricted-sexp}.

@item :args @var{argument-list}
@kindex args@r{, customization keyword}
Use the elements of @var{argument-list} as the arguments of the type
construct.  For instance, @code{(const :args (foo))} is equivalent to
@code{(const foo)}.  You rarely need to write @code{:args} explicitly,
because normally the arguments are recognized automatically as whatever
follows the last keyword-value pair.
@end table

@node Splicing into Lists
@subsection Splicing into Lists

  The @code{:inline} feature lets you splice a variable number of elements
into the middle of a @code{list} or @code{vector} customization type.  You
use it by adding @code{:inline t} to a type specification which is contained
in a @code{list} or @code{vector} specification.

  Normally, each entry in a @code{list} or @code{vector} type specification
describes a single element type.  But when an entry contains @code{:inline
t}, the value it matches is merged directly into the containing sequence.
For example, if the entry matches a list with three elements, those become
three elements of the overall sequence.  This is analogous to @samp{,@@} in
a backquote construct (@pxref{Backquote}).

  For example, to specify a list whose first element must be @code{baz} and
whose remaining arguments should be zero or more of @code{foo} and
@code{bar}, use this customization type:

@example
(list (const baz) (set :inline t (const foo) (const bar)))
@end example

@noindent
This matches values such as @code{(baz)}, @code{(baz foo)}, @code{(baz bar)}
and @code{(baz foo bar)}.

  When the element-type is a @code{choice}, you use @code{:inline} not in the
@code{choice} itself, but in (some of) the alternatives of the
@code{choice}.  For example, to match a list which must start with a file
name, followed either by the symbol @code{t} or two strings, use this
customization type:

@example
(list file
      (choice (const t)
              (list :inline t string string)))
@end example

@noindent
If the user chooses the first alternative in the choice, then the overall
list has two elements and the second element is @code{t}.  If the user
chooses the second alternative, then the overall list has three elements and
the second and third must be strings.

@node Type Keywords
@subsection Type Keywords

You can specify keyword-argument pairs in a customization type after the
type name symbol.  Here are the keywords you can use, and their meanings:

@table @code
@item :value @var{default}
Provide a default value.

If @code{nil} is not a valid value for the alternative, then it is essential
to specify a valid default with @code{:value}.

If you use this for a type that appears as an alternative inside of
@code{choice}; it specifies the default value to use, at first, if and when
the user selects this alternative with the menu in the customization buffer.

Of course, if the actual value of the option fits this alternative, it will
appear showing the actual value, not @var{default}.

@item :format @var{format-string}
@kindex format@r{, customization keyword}
This string will be inserted in the buffer to represent the value
corresponding to the type.  The following @samp{%} escapes are available for
use in @var{format-string}:

@table @samp
@item %[@var{button}%]
Display the text @var{button} marked as a button.  The @code{:action}
attribute specifies what the button will do if the user invokes it; its
value is a function which takes two arguments---the widget which the button
appears in, and the event.

There is no way to specify two different buttons with different actions.

@item %@{@var{sample}%@}
Show @var{sample} in a special face specified by @code{:sample-face}.

@item %v
Substitute the item's value.  How the value is represented depends on the
kind of item, and (for variables) on the customization type.

@item %d
Substitute the item's documentation string.

@item %h
Like @samp{%d}, but if the documentation string is more than one line, add a
button to control whether to show all of it or just the first line.

@item %t
Substitute the tag here.  You specify the tag with the @code{:tag} keyword.

@item %%
Display a literal @samp{%}.
@end table

@item :action @var{action}
@kindex action@r{, customization keyword}
Perform @var{action} if the user clicks on a button.

@item :button-face @var{face}
@kindex button-face@r{, customization keyword}
Use the face @var{face} (a face name or a list of face names) for button
text displayed with @samp{%[@dots{}%]}.

@item :button-prefix @var{prefix}
@itemx :button-suffix @var{suffix}
@kindex button-prefix@r{, customization keyword}
@kindex button-suffix@r{, customization keyword}
These specify the text to display before and after a button.  Each can be:

@table @asis
@item @code{nil}
No text is inserted.

@item a string
The string is inserted literally.

@item a symbol
The symbol's value is used.
@end table

@item :tag @var{tag}
Use @var{tag} (a string) as the tag for the value (or part of the value)
that corresponds to this type.

@item :doc @var{doc}
@kindex doc@r{, customization keyword}
Use @var{doc} as the documentation string for this value (or part of the
value) that corresponds to this type.  In order for this to work, you must
specify a value for @code{:format}, and use @samp{%d} or @samp{%h} in that
value.

The usual reason to specify a documentation string for a type is to provide
more information about the meanings of alternatives inside a @code{:choice}
type or the parts of some other composite type.

@item :help-echo @var{motion-doc}
@kindex help-echo@r{, customization keyword}
When you move to this item with @code{widget-forward} or
@code{widget-backward}, it will display the string @var{motion-doc} in the
echo area.  In addition, @var{motion-doc} is used as the mouse
@code{help-echo} string and may actually be a function or form evaluated to
yield a help string.  If it is a function, it is called with one argument,
the widget.

@item :match @var{function}
@kindex match@r{, customization keyword}
Specify how to decide whether a value matches the type.  The corresponding
value, @var{function}, should be a function that accepts two arguments, a
widget and a value; it should return non-@code{nil} if the value is
acceptable.

@item :validate @var{function}
Specify a validation function for input.  @var{function} takes a widget as
an argument, and should return @code{nil} if the widget's current value is
valid for the widget.  Otherwise, it should return the widget containing the
invalid data, and set that widget's @code{:error} property to a string
explaining the error.

@ignore
@item :indent @var{columns}
Indent this item by @var{columns} columns.  The indentation is used for
@samp{%n}, and automatically for group names, for checklists and radio
buttons, and for editable lists.  It affects the whole of the
item except for the first line.

@item :offset @var{extra}
Indent the subitems of this item @var{extra} columns more than this
item itself.  By default, subitems are indented the same as their
parent.

@item :extra-offset @var{n}
Add @var{n} extra spaces to this item's indentation, compared to its
parent's indentation.

@item :notify @var{function}
Call @var{function} each time the item or a subitem is changed.  The
function gets two or three arguments.  The first argument is the item
itself, the second argument is the item that was changed, and the
third argument is the event leading to the change, if any.

@item :menu-tag @var{tag-string}
Use @var{tag-string} in the menu when the widget is used as an option
in a @code{menu-choice} widget.

@item :menu-tag-get
A function used for finding the tag when the widget is used as an option
in a @code{menu-choice} widget.  By default, the tag used will be either the
@code{:menu-tag} or @code{:tag} property if present, or the @code{princ}
representation of the @code{:value} property if not.

@item :tab-order
Specify the order in which widgets are traversed with
@code{widget-forward} or @code{widget-backward}.  This is only partially
implemented.

@enumerate a
@item
Widgets with tabbing order @code{-1} are ignored.

@item
(Unimplemented) When on a widget with tabbing order @var{n}, go to the
next widget in the buffer with tabbing order @var{n+1} or @code{nil},
whichever comes first.

@item
When on a widget with no tabbing order specified, go to the next widget
in the buffer with a positive tabbing order, or @code{nil}
@end enumerate

@item :parent
The parent of a nested widget (e.g., a @code{menu-choice} item or an
element of a @code{editable-list} widget).

@item :sibling-args
This keyword is only used for members of a @code{radio-button-choice} or
@code{checklist}.  The value should be a list of extra keyword
arguments, which will be used when creating the @code{radio-button} or
@code{checkbox} associated with this item.
@end ignore
@end table

@node Defining New Types
@subsection Defining New Types
@cindex customization types, define new
@cindex define new customization types

In the previous sections we have described how to construct elaborate type
specifications for @code{defcustom}.  In some cases you may want to give
such a type specification a name.  The obvious case is when you are using
the same type for many user options: rather than repeat the specification
for each option, you can give the type specification a name, and use that
name each @code{defcustom}.  The other case is when a user option's value is
a recursive data structure.  To make it possible for a datatype to refer to
itself, it needs to have a name.

Since custom types are implemented as widgets, the way to define a new
customize type is to define a new widget.  We are not going to describe the
widget interface here in details, see @ref{Top, , Introduction, widget, The
Emacs Widget Library}, for that.  Instead we are going to demonstrate the
minimal functionality needed for defining new customize types by a simple
example.

@example
(define-widget 'binary-tree-of-string 'lazy
  "A binary tree made of cons-cells and strings."
  :offset 4
  :tag "Node"
  :type '(choice (string :tag "Leaf" :value "")
                 (cons :tag "Interior"
                       :value ("" . "")
                       binary-tree-of-string
                       binary-tree-of-string)))

(defcustom foo-bar ""
  "Sample variable holding a binary tree of strings."
  :type 'binary-tree-of-string)
@end example

The function to define a new widget is called @code{define-widget}.  The
first argument is the symbol we want to make a new widget type.  The second
argument is a symbol representing an existing widget, the new widget is
going to be defined in terms of difference from the existing widget.  For
the purpose of defining new customization types, the @code{lazy} widget is
perfect, because it accepts a @code{:type} keyword argument with the same
syntax as the keyword argument to @code{defcustom} with the same name.  The
third argument is a documentation string for the new widget.  You will be
able to see that string with the @kbd{M-x widget-browse @key{RET}
binary-tree-of-string @key{RET}} command.

After these mandatory arguments follow the keyword arguments.  The most
important is @code{:type}, which describes the data type we want to match
with this widget.  Here a @code{binary-tree-of-string} is described as being
either a string, or a cons-cell whose car and cdr are themselves both
@code{binary-tree-of-string}.  Note the reference to the widget type we are
currently in the process of defining.  The @code{:tag} attribute is a string
to name the widget in the user interface, and the @code{:offset} argument is
there to ensure that child nodes are indented four spaces relative to the
parent node, making the tree structure apparent in the customization buffer.

The @code{defcustom} shows how the new widget can be used as an ordinary
customization type.

The reason for the name @code{lazy} is that the other composite widgets
convert their inferior widgets to internal form when the widget is
instantiated in a buffer.  This conversion is recursive, so the inferior
widgets will convert @emph{their} inferior widgets.  If the data structure
is itself recursive, this conversion is an infinite recursion.  The
@code{lazy} widget prevents the recursion: it convert its @code{:type}
argument only when needed.

@node Applying Customizations
@section Applying Customizations
@cindex applying customizations

The following functions are responsible for installing the user's
customization settings for variables and faces, respectively.  When the user
invokes @samp{Save for future sessions} in the Customize interface, that
takes effect by writing a @code{custom-set-variables} and/or a
@code{custom-set-faces} form into the custom file, to be evaluated the next
time Emacs starts.

@defun custom-set-variables &rest args
This function installs the variable customizations specified by @var{args}.
Each argument in @var{args} should have the form

@example
(@var{var} @var{expression} [@var{now} [@var{request} [@var{comment}]]])
@end example

@noindent
@var{var} is a variable name (a symbol), and @var{expression} is an
expression which evaluates to the desired customized value.

If the @code{defcustom} form for @var{var} has been evaluated prior to this
@code{custom-set-variables} call, @var{expression} is immediately evaluated,
and the variable's value is set to the result.  Otherwise, @var{expression}
is stored into the variable's @code{saved-value} property, to be evaluated
when the relevant @code{defcustom} is called (usually when the library
defining that variable is loaded into Emacs).

The @var{now}, @var{request}, and @var{comment} entries are for internal use
only, and may be omitted.  @var{now}, if non-@code{nil}, means to set the
variable's value now, even if the variable's @code{defcustom} form has not
been evaluated.  @var{request} is a list of features to be loaded
immediately (@pxref{Named Features}).  @var{comment} is a string describing
the customization.
@end defun

@defun custom-set-faces &rest args
This function installs the face customizations specified by @var{args}.
Each argument in @var{args} should have the form

@example
(@var{face} @var{spec} [@var{now} [@var{comment}]])
@end example

@noindent
@var{face} is a face name (a symbol), and @var{spec} is the customized face
specification for that face (@pxref{Defining Faces}).

The @var{now} and @var{comment} entries are for internal use only, and may
be omitted.  @var{now}, if non-@code{nil}, means to install the face
specification now, even if the @code{defface} form has not been evaluated.
@var{comment} is a string describing the customization.
@end defun

@node Custom Themes
@section Custom Themes

@cindex custom themes
  @dfn{Custom themes} are collections of settings that can be enabled or
disabled as a unit.  @xref{Custom Themes,,, emacs, The GNU Emacs Manual}.
Each Custom theme is defined by an Emacs Lisp source file, which should
follow the conventions described in this section.  (Instead of writing a
Custom theme by hand, you can also create one using a Customize-like
interface; @pxref{Creating Custom Themes,,, emacs, The GNU Emacs Manual}.)

  A Custom theme file should be named @file{@var{foo}-theme.el}, where
@var{foo} is the theme name.  The first Lisp form in the file should be a
call to @code{deftheme}, and the last form should be a call to
@code{provide-theme}.

@defmac deftheme theme &optional doc
This macro declares @var{theme} (a symbol) as the name of a Custom theme.
The optional argument @var{doc} should be a string describing the theme;
this is the description shown when the user invokes the
@code{describe-theme} command or types @kbd{?} in the @samp{*Custom Themes*}
buffer.

Two special theme names are disallowed (using them causes an error):
@code{user} is a ``dummy'' theme that stores the user's direct customization
settings, and @code{changed} is a ``dummy'' theme that stores changes made
outside of the Customize system.
@end defmac

@defmac provide-theme theme
This macro declares that the theme named @var{theme} has been fully
specified.
@end defmac

  In between @code{deftheme} and @code{provide-theme} are Lisp forms
specifying the theme settings: usually a call to
@code{custom-theme-set-variables} and/or a call to
@code{custom-theme-set-faces}.

@defun custom-theme-set-variables theme &rest args
This function specifies the Custom theme @var{theme}'s variable settings.
@var{theme} should be a symbol.  Each argument in @var{args} should be a
list of the form

@example
(@var{var} @var{expression} [@var{now} [@var{request} [@var{comment}]]])
@end example

@noindent
where the list entries have the same meanings as in
@code{custom-set-variables}.  @xref{Applying Customizations}.
@end defun

@defun custom-theme-set-faces theme &rest args
This function specifies the Custom theme @var{theme}'s face settings.
@var{theme} should be a symbol.  Each argument in @var{args} should be a
list of the form

@example
(@var{face} @var{spec} [@var{now} [@var{comment}]])
@end example

@noindent
where the list entries have the same meanings as in
@code{custom-set-faces}.  @xref{Applying Customizations}.
@end defun

  In theory, a theme file can also contain other Lisp forms, which would be
evaluated when loading the theme, but that is ``bad form''.  To protect
against loading themes containing malicious code, Emacs displays the source
file and asks for confirmation from the user before loading any non-built-in
theme for the first time.

  The following functions are useful for programmatically enabling and
disabling themes:

@defun custom-theme-p theme
This function return a non-@code{nil} value if @var{theme} (a symbol)  is
the name of a Custom theme (i.e., a Custom theme which has been loaded into
Emacs, whether or not the theme is enabled).  Otherwise, it returns
@code{nil}.
@end defun

@defvar custom-known-themes
The value of this variable is a list of themes loaded into Emacs.  Each
theme is represented by a Lisp symbol (the theme name).  The default value
of this variable is a list containing two ``dummy'' themes: @code{(user
changed)}.  The @code{changed} theme stores settings made before any Custom
themes are applied (e.g., variables set outside of Customize).  The
@code{user} theme stores settings the user has customized and saved.  Any
additional themes declared with the @code{deftheme} macro are added to the
front of this list.
@end defvar

@deffn Command load-theme theme &optional no-confirm no-enable
This function loads the Custom theme named @var{theme} from its source file,
looking for the source file in the directories specified by the variable
@code{custom-theme-load-path}.  @xref{Custom Themes,,, emacs, The GNU Emacs
Manual}.  It also @dfn{enables} the theme (unless the optional argument
@var{no-enable} is non-@code{nil}), causing its variable and face settings
to take effect.  It prompts the user for confirmation before loading the
theme, unless the optional argument @var{no-confirm} is non-@code{nil}.
@end deffn

@deffn Command enable-theme theme
This function enables the Custom theme named @var{theme}.  It signals an
error if no such theme has been loaded.
@end deffn

@deffn Command disable-theme theme
This function disables the Custom theme named @var{theme}.  The theme
remains loaded, so that a subsequent call to @code{enable-theme} will
re-enable it.
@end deffn
