@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Debugging
@chapter Debugging Lisp Programs
@cindex debugging lisp programs

  Emacs Lispプログラム内の問題を見つけて詳細に調べる方法が、いくつかあります。

@itemize @bullet
@item
プログラム実行中に問題が発生した場合は、Lisp評価機能をサスペンドするためにビルトインのEmacs
Lispデバッガを使用して、評価機能の内部状態の調査および/または変更を行なうことができます。

@item
Emacs Lispにたいするソースレベルデバッガの、Edebugを使用できます。

@item
文法的な問題によりLispがプログラムを読むことさえできない場合は、Lisp編集コマンドを使用して該当箇所を見つけることができます。

@item
バイトコンパイラーがプログラムをコンパイルするとき、コンパイラーにより生成されるエラーメッセージと警告メッセージを調べることができます。@ref{Compiler
Errors}を参照してください。

@item
Testcoverパッケージを使用してプログラムのテストカバレッジを行なえます。

@item
ERTパッケージを使用して、プログラムにたいするリグレッションテストを記述できます。@ref{Top,the ERT manual,, ert,
ERT: Emacs Lisp Regression Testing}を参照してください。

@item
プログラムをプロファイルして、プログラムをより効果的にするためのヒントを取得できます。
@end itemize

  入出力の問題をデバックする便利なその他のツールに、ドリブルファイル(dribble file: @ref{Terminal
Input}を参照)と、@code{open-termscript}関数(@ref{Terminal Output})があります。

@menu
* Debugger::                 Emacs 
                               Lisp評価機能にたいするデバッガ。
* Edebug::                   Emacs Lispソースレベルデバッガ。
* Syntax Errors::            シンタックスエラーを見つける方法。
* Test Coverage::            プログラムのすべての分岐を確実にテストする。
* Profiling::                あなたのコードが使用するリソースの計測。
@end menu

@node Debugger
@section The Lisp Debugger
@cindex debugger for Emacs Lisp
@cindex Lisp debugger
@cindex break

  普通の@dfn{Lispデバッガ}は、フォーム評価のサスペンド機能を提供します。評価がサスペンド(一般的には@dfn{break}の状態として知られる)されている間、実行時スタックを調べたり、ローカル変数やグローバル変数の値を調べたり変更することができます。breakは再帰編集(recursive
edit)なので、Emacsの通常の編集機能が利用可能です。デバッガにエンターするようにプログラムを実行することさえ可能です。@ref{Recursive
Editing}を参照してください。

@menu
* Error Debugging::          エラー発生時にデバッガにエンターする。
* Infinite Loops::           exitしないプログラムの停止デバッグ。
* Function Debugging::       特定の関数が呼び出されたときにデバッガにエンターする。
* Explicit Debug::           プログラム内の特定箇所でデバッガにエンターする。
* Using Debugger::           デバッガが行なうこと: 
                               そこで何を目にするか。
* Debugger Commands::        デバッガで使用するコマンド。
* Invoking the Debugger::    関数@code{debug}の呼び出し方。
* Internals of Debugger::    デバッガのサブルーチン、およびグローバル変数。
@end menu

@node Error Debugging
@subsection Entering the Debugger on an Error
@cindex error debugging
@cindex debugging errors

  デバッガに入る一番重要なタイミングは、Lispエラーが発生したときです。デバッガでは、エラーの直接原因を調査できます。

  しかしデバッガへのエンターは、エラーによる通常の結末ではありません。多くのコマンドは不適切に呼び出されたときにLispエラーをシグナルするので、通常の編集の間にこれが発生するたびデバッガにエンターするのは、とても不便でしょう。したがって、エラーの際にデバッガにエンターしたい場合は、変数@code{debug-on-error}に非@code{nil}をセットします。(コマンド@code{toggle-debug-on-error}は、これを簡単に行う方法を提供します。)

@defopt debug-on-error
この変数はエラーがシグナルされ、それがハンドルされていないときに、デバッガが呼び出されるかどうかを決定します。@code{debug-on-error}が@code{t}の場合は、@code{debug-ignored-errors}(以下を参照)にリストされているエラーを除く、すべての種類のエラーがデバッガを呼び出します。@code{nil}の場合は、デバッガを呼び出しません。

値にはエラー条件(@ref{Signaling
Errors}を参照)のリストも指定できます。その場合、このリスト内のエラー条件だけにより、デバッガが呼び出されます(@code{debug-ignored-errors}にもリストされているエラー条件は除外されます)。たとえば、@code{debug-on-error}をリスト@code{(void-variable)}にセットした場合には、値をもたない変数に関するエラーにたいしてだけデバッガが呼び出されます。

@code{eval-expression-debug-on-error}がこの変数をオーバーライドする場合がいくつかあることに注意してください(以下を参照)。

この変数が非@code{nil}のとき、Emacsはプロセスフィルター関数と番兵(sentinel)の周囲にエラーハンドラーを作成しません。したがって、これらの関数内でのエラーは、デバッガを呼び出します。@ref{Processes}を参照してください。
@end defopt

@defopt debug-ignored-errors
この変数は、@code{debug-on-error}の値に関わらず、デバッガにエンターすべきでないエラーを指定します。変数の値はエラー条件のシンボル、および/または正規表現のリストです。エラーがこれら条件シンボルのいずれか、またはエラーメッセージが正規表現のいずれかにマッチする場合、そのエラーはデバッガにエンターしません。

この変数の通常の値には@code{user-error}と、同様に編集中にしばしば発生するがLispプログラムのバグによるものはほとんどない、いくつかのエラーが含まれます。しかし、``ほとんどない''は``絶対ない''ではありません。あなたのプログラムがこのリストにマッチするエラーにより機能しない場合は、そのエラーをデバッグするために、このリストの変更を試みるのもよいでしょう。通常は@code{debug-ignored-errors}を@code{nil}にセットしておくのが、もっとも簡単な方法です。
@end defopt

@defopt eval-expression-debug-on-error
この変数が非@code{nil}値(デフォルト)の場合は、コマンド@code{eval-expression}の実行により、一時的に@code{debug-on-error}が@code{t}がバインドされます。@ref{Lisp
Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs
Manual}を参照してください。

@code{eval-expression-debug-on-error}が@code{nil}の場合は、@code{eval-expression}の間も@code{debug-on-error}の値は変更されません。
@end defopt

@defvar debug-on-signal
@code{condition-case}によりキャッチされたエラーは通常、決してデバッガを呼び出しません。@code{condition-case}は、デバッガがそのエラーをハンドルする前に、エラーをハンドルする機会を得ます。

@code{debug-on-signal}を非@code{nil}値に変更した場合は、@code{condition-case}の存在如何に関わらず、すべてのエラーにおいてデバッガが最初に機会を得ます。(デバッガを呼び出すためには、依然としてそのエラーが@code{debug-on-error}と@code{debug-ignored-errors}で指定された条件を満たさなければなりません。)

@strong{警告:}
この変数を非@code{nil}にセットすると、芳しくない効果があるかもしれません。Emacsのさまざまな部分で処理の通常の過程としてエラーがキャッチされており、そのエラーが発生したことに気づかないことさえあるかもしれません。@code{condition-case}でラップされたコードをデバッグする必要がある場合は、@code{condition-case-unless-debug}(@pxref{Handling
Errors}を参照)の使用を考慮してください。
@end defvar

@defopt debug-on-event
@code{debug-on-event}をスペシャルイベント(@ref{Special
Events}を参照)にセットした場合は、Emacsは@code{special-event-map}をバイパスして、このイベントを受け取ると即座にデバッガへのエンターを試みます。現在のところサポートされる値は、シグナル@code{SIGUSR1}および@code{SIGUSR2}に対応する値だけです(これがデフォルトです)。これは@code{inhibit-quit}がセットされていて、それ以外はEmacsが応答しない場合に有用かもしれません。
@end defopt

@cindex message, finding what causes a particular message
@defvar debug-on-message
@code{debug-on-message}に正規表現をセットした場合には、それにマッチするメッセージがエコーエリアに表示されると、Emacsはデバッガにエンターします。たとえば、これは特定のメッセージの原因を探すのに有用かもしれません。
@end defvar

  initファイルロード中に発生したエラーをデバッグするには、オプション@samp{--debug-init}を使用します。これはinitファイルロードの間に@code{debug-on-error}を@code{t}にバインドして、通常はinitファイル内のエラーをキャッチする@code{condition-case}をバイパスします。

@node Infinite Loops
@subsection Debugging Infinite Loops
@cindex infinite loops
@cindex loops, infinite
@cindex quitting from infinite loop
@cindex stopping an infinite loop

  プログラムが無限にループしてリターンできないとき、最初の問題はそのループをいかに停止するかです。ほとんどのオペレーティングシステムでは、(@dfn{quit}させる)@kbd{C-g}でこれを行うことができます。@ref{Quitting}を参照してください。

  普通のquitでは、なぜそのプログラムがループしたかについての情報は与えられません。変数@code{debug-on-quit}に非@code{nil}をセットすることにより、より多くの情報を得ることができます。無限ループの途中でデバッガを実行すれば、デバッガからステップコマンドで先へ進むことができます。ループ全体をステップで追えば、問題を解決するために十分な情報が得られるでしょう。

  @kbd{C-g}によるquitはエラーとは判断されないので、@kbd{C-g}のハンドルに@code{debug-on-error}は効果がありません。同じように、@code{debug-on-quit}はエラーにたいして効果がありません。

@defopt debug-on-quit
この変数は、@code{quit}がシグナルされ、それがハンドルされていないときに、デバッガを呼び出すかどうかを決定します。@code{debug-on-quit}が非@code{nil}の場合は、quit(つまり@kbd{C-g}をタイプ)したときは常にデバッガが呼び出されます。@code{debug-on-quit}が@code{nil}(デフォルト)の場合は、quitしてもデバッガは呼び出されません。
@end defopt

@node Function Debugging
@subsection Entering the Debugger on a Function Call
@cindex function call debugging
@cindex debugging specific functions

  プログラムの途中で発生する問題を調べるための有用なテクニックの1つは、特定の関数が呼び出されたときデバッガにエンターする方法です。問題が発生した関数にこれを行い、その関数をステップで追ったり、問題箇所の少し手前の関数呼び出しでこれを行い、その関数をステップオーバーしてその後をステップで追うことができます。

@deffn Command debug-on-entry function-name
この関数は、@var{function-name}が呼び出されるたびにデバッガの呼び出しを要求します。

Lispコードで定義された任意の関数およびマクロは、インタープリターに解釈されたコードかコンパイル済みのコードかに関わらず、エントリーにbreakをセットできます。その関数がコマンドの場合は、Lispから呼び出されたときと、インタラクティブに呼び出されたとき、デバッガにエンターします。(たとえばCで記述された)プリミティブ関数にも、この方法で@code{debug-on-entry}をセットできますが、そのプリミティブがLispコードから呼び出されたときだけ効果があります。@code{debug-on-entry}はスペシャルフォームにはセットできません。

@code{debug-on-entry}がインタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求めます。その関数がすでにエントリーでデバッガを呼び出すようにセットアップされていた場合、@code{debug-on-entry}は何も行いません。@code{debug-on-entry}は常に@var{function-name}をリターンします。

以下は、この関数の使い方を説明するための例です:

@example
@group
(defun fact (n)
  (if (zerop n) 1
      (* n (fact (1- n)))))
     @result{} fact
@end group
@group
(debug-on-entry 'fact)
     @result{} fact
@end group
@group
(fact 3)
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--entering a function:
* fact(3)
  eval((fact 3))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
------ Buffer: *Backtrace* ------
@end group

@end example
@end deffn

@deffn Command cancel-debug-on-entry &optional function-name
この関数は@var{function-name}にたいする@code{debug-on-entry}の効果をアンドゥします。インタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求めます。@var{function-name}が省略された、あるいは@code{nil}の場合は、すべての関数にたいするエントリー時のbreakをキャンセルします。エントリー時にbreakするようセットアップされていない関数に@code{cancel-debug-on-entry}を呼び出したときは、何も行いません。
@end deffn

@node Explicit Debug
@subsection Explicit Entry to the Debugger
@cindex debugger, explicit entry
@cindex force entry to debugger

  You can cause the debugger to be called at a certain point in your program
by writing the expression @code{(debug)} at that point.  To do this, visit
the source file, insert the text @samp{(debug)} at the proper place, and
type @kbd{C-M-x} (@code{eval-defun}, a Lisp mode key binding).
@strong{Warning:} if you do this for temporary debugging purposes, be sure
to undo this insertion before you save the file!

  The place where you insert @samp{(debug)} must be a place where an
additional form can be evaluated and its value ignored.  (If the value of
@code{(debug)} isn't ignored, it will alter the execution of the program!)
The most common suitable places are inside a @code{progn} or an implicit
@code{progn} (@pxref{Sequencing}).

  If you don't know exactly where in the source code you want to put the debug
statement, but you want to display a backtrace when a certain message is
displayed, you can set @code{debug-on-message} to a regular expression
matching the desired message.

@node Using Debugger
@subsection Using the Debugger

  When the debugger is entered, it displays the previously selected buffer in
one window and a buffer named @file{*Backtrace*} in another window.  The
backtrace buffer contains one line for each level of Lisp function execution
currently going on.  At the beginning of this buffer is a message describing
the reason that the debugger was invoked (such as the error message and
associated data, if it was invoked due to an error).

@vindex debugger-bury-or-kill
  The backtrace buffer is read-only and uses a special major mode, Debugger
mode, in which letters are defined as debugger commands.  The usual Emacs
editing commands are available; thus, you can switch windows to examine the
buffer that was being edited at the time of the error, switch buffers, visit
files, or do any other sort of editing.  However, the debugger is a
recursive editing level (@pxref{Recursive Editing})  and it is wise to go
back to the backtrace buffer and exit the debugger (with the @kbd{q}
command) when you are finished with it.  Exiting the debugger gets out of
the recursive edit and buries the backtrace buffer.  (You can customize what
the @kbd{q} command does with the backtrace buffer by setting the variable
@code{debugger-bury-or-kill}.  For example, set it to @code{kill} if you
prefer to kill the buffer rather than bury it.  Consult the variable's
documentation for more possibilities.)

  When the debugger has been entered, the @code{debug-on-error} variable is
temporarily set according to @code{eval-expression-debug-on-error}.  If the
latter variable is non-@code{nil}, @code{debug-on-error} will temporarily be
set to @code{t}.  This means that any further errors that occur while doing
a debugging session will (by default) trigger another backtrace.  If this is
not what you want, you can either set @code{eval-expression-debug-on-error}
to @code{nil}, or set @code{debug-on-error} to @code{nil} in
@code{debugger-mode-hook}.

@cindex current stack frame
  The backtrace buffer shows you the functions that are executing and their
argument values.  It also allows you to specify a stack frame by moving
point to the line describing that frame.  (A stack frame is the place where
the Lisp interpreter records information about a particular invocation of a
function.)  The frame whose line point is on is considered the @dfn{current
frame}.  Some of the debugger commands operate on the current frame.  If a
line starts with a star, that means that exiting that frame will call the
debugger again.  This is useful for examining the return value of a
function.

  If a function name is underlined, that means the debugger knows where its
source code is located.  You can click with the mouse on that name, or move
to it and type @key{RET}, to visit the source code.

  The debugger itself must be run byte-compiled, since it makes assumptions
about how many stack frames are used for the debugger itself.  These
assumptions are false if the debugger is running interpreted.

@node Debugger Commands
@subsection Debugger Commands
@cindex debugger command list

  The debugger buffer (in Debugger mode) provides special commands in addition
to the usual Emacs commands.  The most important use of debugger commands is
for stepping through code, so that you can see how control flows.  The
debugger can step through the control structures of an interpreted function,
but cannot do so in a byte-compiled function.  If you would like to step
through a byte-compiled function, replace it with an interpreted definition
of the same function.  (To do this, visit the source for the function and
type @kbd{C-M-x} on its definition.)  You cannot use the Lisp debugger to
step through a primitive function.

@c FIXME: Add @findex for the following commands?  --xfq
  Here is a list of Debugger mode commands:

@table @kbd
@item c
Exit the debugger and continue execution.  This resumes execution of the
program as if the debugger had never been entered (aside from any
side-effects that you caused by changing variable values or data structures
while inside the debugger).

@item d
Continue execution, but enter the debugger the next time any Lisp function
is called.  This allows you to step through the subexpressions of an
expression, seeing what values the subexpressions compute, and what else
they do.

The stack frame made for the function call which enters the debugger in this
way will be flagged automatically so that the debugger will be called again
when the frame is exited.  You can use the @kbd{u} command to cancel this
flag.

@item b
Flag the current frame so that the debugger will be entered when the frame
is exited.  Frames flagged in this way are marked with stars in the
backtrace buffer.

@item u
Don't enter the debugger when the current frame is exited.  This cancels a
@kbd{b} command on that frame.  The visible effect is to remove the star
from the line in the backtrace buffer.

@item j
Flag the current frame like @kbd{b}.  Then continue execution like @kbd{c},
but temporarily disable break-on-entry for all functions that are set up to
do so by @code{debug-on-entry}.

@item e
Read a Lisp expression in the minibuffer, evaluate it (with the relevant
lexical environment, if applicable), and print the value in the echo area.
The debugger alters certain important variables, and the current buffer, as
part of its operation; @kbd{e} temporarily restores their values from
outside the debugger, so you can examine and change them.  This makes the
debugger more transparent.  By contrast, @kbd{M-:} does nothing special in
the debugger; it shows you the variable values within the debugger.

@item R
Like @kbd{e}, but also save the result of evaluation in the buffer
@file{*Debugger-record*}.

@item q
Terminate the program being debugged; return to top-level Emacs command
execution.

If the debugger was entered due to a @kbd{C-g} but you really want to quit,
and not debug, use the @kbd{q} command.

@item r
Return a value from the debugger.  The value is computed by reading an
expression with the minibuffer and evaluating it.

The @kbd{r} command is useful when the debugger was invoked due to exit from
a Lisp call frame (as requested with @kbd{b} or by entering the frame with
@kbd{d}); then the value specified in the @kbd{r} command is used as the
value of that frame.  It is also useful if you call @code{debug} and use its
return value.  Otherwise, @kbd{r} has the same effect as @kbd{c}, and the
specified return value does not matter.

You can't use @kbd{r} when the debugger was entered due to an error.

@item l
Display a list of functions that will invoke the debugger when called.  This
is a list of functions that are set to break on entry by means of
@code{debug-on-entry}.

@item v
Toggle the display of local variables of the current stack frame.
@end table

@node Invoking the Debugger
@subsection Invoking the Debugger
@cindex invoking lisp debugger

  Here we describe in full detail the function @code{debug} that is used to
invoke the debugger.

@deffn Command debug &rest debugger-args
This function enters the debugger.  It switches buffers to a buffer named
@file{*Backtrace*} (or @file{*Backtrace*<2>} if it is the second recursive
entry to the debugger, etc.), and fills it with information about the stack
of Lisp function calls.  It then enters a recursive edit, showing the
backtrace buffer in Debugger mode.

The Debugger mode @kbd{c}, @kbd{d}, @kbd{j}, and @kbd{r} commands exit the
recursive edit; then @code{debug} switches back to the previous buffer and
returns to whatever called @code{debug}.  This is the only way the function
@code{debug} can return to its caller.

The use of the @var{debugger-args} is that @code{debug} displays the rest of
its arguments at the top of the @file{*Backtrace*} buffer, so that the user
can see them.  Except as described below, this is the @emph{only} way these
arguments are used.

However, certain values for first argument to @code{debug} have a special
significance.  (Normally, these values are used only by the internals of
Emacs, and not by programmers calling @code{debug}.)  Here is a table of
these special values:

@table @code
@item lambda
@cindex @code{lambda} in debug
A first argument of @code{lambda} means @code{debug} was called because of
entry to a function when @code{debug-on-next-call} was non-@code{nil}.  The
debugger displays @samp{Debugger entered--entering a function:} as a line of
text at the top of the buffer.

@item debug
@code{debug} as first argument means @code{debug} was called because of
entry to a function that was set to debug on entry.  The debugger displays
the string @samp{Debugger entered--entering a function:}, just as in the
@code{lambda} case.  It also marks the stack frame for that function so that
it will invoke the debugger when exited.

@item t
When the first argument is @code{t}, this indicates a call to @code{debug}
due to evaluation of a function call form when @code{debug-on-next-call} is
non-@code{nil}.  The debugger displays @samp{Debugger entered--beginning
evaluation of function call form:} as the top line in the buffer.

@item exit
When the first argument is @code{exit}, it indicates the exit of a stack
frame previously marked to invoke the debugger on exit.  The second argument
given to @code{debug} in this case is the value being returned from the
frame.  The debugger displays @samp{Debugger entered--returning value:} in
the top line of the buffer, followed by the value being returned.

@item error
@cindex @code{error} in debug
When the first argument is @code{error}, the debugger indicates that it is
being entered because an error or @code{quit} was signaled and not handled,
by displaying @samp{Debugger entered--Lisp error:} followed by the error
signaled and any arguments to @code{signal}.  For example,

@example
@group
(let ((debug-on-error t))
  (/ 1 0))
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--Lisp error: (arith-error)
  /(1 0)
...
------ Buffer: *Backtrace* ------
@end group
@end example

If an error was signaled, presumably the variable @code{debug-on-error} is
non-@code{nil}.  If @code{quit} was signaled, then presumably the variable
@code{debug-on-quit} is non-@code{nil}.

@item nil
Use @code{nil} as the first of the @var{debugger-args} when you want to
enter the debugger explicitly.  The rest of the @var{debugger-args} are
printed on the top line of the buffer.  You can use this feature to display
messages---for example, to remind yourself of the conditions under which
@code{debug} is called.
@end table
@end deffn

@node Internals of Debugger
@subsection Internals of the Debugger

  This section describes functions and variables used internally by the
debugger.

@defvar debugger
The value of this variable is the function to call to invoke the debugger.
Its value must be a function of any number of arguments, or, more typically,
the name of a function.  This function should invoke some kind of debugger.
The default value of the variable is @code{debug}.

The first argument that Lisp hands to the function indicates why it was
called.  The convention for arguments is detailed in the description of
@code{debug} (@pxref{Invoking the Debugger}).
@end defvar

@deffn Command backtrace
@cindex run time stack
@cindex call stack
This function prints a trace of Lisp function calls currently active.  This
is the function used by @code{debug} to fill up the @file{*Backtrace*}
buffer.  It is written in C, since it must have access to the stack to
determine which function calls are active.  The return value is always
@code{nil}.

In the following example, a Lisp expression calls @code{backtrace}
explicitly.  This prints the backtrace to the stream @code{standard-output},
which, in this case, is the buffer @samp{backtrace-output}.

Each line of the backtrace represents one function call.  The line shows the
values of the function's arguments if they are all known; if they are still
being computed, the line says so.  The arguments of special forms are
elided.

@smallexample
@group
(with-output-to-temp-buffer "backtrace-output"
  (let ((var 1))
    (save-excursion
      (setq var (eval '(progn
                         (1+ var)
                         (list 'testing (backtrace))))))))

     @result{} (testing nil)
@end group

@group
----------- Buffer: backtrace-output ------------
  backtrace()
  (list ...computing arguments...)
@end group
  (progn ...)
  eval((progn (1+ var) (list (quote testing) (backtrace))))
  (setq ...)
  (save-excursion ...)
  (let ...)
  (with-output-to-temp-buffer ...)
  eval((with-output-to-temp-buffer ...))
  eval-last-sexp-1(nil)
@group
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
----------- Buffer: backtrace-output ------------
@end group
@end smallexample
@end deffn

@defvar debug-on-next-call
@cindex @code{eval}, and debugging
@cindex @code{apply}, and debugging
@cindex @code{funcall}, and debugging
If this variable is non-@code{nil}, it says to call the debugger before the
next @code{eval}, @code{apply} or @code{funcall}.  Entering the debugger
sets @code{debug-on-next-call} to @code{nil}.

The @kbd{d} command in the debugger works by setting this variable.
@end defvar

@defun backtrace-debug level flag
This function sets the debug-on-exit flag of the stack frame @var{level}
levels down the stack, giving it the value @var{flag}.  If @var{flag} is
non-@code{nil}, this will cause the debugger to be entered when that frame
later exits.  Even a nonlocal exit through that frame will enter the
debugger.

This function is used only by the debugger.
@end defun

@defvar command-debug-status
This variable records the debugging status of the current interactive
command.  Each time a command is called interactively, this variable is
bound to @code{nil}.  The debugger can set this variable to leave
information for future debugger invocations during the same command
invocation.

The advantage of using this variable rather than an ordinary global variable
is that the data will never carry over to a subsequent command invocation.
@end defvar

@defun backtrace-frame frame-number
The function @code{backtrace-frame} is intended for use in Lisp debuggers.
It returns information about what computation is happening in the stack
frame @var{frame-number} levels down.

If that frame has not evaluated the arguments yet, or is a special form, the
value is @code{(nil @var{function} @var{arg-forms}@dots{})}.

If that frame has evaluated its arguments and called its function already,
the return value is @code{(t @var{function} @var{arg-values}@dots{})}.

In the return value, @var{function} is whatever was supplied as the @sc{car}
of the evaluated list, or a @code{lambda} expression in the case of a macro
call.  If the function has a @code{&rest} argument, that is represented as
the tail of the list @var{arg-values}.

If @var{frame-number} is out of range, @code{backtrace-frame} returns
@code{nil}.
@end defun

@include edebug.texi

@node Syntax Errors
@section Debugging Invalid Lisp Syntax
@cindex debugging invalid Lisp syntax

  The Lisp reader reports invalid syntax, but cannot say where the real
problem is.  For example, the error ``End of file during parsing'' in
evaluating an expression indicates an excess of open parentheses (or square
brackets).  The reader detects this imbalance at the end of the file, but it
cannot figure out where the close parenthesis should have been.  Likewise,
``Invalid read syntax: ")"'' indicates an excess close parenthesis or
missing open parenthesis, but does not say where the missing parenthesis
belongs.  How, then, to find what to change?

  If the problem is not simply an imbalance of parentheses, a useful technique
is to try @kbd{C-M-e} at the beginning of each defun, and see if it goes to
the place where that defun appears to end.  If it does not, there is a
problem in that defun.

@cindex unbalanced parentheses
@cindex parenthesis mismatch, debugging
  However, unmatched parentheses are the most common syntax errors in Lisp,
and we can give further advice for those cases.  (In addition, just moving
point through the code with Show Paren mode enabled might find the
mismatch.)

@menu
* Excess Open::              How to find a spurious open paren or missing 
                               close.
* Excess Close::             How to find a spurious close paren or missing 
                               open.
@end menu

@node Excess Open
@subsection Excess Open Parentheses
@cindex excess open parentheses

  The first step is to find the defun that is unbalanced.  If there is an
excess open parenthesis, the way to do this is to go to the end of the file
and type @kbd{C-u C-M-u}.  This will move you to the beginning of the first
defun that is unbalanced.

  The next step is to determine precisely what is wrong.  There is no way to
be sure of this except by studying the program, but often the existing
indentation is a clue to where the parentheses should have been.  The
easiest way to use this clue is to reindent with @kbd{C-M-q} and see what
moves.  @strong{But don't do this yet!} Keep reading, first.

  Before you do this, make sure the defun has enough close parentheses.
Otherwise, @kbd{C-M-q} will get an error, or will reindent all the rest of
the file until the end.  So move to the end of the defun and insert a close
parenthesis there.  Don't use @kbd{C-M-e} to move there, since that too will
fail to work until the defun is balanced.

  Now you can go to the beginning of the defun and type @kbd{C-M-q}.  Usually
all the lines from a certain point to the end of the function will shift to
the right.  There is probably a missing close parenthesis, or a superfluous
open parenthesis, near that point.  (However, don't assume this is true;
study the code to make sure.)  Once you have found the discrepancy, undo the
@kbd{C-M-q} with @kbd{C-_}, since the old indentation is probably
appropriate to the intended parentheses.

  After you think you have fixed the problem, use @kbd{C-M-q} again.  If the
old indentation actually fit the intended nesting of parentheses, and you
have put back those parentheses, @kbd{C-M-q} should not change anything.

@node Excess Close
@subsection Excess Close Parentheses
@cindex excess close parentheses

  To deal with an excess close parenthesis, first go to the beginning of the
file, then type @kbd{C-u -1 C-M-u} to find the end of the first unbalanced
defun.

  Then find the actual matching close parenthesis by typing @kbd{C-M-f} at the
beginning of that defun.  This will leave you somewhere short of the place
where the defun ought to end.  It is possible that you will find a spurious
close parenthesis in that vicinity.

  If you don't see a problem at that point, the next thing to do is to type
@kbd{C-M-q} at the beginning of the defun.  A range of lines will probably
shift left; if so, the missing open parenthesis or spurious close
parenthesis is probably near the first of those lines.  (However, don't
assume this is true; study the code to make sure.)  Once you have found the
discrepancy, undo the @kbd{C-M-q} with @kbd{C-_}, since the old indentation
is probably appropriate to the intended parentheses.

  After you think you have fixed the problem, use @kbd{C-M-q} again.  If the
old indentation actually fits the intended nesting of parentheses, and you
have put back those parentheses, @kbd{C-M-q} should not change anything.

@node Test Coverage
@section Test Coverage
@cindex coverage testing

@findex testcover-start
@findex testcover-mark-all
@findex testcover-next-mark
  You can do coverage testing for a file of Lisp code by loading the
@code{testcover} library and using the command @kbd{M-x testcover-start
@key{RET} @var{file} @key{RET}} to instrument the code.  Then test your code
by calling it one or more times.  Then use the command @kbd{M-x
testcover-mark-all} to display colored highlights on the code to show where
coverage is insufficient.  The command @kbd{M-x testcover-next-mark} will
move point forward to the next highlighted spot.

  Normally, a red highlight indicates the form was never completely evaluated;
a brown highlight means it always evaluated to the same value (meaning there
has been little testing of what is done with the result).  However, the red
highlight is skipped for forms that can't possibly complete their
evaluation, such as @code{error}.  The brown highlight is skipped for forms
that are expected to always evaluate to the same value, such as @code{(setq
x 14)}.

  For difficult cases, you can add do-nothing macros to your code to give
advice to the test coverage tool.

@defmac 1value form
Evaluate @var{form} and return its value, but inform coverage testing that
@var{form}'s value should always be the same.
@end defmac

@defmac noreturn form
Evaluate @var{form}, informing coverage testing that @var{form} should never
return.  If it ever does return, you get a run-time error.
@end defmac

  Edebug also has a coverage testing feature (@pxref{Coverage Testing}).
These features partly duplicate each other, and it would be cleaner to
combine them.


@node Profiling
@section Profiling
@cindex profiling
@cindex measuring resource usage
@cindex memory usage

If your program is working correctly, but you want to make it run more
quickly or efficiently, the first thing to do is @dfn{profile} your code so
that you know how it is using resources.  If you find that one particular
function is responsible for a significant portion of the runtime, you can
start looking for ways to optimize that piece.

Emacs has built-in support for this.  To begin profiling, type @kbd{M-x
profiler-start}.  You can choose to profile by processor usage, memory
usage, or both.  After doing some work, type @kbd{M-x profiler-report} to
display a summary buffer for each resource that you chose to profile.  The
names of the report buffers include the times at which the reports were
generated, so you can generate another report later on without erasing
previous results.  When you have finished profiling, type @kbd{M-x
profiler-stop} (there is a small overhead associated with profiling).

The profiler report buffer shows, on each line, a function that was called,
followed by how much resource (processor or memory) it used in absolute and
percentage times since profiling started.  If a given line has a @samp{+}
symbol at the left-hand side, you can expand that line by typing @key{RET},
in order to see the function(s) called by the higher-level function.
Pressing @key{RET} again will collapse back to the original state.

Press @kbd{j} or @kbd{mouse-2} to jump to the definition of a function.
Press @kbd{d} to view a function's documentation.  You can save a profile to
a file using @kbd{C-x C-w}.  You can compare two profiles using @kbd{=}.

@c FIXME reversed calltree?

@cindex @file{elp.el}
@cindex timing programs
The @file{elp} library offers an alternative approach.  See the file
@file{elp.el} for instructions.

@cindex @file{benchmark.el}
@cindex benchmarking
You can check the speed of individual Emacs Lisp forms using the
@file{benchmark} library.  See the functions @code{benchmark-run} and
@code{benchmark-run-compiled} in @file{benchmark.el}.

@c Not worth putting in the printed manual.
@ifnottex
@cindex --enable-profiling option of configure
To profile Emacs at the level of its C code, you can build it using the
@option{--enable-profiling} option of @command{configure}.  When Emacs
exits, it generates a file @file{gmon.out} that you can examine using the
@command{gprof} utility.  This feature is mainly useful for debugging
Emacs.  It actually stops the Lisp-level @kbd{M-x profiler-@dots{}} commands
described above from working.
@end ifnottex
