# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Emacs-24.5\n"
"POT-Creation-Date: 2018-01-09 14:40+0900\n"
"PO-Revision-Date: 2018-01-29 07:08+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: debugging.texi.orig:6
#, no-wrap
msgid "Debugging"
msgstr "Debugging"

#. type: chapter
#: debugging.texi.orig:7
#, no-wrap
msgid "Debugging Lisp Programs"
msgstr "Debugging Lisp Programs"

#. type: cindex
#: debugging.texi.orig:8
#, no-wrap
msgid "debugging lisp programs"
msgstr "debugging lisp programs"

#. type: Plain text
#: debugging.texi.orig:12
msgid ""
"There are several ways to find and investigate problems in an Emacs Lisp "
"program."
msgstr "Emacs Lispプログラム内の問題を見つけて詳細に調べる方法が、いくつかあります。"

#. type: itemize
#: debugging.texi.orig:18
msgid ""
"If a problem occurs when you run the program, you can use the built-in Emacs "
"Lisp debugger to suspend the Lisp evaluator, and examine and/or alter its "
"internal state."
msgstr "プログラム実行中に問題が発生した場合は、Lisp評価機能をサスペンドするためにビルトインのEmacs Lispデバッガを使用して、評価機能の内部状態の調査および/または変更を行なうことができます。"

#. type: itemize
#: debugging.texi.orig:21
msgid "You can use Edebug, a source-level debugger for Emacs Lisp."
msgstr "Emacs Lispにたいするソースレベルデバッガの、Edebugを使用できます。"

#. type: itemize
#: debugging.texi.orig:25
msgid ""
"If a syntactic problem is preventing Lisp from even reading the program, you "
"can locate it using Lisp editing commands."
msgstr "文法的な問題によりLispがプログラムを読むことさえできない場合は、Lisp編集コマンドを使用して該当箇所を見つけることができます。"

#. type: itemize
#: debugging.texi.orig:29
msgid ""
"You can look at the error and warning messages produced by the byte compiler "
"when it compiles the program.  @xref{Compiler Errors}."
msgstr "バイトコンパイラーがプログラムをコンパイルするとき、コンパイラーにより生成されるエラーメッセージと警告メッセージを調べることができます。@ref{Compiler Errors}を参照してください。"

#. type: itemize
#: debugging.texi.orig:33
msgid ""
"You can use the Testcover package to perform coverage testing on the "
"program."
msgstr "Testcoverパッケージを使用してプログラムのテストカバレッジを行なえます。"

#. type: itemize
#: debugging.texi.orig:37
msgid ""
"You can use the ERT package to write regression tests for the program.  "
"@xref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}."
msgstr "ERTパッケージを使用して、プログラムにたいするリグレッションテストを記述できます。@ref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}を参照してください。"

#. type: itemize
#: debugging.texi.orig:40
msgid ""
"You can profile the program to get hints about how to make it more "
"efficient."
msgstr "プログラムをプロファイルして、プログラムをより効果的にするためのヒントを取得できます。"

#. type: Plain text
#: debugging.texi.orig:45
msgid ""
"Other useful tools for debugging input and output problems are the dribble "
"file (@pxref{Terminal Input}) and the @code{open-termscript} function "
"(@pxref{Terminal Output})."
msgstr "入出力の問題をデバックする便利なその他のツールに、ドリブルファイル(dribble file: @ref{Terminal Input}を参照)と、@code{open-termscript}関数(@ref{Terminal Output})があります。"

#. type: node
#: debugging.texi.orig:52 debugging.texi.orig:54
#, no-wrap
msgid "Debugger"
msgstr "Debugger"

#. type: menuentry
#: debugging.texi.orig:52
msgid "A debugger for the Emacs Lisp evaluator."
msgstr "Emacs Lisp評価機能にたいするデバッガ。"

#. type: menuentry
#: debugging.texi.orig:52
msgid "Edebug"
msgstr "Edebug"

#. type: menuentry
#: debugging.texi.orig:52
msgid "A source-level Emacs Lisp debugger."
msgstr "Emacs Lispソースレベルデバッガ。"

#. type: node
#: debugging.texi.orig:52 debugging.texi.orig:682
#, no-wrap
msgid "Syntax Errors"
msgstr "Syntax Errors"

#. type: menuentry
#: debugging.texi.orig:52
msgid "How to find syntax errors."
msgstr "シンタックスエラーを見つける方法。"

#. type: section
#: debugging.texi.orig:52 debugging.texi.orig:773 debugging.texi.orig:774
#, no-wrap
msgid "Test Coverage"
msgstr "Test Coverage"

#. type: menuentry
#: debugging.texi.orig:52
msgid "Ensuring you have tested all branches in your code."
msgstr "プログラムのすべての分岐を確実にテストする。"

#. type: section
#: debugging.texi.orig:52 debugging.texi.orig:815 debugging.texi.orig:816
#, no-wrap
msgid "Profiling"
msgstr "Profiling"

#. type: menuentry
#: debugging.texi.orig:52
msgid "Measuring the resources that your code uses."
msgstr "あなたのコードが使用するリソースの計測。"

#. type: section
#: debugging.texi.orig:55
#, no-wrap
msgid "The Lisp Debugger"
msgstr "The Lisp Debugger"

#. type: cindex
#: debugging.texi.orig:56
#, no-wrap
msgid "debugger for Emacs Lisp"
msgstr "debugger for Emacs Lisp"

#. type: cindex
#: debugging.texi.orig:57
#, no-wrap
msgid "Lisp debugger"
msgstr "Lisp debugger"

#. type: cindex
#: debugging.texi.orig:58
#, no-wrap
msgid "break"
msgstr "break"

#. type: Plain text
#: debugging.texi.orig:67
msgid ""
"The ordinary @dfn{Lisp debugger} provides the ability to suspend evaluation "
"of a form.  While evaluation is suspended (a state that is commonly known as "
"a @dfn{break}), you may examine the run time stack, examine the values of "
"local or global variables, or change those values.  Since a break is a "
"recursive edit, all the usual editing facilities of Emacs are available; you "
"can even run programs that will enter the debugger recursively.  "
"@xref{Recursive Editing}."
msgstr "普通の@dfn{Lispデバッガ}は、フォーム評価のサスペンド機能を提供します。評価がサスペンド(一般的には@dfn{break}の状態として知られる)されている間、実行時スタックを調べたり、ローカル変数やグローバル変数の値を調べたり変更することができます。breakは再帰編集(recursive edit)なので、Emacsの通常の編集機能が利用可能です。デバッガにエンターするようにプログラムを実行することさえ可能です。@ref{Recursive Editing}を参照してください。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:79
#, no-wrap
msgid "Error Debugging"
msgstr "Error Debugging"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Entering the debugger when an error happens."
msgstr "エラー発生時にデバッガにエンターする。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:186
#, no-wrap
msgid "Infinite Loops"
msgstr "Infinite Loops"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Stopping and debugging a program that doesn't exit."
msgstr "exitしないプログラムの停止デバッグ。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:216
#, no-wrap
msgid "Function Debugging"
msgstr "Function Debugging"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Entering it when a certain function is called."
msgstr "特定の関数が呼び出されたときにデバッガにエンターする。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:286
#, no-wrap
msgid "Explicit Debug"
msgstr "Explicit Debug"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Entering it at a certain point in the program."
msgstr "プログラム内の特定箇所でデバッガにエンターする。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:309
#, no-wrap
msgid "Using Debugger"
msgstr "Using Debugger"

#. type: menuentry
#: debugging.texi.orig:77
msgid "What the debugger does; what you see while in it."
msgstr "デバッガが行なうこと: そこで何を目にするか。"

#. type: subsection
#: debugging.texi.orig:77 debugging.texi.orig:366 debugging.texi.orig:367
#, no-wrap
msgid "Debugger Commands"
msgstr "Debugger Commands"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Commands used while in the debugger."
msgstr "デバッガで使用するコマンド。"

#. type: subsection
#: debugging.texi.orig:77 debugging.texi.orig:460 debugging.texi.orig:461
#, no-wrap
msgid "Invoking the Debugger"
msgstr "Invoking the Debugger"

#. type: menuentry
#: debugging.texi.orig:77
msgid "How to call the function @code{debug}."
msgstr "関数@code{debug}の呼び出し方。"

#. type: node
#: debugging.texi.orig:77 debugging.texi.orig:556
#, no-wrap
msgid "Internals of Debugger"
msgstr "Internals of Debugger"

#. type: menuentry
#: debugging.texi.orig:77
msgid "Subroutines of the debugger, and global variables."
msgstr "デバッガのサブルーチン、およびグローバル変数。"

#. type: subsection
#: debugging.texi.orig:80
#, no-wrap
msgid "Entering the Debugger on an Error"
msgstr "Entering the Debugger on an Error"

#. type: cindex
#: debugging.texi.orig:81
#, no-wrap
msgid "error debugging"
msgstr "error debugging"

#. type: cindex
#: debugging.texi.orig:82
#, no-wrap
msgid "debugging errors"
msgstr "debugging errors"

#. type: Plain text
#: debugging.texi.orig:87
msgid ""
"The most important time to enter the debugger is when a Lisp error happens.  "
"This allows you to investigate the immediate causes of the error."
msgstr "デバッガに入る一番重要なタイミングは、Lispエラーが発生したときです。デバッガでは、エラーの直接原因を調査できます。"

#. type: Plain text
#: debugging.texi.orig:95
msgid ""
"However, entry to the debugger is not a normal consequence of an error.  "
"Many commands signal Lisp errors when invoked inappropriately, and during "
"ordinary editing it would be very inconvenient to enter the debugger each "
"time this happens.  So if you want errors to enter the debugger, set the "
"variable @code{debug-on-error} to non-@code{nil}.  (The command "
"@code{toggle-debug-on-error} provides an easy way to do this.)"
msgstr "しかしデバッガへのエンターは、エラーによる通常の結末ではありません。多くのコマンドは不適切に呼び出されたときにLispエラーをシグナルするので、通常の編集の間にこれが発生するたびデバッガにエンターするのは、とても不便でしょう。したがって、エラーの際にデバッガにエンターしたい場合は、変数@code{debug-on-error}に非@code{nil}をセットします。(コマンド@code{toggle-debug-on-error}は、これを簡単に行う方法を提供します。)"

#. type: defopt
#: debugging.texi.orig:96
#, no-wrap
msgid "debug-on-error"
msgstr "debug-on-error"

#. type: defopt
#: debugging.texi.orig:102
msgid ""
"This variable determines whether the debugger is called when an error is "
"signaled and not handled.  If @code{debug-on-error} is @code{t}, all kinds "
"of errors call the debugger, except those listed in "
"@code{debug-ignored-errors} (see below).  If it is @code{nil}, none call the "
"debugger."
msgstr "この変数はエラーがシグナルされ、それがハンドルされていないときに、デバッガが呼び出されるかどうかを決定します。@code{debug-on-error}が@code{t}の場合は、@code{debug-ignored-errors}(以下を参照)にリストされているエラーを除く、すべての種類のエラーがデバッガを呼び出します。@code{nil}の場合は、デバッガを呼び出しません。"

#. type: defopt
#: debugging.texi.orig:109
msgid ""
"The value can also be a list of error conditions (@pxref{Signaling "
"Errors}).  Then the debugger is called only for error conditions in this "
"list (except those also listed in @code{debug-ignored-errors}).  For "
"example, if you set @code{debug-on-error} to the list "
"@code{(void-variable)}, the debugger is only called for errors about a "
"variable that has no value."
msgstr "値にはエラー条件(@ref{Signaling Errors}を参照)のリストも指定できます。その場合、このリスト内のエラー条件だけにより、デバッガが呼び出されます(@code{debug-ignored-errors}にもリストされているエラー条件は除外されます)。たとえば、@code{debug-on-error}をリスト@code{(void-variable)}にセットした場合には、値をもたない変数に関するエラーにたいしてだけデバッガが呼び出されます。"

#. type: defopt
#: debugging.texi.orig:112
msgid ""
"Note that @code{eval-expression-debug-on-error} overrides this variable in "
"some cases; see below."
msgstr "@code{eval-expression-debug-on-error}がこの変数をオーバーライドする場合がいくつかあることに注意してください(以下を参照)。"

#. type: defopt
#: debugging.texi.orig:116
msgid ""
"When this variable is non-@code{nil}, Emacs does not create an error handler "
"around process filter functions and sentinels.  Therefore, errors in these "
"functions also invoke the debugger.  @xref{Processes}."
msgstr "この変数が非@code{nil}のとき、Emacsはプロセスフィルター関数と番兵(sentinel)の周囲にエラーハンドラーを作成しません。したがって、これらの関数内でのエラーは、デバッガを呼び出します。@ref{Processes}を参照してください。"

#. type: defopt
#: debugging.texi.orig:118
#, no-wrap
msgid "debug-ignored-errors"
msgstr "debug-ignored-errors"

#. type: defopt
#: debugging.texi.orig:125
msgid ""
"This variable specifies errors which should not enter the debugger, "
"regardless of the value of @code{debug-on-error}.  Its value is a list of "
"error condition symbols and/or regular expressions.  If the error has any of "
"those condition symbols, or if the error message matches any of the regular "
"expressions, then that error does not enter the debugger."
msgstr "この変数は、@code{debug-on-error}の値に関わらず、デバッガにエンターすべきでないエラーを指定します。変数の値はエラー条件のシンボル、および/または正規表現のリストです。エラーがこれら条件シンボルのいずれか、またはエラーメッセージが正規表現のいずれかにマッチする場合、そのエラーはデバッガにエンターしません。"

#. type: defopt
#: debugging.texi.orig:132
msgid ""
"The normal value of this variable includes @code{user-error}, as well as "
"several errors that happen often during editing but rarely result from bugs "
"in Lisp programs.  However, ``rarely'' is not ``never''; if your program "
"fails with an error that matches this list, you may try changing this list "
"to debug the error.  The easiest way is usually to set "
"@code{debug-ignored-errors} to @code{nil}."
msgstr "この変数の通常の値には@code{user-error}と、同様に編集中にしばしば発生するがLispプログラムのバグによるものはほとんどない、いくつかのエラーが含まれます。しかし、``ほとんどない''は``絶対ない''ではありません。あなたのプログラムがこのリストにマッチするエラーにより機能しない場合は、そのエラーをデバッグするために、このリストの変更を試みるのもよいでしょう。通常は@code{debug-ignored-errors}を@code{nil}にセットしておくのが、もっとも簡単な方法です。"

#. type: defopt
#: debugging.texi.orig:134
#, no-wrap
msgid "eval-expression-debug-on-error"
msgstr "eval-expression-debug-on-error"

#. type: defopt
#: debugging.texi.orig:139
msgid ""
"If this variable has a non-@code{nil} value (the default), running the "
"command @code{eval-expression} causes @code{debug-on-error} to be "
"temporarily bound to to @code{t}.  @xref{Lisp Eval,, Evaluating Emacs-Lisp "
"Expressions, emacs, The GNU Emacs Manual}."
msgstr "この変数が非@code{nil}値(デフォルト)の場合は、コマンド@code{eval-expression}の実行により、一時的に@code{debug-on-error}が@code{t}がバインドされます。@ref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defopt
#: debugging.texi.orig:142
msgid ""
"If @code{eval-expression-debug-on-error} is @code{nil}, then the value of "
"@code{debug-on-error} is not changed during @code{eval-expression}."
msgstr "@code{eval-expression-debug-on-error}が@code{nil}の場合は、@code{eval-expression}の間も@code{debug-on-error}の値は変更されません。"

#. type: defvar
#: debugging.texi.orig:144
#, no-wrap
msgid "debug-on-signal"
msgstr "debug-on-signal"

#. type: defvar
#: debugging.texi.orig:148
msgid ""
"Normally, errors caught by @code{condition-case} never invoke the debugger.  "
"The @code{condition-case} gets a chance to handle the error before the "
"debugger gets a chance."
msgstr "@code{condition-case}によりキャッチされたエラーは通常、決してデバッガを呼び出しません。@code{condition-case}は、デバッガがそのエラーをハンドルする前に、エラーをハンドルする機会を得ます。"

#. type: defvar
#: debugging.texi.orig:154
msgid ""
"If you change @code{debug-on-signal} to a non-@code{nil} value, the debugger "
"gets the first chance at every error, regardless of the presence of "
"@code{condition-case}.  (To invoke the debugger, the error must still "
"fulfill the criteria specified by @code{debug-on-error} and "
"@code{debug-ignored-errors}.)"
msgstr "@code{debug-on-signal}を非@code{nil}値に変更した場合は、@code{condition-case}の存在如何に関わらず、すべてのエラーにおいてデバッガが最初に機会を得ます。(デバッガを呼び出すためには、依然としてそのエラーが@code{debug-on-error}と@code{debug-ignored-errors}で指定された条件を満たさなければなりません。)"

#. type: defvar
#: debugging.texi.orig:161
msgid ""
"@strong{Warning:} Setting this variable to non-@code{nil} may have annoying "
"effects.  Various parts of Emacs catch errors in the normal course of "
"affairs, and you may not even realize that errors happen there.  If you need "
"to debug code wrapped in @code{condition-case}, consider using "
"@code{condition-case-unless-debug} (@pxref{Handling Errors})."
msgstr "@strong{警告:} この変数を非@code{nil}にセットすると、芳しくない効果があるかもしれません。Emacsのさまざまな部分で処理の通常の過程としてエラーがキャッチされており、そのエラーが発生したことに気づかないことさえあるかもしれません。@code{condition-case}でラップされたコードをデバッグする必要がある場合は、@code{condition-case-unless-debug}(@pxref{Handling Errors}を参照)の使用を考慮してください。"

#. type: defopt
#: debugging.texi.orig:163
#, no-wrap
msgid "debug-on-event"
msgstr "debug-on-event"

#. type: defopt
#: debugging.texi.orig:170
msgid ""
"If you set @code{debug-on-event} to a special event (@pxref{Special "
"Events}), Emacs will try to enter the debugger as soon as it receives this "
"event, bypassing @code{special-event-map}.  At present, the only supported "
"values correspond to the signals @code{SIGUSR1} and @code{SIGUSR2} (this is "
"the default).  This can be helpful when @code{inhibit-quit} is set and Emacs "
"is not otherwise responding."
msgstr "@code{debug-on-event}をスペシャルイベント(@ref{Special Events}を参照)にセットした場合は、Emacsは@code{special-event-map}をバイパスして、このイベントを受け取ると即座にデバッガへのエンターを試みます。現在のところサポートされる値は、シグナル@code{SIGUSR1}および@code{SIGUSR2}に対応する値だけです(これがデフォルトです)。これは@code{inhibit-quit}がセットされていて、それ以外はEmacsが応答しない場合に有用かもしれません。"

#. type: cindex
#: debugging.texi.orig:172
#, no-wrap
msgid "message, finding what causes a particular message"
msgstr "message, finding what causes a particular message"

#. type: defvar
#: debugging.texi.orig:173
#, no-wrap
msgid "debug-on-message"
msgstr "debug-on-message"

#. type: defvar
#: debugging.texi.orig:178
msgid ""
"If you set @code{debug-on-message} to a regular expression, Emacs will enter "
"the debugger if it displays a matching message in the echo area.  For "
"example, this can be useful when trying to find the cause of a particular "
"message."
msgstr "@code{debug-on-message}に正規表現をセットした場合には、それにマッチするメッセージがエコーエリアに表示されると、Emacsはデバッガにエンターします。たとえば、これは特定のメッセージの原因を探すのに有用かもしれません。"

#. type: Plain text
#: debugging.texi.orig:185
msgid ""
"To debug an error that happens during loading of the init file, use the "
"option @samp{--debug-init}.  This binds @code{debug-on-error} to @code{t} "
"while loading the init file, and bypasses the @code{condition-case} which "
"normally catches errors in the init file."
msgstr "initファイルロード中に発生したエラーをデバッグするには、オプション@samp{--debug-init}を使用します。これはinitファイルロードの間に@code{debug-on-error}を@code{t}にバインドして、通常はinitファイル内のエラーをキャッチする@code{condition-case}をバイパスします。"

#. type: subsection
#: debugging.texi.orig:187
#, no-wrap
msgid "Debugging Infinite Loops"
msgstr "Debugging Infinite Loops"

#. type: cindex
#: debugging.texi.orig:188
#, no-wrap
msgid "infinite loops"
msgstr "infinite loops"

#. type: cindex
#: debugging.texi.orig:189
#, no-wrap
msgid "loops, infinite"
msgstr "loops, infinite"

#. type: cindex
#: debugging.texi.orig:190
#, no-wrap
msgid "quitting from infinite loop"
msgstr "quitting from infinite loop"

#. type: cindex
#: debugging.texi.orig:191
#, no-wrap
msgid "stopping an infinite loop"
msgstr "stopping an infinite loop"

#. type: Plain text
#: debugging.texi.orig:196
msgid ""
"When a program loops infinitely and fails to return, your first problem is "
"to stop the loop.  On most operating systems, you can do this with "
"@kbd{C-g}, which causes a @dfn{quit}.  @xref{Quitting}."
msgstr "プログラムが無限にループしてリターンできないとき、最初の問題はそのループをいかに停止するかです。ほとんどのオペレーティングシステムでは、(@dfn{quit}させる)@kbd{C-g}でこれを行うことができます。@ref{Quitting}を参照してください。"

#. type: Plain text
#: debugging.texi.orig:203
msgid ""
"Ordinary quitting gives no information about why the program was looping.  "
"To get more information, you can set the variable @code{debug-on-quit} to "
"non-@code{nil}.  Once you have the debugger running in the middle of the "
"infinite loop, you can proceed from the debugger using the stepping "
"commands.  If you step through the entire loop, you may get enough "
"information to solve the problem."
msgstr "普通のquitでは、なぜそのプログラムがループしたかについての情報は与えられません。変数@code{debug-on-quit}に非@code{nil}をセットすることにより、より多くの情報を得ることができます。無限ループの途中でデバッガを実行すれば、デバッガからステップコマンドで先へ進むことができます。ループ全体をステップで追えば、問題を解決するために十分な情報が得られるでしょう。"

#. type: Plain text
#: debugging.texi.orig:207
msgid ""
"Quitting with @kbd{C-g} is not considered an error, and "
"@code{debug-on-error} has no effect on the handling of @kbd{C-g}.  Likewise, "
"@code{debug-on-quit} has no effect on errors."
msgstr "@kbd{C-g}によるquitはエラーとは判断されないので、@kbd{C-g}のハンドルに@code{debug-on-error}は効果がありません。同じように、@code{debug-on-quit}はエラーにたいして効果がありません。"

#. type: defopt
#: debugging.texi.orig:208
#, no-wrap
msgid "debug-on-quit"
msgstr "debug-on-quit"

#. type: defopt
#: debugging.texi.orig:214
msgid ""
"This variable determines whether the debugger is called when @code{quit} is "
"signaled and not handled.  If @code{debug-on-quit} is non-@code{nil}, then "
"the debugger is called whenever you quit (that is, type @kbd{C-g}).  If "
"@code{debug-on-quit} is @code{nil} (the default), then the debugger is not "
"called when you quit."
msgstr "この変数は、@code{quit}がシグナルされ、それがハンドルされていないときに、デバッガを呼び出すかどうかを決定します。@code{debug-on-quit}が非@code{nil}の場合は、quit(つまり@kbd{C-g}をタイプ)したときは常にデバッガが呼び出されます。@code{debug-on-quit}が@code{nil}(デフォルト)の場合は、quitしてもデバッガは呼び出されません。"

#. type: subsection
#: debugging.texi.orig:217
#, no-wrap
msgid "Entering the Debugger on a Function Call"
msgstr "Entering the Debugger on a Function Call"

#. type: cindex
#: debugging.texi.orig:218
#, no-wrap
msgid "function call debugging"
msgstr "function call debugging"

#. type: cindex
#: debugging.texi.orig:219
#, no-wrap
msgid "debugging specific functions"
msgstr "debugging specific functions"

#. type: Plain text
#: debugging.texi.orig:227
msgid ""
"To investigate a problem that happens in the middle of a program, one useful "
"technique is to enter the debugger whenever a certain function is called.  "
"You can do this to the function in which the problem occurs, and then step "
"through the function, or you can do this to a function called shortly before "
"the problem, step quickly over the call to that function, and then step "
"through its caller."
msgstr "プログラムの途中で発生する問題を調べるための有用なテクニックの1つは、特定の関数が呼び出されたときデバッガにエンターする方法です。問題が発生した関数にこれを行い、その関数をステップで追ったり、問題箇所の少し手前の関数呼び出しでこれを行い、その関数をステップオーバーしてその後をステップで追うことができます。"

#. type: deffn
#: debugging.texi.orig:228
#, no-wrap
msgid "Command debug-on-entry function-name"
msgstr "Command debug-on-entry function-name"

#. type: deffn
#: debugging.texi.orig:231
msgid ""
"This function requests @var{function-name} to invoke the debugger each time "
"it is called."
msgstr "この関数は、@var{function-name}が呼び出されるたびにデバッガの呼び出しを要求します。"

#. type: deffn
#: debugging.texi.orig:240
msgid ""
"Any function or macro defined as Lisp code may be set to break on entry, "
"regardless of whether it is interpreted code or compiled code.  If the "
"function is a command, it will enter the debugger when called from Lisp and "
"when called interactively (after the reading of the arguments).  You can "
"also set debug-on-entry for primitive functions (i.e., those written in C) "
"this way, but it only takes effect when the primitive is called from Lisp "
"code.  Debug-on-entry is not allowed for special forms."
msgstr "Lispコードで定義された任意の関数およびマクロは、インタープリターに解釈されたコードかコンパイル済みのコードかに関わらず、エントリーにbreakをセットできます。その関数がコマンドの場合は、Lispから呼び出されたときと、インタラクティブに呼び出されたとき、デバッガにエンターします。(たとえばCで記述された)プリミティブ関数にも、この方法で@code{debug-on-entry}をセットできますが、そのプリミティブがLispコードから呼び出されたときだけ効果があります。@code{debug-on-entry}はスペシャルフォームにはセットできません。"

#. type: deffn
#: debugging.texi.orig:245
msgid ""
"When @code{debug-on-entry} is called interactively, it prompts for "
"@var{function-name} in the minibuffer.  If the function is already set up to "
"invoke the debugger on entry, @code{debug-on-entry} does nothing.  "
"@code{debug-on-entry} always returns @var{function-name}."
msgstr "@code{debug-on-entry}がインタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求めます。その関数がすでにエントリーでデバッガを呼び出すようにセットアップされていた場合、@code{debug-on-entry}は何も行いません。@code{debug-on-entry}は常に@var{function-name}をリターンします。"

#. type: deffn
#: debugging.texi.orig:247
msgid "Here's an example to illustrate use of this function:"
msgstr "以下は、この関数の使い方を説明するための例です:"

#. type: group
#: debugging.texi.orig:254
#, no-wrap
msgid ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"
msgstr ""
"(defun fact (n)\n"
"  (if (zerop n) 1\n"
"      (* n (fact (1- n)))))\n"
"     @result{} fact\n"

#. type: group
#: debugging.texi.orig:258
#, no-wrap
msgid ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"
msgstr ""
"(debug-on-entry 'fact)\n"
"     @result{} fact\n"

#. type: group
#: debugging.texi.orig:261
#, no-wrap
msgid "(fact 3)\n"
msgstr "(fact 3)\n"

#. type: group
#: debugging.texi.orig:272
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--entering a function:\n"
"* fact(3)\n"
"  eval((fact 3))\n"
"  eval-last-sexp-1(nil)\n"
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"------ Buffer: *Backtrace* ------\n"

#. type: deffn
#: debugging.texi.orig:277
#, no-wrap
msgid "Command cancel-debug-on-entry &optional function-name"
msgstr "Command cancel-debug-on-entry &optional function-name"

#. type: deffn
#: debugging.texi.orig:284
msgid ""
"This function undoes the effect of @code{debug-on-entry} on "
"@var{function-name}.  When called interactively, it prompts for "
"@var{function-name} in the minibuffer.  If @var{function-name} is omitted or "
"@code{nil}, it cancels break-on-entry for all functions.  Calling "
"@code{cancel-debug-on-entry} does nothing to a function which is not "
"currently set up to break on entry."
msgstr "この関数は@var{function-name}にたいする@code{debug-on-entry}の効果をアンドゥします。インタラクティブに呼び出されたときは、ミニバッファーで@var{function-name}の入力を求めます。@var{function-name}が省略された、あるいは@code{nil}の場合は、すべての関数にたいするbreak-on-entryをキャンセルします。エントリー時にbreakするようセットアップされていない関数に@code{cancel-debug-on-entry}を呼び出したときは、何も行いません。"

#. type: subsection
#: debugging.texi.orig:287
#, no-wrap
msgid "Explicit Entry to the Debugger"
msgstr "Explicit Entry to the Debugger"

#. type: cindex
#: debugging.texi.orig:288
#, no-wrap
msgid "debugger, explicit entry"
msgstr "debugger, explicit entry"

#. type: cindex
#: debugging.texi.orig:289
#, no-wrap
msgid "force entry to debugger"
msgstr "force entry to debugger"

#. type: Plain text
#: debugging.texi.orig:297
msgid ""
"You can cause the debugger to be called at a certain point in your program "
"by writing the expression @code{(debug)} at that point.  To do this, visit "
"the source file, insert the text @samp{(debug)} at the proper place, and "
"type @kbd{C-M-x} (@code{eval-defun}, a Lisp mode key binding).  "
"@strong{Warning:} if you do this for temporary debugging purposes, be sure "
"to undo this insertion before you save the file!"
msgstr "プログラム内の特定箇所に式@code{(debug)}を記述することにより、その箇所でデバッガが呼び出されるようにできます。これを行うにはソースファイルをvisitして、適切な箇所にテキスト@samp{(debug)}を挿入し、@kbd{C-M-x}(Lispモードでの@code{eval-defun}にたいするキーバインド)をタイプします。@strong{警告:} 一時的なデバッグ目的のためにこれを行なう場合は、ファイルを保存する前に確実にアンドゥしてください!"

#. type: Plain text
#: debugging.texi.orig:303
msgid ""
"The place where you insert @samp{(debug)} must be a place where an "
"additional form can be evaluated and its value ignored.  (If the value of "
"@code{(debug)} isn't ignored, it will alter the execution of the program!)  "
"The most common suitable places are inside a @code{progn} or an implicit "
"@code{progn} (@pxref{Sequencing})."
msgstr "@samp{(debug)}を挿入する箇所は、追加フォームが評価されることができ、その値を無視することができる箇所でなければなりません。(@samp{(debug)}の値が無視されない場合が、プログラムの実行が変更されてしまうでしょう!) 一般的にもっとも適した箇所は、@code{progn}または暗黙的な@code{progn}(@ref{Sequencing}を参照)の内部です。"

#. type: Plain text
#: debugging.texi.orig:308
msgid ""
"If you don't know exactly where in the source code you want to put the debug "
"statement, but you want to display a backtrace when a certain message is "
"displayed, you can set @code{debug-on-message} to a regular expression "
"matching the desired message."
msgstr "デバッグ命令を配したいソースコード中の正確な箇所がわからないが、特定のメッセージが表示されたときにバックトレースを表示したい場合は、意図するメッセージにマッチする正規表現を@code{debug-on-message}にセットできます。"

#. type: subsection
#: debugging.texi.orig:310
#, no-wrap
msgid "Using the Debugger"
msgstr "Using the Debugger"

#. type: Plain text
#: debugging.texi.orig:319
msgid ""
"When the debugger is entered, it displays the previously selected buffer in "
"one window and a buffer named @file{*Backtrace*} in another window.  The "
"backtrace buffer contains one line for each level of Lisp function execution "
"currently going on.  At the beginning of this buffer is a message describing "
"the reason that the debugger was invoked (such as the error message and "
"associated data, if it was invoked due to an error)."
msgstr "デバッガにエンターすると、その前に選択されていたウィンドウを1つのウィンドウに表示し、他のウィンドウに@file{*Backtrace*}という名前のバッファーを表示します。backtraceバッファーには、現在実行されているLisp関数の各レベルが1行ずつ含まれます。このバッファーの先頭は、デバッガが呼び出された理由を説明するメッセージ(デバッガがエラーにより呼び出された場合はエラーメッセージや関連するデータなど)です。"

#. type: vindex
#: debugging.texi.orig:320
#, no-wrap
msgid "debugger-bury-or-kill"
msgstr "debugger-bury-or-kill"

#. type: Plain text
#: debugging.texi.orig:335
msgid ""
"The backtrace buffer is read-only and uses a special major mode, Debugger "
"mode, in which letters are defined as debugger commands.  The usual Emacs "
"editing commands are available; thus, you can switch windows to examine the "
"buffer that was being edited at the time of the error, switch buffers, visit "
"files, or do any other sort of editing.  However, the debugger is a "
"recursive editing level (@pxref{Recursive Editing})  and it is wise to go "
"back to the backtrace buffer and exit the debugger (with the @kbd{q} "
"command) when you are finished with it.  Exiting the debugger gets out of "
"the recursive edit and buries the backtrace buffer.  (You can customize what "
"the @kbd{q} command does with the backtrace buffer by setting the variable "
"@code{debugger-bury-or-kill}.  For example, set it to @code{kill} if you "
"prefer to kill the buffer rather than bury it.  Consult the variable's "
"documentation for more possibilities.)"
msgstr "backtraceバッファーは読み取り専用で、文字キーにデバッガコマンドが定義されたDebuggerモードという特別なメジャーモードを使用します。通常のEmacs編集コマンドが利用できます。したがって、エラー時に編集されていたバッファーを調べるためにウィンドウを切り替えたり、バッファーを切り替えやファイルのvisit、その他一連の編集処理を行なうことができます。しかしデバッガは再帰編集レベル(@ref{Recursive Editing}を参照)にあり、編集が終わったらそれはbacktraceバッファーに戻って、(@kbd{q}コマンドで)デバッガをexitできます。デバッガをexitすることにより、再帰編集を抜け出し、backtraceバッファーはバリー(bury: 覆い隠す)されます。(変数@code{debugger-bury-or-killw}をセットすることにより、backtraceバッファーで@kbd{q}コマンドが何を行うかをカスタマイズできます。たとえば、バッファーをバリーせずにkillしたい場合は、この変数を@code{kill}にセットします。他の値については、変数のドキュメントを調べてください。)"

#. type: Plain text
#: debugging.texi.orig:345
msgid ""
"When the debugger has been entered, the @code{debug-on-error} variable is "
"temporarily set according to @code{eval-expression-debug-on-error}.  If the "
"latter variable is non-@code{nil}, @code{debug-on-error} will temporarily be "
"set to @code{t}.  This means that any further errors that occur while doing "
"a debugging session will (by default) trigger another backtrace.  If this is "
"not what you want, you can either set @code{eval-expression-debug-on-error} "
"to @code{nil}, or set @code{debug-on-error} to @code{nil} in "
"@code{debugger-mode-hook}."
msgstr "デバッガにエンターしたとき、@code{eval-expression-debug-on-error}に一致するように変数@code{debug-on-error}が一時的にセットされます。変数@code{eval-expression-debug-on-error}が非@code{nil}の場合、@code{debug-on-error}は一時的に@code{t}にセットされます。これは、デバッグセッション行っている間にさらにエラーが発生すると、(デフォルトでは)他のbacktraceがトリガーされることを意味します。これが望ましくない場合は、@code{debugger-mode-hook}内で@code{eval-expression-debug-on-error}を@code{nil}にセットするか、@code{debug-on-error}を@code{nil}にセットすることができます。"

#. type: cindex
#: debugging.texi.orig:346
#, no-wrap
msgid "current stack frame"
msgstr "current stack frame"

#. type: Plain text
#: debugging.texi.orig:356
msgid ""
"The backtrace buffer shows you the functions that are executing and their "
"argument values.  It also allows you to specify a stack frame by moving "
"point to the line describing that frame.  (A stack frame is the place where "
"the Lisp interpreter records information about a particular invocation of a "
"function.)  The frame whose line point is on is considered the @dfn{current "
"frame}.  Some of the debugger commands operate on the current frame.  If a "
"line starts with a star, that means that exiting that frame will call the "
"debugger again.  This is useful for examining the return value of a "
"function."
msgstr "backtraceバッファーは、実行されている関数と、その関数の引数の値を示します。しのフレームを示す行にポイントを移動して、スタックフレームを指定することもできます。(スタックフレームとは、Lispインタープリターがある関数への特定の呼び出しを記録する場所のことです。) 行ポイントがオンのフレームが、@dfn{カレントフレーム(current frame)}となります。デバッガコマンドのいくつかは、カレントフレームを処理します。ある行がスター(star)で始まる場合は、そのフレームをexitすることにより再びデバッガが呼び出されることを意味します。これは関数のリターン値を調べるとき有用です。"

#. type: Plain text
#: debugging.texi.orig:360
msgid ""
"If a function name is underlined, that means the debugger knows where its "
"source code is located.  You can click with the mouse on that name, or move "
"to it and type @key{RET}, to visit the source code."
msgstr "関数名にアンダーラインが引かれている場合は、デバッガがその関数のソースコードも位置を知っていることを意味します。その名前をマウスでクリックするか、そこに移動して@key{RET}をタイプして、ソースコードをvisitできます。"

#. type: Plain text
#: debugging.texi.orig:365
msgid ""
"The debugger itself must be run byte-compiled, since it makes assumptions "
"about how many stack frames are used for the debugger itself.  These "
"assumptions are false if the debugger is running interpreted."
msgstr "デバッガはデバッガ自身のスタックフレーム数を想定するため、バイトコンパイルされて実行されなければなりません。デバッガがインタープリターに解釈されて実行されているとき、これらの想定は正しくなくなります。"

#. type: cindex
#: debugging.texi.orig:368
#, no-wrap
msgid "debugger command list"
msgstr "debugger command list"

#. type: Plain text
#: debugging.texi.orig:380
msgid ""
"The debugger buffer (in Debugger mode) provides special commands in addition "
"to the usual Emacs commands.  The most important use of debugger commands is "
"for stepping through code, so that you can see how control flows.  The "
"debugger can step through the control structures of an interpreted function, "
"but cannot do so in a byte-compiled function.  If you would like to step "
"through a byte-compiled function, replace it with an interpreted definition "
"of the same function.  (To do this, visit the source for the function and "
"type @kbd{C-M-x} on its definition.)  You cannot use the Lisp debugger to "
"step through a primitive function."
msgstr "(Debuggerモードの)debuggerバッファーでは、通常のEmacsコマンドに加えて、特別なコマンドが提供されます。デバッガでもっとも重要な使い方をするのは、制御フローを見ることができるコードをステップ実行するコマンドです。デバッガはインタープリターにより解釈された制御構造のステップ実行はできますが、バイトコンパイル済みの関数ではできません。バイトコンパイル済み関数をステップ実行したい場合は、同じ関数の解釈された定義に置き換えてください。(これを行なうには、その関数のソースをvisitして、関数の定義で@kbd{C-M-x}とタイプしてください。) プリミティブ関数のステップ実行にLispデバッガは使用できません。"

#. type: Plain text
#: debugging.texi.orig:383
msgid "Here is a list of Debugger mode commands:"
msgstr "以下はDebuggerモードのコマンドのリストです:"

#. type: item
#: debugging.texi.orig:385
#, no-wrap
msgid "c"
msgstr "c"

#. type: table
#: debugging.texi.orig:390
msgid ""
"Exit the debugger and continue execution.  This resumes execution of the "
"program as if the debugger had never been entered (aside from any "
"side-effects that you caused by changing variable values or data structures "
"while inside the debugger)."
msgstr "デバッガをexitして、実行を継続する。これはあたかもデバッガにエンターしなかったかのように(デバッガ内で行った変数値やデータ構造の変更などの副作用は除外される)、プログラムの実行を再開する。"

#. type: item
#: debugging.texi.orig:391
#, no-wrap
msgid "d"
msgstr "d"

#. type: table
#: debugging.texi.orig:396
msgid ""
"Continue execution, but enter the debugger the next time any Lisp function "
"is called.  This allows you to step through the subexpressions of an "
"expression, seeing what values the subexpressions compute, and what else "
"they do."
msgstr "実行を継続するが、次にLisp関数が何か呼び出されたときはデバッガにエンターする。これにより、ある式の下位の式をステップ実行して、下位の式が計算する値や、行うことを確認できる。"

#. type: table
#: debugging.texi.orig:401
msgid ""
"The stack frame made for the function call which enters the debugger in this "
"way will be flagged automatically so that the debugger will be called again "
"when the frame is exited.  You can use the @kbd{u} command to cancel this "
"flag."
msgstr "デバッガにエンターした関数呼び出しにたいして、この方法で作成されたスタックフレームには自動的にフラグがつくので、そのフレームをexitすると再びデバッガが呼び出されます。このフラグは、@kbd{u}コマンドを使用してキャンセルできます。"

#. type: item
#: debugging.texi.orig:402
#, no-wrap
msgid "b"
msgstr "b"

#. type: table
#: debugging.texi.orig:406
msgid ""
"Flag the current frame so that the debugger will be entered when the frame "
"is exited.  Frames flagged in this way are marked with stars in the "
"backtrace buffer."
msgstr "カレントフレームにフラグをつけるので、そのフレームをexitするときデバッガにエンターする。この方法でフラグがつけられたフレームは、backtraceバッファーでスターのマークがつく。"

#. type: item
#: debugging.texi.orig:407
#, no-wrap
msgid "u"
msgstr "u"

#. type: table
#: debugging.texi.orig:411
msgid ""
"Don't enter the debugger when the current frame is exited.  This cancels a "
"@kbd{b} command on that frame.  The visible effect is to remove the star "
"from the line in the backtrace buffer."
msgstr "カレントフレームをexitしたとき、デバッガにエンターしてはならない。これは、そのフレームの@kbd{b}コマンドをキャンセルする。目に見える効果としては、backtraceバッファーの行からスターが削除される。"

#. type: item
#: debugging.texi.orig:412
#, no-wrap
msgid "j"
msgstr "j"

#. type: table
#: debugging.texi.orig:416
msgid ""
"Flag the current frame like @kbd{b}.  Then continue execution like @kbd{c}, "
"but temporarily disable break-on-entry for all functions that are set up to "
"do so by @code{debug-on-entry}."
msgstr "@kbd{b}と同じようにカレントフレームにフラグをつける。その後、@kbd{c}のように実行を継続するが、@code{debug-on-entry}によりセットアップされたすべての関数にたいするbreak-on-entryを一時的に無効にする。"

#. type: item
#: debugging.texi.orig:417
#, no-wrap
msgid "e"
msgstr "e"

#. type: table
#: debugging.texi.orig:426
msgid ""
"Read a Lisp expression in the minibuffer, evaluate it (with the relevant "
"lexical environment, if applicable), and print the value in the echo area.  "
"The debugger alters certain important variables, and the current buffer, as "
"part of its operation; @kbd{e} temporarily restores their values from "
"outside the debugger, so you can examine and change them.  This makes the "
"debugger more transparent.  By contrast, @kbd{M-:} does nothing special in "
"the debugger; it shows you the variable values within the debugger."
msgstr "ミニバッファーのLisp式を読み取り、(関連するlexical環境が適切なら)評価して、エコーエリアに値をプリントする。デバッガは特定の重要な変数とバッファーを処理の一部としてを変更する。@kbd{e}は一時的にデバッガの外部からそれらの値をリストアするので、それらを調べて変更できる。これによりデバッガはより透過的になる。対照的に、デバッガ内で@kbd{M-:}は特別なことを行わず、デバッガ内での変数の値を表示する。"

#. type: item
#: debugging.texi.orig:427
#, no-wrap
msgid "R"
msgstr "R"

#. type: table
#: debugging.texi.orig:430
msgid ""
"Like @kbd{e}, but also save the result of evaluation in the buffer "
"@file{*Debugger-record*}."
msgstr "@kbd{e}と同様だが、バッファー@file{*Debugger-record*}内の評価の結果も保存する。"

#. type: item
#: debugging.texi.orig:431
#, no-wrap
msgid "q"
msgstr "q"

#. type: table
#: debugging.texi.orig:434
msgid ""
"Terminate the program being debugged; return to top-level Emacs command "
"execution."
msgstr "デバッグされているプログラムを終了し、Emacsコマンド実行のトップレベルにリターンする。"

#. type: table
#: debugging.texi.orig:437
msgid ""
"If the debugger was entered due to a @kbd{C-g} but you really want to quit, "
"and not debug, use the @kbd{q} command."
msgstr "@kbd{C-g}によりデバッガにエンターしたが、実際はデバッグではなくquitしたいときは、@kbd{q}コマンドを使用する。"

#. type: item
#: debugging.texi.orig:438
#, no-wrap
msgid "r"
msgstr "r"

#. type: table
#: debugging.texi.orig:441
msgid ""
"Return a value from the debugger.  The value is computed by reading an "
"expression with the minibuffer and evaluating it."
msgstr "デバッガから値をリターンする。ミニバッファーで式を読み取り、それを評価することにより、値が計算される。"

#. type: table
#: debugging.texi.orig:448
msgid ""
"The @kbd{r} command is useful when the debugger was invoked due to exit from "
"a Lisp call frame (as requested with @kbd{b} or by entering the frame with "
"@kbd{d}); then the value specified in the @kbd{r} command is used as the "
"value of that frame.  It is also useful if you call @code{debug} and use its "
"return value.  Otherwise, @kbd{r} has the same effect as @kbd{c}, and the "
"specified return value does not matter."
msgstr "@kbd{d}コマンドは、(@kbd{b}によるリクエスト、または@kbd{d}によるそのフレームへのエンターによる)Lisp呼び出しフレームからのexitでデバッガが呼び出されたときに有用です。@kbd{r}コマンドで指定された値は、そのフレームの値として使用されます。これは、@code{debug}を呼び出して、そのリターン値を使用するときも有用です。それ以外は、@kbd{r}は@kbd{c}と同じ効果をもｙい、指定されたリターン値は問題になりません。"

#. type: table
#: debugging.texi.orig:450
msgid "You can't use @kbd{r} when the debugger was entered due to an error."
msgstr "エラーによりデバッガにエンターしたときは、@kbd{r}コマンドは使用できません。"

#. type: item
#: debugging.texi.orig:451
#, no-wrap
msgid "l"
msgstr "l"

#. type: table
#: debugging.texi.orig:455
msgid ""
"Display a list of functions that will invoke the debugger when called.  This "
"is a list of functions that are set to break on entry by means of "
"@code{debug-on-entry}."
msgstr "呼び出されたときにデバッガを呼び出す関数をリストします。これは、@code{debug-on-entry}によりエントリー時にbreakするようセットされた関数のリストです。"

#. type: item
#: debugging.texi.orig:456
#, no-wrap
msgid "v"
msgstr "v"

#. type: table
#: debugging.texi.orig:458
msgid "Toggle the display of local variables of the current stack frame."
msgstr "カレントスタックフレームのローカル変数の表示を切り替えます。"

#. type: cindex
#: debugging.texi.orig:462
#, no-wrap
msgid "invoking lisp debugger"
msgstr "invoking lisp debugger"

#. type: Plain text
#: debugging.texi.orig:466
msgid ""
"Here we describe in full detail the function @code{debug} that is used to "
"invoke the debugger."
msgstr "以下では、デバッガを呼び出すために使用される関数@code{debug}の完全な詳細を説明します。"

#. type: deffn
#: debugging.texi.orig:467
#, no-wrap
msgid "Command debug &rest debugger-args"
msgstr "Command debug &rest debugger-args"

#. type: deffn
#: debugging.texi.orig:473
msgid ""
"This function enters the debugger.  It switches buffers to a buffer named "
"@file{*Backtrace*} (or @file{*Backtrace*<2>} if it is the second recursive "
"entry to the debugger, etc.), and fills it with information about the stack "
"of Lisp function calls.  It then enters a recursive edit, showing the "
"backtrace buffer in Debugger mode."
msgstr "この関数は、デバッガにエンターします。この関数は@file{*Backtrace*}(デバッガへの2回目以降の再帰エントリーでは@file{*Backtrace*<2>、...})という名前のバッファーにバッファーを切り替えて、Lisp関数呼び出しについての情報を書き込みます。それから再帰編集にエンターして、Debuggerモードでbacktraceバッファーを表示します。"

#. type: deffn
#: debugging.texi.orig:478
msgid ""
"The Debugger mode @kbd{c}, @kbd{d}, @kbd{j}, and @kbd{r} commands exit the "
"recursive edit; then @code{debug} switches back to the previous buffer and "
"returns to whatever called @code{debug}.  This is the only way the function "
"@code{debug} can return to its caller."
msgstr "Debuggerモードのコマンド@kbd{c}、@kbd{d}、@kbd{j}、@kbd{r}は再帰編集をexitします。その後、@code{debug}は以前のバッファーに戻って、@code{debug}を呼び出したものが何であれ、そこにリターンします。これは関数@code{debug}が呼び出し元にリターン可能な唯一の方法です。"

#. type: deffn
#: debugging.texi.orig:483
msgid ""
"The use of the @var{debugger-args} is that @code{debug} displays the rest of "
"its arguments at the top of the @file{*Backtrace*} buffer, so that the user "
"can see them.  Except as described below, this is the @emph{only} way these "
"arguments are used."
msgstr "@var{debugger-args}を使用すると、@code{debug}は@file{*Backtrace*}の最上部に残りの引数を表示するもで、ユーザーがそれらを確認できます。以下で説明する場合を除き、これは、これらの引数を使用する@emph{唯一}の方法です。"

#. type: deffn
#: debugging.texi.orig:488
msgid ""
"However, certain values for first argument to @code{debug} have a special "
"significance.  (Normally, these values are used only by the internals of "
"Emacs, and not by programmers calling @code{debug}.)  Here is a table of "
"these special values:"
msgstr "しかし@code{debug}への1つ目の引数にたいする値は、特別な意味をもちます。(これらの値は通常、@code{debug}を呼び出すプログラマーではなく、Emacs内部でのみ使用されます。) 以下はこれら特別な値のテーブルです:"

#. type: item
#: debugging.texi.orig:490
#, no-wrap
msgid "lambda"
msgstr "lambda"

#. type: cindex
#: debugging.texi.orig:491
#, no-wrap
msgid "@code{lambda} in debug"
msgstr "@code{lambda} in debug"

#. type: table
#: debugging.texi.orig:497
msgid ""
"A first argument of @code{lambda} means @code{debug} was called because of "
"entry to a function when @code{debug-on-next-call} was non-@code{nil}.  The "
"debugger displays @samp{Debugger entered--entering a function:} as a line of "
"text at the top of the buffer."
msgstr "1つ目の引数ga@code{lambda}の場合、それは@code{debug-on-next-call}が非@code{nil}のときに関数にエントリーしたことにより@code{debug}が呼び出されたことを意味する。デバッガはバッファーのトップのテキスト行に@samp{Debugger entered--entering a function:}と表示する。"

#. type: item
#: debugging.texi.orig:498
#, no-wrap
msgid "debug"
msgstr "debug"

#. type: table
#: debugging.texi.orig:504
msgid ""
"@code{debug} as first argument means @code{debug} was called because of "
"entry to a function that was set to debug on entry.  The debugger displays "
"the string @samp{Debugger entered--entering a function:}, just as in the "
"@code{lambda} case.  It also marks the stack frame for that function so that "
"it will invoke the debugger when exited."
msgstr "1つ目の引数が@code{debug}の場合、それはエントリー時にデバッグされるようにセットされた関数にエントリーしたことにより@code{debug}が呼び出されたことを意味する。デバッガは@code{lambda}のときと同様、@samp{Debugger entered--entering a function:}を表示します。これはその関数のスタックフレームもマークするので、exit時にデバッガが呼び出される。"

#. type: item
#: debugging.texi.orig:505
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: debugging.texi.orig:511
msgid ""
"When the first argument is @code{t}, this indicates a call to @code{debug} "
"due to evaluation of a function call form when @code{debug-on-next-call} is "
"non-@code{nil}.  The debugger displays @samp{Debugger entered--beginning "
"evaluation of function call form:} as the top line in the buffer."
msgstr "1つ目の引数が@code{t}の場合、それは@code{debug-on-next-call}が非@code{nil}のときに関数呼び出しの評価により@code{debug}が呼び出されたことを示す。デバッガはバッファーのトップの行に@samp{Debugger entered--beginning evaluation of function call form:}と表示する。"

#. type: item
#: debugging.texi.orig:512
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: table
#: debugging.texi.orig:519
msgid ""
"When the first argument is @code{exit}, it indicates the exit of a stack "
"frame previously marked to invoke the debugger on exit.  The second argument "
"given to @code{debug} in this case is the value being returned from the "
"frame.  The debugger displays @samp{Debugger entered--returning value:} in "
"the top line of the buffer, followed by the value being returned."
msgstr "1つ目の引数が@code{exit}のときは、exit時にデバッガを呼び出すよう以前にマークされたスタックフレームをexitしたことを示す。この場合は、@code{debug}に与えられた2つ目の引数が、そのフレームからリターンされた値になる。デバッガはバッファーのトップの行に@samp{Debugger entered--returning value:}とリターンされた値を表示する。"

#. type: item
#: debugging.texi.orig:520
#, no-wrap
msgid "error"
msgstr "error"

#. type: cindex
#: debugging.texi.orig:521
#, no-wrap
msgid "@code{error} in debug"
msgstr "@code{error} in debug"

#. type: table
#: debugging.texi.orig:527
msgid ""
"When the first argument is @code{error}, the debugger indicates that it is "
"being entered because an error or @code{quit} was signaled and not handled, "
"by displaying @samp{Debugger entered--Lisp error:} followed by the error "
"signaled and any arguments to @code{signal}.  For example,"
msgstr "1つ目の引数が@code{error}のときは、ハンドルされていないエラーまたは@code{quit}がシグナルされてデバッガにエンターした場合で、デバッガは@samp{Debugger entered--Lisp error:}とその後にシグナルされたエラーおよび@code{signal}への引数を表示して、それを示す。たとえば、"

#. type: group
#: debugging.texi.orig:532
#, no-wrap
msgid ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"
msgstr ""
"(let ((debug-on-error t))\n"
"  (/ 1 0))\n"

#. type: group
#: debugging.texi.orig:540
#, no-wrap
msgid ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"
msgstr ""
"------ Buffer: *Backtrace* ------\n"
"Debugger entered--Lisp error: (arith-error)\n"
"  /(1 0)\n"
"...\n"
"------ Buffer: *Backtrace* ------\n"

#. type: table
#: debugging.texi.orig:546
msgid ""
"If an error was signaled, presumably the variable @code{debug-on-error} is "
"non-@code{nil}.  If @code{quit} was signaled, then presumably the variable "
"@code{debug-on-quit} is non-@code{nil}."
msgstr "エラーがシグナルされた場合はおそらく、変数@code{debug-on-error}は非@code{nil}で、@code{quit}がシグナルされた場合はおそらく、変数@code{debug-on-quit}は非@code{nil}である。"

#. type: item
#: debugging.texi.orig:547
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: debugging.texi.orig:553
msgid ""
"Use @code{nil} as the first of the @var{debugger-args} when you want to "
"enter the debugger explicitly.  The rest of the @var{debugger-args} are "
"printed on the top line of the buffer.  You can use this feature to display "
"messages---for example, to remind yourself of the conditions under which "
"@code{debug} is called."
msgstr "明示的にデバッガにエンターしたいときは、@var{debugger-args}の1つ目の引数に@code{nil}を使用する。残りの@var{debugger-args}は、バッファーのトップの行にプリントされる。メッセージ --- たとえば@code{debug}が呼び出された条件を思い出すためのリマインダー --- の表示にこの機能を使用できる。"

#. type: subsection
#: debugging.texi.orig:557
#, no-wrap
msgid "Internals of the Debugger"
msgstr "Internals of the Debugger"

#. type: Plain text
#: debugging.texi.orig:561
msgid ""
"This section describes functions and variables used internally by the "
"debugger."
msgstr "このセクションでは、デバッガ内部で使用される関数と変数について説明します。"

#. type: defvar
#: debugging.texi.orig:562
#, no-wrap
msgid "debugger"
msgstr "debugger"

#. type: defvar
#: debugging.texi.orig:568
msgid ""
"The value of this variable is the function to call to invoke the debugger.  "
"Its value must be a function of any number of arguments, or, more typically, "
"the name of a function.  This function should invoke some kind of debugger.  "
"The default value of the variable is @code{debug}."
msgstr "この関数の値は、デバッガを呼び出す関数呼び出しです。値には任意個の引数をとる関数、より具体的には関数の名前でなければなりません。この関数は何らかのデバッガを呼び出すべきです。この変数のデフォルト値は@code{debug}です。"

#. type: defvar
#: debugging.texi.orig:572
msgid ""
"The first argument that Lisp hands to the function indicates why it was "
"called.  The convention for arguments is detailed in the description of "
"@code{debug} (@pxref{Invoking the Debugger})."
msgstr "関数にたいしてLispが渡す1つ目の引数は、その関数がなぜ呼び出されたかを示します。引数の慣習は、@code{debug}(@ref{Invoking the Debugger})に詳解されています。"

#. type: deffn
#: debugging.texi.orig:574
#, no-wrap
msgid "Command backtrace"
msgstr "Command backtrace"

#. type: cindex
#: debugging.texi.orig:575
#, no-wrap
msgid "run time stack"
msgstr "run time stack"

#. type: cindex
#: debugging.texi.orig:576
#, no-wrap
msgid "call stack"
msgstr "call stack"

#. type: deffn
#: debugging.texi.orig:582
msgid ""
"This function prints a trace of Lisp function calls currently active.  This "
"is the function used by @code{debug} to fill up the @file{*Backtrace*} "
"buffer.  It is written in C, since it must have access to the stack to "
"determine which function calls are active.  The return value is always "
"@code{nil}."
msgstr "この関数は現在アクティブなLisp関数呼び出しのトレースをプリントします。この関数は@code{debug}が@file{*Backtrace*}バッファーに書き込む内容を得るために使用されます。どの関数呼び出しがアクティブか判断するためにスタックにアクセスしなければならないので、この関数はCで記述されています。リターン値は、常に@code{nil}です。"

#. type: deffn
#: debugging.texi.orig:587
msgid ""
"In the following example, a Lisp expression calls @code{backtrace} "
"explicitly.  This prints the backtrace to the stream @code{standard-output}, "
"which, in this case, is the buffer @samp{backtrace-output}."
msgstr "以下の例では、Lisp式で明示的に@code{backtrace}を呼び出しています。これはストリーム@code{standard-output}(この場合はバッファー@samp{backtrace-output})にbacktraceをプリントします。"

#. type: deffn
#: debugging.texi.orig:592
msgid ""
"Each line of the backtrace represents one function call.  The line shows the "
"values of the function's arguments if they are all known; if they are still "
"being computed, the line says so.  The arguments of special forms are "
"elided."
msgstr "backtraceの各行は、1つの関数呼び出しを表します。関数の引数が既知の場合は行に値が表示され、まだ計算中の場合は行にその旨が示されます。スペシャルフォームの引数は無視されます。"

#. type: group
#: debugging.texi.orig:601
#, no-wrap
msgid ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"
msgstr ""
"(with-output-to-temp-buffer \"backtrace-output\"\n"
"  (let ((var 1))\n"
"    (save-excursion\n"
"      (setq var (eval '(progn\n"
"                         (1+ var)\n"
"                         (list 'testing (backtrace))))))))\n"
"\n"

#. type: group
#: debugging.texi.orig:603
#, no-wrap
msgid "     @result{} (testing nil)\n"
msgstr "     @result{} (testing nil)\n"

#. type: group
#: debugging.texi.orig:609
#, no-wrap
msgid ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list ...computing arguments...)\n"
msgstr ""
"----------- Buffer: backtrace-output ------------\n"
"  backtrace()\n"
"  (list ...computing arguments...)\n"

#. type: smallexample
#: debugging.texi.orig:618
#, no-wrap
msgid ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list (quote testing) (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"
msgstr ""
"  (progn ...)\n"
"  eval((progn (1+ var) (list (quote testing) (backtrace))))\n"
"  (setq ...)\n"
"  (save-excursion ...)\n"
"  (let ...)\n"
"  (with-output-to-temp-buffer ...)\n"
"  eval((with-output-to-temp-buffer ...))\n"
"  eval-last-sexp-1(nil)\n"

#. type: group
#: debugging.texi.orig:622
#, no-wrap
msgid ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"
msgstr ""
"  eval-last-sexp(nil)\n"
"  call-interactively(eval-last-sexp)\n"
"----------- Buffer: backtrace-output ------------\n"

#. type: defvar
#: debugging.texi.orig:626
#, no-wrap
msgid "debug-on-next-call"
msgstr "debug-on-next-call"

#. type: cindex
#: debugging.texi.orig:627
#, no-wrap
msgid "@code{eval}, and debugging"
msgstr "@code{eval}, and debugging"

#. type: cindex
#: debugging.texi.orig:628
#, no-wrap
msgid "@code{apply}, and debugging"
msgstr "@code{apply}, and debugging"

#. type: cindex
#: debugging.texi.orig:629
#, no-wrap
msgid "@code{funcall}, and debugging"
msgstr "@code{funcall}, and debugging"

#. type: defvar
#: debugging.texi.orig:633
msgid ""
"If this variable is non-@code{nil}, it says to call the debugger before the "
"next @code{eval}, @code{apply} or @code{funcall}.  Entering the debugger "
"sets @code{debug-on-next-call} to @code{nil}."
msgstr "この変数が非@code{nil}の場合、それは次の@code{eval}、@code{apply}、@code{funcall}の前にデバッガを呼び出すよう指定します。デバッガへのエンターにより、@code{debug-on-next-call}は@code{nil}にセットされます。"

#. type: defvar
#: debugging.texi.orig:635
msgid "The @kbd{d} command in the debugger works by setting this variable."
msgstr "デバッガの@kbd{d}コマンドは、この変数をセットすることにより機能します。"

#. type: defun
#: debugging.texi.orig:637
#, no-wrap
msgid "backtrace-debug level flag"
msgstr "backtrace-debug level flag"

#. type: defun
#: debugging.texi.orig:643
msgid ""
"This function sets the debug-on-exit flag of the stack frame @var{level} "
"levels down the stack, giving it the value @var{flag}.  If @var{flag} is "
"non-@code{nil}, this will cause the debugger to be entered when that frame "
"later exits.  Even a nonlocal exit through that frame will enter the "
"debugger."
msgstr "この関数は、そのスタックフレームの@var{level}下位のスタックフレームのdebug-on-exitフラグに@var{flag}に応じた値をセットします。@var{flag}が非@code{nil}の場合は、後にそのフレームをexitするときデバッガにエンターします。そのフレームを通じた非ローカルexitでも、デバッガにエンターします。"

#. type: defun
#: debugging.texi.orig:645
msgid "This function is used only by the debugger."
msgstr "この関数は、デバッガだけに使用されます。"

#. type: defvar
#: debugging.texi.orig:647
#, no-wrap
msgid "command-debug-status"
msgstr "command-debug-status"

#. type: defvar
#: debugging.texi.orig:653
msgid ""
"This variable records the debugging status of the current interactive "
"command.  Each time a command is called interactively, this variable is "
"bound to @code{nil}.  The debugger can set this variable to leave "
"information for future debugger invocations during the same command "
"invocation."
msgstr "この変数はカレントのインタラクティブコマンドのデバッグ状態を記録します。コマンドがインタラクティブに呼び出されるたびに、この変数は@code{nil}にバインドされます。デバッガは、同じコマンドが呼び出されたときのデバッガ呼び出しに情報を残すために、この変数をセットできます。"

#. type: defvar
#: debugging.texi.orig:657
msgid ""
"The advantage of using this variable rather than an ordinary global variable "
"is that the data will never carry over to a subsequent command invocation."
msgstr "普通のグローバル変数ではなくこの変数を使用する利点は、そのデータが後続のコマンド呼び出しに決して引き継がれないことです。"

#. type: defun
#: debugging.texi.orig:659
#, no-wrap
msgid "backtrace-frame frame-number"
msgstr "backtrace-frame frame-number"

#. type: defun
#: debugging.texi.orig:663
msgid ""
"The function @code{backtrace-frame} is intended for use in Lisp debuggers.  "
"It returns information about what computation is happening in the stack "
"frame @var{frame-number} levels down."
msgstr "関数@code{backtrace-frame}は、Lispデバッガ内での使用を意図しています。これは、@var{frame-number}レベル下位のスタックフレームで、何の評価が行われているかに関する情報をリターンします。"

#. type: defun
#: debugging.texi.orig:666
msgid ""
"If that frame has not evaluated the arguments yet, or is a special form, the "
"value is @code{(nil @var{function} @var{arg-forms}@dots{})}."
msgstr "そのフレームがまだ引数を評価していない場合、またはそのフレームがスペシャルフォームの場合、値は@code{(nil @var{function} @var{arg-forms}@dots{})}です。"

#. type: defun
#: debugging.texi.orig:670
msgid ""
"If that frame has evaluated its arguments and called its function already, "
"the return value is @code{(t @var{function} @var{arg-values}@dots{})}."
msgstr "そのフレームが引数を評価して関数をすでに呼び出した場合、リターン値は@code{(t @var{function} @var{arg-values}@dots{})}です。"

#. type: defun
#: debugging.texi.orig:675
msgid ""
"In the return value, @var{function} is whatever was supplied as the @sc{car} "
"of the evaluated list, or a @code{lambda} expression in the case of a macro "
"call.  If the function has a @code{&rest} argument, that is represented as "
"the tail of the list @var{arg-values}."
msgstr "リターン値の@var{function}は何であれ評価されたリストの@sc{car}として提供されます。マクロ呼び出しの場合は@code{lambda}式になります。その関数に@code{&rest}引数がある場合は、リスト@var{arg-values}の末尾に表されます。"

#. type: defun
#: debugging.texi.orig:678
msgid ""
"If @var{frame-number} is out of range, @code{backtrace-frame} returns "
"@code{nil}."
msgstr "@var{frame-number}が範囲外の場合、@code{backtrace-frame}は@code{nil}をリターンします。"

#. type: include
#: debugging.texi.orig:680
#, no-wrap
msgid "edebug.texi"
msgstr "edebug.texi"

#. type: section
#: debugging.texi.orig:683
#, no-wrap
msgid "Debugging Invalid Lisp Syntax"
msgstr "Debugging Invalid Lisp Syntax"

#. type: cindex
#: debugging.texi.orig:684
#, no-wrap
msgid "debugging invalid Lisp syntax"
msgstr "debugging invalid Lisp syntax"

#. type: Plain text
#: debugging.texi.orig:694
msgid ""
"The Lisp reader reports invalid syntax, but cannot say where the real "
"problem is.  For example, the error ``End of file during parsing'' in "
"evaluating an expression indicates an excess of open parentheses (or square "
"brackets).  The reader detects this imbalance at the end of the file, but it "
"cannot figure out where the close parenthesis should have been.  Likewise, "
"``Invalid read syntax: \")\"'' indicates an excess close parenthesis or "
"missing open parenthesis, but does not say where the missing parenthesis "
"belongs.  How, then, to find what to change?"
msgstr "Lispリーダーは無効な構文(invalid syntax)について報告はしますが、実際の問題箇所は報告しません。たとえば、ある式を評価中のエラー``End of file during parsing(パース中にファイル終端に達した)''は、開カッコまたは開角カッコ(open parenthese or open square bracket)が多いことを示しています。Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあるべき箇所を解決することはできません。同様に、``Invalid read syntax: \")\"(無効なread構文:)\")\"''は開カッコの欠落を示していますが、欠落しているカッコが属すべき場所は告げません。ならば、どうやって変更すべき箇所を探せばよいのでしょうか?"

#. type: Plain text
#: debugging.texi.orig:699
msgid ""
"If the problem is not simply an imbalance of parentheses, a useful technique "
"is to try @kbd{C-M-e} at the beginning of each defun, and see if it goes to "
"the place where that defun appears to end.  If it does not, there is a "
"problem in that defun."
msgstr "問題が単なるカッコの不一致でない場合の便利なテクニックは、各defunの先頭で@kbd{C-M-e}とタイプして、そのdefunの最後と思われる箇所に移動するか確認する方法です。もし移動しなければ、問題はそのdefunの内部にあります。"

#. type: cindex
#: debugging.texi.orig:700
#, no-wrap
msgid "unbalanced parentheses"
msgstr "unbalanced parentheses"

#. type: cindex
#: debugging.texi.orig:701
#, no-wrap
msgid "parenthesis mismatch, debugging"
msgstr "parenthesis mismatch, debugging"

#. type: Plain text
#: debugging.texi.orig:706
msgid ""
"However, unmatched parentheses are the most common syntax errors in Lisp, "
"and we can give further advice for those cases.  (In addition, just moving "
"point through the code with Show Paren mode enabled might find the "
"mismatch.)"
msgstr "マッチしないカッコがLispにおいてもっとも一般的な構文エラーなので、これらのケースにたいしてさらにアドバイスすることができます。(Show Parenモードを有効にしてコードにポイントを移動するだけで、カッコの不一致を探しやすくなるでしょう。)"

#. type: node
#: debugging.texi.orig:710 debugging.texi.orig:712
#, no-wrap
msgid "Excess Open"
msgstr "Excess Open"

#. type: menuentry
#: debugging.texi.orig:710
msgid "How to find a spurious open paren or missing close."
msgstr "誤った開カッコと閉カッコを探す方法。"

#. type: node
#: debugging.texi.orig:710 debugging.texi.orig:747
#, no-wrap
msgid "Excess Close"
msgstr "Excess Close"

#. type: menuentry
#: debugging.texi.orig:710
msgid "How to find a spurious close paren or missing open."
msgstr "誤った閉カッコと開カッコを探す方法。"

#. type: subsection
#: debugging.texi.orig:713
#, no-wrap
msgid "Excess Open Parentheses"
msgstr "Excess Open Parentheses"

#. type: cindex
#: debugging.texi.orig:714
#, no-wrap
msgid "excess open parentheses"
msgstr "excess open parentheses"

#. type: Plain text
#: debugging.texi.orig:720
msgid ""
"The first step is to find the defun that is unbalanced.  If there is an "
"excess open parenthesis, the way to do this is to go to the end of the file "
"and type @kbd{C-u C-M-u}.  This will move you to the beginning of the first "
"defun that is unbalanced."
msgstr "カッコがマッチしないdefunを探すのが、最初のステップです。過剰な開カッコが存在する場合は、ファイルの終端に移動して@kbd{C-u C-M-u}とタイプします。これにより、カッコがマッチしない最初のdefunの先頭に移動するでしょう。"

#. type: Plain text
#: debugging.texi.orig:727
msgid ""
"The next step is to determine precisely what is wrong.  There is no way to "
"be sure of this except by studying the program, but often the existing "
"indentation is a clue to where the parentheses should have been.  The "
"easiest way to use this clue is to reindent with @kbd{C-M-q} and see what "
"moves.  @strong{But don't do this yet!} Keep reading, first."
msgstr "何が間違っているのか正確に判断するのが次のステップです。これを確実に行なうには、そのプログラムを詳しく調べる以外に方法はありませんが、カッコがあるべき箇所を探すのに、既存のインデントが手掛かりになることが多々あります。@kbd{C-M-q}で再インデントして何が移動されるか確認するのが、この手掛かりを使用するもっとも簡単な方法です。@strong{しかし、行うのはちょっと待ってください!} まず続きを読んでからにしましょう。"

#. type: Plain text
#: debugging.texi.orig:733
msgid ""
"Before you do this, make sure the defun has enough close parentheses.  "
"Otherwise, @kbd{C-M-q} will get an error, or will reindent all the rest of "
"the file until the end.  So move to the end of the defun and insert a close "
"parenthesis there.  Don't use @kbd{C-M-e} to move there, since that too will "
"fail to work until the defun is balanced."
msgstr "これを行なう前に、defunに十分な閉カッコがあるか確認します。十分な閉カッコがない場合、@kbd{C-M-q}がエラーとなるか、そのdefunからファイル終端までの残りすべてが再インデントされます。その場合はdefunの最後に移動して、そこに閉カッコを挿入します。そのdefunのカッコの釣り合いがとれるまでは、defunの最後に移動するのに@kbd{C-M-e}は使用できません(失敗するでしょう)。"

#. type: Plain text
#: debugging.texi.orig:741
msgid ""
"Now you can go to the beginning of the defun and type @kbd{C-M-q}.  Usually "
"all the lines from a certain point to the end of the function will shift to "
"the right.  There is probably a missing close parenthesis, or a superfluous "
"open parenthesis, near that point.  (However, don't assume this is true; "
"study the code to make sure.)  Once you have found the discrepancy, undo the "
"@kbd{C-M-q} with @kbd{C-_}, since the old indentation is probably "
"appropriate to the intended parentheses."
msgstr "これでdefunの先頭に移動して@kbd{C-M-q}とタイプすることができます。通常は、一定のポイントからその関数の最後までのすべての行が、右へとシフトされるでしょう。これはおそらくそのポイント付近で閉カッコが欠落しているか、不要な開カッコがあります。(しかし、これを真実と仮定せず、コードを詳しく調べてください。) 不一致箇所が見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、@kbd{C-_}で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: debugging.texi.orig:746
msgid ""
"After you think you have fixed the problem, use @kbd{C-M-q} again.  If the "
"old indentation actually fit the intended nesting of parentheses, and you "
"have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に、再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: subsection
#: debugging.texi.orig:748
#, no-wrap
msgid "Excess Close Parentheses"
msgstr "Excess Close Parentheses"

#. type: cindex
#: debugging.texi.orig:749
#, no-wrap
msgid "excess close parentheses"
msgstr "excess close parentheses"

#. type: Plain text
#: debugging.texi.orig:754
msgid ""
"To deal with an excess close parenthesis, first go to the beginning of the "
"file, then type @kbd{C-u -1 C-M-u} to find the end of the first unbalanced "
"defun."
msgstr "過剰な閉カッコへの対処は、まずファイルの先頭に移動してから、カッコのマッチしないdefunを探すために@kbd{C-u -1 C-M-u}をタイプします。"

#. type: Plain text
#: debugging.texi.orig:759
msgid ""
"Then find the actual matching close parenthesis by typing @kbd{C-M-f} at the "
"beginning of that defun.  This will leave you somewhere short of the place "
"where the defun ought to end.  It is possible that you will find a spurious "
"close parenthesis in that vicinity."
msgstr "それから、そのdefunの先頭で@kbd{C-M-f}をタイプして、実際にマッチする閉カッコを探します。これにより、そのdefunの終端より幾分手前の箇所に移動するでしょう。その付近に間違った閉カッコが見つかるでしょう。"

#. type: Plain text
#: debugging.texi.orig:767
msgid ""
"If you don't see a problem at that point, the next thing to do is to type "
"@kbd{C-M-q} at the beginning of the defun.  A range of lines will probably "
"shift left; if so, the missing open parenthesis or spurious close "
"parenthesis is probably near the first of those lines.  (However, don't "
"assume this is true; study the code to make sure.)  Once you have found the "
"discrepancy, undo the @kbd{C-M-q} with @kbd{C-_}, since the old indentation "
"is probably appropriate to the intended parentheses."
msgstr "そのポイントに問題が見つからない場合には、そのdefunの先頭で@kbd{C-M-q}をタイプするのが次のステップです。ある行範囲はおそらく左へシフトするでしょう。その場合、欠落している開カッコまたは間違った閉カッコは、おそらくそれらの行の1行目の近くにあるでしょう。 (しかし、これを真実と仮定せず、コードを詳しく調べてください。)不一致箇所が見つけたら、元のインデントはおそらく意図されたカッコに適しているはずなので、@kbd{C-_}で@kbd{C-M-q}をアンドゥしてください。"

#. type: Plain text
#: debugging.texi.orig:772
msgid ""
"After you think you have fixed the problem, use @kbd{C-M-q} again.  If the "
"old indentation actually fits the intended nesting of parentheses, and you "
"have put back those parentheses, @kbd{C-M-q} should not change anything."
msgstr "問題をfixできたと思った後に、再度@kbd{C-M-q}を使用します。実際に元のインデントが意図したカッコのネストに適合していて、足りないカッコを追加していたら、@kbd{C-M-q}は何も変更しないはずです。"

#. type: cindex
#: debugging.texi.orig:775
#, no-wrap
msgid "coverage testing"
msgstr "coverage testing"

#. type: findex
#: debugging.texi.orig:777
#, no-wrap
msgid "testcover-start"
msgstr "testcover-start"

#. type: findex
#: debugging.texi.orig:778
#, no-wrap
msgid "testcover-mark-all"
msgstr "testcover-mark-all"

#. type: findex
#: debugging.texi.orig:779
#, no-wrap
msgid "testcover-next-mark"
msgstr "testcover-next-mark"

#. type: Plain text
#: debugging.texi.orig:788
msgid ""
"You can do coverage testing for a file of Lisp code by loading the "
"@code{testcover} library and using the command @kbd{M-x testcover-start "
"@key{RET} @var{file} @key{RET}} to instrument the code.  Then test your code "
"by calling it one or more times.  Then use the command @kbd{M-x "
"testcover-mark-all} to display colored highlights on the code to show where "
"coverage is insufficient.  The command @kbd{M-x testcover-next-mark} will "
"move point forward to the next highlighted spot."
msgstr "@code{testcover}ライブラリーをロードして、コマンド@kbd{M-x testcover-start @key{RET} @var{file} @key{RET}}でコードをインストルメントすることにより、Lispコードのファイルにたいしてカバレッジテストを行なうことができます。コードを1回以上呼び出すことにより、テストが行なわれます。コマンド@kbd{M-x testcover-mark-all}を使用すれば、カバレッジが不十分な箇所が色付きでハイライト表示されます。コマンド@kbd{M-x testcover-next-mark}は、次のハイライトされた箇所へポイントを前方に移動します。"

#. type: Plain text
#: debugging.texi.orig:796
msgid ""
"Normally, a red highlight indicates the form was never completely evaluated; "
"a brown highlight means it always evaluated to the same value (meaning there "
"has been little testing of what is done with the result).  However, the red "
"highlight is skipped for forms that can't possibly complete their "
"evaluation, such as @code{error}.  The brown highlight is skipped for forms "
"that are expected to always evaluate to the same value, such as @code{(setq "
"x 14)}."
msgstr "通常、赤くハイライトされた箇所はそのフォームが完全に評価されたことが一度もないことを示し、茶色でハイライトされた箇所は常に同じ値に評価された(その結果にたいして少ししかテストされていない)ことを意味します。しかし、@code{error}のように完全に評価するのが不可能なフォームにたいしては、赤いハイライトはスキップされます。@code{(setq x 14)}のように、常に同じ値に評価されることが期待されるフォームにたいしては、茶色のハイライトスキップされます。"

#. type: Plain text
#: debugging.texi.orig:799
msgid ""
"For difficult cases, you can add do-nothing macros to your code to give "
"advice to the test coverage tool."
msgstr "難しいケースでは、テストカバレッジツールにアドバイスを与えるために、コードにdo-nothingマクロを追加することができます。"

#. type: defmac
#: debugging.texi.orig:800
#, no-wrap
msgid "1value form"
msgstr "1value form"

#. type: defmac
#: debugging.texi.orig:803
msgid ""
"Evaluate @var{form} and return its value, but inform coverage testing that "
"@var{form}'s value should always be the same."
msgstr "@var{form}を評価してその値をリターンするが、テストカバレッジにたいして@var{form}が常に同じ値だという情報を与える。"

#. type: defmac
#: debugging.texi.orig:805
#, no-wrap
msgid "noreturn form"
msgstr "noreturn form"

#. type: defmac
#: debugging.texi.orig:808
msgid ""
"Evaluate @var{form}, informing coverage testing that @var{form} should never "
"return.  If it ever does return, you get a run-time error."
msgstr "@var{form}を評価し、@var{form}が決してリターンしないという情報をカバレッジテストに与える。もしリターンした場合は、run-timeエラーとなる。"

#. type: Plain text
#: debugging.texi.orig:813
msgid ""
"Edebug also has a coverage testing feature (@pxref{Coverage Testing}).  "
"These features partly duplicate each other, and it would be cleaner to "
"combine them."
msgstr "Edebugにもカバレッジテスト機能があります(@ref{Coverage Testing}を参照)。これらの機能は部分的に重複しており、組み合わせることで明確になるでしょう。"

#. type: cindex
#: debugging.texi.orig:817
#, no-wrap
msgid "profiling"
msgstr "profiling"

#. type: cindex
#: debugging.texi.orig:818
#, no-wrap
msgid "measuring resource usage"
msgstr "measuring resource usage"

#. type: cindex
#: debugging.texi.orig:819
#, no-wrap
msgid "memory usage"
msgstr "memory usage"

#. type: Plain text
#: debugging.texi.orig:826
msgid ""
"If your program is working correctly, but you want to make it run more "
"quickly or efficiently, the first thing to do is @dfn{profile} your code so "
"that you know how it is using resources.  If you find that one particular "
"function is responsible for a significant portion of the runtime, you can "
"start looking for ways to optimize that piece."
msgstr "プログラムは正常に機能しているものの、より高速にまたは効率的に実行させたい場合にまず行うべきは、そのプログラムがリソースをどのように使用するか知るために、コードを@dfn{プロファイル(profile)}することです。ある特定の関数の実行が、実行時間のうち無視できない割り合いを占めるようなら、その部分を最適化する方法を探すことを開始できます。"

#. type: Plain text
#: debugging.texi.orig:836
msgid ""
"Emacs has built-in support for this.  To begin profiling, type @kbd{M-x "
"profiler-start}.  You can choose to profile by processor usage, memory "
"usage, or both.  After doing some work, type @kbd{M-x profiler-report} to "
"display a summary buffer for each resource that you chose to profile.  The "
"names of the report buffers include the times at which the reports were "
"generated, so you can generate another report later on without erasing "
"previous results.  When you have finished profiling, type @kbd{M-x "
"profiler-stop} (there is a small overhead associated with profiling)."
msgstr "Emacsには、このためのビルトインサポートがあります。プロファイリングを開始するには、@kbd{M-x profiler-start}をタイプします。プロファイルはプロセッサー使用(processor usage)、メモリー使用(memory usage)、またはその両方を選択できます。何らかの処理を行った後に@kbd{M-x profiler-report}とタイプすると、プロファイルに選択した各リソースがsummaryバッファーに表示されます。reportバッファーの名前には、そのレポートが生成された時刻が含まれるので、前の結果を消去せずに後で他のレポートを生成できます。プロファイリングが終了したら、@kbd{M-x profiler-stop}とタイプしてください(プロファイリングに関連したオーバーヘッドが少しあるからです)。"

#. type: Plain text
#: debugging.texi.orig:844
msgid ""
"The profiler report buffer shows, on each line, a function that was called, "
"followed by how much resource (processor or memory) it used in absolute and "
"percentage times since profiling started.  If a given line has a @samp{+} "
"symbol at the left-hand side, you can expand that line by typing @key{RET}, "
"in order to see the function(s) called by the higher-level function.  "
"Pressing @key{RET} again will collapse back to the original state."
msgstr "profiler reportバッファーでは、各行に呼び出された関数と、その後にプロファイリングが開始されてから使用したリソース(プロセッサーまたはメモリー)の絶対時間とパーセンテージ時間が表示されます。左側にシンボル@samp{+}のある行では@key{RET}をタイプして行を展開して、高位レベルの関数に呼び出された関数を確認できます。もう一度@key{RET}をタイプすると、元の状態へと行が折り畳まれます。"

#. type: Plain text
#: debugging.texi.orig:849
msgid ""
"Press @kbd{j} or @kbd{mouse-2} to jump to the definition of a function.  "
"Press @kbd{d} to view a function's documentation.  You can save a profile to "
"a file using @kbd{C-x C-w}.  You can compare two profiles using @kbd{=}."
msgstr "@kbd{j}または@kbd{mouse-2}を押下すると、関数の定義にジャンプします。@kbd{d}を押下すると、関数のドキュメントを閲覧できます。@kbd{C-x C-w}を使用して、プロファイルをファイルに保存できます。@kbd{=}を使用すれば、2つのプロファイルを比較することができます。"

#. type: file{#1}
#: debugging.texi.orig:852
#, no-wrap
msgid "elp.el"
msgstr "elp.el"

#. type: cindex
#: debugging.texi.orig:853
#, no-wrap
msgid "timing programs"
msgstr "timing programs"

#. type: Plain text
#: debugging.texi.orig:856
msgid ""
"The @file{elp} library offers an alternative approach.  See the file "
"@file{elp.el} for instructions."
msgstr "@file{elp}ライブラリーは、別のアプローチを提案します。使い方は@file{elp.el}を参照してください。"

#. type: file{#1}
#: debugging.texi.orig:857
#, no-wrap
msgid "benchmark.el"
msgstr "benchmark.el"

#. type: cindex
#: debugging.texi.orig:858
#, no-wrap
msgid "benchmarking"
msgstr "benchmarking"

#. type: Plain text
#: debugging.texi.orig:862
msgid ""
"You can check the speed of individual Emacs Lisp forms using the "
"@file{benchmark} library.  See the functions @code{benchmark-run} and "
"@code{benchmark-run-compiled} in @file{benchmark.el}."
msgstr "@file{benchmark}ライブラリーを使用して、Emacs Lispフォームのスピードwpy個別にチェックできます。@file{benchmark.el}内の関数@code{benchmark-run}、および@code{benchmark-run-compiled}を参照してください。"

#. type: cindex
#: debugging.texi.orig:865
#, no-wrap
msgid "--enable-profiling option of configure"
msgstr "--enable-profiling option of configure"

#. type: ifnottex
#: debugging.texi.orig:872
msgid ""
"To profile Emacs at the level of its C code, you can build it using the "
"@option{--enable-profiling} option of @command{configure}.  When Emacs "
"exits, it generates a file @file{gmon.out} that you can examine using the "
"@command{gprof} utility.  This feature is mainly useful for debugging "
"Emacs.  It actually stops the Lisp-level @kbd{M-x profiler-@dots{}} commands "
"described above from working."
msgstr "@command{configure}のオプションに@option{--enable-profiling}を使用してビルドすることにより、EmacsをCコードのレベルでプロファイルすることができます。こうしてビルドされたEmacsは、Emacsをexitするときに@command{gprof}ユーティリティを使用して検証できるファイル@file{gmon.out}を生成します。この機能は主にEmacsのデバッグに有用です。このEmacsは、実行状態から上述の@kbd{M-x profiler-@dots{}}コマンドによりLispレベルで実際にストップします。"
