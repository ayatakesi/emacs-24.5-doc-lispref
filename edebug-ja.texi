@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@comment -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1992-1994, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@c This file can also be used by an independent Edebug User
@c Manual in which case the Edebug node below should be used
@c with the following links to the Bugs section and to the top level:

@c , Bugs and Todo List, Top, Top

@node Edebug
@section Edebug
@cindex Edebug debugging facility

  EdebugはEmacs Lispプログラムにたいするソースレベルデバッガです。これにより、以下のことができます:

@itemize @bullet
@item
式の前や後でストップして、評価をステップで実行する。

@item
条件付き、または無条件のbreakpointのセット。

@item
指定された条件がtrueのときにストップする(グローバルbreakpoint)。

@item
ストップポイントごとに停止したり、breakpointごとに簡単に停止して、低速または高速にトレースを行う。

@item
Edebug外部であるかのように、式の結果を表示し、式を評価する。

@item
式のリストを自動的に再評価して、Edebugがディスプレイを更新するたびにそれらの結果を表示する。

@item
関数呼び出しとリターンのトレース情報を出力する。

@item
エラー発生時にストップする。

@item
Edebug自身のフレームを除外してbacktraceを表示する。

@item
マクロおよびフォームの定義で引数の評価を指定する。

@item
初歩的なカバレッジテストと頻度数の取得。
@end itemize

以下の初めの3つのセクションは、使用を開始するためにEdebugについて十分説明します。

@menu
* Using Edebug::             Edebug使用のための手引き。
* Instrumenting::            Edebugでデバッグするために、コードをインストルメント(計装)しなければならないe
* Modes: Edebug Execution Modes.  多かれ少なかれ、ストップする実行モード。
* Jumping::                  特定の位置にジャンプするコマンド。
* Misc: Edebug Misc.         さまざまなコマンド。
* Breaks::                   プログラムをストップさせるbreakpointのセット。
* Trapping Errors::          Edebugでのエラーのトラップ。
* Views: Edebug Views.       Edebugの内側と外側のビュー。
* Eval: Edebug Eval.         Edebugでの式の評価。
* Eval List::                Edebugにエンターするたびに値が表示される式。
* Printing in Edebug::       プリントのカスタマイズ。
* Trace Buffer::             バッファー内で採れを生成する方法。
* Coverage Testing::         評価をカバレッジテストする方法。
* The Outside Context::      Edebugが保存およびリストアするデータ。
* Edebug and Macros::        マクロ呼び出しをハンドルする方法の指定。
* Options: Edebug Options.   Edebugをカスタマイズするオプション変数。
@end menu

@node Using Edebug
@subsection Edebugの使用

  EdebugでLispプログラムをデバッグするには、最初にデバッグしたいLispコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。これを行なうもっともシンプルな方法は、関数またはマクロの定義に移動して、@kbd{C-u
C-M-x}(プレフィクス引数を指定した@code{eval-defun})を行います。コードをインストルメントする他の手段については、@ref{Instrumenting}を参照してください。

  一度関数をインストルメントすると、その関数にたいする任意の呼び出しにより、Edebugがアクティブになります。Edebugがアクティブになると、どのEdebug実行モードを選択したかに依存して、その関数をステップ実行できるように実行がストップされるか、ディスプレイを更新してデバッグコマンドにたいするチェックの間、実行が継続されます。デフォルトの実行モードstepで、これは実行をストップします。@ref{Edebug
Execution Modes}を参照してください。

  Edebugでは通常、デバッグしているLispコードをEmacsバッファーで閲覧します。これを@dfn{ソースコードバッファー(source code
buffer)}と呼び、バッファーは一時的に読み取り専用になります。

  左フリンジの矢印は、その関数で実行されている行を示します。最初ポイントはその関数の実行されている行にありますが、ポイントを移動するとこれは真ではなくなります。

  以下は、@code{fac}の定義(以下を参照)をインストルメントして@code{(fac
3)}を実行した場合に通常目にするものです。ポイントは、@code{if}の前の開きカッコにあります。

@example
(defun fac (n)
=>@point{}(if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

@cindex stop points
関数内でEdebugが実行をストップできる位置のことを、@dfn{ストップポイント(stop
points)}と呼びます。ストップポイントは、リストであるような部分式の前後、および変数参照の後でも発生します。以下は、関数@code{fac}内のストップポイントをピリオドで示したものです:

@example
(defun fac (n)
  .(if .(< 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
@end example

Emacs
Lispモードのコマンドに加えて、ソースコードバッファーでは、Edebugのスペシャルコマンドが利用できます。たとえば、Edebugコマンド@key{SPC}で次のストップポイントまで実行することができます。@code{fac}にエントリーした後に一度@code{fac}とタイプした場合は、以下のように表示されるでしょう:

@example
(defun fac (n)
=>(if @point{}(< 0 n)
      (* n (fac (1- n)))
    1))
@end example

式の後でEdebugが実行をストップしたときは、エコーエリアにその式の値が表示されます。

他にも頻繁に使用されるコマンドとして、ストップポイントにbreakpointをセットする@kbd{b}、breakpointに達するまで実行する@kbd{g}、Edebugをexitしてトップレベルのコマンドループにリターンする@kbd{q}があります。また、@kbd{?}とタイプするとすべてのEdebugコマンドがリストされます。

@node Instrumenting
@subsection Edebugのためのインストルメント
@cindex instrumenting for Edebug

  LispコードのデバッグにEdebugを使用するためには、最初にそのコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。コードをインストルメントすると、適切な位置でEdebugを呼び出すために追加コードが挿入されます。

@kindex C-M-x
@findex eval-defun (Edebug)
  関数定義でプレフィクス引数とともにコマンド@kbd{C-M-x}
(@code{eval-defun})を呼び出すと、それを評価する前にその定義をインストルメントします。(ソースコード自体は変更しません。)
変数@code{edebug-all-defs}が非@code{nil}の場合は、プレフィクス引数の意味を反転します。この場合、@kbd{C-M-x}はプレフィクス引数が@emph{なければ}その定義をインストルメントします。@code{edebug-all-defs}のデフォルト値は@code{nil}です。コマンド@kbd{M-x
edebug-all-defs}は、変数@code{edebug-all-defs}の値を切り替えます。

@findex eval-region @r{(Edebug)}
@findex eval-buffer @r{(Edebug)}
@findex eval-current-buffer @r{(Edebug)}
  @code{edebug-all-defs}が非@code{nil}の場合は@code{eval-region}、@code{eval-current-buffer}、@code{eval-buffer}も、それらが評価する定義をインストルメントします。同様に、@code{edebug-all-forms}は、@code{eval-region}が(非定義フォームさえ含む）@emph{あらゆる}フォームをインストルメントすべきかを制御します。これはミニバッファー内でのロードや評価には適用されません。コマンド@kbd{M-x
edebug-all-forms}は、このオプションを切り替えます。

@findex edebug-eval-top-level-form
@findex edebug-defun
  他にもコマンド@kbd{M-x
edebug-eval-top-level-form}が利用可能で、これは@code{edebug-all-defs}や@code{edebug-all-forms}の値に関わらず、トップレベルの任意のフォームをインストルメントします。@code{edebug-defun}は@code{edebug-eval-top-level-form}のエイリアスです。

  Edebugがアクティブのの間、コマンド@kbd{I}(@code{edebug-instrument-callee})は、ポイント後のリストフォームに呼び出される関数およびマクロ定義がまだインストルメントされていなければ、それらをインストルメントします。これは、そのファイルのソースの場所をEdebugが知っている場合だけ可能です。この理由によりEdebugロード後は、たとえ評価する定義をインストルメントしない場合でも、@code{eval-region}は評価するすべての定義の位置を記録します。インストルメント済み関数呼び出しにステップインする@kbd{i}コマンド(@ref{Jumping}を参照)も参照してください。

  Edebugはすべての標準スペシャルフォーム、式引数をもつ@code{interactive}フォーム、無名ラムダ式、およびその他の定義フォームのインストルメント方法を知っています。しかし、Edebugはユーザー定義マクロが引数にたいして何を行うかを判断できないので、Edebug仕様を使用してその情報を与えなければなりません。詳細は@ref{Edebug
and Macros}を参照してください。

  Edebugがセッション内で最初にコードをインストルメントしようとするときは、フック@code{edebug-setup-hook}を実行してから、それに@code{nil}をセットします。使おうとしているパッケージに結びつけてEdebug仕様をロードするためにこれを使用できますが、それはEdebugを使用するときだけ機能します。

@findex eval-expression @r{(Edebug)}
  定義からインストルメントを削除するには、単にインストルメントを行わない方法でその定義を再評価するだけです。フォームを絶対にインストルメントせずに評価するには、2つの方法があります。それはファイルからの@code{load}による評価と、ミニバッファーからの@code{eval-expression}(@kbd{M-:})による評価です。

@c FIXME?  I can't see that it "leaves point at the erroneous code".
  Edebugがインストルメント中にシンタックスエラー(syntax error:
構文エラー)を検知した場合は、間違ったコードの箇所にポイントを残して@code{invalid-read-syntax}エラーをシグナルします。

  Edebug内で利用可能な他の評価関数については、@ref{Edebug Eval}を参照してください。

@node Edebug Execution Modes
@subsection Edebugの実行モード

@cindex Edebug execution modes
Edebugは、デバッグするプログラムの実行にたいして、いくつかの実行モードをサポートします。これらの実行モードを、@dfn{Edebug実行モード(Edebug
execution
modes)}と呼びます。これらをメジャーモードやマイナーモードと混同しないでください。カレントのEdebug実行モードは、プログラムをストップする前にEdebugがどれだけ実行を継続するか
--- たとえばストップポイントごとにストップ、あるいは次のbreakpointまで継続など ---
と、ストップする前にEdebugがどれだけ進捗を表示するかを決定します。

Edebug実行モードは通常、ある特定のモードでプログラムを継続させるコマンドをタイプすることにより指定します。以下は、それらのコマンドのテーブルです。プログラムの実行を再開@kbd{S}以外は、少なくともある長さの間だけ実行を継続します。

@table @kbd
@item S
@c FIXME Does not work. http://debbugs.gnu.org/9764
Stop(ストップ): これ以上プログラムを実行しないで、Edebugのコマンドを待つ(@code{edebug-stop})。

@item @key{SPC}
Step(ステップ): 次のストップポイントでストップする(@code{edebug-step-mode})。

@item n
Next(次へ):
式の後にある次のストップポイントでストップする(@code{edebug-next-mode})。@ref{Jumping}の@code{edebug-forward-sexp}も参照。

@item t
Trace(トレース): Edebugのストップポイントごとにpause(通常は1秒)する(@code{edebug-trace-mode})。

@item T
Rapid
trace(高速でトレース):ストップポイントごとに表示を更新するが、実際にpauseはしない(@code{edebug-Trace-fast-mode})。

@item g
Go(進む): 次のbreakpointまで実行する(@code{edebug-go-mode})。@ref{Breakpoints}を参照。

@item c
Continue(継続): breakpointごとにpauseしてから継続する(@code{edebug-continue-mode})。

@item C
Rapid continue(高速で継続):
ポイントを各breakpointへ移動するが、pauseしない(@code{edebug-Continue-fast-mode})。

@item G
Go non-stop(ストップせず進む):
breakpointを無視する(@code{edebug-Go-nonstop-mode})。まだ@kbd{S}、またはその他の編集コマンドでプログラムをストップするのは可能。
@end table

一般的に、上記リストの最初のほうにある実行モードは後のほうの実行モードに比べて、プログラムをより低速に実行、またはすぐにストップさせます。

実行中、またはトレース中は、任意のEdebugコマンドをタイプすることにより、実行をインタラプト(interrupt:
中断、割り込み)できます。Edebugは次のストップポイントでプログラムをストップしてから、タイプされたコマンドを実行します。たとえば、実行中に@kbd{t}をタイプすると、次のストップポイントでトレースモードに切り替えます。@kbd{S}を使用すれば、他に何も行わずに実行をストップできます。

関数でたまたま読み取り入力が発生した場合には、実行のインタラプトを意図してタイプされた文字は、かわりにその関数により読み取られます。そのプログラムが入力を欲するタイミングに注意を払うことで、そのような意図せぬ結果を避けることができます。

@cindex keyboard macros (Edebug)
このセクションのコマンドを含むキーボードマクロは、完全には機能しません。プログラムを再開するためにEdebugからexitすると、キーボードマクロの追跡記録は失われます。これを処理するのは、簡単ではありません。またEdebug外部でキーボードマクロを定義または実行しても、Edebug内部のコマンドに影響しません。通常これは利点です。@ref{Edebug
Options}内の@code{edebug-continue-kbd-macro}オプションも参照してください。

新たなEdebugレベルにエンターしたとき、初期の実行モードは変数@code{edebug-initial-mode}の値により与えられます(@ref{Edebug
Options}を参照)。デフォルトでこれはstepモードを指定します。たとえば１つのコマンドからインストルメント済みの関数が複数回呼び出された場合は、同じEdebugレベルに再エンターするかもしれないことに注意してください。

@defopt edebug-sit-for-seconds
このオプションは、traceモードおよびcontinueモードで実行ステップの間を何秒待つか指定します。デフォルトは1秒です。
@end defopt

@node Jumping
@subsection ジャンプ

  このセクションで説明するコマンドは、指定された場所に達するまで実行を続けます。@kbd{i}を除くすべてのコマンドは、ストップ場所を確立するために一時的なbreakpointを作成してから、goモードにスイッチします。意図されたストップポイントの前にある他のストップポイントに達した場合も、実行はストップします。breakpointの詳細は、@ref{Breakpoints}を参照してください。

  これらのコマンドは、非ローカルexitの場合はプログラムのストップを期待する一時的なbreakpointをバイパスできるので、期待どおり機能しないかもしれません。

@table @kbd
@item h
ポイントがある場所の近くのストップポイントへ実行を進める(@code{edebug-goto-here})。

@item f
プログラムの式を1つ分実行する(@code{edebug-forward-sexp})。

@item o
sexpを含む終端までプログラムを実行する(@code{edebug-step-out})。

@item i
ポイントの後のフォームから呼び出された関数またはマクロにステップインする(@code{edebug-step-in})。
@end table

@kbd{h}コマンドは一時的なbreakpointを使用して、ポイントのカレント位置、またはその後のストップポイントまで処理を進めます。

@kbd{f}コマンドは式を1つ飛び越してプログラムを実家します。より正確には、@code{forward-sexp}により到達できる位置に一時的なbreakpointをセットしてからgoモードで実行するので、プログラムはそのbreakpointでストップすることになります。

プレフィクス引数@var{n}とともに使用した場合は、ポイントから@var{n}個のsexp(s-expression:
S式)を超えた場所に一時的なbreakpointをセットします。ポイントを含むリストが@var{n}より少ない要素で終わるような場合は、ストップ箇所はポイントが含まれる式の後になります。

@code{forward-sexp}が見つける位置と、プログラムを実際にストップさせたい位置なのかチェックしなければなりません。たとえば@code{cond}内では、これは正しくないかもしれません。

@kbd{f}コマンドは柔軟性を与えるために、@code{forward-sexp}をストップポイントではなく、ポイント位置から開始します。@emph{カレントのストップポイント}から1つの式を実行したい場合は、まずそこにポイントを移動するために@kbd{w}(@code{edebug-where})をタイプして、それから@kbd{f}をタイプしてください。

@kbd{o}コマンドは、式の``外側''で実行を継続します。これは、ポイントを含む式の最後に一時的なbreakpointを配します。ポイントを含むsexpが関数定義の場合、@kbd{o}はその定義内の最後のsexpの直前まで実行を継続します。もし定義内の最後のsexpの直前にポイントがある場合は、その関数からリターンしてからストップします。他の言い方をすると、このコマンドは最後のsexpの後にポイントがない場合は、カレントで実行中の関数からexitしません。

@kbd{i}コマンドは、ポイントの後のリストフォームに呼び出された関数、またはマクロにステップインします。そのフォームは、評価されようとしているもの1つである必要はないことに注意してください。しかし、そのフォームが評価されようとしている関数呼び出しの場合は、引数が何も評価されないうちにこのコマンドを使用しないと、遅すぎることを覚えておいてください。

@kbd{i}コマンドは、ステップインしようとしている関数またはマクロがまだインストルメントされていない場合は、それらをインストルメントします。これは便利かもしれませんが、それらを明示的に非インストルメントしない場合、その関数またはマクロはインストルメントされたままになることを覚えておいてください。

@node Edebug Misc
@subsection その他のEdebugコマンド

  ここでは、その他のEdebugコマンドを説明します。

@table @kbd
@item ?
Edebugのヘルプメッセージを表示する(@code{edebug-help})。

@item C-]
1レベルを中断して以前のコマンドレベルへ戻る(@code{abort-recursive-edit})。

@item q
エディターのトップレベルのコマンドループにリターンする(@code{top-level})。これは、すべてのレベルのEdebugアクティビティを含む、すべての再帰編集レベルをexitする。しかし、フォーム@code{unwind-protect}または@code{condition-case}で保護されたインストルメント済みのコードはデバッグを再開するかもしれない。

@item Q
@kbd{q}と同様だが、保護されたコードでもストップしない(@code{edebug-top-level-nonstop})。

@item r
エコーエリアに、もっとも最近の既知のコマンドを再表示する(@code{edebug-previous-result})。

@item d
backtraceを表示するが、明確であるようにEdebug自身の関数は除外される(@code{edebug-backtrace})。

Edebugのbacktraceバッファーでは、標準デバッガ内のようにバッガコマンドは使用できない。

実行を継続したとき、backtraceバッファーは自動的にkillされる。
@end table

Edebugから再帰的にEdebugをアクティブにするコマンドを呼び出すことができます。Edebugがアクティブなときは常に、@kbd{q}によトップレベルの終了、または@kbd{C-]}による再帰編集1レベルの中断ができます。@kbd{d}により、すべての未解決な評価のbacktraceを表示できます。

@node Breaks
@subsection ブレーク

Edebugのstepモードは、次のストップポイントに達したときに、実行をストップします。一度開始されたEdebugの実行をストップするには、他に3つの方法があります。それはbreakpoint、グローバルbreak条件、およびソースbreakpointです。

@menu
* Breakpoints::              ストップポイントのbreakpoint。
* Global Break Condition::   イベントによるbreak。
* Source Breakpoints::       ソースコードに埋め込まれたbreakpoint。
@end menu

@node Breakpoints
@subsubsection Edebugのブレークポイント

@cindex breakpoints (Edebug)
Edebugを使用しているときは、テスト中のプログラム内に@dfn{breakpoint}を指定できます。breakpointとは、実行がストップされる場所のことです。@ref{Using
Edebug}で定義されている任意のストップポイントに、breakpointをセットできます。breakpointをセットおよび解除において影響を受けるストップポイントは、ソースコードバッファー内でポイント位置、またはポイント位置の後の最初のストップポイントです。以下はEdebugのbreakpoint用のコマンドです:

@table @kbd
@item b
ポイント位置、またはポイント位置の後のストップポイントに、breakpointをセットする(@code{edebug-set-breakpoint})。プレフィクス引数を使用した場合、それは一時的なbreakpointになり、プログラムが最初にそこで停止したとき解除される。

@item u
(もしあれば)ポイント位置、またはポイント位置の後のストップポイントにあるbreakpointを解除(unset)する(@code{edebug-unset-breakpoint})。

@item x @var{condition} @key{RET}
@var{condition}を評価して非@code{nil}値になる場合だけプログラムをストップする、条件付きbreakpointをセットする(@code{edebug-set-conditional-breakpoint})。プレフィクス引数を指定した場合は、一時的なbreakpointになる。

@item B
カレント定義内の、次のbreakpointにポイントを移動する(@code{edebug-next-breakpoint})。
@end table

Edebug内では、@kbd{b}でbreakpointをセットして、@kbd{u}でそれを解除できます。最初に望ましいストップポイントにポイントを移動してから、そこにbreakpointをセットまたは解除するために@kbd{b}または@kbd{u}をタイプしますbreakpointがない場所でbreakpointを解除しても、影響はありません。

ある定義を再評価、または再インストルメントすると、以前のbreakpointはすべて削除されます。

@dfn{条件付きbreakpoint(conditional
breakpoint)}は、プログラムがそこに達するたびに条件をテストします。条件を評価した結果エラーが発生した場合、エラーは無視され結果は@code{nil}になります。条件付きbreakpointをセットするには@kbd{x}を使用して、ミニバッファーで条件式を指定します。以前にセットされた条件付きbreakpointがあるストップポイントに条件付きbreakpointをセットすると、以前の条件式がミニバッファーに配されるので、それを編集できます。

プレフィクス引数を指定してbreakpointをセットするコマンドを使用することにより、@dfn{一時的}な条件付きbreakpoint、および無条件のbreakpointを作成できます。一時的なbreakpointによりプログラムがストップしたとき、そのbreakpointは自動的に解除されます。

Go-nonstopモードを除き、Edebugは常にbreakpointでストップ、またはpauseします。Go-nonstopモードでは、breakpointは完全に無視されます。

breakpointがどこにあるか探すには、@kbd{B}コマンドを使用します。このコマンドは同じ関数内から、ポイント以降にある次のbreakpoint(ポイント以降にbreakpointが存在しない場合は最初のbreakpoint)にポイントを移動します。このコマンドは実行を継続せず、単にバッファー内のポイントを移動します。

@node Global Break Condition
@subsubsection グローバルなブレーク条件

@cindex stopping on events
@cindex global break condition
  @dfn{グローバルbreak条件(global break
condition)}は指定された条件が満たされたとき、それがどこで発生したかによらず、実行をストップします。Edebugは、すべてのストップポイントでグローバルbreak条件を評価します。これが非@code{nil}値に評価された場合は、あたかもそのストップポイントにbreakpointがあったかのように、実行をストップまたはpauseします(実行モードによる)。条件の評価でエラーを取得した場合は、実行をストップしません。

@findex edebug-set-global-break-condition
  条件式は@code{edebug-global-break-condition}に格納されます。Edebugがアクティブなときにソースバッファーから@kbd{X}コマンドを使用するか、Edebugがロードされている間は任意のバッファーから任意のタイミングで@kbd{C-x
X X}(@code{edebug-set-global-break-condition})を使用することにより新たな式を指定できます。

  グローバルbreak条件は、コード内のどこでイベントが発生したかを見つけるもっともシンプルな方法ですが、コードの実行は遅くなります。そのため、使用しないときは条件を@code{nil}にリセットするべきです。

@node Source Breakpoints
@subsubsection ソースブレークポイント

@findex edebug
@cindex source breakpoints
  定義内のすべてのbreakpointは、それをインストルメントするたびに失われます。breakpointが失われないようにしたい場合は、ソースコード内で単に関数@code{edebug}を呼び出す@dfn{ソースbreakpoint(source
breakpoint)}を記述できます。もちろん、そのような呼び出しを条件付きすることにもできます。たとえば@code{fac}関数内に以下のような行を1行目に挿入して、引数が0になったときストップさせることができます:

@example
(defun fac (n)
  (if (= n 0) (edebug))
  (if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

  @code{fac}の定義がインストルメントされて呼び出されたとき、@code{edebug}呼び出しはbreakpointとして振る舞います。実行モードに応じて、Edebugはそこでストップまたはpauseします。

@c This may not be a good idea anymore.
  @code{edebug}が呼び出されたときにインストルメント済みのコードが実行されていなければ、この関数は@code{debug}を呼び出します。

@node Trapping Errors
@subsection エラーのトラップ

  エラーがシグナルされて、それが@code{condition-case}でハンドルされていないとき、Emacsは通常エラーメッセージを表示します。Edebugがアクティブでインストルメント済みのコードを実行中は、ハンドルされていないエラーには通常Edebugが対応します。オプション@code{edebug-on-error}および@code{edebug-on-quit}で、これをカスタマイズできます。@ref{Edebug
Options}を参照してください。

  Edebugがエラーに対応するときは、エラー発生箇所の前にある最後のストップポイントを表示します。この場所はインストルメントされていない関数の呼び出しで、その関数内で実際にエラーが発生したのかもしれません。バインドされていない変数に関するエラーの場合は、最後の既知のストップポイントは、その不正な変数参照から遠く離れた場所かもしれません。そのような場合は、完全なbacktraceを表示したいと思うでしょう(@ref{Edebug
Misc}を参照)。

@c Edebug should be changed for the following: -- dan
  Edebugがアクティブの間に@code{debug-on-error}、または@code{debug-on-quit}を変更した場合、それらの変更はEdebugが非アクティブになったとき失われます。さらに、Edebugの再帰編集の間、これらの変数はEdebugの外部でもっていた値にバインドされます。

@node Edebug Views
@subsection Edebugのビュー

  これらのEdebugコマンドは、Edebugにエントリーする前のバッファーの外観と、ウィンドウの状態を調べるコマンドです。外部のウィンドウ構成は、ウィンドウのコレクションとその内容であり、これらは実際にEdebugの外部にあります。

@table @kbd
@item v
外部のウィンドウ構成ビューに切り替える(@code{edebug-view-outside})。Edebugにリターンするには、@kbd{C-x X
w}をタイプする。

@item p
一時的に外部のカレントバッファーを表示し、ポイントもその外部の位置になる(@code{edebug-bounce-point})。Edebugにリターンする前に、1秒pauseする。プレフィクス引数@var{n}を指定すると、かわりに@var{n}秒pauseする。

@item w
ソースコードバッファー内のカレントストップポイントにポイントを戻す(@code{edebug-where})。

このコマンドを同じバッファーを表示する異なるウィンドウで使用した場合には、そのウィンドウは将来カレント定義を表示するために代用される。

@item W
@c Its function is not simply to forget the saved configuration -- dan
Edebugが外部のウィンドウ構成を保存、およびリストアするかどうかを切り替える(@code{edebug-toggle-save-windows})。

プレフィクス引数を指定すると、@code{W}は選択されたウィンドウの保存とリストアだけを切り替える。ソースコードバッファーを表示していないウィンドウを指定するには、グローバルキーマップから@kbd{C-x
X W}を使用しなければならない。
@end table

  @kbd{v}、または単に@kbd{p}でカレントバッファーにポイントを反跳させれば、たとえ通常は表示されないウィンドウでも、外部のウィンドウ構成を調べることができます。

  ポイントを移動した後に、ストップポイントに戻りたいときがあるかもしれません。これは、ソースコードバッファーから@kbd{w}で行うことができます。どのバッファーにいても、@kbd{C-x
X w}を使用すれば、ソースコードバッファー内のストップポイントに戻ることができます。

  保存を@emph{オフ}にするために@kbd{W}を使用するたびに、Edebugは外部のウィンドウ構成を忘れます。そのため、たとえ保存を@emph{オン}に戻しても、(プログラムを実行することにより)次にEdebugをexitしたとき、カレントウィンドウ構成は変更されないまま残ります。しかし、十分な数のウィンドウをオープンしていない場合は、@file{*edebug*}と@file{*edebug-trace*}の再表示が、あなたが見たいバッファーと競合するかもしれません。

@node Edebug Eval
@subsection 評価

  Edebug内では、まるでEdebugが実行されていないかのように、式を評価できます。式の評価とプリントに際して、Edebugが不可視になるよう試みます。。副作用をもつ式の評価は、Edebugが明示的に保存とリストアを行うデータへの変更を除き、期待したとおり機能するでしょう。このプロセスの詳細は、@ref{The
Outside Context}を参照してください。

@table @kbd
@item e @var{exp} @key{RET}
Edebugのコンテキスト外で、式@var{exp}を評価する(@code{edebug-eval-expression})。つまり、Edebugはその式への干渉を最小限にしようと努める。

@item M-: @var{exp} @key{RET}
Edebug自身のコンテキスト内で、式@var{exp}を評価する(@code{eval-expression})。

@item C-x C-e
Edebugのコンテキスト外で、ポイントの前の式を評価する(@code{edebug-eval-last-sexp})。
@end table

@cindex lexical binding (Edebug)
@c FIXME?  What about lexical-binding = t?
  Edebugは、@file{cl.el}内の構文(@code{lexical-let}、@code{macrolet}、@code{symbol-macrolet})により作成された、レキシカル(lexical)にバインドされたシンボルへの参照を含む式の評価をサポートします。

@node Eval List
@subsection 評価 List Buffer

  式をインタラクティブに評価するために、@file{*edebug*}と呼ばれる@dfn{評価リストバッファー(evaluation list
buffer)}を使用できます。Edebugがディスプレイを更新するたびに自動的に評価される、式の@dfn{評価リスト(evaluation
list)}もセットアップできます。

@table @kbd
@item E
評価リストバッファー@file{*edebug*}に切り替える(@code{edebug-visit-eval-list})。
@end table

  @file{*edebug*}バッファーでは、以下の特別なコマンドと同様に、Lisp Interactionモード(@pxref{Lisp
Interaction,,, emacs, The GNU Emacs Manual})のコマンドも使用できます。

@table @kbd
@item C-j
ポイントの前の式をコンテキスト外で評価して、その値をバッファーに挿入する(@code{edebug-eval-print-last-sexp})。

@item C-x C-e
Edebugのコンテキスト外で、ポイントの前の式を評価する(@code{edebug-eval-last-sexp})。

@item C-c C-u
バッファー内のコンテンツから、新たに評価リストを構築する(@code{edebug-update-eval-list})。

@item C-c C-d
ポイントのある評価リストグループを削除する(@code{edebug-delete-eval-item})。

@item C-c C-w
ソースコードバッファーに切り替えてカレントストップポイントに戻る(@code{edebug-where})。
@end table

  評価リストウィンドウ内では、@file{*scratch*}にいるときと同様に、@kbd{C-j}や@kbd{C-x
C-e}で式を評価できますが、それらはEdebugのコンテキスト外で評価されます。

  インタラクティブに入力した式(とその結果)は、実行を継続すると失われます。しかし、実行がストップされるたびに評価されるように、式から構成される@dfn{評価リスト}をセットアップできます。

@cindex evaluation list group
  これを行なうには、評価リストバッファー内で1つ以上の@dfn{評価リストグループ(evaluation list
group)}を記述します。評価リストグループは、1つ以上のLisp式から構成されます。グループはコメント行で区切られます。

  コマンド@kbd{C-c
C-u}(@code{edebug-update-eval-list})は、バッファーをスキャンして各グループの最初の式を使用して、評価リストを再構築します。(これはグループの2つ目の式は以前に計算、表示されている値だという発想からです。)

  Edebugにエントリーするたびに、評価リストの各式(および式の後に式のカレント値)をバッファーに挿入して再表示します。これはコメント行も挿入するため、各式はそのグループの一員となります。したがって、バッファーのテキストを変更せずに@kbd{C-c
C-u}とタイプした場合、評価リストは実際には変更されません。

  評価リストからの評価の間にエラーが発生した場合、それが式の結果であるかのようにエラーメッセージが文字列で表示されます。したがって、カレントで無効な変数を使用する式により、デバッグが中断されることはありません。

  以下は、いくつかの式を評価リストウィンドウに追加したとき、どのように見えるかの例です:

@smallexample
(current-buffer)
#<buffer *scratch*>
;---------------------------------------------------------------
(selected-window)
#<window 16 on *scratch*>
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
@end smallexample

グループを削除するには、グループ内にポイントを移動して@kbd{C-c C-d}をタイプするか、単にグループのテキストを削除して@kbd{C-c
C-u}で評価リストを更新します。評価リストに新たな式を追加するには、適切な箇所にその式を挿入し、新たなコメント行を挿入してから@kbd{C-c
C-u}をタイプします。コメント行にダッシュを挿入する必要はありません --- 内容は関係ないのです。

@file{*edebug*}を選択した後に、@kbd{C-c
C-w}でソースコードバッファーにリターンできます。@file{*edebug*}は実行を継続したときkillされ、次回必要なとき再作成されます。

@node Printing in Edebug
@subsection Edebugでのプリント

@cindex printing (Edebug)
@cindex printing circular structures
@pindex cust-print
  プログラム内の式が循環リスト構造(circular list
structure)を含む値を生成する場合は、Edebugがそれをプリントしようとしたときエラーとなるかもしれません。

  循環構造への対処の1つに、@code{print-length}および@code{print-level}にプリントの切り詰めをセットする方法があります。Edebugは、変数@code{edebug-print-length}および@code{edebug-print-level}の値(非@code{nil}値をもつ場合)を、これらの変数にバインドします。@ref{Output
Variables}を参照してください。

@defopt edebug-print-length
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-length}をこの値にバインドする。デフォルト値は@code{50}。
@end defopt

@defopt edebug-print-level
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-level}をこの値にバインドする。デフォルト値は@code{50}。
@end defopt

  @code{print-circle}を非@code{nil}値にバインドして、循環構造や要素を共有する構造を、より参考になる情報をプリントすることもできます。

  以下は循環構造を作成するコードの例です:

@example
(setq a '(x y))
(setcar a a)
@end example

@noindent
カスタムプリントはこれを、@samp{Result: #1=(#1#
y)}のようにプリントします。@samp{#1=}という表記はその後の構造をラベル@samp{1}とラベル付けし、@samp{#1#}表記はその前にラベル付けされた構造を参照しています。この表記は、リストやベクターの任意の共有要素に使用されます。

@defopt edebug-print-circle
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-circle}をこの値にバインドする。デフォルト値は@code{t}。
@end defopt

  他にプログラムもカスタムプリントを使用できます。詳細は@file{cust-print.el}を参照してください。

@node Trace Buffer
@subsection トレースバッファー
@cindex trace buffer

  Edebugは実行トレースを@file{*edebug-trace*}という名前のバッファーに格納して記録できます。実行トレースとは関数呼び出しよリターンのログのことで、関数名と引数、および値が確認できます。トレースレコードを有効にするには、@code{edebug-trace}を非@code{nil}値にセットしてください。

  トレースバッファーの作成は、実行モードのトレースの使用(@ref{Edebug Execution Modes}を参照)と同じではありません。

  トレースレコードが有効なときは、関数へのエントリーとexitのたびに、トレースバッファーに行が追加されます。関数エントリーレコードは@samp{::::@{}、および関数名と引数の値により構成されます。関数exitレコードは@samp{::::@}}、および関数名と関数の結果により構成されます。

  @samp{:}の数は、関数エントリーの再帰レベルを表します。トレースバッファーでは、関数呼び出しの開始と終了の検索に@samp{@{}と@samp{@}}を使用できます。

@findex edebug-print-trace-before
@findex edebug-print-trace-after
  関数@code{edebug-print-trace-before}および@code{edebug-print-trace-after}を再定義することにより、関数エントリーと関数exitのトレースレコードをカスタマイズできます。

@defmac edebug-tracing string body@dots{}
このマクロは@var{body}フォーム実行活動にたいする、追加のトレース情報をリクエストする。引数@var{string}は、トレースバッファーに配す@samp{@{}または@samp{@}}の後のテキストを指定する。すべての引数は評価され、@code{edebug-tracing}は@var{body}内の最後のフォームの値をリターンする。
@end defmac

@defun edebug-trace format-string &rest format-args
この関数は、トレースバッファーにテキストを挿入する。テキストは、@code{(apply 'format @var{format-string}
@var{format-args})}により計算される。エントリー間の区切りとして改行も付け加える。
@end defun

  @code{edebug-tracing}および@code{edebug-trace}は、たとえEdebugが非アクティブでも、呼び出されたときは常にトレースバッファーに行を挿入します。トレースバッファーへのテキストの追加により、挿入された最後の行が見えるようにウィンドウもスクロールします。

@node Coverage Testing
@subsection カバレッジテスト

@cindex coverage testing (Edebug)
@cindex frequency counts
@cindex performance analysis
  Edebugは基本的なカバレッジテスト(coverage test)と実行頻度(execution frequency)の表示を提供します。

  カバレッジテストは、すべての式の結果と以前の結果を比較することにより機能します。プログラム内のフォームがそれぞれ、カレントEmacsセッション内でカバレッジテストを開始して以降に、2つの異なる値をリターンした場合、それらのフォームは``カバー''されたと判断します。したがって、プログラムにカバレッジテストを行なうには、そのプログラムをさまざまなコンディション下で実行して、プログラムが正しく振る舞うかに注目します。異なるコンディション下で十分にテストして、すべてのフォームが異なる2つの値をリターンしたとき、Edebugはそのことを告げるでしょう。

  カバレッジテストにより実行速度が低下するので、@code{edebug-test-coverage}が非@code{nil}のときだけカバレッジテストが行なわれます。頻度計数(frequency
count)は、たとえ実行モードがGo-nonstopでも、カバレッジテストが有効か無効かに関わらず、すべての式にたいして処理されます。

@kindex C-x X =
@findex edebug-temp-display-freq-count
  定義にたいするカバレッジ情報と頻度数の両方を表示するには、@kbd{C-x X
=}(@code{edebug-display-freq-count})を使用する。単に@kbd{=}(@code{edebug-temp-display-freq-count})とすると、他のキーをタイプするまでの間だけ、同様な情報を一時的に表示する。

@deffn Command edebug-display-freq-count
このコマンドは、カレント定義の各行の頻度数を表示する。

このコマンドは、コードの各行の下にコメント行として頻度数を挿入する。1回の@code{undo}コマンドで、すべての挿入をアンドゥできる。頻度数は式の前の@samp{(}、または式の後の@samp{)}、または変数の最後の文字の下に表示される。表示をシンプルにするために、同一行にたいして式の以前頻度数と頻度数が同じ場合は表示しない。

ある式にたいする頻度数の後に文字@samp{=}がある場合、それはその式が評価されるたびに毎回同じ値をリターンしていることを表す。他の言い方をすると、カバレッジテストの目的からは、その式はまだ``カバー''されていないということである。

ある定義にたいして頻度数とカバレッジデータを明確にするには、単に@code{eval-defun}で再インストルメントすればよい。
@end deffn

たとえば、ソースのbreakpointで@code{(fac
5)}を評価した後、@code{edebug-test-coverage}を@code{t}にセットすると、breakpointに達したときの頻度データは以下のようになります:

@example
(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (< 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
@end example

コメント行は、@code{fac}が6回呼び出されたことを表しています。最初の@code{if}命令は毎回同じ結果を5回リターンしています。同じ結果という意味では、2つ目の@code{if}の条件にも当てはまります。@code{fac}の再帰呼び出しは、結局リターンしません。


@node The Outside Context
@subsection コンテキスト外部

Edebugはデバッグ中のプログラムにたいして透過的であろうと努めますが、完全には達成されません。Edebugは、@kbd{e}や評価リストバッファーで式を評価するときも、一時的に外部のコンテキストをリストアして、透明化を試みます。このセクションではEdebugがリストアするコンテキストと、Edebugがいかにして完全に透過的になるのに失敗するかを正確に説明します。

@menu
* Checking Whether to Stop::  何を行うかをEdebugが決定するタイミング。
* Edebug Display Update::    Edebugがディスプレイを更新するタイミング。
* Edebug Recursive Edit::    Edebugが実行をストップするタイミング。
@end menu

@node Checking Whether to Stop
@subsubsection 停止するかどうかのチェック

Edebugにエンターするときは常に特定のデータの保存とリストアを行なう必要があり、それはトレース情報を作成するか、あるいはプログラムを停止するかを決定する前に行なう必要があります。

@itemize @bullet
@item
@code{max-lisp-eval-depth}および@code{max-specpdl-size}は、Edebugがスタック与える影響の低減効果を高める。しかしそれでも、Edebug使用時にスタック空間を使い切ってしまうことはあり得る。

@item
キーボードマクロの実行状態は保存およびリストアされる。Edebugがアクティブの間、@code{edebug-continue-kbd-macro}が@code{nil}の場合は、@code{executing-kbd-macro}が@code{nil}にバインドされる。
@end itemize


@node Edebug Display Update
@subsubsection Edebugの表示の更新

@c This paragraph is not filled, because LaLiberte's conversion script
@c needs an xref to be on just one line.
(たとえばtraceモードなどで)Edebugが何かを表示する必要があるときは、Edebugの``外部''からカレントウィンドウ構成(@ref{Window
Configurations}を参照)を保存します。Edebugをexitするときに、以前のウィンドウ構成がリストアされます。

Emacsは、pause時だけ再表示を行います。通常は実行を継続したときに、そのプログラムはbreakpointまたはステップ実行後にEdebugに再エンターし、その間にpauseや入力の読み取りはありません。そのような場合、Emacsが``外部''の構成を再表示する機会は決してありません。結果として、ユーザーが目にするウィンドウ構成は、前回Edebugが中断なしでアクティブだったときのウィンドウ構成と同じになります。

何かを表示するためにEdebugにエントリーすることにより、(たとえこれらのうちのいくつかは、エラーやquitがシグナルされたときは、故意にリストアしないデータだとしても)以下のデータも保存およびリストアされます。

@itemize @bullet
@item
@cindex current buffer point and mark (Edebug)
どれがカレントバッファーか、そしてカレントバッファー内のポイントとマークの位置が、保存およびリストアされる。

@item
@cindex window configuration (Edebug)
@code{edebug-save-windows}が非@code{nil}の場合は、外部のウィンドウ構成が保存およびリストアされる(@ref{Edebug
Options}を参照)。

エラーやquitではウィンドウ構成はリストアされないが、@code{save-excursion}がアクティブな場合は、たとえエラーやquitのとき外部の選択されたウィンドウが再選択@emph{される}。@code{edebug-save-windows}の値がリストの場合は、それにリストされたウィンドウだけが保存およびリストアされる。

しかし、ソースコードバッファーのウィンドウの開始位置と水平スクロールはリストアされないので、表示はEdebug内で整合性が保たれたままとなる。

@item
@code{edebug-save-displayed-buffer-points}が非@code{nil}の場合、表示されているそれぞれのバッファー内のポイント値は、保存およびリストアされる。

@item
変数@code{overlay-arrow-position}と@code{overlay-arrow-string}は保存およびリストアされるので、同じバッファー内の他の場所の再帰編集から、安全にEdebugを呼び出せる。

@item
@code{cursor-in-echo-area}は@code{nil}にローカルにバインドされるので、カーソルはそのウィンドウ内に現れる。
@end itemize

@node Edebug Recursive Edit
@subsubsection Edebugの再帰編集

Edebugにエンターしてユーザーのコマンドが実際に読み取られるとき、Edebugは以下の追加データを保存(そして後でリストア)します:

@itemize @bullet
@item
カレントマッチデータ。@ref{Match Data}を参照。

@item
変数@code{last-command}、@code{this-command}、@code{last-command-event}、@code{last-input-event}、@code{last-event-frame}、@code{last-nonmenu-event}、@code{track-mouse}。Edebug内のコマンドは、Edebug外部のこれらの変数に影響をあたえない。

Edebug内でのコマンド実行は、@code{this-command-keys}によりリターンされるキーシーケンスを変更でき、Lispからそのキーシーケンスをリセットする方法はない。

Edebugは@code{unread-command-events}の値の保存およびリストアができない。この変数が重要な値をもつときにEdebugにエンターすると、デバッグ中のプログラムの実行に干渉する可能性がある。

@item
Edebug内で実行された複雑なコマンドは、変数@code{command-history}に追加される。これが稀に実行に影響を与える。

@item
Edebug内では、再帰深さがEdebug外部の再帰深さより1つ深くなる。これは自動的に更新される評価リストウィンドウでは異なる。

@item
@code{standard-output}と@code{standard-input}は@code{recursive-edit}により@code{nil}にバインドされるが、Edebugは評価の間それらを一時的にリストアする。

@item
キーボードマクロ定義の状態は、保存およびリストアされる。Edebugがアクティブの間、@code{defining-kbd-macro}は@code{edebug-continue-kbd-macro}にバインドされる。
@end itemize

@node Edebug and Macros
@subsection Edebugとマクロ

Edebugが正しくマクロを呼び出す式をインストルメントするには、いくつかの特定な配慮が必要になります。このサブセクションでは、その詳細を説明します。

@menu
* Instrumenting Macro Calls::  基本的な問題点。
* Specification List::       式の複雑なパターンを指定する方法。
* Backtracking::             マッチに失敗したときEdebugが行なうこと。
* Specification Examples::   Edebug仕様を理解するために。
@end menu

@node Instrumenting Macro Calls
@subsubsection マクロ呼び出しのインストルメント

  EdebugがLispマクロを呼び出す式をインストルメントするときは、正しくインストルメントを行なうために、そのマクロに関して追加の情報が必要になります。これは、マクロ呼び出しのどの部分式(subexpression)が評価されるフォームなのか推測する方法がないからです。(評価はマクロのbodyで明示的に発生するかもしれないし、展開結果が評価されるとき、または任意のタイミングで行われるかもしれません。)

  したがって、Edebugが処理するかもしれないすべてのマクロにたいして、そのマクロの呼び出しフォーマットを説明するための、Edebug仕様(Edebug
specification)を定義しなければなりません。これを行なうには、マクロ定義に@code{debug}宣言を追加します。以下はマクロ例@code{for}(@ref{Argument
Evaluation}を参照)にたいする簡単な仕様の例です。

@smallexample
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &rest form)))
  ...)
@end smallexample

  このEdebug仕様は、マクロ呼び出しのどの部分が評価されるフォームなのかを示しています。単純なマクロにたいするEdebug仕様は、そのマクロ定義の正式な引数リストに非常に類似している場合がありますが、Edebug仕様はマクロ引数に比べより汎的です。@code{declare}フォームの詳細は、@ref{Defining
Macros}を参照してください。

@c See, e.g., http://debbugs.gnu.org/10577
@c FIXME  Maybe there should be an Edebug option to get it to
@c automatically load the entire source file containing the function
@c being instrumented.  That would avoid this.
  コードをインストルメントするときEdebugに仕様が確実に解るよう注意してください。マクロ定義を含む他のファイルを要求するために@code{eval-when-compile}を使用するファイルから関数をインストルメントする場合は、そのファイルを明示的にロードする必要があるかもしれません。

  @code{def-edebug-spec}によりマクロ定義から個々のマクロにたいしてEdebug仕様を定義することもできます。Lispで記述されたマクロ定義にたいしては@code{debug}宣言を追加するほうが好ましく、その方が便利でもありますが、@code{def-edebug-spec}ではCで実装されたスペシャルフォームにたいしてEdebug仕様を定義することが可能になります。

@defmac def-edebug-spec macro specification
マクロ@var{macro}呼び出しのどの式が評価される式かを指定する。@var{specification}はEdebug仕様である。どちらの引数も評価されない。

引数@var{macro}は単なるマクロ名ではない、任意の実シンボルを指定できる。
@end defmac

以下は@var{specification}に指定できるシンボルと、引数を処理する方法のテーブルです。

@table @asis
@item @code{t}
すべての引数は評価のためにインストルメントされる。

@item @code{0}
引数はインストルメントされない。

@item シンボル
そのシンボルは、かわりに使用されるEdebug仕様をもたなければならない。このインダイレクションは、他の種類の仕様が見つかるまで繰り返される。これにより、他のマクロの仕様を継承できる。

@item リスト
リストの要素はフォーム呼び出しの引数の型を記述する。仕様リストに指定できる要素については、以降のセクションを参照。
@end table

マクロがEdebug仕様をもたない場合は、@code{debug}宣言および@code{def-edebug-spec}呼び出しのどちらを通じても、変数@code{edebug-eval-macro-args}が効果を発揮する。

@defopt edebug-eval-macro-args
これは、Edebugが明示的なEdebug仕様をもたないマクロ引数を扱う方法を制御する。@code{nil}(デフォルト)の場合、引数は評価のためにインストルメントされない。それ以外は、すべての引数がインストルメントされる。
@end defopt

@node Specification List
@subsubsection 仕様リスト

@cindex Edebug specification list
あるマクロ呼び出しにおいて、いくつかの引数は評価されるが、それ以外の引数は評価されないような場合には、Edebug仕様のために@dfn{仕様リスト(specification
list)}が要求されます。仕様リスト内のいくつかの要素は1つ以上の引数にマッチしまづが、それ以外の要素は以降に続くすべての引数の処理を変更します。後者は@dfn{仕様キーワード(specification
keywords)}と呼ばれ、(@code{&optional}のように)@samp{&}で始まるシンボルです。

仕様リストは、それ自身がリストであるような引数にマッチする部分リスト(sublist)、またはグループ化に使用されるベクターを含むかもしれません。したがって部分式とグループは、仕様リストをレベル階層に細分化します。仕様キーワードは、部分式やグループを含むものの残りに適用されます。

仕様リストに選択肢や繰り返しが含まれる場合は、実際のマクロの呼び出しにたいしてマッチさせるためにバックトラックが要求されるかもしれません。詳細は、@ref{Backtracking}を参照してください。

Edebug仕様は、バランスのとれたカッコで括られた部分式へのマッチ、フォームの再帰処理、インダイレクト仕様を通じた再帰などの、正規表現によるマッチングと、コンテキストに依存しない文法構成を提供します。

以下は仕様リストに使用できる要素と、その意味についてのテーブルです(使用例は@ref{Specification Examples}を参照):

@table @code
@item sexp
@c an "expression" is not necessarily intended for evaluation.
評価れない単一のLispオブジェクト。インストルメントされない。

@item form
評価される単一のLispオブジェクト。インストルメントされる。

@item place
汎変数(generalized variable)。@ref{Generalized Variables}を参照。

@item body
@code{&rest form}の省略形。以下の@code{&rest}を参照。

@item function-form
関数フォーム。クォートされた関数シンボル、クォートされたラムダ式、または(関数シンボルかラムダ式に評価される)フォームのうちのどれか。これはラムダ式のbodyをいずれかの方法でインストルメントするため、@code{function}よりも@code{quote}でクォートされたラムダ式の引数にたいし有用。

@item lambda-expr
クォートされないラムダ式。

@item &optional
@c @kindex &optional @r{(Edebug)}
仕様リスト内の後続の要素はオプション。マッチしない要素が出現すると、Edebugはこのレベルのマッチングを停止する。

後続が非オプションの要素であるような数個の要素をオプションにするだけなら、@code{[&optional
@var{specs}@dots{}]}を使用する。複数の要素すべてのマッチ、または非マッチを指定するには、@code{&optional
[@var{specs}@dots{}]}を使用する。@code{defun}の例を参照。

@item &rest
@c @kindex &rest @r{(Edebug)}
仕様リスト内の後続のすべての要素は、0回以上繰り返される。しかし、最後の繰り返しでは、仕様リスト内のすべての要素にたいするマッチングの前に式が終了しても問題はない。

数個の要素を繰り返すには、@code{[&rest
@var{specs}@dots{}]}を使用する。各繰り返しにおいいてすべてマッチしなければならない複数要素を指定するには、@code{&rest
[@var{specs}@dots{}]}を使用する。

@item &or
@c @kindex &or @r{(Edebug)}
仕様リスト内の後続の各要素は選択肢。選択肢の1つがマッチしなければならず、マッチしない場合@code{&or}仕様は失敗する。

@code{&or}に続く各リスト要素は、単一の選択肢。複数のリスト要素を単一の選択肢にグループ化するには、それらを@code{[@dots{}]}で括る。

@item &not
@c @kindex &not @r{(Edebug)}
後続の各要素は、@code{&or}が使用されたときのように選択肢にマッチするが、要素がマッチした場合に失敗する。どれもマッチする要素がない場合は何もマッチされないが、@code{&not}仕様は成功する。

@c FIXME &key?

@item &define
@c @kindex &define @r{(Edebug)}
フォーム定義にたいする仕様であることを示す。フォーム定義自体はインストルメントされない(つまりEdebugはフォーム定義の前後でストップしない)が、フォーム内部は通常はインストルメントされるであろう。@code{&define}キーワードはリスト仕様の最初の要素であること。

@item nil
カレント引数レベルでマッチさせる引数が存在しない場合は成功し、それ以外は失敗する。部分リスト仕様とバッククォートの例を参照。

@item gate
@cindex preventing backtracking
引数はマッチされないがgateを通じたバックトラックは、このレベルの使用の残りをマッチングする間は無効にされる。これは主に、特定の構文エラーメッセージを一般的にするために使用される。詳細は@ref{Backtracking}、および@code{let}の例も参照。

@item @var{other-symbol}
@cindex indirect specifications
仕様リスト内のその他の要素は、述語(predicate)かインダイレクト仕様(indirect specification)である。

シンボルがEdebug仕様をもつ場合、@dfn{インダイレクト仕様(indirect
specification)}はシンボル位置に使用されるリスト仕様か、引数を処理するための関数のどちらかである。この仕様はマクロにたいする@code{def-edebug-spec}のように定義される。@code{defun}の例を参照。

それ以外の場合、シンボルは述語(predicate)である。述語は引数とともに呼び出され、述語が@code{nil}をリターンした場合、その仕様は失敗して引数はインストルメントされない。

適切な述語としては@code{symbolp}、@code{integerp}、@code{stringp}、@code{vectorp}、@code{atom}が含まれる。

@item [@var{elements}@dots{}]
@cindex [@dots{}] (Edebug)
要素のベクターは、要素を単一の@dfn{グループ仕様(group
specification)}にグループ化する。このグループ仕様は、ベクター自体に何も行わない。

@item "@var{string}"
引数は@var{string}という名前のシンボルである。この仕様は、@var{symbol}の名前が@var{string}であるクォートされたシンボル@code{'@var{symbol}}と等価だが、文字列形式のほうが好ましい。

@item (vector @var{elements}@dots{})
引数は、要素が仕様内の@var{elements}にマッチするベクターである。バッククォートの例を参照。

@item (@var{elements}@dots{})
他のリストは@dfn{部分リスト仕様(sublist
specification)}であり、引数は要素が仕様の@var{elements}にマッチするリストでなければならない。

@cindex dotted lists (Edebug)
部分リスト仕様はドットリスト(dotted
list)かもしれず、その場合対応するリスト引数はドットリストである。かわりに、ドットリスト仕様の最後の@sc{cdr}が、(グループ化やインダイレクト仕様による)他の部分リスト仕様かもしれない(たとえば要素が非ドットリストにマッチする@code{(spec
. [(more
specs@dots{})])}))。これはバッククォートの例のような再帰仕様に有用。このような再帰を終了させるには、上述の@code{nil}仕様も参照。

@code{(specs .  nil)}のように記述された部分リスト仕様は@code{(specs)}、@code{(specs .
(sublist-elements@dots{}))}は@code{(specs
sublist-elements@dots{})}と等価であることに注意。
@end table

@c Need to document extensions with &symbol and :symbol

以下は@code{&define}の後だけに出現する追加仕様のリストです。@code{defun}の例を参照してください。

@table @code
@item name
引数(シンボル)は定義フォームの名前。

定義フォームは名前フィールドをもつ必要はなく、複数の名前フィールドをもつかもしれない。

@item :name
この構成は引数に実際のマッチは行わない。@code{:name}の後の要素はシンボルであり、その定義の追加の名前要素として使用される。定義名に一意で静的な要素を加えるために、これを使用できる。複数回使用されるかもしれない。

@item arg
引数(シンボル)は定義フォームの引数の名前である。しかし、lambda-listキーワード(@samp{&}で始まるシンボル)は許されない。

@item lambda-list
@cindex lambda-list (Edebug)
これはラムダリスト(ラムダ式の引数リスト)にマッチする。

@item def-body
引数は定義内のコードのbodyである。これは上述の@code{body}と似ているが、定義のbodyはその定義に関連する情報を照会する別のEdebug呼び出しでインストルメントされていなければならない。定義内のより高位レベルのフォームリストには、@code{def-body}を使用する。

@item def-form
引数は、定義内のもっとも高位レベルの単一フォームである。これは@code{def-body}と似ているが、フォームリストではなく単一フォームのマッチに使用される。特別なケースとして、@code{def-form}はフォームが実行されるときトレース情報を出力しないことも意味する。@code{interactive}の例を参照。
@end table

@node Backtracking
@subsubsection 仕様でのバックトレース

@cindex backtracking
@cindex syntax error (Edebug)
あるポイント位置で仕様がマッチに失敗しても、構文エラーがシグナルされるとは限りません。そのかわり@dfn{バックトラック(backtracking)}が開始されます。バックトラックは、すべての選択肢をマッチングするまで行なわれます。最終的に引数リストのすべての要素は仕様内の要素のいずれかとマッチしなければならず、仕様内の必須要素は引数のいずれかとマッチしなければなりません。

構文エラーが検出されてもその時点では報告されず、より高位レベルの選択肢のマッチングが終わった後、実際のエラー箇所から離れたポイント位置でエラーが報告されるかもしれません。しかしエラー発生時にバックトラックが無効なら、エラーは即座に報告されるでしょう。ある状況においては、バックトラックも自動的に再有効化されることに注意してください。@code{&optional}、@code{&rest}、@code{&or}により新たな選択肢が設定されたとき、または部分リスト、グループ、インダイレクト仕様が開始されたときは、バックトラックが自動的に有効になります。バックトラックを有効、または無効にした場合の影響は、現在処理中のレベルの残り要素と、低位レベルに限定されます。

何らかのフォーム仕様(すなわち@code{form}、@code{body}、@code{def-form}、@code{def-body})をマッチングする間、バックトラックは無効になっています。これらの仕様は任意のフォームにマッチするので、何らかのエラーが発生するとしたらそれは高位レベルではなく、そのフォーム自体の内部でなければなりません。

バックトラックはクォートされたシンボルや文字列仕様とのマッチに成功した後にも無効になります。なぜなら通常これは構成が認識されたことを示すからです。しかし、同じシンボルで始まる一連の選択肢構成がある場合は、たとえば@code{["foo"
&or [first case] [second case]
...]}のように、通常は選択肢の外部にそのシンボルをファクタリングすることにより、この制約に対処できます。

ほとんどのニーズは、バックトラックを自動的に無効にする、これら2つの方法で満足させることができますが、@code{gate}仕様を使用して明示的にバックトラックを無効にするほうが便利なときもあります。これは、高位に適用可能な選択肢が存在しないことが分かっている場合に有用です。@code{let}仕様の例を参照してください。

@node Specification Examples
@subsubsection 仕様の例

以下で提供する例から学ぶことにより、Edebug仕様の理解が容易になるかもしれません。

スペシャルフォーム@code{let}は、バインディングとbodyのシーケンスをもちます。各バインディングはそシンボル、またはシンボルとオプションの部分リストです。以下の仕様では、部分リストを見つけたらバックトラックを抑止するために、部分リスト内の@code{gate}があることに注目してください。

@ignore
@c FIXME?  The actual definition in edebug.el looks like this (and always
@c has AFAICS).  In fact, nothing in edebug.el uses gate.  So maybe
@c this is just an example for illustration?
(def-edebug-spec let
  ((&rest
    &or (symbolp &optional form) symbolp)
   body))
@end ignore
@example
(def-edebug-spec let
  ((&rest
    &or symbolp (gate symbolp &optional form))
   body))
@end example

Edebugは@code{defun}および関連する引数リスト、@code{interactive}仕様にたいして以下の仕様を使用します。式の引数はその関数bodyの外部で実際に評価されるので、interactiveフォームは特別に処理する必要があります。(@code{defmacro}にたいする仕様は@code{defun}にたいする仕様と非常に似ていますが、@code{declare}命令文が許されます。)

@smallexample
(def-edebug-spec defun
  (&define name lambda-list
           [&optional stringp]   ; @r{ドキュメント文字列が与えられた場合はマッチする。}
           [&optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&rest arg]
    [&optional ["&optional" arg &rest arg]]
    &optional ["&rest" arg]
    )))

(def-edebug-spec interactive
  (&optional &or stringp def-form))    ; @r{Notice: @code{def-form}}
@end smallexample

以下のバッククォートにたいする仕様は、ドットリストにマッチさせる方法と、@code{nil}を使用して再帰を終了させる方法を説明するための例です。また、ベクターのコンポーネントをマッチさせる方法も示しています。(Edebugにより定義される実際の仕様は少し異なり、ドットリストについては失敗するかもしれない非常に深い再帰を引き起こすためサポートしていません。)

@smallexample
(def-edebug-spec \` (backquote-form))   ; @r{Alias just for clarity.}

(def-edebug-spec backquote-form
  (&or ([&or "," ",@@"] &or ("quote" backquote-form) form)
       (backquote-form . [&or nil backquote-form])
       (vector &rest backquote-form)
       sexp))
@end smallexample


@node Edebug Options
@subsection Edebugのオプション

@c Previously defopt'd:
@c edebug-sit-for-seconds, edebug-print-length, edebug-print-level
@c edebug-print-circle, edebug-eval-macro-args
  以下のオプションは、Edebugの動作に影響を与えます:

@defopt edebug-setup-hook
Edebugが使用される前に呼び出される関数。この関数は毎回新たな値をセットする。Edebugこれらの関数を一度呼び出したら、その後@code{edebug-setup-hook}@code{nil}にリセットする。使用するパッケージに関係するEdebug仕様をロードするために使用ｄきるが、それはEdebugを使用するときだけである。@ref{Instrumenting}を参照。
@end defopt

@defopt edebug-all-defs
これが非@code{nil}の場合は@code{defun}や@code{defmacro}のような定義フォームの普通に評価すると、Edebug用にインストルメントされる。これは@code{eval-defun}、@code{eval-region}、@code{eval-buffer}、and
@code{eval-current-buffer}に適用される。

このオプションの切り替えには、コマンド@kbd{M-x edebug-all-defs}を使用する。@ref{Instrumenting}を参照。
@end defopt

@defopt edebug-all-forms
これが非@code{nil}の場合@code{eval-defun}、@code{eval-region}、@code{eval-buffer}、@code{eval-current-buffer}は、たとえフォームが何も定義していなくても、すべてのフォームをインストルメントする。これはロードとミニバッファー内の評価には適用されない。

このオプションの切り替えには、コマンド@kbd{M-x edebug-all-forms}を使用する。@ref{Instrumenting}を参照。
@end defopt

@defopt edebug-save-windows
これが非@code{nil}の場合、Edebugはウィンドウ構成の保存とリストアを行なう。これにはある程度時間がかかるので、ウィンドウ構成に何が起こってもプログラムに関係しない場合は、この変数を@code{nil}にセットしたほうがよい。

値がリストの場合は、リストされたウィンドウだけが保存およびリストアされる。

Edebug内では、この変数をインタラクティブに変更するために@kbd{W}コマンドを使用できる。@ref{Edebug Display
Update}を参照。
@end defopt

@defopt edebug-save-displayed-buffer-points
これが非@code{nil}の場合、Edebugは表示されているすべてのバッファー内のポイントを保存およびリストアする。

選択されていないウィンドウ内に表示されているバッファーのポイントを変更するコードをデバッグしている場合は、他のバッファーのポイントを保存およびリストアする必要がある。その後にEdebugまたはユーザーがそのウィンドウを選択した場合は、そのバッファー内のポイントは、そのウィンドウのポイント値に移動される。

すべてのバッファー内のポイントの保存とリストアは、それぞれのウィンドウを2回選択する必要があり高価な処理のため、必要なときだけ有効にする。@ref{Edebug
Display Update}を参照。
@end defopt

@defopt edebug-initial-mode
この変数が非@code{nil}の場合、Edebugが最初にアクティブになったときの、Edebugの最初の実行モードを指定する。指定できる値は@code{step}、@code{next}、@code{go}、@code{Go-nonstop}、@code{trace}、@code{Trace-fast}、@code{continue}、@code{Continue-fast}。

デフォルト値は@code{step}。@ref{Edebug Execution Modes}を参照。
@end defopt

@defopt edebug-trace
これが非@code{nil}の場合が、各関数のエントリーとexitをトレースする。トレース出力は、関数のエントリーとexitを行ごとに、再帰レベルにしたがって@file{*edebug-trace*}という名前のバッファーに表示される。

@ref{Trace Buffer}の@code{edebug-tracing}も参照のこと。
@end defopt

@defopt edebug-test-coverage
非@code{nil}の場合、Edebugはデバッグされるすべての式のカバレッジをテストする。@ref{Coverage Testing}を参照。
@end defopt

@defopt edebug-continue-kbd-macro
非@code{nil}の場合は、Edebug外で実行されている任意のキーボードマクロの定義または実行を継続する。これはデバッグされないので、慎重に使用すること。@ref{Edebug
Execution Modes}を参照。
@end defopt

@defopt edebug-unwrap-results
非@code{nil}の場合、Edebugは式の結果を表示するときに、その式自体のインストルメント結果の削除を試みる。マクロをデバッグするときは、式の結果自体がインストルメントされた式になるということに関連する。実際的な例ではないが、サンプル例の関数@code{fac}がインストルメントされたとき、そのフォームのマクロを考えてみるとよい。

@c FIXME find a less silly example.
@smallexample
(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      @dots{}))
@end smallexample

@code{test}マクロをインストルメントしてステップ実行すると、デフォルトでは@code{symbol-function}呼び出しは多数の@code{edebug-after}フォームと@code{edebug-before}フォームをもつことになり、それにより``実際の''結果の確認が難しくなり得る。@code{edebug-unwrap-results}が非@code{nil}の場合、Edebugは結果からこれらのフォームの削除を試みる。
@end defopt

@defopt edebug-on-error
@code{debug-on-error}の以前が@code{nil}の場合、Edebugは@code{debug-on-error}をこの値にバインドする。@ref{Trapping
Errors}を参照。
@end defopt

@defopt edebug-on-quit
@code{debug-on-quit}の以前の値が@code{nil}の場合、Edebugは@code{debug-on-quit}にこの値をバインドする。@ref{Trapping
Errors}を参照。
@end defopt

@c Not necessarily a deeper command level.
@c A new command is not precisely true, but that is close enough -- dan
  Edebugがアクティブな間に@code{edebug-on-error}または@code{edebug-on-quit}の値を変更した場合は、@emph{次回}に新たなコマンドを通じてEdebugが呼び出されるまで、これらの値は使用されない。

@defopt edebug-global-break-condition
非@code{nil}の場合、値はすべてのステップポイントでテストされる式である。式の結果が@code{nil}の場合は、breakする。エラーは無視される。@ref{Global
Break Condition}を参照。
@end defopt
