@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@comment -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1992-1994, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@c This file can also be used by an independent Edebug User
@c Manual in which case the Edebug node below should be used
@c with the following links to the Bugs section and to the top level:

@c , Bugs and Todo List, Top, Top

@node Edebug
@section Edebug
@cindex Edebug debugging facility

  EdebugはEmacs Lispプログラムにたいするソースレベルデバッガです。これにより、以下のことができます:

@itemize @bullet
@item
式の前や後でストップして、評価をステップで実行する。

@item
条件付き、または無条件のbreakpointのセット。

@item
指定された条件がtrueのときにストップする(グローバルbreakpoint)。

@item
ストップポイントごとに停止したり、breakpointごとに簡単に停止して、低速または高速にトレースを行う。

@item
Edebug外部であるかのように、式の結果を表示し、式を評価する。

@item
式のリストを自動的に再評価して、Edebugがディスプレイを更新するたびにそれらの結果を表示する。

@item
関数呼び出しとリターンのトレース情報を出力する。

@item
エラー発生時にストップする。

@item
Edebug自身のフレームを除外してbacktraceを表示する。

@item
マクロおよびフォームの定義で引数の評価を指定する。

@item
初歩的なカバレッジテストと頻度数の取得。
@end itemize

以下の初めの3つのセクションは、使用を開始するためにEdebugについて十分説明します。

@menu
* Using Edebug::             Edebug使用のための手引き。
* Instrumenting::            Edebugでデバッグするために、コードをインストルメント(計装)しなければならないe
* Modes: Edebug Execution Modes.  多かれ少なかれ、ストップする実行モード。
* Jumping::                  特定の位置にジャンプするコマンド。
* Misc: Edebug Misc.         さまざまなコマンド。
* Breaks::                   プログラムをストップさせるbreakpointのセット。
* Trapping Errors::          Edebugでのエラーのトラップ。
* Views: Edebug Views.       Edebugの内側と外側のビュー。
* Eval: Edebug Eval.         Edebugでの式の評価。
* Eval List::                Edebugにエンターするたびに値が表示される式。
* Printing in Edebug::       プリントのカスタマイズ。
* Trace Buffer::             バッファー内で採れを生成する方法。
* Coverage Testing::         評価をカバレッジテストする方法。
* The Outside Context::      Edebugが保存およびリストアするデータ。
* Edebug and Macros::        マクロ呼び出しをハンドルする方法の指定。
* Options: Edebug Options.   Edebugをカスタマイズするオプション変数。
@end menu

@node Using Edebug
@subsection Using Edebug

  EdebugでLispプログラムをデバッグするには、最初にデバッグしたいLispコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。これを行なうもっともシンプルな方法は、関数またはマクロの定義に移動して、@kbd{C-u
C-M-x}(プレフィクス引数を指定した@code{eval-defun})を行います。コードをインストルメントする他の手段については、@ref{Instrumenting}を参照してください。

  一度関数をインストルメントすると、その関数にたいする任意の呼び出しにより、Edebugがアクティブになります。Edebugがアクティブになると、どのEdebug実行モードを選択したかに依存して、その関数をステップ実行できるように実行がストップされるか、ディスプレイを更新してデバッグコマンドにたいするチェックの間、実行が継続されます。デフォルトの実行モードstepで、これは実行をストップします。@ref{Edebug
Execution Modes}を参照してください。

  Edebugでは通常、デバッグしているLispコードをEmacsバッファーで閲覧します。これを@dfn{ソースコードバッファー(source code
buffer)}と呼び、バッファーは一時的に読み取り専用になります。

  左フリンジの矢印は、その関数で実行されている行を示します。最初ポイントはその関数の実行されている行にありますが、ポイントを移動するとこれは真ではなくなります。

  以下は、@code{fac}の定義(以下を参照)をインストルメントして@code{(fac
3)}を実行した場合に通常目にするものです。ポイントは、@code{if}の前の開きカッコにあります。

@example
(defun fac (n)
=>@point{}(if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

@cindex stop points
関数内でEdebugが実行をストップできる位置のことを、@dfn{ストップポイント(stop
points)}と呼びます。ストップポイントは、リストであるような部分式の前後、および変数参照の後でも発生します。以下は、関数@code{fac}内のストップポイントをピリオドで示したものです:

@example
(defun fac (n)
  .(if .(< 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
@end example

Emacs
Lispモードのコマンドに加えて、ソースコードバッファーでは、Edebugのスペシャルコマンドが利用できます。たとえば、Edebugコマンド@key{SPC}で次のストップポイントまで実行することができます。@code{fac}にエントリーした後に一度@code{fac}とタイプした場合は、以下のように表示されるでしょう:

@example
(defun fac (n)
=>(if @point{}(< 0 n)
      (* n (fac (1- n)))
    1))
@end example

式の後でEdebugが実行をストップしたときは、エコーエリアにその式の値が表示されます。

他にも頻繁に使用されるコマンドとして、ストップポイントにbreakpointをセットする@kbd{b}、breakpointに達するまで実行する@kbd{g}、Edebugをexitしてトップレベルのコマンドループにリターンする@kbd{q}があります。また、@kbd{?}とタイプするとすべてのEdebugコマンドがリストされます。

@node Instrumenting
@subsection Instrumenting for Edebug
@cindex instrumenting for Edebug

  LispコードのデバッグにEdebugを使用するためには、最初にそのコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。コードをインストルメントすると、適切な位置でEdebugを呼び出すために追加コードが挿入されます。

@kindex C-M-x
@findex eval-defun (Edebug)
  関数定義でプレフィクス引数とともにコマンド@kbd{C-M-x}
(@code{eval-defun})を呼び出すと、それを評価する前にその定義をインストルメントします。(ソースコード自体は変更しません。)
変数@code{edebug-all-defs}が非@code{nil}の場合は、プレフィクス引数の意味を反転します。この場合、@kbd{C-M-x}はプレフィクス引数が@emph{なければ}その定義をインストルメントします。@code{edebug-all-defs}のデフォルト値は@code{nil}です。コマンド@kbd{M-x
edebug-all-defs}は、変数@code{edebug-all-defs}の値を切り替えます。

@findex eval-region @r{(Edebug)}
@findex eval-buffer @r{(Edebug)}
@findex eval-current-buffer @r{(Edebug)}
  @code{edebug-all-defs}が非@code{nil}の場合は@code{eval-region}、@code{eval-current-buffer}、@code{eval-buffer}も、それらが評価する定義をインストルメントします。同様に、@code{edebug-all-forms}は、@code{eval-region}が(非定義フォームさえ含む）@emph{あらゆる}フォームをインストルメントすべきかを制御します。これはミニバッファー内でのロードや評価には適用されません。コマンド@kbd{M-x
edebug-all-forms}は、このオプションを切り替えます。

@findex edebug-eval-top-level-form
@findex edebug-defun
  他にもコマンド@kbd{M-x
edebug-eval-top-level-form}が利用可能で、これは@code{edebug-all-defs}や@code{edebug-all-forms}の値に関わらず、トップレベルの任意のフォームをインストルメントします。@code{edebug-defun}は@code{edebug-eval-top-level-form}のエイリアスです。

  Edebugがアクティブのの間、コマンド@kbd{I}(@code{edebug-instrument-callee})は、ポイント後のリストフォームに呼び出される関数およびマクロ定義がまだインストルメントされていなければ、それらをインストルメントします。これは、そのファイルのソースの場所をEdebugが知っている場合だけ可能です。この理由によりEdebugロード後は、たとえ評価する定義をインストルメントしない場合でも、@code{eval-region}は評価するすべての定義の位置を記録します。インストルメント済み関数呼び出しにステップインする@kbd{i}コマンド(@ref{Jumping}を参照)も参照してください。

  Edebugはすべての標準スペシャルフォーム、式引数をもつ@code{interactive}フォーム、無名ラムダ式、およびその他の定義フォームのインストルメント方法を知っています。しかし、Edebugはユーザー定義マクロが引数にたいして何を行うかを判断できないので、Edebug仕様を使用してその情報を与えなければなりません。詳細は@ref{Edebug
and Macros}を参照してください。

  Edebugがセッション内で最初にコードをインストルメントしようとするときは、フック@code{edebug-setup-hook}を実行してから、それに@code{nil}をセットします。使おうとしているパッケージに結びつけてEdebug仕様をロードするためにこれを使用できますが、それはEdebugを使用するときだけ機能します。

@findex eval-expression @r{(Edebug)}
  定義からインストルメントを削除するには、単にインストルメントを行わない方法でその定義を再評価するだけです。フォームを絶対にインストルメントせずに評価するには、2つの方法があります。それはファイルからの@code{load}による評価と、ミニバッファーからの@code{eval-expression}(@kbd{M-:})による評価です。

@c FIXME?  I can't see that it "leaves point at the erroneous code".
  Edebugがインストルメント中にシンタックスエラー(syntax error:
構文エラー)を検知した場合は、間違ったコードの箇所にポイントを残して@code{invalid-read-syntax}エラーをシグナルします。

  Edebug内で利用可能な他の評価関数については、@ref{Edebug Eval}を参照してください。

@node Edebug Execution Modes
@subsection Edebug Execution Modes

@cindex Edebug execution modes
Edebugは、デバッグするプログラムの実行にたいして、いくつかの実行モードをサポートします。これらの実行モードを、@dfn{Edebug実行モード(Edebug
execution
modes)}と呼びます。これらをメジャーモードやマイナーモードと混同しないでください。カレントのEdebug実行モードは、プログラムをストップする前にEdebugがどれだけ実行を継続するか
--- たとえばストップポイントごとにストップ、あるいは次のbreakpointまで継続など ---
と、ストップする前にEdebugがどれだけ進捗を表示するかを決定します。

Edebug実行モードは通常、ある特定のモードでプログラムを継続させるコマンドをタイプすることにより指定します。以下は、それらのコマンドのテーブルです。プログラムの実行を再開@kbd{S}以外は、少なくともある長さの間だけ実行を継続します。

@table @kbd
@item S
@c FIXME Does not work. http://debbugs.gnu.org/9764
Stop(ストップ): これ以上プログラムを実行しないで、Edebugのコマンドを待つ(@code{edebug-stop})。

@item @key{SPC}
Step(ステップ): 次のストップポイントでストップする(@code{edebug-step-mode})。

@item n
Next(次へ):
式の後にある次のストップポイントでストップする(@code{edebug-next-mode})。@ref{Jumping}の@code{edebug-forward-sexp}も参照。

@item t
Trace(トレース): Edebugのストップポイントごとに一時停止(通常は1秒)する(@code{edebug-trace-mode})。

@item T
Rapid
trace(高速でトレース):ストップポイントごとに表示を更新するが、実際に一時停止はしない(@code{edebug-Trace-fast-mode})。

@item g
Go(進む): 次のbreakpointまで実行する(@code{edebug-go-mode})。@ref{Breakpoints}を参照。

@item c
Continue(継続): breakpointごとに一時停止してから継続する(@code{edebug-continue-mode})。

@item C
Rapid continue(高速で継続):
ポイントを各breakpointへ移動するが、一時停止しない(@code{edebug-Continue-fast-mode})。

@item G
Go non-stop(ストップせず進む):
breakpointを無視する(@code{edebug-Go-nonstop-mode})。まだ@kbd{S}、またはその他の編集コマンドでプログラムをストップするのは可能。
@end table

一般的に、上記リストの最初のほうにある実行モードは後のほうの実行モードに比べて、プログラムをより低速に実行、またはすぐにストップさせます。

実行中、またはトレース中は、任意のEdebugコマンドをタイプすることにより、実行をインタラプト(interrupt:
中断、割り込み)できます。Edebugは次のストップポイントでプログラムをストップしてから、タイプされたコマンドを実行します。たとえば、実行中に@kbd{t}をタイプすると、次のストップポイントでトレースモードに切り替えます。@kbd{S}を使用すれば、他に何も行わずに実行をストップできます。

関数でたまたま読み取り入力が発生した場合には、実行のインタラプトを意図してタイプされた文字は、かわりにその関数により読み取られます。そのプログラムが入力を欲するタイミングに注意を払うことで、そのような意図せぬ結果を避けることができます。

@cindex keyboard macros (Edebug)
このセクションのコマンドを含むキーボードマクロは、完全には機能しません。プログラムを再開するためにEdebugからexitすると、キーボードマクロの追跡記録は失われます。これを処理するのは、簡単ではありません。またEdebug外部でキーボードマクロを定義または実行しても、Edebug内部のコマンドに影響しません。通常これは利点です。@ref{Edebug
Options}内の@code{edebug-continue-kbd-macro}オプションも参照してください。

新たなEdebugレベルにエンターしたとき、初期の実行モードは変数@code{edebug-initial-mode}の値により与えられます(@ref{Edebug
Options}を参照)。デフォルトでこれはstepモードを指定します。たとえば１つのコマンドからインストルメント済みの関数が複数回呼び出された場合は、同じEdebugレベルに再エンターするかもしれないことに注意してください。

@defopt edebug-sit-for-seconds
このオプションは、traceモードおよびcontinueモードで実行ステップの間を何秒待つか指定します。デフォルトは1秒です。
@end defopt

@node Jumping
@subsection Jumping

  このセクションで説明するコマンドは、指定された場所に達するまで実行を続けます。@kbd{i}を除くすべてのコマンドは、ストップ場所を確立するために一時的なbreakpointを作成してから、goモードにスイッチします。意図されたストップポイントの前にある他のストップポイントに達した場合も、実行はストップします。breakpointの詳細は、@ref{Breakpoints}を参照してください。

  これらのコマンドは、非ローカルexitの場合はプログラムのストップを期待する一時的なbreakpointをバイパスできるので、期待どおり機能しないかもしれません。

@table @kbd
@item h
ポイントがある場所の近くのストップポイントへ実行を進める(@code{edebug-goto-here})。

@item f
プログラムの式を1つ分実行する(@code{edebug-forward-sexp})。

@item o
sexpを含む終端までプログラムを実行する(@code{edebug-step-out})。

@item i
ポイントの後のフォームから呼び出された関数またはマクロにステップインする(@code{edebug-step-in})。
@end table

@kbd{h}コマンドは一時的なbreakpointを使用して、ポイントのカレント位置、またはその後のストップポイントまで処理を進めます。

@kbd{f}コマンドは式を1つ飛び越してプログラムを実家します。より正確には、@code{forward-sexp}により到達できる位置に一時的なbreakpointをセットしてからgoモードで実行するので、プログラムはそのbreakpointでストップすることになります。

プレフィクス引数@var{n}とともに使用した場合は、ポイントから@var{n}個のsexp(s-expression:
S式)を超えた場所に一時的なbreakpointをセットします。ポイントを含むリストが@var{n}より少ない要素で終わるような場合は、ストップ箇所はポイントが含まれる式の後になります。

@code{forward-sexp}が見つける位置と、プログラムを実際にストップさせたい位置なのかチェックしなければなりません。たとえば@code{cond}内では、これは正しくないかもしれません。

@kbd{f}コマンドは柔軟性を与えるために、@code{forward-sexp}をストップポイントではなく、ポイント位置から開始します。@emph{カレントのストップポイント}から1つの式を実行したい場合は、まずそこにポイントを移動するために@kbd{w}(@code{edebug-where})をタイプして、それから@kbd{f}をタイプしてください。

@kbd{o}コマンドは、式の``外側''で実行を継続します。これは、ポイントを含む式の最後に一時的なbreakpointを配します。ポイントを含むsexpが関数定義の場合、@kbd{o}はその定義内の最後のsexpの直前まで実行を継続します。もし定義内の最後のsexpの直前にポイントがある場合は、その関数からリターンしてからストップします。他の言い方をすると、このコマンドは最後のsexpの後にポイントがない場合は、カレントで実行中の関数からexitしません。

@kbd{i}コマンドは、ポイントの後のリストフォームに呼び出された関数、またはマクロにステップインします。そのフォームは、評価されようとしているもの1つである必要はないことに注意してください。しかし、そのフォームが評価されようとしている関数呼び出しの場合は、引数が何も評価されないうちにこのコマンドを使用しないと、遅すぎることを覚えておいてください。

@kbd{i}コマンドは、ステップインしようとしている関数またはマクロがまだインストルメントされていない場合は、それらをインストルメントします。これは便利かもしれませんが、それらを明示的に非インストルメントしない場合、その関数またはマクロはインストルメントされたままになることを覚えておいてください。

@node Edebug Misc
@subsection Miscellaneous Edebug Commands

  ここでは、その他のEdebugコマンドを説明します。

@table @kbd
@item ?
Edebugのヘルプメッセージを表示する(@code{edebug-help})。

@item C-]
1レベルを中断して以前のコマンドレベルへ戻る(@code{abort-recursive-edit})。

@item q
エディターのトップレベルのコマンドループにリターンする(@code{top-level})。これは、すべてのレベルのEdebugアクティビティを含む、すべての再帰編集レベルをexitする。しかし、フォーム@code{unwind-protect}または@code{condition-case}で保護されたインストルメント済みのコードはデバッグを再開するかもしれない。

@item Q
@kbd{q}と同様だが、保護されたコードでもストップしない(@code{edebug-top-level-nonstop})。

@item r
エコーエリアに、もっとも最近の既知のコマンドを再表示する(@code{edebug-previous-result})。

@item d
backtraceを表示するが、明確であるようにEdebug自身の関数は除外される(@code{edebug-backtrace})。

Edebugのbacktraceバッファーでは、標準デバッガ内のようにバッガコマンドは使用できない。

実行を継続したとき、backtraceバッファーは自動的にkillされる。
@end table

Edebugから再帰的にEdebugをアクティブにするコマンドを呼び出すことができます。Edebugがアクティブなときは常に、@kbd{q}によトップレベルの終了、または@kbd{C-]}による再帰編集1レベルの中断ができます。@kbd{d}により、すべての未解決な評価のbacktraceを表示できます。

@node Breaks
@subsection Breaks

Edebugのstepモードは、次のストップポイントに達したときに、実行をストップします。一度開始されたEdebugの実行をストップするには、他に3つの方法があります。それはbreakpoint、グローバルbreak条件、およびソースbreakpointです。

@menu
* Breakpoints::              ストップポイントのbreakpoint。
* Global Break Condition::   eイベントによるbreak。
* Source Breakpoints::       ソースコードに埋め込まれたbreakpoint。
@end menu

@node Breakpoints
@subsubsection Edebug Breakpoints

@cindex breakpoints (Edebug)
While using Edebug, you can specify @dfn{breakpoints} in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in @ref{Using Edebug}.  For setting
and unsetting breakpoints, the stop point that is affected is the first one
at or after point in the source code buffer.  Here are the Edebug commands
for breakpoints:

@table @kbd
@item b
Set a breakpoint at the stop point at or after point
(@code{edebug-set-breakpoint}).  If you use a prefix argument, the
breakpoint is temporary---it turns off the first time it stops the program.

@item u
Unset the breakpoint (if any) at the stop point at or after point
(@code{edebug-unset-breakpoint}).

@item x @var{condition} @key{RET}
Set a conditional breakpoint which stops the program only if evaluating
@var{condition} produces a non-@code{nil} value
(@code{edebug-set-conditional-breakpoint}).  With a prefix argument, the
breakpoint is temporary.

@item B
Move point to the next breakpoint in the current definition
(@code{edebug-next-breakpoint}).
@end table

While in Edebug, you can set a breakpoint with @kbd{b} and unset one with
@kbd{u}.  First move point to the Edebug stop point of your choice, then
type @kbd{b} or @kbd{u} to set or unset a breakpoint there.  Unsetting a
breakpoint where none has been set has no effect.

Re-evaluating or reinstrumenting a definition removes all of its previous
breakpoints.

A @dfn{conditional breakpoint} tests a condition each time the program gets
there.  Any errors that occur as a result of evaluating the condition are
ignored, as if the result were @code{nil}.  To set a conditional breakpoint,
use @kbd{x}, and specify the condition expression in the minibuffer.
Setting a conditional breakpoint at a stop point that has a previously
established conditional breakpoint puts the previous condition expression in
the minibuffer so you can edit it.

You can make a conditional or unconditional breakpoint @dfn{temporary} by
using a prefix argument with the command to set the breakpoint.  When a
temporary breakpoint stops the program, it is automatically unset.

Edebug always stops or pauses at a breakpoint, except when the Edebug mode
is Go-nonstop.  In that mode, it ignores breakpoints entirely.

To find out where your breakpoints are, use the @kbd{B} command, which moves
point to the next breakpoint following point, within the same function, or
to the first breakpoint if there are no following breakpoints.  This command
does not continue execution---it just moves point in the buffer.

@node Global Break Condition
@subsubsection Global Break Condition

@cindex stopping on events
@cindex global break condition
  A @dfn{global break condition} stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global
break condition at every stop point; if it evaluates to a non-@code{nil}
value, then execution stops or pauses depending on the execution mode, as if
a breakpoint had been hit.  If evaluating the condition gets an error,
execution does not stop.

@findex edebug-set-global-break-condition
  The condition expression is stored in @code{edebug-global-break-condition}.
You can specify a new expression using the @kbd{X} command from the source
code buffer while Edebug is active, or using @kbd{C-x X X} from any buffer
at any time, as long as Edebug is loaded
(@code{edebug-set-global-break-condition}).

  The global break condition is the simplest way to find where in your code
some event occurs, but it makes code run much more slowly.  So you should
reset the condition to @code{nil} when not using it.

@node Source Breakpoints
@subsubsection Source Breakpoints

@findex edebug
@cindex source breakpoints
  All breakpoints in a definition are forgotten each time you reinstrument
it.  If you wish to make a breakpoint that won't be forgotten, you can write
a @dfn{source breakpoint}, which is simply a call to the function
@code{edebug} in your source code.  You can, of course, make such a call
conditional.  For example, in the @code{fac} function, you can insert the
first line as shown below, to stop when the argument reaches zero:

@example
(defun fac (n)
  (if (= n 0) (edebug))
  (if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

  When the @code{fac} definition is instrumented and the function is called,
the call to @code{edebug} acts as a breakpoint.  Depending on the execution
mode, Edebug stops or pauses there.

@c This may not be a good idea anymore.
  If no instrumented code is being executed when @code{edebug} is called, that
function calls @code{debug}.

@node Trapping Errors
@subsection Trapping Errors

  Emacs normally displays an error message when an error is signaled and not
handled with @code{condition-case}.  While Edebug is active and executing
instrumented code, it normally responds to all unhandled errors.  You can
customize this with the options @code{edebug-on-error} and
@code{edebug-on-quit}; see @ref{Edebug Options}.

  When Edebug responds to an error, it shows the last stop point encountered
before the error.  This may be the location of a call to a function which
was not instrumented, and within which the error actually occurred.  For an
unbound variable error, the last known stop point might be quite distant
from the offending variable reference.  In that case, you might want to
display a full backtrace (@pxref{Edebug Misc}).

@c Edebug should be changed for the following: -- dan
  If you change @code{debug-on-error} or @code{debug-on-quit} while Edebug is
active, these changes will be forgotten when Edebug becomes inactive.
Furthermore, during Edebug's recursive edit, these variables are bound to
the values they had outside of Edebug.

@node Edebug Views
@subsection Edebug Views

  These Edebug commands let you view aspects of the buffer and window status
as they were before entry to Edebug.  The outside window configuration is
the collection of windows and contents that were in effect outside of
Edebug.

@table @kbd
@item v
Switch to viewing the outside window configuration
(@code{edebug-view-outside}).  Type @kbd{C-x X w} to return to Edebug.

@item p
Temporarily display the outside current buffer with point at its outside
position (@code{edebug-bounce-point}), pausing for one second before
returning to Edebug.  With a prefix argument @var{n}, pause for @var{n}
seconds instead.

@item w
Move point back to the current stop point in the source code buffer
(@code{edebug-where}).

If you use this command in a different window displaying the same buffer,
that window will be used instead to display the current definition in the
future.

@item W
@c Its function is not simply to forget the saved configuration -- dan
Toggle whether Edebug saves and restores the outside window configuration
(@code{edebug-toggle-save-windows}).

With a prefix argument, @code{W} only toggles saving and restoring of the
selected window.  To specify a window that is not displaying the source code
buffer, you must use @kbd{C-x X W} from the global keymap.
@end table

  You can view the outside window configuration with @kbd{v} or just bounce to
the point in the current buffer with @kbd{p}, even if it is not normally
displayed.

  After moving point, you may wish to jump back to the stop point.  You can do
that with @kbd{w} from a source code buffer.  You can jump back to the stop
point in the source code buffer from any buffer using @kbd{C-x X w}.

  Each time you use @kbd{W} to turn saving @emph{off}, Edebug forgets the
saved outside window configuration---so that even if you turn saving back
@emph{on}, the current window configuration remains unchanged when you next
exit Edebug (by continuing the program).  However, the automatic redisplay
of @file{*edebug*} and @file{*edebug-trace*} may conflict with the buffers
you wish to see unless you have enough windows open.

@node Edebug Eval
@subsection Evaluation

  While within Edebug, you can evaluate expressions as if Edebug were not
running.  Edebug tries to be invisible to the expression's evaluation and
printing.  Evaluation of expressions that cause side effects will work as
expected, except for changes to data that Edebug explicitly saves and
restores.  @xref{The Outside Context}, for details on this process.

@table @kbd
@item e @var{exp} @key{RET}
Evaluate expression @var{exp} in the context outside of Edebug
(@code{edebug-eval-expression}).  That is, Edebug tries to minimize its
interference with the evaluation.

@item M-: @var{exp} @key{RET}
Evaluate expression @var{exp} in the context of Edebug itself
(@code{eval-expression}).

@item C-x C-e
Evaluate the expression before point, in the context outside of Edebug
(@code{edebug-eval-last-sexp}).
@end table

@cindex lexical binding (Edebug)
@c FIXME?  What about lexical-binding = t?
  Edebug supports evaluation of expressions containing references to lexically
bound symbols created by the following constructs in @file{cl.el}:
@code{lexical-let}, @code{macrolet}, and @code{symbol-macrolet}.

@node Eval List
@subsection Evaluation List Buffer

  You can use the @dfn{evaluation list buffer}, called @file{*edebug*}, to
evaluate expressions interactively.  You can also set up the @dfn{evaluation
list} of expressions to be evaluated automatically each time Edebug updates
the display.

@table @kbd
@item E
Switch to the evaluation list buffer @file{*edebug*}
(@code{edebug-visit-eval-list}).
@end table

  In the @file{*edebug*} buffer you can use the commands of Lisp Interaction
mode (@pxref{Lisp Interaction,,, emacs, The GNU Emacs Manual}) as well as
these special commands:

@table @kbd
@item C-j
Evaluate the expression before point, in the outside context, and insert the
value in the buffer (@code{edebug-eval-print-last-sexp}).

@item C-x C-e
Evaluate the expression before point, in the context outside of Edebug
(@code{edebug-eval-last-sexp}).

@item C-c C-u
Build a new evaluation list from the contents of the buffer
(@code{edebug-update-eval-list}).

@item C-c C-d
Delete the evaluation list group that point is in
(@code{edebug-delete-eval-item}).

@item C-c C-w
Switch back to the source code buffer at the current stop point
(@code{edebug-where}).
@end table

  You can evaluate expressions in the evaluation list window with @kbd{C-j} or
@kbd{C-x C-e}, just as you would in @file{*scratch*}; but they are evaluated
in the context outside of Edebug.

  The expressions you enter interactively (and their results) are lost when
you continue execution; but you can set up an @dfn{evaluation list}
consisting of expressions to be evaluated each time execution stops.

@cindex evaluation list group
  To do this, write one or more @dfn{evaluation list groups} in the evaluation
list buffer.  An evaluation list group consists of one or more Lisp
expressions.  Groups are separated by comment lines.

  The command @kbd{C-c C-u} (@code{edebug-update-eval-list}) rebuilds the
evaluation list, scanning the buffer and using the first expression of each
group.  (The idea is that the second expression of the group is the value
previously computed and displayed.)

  Each entry to Edebug redisplays the evaluation list by inserting each
expression in the buffer, followed by its current value.  It also inserts
comment lines so that each expression becomes its own group.  Thus, if you
type @kbd{C-c C-u} again without changing the buffer text, the evaluation
list is effectively unchanged.

  If an error occurs during an evaluation from the evaluation list, the error
message is displayed in a string as if it were the result.  Therefore,
expressions using variables that are not currently valid do not interrupt
your debugging.

  Here is an example of what the evaluation list window looks like after
several expressions have been added to it:

@smallexample
(current-buffer)
#<buffer *scratch*>
;---------------------------------------------------------------
(selected-window)
#<window 16 on *scratch*>
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
@end smallexample

To delete a group, move point into it and type @kbd{C-c C-d}, or simply
delete the text for the group and update the evaluation list with @kbd{C-c
C-u}.  To add a new expression to the evaluation list, insert the expression
at a suitable place, insert a new comment line, then type @kbd{C-c C-u}.
You need not insert dashes in the comment line---its contents don't matter.

After selecting @file{*edebug*}, you can return to the source code buffer
with @kbd{C-c C-w}.  The @file{*edebug*} buffer is killed when you continue
execution, and recreated next time it is needed.

@node Printing in Edebug
@subsection Printing in Edebug

@cindex printing (Edebug)
@cindex printing circular structures
@pindex cust-print
  If an expression in your program produces a value containing circular list
structure, you may get an error when Edebug attempts to print it.

  One way to cope with circular structure is to set @code{print-length} or
@code{print-level} to truncate the printing.  Edebug does this for you; it
binds @code{print-length} and @code{print-level} to the values of the
variables @code{edebug-print-length} and @code{edebug-print-level} (so long
as they have non-@code{nil} values).  @xref{Output Variables}.

@defopt edebug-print-length
If non-@code{nil}, Edebug binds @code{print-length} to this value while
printing results.  The default value is @code{50}.
@end defopt

@defopt edebug-print-level
If non-@code{nil}, Edebug binds @code{print-level} to this value while
printing results.  The default value is @code{50}.
@end defopt

  You can also print circular structures and structures that share elements
more informatively by binding @code{print-circle} to a non-@code{nil} value.

  Here is an example of code that creates a circular structure:

@example
(setq a '(x y))
(setcar a a)
@end example

@noindent
Custom printing prints this as @samp{Result: #1=(#1# y)}.  The @samp{#1=}
notation labels the structure that follows it with the label @samp{1}, and
the @samp{#1#} notation references the previously labeled structure.  This
notation is used for any shared elements of lists or vectors.

@defopt edebug-print-circle
If non-@code{nil}, Edebug binds @code{print-circle} to this value while
printing results.  The default value is @code{t}.
@end defopt

  Other programs can also use custom printing; see @file{cust-print.el} for
details.

@node Trace Buffer
@subsection Trace Buffer
@cindex trace buffer

  Edebug can record an execution trace, storing it in a buffer named
@file{*edebug-trace*}.  This is a log of function calls and returns, showing
the function names and their arguments and values.  To enable trace
recording, set @code{edebug-trace} to a non-@code{nil} value.

  Making a trace buffer is not the same thing as using trace execution mode
(@pxref{Edebug Execution Modes}).

  When trace recording is enabled, each function entry and exit adds lines to
the trace buffer.  A function entry record consists of @samp{::::@{},
followed by the function name and argument values.  A function exit record
consists of @samp{::::@}}, followed by the function name and result of the
function.

  The number of @samp{:}s in an entry shows its recursion depth.  You can use
the braces in the trace buffer to find the matching beginning or end of
function calls.

@findex edebug-print-trace-before
@findex edebug-print-trace-after
  You can customize trace recording for function entry and exit by redefining
the functions @code{edebug-print-trace-before} and
@code{edebug-print-trace-after}.

@defmac edebug-tracing string body@dots{}
This macro requests additional trace information around the execution of the
@var{body} forms.  The argument @var{string} specifies text to put in the
trace buffer, after the @samp{@{} or @samp{@}}.  All the arguments are
evaluated, and @code{edebug-tracing} returns the value of the last form in
@var{body}.
@end defmac

@defun edebug-trace format-string &rest format-args
This function inserts text in the trace buffer.  It computes the text with
@code{(apply 'format @var{format-string} @var{format-args})}.  It also
appends a newline to separate entries.
@end defun

  @code{edebug-tracing} and @code{edebug-trace} insert lines in the trace
buffer whenever they are called, even if Edebug is not active.  Adding text
to the trace buffer also scrolls its window to show the last lines inserted.

@node Coverage Testing
@subsection Coverage Testing

@cindex coverage testing (Edebug)
@cindex frequency counts
@cindex performance analysis
  Edebug provides rudimentary coverage testing and display of execution
frequency.

  Coverage testing works by comparing the result of each expression with the
previous result; each form in the program is considered ``covered'' if it
has returned two different values since you began testing coverage in the
current Emacs session.  Thus, to do coverage testing on your program,
execute it under various conditions and note whether it behaves correctly;
Edebug will tell you when you have tried enough different conditions that
each form has returned two different values.

  Coverage testing makes execution slower, so it is only done if
@code{edebug-test-coverage} is non-@code{nil}.  Frequency counting is
performed for all executions of an instrumented function, even if the
execution mode is Go-nonstop, and regardless of whether coverage testing is
enabled.

@kindex C-x X =
@findex edebug-temp-display-freq-count
  Use @kbd{C-x X =} (@code{edebug-display-freq-count}) to display both the
coverage information and the frequency counts for a definition.  Just
@kbd{=} (@code{edebug-temp-display-freq-count}) displays the same
information temporarily, only until you type another key.

@deffn Command edebug-display-freq-count
This command displays the frequency count data for each line of the current
definition.

It inserts frequency counts as comment lines after each line of code.  You
can undo all insertions with one @code{undo} command.  The counts appear
under the @samp{(} before an expression or the @samp{)} after an expression,
or on the last character of a variable.  To simplify the display, a count is
not shown if it is equal to the count of an earlier expression on the same
line.

The character @samp{=} following the count for an expression says that the
expression has returned the same value each time it was evaluated.  In other
words, it is not yet ``covered'' for coverage testing purposes.

To clear the frequency count and coverage data for a definition, simply
reinstrument it with @code{eval-defun}.
@end deffn

For example, after evaluating @code{(fac 5)} with a source breakpoint, and
setting @code{edebug-test-coverage} to @code{t}, when the breakpoint is
reached, the frequency data looks like this:

@example
(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (< 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
@end example

The comment lines show that @code{fac} was called 6 times.  The first
@code{if} statement returned 5 times with the same result each time; the
same is true of the condition on the second @code{if}.  The recursive call
of @code{fac} did not return at all.


@node The Outside Context
@subsection The Outside Context

Edebug tries to be transparent to the program you are debugging, but it does
not succeed completely.  Edebug also tries to be transparent when you
evaluate expressions with @kbd{e} or with the evaluation list buffer, by
temporarily restoring the outside context.  This section explains precisely
what context Edebug restores, and how Edebug fails to be completely
transparent.

@menu
* Checking Whether to Stop::  When Edebug decides what to do.
* Edebug Display Update::    When Edebug updates the display.
* Edebug Recursive Edit::    When Edebug stops execution.
@end menu

@node Checking Whether to Stop
@subsubsection Checking Whether to Stop

Whenever Edebug is entered, it needs to save and restore certain data before
even deciding whether to make trace information or stop the program.

@itemize @bullet
@item
@code{max-lisp-eval-depth} and @code{max-specpdl-size} are both increased to
reduce Edebug's impact on the stack.  You could, however, still run out of
stack space when using Edebug.

@item
The state of keyboard macro execution is saved and restored.  While Edebug
is active, @code{executing-kbd-macro} is bound to @code{nil} unless
@code{edebug-continue-kbd-macro} is non-@code{nil}.
@end itemize


@node Edebug Display Update
@subsubsection Edebug Display Update

@c This paragraph is not filled, because LaLiberte's conversion script
@c needs an xref to be on just one line.
When Edebug needs to display something (e.g., in trace mode), it saves the
current window configuration from ``outside'' Edebug (@pxref{Window
Configurations}).  When you exit Edebug, it restores the previous window
configuration.

Emacs redisplays only when it pauses.  Usually, when you continue execution,
the program re-enters Edebug at a breakpoint or after stepping, without
pausing or reading input in between.  In such cases, Emacs never gets a
chance to redisplay the ``outside'' configuration.  Consequently, what you
see is the same window configuration as the last time Edebug was active,
with no interruption.

Entry to Edebug for displaying something also saves and restores the
following data (though some of them are deliberately not restored if an
error or quit signal occurs).

@itemize @bullet
@item
@cindex current buffer point and mark (Edebug)
Which buffer is current, and the positions of point and the mark in the
current buffer, are saved and restored.

@item
@cindex window configuration (Edebug)
The outside window configuration is saved and restored if
@code{edebug-save-windows} is non-@code{nil} (@pxref{Edebug Options}).

The window configuration is not restored on error or quit, but the outside
selected window @emph{is} reselected even on error or quit in case a
@code{save-excursion} is active.  If the value of @code{edebug-save-windows}
is a list, only the listed windows are saved and restored.

The window start and horizontal scrolling of the source code buffer are not
restored, however, so that the display remains coherent within Edebug.

@item
The value of point in each displayed buffer is saved and restored if
@code{edebug-save-displayed-buffer-points} is non-@code{nil}.

@item
The variables @code{overlay-arrow-position} and @code{overlay-arrow-string}
are saved and restored, so you can safely invoke Edebug from the recursive
edit elsewhere in the same buffer.

@item
@code{cursor-in-echo-area} is locally bound to @code{nil} so that the cursor
shows up in the window.
@end itemize

@node Edebug Recursive Edit
@subsubsection Edebug Recursive Edit

When Edebug is entered and actually reads commands from the user, it saves
(and later restores) these additional data:

@itemize @bullet
@item
The current match data.  @xref{Match Data}.

@item
The variables @code{last-command}, @code{this-command},
@code{last-command-event}, @code{last-input-event}, @code{last-event-frame},
@code{last-nonmenu-event}, and @code{track-mouse}.  Commands in Edebug do
not affect these variables outside of Edebug.

Executing commands within Edebug can change the key sequence that would be
returned by @code{this-command-keys}, and there is no way to reset the key
sequence from Lisp.

Edebug cannot save and restore the value of @code{unread-command-events}.
Entering Edebug while this variable has a nontrivial value can interfere
with execution of the program you are debugging.

@item
Complex commands executed while in Edebug are added to the variable
@code{command-history}.  In rare cases this can alter execution.

@item
Within Edebug, the recursion depth appears one deeper than the recursion
depth outside Edebug.  This is not true of the automatically updated
evaluation list window.

@item
@code{standard-output} and @code{standard-input} are bound to @code{nil} by
the @code{recursive-edit}, but Edebug temporarily restores them during
evaluations.

@item
The state of keyboard macro definition is saved and restored.  While Edebug
is active, @code{defining-kbd-macro} is bound to
@code{edebug-continue-kbd-macro}.
@end itemize

@node Edebug and Macros
@subsection Edebug and Macros

To make Edebug properly instrument expressions that call macros, some extra
care is needed.  This subsection explains the details.

@menu
* Instrumenting Macro Calls::  The basic problem.
* Specification List::       How to specify complex patterns of evaluation.
* Backtracking::             What Edebug does when matching fails.
* Specification Examples::   To help understand specifications.
@end menu

@node Instrumenting Macro Calls
@subsubsection Instrumenting Macro Calls

  When Edebug instruments an expression that calls a Lisp macro, it needs
additional information about the macro to do the job properly.  This is
because there is no a-priori way to tell which subexpressions of the macro
call are forms to be evaluated.  (Evaluation may occur explicitly in the
macro body, or when the resulting expansion is evaluated, or any time
later.)

  Therefore, you must define an Edebug specification for each macro that
Edebug will encounter, to explain the format of calls to that macro.  To do
this, add a @code{debug} declaration to the macro definition.  Here is a
simple example that shows the specification for the @code{for} example macro
(@pxref{Argument Evaluation}).

@smallexample
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &rest form)))
  ...)
@end smallexample

  The Edebug specification says which parts of a call to the macro are forms
to be evaluated.  For simple macros, the specification often looks very
similar to the formal argument list of the macro definition, but
specifications are much more general than macro arguments.  @xref{Defining
Macros}, for more explanation of the @code{declare} form.

@c See, e.g., http://debbugs.gnu.org/10577
@c FIXME  Maybe there should be an Edebug option to get it to
@c automatically load the entire source file containing the function
@c being instrumented.  That would avoid this.
  Take care to ensure that the specifications are known to Edebug when you
instrument code.  If you are instrumenting a function from a file that uses
@code{eval-when-compile} to require another file containing macro
definitions, you may need to explicitly load that file.

  You can also define an edebug specification for a macro separately from the
macro definition with @code{def-edebug-spec}.  Adding @code{debug}
declarations is preferred, and more convenient, for macro definitions in
Lisp, but @code{def-edebug-spec} makes it possible to define Edebug
specifications for special forms implemented in C.

@defmac def-edebug-spec macro specification
Specify which expressions of a call to macro @var{macro} are forms to be
evaluated.  @var{specification} should be the edebug specification.  Neither
argument is evaluated.

The @var{macro} argument can actually be any symbol, not just a macro name.
@end defmac

Here is a table of the possibilities for @var{specification} and how each
directs processing of arguments.

@table @asis
@item @code{t}
All arguments are instrumented for evaluation.

@item @code{0}
None of the arguments is instrumented.

@item a symbol
The symbol must have an Edebug specification, which is used instead.  This
indirection is repeated until another kind of specification is found.  This
allows you to inherit the specification from another macro.

@item a list
The elements of the list describe the types of the arguments of a calling
form.  The possible elements of a specification list are described in the
following sections.
@end table

If a macro has no Edebug specification, neither through a @code{debug}
declaration nor through a @code{def-edebug-spec} call, the variable
@code{edebug-eval-macro-args} comes into play.

@defopt edebug-eval-macro-args
This controls the way Edebug treats macro arguments with no explicit Edebug
specification.  If it is @code{nil} (the default), none of the arguments is
instrumented for evaluation.  Otherwise, all arguments are instrumented.
@end defopt

@node Specification List
@subsubsection Specification List

@cindex Edebug specification list
A @dfn{specification list} is required for an Edebug specification if some
arguments of a macro call are evaluated while others are not.  Some elements
in a specification list match one or more arguments, but others modify the
processing of all following elements.  The latter, called @dfn{specification
keywords}, are symbols beginning with @samp{&} (such as @code{&optional}).

A specification list may contain sublists, which match arguments that are
themselves lists, or it may contain vectors used for grouping.  Sublists and
groups thus subdivide the specification list into a hierarchy of levels.
Specification keywords apply only to the remainder of the sublist or group
they are contained in.

When a specification list involves alternatives or repetition, matching it
against an actual macro call may require backtracking.  For more details,
@pxref{Backtracking}.

Edebug specifications provide the power of regular expression matching, plus
some context-free grammar constructs: the matching of sublists with balanced
parentheses, recursive processing of forms, and recursion via indirect
specifications.

Here's a table of the possible elements of a specification list, with their
meanings (see @ref{Specification Examples}, for the referenced examples):

@table @code
@item sexp
@c an "expression" is not necessarily intended for evaluation.
A single unevaluated Lisp object, which is not instrumented.

@item form
A single evaluated expression, which is instrumented.

@item place
A generalized variable.  @xref{Generalized Variables}.

@item body
Short for @code{&rest form}.  See @code{&rest} below.

@item function-form
A function form: either a quoted function symbol, a quoted lambda
expression, or a form (that should evaluate to a function symbol or lambda
expression).  This is useful when an argument that's a lambda expression
might be quoted with @code{quote} rather than @code{function}, since it
instruments the body of the lambda expression either way.

@item lambda-expr
A lambda expression with no quoting.

@item &optional
@c @kindex &optional @r{(Edebug)}
All following elements in the specification list are optional; as soon as
one does not match, Edebug stops matching at this level.

To make just a few elements optional, followed by non-optional elements, use
@code{[&optional @var{specs}@dots{}]}.  To specify that several elements
must all match or none, use @code{&optional [@var{specs}@dots{}]}.  See the
@code{defun} example.

@item &rest
@c @kindex &rest @r{(Edebug)}
All following elements in the specification list are repeated zero or more
times.  In the last repetition, however, it is not a problem if the
expression runs out before matching all of the elements of the specification
list.

To repeat only a few elements, use @code{[&rest @var{specs}@dots{}]}.  To
specify several elements that must all match on every repetition, use
@code{&rest [@var{specs}@dots{}]}.

@item &or
@c @kindex &or @r{(Edebug)}
Each of the following elements in the specification list is an alternative.
One of the alternatives must match, or the @code{&or} specification fails.

Each list element following @code{&or} is a single alternative.  To group
two or more list elements as a single alternative, enclose them in
@code{[@dots{}]}.

@item &not
@c @kindex &not @r{(Edebug)}
Each of the following elements is matched as alternatives as if by using
@code{&or}, but if any of them match, the specification fails.  If none of
them match, nothing is matched, but the @code{&not} specification succeeds.

@c FIXME &key?

@item &define
@c @kindex &define @r{(Edebug)}
Indicates that the specification is for a defining form.  The defining form
itself is not instrumented (that is, Edebug does not stop before and after
the defining form), but forms inside it typically will be instrumented.  The
@code{&define} keyword should be the first element in a list specification.

@item nil
This is successful when there are no more arguments to match at the current
argument list level; otherwise it fails.  See sublist specifications and the
backquote example.

@item gate
@cindex preventing backtracking
No argument is matched but backtracking through the gate is disabled while
matching the remainder of the specifications at this level.  This is
primarily used to generate more specific syntax error messages.  See
@ref{Backtracking}, for more details.  Also see the @code{let} example.

@item @var{other-symbol}
@cindex indirect specifications
Any other symbol in a specification list may be a predicate or an indirect
specification.

If the symbol has an Edebug specification, this @dfn{indirect specification}
should be either a list specification that is used in place of the symbol,
or a function that is called to process the arguments.  The specification
may be defined with @code{def-edebug-spec} just as for macros.  See the
@code{defun} example.

Otherwise, the symbol should be a predicate.  The predicate is called with
the argument, and if the predicate returns @code{nil}, the specification
fails and the argument is not instrumented.

Some suitable predicates include @code{symbolp}, @code{integerp},
@code{stringp}, @code{vectorp}, and @code{atom}.

@item [@var{elements}@dots{}]
@cindex [@dots{}] (Edebug)
A vector of elements groups the elements into a single @dfn{group
specification}.  Its meaning has nothing to do with vectors.

@item "@var{string}"
The argument should be a symbol named @var{string}.  This specification is
equivalent to the quoted symbol, @code{'@var{symbol}}, where the name of
@var{symbol} is the @var{string}, but the string form is preferred.

@item (vector @var{elements}@dots{})
The argument should be a vector whose elements must match the @var{elements}
in the specification.  See the backquote example.

@item (@var{elements}@dots{})
Any other list is a @dfn{sublist specification} and the argument must be a
list whose elements match the specification @var{elements}.

@cindex dotted lists (Edebug)
A sublist specification may be a dotted list and the corresponding list
argument may then be a dotted list.  Alternatively, the last @sc{cdr} of a
dotted list specification may be another sublist specification (via a
grouping or an indirect specification, e.g., @code{(spec .  [(more
specs@dots{})])}) whose elements match the non-dotted list arguments.  This
is useful in recursive specifications such as in the backquote example.
Also see the description of a @code{nil} specification above for terminating
such recursion.

Note that a sublist specification written as @code{(specs .  nil)} is
equivalent to @code{(specs)}, and @code{(specs .
(sublist-elements@dots{}))} is equivalent to @code{(specs
sublist-elements@dots{})}.
@end table

@c Need to document extensions with &symbol and :symbol

Here is a list of additional specifications that may appear only after
@code{&define}.  See the @code{defun} example.

@table @code
@item name
The argument, a symbol, is the name of the defining form.

A defining form is not required to have a name field; and it may have
multiple name fields.

@item :name
This construct does not actually match an argument.  The element following
@code{:name} should be a symbol; it is used as an additional name component
for the definition.  You can use this to add a unique, static component to
the name of the definition.  It may be used more than once.

@item arg
The argument, a symbol, is the name of an argument of the defining form.
However, lambda-list keywords (symbols starting with @samp{&})  are not
allowed.

@item lambda-list
@cindex lambda-list (Edebug)
This matches a lambda list---the argument list of a lambda expression.

@item def-body
The argument is the body of code in a definition.  This is like @code{body},
described above, but a definition body must be instrumented with a different
Edebug call that looks up information associated with the definition.  Use
@code{def-body} for the highest level list of forms within the definition.

@item def-form
The argument is a single, highest-level form in a definition.  This is like
@code{def-body}, except it is used to match a single form rather than a list
of forms.  As a special case, @code{def-form} also means that tracing
information is not output when the form is executed.  See the
@code{interactive} example.
@end table

@node Backtracking
@subsubsection Backtracking in Specifications

@cindex backtracking
@cindex syntax error (Edebug)
If a specification fails to match at some point, this does not necessarily
mean a syntax error will be signaled; instead, @dfn{backtracking} will take
place until all alternatives have been exhausted.  Eventually every element
of the argument list must be matched by some element in the specification,
and every required element in the specification must match some argument.

When a syntax error is detected, it might not be reported until much later,
after higher-level alternatives have been exhausted, and with the point
positioned further from the real error.  But if backtracking is disabled
when an error occurs, it can be reported immediately.  Note that
backtracking is also reenabled automatically in several situations; when a
new alternative is established by @code{&optional}, @code{&rest}, or
@code{&or}, or at the start of processing a sublist, group, or indirect
specification.  The effect of enabling or disabling backtracking is limited
to the remainder of the level currently being processed and lower levels.

Backtracking is disabled while matching any of the form specifications (that
is, @code{form}, @code{body}, @code{def-form}, and @code{def-body}).  These
specifications will match any form so any error must be in the form itself
rather than at a higher level.

Backtracking is also disabled after successfully matching a quoted symbol or
string specification, since this usually indicates a recognized construct.
But if you have a set of alternative constructs that all begin with the same
symbol, you can usually work around this constraint by factoring the symbol
out of the alternatives, e.g., @code{["foo" &or [first case] [second case]
...]}.

Most needs are satisfied by these two ways that backtracking is
automatically disabled, but occasionally it is useful to explicitly disable
backtracking by using the @code{gate} specification.  This is useful when
you know that no higher alternatives could apply.  See the example of the
@code{let} specification.

@node Specification Examples
@subsubsection Specification Examples

It may be easier to understand Edebug specifications by studying the
examples provided here.

A @code{let} special form has a sequence of bindings and a body.  Each of
the bindings is either a symbol or a sublist with a symbol and optional
expression.  In the specification below, notice the @code{gate} inside of
the sublist to prevent backtracking once a sublist is found.

@ignore
@c FIXME?  The actual definition in edebug.el looks like this (and always
@c has AFAICS).  In fact, nothing in edebug.el uses gate.  So maybe
@c this is just an example for illustration?
(def-edebug-spec let
  ((&rest
    &or (symbolp &optional form) symbolp)
   body))
@end ignore
@example
(def-edebug-spec let
  ((&rest
    &or symbolp (gate symbolp &optional form))
   body))
@end example

Edebug uses the following specifications for @code{defun} and the associated
argument list and @code{interactive} specifications.  It is necessary to
handle interactive forms specially since an expression argument is actually
evaluated outside of the function body.  (The specification for
@code{defmacro} is very similar to that for @code{defun}, but allows for the
@code{declare} statement.)

@smallexample
(def-edebug-spec defun
  (&define name lambda-list
           [&optional stringp]   ; @r{Match the doc string, if present.}
           [&optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&rest arg]
    [&optional ["&optional" arg &rest arg]]
    &optional ["&rest" arg]
    )))

(def-edebug-spec interactive
  (&optional &or stringp def-form))    ; @r{Notice: @code{def-form}}
@end smallexample

The specification for backquote below illustrates how to match dotted lists
and use @code{nil} to terminate recursion.  It also illustrates how
components of a vector may be matched.  (The actual specification defined by
Edebug is a little different, and does not support dotted lists because
doing so causes very deep recursion that could fail.)

@smallexample
(def-edebug-spec \` (backquote-form))   ; @r{Alias just for clarity.}

(def-edebug-spec backquote-form
  (&or ([&or "," ",@@"] &or ("quote" backquote-form) form)
       (backquote-form . [&or nil backquote-form])
       (vector &rest backquote-form)
       sexp))
@end smallexample


@node Edebug Options
@subsection Edebug Options

@c Previously defopt'd:
@c edebug-sit-for-seconds, edebug-print-length, edebug-print-level
@c edebug-print-circle, edebug-eval-macro-args
  These options affect the behavior of Edebug:

@defopt edebug-setup-hook
Functions to call before Edebug is used.  Each time it is set to a new
value, Edebug will call those functions once and then reset
@code{edebug-setup-hook} to @code{nil}.  You could use this to load up
Edebug specifications associated with a package you are using, but only when
you also use Edebug.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-defs
If this is non-@code{nil}, normal evaluation of defining forms such as
@code{defun} and @code{defmacro} instruments them for Edebug.  This applies
to @code{eval-defun}, @code{eval-region}, @code{eval-buffer}, and
@code{eval-current-buffer}.

Use the command @kbd{M-x edebug-all-defs} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-forms
If this is non-@code{nil}, the commands @code{eval-defun},
@code{eval-region}, @code{eval-buffer}, and @code{eval-current-buffer}
instrument all forms, even those that don't define anything.  This doesn't
apply to loading or evaluations in the minibuffer.

Use the command @kbd{M-x edebug-all-forms} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-save-windows
If this is non-@code{nil}, Edebug saves and restores the window
configuration.  That takes some time, so if your program does not care what
happens to the window configurations, it is better to set this variable to
@code{nil}.

If the value is a list, only the listed windows are saved and restored.

You can use the @kbd{W} command in Edebug to change this variable
interactively.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-save-displayed-buffer-points
If this is non-@code{nil}, Edebug saves and restores point in all displayed
buffers.

Saving and restoring point in other buffers is necessary if you are
debugging code that changes the point of a buffer that is displayed in a
non-selected window.  If Edebug or the user then selects the window, point
in that buffer will move to the window's value of point.

Saving and restoring point in all buffers is expensive, since it requires
selecting each window twice, so enable this only if you need it.
@xref{Edebug Display Update}.
@end defopt

@defopt edebug-initial-mode
If this variable is non-@code{nil}, it specifies the initial execution mode
for Edebug when it is first activated.  Possible values are @code{step},
@code{next}, @code{go}, @code{Go-nonstop}, @code{trace}, @code{Trace-fast},
@code{continue}, and @code{Continue-fast}.

The default value is @code{step}.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-trace
If this is non-@code{nil}, trace each function entry and exit.  Tracing
output is displayed in a buffer named @file{*edebug-trace*}, one function
entry or exit per line, indented by the recursion level.

Also see @code{edebug-tracing}, in @ref{Trace Buffer}.
@end defopt

@defopt edebug-test-coverage
If non-@code{nil}, Edebug tests coverage of all expressions debugged.
@xref{Coverage Testing}.
@end defopt

@defopt edebug-continue-kbd-macro
If non-@code{nil}, continue defining or executing any keyboard macro that is
executing outside of Edebug.  Use this with caution since it is not
debugged.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-unwrap-results
If non-@code{nil}, Edebug tries to remove any of its own instrumentation
when showing the results of expressions.  This is relevant when debugging
macros where the results of expressions are themselves instrumented
expressions.  As a very artificial example, suppose that the example
function @code{fac} has been instrumented, and consider a macro of the form:

@c FIXME find a less silly example.
@smallexample
(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      @dots{}))
@end smallexample

If you instrument the @code{test} macro and step through it, then by default
the result of the @code{symbol-function} call has numerous
@code{edebug-after} and @code{edebug-before} forms, which can make it
difficult to see the ``actual'' result.  If @code{edebug-unwrap-results} is
non-@code{nil}, Edebug tries to remove these forms from the result.
@end defopt

@defopt edebug-on-error
Edebug binds @code{debug-on-error} to this value, if @code{debug-on-error}
was previously @code{nil}.  @xref{Trapping Errors}.
@end defopt

@defopt edebug-on-quit
Edebug binds @code{debug-on-quit} to this value, if @code{debug-on-quit} was
previously @code{nil}.  @xref{Trapping Errors}.
@end defopt

@c Not necessarily a deeper command level.
@c A new command is not precisely true, but that is close enough -- dan
  If you change the values of @code{edebug-on-error} or @code{edebug-on-quit}
while Edebug is active, their values won't be used until the @emph{next}
time Edebug is invoked via a new command.

@defopt edebug-global-break-condition
If non-@code{nil}, an expression to test for at every stop point.  If the
result is non-@code{nil}, then break.  Errors are ignored.  @xref{Global
Break Condition}.
@end defopt
