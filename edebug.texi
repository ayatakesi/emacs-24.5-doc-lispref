@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@comment -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1992-1994, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@c This file can also be used by an independent Edebug User
@c Manual in which case the Edebug node below should be used
@c with the following links to the Bugs section and to the top level:

@c , Bugs and Todo List, Top, Top

@node Edebug
@section Edebug
@cindex Edebug debugging facility

  EdebugはEmacs Lispプログラムにたいするソースレベルデバッガです。これにより、以下のことができます:

@itemize @bullet
@item
式の前や後でストップして、評価をステップで実行する。

@item
条件付き、または無条件のbreakpointのセット。

@item
指定された条件がtrueのときにストップする(グローバルbreakpoint)。

@item
ストップポイントごとに停止したり、breakpointごとに簡単に停止して、低速または高速にトレースを行う。

@item
Edebug外部であるかのように、式の結果を表示し、式を評価する。

@item
式のリストを自動的に再評価して、Edebugがディスプレイを更新するたびにそれらの結果を表示する。

@item
関数呼び出しとリターンのトレース情報を出力する。

@item
エラー発生時にストップする。

@item
Edebug自身のフレームを除外してbacktraceを表示する。

@item
マクロおよびフォームの定義で引数の評価を指定する。

@item
初歩的なカバレッジテストと頻度数の取得。
@end itemize

以下の初めの3つのセクションは、使用を開始するためにEdebugについて十分説明します。

@menu
* Using Edebug::             Edebug使用のための手引き。
* Instrumenting::            Edebugでデバッグするために、コードをインストルメント(計装)しなければならないe
* Modes: Edebug Execution Modes.  多かれ少なかれ、ストップする実行モード。
* Jumping::                  特定の位置にジャンプするコマンド。
* Misc: Edebug Misc.         さまざまなコマンド。
* Breaks::                   プログラムをストップさせるbreakpointのセット。
* Trapping Errors::          Edebugでのエラーのトラップ。
* Views: Edebug Views.       Edebugの内側と外側のビュー。
* Eval: Edebug Eval.         Edebugでの式の評価。
* Eval List::                Edebugにエンターするたびに値が表示される式。
* Printing in Edebug::       プリントのカスタマイズ。
* Trace Buffer::             バッファー内で採れを生成する方法。
* Coverage Testing::         評価をカバレッジテストする方法。
* The Outside Context::      Edebugが保存およびリストアするデータ。
* Edebug and Macros::        マクロ呼び出しをハンドルする方法の指定。
* Options: Edebug Options.   Edebugをカスタマイズするオプション変数。
@end menu

@node Using Edebug
@subsection Using Edebug

  EdebugでLispプログラムをデバッグするには、最初にデバッグしたいLispコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。これを行なうもっともシンプルな方法は、関数またはマクロの定義に移動して、@kbd{C-u
C-M-x}(プレフィクス引数を指定した@code{eval-defun})を行います。コードをインストルメントする他の手段については、@ref{Instrumenting}を参照してください。

  一度関数をインストルメントすると、その関数にたいする任意の呼び出しにより、Edebugがアクティブになります。Edebugがアクティブになると、どのEdebug実行モードを選択したかに依存して、その関数をステップ実行できるように実行がストップされるか、ディスプレイを更新してデバッグコマンドにたいするチェックの間、実行が継続されます。デフォルトの実行モードstepで、これは実行をストップします。@ref{Edebug
Execution Modes}を参照してください。

  Edebugでは通常、デバッグしているLispコードをEmacsバッファーで閲覧します。これを@dfn{ソースコードバッファー(source code
buffer)}と呼び、バッファーは一時的に読み取り専用になります。

  左フリンジの矢印は、その関数で実行されている行を示します。最初ポイントはその関数の実行されている行にありますが、ポイントを移動するとこれは真ではなくなります。

  以下は、@code{fac}の定義(以下を参照)をインストルメントして@code{(fac
3)}を実行した場合に通常目にするものです。ポイントは、@code{if}の前の開きカッコにあります。

@example
(defun fac (n)
=>@point{}(if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

@cindex stop points
関数内でEdebugが実行をストップできる位置のことを、@dfn{ストップポイント(stop
points)}と呼びます。ストップポイントは、リストであるような部分式の前後、および変数参照の後でも発生します。以下は、関数@code{fac}内のストップポイントをピリオドで示したものです:

@example
(defun fac (n)
  .(if .(< 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
@end example

Emacs
Lispモードのコマンドに加えて、ソースコードバッファーでは、Edebugのスペシャルコマンドが利用できます。たとえば、Edebugコマンド@key{SPC}で次のストップポイントまで実行することができます。@code{fac}にエントリーした後に一度@code{fac}とタイプした場合は、以下のように表示されるでしょう:

@example
(defun fac (n)
=>(if @point{}(< 0 n)
      (* n (fac (1- n)))
    1))
@end example

式の後でEdebugが実行をストップしたときは、エコーエリアにその式の値が表示されます。

他にも頻繁に使用されるコマンドとして、ストップポイントにbreakpointをセットする@kbd{b}、breakpointに達するまで実行する@kbd{g}、Edebugをexitしてトップレベルのコマンドループにリターンする@kbd{q}があります。また、@kbd{?}とタイプするとすべてのEdebugコマンドがリストされます。

@node Instrumenting
@subsection Instrumenting for Edebug
@cindex instrumenting for Edebug

  LispコードのデバッグにEdebugを使用するためには、最初にそのコードを@dfn{インストルメント(instrument:
計装)}しなければなりません。コードをインストルメントすると、適切な位置でEdebugを呼び出すために追加コードが挿入されます。

@kindex C-M-x
@findex eval-defun (Edebug)
  関数定義でプレフィクス引数とともにコマンド@kbd{C-M-x}
(@code{eval-defun})を呼び出すと、それを評価する前にその定義をインストルメントします。(ソースコード自体は変更しません。)
変数@code{edebug-all-defs}が非@code{nil}の場合は、プレフィクス引数の意味を反転します。この場合、@kbd{C-M-x}はプレフィクス引数が@emph{なければ}その定義をインストルメントします。@code{edebug-all-defs}のデフォルト値は@code{nil}です。コマンド@kbd{M-x
edebug-all-defs}は、変数@code{edebug-all-defs}の値を切り替えます。

@findex eval-region @r{(Edebug)}
@findex eval-buffer @r{(Edebug)}
@findex eval-current-buffer @r{(Edebug)}
  @code{edebug-all-defs}が非@code{nil}の場合は@code{eval-region}、@code{eval-current-buffer}、@code{eval-buffer}も、それらが評価する定義をインストルメントします。同様に、@code{edebug-all-forms}は、@code{eval-region}が(非定義フォームさえ含む）@emph{あらゆる}フォームをインストルメントすべきかを制御します。これはミニバッファー内でのロードや評価には適用されません。コマンド@kbd{M-x
edebug-all-forms}は、このオプションを切り替えます。

@findex edebug-eval-top-level-form
@findex edebug-defun
  他にもコマンド@kbd{M-x
edebug-eval-top-level-form}が利用可能で、これは@code{edebug-all-defs}や@code{edebug-all-forms}の値に関わらず、トップレベルの任意のフォームをインストルメントします。@code{edebug-defun}は@code{edebug-eval-top-level-form}のエイリアスです。

  Edebugがアクティブのの間、コマンド@kbd{I}(@code{edebug-instrument-callee})は、ポイント後のリストフォームに呼び出される関数およびマクロ定義がまだインストルメントされていなければ、それらをインストルメントします。これは、そのファイルのソースの場所をEdebugが知っている場合だけ可能です。この理由によりEdebugロード後は、たとえ評価する定義をインストルメントしない場合でも、@code{eval-region}は評価するすべての定義の位置を記録します。インストルメント済み関数呼び出しにステップインする@kbd{i}コマンド(@ref{Jumping}を参照)も参照してください。

  Edebugはすべての標準スペシャルフォーム、式引数をもつ@code{interactive}フォーム、無名ラムダ式、およびその他の定義フォームのインストルメント方法を知っています。しかし、Edebugはユーザー定義マクロが引数にたいして何を行うかを判断できないので、Edebug仕様を使用してその情報を与えなければなりません。詳細は@ref{Edebug
and Macros}を参照してください。

  Edebugがセッション内で最初にコードをインストルメントしようとするときは、フック@code{edebug-setup-hook}を実行してから、それに@code{nil}をセットします。使おうとしているパッケージに結びつけてEdebug仕様をロードするためにこれを使用できますが、それはEdebugを使用するときだけ機能します。

@findex eval-expression @r{(Edebug)}
  定義からインストルメントを削除するには、単にインストルメントを行わない方法でその定義を再評価するだけです。フォームを絶対にインストルメントせずに評価するには、2つの方法があります。それはファイルからの@code{load}による評価と、ミニバッファーからの@code{eval-expression}(@kbd{M-:})による評価です。

@c FIXME?  I can't see that it "leaves point at the erroneous code".
  Edebugがインストルメント中にシンタックスエラー(syntax error:
構文エラー)を検知した場合は、間違ったコードの箇所にポイントを残して@code{invalid-read-syntax}エラーをシグナルします。

  Edebug内で利用可能な他の評価関数については、@ref{Edebug Eval}を参照してください。

@node Edebug Execution Modes
@subsection Edebug Execution Modes

@cindex Edebug execution modes
Edebugは、デバッグするプログラムの実行にたいして、いくつかの実行モードをサポートします。これらの実行モードを、@dfn{Edebug実行モード(Edebug
execution
modes)}と呼びます。これらをメジャーモードやマイナーモードと混同しないでください。カレントのEdebug実行モードは、プログラムをストップする前にEdebugがどれだけ実行を継続するか
--- たとえばストップポイントごとにストップ、あるいは次のbreakpointまで継続など ---
と、ストップする前にEdebugがどれだけ進捗を表示するかを決定します。

Edebug実行モードは通常、ある特定のモードでプログラムを継続させるコマンドをタイプすることにより指定します。以下は、それらのコマンドのテーブルです。プログラムの実行を再開@kbd{S}以外は、少なくともある長さの間だけ実行を継続します。

@table @kbd
@item S
@c FIXME Does not work. http://debbugs.gnu.org/9764
Stop(ストップ): これ以上プログラムを実行しないで、Edebugのコマンドを待つ(@code{edebug-stop})。

@item @key{SPC}
Step(ステップ): 次のストップポイントでストップする(@code{edebug-step-mode})。

@item n
Next(次へ):
式の後にある次のストップポイントでストップする(@code{edebug-next-mode})。@ref{Jumping}の@code{edebug-forward-sexp}も参照。

@item t
Trace(トレース): Edebugのストップポイントごとにpause(通常は1秒)する(@code{edebug-trace-mode})。

@item T
Rapid
trace(高速でトレース):ストップポイントごとに表示を更新するが、実際にpauseはしない(@code{edebug-Trace-fast-mode})。

@item g
Go(進む): 次のbreakpointまで実行する(@code{edebug-go-mode})。@ref{Breakpoints}を参照。

@item c
Continue(継続): breakpointごとにpauseしてから継続する(@code{edebug-continue-mode})。

@item C
Rapid continue(高速で継続):
ポイントを各breakpointへ移動するが、pauseしない(@code{edebug-Continue-fast-mode})。

@item G
Go non-stop(ストップせず進む):
breakpointを無視する(@code{edebug-Go-nonstop-mode})。まだ@kbd{S}、またはその他の編集コマンドでプログラムをストップするのは可能。
@end table

一般的に、上記リストの最初のほうにある実行モードは後のほうの実行モードに比べて、プログラムをより低速に実行、またはすぐにストップさせます。

実行中、またはトレース中は、任意のEdebugコマンドをタイプすることにより、実行をインタラプト(interrupt:
中断、割り込み)できます。Edebugは次のストップポイントでプログラムをストップしてから、タイプされたコマンドを実行します。たとえば、実行中に@kbd{t}をタイプすると、次のストップポイントでトレースモードに切り替えます。@kbd{S}を使用すれば、他に何も行わずに実行をストップできます。

関数でたまたま読み取り入力が発生した場合には、実行のインタラプトを意図してタイプされた文字は、かわりにその関数により読み取られます。そのプログラムが入力を欲するタイミングに注意を払うことで、そのような意図せぬ結果を避けることができます。

@cindex keyboard macros (Edebug)
このセクションのコマンドを含むキーボードマクロは、完全には機能しません。プログラムを再開するためにEdebugからexitすると、キーボードマクロの追跡記録は失われます。これを処理するのは、簡単ではありません。またEdebug外部でキーボードマクロを定義または実行しても、Edebug内部のコマンドに影響しません。通常これは利点です。@ref{Edebug
Options}内の@code{edebug-continue-kbd-macro}オプションも参照してください。

新たなEdebugレベルにエンターしたとき、初期の実行モードは変数@code{edebug-initial-mode}の値により与えられます(@ref{Edebug
Options}を参照)。デフォルトでこれはstepモードを指定します。たとえば１つのコマンドからインストルメント済みの関数が複数回呼び出された場合は、同じEdebugレベルに再エンターするかもしれないことに注意してください。

@defopt edebug-sit-for-seconds
このオプションは、traceモードおよびcontinueモードで実行ステップの間を何秒待つか指定します。デフォルトは1秒です。
@end defopt

@node Jumping
@subsection Jumping

  このセクションで説明するコマンドは、指定された場所に達するまで実行を続けます。@kbd{i}を除くすべてのコマンドは、ストップ場所を確立するために一時的なbreakpointを作成してから、goモードにスイッチします。意図されたストップポイントの前にある他のストップポイントに達した場合も、実行はストップします。breakpointの詳細は、@ref{Breakpoints}を参照してください。

  これらのコマンドは、非ローカルexitの場合はプログラムのストップを期待する一時的なbreakpointをバイパスできるので、期待どおり機能しないかもしれません。

@table @kbd
@item h
ポイントがある場所の近くのストップポイントへ実行を進める(@code{edebug-goto-here})。

@item f
プログラムの式を1つ分実行する(@code{edebug-forward-sexp})。

@item o
sexpを含む終端までプログラムを実行する(@code{edebug-step-out})。

@item i
ポイントの後のフォームから呼び出された関数またはマクロにステップインする(@code{edebug-step-in})。
@end table

@kbd{h}コマンドは一時的なbreakpointを使用して、ポイントのカレント位置、またはその後のストップポイントまで処理を進めます。

@kbd{f}コマンドは式を1つ飛び越してプログラムを実家します。より正確には、@code{forward-sexp}により到達できる位置に一時的なbreakpointをセットしてからgoモードで実行するので、プログラムはそのbreakpointでストップすることになります。

プレフィクス引数@var{n}とともに使用した場合は、ポイントから@var{n}個のsexp(s-expression:
S式)を超えた場所に一時的なbreakpointをセットします。ポイントを含むリストが@var{n}より少ない要素で終わるような場合は、ストップ箇所はポイントが含まれる式の後になります。

@code{forward-sexp}が見つける位置と、プログラムを実際にストップさせたい位置なのかチェックしなければなりません。たとえば@code{cond}内では、これは正しくないかもしれません。

@kbd{f}コマンドは柔軟性を与えるために、@code{forward-sexp}をストップポイントではなく、ポイント位置から開始します。@emph{カレントのストップポイント}から1つの式を実行したい場合は、まずそこにポイントを移動するために@kbd{w}(@code{edebug-where})をタイプして、それから@kbd{f}をタイプしてください。

@kbd{o}コマンドは、式の``外側''で実行を継続します。これは、ポイントを含む式の最後に一時的なbreakpointを配します。ポイントを含むsexpが関数定義の場合、@kbd{o}はその定義内の最後のsexpの直前まで実行を継続します。もし定義内の最後のsexpの直前にポイントがある場合は、その関数からリターンしてからストップします。他の言い方をすると、このコマンドは最後のsexpの後にポイントがない場合は、カレントで実行中の関数からexitしません。

@kbd{i}コマンドは、ポイントの後のリストフォームに呼び出された関数、またはマクロにステップインします。そのフォームは、評価されようとしているもの1つである必要はないことに注意してください。しかし、そのフォームが評価されようとしている関数呼び出しの場合は、引数が何も評価されないうちにこのコマンドを使用しないと、遅すぎることを覚えておいてください。

@kbd{i}コマンドは、ステップインしようとしている関数またはマクロがまだインストルメントされていない場合は、それらをインストルメントします。これは便利かもしれませんが、それらを明示的に非インストルメントしない場合、その関数またはマクロはインストルメントされたままになることを覚えておいてください。

@node Edebug Misc
@subsection Miscellaneous Edebug Commands

  ここでは、その他のEdebugコマンドを説明します。

@table @kbd
@item ?
Edebugのヘルプメッセージを表示する(@code{edebug-help})。

@item C-]
1レベルを中断して以前のコマンドレベルへ戻る(@code{abort-recursive-edit})。

@item q
エディターのトップレベルのコマンドループにリターンする(@code{top-level})。これは、すべてのレベルのEdebugアクティビティを含む、すべての再帰編集レベルをexitする。しかし、フォーム@code{unwind-protect}または@code{condition-case}で保護されたインストルメント済みのコードはデバッグを再開するかもしれない。

@item Q
@kbd{q}と同様だが、保護されたコードでもストップしない(@code{edebug-top-level-nonstop})。

@item r
エコーエリアに、もっとも最近の既知のコマンドを再表示する(@code{edebug-previous-result})。

@item d
backtraceを表示するが、明確であるようにEdebug自身の関数は除外される(@code{edebug-backtrace})。

Edebugのbacktraceバッファーでは、標準デバッガ内のようにバッガコマンドは使用できない。

実行を継続したとき、backtraceバッファーは自動的にkillされる。
@end table

Edebugから再帰的にEdebugをアクティブにするコマンドを呼び出すことができます。Edebugがアクティブなときは常に、@kbd{q}によトップレベルの終了、または@kbd{C-]}による再帰編集1レベルの中断ができます。@kbd{d}により、すべての未解決な評価のbacktraceを表示できます。

@node Breaks
@subsection Breaks

Edebugのstepモードは、次のストップポイントに達したときに、実行をストップします。一度開始されたEdebugの実行をストップするには、他に3つの方法があります。それはbreakpoint、グローバルbreak条件、およびソースbreakpointです。

@menu
* Breakpoints::              ストップポイントのbreakpoint。
* Global Break Condition::   イベントによるbreak。
* Source Breakpoints::       ソースコードに埋め込まれたbreakpoint。
@end menu

@node Breakpoints
@subsubsection Edebug Breakpoints

@cindex breakpoints (Edebug)
Edebugを使用しているときは、テスト中のプログラム内に@dfn{breakpoint}を指定できます。breakpointとは、実行がストップされる場所のことです。@ref{Using
Edebug}で定義されている任意のストップポイントに、breakpointをセットできます。breakpointをセットおよび解除において影響を受けるストップポイントは、ソースコードバッファー内でポイント位置、またはポイント位置の後の最初のストップポイントです。以下はEdebugのbreakpoint用のコマンドです:

@table @kbd
@item b
ポイント位置、またはポイント位置の後のストップポイントに、breakpointをセットする(@code{edebug-set-breakpoint})。プレフィクス引数を使用した場合、それは一時的なbreakpointになり、プログラムが最初にそこで停止したとき解除される。

@item u
(もしあれば)ポイント位置、またはポイント位置の後のストップポイントにあるbreakpointを解除(unset)する(@code{edebug-unset-breakpoint})。

@item x @var{condition} @key{RET}
@var{condition}を評価して非@code{nil}値になる場合だけプログラムをストップする、条件付きbreakpointをセットする(@code{edebug-set-conditional-breakpoint})。プレフィクス引数を指定した場合は、一時的なbreakpointになる。

@item B
カレント定義内の、次のbreakpointにポイントを移動する(@code{edebug-next-breakpoint})。
@end table

Edebug内では、@kbd{b}でbreakpointをセットして、@kbd{u}でそれを解除できます。最初に望ましいストップポイントにポイントを移動してから、そこにbreakpointをセットまたは解除するために@kbd{b}または@kbd{u}をタイプしますbreakpointがない場所でbreakpointを解除しても、影響はありません。

ある定義を再評価、または再インストルメントすると、以前のbreakpointはすべて削除されます。

@dfn{条件付きbreakpoint(conditional
breakpoint)}は、プログラムがそこに達するたびに条件をテストします。条件を評価した結果エラーが発生した場合、エラーは無視され結果は@code{nil}になります。条件付きbreakpointをセットするには@kbd{x}を使用して、ミニバッファーで条件式を指定します。以前にセットされた条件付きbreakpointがあるストップポイントに条件付きbreakpointをセットすると、以前の条件式がミニバッファーに配されるので、それを編集できます。

プレフィクス引数を指定してbreakpointをセットするコマンドを使用することにより、@dfn{一時的}な条件付きbreakpoint、および無条件のbreakpointを作成できます。一時的なbreakpointによりプログラムがストップしたとき、そのbreakpointは自動的に解除されます。

Go-nonstopモードを除き、Edebugは常にbreakpointでストップ、またはpauseします。Go-nonstopモードでは、breakpointは完全に無視されます。

breakpointがどこにあるか探すには、@kbd{B}コマンドを使用します。このコマンドは同じ関数内から、ポイント以降にある次のbreakpoint(ポイント以降にbreakpointが存在しない場合は最初のbreakpoint)にポイントを移動します。このコマンドは実行を継続せず、単にバッファー内のポイントを移動します。

@node Global Break Condition
@subsubsection Global Break Condition

@cindex stopping on events
@cindex global break condition
  @dfn{グローバルbreak条件(global break
condition)}は指定された条件が満たされたとき、それがどこで発生したかによらず、実行をストップします。Edebugは、すべてのストップポイントでグローバルbreak条件を評価します。これが非@code{nil}値に評価された場合は、あたかもそのストップポイントにbreakpointがあったかのように、実行をストップまたはpauseします(実行モードによる)。条件の評価でエラーを取得した場合は、実行をストップしません。

@findex edebug-set-global-break-condition
  条件式は@code{edebug-global-break-condition}に格納されます。Edebugがアクティブなときにソースバッファーから@kbd{X}コマンドを使用するか、Edebugがロードされている間は任意のバッファーから任意のタイミングで@kbd{C-x
X X}(@code{edebug-set-global-break-condition})を使用することにより新たな式を指定できます。

  グローバルbreak条件は、コード内のどこでイベントが発生したかを見つけるもっともシンプルな方法ですが、コードの実行は遅くなります。そのため、使用しないときは条件を@code{nil}にリセットするべきです。

@node Source Breakpoints
@subsubsection Source Breakpoints

@findex edebug
@cindex source breakpoints
  定義内のすべてのbreakpointは、それをインストルメントするたびに失われます。breakpointが失われないようにしたい場合は、ソースコード内で単に関数@code{edebug}を呼び出す@dfn{ソースbreakpoint(source
breakpoint)}を記述できます。もちろん、そのような呼び出しを条件付きすることにもできます。たとえば@code{fac}関数内に以下のような行を1行目に挿入して、引数が0になったときストップさせることができます:

@example
(defun fac (n)
  (if (= n 0) (edebug))
  (if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

  @code{fac}の定義がインストルメントされて呼び出されたとき、@code{edebug}呼び出しはbreakpointとして振る舞います。実行モードに応じて、Edebugはそこでストップまたはpauseします。

@c This may not be a good idea anymore.
  @code{edebug}が呼び出されたときにインストルメント済みのコードが実行されていなければ、この関数は@code{debug}を呼び出します。

@node Trapping Errors
@subsection Trapping Errors

  エラーがシグナルされて、それが@code{condition-case}でハンドルされていないとき、Emacsは通常エラーメッセージを表示します。Edebugがアクティブでインストルメント済みのコードを実行中は、ハンドルされていないエラーには通常Edebugが対応します。オプション@code{edebug-on-error}および@code{edebug-on-quit}で、これをカスタマイズできます。@ref{Edebug
Options}を参照してください。

  Edebugがエラーに対応するときは、エラー発生箇所の前にある最後のストップポイントを表示します。この場所はインストルメントされていない関数の呼び出しで、その関数内で実際にエラーが発生したのかもしれません。バインドされていない変数に関するエラーの場合は、最後の既知のストップポイントは、その不正な変数参照から遠く離れた場所かもしれません。そのような場合は、完全なbacktraceを表示したいと思うでしょう(@ref{Edebug
Misc}を参照)。

@c Edebug should be changed for the following: -- dan
  Edebugがアクティブの間に@code{debug-on-error}、または@code{debug-on-quit}を変更した場合、それらの変更はEdebugが非アクティブになったとき失われます。さらに、Edebugの再帰編集の間、これらの変数はEdebugの外部でもっていた値にバインドされます。

@node Edebug Views
@subsection Edebug Views

  これらのEdebugコマンドは、Edebugにエントリーする前のバッファーの外観と、ウィンドウの状態を調べるコマンドです。外部のウィンドウ構成は、ウィンドウのコレクションとその内容であり、これらは実際にEdebugの外部にあります。

@table @kbd
@item v
外部のウィンドウ構成ビューに切り替える(@code{edebug-view-outside})。Edebugにリターンするには、@kbd{C-x X
w}をタイプする。

@item p
一時的に外部のカレントバッファーを表示し、ポイントもその外部の位置になる(@code{edebug-bounce-point})。Edebugにリターンする前に、1秒pauseする。プレフィクス引数@var{n}を指定すると、かわりに@var{n}秒pauseする。

@item w
ソースコードバッファー内のカレントストップポイントにポイントを戻す(@code{edebug-where})。

このコマンドを同じバッファーを表示する異なるウィンドウで使用した場合には、そのウィンドウは将来カレント定義を表示するために代用される。

@item W
@c Its function is not simply to forget the saved configuration -- dan
Edebugが外部のウィンドウ構成を保存、およびリストアするかどうかを切り替える(@code{edebug-toggle-save-windows})。

プレフィクス引数を指定すると、@code{W}は選択されたウィンドウの保存とリストアだけを切り替える。ソースコードバッファーを表示していないウィンドウを指定するには、グローバルキーマップから@kbd{C-x
X W}を使用しなければならない。
@end table

  @kbd{v}、または単に@kbd{p}でカレントバッファーにポイントを反跳させれば、たとえ通常は表示されないウィンドウでも、外部のウィンドウ構成を調べることができます。

  ポイントを移動した後に、ストップポイントに戻りたいときがあるかもしれません。これは、ソースコードバッファーから@kbd{w}で行うことができます。どのバッファーにいても、@kbd{C-x
X w}を使用すれば、ソースコードバッファー内のストップポイントに戻ることができます。

  保存を@emph{オフ}にするために@kbd{W}を使用するたびに、Edebugは外部のウィンドウ構成を忘れます。そのため、たとえ保存を@emph{オン}に戻しても、(プログラムを実行することにより)次にEdebugをexitしたとき、カレントウィンドウ構成は変更されないまま残ります。しかし、十分な数のウィンドウをオープンしていない場合は、@file{*edebug*}と@file{*edebug-trace*}の再表示が、あなたが見たいバッファーと競合するかもしれません。

@node Edebug Eval
@subsection Evaluation

  Edebug内では、まるでEdebugが実行されていないかのように、式を評価できます。式の評価とプリントに際して、Edebugが不可視になるよう試みます。。副作用をもつ式の評価は、Edebugが明示的に保存とリストアを行うデータへの変更を除き、期待したとおり機能するでしょう。このプロセスの詳細は、@ref{The
Outside Context}を参照してください。

@table @kbd
@item e @var{exp} @key{RET}
Edebugのコンテキスト外で、式@var{exp}を評価する(@code{edebug-eval-expression})。つまり、Edebugはその式への干渉を最小限にしようと努める。

@item M-: @var{exp} @key{RET}
Edebug自身のコンテキスト内で、式@var{exp}を評価する(@code{eval-expression})。

@item C-x C-e
Edebugのコンテキスト外で、ポイントの前の式を評価する(@code{edebug-eval-last-sexp})。
@end table

@cindex lexical binding (Edebug)
@c FIXME?  What about lexical-binding = t?
  Edebugは、@file{cl.el}内の構文(@code{lexical-let}、@code{macrolet}、@code{symbol-macrolet})により作成された、レキシカル(lexical)にバインドされたシンボルへの参照を含む式の評価をサポートします。

@node Eval List
@subsection Evaluation List Buffer

  式をインタラクティブに評価するために、@file{*edebug*}と呼ばれる@dfn{評価リストバッファー(evaluation list
buffer)}を使用できます。Edebugがディスプレイを更新するたびに自動的に評価される、式の@dfn{評価リスト(evaluation
list)}もセットアップできます。

@table @kbd
@item E
評価リストバッファー@file{*edebug*}に切り替える(@code{edebug-visit-eval-list})。
@end table

  @file{*edebug*}バッファーでは、以下の特別なコマンドと同様に、Lisp Interactionモード(@pxref{Lisp
Interaction,,, emacs, The GNU Emacs Manual})のコマンドも使用できます。

@table @kbd
@item C-j
ポイントの前の式をコンテキスト外で評価して、その値をバッファーに挿入する(@code{edebug-eval-print-last-sexp})。

@item C-x C-e
Edebugのコンテキスト外で、ポイントの前の式を評価する(@code{edebug-eval-last-sexp})。

@item C-c C-u
バッファー内のコンテンツから、新たに評価リストを構築する(@code{edebug-update-eval-list})。

@item C-c C-d
ポイントのある評価リストグループを削除する(@code{edebug-delete-eval-item})。

@item C-c C-w
ソースコードバッファーに切り替えてカレントストップポイントに戻る(@code{edebug-where})。
@end table

  評価リストウィンドウ内では、@file{*scratch*}にいるときと同様に、@kbd{C-j}や@kbd{C-x
C-e}で式を評価できますが、それらはEdebugのコンテキスト外で評価されます。

  インタラクティブに入力した式(とその結果)は、実行を継続すると失われます。しかし、実行がストップされるたびに評価されるように、式から構成される@dfn{評価リスト}をセットアップできます。

@cindex evaluation list group
  これを行なうには、評価リストバッファー内で1つ以上の@dfn{評価リストグループ(evaluation list
group)}を記述します。評価リストグループは、1つ以上のLisp式から構成されます。グループはコメント行で区切られます。

  コマンド@kbd{C-c
C-u}(@code{edebug-update-eval-list})は、バッファーをスキャンして各グループの最初の式を使用して、評価リストを再構築します。(これはグループの2つ目の式は以前に計算、表示されている値だという発想からです。)

  Edebugにエントリーするたびに、評価リストの各式(および式の後に式のカレント値)をバッファーに挿入して再表示します。これはコメント行も挿入するため、各式はそのグループの一員となります。したがって、バッファーのテキストを変更せずに@kbd{C-c
C-u}とタイプした場合、評価リストは実際には変更されません。

  評価リストからの評価の間にエラーが発生した場合、それが式の結果であるかのようにエラーメッセージが文字列で表示されます。したがって、カレントで無効な変数を使用する式により、デバッグが中断されることはありません。

  以下は、いくつかの式を評価リストウィンドウに追加したとき、どのように見えるかの例です:

@smallexample
(current-buffer)
#<buffer *scratch*>
;---------------------------------------------------------------
(selected-window)
#<window 16 on *scratch*>
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
@end smallexample

グループを削除するには、グループ内にポイントを移動して@kbd{C-c C-d}をタイプするか、単にグループのテキストを削除して@kbd{C-c
C-u}で評価リストを更新します。評価リストに新たな式を追加するには、適切な箇所にその式を挿入し、新たなコメント行を挿入してから@kbd{C-c
C-u}をタイプします。コメント行にダッシュを挿入する必要はありません --- 内容は関係ないのです。

@file{*edebug*}を選択した後に、@kbd{C-c
C-w}でソースコードバッファーにリターンできます。@file{*edebug*}は実行を継続したときkillされ、次回必要なとき再作成されます。

@node Printing in Edebug
@subsection Printing in Edebug

@cindex printing (Edebug)
@cindex printing circular structures
@pindex cust-print
  プログラム内の式が循環リスト構造(circular list
structure)を含む値を生成する場合は、Edebugがそれをプリントしようとしたときエラーとなるかもしれません。

  循環構造への対処の1つに、@code{print-length}および@code{print-level}にプリントの切り詰めをセットする方法があります。Edebugは、変数@code{edebug-print-length}および@code{edebug-print-level}の値(非@code{nil}値をもつ場合)を、これらの変数にバインドします。@ref{Output
Variables}を参照してください。

@defopt edebug-print-length
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-length}をこの値にバインドする。デフォルト値は@code{50}。
@end defopt

@defopt edebug-print-level
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-level}をこの値にバインドする。デフォルト値は@code{50}。
@end defopt

  @code{print-circle}を非@code{nil}値にバインドして、循環構造や要素を共有する構造を、より参考になる情報をプリントすることもできます。

  以下は循環構造を作成するコードの例です:

@example
(setq a '(x y))
(setcar a a)
@end example

@noindent
カスタムプリントはこれを、@samp{Result: #1=(#1#
y)}のようにプリントします。@samp{#1=}という表記はその後の構造をラベル@samp{1}とラベル付けし、@samp{#1#}表記はその前にラベル付けされた構造を参照しています。この表記は、リストやベクターの任意の共有要素に使用されます。

@defopt edebug-print-circle
非@code{nil}の場合は、結果をプリントするときEdebugは@code{print-circle}をこの値にバインドする。デフォルト値は@code{t}。
@end defopt

  他にプログラムもカスタムプリントを使用できます。詳細は@file{cust-print.el}を参照してください。

@node Trace Buffer
@subsection Trace Buffer
@cindex trace buffer

  Edebugは実行トレースを@file{*edebug-trace*}という名前のバッファーに格納して記録できます。実行トレースとは関数呼び出しよリターンのログのことで、関数名と引数、および値が確認できます。トレースレコードを有効にするには、@code{edebug-trace}を非@code{nil}値にセットしてください。

  トレースバッファーの作成は、実行モードのトレースの使用(@ref{Edebug Execution Modes}を参照)と同じではありません。

  トレースレコードが有効なときは、関数へのエントリーとexitのたびに、トレースバッファーに行が追加されます。関数エントリーレコードは@samp{::::@{}、および関数名と引数の値により構成されます。関数exitレコードは@samp{::::@}}、および関数名と関数の結果により構成されます。

  @samp{:}の数は、関数エントリーの再帰レベルを表します。トレースバッファーでは、関数呼び出しの開始と終了の検索に@samp{@{}と@samp{@}}を使用できます。

@findex edebug-print-trace-before
@findex edebug-print-trace-after
  
関数@code{edebug-print-trace-before}および@code{edebug-print-trace-after}を再定義することにより、関数エントリーと関数exitのトレースレコードをカスタマイズできます。

@defmac edebug-tracing string body@dots{}
このマクロは@var{body}フォーム実行活動にたいする、追加のトレース情報をリクエストする。引数@var{string}は、トレースバッファーに配す@samp{@{}または@samp{@}}の後のテキストを指定する。すべての引数は評価され、@code{edebug-tracing}は@var{body}内の最後のフォームの値をリターンする。
@end defmac

@defun edebug-trace format-string &rest format-args
この関数は、トレースバッファーにテキストを挿入する。テキストは、@code{(apply 'format @var{format-string}
@var{format-args})}により計算される。エントリー間の区切りとして改行も付け加える。
@end defun

  @code{edebug-tracing}および@code{edebug-trace}は、たとえEdebugが非アクティブでも、呼び出されたときは常にトレースバッファーに行を挿入します。トレースバッファーへのテキストの追加により、挿入された最後の行が見えるようにウィンドウもスクロールします。

@node Coverage Testing
@subsection Coverage Testing

@cindex coverage testing (Edebug)
@cindex frequency counts
@cindex performance analysis
  Edebugは基本的なカバレッジテスト(coverage test)と実行頻度(execution frequency)の表示を提供します。

  カバレッジテストは、すべての式の結果と以前の結果を比較することにより機能します。プログラム内のフォームがそれぞれ、カレントEmacsセッション内でカバレッジテストを開始して以降に、2つの異なる値をリターンした場合、それらのフォームは``カバー''されたと判断します。したがって、プログラムにカバレッジテストを行なうには、そのプログラムをさまざまなコンディション下で実行して、プログラムが正しく振る舞うかに注目します。異なるコンディション下で十分にテストして、すべてのフォームが異なる2つの値をリターンしたとき、Edebugはそのことを告げるでしょう。

  カバレッジテストにより実行速度が低下するので、@code{edebug-test-coverage}が非@code{nil}のときだけカバレッジテストが行なわれます。頻度計数(frequency
count)は、たとえ実行モードがGo-nonstopでも、カバレッジテストが有効か無効かに関わらず、すべての式にたいして処理されます。

@kindex C-x X =
@findex edebug-temp-display-freq-count
  定義にたいするカバレッジ情報と頻度数の両方を表示するには、@kbd{C-x X
=}(@code{edebug-display-freq-count})を使用する。単に@kbd{=}(@code{edebug-temp-display-freq-count})とすると、他のキーをタイプするまでの間だけ、同様な情報を一時的に表示する。

@deffn Command edebug-display-freq-count
このコマンドは、カレント定義の各行の頻度数を表示する。

このコマンドは、コードの各行の下にコメント行として頻度数を挿入する。1回の@code{undo}コマンドで、すべての挿入をアンドゥできる。頻度数は式の前の@samp{(}、または式の後の@samp{)}、または変数の最後の文字の下に表示される。表示をシンプルにするために、同一行にたいして式の以前頻度数と頻度数が同じ場合は表示しない。

ある式にたいする頻度数の後に文字@samp{=}がある場合、それはその式が評価されるたびに毎回同じ値をリターンしていることを表す。他の言い方をすると、カバレッジテストの目的からは、その式はまだ``カバー''されていないということである。

ある定義にたいして頻度数とカバレッジデータを明確にするには、単に@code{eval-defun}で再インストルメントすればよい。
@end deffn

たとえば、ソースのbreakpointで@code{(fac
5)}を評価した後、@code{edebug-test-coverage}を@code{t}にセットすると、breakpointに達したときの頻度データは以下のようになります:

@example
(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (< 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
@end example

コメント行は、@code{fac}が6回呼び出されたことを表しています。最初の@code{if}命令は毎回同じ結果を5回リターンしています。同じ結果という意味では、2つ目の@code{if}の条件にも当てはまります。@code{fac}の再帰呼び出しは、結局リターンしません。


@node The Outside Context
@subsection The Outside Context

Edebugはデバッグ中のプログラムにたいして透過的であろうと努めますが、完全には達成されません。Edebugは、@kbd{e}や評価リストバッファーで式を評価するときも、一時的に外部のコンテキストをリストアして、透明化を試みます。このセクションではEdebugがリストアするコンテキストと、Edebugがいかにして完全に透過的になるのに失敗するかを正確に説明します。

@menu
* Checking Whether to Stop::  何を行うかをEdebugが決定するタイミング。
* Edebug Display Update::    Edebugがディスプレイを更新するタイミング。
* Edebug Recursive Edit::    Edebugが実行をストップするタイミング。
@end menu

@node Checking Whether to Stop
@subsubsection Checking Whether to Stop

Edebugにエンターするときは常に特定のデータの保存とリストアを行なう必要があり、それはトレース情報を作成するか、あるいはプログラムを停止するかを決定する前に行なう必要があります。

@itemize @bullet
@item
@code{max-lisp-eval-depth}および@code{max-specpdl-size}は、Edebugがスタック与える影響の低減効果を高める。しかしそれでも、Edebug使用時にスタック空間を使い切ってしまうことはあり得る。

@item
キーボードマクロの実行状態は保存およびリストアされる。Edebugがアクティブの間、@code{edebug-continue-kbd-macro}が@code{nil}の場合は、@code{executing-kbd-macro}が@code{nil}にバインドされる。
@end itemize


@node Edebug Display Update
@subsubsection Edebug Display Update

@c This paragraph is not filled, because LaLiberte's conversion script
@c needs an xref to be on just one line.
(たとえばtraceモードなどで)Edebugが何かを表示する必要があるときは、Edebugの``外部''からカレントウィンドウ構成(@ref{Window
Configurations}を参照)を保存します。Edebugをexitするときに、以前のウィンドウ構成がリストアされます。

Emacsは、pause時だけ再表示を行います。通常は実行を継続したときに、そのプログラムはbreakpointまたはステップ実行後にEdebugに再エンターし、その間にpauseや入力の読み取りはありません。そのような場合、Emacsが``外部''の構成を再表示する機会は決してありません。結果として、ユーザーが目にするウィンドウ構成は、前回Edebugが中断なしでアクティブだったときのウィンドウ構成と同じになります。

何かを表示するためにEdebugにエントリーすることにより、(たとえこれらのうちのいくつかは、エラーやquitがシグナルされたときは、故意にリストアしないデータだとしても)以下のデータも保存およびリストアされます。

@itemize @bullet
@item
@cindex current buffer point and mark (Edebug)
どれがカレントバッファーか、そしてカレントバッファー内のポイントとマークの位置が、保存およびリストアされる。

@item
@cindex window configuration (Edebug)
@code{edebug-save-windows}が非@code{nil}の場合は、外部のウィンドウ構成が保存およびリストアされる(@ref{Edebug
Options}を参照)。

エラーやquitではウィンドウ構成はリストアされないが、@code{save-excursion}がアクティブな場合は、たとえエラーやquitのとき外部の選択されたウィンドウが再選択@emph{される}。@code{edebug-save-windows}の値がリストの場合は、それにリストされたウィンドウだけが保存およびリストアされる。

しかし、ソースコードバッファーのウィンドウの開始位置と水平スクロールはリストアされないので、表示はEdebug内で整合性が保たれたままとなる。

@item
@code{edebug-save-displayed-buffer-points}が非@code{nil}の場合、表示されているそれぞれのバッファー内のポイント値は、保存およびリストアされる。

@item
変数@code{overlay-arrow-position}と@code{overlay-arrow-string}は保存およびリストアされるので、同じバッファー内の他の場所の再帰編集から、安全にEdebugを呼び出せる。

@item
@code{cursor-in-echo-area}は@code{nil}にローカルにバインドされるので、カーソルはそのウィンドウ内に現れる。
@end itemize

@node Edebug Recursive Edit
@subsubsection Edebug Recursive Edit

Edebugにエンターしてユーザーのコマンドが実際に読み取られるとき、Edebugは以下の追加データを保存(そして後でリストア)します:

@itemize @bullet
@item
カレントマッチデータ。@ref{Match Data}を参照。

@item
変数@code{last-command}、@code{this-command}、@code{last-command-event}、@code{last-input-event}、@code{last-event-frame}、@code{last-nonmenu-event}、@code{track-mouse}。Edebug内のコマンドは、Edebug外部のこれらの変数に影響をあたえない。

Edebug内でのコマンド実行は、@code{this-command-keys}によりリターンされるキーシーケンスを変更でき、Lispからそのキーシーケンスをリセットする方法はない。

Edebugは@code{unread-command-events}の値の保存およびリストアができない。この変数が重要な値をもつときにEdebugにエンターすると、デバッグ中のプログラムの実行に干渉する可能性がある。

@item
Edebug内で実行された複雑なコマンドは、変数@code{command-history}に追加される。これが稀に実行に影響を与える。

@item
Edebug内では、再帰深さがEdebug外部の再帰深さより1つ深くなる。これは自動的に更新される評価リストウィンドウでは異なる。

@item
@code{standard-output}と@code{standard-input}は@code{recursive-edit}により@code{nil}にバインドされるが、Edebugは評価の間それらを一時的にリストアする。

@item
キーボードマクロ定義の状態は、保存およびリストアされる。Edebugがアクティブの間、@code{defining-kbd-macro}は@code{edebug-continue-kbd-macro}にバインドされる。
@end itemize

@node Edebug and Macros
@subsection Edebug and Macros

Edebugが正しくマクロを呼び出す式をインストルメントするには、いくつかの特定な配慮が必要になります。このサブセクションでは、その詳細を説明します。

@menu
* Instrumenting Macro Calls::  基本的な問題点。
* Specification List::       式の複雑なパターンを指定する方法。
* Backtracking::             マッチに失敗したときEdebugが行なうこと。
* Specification Examples::   Edebug仕様を理解するために。
@end menu

@node Instrumenting Macro Calls
@subsubsection Instrumenting Macro Calls

  EdebugがLispマクロを呼び出す式をインストルメントするときは、正しくインストルメントを行なうために、そのマクロに関して追加の情報が必要になります。これは、マクロ呼び出しのどの部分式(subexpression)が評価されるフォームなのか推測する方法がないからです。(評価はマクロのbodyで明示的に発生するかもしれないし、展開結果が評価されるとき、または任意のタイミングで行われるかもしれません。)

  したがって、Edebugが処理するかもしれないすべてのマクロにたいして、そのマクロの呼び出しフォーマットを説明するための、Edebug仕様(Edebug
specification)を定義しなければなりません。これを行なうには、マクロ定義に@code{debug}宣言を追加します。以下はマクロ例@code{for}(@ref{Argument
Evaluation}を参照)にたいする簡単な仕様の例です。

@smallexample
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &rest form)))
  ...)
@end smallexample

  このEdebug仕様は、マクロ呼び出しのどの部分が評価されるフォームなのかを示しています。単純なマクロにたいするEdebug仕様は、そのマクロ定義の正式な引数リストに非常に類似している場合がありますが、Edebug仕様はマクロ引数に比べより汎的です。@code{declare}フォームの詳細は、@ref{Defining
Macros}を参照してください。

@c See, e.g., http://debbugs.gnu.org/10577
@c FIXME  Maybe there should be an Edebug option to get it to
@c automatically load the entire source file containing the function
@c being instrumented.  That would avoid this.
  コードをインストルメントするときEdebugに仕様が確実に解るよう注意してください。マクロ定義を含む他のファイルを要求するために@code{eval-when-compile}を使用するファイルから関数をインストルメントする場合は、そのファイルを明示的にロードする必要があるかもしれません。

  @code{def-edebug-spec}によりマクロ定義から個々のマクロにたいしてEdebug仕様を定義することもできます。Lispで記述されたマクロ定義にたいしては@code{debug}宣言を追加するほうが好ましく、その方が便利でもありますが、@code{def-edebug-spec}ではCで実装されたスペシャルフォームにたいしてEdebug仕様を定義することが可能になります。

@defmac def-edebug-spec macro specification
マクロ@var{macro}呼び出しのどの式が評価される式かを指定する。@var{specification}はEdebug仕様である。どちらの引数も評価されない。

引数@var{macro}は単なるマクロ名ではない、任意の実シンボルを指定できる。
@end defmac

以下は@var{specification}に指定できるシンボルと、引数を処理する方法のテーブルです。

@table @asis
@item @code{t}
すべての引数は評価のためにインストルメントされる。

@item @code{0}
引数はインストルメントされない。

@item シンボル
そのシンボルは、かわりに使用されるEdebug仕様をもたなければならない。このインダイレクションは、他の種類の仕様が見つかるまで繰り返される。これにより、他のマクロの仕様を継承できる。

@item リスト
リストの要素はフォーム呼び出しの引数の型を記述する。仕様リストに指定できる要素については、以降のセクションを参照。
@end table

マクロがEdebug仕様をもたない場合は、@code{debug}宣言および@code{def-edebug-spec}呼び出しのどちらを通じても、変数@code{edebug-eval-macro-args}が効果を発揮する。

@defopt edebug-eval-macro-args
これは、Edebugが明示的なEdebug仕様をもたないマクロ引数を扱う方法を制御する。@code{nil}(デフォルト)の場合、引数は評価のためにインストルメントされない。それ以外は、すべての引数がインストルメントされる。
@end defopt

@node Specification List
@subsubsection Specification List

@cindex Edebug specification list
A @dfn{specification list} is required for an Edebug specification if some
arguments of a macro call are evaluated while others are not.  Some elements
in a specification list match one or more arguments, but others modify the
processing of all following elements.  The latter, called @dfn{specification
keywords}, are symbols beginning with @samp{&} (such as @code{&optional}).

A specification list may contain sublists, which match arguments that are
themselves lists, or it may contain vectors used for grouping.  Sublists and
groups thus subdivide the specification list into a hierarchy of levels.
Specification keywords apply only to the remainder of the sublist or group
they are contained in.

When a specification list involves alternatives or repetition, matching it
against an actual macro call may require backtracking.  For more details,
@pxref{Backtracking}.

Edebug specifications provide the power of regular expression matching, plus
some context-free grammar constructs: the matching of sublists with balanced
parentheses, recursive processing of forms, and recursion via indirect
specifications.

Here's a table of the possible elements of a specification list, with their
meanings (see @ref{Specification Examples}, for the referenced examples):

@table @code
@item sexp
@c an "expression" is not necessarily intended for evaluation.
A single unevaluated Lisp object, which is not instrumented.

@item form
A single evaluated expression, which is instrumented.

@item place
A generalized variable.  @xref{Generalized Variables}.

@item body
Short for @code{&rest form}.  See @code{&rest} below.

@item function-form
A function form: either a quoted function symbol, a quoted lambda
expression, or a form (that should evaluate to a function symbol or lambda
expression).  This is useful when an argument that's a lambda expression
might be quoted with @code{quote} rather than @code{function}, since it
instruments the body of the lambda expression either way.

@item lambda-expr
A lambda expression with no quoting.

@item &optional
@c @kindex &optional @r{(Edebug)}
All following elements in the specification list are optional; as soon as
one does not match, Edebug stops matching at this level.

To make just a few elements optional, followed by non-optional elements, use
@code{[&optional @var{specs}@dots{}]}.  To specify that several elements
must all match or none, use @code{&optional [@var{specs}@dots{}]}.  See the
@code{defun} example.

@item &rest
@c @kindex &rest @r{(Edebug)}
All following elements in the specification list are repeated zero or more
times.  In the last repetition, however, it is not a problem if the
expression runs out before matching all of the elements of the specification
list.

To repeat only a few elements, use @code{[&rest @var{specs}@dots{}]}.  To
specify several elements that must all match on every repetition, use
@code{&rest [@var{specs}@dots{}]}.

@item &or
@c @kindex &or @r{(Edebug)}
Each of the following elements in the specification list is an alternative.
One of the alternatives must match, or the @code{&or} specification fails.

Each list element following @code{&or} is a single alternative.  To group
two or more list elements as a single alternative, enclose them in
@code{[@dots{}]}.

@item &not
@c @kindex &not @r{(Edebug)}
Each of the following elements is matched as alternatives as if by using
@code{&or}, but if any of them match, the specification fails.  If none of
them match, nothing is matched, but the @code{&not} specification succeeds.

@c FIXME &key?

@item &define
@c @kindex &define @r{(Edebug)}
Indicates that the specification is for a defining form.  The defining form
itself is not instrumented (that is, Edebug does not stop before and after
the defining form), but forms inside it typically will be instrumented.  The
@code{&define} keyword should be the first element in a list specification.

@item nil
This is successful when there are no more arguments to match at the current
argument list level; otherwise it fails.  See sublist specifications and the
backquote example.

@item gate
@cindex preventing backtracking
No argument is matched but backtracking through the gate is disabled while
matching the remainder of the specifications at this level.  This is
primarily used to generate more specific syntax error messages.  See
@ref{Backtracking}, for more details.  Also see the @code{let} example.

@item @var{other-symbol}
@cindex indirect specifications
Any other symbol in a specification list may be a predicate or an indirect
specification.

If the symbol has an Edebug specification, this @dfn{indirect specification}
should be either a list specification that is used in place of the symbol,
or a function that is called to process the arguments.  The specification
may be defined with @code{def-edebug-spec} just as for macros.  See the
@code{defun} example.

Otherwise, the symbol should be a predicate.  The predicate is called with
the argument, and if the predicate returns @code{nil}, the specification
fails and the argument is not instrumented.

Some suitable predicates include @code{symbolp}, @code{integerp},
@code{stringp}, @code{vectorp}, and @code{atom}.

@item [@var{elements}@dots{}]
@cindex [@dots{}] (Edebug)
A vector of elements groups the elements into a single @dfn{group
specification}.  Its meaning has nothing to do with vectors.

@item "@var{string}"
The argument should be a symbol named @var{string}.  This specification is
equivalent to the quoted symbol, @code{'@var{symbol}}, where the name of
@var{symbol} is the @var{string}, but the string form is preferred.

@item (vector @var{elements}@dots{})
The argument should be a vector whose elements must match the @var{elements}
in the specification.  See the backquote example.

@item (@var{elements}@dots{})
Any other list is a @dfn{sublist specification} and the argument must be a
list whose elements match the specification @var{elements}.

@cindex dotted lists (Edebug)
A sublist specification may be a dotted list and the corresponding list
argument may then be a dotted list.  Alternatively, the last @sc{cdr} of a
dotted list specification may be another sublist specification (via a
grouping or an indirect specification, e.g., @code{(spec .  [(more
specs@dots{})])}) whose elements match the non-dotted list arguments.  This
is useful in recursive specifications such as in the backquote example.
Also see the description of a @code{nil} specification above for terminating
such recursion.

Note that a sublist specification written as @code{(specs .  nil)} is
equivalent to @code{(specs)}, and @code{(specs .
(sublist-elements@dots{}))} is equivalent to @code{(specs
sublist-elements@dots{})}.
@end table

@c Need to document extensions with &symbol and :symbol

Here is a list of additional specifications that may appear only after
@code{&define}.  See the @code{defun} example.

@table @code
@item name
The argument, a symbol, is the name of the defining form.

A defining form is not required to have a name field; and it may have
multiple name fields.

@item :name
This construct does not actually match an argument.  The element following
@code{:name} should be a symbol; it is used as an additional name component
for the definition.  You can use this to add a unique, static component to
the name of the definition.  It may be used more than once.

@item arg
The argument, a symbol, is the name of an argument of the defining form.
However, lambda-list keywords (symbols starting with @samp{&})  are not
allowed.

@item lambda-list
@cindex lambda-list (Edebug)
This matches a lambda list---the argument list of a lambda expression.

@item def-body
The argument is the body of code in a definition.  This is like @code{body},
described above, but a definition body must be instrumented with a different
Edebug call that looks up information associated with the definition.  Use
@code{def-body} for the highest level list of forms within the definition.

@item def-form
The argument is a single, highest-level form in a definition.  This is like
@code{def-body}, except it is used to match a single form rather than a list
of forms.  As a special case, @code{def-form} also means that tracing
information is not output when the form is executed.  See the
@code{interactive} example.
@end table

@node Backtracking
@subsubsection Backtracking in Specifications

@cindex backtracking
@cindex syntax error (Edebug)
If a specification fails to match at some point, this does not necessarily
mean a syntax error will be signaled; instead, @dfn{backtracking} will take
place until all alternatives have been exhausted.  Eventually every element
of the argument list must be matched by some element in the specification,
and every required element in the specification must match some argument.

When a syntax error is detected, it might not be reported until much later,
after higher-level alternatives have been exhausted, and with the point
positioned further from the real error.  But if backtracking is disabled
when an error occurs, it can be reported immediately.  Note that
backtracking is also reenabled automatically in several situations; when a
new alternative is established by @code{&optional}, @code{&rest}, or
@code{&or}, or at the start of processing a sublist, group, or indirect
specification.  The effect of enabling or disabling backtracking is limited
to the remainder of the level currently being processed and lower levels.

Backtracking is disabled while matching any of the form specifications (that
is, @code{form}, @code{body}, @code{def-form}, and @code{def-body}).  These
specifications will match any form so any error must be in the form itself
rather than at a higher level.

Backtracking is also disabled after successfully matching a quoted symbol or
string specification, since this usually indicates a recognized construct.
But if you have a set of alternative constructs that all begin with the same
symbol, you can usually work around this constraint by factoring the symbol
out of the alternatives, e.g., @code{["foo" &or [first case] [second case]
...]}.

Most needs are satisfied by these two ways that backtracking is
automatically disabled, but occasionally it is useful to explicitly disable
backtracking by using the @code{gate} specification.  This is useful when
you know that no higher alternatives could apply.  See the example of the
@code{let} specification.

@node Specification Examples
@subsubsection Specification Examples

It may be easier to understand Edebug specifications by studying the
examples provided here.

A @code{let} special form has a sequence of bindings and a body.  Each of
the bindings is either a symbol or a sublist with a symbol and optional
expression.  In the specification below, notice the @code{gate} inside of
the sublist to prevent backtracking once a sublist is found.

@ignore
@c FIXME?  The actual definition in edebug.el looks like this (and always
@c has AFAICS).  In fact, nothing in edebug.el uses gate.  So maybe
@c this is just an example for illustration?
(def-edebug-spec let
  ((&rest
    &or (symbolp &optional form) symbolp)
   body))
@end ignore
@example
(def-edebug-spec let
  ((&rest
    &or symbolp (gate symbolp &optional form))
   body))
@end example

Edebug uses the following specifications for @code{defun} and the associated
argument list and @code{interactive} specifications.  It is necessary to
handle interactive forms specially since an expression argument is actually
evaluated outside of the function body.  (The specification for
@code{defmacro} is very similar to that for @code{defun}, but allows for the
@code{declare} statement.)

@smallexample
(def-edebug-spec defun
  (&define name lambda-list
           [&optional stringp]   ; @r{Match the doc string, if present.}
           [&optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&rest arg]
    [&optional ["&optional" arg &rest arg]]
    &optional ["&rest" arg]
    )))

(def-edebug-spec interactive
  (&optional &or stringp def-form))    ; @r{Notice: @code{def-form}}
@end smallexample

The specification for backquote below illustrates how to match dotted lists
and use @code{nil} to terminate recursion.  It also illustrates how
components of a vector may be matched.  (The actual specification defined by
Edebug is a little different, and does not support dotted lists because
doing so causes very deep recursion that could fail.)

@smallexample
(def-edebug-spec \` (backquote-form))   ; @r{Alias just for clarity.}

(def-edebug-spec backquote-form
  (&or ([&or "," ",@@"] &or ("quote" backquote-form) form)
       (backquote-form . [&or nil backquote-form])
       (vector &rest backquote-form)
       sexp))
@end smallexample


@node Edebug Options
@subsection Edebug Options

@c Previously defopt'd:
@c edebug-sit-for-seconds, edebug-print-length, edebug-print-level
@c edebug-print-circle, edebug-eval-macro-args
  These options affect the behavior of Edebug:

@defopt edebug-setup-hook
Functions to call before Edebug is used.  Each time it is set to a new
value, Edebug will call those functions once and then reset
@code{edebug-setup-hook} to @code{nil}.  You could use this to load up
Edebug specifications associated with a package you are using, but only when
you also use Edebug.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-defs
If this is non-@code{nil}, normal evaluation of defining forms such as
@code{defun} and @code{defmacro} instruments them for Edebug.  This applies
to @code{eval-defun}, @code{eval-region}, @code{eval-buffer}, and
@code{eval-current-buffer}.

Use the command @kbd{M-x edebug-all-defs} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-forms
If this is non-@code{nil}, the commands @code{eval-defun},
@code{eval-region}, @code{eval-buffer}, and @code{eval-current-buffer}
instrument all forms, even those that don't define anything.  This doesn't
apply to loading or evaluations in the minibuffer.

Use the command @kbd{M-x edebug-all-forms} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-save-windows
If this is non-@code{nil}, Edebug saves and restores the window
configuration.  That takes some time, so if your program does not care what
happens to the window configurations, it is better to set this variable to
@code{nil}.

If the value is a list, only the listed windows are saved and restored.

You can use the @kbd{W} command in Edebug to change this variable
interactively.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-save-displayed-buffer-points
If this is non-@code{nil}, Edebug saves and restores point in all displayed
buffers.

Saving and restoring point in other buffers is necessary if you are
debugging code that changes the point of a buffer that is displayed in a
non-selected window.  If Edebug or the user then selects the window, point
in that buffer will move to the window's value of point.

Saving and restoring point in all buffers is expensive, since it requires
selecting each window twice, so enable this only if you need it.
@xref{Edebug Display Update}.
@end defopt

@defopt edebug-initial-mode
If this variable is non-@code{nil}, it specifies the initial execution mode
for Edebug when it is first activated.  Possible values are @code{step},
@code{next}, @code{go}, @code{Go-nonstop}, @code{trace}, @code{Trace-fast},
@code{continue}, and @code{Continue-fast}.

The default value is @code{step}.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-trace
If this is non-@code{nil}, trace each function entry and exit.  Tracing
output is displayed in a buffer named @file{*edebug-trace*}, one function
entry or exit per line, indented by the recursion level.

Also see @code{edebug-tracing}, in @ref{Trace Buffer}.
@end defopt

@defopt edebug-test-coverage
If non-@code{nil}, Edebug tests coverage of all expressions debugged.
@xref{Coverage Testing}.
@end defopt

@defopt edebug-continue-kbd-macro
If non-@code{nil}, continue defining or executing any keyboard macro that is
executing outside of Edebug.  Use this with caution since it is not
debugged.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-unwrap-results
If non-@code{nil}, Edebug tries to remove any of its own instrumentation
when showing the results of expressions.  This is relevant when debugging
macros where the results of expressions are themselves instrumented
expressions.  As a very artificial example, suppose that the example
function @code{fac} has been instrumented, and consider a macro of the form:

@c FIXME find a less silly example.
@smallexample
(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      @dots{}))
@end smallexample

If you instrument the @code{test} macro and step through it, then by default
the result of the @code{symbol-function} call has numerous
@code{edebug-after} and @code{edebug-before} forms, which can make it
difficult to see the ``actual'' result.  If @code{edebug-unwrap-results} is
non-@code{nil}, Edebug tries to remove these forms from the result.
@end defopt

@defopt edebug-on-error
Edebug binds @code{debug-on-error} to this value, if @code{debug-on-error}
was previously @code{nil}.  @xref{Trapping Errors}.
@end defopt

@defopt edebug-on-quit
Edebug binds @code{debug-on-quit} to this value, if @code{debug-on-quit} was
previously @code{nil}.  @xref{Trapping Errors}.
@end defopt

@c Not necessarily a deeper command level.
@c A new command is not precisely true, but that is close enough -- dan
  If you change the values of @code{edebug-on-error} or @code{edebug-on-quit}
while Edebug is active, their values won't be used until the @emph{next}
time Edebug is invoked via a new command.

@defopt edebug-global-break-condition
If non-@code{nil}, an expression to test for at every stop point.  If the
result is non-@code{nil}, then break.  Errors are ignored.  @xref{Global
Break Condition}.
@end defopt
