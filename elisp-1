This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Top,  Next: Introduction,  Up: (dir)

Emacs Lisp
**********

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”

* Menu:

* Introduction::            Introduction and conventions used.

* Lisp Data Types::         Data types of objects in Emacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Hash Tables::             Very fast lookup-tables.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.
* Functions::               A function is a Lisp program
                              that can be invoked from other functions.
* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Making variables and faces customizable.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::                  Making multiple system-level windows.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Non-ASCII Characters::    Non-ASCII text in buffers and strings.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Processes::               Running and communicating with subprocesses.
* Display::                 Features for controlling the screen display.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.

* Packaging::               Preparing Lisp code for distribution.

Appendices

* Antinews::                Info for users downgrading to Emacs 23.
* GNU Free Documentation License:: The license for this documentation.
* GPL::                     Conditions for copying and changing GNU Emacs.
* Tips::                    Advice and coding conventions for Emacs Lisp.
* GNU Emacs Internals::     Building and dumping Emacs;
                              internal data structures.
* Standard Errors::         List of some standard error symbols.
* Standard Keymaps::        List of some standard keymaps.
* Standard Hooks::          List of some standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.



 — The Detailed Node Listing —
 ———————————

Here are other nodes that are subnodes of those already listed,
mentioned here so you can get to them in one step:

Introduction

* Caveats::                 Flaws and a request for help.
* Lisp History::            Emacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Version Info::            Which Emacs version is running?
* Acknowledgments::         The authors, editors, and sponsors of this manual.

Conventions

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols ‘nil’ and ‘t’ are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use when examples print text.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

Format of Descriptions

* A Sample Function Description::  A description of an imaginary
                                     function, ‘foo’.
* A Sample Variable Description::  A description of an imaginary
                                     variable, ‘electric-future-map’.

Lisp Data Types

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to Emacs.
* Circular Objects::        Read syntax for circular structure.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

Programming Types

* Integer Type::        Numbers without fractional parts.
* Floating-Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                          control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of ‘t’ or ‘nil’.
* Hash Table Type::     Super-fast lookup tables.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                          functions.

Character Type

* Basic Char Syntax::       Syntax for regular characters.
* General Escape Syntax::   How to specify characters by their codes.
* Ctl-Char Syntax::         Syntax for control characters.
* Meta-Char Syntax::        Syntax for meta-characters.
* Other Char Bits::         Syntax for hyper-, super-, and alt-characters.

Cons Cell and List Types

* Box Diagrams::            Drawing pictures of lists.
* Dotted Pair Notation::    A general syntax for cons cells.
* Association List Type::   A specially constructed list.

String Type

* Syntax for Strings::      How to specify Lisp strings.
* Non-ASCII in Strings::    International characters in strings.
* Nonprinting Characters::  Literal unprintable characters in strings.
* Text Props and Strings::  Strings with text properties.

Editing Types

* Buffer Type::             The basic object of editing.
* Marker Type::             A position in a buffer.
* Window Type::             Buffers are displayed in windows.
* Frame Type::              Windows subdivide frames.
* Terminal Type::           A terminal device displays frames.
* Window Configuration Type::  Recording the way a frame is subdivided.
* Frame Configuration Type::   Recording the status of all frames.
* Process Type::            A subprocess of Emacs running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Overlay Type::            How an overlay is represented.
* Font Type::               Fonts for displaying text.

Numbers

* Integer Basics::          Representation and range of integers.
* Float Basics::            Representation and range of floating point.
* Predicates on Numbers::   Testing for numbers.
* Comparison of Numbers::   Equality and inequality predicates.
* Numeric Conversions::     Converting float to integer and vice versa.
* Arithmetic Operations::   How to add, subtract, multiply and divide.
* Rounding Operations::     Explicitly rounding floating-point numbers.
* Bitwise Operations::      Logical and, or, not, shifting.
* Math Functions::          Trig, exponential and logarithmic functions.
* Random Numbers::          Obtaining random integers, predictable or not.

Strings and Characters

* String Basics::           Basic properties of strings and characters.
* Predicates for Strings::  Testing whether an object is a string or char.
* Creating Strings::        Functions to allocate new strings.
* Modifying Strings::       Altering the contents of an existing string.
* Text Comparison::         Comparing characters or strings.
* String Conversion::       Converting to and from characters and strings.
* Formatting Strings::      ‘format’: Emacs’s analogue of ‘printf’.
* Case Conversion::         Case conversion functions.
* Case Tables::             Customizing case conversion.

Lists

* Cons Cells::              How lists are made out of cons cells.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* List Variables::          Modifying lists stored in variables.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.
* Property Lists::          A list of paired elements.

Modifying Existing List Structure

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

Property Lists

* Plists and Alists::       Comparison of the advantages of property
                              lists and association lists.
* Plist Access::            Accessing property lists stored elsewhere.

Sequences, Arrays, and Vectors

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in Emacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Special characteristics of Emacs Lisp vectors.
* Vector Functions::        Functions specifically for vectors.
* Char-Tables::             How to work with char-tables.
* Bool-Vectors::            How to work with bool-vectors.
* Rings::                   Managing a fixed-size ring of objects.

Hash Tables

* Creating Hash::           Functions to create hash tables.
* Hash Access::             Reading and writing the hash table contents.
* Defining Hash::           Defining new comparison methods.
* Other Hash::              Miscellaneous.

Symbols

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Symbol Properties::       Each symbol has a property list
                              for recording miscellaneous information.

Symbol Properties

* Symbol Plists::           Accessing symbol properties.
* Standard Properties::     Standard meanings of symbol properties.

Evaluation

* Intro Eval::              Evaluation in the scheme of things.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).
* Backquote::               Easier construction of list structure.
* Eval::                    How to invoke the Lisp interpreter explicitly.

Kinds of Forms

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           "Special forms" are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

Control Structures

* Sequencing::              Evaluation in textual order.
* Conditionals::            ‘if’, ‘cond’, ‘when’, ‘unless’.
* Combining Conditions::    ‘and’, ‘or’, ‘not’.
* Iteration::               ‘while’ loops.
* Nonlocal Exits::          Jumping out of a sequence.

Nonlocal Exits

* Catch and Throw::         Nonlocal exits for the program’s own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

Errors

* Signaling Errors::        How to report an error.
* Processing of Errors::    What Emacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

Variables

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Tips for Defining::       Things you should think about when you
                              define a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.
* File Local Variables::    Handling local variable lists in files.
* Directory Local Variables:: Local variables common to all files in a
                                directory.
* Variable Aliases::        Variables that are aliases for other variables.
* Variables with Restricted Values::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.
* Generalized Variables::   Extending the concept of variables.

Scoping Rules for Variable Bindings

* Dynamic Binding::         The default for binding local variables in Emacs.
* Dynamic Binding Tips::    Avoiding problems with dynamic binding.
* Lexical Binding::         A different type of local variable binding.
* Using Lexical Binding::   How to enable lexical binding.

Buffer-Local Variables

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don’t have their own buffer-local values.

Generalized Variables

* Setting Generalized Variables::   The ‘setf’ macro.
* Adding Generalized Variables::    Defining new ‘setf’ forms.

Functions

* What Is a Function::      Lisp functions vs. primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Closures::                Functions that enclose a lexical environment.
* Obsolete Functions::      Declaring functions obsolete.
* Inline Functions::        Defining functions that the compiler
                              will expand inline.
* Declare Form::          Adding additional information about a function.
* Declaring Functions::     Telling the compiler that a function is defined.
* Function Safety::         Determining whether a function is safe to call.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

Macros

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Problems with Macros::    Don’t evaluate the macro arguments too many times.
                              Don’t hide the user’s variables.
* Indenting Macros::        Specifying how to indent macro calls.

Common Problems Using Macros

* Wrong Time::             Do the work in the expansion, not in the macro.
* Argument Evaluation::    The expansion should evaluate each macro arg once.
* Surprising Local Vars::  Local variable bindings in the expansion
                              require special care.
* Eval During Expansion::  Don’t evaluate them; put them in the expansion.
* Repeated Expansion::     Avoid depending on how many times expansion is done.

Customization Settings

* Common Keywords::         Common keyword arguments for all kinds of
                              customization declarations.
* Group Definitions::       Writing customization group definitions.
* Variable Definitions::    Declaring user options.
* Customization Types::     Specifying the type of a user option.
* Applying Customizations:: Functions to apply customization settings.
* Custom Themes::           Writing Custom themes.

Customization Types

* Simple Types::            Simple customization types: sexp, integer, etc.
* Composite Types::         Build new types from other types or data.
* Splicing into Lists::     Splice elements into list with ‘:inline’.
* Type Keywords::           Keyword-argument pairs in a customization type.
* Defining New Types::      Give your type a name.

Loading

* How Programs Do Loading:: The ‘load’ function and others.
* Load Suffixes::           Details about the suffixes that ‘load’ tries.
* Library Search::          Finding a library to load.
* Loading Non-ASCII::       Non-ASCII characters in Emacs Lisp files.
* Autoload::                Setting up a function to autoload.
* Repeated Loading::        Precautions about loading a file twice.
* Named Features::          Loading a library if it isn’t already loaded.
* Where Defined::           Finding which file defined a certain symbol.
* Unloading::               How to "unload" a library that was loaded.
* Hooks for Loading::       Providing code to be run when
                              particular libraries are loaded.

Byte Compilation

* Speed of Byte-Code::      An example of speedup from byte compilation.
* Compilation Functions::   Byte compilation functions.
* Docs and Compilation::    Dynamic loading of documentation strings.
* Dynamic Loading::         Dynamic loading of individual functions.
* Eval During Compile::     Code to be evaluated when you compile.
* Compiler Errors::         Handling compiler error messages.
* Byte-Code Objects::       The data type used for byte-compiled functions.
* Disassembly::             Disassembling byte-code; how to read byte-code.

Debugging Lisp Programs

* Debugger::                A debugger for the Emacs Lisp evaluator.
* Edebug::                  A source-level Emacs Lisp debugger.
* Syntax Errors::           How to find syntax errors.
* Test Coverage::           Ensuring you have tested all branches in your code.
* Profiling::               Measuring the resources that your code uses.

The Lisp Debugger

* Error Debugging::         Entering the debugger when an error happens.
* Infinite Loops::          Stopping and debugging a program that doesn’t exit.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function ‘debug’.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

Edebug

* Using Edebug::            Introduction to use of Edebug.
* Instrumenting::           You must instrument your code
                              in order to debug it with Edebug.
* Edebug Execution Modes::  Execution modes, stopping more or less often.
* Jumping::                 Commands to jump to a specified place.
* Edebug Misc::             Miscellaneous commands.
* Breaks::                  Setting breakpoints to make the program stop.
* Trapping Errors::         Trapping errors with Edebug.
* Edebug Views::            Views inside and outside of Edebug.
* Edebug Eval::             Evaluating expressions within Edebug.
* Eval List::               Expressions whose values are displayed
                              each time you enter Edebug.
* Printing in Edebug::      Customization of printing.
* Trace Buffer::            How to produce trace output in a buffer.
* Coverage Testing::        How to test evaluation coverage.
* The Outside Context::     Data that Edebug saves and restores.
* Edebug and Macros::       Specifying how to handle macro calls.
* Edebug Options::          Option variables for customizing Edebug.

Breaks

* Breakpoints::             Breakpoints at stop points.
* Global Break Condition::  Breaking on an event.
* Source Breakpoints::      Embedding breakpoints in source code.

The Outside Context

* Checking Whether to Stop::When Edebug decides what to do.
* Edebug Display Update::   When Edebug updates the display.
* Edebug Recursive Edit::   When Edebug stops execution.

Edebug and Macros

* Instrumenting Macro Calls::The basic problem.
* Specification List::      How to specify complex patterns of evaluation.
* Backtracking::            What Edebug does when matching fails.
* Specification Examples::  To help understand specifications.

Debugging Invalid Lisp Syntax

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.
* Output Variables::        Variables that control what the printing
                              functions do.

Minibuffers

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Minibuffer History::      Recording previous minibuffer inputs
                              so the user can reuse them.
* Initial Input::           Specifying initial contents for the minibuffer.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Multiple Queries::        Asking a series of similar questions.
* Reading a Password::      Reading a password from the terminal.
* Minibuffer Commands::     Commands used as key bindings in minibuffers.
* Minibuffer Windows::      Operating on the special minibuffer windows.
* Minibuffer Contents::     How such commands access the minibuffer text.
* Recursive Mini::          Whether recursive entry to minibuffer is allowed.
* Minibuffer Misc::         Various customization hooks and variables.

Completion

* Basic Completion::        Low-level functions for completing strings.
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer names, variable names, etc.).
* Reading File Names::      Using completion to read file names and
                              shell commands.
* Completion Variables::    Variables controlling completion behavior.
* Programmed Completion::   Writing your own completion function.
* Completion in Buffers::   Completing text in ordinary buffers.

Command Loop

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Distinguish Interactive::     Making a command distinguish interactive calls.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Adjusting Point::     Adjustment of point after a command.
* Input Events::        What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How ‘C-g’ works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn’t.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

Defining Commands

* Using Interactive::       General rules for ‘interactive’.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.
* Generic Commands::        Select among command alternatives.


Input Events

* Keyboard Events::         Ordinary characters–keys with symbols on them.
* Function Keys::           Function keys–keys with names, not symbols.
* Mouse Events::            Overview of mouse events.
* Click Events::            Pushing and releasing a mouse button.
* Drag Events::             Moving the mouse before releasing the button.
* Button-Down Events::      A button was pushed and not yet released.
* Repeat Events::           Double and triple click (or drag, or down).
* Motion Events::           Just moving the mouse, not pushing a button.
* Focus Events::            Moving the mouse between frames.
* Misc Events::             Other events the system can generate.
* Event Examples::          Examples of the lists for mouse events.
* Classifying Events::      Finding the modifier keys in an event symbol.
                              Event types.
* Accessing Mouse::         Functions to extract info from mouse events.
* Accessing Scroll::        Functions to get info from scroll bar events.
* Strings of Events::       Special considerations for putting
                              keyboard character events in a string.

Reading Input

* Key Sequence Input::      How to read one key sequence.
* Reading One Event::       How to read just one event.
* Event Mod::               How Emacs modifies events as they are read.
* Invoking the Input Method::   How reading an event uses the input method.
* Quoted Character Input::  Asking the user to specify a character.
* Event Input Misc::        How to reread or throw away input events.

Keymaps

* Key Sequences::           Key sequences as Lisp objects.
* Keymap Basics::           Basic concepts of keymaps.
* Format of Keymaps::       What a keymap looks like as a Lisp object.
* Creating Keymaps::        Functions to create and copy keymaps.
* Inheritance and Keymaps:: How one keymap can inherit the bindings
                              of another keymap.
* Prefix Keys::             Defining a key with a keymap as its definition.
* Active Keymaps::          How Emacs searches the active keymaps
                              for a key binding.
* Searching Keymaps::       A pseudo-Lisp summary of searching active maps.
* Controlling Active Maps:: Each buffer has a local keymap
                               to override the standard (global) bindings.
                               A minor mode can also override them.
* Key Lookup::              Finding a key’s binding in one keymap.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::   Redefining a key in a keymap.
* Remapping Commands::      A keymap can translate one command to another.
* Translation Keymaps::     Keymaps for translating sequences of events.
* Key Binding Commands::    Interactive interfaces for redefining keys.
* Scanning Keymaps::        Looking through all keymaps, for printing help.
* Menu Keymaps::            Defining a menu as a keymap.

Menu Keymaps

* Defining Menus::          How to make a keymap that defines a menu.
* Mouse Menus::             How users actuate the menu with the mouse.
* Keyboard Menus::          How users actuate the menu with the keyboard.
* Menu Example::            Making a simple menu.
* Menu Bar::                How to customize the menu bar.
* Tool Bar::                A tool bar is a row of images.
* Modifying Menus::         How to add new items to a menu.
* Easy Menu::               A convenience macro for defining menus.

Defining Menus

* Simple Menu Items::       A simple kind of menu key binding.
* Extended Menu Items::     More complex menu item definitions.
* Menu Separators::         Drawing a horizontal line through a menu.
* Alias Menu Items::        Using command aliases in menu items.

Major and Minor Modes

* Hooks::              How to use hooks; how to write code that provides hooks.
* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Imenu::              Providing a menu of definitions made in a buffer.
* Font Lock Mode::     How modes can highlight text according to syntax.
* Auto-Indentation::   How to teach Emacs to indent for a major mode.
* Desktop Save Mode::  How modes can have buffer state saved between
                         Emacs sessions.

Hooks

* Running Hooks::      How to run a hook.
* Setting Hooks::      How to put functions on a hook, or remove them.

Major Modes

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major
                              mode.
* Basic Major Modes::       Modes that other modes are often derived from.
* Mode Hooks::              Hooks run at the end of major mode functions.
* Tabulated List Mode::     Parent mode for buffers containing tabulated data.
* Generic Modes::           Defining a simple major mode that supports
                              comment syntax and Font Lock mode.
* Example Major Modes::     Text mode and Lisp modes.

Minor Modes

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.
* Defining Minor Modes::    A convenient facility for defining minor modes.

Mode Line Format

* Mode Line Basics::        Basic ideas of mode line control.
* Mode Line Data::          The data structure that controls the mode line.
* Mode Line Top::           The top level variable, mode-line-format.
* Mode Line Variables::     Variables used in that data structure.
* %-Constructs::            Putting information into a mode line.
* Properties in Mode::      Using text properties in the mode line.
* Header Lines::            Like a mode line, but at the top.
* Emulating Mode Line::     Formatting text as the mode line would.

Font Lock Mode

* Font Lock Basics::        Overview of customizing Font Lock.
* Search-based Fontification::  Fontification based on regexps.
* Customizing Keywords::    Customizing search-based fontification.
* Other Font Lock Variables::   Additional customization facilities.
* Levels of Font Lock::     Each mode can define alternative levels
                              so that the user can select more or less.
* Precalculated Fontification:: How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* Faces for Font Lock::     Special faces specifically for Font Lock.
* Syntactic Font Lock::     Fontification based on syntax tables.
* Multiline Font Lock::     How to coerce Font Lock into properly
                              highlighting multiline constructs.

Multiline Font Lock Constructs

* Font Lock Multiline::     Marking multiline chunks with a text property.
* Region to Refontify::     Controlling which region gets refontified
                              after a buffer change.

Automatic Indentation of code

* SMIE::                    A simple minded indentation engine.

Simple Minded Indentation Engine

* SMIE setup::              SMIE setup and features.
* Operator Precedence Grammars:: A very simple parsing technique.
* SMIE Grammar::            Defining the grammar of a language.
* SMIE Lexer::              Defining tokens.
* SMIE Tricks::             Working around the parser’s limitations.
* SMIE Indentation::        Specifying indentation rules.
* SMIE Indentation Helpers:: Helper functions for indentation rules.
* SMIE Indentation Example:: Sample indentation rules.
* SMIE Customization::      Customizing indentation.

Documentation

* Documentation Basics::    Where doc strings are defined and stored.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by Emacs help facilities.

Files

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into buffers without visiting.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                              simultaneous editing by two people.
* Information about Files:: Testing existence, accessibility, size of files.
* Changing Files::          Renaming files, changing permissions, etc.
* File Names::              Decomposing and expanding file names.
* Contents of Directories:: Getting a list of the files in a directory.
* Create/Delete Dirs::      Creating and Deleting Directories.
* Magic File Names::        Special handling for certain file names.
* Format Conversion::       Conversion to and from various file formats.

Visiting Files

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

Information about Files

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::               Eliminating symbolic links from a file name.
* File Attributes::         File sizes, modification times, etc.
* Extended Attributes::     Extended file attributes for access control.
* Locating Files::          How to find a file in standard places.

File Names

* File Name Components::    The directory part of a file name, and the rest.
* Relative File Names::     Some file names are relative to a current directory.
* Directory Names::         A directory’s name as a directory
                              is different from its name as a file.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.
* Standard File Names::     If your package uses a fixed file name,
                              how to handle various operating systems simply.

File Format Conversion

* Format Conversion Overview::   ‘insert-file-contents’ and ‘write-region’.
* Format Conversion Round-Trip:: Using ‘format-alist’.
* Format Conversion Piecemeal::  Specifying non-paired conversion.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               ‘revert-buffer’, and how to customize
                              what it does.

Backup Files

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Current Buffer::          Designating a buffer as current
                              so that primitives will access its contents.
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is “modified” if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              "behind Emacs’s back".
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* Buffer List::             How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Indirect Buffers::        An indirect buffer shares text with some
                              other buffer.
* Swapping Text::           Swapping text between two buffers.
* Buffer Gap::              The gap in the buffer.

Windows

* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window’s size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Recombining Windows::     Preserving the frame layout when splitting and
                              deleting windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for ‘display-buffer’.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

Frames

* Creating Frames::         Creating additional frames.
* Multiple Terminals::      Displaying on several different devices.
* Frame Parameters::        Controlling frame size, position, font, etc.
* Terminal Parameters::     Parameters common for all frames on terminal.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::         Frames last until explicitly deleted.
* Finding All Frames::      How to examine all existing frames.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::             Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other windows;
                              lowering it makes the others hide it.
* Frame Configurations::    Saving the state of all frames.
* Mouse Tracking::          Getting events that say when the mouse moves.
* Mouse Position::          Asking where the mouse is, or moving it.
* Pop-Up Menus::            Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shape::           Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other X clients.
* Drag and Drop::               Internals of Drag-and-Drop implementation.
* Color Names::             Getting the definitions of color names.
* Text Terminal Colors::    Defining colors for text terminals.
* Resources::               Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

Frame Parameters

* Parameter Access::        How to change a frame’s parameters.
* Initial Parameters::      Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Size and Position::       Changing the size and position of a frame.
* Geometry::                Parsing geometry specifications.

Window Frame Parameters

* Basic Parameters::        Parameters that are fundamental.
* Position Parameters::     The position of the frame on the screen.
* Size Parameters::         Frame’s size.
* Layout Parameters::       Size of parts of the frame, and
                              enabling or disabling some parts.
* Buffer Parameters::       Which buffers have been or should be shown.
* Management Parameters::   Communicating with the window manager.
* Cursor Parameters::       Controlling the cursor appearance.
* Font and Color Parameters:: Fonts and colors for the frame text.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::Finding the marker’s buffer or character position.
* Marker Insertion Types::  Two ways a marker can relocate when you
                              insert where it points.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How "the mark" is implemented with a marker.
* The Region::              How to access "the region".

Text

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Comparing Text::          Comparing substrings of buffers.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Maintaining Undo::        How to enable and disable undo information.
                              How to control how much information is kept.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Adaptive Fill::           Adaptive Fill mode chooses a fill prefix
                              from context.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Sorting::                 Functions for sorting parts of the buffer.
* Columns::                 Computing horizontal positions, and using them.
* Indentation::             Functions to insert or adjust indentation.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Transposition::           Swapping two portions of a buffer.
* Decompression::           Dealing with compressed data.
* Base 64::                 Conversion to or from base 64 encoding.
* Checksum/Hash::           Computing cryptographic hashes.
* Parsing HTML/XML::        Parsing HTML and XML.
* Atomic Changes::          Installing several buffer changes "atomically".
* Change Hooks::            Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yanking::                 How yanking is done.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::     Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Text Properties

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::     Setting the properties of a range of text.
* Property Search::         Searching for where a property changes value.
* Special Properties::      Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The ‘field’ property defines
                              fields within the buffer.
* Not Intervals::           Why text properties do not use
                              Lisp-visible text intervals.

Non-ASCII Characters

* Text Representations::    How Emacs represents text.
* Disabling Multibyte::     Controlling whether to use multibyte characters.
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Properties::    Character attributes that define their
                                behavior and handling.
* Character Sets::          The space of possible character codes
                                is divided into various character sets.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

Coding Systems

* Coding System Basics::    Basic concepts.
* Encoding and I/O::        How file I/O functions handle coding systems.
* Lisp and Coding Systems:: Functions to operate on coding system names.
* User-Chosen Coding Systems::  Asking the user to choose a coding system.
* Default Coding Systems::  Controlling the default choices.
* Specifying Coding Systems::   Requesting a particular coding system
                                    for a single file operation.
* Explicit Encoding::       Encoding or decoding text without doing I/O.
* Terminal I/O Encoding::   Use of encoding for terminal I/O.

Searching and Matching

* String Search::           Search for an exact match.
* Searching and Case::      Case-independent or case-significant searching.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* POSIX Regexps::           Searching POSIX-style for the longest match.
* Match Data::              Finding out which part of the text matched,
                              after a string or regexp search.
* Search and Replace::      Commands that loop, searching and replacing.
* Standard Regexps::        Useful regexps for finding sentences, pages,...

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
* Regexp Functions::        Functions for operating on regular expressions.

Syntax of Regular Expressions

* Regexp Special::          Special characters in regular expressions.
* Char Classes::            Character classes used in regular expressions.
* Regexp Backslash::        Backslash-sequences in regular expressions.

The Match Data

* Replacing Match::         Replacing a substring that was matched.
* Simple Match Data::       Accessing single items of match data,
                              such as where a particular subexpression started.
* Entire Match Data::       Accessing the entire match data at once, as a list.
* Saving Match Data::       Saving and restoring the match data.

Syntax Tables

* Syntax Basics::           Basic concepts of syntax tables.
* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Syntax Properties::       Overriding syntax with text properties.
* Motion and Syntax::       Moving over characters with certain syntaxes.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Syntax Table Internals::  How syntax table information is stored.
* Categories::              Another way of classifying character syntax.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Parsing Expressions

* Motion via Parsing::      Motion functions that work by parsing.
* Position Parse::          Determining the syntactic state of a position.
* Parser State::            How Emacs represents a syntactic state.
* Low-Level Parsing::       Parsing across a specified region.
* Control Parsing::         Parameters that affect parsing.

Abbrevs and Abbrev Expansion

* Abbrev Tables::           Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Abbrev Files::            Saving abbrevs in files.
* Abbrev Expansion::        Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.
* Abbrev Properties::       How to read and set abbrev properties.
                            Which properties have which effect.
* Abbrev Table Properties:: How to read and set abbrev table properties.
                            Which properties have which effect.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Shell Arguments::         Quoting an argument to pass it to a shell.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Query Before Exit::       Whether to query if exiting will kill a process.
* System Processes::        Accessing other processes running on your system.
* Transaction Queues::      Transaction-based communication with subprocesses.
* Network::                 Opening network connections.
* Network Servers::         Network servers let Emacs accept net connections.
* Datagrams::               UDP network connections.
* Low-Level Network::       Lower-level but more general function
                              to create connections and servers.
* Misc Network::            Additional relevant functions for net connections.
* Serial Ports::            Communicating with serial ports.
* Byte Packing::            Using bindat to pack and unpack binary data.

Receiving Output from Processes

* Process Buffers::         By default, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.

Low-Level Network Access

* Network Processes::       Using ‘make-network-process’.
* Network Options::         Further control over network connections.
* Network Feature Testing:: Determining which network features work on
                              the machine you are using.

Packing and Unpacking Byte Arrays

* Bindat Spec::             Describing data layout.
* Bindat Functions::        Doing the unpacking and packing.
* Bindat Examples::         Samples of what bindat.el can do for you!

Emacs Display

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Forcing Redisplay::       Forcing redisplay.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Displaying messages at the bottom of the screen.
* Warnings::                Displaying warning messages for the user.
* Invisible Text::          Hiding part of the buffer text.
* Selective Display::       Hiding part of the buffer text (the old way).
* Temporary Displays::      Displays that go away automatically.
* Overlays::                Use overlays to highlight parts of the buffer.
* Size of Displayed Text::  How large displayed text is.
* Line Height::             Controlling the height of lines.
* Faces::                   A face defines a graphics style
                              for text characters: font, colors, etc.
* Fringes::                 Controlling window fringes.
* Scroll Bars::             Controlling vertical scroll bars.
* Window Dividers::         Separating windows visually.
* Display Property::        Enabling special display features.
* Images::                  Displaying images in Emacs buffers.
* Buttons::                 Adding clickable buttons to Emacs buffers.
* Abstract Display::        Emacs’s Widget for Object Collections.
* Blinking::                How Emacs shows the matching open parenthesis.
* Character Display::       How Emacs displays individual characters.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.
* Bidirectional Display::   Display of bidirectional scripts, such as
                              Arabic and Farsi.

The Echo Area

* Displaying Messages::     Explicitly displaying text in the echo area.
* Progress::                Informing user about progress of a long operation.
* Logging Messages::        Echo area messages are logged for the user.
* Echo Area Customization:: Controlling the echo area.

Reporting Warnings

* Warning Basics::          Warnings concepts and functions to report them.
* Warning Variables::       Variables programs bind to customize
                              their warnings.
* Warning Options::         Variables users set to control display of warnings.
* Delayed Warnings::        Deferring a warning until the end of a command.

Overlays

* Managing Overlays::       Creating and moving overlays.
* Overlay Properties::      How to read and set properties.
                              What properties do to the screen display.
* Finding Overlays::        Searching for overlays.

Faces

* Face Attributes::         What is in a face?
* Defining Faces::          How to define a face.
* Attribute Functions::     Functions to examine and set face attributes.
* Displaying Faces::        How Emacs combines the faces specified for
                              a character.
* Face Remapping::          Remapping faces to alternative definitions.
* Face Functions::          How to define and examine faces.
* Auto Faces::              Hook for automatic face assignment.
* Basic Faces::             Faces that are defined by default.
* Font Selection::          Finding the best available font for a face.
* Font Lookup::             Looking up the names of available fonts
                              and information about them.
* Fontsets::                A fontset is a collection of fonts
                              that handle a range of character sets.
* Low-Level Font::          Lisp representation for character display fonts.

Fringes

* Fringe Size/Pos::         Specifying where to put the window fringes.
* Fringe Indicators::       Displaying indicator icons in the window fringes.
* Fringe Cursors::          Displaying cursors in the right fringe.
* Fringe Bitmaps::          Specifying bitmaps for fringe indicators.
* Customizing Bitmaps::     Specifying your own bitmaps to use in the fringes.
* Overlay Arrow::           Display of an arrow to indicate position.

The ‘display’ Property

* Replacing Specs::         Display specs that replace the text.
* Specified Space::         Displaying one space with a specified width.
* Pixel Specification::     Specifying space width or height in pixels.
* Other Display Specs::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* Display Margins::         Displaying text or images to the side of
                              the main text.

Images

* Image Formats::           Supported image formats.
* Image Descriptors::       How to specify an image for use in ‘:display’.
* XBM Images::              Special features for XBM format.
* XPM Images::              Special features for XPM format.
* PostScript Images::       Special features for PostScript format.
* ImageMagick Images::      Special features available through ImageMagick.
* Other Image Types::       Various other formats are supported.
* Defining Images::         Convenient ways to define an image for later use.
* Showing Images::          Convenient ways to display an image once
                              it is defined.
* Multi-Frame Images::      Some images contain more than one frame.
* Image Cache::             Internal mechanisms of image display.

Buttons

* Button Properties::       Button properties with special meanings.
* Button Types::            Defining common properties for classes of buttons.
* Making Buttons::          Adding buttons to Emacs buffers.
* Manipulating Buttons::    Getting and setting properties of buttons.
* Button Buffer Commands::  Buffer-wide commands and bindings for buttons.

Abstract Display

* Abstract Display Functions::  Functions in the Ewoc package.
* Abstract Display Example::    Example of using Ewoc.

Character Display

* Usual Display::       The usual conventions for displaying characters.
* Display Tables::      What a display table consists of.
* Active Display Table::  How Emacs selects a display table to use.
* Glyphs::              How to define a glyph, and what glyphs mean.
* Glyphless Chars::     How glyphless characters are drawn.

Operating System Interface

* Starting Up::             Customizing Emacs startup processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* User Identification::     Finding the name and user id of the user.
* Time of Day::             Getting the current time.
* Time Conversion::         Converting a time from numeric form to
                              calendrical data and vice versa.
* Time Parsing::            Converting a time from numeric form to text
                              and vice versa.
* Processor Run Time::      Getting the run time used by Emacs.
* Time Calculations::       Adding, subtracting, comparing times, etc.
* Timers::                  Setting a timer to call a function at a
                              certain time.
* Idle Timers::             Setting a timer to call a function when Emacs has
                              been idle for a certain length of time.
* Terminal Input::          Accessing and recording terminal input.
* Terminal Output::         Controlling and recording terminal output.
* Sound Output::            Playing sounds on the computer’s speaker.
* X11 Keysyms::             Operating on key symbols for X Windows.
* Batch Mode::              Running Emacs without terminal interaction.
* Session Management::      Saving and restoring state with
                              X Session Management.
* Desktop Notifications::   Desktop notifications.
* File Notifications::      File notifications.
* Dynamic Libraries::       On-demand loading of support libraries.

Starting Up Emacs

* Startup Summary::         Sequence of actions Emacs performs at startup.
* Init File::               Details on reading the init file.
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command-line arguments are processed,
                              and how you can customize them.

Getting Out of Emacs

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Terminal Input

* Input Modes::             Options for how input is processed.
* Recording Input::         Saving histories of recent or all input events.

Preparing Lisp code for distribution

* Packaging Basics::        The basic concepts of Emacs Lisp packages.
* Simple Packages::         How to package a single .el file.
* Multi-file Packages::     How to package multiple files.
* Package Archives::        Maintaining package archives.

Tips and Conventions

* Coding Conventions::      Conventions for clean and robust programs.
* Key Binding Conventions:: Which keys should be bound by which programs.
* Programming Tips::        Making Emacs code fit smoothly in Emacs.
* Compilation Tips::        Making compiled code run fast.
* Warning Tips::            Turning off compiler warnings.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::            Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

GNU Emacs Internals

* Building Emacs::          How the dumped Emacs is made.
* Pure Storage::            Kludge to make preloaded Lisp functions shareable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Memory Usage::            Info about total size of Lisp objects made so far.
* Writing Emacs Primitives::  Writing C code for Emacs.
* Object Internals::        Data formats of buffers, windows, processes.

Object Internals

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.


File: elisp,  Node: Introduction,  Next: Lisp Data Types,  Prev: Top,  Up: Top

1 Introduction
**************

GNU Emacsテキストエディターのほとんどの部分は、Emacs Lispと呼ばれるプロ
グラミング言語で記述されています。新しいコードをEmacs Lispで記述して、こ
のエディターの拡張としてインストールできます。しかしEmacs Lispは、単なる
“拡張言語”を越えた言語であり、それ自体で完全なコンピュータープログラミン
グ言語です。他のプログラミング言語で行なうすべてのことに、この言語を使用
できます。

   Emacs Lispはエディターの中で使用するようにデザインされているので、テ
キストのスキャンやパースのための特別な機能をもち、同様にファイル、バッフ
ァー、ディスプレー、サブプロセスを処理する機能をもちます。Emacs Lispは編
集機能と密に統合されています。したがって編集コマンドはLispプログラムから
簡単に呼び出せる関数であり、カスタマイズのためのパラメーターは普通の
Lisp変数です。

   このマニュアルはEmacs Lispの完全な記述を試みます。初心者のためのEmacs
Lispのイントロダクションは、Free Software Foundationからも出版されている
、Bob Chassellの‘An Introduction to Emacs Lisp Programming’を参照してく
ださい。このマニュアルは、Emacsを使用した編集に熟知していることを前提と
しています。これの基本的な情報については、‘The GNU Emacs Manual’を参照し
てください。

   おおまかに言うと、前の方のチャプターでは多くのプログラミング言語に対
応するEmacs Lispの機能について説明し、後のチャプターではEmacs Lispに特異
な機能や、特に編集に関連した機能を説明します。

   これは Emacs 24.5に対応した‘GNU Emacs Lisp Reference Manual’です。

* Menu:

* Caveats::                  不備な点と、助けを求める方法。
* Lisp History::             Emacs LispはMaclispが由来です。
* Conventions::              このマニュアルがフォーマットされた方法。
* Version Info::             実行中のEmacsのバージョンは?
* Acknowledgments::          このマニュアルの著者、編集者、スポンサー。


File: elisp,  Node: Caveats,  Next: Lisp History,  Up: Introduction

1.1 Caveats
===========

このマニュアルは幾多のドラフトを経てきました。ほとんど完璧ではありますが
、不備がないとも言えません。(ほとんどの特定のモードのように)それらが副次
的であるとか、まだ記述されていないという理由により、カバーされていないト
ピックもあります。わたしたちがそれらを完璧に扱うことはできないので、いく
つかの部分は意図的に省略しました。

   このマニュアルは、それがカバーしている事柄については完全に正しくある
べきあり、故に、特定の説明テキスト、チャプターやセクションの順番にたいし
ての批判に開かれているべきです。判りにくかったり、このマニュアルでカバー
されていない何かを学ぶためにソースを見たり実験から学ぶ必要があるなら、こ
のマニュアルはおそらくフィクスされるべきなのかもしれません。わたしたちに
それを教えてください。

   このマニュアルを使用するときは、間違いを見つけたらすぐに訂正を送って
ください。関数または間数グループの単純な現実例を考えたときは、ぜひそれを
記述して送ってください。それが妥当ならコメントでノード名と関数名や変数名
を参照してください。あなたが訂正を求めるエディションのバージョンも示して
ください。

   ‘M-x report-emacs-bug’を使用してコメントや訂正を送ってください。


File: elisp,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Lisp History
================

Lisp(LISt Processing language: リスト処理言語)は、MIT(Massachusetts
Institute of Technology: マサチューセッツ工科大学)で、AI(artificial
intelligence: 人工知能)の研究のために、1950年代末に最初に開発されました
。Lisp言語の強力なパワーは、編集コマンドの記述のような、他の目的にも適っ
ています。

   長年の間に何ダースものLisp実装が構築されてきて、それぞれ特異な点があ
ります。これらの多くは、1960年代にMITのProject MACで記述された、
Maclispに影響を受けています。最終的に、Maclisp後裔の実装者は共同して、
Common Lispと呼ばれる標準のLispシステムを開発しました。その間に、MITの
Gerry SussmanとGuy Steeleにより、簡潔だがとても強力なLisp方言である、
Schemeが開発されました。

   GNU Emacs LispはMaclispから多く、Common Lispから少し影響を受けていま
す。Common Lispを知っている場合、多くの類似点に気がつくでしょう。しかし
Common Lispの多くの機能は、GNU Emacsが要求するメモリー量を削減するために
、省略されるか単純化されています。ときには劇的に単純化がされているために
、Common Lispユーザーは混乱するかもしれません。わたしたちは時折GNU Emacs
LispがCommon Lispと異なるか示すでしょう。Common Lispを知らない場合、それ
について心配する必要はありません。このマニュアルは自己完結しています。

   ‘cl-lib’ライブラリーを通じて、Common Lispをかなりエミュレートできます
。*note Overview: (cl)Top.を参照してください。

   Emacs LispはSchemeの影響は受けていません。しかしGNUプロジェクトには
Guileと呼ばれるScheme実装があります。拡張が必要な新しいGNUソフトウェアー
では、Guileを使用します。


File: elisp,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

1.3 Conventions
===============

このセクションでは、このマニュアルで使用する表記規約を説明します。あなた
はこのセクションはスキップして、後で参照したいと思うかもしれません。

* Menu:

* Some Terms::               このマニュアルで使用する用語の説明。
* nil and t::                シンボル‘nil’と‘t’の使用方法。
* Evaluation Notation::      評価の例で使用するフォーマット。
* Printing Notation::        テキストのプリント例で使用するフォーマット。
* Error Messages::           エラー例で使用するフォーマット。
* Buffer Text Notation::     例のバッファー内容で使用するフォーマット。
* Format of Descriptions::   関数や変数などの説明にたいする表記。


File: elisp,  Node: Some Terms,  Next: nil and t,  Up: Conventions

1.3.1 Some Terms
----------------

このマニュアルでは、“Lispリーダー”および“Lispプリンター”という用語で、
Lispのテキスト表現を実際のLispオブジェクトに変換したり、その逆を行なう
Lispルーチンを参照します。詳細については、*note Printed
Representation::を参照してください。あなた、つまりこのマニュアルを読んで
いる人のことは“プログラマー”と考えて“あなた”と呼びます。“ユーザー”とは、
あなたの記述したものも含めて、Lispプログラムを使用する人を指します。

   Lispコードの例は、‘(list 1 2 3)’のようなフォーマットです。 Examples
of Lisp code are formatted like this: ‘(list 1 2 3)’. メタ構文変数
(metasyntactic variables)を表す名前や、説明されている関数の引数名前は、
FIRST-NUMBERのような形式です。


File: elisp,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 ‘nil’ and ‘t’
-------------------

Emacs Lispでは、シンボル‘nil’には3つの異なる意味があります。1つ目は
‘nil’という名前のシンボル、2つ目は論理値のFALSE、3つ目は空リスト — つま
り要素が0のリストです。変数として使用した場合、‘nil’は常に値‘nil’をもち
ます。

   Lispリーダーに関する限り、‘()’と‘nil’は同一です。これらは同じオブジェ
クト、つまりシンボル‘nil’を意味します。このシンボルを異なる方法で記述す
るのは、完全に人間の読み手を意図したものです。Lispリーダーが‘()’か
‘nil’のどちらかを読み取った後は、プログラマーが実際にどちらの表現で記述
したかを判断する方法はありません。

   このマニュアルでは、空リストを意味することを強調したいときは‘()’と記
述し、論理値のFALSEを意味することを強調したいときは‘nil’と記述します。こ
の慣習はLispプログラムで使用してもよいでしょう。

     (cons 'foo ())                ; 空リストを強調します
     (setq foo-flag nil)           ; 論理値のFALSEを強調します

   論理値が期待されているコンテキストでは、非‘nil’はTRUEと判断されます。
しかし論理値のTRUEを表す好ましい方法は‘t’です。TRUEを表す値を選択する必
要があり、他に選択の根拠がない場合は、‘t’を使用してください。シンボル
‘t’は、常に値‘t’をもちます。

   Emacs Lispでは、‘nil’と‘t’は、常に自分自身を評価する、特別なシンボル
です。そのためプログラムでこれらを定数として使用する場合、クォートする必
要はありません。これらの値を変更使用と試みると、結果は
‘setting-constant’エラーとなります。*note Constant Variables::を参照して
ください。

 -- Function: booleanp object
     OBJECTが、2つのカノニカルなブーリーン値(‘t’または‘nil’)の場合は、非
     ‘nil’をリターンします。


File: elisp,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

1.3.3 Evaluation Notation
-------------------------

評価することができるLisp式のことを、“フォーム(form)”と呼びます。フォーム
の評価により、常に結果としてLispオブジェクトが生成されます。このマニュア
ルの例では、これを‘⇒’で示します:

     (car '(1 2))
          ⇒ 1

これは、“‘(car '(1 2))’を評価すると1になる”と読むことができます。

   フォームがマクロ呼び出しの場合、それは評価されるための新しいLispのフ
ォームに展開されます。展開された結果は‘↦’で示します。展開されたフォーム
を評価した結果を示すこともあれば、示さない場合もあります。

     (third '(a b c))
          ↦ (car (cdr (cdr '(a b c))))
          ⇒ c

   1つのフォームを説明するために、同じ結果を生成する別のフォームを示すこ
ともあります。完全に等価な2つのフォームは、‘≡’で示します。

     (make-sparse-keymap) ≡ (list 'keymap)


File: elisp,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.4 Printing Notation
-----------------------

このマニュアルの例の多くは、それらが評価されるときにテキストをプリントし
ます。(‘*scratch*’バッファーのような)Lisp Interactionバッファーでコード
例を実行する場合、プリントされるテキストはそのバッファーに挿入されます。
(関数‘eval-region’で評価するなど)他の方法でコード例を実行する場合、プリ
ントされるテキストはエコーエリアに表示されます。

   このマニュアルの例はプリントされるテキストがどこに出力されるかに関わ
らず、それを‘⊣’で示します。フォームを評価することにより戻される値は、
‘⇒’とともに後続の行で示します。

     (progn (prin1 'foo) (princ "\n") (prin1 'bar))
          ⊣ foo
          ⊣ bar
          ⇒ bar


File: elisp,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

1.3.5 Error Messages
--------------------

エラーをシグナルする例も、いくつかあります。これは通常、エコーエリアにエ
ラーメッセージを表示します。エラーメッセージの行は、‘error→’で始まります
。‘error→’自体は、エコーエリアに表示されないことに注意してください。

     (+ 23 'x)
     error→ Wrong type argument: number-or-marker-p, x


File: elisp,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.6 Buffer Text Notation
--------------------------

バッファー内容の変更を説明する例もあり、それらの例ではテキストの
“before(以前)”と“after(以後)”のバージョンを示します。それらの例では、バ
ッファー内容の該当する部分を、ダッシュを用いた2行の破線(バッファー名を含
む)で示します。さらに、‘★’はポイントの位置を示します(もちろんポイントの
シンボルは、バッファーのテキストの一部ではなく、それはポイントが現在配さ
れている2つの文字の_間_の位置を示します)。

     ---------- Buffer: foo ----------
     This is the ★contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          ⇒ nil
     ---------- Buffer: foo ----------
     This is the changed ★contents of foo.
     ---------- Buffer: foo ----------


File: elisp,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

1.3.7 Format of Descriptions
----------------------------

このマニュアルでは関数(function)、変数(variable)、コマンド(command)、ユ
ーザーオプション(user option)、スペシャルフォーム(special form)を、統一
されたフォーマットで記述します。記述の最初の行には、そのアイテムの名前と
、もしあれば引数(argument)が続きます。 そのアイテムの属するカテゴリー
(function、variableなど)は、行の先頭に表示します。 それ以降の行は説明行
で、例を含む場合もあります。

* Menu:

* A Sample Function Description::  架空の関数‘foo’にたいする記述例。
* A Sample Variable Description::  架空の変数‘electric-future-map’にたいする記述例。


File: elisp,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Up: Format of Descriptions

1.3.7.1 A Sample Function Description
.....................................

関数の記述では、関数の名前が最初に記述されます。同じ行に引数の名前のリス
トが続きます。引数の値を参照するために、引数の名前は記述の本文にも使用さ
れます。

   引数リストの中にキーワード‘&optional’がある場合、その後の引数が省略可
能であることを示します(省略された引数のデフォルトは‘nil’です)。その関数
を呼び出すときは、‘&optional’を記述しないでください。

   キーワード‘&rest’(これの後には1つの引数名を続けなければなりません)は
、その後に任意の引数を続けることができることを表します。‘&rest’の後に記
述された引数名の値には、その関数に渡された残りのすべての引数がリストとし
てセットされます。この関数を呼び出すときは、‘&rest’を記述しないでくださ
い。

   以下は‘foo’という架空の関数(function)の説明です:

 -- Function: foo integer1 &optional integer2 &rest integers
     関数‘foo’はINTEGER2からINTEGER1を減じてから、その結果に残りすべての
     引数を加えます。INTEGER2が与えられなかった場合、デフォルトして数値
     19が使用されます。

          (foo 1 5 3 9)
               ⇒ 16
          (foo 5)
               ⇒ 14

     より一般的には、

          (foo W X Y...)
          ≡
          (+ (- X W) Y...)

   慣例として引数の名前には、(たとえばINTEGER、INTEGER1、BUFFERのような
)期待されるタイプ名が含めます。(BUFFERSのような)複数形のタイプは、しばし
ばそのタイプのオブジェクトのリストを意味します。OBJECTのような引き数名は
、それが任意のタイプであることを表します(Emacsオブジェクトタイプのリスト
は、*note Lisp Data Types::を参照してください)。他の名前をもつ引数(たと
えばNEW-FILE)は、関数に固有の引数で、関数がドキュメント文字列をもつ場合
、引数のタイプはその中で説明されるべきです(*note Documentation::を参照し
てください)。

   ‘&optional’や‘&rest’により修飾される引数の、より完全な説明は、*note
Lambda Expressions::を参照してください。

   コマンド(command)、マクロ(macro)、スペシャルフォーム(special form)の
説明も同じフォーマットをもちますが、‘Function’が‘Command’、‘Macro’、
‘Special Form’に置き換えられます。コマンドは単にインタラクティブに呼び出
すことができる関数です。マクロは関数とは違う方法(引数は評価されません)で
引数を処理しますは、同じ方法で記述されます。

   マクロとスペシャルフォームにたいする説明には、特定のオプション引数や
繰り替えされる引数のために、より複雑な表記が使用されます。なぜなら引数リ
ストが、より複雑な方法で別の引数に分離されるからです。‘[OPTIONAL-ARG]’は
OPTIONAL-ARGがオプションであることを意味し、‘REPEATED-ARGS...’は0個以上
の引数を表します。カッコ(parentheses)は、複数の引数をリスト構造の追加レ
ベルにグループ化するのに使用されます。以下は例です:

 -- Special Form: count-loop (var [from to [inc]]) body...
     この架空のスペシャルフォームは、 BODYフォームを実行してから変数
     VARをインクリメントするループを実装します。最初の繰り返しでは変数は
     値FROMをもちます。以降の繰り返しでは、変数は1(INCが与えられた場合は
     INC)増加されます。VARがTOに等しい場合、BODYを実行する前にループを
     exitします。以下は例です:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOが省略された場合、ループを実行する前にVARに‘nil’がバインド
     され、繰り返しの先頭においてVARが非‘nil’の場合は、ループをexitしま
     す。以下は例です:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは、引数FROMおよびTOはオプションですが、両
     方を指定するか、両方を未指定にしなければなりません。これらの引数が
     与えられた場合、オプションでINCも同様に指定することができます。これ
     らの引数は、フォームのすべての残りの要素を含むBODYと区別するために
     、引数VARとともにリストにグループ化されます。


File: elisp,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

1.3.7.2 A Sample Variable Description
.....................................

“変数(variable)”とは、オブジェクトに“バインド(bind)”(または“set”)される
名前です。変数がバインドされたオブジェクトのことを“値(value)”と呼びます
。このような場合、その変数が値をもつ、という言い方もします。ほとんどすべ
ての変数はユーザーがセットすることができますが、特にユーザーが変更できる
特定の変数も存在し、これらは“ユーザーオプション(user options)”と呼ばれま
す。通常の変数およびユーザーオプションは、関数と同様のフォーマットを使用
して説明されますが、それらには引数がありません。

   以下は架空の変数‘electric-future-map’にたいする説明です。

 -- Variable: electric-future-map
     この変数の値はElectric Command Futureモードで使用される完全なキーマ
     ップです。このマップの関数により、まだ実行していないコマンドの編集
     が可能になります。

   ユーザーオプションも同じフォーマットをもちますが、‘Variable’が‘User
Option’に置き換えられます。


File: elisp,  Node: Version Info,  Next: Acknowledgments,  Prev: Conventions,  Up: Introduction

1.4 Version Information
=======================

以下の機能は使用しているEmacsに関する情報を提供します。

 -- Command: emacs-version &optional here
     この関数は実行しているEmacsのバージョンを説明する文字列をreturnそま
     す。バグレポートにこの文字列を含めるときに役立ちます。

          (emacs-version)
            ⇒ "GNU Emacs 23.1 (i686-pc-linux-gnu, GTK+ Version 2.14.4)
                       of 2009-06-01 on cyd.mit.edu"

     HEREが非‘nil’の場合、関数はテキストをバッファーのポイントの前に挿入
     し、‘nil’をreturnします。この関数がインタラクティブに呼び出された場
     合は、同じ情報をエコーエリアに出力しますが、プレフィクス引数を与え
     た場合は、HEREが非‘nil’になります。

 -- Variable: emacs-build-time
     この変数の値は、Emacsがビルドされた日時を示します。値は、
     ‘current-time’の値と同様の、4つの整数からなるリストです(*note Time
     of Day::を参照してください)。

          emacs-build-time
               ⇒ (20614 63694 515336 438000)

 -- Variable: emacs-version
     この変数の値は実行中のEmacsのバージョンで、‘"23.1.1"’のような文字列
     です。この文字列の最後の数字は、実際にはEmacsのリリースバージョン番
     号の一部ではなく、任意のディレクトリーにおいてEmacsがビルドされる度
     にインクリメントされます。‘"22.0.91.1"’のように4つの数字から構成さ
     れる値は、それがリリースではないテストバージョンであることを示しま
     す。

 -- Variable: emacs-major-version
     Emacsのメジャーバージョン番号を示す整数です。Emacs 23.1では、値は
     23になります。

 -- Variable: emacs-minor-version
     Emacsのマイナーバージョン番号をしめす整数です。Emacs 23.1では、値は
     1になります。


File: elisp,  Node: Acknowledgments,  Prev: Version Info,  Up: Introduction

1.5 Acknowledgments
===================

このマニュアルは当初、Robert Krawitz、Bil Lewis、Dan LaLiberte、
Richard M. Stallman、Chris Welty、GNUマニュアルグループのボランティアー
により、数年を費やして記述されました。Robert J. Chassellはこのマニュアル
のレビューと編集をDefense Advanced Research Projects Agency、ARPA Order
6082のサポートのもとに手助けしてくれ、Computational Logic, Incの
Warren A. Hunt, Jr.によりアレンジされました。それ以降も、追加のセクショ
ンがMiles Bader、Lars Brinkhoff、Chong Yidong、Kenichi Handa、Lute
Kamstra、Juri Linkov、Glenn Morris、Thien-Thi Nguyen、Dan Nicolaescu、
Martin Rudalics、Kim F. Storm、Luc Teirlinck、Eli Zaretskii、およびその
他の人たちにより記述されました。

   Drew Adams、Juanma Barranquero、Karl Berry、Jim Blandy、Bard Bloom、
Stephane Boucher、David Boyes、Alan Carroll、Richard Davis、Lawrence R.
Dodd、Peter Doornbosch、David A. Duff、Chris Eich、Beverly Erlebacher、
David Eckelkamp、Ralf Fassel、Eirik Fuller、Stephen Gildea、Bob
Glickstein、Eric Hanchrow、Jesper Harder、George Hartzell、Nathan Hess、
Masayuki Ida、Dan Jacobson、Jak Kirman、Bob Knighten、Frederick M. Korz、
Joe Lammens、Glenn M. Lewis、K. Richard Magill、Brian Marick、Roland
McGrath、Stefan Monnier、Skip Montanaro、John Gardiner Myers、Thomas A.
Peterson、Francesco Potortì、Friedrich Pukelsheim、Arnold D. Robbins、
Raul Rockwell、Jason Rumney、Per Starbäck、Shinichirou Sugou、Kimmo
Suominen、Edward Tharp、Bill Trost、Rickard Westman、Jean White、Eduard
Wiebe、Matthew Wilding、Carl Witty、Dale Worley、Rusty Wright、David D.
Zuhnにより訂正が提供されました。

   より完全な貢献者のリストは、Emacsソースリポジトリーの関連する変更ログ
エントリーを参照してください。


File: elisp,  Node: Lisp Data Types,  Next: Numbers,  Prev: Introduction,  Up: Top

2 Lisp Data Types
*****************

Lispの“オブジェクト(object)”とは、Lispおプログラムにより操作されるデータ
です。“型(type)”や“データ型(data type)”は、可能なオブジェクトの集合を意
味します。

   すべてのオブジェクトは少なくとも1つの型に属します。同じ型のオブジェク
トは、同様な構造をもち、通常は同じコンテキストで使用されます。型は重複で
き、オブジェクトは複数の型に属することができます。結果として、あるオブジ
ェクトが特定の型に属するかどうかを尋ねることはできますが、オブジェクトが
“その”型だけに属するかどうかは決定できません。

   多くはありませんがEmacsにはいくつかの基本オブジェクト型が組み込まれて
います。これらの型は、他のすべての型を構成するもとであり、“基本型
(primitive types)”と呼ばれます。すべてのオブジェクトはただ1つの基本型に
属します。これらの型には、“整数(integer)”、“浮動小数点数(float)”、“コン
ス(cons)”、“シンボル(symbol)”、“文字列(string)”、“ベクター(vector)”、“ハ
ッシュテーブル(hash-table)”、“サブルーチン(subr)”、“バイトコード関数
(byte-code function)”、および“buffer”のような編集に関連した特別な型
(*note Editing Types::を参照してください)が含まれます。

   基本型にはそれぞれ、オブジェクトがその型のメンバーかどうかのチェック
を行なう、対応するLisp関数があります。

   他の多くの言語とは異なり、Lispのオブジェクトは“自己記述
(self-typing)”的です。オブジェクトの基本型は、オブジェクト自体に暗に含ま
れます。たとえばオブジェクトがベクターの場合、それを数字として扱うことは
できません。Lispはベクターが数字でないことを知っているのです。

   多くの言語では、プログラマーは各変数にたいしてデータ型を宣言しなけれ
ばならず、コンパイラーは型を知っていますが、データの中に型はありません。
Emacs Lispには、このような型宣言はありません。Lisp変数は任意の型の値をも
つことができ、変数に保存した値と型を記憶します(実際には、特定の型の値だ
けをもつことができる少数のEmacs Lisp変数があります。*note Variables with
Restricted Values::を参照してください)。

   このチャプターでは、GNU Emacs Lispの各標準型の意味、プリント表現
(printed representation)、入力構文(read syntax)を説明します。これらのデ
ータ型を使用する方法についての詳細は、以降のチャプターを参照してください
。

* Menu:

* Printed Representation::   Lispオブジェクトがテキストとして表現される方法。
* Comments::                 コメントとコメント書式の慣例。
* Programming Types::        すべてのLispシステムに存在する型。
* Editing Types::            Emacs固有の型。
* Circular Objects::         循環構造にたいする入力構文。
* Type Predicates::          型に関連するテスト。
* Equality Predicates::      2つのオブジェクトが等しいかのテスト。


File: elisp,  Node: Printed Representation,  Next: Comments,  Up: Lisp Data Types

2.1 Printed Representation and Read Syntax
==========================================

オブジェクトのプリント表現(printed representation)とは、オブジェクトにた
いしてLispプリンター(関数‘prin1’)が生成する出力のフォーマットです。すべ
てのデータ型は一意なプリント表現をもちます。オブジェクトの“入力構文(read
syntax)”とは、オブジェクトにたいしてLispリーダー(関数‘read’)が受け取る入
力のフォーマットです。これは一意である必要はありません。多くの種類のオブ
ジェクトが複数の構文をもちます。*note Read and Print::を参照してください
。

   ほとんどの場合、オブジェクトのプリント表記が、入力構文としても使用さ
れます。しかしLispプログラム内の定数とすることに意味が無いいくつかの型に
は、入力構文がありません。これらのオブジェクトは“ハッシュ表記(hash
notation)”でプリントされ、‘#<’、説明的な文字列(典型的には型名にオブジェ
クトの名前を続けたもの)、‘>’で構成される文字列です。たとえば:

     (current-buffer)
          ⇒ #<buffer objects.texi>

ハッシュ表気は読み取ることができないので、Lispリーダーは‘#<’に遭遇すると
、常にエラー‘invalid-read-syntax’をシグナルします。

   他の言語では、式はテキストであり、これ以外の形式はありません。Lispで
は、第一に式はLispオブジェクトであって、オブジェクトの入力構文であるテキ
ストは副次的なものに過ぎません。たいてい、この違いを強調する必要はありま
せんが、このことを心に留めておかないと、たまに混乱することがあるでしょう
。

   インタラクティブに式を評価するとき、Lispインタープリターは最初にそれ
のテキスト表現を読み取り、Lispオブジェクトを生成してから、そのオブジェク
トを評価します(*note Evaluation::を参照してください)。しかし評価と読み取
りは、別の処理です。読み取りによりテキストにより表現されたLispオブジェク
トを読み取り、Lispオブジェクトがreturnされます。後でオブジェクトは評価さ
れるかもしれないし、評価されないかもしれません。オブジェクトを読み取るた
めの基本的な関数‘read’の説明は、*note Input Functions::を参照してくださ
い。


File: elisp,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Lisp Data Types

2.2 Comments
============

“コメント(comment)”hqあ、プログラム中に記述されたテキストであり、そのプ
ログラムを読む人間ためだけに存在し、プログラムの意味には何の影響ももちま
せん。Lispでは、それが文字列や文字定数にある場合をのぞき、セミコロン
(‘;’)でコメントが開始されます。行の終端までがコメントになります。Lispリ
ーダーはコメントを破棄します。コメントはLispシステム内でプログラムを表す
Lispオブジェクトの一部にはなりません。

   ‘#@COUNT’構成は、次のCOUNT個の文字をスキップします。これはプログラム
により生成されたバイナリーデータを含むコメントにたいして有用です。Emacs
Lisp倍とコンパイラーは、出力ファイルにこれを使用します(*note Byte
Compilation::を参照してください)。しかしソースファイル用ではありません。

   コメントのフォーマットにたいする慣例は、*note Comment Tips::を参照し
てください。


File: elisp,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Lisp Data Types

2.3 Programming Types
=====================

Emacs Lispには2種類の一般的な型があります。1つはLispプログラミングに関わ
るもので、もう1つは編集に関わるものです。前者はさまざまな形で多くの
Lisp実装に存在します。後者はEmacs Lispに固有です。

* Menu:

* Integer Type::             小数部のない数字。
* Floating-Point Type::      広い範囲をもつ、小数部をもつ数字。
* Character Type::           文字、数字、コントロール文字にたいする表現。
* Symbol Type::              関数、変数、プロパティーリストを参照する、一意に識別される多目的オブジェクト。
* Sequence Type::            リストと配列はどちらもシーケンスに分類されます。
* Cons Cell Type::           コンスセル、および(コンスセルにより作られる)リスト。
* Array Type::               配列には文字列とベクターが含まれます。
* String Type::              (効率的な)文字の配列。
* Vector Type::              1次元の配列。
* Char-Table Type::          文字によりインデックスされる1次元の疎な配列。
* Bool-Vector Type::         ‘t’と‘nil’からなる、1次元の配列。
* Hash Table Type::          とても高速な参照用のテーブル。
* Function Type::            他の場所から呼び出せる実行可能なコードの断片。
* Macro Type::               より基本的だが少し見栄えの悪い、式を他の式に展開する手法。
* Primitive Function Type::  Lispから呼び出せる、Cで記述された関数。
* Byte-Code Type::           Lispで記述されてからコンパイルされた関数。
* Autoload Type::            頻繁に使用されない関数を自動的にロードするために使用される型。


File: elisp,  Node: Integer Type,  Next: Floating-Point Type,  Up: Programming Types

2.3.1 Integer Type
------------------

整数の値の範囲はマシンに依存します、最小のレンジは−536,870,912から
536,870,911(30ビットでは −2**29 から 2**29 − 1) ですが、多くのマシンはこ
れより広い範囲を提供します。Emacs Lispの数学関数は整数のオーバーフローを
チェックしません。したがってEmacsのh整数が30ビットの場合、‘(1+
536870911)’は−536,870,912になります。

   整数にたいする入力構文は、(10を基数とする)数字のシーケンスで、オプシ
ョンで先頭に符号、最後にピリオドがつきます。Lispインタープリターにより生
成されるプリント表記には、先頭の ‘+’や、最後の‘.’はありません。

     -1               ; 整数の−1.
     1                ; 整数の1.
     1.               ; これも整数の1.
     +1               ; これも整数の1.

特別な例外として、数字シーケンスが有効なオブジェクトとしては大きすぎる、
または小さすぎる整数を指定する場合、Lispリーダーはそれを浮動小数点数
(*note Floating-Point Type::を参照してください)として読み取ります。たと
えば、Emacsの整数が30ビットの場合、‘536870912’は浮動小数点数の
‘536870912.0’として読み取られます。

   詳細は、*note Numbers::を参照してください。


File: elisp,  Node: Floating-Point Type,  Next: Character Type,  Prev: Integer Type,  Up: Programming Types

2.3.2 Floating-Point Type
-------------------------

浮動小数点数は、コンピューターにおける科学表記に相当するものです。浮動小
数点数を10の指数をともなう有理数として考えることができます。正確な有効桁
数と可能な指数は、マシン固有です。Emacsは値の保存にCデータ型の‘double’を
使用し、内部的には10の指数ではなく、2の指数として記録します。

   浮動小数点数のプリント表現には、(後に最低1つの数字をともなう)小数点と
、指数のどちらか一方、または両方が必要です。たとえば‘1500.0’、‘+15e2’、
‘15.0e+2’、‘+1500000e-3’、‘.15e4’は、いずれも浮動小数点数の1500を記述し
、これらはすべて等価です。

   詳細は、*note Numbers::を参照してください。


File: elisp,  Node: Character Type,  Next: Symbol Type,  Prev: Floating-Point Type,  Up: Programming Types

2.3.3 Character Type
--------------------

Emacs Lispでの“文字(character)”は、整数以外の何者でもありません。他の言
い方をすると、文字は文字コードで表現されます。たとえば文字‘A’は、
整数の65として表現されます。

   プログラムで文字を個別に使用するのは稀であり、文字のシーケンスとして
構成される_文字列(strings)_として扱われるのがより一般的です。*note
String Type::を参照してください。

   文字列やバッファーの中の文字は、現在のところ0から4194303の範囲 — つま
り22ビットに制限されています(*note Character Codes::を参照してください
)。0から127のコードはASCIIコードで、残りは非ASCIIです(*note Non-ASCII
Characters::を参照してください)。キーボード入力を表す文字は、Control、
Meta、Shiftなどの修飾キーをエンコードするために、より広い範囲をもちます
。

   メッセージのために、文字にたいして人間が読むことができるテキストによ
る説明を生成する特別な関数が存在します。*note Describing Characters::を
参照してください。

* Menu:

* Basic Char Syntax::        標準的な文字の構文。
* General Escape Syntax::    文字をコードにより指定する方法。
* Ctl-Char Syntax::          コントロール文字の構文。
* Meta-Char Syntax::         メタ文字の構文。
* Other Char Bits::          ハイパー、スーパー、アルト文字の構文。


File: elisp,  Node: Basic Char Syntax,  Next: General Escape Syntax,  Up: Character Type

2.3.3.1 Basic Char Syntax
.........................

文字は実際には整数なので、文字のプリント表現は10進数です。文字にたいする
入力構文も利用可能ですが、Lispプログラムでこの方法により文字を記述するの
は、明解なプログラミングではありません。文字にたいしては、Emacs Lispが提
供する、特別な入力構文を_常に_使用するべきです。これらの構文フォーマット
はクエスチョンマークで開始されます。

   英数字にたいする通常の入力構文は、クエスチョンマークと、その後にその
文字を記述します。したがって文字‘A’にたいしては‘?A’、文字‘B’にたいしては
‘?B’、文字‘a’にたいしては‘?a’となります。

   たとえば:

     ?Q ⇒ 81     ?q ⇒ 113

   句読点文字にも同じ構文を使用できますが、Lispコードを編集するための
Emacsコマンドが混乱しないように、‘\’を追加するのがよい場合がしばしばあり
ます。たとえば開きカッコを記述するために‘?\(’と記述します。その文字が
‘\’の場合、それをクォートするために、‘?\\’のように2つ目の‘\’を使用しなけ
れば_なりません_。

   control-g、backspace、tab、newline、vertical tab、formfeed、space、
return、del、escapeはそれぞれ‘?\a’、‘?\b’、‘?\t’、‘?\n’、‘?\v’、‘?\f’、
‘?\s’、‘?\r’、‘?\d’、‘?\e’と表すことができます(後にダッシュのついた
‘?\s’は違う意味をもちます — これは後続の文字にたいして“super”の修飾を適
用します)。したがって、

     ?\a ⇒ 7                 ; control-g, ‘C-g’
     ?\b ⇒ 8                 ; backspace, <BS>, ‘C-h’
     ?\t ⇒ 9                 ; tab, <TAB>, ‘C-i’
     ?\n ⇒ 10                ; newline, ‘C-j’
     ?\v ⇒ 11                ; vertical tab, ‘C-k’
     ?\f ⇒ 12                ; formfeed character, ‘C-l’
     ?\r ⇒ 13                ; carriage return, <RET>, ‘C-m’
     ?\e ⇒ 27                ; escape character, <ESC>, ‘C-[’
     ?\s ⇒ 32                ; space character, <SPC>
     ?\\ ⇒ 92                ; backslash character, ‘\’
     ?\d ⇒ 127               ; delete character, <DEL>

   バックスラッシュが“エスケープ文字(escape character)”の役割を果たすの
で、これらのバックスラッシュで始まるシーケンスは“エスケープシーケンス
(escape sequences)”とも呼ばれます。この用語法は、文字<ESC>とは関係ありま
せん。‘\s’は文字定数としての使用を意図しており、文字定数の内部では、単に
スペースを記述します。

   エスケープという特別な意味を与えずに、任意の文字の前にバックスラッシ
ュの使用することは許されており、害もありませんしたがって‘?\+’は‘?+’と等
価です。ほとんどの文字の前にバックスラッシュを追加することに理由はありま
せん。しかし、Lispコードを編集するEmacsコマンドが混乱するのを避けるため
に、文字‘()\|;'`"#.,’の前にはバックスラッシュを追加するべきです。space、
tab、newline、formfeedのような空白文字の前にもバックスラッシュを追加でき
ます。しかし、tabやspaceのような実際の空白文字のかわりに、‘\t’や‘\s’のよ
うな可読性のあるエスケープシーケンスを使用するほうが明解です(スペースを
後にともなうバックスラッシュを記述する場合、後続のテキストと区別するため
に、文字定数の後に余分なスペースを記述するべきです)。


File: elisp,  Node: General Escape Syntax,  Next: Ctl-Char Syntax,  Prev: Basic Char Syntax,  Up: Character Type

2.3.3.2 General Escape Syntax
.............................

特に重要なコントロール文字にたいする特別なエスケープシーケンスに加えて、
Emacsは非ASCIIテキスト文字の指定に使用できる、何種類かのエスケープ構文を
提供します。

   最初に、文字をUnicodeの値で指定することができます。‘?\uNNNN’は
Unicodeのコードポイント‘U+NNNN’の文字を表します。ここでNNNNは、(慣例によ
り)正確に4桁の16進数です。バックスラッシュは、後続の文字がエスケープシー
ケンスを形成することを示し、‘u’はUnicodeエスケープシーケンスを指定します
。

   ‘U+FFFF’より大きなコードポイントをもつUnicode文字を指定するために、若
干異なる構文が存在します。‘?\U00NNNNNN’はコードポイント‘U+NNNNNN’の文字
を表します。ここでNNNNNNは6桁の16進数です。Unicode Standardは
‘U+10FFFF’までのコードポイントだけを定義するので、これより大きいコードポ
イントを指定すると、Emacsはエラーをシグナルします。

   次に、文字を16進の文字コードで指定できます。16進エスケープシーケンス
は、バックスラッシュ、‘x’、および16進の文字コードにより構成されます。し
たがって‘?\x41’は文字‘A’、‘?\x1’は文字‘C-a’、‘?\xe0’は grave accentつき
の文字‘a’を表します。 任意の数の16進数を使用できるので、この方法により任
意の文字コードを表すことができます。

   最後に、8進の文字コードにより文字を指定できます。8進エスケープシーケ
ンスは、3桁までの8進数字をともなうバックスラッシュにより形成されます。し
たがって‘?\101’は文字‘A’、‘?\001’は文字‘C-a’、‘?\002’は文字‘C-b’を表しま
す。この方法で指定できるのは、8進コード777までの文字だけです。

   これらのエスケープシーケンスは、文字列内でも使用されます。*note
Non-ASCII in Strings::を参照してください。


File: elisp,  Node: Ctl-Char Syntax,  Next: Meta-Char Syntax,  Prev: General Escape Syntax,  Up: Character Type

2.3.3.3 Control-Character Syntax
................................

他の入力構文を使用してコントロール文字を表すことができます。これは後にバ
ックスラッシュ、カレット、対応する非コントロール文字(大文字か小文字)をと
もなうクエスチョンマークから構成されます。たとえば‘?\^I’と‘?\^i’はどちら
も、値が9である文字‘C-i’にたいする、有効な入力構文です。

   ‘^’のかわりに、‘C-’を使用することもできます。したがって‘?\C-i’は、
‘?\^I’や‘?\^i’と等価です。

     ?\^I ⇒ 9     ?\C-I ⇒ 9

   文字列やバッファーの中では、ASCIIのコントロール文字だけが許されますが
、キーボード入力にたいしては‘C-’により任意の文字をコントロール文字にする
ことができます。これらの非ASCIIのコントロール文字にたいするコントロール
文字には 非コントロール文字にたいするコードと同様に、2**26 ビットが含ま
れます。通常のテキスト端末には、非ASCIIコントロール文字を生成する方法が
ありませんが、Xおよび他のウィンドウシステムを使用することにより、簡単に
生成することができます。

   歴史的な理由により、Emacsは<DEL>文字を、‘?’のコントロール文字として扱
います:

     ?\^? ⇒ 127     ?\C-? ⇒ 127

結果として、Xでは有意な入力文字である‘Control-?’文字を、‘\C-’を使用して
表現することは今のところできません。さまざまなLispファイルがこの方法によ
り<DEL>を参照するため、これを変更するのは簡単ではありません。

   コントロール文字の表現はファイルや文字列のなかで見ることができますが
、わたしたちは‘^’構文を推奨します。キーボード入力にたいするコントロール
文字に好ましいのは、‘C-’構文です。どちらを使用するかはプログラムの意味に
影響しませんが、プログラムを読む人の理解を助けるでしょう。


File: elisp,  Node: Meta-Char Syntax,  Next: Other Char Bits,  Prev: Ctl-Char Syntax,  Up: Character Type

2.3.3.4 Meta-Character Syntax
.............................

“メタ文字(meta character)”とは、<META>修飾キーとともにタイプされた文字で
す。そのような文字を表す整数には 2**27 のビットがセットされています。基
本的な文字コードの広い範囲を利用可能にするために、メタや他の修飾にたいし
て上位ビットを使用します。

   文字列では、メタ文字を示すASCII文字に、 2**7 ビットが付加されます。し
たがって文字列に含めることができるメタ文字のコードは1から255の範囲となり
、メタ文字は通常のASCII文字のメタ修飾されたバージョンとなります。文字列
内での<META>処理の詳細については、*note Strings of Events::を参照してく
ださい。

   メタ文字の入力構文には‘\M-’を使用します。たとえば‘?\M-A’は‘M-A’を意味
します。8進文字コード(以下参照)や、‘\C-’、その他の文字にたいする他の構文
とともに‘\M-’を使用できます。したがって、‘M-A’は‘?\M-A’や‘?\M-\101’と記
述できます。同様に、‘C-M-b’は‘?\M-\C-b’、‘?\C-\M-b’、‘?\M-\002’と記述す
ることができます。


File: elisp,  Node: Other Char Bits,  Prev: Meta-Char Syntax,  Up: Character Type

2.3.3.5 Other Character Modifier Bits
.....................................

グラフィック文字(graphic character)の大文字小文字は、文字コードで示され
ます。たとえばASCIIでは、文字‘a’と文字‘A’は区別されます。しかしASCIIには
コントロール文字が大文字なのか小文字なのかを表現する方法がありません。コ
ントロール文字がタイプされたときシフトキーが使用されたかを示すために、
Emacsは 2**25 のビットを使用します。この区別は、X端末や、他の特別な端末
を使用しているときだけ可能です。通常のテキスト端末は、これらの違いを報告
しません。シフトをあらわすビットのためのLisp構文は‘\S-’です。したがって
‘?\C-\S-o’や‘?\C-\S-O’は、shifted-control-o文字を表します。

   Xウィンドウシステムは文字にセットできる、他に3つ修飾ビット — “hyper”、
“super”、“alt”を定義します。これらのビットにたいする構文は、‘\H-’、
‘\s-’、‘\A-’です(これらのプレフィクスでは、大文字小文字は意味があります
)。したがって‘?\H-\M-\A-x’は‘Alt-Hyper-Meta-x’を表します(‘-’が後にない
‘\s’は、スペース文字を表すことに注意してください)。 数値的には、ビット値
2**22はalt、2**23はsuper、2**24はhyperです。


File: elisp,  Node: Symbol Type,  Next: Sequence Type,  Prev: Character Type,  Up: Programming Types

2.3.4 Symbol Type
-----------------

GNU Emacs Lispでの“シンボル(symbol)”とは、名前をもつオブジェクトです。シ
ンボル名は、そのシンボルのプリント表現としての役割があります。Lispの通常
の使用では、1つのobarray(*note Creating Symbols::を参照してください)によ
り、シンボル名は一意です — 2つのシンボルが同じ名前をもつことはありません
。

   シンボルは、変数、関数名としての役割や、プロパティーリストを保持する
役割をもつことができます。他のすべてのLispオブジェクトから区別するためだ
けの役割をもつ場合もあり、データ構造内にそのようなシンボルが存在すること
は、確実に認識されるでしょう。与えられたコンテキストにおいて、通常はこれ
らのうちの1つの使用だけが意図されます。しかし3つすべての方法で、1つのシ
ンボルを独立して使用することもできます。

   名前がコロン(‘:’)で開始されるシンボルは、“キーワードシンボル(keyword
symbol)”と呼ばれます。これらのシンボルは自動的に定数として振る舞い、通常
は未知のシンボルと、いくつかの特定の候補を比較することだけに使用されます
。*note Constant Variables::を参照してください。

   シンボル名にはどんな文字でも含めることができます。ほとんどのシンボル
名は英字、数字、‘-+=*/’などの句読点文字で記述されます。このような名前に
は、特別な句読点文字は必要ありません。名前が数字のように見えない限りは、
名前にはどのような文字も使用できます(名前が数字のように見える場合は、名
前の先頭に‘\’を記述して、強制的にシンボルとして解釈させます)。文字
‘_~!@$%^&:<>{}?’はあまり使用されませんが、これらも特別な句読点文字を必要
としません。他の文字も、バックスラッシュでエスケープすることにより、シン
ボル名に含めることができます。しかし、文字列内でのバックスラッシュの使用
とは対照的に、シンボル名でのバックスラッシュは、バックスラッシュの後の
1文字をエスケープするだけです。たとえば文字列内では、‘\t’はタブ文字を表
します。しかしシンボル名の中では、‘\t’は英字‘t’をクォートするに過ぎませ
ん。 名前にタブ文字をもつシンボルを記述するには、(バックスラッシュを前置
した)実際のタブを使用しなければなりません。しかし、そのようなことを行な
うことは、めったにありません。

     Common Lispに関する注意:Common Lispでは、明示的にエスケープされない
     限り、小文字は常に大文字に“フォールドされ(folded)”ます。Emacs Lispで
     は大文字と小文字は区別されます。

   以下はシンボル名の例です。4番目の例の中の‘+’は、シンボルが数字として
読み取られるのを防ぐために、エスケープされていることに注意してください。
6番目の例では、名前の残りの部分により数字としては不正なので、エスケープ
の必要はありません。

     foo                 ; ‘foo’という名前のシンボル。
     FOO                 ; ‘foo’とは別の、‘FOO’という名前のシンボル。
     1+                  ; ‘1+’という名前のシンボル
                         ;   (整数の‘+1’ではありません)。
     \+1                 ; ‘+1’という名前のシンボル
                         ;   (とても読みやすい名前とはいえません)。
     \(*\ 1\ 2\)         ; ‘(* 1 2)’という名前のシンボル(悪い名前)。
     +-*/_~!@$%^&=:<>{}  ; ‘+-*/_~!@$%^&=:<>{}’という名前のシンボル。
                         ;   これらの文字はエスケープする必要はありません。

   シンボル名がプリント表現としての役割をもつというルールの例外として、
‘##’があります。これは、名前が空文字列の、internされたシンボルのプリント
表現です。さらに‘#:FOO’は、internされていないFOOという名前のシンボルにた
いするプリント表現です(通常、Lispリーダーはすべてのシンボルをinternしま
す。*note Creating Symbols::を参照してください)。


File: elisp,  Node: Sequence Type,  Next: Cons Cell Type,  Prev: Symbol Type,  Up: Programming Types

2.3.5 Sequence Types
--------------------

“シーケンス(sequence)”とは、要素の順序セットを表現する、Lispオブジェクト
です。Emacs Lispには、2種類のシーケンス — “リスト(lists)”と“配列
(arrays)”があります。

   リストはもっとも一般的に使用されるシーケンスです。リストは任意の型の
要素を保持でき、要素の追加・削除により簡単に長さを変更できます。リストに
ついては、次のサブセクションを参照してください。

   配列は固定長のシーケンスです。配列はさらに文字列(strings)、ベクター
(vectors)、文字テーブル(char-tables)、ブールベクター(bool-vectors)に細分
されます。ベクターは任意の型の要素を保持できますが、文字列の要素は文字で
なければならず、ブールベクターの要素は‘t’か‘nil’でなければなりません。文
字テーブルはベクターと似ていますが、有効な文字によりインデックスづけされ
る点が異なります。文字列内の文字は、バッファー内の文字のようにテキストプ
ロパティーをもつことができます(*note Text Properties::を参照してください
)。しかしベクターは、その要素が文字のときでも、テキストプロパティーをサ
ポートしません。

   リスト、文字列、およびその他の配列型も、重要な類似点を共有します。た
とえば、それらはすべて長さLをもち、要素は0からL−1でインデックスづけされ
ます。いくつかの関数はシーケンス関数と呼ばれ、これらは任意の種類のシーケ
ンスを許容します。たとえば、関数‘length’は、任意の種類のシーケンスの長さ
を報告します。*note Sequences Arrays Vectors::を参照してください。

   シーケンスは読み取りにより常に新たに作成されるので、同じシーケンスを
2回読み取るのは、一般的に不可能です。シーケンスにたいする入力構文を2回読
み取った場合、内容が等しい2つのシーケンスを得ます。これには1つ例外があり
ます。空リスト‘()’は、常に同じオブジェクト‘nil’を表します。


File: elisp,  Node: Cons Cell Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

2.3.6 Cons Cell and List Types
------------------------------

“コンスセル(cons cell)”は、CARスロット、CDRスロットと呼ばれる2つのスロッ
トから構成されるオブジェクトです。各スロットは、任意のLispオブジェクトを
“保持”できます。そのときCARスロットに保持されるオブジェクトが何であれ、
わたしたちは“このコンスセルのCAR”のような言い方をします。これはCDRの場合
も同様です。

   “リスト(list)”は、コンスセルの連続するシリーズで、各コンスセルのCDRス
ロットは、次のコンスセル、または空リストを保持します。空リストは実際には
シンボル‘nil’です。詳細については、*note Lists::を参照してください。ほと
んどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセ
ルにより構成される任意の構造を、“リスト構造(list structure)”という用語で
参照します。

     Cプログラマーにたいする注意: Lispのリストはコンスセルにより構築され
     る、“リンクリスト(linked list)”として機能します。Lispではポインター
     は暗黙的なので、わたしたちはコンスセルのスロットが、値を“保持
     (hold)”するのか、それとも値を“指す(point)”のかを区別しません。

   コンスセルはLispの中心なので、“コンスセルではないオブジェクト”にたい
する単語もあります。これらのオブジェクトは“アトム(atoms)”と呼ばれます。

   リストにたいする入力構文とプリント表現は等しく、それは左カッコ、任意
の数の要素、右カコから構成されます。以下はリストの例です:

     (A 2 "A")            ; 3要素のリスト。
     ()                   ; 要素がないリスト(空リスト)。
     nil                  ; 要素がないリスト(空リスト)。
     ("A ()")             ; 1要素のリスト: 文字列‘"A ()"’。
     (A ())               ; 2要素のリスト: ‘A’と空リスト。
     (A nil)              ; 同上
     ((A B C))            ; 1要素のリスト
                          ;   (この要素は、3要素のリスト)。

   読み取りにおいては、カッコの内側は、リストの要素になります。つまり、
コンスセルは各要素から作成されます。コンスセルのCARスロットは要素を保持
し、CDRスロットはリスト内の次のコンスセル(このコンスセルはリスト内の次の
要素を保持します)を参照します。最後のコンスセルのCDRスロットは、‘nil’を
保持するようにセットされます。

   CAR、CDRという名称は、Lispの歴史に由来します。オリジナルのLisp実装は
IBM 704コンピューターで実行されていました。ワードを2つの部分、つまり
“address”と呼ばれる部分と、“decrement”と呼ばれる部分に分割していて、その
際CARはaddress部から内容を取り出す命令で、CDRはdecrement部から内容を取り
出す命令でした。対照的に“cons cells”は、これらを作成する関数‘cons’から命
名されました。この関数は関数の目的、すなわちセルを作る(construction of
cells)という目的から命名されました。

* Menu:

* Box Diagrams::             リストを絵で書いたら。
* Dotted Pair Notation::     コンスセルの一般的な構文。
* Association List Type::    特別に構成されるリスト。


File: elisp,  Node: Box Diagrams,  Next: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.1 Drawing Lists as Box Diagrams
.....................................

コンスセルを表現するドミノのような1対のボックスによる図により、リストを
説明することができます(Lispリーダーがこのような図を読み取ることはできま
せん。人間およびコンピューターが理解できるテキスト表記と異なり、ボックス
の図は人間だけが理解できます)。この図は3要素のリスト‘(rose violet
buttercup)’を表したものです:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   この図では、ボックスは任意のLispオブジェクトへの参照を保持できるスロ
ットを表します。ボックスのペアはコンスセルを表します。矢印はLispオブジェ
クト(アトム、または他のコンスセル)への参照を表します。

   この例では、1番目のボックスは1番目のコンスセルで、それのCARは
‘rose’(シンボル)を参照または“保持(holds)”します。2番目のボックスは1番目
のコンスセルのCDRを保持し、次のボックスペア、すなわち2番目のコンスセルを
参照します。2番目のコンスセルのCARは‘violet’で、CDRは3番目のコンスセルで
す。(最後の)3番目のコンスセルのCDRは、‘nil’です。

   同じリスト‘(rose violet buttercup)’を、違うやり方で描いた別の図で表し
てみましょう:

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   要素がないリストは“空リスト(empty list)”で、これはシンボル‘nil’と同じ
です。別の言い方をすると、‘nil’はシンボルであり、リストでもあります。

   以下は、リスト‘(A ())’、または等価な‘(A nil)’をボックスと矢印で描いた
ものです:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

   以下はもっと複雑な例です。これは、1番目の要素が2等疎のリスとである、
3要素のリスト‘((pine needles) oak maple)’を表します:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   同じリストを2番目のボックス表記で表すと、以下のようになります:

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------


File: elisp,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: Box Diagrams,  Up: Cons Cell Type

2.3.6.2 Dotted Pair Notation
............................

“ドットペア表記(dotted pair notation)”はCARとCDRが明示的に表されたコンス
セルにたいする、一般的な構文です。この構文では、‘(A . B)’は、CARがオブジ
ェクトAで、CDRがオブジェクトBという意味になります。CDRがリスとである必要
がないので、ドットペア表記は、より一般的なリスト構文です。しかしキスと構
文が機能するでような場合には、より扱いにくくなります。ドットペア表記では
、リスト‘(1 2 3)’は、‘(1 . (2 . (3 . nil)))’と記述されます。‘nil’で終端
されたリストにたいしては、どちらの表記法も使用できますが、リスト表記の方
が、通常は明解で便利です。リストをプリントする場合、コンスセルのCDRがリ
スとでないときだけ、ドットペア表記が使用されます。

   以下はボックスを使用してドットペア表記を表した例です。この例はペア
‘(rose . violet)’を表します。

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   最後のCDRが非‘nil’のコンスセルのチェーンを表すために、ドットペア表記
とリスト表記を組み合わせることができます。リストの最後の要素の後にドット
を記述して、その後に最後のコンスセルのCDRを記述します。たとえば、‘(rose
violet . buttercup)’は、‘(rose . (violet . buttercup))’と等価です。オブ
ジェクトは以下のようになります:

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   構文‘(rose . violet . buttercup)’は無効です。なぜならこれが意味するこ
とは何もないからです。何かあるにしても、‘violet’のためにCDRがすでに使用
されているコンスセルのCDRに‘buttercup’を置く、ということになります。

   リスト‘(rose violet)’は‘(rose . (violet))’と等価であり、以下のように
なります:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   同様に3要素のリスト‘(rose violet buttercup)’は、‘(rose . (violet .
(buttercup)))’と等価です。 これは以下のようになります:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


File: elisp,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.3 Association List Type
.............................

“連想リスト(association list)”または“alist”は、要素がコンスセルであるよ
うに特別に構成されたリストです。各要素においては、CARが“キー(key)”で、
CDRが“連想値(associated value)”であると考えます(連想値がCDRのCARに保存さ
れる場合もあります)。リストの先頭に連想値を追加したり削除するのが簡単な
ので、連想リストはスタック(stack)にしばしば使用されます。

   たとえば、

     (setq alist-of-colors
           '((rose . red) (lily . white) (buttercup . yellow)))

これは変数‘alist-of-colors’に3葉疎のalistをセットします。最初の要素では
、‘rose’がキーで、‘red’が値になります。

   alistと、alistに関数についての詳細な説明は、*note Association
Lists::を参照してください。テーブルを照合する、(多くのキーの操作を、より
速く行なう)他の手段については、*note Hash Tables::を参照してください。


File: elisp,  Node: Array Type,  Next: String Type,  Prev: Cons Cell Type,  Up: Programming Types

2.3.7 Array Type
----------------

“配列(array)”は、他のLispオブジェクトを保持または参照する、任意の数のス
ロットから構成され、メモリーの連続ブロックに配列されます。配列の任意の要
素へのアクセス時間は、大体同じです。対照的に、リストの要素にたいするアク
セスは、リスト内でのその要素の位置に比例した時間を要します(リストの最後
の要素にアクセスするには、リストの最初の要素にアクセスするより、長い時間
を要します)。

   Emacsは文字列(strings)、ベクター(vectors)、ブールベクター
(bool-vectors)、文字テーブル(char-tables)という、4種の配列を定義します。

   文字列は文字の配列で、ベクターは任意のオブジェクトの配列です。ブール
ベクターは‘t’か‘nil’だけを保持できます。この種の配列は、もっとも大きい整
数までの、任意の長さをもつことができます。文字テーブルは、任意の有効な文
字コードによりインデックスづけされる疎な配列で、任意のオブジェクトを保持
することができます。

   配列の最初の要素はインデックス0、2番目の要素はインデックス1、...とな
ります。これは0基準“zero-origin”のインデックスづけと呼ばれます。たとえば
、4要素の配列は、インデックス0、1、2、3をもちます。利用できる最大のイン
デックス値は、配列の長さより1小さくなります。1度配列が作成されると、長さ
は固定されます。

   Emacs Lispのすべての配列は、1次元です(他のほとんどのプログラミング言
語は多次元配列をサポートしますが、これらは必須ではありません。ネストされ
た1次元配列により同じ効果を得ることができます)。各種の配列のは、独自の入
力構文をもちます。詳細は以降のセクションを参照してください。

   配列型はシーケンス型のサブセットであり、文字列型、ベクター型、ブール
ベクター型、文字テーブル型が含まれます。


File: elisp,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

2.3.8 String Type
-----------------

“文字列(string)”とは、文字の配列です。Emacsがテキストエディターであるこ
とから予想できるように、文字列は、たとえばLispシンボルの名前、ユーザーへ
のメッセージ、バッファーから抽出されたテキストの表現など、多くの目的のた
めに使用されます。Lispの文字列は定数です。文字列を評価すると、それと同じ
文字列がreturnされます。

   文字列を操作する関数については、*note Strings and Characters::を参照
してください。

* Menu:

* Syntax for Strings::       Lisp文字列を指定する方法。
* Non-ASCII in Strings::     文字列内の国際化文字。
* Nonprinting Characters::   文字列内の印刷不可能なリテラル文字。
* Text Props and Strings::   テキストプロパティーをともなう文字列。


File: elisp,  Node: Syntax for Strings,  Next: Non-ASCII in Strings,  Up: String Type

2.3.8.1 Syntax for Strings
..........................

文字列にたいする入力構文は、‘"like this"’のように、ダブルクォート、任意
個の文字、もう1つのダブルクォートから構成されます。文字列内にダブルクォ
ートを含める場合は、それの前にバックスラッシュを記述します。したがって、
‘"\""’は1つのダブルクォート文字だけを含む文字列です。同様に、バックスラ
ッシュを含める場合は、‘"this \\ is a single embedded backslash"’のように
、それの前にもう1つのバックスラッシュを記述します。

   文字列にたいする入力構文では、改行(newline)は特別ではありません。ダブ
ルクォートの間に改行を記述すれば、その改行は文字列内の文字となります。し
かしエスケープされた改行 — 前に‘\’をともなう改行 —は文字列の一部とはなり
ません。同様に、エスケープされたスペース‘\  ’も無視されます。

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          ⇒ "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."


File: elisp,  Node: Non-ASCII in Strings,  Next: Nonprinting Characters,  Prev: Syntax for Strings,  Up: String Type

2.3.8.2 Non-ASCII Characters in Strings
.......................................

Emacdの文字列内の非ASCII文字にたいしては、2つのテキスト表現 — マルチバイ
ト(multibyte)とユニバイト(unibyte)があります(*note Text
Representations::を参照してください)。大まかに言うと、ユニバイト文字列に
はraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが
保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255とな
ります。対照的に、マルチバイト文字列内の各文字は、0から4194303の値をもつ
かもしれません(*note Character Type::を参照してください)。両方とも、
127より上の文字は非ASCIIです。

   文字をリテラルとして記述することにより、文字列に非ASCII文字を含めるこ
とができます。マルチバイトのバッファーや文字列、あるいはマルチバイトとし
てvisitされたファイル等の、マルチバイトのソースから文字列定数を読み込む
場合、Emacsは非ASCII文字をマルチバイト文字として読み取り、その文字列を自
動的にマルチバイト文字列にします。ユニバイトのソースから文字列定数を読み
込む場合、Emacsは非ASCII文字をユニバイト文字として読み取り、その文字列を
湯にバイト文字列にします。

   マルチバイト文字列内にリテラルとして文字を記述するかわりに、エスケー
プシーケンスを使用して文字コードとして記述できます。エスケープシーケンス
についての詳細は、*note General Escape Syntax::を参照してください。

   文字列定数内でUnicodeスタイルのエスケープシーケンス‘\uNNNN’または
‘\U00NNNNNN’を使用する場合、(たとえASCII文字の場合でも)Emacsは自動的に文
字列をマルチバイトとみなします。

   文字列定数内で、16進エスケープシーケンス(‘\xN’)、および8進エスケープ
シーケンス(‘\N’)を使用することもできます。*しかし注意してください: *文字
列定数が16進または8進のエスケープシーケンスを含み、それらのエスケープシ
ーケンスすべてがユニバイト文字(256より小)を指定していて、その文字列内に
他にリテラルの非ASCII文字またはUnicodeスタイルのエスケープシーケンスが存
在しない場合、Emacsは自動的に文字列をユニバイト文字列とみなします。つま
り文字列内のすべての非ASCII文字は8ビットのrawバイトとみなされます。

   16進および8進のエスケープシーケンスではエスケープされた文字コードは可
変個の数字を含むかもしれないので、それに続く文字で、16進および8進として
有効ではない最初の文字は、エスケープシーケンスを終了させます。文字列内の
次の文字が16進または8進として解釈できる文字の場合は、‘\  ’(バックスラッ
シュとスペース)を記述して、エスケープシーケンスを終了できます。たとえば
‘\xe0\ ’はgrave accentつきの‘a’という、1文字を表します。文字列内の
‘\  ’は、バックスラッシュー改行と同様です。これは文字列内の文字とはなり
ませんが、先行する16進エスケープを終了します。


File: elisp,  Node: Nonprinting Characters,  Next: Text Props and Strings,  Prev: Non-ASCII in Strings,  Up: String Type

2.3.8.3 Nonprinting Characters in Strings
.........................................

リテラル文字と同様に、文字列定数内でバックスラッシュによるエスケープシー
ケンスを使用できます(ただし文字定数を開始するクエスチョンマークは使用し
ません)。たとえば、非プリント文字のタブと‘C-a’を含む文字列は、‘"\t,
\C-a"’のように、それらの間にカンマとスペースを記述します。文字にたいする
入力構文の説明は、*note Character Type::を参照してください。

   しかし、バックスラッシュによるエスケープシーケンスとともに記述できる
すべての文字が、文字列内で有効というわけではありません。文字列が保持でき
るコントロール文字は、ASCIIコントロール文字だけです。ASCIIコントロール文
字では、文字列の大文字小文字は区別されません。

   正確に言うと、文字列はメタ文字を保持できません。しかし文字列がキーシ
ーケンスとして使用される場合、文字列内でメタで修飾されたASCII文字を表現
するための方法を提供する、特別な慣習があります。文字列定数内でメタ文字を
示すために‘\M-’構文を使用した場合、これは文字列内の文字の 2**7 のビット
をセットします。その文字列が‘define-key’または‘lookup-key’で使用される場
合、この数字コードは等価なメタ文字に変換されます。*note Character
Type::を参照してください。

   文字列はhyper、super、altで修飾された文字を保持できません。


File: elisp,  Node: Text Props and Strings,  Prev: Nonprinting Characters,  Up: String Type

2.3.8.4 Text Properties in Strings
..................................

文字列は、その文字自身に加えて、文字のプロパティーも保持することができま
す。これにより、特別なことをしなくても、文字列とバッファーとの間でテキス
トをコピーするプログラムが、テキストプロパティーをコピーすることが可能に
なります。テキストプロパティーが何を意味するかについての説明は、*note
Text Properties::を参照してください。テキストプロパティーをもつ文字列は
、特別な入力構文とプリント構文を使用します。

     #("CHARACTERS" PROPERTY-DATA...)

ここでPROPERTY-DATAは3個でグループ化された、0個以上の要素から構成されま
す:

     BEG END PLIST

要素BEGおよびENDは整数で、文字列内のインデックスの範囲を指定します。
PLISTはその範囲にたいするプロパティーリストです。たとえば、

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

これはテキスト内容が‘foo bar’で、最初の3文字は‘face’プロパティーに値
‘bold’をもち、最後の3文字は‘face’プロパティーに値‘italic’をもつことを表
します。(4番目の文字にはテキストプロパティーはないので、プロパティーリス
トは‘nil’です。実際には、範囲の中の指定されていない文字はデフォルトでは
プロパティーをもたないので、範囲のプロパティーリストを‘nil’と指定する必
要ありません)。


File: elisp,  Node: Vector Type,  Next: Char-Table Type,  Prev: String Type,  Up: Programming Types

2.3.9 Vector Type
-----------------

“ベクター(vector)”は、任意の型の要素からなる1次元の配列です。ベクター内
の任意の要素へのアクセスに要す時間は、一定です(リストの場合、要素へのア
クセスに要す時間は、リストの先頭からその要素までの距離に比例します)。

   ベクターのプリント表現は、左角カッコ(left square bracket)、要素、右角
カッコ(right square bracket)から構成されます。これは入力構文でもあります
。数字や文字列と同様に、ベクターは評価において定数と判断されます。

     [1 "two" (three)]      ; 3要素のベクター。
          ⇒ [1 "two" (three)]

   ベクターに作用する関数については、*note Vectors::を参照してください。


File: elisp,  Node: Char-Table Type,  Next: Bool-Vector Type,  Prev: Vector Type,  Up: Programming Types

2.3.10 Char-Table Type
----------------------

“文字テーブル(char-table)”は、任意の型の要素をもつ1次元の配列で、文字コ
ードによりインデックスづけされます。文字テーブルは、文字コードに情報を割
り当てることを必要とする多くの処理を簡単にするための、特別な追加の機能を
もちます — たとえば、文字テーブルは、継承するための親、デフォルト値、特
別な目的のために使用する少数の余分なスロットをもつことができます。文字テ
ーブルは、文字セット全体にたいして1つの値を指定することもできます。

   文字テーブルのプリント表現はベクターと似ていますが、最初に余分な
‘#^’があります(1)。

   文字テーブルを操作する特別な関数については、*note Char-Tables::を参照
してください。文字テーブルの使用には以下が含まれます:

   • 大文字小文字テーブル(*note Case Tables::を参照してください)。

   • 文字カテゴリーテーブル(*note Categories::を参照してください)。

   • ディスプレーテーブル(*note Display Tables::を参照してください)。

   • 構文テーブル(*note Syntax Tables::を参照してください)。

   ---------- Footnotes ----------

   (1) “サブ文字テーブル(sub-char-tables)”に使用される‘#^^’を目にするこ
とがあるかもしれません。


File: elisp,  Node: Bool-Vector Type,  Next: Hash Table Type,  Prev: Char-Table Type,  Up: Programming Types

2.3.11 Bool-Vector Type
-----------------------

“ブールベクター(bool-vector)”は、要素が‘t’か‘nil’でなければならない、1次
元の配列です。

   ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述し
た‘#&’で始まります。これに続く文字列定数は、ビットマップとして実際に内容
を指定するブールベクターです — 文字列定数内のそれぞれの“文字”は8ビットを
含み、これはブールベクターの次の8要素を指定します(1は‘t’、0は‘nil’です
)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。

     (make-bool-vector 3 t)
          ⇒ #&3"^G"
     (make-bool-vector 3 nil)
          ⇒ #&3"^@"

‘C-g’の2進コードは111、‘C-@’はコード0の文字なので、この結果は道理にかな
っています。

   長さが8の倍数でない場合、プリント表現には余分な要素が表示されますが、
これらの余分な要素に意味はありません。たとえば以下の例では、最初の3ビッ
トだけが使用されるので、2つのブールベクターは等価です:

     (equal #&3"\377" #&3"\007")
          ⇒ t


File: elisp,  Node: Hash Table Type,  Next: Function Type,  Prev: Bool-Vector Type,  Up: Programming Types

2.3.12 Hash Table Type
----------------------

ハッシュテーブルは非常に高速な照合テーブルの一種で、キーを対応する値にマ
ップするalistと似ていますが、より高速です。ハッシュテーブルのプリント表
現、以下のようにハッシュテーブルのプロパティーと内容を指定します:

     (make-hash-table)
          ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8 data ())

ハッシュテーブルについての詳細な情報は、*note Hash Tables::を参照してく
ださい。


File: elisp,  Node: Function Type,  Next: Macro Type,  Prev: Hash Table Type,  Up: Programming Types

2.3.13 Function Type
--------------------

他のプログラミング言語の関数と同様に、Lisp関数は実行可能なコードです。他
の言語とは異なり、Lispの関数はLispオブジェクトでもあります。Lispのコンパ
イルされていない関数はラムダ式 — つまり1番目の要素がシンボル‘lambda’であ
るリストです(*note Lambda Expressions::を参照してください)。

   ほとんどのプログラミング言語では、名前のないの関数はありません。
Lispでは、関数に本質的な名前はありません。名前がなくても、ラムダ式を関数
として呼び出すことができます。これを強調するために、わたしたちはこれを
“無名関数(anonymous function)”とも呼びます(*note Anonymous Functions::を
参照してください)。Lispの名前つき関数は、関数セルに有効な関数がセットさ
れた単なるシンボルです(*note Defining Functions::を参照してください)。

   ほとんどの場合、関数はLispプログラム内のLisp式に名前が記述されたとこ
ろで呼び出されます。しかし、実行時に関数オブジェクトを構築または取得して
から、基本関数‘funcall’および‘apply’により呼び出すことができます。*note
Calling Functions::を参照してください。


File: elisp,  Node: Macro Type,  Next: Primitive Function Type,  Prev: Function Type,  Up: Programming Types

2.3.14 Macro Type
-----------------

“Lispマクロ(Lisp macro)”は。Lisp言語を拡張する、ユーザー定義の構成です。
これはオブジェクトとしてではなく関数のように表現されますが、引数の渡し方
の意味が異なります。Lispマクロの形式はリストです。これは、最初の要素が
‘macro’で、(‘lambda’シンボルを含む)CDRがLisp関数オブジェクトであるような
リストです。

   Lispマクロオブジェクトは通常、ビルトインの‘defmacro’関数で定義されま
すが、‘macro’で始まる任意のリストも、Emacsにとってはマクロです。マクロを
記述する方法の説明は、*note Macros::を参照してください。

   *警告*: Lispマクロとキーボードマクロ(*note Keyboard Macros::を参照し
てください)は、完全に別物です。修飾なしで“マクロ”という単語を使用したと
きは、キーボードマクロではなく、Lispマクロのことを指します。


File: elisp,  Node: Primitive Function Type,  Next: Byte-Code Type,  Prev: Macro Type,  Up: Programming Types

2.3.15 Primitive Function Type
------------------------------

“基本関数(primitive function)”とは、Cプログラミング言語で記述された、
Lispから呼び出せる関数です。基本関数は“subrs”や“ビルと陰関数(built-in
functions)”とも呼ばれます(単語“subr”は、“サブルーチン(subroutine)”が由来
です)。ほとんどの基本関数、呼び出されたとき、すべての引数を評価します。
すべての引数を評価しない基本関数は、“スペシャルフォーム(special form)”と
呼ばれます(*note Special Forms::を参照してください)。

   呼び出す側からすれば、その関数が基本関数かどうかは、問題になりません
。しかし、基本関数をLispで記述された関数で再定義した場合は、問題になりま
す。理由は、その基本関数がCコードから直接呼び出されているかもしれないか
らです。Lispから再定義した関数を呼び出すと、これは新しい定義を使用するで
しょうが、Cコードから呼び出すと、ビルトインの定義が使用されるでしょう。
したがって、*基本関数の再定義はしないでください*。

   “関数(function)”という用語により、LispやCで記述された、すべての
Emacs関数を参照します。Lispで記述された関数についての情報は、*note
Function Type::を参照してください。

   基本関数に入力構文はなく、サブルーチン名とともにハッシュ表記でプリン
トします。

     (symbol-function 'car)          ; そのシンボルの関数セルに
                                     ;     アクセスします。
          ⇒ #<subr car>
     (subrp (symbol-function 'car))  ; これは基本関数か?
          ⇒ t                ;    イェース。


File: elisp,  Node: Byte-Code Type,  Next: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

2.3.16 Byte-Code Function Type
------------------------------

“バイトコード関数オブジェクト(byte-code function objects)”は、Lispコード
をバイトコンパイルすることにより生成されます(*note Byte Compilation::を
参照してください)。内部的には、バイトコード関数オブジェクトは、ベクター
によく似ています。しかしバイトコード関数オブジェクトが関数呼び出しのよう
に見える場合、評価プロセスにより、このデータ型は特別に処理されます。
*note Byte-Code Objects::を参照してください。

   バイトコード関数オブジェクトのプリント表現と入力構文は、ベクターのも
のと似ていますが、開き角カッコ‘[’の前に‘#’があります。


File: elisp,  Node: Autoload Type,  Prev: Byte-Code Type,  Up: Programming Types

2.3.17 Autoload Type
--------------------

“autoloadオブジェクト(autoload object)”は、最初の要素がシンボル
‘autoload’のリストです。これはシンボルの関数定義として保存され、実際の定
義にたいする代替としての役割をもちます。autoloadオブジェクトは、必要な時
にロードされるLispコードファイルのなかで、実際の定義を見つけることができ
ることを宣言します。これにはファイル名と、加えて実際の定義についての他の
いくつかの情報が含まれます。

   ファイルがロードされた後、そのシンボルは、autoloadオブジェクトではな
い、新しい関数定義をもつはずです。新しい定義は、最初からそこにあったかの
ように呼び出されます。ユーザーの観点からは、関数呼び出しは期待された動作
、つまりロードされたファイル内の関数定義を使用します。

   autoloadオブジェクトは通常、シンボルの関数セルにオブジェクトを保存す
る、関数‘autoload’により作成されます。詳細は、*note Autoload::を参照して
ください。


File: elisp,  Node: Editing Types,  Next: Circular Objects,  Prev: Programming Types,  Up: Lisp Data Types

2.4 Editing Types
=================

前のセクションの型は一般的なプログラミングの目的のために使用され、これら
のほとんどは、ほとんどのLisp方言で一般的です。Emacs Lispは、編集に関する
目的のために、いくつかの追加のデータ型を提供します。

* Menu:

* Buffer Type::              編集のための基本オブジェクト。
* Marker Type::              バッファー内の位置。
* Window Type::              バッファーはウィンドウ内に表示されます。
* Frame Type::               ウィンドウはフレームを細分します。
* Terminal Type::            フレームを表示する端末デバイス。
* Window Configuration Type::  フレームが細分化された方法を記録する。
* Frame Configuration Type::  すべてのフレームの状態を記録する。
* Process Type::             背後のOS上で実行されるEmacsのサブプロセス。
* Stream Type::              文字の受信と送信。
* Keymap Type::              キーストロークがどの関数を呼び出すか。
* Overlay Type::             オーバーレイが表示される方法。
* Font Type::                テキストを表示するフォント。


File: elisp,  Node: Buffer Type,  Next: Marker Type,  Up: Editing Types

2.4.1 Buffer Type
-----------------

“バッファー(buffer)”とは、編集されるテキストを保持するオブジェクトです
(*note Buffers::を参照してください)。ほとんどのバッファーはディスクファ
イル(*note Files::を参照してください)の内容を保持するので、それらは編集
できますが、他の目的のために使用されるものもいくつかあります。ほとんどの
バッファーは、ユーザーにより閲覧されることも意図しているので、いつかはウ
ィンドウ内(*note Windows::を参照してください)に表示されます。しかしバッ
ファーはウィンドウに表示される必要はありません。バッファーはそれぞれ、
“ポイント(point)”と呼ばれる位置指定をもちます(*note Positions::を参照し
てください)。ほとんどの編集コマンドは、カレントバッファー内のポイントに
隣接する内容を処理します。常に1つのバッファーが“カレントバッファー
(current buffer)”です。

   バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの
文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキ
ストを“挿入”するためには、部分文字列の結合が必要で、結果は完全に新しい文
字列オブジェクトなのに比べて、バッファーでは既存のバッファーに効率的にテ
キストを挿入して、バッファーの内容を変更できます。

   標準的なEmacs関数の多くは、カレントバッファー内の文字を操作したりテス
トするためのものです。このマニュアルには、これらの関数の説明のために、
1つのチャプターをあてています(*note Text::を参照してください)。

   他のデータ構造のいくつかは、各バッファーに関連付けられています:

   • ローカル構文テーブル(*note Syntax Tables::を参照してください)。

   • ローカルキーマップ(*note Keymaps::を参照してください)。

   • バッファーローカルな変数バインディングのリスト(*note Buffer-Local
     Variables::を参照してください)。

   • オーバーレイ(*note Overlays::を参照してください)。

   • バッファー内のテキストにたいするテキストプロパティー(*note Text
     Properties::を参照してください)。

ローカルキーマップと変数リストは、具ローマルナバインディングや値を個別に
オーバーライドするためのエントリーを含みます。これらは、実際にプログラム
を変更することなく、異なるバッファーでのプログラムの振る舞いをカスタマイ
ズするために使用されます。

   バッファーは“インダイレクト(indirect: 間接)” — つまり他のバッファーと
テキストを共有するが、それぞれ別に表示する — かもしれません。*note
Indirect Buffers::を参照してください。

   バッファーに入力構文はありません。バッファーはバッファー名を含むハッ
シュ表記でプリントされます。

     (current-buffer)
          ⇒ #<buffer objects.texi>


File: elisp,  Node: Marker Type,  Next: Window Type,  Prev: Buffer Type,  Up: Editing Types

2.4.2 Marker Type
-----------------

“マーカー(marker)”は、特定のバッファー内の位置を表します。したがってマー
カーには2つの内容 — 1つはバッファー、もう1つは位置 — をもちます。バッフ
ァーのテキストの変更では、マーカーが常にバッファー内の同じ2つの文字の間
に位置することを確実にするために、必要に応じて自動的に位置の値が再配置さ
れます。

   マーカーは入力構文をもちません。マーカーは、カレントの文字位置と、そ
のバッファー名を与える、ハッシュ表記でプリントされます。

     (point-marker)
          ⇒ #<marker at 10779 in objects.texi>

   マーカーのテスト、作成、コピー、移動の方法についての情報は、*note
Markers::を参照してください。


File: elisp,  Node: Window Type,  Next: Frame Type,  Prev: Marker Type,  Up: Editing Types

2.4.3 Window Type
-----------------

“ウィンドウ(window)”はEmacsがバッファーを表示するために使用する端末スク
リーンの部分を記述します。すべてのウィンドウは関連付けられた1つのバッフ
ァーをもち、バッファーの内容はそのウィンドウに表示されます。対照的に、あ
るバッファーは、1つのウィンドウに表示されるか、ウィンドウに表示されない
か、それとも複数のウィンドウに表示されるかもしれません。

   同時に複数のウィンドウが存在するかもしれませんが、常に1つのウィンドウ
が“選択されたウィンドウ(selected window)”になります。Emacsがコマンドにた
いして準備できているときに、(通常は)カーソルが表示されるウィンドウが、選
択されたウィンドウです。選択されたウィンドウは通常、カレントバッファーを
表示しますが、これは必須ではありません。

   スクリーン上でウィンドウはフレームにグループ化されます。各ウィンドウ
は、ただ1つだけのフレームに属します。*note Frame Type::を参照してくださ
い。

   ウィンドウは入力構文をもちません。ウィンドウは、ウィンドウ番号、表示
されているバッファー名を与える、ハッシュ表記でプリントされます。与えられ
たウィンドウに表示されるバッファーは頻繁に変更されるかもしれないので、一
意にウィンドウを識別するためにウィンドウ番号が存在します。

     (selected-window)
          ⇒ #<window 1 on objects.texi>

   ウィンドウに作用する関数の説明は、*note Windows::を参照してください。


File: elisp,  Node: Frame Type,  Next: Terminal Type,  Prev: Window Type,  Up: Editing Types

2.4.4 Frame Type
----------------

“フレーム(frame)”とは、１つ以上のEmacsウィンドウを含むスクリーン領域です
。スクリーン領域を参照するためにEmacsが使用するLispオブジェクトを指す場
合も、“フレーム”という用語を使用します。

   フレームは入力構文をもちません。フレームはフレームのタイトル、(フレー
ムを一意に識別するのに便利な)メモリー内のアドレスを与えるハッシュ表記で
プリントされます。

     (selected-frame)
          ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>

   フレームに作用する関数の説明は、*note Frames::を参照してください。


File: elisp,  Node: Terminal Type,  Next: Window Configuration Type,  Prev: Frame Type,  Up: Editing Types

2.4.5 Terminal Type
-------------------

“端末(terminal)”は、1つ以上のEmacsフレーム(*note Frame Type::を参照して
ください)を表示する能力があるデバイスです。

   端末は入力構文をもちません。端末は、その端末の順序番号、TTYデバイスフ
ァイル名を与える、ハッシュ表記でプリントされます。

     (get-device-terminal nil)
          ⇒ #<terminal 1 on /dev/tty>


File: elisp,  Node: Window Configuration Type,  Next: Frame Configuration Type,  Prev: Terminal Type,  Up: Editing Types

2.4.6 Window Configuration Type
-------------------------------

“ウィンドウ構成(window configuration)”は、フレーム内のウィンドウの位置、
サイズ、内容についての情報を保持します。これにより後で同じウィンドウ配置
を再作成できます。

   ウィンドウ構成は入力構文をもちません。ウィンドウ構成のプリント表現は
、‘#<window-configuration>’のようになります。ウィンドウ構成に関連するい
くつかの関数の説明は、*note Window Configurations::を参照してください。


File: elisp,  Node: Frame Configuration Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

2.4.7 Frame Configuration Type
------------------------------

“フレーム構成(frame configuration)”は、すべてのフレーム内のウィンドウの
位置、サイズ、内容についての情報を保持します。これは基本型ではありません
— 実際のところ、これはCARが‘frame-configuration’で、CDRがalistのリストで
す。各alist要素は、その要素のCARに示される1つのフレームを記述します。

   フレーム構成に関連するいくつかの関数の説明は、*note Frame
Configurations::を参照してください。


File: elisp,  Node: Process Type,  Next: Stream Type,  Prev: Frame Configuration Type,  Up: Editing Types

2.4.8 Process Type
------------------

単語“プロセス(process)”は通常、実行中のプログラムを意味します。Emacs自身
はこの種のプロセス内で実行されます。しかしEmacs Lispでは、プロセスとは
Emacsプロセスにより作成されたサブプロセスを表す、Lispオブジェクトです。
シェル、GDB、ftp、コンパイラーなどのプログラムは、Emacsのサブプロセスと
して実行され、Emacsの能力を拡張します。さらに操作を行なうために、Emacsサ
ブプロセスは、Emacsからテキスト入力を受け取り、テキスト出力をEmacsに
returnします。Emacsは、サブプロセスにシグナルを送ることもできます。

   プロセスオブジェクトは入力構文をもちません。プロセスオブジェクトは、
プロセス名を与えるハッシュ表記でプリントされます。

     (process-list)
          ⇒ (#<process shell>)

   プロセスの作成、削除、プロセスに関する情報のreturn、入力やシグナルの
送信、出力の受信を行なう関数についての情報は、*note Processes::を参照し
てください。


File: elisp,  Node: Stream Type,  Next: Keymap Type,  Prev: Process Type,  Up: Editing Types

2.4.9 Stream Type
-----------------

“ストリーム(stream)”とは、文字のソースまたはシンクとして — つまり入力と
して文字を供給したり、出力として文字を受け入れるために使用できるオブジェ
クトです。多くの異なるタイプ — マーカー、バッファー、文字列、関数を、こ
の方法で使用できます。ほとんどの場合、入力ストリーム(文字列ソース)は、キ
ーボード、バッファー、ファイルから文字を受け取り、出力ストリーム(文字シ
ンク)は文字を‘*Help*’バッファーのようなバッファー、エコーエリアに文字を
送ります。

   オブジェクト‘nil’は、他の意味に加えて、ストリームとして使用されること
があります。‘nil’は変数‘standard-input’や‘standard-output’の値を表します
。オブジェクト‘t’も、入力としてミニバッファー(*note Minibuffers::を参照
してください)、出力としてエコーエリア(*note The Echo Area::を参照してく
ださい)の使用を指定するストリームになります。

   ストリームは特別なプリント表現や入力構文をもたず、何であれ、それらの
基本型としてプリントされます。

   パース関数およびプリント関数を含む、ストリームに関連した関数の説明は
、*note Read and Print::を参照してください。


File: elisp,  Node: Keymap Type,  Next: Overlay Type,  Prev: Stream Type,  Up: Editing Types

2.4.10 Keymap Type
------------------

“キーマップ(keymap)”は、ユーザーがタイプした文字を、コマンドにマップしま
す。このマップは、ユーザーのコマンド入力が実行される方法を制御します。キ
ーマップは、実際にはCARがシンボル‘keymap’のリストです。

   キーマップの作成、プレフィクスキーの処理、ローカルキーマップやグロー
バルキーマップ、キーバインドの変更についての情報は、*note Keymaps::を参
照してください。


File: elisp,  Node: Overlay Type,  Next: Font Type,  Prev: Keymap Type,  Up: Editing Types

2.4.11 Overlay Type
-------------------

“オーバーレイ(overlay)”は、バッファーの一部に適用するプロパティーを指定
します。それぞれのオーバーレイはバッファーの指定された範囲に適用され、プ
ロパティーリスト(プロパティー名と値が交互に記述された要素のリスト)を含み
ます。オーバーレイプロパティーは、バッファーの指定された一部を、一時的に
異なるスタイルで表示するために使用されます。オーバーレイは入力構文をもた
ず、バッファーメイト範囲の位置を与えるハッシュ表記でプリントされます。

   オーバーレイを作成したり使用する方法についての情報は、*note
Overlays::を参照してください。


File: elisp,  Node: Font Type,  Prev: Overlay Type,  Up: Editing Types

2.4.12 Font Type
----------------

“font”は、グラフィカルな端末上のテキストを表示する方法を指定します。実際
には異なる3つのフォント型 — “フォントオブジェクト(font objects)”、“フォ
ントスペック(font specs)”、“フォントエンティティー(font entities)” — が
存在しますこれらは入力構文をもちません。これらのプリント構文は、
‘#<font-object>’、‘#<font-spec>’、‘#<font-entity>’のようになります。これ
らのLispオブジェクトの説明は、*note Low-Level Font::を参照してください。


File: elisp,  Node: Circular Objects,  Next: Type Predicates,  Prev: Editing Types,  Up: Lisp Data Types

2.5 Read Syntax for Circular Objects
====================================

複雑なLispオブジェクトにおける共有された構造、または循環する構造を表すた
めに、リーダー構成‘#N=’と‘#N#’を使用することができます。

   後でオブジェクトを参照するには、オブジェクトの前で‘#N=’を使用します。
その後で、他の場所にある同じオブジェクトを参照するために、‘#N#’を使用す
ることができます。ここでNは任意の整数です。たとえば以下は、1番目の要素が
3番目の要素にも繰り替えされるリストを作成する方法です:

     (#1=(a) b #1#)

これは、以下のような通常の構文とは異なります

     ((a) b (a))

これは1番目の要素と3番目の要素がそっくりなリストですが、これらは同じ
Lispオブジェクトではありません。以下で違いを見ることができます:

     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ nil

   “要素”として自身を含むような、循環する構造を作成するために、同じ構文
を使用できます。以下は例です:

     #1=(a #1#)

これは、2番目の要素がそのリスト自身であるリストを作成します。これが実際
にうまくいくのか、以下で確認できます:

     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          ⇒ t

   変数‘print-circle’を非‘nil’値にバインドした場合、Lispプリンターは、循
環および共有されるLispオブジェクトを記録するこの構文を、生成することがで
きます。*note Output Variables::を参照してください。


File: elisp,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Circular Objects,  Up: Lisp Data Types

2.6 Type Predicates
===================

Emacs Lispインタープリター自身は、関数が呼び出されたときに、その関数に渡
された実際の引数にたいする型チェックは行ないません。それが行なえないのは
、Lispにおける関数の引数は、他のプログラミング言語のようなデータ型宣言を
もたないからです。したがって実際の引数が、その関数が使用できる型に属する
かどうかをテストするのは、それぞれの関数に任されています。

   すべてのビルトイン関数は、適切なときに実際の引数の型チェックを行い、
引数の型が違う場合は、‘wrong-type-argument’エラーをシグナルします。たと
えば以下は、‘+’の引数に、‘+’が扱うことができない引数を渡したとき何が起こ
るかの例です:

     (+ 2 'a)
          error→ Wrong type argument: number-or-marker-p, a

   異なる型にたいして異なる処理をプログラムに行なわせる場合は、明示的に
型チェックを行なわなければなりません。オブジェクトの型をチェックするもっ
とも一般的な方法は、“型述語(type predicate)”関数の呼び出しです。Emacsは
それぞれの型にたいする型述語をもち、組み合わされた型にたいする述語もあり
ます。

   型述語関数は1つの引数をとり、その引数が適切な型であれば‘t’、そうでな
い場合は‘nil’をreturnします。述語関数にたいする一般的なLisp慣習にしたが
い、ほとんどの型述語の名前は、‘p’で終わります。

   以下はリストにたいしてチェックを行なう述語‘listp’と、シンボルにたいし
てチェックを行なう述語‘symbolp’の例です。

     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))

   以下の表は、事前定義された型述語(アルファベット順)と、さらに情報を得
るためのリファレンスです。

‘atom’
     *note atom: List-related Predicates.を参照してください。

‘arrayp’
     *note arrayp: Array Functions.を参照してください。

‘bool-vector-p’
     *note bool-vector-p: Bool-Vectors.を参照してください。

‘bufferp’
     *note bufferp: Buffer Basics.を参照してください。

‘byte-code-function-p’
     *note byte-code-function-p: Byte-Code Type.を参照してください。

‘case-table-p’
     *note case-table-p: Case Tables.を参照してください。

‘char-or-string-p’
     *note char-or-string-p: Predicates for Strings.を参照してください。

‘char-table-p’
     *note char-table-p: Char-Tables.を参照してください。

‘commandp’
     *note commandp: Interactive Call.を参照してください。

‘consp’
     *note consp: List-related Predicates.を参照してください。

‘custom-variable-p’
     *note custom-variable-p: Variable Definitions.を参照してください。

‘display-table-p’
     *note display-table-p: Display Tables.を参照してください。

‘floatp’
     *note floatp: Predicates on Numbers.を参照してください。

‘fontp’
     *note Low-Level Font::を参照してください。

‘frame-configuration-p’
     *note frame-configuration-p: Frame Configurations.を参照してくださ
     い。

‘frame-live-p’
     *note frame-live-p: Deleting Frames.を参照してください。

‘framep’
     *note framep: Frames.を参照してください。

‘functionp’
     *note functionp: Functions.を参照してください。

‘hash-table-p’
     *note hash-table-p: Other Hash.を参照してください。

‘integer-or-marker-p’
     *note integer-or-marker-p: Predicates on Markers.を参照してください
     。

‘integerp’
     *note integerp: Predicates on Numbers.を参照してください。

‘keymapp’
     *note keymapp: Creating Keymaps.を参照してください。

‘keywordp’
     *note Constant Variables::を参照してください。

‘listp’
     *note listp: List-related Predicates.を参照してください。

‘markerp’
     *note markerp: Predicates on Markers.を参照してください。

‘wholenump’
     *note wholenump: Predicates on Numbers.を参照してください。

‘nlistp’
     *note nlistp: List-related Predicates.を参照してください。

‘numberp’
     *note numberp: Predicates on Numbers.を参照してください。

‘number-or-marker-p’
     *note number-or-marker-p: Predicates on Markers.を参照してください
     。

‘overlayp’
     *note overlayp: Overlays.を参照してください。

‘processp’
     *note processp: Processes.を参照してください。

‘sequencep’
     *note sequencep: Sequence Functions.を参照してください。

‘stringp’
     *note stringp: Predicates for Strings.を参照してください。

‘subrp’
     *note subrp: Function Cells.を参照してください。

‘symbolp’
     *note symbolp: Symbols.を参照してください。

‘syntax-table-p’
     *note syntax-table-p: Syntax Tables.を参照してください。

‘vectorp’
     *note vectorp: Vectors.を参照してください。

‘window-configuration-p’
     *note window-configuration-p: Window Configurations.を参照してくだ
     さい。

‘window-live-p’
     *note window-live-p: Deleting Windows.を参照してください。

‘windowp’
     *note windowp: Basic Windows.を参照してください。

‘booleanp’
     *note booleanp: nil and t.を参照してください。

‘string-or-null-p’
     *note string-or-null-p: Predicates for Strings.を参照してください。

   あるオブジェクトがどの型かチェックするもっとも一般的な方法は、関数
‘type-of’の呼び出しです。オブジェクトは、ただ1つだけの基本型に属すること
を思い出してください。‘type-of’は、それがどの型(*note Lisp Data Types::を
参照してください)か告げます。しかし‘type-of’は基本型以外の型については何
も知りません。ほとんどの場合、‘type-of’より型述語を使用するほうが便利で
しょう。

 -- Function: type-of object
     この関数はOBJECTの基本型を名前とする、シンボルをreturnします。
     retuen値はシンボル‘bool-vector’、‘buffer’、‘char-table’、
     ‘compiled-function’、‘cons’、‘float’、‘font-entity’、
     ‘font-object’、‘font-spec’、‘frame’、‘hash-table’、‘integer’、
     ‘marker’、‘overlay’、‘process’、‘string’、‘subr’、‘symbol’、
     ‘vector’、‘window’、‘window-configuration’のうちの1つです。

          (type-of 1)
               ⇒ integer
          (type-of 'nil)
               ⇒ symbol
          (type-of '())    ; ‘()’は‘nil’です。
               ⇒ symbol
          (type-of '(x))
               ⇒ cons


File: elisp,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Lisp Data Types

2.7 Equality Predicates
=======================

ここでは、2つのオブジェクトの同一性をテストする関数を説明します。(たとえ
ば文字列などの)特定の型のオブジェクト同士で、内容の同一性をテストするの
は、別の関数を使用します。これらの述語にたいしては、そのデータ型を説明す
る、適切なチャプターを参照してください。

 -- Function: eq object1 object2
     この関数はOBJECT1とOBJECT2が同じオブジェクトの場合は‘t’、それ以外は
     ‘nil’をreturnします。

     OBJECT1とOBJECT2が、同じ値をもつ整数の場合、これらは同じオブジェク
     トと判断されます(‘eq’は‘t’をreturnします)。OBJECT1とOBJECT2が、同じ
     名前のシンボルの場合、通常は同じオブジェクトです。しかし例外もあり
     ます。*note Creating Symbols::を参照してください。(リスト、ベクター
     文字列などの)他の型にたいしては、同じ内容(または要素)の2つの引数が
     、両者‘eq’である必要はありません。これらが同じオブジェクトの場合だ
     け‘eq’であり、その場合は、一方の内容を変更すると、もう一方の内容に
     も同じ変更が反映されます。

          (eq 'foo 'foo)
               ⇒ t

          (eq 456 456)
               ⇒ t

          (eq "asdf" "asdf")
               ⇒ nil

          (eq "" "")
               ⇒ t
          ;; この例外は省スペースのためにEmacs Lispが
          ;; ただ1つのマルチバイトの空文字列を作成するためです。

          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (setq foo '(1 (2 (3))))
               ⇒ (1 (2 (3)))
          (eq foo foo)
               ⇒ t
          (eq foo '(1 (2 (3))))
               ⇒ nil

          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (eq (point-marker) (point-marker))
               ⇒ nil

     ‘make-symbol’関数は、internされていないシンボルをreturnします。これ
     はLisp式内で、その名前を記述したシンボルとは区別されます。同じ名前
     の、異なるシンボルは、‘eq’ではありません。*note Creating Symbols::を
     参照してください。

          (eq (make-symbol "foo") 'foo)
               ⇒ nil

 -- Function: equal object1 object2
     この関数は、OBJECT1とOBJECT2が同じ構成要素をもつ場合は‘t’、それ以外
     は‘nil’をreturnします。‘eq’は引数が同じオブジェクトなのかテストする
     のにたいして、‘equal’は同一でない引数の内部を調べて、それらの要素ま
     たは内容が同一化をテストします。したがって2つのオブジェクトが‘eq’な
     らば、それらは‘equal’です。しかし、その逆は常に真ではありません。

          (equal 'foo 'foo)
               ⇒ t

          (equal 456 456)
               ⇒ t

          (equal "asdf" "asdf")
               ⇒ t
          (eq "asdf" "asdf")
               ⇒ nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               ⇒ t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (equal [(1 2) 3] [(1 2) 3])
               ⇒ t
          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (equal (point-marker) (point-marker))
               ⇒ t

          (eq (point-marker) (point-marker))
               ⇒ nil

     文字列の比較は大文字小文字を区別しますが、テキストプロパティーは考
     慮しません — これは文字列内の文字だけを比較します。*note Text
     Properties::を参照してください。テキストプロパティーも比較する場合
     は、‘equal-including-properties’を使用します。記述的な理由により、
     ユニバイト文字列とマルチバイト文字列は、それらが同じ文字シーケンス
     を含み、それらすべてのコードが0から127(ASCII)、または160から
     255(‘8ビットグラフィック’)の場合に限り、‘equal’です(*note Text
     Representations::を参照してください)。

          (equal "asdf" "ASDF")
               ⇒ nil

     しかし2つの別のバッファーは、それらのテキスト内容が同じでも、
     ‘equal’と判断されることはありません。

   ‘equal’のテストは再帰により実装されています。たとえば2つのコンスセル
XとYを与えると、‘(equal X Y)’は、以下の式の両方が‘t’をreturnする場合に限
り、‘t’をreturnします:

     (equal (car X) (car Y))
     (equal (cdr X) (cdr Y))

   これは再帰処理なので、循環するリストがあると無限再帰となります(エラー
となります)。

 -- Function: equal-including-properties object1 object2
     この関数はすべてのケースにおいて‘equal’と同様に振る舞いますが、2つ
     の文字列が‘equal’になるためには、それらが同じテキストプロパティーを
     もつ必要があります。

          (equal "asdf" (propertize "asdf" 'asdf t))
               ⇒ t
          (equal-including-properties "asdf"
                                      (propertize "asdf" 'asdf t))
               ⇒ nil


File: elisp,  Node: Numbers,  Next: Strings and Characters,  Prev: Lisp Data Types,  Up: Top

3 Numbers
*********

GNU Emacsは2つの数値データ型 — “整数(integers)”と“浮動小数点数
(floating-point numbers)”をサポートします。整数は−3、0、7、13、511などの
整数です。浮動小数点数は−4.5、0.0、2.71828などの小数部をもちます・これら
は指数記数法でも表現できます — ‘1.5e2’は‘150.0’と同じです。ここで‘e2’は
10の2乗をあらわし、それに1.5を乗じるという意味です。整数計算は正確であり
、オーバーフローするときもあります。浮動小数点数の計算においては、数値は
固定された精度をもつため、、しばしば丸め誤差(rounding errors)を引き起こ
します。

* Menu:

* Integer Basics::           整数の表現と範囲。
* Float Basics::             浮動少数の表現と範囲。
* Predicates on Numbers::    数にたいするテスト。
* Comparison of Numbers::    同一性と非同一性の述語。
* Numeric Conversions::      手動小数点数から整数、または疎の逆の変換。
* Arithmetic Operations::    加減乗除の方法。
* Rounding Operations::      浮動小数点数の明示的な丸め。
* Bitwise Operations::       論理的なadd、or、not、shift。
* Math Functions::           三角法、指数、対数関数。
* Random Numbers::           予測可能または不可能な乱数の取得。


File: elisp,  Node: Integer Basics,  Next: Float Basics,  Up: Numbers

3.1 Integer Basics
==================

整数の値の範囲はマシンに依存します。最小の範囲は−536,870,912から
536,870,911(30ビット長の −2**29 から 2**29 − 1) ですが、多くのマシンはこ
れより広い範囲を提供します。このチャプターの例の多くは、最小の整数は30ビ
ット長であると仮定します。

   Lispリーダーは、(オプションで最初の符号記号と、最後のピリオドをともな
う)数字のシーケンスとして整数を読み取ります。Emacsの範囲を超える整数は、
浮動小数点数として扱われます。

      1               ; 整数1。
      1.              ; 整数1。
     +1               ; これも整数1。
     -1               ; 整数−1。
      9000000000000000000
                      ; 浮動小数点数9e18.
      0               ; 整数0
     -0               ; 整数0

   基数が10以外の整数の構文は、‘#’の後に基数を指定する文字 — 2進は‘b’、
8進は‘o’、16進は‘x’、‘RADIXr’は基数RADIX — を記述します。基数を指定する
文字の大文字小文字は区別されません。したがって‘#bINTEGER’はINTEGERを2進
として読み取り、‘#RADIXrINTEGER’はINTEGERを基数RADIXとして読み取ります。
RADIXに指定できる値は2から36です。たとえば:

     #b101100 ⇒ 44
     #o54 ⇒ 44
     #x2c ⇒ 44
     #24r1k ⇒ 44

   整数にたいして処理を行なうさまざまな関数、特にビット演算(*note
Bitwise Operations::を参照してください)を理解するためには、数を2進形式で
見ることが助けになることがしばしばあります。

   30ビットの2進では、10進数の整数5は以下のようになります:

     0000...000101 (全部で30ビット)

(‘...’は30ビットのワードを満たすのに充分なビットを意味し、この場合の
‘...’は12個の0ビットを意味します。以下の例でも、2進の整数を読みやすくす
るために、‘...’の表記を使用します)

   整数の−1は、以下のようになります:

     1111...111111 (全部で30ビット)

−1は30個の1で表現されます(これは“2の補数”表記と呼ばれます)。

   −1から4を減じることにより、負の整数−5が得られます。10進の整数4は、2進
では100です。したがって、−5は以下のようになります:

     1111...111011 (全部で30ビット)

   この実装では、0ビットの2進の最大は、10進の536,870,911です。これは2進
では以下のようになります:

     0111...111111 (全部で30ビット)

   算術関数は整数が範囲の外かをチェックしないので、536,870,911に1を加え
ると、その値は負の整数−536,870,912になります:

     (+ 1 536870911)
          ⇒ -536870912
          ⇒ 1000...000000 (全部で30ビット)

   このチャプターで説明する多くの関数は、数字の位置として引数にマーカー
(*note Markers::を参照してください)を受け取ります。そのような関数にたい
する実際の引数は数字かマーカーなので、わたしたちはこれらの引数に
NUMBER-OR-MARKERという名前を与えることがあります。引数の値がマーカーの場
合、マーカーの位置が使用され、マーカーのバッファーは無視されます。

 -- Variable: most-positive-fixnum
     この変数の値は、Emacs Lispが扱える整数の最大値です。典型的な値は
     32ビットでは 2**29 − 1 、64ビットでは 2**61 − 1 です。

 -- Variable: most-negative-fixnum
     この変数の値は、Emacs Lispが扱える最小の整数です。これは負の整数で
     す。典型的な値は32ビットでは −2**29 、64ビットでは −2**61、 です。

   Emacs Lispでは、テキスト文字は整数により表現されます。0から
‘(max-char)’までの整数は、有効な文字として判断されます。*note Character
Codes::を参照してください。


File: elisp,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

3.2 Floating-Point Basics
=========================

浮動小数点数は整数ではない数を表現するのに便利です。浮動小数点数の範囲は
、使用しているマシンでのCデータ型の‘double’と同じ範囲です。現在Emacsでサ
ポートされているすべてのコンピューターでは、これは倍精度のIEEE浮動小数点
数です。

   浮動小数点数にたいする入力構文は、小数点と指数のどちらか1つ、または両
方が必要とします。オプションの符号(‘+’か‘-’)は、その数字と指数の前に記述
します。たとえば、‘1500.0’、‘+15e2’、‘15.0e+2’、‘+1500000e-3’、‘.15e4’は
、値が1500の浮動小数点数を記述する5つの方法です。これらはすべて等価です
。Common Lispと同様、Emacs Lispは、浮動小数点数の小数点の後に、少なくと
も1つの数字を必要とします。‘1500.’は整数であり、浮動小数点数ではありませ
ん。

   Emacs Lispは‘-0.0’を、‘equal’と‘=’に関して、通常の0と数学的に同じもの
として扱います。これは、(他の処理がこれらを区別するとしても、‘-0.0’と
‘0.0’は数学的に等しいとする)IEEE浮動小数点数規格にしたがっています。

   IEEE浮動小数点数規格は、浮動小数点数として、正の無限大と、負の無限大
をサポートします。この規格はNaNまたは“not-a-number(数字ではない)”と呼ば
れる値クラスも提供します。数学関数は、正しい答えが存在しないような場合に
、このような値をreturnします。たとえば‘(/ 0.0 0.0)’はNaNをreturnします。
NaN値に符号がついていたとしても、実用的な目的にたいして、Emacs Lispにお
ける異なるNaN値に、意味のある違いはありません。

   以下は、これらの特別な浮動小数点数にたいする入力構文です:

infinity
     ‘1.0e+INF’と‘-1.0e+INF’
not-a-number
     ‘0.0e+NaN’と‘-0.0e+NaN’

   以下の関数は浮動小数点数を扱うために特化したものです:

 -- Function: isnan x
     この述語は浮動小数引数がNaNのときは‘t’、それ以外は‘nil’をreturnしま
     す。

 -- Function: frexp x
     この関数はコンスセル‘(S . E)’をreturnします。ここでSとEは、浮動小数
     点数のsignificand(浮動小数点数を2の指数表現したときの仮引数)と指数
     です。

     Xが有限の場合、Sは0.5以上1.0未満の浮動小数点数で、Eは整数で、 X = S
     * 2**Eです。 Xが0または無限の場合、SはXと等しくなります。XがNaNの場
     合は、SもNaNです。Xが0の場合、Eは0です。

 -- Function: ldexp sig &optional exp
     この関数は、significandがSIG、指数がEXPの浮動小数点数をreturnします
     。

 -- Function: copysign x1 x2
     koの関数はX2の、X1の値にコピーして、その結果をreturnします。X1と
     X2は浮動小数でなければなりません。

 -- Function: logb x
     この関数はXの2進指数をreturnします。より正確にいうと、この値は|x|の
     2を底とする対数を、整数に切り下げたものです。

          (logb 10)
               ⇒ 3
          (logb 10.0e20)
               ⇒ 69


File: elisp,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

3.3 Type Predicates for Numbers
===============================

このセクションの関数は、数または数の特定の型にたいしてテストを行ないます
。関数‘integerp’および‘floatp’は、引き数として任意のLispオブジェクト型を
とることができます(そうでないと、あまり使用する機会がありません)。しかし
、述語‘zerop’は、引き数として数を要求します。*note Predicates on
Markers::の‘integer-or-marker-p’と‘number-or-marker-p’も参照してください
。

 -- Function: floatp object
     この述語は、引数が浮動小数かどうかをテストして、もしそうなら‘t’、そ
     れ以外は‘nil’をreturnします。

 -- Function: integerp object
     この述語は引数が整数かどうかをテストして、もしそうなら‘t’、それ以外
     は‘nil’をreturnします。

 -- Function: numberp object
     この述語は引数が数(整数か浮動小数)かどうかをテストして、もしそうな
     ら‘t’、それ以外は‘nil’をreturnします。

 -- Function: natnump object
     この述語(名前は“natural number(自然数)”が由来です)は、引数が正の整
     数かどうかをテストして、もしそうなら‘t’、それ以外は‘nil’をreturnし
     ます。0は整数と判断されます。

     ‘wholenump’は、‘natnump’にたいするシノニムです。

 -- Function: zerop number
     この述語は、引数が0かどうかをテストして、もしそうなら‘t’、それ以外
     は‘nil’をreturnします。引数は数でなければなりません。

     ‘(zerop x)’は、‘(= x 0)’と等価です。


File: elisp,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

3.4 Comparison of Numbers
=========================

数が数値的に等しいかテストするためには、‘eq’ではなく、通常は‘=’を使用す
るべきです。同じ数値をもつ、多くの浮動小数オブジェクトが存在するかもしれ
ません。これらを比較するのに‘eq’を使用する場合、これは2つの値が同じオブ
ジェクトかどうかをテストすることになります。対照的に、‘=’はオブジェクト
の数値的な値だけを比較します。

   Emacs Lispでは、それぞれの整数はは、一意なLispオブジェクトです。した
がって、整数に関しては、‘eq’は‘=’と同じです。未知の整数の値を比較するの
に、‘eq’を使用するのが便利な場合があります。なぜなら未知の値が数字でない
場合でも、‘eq’はエラーを報告しません。対照的に、引数が数でもマーカーでも
ない場合、‘=’はエラーをシグナルします。しかし、整数の比較においてさえ、
使用できる場合は‘=’を使用するのが、よいプログラミング習慣です。

   数の比較において、2つの数が同じデータ型(どちらも整数、またはどちらも
浮動小数)で、同じ値の場合は等しい数として扱う、‘equal’のほうが便利なとき
もあります。対照的に、‘=’は、整数と浮動小数点数を等しい数と扱うことがで
きます。*note Equality Predicates::を参照してください。

   他の欠点もあります。浮動小数演算は正確ではないので、浮動小数値を比較
するのが悪いアイデアのときが、しばしばあります。通常は、近似的に等しいこ
とをテストするほうがよいでしょう。以下はこれを行なう関数です:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (= x y)
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

     Common Lispに関する注意: Common Lispは複数ワード整数を実装していて
     、2つの別の整数オブジェクトが、同じ数値的な値をもつことができるので
     、Common Lispでの数の比較は、常に‘=’が要求されます。Emacs Lispの整
     数は範囲が制限されているため、与えられた値に対応する整数オブジェク
     トは、1つだけです。

 -- Function: = number-or-marker &rest number-or-markers
     この関数は、すべての引数が数値的に等しいかどうかをテストして、もし
     そうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: eql value1 value2
     この関数は‘eq’と同様に振る舞いますが、引数が両方とも数のときは例外
     です。これは数を型と数値的な値により比較するので、‘(eql 1.0 1)’は
     ‘nil’をreturnしますが、‘(eql 1.0 1.0)’と‘(eql 1 1)’は‘t’をreturnし
     ます。

 -- Function: /= number-or-marker1 number-or-marker2
     この関数は引数が数値的に等しいかどうかをテストして、もし異なる場合
     は‘t’、等しい場合は‘nil’をreturnします。

 -- Function: < number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数より小さいかどうかをテス
     トして、もしそうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: <= number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数以下かどうかをテストして
     、もしそうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: > number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数より大きいかどうかをテス
     トして、もしそうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: >= number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数以上かどうかをテストして
     、もしそうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: max number-or-marker &rest numbers-or-markers
     この関数は引数の最大をreturnします。引数のどれかが浮動小数の場合は
     、たとえ最大が整数であっても、浮動小数として値がreturnされます。

          (max 20)
               ⇒ 20
          (max 1 2.5)
               ⇒ 2.5
          (max 1 3 2.5)
               ⇒ 3.0

 -- Function: min number-or-marker &rest numbers-or-markers
     この関数は引数の最小をreturnします。引数のどれかが浮動小数の場合は
     、たとえ最小が整数であっても、浮動小数として値がreturnされます。

          (min -4 1)
               ⇒ -4

 -- Function: abs number
     この関数はNUMBERの絶対値をreturnします。


File: elisp,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

3.5 Numeric Conversions
=======================

整数を浮動少数に変換するには、関数‘float’を使用します。

 -- Function: float number
     これは浮動小数に変換されたNUMBERをreturnします。すでにNUMBERが浮動
     小数の場合、‘float’はそれを変更せずにreturnします。

   浮動小数点数を整数に変換する関数が4つあります。これらは浮動小数点数を
丸める方法がことなります。これらはすべて引数NUMBERと、オプション引数とし
てDIVISORを受け取ります。引数は両方とも整数または浮動小数点数です。
DIVISORが‘nil’のこともあります。DIVISORが‘nil’または省略された場合、これ
らの関数はNUMBERを整数に変換するか、それが既に整数の場合は変更せずに
returnします。DIVISORが非‘nil’の場合、これらの関数はNUMBERをDIVISORで除
してから、その結果を整数に変換します。DIVISORが(整数か浮動小数かに関わら
ず)0の場合、Emacsは‘arith-error’エラーをシグナルします。

 -- Function: truncate number &optional divisor
     これは0に向かって丸めることにより整数に変換したNUMBERをreturnします
     。

          (truncate 1.2)
               ⇒ 1
          (truncate 1.7)
               ⇒ 1
          (truncate -1.2)
               ⇒ -1
          (truncate -1.7)
               ⇒ -1

 -- Function: floor number &optional divisor
     これは、下方(負の無限大に向かって)に丸めることにより整数に変換した
     NUMBERをreturnします。

     DIVISORが指定された場合、‘mod’に相当する種類の除算演算を使用して、
     下方に丸めを行ないます。

          (floor 1.2)
               ⇒ 1
          (floor 1.7)
               ⇒ 1
          (floor -1.2)
               ⇒ -2
          (floor -1.7)
               ⇒ -2
          (floor 5.99 3)
               ⇒ 1

 -- Function: ceiling number &optional divisor
     これは、上方(正の無限大に向かって)に丸めることにより整数に変換した
     NUMBERをreturnします。

          (ceiling 1.2)
               ⇒ 2
          (ceiling 1.7)
               ⇒ 2
          (ceiling -1.2)
               ⇒ -1
          (ceiling -1.7)
               ⇒ -1

 -- Function: round number &optional divisor
     これは、もっとも近い整数に向かって丸めることにより整数に変換した
     NUMBERをreturnします。2つの整数から等距離にある値の丸めでは、偶数の
     整数をreturnします。

          (round 1.2)
               ⇒ 1
          (round 1.7)
               ⇒ 2
          (round -1.2)
               ⇒ -1
          (round -1.7)
               ⇒ -2


File: elisp,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

3.6 Arithmetic Operations
=========================

Emacs Lispは伝統的な4つの算術演算(加減乗除)、同様に剰余とmodulusの関数、
および1加算、1減算の関数を提供します。‘%’を除き、これらの各関数は引き数
として整数か浮動小数を受け取り、浮動小数の引数がある場合は、浮動小数点数
をreturnします。

   Emacs Lispの算術関数は整数のオーバーフローをチェックしません。したが
って‘(1+ 536870911)’は−536870912に評価されるかもしれず、それはハードウェ
アーに依存します。

 -- Function: 1+ number-or-marker
     この関数はNUMBER-OR-MARKER + 1をreturnします。例えば、

          (setq foo 4)
               ⇒ 4
          (1+ foo)
               ⇒ 5

     この関数はCの演算子‘++’とは類似しません — この関数は変数をインクリ
     メントしません。この関数は和を計算するだけです、したがって以下を続
     けて評価すると、

          foo
               ⇒ 4

     変数をインクリメントしたい場合は、以下のように‘setq’を使用しなけれ
     ばなりません:

          (setq foo (1+ foo))
               ⇒ 5

 -- Function: 1- number-or-marker
     この関数はNUMBER-OR-MARKER − 1をreturnします。

 -- Function: + &rest numbers-or-markers
     この関数は引数すべてを加算します。引数を与えない場合、‘+’は0を
     returnします。

          (+)
               ⇒ 0
          (+ 1)
               ⇒ 1
          (+ 1 2 3 4)
               ⇒ 10

 -- Function: - &optional number-or-marker &rest more-numbers-or-markers
     ‘-’関数は2つの目的 — 符号反転と減算 —を果たします。‘-’に1つの引数を
     与えた場合、値は引数の符号を反転したものになります。複数の引数があ
     る場合、NUMBER-OR-MARKERからMORE-NUMBERS-OR-MARKERSまでの各値を蓄積
     的に減算します。引数がない場合、結果は0です。

          (- 10 1 2 3 4)
               ⇒ 0
          (- 10)
               ⇒ -10
          (-)
               ⇒ 0

 -- Function: * &rest numbers-or-markers
     この関数はすべての引数を乗じて、積をreturnします。引数がない場合、
     ‘*’は1をreturnします。

          (*)
               ⇒ 1
          (* 1)
               ⇒ 1
          (* 1 2 3 4)
               ⇒ 24

 -- Function: / dividend divisor &rest divisors
     この関数はDIVIDENDをDIVISORで除し、商をreturnします。追加の引数
     DIVISORSがある場合、その後さらにDIVIDENDをDIVISORSで順に除します。
     各引数は数かマーカーです。

     すべての引数が整数の場合、結果は各除算の後に商を0へ向かって丸めるこ
     とにより得られる整数になります。

          (/ 6 2)
               ⇒ 3
          (/ 5 2)
               ⇒ 2
          (/ 5.0 2)
               ⇒ 2.5
          (/ 5 2.0)
               ⇒ 2.5
          (/ 5.0 2.0)
               ⇒ 2.5
          (/ 25 3 2)
               ⇒ 4
          (/ -17 6)
               ⇒ -2

     整数を整数0で除すると、Emacsは‘arith-error’エラー(*note Errors::を
     参照してください)をシグナルします。浮動小数の除算においては、0でな
     い数を0で除することにより、正の無限大または負の無限大を得ます(*note
     Float Basics::を参照してください)。

 -- Function: % dividend divisor
     この関数は、DIVIDENDをDIVISORで除した後、その剰余を整数でreturnしま
     す。引数は整数かマーカーでなければなりません。

     任意の2つの整数DIVIDENDとDIVISORにたいして、

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     は、DIVISORが非0の場合は常にDIVIDENDと等しくなります。

          (% 9 4)
               ⇒ 1
          (% -9 4)
               ⇒ -1
          (% 9 -4)
               ⇒ 1
          (% -9 -4)
               ⇒ -1

 -- Function: mod dividend divisor
     この関数はDIVIDENDのDIVISORにたいするmodulo、言い換えるとDIVIDENDを
     DIVISORで除した後の剰余(ただし符号はDIVISORと同じ)えおreturnします
     。引数は数かマーカーでなければなりません。

     ‘%’とは異なり、‘mod’は浮動小数の引数を許容します。これは商を整数に
     下方(負の無限大に向かって)へ丸めて、剰余を計算するのにこの商を使用
     します。

     DIVISORが0のとき‘mod’は、両方の引数が整数の場合は‘arith-error’エラ
     ーをシグナルし、それ以外はNaNをreturnします。

          (mod 9 4)
               ⇒ 1
          (mod -9 4)
               ⇒ 3
          (mod 9 -4)
               ⇒ -3
          (mod -9 -4)
               ⇒ -1
          (mod 5.5 2.5)
               ⇒ .5

     任意の2つの数DIVIDENDとDIVISORにたいして、

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     は常にDIVIDENDになります(ただし引数のどちらかが浮動小数の場合は丸め
     誤差の範囲内で等しく、DIVIDENDが整数でDIVISORが0の場合は
     ‘arith-error’となります)。‘floor’については、*note Numeric
     Conversions::を参照してください。


File: elisp,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

3.7 Rounding Operations
=======================

関数‘ffloor’、‘fceiling’、‘fround’、‘ftruncate’は、浮動小数の引数をとり
、値が近くの整数であるような浮動少数をreturnします。‘ffloor’は一番近い下
方の整数、‘fceiling’は一番近い上方の整数、‘ftruncate’は0に向かう方向で一
番近い整数、‘fround’は一番近い整数をreturnします。

 -- Function: ffloor float
     この関数はFLOATを次に小さい整数値に丸めて、その値を浮動小数点数とし
     てreturnします。

 -- Function: fceiling float
     この関数はFLOATを次に大きい整数値に丸めて、その値を浮動小数点数とし
     てreturnします。

 -- Function: ftruncate float
     この関数はFLOATを0方向の整数値に丸めて、その値を浮動小数点数として
     returnします。

 -- Function: fround float
     この関数はFLOATを一番近い整数値に丸めて、その値を浮動小数点数として
     returnします。2つの整数値との距離が等しい値にたいする丸めでは、偶数
     の整数をreturnします。


File: elisp,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

3.8 Bitwise Operations on Integers
==================================

コンピューターの中では、整数は“ビット(bit: 0か1の数字)”のシーケンスであ
る、2進数で表されます。ビット演算は、そのようなシーケンスの中の個々のビ
ットに作用します。たとえば、“シフト(shifting)”はシーケンス全体を1つ以上
左または右に移動して、“移動された”のと同じパターンを再生します。

   Emacs Lispのビット演算は、整数だけに適用されます。

 -- Function: lsh integer1 count
     ‘lsh’は“logical shift”の略で、INTEGER1のビットを左にCOUNT個シフトし
     ます。COUNTが負の場合は右にシフトし、シフトにより空きになったビット
     には0がセットされます。COUNT isが負の場合、‘lsh’は左端(最上位)に0を
     シフトするので、INTEGER1が負の場合でも、正の結果が生成されます。こ
     れと対照的なのが、以下で説明する‘ash’です。

     以下に、‘lsh’でビットパターンの位置を1つ左にシフトする例を2つ紹介し
     ます。ここでは下位8ビットの2進パターンだけを表示しており、残りのビ
     ットはすべて0です。

          (lsh 5 1)
               ⇒ 10
          ;; 10進の5は、10進の10になります。
          00000101 ⇒ 00001010

          (lsh 7 1)
               ⇒ 14
          ;; 10進の7は、10進の14になります。
          00000111 ⇒ 00001110

     この例が説明するように、ビットパターンを左に1シフトすると、生成され
     る数は、元の数の2倍になります。

     ビットパターンを左に2シフトすると、以下(8ビット2進数)の結果が生成さ
     れます:

          (lsh 3 2)
               ⇒ 12
          ;; 10進の3は、10進の12になります。
          00000011 ⇒ 00001100

     一方、右に1シフトすると、以下のようになります:

          (lsh 6 -1)
               ⇒ 3
          ;; 10進の6は10進の3になります。
          00000110 ⇒ 00000011

          (lsh 5 -1)
               ⇒ 2
          ;; 10進の5は、10進の2になります。
          00000101 ⇒ 00000010

     例が明かにするように、右に1シフトすることにより、正の整数の値が2で
     除され、下方に丸められます。

     関数‘lsh’は、他のEmacs Lisp算術関数と同様、オーバーフローをチェック
     しないので、左にシフトすることにより上位ビットが捨てられ、その数の
     符号が変化するかもしれません。たとえば30ビットの実装では、
     536,870,911を左にシフトすると、−2が生成されます。

          (lsh 536870911 1)          ; 左シフト
               ⇒ -2

     2進では、この引数は以下のようになります:

          ;; 10進の536,870,911
          0111...111111 (全部で30ビット)

     これを左にシフトすると、以下のようになります:

          ;; 10進の−2
          1111...111110 (全部で30ビット)

 -- Function: ash integer1 count
     ‘ash’ (“算術シフト(arithmetic shift)”)は、INTEGER1の中のビット位置
     を左にCOUNTシフトします。COUNTが負の場合は右にシフトします。

     ‘ash’は‘lsh’と同じ結果を与えますが、例外はINTEGER1とCOUNTがとみに負
     の場合です。この場合、‘lsh’は左にできる空きビットに0を置きますが、
     ‘ash’は1を置きます。

     したがって‘ash’でビットパターンの位置を右に1シフトすると、以下のよ
     うになります:

          (ash -6 -1) ⇒ -3
          ;; 10進の−6は、10進の−3になります
          1111...111010 (30 bits total)
               ⇒
          1111...111101 (30 bits total)

     対照的に、‘lsh’でビットパターンの位置を1右にシフトすると、以下のよ
     うになります:

          (lsh -6 -1) ⇒ 536870909
          ;; 10進の−6は、10進の536,870,909になります。
          1111...111010 (30 bits total)
               ⇒
          0111...111101 (30 bits total)

     他にも例を示します:

                             ;         30ビットの2進数

          (lsh 5 2)          ;   5  =  0000...000101
               ⇒ 20         ;      =  0000...010100
          (ash 5 2)
               ⇒ 20
          (lsh -5 2)         ;  -5  =  1111...111011
               ⇒ -20        ;      =  1111...101100
          (ash -5 2)
               ⇒ -20
          (lsh 5 -2)         ;   5  =  0000...000101
               ⇒ 1          ;      =  0000...000001
          (ash 5 -2)
               ⇒ 1
          (lsh -5 -2)        ;  -5  =  1111...111011
               ⇒ 268435454
                             ;      =  0011...111110
          (ash -5 -2)        ;  -5  =  1111...111011
               ⇒ -2         ;      =  1111...111110

 -- Function: logand &rest ints-or-markers
     この関数は、引数の“論理積(logical and)”をreturnします。すべての引数
     のN番目のビットがセットされている場合に限り、結果のN番目のビットが
     セットされます(“セット”とは、そのビットの値が0ではなく1であることを
     意味します)。

     たとえば、13と12の“論理積”は — 4ビット2進数を使用すると1101と1100の
     論理積は1100を生成します。この2進数では両方とも、左の2ビットがセッ
     ト(つまり1)されているので、returnされる値の左2ビットがセットされま
     す。しかし右の2ビットにたいしては、少なくとも1つの引数でそのビット
     が0なので、returnされる値の右2ビットは0になります。

     したがって、

          (logand 13 12)
               ⇒ 12

     ‘logand’に何の引数も綿さない場合は、値−1がreturnされます。−1を2進数
     で表すとすべてのビットが1なので、−1は‘logand’にたいする単位元
     (identity element)です。

                             ;        30ビット2進数

          (logand 14 13)     ; 14  =  0000...001110
                             ; 13  =  0000...001101
               ⇒ 12         ; 12  =  0000...001100

          (logand 14 13 4)   ; 14  =  0000...001110
                             ; 13  =  0000...001101
                             ;  4  =  0000...000100
               ⇒ 4          ;  4  =  0000...000100

          (logand)
               ⇒ -1         ; -1  =  1111...111111

 -- Function: logior &rest ints-or-markers
     この関数は、引数の“論理和(inclusive or)”をreturnします。少なくとも
     1つの引数でN番目のビットがセットされていれば、結果のN番目のビットが
     セットされます。引数を与えない場合の結果は、この処理にたいする単位
     元である0です。‘logior’に渡す引数が1つだけの場合、その引数が
     returnされます。

                             ;        30ビット2進数

          (logior 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 13         ; 13  =  0000...001101

          (logior 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 15         ; 15  =  0000...001111

 -- Function: logxor &rest ints-or-markers
     この関数は、引数の“排他的論理和(exclusive or)”をreturnします。N番目
     のビットがセットされている引数の数が奇数個の場合だけ、結果のN番目の
     ビットがセットされます。引数を与えない場合の結果は、この処理の単位
     元である0となります。‘logxor’に渡す引数が1つだけの場合、その引数が
     returnされます。

                             ;        30ビット2進数

          (logxor 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 9          ;  9  =  0000...001001

          (logxor 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 14         ; 14  =  0000...001110

 -- Function: lognot integer
     この関数は引数の論理的な補数(logical complement)をreturnします。
     INTEGERのN番目のビットが0の場合に限り、結果のN番目のビットが1になり
     ます。逆も成り立ちます。

          (lognot 5)
               ⇒ -6
          ;;  5  =  0000...000101 (全部で30ビット)
          ;; becomes
          ;; -6  =  1111...111010 (全部で30ビット)


File: elisp,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

3.9 Standard Mathematical Functions
===================================

これらの数学的関数は、引き数として整数と同様に浮動小数点数も許容します。

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     これらは三角関数です、引数ARGはラジアン単位です。

 -- Function: asin arg
     ‘(asin ARG)’の値は、sinの値がARGとなるような −pi/2 から pi/2 (境界
     値を含む)の数です。ARGが範囲外([−1, 1]の外)の場合、‘asin’はNaNを
     returnします。

 -- Function: acos arg
     ‘(acos ARG)’の値は、cosの値がARGとなるような、0から pi (境界値を含
     む)の数です。argが範囲外([-1, 1]の外)の場合、‘acos’はNaNをreturnし
     ます。

 -- Function: atan y &optional x
     ‘(atan Y)’の値は、tanの値がYとなるような、 −pi/2 から pi/2 (境界値
     を含まない)の数です。オプションの第2引数Xが与えられた場合、‘(atan y
     x)’の値はベクトル‘[X, Y]’と‘X’軸が成す角度のラジアン値です。

 -- Function: exp arg
     これは指数関数です。この関数はeの指数ARGをreturnします。

 -- Function: log arg &optional base
     この関数は底をBASEとするARGの対数をreturnします。BASEを指定しない場
     合、自然底(natural base)eが使用されます。ARGまたhBASEが負の場合、
     ‘log’はNaNをreturnします。

 -- Function: expt x y
     この関数はXにYを乗じてreturnします。引数が両方とも整数で、Yが正の場
     合、結果は整数になります。この場合オーバーフローによる切り捨てが発
     生するので、注意してください。Xが有限の負数で、Yが有限の非整数の場
     合、‘expt’はNaNをreturnします。

 -- Function: sqrt arg
     これはARGの平方根をreturnします。ARGが有限で0より小さい場合、
     ‘sqrt’はNaNをreturnします。

   加えて、Emacsは以下の数学的な定数を定義します:

 -- Variable: float-e
     自然対数e(2.71828...)。

 -- Variable: float-pi
     円周率pi(3.14159...)。


File: elisp,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

3.10 Random Numbers
===================

決定論的なコンピュータープログラムでは、真の乱数を生成することはできませ
ん。しかしほとんどの目的には、“疑似乱数(pseudo-random numbers)”で充分で
す。一連の疑似乱数は、決定論的な手法により生成されます。真の乱数ではあり
ませんが、それらにはランダム列を模する特別な性質があります。たとえば疑似
ランダム系では、すべての可能な値は、均等に発生します。

   疑似乱数は“シード(seed: 種)”から生成されます。与えられた任意のシード
から開始することにより、‘random’関数は常に同じ数列を生成します。デフォル
トでは、Emacsは開始時に乱数シードを初期化することにより、それぞれの
Emacsの実行において、‘random’の値シーケンスは(ほとんど確実に)異なります
。

   再現可能な乱数シーケンスが欲しい場合もあります。たとえば乱数シーケン
スに依存するプログラムをデバッグする場合、プログラムの各実行において同じ
挙動を得ることが助けになります。再現可能なシーケンスを作成するには、
‘(random "")’を実行します。これは特定のEmacsの実行可能ファイルにたいして
、シードに定数値をセットします(しかし、この実行可能ファイルは、その他の
Emacsビルドと異なるものになるでしょう)。シード値として、他のさまざまな文
字列を使用することができます。

 -- Function: random &optional limit
     この関数は疑似乱数の整数をreturnします。繰り返し呼び出すと、一連の
     疑似乱数の整数をreturnします。

     LIMITが正の整数の場合、値は負ではないLIMIT未満の値から選択されます
     。それ以外では、値は‘most-negative-fixnum’から
     ‘most-positive-fixnum’の間の、Lispで表現可能な任意の整数(*note
     Integer Basics::を参照してください)になるでしょう。

     LIMITが‘t’の場合は、Emacsを再起動したときに、新しいシードを選択する
     ことを意味します。

     LIMITが文字列の場合、その文字列定数にもとづいた新しいシードを選択す
     ることを意味します。


File: elisp,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

4 Strings and Characters
************************

Emacs Lispの文字列は、文字列の順序列(ordered sequence)を含む配列です。文
字列はシンボル、バッファー、ファイルの名前に使用されます。その他にも、ユ
ーザーにたいしてメッセージを送ったりバッファー間でコピーする文字列を保持
したり等の、他の多くの目的にたいして使用されます。文字列は特に重要なので
、Emacs Lispは特別に文字列を操作するための、多くの関数をもちます。Emacs
Lispプログラムは、個々の文字より、文字列を多用します。

   キーボードの文字イベントの文字列にたいする特別な考慮は、*note Strings
of Events::を参照してください。

* Menu:

* Basics: String Basics.     文字列と文字の基本的なプロパティー。
* Predicates for Strings::   オブジェクトが文字列か文字化をテストする。
* Creating Strings::         新しい文字列を割り当てる関数。
* Modifying Strings::        既存の文字列の内容を変更する。
* Text Comparison::          文字または文字列を比較する。
* String Conversion::        文字から文字列、文字から文字列への変換。
* Formatting Strings::       ‘format’:
                               ‘printf’のEmacsバージョン。
* Case Conversion::          大文字小文字変換関数。
* Case Tables::              大文字小文字変換のカスタマイズ。


File: elisp,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

4.1 String and Character Basics
===============================

文字(character)とは、テキスト内の1つの文字を表すLispオブジェクトです。
Emacs Lispでは、文字は単なる整数です。ある整数が文字か文字でないかを区別
するのは、それが使用される方法だけです。Emacsでの文字表現についての詳細
は、*note Character Codes::を参照してください。

   文字列(string)とは、固定された文字シーケンスです。これは“配列
(array)”と呼ばれるシーケンス型で、配列長が固定で、1度作成したら変更でき
ないことを意味します(*note Sequences Arrays Vectors::を参照してください
)。Cとは異なり、Emacs Lispの文字列は文字コードを判断することにより終端
_されません_。

   文字列は配列であり、したがって同様にシーケンスでもあるので、*note
Sequences Arrays Vectors::にドキュメントされている一般的な配列関数やシー
ケンス関数で、文字列を処理できます。たとえば、文字列内の特定の文字にアク
セスしたり変更することができますしかし表示された文字列の幅を計算するため
に、‘length’を使用するべきでは_ない_ことに注意してください。かわりに
‘string-width’を使用してください(*note Size of Displayed Text::を参照し
てください)。

   Emacs文字列での非ASCIIにたいすテキスト表現は2つ — ユニバイト
(unibyte)とマルチバイト(multibyte)がありますほとんどのLispプログラミング
では、これら2つの表現を気にする必要はありません。詳細は、*note Text
Representations::を参照してください。

   キーシーケンスがユニバイト文字列で表されることがあります。ユニバイト
文字列がキーシーケンスの場合、範囲128から255までの文字列要素は、範囲
128から255の文字コードではなく、メタ文字(これは非常に大きな整数です)を表
します。文字列はhyper、super、altで修飾された文字を保持できません。文字
列はASCIIコントロール文字を保持できますが、それは他のコントロール文字で
す。文字列はASCIIコントロール文字の大文字小文字を区別できません。そのよ
うな文字をシーケンスに保存したい場合は、文字列ではなくベクターを使用しな
ければなりません。キーボード入力文字についての情報は、*note Character
Type::を参照してください。

   文字列は正規表現を保持するために便利です。‘string-match’ (*note
Regexp Search::を参照してください)を使用して、文字列にたいして正規表現を
マッチすることもできます。関数‘match-string’ (*note Simple Match Data::を
参照してください)と、‘replace-match’ (*note Replacing Match::)は、文字列
にたいして正規表現をマッチした後に、文字列を分解、変更するのに便利です。

   バッファーのように、文字列は文字列内の文字自身と、その文字にたいする
テキストプロパティーを含みます。*note Text Properties::を参照してくださ
い。文字列からバッファーや他の文字列にテキストをコピーする、すべての
Lispプリミティブ(Lisp primitives)は、コピーされる文字のプロパティーもコ
ピーします。

   文字列を表示したり、バッファーにコピーする関数についての情報は、*note
Text::を参照してください。文字または文字列の構文についての情報は、*note
Character Type::と*note String Type::を参照してください。異なるテキスト
表現間で変換したり、文字コードをエンコード、デコードする関数については、
*note Non-ASCII Characters::を参照してください。


File: elisp,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

4.2 Predicates for Strings
==========================

一般的なシーケンスや配列にたいする述語についての情報は、*note Sequences
Arrays Vectors::、および*note Arrays::を参照してください。

 -- Function: stringp object
     この関数はOBJECTが文字列の場合は‘t’、それ以外は‘nil’をreturnします
     。

 -- Function: string-or-null-p object
     この関数は、OBJECTが文字列または‘nil’の場合は‘t’、それ以外は‘nil’を
     returnします。

 -- Function: char-or-string-p object
     この関数は、OBJECTが文字列または文字(たとえば整数)の場合は‘t’、それ
     以外は‘nil’をreturnします。


File: elisp,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

4.3 Creating Strings
====================

以下の関数は、新たに文字列を作成したり、文字列同士を結合して文字列を作成
したり、文字列の一部から文字列を作成する関数です。

 -- Function: make-string count character
     この関数は、CHARACTERをCOUNT回繰り返すことにより作成された文字列を
     returnします。COUNTが負の場合は、エラーをシグナルします。

          (make-string 5 ?x)
               ⇒ "xxxxx"
          (make-string 0 ?x)
               ⇒ ""

     この関数に対応する他の関数には‘make-vector’ (*note Vectors::を参照
     してください)、および‘make-list’ (*note Building Lists::を参照して
     ください)が含まれます。

 -- Function: string &rest characters
     この関数は、文字CHARACTERSを含む文字列をreturnします。

          (string ?a ?b ?c)
               ⇒ "abc"

 -- Function: substring string start &optional end
     この関数は、STRINGから、インデックスSTARTの文字(その文字を含む)から
     、ENDまでの文字(その文字は含まない)の範囲の文字から構成される、新し
     い文字列をreturnします。文字列の最初の文字がインデックス0になります
     。

          (substring "abcdefg" 0 3)
               ⇒ "abc"

     上記の例では、‘a’のインデックスは0、‘b’のインデックスは1、‘c’のイン
     デックスは2です。インデックス3 — この文字列の4番目の文字 — は、部分
     文字列がコピーされる文字位置までをマークします。したがって文字列
     ‘"abcdefg"’から、‘abc’がコピーされます。

     負のかすは、文字列の最後から数えることを意味するので、−1は文字列の
     最後の文字のインデックスです。たとえば:

          (substring "abcdefg" -3 -1)
               ⇒ "ef"

     この例では、‘e’のインデックスは−3、‘f’のインデックスは−2、‘g’のイン
     デックスは−1です。したがって、‘e’と‘f’が含まれ、‘g’は含まれません。

     ENDに‘nil’が使用された場合、それは文字列の長さを意味します。したが
     って、

          (substring "abcdefg" -3 nil)
               ⇒ "efg"

     引数ENDを省略した場合、それは‘nil’を指定したのと同じです。
     ‘(substring STRING 0)’は、STRINGのすべてをコピーしてreturnします。

          (substring "abcdefg" 0)
               ⇒ "abcdefg"

     しかし、この目的のためには‘copy-sequence’を推奨します(*note
     Sequence Functions::)。

     STRINGからコピーされた文字がテキストプロパティーをもつ場合、そのプ
     ロパティーは新しい文字列へもコピーされます。*note Text
     Properties::を参照してください。

     ‘substring’の最初の引数にはベクターも指定できます。たとえば:

          (substring [a b (c) "d"] 1 3)
               ⇒ [b (c)]

     STARTが整数でない場合、またはENDが整数でも‘nil’でもない場合は、
     ‘wrong-type-argument’エラーがシグナルされます。STARTがENDの後の文字
     を指す場合、またはSTRINGにたいして範囲外の整数をどちらかに指定した
     場合は、‘args-out-of-range’エラーがシグナルされます。

     この関数に対応するのは‘buffer-substring’ (*note Buffer Contents::を
     参照してください)で、これはカレントバッファー内のテキストの一部を含
     む文字列をreturnします。文字列の先頭はインデックス0ですが、バッファ
     ーの先頭はインデックス1です。

 -- Function: substring-no-properties string &optional start end
     これは‘substring’と同じようにL機能しますが、値からすべてのテキスト
     プロパティーを破棄します。STARTを省略したり、‘nil’を指定することが
     でき、この場合0に等しくなります。したがって
     ‘(substring-no-properties STRING)’は、すべてのテキストプロパティー
     が削除されたSTRINGのコピーをreturnします。

 -- Function: concat &rest sequences
     この関数は、渡された引数内の文字からなる、新しい文字列をreturnしま
     す(もしあればテキストプロパティーも)。引数には文字列、数のリスト、
     数のベクターを指定できます。引数は変更されません。‘concat’に引数を
     指定しない場合、空文字列をreturnします。

          (concat "abc" "-def")
               ⇒ "abc-def"
          (concat "abc" (list 120 121) [122])
               ⇒ "abcxyz"
          ;; ‘nil’hあ空のシーケンス。
          (concat "abc" nil "-def")
               ⇒ "abc-def"
          (concat "The " "quick brown " "fox.")
               ⇒ "The quick brown fox."
          (concat)
               ⇒ ""

     この関数は常に、任意の既存の文字列にたいして‘eq’ではない、新しい文
     字列を構築しますが、結果が空文字列の時は例外です(スペースを省くため
     に、Emacsは空のマルチバイト文字列を1つだけ作成します)。

     他の結合関数(concatenation functions)についての情報は、*note
     Mapping Functions::の‘mapconcat’、*note Vector Functions::の
     ‘vconcat’、*note Building Lists::の‘append’を参照してください。シェ
     ルコマンドで使用される文字列の中に、個々のコマンドライン引数を結合
     するには、*note combine-and-quote-strings: Shell Arguments.を参照し
     てください。

 -- Function: split-string string &optional separators omit-nulls trim
     この関数は、正規表現SEPARATORS(*note Regular Expressions::を参照し
     てください)にもとづいて、STRINGを部分文字列に分解します。
     SEPARATORSにたいする各マッチは、分割位置を定義します。分割位置の間
     にある部分文字列を、リストにまとめてreturnします。

     OMIT-NULLSが‘nil’(または省略)の場合、連続する2つのSEPARATORSへのマ
     ッチ、またはSTRINGの最初か最後にマッチしたときの空文字列が結果に含
     まれます。OMIT-NULLSが‘t’の場合、これらの空文字列は結果から除外され
     ます。

     SEPARATORSが‘nil’(または省略)の場合、デフォルトは
     ‘split-string-default-separators’の値になります。

     特別なケースとして、SEPARATORSが‘nil’(または省略)の場合、常に結果か
     ら空文字列が除外されます。したがって:

          (split-string "  two words ")
               ⇒ ("two" "words")

     結果は、ほとんど有用ではないであろう‘("" "two" "words" "")’という結
     果ではありません。このような結果が必要な時は、SEPARATORSに明示的な
     値を使用します:

          (split-string "  two words "
                        split-string-default-separators)
               ⇒ ("" "two" "words" "")

     他にも例を示します:

          (split-string "Soup is good food" "o")
               ⇒ ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o" t)
               ⇒ ("S" "up is g" "d f" "d")
          (split-string "Soup is good food" "o+")
               ⇒ ("S" "up is g" "d f" "d")

     空のマッチはカウントされます。例外は、空でないマッチを使用すること
     により、すでに文字列の最後に到達しているとき、またはSTRINGが空の時
     で、この場合‘split-string’は最後の空マッチを探しません。

          (split-string "aooob" "o*")
               ⇒ ("" "a" "" "b" "")
          (split-string "ooaboo" "o*")
               ⇒ ("" "" "a" "b" "")
          (split-string "" "")
               ⇒ ("")

     しかし、SEPARATORSが空文字列にマッチできるとき、通常はOMIT-NULLSは
     ‘t’にすれば、前の3つの例の不明瞭さは、ほとんど発生しません:

          (split-string "Soup is good food" "o*" t)
               ⇒ ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "" t)
               ⇒ ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
          (split-string "" "" t)
               ⇒ nil

     空でないマッチより空のマッチを優先するような、一部の“非貪欲
     (non-greedy)”な値をSEPARATORSに指定することにより、幾分奇妙(しかし
     予見可能)な振る舞いが発生する場合があります。繰り返しますが、そのよ
     うな値は実際にはまれです:

          (split-string "ooo" "o*" t)
               ⇒ nil
          (split-string "ooo" "\\|o+" t)
               ⇒ ("o" "o" "o")

     オプションの引数TRIMが非‘nil’の場合、その値は各部分文字列の最初と最
     後からトリムするテキストにマッチする正規表現を指定します。トリムに
     より、その部分文字列が空になるような場合、それは空文字列として扱わ
     れます。

     文字列を分割して、‘call-process’や‘start-process’に適した、個々のコ
     マンドライン引数のリストにする必要がある場合は、*note
     split-string-and-unquote: Shell Arguments.を参照してください。

 -- Variable: split-string-default-separators
     ‘split-string’のSEPARATORSにたいするデフォルト値です。通常の値は、
     ‘"[ \f\t\n\r\v]+"’です。


File: elisp,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

4.4 Modifying Strings
=====================

既存の文字列の内容を変更するもっとも基本的な方法は、‘aset’ (*note Array
Functions::)を使用する方法です。‘(aset STRING IDX CHAR)’は、STRINGのイン
デックスIDXに、CHARを格納します。それぞれの文字は１文字以上を占有します
が、すでにインデックスの場所にある文字のバイト数が、CHARが要するバイト数
と異なる場合、‘aset’はエラーをシグナルします。

   より強力な関数は‘store-substring’です:

 -- Function: store-substring string idx obj
     この関数は、インデックスIDXで開始される位置にOBJを格納することによ
     り、文字列STRINGの内容の一部を変更します。OBJは文字、または
     (STRINGより小さい)文字列です。

     既存の文字列の長さを変更するのは不可能なので、STRINGの実際の長さに
     OBJが収まらない場合、またはSTRINGのその位置に現在ある文字のバイト数
     が、新しい文字に必要なバイト数と異なる場合はエラーになります。

   パスワードを含む文字列をクリアーするときは、‘clear-string’を使用しま
す:

 -- Function: clear-string string
     これはSTRINGをユニバイト文字列として、内容を0にクリアーします。これ
     によりSTRINGの長さも変更されるでしょう。


File: elisp,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

4.5 Comparison of Characters and Strings
========================================

 -- Function: char-equal character1 character2
     この関数は引数が同じ文字を表す場合は‘t’、それ以外は‘nil’をreturnし
     ます。‘case-fold-search’が非‘nil’の場合、この関数は大文字小文字の違
     いを無視します。

          (char-equal ?x ?x)
               ⇒ t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               ⇒ nil

 -- Function: string= string1 string2
     この関数は、2つの文字列の文字が正確にマッチする場合は、‘t’を
     returnします。引数にシンボルを指定することもでき、この場合はシンボ
     ル名が使用されます。‘case-fold-search’とは無関係に、大文字小文字は
     常に意味をもちます。

     この関数は、‘equal’で2つの文字列を比較するのと等価です(*note
     Equality Predicates::を参照してください)。特に、2つの文字列のテキス
     トプロパティーは無視されます。テキストプロパティーだけが異なる文字
     列を区別する必要がある場合は、‘equal-including-properties’を使用し
     ます。しかし‘equal’とは異なり、どちらかの引数が文字列でもシンボルで
     もない場合、‘string=’はエラーをシグナルします。

          (string= "abc" "abc")
               ⇒ t
          (string= "abc" "ABC")
               ⇒ nil
          (string= "ab" "ABC")
               ⇒ nil

     技術的な理由により、ユニバイト文字列とマルチバイト文字列が‘equal’な
     のは、それらが同じ文字コードのシーケンスを含み、それらすべてのコー
     ドが0から127(ASCII)か、160から255(‘eight-bit-graphic’)のときだけで
     す。しかしユニバイト文字列をマルチバイト文字列に変更する際、コード
     が160から255の範囲にあるすべての文字はより高いコードに変換され、
     ASCII文字は変換されないまま残ります。したがってユニバイト文字列と、
     それを変換したマルチバイト文字列は、その文字列のすべてがASCIIのとき
     だけ‘equal’です。マルチバイト文字列中で、もし文字コード160から255の
     文字があったとしても、それは完全に正しいとは言えません。結果として
     、すべてがASCIIではないユニバイト文字列とマルチバイト文字列が
     ‘equal’であるという状況は、もしかしたらEmacs Lispプロプラマーが直面
     するかもしれない、とても希少な偽術的に不可解な状況だといえます。
     *note Text Representations::を参照してください。

 -- Function: string-equal string1 string2
     ‘string-equal’は‘string=’に対する別名です。

 -- Function: string< string1 string2
     この関数は、2つの文字列を1文字づつ比較します。この関数は、同時に2つ
     の文字列をスキャンして、対応する文字同士がマッチしない最初のペアを
     探します。2つの文字列内で、小さいほうの文字がSTRING1の文字の場合、
     STRING1が小さいことになり、この関数は‘t’をreturnします。小さいほう
     の文字がSTRING2の文字の場合、STRING1が大きいことになり、この関数は
     ‘nil’をreturnします。2つの文字列が完全にマッチした場合、値は‘nil’に
     なります。

     文字のペアは、文字コードで比較されます。ASCII文字セットでは、小文字
     英字は大文字英字より、高い数値をもつことに留意してください。数字お
     よび多くの句読点文字は、大文字英字より低い数値をもちます。ASCII文字
     は、任意の非ASCII文字より小さくなります。ユニバイト非ASCII文字は、
     任意のマルチバイト非ASCII文字より、常に小さくなります(*note Text
     Representations::を参照してください)。

          (string< "abc" "abd")
               ⇒ t
          (string< "abd" "abc")
               ⇒ nil
          (string< "123" "abc")
               ⇒ t

     文字列の長さが異なり、STRING1の長さまでマッチする場合、結果は‘t’に
     なります。STRING2の長さまでマッチする場合、結果は‘nil’になります。
     文字を含まない文字列は、他の任意の文字列より小さくなります。

          (string< "" "abc")
               ⇒ t
          (string< "ab" "abc")
               ⇒ t
          (string< "abc" "")
               ⇒ nil
          (string< "abc" "ab")
               ⇒ nil
          (string< "" "")
               ⇒ nil

     引数としてシンボルを指定することもでき、この場合はシンボルのプリン
     ト名が使用されます。

 -- Function: string-lessp string1 string2
     ‘string-lessp’は‘string<’にたいする別名です。

 -- Function: string-prefix-p string1 string2 &optional ignore-case
     この関数は、STRING1がSTRING2のプレフィクス(接頭辞)の場合(たとえば
     STRING2がSTRING1で始まる場合)、非‘nil’をreturnします。オプションの
     引数IGNORE-CASEが非‘nil’の場合、比較において大文字小文字の違いは無
     視されます。

 -- Function: string-suffix-p suffix string &optional ignore-case
     この関数は、SUFFIXがSTRINGのサフィックス(接尾辞)の場合(たとえば
     STRINGがSUFFIXで終わる場合)、非‘nil’をreturnします。オプションの引
     数IGNORE-CASEが非‘nil’の場合、比較において大文字小文字の違いは無視
     されます。

 -- Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     この関数は、STRING1の指定された部分を、STRING2の指定された部分と比
     較します。STRING1の指定された部分とは、インデックスSTART1(その文字
     を含む)から、インデックスEND1(その文字を含まない)までです。START1に
     ‘nil’を指定すると文字列の最初という意味になり、END1に‘nil’を指定す
     ると文字列の長さを意味します同様に、STRING2の指定された部分とは、イ
     ンデックスSTART2からインデックスEND2までです。

     文字列は、文字列内の文字の数値により比較されます。たとえば、STR1と
     STR2は、最初に異なる文字でSTR1の文字の数値が小さいときに、“小さい
     ”と判断されます。IGNORE-CASEが非‘nil’の場合、文字は比較を行なう前に
     小文字に変換されます。比較のためにユニバイト文字列はマルチバイト文
     字列に変換されるので(*note Text Representations::を参照してください
     )、ユニバイト文字列と、それを変換したマルチバイト文字列は、常に等し
     くなります。

     2つの文字列の指定された部分がマッチした場合、値は‘t’になります。そ
     れ以外では、値は整数で、これは何文字が一致して、どちらの文字が小さ
     いかを示します。この値の絶対値は、2つの文字列の先頭から一致した文字
     数に1加えた値になります。STRING1(または指定された部分)のほうが小さ
     い場合、符号は負になります。

 -- Function: assoc-string key alist &optional case-fold
     この関数は‘assoc’と同様に機能しますが、KEYは文字列かシンボルでなけ
     ればならず、比較は‘compare-strings’を使用して行なわれます。テストす
     る前にシンボルは文字列に変換されます。CASE-FOLDが非‘nil’の場合、大
     文字小文字の違いは無視されます。‘assoc’とは異なり、この関数はコンス
     ではない文字列またはシンボルのalist要素もマッチできます。特に、
     ALISTは実際のalistではなく、文字列またはリストでも可能です。*note
     Association Lists::を参照してください。

   バッファー内のテキストを比較する方法として、*note Comparing Text::の
関数‘compare-buffer-substrings’も参照してください。文字列にたいして正規
表現のマッチを行なう関数‘string-match’も、ある種の文字列比較に使用するこ
とができます。*note Regexp Search::を参照してください。


File: elisp,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

4.6 Conversion of Characters and Strings
========================================

このセクションでは文字、文字列、整数の間で変換を行なう関数を説明します。
‘format’ (*note Formatting Strings::を参照してください)、および
‘prin1-to-string’ (*note Output Functions::を参照してください)も、Lispオ
ブジェクトを文字列に変換できます。‘read-from-string’ (*note Input
Functions::を参照してください)は、Lispオブジェクトの文字列表現を、オブジ
ェクトに“変換”できます。関数‘string-to-multibyte’および
‘string-to-unibyte’は、テキスト表現を文字列に変換します(*note Converting
Representations::を参照してください)。

   テキスト文字と一般的なインプットイベントにたいするテキスト説明を生成
する関数(‘single-key-description’および‘text-char-description’)について
は、*note Documentation::を参照してください。これらの関数は主にヘルプメ
ッセージを作成するために使用されます。

 -- Function: number-to-string number
     この関数はNUMBERの10進プリント表現からなる文字列をreturnします。引
     数が負の場合、return値はマイナス記号から開始されます。

          (number-to-string 256)
               ⇒ "256"
          (number-to-string -23)
               ⇒ "-23"
          (number-to-string -23.5)
               ⇒ "-23.5"

     ‘int-to-string’は、この関数にたいする半ば廃れた(semi-obsolete)エイ
     リアスです。

     *note Formatting Strings::の関数‘format’も参照してください。

 -- Function: string-to-number string &optional base
     この関数はSTRING内の文字の数値的な値をreturnします。BASEが非‘nil’の
     場合、値は2以上16以下でなければならず、整数はその基数に変換されます
     。BASEが‘nil’の場合、基数に10が使用されます。浮動少数の変換は基数が
     10のときだけ機能します。わたしたちは浮動小数点数にたいして他の基数
     を実装していません。なえならこれには多くの作業が必要で、その割にそ
     の機能が有用には思えないからです。STRINGが整数のように見えるが、そ
     の値がLispの整数に収まらないほど大きな値の場合、
     ‘string-to-number’は浮動小数の結果をreturnします。

     解析ではSTRINGの先頭にあるスペースとタブはスキップして、それから与
     えられた基数で数字として解釈できるところまでSTRINGを読み取ります(ス
     ペースとタブだけではなく、先頭にある他の空白文字を無視するシステム
     もあります)。STRINGを数字として解釈できない場合、この関数は0を
     returnします。

          (string-to-number "256")
               ⇒ 256
          (string-to-number "25 is a perfect square.")
               ⇒ 25
          (string-to-number "X256")
               ⇒ 0
          (string-to-number "-4.5")
               ⇒ -4.5
          (string-to-number "1e5")
               ⇒ 100000.0

     ‘string-to-int’は、この関数にたいする半ば廃れたエイリアスです。

 -- Function: char-to-string character
     この関数は、1つの文字CHARACTERを含む新しい文字列をreturnします。関
     数‘string’のほうがより一般的なので、この関数は半ば廃れています。
     *note Creating Strings::を参照してください。

 -- Function: string-to-char string
     この関数は、STRINGの最初の文字をreturnします。これはほとんど‘(aref
     string 0)’と同じで、例外は文字列が空のときに0をreturnすることです
     (文字列の最初の文字がASCIIコード0のヌル文字のときも、0をreturnしま
     す)。この関数は、残すのに充分なほど有用と思えない場合、将来削除され
     るかもしれません。

   以下は、文字列へ／からの変換に使用できる、その他の関数です:

‘concat’
     この関数はベクターまたはリストから文字列に変換します。*note
     Creating Strings::を参照してください。

‘vconcat’
     この関数は文字列をベクターに変換します。*note Vector Functions::を
     参照してください。

‘append’
     この関数は文字列をリストに変換します。*note Building Lists::を参照
     してください。

‘byte-to-string’
     この関数は文字データのバイトをユニバイト文字列に変換します。*note
     Converting Representations::を参照してください。


File: elisp,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

4.7 Formatting Strings
======================

“フォーマット(formatting)”とは、定数文字列内のなまざまな場所を、計算され
た値で置き換えることにより、文字列を構築することを意味します。この定数文
字列は、他の値がプリントされる方法、同様にどこに表示するかを制御します。
これは“フォーマット文字列(format string)”と呼ばれます。

   フォーマットは、表示されるメッセージを計算するために便利なことがしば
しばあります。実際に、関数‘message’および‘error’は、ここで説明する機能と
同じフォーマットを提供します。これらの関数と‘format’の違いは、フォーマッ
トされた結果を使用する方法だけです。

 -- Function: format string &rest objects
     この関数は、STRINGをコピーしてから、対応するOBJECTSをエンコードする
     、コピー内の任意のフォーマット指定(format specification)を置換する
     ことにより作成される、新しい文字列をreturnします。引数OBJECTSは、フ
     ォーマットされる計算された値です。

     STRING内のフォーマット指定以外の文字は、(もしあれば)テキストプロパ
     ティーを含め、出力に直接コピーされます。

   フォーマット指定は、‘%’で始まる文字シーケンスです。したがってSTRING内
に‘%d’があれば、‘format’はそれを、フォーマットされる値の1つ(引数
OBJECTSのうちの1つ)にたいするプリント表現で置き換えます。たとえば:

     (format "The value of fill-column is %d." fill-column)
          ⇒ "The value of fill-column is 72."

   ‘format’は文字‘%’をフォーマット指定と解釈するので、_決して_最初の引数
に不定な文字列(arbitrary string)を渡すべきではありません。これは特に何ら
かのLispコードにより生成された文字列の場合に当てはまります。その文字列が
決して文字‘%’を含まないと_確信_できないときは、以下で説明するように最初
の引数に‘"%s"’を渡して、不定な文字列を2番目の引数として渡します:

       (format "%s" ARBITRARY-STRING)

   STRINGに複数のフォーマット指定が含まれる場合、フォーマット指定は
OBJECTSから連続して値を引き当てます。つまり、STRING内の1番目のフォーマッ
ト指定は1番目の値、2番目のフォーマット指定は2番目の値、...を使用します。
余分なフォーマット指定(対応する値がない場合)は、エラーとなります。フォー
マットされる値が余分にある場合は、無視されます。

   ある種のフォーマット指定は、特定の型の値を要求します。その要求に適合
しない値を与えた場合、エラーがシグナルされます。

   以下は有効なフォーマット指定の表です:

‘%s’
     フォーマット指定を、クォートなし(つまり‘prin1’ではなく‘princ’を使用
     して。*note Output Functions::を参照してください)の、オブジェクトの
     プリント表現で置き換えます。したがって、文字列は‘"’文字なしの、文字
     列内容だけが表示され、シンボルは‘\’文字なしで表されます。

     オブジェクトが文字列の場合、文字列のプロパティーは出力にコピーされ
     ます。‘%s’のテキストプロパティー自身もコピーされますが、オブジェク
     トのテキストプロパティーが優先されます。

‘%S’
     フォーマット指定を、クォートあり(つまり‘prin1’を使用して。*note
     Output Functions::を参照してください)の、オブジェクトのプリント表現
     で置き換えます。したがって、文字列は‘"’文字で囲まれ、必要となる特別
     文字の前に‘\’文字が表示されます。

‘%o’
     フォーマット指定を8進表現の整数で置き換えます。

‘%d’
     フォーマット指定を10進表現の整数で置き換えます。

‘%x’
‘%X’
     フォーマット指定を16進表現の整数で置き換えます。‘%x’の場合は小文字
     、‘%X’の場合は大文字が使用されます。

‘%c’
     フォーマット指定を、与えられた値の文字で置き換えます。

‘%e’
     フォーマット指定を、浮動小数点数の指数表現で置き換えます。

‘%f’
     フォーマット指定を、浮動小数点数にたいする10進少数表記で置き換えま
     す。

‘%g’
     フォーマット指定を、指数または10進少数のどちらか短いほうの表記を使
     用した浮動小数点数で置き換えます。

‘%%’
     フォーマット指定を1つの‘%’で置き換えます。このフォーマット指定は、
     値を使用しません。たとえば、‘(format "%% %d" 30)’は‘"% 30"’を
     returnします。

   他のフォーマット文字は、‘Invalid format operation’エラーになります。

   以下にいくつかの例を示します:

     (format "The name of this buffer is %s." (buffer-name))
          ⇒ "The name of this buffer is strings.texi."

     (format "The buffer object prints as %s." (current-buffer))
          ⇒ "The buffer object prints as strings.texi."

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          ⇒ "The octal value of 18 is 22,
              and the hex value is 12."

   フォーマット指定は“フィールド幅(width)”をもつことができ、これは‘%’と
フォーマット指定文字(specification character)の間の10進の数字です。その
オブジェクトのプリント表現が、このフィールド幅より少ない文字で構成される
場合、‘format’はパディングしてフィールド幅に拡張します。フォーマット指定
‘%%’では、フィールド幅の指定は無視されます。シールド幅指定により行なわれ
るパディングは通常、左側にスペースを挿入します。

     (format "%5d is padded on the left with spaces" 123)
          ⇒ "  123 is padded on the left with spaces"

フィールド幅が小さすぎる場合でも、‘format’はオブジェクトのプリント表現を
切り詰めません。したがって、情報を失う危険を犯すことなく、フィールドの最
小幅を指定することができます。以下の2つの例では、‘%7s’は最小幅に7を指定
します。1番目の例では、‘%7s’に挿入される文字列は3文字だけなので、4つのブ
ランクスペースによりパディングされます。2番目の例では、文字列
‘"specification"’は13文字ですが、切り詰めはされません。

     (format "The word `%7s' has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word `    foo' has 3 letters in it."
     (format "The word `%7s' has %d letters in it."
             "specification" (length "specification"))
          ⇒ "The word `specification' has 13 letters in it."

   ‘%’の直後、オプションのフィールド幅指定の前に、“フラグ文字(flag
characters)”を置くこともできます。

   フラグ‘+’は、正数の前にプラス符号を挿入するので、数には常に符号がつき
ます。フラグとしてスペースを指定すると、正数の前に1つのスペースが挿入さ
れます(それ以外は、正数は最初の数字から開始されます)。これらのフラグは、
正数と負数が同じ列数を使用することを確実にするのに便利です。これらは
‘%d’、‘%e’、‘%f’、‘%g’以外では無視され、両方が指定された場合は、‘+’が優
先されます。

   フラグ‘#’は“代替形式(alternate form)”を指定し。これは使用するフォーマ
ットに依存します。‘%o’にたいしては、結果を‘0’で開始させます。‘%x’と
‘%X’にたいしては、結果のプレフィクスは‘0x’または‘0X’になります。‘%e’、
‘%f’、‘%g’にたいしては、‘#’フラグは、少数部が0のときも小数点が含まれるこ
とを意味します。

   フラグ‘0’は、スペースの代わりに文字‘0’でパディングします。このフラグ
は‘%s’、‘%S’、‘%c’のような、非数値のフォーマット指定文字では無視されます
。もれらのフォーマット指定文字で‘0’フラグを指定できますが、それでも_スペ
ース_でパディングされます。

   フラグ‘-’はフィールド幅指定により挿入されるパディングに作用し、もしパ
ディングがある場合、左側ではなく右側にパディングされます。‘-’と‘0’の両方
が指定された場合、‘0’フラグは無視されます。

     (format "%06d is padded on the left with zeros" 123)
          ⇒ "000123 is padded on the left with zeros"

     (format "%-6d is padded on the right" 123)
          ⇒ "123    is padded on the right"

     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word `foo    ' actually has 3 letters in it."

   すべてのフォーマット指定文字には、その文字の前(フィールド幅がある場合
は、その後)に、オプションで“精度(precision)”を指定できます。精度は小数点
‘.’と、その後に桁文字列(digit-string)を指定します。浮動少数のフォーマッ
ト指定(‘%e’、‘%f’、‘%g’)では、精度は表示する小数点以下の桁数を指定します
。0の場合は小数点も省略されます。‘%s’と‘%S’にたいしては、文字列を精度で
指定された幅に切り詰めます。したがって‘%.3s’では、OBJECTにたいするプリン
ト表現の最初の3文字だけが表示されます。他のフォーマット指定文字にたいし
ては、精度は効果がありません。


File: elisp,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

4.8 Case Conversion in Lisp
===========================

大文字小文字変換関数(character case functions)は、1つの文字または文字列
の内容の大文字小文字を変換します。関数は通常、アルファベット文字(英字
‘A’から‘Z’と‘a’から‘z’、同様に非ASCIIの英字)だけを変換し、それ以外の文字
は変換しません。大文字小文字テーブル(case table。*note Case Tables::を参
照してください)で指定することにより大文字小文字の変換に異なるマッピング
を指定できます。

   これらの関数は、引数として渡された文字列は変更しません。

   以下の例では文字‘X’と‘x’を使用し、これらのASCIIコードは88と120です。

 -- Function: downcase string-or-char
     この関数は、STRING-OR-CHAR(文字か文字列)を小文字に変換します。

     STRING-OR-CHARが文字列の場合、この関数は引数の大文字を小文字に変換
     した、新しい文字列をreturnします。STRING-OR-CHARが文字の場合、この
     関数は対応する小文字(正数)をreturnします。元の文字が小文字の場合、
     または英字でない場合、return値は元の文字と同じです。

          (downcase "The cat in the hat")
               ⇒ "the cat in the hat"

          (downcase ?X)
               ⇒ 120

 -- Function: upcase string-or-char
     この関数は、STRING-OR-CHAR(文字か文字列)を大文字に変換します。

     STRING-OR-CHARが文字列の場合、この関数は引数の小文字を大文字に変換
     した、新しい文字列をreturnします。STRING-OR-CHARが文字の場合、この
     関数は対応する大文字(正数)をreturnします。元の文字が大文字の場合、
     または英字でない場合、return値は元の文字と同じです。

          (upcase "The cat in the hat")
               ⇒ "THE CAT IN THE HAT"

          (upcase ?x)
               ⇒ 88

 -- Function: capitalize string-or-char
     この関数は文字列または文字をキャピタライズ(capitalize: 先頭が大文字
     で残りは小文字)します。この関数は、STRING-OR-CHARが文字列の場合、
     STRING-OR-CHARの各単語がキャピタライズされた新しいコピーをreturnし
     ます。これは各単語の最初の文字が大文字に変換され、残りは小文字に変
     換されることを意味します。

     単語の定義は、カレント構文テーブル(current syntax table)の単語構成
     構文クラス(word constituent syntax class)に割り当てられた、連続する
     文字の任意シーケンスです(*note Syntax Class Table::を参照してくださ
     い)。

     STRING-OR-CHARが文字の場合、この関数は‘upcase’と同じことを行ないま
     す。

          (capitalize "The cat in the hat")
               ⇒ "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               ⇒ "The 77th-Hatted Cat"

          (capitalize ?x)
               ⇒ 88

 -- Function: upcase-initials string-or-char
     この関数は、STRING-OR-CHARが文字列の場合、STRING-OR-CHARの中の単語
     の頭文字をキャピタライズし、頭文字以外の文字は変更しません。この関
     数は、STRING-OR-CHARの各単語の頭文字が大文字に変換された新しいコピ
     ーをreturnします。

     単語の定義は、カレント構文テーブル(current syntax table)の単語構成
     構文クラス(word constituent syntax class)に割り当てられた、連続する
     文字の任意シーケンスです(*note Syntax Class Table::を参照してくださ
     い)。

     ‘upcase-initials’の引数が文字の場合、‘upcase-initials’の結果は
     ‘upcase’と同じになります。

          (upcase-initials "The CAT in the hAt")
               ⇒ "The CAT In The HAt"

   文字列を比較する関数(大文字小文字の違いを無視するものや、オプションで
大文字小文字の違いを無視できるもの)については、*note Text Comparison::を
参照してください。


File: elisp,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

4.9 The Case Table
==================

特別な“大文字小文字テーブル(case table)”をインストールすることにより、大
文字小文字の変換をカスタマイズできます。大文字小文字テーブルは大文字と小
文字の間のマッピングを指定します。大文字小文字テーブルはLispオブジェクト
にたいする大文字小文字変換関数(前のセクションを参照してください)と、バッ
ファー内のテキストに適用される関数の両方に影響します。それぞれのバッファ
ーには大文字小文字テーブルがあります。新しいバッファーの大文字小文字テー
ブルを初期化するために使用される、標準の大文字小文字テーブル(standard
case table)もあります。

   大文字小文字テーブルは、サブタイプが‘case-table’の文字テーブル
(char-table。*note Char-Tables::を参照してください)です。この文字テーブ
ルは、それぞれの文字を対応する小文字にマップします。大文字小文字テーブル
は、関連するテーブルを保持する、3つの追加スロットをもちます:

UPCASE
     upcase(大文字)テーブルは、それぞれの文字を対応する大文字にマップし
     ます。
CANONICALIZE
     canonicalize(正準化)テーブルは、大文字小文字に関連する文字セットの
     すべてを、その文字セットの特別なメンバーにマップします。
EQUIVALENCES
     equivalence(同値)テーブルは、大の字小文字に関連した文字セットのそれ
     ぞれを、そのセットの次の文字にマップします。

   単純な例では、小文字へのマッピングを指定することだけが必要です。3つの
関連するテーブルは、このマッピングから自動的に計算されます。

   大文字と小文字が1対1で対応しない言語もいくつかあります。これらの言語
では、2つの異なる小文字が、同じ大文字にマップされます。このような場合、
大文字と小文字の両方にたいするマップを指定する必要があります。

   追加のCANONICALIZEテーブルは、それぞれの文字を、正準化された等価文字
にマップします。大文字小文字に関連する任意の2文字は、同じ正準等価文字
(canonical equivalent character)をもちます。たとえば‘a’と‘A’は大文字小文
字変換に関係があるので、これらの文字は同じ正準等価文字(両方の文字が‘a’、
または両方の文字が‘A’)をもつべきです。

   追加のEQUIVALENCESテーブルは、各等価クラスの文字(同じ正準等価文字をも
つ文字)を循環的にマップします(通常のASCIIでは、これは‘a’を‘A’に‘A’を
‘a’にマップし、他の等価文字セットにたいしても同様にマップします)。

   大文字小文字テーブルを構築する際は、CANONICALIZEに‘nil’を指定できます
。この場合、Emacsは大文字と小文字のマッピングで、このスロットを充填しま
す。EQUIVALENCESにたいして‘nil’を指定することもできます。この場合、
EmacsはCANONICALIZEから、このスロットを充填します。実際に使用される大文
字小文字テーブルでは、これらのコンポーネントは非‘nil’です。
CANONICALIZEを指定せずにEQUIVALENCESを指定しないでください。

   以下は大文字小文字テーブルに作用する関数です:

 -- Function: case-table-p object
     この述語は、OBJECTが有効な大文字小文字テーブルの場合は、非‘nil’を
     returnします。

 -- Function: set-standard-case-table table
     この関数は、TABLEを標準大文字小文字テーブルにして、これ以降に作成さ
     れる任意のバッファーにたいしてこのテーブルが使用されます。

 -- Function: standard-case-table
     これは標準大文字小文字テーブル(standard case table)をreturnします。

 -- Function: current-case-table
     この関数は、カレントバッファーの大文字小文字テーブルをreturnします
     。

 -- Function: set-case-table table
     これはカレントバッファーの大文字小文字テーブルを、TABLEにセットしま
     す。

 -- Macro: with-case-table table body...
     ‘with-case-table’マクロはカレント大文字小文字テーブルを保存してから
     、TABLEをカレント大文字小文字テーブルにセットし、その後にBODYフォー
     ムを評価してから、最後に大文字小文字テーブルをリストアします。
     return値は、BODYの最後のフォームの値です。‘throw’またはエラー(*note
     Nonlocal Exits::を参照してください)により異常終了した場合でも、大文
     字小文字テーブルはリストアされます。

   ASCII文字の大文字小文字変換を変更する言語環境(language environment)が
いくつかあります。たとえばTurkishの言語環境では、ASCII文字の‘I’にたいす
る小文字は、Turkishの“dotless i”です。これは、(ASCIIベースのネットワーク
プロトコル実装のような)ASCIIの通常の大文字小文字変換を要求するコードに干
渉する可能性があります。このような場合は、変数ASCII-CASE-TABLEにたいして
‘with-case-table’マクロを使用します。これにより、変更されていないASCII文
字セットの大文字小文字テーブルが保存されます。

 -- Variable: ascii-case-table
     ASCII文字セットにたいする大文字小文字テーブルです。すべての言語環境
     セッティングにおいて、これを変更するべきではありません。

   以下の3つの関数は、非ASCII文字セットを定義するパッケージにたいして便
利なサブルーチンです。これらはCASE-TABLEに指定された大文字小文字テーブル
を変更します。これは標準構文テーブルも変更します。*note Syntax Tables::を
参照してください。通常これらの関数は、標準大文字小文字テーブルを変更する
ために使用されます。

 -- Function: set-case-syntax-pair uc lc case-table
     この関数は、対応する文字のペア(一方は大文字、もう一方は小文字)を指
     定します。

 -- Function: set-case-syntax-delims l r case-table
     この関数は文字LとRを、大文字小文字不変区切り(case-invariant
     delimiter)mpマッチングペアにします。

 -- Function: set-case-syntax char syntax case-table
     この関数はCHARを、構文SYNTAXの、大文字小文字不変(case-invariant)と
     します。

 -- Command: describe-buffer-case-table
     このコマンドは、カレントバッファーの大文字小文字テーブルの内容にた
     いする説明を表示します。


File: elisp,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

5 Lists
*******

“リスト(list)”は0個以上の要素(任意のLispオブジェクト)のシーケンスを表し
ます。リストとベクターの重要な違いは、、2つ以上のリストが、構造の一部を
共有できることです。加えて、リスト全体をコピーすることなく、要素の挿入、
削除ができます。

* Menu:

* Cons Cells::               コンスセルからリストが作られる方法。
* List-related Predicates::  このオブジェクトはリストか?
                               2つのリストを比較する。
* List Elements::            リストの一部を抽出する。
* Building Lists::           リスト構造の作成。
* List Variables::           変数に保存されたリストにたいする変更。
* Modifying Lists::          既存のリストに新しい要素を保存する。
* Sets And Lists::           リストは有限な数学集合を表現できます。
* Association Lists::        リストは有限な関係またはマッピングを表現できます。
* Property Lists::           要素ペアのリスト


File: elisp,  Node: Cons Cells,  Next: List-related Predicates,  Up: Lists

5.1 Lists and Cons Cells
========================

Lispでのリストは基本データ型ではありません。リストは“コンスセル(cons
cells)”から構築されます(*note Cons Cell Type::を参照してください)。コン
スセルは、順序つきペアを表現するデータオブジェクトです。つまり、コンスセ
ルは2つのスロットをもち、それぞれのスロットはLispオブジェクトを“保持
(holds)”、または“参照(refers to)”します。1つのスロットはCAR、もう1つは
CDRです(これらの名前は歴史的なものです。*note Cons Cell Type::を参照して
ください)。CDRは“could-er(クダー)”と発音されます。

   わたしたちは、コンスセルのCARスロットに現在保持されているオブジェクト
が何であれ、“このコンスセルのCARは、...”のような言い方をします。これは
CDRの場合も同様です。

   リストとは、“互いにつながった(chained together)”一連のコンスセルであ
り、各セルは次のセルを参照します。リストの各要素にたいして、それぞれ1つ
のコンスセルがあります。慣例により、コンスセルのCARはリストの要素を保持
し、CDRはリストをチェーンするのに使用されます(CARとCDRの間の非対称性は完
全に慣例的なものです。コンスセルのレベルでは、CARスロットとCDRスロットは
同じようなプロパティーをもちます)。したがって、リスト内の各コンスセルの
CDRスロットは、次のコンスセルを参照します。

   これも慣例的なものですが、リスト内の最後のコンスセルのCDRは‘nil’です
。わたしたちは、このような‘nil’で終端された構造を、“真リスト(true
list)”と呼びます。Emacs Lispでは、シンボル‘nil’は、シンボルであり、要素
なしのリストでもあります。便宜上、シンボル‘nil’は、そのCDR(およびCAR)に
‘nil’をもつと考えます。

   したがって真リストのCDRは、常に真リストです。空でない真リストのCDRは
、1番目の要素以外を含む真リストです。

   リストの最後のコンスセルのCDRが‘nil’以外の何らかの値の場合、このリス
トのプリント表現はドットペア表記(dotted pair notation。*note Dotted Pair
Notation::を参照してください)を使用するので、わたしたちはこの構造を“ドッ
トリスト(dotted list)”と呼びます。他の可能性もあります。あるコンスセルの
CDRが、そのリストのそれより前にある要素を指すかもしれません。わたしたち
は、この構造を“循環リスト(circular list)”と呼びます。

   ある目的にたいしては、そのリストが真リストか、循環リストなのか、ドッ
トリストなのかが問題にならない場合もあります。そのプログラムが、リストを
充分に下って最後のコンスセルのCDRを確認しようとしないなら、これは問題に
なりません。しかし、リストを処理するの関数のいくつかは、真リストを要求し
、ドットリストの場合はエラーをシグナルします。リストの最後を探そうと試み
る関数のほとんどは、循環リストを与えると無限ループに突入します。

   ほとんどのコンスセルはリストの一部として使用されるので、わたしたちは
コンスセルで構成される任意の構造を、“リスト構造(list structure)”と呼びま
す。


File: elisp,  Node: List-related Predicates,  Next: List Elements,  Prev: Cons Cells,  Up: Lists

5.2 Predicates on Lists
=======================

以下の述語は、あるLispオブジェクトがアトムなのか、コンスセルなのか、それ
ともリストなのか、またはオブジェクトが‘nil’かどうかテストします(これらの
述語の多くは、他の述語で定義することもできますが、多用されるので、定義す
る価値があるのです)。

 -- Function: consp object
     この関数は、OBJECTがコンスセルの場合は‘t’、それ以外は‘nil’を
     returnします。たとえ‘nil’はリスト_です_が、コンスセルではありません
     。

 -- Function: atom object
     この関数は、OBJECTがアトムの場合は‘t’、それ以外は‘nil’をreturnしま
     す。シンボル‘nil’はアトムであり、リストでもあります。そのような
     Lispオブジェクトは‘nil’だけです。

          (atom OBJECT) ≡ (not (consp OBJECT))

 -- Function: listp object
     この関数は、OBJECTがコンスセルか‘nil’の場合は‘t’をreturnします。そ
     れ以外は‘nil’をreturnします。

          (listp '(1))
               ⇒ t
          (listp '())
               ⇒ t

 -- Function: nlistp object
     この関数は‘listp’の反対です。OBJECTがリストでない場合は‘t’を
     returnします。それ以外は‘nil’をreturnします。

          (listp OBJECT) ≡ (not (nlistp OBJECT))

 -- Function: null object
     この関数は、OBJECTが‘nil’の場合は‘t’、それ以外は‘nil’をreturnします
     。この関数は‘not’と等価ですが、明解にするために、OBJECTをリストだと
     考えるときは‘null’、真偽値だと考えるときは‘not’を使用します(*note
     Combining Conditions::の‘not’を参照してください)。

          (null '(1))
               ⇒ nil
          (null '())
               ⇒ t


File: elisp,  Node: List Elements,  Next: Building Lists,  Prev: List-related Predicates,  Up: Lists

5.3 Accessing Elements of Lists
===============================

 -- Function: car cons-cell
     この関数は、コンスセルCONS-CELLの1番目のスロットにより参照される値
     をreturnします。他の言い方をすると、この関数はCONS-CELLのCARを
     returnします。

     特別なケースとして、CONS-CELLが‘nil’の場合、この関数は‘nil’を
     returnします。したがって、リストはすべて引数として有効です。引数が
     コンスセルでも‘nil’でもない場合、エラーがシグナルされます。

          (car '(a b c))
               ⇒ a
          (car '())
               ⇒ nil

 -- Function: cdr cons-cell
     この関数は、コンスセルCONS-CELLの2番目のスロットにより参照される値
     をreturnします。他の言い方をすると、この関数はCONS-CELLのCDRを
     returnします。

     特別なケースとして、CONS-CELLが‘nil’の場合、この関数は‘nil’を
     returnします。したがって、リストはすべて引数として有効です。引数が
     コンスセルでも‘nil’でもない場合、エラーがシグナルされます。

          (cdr '(a b c))
               ⇒ (b c)
          (cdr '())
               ⇒ nil

 -- Function: car-safe object
     この関数により、他のデータ型によるエラーを起こさずに、コンスセルの
     CARを取得できます。この関数は、OBJECTがコンスセルの場合はOBJECTの
     CAR、それ以外は‘nil’をreturnします。この関数は、OBJECTがリスとでな
     いときはエラーをシグナルする‘car’とは対象的です。

          (car-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     この関数により、他のデータ型によるエラーを起こさずに、コンスセルの
     CDRを取得できます。この関数は、OBJECTがコンスセルの場合はOBJECTの
     CDR、それ以外は‘nil’をreturnします。この関数は、OBJECTがリスとでな
     いときはエラーをシグナルする‘cdr’とは対象的です。

          (cdr-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Macro: pop listname
     このマクロはリストのCARを調べて、それをリストから取り去るのを1度に
     行なう便利な方法を提供します。この関数はLISTNAMEに格納されたリスト
     にたいして処理を行ないます。この関数はリストから1番目の要素を削除し
     て、CDRをLISTNAMEに保存し、その後で削除した要素をreturnします。

     1番単純なケースは、リストに名前をつけるためのクォートされていないシ
     ンボルの場合です。この場合、このマクロは
     ‘(prog1 (car listname) (setq listname (cdr listname)))’と等価です。

          x
               ⇒ (a b c)
          (pop x)
               ⇒ a
          x
               ⇒ (b c)

     より一般的なのは、LISTNAMEが汎変数(generalized variable)の場合です
     。この場合、このマクロは‘setf’を使用してLISTNAMEに保存します。*note
     Generalized Variables::を参照してください。

     リストに要素を追加する‘push’マクロについては、*note List
     Variables::を参照してください。

 -- Function: nth n list
     この関数は、LISTのN番目の要素をreturnします。要素は0から数えられる
     ので、LISTのCARは要素0になります。LISTの長さがN以下の場合、値は
     ‘nil’です。

          (nth 2 '(1 2 3 4))
               ⇒ 3
          (nth 10 '(1 2 3 4))
               ⇒ nil

          (nth n x) ≡ (car (nthcdr n x))

     関数‘elt’は似ていますが、これは任意の種類のシーケンスに適用されます
     。歴史的な理由により、この関数は逆の順序で引数を受け取ります。*note
     Sequence Functions::を参照してください。

 -- Function: nthcdr n list
     この関数は、LISTのN番目のCDRをreturnします。他の言い方をすると、こ
     の関数はLISTの最初のN個のリンクをスキップしてから、それ以降を
     returnします。

     Nが0の場合、‘nthcdr’はLIST全体をreturnします。LISTの長さがN以下の場
     合、‘nthcdr’は‘nil’をreturnします。

          (nthcdr 1 '(1 2 3 4))
               ⇒ (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               ⇒ nil
          (nthcdr 0 '(1 2 3 4))
               ⇒ (1 2 3 4)

 -- Function: last list &optional n
     この関数は、LISTの最後のリンクをreturnします。このリンクの‘car’は、
     このリストの最後の要素です。LISTがnullの場合、‘nil’がreturnされます
     。Nが非‘nil’の場合、N番目から最後までのリンクがreturnされます。Nが
     LISTの長さより大きい場合は、LIST全体がreturnされます。

 -- Function: safe-length list
     この関数は、エラーや無限ループの危険なしで、LISTの長さをreturnしま
     す。この関数は一般的に、リスト内のコンスセルの個数をreturnします。
     しかし循環リストでは、単に上限値が値となるため、非常に大きくなる場
     合があります。

     LISTが‘nil’でもコンスセルでもない場合、‘safe-length’は0をreturnしま
     す。

   循環リストを考慮しなくてもよい場合に、リストの長さを計算するもっとも
一般的な方法は、‘length’を使うことです。*note Sequence Functions::を参照
してください。

 -- Function: caar cons-cell
     これは、‘(car (car CONS-CELL))’と同じです。

 -- Function: cadr cons-cell
     これは、‘(car (cdr CONS-CELL))’または‘(nth 1 CONS-CELL)’と同じです
     。

 -- Function: cdar cons-cell
     これは、‘(cdr (car CONS-CELL))’と同じです。

 -- Function: cddr cons-cell
     これは、‘(cdr (cdr CONS-CELL))’または‘(nthcdr 2 CONS-CELL)’と同じで
     す。

 -- Function: butlast x &optional n
     この関数は、リストXから、最後の要素、または最後のN個の要素を削除し
     てreturnします。Nが0より大きい場合、この関数はリストのコピーを作成
     するので、元のリストに影響はありません。一般的に、‘(append (butlast
     X N) (last X N))’は、Xと等しいリストをreturnします。

 -- Function: nbutlast x &optional n
     この関数は、リストのコピーを作成するのではなく、‘cdr’を適切な要素に
     変更することにより破壊的に機能するバージョンの‘butlast’です。

