This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Top,  Next: Introduction,  Up: (dir)

Emacs Lisp
**********

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”

* Menu:

* Introduction::            Introduction and conventions used.

* Lisp Data Types::         Data types of objects in Emacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Hash Tables::             Very fast lookup-tables.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.
* Functions::               A function is a Lisp program
                              that can be invoked from other functions.
* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Making variables and faces customizable.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::                  Making multiple system-level windows.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Non-ASCII Characters::    Non-ASCII text in buffers and strings.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Processes::               Running and communicating with subprocesses.
* Display::                 Features for controlling the screen display.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.

* Packaging::               Preparing Lisp code for distribution.

Appendices

* Antinews::                Info for users downgrading to Emacs 23.
* GNU Free Documentation License:: The license for this documentation.
* GPL::                     Conditions for copying and changing GNU Emacs.
* Tips::                    Advice and coding conventions for Emacs Lisp.
* GNU Emacs Internals::     Building and dumping Emacs;
                              internal data structures.
* Standard Errors::         List of some standard error symbols.
* Standard Keymaps::        List of some standard keymaps.
* Standard Hooks::          List of some standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.



 — The Detailed Node Listing —
 ———————————

Here are other nodes that are subnodes of those already listed,
mentioned here so you can get to them in one step:

Introduction

* Caveats::                 Flaws and a request for help.
* Lisp History::            Emacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Version Info::            Which Emacs version is running?
* Acknowledgments::         The authors, editors, and sponsors of this manual.

Conventions

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols ‘nil’ and ‘t’ are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use when examples print text.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

Format of Descriptions

* A Sample Function Description::  A description of an imaginary
                                     function, ‘foo’.
* A Sample Variable Description::  A description of an imaginary
                                     variable, ‘electric-future-map’.

Lisp Data Types

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to Emacs.
* Circular Objects::        Read syntax for circular structure.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

Programming Types

* Integer Type::        Numbers without fractional parts.
* Floating-Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                          control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of ‘t’ or ‘nil’.
* Hash Table Type::     Super-fast lookup tables.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                          functions.

Character Type

* Basic Char Syntax::       Syntax for regular characters.
* General Escape Syntax::   How to specify characters by their codes.
* Ctl-Char Syntax::         Syntax for control characters.
* Meta-Char Syntax::        Syntax for meta-characters.
* Other Char Bits::         Syntax for hyper-, super-, and alt-characters.

Cons Cell and List Types

* Box Diagrams::            Drawing pictures of lists.
* Dotted Pair Notation::    A general syntax for cons cells.
* Association List Type::   A specially constructed list.

String Type

* Syntax for Strings::      How to specify Lisp strings.
* Non-ASCII in Strings::    International characters in strings.
* Nonprinting Characters::  Literal unprintable characters in strings.
* Text Props and Strings::  Strings with text properties.

Editing Types

* Buffer Type::             The basic object of editing.
* Marker Type::             A position in a buffer.
* Window Type::             Buffers are displayed in windows.
* Frame Type::              Windows subdivide frames.
* Terminal Type::           A terminal device displays frames.
* Window Configuration Type::  Recording the way a frame is subdivided.
* Frame Configuration Type::   Recording the status of all frames.
* Process Type::            A subprocess of Emacs running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Overlay Type::            How an overlay is represented.
* Font Type::               Fonts for displaying text.

Numbers

* Integer Basics::          Representation and range of integers.
* Float Basics::            Representation and range of floating point.
* Predicates on Numbers::   Testing for numbers.
* Comparison of Numbers::   Equality and inequality predicates.
* Numeric Conversions::     Converting float to integer and vice versa.
* Arithmetic Operations::   How to add, subtract, multiply and divide.
* Rounding Operations::     Explicitly rounding floating-point numbers.
* Bitwise Operations::      Logical and, or, not, shifting.
* Math Functions::          Trig, exponential and logarithmic functions.
* Random Numbers::          Obtaining random integers, predictable or not.

Strings and Characters

* String Basics::           Basic properties of strings and characters.
* Predicates for Strings::  Testing whether an object is a string or char.
* Creating Strings::        Functions to allocate new strings.
* Modifying Strings::       Altering the contents of an existing string.
* Text Comparison::         Comparing characters or strings.
* String Conversion::       Converting to and from characters and strings.
* Formatting Strings::      ‘format’: Emacs’s analogue of ‘printf’.
* Case Conversion::         Case conversion functions.
* Case Tables::             Customizing case conversion.

Lists

* Cons Cells::              How lists are made out of cons cells.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* List Variables::          Modifying lists stored in variables.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.
* Property Lists::          A list of paired elements.

Modifying Existing List Structure

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

Property Lists

* Plists and Alists::       Comparison of the advantages of property
                              lists and association lists.
* Plist Access::            Accessing property lists stored elsewhere.

Sequences, Arrays, and Vectors

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in Emacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Special characteristics of Emacs Lisp vectors.
* Vector Functions::        Functions specifically for vectors.
* Char-Tables::             How to work with char-tables.
* Bool-Vectors::            How to work with bool-vectors.
* Rings::                   Managing a fixed-size ring of objects.

Hash Tables

* Creating Hash::           Functions to create hash tables.
* Hash Access::             Reading and writing the hash table contents.
* Defining Hash::           Defining new comparison methods.
* Other Hash::              Miscellaneous.

Symbols

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Symbol Properties::       Each symbol has a property list
                              for recording miscellaneous information.

Symbol Properties

* Symbol Plists::           Accessing symbol properties.
* Standard Properties::     Standard meanings of symbol properties.

Evaluation

* Intro Eval::              Evaluation in the scheme of things.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).
* Backquote::               Easier construction of list structure.
* Eval::                    How to invoke the Lisp interpreter explicitly.

Kinds of Forms

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           "Special forms" are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

Control Structures

* Sequencing::              Evaluation in textual order.
* Conditionals::            ‘if’, ‘cond’, ‘when’, ‘unless’.
* Combining Conditions::    ‘and’, ‘or’, ‘not’.
* Iteration::               ‘while’ loops.
* Nonlocal Exits::          Jumping out of a sequence.

Nonlocal Exits

* Catch and Throw::         Nonlocal exits for the program’s own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

Errors

* Signaling Errors::        How to report an error.
* Processing of Errors::    What Emacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

Variables

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Tips for Defining::       Things you should think about when you
                              define a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.
* File Local Variables::    Handling local variable lists in files.
* Directory Local Variables:: Local variables common to all files in a
                                directory.
* Variable Aliases::        Variables that are aliases for other variables.
* Variables with Restricted Values::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.
* Generalized Variables::   Extending the concept of variables.

Scoping Rules for Variable Bindings

* Dynamic Binding::         The default for binding local variables in Emacs.
* Dynamic Binding Tips::    Avoiding problems with dynamic binding.
* Lexical Binding::         A different type of local variable binding.
* Using Lexical Binding::   How to enable lexical binding.

Buffer-Local Variables

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don’t have their own buffer-local values.

Generalized Variables

* Setting Generalized Variables::   The ‘setf’ macro.
* Adding Generalized Variables::    Defining new ‘setf’ forms.

Functions

* What Is a Function::      Lisp functions vs. primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Closures::                Functions that enclose a lexical environment.
* Obsolete Functions::      Declaring functions obsolete.
* Inline Functions::        Defining functions that the compiler
                              will expand inline.
* Declare Form::          Adding additional information about a function.
* Declaring Functions::     Telling the compiler that a function is defined.
* Function Safety::         Determining whether a function is safe to call.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

Macros

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Problems with Macros::    Don’t evaluate the macro arguments too many times.
                              Don’t hide the user’s variables.
* Indenting Macros::        Specifying how to indent macro calls.

Common Problems Using Macros

* Wrong Time::             Do the work in the expansion, not in the macro.
* Argument Evaluation::    The expansion should evaluate each macro arg once.
* Surprising Local Vars::  Local variable bindings in the expansion
                              require special care.
* Eval During Expansion::  Don’t evaluate them; put them in the expansion.
* Repeated Expansion::     Avoid depending on how many times expansion is done.

Customization Settings

* Common Keywords::         Common keyword arguments for all kinds of
                              customization declarations.
* Group Definitions::       Writing customization group definitions.
* Variable Definitions::    Declaring user options.
* Customization Types::     Specifying the type of a user option.
* Applying Customizations:: Functions to apply customization settings.
* Custom Themes::           Writing Custom themes.

Customization Types

* Simple Types::            Simple customization types: sexp, integer, etc.
* Composite Types::         Build new types from other types or data.
* Splicing into Lists::     Splice elements into list with ‘:inline’.
* Type Keywords::           Keyword-argument pairs in a customization type.
* Defining New Types::      Give your type a name.

Loading

* How Programs Do Loading:: The ‘load’ function and others.
* Load Suffixes::           Details about the suffixes that ‘load’ tries.
* Library Search::          Finding a library to load.
* Loading Non-ASCII::       Non-ASCII characters in Emacs Lisp files.
* Autoload::                Setting up a function to autoload.
* Repeated Loading::        Precautions about loading a file twice.
* Named Features::          Loading a library if it isn’t already loaded.
* Where Defined::           Finding which file defined a certain symbol.
* Unloading::               How to "unload" a library that was loaded.
* Hooks for Loading::       Providing code to be run when
                              particular libraries are loaded.

Byte Compilation

* Speed of Byte-Code::      An example of speedup from byte compilation.
* Compilation Functions::   Byte compilation functions.
* Docs and Compilation::    Dynamic loading of documentation strings.
* Dynamic Loading::         Dynamic loading of individual functions.
* Eval During Compile::     Code to be evaluated when you compile.
* Compiler Errors::         Handling compiler error messages.
* Byte-Code Objects::       The data type used for byte-compiled functions.
* Disassembly::             Disassembling byte-code; how to read byte-code.

Debugging Lisp Programs

* Debugger::                A debugger for the Emacs Lisp evaluator.
* Edebug::                  A source-level Emacs Lisp debugger.
* Syntax Errors::           How to find syntax errors.
* Test Coverage::           Ensuring you have tested all branches in your code.
* Profiling::               Measuring the resources that your code uses.

The Lisp Debugger

* Error Debugging::         Entering the debugger when an error happens.
* Infinite Loops::          Stopping and debugging a program that doesn’t exit.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function ‘debug’.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

Edebug

* Using Edebug::            Introduction to use of Edebug.
* Instrumenting::           You must instrument your code
                              in order to debug it with Edebug.
* Edebug Execution Modes::  Execution modes, stopping more or less often.
* Jumping::                 Commands to jump to a specified place.
* Edebug Misc::             Miscellaneous commands.
* Breaks::                  Setting breakpoints to make the program stop.
* Trapping Errors::         Trapping errors with Edebug.
* Edebug Views::            Views inside and outside of Edebug.
* Edebug Eval::             Evaluating expressions within Edebug.
* Eval List::               Expressions whose values are displayed
                              each time you enter Edebug.
* Printing in Edebug::      Customization of printing.
* Trace Buffer::            How to produce trace output in a buffer.
* Coverage Testing::        How to test evaluation coverage.
* The Outside Context::     Data that Edebug saves and restores.
* Edebug and Macros::       Specifying how to handle macro calls.
* Edebug Options::          Option variables for customizing Edebug.

Breaks

* Breakpoints::             Breakpoints at stop points.
* Global Break Condition::  Breaking on an event.
* Source Breakpoints::      Embedding breakpoints in source code.

The Outside Context

* Checking Whether to Stop::When Edebug decides what to do.
* Edebug Display Update::   When Edebug updates the display.
* Edebug Recursive Edit::   When Edebug stops execution.

Edebug and Macros

* Instrumenting Macro Calls::The basic problem.
* Specification List::      How to specify complex patterns of evaluation.
* Backtracking::            What Edebug does when matching fails.
* Specification Examples::  To help understand specifications.

Debugging Invalid Lisp Syntax

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.
* Output Variables::        Variables that control what the printing
                              functions do.

Minibuffers

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Minibuffer History::      Recording previous minibuffer inputs
                              so the user can reuse them.
* Initial Input::           Specifying initial contents for the minibuffer.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Multiple Queries::        Asking a series of similar questions.
* Reading a Password::      Reading a password from the terminal.
* Minibuffer Commands::     Commands used as key bindings in minibuffers.
* Minibuffer Windows::      Operating on the special minibuffer windows.
* Minibuffer Contents::     How such commands access the minibuffer text.
* Recursive Mini::          Whether recursive entry to minibuffer is allowed.
* Minibuffer Misc::         Various customization hooks and variables.

Completion

* Basic Completion::        Low-level functions for completing strings.
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer names, variable names, etc.).
* Reading File Names::      Using completion to read file names and
                              shell commands.
* Completion Variables::    Variables controlling completion behavior.
* Programmed Completion::   Writing your own completion function.
* Completion in Buffers::   Completing text in ordinary buffers.

Command Loop

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Distinguish Interactive::     Making a command distinguish interactive calls.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Adjusting Point::     Adjustment of point after a command.
* Input Events::        What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How ‘C-g’ works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn’t.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

Defining Commands

* Using Interactive::       General rules for ‘interactive’.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.
* Generic Commands::        Select among command alternatives.


Input Events

* Keyboard Events::         Ordinary characters–keys with symbols on them.
* Function Keys::           Function keys–keys with names, not symbols.
* Mouse Events::            Overview of mouse events.
* Click Events::            Pushing and releasing a mouse button.
* Drag Events::             Moving the mouse before releasing the button.
* Button-Down Events::      A button was pushed and not yet released.
* Repeat Events::           Double and triple click (or drag, or down).
* Motion Events::           Just moving the mouse, not pushing a button.
* Focus Events::            Moving the mouse between frames.
* Misc Events::             Other events the system can generate.
* Event Examples::          Examples of the lists for mouse events.
* Classifying Events::      Finding the modifier keys in an event symbol.
                              Event types.
* Accessing Mouse::         Functions to extract info from mouse events.
* Accessing Scroll::        Functions to get info from scroll bar events.
* Strings of Events::       Special considerations for putting
                              keyboard character events in a string.

Reading Input

* Key Sequence Input::      How to read one key sequence.
* Reading One Event::       How to read just one event.
* Event Mod::               How Emacs modifies events as they are read.
* Invoking the Input Method::   How reading an event uses the input method.
* Quoted Character Input::  Asking the user to specify a character.
* Event Input Misc::        How to reread or throw away input events.

Keymaps

* Key Sequences::           Key sequences as Lisp objects.
* Keymap Basics::           Basic concepts of keymaps.
* Format of Keymaps::       What a keymap looks like as a Lisp object.
* Creating Keymaps::        Functions to create and copy keymaps.
* Inheritance and Keymaps:: How one keymap can inherit the bindings
                              of another keymap.
* Prefix Keys::             Defining a key with a keymap as its definition.
* Active Keymaps::          How Emacs searches the active keymaps
                              for a key binding.
* Searching Keymaps::       A pseudo-Lisp summary of searching active maps.
* Controlling Active Maps:: Each buffer has a local keymap
                               to override the standard (global) bindings.
                               A minor mode can also override them.
* Key Lookup::              Finding a key’s binding in one keymap.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::   Redefining a key in a keymap.
* Remapping Commands::      A keymap can translate one command to another.
* Translation Keymaps::     Keymaps for translating sequences of events.
* Key Binding Commands::    Interactive interfaces for redefining keys.
* Scanning Keymaps::        Looking through all keymaps, for printing help.
* Menu Keymaps::            Defining a menu as a keymap.

Menu Keymaps

* Defining Menus::          How to make a keymap that defines a menu.
* Mouse Menus::             How users actuate the menu with the mouse.
* Keyboard Menus::          How users actuate the menu with the keyboard.
* Menu Example::            Making a simple menu.
* Menu Bar::                How to customize the menu bar.
* Tool Bar::                A tool bar is a row of images.
* Modifying Menus::         How to add new items to a menu.
* Easy Menu::               A convenience macro for defining menus.

Defining Menus

* Simple Menu Items::       A simple kind of menu key binding.
* Extended Menu Items::     More complex menu item definitions.
* Menu Separators::         Drawing a horizontal line through a menu.
* Alias Menu Items::        Using command aliases in menu items.

Major and Minor Modes

* Hooks::              How to use hooks; how to write code that provides hooks.
* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Imenu::              Providing a menu of definitions made in a buffer.
* Font Lock Mode::     How modes can highlight text according to syntax.
* Auto-Indentation::   How to teach Emacs to indent for a major mode.
* Desktop Save Mode::  How modes can have buffer state saved between
                         Emacs sessions.

Hooks

* Running Hooks::      How to run a hook.
* Setting Hooks::      How to put functions on a hook, or remove them.

Major Modes

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major
                              mode.
* Basic Major Modes::       Modes that other modes are often derived from.
* Mode Hooks::              Hooks run at the end of major mode functions.
* Tabulated List Mode::     Parent mode for buffers containing tabulated data.
* Generic Modes::           Defining a simple major mode that supports
                              comment syntax and Font Lock mode.
* Example Major Modes::     Text mode and Lisp modes.

Minor Modes

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.
* Defining Minor Modes::    A convenient facility for defining minor modes.

Mode Line Format

* Mode Line Basics::        Basic ideas of mode line control.
* Mode Line Data::          The data structure that controls the mode line.
* Mode Line Top::           The top level variable, mode-line-format.
* Mode Line Variables::     Variables used in that data structure.
* %-Constructs::            Putting information into a mode line.
* Properties in Mode::      Using text properties in the mode line.
* Header Lines::            Like a mode line, but at the top.
* Emulating Mode Line::     Formatting text as the mode line would.

Font Lock Mode

* Font Lock Basics::        Overview of customizing Font Lock.
* Search-based Fontification::  Fontification based on regexps.
* Customizing Keywords::    Customizing search-based fontification.
* Other Font Lock Variables::   Additional customization facilities.
* Levels of Font Lock::     Each mode can define alternative levels
                              so that the user can select more or less.
* Precalculated Fontification:: How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* Faces for Font Lock::     Special faces specifically for Font Lock.
* Syntactic Font Lock::     Fontification based on syntax tables.
* Multiline Font Lock::     How to coerce Font Lock into properly
                              highlighting multiline constructs.

Multiline Font Lock Constructs

* Font Lock Multiline::     Marking multiline chunks with a text property.
* Region to Refontify::     Controlling which region gets refontified
                              after a buffer change.

Automatic Indentation of code

* SMIE::                    A simple minded indentation engine.

Simple Minded Indentation Engine

* SMIE setup::              SMIE setup and features.
* Operator Precedence Grammars:: A very simple parsing technique.
* SMIE Grammar::            Defining the grammar of a language.
* SMIE Lexer::              Defining tokens.
* SMIE Tricks::             Working around the parser’s limitations.
* SMIE Indentation::        Specifying indentation rules.
* SMIE Indentation Helpers:: Helper functions for indentation rules.
* SMIE Indentation Example:: Sample indentation rules.
* SMIE Customization::      Customizing indentation.

Documentation

* Documentation Basics::    Where doc strings are defined and stored.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by Emacs help facilities.

Files

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into buffers without visiting.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                              simultaneous editing by two people.
* Information about Files:: Testing existence, accessibility, size of files.
* Changing Files::          Renaming files, changing permissions, etc.
* File Names::              Decomposing and expanding file names.
* Contents of Directories:: Getting a list of the files in a directory.
* Create/Delete Dirs::      Creating and Deleting Directories.
* Magic File Names::        Special handling for certain file names.
* Format Conversion::       Conversion to and from various file formats.

Visiting Files

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

Information about Files

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::               Eliminating symbolic links from a file name.
* File Attributes::         File sizes, modification times, etc.
* Extended Attributes::     Extended file attributes for access control.
* Locating Files::          How to find a file in standard places.

File Names

* File Name Components::    The directory part of a file name, and the rest.
* Relative File Names::     Some file names are relative to a current directory.
* Directory Names::         A directory’s name as a directory
                              is different from its name as a file.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.
* Standard File Names::     If your package uses a fixed file name,
                              how to handle various operating systems simply.

File Format Conversion

* Format Conversion Overview::   ‘insert-file-contents’ and ‘write-region’.
* Format Conversion Round-Trip:: Using ‘format-alist’.
* Format Conversion Piecemeal::  Specifying non-paired conversion.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               ‘revert-buffer’, and how to customize
                              what it does.

Backup Files

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Current Buffer::          Designating a buffer as current
                              so that primitives will access its contents.
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is “modified” if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              "behind Emacs’s back".
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* Buffer List::             How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Indirect Buffers::        An indirect buffer shares text with some
                              other buffer.
* Swapping Text::           Swapping text between two buffers.
* Buffer Gap::              The gap in the buffer.

Windows

* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window’s size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Recombining Windows::     Preserving the frame layout when splitting and
                              deleting windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for ‘display-buffer’.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

Frames

* Creating Frames::         Creating additional frames.
* Multiple Terminals::      Displaying on several different devices.
* Frame Parameters::        Controlling frame size, position, font, etc.
* Terminal Parameters::     Parameters common for all frames on terminal.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::         Frames last until explicitly deleted.
* Finding All Frames::      How to examine all existing frames.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::             Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other windows;
                              lowering it makes the others hide it.
* Frame Configurations::    Saving the state of all frames.
* Mouse Tracking::          Getting events that say when the mouse moves.
* Mouse Position::          Asking where the mouse is, or moving it.
* Pop-Up Menus::            Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shape::           Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other X clients.
* Drag and Drop::               Internals of Drag-and-Drop implementation.
* Color Names::             Getting the definitions of color names.
* Text Terminal Colors::    Defining colors for text terminals.
* Resources::               Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

Frame Parameters

* Parameter Access::        How to change a frame’s parameters.
* Initial Parameters::      Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Size and Position::       Changing the size and position of a frame.
* Geometry::                Parsing geometry specifications.

Window Frame Parameters

* Basic Parameters::        Parameters that are fundamental.
* Position Parameters::     The position of the frame on the screen.
* Size Parameters::         Frame’s size.
* Layout Parameters::       Size of parts of the frame, and
                              enabling or disabling some parts.
* Buffer Parameters::       Which buffers have been or should be shown.
* Management Parameters::   Communicating with the window manager.
* Cursor Parameters::       Controlling the cursor appearance.
* Font and Color Parameters:: Fonts and colors for the frame text.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::Finding the marker’s buffer or character position.
* Marker Insertion Types::  Two ways a marker can relocate when you
                              insert where it points.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How "the mark" is implemented with a marker.
* The Region::              How to access "the region".

Text

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Comparing Text::          Comparing substrings of buffers.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Maintaining Undo::        How to enable and disable undo information.
                              How to control how much information is kept.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Adaptive Fill::           Adaptive Fill mode chooses a fill prefix
                              from context.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Sorting::                 Functions for sorting parts of the buffer.
* Columns::                 Computing horizontal positions, and using them.
* Indentation::             Functions to insert or adjust indentation.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Transposition::           Swapping two portions of a buffer.
* Decompression::           Dealing with compressed data.
* Base 64::                 Conversion to or from base 64 encoding.
* Checksum/Hash::           Computing cryptographic hashes.
* Parsing HTML/XML::        Parsing HTML and XML.
* Atomic Changes::          Installing several buffer changes "atomically".
* Change Hooks::            Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yanking::                 How yanking is done.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::     Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Text Properties

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::     Setting the properties of a range of text.
* Property Search::         Searching for where a property changes value.
* Special Properties::      Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The ‘field’ property defines
                              fields within the buffer.
* Not Intervals::           Why text properties do not use
                              Lisp-visible text intervals.

Non-ASCII Characters

* Text Representations::    How Emacs represents text.
* Disabling Multibyte::     Controlling whether to use multibyte characters.
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Properties::    Character attributes that define their
                                behavior and handling.
* Character Sets::          The space of possible character codes
                                is divided into various character sets.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

Coding Systems

* Coding System Basics::    Basic concepts.
* Encoding and I/O::        How file I/O functions handle coding systems.
* Lisp and Coding Systems:: Functions to operate on coding system names.
* User-Chosen Coding Systems::  Asking the user to choose a coding system.
* Default Coding Systems::  Controlling the default choices.
* Specifying Coding Systems::   Requesting a particular coding system
                                    for a single file operation.
* Explicit Encoding::       Encoding or decoding text without doing I/O.
* Terminal I/O Encoding::   Use of encoding for terminal I/O.

Searching and Matching

* String Search::           Search for an exact match.
* Searching and Case::      Case-independent or case-significant searching.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* POSIX Regexps::           Searching POSIX-style for the longest match.
* Match Data::              Finding out which part of the text matched,
                              after a string or regexp search.
* Search and Replace::      Commands that loop, searching and replacing.
* Standard Regexps::        Useful regexps for finding sentences, pages,...

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
* Regexp Functions::        Functions for operating on regular expressions.

Syntax of Regular Expressions

* Regexp Special::          Special characters in regular expressions.
* Char Classes::            Character classes used in regular expressions.
* Regexp Backslash::        Backslash-sequences in regular expressions.

The Match Data

* Replacing Match::         Replacing a substring that was matched.
* Simple Match Data::       Accessing single items of match data,
                              such as where a particular subexpression started.
* Entire Match Data::       Accessing the entire match data at once, as a list.
* Saving Match Data::       Saving and restoring the match data.

Syntax Tables

* Syntax Basics::           Basic concepts of syntax tables.
* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Syntax Properties::       Overriding syntax with text properties.
* Motion and Syntax::       Moving over characters with certain syntaxes.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Syntax Table Internals::  How syntax table information is stored.
* Categories::              Another way of classifying character syntax.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Parsing Expressions

* Motion via Parsing::      Motion functions that work by parsing.
* Position Parse::          Determining the syntactic state of a position.
* Parser State::            How Emacs represents a syntactic state.
* Low-Level Parsing::       Parsing across a specified region.
* Control Parsing::         Parameters that affect parsing.

Abbrevs and Abbrev Expansion

* Abbrev Tables::           Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Abbrev Files::            Saving abbrevs in files.
* Abbrev Expansion::        Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.
* Abbrev Properties::       How to read and set abbrev properties.
                            Which properties have which effect.
* Abbrev Table Properties:: How to read and set abbrev table properties.
                            Which properties have which effect.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Shell Arguments::         Quoting an argument to pass it to a shell.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Query Before Exit::       Whether to query if exiting will kill a process.
* System Processes::        Accessing other processes running on your system.
* Transaction Queues::      Transaction-based communication with subprocesses.
* Network::                 Opening network connections.
* Network Servers::         Network servers let Emacs accept net connections.
* Datagrams::               UDP network connections.
* Low-Level Network::       Lower-level but more general function
                              to create connections and servers.
* Misc Network::            Additional relevant functions for net connections.
* Serial Ports::            Communicating with serial ports.
* Byte Packing::            Using bindat to pack and unpack binary data.

Receiving Output from Processes

* Process Buffers::         By default, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.

Low-Level Network Access

* Network Processes::       Using ‘make-network-process’.
* Network Options::         Further control over network connections.
* Network Feature Testing:: Determining which network features work on
                              the machine you are using.

Packing and Unpacking Byte Arrays

* Bindat Spec::             Describing data layout.
* Bindat Functions::        Doing the unpacking and packing.
* Bindat Examples::         Samples of what bindat.el can do for you!

Emacs Display

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Forcing Redisplay::       Forcing redisplay.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Displaying messages at the bottom of the screen.
* Warnings::                Displaying warning messages for the user.
* Invisible Text::          Hiding part of the buffer text.
* Selective Display::       Hiding part of the buffer text (the old way).
* Temporary Displays::      Displays that go away automatically.
* Overlays::                Use overlays to highlight parts of the buffer.
* Size of Displayed Text::  How large displayed text is.
* Line Height::             Controlling the height of lines.
* Faces::                   A face defines a graphics style
                              for text characters: font, colors, etc.
* Fringes::                 Controlling window fringes.
* Scroll Bars::             Controlling vertical scroll bars.
* Window Dividers::         Separating windows visually.
* Display Property::        Enabling special display features.
* Images::                  Displaying images in Emacs buffers.
* Buttons::                 Adding clickable buttons to Emacs buffers.
* Abstract Display::        Emacs’s Widget for Object Collections.
* Blinking::                How Emacs shows the matching open parenthesis.
* Character Display::       How Emacs displays individual characters.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.
* Bidirectional Display::   Display of bidirectional scripts, such as
                              Arabic and Farsi.

The Echo Area

* Displaying Messages::     Explicitly displaying text in the echo area.
* Progress::                Informing user about progress of a long operation.
* Logging Messages::        Echo area messages are logged for the user.
* Echo Area Customization:: Controlling the echo area.

Reporting Warnings

* Warning Basics::          Warnings concepts and functions to report them.
* Warning Variables::       Variables programs bind to customize
                              their warnings.
* Warning Options::         Variables users set to control display of warnings.
* Delayed Warnings::        Deferring a warning until the end of a command.

Overlays

* Managing Overlays::       Creating and moving overlays.
* Overlay Properties::      How to read and set properties.
                              What properties do to the screen display.
* Finding Overlays::        Searching for overlays.

Faces

* Face Attributes::         What is in a face?
* Defining Faces::          How to define a face.
* Attribute Functions::     Functions to examine and set face attributes.
* Displaying Faces::        How Emacs combines the faces specified for
                              a character.
* Face Remapping::          Remapping faces to alternative definitions.
* Face Functions::          How to define and examine faces.
* Auto Faces::              Hook for automatic face assignment.
* Basic Faces::             Faces that are defined by default.
* Font Selection::          Finding the best available font for a face.
* Font Lookup::             Looking up the names of available fonts
                              and information about them.
* Fontsets::                A fontset is a collection of fonts
                              that handle a range of character sets.
* Low-Level Font::          Lisp representation for character display fonts.

Fringes

* Fringe Size/Pos::         Specifying where to put the window fringes.
* Fringe Indicators::       Displaying indicator icons in the window fringes.
* Fringe Cursors::          Displaying cursors in the right fringe.
* Fringe Bitmaps::          Specifying bitmaps for fringe indicators.
* Customizing Bitmaps::     Specifying your own bitmaps to use in the fringes.
* Overlay Arrow::           Display of an arrow to indicate position.

The ‘display’ Property

* Replacing Specs::         Display specs that replace the text.
* Specified Space::         Displaying one space with a specified width.
* Pixel Specification::     Specifying space width or height in pixels.
* Other Display Specs::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* Display Margins::         Displaying text or images to the side of
                              the main text.

Images

* Image Formats::           Supported image formats.
* Image Descriptors::       How to specify an image for use in ‘:display’.
* XBM Images::              Special features for XBM format.
* XPM Images::              Special features for XPM format.
* PostScript Images::       Special features for PostScript format.
* ImageMagick Images::      Special features available through ImageMagick.
* Other Image Types::       Various other formats are supported.
* Defining Images::         Convenient ways to define an image for later use.
* Showing Images::          Convenient ways to display an image once
                              it is defined.
* Multi-Frame Images::      Some images contain more than one frame.
* Image Cache::             Internal mechanisms of image display.

Buttons

* Button Properties::       Button properties with special meanings.
* Button Types::            Defining common properties for classes of buttons.
* Making Buttons::          Adding buttons to Emacs buffers.
* Manipulating Buttons::    Getting and setting properties of buttons.
* Button Buffer Commands::  Buffer-wide commands and bindings for buttons.

Abstract Display

* Abstract Display Functions::  Functions in the Ewoc package.
* Abstract Display Example::    Example of using Ewoc.

Character Display

* Usual Display::       The usual conventions for displaying characters.
* Display Tables::      What a display table consists of.
* Active Display Table::  How Emacs selects a display table to use.
* Glyphs::              How to define a glyph, and what glyphs mean.
* Glyphless Chars::     How glyphless characters are drawn.

Operating System Interface

* Starting Up::             Customizing Emacs startup processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* User Identification::     Finding the name and user id of the user.
* Time of Day::             Getting the current time.
* Time Conversion::         Converting a time from numeric form to
                              calendrical data and vice versa.
* Time Parsing::            Converting a time from numeric form to text
                              and vice versa.
* Processor Run Time::      Getting the run time used by Emacs.
* Time Calculations::       Adding, subtracting, comparing times, etc.
* Timers::                  Setting a timer to call a function at a
                              certain time.
* Idle Timers::             Setting a timer to call a function when Emacs has
                              been idle for a certain length of time.
* Terminal Input::          Accessing and recording terminal input.
* Terminal Output::         Controlling and recording terminal output.
* Sound Output::            Playing sounds on the computer’s speaker.
* X11 Keysyms::             Operating on key symbols for X Windows.
* Batch Mode::              Running Emacs without terminal interaction.
* Session Management::      Saving and restoring state with
                              X Session Management.
* Desktop Notifications::   Desktop notifications.
* File Notifications::      File notifications.
* Dynamic Libraries::       On-demand loading of support libraries.

Starting Up Emacs

* Startup Summary::         Sequence of actions Emacs performs at startup.
* Init File::               Details on reading the init file.
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command-line arguments are processed,
                              and how you can customize them.

Getting Out of Emacs

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Terminal Input

* Input Modes::             Options for how input is processed.
* Recording Input::         Saving histories of recent or all input events.

Preparing Lisp code for distribution

* Packaging Basics::        The basic concepts of Emacs Lisp packages.
* Simple Packages::         How to package a single .el file.
* Multi-file Packages::     How to package multiple files.
* Package Archives::        Maintaining package archives.

Tips and Conventions

* Coding Conventions::      Conventions for clean and robust programs.
* Key Binding Conventions:: Which keys should be bound by which programs.
* Programming Tips::        Making Emacs code fit smoothly in Emacs.
* Compilation Tips::        Making compiled code run fast.
* Warning Tips::            Turning off compiler warnings.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::            Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

GNU Emacs Internals

* Building Emacs::          How the dumped Emacs is made.
* Pure Storage::            Kludge to make preloaded Lisp functions shareable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Memory Usage::            Info about total size of Lisp objects made so far.
* Writing Emacs Primitives::  Writing C code for Emacs.
* Object Internals::        Data formats of buffers, windows, processes.

Object Internals

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.


File: elisp,  Node: Introduction,  Next: Lisp Data Types,  Prev: Top,  Up: Top

1 Introduction
**************

GNU Emacsテキストエディターのほとんどの部分は、Emacs
Lispと呼ばれるプログラミング言語で記述されています。新し
いコードをEmacs Lispで記述して、このエディターの拡張とし
てインストールできます。しかしEmacs Lispは、単なる“拡張
言語”を越えた言語であり、それ自体で完全なコンピューター
プログラミング言語です。他のプログラミング言語で行なうす
べてのことに、この言語を使用できます。

   Emacs Lispはエディターの中で使用するようにデザインさ
れているので、テキストのスキャンやパースのための特別な機
能をもち、同様にファイル、バッファー、ディスプレー、サブ
プロセスを処理する機能をもちます。Emacs Lispは編集機能と
密に統合されています。したがって編集コマンドはLispプログ
ラムから簡単に呼び出せる関数であり、カスタマイズのための
パラメーターは普通のLisp変数です。

   このマニュアルはEmacs Lispの完全な記述を試みます。初
心者のためのEmacs Lispのイントロダクションは、Free
Software Foundationからも出版されている、Bob Chassellの
‘An Introduction to Emacs Lisp Programming’を参照してく
ださい。このマニュアルは、Emacsを使用した編集に熟知して
いることを前提としています。これの基本的な情報については
、‘The GNU Emacs Manual’を参照してください。

   おおまかに言うと、前の方のチャプターでは多くのプログ
ラミング言語に対応するEmacs Lispの機能について説明し、後
のチャプターではEmacs Lispに特異な機能や、特に編集に関連
した機能を説明します。

   これは Emacs 24.5に対応した‘GNU Emacs Lisp Reference
Manual’です。

* Menu:

* Caveats::                  不備な点と、助けを求める方法。
* Lisp History::             Emacs LispはMaclispが由来です。
* Conventions::              このマニュアルがフォーマットされた方法。
* Version Info::             実行中のEmacsのバージョンは?
* Acknowledgments::          このマニュアルの著者、編集者、スポンサー。


File: elisp,  Node: Caveats,  Next: Lisp History,  Up: Introduction

1.1 Caveats
===========

このマニュアルは幾多のドラフトを経てきました。ほとんど完
璧ではありますが、不備がないとも言えません。(ほとんどの
特定のモードのように)それらが副次的であるとか、まだ記述
されていないという理由により、カバーされていないトピック
もあります。わたしたちがそれらを完璧に扱うことはできない
ので、いくつかの部分は意図的に省略しました。

   このマニュアルは、それがカバーしている事柄については
完全に正しくあるべきあり、故に、特定の説明テキスト、チャ
プターやセクションの順番にたいしての批判に開かれているべ
きです。判りにくかったり、このマニュアルでカバーされてい
ない何かを学ぶためにソースを見たり実験から学ぶ必要がある
なら、このマニュアルはおそらくフィクスされるべきなのかも
しれません。わたしたちにそれを教えてください。

   このマニュアルを使用するときは、間違いを見つけたらす
ぐに訂正を送ってください。関数または間数グループの単純な
現実例を考えたときは、ぜひそれを記述して送ってください。
それが妥当ならコメントでノード名と関数名や変数名を参照し
てください。あなたが訂正を求めるエディションのバージョン
も示してください。

   ‘M-x report-emacs-bug’を使用してコメントや訂正を送っ
てください。


File: elisp,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Lisp History
================

Lisp(LISt Processing language: リスト処理言語)は、
MIT(Massachusetts Institute of Technology: マサチューセ
ッツ工科大学)で、AI(artificial intelligence: 人工知能)の
研究のために、1950年代末に最初に開発されました。Lisp言語
の強力なパワーは、編集コマンドの記述のような、他の目的に
も適っています。

   長年の間に何ダースものLisp実装が構築されてきて、それ
ぞれ特異な点があります。これらの多くは、1960年代にMITの
Project MACで記述された、Maclispに影響を受けています。最
終的に、Maclisp後裔の実装者は共同して、Common Lispと呼ば
れる標準のLispシステムを開発しました。その間に、MITの
Gerry SussmanとGuy Steeleにより、簡潔だがとても強力な
Lisp方言である、Schemeが開発されました。

   GNU Emacs LispはMaclispから多く、Common Lispから少し
影響を受けています。Common Lispを知っている場合、多くの
類似点に気がつくでしょう。しかしCommon Lispの多くの機能
は、GNU Emacsが要求するメモリー量を削減するために、省略
されるか単純化されています。ときには劇的に単純化がされて
いるために、Common Lispユーザーは混乱するかもしれません
。わたしたちは時折GNU Emacs LispがCommon Lispと異なるか
示すでしょう。Common Lispを知らない場合、それについて心
配する必要はありません。このマニュアルは自己完結していま
す。

   ‘cl-lib’ライブラリーを通じて、Common Lispをかなりエミ
ュレートできます。*note Overview: (cl)Top.を参照してくだ
さい。

   Emacs LispはSchemeの影響は受けていません。しかしGNUプ
ロジェクトにはGuileと呼ばれるScheme実装があります。拡張
が必要な新しいGNUソフトウェアーでは、Guileを使用します。


File: elisp,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

1.3 Conventions
===============

このセクションでは、このマニュアルで使用する表記規約を説
明します。あなたはこのセクションはスキップして、後で参照
したいと思うかもしれません。

* Menu:

* Some Terms::               このマニュアルで使用する用語の説明。
* nil and t::                シンボル‘nil’と‘t’の使用方法。
* Evaluation Notation::      評価の例で使用するフォーマット。
* Printing Notation::        テキストのプリント例で使用するフォーマット。
* Error Messages::           エラー例で使用するフォーマット。
* Buffer Text Notation::     例のバッファー内容で使用するフォーマット。
* Format of Descriptions::   関数や変数などの説明にたいする表記。


File: elisp,  Node: Some Terms,  Next: nil and t,  Up: Conventions

1.3.1 Some Terms
----------------

このマニュアルでは、“Lispリーダー”および“Lispプリンター
”という用語で、Lispのテキスト表現を実際のLispオブジェク
トに変換したり、その逆を行なうLispルーチンを参照します。
詳細については、*note Printed Representation::を参照して
ください。あなた、つまりこのマニュアルを読んでいる人のこ
とは“プログラマー”と考えて“あなた”と呼びます。“ユーザー
”とは、あなたの記述したものも含めて、Lispプログラムを使
用する人を指します。

   Lispコードの例は、‘(list 1 2 3)’のようなフォーマット
です。 Examples of Lisp code are formatted like this:
‘(list 1 2 3)’. メタ構文変数(metasyntactic variables)を
表す名前や、説明されている関数の引数名前は、
FIRST-NUMBERのような形式です。


File: elisp,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 ‘nil’ and ‘t’
-------------------

Emacs Lispでは、シンボル‘nil’には3つの異なる意味がありま
す。1つ目は‘nil’という名前のシンボル、2つ目は論理値の
FALSE、3つ目は空リスト — つまり要素が0のリストです。変数
として使用した場合、‘nil’は常に値‘nil’をもちます。

   Lispリーダーに関する限り、‘()’と‘nil’は同一です。これ
らは同じオブジェクト、つまりシンボル‘nil’を意味します。
このシンボルを異なる方法で記述するのは、完全に人間の読み
手を意図したものです。Lispリーダーが‘()’か‘nil’のどちら
かを読み取った後は、プログラマーが実際にどちらの表現で記
述したかを判断する方法はありません。

   このマニュアルでは、空リストを意味することを強調した
いときは‘()’と記述し、論理値のFALSEを意味することを強調
したいときは‘nil’と記述します。この慣習はLispプログラム
で使用してもよいでしょう。

     (cons 'foo ())                ; 空リストを強調します
     (setq foo-flag nil)           ; 論理値のFALSEを強調します

   論理値が期待されているコンテキストでは、非‘nil’は
TRUEと判断されます。しかし論理値のTRUEを表す好ましい方法
は‘t’です。TRUEを表す値を選択する必要があり、他に選択の
根拠がない場合は、‘t’を使用してください。シンボル‘t’は、
常に値‘t’をもちます。

   Emacs Lispでは、‘nil’と‘t’は、常に自分自身を評価する
、特別なシンボルです。そのためプログラムでこれらを定数と
して使用する場合、クォートする必要はありません。これらの
値を変更使用と試みると、結果は‘setting-constant’エラーと
なります。*note Constant Variables::を参照してください。

 -- Function: booleanp object
     OBJECTが、2つのカノニカルなブーリーン値(‘t’または
     ‘nil’)の場合は、非‘nil’をリターンします。


File: elisp,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

1.3.3 Evaluation Notation
-------------------------

評価することができるLisp式のことを、“フォーム(form)”と呼
びます。フォームの評価により、常に結果としてLispオブジェ
クトが生成されます。このマニュアルの例では、これを‘⇒’で
示します:

     (car '(1 2))
          ⇒ 1

これは、“‘(car '(1 2))’を評価すると1になる”と読むことが
できます。

   フォームがマクロ呼び出しの場合、それは評価されるため
の新しいLispのフォームに展開されます。展開された結果は
‘↦’で示します。展開されたフォームを評価した結果を示すこ
ともあれば、示さない場合もあります。

     (third '(a b c))
          ↦ (car (cdr (cdr '(a b c))))
          ⇒ c

   1つのフォームを説明するために、同じ結果を生成する別の
フォームを示すこともあります。完全に等価な2つのフォーム
は、‘≡’で示します。

     (make-sparse-keymap) ≡ (list 'keymap)


File: elisp,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.4 Printing Notation
-----------------------

このマニュアルの例の多くは、それらが評価されるときにテキ
ストをプリントします。(‘*scratch*’バッファーのような
)Lisp Interactionバッファーでコード例を実行する場合、プ
リントされるテキストはそのバッファーに挿入されます。(関
数‘eval-region’で評価するなど)他の方法でコード例を実行す
る場合、プリントされるテキストはエコーエリアに表示されま
す。

   このマニュアルの例はプリントされるテキストがどこに出
力されるかに関わらず、それを‘⊣’で示します。フォームを評
価することにより戻される値は、‘⇒’とともに後続の行で示し
ます。

     (progn (prin1 'foo) (princ "\n") (prin1 'bar))
          ⊣ foo
          ⊣ bar
          ⇒ bar


File: elisp,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

1.3.5 Error Messages
--------------------

エラーをシグナルする例も、いくつかあります。これは通常、
エコーエリアにエラーメッセージを表示します。エラーメッセ
ージの行は、‘error→’で始まります。‘error→’自体は、エコー
エリアに表示されないことに注意してください。

     (+ 23 'x)
     error→ Wrong type argument: number-or-marker-p, x


File: elisp,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.6 Buffer Text Notation
--------------------------

バッファー内容の変更を説明する例もあり、それらの例ではテ
キストの“before(以前)”と“after(以後)”のバージョンを示し
ます。それらの例では、バッファー内容の該当する部分を、ダ
ッシュを用いた2行の破線(バッファー名を含む)で示します。
さらに、‘★’はポイントの位置を示します(もちろんポイントの
シンボルは、バッファーのテキストの一部ではなく、それはポ
イントが現在配されている2つの文字の_間_の位置を示します
)。

     ---------- Buffer: foo ----------
     This is the ★contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          ⇒ nil
     ---------- Buffer: foo ----------
     This is the changed ★contents of foo.
     ---------- Buffer: foo ----------


File: elisp,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

1.3.7 Format of Descriptions
----------------------------

このマニュアルでは関数(function)、変数(variable)、コマン
ド(command)、ユーザーオプション(user option)、スペシャル
フォーム(special form)を、統一されたフォーマットで記述し
ます。記述の最初の行には、そのアイテムの名前と、もしあれ
ば引数(argument)が続きます。 そのアイテムの属するカテゴ
リー(function、variableなど)は、行の先頭に表示します。 そ
れ以降の行は説明行で、例を含む場合もあります。

* Menu:

* A Sample Function Description::  架空の関数‘foo’にたいする記述例。
* A Sample Variable Description::  架空の変数‘electric-future-map’にたいする記述例。


File: elisp,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Up: Format of Descriptions

1.3.7.1 A Sample Function Description
.....................................

関数の記述では、関数の名前が最初に記述されます。同じ行に
引数の名前のリストが続きます。引数の値を参照するために、
引数の名前は記述の本文にも使用されます。

   引数リストの中にキーワード‘&optional’がある場合、その
後の引数が省略可能であることを示します(省略された引数の
デフォルトは‘nil’です)。その関数を呼び出すときは、
‘&optional’を記述しないでください。

   キーワード‘&rest’(これの後には1つの引数名を続けなけれ
ばなりません)は、その後に任意の引数を続けることができる
ことを表します。‘&rest’の後に記述された引数名の値には、
その関数に渡された残りのすべての引数がリストとしてセット
されます。この関数を呼び出すときは、‘&rest’を記述しない
でください。

   以下は‘foo’という架空の関数(function)の説明です:

 -- Function: foo integer1 &optional integer2 &rest
          integers
     関数‘foo’はINTEGER2からINTEGER1を減じてから、その結
     果に残りすべての引数を加えます。INTEGER2が与えられ
     なかった場合、デフォルトして数値19が使用されます。

          (foo 1 5 3 9)
               ⇒ 16
          (foo 5)
               ⇒ 14

     より一般的には、

          (foo W X Y...)
          ≡
          (+ (- X W) Y...)

   慣例として引数の名前には、(たとえばINTEGER、
INTEGER1、BUFFERのような)期待されるタイプ名が含めます。
(BUFFERSのような)複数形のタイプは、しばしばそのタイプの
オブジェクトのリストを意味します。OBJECTのような引き数名
は、それが任意のタイプであることを表します(Emacsオブジェ
クトタイプのリストは、*note Lisp Data Types::を参照して
ください)。他の名前をもつ引数(たとえばNEW-FILE)は、関数
に固有の引数で、関数がドキュメント文字列をもつ場合、引数
のタイプはその中で説明されるべきです(*note
Documentation::を参照してください)。

   ‘&optional’や‘&rest’により修飾される引数の、より完全
な説明は、*note Lambda Expressions::を参照してください。

   コマンド(command)、マクロ(macro)、スペシャルフォーム
(special form)の説明も同じフォーマットをもちますが、
‘Function’が‘Command’、‘Macro’、‘Special Form’に置き換え
られます。コマンドは単にインタラクティブに呼び出すことが
できる関数です。マクロは関数とは違う方法(引数は評価され
ません)で引数を処理しますは、同じ方法で記述されます。

   マクロとスペシャルフォームにたいする説明には、特定の
オプション引数や繰り替えされる引数のために、より複雑な表
記が使用されます。なぜなら引数リストが、より複雑な方法で
別の引数に分離されるからです。‘[OPTIONAL-ARG]’は
OPTIONAL-ARGがオプションであることを意味し、
‘REPEATED-ARGS...’は0個以上の引数を表します。カッコ
(parentheses)は、複数の引数をリスト構造の追加レベルにグ
ループ化するのに使用されます。以下は例です:

 -- Special Form: count-loop (var [from to [inc]])
          body...
     この架空のスペシャルフォームは、 BODYフォームを実行
     してから変数VARをインクリメントするループを実装しま
     す。最初の繰り返しでは変数は値FROMをもちます。以降
     の繰り返しでは、変数は1(INCが与えられた場合はINC)増
     加されます。VARがTOに等しい場合、BODYを実行する前に
     ループをexitします。以下は例です:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOが省略された場合、ループを実行する前にVARに
     ‘nil’がバインドされ、繰り返しの先頭においてVARが非
     ‘nil’の場合は、ループをexitします。以下は例です:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは、引数FROMおよびTOはオプ
     ションですが、両方を指定するか、両方を未指定にしな
     ければなりません。これらの引数が与えられた場合、オ
     プションでINCも同様に指定することができます。これら
     の引数は、フォームのすべての残りの要素を含むBODYと
     区別するために、引数VARとともにリストにグループ化さ
     れます。


File: elisp,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

1.3.7.2 A Sample Variable Description
.....................................

“変数(variable)”とは、オブジェクトに“バインド(bind)”(ま
たは“set”)される名前です。変数がバインドされたオブジェク
トのことを“値(value)”と呼びます。このような場合、その変
数が値をもつ、という言い方もします。ほとんどすべての変数
はユーザーがセットすることができますが、特にユーザーが変
更できる特定の変数も存在し、これらは“ユーザーオプション
(user options)”と呼ばれます。通常の変数およびユーザーオ
プションは、関数と同様のフォーマットを使用して説明されま
すが、それらには引数がありません。

   以下は架空の変数‘electric-future-map’にたいする説明で
す。

 -- Variable: electric-future-map
     この変数の値はElectric Command Futureモードで使用さ
     れる完全なキーマップです。このマップの関数により、
     まだ実行していないコマンドの編集が可能になります。

   ユーザーオプションも同じフォーマットをもちますが、
‘Variable’が‘User Option’に置き換えられます。


File: elisp,  Node: Version Info,  Next: Acknowledgments,  Prev: Conventions,  Up: Introduction

1.4 Version Information
=======================

以下の機能は使用しているEmacsに関する情報を提供します。

 -- Command: emacs-version &optional here
     この関数は実行しているEmacsのバージョンを説明する文
     字列をreturnそます。バグレポートにこの文字列を含め
     るときに役立ちます。

          (emacs-version)
            ⇒ "GNU Emacs 23.1 (i686-pc-linux-gnu, GTK+ Version 2.14.4)
                       of 2009-06-01 on cyd.mit.edu"

     HEREが非‘nil’の場合、関数はテキストをバッファーのポ
     イントの前に挿入し、‘nil’をreturnします。この関数が
     インタラクティブに呼び出された場合は、同じ情報をエ
     コーエリアに出力しますが、プレフィクス引数を与えた
     場合は、HEREが非‘nil’になります。

 -- Variable: emacs-build-time
     この変数の値は、Emacsがビルドされた日時を示します。
     値は、‘current-time’の値と同様の、4つの整数からなる
     リストです(*note Time of Day::を参照してください)。

          emacs-build-time
               ⇒ (20614 63694 515336 438000)

 -- Variable: emacs-version
     この変数の値は実行中のEmacsのバージョンで、
     ‘"23.1.1"’のような文字列です。この文字列の最後の数
     字は、実際にはEmacsのリリースバージョン番号の一部で
     はなく、任意のディレクトリーにおいてEmacsがビルドさ
     れる度にインクリメントされます。‘"22.0.91.1"’のよう
     に4つの数字から構成される値は、それがリリースではな
     いテストバージョンであることを示します。

 -- Variable: emacs-major-version
     Emacsのメジャーバージョン番号を示す整数です。Emacs
     23.1では、値は23になります。

 -- Variable: emacs-minor-version
     Emacsのマイナーバージョン番号をしめす整数です。
     Emacs 23.1では、値は1になります。


File: elisp,  Node: Acknowledgments,  Prev: Version Info,  Up: Introduction

1.5 Acknowledgments
===================

このマニュアルは当初、Robert Krawitz、Bil Lewis、Dan
LaLiberte、Richard M. Stallman、Chris Welty、GNUマニュア
ルグループのボランティアーにより、数年を費やして記述され
ました。Robert J. Chassellはこのマニュアルのレビューと編
集をDefense Advanced Research Projects Agency、ARPA
Order 6082のサポートのもとに手助けしてくれ、
Computational Logic, IncのWarren A. Hunt, Jr.によりアレ
ンジされました。それ以降も、追加のセクションがMiles
Bader、Lars Brinkhoff、Chong Yidong、Kenichi Handa、Lute
Kamstra、Juri Linkov、Glenn Morris、Thien-Thi Nguyen、
Dan Nicolaescu、Martin Rudalics、Kim F. Storm、Luc
Teirlinck、Eli Zaretskii、およびその他の人たちにより記述
されました。

   Drew Adams、Juanma Barranquero、Karl Berry、Jim
Blandy、Bard Bloom、Stephane Boucher、David Boyes、Alan
Carroll、Richard Davis、Lawrence R. Dodd、Peter
Doornbosch、David A. Duff、Chris Eich、Beverly
Erlebacher、David Eckelkamp、Ralf Fassel、Eirik Fuller、
Stephen Gildea、Bob Glickstein、Eric Hanchrow、Jesper
Harder、George Hartzell、Nathan Hess、Masayuki Ida、Dan
Jacobson、Jak Kirman、Bob Knighten、Frederick M. Korz、
Joe Lammens、Glenn M. Lewis、K. Richard Magill、Brian
Marick、Roland McGrath、Stefan Monnier、Skip Montanaro、
John Gardiner Myers、Thomas A. Peterson、Francesco
Potortì、Friedrich Pukelsheim、Arnold D. Robbins、Raul
Rockwell、Jason Rumney、Per Starbäck、Shinichirou Sugou、
Kimmo Suominen、Edward Tharp、Bill Trost、Rickard
Westman、Jean White、Eduard Wiebe、Matthew Wilding、Carl
Witty、Dale Worley、Rusty Wright、David D. Zuhnにより訂
正が提供されました。

   より完全な貢献者のリストは、Emacsソースリポジトリーの
関連する変更ログエントリーを参照してください。


File: elisp,  Node: Lisp Data Types,  Next: Numbers,  Prev: Introduction,  Up: Top

2 Lisp Data Types
*****************

Lispの“オブジェクト(object)”とは、Lispおプログラムにより
操作されるデータです。“型(type)”や“データ型(data type)”は
、可能なオブジェクトの集合を意味します。

   すべてのオブジェクトは少なくとも1つの型に属します。同
じ型のオブジェクトは、同様な構造をもち、通常は同じコンテ
キストで使用されます。型は重複でき、オブジェクトは複数の
型に属することができます。結果として、あるオブジェクトが
特定の型に属するかどうかを尋ねることはできますが、オブジ
ェクトが“その”型だけに属するかどうかは決定できません。

   多くはありませんがEmacsにはいくつかの基本オブジェクト
型が組み込まれています。これらの型は、他のすべての型を構
成するもとであり、“基本型(primitive types)”と呼ばれます
。すべてのオブジェクトはただ1つの基本型に属します。これ
らの型には、“整数(integer)”、“浮動小数点数(float)”、“コ
ンス(cons)”、“シンボル(symbol)”、“文字列(string)”、“ベク
ター(vector)”、“ハッシュテーブル(hash-table)”、“サブルー
チン(subr)”、“バイトコード関数(byte-code function)”、お
よび“buffer”のような編集に関連した特別な型(*note Editing
Types::を参照してください)が含まれます。

   基本型にはそれぞれ、オブジェクトがその型のメンバーか
どうかのチェックを行なう、対応するLisp関数があります。

   他の多くの言語とは異なり、Lispのオブジェクトは“自己記
述(self-typing)”的です。オブジェクトの基本型は、オブジェ
クト自体に暗に含まれます。たとえばオブジェクトがベクター
の場合、それを数字として扱うことはできません。Lispはベク
ターが数字でないことを知っているのです。

   多くの言語では、プログラマーは各変数にたいしてデータ
型を宣言しなければならず、コンパイラーは型を知っています
が、データの中に型はありません。Emacs Lispには、このよう
な型宣言はありません。Lisp変数は任意の型の値をもつことが
でき、変数に保存した値と型を記憶します(実際には、特定の
型の値だけをもつことができる少数のEmacs Lisp変数がありま
す。*note Variables with Restricted Values::を参照してく
ださい)。

   このチャプターでは、GNU Emacs Lispの各標準型の意味、
プリント表現(printed representation)、入力構文(read
syntax)を説明します。これらのデータ型を使用する方法につ
いての詳細は、以降のチャプターを参照してください。

* Menu:

* Printed Representation::   Lispオブジェクトがテキストとして表現される方法。
* Comments::                 コメントとコメント書式の慣例。
* Programming Types::        すべてのLispシステムに存在する型。
* Editing Types::            Emacs固有の型。
* Circular Objects::         循環構造にたいする入力構文。
* Type Predicates::          型に関連するテスト。
* Equality Predicates::      2つのオブジェクトが等しいかのテスト。


File: elisp,  Node: Printed Representation,  Next: Comments,  Up: Lisp Data Types

2.1 Printed Representation and Read Syntax
==========================================

オブジェクトのプリント表現(printed representation)とは、
オブジェクトにたいしてLispプリンター(関数‘prin1’)が生成
する出力のフォーマットです。すべてのデータ型は一意なプリ
ント表現をもちます。オブジェクトの“入力構文(read
syntax)”とは、オブジェクトにたいしてLispリーダー(関数
‘read’)が受け取る入力のフォーマットです。これは一意であ
る必要はありません。多くの種類のオブジェクトが複数の構文
をもちます。*note Read and Print::を参照してください。

   ほとんどの場合、オブジェクトのプリント表記が、入力構
文としても使用されます。しかしLispプログラム内の定数とす
ることに意味が無いいくつかの型には、入力構文がありません
。これらのオブジェクトは“ハッシュ表記(hash notation)”で
プリントされ、‘#<’、説明的な文字列(典型的には型名にオブ
ジェクトの名前を続けたもの)、‘>’で構成される文字列です。
たとえば:

     (current-buffer)
          ⇒ #<buffer objects.texi>

ハッシュ表気は読み取ることができないので、Lispリーダーは
‘#<’に遭遇すると、常にエラー‘invalid-read-syntax’をシグ
ナルします。

   他の言語では、式はテキストであり、これ以外の形式はあ
りません。Lispでは、第一に式はLispオブジェクトであって、
オブジェクトの入力構文であるテキストは副次的なものに過ぎ
ません。たいてい、この違いを強調する必要はありませんが、
このことを心に留めておかないと、たまに混乱することがある
でしょう。

   インタラクティブに式を評価するとき、Lispインタープリ
ターは最初にそれのテキスト表現を読み取り、Lispオブジェク
トを生成してから、そのオブジェクトを評価します(*note
Evaluation::を参照してください)。しかし評価と読み取りは
、別の処理です。読み取りによりテキストにより表現された
Lispオブジェクトを読み取り、Lispオブジェクトがreturnされ
ます。後でオブジェクトは評価されるかもしれないし、評価さ
れないかもしれません。オブジェクトを読み取るための基本的
な関数‘read’の説明は、*note Input Functions::を参照して
ください。


File: elisp,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Lisp Data Types

2.2 Comments
============

“コメント(comment)”hqあ、プログラム中に記述されたテキス
トであり、そのプログラムを読む人間ためだけに存在し、プロ
グラムの意味には何の影響ももちません。Lispでは、それが文
字列や文字定数にある場合をのぞき、セミコロン(‘;’)でコメ
ントが開始されます。行の終端までがコメントになります。
Lispリーダーはコメントを破棄します。コメントはLispシステ
ム内でプログラムを表すLispオブジェクトの一部にはなりませ
ん。

   ‘#@COUNT’構成は、次のCOUNT個の文字をスキップします。
これはプログラムにより生成されたバイナリーデータを含むコ
メントにたいして有用です。Emacs Lisp倍とコンパイラーは、
出力ファイルにこれを使用します(*note Byte Compilation::を
参照してください)。しかしソースファイル用ではありません
。

   コメントのフォーマットにたいする慣例は、*note Comment
Tips::を参照してください。


File: elisp,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Lisp Data Types

2.3 Programming Types
=====================

Emacs Lispには2種類の一般的な型があります。1つはLispプロ
グラミングに関わるもので、もう1つは編集に関わるものです
。前者はさまざまな形で多くのLisp実装に存在します。後者は
Emacs Lispに固有です。

* Menu:

* Integer Type::             小数部のない数字。
* Floating-Point Type::      広い範囲をもつ、小数部をもつ数字。
* Character Type::           文字、数字、コントロール文字にたいする表現。
* Symbol Type::              関数、変数、プロパティーリストを参照する、一意に識別される多目的オブジェクト。
* Sequence Type::            リストと配列はどちらもシーケンスに分類されます。
* Cons Cell Type::           コンスセル、および(コンスセルにより作られる)リスト。
* Array Type::               配列には文字列とベクターが含まれます。
* String Type::              (効率的な)文字の配列。
* Vector Type::              1次元の配列。
* Char-Table Type::          文字によりインデックスされる1次元の疎な配列。
* Bool-Vector Type::         ‘t’と‘nil’からなる、1次元の配列。
* Hash Table Type::          とても高速な参照用のテーブル。
* Function Type::            他の場所から呼び出せる実行可能なコードの断片。
* Macro Type::               より基本的だが少し見栄えの悪い、式を他の式に展開する手法。
* Primitive Function Type::  Lispから呼び出せる、Cで記述された関数。
* Byte-Code Type::           Lispで記述されてからコンパイルされた関数。
* Autoload Type::            頻繁に使用されない関数を自動的にロードするために使用される型。


File: elisp,  Node: Integer Type,  Next: Floating-Point Type,  Up: Programming Types

2.3.1 Integer Type
------------------

整数の値の範囲はマシンに依存します、最小のレンジは
−536,870,912から536,870,911(30ビットでは −2**29 から
2**29 − 1) ですが、多くのマシンはこれより広い範囲を提供
します。Emacs Lispの数学関数は整数のオーバーフローをチェ
ックしません。したがってEmacsのh整数が30ビットの場合、
‘(1+ 536870911)’は−536,870,912になります。

   整数にたいする入力構文は、(10を基数とする)数字のシー
ケンスで、オプションで先頭に符号、最後にピリオドがつきま
す。Lispインタープリターにより生成されるプリント表記には
、先頭の ‘+’や、最後の‘.’はありません。

     -1               ; 整数の−1.
     1                ; 整数の1.
     1.               ; これも整数の1.
     +1               ; これも整数の1.

特別な例外として、数字シーケンスが有効なオブジェクトとし
ては大きすぎる、または小さすぎる整数を指定する場合、
Lispリーダーはそれを浮動小数点数(*note Floating-Point
Type::を参照してください)として読み取ります。たとえば、
Emacsの整数が30ビットの場合、‘536870912’は浮動小数点数の
‘536870912.0’として読み取られます。

   詳細は、*note Numbers::を参照してください。


File: elisp,  Node: Floating-Point Type,  Next: Character Type,  Prev: Integer Type,  Up: Programming Types

2.3.2 Floating-Point Type
-------------------------

浮動小数点数は、コンピューターにおける科学表記に相当する
ものです。浮動小数点数を10の指数をともなう有理数として考
えることができます。正確な有効桁数と可能な指数は、マシン
固有です。Emacsは値の保存にCデータ型の‘double’を使用し、
内部的には10の指数ではなく、2の指数として記録します。

   浮動小数点数のプリント表現には、(後に最低1つの数字を
ともなう)小数点と、指数のどちらか一方、または両方が必要
です。たとえば‘1500.0’、‘+15e2’、‘15.0e+2’、
‘+1500000e-3’、‘.15e4’は、いずれも浮動小数点数の1500を記
述し、これらはすべて等価です。

   詳細は、*note Numbers::を参照してください。


File: elisp,  Node: Character Type,  Next: Symbol Type,  Prev: Floating-Point Type,  Up: Programming Types

2.3.3 Character Type
--------------------

Emacs Lispでの“文字(character)”は、整数以外の何者でもあ
りません。他の言い方をすると、文字は文字コードで表現され
ます。たとえば文字‘A’は、整数の65として表現されます。

   プログラムで文字を個別に使用するのは稀であり、文字の
シーケンスとして構成される_文字列(strings)_として扱われ
るのがより一般的です。*note String Type::を参照してくだ
さい。

   文字列やバッファーの中の文字は、現在のところ0から
4194303の範囲 — つまり22ビットに制限されています(*note
Character Codes::を参照してください)。0から127のコードは
ASCIIコードで、残りは非ASCIIです(*note Non-ASCII
Characters::を参照してください)。キーボード入力を表す文
字は、Control、Meta、Shiftなどの修飾キーをエンコードする
ために、より広い範囲をもちます。

   メッセージのために、文字にたいして人間が読むことがで
きるテキストによる説明を生成する特別な関数が存在します。
*note Describing Characters::を参照してください。

* Menu:

* Basic Char Syntax::        標準的な文字の構文。
* General Escape Syntax::    文字をコードにより指定する方法。
* Ctl-Char Syntax::          コントロール文字の構文。
* Meta-Char Syntax::         メタ文字の構文。
* Other Char Bits::          ハイパー、スーパー、アルト文字の構文。


File: elisp,  Node: Basic Char Syntax,  Next: General Escape Syntax,  Up: Character Type

2.3.3.1 Basic Char Syntax
.........................

文字は実際には整数なので、文字のプリント表現は10進数です
。文字にたいする入力構文も利用可能ですが、Lispプログラム
でこの方法により文字を記述するのは、明解なプログラミング
ではありません。文字にたいしては、Emacs Lispが提供する、
特別な入力構文を_常に_使用するべきです。これらの構文フォ
ーマットはクエスチョンマークで開始されます。

   英数字にたいする通常の入力構文は、クエスチョンマーク
と、その後にその文字を記述します。したがって文字‘A’にた
いしては‘?A’、文字‘B’にたいしては‘?B’、文字‘a’にたいして
は‘?a’となります。

   たとえば:

     ?Q ⇒ 81     ?q ⇒ 113

   句読点文字にも同じ構文を使用できますが、Lispコードを
編集するためのEmacsコマンドが混乱しないように、‘\’を追加
するのがよい場合がしばしばあります。たとえば開きカッコを
記述するために‘?\(’と記述します。その文字が‘\’の場合、そ
れをクォートするために、‘?\\’のように2つ目の‘\’を使用し
なければ_なりません_。

   control-g、backspace、tab、newline、vertical tab、
formfeed、space、return、del、escapeはそれぞれ‘?\a’、
‘?\b’、‘?\t’、‘?\n’、‘?\v’、‘?\f’、‘?\s’、‘?\r’、‘?\d’、
‘?\e’と表すことができます(後にダッシュのついた‘?\s’は違
う意味をもちます — これは後続の文字にたいして“super”の修
飾を適用します)。したがって、

     ?\a ⇒ 7                 ; control-g, ‘C-g’
     ?\b ⇒ 8                 ; backspace, <BS>, ‘C-h’
     ?\t ⇒ 9                 ; tab, <TAB>, ‘C-i’
     ?\n ⇒ 10                ; newline, ‘C-j’
     ?\v ⇒ 11                ; vertical tab, ‘C-k’
     ?\f ⇒ 12                ; formfeed character, ‘C-l’
     ?\r ⇒ 13                ; carriage return, <RET>, ‘C-m’
     ?\e ⇒ 27                ; escape character, <ESC>, ‘C-[’
     ?\s ⇒ 32                ; space character, <SPC>
     ?\\ ⇒ 92                ; backslash character, ‘\’
     ?\d ⇒ 127               ; delete character, <DEL>

   バックスラッシュが“エスケープ文字(escape character)”の
役割を果たすので、これらのバックスラッシュで始まるシーケ
ンスは“エスケープシーケンス(escape sequences)”とも呼ばれ
ます。この用語法は、文字<ESC>とは関係ありません。‘\s’は
文字定数としての使用を意図しており、文字定数の内部では、
単にスペースを記述します。

   エスケープという特別な意味を与えずに、任意の文字の前
にバックスラッシュの使用することは許されており、害もあり
ませんしたがって‘?\+’は‘?+’と等価です。ほとんどの文字の
前にバックスラッシュを追加することに理由はありません。し
かし、Lispコードを編集するEmacsコマンドが混乱するのを避
けるために、文字‘()\|;'`"#.,’の前にはバックスラッシュを
追加するべきです。space、tab、newline、formfeedのような
空白文字の前にもバックスラッシュを追加できます。しかし、
tabやspaceのような実際の空白文字のかわりに、‘\t’や‘\s’の
ような可読性のあるエスケープシーケンスを使用するほうが明
解です(スペースを後にともなうバックスラッシュを記述する
場合、後続のテキストと区別するために、文字定数の後に余分
なスペースを記述するべきです)。


File: elisp,  Node: General Escape Syntax,  Next: Ctl-Char Syntax,  Prev: Basic Char Syntax,  Up: Character Type

2.3.3.2 General Escape Syntax
.............................

特に重要なコントロール文字にたいする特別なエスケープシー
ケンスに加えて、Emacsは非ASCIIテキスト文字の指定に使用で
きる、何種類かのエスケープ構文を提供します。

   最初に、文字をUnicodeの値で指定することができます。
‘?\uNNNN’はUnicodeのコードポイント‘U+NNNN’の文字を表しま
す。ここでNNNNは、(慣例により)正確に4桁の16進数です。バ
ックスラッシュは、後続の文字がエスケープシーケンスを形成
することを示し、‘u’はUnicodeエスケープシーケンスを指定し
ます。

   ‘U+FFFF’より大きなコードポイントをもつUnicode文字を指
定するために、若干異なる構文が存在します。
‘?\U00NNNNNN’はコードポイント‘U+NNNNNN’の文字を表します
。ここでNNNNNNは6桁の16進数です。Unicode Standardは
‘U+10FFFF’までのコードポイントだけを定義するので、これよ
り大きいコードポイントを指定すると、Emacsはエラーをシグ
ナルします。

   次に、文字を16進の文字コードで指定できます。16進エス
ケープシーケンスは、バックスラッシュ、‘x’、および16進の
文字コードにより構成されます。したがって‘?\x41’は文字
‘A’、‘?\x1’は文字‘C-a’、‘?\xe0’は grave accentつきの文字
‘a’を表します。 任意の数の16進数を使用できるので、この方
法により任意の文字コードを表すことができます。

   最後に、8進の文字コードにより文字を指定できます。8進
エスケープシーケンスは、3桁までの8進数字をともなうバック
スラッシュにより形成されます。したがって‘?\101’は文字
‘A’、‘?\001’は文字‘C-a’、‘?\002’は文字‘C-b’を表します。
この方法で指定できるのは、8進コード777までの文字だけです
。

   これらのエスケープシーケンスは、文字列内でも使用され
ます。*note Non-ASCII in Strings::を参照してください。


File: elisp,  Node: Ctl-Char Syntax,  Next: Meta-Char Syntax,  Prev: General Escape Syntax,  Up: Character Type

2.3.3.3 Control-Character Syntax
................................

他の入力構文を使用してコントロール文字を表すことができま
す。これは後にバックスラッシュ、カレット、対応する非コン
トロール文字(大文字か小文字)をともなうクエスチョンマーク
から構成されます。たとえば‘?\^I’と‘?\^i’はどちらも、値が
9である文字‘C-i’にたいする、有効な入力構文です。

   ‘^’のかわりに、‘C-’を使用することもできます。したがっ
て‘?\C-i’は、‘?\^I’や‘?\^i’と等価です。

     ?\^I ⇒ 9     ?\C-I ⇒ 9

   文字列やバッファーの中では、ASCIIのコントロール文字だ
けが許されますが、キーボード入力にたいしては‘C-’により任
意の文字をコントロール文字にすることができます。これらの
非ASCIIのコントロール文字にたいするコントロール文字には
非コントロール文字にたいするコードと同様に、2**26 ビット
が含まれます。通常のテキスト端末には、非ASCIIコントロー
ル文字を生成する方法がありませんが、Xおよび他のウィンド
ウシステムを使用することにより、簡単に生成することができ
ます。

   歴史的な理由により、Emacsは<DEL>文字を、‘?’のコントロ
ール文字として扱います:

     ?\^? ⇒ 127     ?\C-? ⇒ 127

結果として、Xでは有意な入力文字である‘Control-?’文字を、
‘\C-’を使用して表現することは今のところできません。さま
ざまなLispファイルがこの方法により<DEL>を参照するため、
これを変更するのは簡単ではありません。

   コントロール文字の表現はファイルや文字列のなかで見る
ことができますが、わたしたちは‘^’構文を推奨します。キー
ボード入力にたいするコントロール文字に好ましいのは、
‘C-’構文です。どちらを使用するかはプログラムの意味に影響
しませんが、プログラムを読む人の理解を助けるでしょう。


File: elisp,  Node: Meta-Char Syntax,  Next: Other Char Bits,  Prev: Ctl-Char Syntax,  Up: Character Type

2.3.3.4 Meta-Character Syntax
.............................

“メタ文字(meta character)”とは、<META>修飾キーとともにタ
イプされた文字です。そのような文字を表す整数には 2**27 の
ビットがセットされています。基本的な文字コードの広い範囲
を利用可能にするために、メタや他の修飾にたいして上位ビッ
トを使用します。

   文字列では、メタ文字を示すASCII文字に、 2**7 ビットが
付加されます。したがって文字列に含めることができるメタ文
字のコードは1から255の範囲となり、メタ文字は通常の
ASCII文字のメタ修飾されたバージョンとなります。文字列内
での<META>処理の詳細については、*note Strings of
Events::を参照してください。

   メタ文字の入力構文には‘\M-’を使用します。たとえば
‘?\M-A’は‘M-A’を意味します。8進文字コード(以下参照)や、
‘\C-’、その他の文字にたいする他の構文とともに‘\M-’を使用
できます。したがって、‘M-A’は‘?\M-A’や‘?\M-\101’と記述で
きます。同様に、‘C-M-b’は‘?\M-\C-b’、‘?\C-\M-b’、
‘?\M-\002’と記述することができます。


File: elisp,  Node: Other Char Bits,  Prev: Meta-Char Syntax,  Up: Character Type

2.3.3.5 Other Character Modifier Bits
.....................................

グラフィック文字(graphic character)の大文字小文字は、文
字コードで示されます。たとえばASCIIでは、文字‘a’と文字
‘A’は区別されます。しかしASCIIにはコントロール文字が大文
字なのか小文字なのかを表現する方法がありません。コントロ
ール文字がタイプされたときシフトキーが使用されたかを示す
ために、Emacsは 2**25 のビットを使用します。この区別は、
X端末や、他の特別な端末を使用しているときだけ可能です。
通常のテキスト端末は、これらの違いを報告しません。シフト
をあらわすビットのためのLisp構文は‘\S-’です。したがって
‘?\C-\S-o’や‘?\C-\S-O’は、shifted-control-o文字を表しま
す。

   Xウィンドウシステムは文字にセットできる、他に3つ修飾
ビット — “hyper”、“super”、“alt”を定義します。これらのビ
ットにたいする構文は、‘\H-’、‘\s-’、‘\A-’です(これらのプ
レフィクスでは、大文字小文字は意味があります)。したがっ
て‘?\H-\M-\A-x’は‘Alt-Hyper-Meta-x’を表します(‘-’が後に
ない‘\s’は、スペース文字を表すことに注意してください)。
数値的には、ビット値2**22はalt、2**23はsuper、2**24は
hyperです。


File: elisp,  Node: Symbol Type,  Next: Sequence Type,  Prev: Character Type,  Up: Programming Types

2.3.4 Symbol Type
-----------------

GNU Emacs Lispでの“シンボル(symbol)”とは、名前をもつオブ
ジェクトです。シンボル名は、そのシンボルのプリント表現と
しての役割があります。Lispの通常の使用では、1つの
obarray(*note Creating Symbols::を参照してください)によ
り、シンボル名は一意です — 2つのシンボルが同じ名前をもつ
ことはありません。

   シンボルは、変数、関数名としての役割や、プロパティー
リストを保持する役割をもつことができます。他のすべての
Lispオブジェクトから区別するためだけの役割をもつ場合もあ
り、データ構造内にそのようなシンボルが存在することは、確
実に認識されるでしょう。与えられたコンテキストにおいて、
通常はこれらのうちの1つの使用だけが意図されます。しかし
3つすべての方法で、1つのシンボルを独立して使用することも
できます。

   名前がコロン(‘:’)で開始されるシンボルは、“キーワード
シンボル(keyword symbol)”と呼ばれます。これらのシンボル
は自動的に定数として振る舞い、通常は未知のシンボルと、い
くつかの特定の候補を比較することだけに使用されます。
*note Constant Variables::を参照してください。

   シンボル名にはどんな文字でも含めることができます。ほ
とんどのシンボル名は英字、数字、‘-+=*/’などの句読点文字
で記述されます。このような名前には、特別な句読点文字は必
要ありません。名前が数字のように見えない限りは、名前には
どのような文字も使用できます(名前が数字のように見える場
合は、名前の先頭に‘\’を記述して、強制的にシンボルとして
解釈させます)。文字‘_~!@$%^&:<>{}?’はあまり使用されませ
んが、これらも特別な句読点文字を必要としません。他の文字
も、バックスラッシュでエスケープすることにより、シンボル
名に含めることができます。しかし、文字列内でのバックスラ
ッシュの使用とは対照的に、シンボル名でのバックスラッシュ
は、バックスラッシュの後の1文字をエスケープするだけです
。たとえば文字列内では、‘\t’はタブ文字を表します。しかし
シンボル名の中では、‘\t’は英字‘t’をクォートするに過ぎま
せん。 名前にタブ文字をもつシンボルを記述するには、(バッ
クスラッシュを前置した)実際のタブを使用しなければなりま
せん。しかし、そのようなことを行なうことは、めったにあり
ません。

     Common Lispに関する注意:Common Lispでは、明示的にエ
     スケープされない限り、小文字は常に大文字に“フォール
     ドされ(folded)”ます。Emacs Lispでは大文字と小文字は
     区別されます。

   以下はシンボル名の例です。4番目の例の中の‘+’は、シン
ボルが数字として読み取られるのを防ぐために、エスケープさ
れていることに注意してください。6番目の例では、名前の残
りの部分により数字としては不正なので、エスケープの必要は
ありません。

     foo                 ; ‘foo’という名前のシンボル。
     FOO                 ; ‘foo’とは別の、‘FOO’という名前のシンボル。
     1+                  ; ‘1+’という名前のシンボル
                         ;   (整数の‘+1’ではありません)。
     \+1                 ; ‘+1’という名前のシンボル
                         ;   (とても読みやすい名前とはいえません)。
     \(*\ 1\ 2\)         ; ‘(* 1 2)’という名前のシンボル(悪い名前)。
     +-*/_~!@$%^&=:<>{}  ; ‘+-*/_~!@$%^&=:<>{}’という名前のシンボル。
                         ;   これらの文字はエスケープする必要はありません。

   シンボル名がプリント表現としての役割をもつというルー
ルの例外として、‘##’があります。これは、名前が空文字列の
、internされたシンボルのプリント表現です。さらに
‘#:FOO’は、internされていないFOOという名前のシンボルにた
いするプリント表現です(通常、Lispリーダーはすべてのシン
ボルをinternします。*note Creating Symbols::を参照してく
ださい)。


File: elisp,  Node: Sequence Type,  Next: Cons Cell Type,  Prev: Symbol Type,  Up: Programming Types

2.3.5 Sequence Types
--------------------

“シーケンス(sequence)”とは、要素の順序セットを表現する、
Lispオブジェクトです。Emacs Lispには、2種類のシーケンス
— “リスト(lists)”と“配列(arrays)”があります。

   リストはもっとも一般的に使用されるシーケンスです。リ
ストは任意の型の要素を保持でき、要素の追加・削除により簡
単に長さを変更できます。リストについては、次のサブセクシ
ョンを参照してください。

   配列は固定長のシーケンスです。配列はさらに文字列
(strings)、ベクター(vectors)、文字テーブル
(char-tables)、ブールベクター(bool-vectors)に細分されま
す。ベクターは任意の型の要素を保持できますが、文字列の要
素は文字でなければならず、ブールベクターの要素は‘t’か
‘nil’でなければなりません。文字テーブルはベクターと似て
いますが、有効な文字によりインデックスづけされる点が異な
ります。文字列内の文字は、バッファー内の文字のようにテキ
ストプロパティーをもつことができます(*note Text
Properties::を参照してください)。しかしベクターは、その
要素が文字のときでも、テキストプロパティーをサポートしま
せん。

   リスト、文字列、およびその他の配列型も、重要な類似点
を共有します。たとえば、それらはすべて長さLをもち、要素
は0からL−1でインデックスづけされます。いくつかの関数はシ
ーケンス関数と呼ばれ、これらは任意の種類のシーケンスを許
容します。たとえば、関数‘length’は、任意の種類のシーケン
スの長さを報告します。*note Sequences Arrays Vectors::を
参照してください。

   シーケンスは読み取りにより常に新たに作成されるので、
同じシーケンスを2回読み取るのは、一般的に不可能です。シ
ーケンスにたいする入力構文を2回読み取った場合、内容が等
しい2つのシーケンスを得ます。これには1つ例外があります。
空リスト‘()’は、常に同じオブジェクト‘nil’を表します。


File: elisp,  Node: Cons Cell Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

2.3.6 Cons Cell and List Types
------------------------------

“コンスセル(cons cell)”は、CARスロット、CDRスロットと呼
ばれる2つのスロットから構成されるオブジェクトです。各ス
ロットは、任意のLispオブジェクトを“保持”できます。そのと
きCARスロットに保持されるオブジェクトが何であれ、わたし
たちは“このコンスセルのCAR”のような言い方をします。これ
はCDRの場合も同様です。

   “リスト(list)”は、コンスセルの連続するシリーズで、各
コンスセルのCDRスロットは、次のコンスセル、または空リス
トを保持します。空リストは実際にはシンボル‘nil’です。詳
細については、*note Lists::を参照してください。ほとんど
のコンスセルはリストの一部として使用されるので、わたした
ちはコンスセルにより構成される任意の構造を、“リスト構造
(list structure)”という用語で参照します。

     Cプログラマーにたいする注意: Lispのリストはコンスセ
     ルにより構築される、“リンクリスト(linked list)”とし
     て機能します。Lispではポインターは暗黙的なので、わ
     たしたちはコンスセルのスロットが、値を“保持
     (hold)”するのか、それとも値を“指す(point)”のかを区
     別しません。

   コンスセルはLispの中心なので、“コンスセルではないオブ
ジェクト”にたいする単語もあります。これらのオブジェクト
は“アトム(atoms)”と呼ばれます。

   リストにたいする入力構文とプリント表現は等しく、それ
は左カッコ、任意の数の要素、右カコから構成されます。以下
はリストの例です:

     (A 2 "A")            ; 3要素のリスト。
     ()                   ; 要素がないリスト(空リスト)。
     nil                  ; 要素がないリスト(空リスト)。
     ("A ()")             ; 1要素のリスト: 文字列‘"A ()"’。
     (A ())               ; 2要素のリスト: ‘A’と空リスト。
     (A nil)              ; 同上
     ((A B C))            ; 1要素のリスト
                          ;   (この要素は、3要素のリスト)。

   読み取りにおいては、カッコの内側は、リストの要素にな
ります。つまり、コンスセルは各要素から作成されます。コン
スセルのCARスロットは要素を保持し、CDRスロットはリスト内
の次のコンスセル(このコンスセルはリスト内の次の要素を保
持します)を参照します。最後のコンスセルのCDRスロットは、
‘nil’を保持するようにセットされます。

   CAR、CDRという名称は、Lispの歴史に由来します。オリジ
ナルのLisp実装はIBM 704コンピューターで実行されていまし
た。ワードを2つの部分、つまり“address”と呼ばれる部分と、
“decrement”と呼ばれる部分に分割していて、その際CARは
address部から内容を取り出す命令で、CDRはdecrement部から
内容を取り出す命令でした。対照的に“cons cells”は、これら
を作成する関数‘cons’から命名されました。この関数は関数の
目的、すなわちセルを作る(construction of cells)という目
的から命名されました。

* Menu:

* Box Diagrams::             リストを絵で書いたら。
* Dotted Pair Notation::     コンスセルの一般的な構文。
* Association List Type::    特別に構成されるリスト。


File: elisp,  Node: Box Diagrams,  Next: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.1 Drawing Lists as Box Diagrams
.....................................

コンスセルを表現するドミノのような1対のボックスによる図
により、リストを説明することができます(Lispリーダーがこ
のような図を読み取ることはできません。人間およびコンピュ
ーターが理解できるテキスト表記と異なり、ボックスの図は人
間だけが理解できます)。この図は3要素のリスト‘(rose
violet buttercup)’を表したものです:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   この図では、ボックスは任意のLispオブジェクトへの参照
を保持できるスロットを表します。ボックスのペアはコンスセ
ルを表します。矢印はLispオブジェクト(アトム、または他の
コンスセル)への参照を表します。

   この例では、1番目のボックスは1番目のコンスセルで、そ
れのCARは‘rose’(シンボル)を参照または“保持(holds)”します
。2番目のボックスは1番目のコンスセルのCDRを保持し、次の
ボックスペア、すなわち2番目のコンスセルを参照します。2番
目のコンスセルのCARは‘violet’で、CDRは3番目のコンスセル
です。(最後の)3番目のコンスセルのCDRは、‘nil’です。

   同じリスト‘(rose violet buttercup)’を、違うやり方で描
いた別の図で表してみましょう:

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   要素がないリストは“空リスト(empty list)”で、これはシ
ンボル‘nil’と同じです。別の言い方をすると、‘nil’はシンボ
ルであり、リストでもあります。

   以下は、リスト‘(A ())’、または等価な‘(A nil)’をボック
スと矢印で描いたものです:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

   以下はもっと複雑な例です。これは、1番目の要素が2等疎
のリスとである、3要素のリスト‘((pine needles) oak
maple)’を表します:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   同じリストを2番目のボックス表記で表すと、以下のように
なります:

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------


File: elisp,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: Box Diagrams,  Up: Cons Cell Type

2.3.6.2 Dotted Pair Notation
............................

“ドットペア表記(dotted pair notation)”はCARとCDRが明示的
に表されたコンスセルにたいする、一般的な構文です。この構
文では、‘(A . B)’は、CARがオブジェクトAで、CDRがオブジェ
クトBという意味になります。CDRがリスとである必要がないの
で、ドットペア表記は、より一般的なリスト構文です。しかし
キスと構文が機能するでような場合には、より扱いにくくなり
ます。ドットペア表記では、リスト‘(1 2 3)’は、‘(1 . (2 .
(3 . nil)))’と記述されます。‘nil’で終端されたリストにた
いしては、どちらの表記法も使用できますが、リスト表記の方
が、通常は明解で便利です。リストをプリントする場合、コン
スセルのCDRがリスとでないときだけ、ドットペア表記が使用
されます。

   以下はボックスを使用してドットペア表記を表した例です
。この例はペア‘(rose . violet)’を表します。

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   最後のCDRが非‘nil’のコンスセルのチェーンを表すために
、ドットペア表記とリスト表記を組み合わせることができます
。リストの最後の要素の後にドットを記述して、その後に最後
のコンスセルのCDRを記述します。たとえば、‘(rose violet .
buttercup)’は、‘(rose . (violet . buttercup))’と等価です
。オブジェクトは以下のようになります:

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   構文‘(rose . violet . buttercup)’は無効です。なぜなら
これが意味することは何もないからです。何かあるにしても、
‘violet’のためにCDRがすでに使用されているコンスセルの
CDRに‘buttercup’を置く、ということになります。

   リスト‘(rose violet)’は‘(rose . (violet))’と等価であ
り、以下のようになります:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   同様に3要素のリスト‘(rose violet buttercup)’は、
‘(rose . (violet . (buttercup)))’と等価です。 これは以下
のようになります:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


File: elisp,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.3 Association List Type
.............................

“連想リスト(association list)”または“alist”は、要素がコ
ンスセルであるように特別に構成されたリストです。各要素に
おいては、CARが“キー(key)”で、CDRが“連想値(associated
value)”であると考えます(連想値がCDRのCARに保存される場合
もあります)。リストの先頭に連想値を追加したり削除するの
が簡単なので、連想リストはスタック(stack)にしばしば使用
されます。

   たとえば、

     (setq alist-of-colors
           '((rose . red) (lily . white) (buttercup . yellow)))

これは変数‘alist-of-colors’に3葉疎のalistをセットします
。最初の要素では、‘rose’がキーで、‘red’が値になります。

   alistと、alistに関数についての詳細な説明は、*note
Association Lists::を参照してください。テーブルを照合す
る、(多くのキーの操作を、より速く行なう)他の手段について
は、*note Hash Tables::を参照してください。


File: elisp,  Node: Array Type,  Next: String Type,  Prev: Cons Cell Type,  Up: Programming Types

2.3.7 Array Type
----------------

“配列(array)”は、他のLispオブジェクトを保持または参照す
る、任意の数のスロットから構成され、メモリーの連続ブロッ
クに配列されます。配列の任意の要素へのアクセス時間は、大
体同じです。対照的に、リストの要素にたいするアクセスは、
リスト内でのその要素の位置に比例した時間を要します(リス
トの最後の要素にアクセスするには、リストの最初の要素にア
クセスするより、長い時間を要します)。

   Emacsは文字列(strings)、ベクター(vectors)、ブールベク
ター(bool-vectors)、文字テーブル(char-tables)という、4種
の配列を定義します。

   文字列は文字の配列で、ベクターは任意のオブジェクトの
配列です。ブールベクターは‘t’か‘nil’だけを保持できます。
この種の配列は、もっとも大きい整数までの、任意の長さをも
つことができます。文字テーブルは、任意の有効な文字コード
によりインデックスづけされる疎な配列で、任意のオブジェク
トを保持することができます。

   配列の最初の要素はインデックス0、2番目の要素はインデ
ックス1、...となります。これは0基準“zero-origin”のインデ
ックスづけと呼ばれます。たとえば、4要素の配列は、インデ
ックス0、1、2、3をもちます。利用できる最大のインデックス
値は、配列の長さより1小さくなります。1度配列が作成される
と、長さは固定されます。

   Emacs Lispのすべての配列は、1次元です(他のほとんどの
プログラミング言語は多次元配列をサポートしますが、これら
は必須ではありません。ネストされた1次元配列により同じ効
果を得ることができます)。各種の配列のは、独自の入力構文
をもちます。詳細は以降のセクションを参照してください。

   配列型はシーケンス型のサブセットであり、文字列型、ベ
クター型、ブールベクター型、文字テーブル型が含まれます。


File: elisp,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

2.3.8 String Type
-----------------

“文字列(string)”とは、文字の配列です。Emacsがテキストエ
ディターであることから予想できるように、文字列は、たとえ
ばLispシンボルの名前、ユーザーへのメッセージ、バッファー
から抽出されたテキストの表現など、多くの目的のために使用
されます。Lispの文字列は定数です。文字列を評価すると、そ
れと同じ文字列がreturnされます。

   文字列を操作する関数については、*note Strings and
Characters::を参照してください。

* Menu:

* Syntax for Strings::       Lisp文字列を指定する方法。
* Non-ASCII in Strings::     文字列内の国際化文字。
* Nonprinting Characters::   文字列内の印刷不可能なリテラル文字。
* Text Props and Strings::   テキストプロパティーをともなう文字列。


File: elisp,  Node: Syntax for Strings,  Next: Non-ASCII in Strings,  Up: String Type

2.3.8.1 Syntax for Strings
..........................

文字列にたいする入力構文は、‘"like this"’のように、ダブ
ルクォート、任意個の文字、もう1つのダブルクォートから構
成されます。文字列内にダブルクォートを含める場合は、それ
の前にバックスラッシュを記述します。したがって、‘"\""’は
1つのダブルクォート文字だけを含む文字列です。同様に、バ
ックスラッシュを含める場合は、‘"this \\ is a single
embedded backslash"’のように、それの前にもう1つのバック
スラッシュを記述します。

   文字列にたいする入力構文では、改行(newline)は特別では
ありません。ダブルクォートの間に改行を記述すれば、その改
行は文字列内の文字となります。しかしエスケープされた改行
— 前に‘\’をともなう改行 —は文字列の一部とはなりません。
同様に、エスケープされたスペース‘\  ’も無視されます。

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          ⇒ "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."


File: elisp,  Node: Non-ASCII in Strings,  Next: Nonprinting Characters,  Prev: Syntax for Strings,  Up: String Type

2.3.8.2 Non-ASCII Characters in Strings
.......................................

Emacdの文字列内の非ASCII文字にたいしては、2つのテキスト
表現 — マルチバイト(multibyte)とユニバイト(unibyte)があ
ります(*note Text Representations::を参照してください)。
大まかに言うと、ユニバイト文字列にはraw(生)バイトが保存
され、マルチバイト文字列には人間が読めるテキストが保存さ
れます。ユニバイト文字列内の各文字はバイトであり、値は
0から255となります。対照的に、マルチバイト文字列内の各文
字は、0から4194303の値をもつかもしれません(*note
Character Type::を参照してください)。両方とも、127より上
の文字は非ASCIIです。

   文字をリテラルとして記述することにより、文字列に非
ASCII文字を含めることができます。マルチバイトのバッファ
ーや文字列、あるいはマルチバイトとしてvisitされたファイ
ル等の、マルチバイトのソースから文字列定数を読み込む場合
、Emacsは非ASCII文字をマルチバイト文字として読み取り、そ
の文字列を自動的にマルチバイト文字列にします。ユニバイト
のソースから文字列定数を読み込む場合、Emacsは非ASCII文字
をユニバイト文字として読み取り、その文字列を湯にバイト文
字列にします。

   マルチバイト文字列内にリテラルとして文字を記述するか
わりに、エスケープシーケンスを使用して文字コードとして記
述できます。エスケープシーケンスについての詳細は、*note
General Escape Syntax::を参照してください。

   文字列定数内でUnicodeスタイルのエスケープシーケンス
‘\uNNNN’または‘\U00NNNNNN’を使用する場合、(たとえASCII文
字の場合でも)Emacsは自動的に文字列をマルチバイトとみなし
ます。

   文字列定数内で、16進エスケープシーケンス(‘\xN’)、およ
び8進エスケープシーケンス(‘\N’)を使用することもできます
。*しかし注意してください: *文字列定数が16進または8進の
エスケープシーケンスを含み、それらのエスケープシーケンス
すべてがユニバイト文字(256より小)を指定していて、その文
字列内に他にリテラルの非ASCII文字またはUnicodeスタイルの
エスケープシーケンスが存在しない場合、Emacsは自動的に文
字列をユニバイト文字列とみなします。つまり文字列内のすべ
ての非ASCII文字は8ビットのrawバイトとみなされます。

   16進および8進のエスケープシーケンスではエスケープされ
た文字コードは可変個の数字を含むかもしれないので、それに
続く文字で、16進および8進として有効ではない最初の文字は
、エスケープシーケンスを終了させます。文字列内の次の文字
が16進または8進として解釈できる文字の場合は、‘\  ’(バッ
クスラッシュとスペース)を記述して、エスケープシーケンス
を終了できます。たとえば‘\xe0\ ’はgrave accentつきの
‘a’という、1文字を表します。文字列内の‘\  ’は、バックス
ラッシュー改行と同様です。これは文字列内の文字とはなりま
せんが、先行する16進エスケープを終了します。


File: elisp,  Node: Nonprinting Characters,  Next: Text Props and Strings,  Prev: Non-ASCII in Strings,  Up: String Type

2.3.8.3 Nonprinting Characters in Strings
.........................................

リテラル文字と同様に、文字列定数内でバックスラッシュによ
るエスケープシーケンスを使用できます(ただし文字定数を開
始するクエスチョンマークは使用しません)。たとえば、非プ
リント文字のタブと‘C-a’を含む文字列は、‘"\t, \C-a"’のよ
うに、それらの間にカンマとスペースを記述します。文字にた
いする入力構文の説明は、*note Character Type::を参照して
ください。

   しかし、バックスラッシュによるエスケープシーケンスと
ともに記述できるすべての文字が、文字列内で有効というわけ
ではありません。文字列が保持できるコントロール文字は、
ASCIIコントロール文字だけです。ASCIIコントロール文字では
、文字列の大文字小文字は区別されません。

   正確に言うと、文字列はメタ文字を保持できません。しか
し文字列がキーシーケンスとして使用される場合、文字列内で
メタで修飾されたASCII文字を表現するための方法を提供する
、特別な慣習があります。文字列定数内でメタ文字を示すため
に‘\M-’構文を使用した場合、これは文字列内の文字の 2**7 の
ビットをセットします。その文字列が‘define-key’または
‘lookup-key’で使用される場合、この数字コードは等価なメタ
文字に変換されます。*note Character Type::を参照してくだ
さい。

   文字列はhyper、super、altで修飾された文字を保持できま
せん。


File: elisp,  Node: Text Props and Strings,  Prev: Nonprinting Characters,  Up: String Type

2.3.8.4 Text Properties in Strings
..................................

文字列は、その文字自身に加えて、文字のプロパティーも保持
することができます。これにより、特別なことをしなくても、
文字列とバッファーとの間でテキストをコピーするプログラム
が、テキストプロパティーをコピーすることが可能になります
。テキストプロパティーが何を意味するかについての説明は、
*note Text Properties::を参照してください。テキストプロ
パティーをもつ文字列は、特別な入力構文とプリント構文を使
用します。

     #("CHARACTERS" PROPERTY-DATA...)

ここでPROPERTY-DATAは3個でグループ化された、0個以上の要
素から構成されます:

     BEG END PLIST

要素BEGおよびENDは整数で、文字列内のインデックスの範囲を
指定します。PLISTはその範囲にたいするプロパティーリスト
です。たとえば、

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

これはテキスト内容が‘foo bar’で、最初の3文字は‘face’プロ
パティーに値‘bold’をもち、最後の3文字は‘face’プロパティ
ーに値‘italic’をもつことを表します。(4番目の文字にはテキ
ストプロパティーはないので、プロパティーリストは‘nil’で
す。実際には、範囲の中の指定されていない文字はデフォルト
ではプロパティーをもたないので、範囲のプロパティーリスト
を‘nil’と指定する必要ありません)。


File: elisp,  Node: Vector Type,  Next: Char-Table Type,  Prev: String Type,  Up: Programming Types

2.3.9 Vector Type
-----------------

“ベクター(vector)”は、任意の型の要素からなる1次元の配列
です。ベクター内の任意の要素へのアクセスに要す時間は、一
定です(リストの場合、要素へのアクセスに要す時間は、リス
トの先頭からその要素までの距離に比例します)。

   ベクターのプリント表現は、左角カッコ(left square
bracket)、要素、右角カッコ(right square bracket)から構成
されます。これは入力構文でもあります。数字や文字列と同様
に、ベクターは評価において定数と判断されます。

     [1 "two" (three)]      ; 3要素のベクター。
          ⇒ [1 "two" (three)]

   ベクターに作用する関数については、*note Vectors::を参
照してください。


File: elisp,  Node: Char-Table Type,  Next: Bool-Vector Type,  Prev: Vector Type,  Up: Programming Types

2.3.10 Char-Table Type
----------------------

“文字テーブル(char-table)”は、任意の型の要素をもつ1次元
の配列で、文字コードによりインデックスづけされます。文字
テーブルは、文字コードに情報を割り当てることを必要とする
多くの処理を簡単にするための、特別な追加の機能をもちます
— たとえば、文字テーブルは、継承するための親、デフォルト
値、特別な目的のために使用する少数の余分なスロットをもつ
ことができます。文字テーブルは、文字セット全体にたいして
1つの値を指定することもできます。

   文字テーブルのプリント表現はベクターと似ていますが、
最初に余分な‘#^’があります(1)。

   文字テーブルを操作する特別な関数については、*note
Char-Tables::を参照してください。文字テーブルの使用には
以下が含まれます:

   • 大文字小文字テーブル(*note Case Tables::を参照して
     ください)。

   • 文字カテゴリーテーブル(*note Categories::を参照して
     ください)。

   • ディスプレーテーブル(*note Display Tables::を参照し
     てください)。

   • 構文テーブル(*note Syntax Tables::を参照してくださ
     い)。

   ---------- Footnotes ----------

   (1) “サブ文字テーブル(sub-char-tables)”に使用される
‘#^^’を目にすることがあるかもしれません。


File: elisp,  Node: Bool-Vector Type,  Next: Hash Table Type,  Prev: Char-Table Type,  Up: Programming Types

2.3.11 Bool-Vector Type
-----------------------

“ブールベクター(bool-vector)”は、要素が‘t’か‘nil’でなけ
ればならない、1次元の配列です。

   ブールベクターのプリント表現は文字列と似ていますが、
後に長さを記述した‘#&’で始まります。これに続く文字列定数
は、ビットマップとして実際に内容を指定するブールベクター
です — 文字列定数内のそれぞれの“文字”は8ビットを含み、こ
れはブールベクターの次の8要素を指定します(1は‘t’、0は
‘nil’です)。文字の最下位ビットブールベクターの最下位のイ
ンデックスに対応します。

     (make-bool-vector 3 t)
          ⇒ #&3"^G"
     (make-bool-vector 3 nil)
          ⇒ #&3"^@"

‘C-g’の2進コードは111、‘C-@’はコード0の文字なので、この
結果は道理にかなっています。

   長さが8の倍数でない場合、プリント表現には余分な要素が
表示されますが、これらの余分な要素に意味はありません。た
とえば以下の例では、最初の3ビットだけが使用されるので、
2つのブールベクターは等価です:

     (equal #&3"\377" #&3"\007")
          ⇒ t


File: elisp,  Node: Hash Table Type,  Next: Function Type,  Prev: Bool-Vector Type,  Up: Programming Types

2.3.12 Hash Table Type
----------------------

ハッシュテーブルは非常に高速な照合テーブルの一種で、キー
を対応する値にマップするalistと似ていますが、より高速で
す。ハッシュテーブルのプリント表現、以下のようにハッシュ
テーブルのプロパティーと内容を指定します:

     (make-hash-table)
          ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8 data ())

ハッシュテーブルについての詳細な情報は、*note Hash
Tables::を参照してください。


File: elisp,  Node: Function Type,  Next: Macro Type,  Prev: Hash Table Type,  Up: Programming Types

2.3.13 Function Type
--------------------

他のプログラミング言語の関数と同様に、Lisp関数は実行可能
なコードです。他の言語とは異なり、Lispの関数はLispオブジ
ェクトでもあります。Lispのコンパイルされていない関数はラ
ムダ式 — つまり1番目の要素がシンボル‘lambda’であるリスト
です(*note Lambda Expressions::を参照してください)。

   ほとんどのプログラミング言語では、名前のないの関数は
ありません。Lispでは、関数に本質的な名前はありません。名
前がなくても、ラムダ式を関数として呼び出すことができます
。これを強調するために、わたしたちはこれを“無名関数
(anonymous function)”とも呼びます(*note Anonymous
Functions::を参照してください)。Lispの名前つき関数は、関
数セルに有効な関数がセットされた単なるシンボルです(*note
Defining Functions::を参照してください)。

   ほとんどの場合、関数はLispプログラム内のLisp式に名前
が記述されたところで呼び出されます。しかし、実行時に関数
オブジェクトを構築または取得してから、基本関数
‘funcall’および‘apply’により呼び出すことができます。
*note Calling Functions::を参照してください。


File: elisp,  Node: Macro Type,  Next: Primitive Function Type,  Prev: Function Type,  Up: Programming Types

2.3.14 Macro Type
-----------------

“Lispマクロ(Lisp macro)”は。Lisp言語を拡張する、ユーザー
定義の構成です。これはオブジェクトとしてではなく関数のよ
うに表現されますが、引数の渡し方の意味が異なります。
Lispマクロの形式はリストです。これは、最初の要素が
‘macro’で、(‘lambda’シンボルを含む)CDRがLisp関数オブジェ
クトであるようなリストです。

   Lispマクロオブジェクトは通常、ビルトインの
‘defmacro’関数で定義されますが、‘macro’で始まる任意のリ
ストも、Emacsにとってはマクロです。マクロを記述する方法
の説明は、*note Macros::を参照してください。

   *警告*: Lispマクロとキーボードマクロ(*note Keyboard
Macros::を参照してください)は、完全に別物です。修飾なし
で“マクロ”という単語を使用したときは、キーボードマクロで
はなく、Lispマクロのことを指します。


File: elisp,  Node: Primitive Function Type,  Next: Byte-Code Type,  Prev: Macro Type,  Up: Programming Types

2.3.15 Primitive Function Type
------------------------------

“基本関数(primitive function)”とは、Cプログラミング言語
で記述された、Lispから呼び出せる関数です。基本関数は
“subrs”や“ビルと陰関数(built-in functions)”とも呼ばれま
す(単語“subr”は、“サブルーチン(subroutine)”が由来です)。
ほとんどの基本関数、呼び出されたとき、すべての引数を評価
します。すべての引数を評価しない基本関数は、“スペシャル
フォーム(special form)”と呼ばれます(*note Special
Forms::を参照してください)。

   呼び出す側からすれば、その関数が基本関数かどうかは、
問題になりません。しかし、基本関数をLispで記述された関数
で再定義した場合は、問題になります。理由は、その基本関数
がCコードから直接呼び出されているかもしれないからです。
Lispから再定義した関数を呼び出すと、これは新しい定義を使
用するでしょうが、Cコードから呼び出すと、ビルトインの定
義が使用されるでしょう。したがって、*基本関数の再定義は
しないでください*。

   “関数(function)”という用語により、LispやCで記述された
、すべてのEmacs関数を参照します。Lispで記述された関数に
ついての情報は、*note Function Type::を参照してください
。

   基本関数に入力構文はなく、サブルーチン名とともにハッ
シュ表記でプリントします。

     (symbol-function 'car)          ; そのシンボルの関数セルに
                                     ;     アクセスします。
          ⇒ #<subr car>
     (subrp (symbol-function 'car))  ; これは基本関数か?
          ⇒ t                ;    イェース。


File: elisp,  Node: Byte-Code Type,  Next: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

2.3.16 Byte-Code Function Type
------------------------------

“バイトコード関数オブジェクト(byte-code function
objects)”は、Lispコードをバイトコンパイルすることにより
生成されます(*note Byte Compilation::を参照してください
)。内部的には、バイトコード関数オブジェクトは、ベクター
によく似ています。しかしバイトコード関数オブジェクトが関
数呼び出しのように見える場合、評価プロセスにより、このデ
ータ型は特別に処理されます。*note Byte-Code Objects::を
参照してください。

   バイトコード関数オブジェクトのプリント表現と入力構文
は、ベクターのものと似ていますが、開き角カッコ‘[’の前に
‘#’があります。


File: elisp,  Node: Autoload Type,  Prev: Byte-Code Type,  Up: Programming Types

2.3.17 Autoload Type
--------------------

“autoloadオブジェクト(autoload object)”は、最初の要素が
シンボル‘autoload’のリストです。これはシンボルの関数定義
として保存され、実際の定義にたいする代替としての役割をも
ちます。autoloadオブジェクトは、必要な時にロードされる
Lispコードファイルのなかで、実際の定義を見つけることがで
きることを宣言します。これにはファイル名と、加えて実際の
定義についての他のいくつかの情報が含まれます。

   ファイルがロードされた後、そのシンボルは、autoloadオ
ブジェクトではない、新しい関数定義をもつはずです。新しい
定義は、最初からそこにあったかのように呼び出されます。ユ
ーザーの観点からは、関数呼び出しは期待された動作、つまり
ロードされたファイル内の関数定義を使用します。

   autoloadオブジェクトは通常、シンボルの関数セルにオブ
ジェクトを保存する、関数‘autoload’により作成されます。詳
細は、*note Autoload::を参照してください。


File: elisp,  Node: Editing Types,  Next: Circular Objects,  Prev: Programming Types,  Up: Lisp Data Types

2.4 Editing Types
=================

前のセクションの型は一般的なプログラミングの目的のために
使用され、これらのほとんどは、ほとんどのLisp方言で一般的
です。Emacs Lispは、編集に関する目的のために、いくつかの
追加のデータ型を提供します。

* Menu:

* Buffer Type::              編集のための基本オブジェクト。
* Marker Type::              バッファー内の位置。
* Window Type::              バッファーはウィンドウ内に表示されます。
* Frame Type::               ウィンドウはフレームを細分します。
* Terminal Type::            フレームを表示する端末デバイス。
* Window Configuration Type::  フレームが細分化された方法を記録する。
* Frame Configuration Type::  すべてのフレームの状態を記録する。
* Process Type::             背後のOS上で実行されるEmacsのサブプロセス。
* Stream Type::              文字の受信と送信。
* Keymap Type::              キーストロークがどの関数を呼び出すか。
* Overlay Type::             オーバーレイが表示される方法。
* Font Type::                テキストを表示するフォント。


File: elisp,  Node: Buffer Type,  Next: Marker Type,  Up: Editing Types

2.4.1 Buffer Type
-----------------

“バッファー(buffer)”とは、編集されるテキストを保持するオ
ブジェクトです(*note Buffers::を参照してください)。ほと
んどのバッファーはディスクファイル(*note Files::を参照し
てください)の内容を保持するので、それらは編集できますが
、他の目的のために使用されるものもいくつかあります。ほと
んどのバッファーは、ユーザーにより閲覧されることも意図し
ているので、いつかはウィンドウ内(*note Windows::を参照し
てください)に表示されます。しかしバッファーはウィンドウ
に表示される必要はありません。バッファーはそれぞれ、“ポ
イント(point)”と呼ばれる位置指定をもちます(*note
Positions::を参照してください)。ほとんどの編集コマンドは
、カレントバッファー内のポイントに隣接する内容を処理しま
す。常に1つのバッファーが“カレントバッファー(current
buffer)”です。

   バッファーの内容は文字列によく似ていますが、バッファ
ーはEmacs Lispの文字列と同じようには使用されず、利用可能
な操作は異なります。文字列にテキストを“挿入”するためには
、部分文字列の結合が必要で、結果は完全に新しい文字列オブ
ジェクトなのに比べて、バッファーでは既存のバッファーに効
率的にテキストを挿入して、バッファーの内容を変更できます
。

   標準的なEmacs関数の多くは、カレントバッファー内の文字
を操作したりテストするためのものです。このマニュアルには
、これらの関数の説明のために、1つのチャプターをあててい
ます(*note Text::を参照してください)。

   他のデータ構造のいくつかは、各バッファーに関連付けら
れています:

   • ローカル構文テーブル(*note Syntax Tables::を参照し
     てください)。

   • ローカルキーマップ(*note Keymaps::を参照してくださ
     い)。

   • バッファーローカルな変数バインディングのリスト
     (*note Buffer-Local Variables::を参照してください
     )。

   • オーバーレイ(*note Overlays::を参照してください)。

   • バッファー内のテキストにたいするテキストプロパティ
     ー(*note Text Properties::を参照してください)。

ローカルキーマップと変数リストは、具ローマルナバインディ
ングや値を個別にオーバーライドするためのエントリーを含み
ます。これらは、実際にプログラムを変更することなく、異な
るバッファーでのプログラムの振る舞いをカスタマイズするた
めに使用されます。

   バッファーは“インダイレクト(indirect: 間接)” — つまり
他のバッファーとテキストを共有するが、それぞれ別に表示す
る — かもしれません。*note Indirect Buffers::を参照して
ください。

   バッファーに入力構文はありません。バッファーはバッフ
ァー名を含むハッシュ表記でプリントされます。

     (current-buffer)
          ⇒ #<buffer objects.texi>


File: elisp,  Node: Marker Type,  Next: Window Type,  Prev: Buffer Type,  Up: Editing Types

2.4.2 Marker Type
-----------------

“マーカー(marker)”は、特定のバッファー内の位置を表します
。したがってマーカーには2つの内容 — 1つはバッファー、も
う1つは位置 — をもちます。バッファーのテキストの変更では
、マーカーが常にバッファー内の同じ2つの文字の間に位置す
ることを確実にするために、必要に応じて自動的に位置の値が
再配置されます。

   マーカーは入力構文をもちません。マーカーは、カレント
の文字位置と、そのバッファー名を与える、ハッシュ表記でプ
リントされます。

     (point-marker)
          ⇒ #<marker at 10779 in objects.texi>

   マーカーのテスト、作成、コピー、移動の方法についての
情報は、*note Markers::を参照してください。


File: elisp,  Node: Window Type,  Next: Frame Type,  Prev: Marker Type,  Up: Editing Types

2.4.3 Window Type
-----------------

“ウィンドウ(window)”はEmacsがバッファーを表示するために
使用する端末スクリーンの部分を記述します。すべてのウィン
ドウは関連付けられた1つのバッファーをもち、バッファーの
内容はそのウィンドウに表示されます。対照的に、あるバッフ
ァーは、1つのウィンドウに表示されるか、ウィンドウに表示
されないか、それとも複数のウィンドウに表示されるかもしれ
ません。

   同時に複数のウィンドウが存在するかもしれませんが、常
に1つのウィンドウが“選択されたウィンドウ(selected
window)”になります。Emacsがコマンドにたいして準備できて
いるときに、(通常は)カーソルが表示されるウィンドウが、選
択されたウィンドウです。選択されたウィンドウは通常、カレ
ントバッファーを表示しますが、これは必須ではありません。

   スクリーン上でウィンドウはフレームにグループ化されま
す。各ウィンドウは、ただ1つだけのフレームに属します。
*note Frame Type::を参照してください。

   ウィンドウは入力構文をもちません。ウィンドウは、ウィ
ンドウ番号、表示されているバッファー名を与える、ハッシュ
表記でプリントされます。与えられたウィンドウに表示される
バッファーは頻繁に変更されるかもしれないので、一意にウィ
ンドウを識別するためにウィンドウ番号が存在します。

     (selected-window)
          ⇒ #<window 1 on objects.texi>

   ウィンドウに作用する関数の説明は、*note Windows::を参
照してください。


File: elisp,  Node: Frame Type,  Next: Terminal Type,  Prev: Window Type,  Up: Editing Types

2.4.4 Frame Type
----------------

“フレーム(frame)”とは、１つ以上のEmacsウィンドウを含むス
クリーン領域です。スクリーン領域を参照するためにEmacsが
使用するLispオブジェクトを指す場合も、“フレーム”という用
語を使用します。

   フレームは入力構文をもちません。フレームはフレームの
タイトル、(フレームを一意に識別するのに便利な)メモリー内
のアドレスを与えるハッシュ表記でプリントされます。

     (selected-frame)
          ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>

   フレームに作用する関数の説明は、*note Frames::を参照
してください。


File: elisp,  Node: Terminal Type,  Next: Window Configuration Type,  Prev: Frame Type,  Up: Editing Types

2.4.5 Terminal Type
-------------------

“端末(terminal)”は、1つ以上のEmacsフレーム(*note Frame
Type::を参照してください)を表示する能力があるデバイスで
す。

   端末は入力構文をもちません。端末は、その端末の順序番
号、TTYデバイスファイル名を与える、ハッシュ表記でプリン
トされます。

     (get-device-terminal nil)
          ⇒ #<terminal 1 on /dev/tty>


File: elisp,  Node: Window Configuration Type,  Next: Frame Configuration Type,  Prev: Terminal Type,  Up: Editing Types

2.4.6 Window Configuration Type
-------------------------------

“ウィンドウ構成(window configuration)”は、フレーム内のウ
ィンドウの位置、サイズ、内容についての情報を保持します。
これにより後で同じウィンドウ配置を再作成できます。

   ウィンドウ構成は入力構文をもちません。ウィンドウ構成
のプリント表現は、‘#<window-configuration>’のようになり
ます。ウィンドウ構成に関連するいくつかの関数の説明は、
*note Window Configurations::を参照してください。


File: elisp,  Node: Frame Configuration Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

2.4.7 Frame Configuration Type
------------------------------

“フレーム構成(frame configuration)”は、すべてのフレーム
内のウィンドウの位置、サイズ、内容についての情報を保持し
ます。これは基本型ではありません — 実際のところ、これは
CARが‘frame-configuration’で、CDRがalistのリストです。各
alist要素は、その要素のCARに示される1つのフレームを記述
します。

   フレーム構成に関連するいくつかの関数の説明は、*note
Frame Configurations::を参照してください。


File: elisp,  Node: Process Type,  Next: Stream Type,  Prev: Frame Configuration Type,  Up: Editing Types

2.4.8 Process Type
------------------

単語“プロセス(process)”は通常、実行中のプログラムを意味
します。Emacs自身はこの種のプロセス内で実行されます。し
かしEmacs Lispでは、プロセスとはEmacsプロセスにより作成
されたサブプロセスを表す、Lispオブジェクトです。シェル、
GDB、ftp、コンパイラーなどのプログラムは、Emacsのサブプ
ロセスとして実行され、Emacsの能力を拡張します。さらに操
作を行なうために、Emacsサブプロセスは、Emacsからテキスト
入力を受け取り、テキスト出力をEmacsにreturnします。
Emacsは、サブプロセスにシグナルを送ることもできます。

   プロセスオブジェクトは入力構文をもちません。プロセス
オブジェクトは、プロセス名を与えるハッシュ表記でプリント
されます。

     (process-list)
          ⇒ (#<process shell>)

   プロセスの作成、削除、プロセスに関する情報のreturn、
入力やシグナルの送信、出力の受信を行なう関数についての情
報は、*note Processes::を参照してください。


File: elisp,  Node: Stream Type,  Next: Keymap Type,  Prev: Process Type,  Up: Editing Types

2.4.9 Stream Type
-----------------

“ストリーム(stream)”とは、文字のソースまたはシンクとして
— つまり入力として文字を供給したり、出力として文字を受け
入れるために使用できるオブジェクトです。多くの異なるタイ
プ — マーカー、バッファー、文字列、関数を、この方法で使
用できます。ほとんどの場合、入力ストリーム(文字列ソース
)は、キーボード、バッファー、ファイルから文字を受け取り
、出力ストリーム(文字シンク)は文字を‘*Help*’バッファーの
ようなバッファー、エコーエリアに文字を送ります。

   オブジェクト‘nil’は、他の意味に加えて、ストリームとし
て使用されることがあります。‘nil’は変数
‘standard-input’や‘standard-output’の値を表します。オブ
ジェクト‘t’も、入力としてミニバッファー(*note
Minibuffers::を参照してください)、出力としてエコーエリア
(*note The Echo Area::を参照してください)の使用を指定す
るストリームになります。

   ストリームは特別なプリント表現や入力構文をもたず、何
であれ、それらの基本型としてプリントされます。

   パース関数およびプリント関数を含む、ストリームに関連
した関数の説明は、*note Read and Print::を参照してくださ
い。


File: elisp,  Node: Keymap Type,  Next: Overlay Type,  Prev: Stream Type,  Up: Editing Types

2.4.10 Keymap Type
------------------

“キーマップ(keymap)”は、ユーザーがタイプした文字を、コマ
ンドにマップします。このマップは、ユーザーのコマンド入力
が実行される方法を制御します。キーマップは、実際には
CARがシンボル‘keymap’のリストです。

   キーマップの作成、プレフィクスキーの処理、ローカルキ
ーマップやグローバルキーマップ、キーバインドの変更につい
ての情報は、*note Keymaps::を参照してください。


File: elisp,  Node: Overlay Type,  Next: Font Type,  Prev: Keymap Type,  Up: Editing Types

2.4.11 Overlay Type
-------------------

“オーバーレイ(overlay)”は、バッファーの一部に適用するプ
ロパティーを指定します。それぞれのオーバーレイはバッファ
ーの指定された範囲に適用され、プロパティーリスト(プロパ
ティー名と値が交互に記述された要素のリスト)を含みます。
オーバーレイプロパティーは、バッファーの指定された一部を
、一時的に異なるスタイルで表示するために使用されます。オ
ーバーレイは入力構文をもたず、バッファーメイト範囲の位置
を与えるハッシュ表記でプリントされます。

   オーバーレイを作成したり使用する方法についての情報は
、*note Overlays::を参照してください。


File: elisp,  Node: Font Type,  Prev: Overlay Type,  Up: Editing Types

2.4.12 Font Type
----------------

“font”は、グラフィカルな端末上のテキストを表示する方法を
指定します。実際には異なる3つのフォント型 — “フォントオ
ブジェクト(font objects)”、“フォントスペック(font
specs)”、“フォントエンティティー(font entities)” — が存
在しますこれらは入力構文をもちません。これらのプリント構
文は、‘#<font-object>’、‘#<font-spec>’、
‘#<font-entity>’のようになります。これらのLispオブジェク
トの説明は、*note Low-Level Font::を参照してください。


File: elisp,  Node: Circular Objects,  Next: Type Predicates,  Prev: Editing Types,  Up: Lisp Data Types

2.5 Read Syntax for Circular Objects
====================================

複雑なLispオブジェクトにおける共有された構造、または循環
する構造を表すために、リーダー構成‘#N=’と‘#N#’を使用する
ことができます。

   後でオブジェクトを参照するには、オブジェクトの前で
‘#N=’を使用します。その後で、他の場所にある同じオブジェ
クトを参照するために、‘#N#’を使用することができます。こ
こでNは任意の整数です。たとえば以下は、1番目の要素が3番
目の要素にも繰り替えされるリストを作成する方法です:

     (#1=(a) b #1#)

これは、以下のような通常の構文とは異なります

     ((a) b (a))

これは1番目の要素と3番目の要素がそっくりなリストですが、
これらは同じLispオブジェクトではありません。以下で違いを
見ることができます:

     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ nil

   “要素”として自身を含むような、循環する構造を作成する
ために、同じ構文を使用できます。以下は例です:

     #1=(a #1#)

これは、2番目の要素がそのリスト自身であるリストを作成し
ます。これが実際にうまくいくのか、以下で確認できます:

     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          ⇒ t

   変数‘print-circle’を非‘nil’値にバインドした場合、
Lispプリンターは、循環および共有されるLispオブジェクトを
記録するこの構文を、生成することができます。*note Output
Variables::を参照してください。


File: elisp,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Circular Objects,  Up: Lisp Data Types

2.6 Type Predicates
===================

Emacs Lispインタープリター自身は、関数が呼び出されたとき
に、その関数に渡された実際の引数にたいする型チェックは行
ないません。それが行なえないのは、Lispにおける関数の引数
は、他のプログラミング言語のようなデータ型宣言をもたない
からです。したがって実際の引数が、その関数が使用できる型
に属するかどうかをテストするのは、それぞれの関数に任され
ています。

   すべてのビルトイン関数は、適切なときに実際の引数の型
チェックを行い、引数の型が違う場合は、
‘wrong-type-argument’エラーをシグナルします。たとえば以
下は、‘+’の引数に、‘+’が扱うことができない引数を渡したと
き何が起こるかの例です:

     (+ 2 'a)
          error→ Wrong type argument: number-or-marker-p, a

   異なる型にたいして異なる処理をプログラムに行なわせる
場合は、明示的に型チェックを行なわなければなりません。オ
ブジェクトの型をチェックするもっとも一般的な方法は、“型
述語(type predicate)”関数の呼び出しです。Emacsはそれぞれ
の型にたいする型述語をもち、組み合わされた型にたいする述
語もあります。

   型述語関数は1つの引数をとり、その引数が適切な型であれ
ば‘t’、そうでない場合は‘nil’をreturnします。述語関数にた
いする一般的なLisp慣習にしたがい、ほとんどの型述語の名前
は、‘p’で終わります。

   以下はリストにたいしてチェックを行なう述語‘listp’と、
シンボルにたいしてチェックを行なう述語‘symbolp’の例です
。

     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))

   以下の表は、事前定義された型述語(アルファベット順)と
、さらに情報を得るためのリファレンスです。

‘atom’
     *note atom: List-related Predicates.を参照してくだ
     さい。

‘arrayp’
     *note arrayp: Array Functions.を参照してください。

‘bool-vector-p’
     *note bool-vector-p: Bool-Vectors.を参照してくださ
     い。

‘bufferp’
     *note bufferp: Buffer Basics.を参照してください。

‘byte-code-function-p’
     *note byte-code-function-p: Byte-Code Type.を参照し
     てください。

‘case-table-p’
     *note case-table-p: Case Tables.を参照してください
     。

‘char-or-string-p’
     *note char-or-string-p: Predicates for Strings.を参
     照してください。

‘char-table-p’
     *note char-table-p: Char-Tables.を参照してください
     。

‘commandp’
     *note commandp: Interactive Call.を参照してください
     。

‘consp’
     *note consp: List-related Predicates.を参照してくだ
     さい。

‘custom-variable-p’
     *note custom-variable-p: Variable Definitions.を参
     照してください。

‘display-table-p’
     *note display-table-p: Display Tables.を参照してく
     ださい。

‘floatp’
     *note floatp: Predicates on Numbers.を参照してくだ
     さい。

‘fontp’
     *note Low-Level Font::を参照してください。

‘frame-configuration-p’
     *note frame-configuration-p: Frame Configurations.を
     参照してください。

‘frame-live-p’
     *note frame-live-p: Deleting Frames.を参照してくだ
     さい。

‘framep’
     *note framep: Frames.を参照してください。

‘functionp’
     *note functionp: Functions.を参照してください。

‘hash-table-p’
     *note hash-table-p: Other Hash.を参照してください。

‘integer-or-marker-p’
     *note integer-or-marker-p: Predicates on Markers.を
     参照してください。

‘integerp’
     *note integerp: Predicates on Numbers.を参照してく
     ださい。

‘keymapp’
     *note keymapp: Creating Keymaps.を参照してください
     。

‘keywordp’
     *note Constant Variables::を参照してください。

‘listp’
     *note listp: List-related Predicates.を参照してくだ
     さい。

‘markerp’
     *note markerp: Predicates on Markers.を参照してくだ
     さい。

‘wholenump’
     *note wholenump: Predicates on Numbers.を参照してく
     ださい。

‘nlistp’
     *note nlistp: List-related Predicates.を参照してく
     ださい。

‘numberp’
     *note numberp: Predicates on Numbers.を参照してくだ
     さい。

‘number-or-marker-p’
     *note number-or-marker-p: Predicates on Markers.を
     参照してください。

‘overlayp’
     *note overlayp: Overlays.を参照してください。

‘processp’
     *note processp: Processes.を参照してください。

‘sequencep’
     *note sequencep: Sequence Functions.を参照してくだ
     さい。

‘stringp’
     *note stringp: Predicates for Strings.を参照してく
     ださい。

‘subrp’
     *note subrp: Function Cells.を参照してください。

‘symbolp’
     *note symbolp: Symbols.を参照してください。

‘syntax-table-p’
     *note syntax-table-p: Syntax Tables.を参照してくだ
     さい。

‘vectorp’
     *note vectorp: Vectors.を参照してください。

‘window-configuration-p’
     *note window-configuration-p: Window
     Configurations.を参照してください。

‘window-live-p’
     *note window-live-p: Deleting Windows.を参照してく
     ださい。

‘windowp’
     *note windowp: Basic Windows.を参照してください。

‘booleanp’
     *note booleanp: nil and t.を参照してください。

‘string-or-null-p’
     *note string-or-null-p: Predicates for Strings.を参
     照してください。

   あるオブジェクトがどの型かチェックするもっとも一般的
な方法は、関数‘type-of’の呼び出しです。オブジェクトは、
ただ1つだけの基本型に属することを思い出してください。
‘type-of’は、それがどの型(*note Lisp Data Types::を参照
してください)か告げます。しかし‘type-of’は基本型以外の型
については何も知りません。ほとんどの場合、‘type-of’より
型述語を使用するほうが便利でしょう。

 -- Function: type-of object
     この関数はOBJECTの基本型を名前とする、シンボルを
     returnします。retuen値はシンボル‘bool-vector’、
     ‘buffer’、‘char-table’、‘compiled-function’、
     ‘cons’、‘float’、‘font-entity’、‘font-object’、
     ‘font-spec’、‘frame’、‘hash-table’、‘integer’、
     ‘marker’、‘overlay’、‘process’、‘string’、‘subr’、
     ‘symbol’、‘vector’、‘window’、
     ‘window-configuration’のうちの1つです。

          (type-of 1)
               ⇒ integer
          (type-of 'nil)
               ⇒ symbol
          (type-of '())    ; ‘()’は‘nil’です。
               ⇒ symbol
          (type-of '(x))
               ⇒ cons


File: elisp,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Lisp Data Types

2.7 Equality Predicates
=======================

ここでは、2つのオブジェクトの同一性をテストする関数を説
明します。(たとえば文字列などの)特定の型のオブジェクト同
士で、内容の同一性をテストするのは、別の関数を使用します
。これらの述語にたいしては、そのデータ型を説明する、適切
なチャプターを参照してください。

 -- Function: eq object1 object2
     この関数はOBJECT1とOBJECT2が同じオブジェクトの場合
     は‘t’、それ以外は‘nil’をreturnします。

     OBJECT1とOBJECT2が、同じ値をもつ整数の場合、これら
     は同じオブジェクトと判断されます(‘eq’は‘t’を
     returnします)。OBJECT1とOBJECT2が、同じ名前のシンボ
     ルの場合、通常は同じオブジェクトです。しかし例外も
     あります。*note Creating Symbols::を参照してくださ
     い。(リスト、ベクター文字列などの)他の型にたいして
     は、同じ内容(または要素)の2つの引数が、両者‘eq’であ
     る必要はありません。これらが同じオブジェクトの場合
     だけ‘eq’であり、その場合は、一方の内容を変更すると
     、もう一方の内容にも同じ変更が反映されます。

          (eq 'foo 'foo)
               ⇒ t

          (eq 456 456)
               ⇒ t

          (eq "asdf" "asdf")
               ⇒ nil

          (eq "" "")
               ⇒ t
          ;; この例外は省スペースのためにEmacs Lispが
          ;; ただ1つのマルチバイトの空文字列を作成するためです。

          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (setq foo '(1 (2 (3))))
               ⇒ (1 (2 (3)))
          (eq foo foo)
               ⇒ t
          (eq foo '(1 (2 (3))))
               ⇒ nil

          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (eq (point-marker) (point-marker))
               ⇒ nil

     ‘make-symbol’関数は、internされていないシンボルを
     returnします。これはLisp式内で、その名前を記述した
     シンボルとは区別されます。同じ名前の、異なるシンボ
     ルは、‘eq’ではありません。*note Creating Symbols::を
     参照してください。

          (eq (make-symbol "foo") 'foo)
               ⇒ nil

 -- Function: equal object1 object2
     この関数は、OBJECT1とOBJECT2が同じ構成要素をもつ場
     合は‘t’、それ以外は‘nil’をreturnします。‘eq’は引数
     が同じオブジェクトなのかテストするのにたいして、
     ‘equal’は同一でない引数の内部を調べて、それらの要素
     または内容が同一化をテストします。したがって2つのオ
     ブジェクトが‘eq’ならば、それらは‘equal’です。しかし
     、その逆は常に真ではありません。

          (equal 'foo 'foo)
               ⇒ t

          (equal 456 456)
               ⇒ t

          (equal "asdf" "asdf")
               ⇒ t
          (eq "asdf" "asdf")
               ⇒ nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               ⇒ t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (equal [(1 2) 3] [(1 2) 3])
               ⇒ t
          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (equal (point-marker) (point-marker))
               ⇒ t

          (eq (point-marker) (point-marker))
               ⇒ nil

     文字列の比較は大文字小文字を区別しますが、テキスト
     プロパティーは考慮しません — これは文字列内の文字だ
     けを比較します。*note Text Properties::を参照してく
     ださい。テキストプロパティーも比較する場合は、
     ‘equal-including-properties’を使用します。記述的な
     理由により、ユニバイト文字列とマルチバイト文字列は
     、それらが同じ文字シーケンスを含み、それらすべての
     コードが0から127(ASCII)、または160から255(‘8ビット
     グラフィック’)の場合に限り、‘equal’です(*note Text
     Representations::を参照してください)。

          (equal "asdf" "ASDF")
               ⇒ nil

     しかし2つの別のバッファーは、それらのテキスト内容が
     同じでも、‘equal’と判断されることはありません。

   ‘equal’のテストは再帰により実装されています。たとえば
2つのコンスセルXとYを与えると、‘(equal X Y)’は、以下の式
の両方が‘t’をreturnする場合に限り、‘t’をreturnします:

     (equal (car X) (car Y))
     (equal (cdr X) (cdr Y))

   これは再帰処理なので、循環するリストがあると無限再帰
となります(エラーとなります)。

 -- Function: equal-including-properties object1 object2
     この関数はすべてのケースにおいて‘equal’と同様に振る
     舞いますが、2つの文字列が‘equal’になるためには、そ
     れらが同じテキストプロパティーをもつ必要があります
     。

          (equal "asdf" (propertize "asdf" 'asdf t))
               ⇒ t
          (equal-including-properties "asdf"
                                      (propertize "asdf" 'asdf t))
               ⇒ nil


File: elisp,  Node: Numbers,  Next: Strings and Characters,  Prev: Lisp Data Types,  Up: Top

3 Numbers
*********

GNU Emacsは2つの数値データ型 — “整数(integers)”と“浮動小
数点数(floating-point numbers)”をサポートします。整数は
−3、0、7、13、511などの整数です。浮動小数点数は−4.5、
0.0、2.71828などの小数部をもちます・これらは指数記数法で
も表現できます — ‘1.5e2’は‘150.0’と同じです。ここで
‘e2’は10の2乗をあらわし、それに1.5を乗じるという意味です
。整数計算は正確であり、オーバーフローするときもあります
。浮動小数点数の計算においては、数値は固定された精度をも
つため、、しばしば丸め誤差(rounding errors)を引き起こし
ます。

* Menu:

* Integer Basics::           整数の表現と範囲。
* Float Basics::             浮動少数の表現と範囲。
* Predicates on Numbers::    数にたいするテスト。
* Comparison of Numbers::    同一性と非同一性の述語。
* Numeric Conversions::      手動小数点数から整数、または疎の逆の変換。
* Arithmetic Operations::    加減乗除の方法。
* Rounding Operations::      浮動小数点数の明示的な丸め。
* Bitwise Operations::       論理的なadd、or、not、shift。
* Math Functions::           三角法、指数、対数関数。
* Random Numbers::           予測可能または不可能な乱数の取得。


File: elisp,  Node: Integer Basics,  Next: Float Basics,  Up: Numbers

3.1 Integer Basics
==================

整数の値の範囲はマシンに依存します。最小の範囲は
−536,870,912から536,870,911(30ビット長の −2**29 から
2**29 − 1) ですが、多くのマシンはこれより広い範囲を提供
します。このチャプターの例の多くは、最小の整数は30ビット
長であると仮定します。

   Lispリーダーは、(オプションで最初の符号記号と、最後の
ピリオドをともなう)数字のシーケンスとして整数を読み取り
ます。Emacsの範囲を超える整数は、浮動小数点数として扱わ
れます。

      1               ; 整数1。
      1.              ; 整数1。
     +1               ; これも整数1。
     -1               ; 整数−1。
      9000000000000000000
                      ; 浮動小数点数9e18.
      0               ; 整数0
     -0               ; 整数0

   基数が10以外の整数の構文は、‘#’の後に基数を指定する文
字 — 2進は‘b’、8進は‘o’、16進は‘x’、‘RADIXr’は基数RADIX
— を記述します。基数を指定する文字の大文字小文字は区別さ
れません。したがって‘#bINTEGER’はINTEGERを2進として読み
取り、‘#RADIXrINTEGER’はINTEGERを基数RADIXとして読み取り
ます。RADIXに指定できる値は2から36です。たとえば:

     #b101100 ⇒ 44
     #o54 ⇒ 44
     #x2c ⇒ 44
     #24r1k ⇒ 44

   整数にたいして処理を行なうさまざまな関数、特にビット
演算(*note Bitwise Operations::を参照してください)を理解
するためには、数を2進形式で見ることが助けになることがし
ばしばあります。

   30ビットの2進では、10進数の整数5は以下のようになりま
す:

     0000...000101 (全部で30ビット)

(‘...’は30ビットのワードを満たすのに充分なビットを意味し
、この場合の‘...’は12個の0ビットを意味します。以下の例で
も、2進の整数を読みやすくするために、‘...’の表記を使用し
ます)

   整数の−1は、以下のようになります:

     1111...111111 (全部で30ビット)

−1は30個の1で表現されます(これは“2の補数”表記と呼ばれま
す)。

   −1から4を減じることにより、負の整数−5が得られます。
10進の整数4は、2進では100です。したがって、−5は以下のよ
うになります:

     1111...111011 (全部で30ビット)

   この実装では、0ビットの2進の最大は、10進の
536,870,911です。これは2進では以下のようになります:

     0111...111111 (全部で30ビット)

   算術関数は整数が範囲の外かをチェックしないので、
536,870,911に1を加えると、その値は負の整数−536,870,912に
なります:

     (+ 1 536870911)
          ⇒ -536870912
          ⇒ 1000...000000 (全部で30ビット)

   このチャプターで説明する多くの関数は、数字の位置とし
て引数にマーカー(*note Markers::を参照してください)を受
け取ります。そのような関数にたいする実際の引数は数字かマ
ーカーなので、わたしたちはこれらの引数に
NUMBER-OR-MARKERという名前を与えることがあります。引数の
値がマーカーの場合、マーカーの位置が使用され、マーカーの
バッファーは無視されます。

 -- Variable: most-positive-fixnum
     この変数の値は、Emacs Lispが扱える整数の最大値です
     。典型的な値は32ビットでは 2**29 − 1 、64ビットでは
     2**61 − 1 です。

 -- Variable: most-negative-fixnum
     この変数の値は、Emacs Lispが扱える最小の整数です。
     これは負の整数です。典型的な値は32ビットでは −2**29
     、64ビットでは −2**61、 です。

   Emacs Lispでは、テキスト文字は整数により表現されます
。0から‘(max-char)’までの整数は、有効な文字として判断さ
れます。*note Character Codes::を参照してください。


File: elisp,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

3.2 Floating-Point Basics
=========================

浮動小数点数は整数ではない数を表現するのに便利です。浮動
小数点数の範囲は、使用しているマシンでのCデータ型の
‘double’と同じ範囲です。現在Emacsでサポートされているす
べてのコンピューターでは、これは倍精度のIEEE浮動小数点数
です。

   浮動小数点数にたいする入力構文は、小数点と指数のどち
らか1つ、または両方が必要とします。オプションの符号
(‘+’か‘-’)は、その数字と指数の前に記述します。たとえば、
‘1500.0’、‘+15e2’、‘15.0e+2’、‘+1500000e-3’、‘.15e4’は、
値が1500の浮動小数点数を記述する5つの方法です。これらは
すべて等価です。Common Lispと同様、Emacs Lispは、浮動小
数点数の小数点の後に、少なくとも1つの数字を必要とします
。‘1500.’は整数であり、浮動小数点数ではありません。

   Emacs Lispは‘-0.0’を、‘equal’と‘=’に関して、通常の0と
数学的に同じものとして扱います。これは、(他の処理がこれ
らを区別するとしても、‘-0.0’と‘0.0’は数学的に等しいとす
る)IEEE浮動小数点数規格にしたがっています。

   IEEE浮動小数点数規格は、浮動小数点数として、正の無限
大と、負の無限大をサポートします。この規格はNaNまたは
“not-a-number(数字ではない)”と呼ばれる値クラスも提供しま
す。数学関数は、正しい答えが存在しないような場合に、この
ような値をreturnします。たとえば‘(/ 0.0 0.0)’はNaNを
returnします。NaN値に符号がついていたとしても、実用的な
目的にたいして、Emacs Lispにおける異なるNaN値に、意味の
ある違いはありません。

   以下は、これらの特別な浮動小数点数にたいする入力構文
です:

infinity
     ‘1.0e+INF’と‘-1.0e+INF’
not-a-number
     ‘0.0e+NaN’と‘-0.0e+NaN’

   以下の関数は浮動小数点数を扱うために特化したものです:

 -- Function: isnan x
     この述語は浮動小数引数がNaNのときは‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: frexp x
     この関数はコンスセル‘(S . E)’をreturnします。ここで
     SとEは、浮動小数点数のsignificand(浮動小数点数を2の
     指数表現したときの仮引数)と指数です。

     Xが有限の場合、Sは0.5以上1.0未満の浮動小数点数で、
     Eは整数で、 X = S * 2**Eです。 Xが0または無限の場合
     、SはXと等しくなります。XがNaNの場合は、SもNaNです
     。Xが0の場合、Eは0です。

 -- Function: ldexp sig &optional exp
     この関数は、significandがSIG、指数がEXPの浮動小数点
     数をreturnします。

 -- Function: copysign x1 x2
     koの関数はX2の、X1の値にコピーして、その結果を
     returnします。X1とX2は浮動小数でなければなりません
     。

 -- Function: logb x
     この関数はXの2進指数をreturnします。より正確にいう
     と、この値は|x|の2を底とする対数を、整数に切り下げ
     たものです。

          (logb 10)
               ⇒ 3
          (logb 10.0e20)
               ⇒ 69


File: elisp,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

3.3 Type Predicates for Numbers
===============================

このセクションの関数は、数または数の特定の型にたいしてテ
ストを行ないます。関数‘integerp’および‘floatp’は、引き数
として任意のLispオブジェクト型をとることができます(そう
でないと、あまり使用する機会がありません)。しかし、述語
‘zerop’は、引き数として数を要求します。*note Predicates
on Markers::の‘integer-or-marker-p’と
‘number-or-marker-p’も参照してください。

 -- Function: floatp object
     この述語は、引数が浮動小数かどうかをテストして、も
     しそうなら‘t’、それ以外は‘nil’をreturnします。

 -- Function: integerp object
     この述語は引数が整数かどうかをテストして、もしそう
     なら‘t’、それ以外は‘nil’をreturnします。

 -- Function: numberp object
     この述語は引数が数(整数か浮動小数)かどうかをテスト
     して、もしそうなら‘t’、それ以外は‘nil’をreturnしま
     す。

 -- Function: natnump object
     この述語(名前は“natural number(自然数)”が由来です
     )は、引数が正の整数かどうかをテストして、もしそうな
     ら‘t’、それ以外は‘nil’をreturnします。0は整数と判断
     されます。

     ‘wholenump’は、‘natnump’にたいするシノニムです。

 -- Function: zerop number
     この述語は、引数が0かどうかをテストして、もしそうな
     ら‘t’、それ以外は‘nil’をreturnします。引数は数でな
     ければなりません。

     ‘(zerop x)’は、‘(= x 0)’と等価です。


File: elisp,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

3.4 Comparison of Numbers
=========================

数が数値的に等しいかテストするためには、‘eq’ではなく、通
常は‘=’を使用するべきです。同じ数値をもつ、多くの浮動小
数オブジェクトが存在するかもしれません。これらを比較する
のに‘eq’を使用する場合、これは2つの値が同じオブジェクト
かどうかをテストすることになります。対照的に、‘=’はオブ
ジェクトの数値的な値だけを比較します。

   Emacs Lispでは、それぞれの整数はは、一意なLispオブジ
ェクトです。したがって、整数に関しては、‘eq’は‘=’と同じ
です。未知の整数の値を比較するのに、‘eq’を使用するのが便
利な場合があります。なぜなら未知の値が数字でない場合でも
、‘eq’はエラーを報告しません。対照的に、引数が数でもマー
カーでもない場合、‘=’はエラーをシグナルします。しかし、
整数の比較においてさえ、使用できる場合は‘=’を使用するの
が、よいプログラミング習慣です。

   数の比較において、2つの数が同じデータ型(どちらも整数
、またはどちらも浮動小数)で、同じ値の場合は等しい数とし
て扱う、‘equal’のほうが便利なときもあります。対照的に、
‘=’は、整数と浮動小数点数を等しい数と扱うことができます
。*note Equality Predicates::を参照してください。

   他の欠点もあります。浮動小数演算は正確ではないので、
浮動小数値を比較するのが悪いアイデアのときが、しばしばあ
ります。通常は、近似的に等しいことをテストするほうがよい
でしょう。以下はこれを行なう関数です:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (= x y)
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

     Common Lispに関する注意: Common Lispは複数ワード整
     数を実装していて、2つの別の整数オブジェクトが、同じ
     数値的な値をもつことができるので、Common Lispでの数
     の比較は、常に‘=’が要求されます。Emacs Lispの整数は
     範囲が制限されているため、与えられた値に対応する整
     数オブジェクトは、1つだけです。

 -- Function: = number-or-marker &rest number-or-markers
     この関数は、すべての引数が数値的に等しいかどうかを
     テストして、もしそうなら‘t’、それ以外は‘nil’を
     returnします。

 -- Function: eql value1 value2
     この関数は‘eq’と同様に振る舞いますが、引数が両方と
     も数のときは例外です。これは数を型と数値的な値によ
     り比較するので、‘(eql 1.0 1)’は‘nil’をreturnします
     が、‘(eql 1.0 1.0)’と‘(eql 1 1)’は‘t’をreturnします
     。

 -- Function: /= number-or-marker1 number-or-marker2
     この関数は引数が数値的に等しいかどうかをテストして
     、もし異なる場合は‘t’、等しい場合は‘nil’をreturnし
     ます。

 -- Function: < number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数より小さ
     いかどうかをテストして、もしそうなら‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: <= number-or-marker &rest
          number-or-markers
     この関数は、各引数がそれぞれ、その後の引数以下かど
     うかをテストして、もしそうなら‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: > number-or-marker &rest number-or-markers
     この関数は、各引数がそれぞれ、その後の引数より大き
     いかどうかをテストして、もしそうなら‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: >= number-or-marker &rest
          number-or-markers
     この関数は、各引数がそれぞれ、その後の引数以上かど
     うかをテストして、もしそうなら‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: max number-or-marker &rest
          numbers-or-markers
     この関数は引数の最大をreturnします。引数のどれかが
     浮動小数の場合は、たとえ最大が整数であっても、浮動
     小数として値がreturnされます。

          (max 20)
               ⇒ 20
          (max 1 2.5)
               ⇒ 2.5
          (max 1 3 2.5)
               ⇒ 3.0

 -- Function: min number-or-marker &rest
          numbers-or-markers
     この関数は引数の最小をreturnします。引数のどれかが
     浮動小数の場合は、たとえ最小が整数であっても、浮動
     小数として値がreturnされます。

          (min -4 1)
               ⇒ -4

 -- Function: abs number
     この関数はNUMBERの絶対値をreturnします。


File: elisp,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

3.5 Numeric Conversions
=======================

整数を浮動少数に変換するには、関数‘float’を使用します。

 -- Function: float number
     これは浮動小数に変換されたNUMBERをreturnします。す
     でにNUMBERが浮動小数の場合、‘float’はそれを変更せず
     にreturnします。

   浮動小数点数を整数に変換する関数が4つあります。これら
は浮動小数点数を丸める方法がことなります。これらはすべて
引数NUMBERと、オプション引数としてDIVISORを受け取ります
。引数は両方とも整数または浮動小数点数です。DIVISORが
‘nil’のこともあります。DIVISORが‘nil’または省略された場
合、これらの関数はNUMBERを整数に変換するか、それが既に整
数の場合は変更せずにreturnします。DIVISORが非‘nil’の場合
、これらの関数はNUMBERをDIVISORで除してから、その結果を
整数に変換します。DIVISORが(整数か浮動小数かに関わらず
)0の場合、Emacsは‘arith-error’エラーをシグナルします。

 -- Function: truncate number &optional divisor
     これは0に向かって丸めることにより整数に変換した
     NUMBERをreturnします。

          (truncate 1.2)
               ⇒ 1
          (truncate 1.7)
               ⇒ 1
          (truncate -1.2)
               ⇒ -1
          (truncate -1.7)
               ⇒ -1

 -- Function: floor number &optional divisor
     これは、下方(負の無限大に向かって)に丸めることによ
     り整数に変換したNUMBERをreturnします。

     DIVISORが指定された場合、‘mod’に相当する種類の除算
     演算を使用して、下方に丸めを行ないます。

          (floor 1.2)
               ⇒ 1
          (floor 1.7)
               ⇒ 1
          (floor -1.2)
               ⇒ -2
          (floor -1.7)
               ⇒ -2
          (floor 5.99 3)
               ⇒ 1

 -- Function: ceiling number &optional divisor
     これは、上方(正の無限大に向かって)に丸めることによ
     り整数に変換したNUMBERをreturnします。

          (ceiling 1.2)
               ⇒ 2
          (ceiling 1.7)
               ⇒ 2
          (ceiling -1.2)
               ⇒ -1
          (ceiling -1.7)
               ⇒ -1

 -- Function: round number &optional divisor
     これは、もっとも近い整数に向かって丸めることにより
     整数に変換したNUMBERをreturnします。2つの整数から等
     距離にある値の丸めでは、偶数の整数をreturnします。

          (round 1.2)
               ⇒ 1
          (round 1.7)
               ⇒ 2
          (round -1.2)
               ⇒ -1
          (round -1.7)
               ⇒ -2


File: elisp,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

3.6 Arithmetic Operations
=========================

Emacs Lispは伝統的な4つの算術演算(加減乗除)、同様に剰余
とmodulusの関数、および1加算、1減算の関数を提供します。
‘%’を除き、これらの各関数は引き数として整数か浮動小数を
受け取り、浮動小数の引数がある場合は、浮動小数点数を
returnします。

   Emacs Lispの算術関数は整数のオーバーフローをチェック
しません。したがって‘(1+ 536870911)’は−536870912に評価さ
れるかもしれず、それはハードウェアーに依存します。

 -- Function: 1+ number-or-marker
     この関数はNUMBER-OR-MARKER + 1をreturnします。例え
     ば、

          (setq foo 4)
               ⇒ 4
          (1+ foo)
               ⇒ 5

     この関数はCの演算子‘++’とは類似しません — この関数
     は変数をインクリメントしません。この関数は和を計算
     するだけです、したがって以下を続けて評価すると、

          foo
               ⇒ 4

     変数をインクリメントしたい場合は、以下のように
     ‘setq’を使用しなければなりません:

          (setq foo (1+ foo))
               ⇒ 5

 -- Function: 1- number-or-marker
     この関数はNUMBER-OR-MARKER − 1をreturnします。

 -- Function: + &rest numbers-or-markers
     この関数は引数すべてを加算します。引数を与えない場
     合、‘+’は0をreturnします。

          (+)
               ⇒ 0
          (+ 1)
               ⇒ 1
          (+ 1 2 3 4)
               ⇒ 10

 -- Function: - &optional number-or-marker &rest
          more-numbers-or-markers
     ‘-’関数は2つの目的 — 符号反転と減算 —を果たします。
     ‘-’に1つの引数を与えた場合、値は引数の符号を反転し
     たものになります。複数の引数がある場合、
     NUMBER-OR-MARKERからMORE-NUMBERS-OR-MARKERSまでの各
     値を蓄積的に減算します。引数がない場合、結果は0です
     。

          (- 10 1 2 3 4)
               ⇒ 0
          (- 10)
               ⇒ -10
          (-)
               ⇒ 0

 -- Function: * &rest numbers-or-markers
     この関数はすべての引数を乗じて、積をreturnします。
     引数がない場合、‘*’は1をreturnします。

          (*)
               ⇒ 1
          (* 1)
               ⇒ 1
          (* 1 2 3 4)
               ⇒ 24

 -- Function: / dividend divisor &rest divisors
     この関数はDIVIDENDをDIVISORで除し、商をreturnします
     。追加の引数DIVISORSがある場合、その後さらに
     DIVIDENDをDIVISORSで順に除します。各引数は数かマー
     カーです。

     すべての引数が整数の場合、結果は各除算の後に商を0へ
     向かって丸めることにより得られる整数になります。

          (/ 6 2)
               ⇒ 3
          (/ 5 2)
               ⇒ 2
          (/ 5.0 2)
               ⇒ 2.5
          (/ 5 2.0)
               ⇒ 2.5
          (/ 5.0 2.0)
               ⇒ 2.5
          (/ 25 3 2)
               ⇒ 4
          (/ -17 6)
               ⇒ -2

     整数を整数0で除すると、Emacsは‘arith-error’エラー
     (*note Errors::を参照してください)をシグナルします
     。浮動小数の除算においては、0でない数を0で除するこ
     とにより、正の無限大または負の無限大を得ます(*note
     Float Basics::を参照してください)。

 -- Function: % dividend divisor
     この関数は、DIVIDENDをDIVISORで除した後、その剰余を
     整数でreturnします。引数は整数かマーカーでなければ
     なりません。

     任意の2つの整数DIVIDENDとDIVISORにたいして、

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     は、DIVISORが非0の場合は常にDIVIDENDと等しくなりま
     す。

          (% 9 4)
               ⇒ 1
          (% -9 4)
               ⇒ -1
          (% 9 -4)
               ⇒ 1
          (% -9 -4)
               ⇒ -1

 -- Function: mod dividend divisor
     この関数はDIVIDENDのDIVISORにたいするmodulo、言い換
     えるとDIVIDENDをDIVISORで除した後の剰余(ただし符号
     はDIVISORと同じ)えおreturnします。引数は数かマーカ
     ーでなければなりません。

     ‘%’とは異なり、‘mod’は浮動小数の引数を許容します。
     これは商を整数に下方(負の無限大に向かって)へ丸めて
     、剰余を計算するのにこの商を使用します。

     DIVISORが0のとき‘mod’は、両方の引数が整数の場合は
     ‘arith-error’エラーをシグナルし、それ以外はNaNを
     returnします。

          (mod 9 4)
               ⇒ 1
          (mod -9 4)
               ⇒ 3
          (mod 9 -4)
               ⇒ -3
          (mod -9 -4)
               ⇒ -1
          (mod 5.5 2.5)
               ⇒ .5

     任意の2つの数DIVIDENDとDIVISORにたいして、

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     は常にDIVIDENDになります(ただし引数のどちらかが浮動
     小数の場合は丸め誤差の範囲内で等しく、DIVIDENDが整
     数でDIVISORが0の場合は‘arith-error’となります)。
     ‘floor’については、*note Numeric Conversions::を参
     照してください。


File: elisp,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

3.7 Rounding Operations
=======================

関数‘ffloor’、‘fceiling’、‘fround’、‘ftruncate’は、浮動
小数の引数をとり、値が近くの整数であるような浮動少数を
returnします。‘ffloor’は一番近い下方の整数、‘fceiling’は
一番近い上方の整数、‘ftruncate’は0に向かう方向で一番近い
整数、‘fround’は一番近い整数をreturnします。

 -- Function: ffloor float
     この関数はFLOATを次に小さい整数値に丸めて、その値を
     浮動小数点数としてreturnします。

 -- Function: fceiling float
     この関数はFLOATを次に大きい整数値に丸めて、その値を
     浮動小数点数としてreturnします。

 -- Function: ftruncate float
     この関数はFLOATを0方向の整数値に丸めて、その値を浮
     動小数点数としてreturnします。

 -- Function: fround float
     この関数はFLOATを一番近い整数値に丸めて、その値を浮
     動小数点数としてreturnします。2つの整数値との距離が
     等しい値にたいする丸めでは、偶数の整数をreturnしま
     す。


File: elisp,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

3.8 Bitwise Operations on Integers
==================================

コンピューターの中では、整数は“ビット(bit: 0か1の数字
)”のシーケンスである、2進数で表されます。ビット演算は、
そのようなシーケンスの中の個々のビットに作用します。たと
えば、“シフト(shifting)”はシーケンス全体を1つ以上左また
は右に移動して、“移動された”のと同じパターンを再生します
。

   Emacs Lispのビット演算は、整数だけに適用されます。

 -- Function: lsh integer1 count
     ‘lsh’は“logical shift”の略で、INTEGER1のビットを左
     にCOUNT個シフトします。COUNTが負の場合は右にシフト
     し、シフトにより空きになったビットには0がセットされ
     ます。COUNT isが負の場合、‘lsh’は左端(最上位)に0を
     シフトするので、INTEGER1が負の場合でも、正の結果が
     生成されます。これと対照的なのが、以下で説明する
     ‘ash’です。

     以下に、‘lsh’でビットパターンの位置を1つ左にシフト
     する例を2つ紹介します。ここでは下位8ビットの2進パタ
     ーンだけを表示しており、残りのビットはすべて0です。

          (lsh 5 1)
               ⇒ 10
          ;; 10進の5は、10進の10になります。
          00000101 ⇒ 00001010

          (lsh 7 1)
               ⇒ 14
          ;; 10進の7は、10進の14になります。
          00000111 ⇒ 00001110

     この例が説明するように、ビットパターンを左に1シフト
     すると、生成される数は、元の数の2倍になります。

     ビットパターンを左に2シフトすると、以下(8ビット2進
     数)の結果が生成されます:

          (lsh 3 2)
               ⇒ 12
          ;; 10進の3は、10進の12になります。
          00000011 ⇒ 00001100

     一方、右に1シフトすると、以下のようになります:

          (lsh 6 -1)
               ⇒ 3
          ;; 10進の6は10進の3になります。
          00000110 ⇒ 00000011

          (lsh 5 -1)
               ⇒ 2
          ;; 10進の5は、10進の2になります。
          00000101 ⇒ 00000010

     例が明かにするように、右に1シフトすることにより、正
     の整数の値が2で除され、下方に丸められます。

     関数‘lsh’は、他のEmacs Lisp算術関数と同様、オーバー
     フローをチェックしないので、左にシフトすることによ
     り上位ビットが捨てられ、その数の符号が変化するかも
     しれません。たとえば30ビットの実装では、
     536,870,911を左にシフトすると、−2が生成されます。

          (lsh 536870911 1)          ; 左シフト
               ⇒ -2

     2進では、この引数は以下のようになります:

          ;; 10進の536,870,911
          0111...111111 (全部で30ビット)

     これを左にシフトすると、以下のようになります:

          ;; 10進の−2
          1111...111110 (全部で30ビット)

 -- Function: ash integer1 count
     ‘ash’ (“算術シフト(arithmetic shift)”)は、
     INTEGER1の中のビット位置を左にCOUNTシフトします。
     COUNTが負の場合は右にシフトします。

     ‘ash’は‘lsh’と同じ結果を与えますが、例外は
     INTEGER1とCOUNTがとみに負の場合です。この場合、
     ‘lsh’は左にできる空きビットに0を置きますが、‘ash’は
     1を置きます。

     したがって‘ash’でビットパターンの位置を右に1シフト
     すると、以下のようになります:

          (ash -6 -1) ⇒ -3
          ;; 10進の−6は、10進の−3になります
          1111...111010 (30 bits total)
               ⇒
          1111...111101 (30 bits total)

     対照的に、‘lsh’でビットパターンの位置を1右にシフト
     すると、以下のようになります:

          (lsh -6 -1) ⇒ 536870909
          ;; 10進の−6は、10進の536,870,909になります。
          1111...111010 (30 bits total)
               ⇒
          0111...111101 (30 bits total)

     他にも例を示します:

                             ;         30ビットの2進数

          (lsh 5 2)          ;   5  =  0000...000101
               ⇒ 20         ;      =  0000...010100
          (ash 5 2)
               ⇒ 20
          (lsh -5 2)         ;  -5  =  1111...111011
               ⇒ -20        ;      =  1111...101100
          (ash -5 2)
               ⇒ -20
          (lsh 5 -2)         ;   5  =  0000...000101
               ⇒ 1          ;      =  0000...000001
          (ash 5 -2)
               ⇒ 1
          (lsh -5 -2)        ;  -5  =  1111...111011
               ⇒ 268435454
                             ;      =  0011...111110
          (ash -5 -2)        ;  -5  =  1111...111011
               ⇒ -2         ;      =  1111...111110

 -- Function: logand &rest ints-or-markers
     この関数は、引数の“論理積(logical and)”をreturnしま
     す。すべての引数のN番目のビットがセットされている場
     合に限り、結果のN番目のビットがセットされます(“セッ
     ト”とは、そのビットの値が0ではなく1であることを意味
     します)。

     たとえば、13と12の“論理積”は — 4ビット2進数を使用す
     ると1101と1100の論理積は1100を生成します。この2進数
     では両方とも、左の2ビットがセット(つまり1)されてい
     るので、returnされる値の左2ビットがセットされます。
     しかし右の2ビットにたいしては、少なくとも1つの引数
     でそのビットが0なので、returnされる値の右2ビットは
     0になります。

     したがって、

          (logand 13 12)
               ⇒ 12

     ‘logand’に何の引数も綿さない場合は、値−1がreturnさ
     れます。−1を2進数で表すとすべてのビットが1なので、
     −1は‘logand’にたいする単位元(identity element)です
     。

                             ;        30ビット2進数

          (logand 14 13)     ; 14  =  0000...001110
                             ; 13  =  0000...001101
               ⇒ 12         ; 12  =  0000...001100

          (logand 14 13 4)   ; 14  =  0000...001110
                             ; 13  =  0000...001101
                             ;  4  =  0000...000100
               ⇒ 4          ;  4  =  0000...000100

          (logand)
               ⇒ -1         ; -1  =  1111...111111

 -- Function: logior &rest ints-or-markers
     この関数は、引数の“論理和(inclusive or)”をreturnし
     ます。少なくとも1つの引数でN番目のビットがセットさ
     れていれば、結果のN番目のビットがセットされます。引
     数を与えない場合の結果は、この処理にたいする単位元
     である0です。‘logior’に渡す引数が1つだけの場合、そ
     の引数がreturnされます。

                             ;        30ビット2進数

          (logior 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 13         ; 13  =  0000...001101

          (logior 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 15         ; 15  =  0000...001111

 -- Function: logxor &rest ints-or-markers
     この関数は、引数の“排他的論理和(exclusive or)”を
     returnします。N番目のビットがセットされている引数の
     数が奇数個の場合だけ、結果のN番目のビットがセットさ
     れます。引数を与えない場合の結果は、この処理の単位
     元である0となります。‘logxor’に渡す引数が1つだけの
     場合、その引数がreturnされます。

                             ;        30ビット2進数

          (logxor 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               ⇒ 9          ;  9  =  0000...001001

          (logxor 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               ⇒ 14         ; 14  =  0000...001110

 -- Function: lognot integer
     この関数は引数の論理的な補数(logical complement)を
     returnします。INTEGERのN番目のビットが0の場合に限り
     、結果のN番目のビットが1になります。逆も成り立ちま
     す。

          (lognot 5)
               ⇒ -6
          ;;  5  =  0000...000101 (全部で30ビット)
          ;; becomes
          ;; -6  =  1111...111010 (全部で30ビット)


File: elisp,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

3.9 Standard Mathematical Functions
===================================

これらの数学的関数は、引き数として整数と同様に浮動小数点
数も許容します。

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     これらは三角関数です、引数ARGはラジアン単位です。

 -- Function: asin arg
     ‘(asin ARG)’の値は、sinの値がARGとなるような −pi/2
     から pi/2 (境界値を含む)の数です。ARGが範囲外([−1,
     1]の外)の場合、‘asin’はNaNをreturnします。

 -- Function: acos arg
     ‘(acos ARG)’の値は、cosの値がARGとなるような、0から
     pi (境界値を含む)の数です。argが範囲外([-1, 1]の外
     )の場合、‘acos’はNaNをreturnします。

 -- Function: atan y &optional x
     ‘(atan Y)’の値は、tanの値がYとなるような、 −pi/2 か
     ら pi/2 (境界値を含まない)の数です。オプションの第
     2引数Xが与えられた場合、‘(atan y x)’の値はベクトル
     ‘[X, Y]’と‘X’軸が成す角度のラジアン値です。

 -- Function: exp arg
     これは指数関数です。この関数はeの指数ARGをreturnし
     ます。

 -- Function: log arg &optional base
     この関数は底をBASEとするARGの対数をreturnします。
     BASEを指定しない場合、自然底(natural base)eが使用さ
     れます。ARGまたhBASEが負の場合、‘log’はNaNを
     returnします。

 -- Function: expt x y
     この関数はXにYを乗じてreturnします。引数が両方とも
     整数で、Yが正の場合、結果は整数になります。この場合
     オーバーフローによる切り捨てが発生するので、注意し
     てください。Xが有限の負数で、Yが有限の非整数の場合
     、‘expt’はNaNをreturnします。

 -- Function: sqrt arg
     これはARGの平方根をreturnします。ARGが有限で0より小
     さい場合、‘sqrt’はNaNをreturnします。

   加えて、Emacsは以下の数学的な定数を定義します:

 -- Variable: float-e
     自然対数e(2.71828...)。

 -- Variable: float-pi
     円周率pi(3.14159...)。


File: elisp,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

3.10 Random Numbers
===================

決定論的なコンピュータープログラムでは、真の乱数を生成す
ることはできません。しかしほとんどの目的には、“疑似乱数
(pseudo-random numbers)”で充分です。一連の疑似乱数は、決
定論的な手法により生成されます。真の乱数ではありませんが
、それらにはランダム列を模する特別な性質があります。たと
えば疑似ランダム系では、すべての可能な値は、均等に発生し
ます。

   疑似乱数は“シード(seed: 種)”から生成されます。与えら
れた任意のシードから開始することにより、‘random’関数は常
に同じ数列を生成します。デフォルトでは、Emacsは開始時に
乱数シードを初期化することにより、それぞれのEmacsの実行
において、‘random’の値シーケンスは(ほとんど確実に)異なり
ます。

   再現可能な乱数シーケンスが欲しい場合もあります。たと
えば乱数シーケンスに依存するプログラムをデバッグする場合
、プログラムの各実行において同じ挙動を得ることが助けにな
ります。再現可能なシーケンスを作成するには、‘(random
"")’を実行します。これは特定のEmacsの実行可能ファイルに
たいして、シードに定数値をセットします(しかし、この実行
可能ファイルは、その他のEmacsビルドと異なるものになるで
しょう)。シード値として、他のさまざまな文字列を使用する
ことができます。

 -- Function: random &optional limit
     この関数は疑似乱数の整数をreturnします。繰り返し呼
     び出すと、一連の疑似乱数の整数をreturnします。

     LIMITが正の整数の場合、値は負ではないLIMIT未満の値
     から選択されます。それ以外では、値は
     ‘most-negative-fixnum’から‘most-positive-fixnum’の
     間の、Lispで表現可能な任意の整数(*note Integer
     Basics::を参照してください)になるでしょう。

     LIMITが‘t’の場合は、Emacsを再起動したときに、新しい
     シードを選択することを意味します。

     LIMITが文字列の場合、その文字列定数にもとづいた新し
     いシードを選択することを意味します。


File: elisp,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

4 Strings and Characters
************************

Emacs Lispの文字列は、文字列の順序列(ordered sequence)を
含む配列です。文字列はシンボル、バッファー、ファイルの名
前に使用されます。その他にも、ユーザーにたいしてメッセー
ジを送ったりバッファー間でコピーする文字列を保持したり等
の、他の多くの目的にたいして使用されます。文字列は特に重
要なので、Emacs Lispは特別に文字列を操作するための、多く
の関数をもちます。Emacs Lispプログラムは、個々の文字より
、文字列を多用します。

   キーボードの文字イベントの文字列にたいする特別な考慮
は、*note Strings of Events::を参照してください。

* Menu:

* Basics: String Basics.     文字列と文字の基本的なプロパティー。
* Predicates for Strings::   オブジェクトが文字列か文字化をテストする。
* Creating Strings::         新しい文字列を割り当てる関数。
* Modifying Strings::        既存の文字列の内容を変更する。
* Text Comparison::          文字または文字列を比較する。
* String Conversion::        文字から文字列、文字から文字列への変換。
* Formatting Strings::       ‘format’:
                               ‘printf’のEmacsバージョン。
* Case Conversion::          大文字小文字変換関数。
* Case Tables::              大文字小文字変換のカスタマイズ。


File: elisp,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

4.1 String and Character Basics
===============================

文字(character)とは、テキスト内の1つの文字を表すLispオブ
ジェクトです。Emacs Lispでは、文字は単なる整数です。ある
整数が文字か文字でないかを区別するのは、それが使用される
方法だけです。Emacsでの文字表現についての詳細は、*note
Character Codes::を参照してください。

   文字列(string)とは、固定された文字シーケンスです。こ
れは“配列(array)”と呼ばれるシーケンス型で、配列長が固定
で、1度作成したら変更できないことを意味します(*note
Sequences Arrays Vectors::を参照してください)。Cとは異な
り、Emacs Lispの文字列は文字コードを判断することにより終
端_されません_。

   文字列は配列であり、したがって同様にシーケンスでもあ
るので、*note Sequences Arrays Vectors::にドキュメントさ
れている一般的な配列関数やシーケンス関数で、文字列を処理
できます。たとえば、文字列内の特定の文字にアクセスしたり
変更することができますしかし表示された文字列の幅を計算す
るために、‘length’を使用するべきでは_ない_ことに注意して
ください。かわりに‘string-width’を使用してください(*note
Size of Displayed Text::を参照してください)。

   Emacs文字列での非ASCIIにたいすテキスト表現は2つ — ユ
ニバイト(unibyte)とマルチバイト(multibyte)がありますほと
んどのLispプログラミングでは、これら2つの表現を気にする
必要はありません。詳細は、*note Text Representations::を
参照してください。

   キーシーケンスがユニバイト文字列で表されることがあり
ます。ユニバイト文字列がキーシーケンスの場合、範囲128か
ら255までの文字列要素は、範囲128から255の文字コードでは
なく、メタ文字(これは非常に大きな整数です)を表します。文
字列はhyper、super、altで修飾された文字を保持できません
。文字列はASCIIコントロール文字を保持できますが、それは
他のコントロール文字です。文字列はASCIIコントロール文字
の大文字小文字を区別できません。そのような文字をシーケン
スに保存したい場合は、文字列ではなくベクターを使用しなけ
ればなりません。キーボード入力文字についての情報は、
*note Character Type::を参照してください。

   文字列は正規表現を保持するために便利です。
‘string-match’ (*note Regexp Search::を参照してください
)を使用して、文字列にたいして正規表現をマッチすることも
できます。関数‘match-string’ (*note Simple Match Data::を
参照してください)と、‘replace-match’ (*note Replacing
Match::)は、文字列にたいして正規表現をマッチした後に、文
字列を分解、変更するのに便利です。

   バッファーのように、文字列は文字列内の文字自身と、そ
の文字にたいするテキストプロパティーを含みます。*note
Text Properties::を参照してください。文字列からバッファ
ーや他の文字列にテキストをコピーする、すべてのLispプリミ
ティブ(Lisp primitives)は、コピーされる文字のプロパティ
ーもコピーします。

   文字列を表示したり、バッファーにコピーする関数につい
ての情報は、*note Text::を参照してください。文字または文
字列の構文についての情報は、*note Character Type::と
*note String Type::を参照してください。異なるテキスト表
現間で変換したり、文字コードをエンコード、デコードする関
数については、*note Non-ASCII Characters::を参照してくだ
さい。


File: elisp,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

4.2 Predicates for Strings
==========================

一般的なシーケンスや配列にたいする述語についての情報は、
*note Sequences Arrays Vectors::、および*note Arrays::を
参照してください。

 -- Function: stringp object
     この関数はOBJECTが文字列の場合は‘t’、それ以外は
     ‘nil’をreturnします。

 -- Function: string-or-null-p object
     この関数は、OBJECTが文字列または‘nil’の場合は‘t’、
     それ以外は‘nil’をreturnします。

 -- Function: char-or-string-p object
     この関数は、OBJECTが文字列または文字(たとえば整数
     )の場合は‘t’、それ以外は‘nil’をreturnします。


File: elisp,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

4.3 Creating Strings
====================

以下の関数は、新たに文字列を作成したり、文字列同士を結合
して文字列を作成したり、文字列の一部から文字列を作成する
関数です。

 -- Function: make-string count character
     この関数は、CHARACTERをCOUNT回繰り返すことにより作
     成された文字列をreturnします。COUNTが負の場合は、エ
     ラーをシグナルします。

          (make-string 5 ?x)
               ⇒ "xxxxx"
          (make-string 0 ?x)
               ⇒ ""

     この関数に対応する他の関数には‘make-vector’ (*note
     Vectors::を参照してください)、および‘make-list’
     (*note Building Lists::を参照してください)が含まれ
     ます。

 -- Function: string &rest characters
     この関数は、文字CHARACTERSを含む文字列をreturnしま
     す。

          (string ?a ?b ?c)
               ⇒ "abc"

 -- Function: substring string start &optional end
     この関数は、STRINGから、インデックスSTARTの文字(そ
     の文字を含む)から、ENDまでの文字(その文字は含まない
     )の範囲の文字から構成される、新しい文字列をreturnし
     ます。文字列の最初の文字がインデックス0になります。

          (substring "abcdefg" 0 3)
               ⇒ "abc"

     上記の例では、‘a’のインデックスは0、‘b’のインデック
     スは1、‘c’のインデックスは2です。インデックス3 — こ
     の文字列の4番目の文字 — は、部分文字列がコピーされ
     る文字位置までをマークします。したがって文字列
     ‘"abcdefg"’から、‘abc’がコピーされます。

     負のかすは、文字列の最後から数えることを意味するの
     で、−1は文字列の最後の文字のインデックスです。たと
     えば:

          (substring "abcdefg" -3 -1)
               ⇒ "ef"

     この例では、‘e’のインデックスは−3、‘f’のインデック
     スは−2、‘g’のインデックスは−1です。したがって、
     ‘e’と‘f’が含まれ、‘g’は含まれません。

     ENDに‘nil’が使用された場合、それは文字列の長さを意
     味します。したがって、

          (substring "abcdefg" -3 nil)
               ⇒ "efg"

     引数ENDを省略した場合、それは‘nil’を指定したのと同
     じです。‘(substring STRING 0)’は、STRINGのすべてを
     コピーしてreturnします。

          (substring "abcdefg" 0)
               ⇒ "abcdefg"

     しかし、この目的のためには‘copy-sequence’を推奨しま
     す(*note Sequence Functions::)。

     STRINGからコピーされた文字がテキストプロパティーを
     もつ場合、そのプロパティーは新しい文字列へもコピー
     されます。*note Text Properties::を参照してください
     。

     ‘substring’の最初の引数にはベクターも指定できます。
     たとえば:

          (substring [a b (c) "d"] 1 3)
               ⇒ [b (c)]

     STARTが整数でない場合、またはENDが整数でも‘nil’でも
     ない場合は、‘wrong-type-argument’エラーがシグナルさ
     れます。STARTがENDの後の文字を指す場合、または
     STRINGにたいして範囲外の整数をどちらかに指定した場
     合は、‘args-out-of-range’エラーがシグナルされます。

     この関数に対応するのは‘buffer-substring’ (*note
     Buffer Contents::を参照してください)で、これはカレ
     ントバッファー内のテキストの一部を含む文字列を
     returnします。文字列の先頭はインデックス0ですが、バ
     ッファーの先頭はインデックス1です。

 -- Function: substring-no-properties string &optional
          start end
     これは‘substring’と同じようにL機能しますが、値から
     すべてのテキストプロパティーを破棄します。STARTを省
     略したり、‘nil’を指定することができ、この場合0に等
     しくなります。したがって
     ‘(substring-no-properties STRING)’は、すべてのテキ
     ストプロパティーが削除されたSTRINGのコピーを
     returnします。

 -- Function: concat &rest sequences
     この関数は、渡された引数内の文字からなる、新しい文
     字列をreturnします(もしあればテキストプロパティーも
     )。引数には文字列、数のリスト、数のベクターを指定で
     きます。引数は変更されません。‘concat’に引数を指定
     しない場合、空文字列をreturnします。

          (concat "abc" "-def")
               ⇒ "abc-def"
          (concat "abc" (list 120 121) [122])
               ⇒ "abcxyz"
          ;; ‘nil’hあ空のシーケンス。
          (concat "abc" nil "-def")
               ⇒ "abc-def"
          (concat "The " "quick brown " "fox.")
               ⇒ "The quick brown fox."
          (concat)
               ⇒ ""

     この関数は常に、任意の既存の文字列にたいして‘eq’で
     はない、新しい文字列を構築しますが、結果が空文字列
     の時は例外です(スペースを省くために、Emacsは空のマ
     ルチバイト文字列を1つだけ作成します)。

     他の結合関数(concatenation functions)についての情報
     は、*note Mapping Functions::の‘mapconcat’、*note
     Vector Functions::の‘vconcat’、*note Building
     Lists::の‘append’を参照してください。シェルコマンド
     で使用される文字列の中に、個々のコマンドライン引数
     を結合するには、*note combine-and-quote-strings:
     Shell Arguments.を参照してください。

 -- Function: split-string string &optional separators
          omit-nulls trim
     この関数は、正規表現SEPARATORS(*note Regular
     Expressions::を参照してください)にもとづいて、
     STRINGを部分文字列に分解します。SEPARATORSにたいす
     る各マッチは、分割位置を定義します。分割位置の間に
     ある部分文字列を、リストにまとめてreturnします。

     OMIT-NULLSが‘nil’(または省略)の場合、連続する2つの
     SEPARATORSへのマッチ、またはSTRINGの最初か最後にマ
     ッチしたときの空文字列が結果に含まれます。
     OMIT-NULLSが‘t’の場合、これらの空文字列は結果から除
     外されます。

     SEPARATORSが‘nil’(または省略)の場合、デフォルトは
     ‘split-string-default-separators’の値になります。

     特別なケースとして、SEPARATORSが‘nil’(または省略)の
     場合、常に結果から空文字列が除外されます。したがっ
     て:

          (split-string "  two words ")
               ⇒ ("two" "words")

     結果は、ほとんど有用ではないであろう‘("" "two"
     "words" "")’という結果ではありません。このような結
     果が必要な時は、SEPARATORSに明示的な値を使用します:

          (split-string "  two words "
                        split-string-default-separators)
               ⇒ ("" "two" "words" "")

     他にも例を示します:

          (split-string "Soup is good food" "o")
               ⇒ ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o" t)
               ⇒ ("S" "up is g" "d f" "d")
          (split-string "Soup is good food" "o+")
               ⇒ ("S" "up is g" "d f" "d")

     空のマッチはカウントされます。例外は、空でないマッ
     チを使用することにより、すでに文字列の最後に到達し
     ているとき、またはSTRINGが空の時で、この場合
     ‘split-string’は最後の空マッチを探しません。

          (split-string "aooob" "o*")
               ⇒ ("" "a" "" "b" "")
          (split-string "ooaboo" "o*")
               ⇒ ("" "" "a" "b" "")
          (split-string "" "")
               ⇒ ("")

     しかし、SEPARATORSが空文字列にマッチできるとき、通
     常はOMIT-NULLSは‘t’にすれば、前の3つの例の不明瞭さ
     は、ほとんど発生しません:

          (split-string "Soup is good food" "o*" t)
               ⇒ ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "" t)
               ⇒ ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
          (split-string "" "" t)
               ⇒ nil

     空でないマッチより空のマッチを優先するような、一部
     の“非貪欲(non-greedy)”な値をSEPARATORSに指定するこ
     とにより、幾分奇妙(しかし予見可能)な振る舞いが発生
     する場合があります。繰り返しますが、そのような値は
     実際にはまれです:

          (split-string "ooo" "o*" t)
               ⇒ nil
          (split-string "ooo" "\\|o+" t)
               ⇒ ("o" "o" "o")

     オプションの引数TRIMが非‘nil’の場合、その値は各部分
     文字列の最初と最後からトリムするテキストにマッチす
     る正規表現を指定します。トリムにより、その部分文字
     列が空になるような場合、それは空文字列として扱われ
     ます。

     文字列を分割して、‘call-process’や‘start-process’に
     適した、個々のコマンドライン引数のリストにする必要
     がある場合は、*note split-string-and-unquote: Shell
     Arguments.を参照してください。

 -- Variable: split-string-default-separators
     ‘split-string’のSEPARATORSにたいするデフォルト値で
     す。通常の値は、‘"[ \f\t\n\r\v]+"’です。


File: elisp,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

4.4 Modifying Strings
=====================

既存の文字列の内容を変更するもっとも基本的な方法は、
‘aset’ (*note Array Functions::)を使用する方法です。
‘(aset STRING IDX CHAR)’は、STRINGのインデックスIDXに、
CHARを格納します。それぞれの文字は１文字以上を占有します
が、すでにインデックスの場所にある文字のバイト数が、
CHARが要するバイト数と異なる場合、‘aset’はエラーをシグナ
ルします。

   より強力な関数は‘store-substring’です:

 -- Function: store-substring string idx obj
     この関数は、インデックスIDXで開始される位置にOBJを
     格納することにより、文字列STRINGの内容の一部を変更
     します。OBJは文字、または(STRINGより小さい)文字列で
     す。

     既存の文字列の長さを変更するのは不可能なので、
     STRINGの実際の長さにOBJが収まらない場合、または
     STRINGのその位置に現在ある文字のバイト数が、新しい
     文字に必要なバイト数と異なる場合はエラーになります
     。

   パスワードを含む文字列をクリアーするときは、
‘clear-string’を使用します:

 -- Function: clear-string string
     これはSTRINGをユニバイト文字列として、内容を0にクリ
     アーします。これによりSTRINGの長さも変更されるでし
     ょう。


File: elisp,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

4.5 Comparison of Characters and Strings
========================================

 -- Function: char-equal character1 character2
     この関数は引数が同じ文字を表す場合は‘t’、それ以外は
     ‘nil’をreturnします。‘case-fold-search’が非‘nil’の
     場合、この関数は大文字小文字の違いを無視します。

          (char-equal ?x ?x)
               ⇒ t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               ⇒ nil

 -- Function: string= string1 string2
     この関数は、2つの文字列の文字が正確にマッチする場合
     は、‘t’をreturnします。引数にシンボルを指定すること
     もでき、この場合はシンボル名が使用されます。
     ‘case-fold-search’とは無関係に、大文字小文字は常に
     意味をもちます。

     この関数は、‘equal’で2つの文字列を比較するのと等価
     です(*note Equality Predicates::を参照してください
     )。特に、2つの文字列のテキストプロパティーは無視さ
     れます。テキストプロパティーだけが異なる文字列を区
     別する必要がある場合は、
     ‘equal-including-properties’を使用します。しかし
     ‘equal’とは異なり、どちらかの引数が文字列でもシンボ
     ルでもない場合、‘string=’はエラーをシグナルします。

          (string= "abc" "abc")
               ⇒ t
          (string= "abc" "ABC")
               ⇒ nil
          (string= "ab" "ABC")
               ⇒ nil

     技術的な理由により、ユニバイト文字列とマルチバイト
     文字列が‘equal’なのは、それらが同じ文字コードのシー
     ケンスを含み、それらすべてのコードが0から
     127(ASCII)か、160から255(‘eight-bit-graphic’)のとき
     だけです。しかしユニバイト文字列をマルチバイト文字
     列に変更する際、コードが160から255の範囲にあるすべ
     ての文字はより高いコードに変換され、ASCII文字は変換
     されないまま残ります。したがってユニバイト文字列と
     、それを変換したマルチバイト文字列は、その文字列の
     すべてがASCIIのときだけ‘equal’です。マルチバイト文
     字列中で、もし文字コード160から255の文字があったと
     しても、それは完全に正しいとは言えません。結果とし
     て、すべてがASCIIではないユニバイト文字列とマルチバ
     イト文字列が‘equal’であるという状況は、もしかしたら
     Emacs Lispプロプラマーが直面するかもしれない、とて
     も希少な偽術的に不可解な状況だといえます。*note
     Text Representations::を参照してください。

 -- Function: string-equal string1 string2
     ‘string-equal’は‘string=’に対する別名です。

 -- Function: string< string1 string2
     この関数は、2つの文字列を1文字づつ比較します。この
     関数は、同時に2つの文字列をスキャンして、対応する文
     字同士がマッチしない最初のペアを探します。2つの文字
     列内で、小さいほうの文字がSTRING1の文字の場合、
     STRING1が小さいことになり、この関数は‘t’をreturnし
     ます。小さいほうの文字がSTRING2の文字の場合、
     STRING1が大きいことになり、この関数は‘nil’を
     returnします。2つの文字列が完全にマッチした場合、値
     は‘nil’になります。

     文字のペアは、文字コードで比較されます。ASCII文字セ
     ットでは、小文字英字は大文字英字より、高い数値をも
     つことに留意してください。数字および多くの句読点文
     字は、大文字英字より低い数値をもちます。ASCII文字は
     、任意の非ASCII文字より小さくなります。ユニバイト非
     ASCII文字は、任意のマルチバイト非ASCII文字より、常
     に小さくなります(*note Text Representations::を参照
     してください)。

          (string< "abc" "abd")
               ⇒ t
          (string< "abd" "abc")
               ⇒ nil
          (string< "123" "abc")
               ⇒ t

     文字列の長さが異なり、STRING1の長さまでマッチする場
     合、結果は‘t’になります。STRING2の長さまでマッチす
     る場合、結果は‘nil’になります。文字を含まない文字列
     は、他の任意の文字列より小さくなります。

          (string< "" "abc")
               ⇒ t
          (string< "ab" "abc")
               ⇒ t
          (string< "abc" "")
               ⇒ nil
          (string< "abc" "ab")
               ⇒ nil
          (string< "" "")
               ⇒ nil

     引数としてシンボルを指定することもでき、この場合は
     シンボルのプリント名が使用されます。

 -- Function: string-lessp string1 string2
     ‘string-lessp’は‘string<’にたいする別名です。

 -- Function: string-prefix-p string1 string2 &optional
          ignore-case
     この関数は、STRING1がSTRING2のプレフィクス(接頭辞
     )の場合(たとえばSTRING2がSTRING1で始まる場合)、非
     ‘nil’をreturnします。オプションの引数IGNORE-CASEが
     非‘nil’の場合、比較において大文字小文字の違いは無視
     されます。

 -- Function: string-suffix-p suffix string &optional
          ignore-case
     この関数は、SUFFIXがSTRINGのサフィックス(接尾辞)の
     場合(たとえばSTRINGがSUFFIXで終わる場合)、非‘nil’を
     returnします。オプションの引数IGNORE-CASEが非
     ‘nil’の場合、比較において大文字小文字の違いは無視さ
     れます。

 -- Function: compare-strings string1 start1 end1
          string2 start2 end2 &optional ignore-case
     この関数は、STRING1の指定された部分を、STRING2の指
     定された部分と比較します。STRING1の指定された部分と
     は、インデックスSTART1(その文字を含む)から、インデ
     ックスEND1(その文字を含まない)までです。START1に
     ‘nil’を指定すると文字列の最初という意味になり、
     END1に‘nil’を指定すると文字列の長さを意味します同様
     に、STRING2の指定された部分とは、インデックス
     START2からインデックスEND2までです。

     文字列は、文字列内の文字の数値により比較されます。
     たとえば、STR1とSTR2は、最初に異なる文字でSTR1の文
     字の数値が小さいときに、“小さい”と判断されます。
     IGNORE-CASEが非‘nil’の場合、文字は比較を行なう前に
     小文字に変換されます。比較のためにユニバイト文字列
     はマルチバイト文字列に変換されるので(*note Text
     Representations::を参照してください)、ユニバイト文
     字列と、それを変換したマルチバイト文字列は、常に等
     しくなります。

     2つの文字列の指定された部分がマッチした場合、値は
     ‘t’になります。それ以外では、値は整数で、これは何文
     字が一致して、どちらの文字が小さいかを示します。こ
     の値の絶対値は、2つの文字列の先頭から一致した文字数
     に1加えた値になります。STRING1(または指定された部分
     )のほうが小さい場合、符号は負になります。

 -- Function: assoc-string key alist &optional case-fold
     この関数は‘assoc’と同様に機能しますが、KEYは文字列
     かシンボルでなければならず、比較は
     ‘compare-strings’を使用して行なわれます。テストする
     前にシンボルは文字列に変換されます。CASE-FOLDが非
     ‘nil’の場合、大文字小文字の違いは無視されます。
     ‘assoc’とは異なり、この関数はコンスではない文字列ま
     たはシンボルのalist要素もマッチできます。特に、
     ALISTは実際のalistではなく、文字列またはリストでも
     可能です。*note Association Lists::を参照してくださ
     い。

   バッファー内のテキストを比較する方法として、*note
Comparing Text::の関数‘compare-buffer-substrings’も参照
してください。文字列にたいして正規表現のマッチを行なう関
数‘string-match’も、ある種の文字列比較に使用することがで
きます。*note Regexp Search::を参照してください。


File: elisp,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

4.6 Conversion of Characters and Strings
========================================

このセクションでは文字、文字列、整数の間で変換を行なう関
数を説明します。‘format’ (*note Formatting Strings::を参
照してください)、および‘prin1-to-string’ (*note Output
Functions::を参照してください)も、Lispオブジェクトを文字
列に変換できます。‘read-from-string’ (*note Input
Functions::を参照してください)は、Lispオブジェクトの文字
列表現を、オブジェクトに“変換”できます。関数
‘string-to-multibyte’および‘string-to-unibyte’は、テキス
ト表現を文字列に変換します(*note Converting
Representations::を参照してください)。

   テキスト文字と一般的なインプットイベントにたいするテ
キスト説明を生成する関数(‘single-key-description’および
‘text-char-description’)については、*note
Documentation::を参照してください。これらの関数は主にヘ
ルプメッセージを作成するために使用されます。

 -- Function: number-to-string number
     この関数はNUMBERの10進プリント表現からなる文字列を
     returnします。引数が負の場合、return値はマイナス記
     号から開始されます。

          (number-to-string 256)
               ⇒ "256"
          (number-to-string -23)
               ⇒ "-23"
          (number-to-string -23.5)
               ⇒ "-23.5"

     ‘int-to-string’は、この関数にたいする半ば廃れた
     (semi-obsolete)エイリアスです。

     *note Formatting Strings::の関数‘format’も参照して
     ください。

 -- Function: string-to-number string &optional base
     この関数はSTRING内の文字の数値的な値をreturnします
     。BASEが非‘nil’の場合、値は2以上16以下でなければな
     らず、整数はその基数に変換されます。BASEが‘nil’の場
     合、基数に10が使用されます。浮動少数の変換は基数が
     10のときだけ機能します。わたしたちは浮動小数点数に
     たいして他の基数を実装していません。なえならこれに
     は多くの作業が必要で、その割にその機能が有用には思
     えないからです。STRINGが整数のように見えるが、その
     値がLispの整数に収まらないほど大きな値の場合、
     ‘string-to-number’は浮動小数の結果をreturnします。

     解析ではSTRINGの先頭にあるスペースとタブはスキップ
     して、それから与えられた基数で数字として解釈できる
     ところまでSTRINGを読み取ります(スペースとタブだけで
     はなく、先頭にある他の空白文字を無視するシステムも
     あります)。STRINGを数字として解釈できない場合、この
     関数は0をreturnします。

          (string-to-number "256")
               ⇒ 256
          (string-to-number "25 is a perfect square.")
               ⇒ 25
          (string-to-number "X256")
               ⇒ 0
          (string-to-number "-4.5")
               ⇒ -4.5
          (string-to-number "1e5")
               ⇒ 100000.0

     ‘string-to-int’は、この関数にたいする半ば廃れたエイ
     リアスです。

 -- Function: char-to-string character
     この関数は、1つの文字CHARACTERを含む新しい文字列を
     returnします。関数‘string’のほうがより一般的なので
     、この関数は半ば廃れています。*note Creating
     Strings::を参照してください。

 -- Function: string-to-char string
     この関数は、STRINGの最初の文字をreturnします。これ
     はほとんど‘(aref string 0)’と同じで、例外は文字列が
     空のときに0をreturnすることです(文字列の最初の文字
     がASCIIコード0のヌル文字のときも、0をreturnします
     )。この関数は、残すのに充分なほど有用と思えない場合
     、将来削除されるかもしれません。

   以下は、文字列へ／からの変換に使用できる、その他の関
数です:

‘concat’
     この関数はベクターまたはリストから文字列に変換しま
     す。*note Creating Strings::を参照してください。

‘vconcat’
     この関数は文字列をベクターに変換します。*note
     Vector Functions::を参照してください。

‘append’
     この関数は文字列をリストに変換します。*note
     Building Lists::を参照してください。

‘byte-to-string’
     この関数は文字データのバイトをユニバイト文字列に変
     換します。*note Converting Representations::を参照
     してください。


File: elisp,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

4.7 Formatting Strings
======================

“フォーマット(formatting)”とは、定数文字列内のなまざまな
場所を、計算された値で置き換えることにより、文字列を構築
することを意味します。この定数文字列は、他の値がプリント
される方法、同様にどこに表示するかを制御します。これは
“フォーマット文字列(format string)”と呼ばれます。

   フォーマットは、表示されるメッセージを計算するために
便利なことがしばしばあります。実際に、関数‘message’およ
び‘error’は、ここで説明する機能と同じフォーマットを提供
します。これらの関数と‘format’の違いは、フォーマットされ
た結果を使用する方法だけです。

 -- Function: format string &rest objects
     この関数は、STRINGをコピーしてから、対応する
     OBJECTSをエンコードする、コピー内の任意のフォーマッ
     ト指定(format specification)を置換することにより作
     成される、新しい文字列をreturnします。引数OBJECTSは
     、フォーマットされる計算された値です。

     STRING内のフォーマット指定以外の文字は、(もしあれば
     )テキストプロパティーを含め、出力に直接コピーされま
     す。

   フォーマット指定は、‘%’で始まる文字シーケンスです。し
たがってSTRING内に‘%d’があれば、‘format’はそれを、フォー
マットされる値の1つ(引数OBJECTSのうちの1つ)にたいするプ
リント表現で置き換えます。たとえば:

     (format "The value of fill-column is %d." fill-column)
          ⇒ "The value of fill-column is 72."

   ‘format’は文字‘%’をフォーマット指定と解釈するので、
_決して_最初の引数に不定な文字列(arbitrary string)を渡す
べきではありません。これは特に何らかのLispコードにより生
成された文字列の場合に当てはまります。その文字列が決して
文字‘%’を含まないと_確信_できないときは、以下で説明する
ように最初の引数に‘"%s"’を渡して、不定な文字列を2番目の
引数として渡します:

       (format "%s" ARBITRARY-STRING)

   STRINGに複数のフォーマット指定が含まれる場合、フォー
マット指定はOBJECTSから連続して値を引き当てます。つまり
、STRING内の1番目のフォーマット指定は1番目の値、2番目の
フォーマット指定は2番目の値、...を使用します。余分なフォ
ーマット指定(対応する値がない場合)は、エラーとなります。
フォーマットされる値が余分にある場合は、無視されます。

   ある種のフォーマット指定は、特定の型の値を要求します
。その要求に適合しない値を与えた場合、エラーがシグナルさ
れます。

   以下は有効なフォーマット指定の表です:

‘%s’
     フォーマット指定を、クォートなし(つまり‘prin1’では
     なく‘princ’を使用して。*note Output Functions::を参
     照してください)の、オブジェクトのプリント表現で置き
     換えます。したがって、文字列は‘"’文字なしの、文字列
     内容だけが表示され、シンボルは‘\’文字なしで表されま
     す。

     オブジェクトが文字列の場合、文字列のプロパティーは
     出力にコピーされます。‘%s’のテキストプロパティー自
     身もコピーされますが、オブジェクトのテキストプロパ
     ティーが優先されます。

‘%S’
     フォーマット指定を、クォートあり(つまり‘prin1’を使
     用して。*note Output Functions::を参照してください
     )の、オブジェクトのプリント表現で置き換えます。した
     がって、文字列は‘"’文字で囲まれ、必要となる特別文字
     の前に‘\’文字が表示されます。

‘%o’
     フォーマット指定を8進表現の整数で置き換えます。

‘%d’
     フォーマット指定を10進表現の整数で置き換えます。

‘%x’
‘%X’
     フォーマット指定を16進表現の整数で置き換えます。
     ‘%x’の場合は小文字、‘%X’の場合は大文字が使用されま
     す。

‘%c’
     フォーマット指定を、与えられた値の文字で置き換えま
     す。

‘%e’
     フォーマット指定を、浮動小数点数の指数表現で置き換
     えます。

‘%f’
     フォーマット指定を、浮動小数点数にたいする10進少数
     表記で置き換えます。

‘%g’
     フォーマット指定を、指数または10進少数のどちらか短
     いほうの表記を使用した浮動小数点数で置き換えます。

‘%%’
     フォーマット指定を1つの‘%’で置き換えます。このフォ
     ーマット指定は、値を使用しません。たとえば、
     ‘(format "%% %d" 30)’は‘"% 30"’をreturnします。

   他のフォーマット文字は、‘Invalid format operation’エ
ラーになります。

   以下にいくつかの例を示します:

     (format "The name of this buffer is %s." (buffer-name))
          ⇒ "The name of this buffer is strings.texi."

     (format "The buffer object prints as %s." (current-buffer))
          ⇒ "The buffer object prints as strings.texi."

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          ⇒ "The octal value of 18 is 22,
              and the hex value is 12."

   フォーマット指定は“フィールド幅(width)”をもつことがで
き、これは‘%’とフォーマット指定文字(specification
character)の間の10進の数字です。そのオブジェクトのプリン
ト表現が、このフィールド幅より少ない文字で構成される場合
、‘format’はパディングしてフィールド幅に拡張します。フォ
ーマット指定‘%%’では、フィールド幅の指定は無視されます。
シールド幅指定により行なわれるパディングは通常、左側にス
ペースを挿入します。

     (format "%5d is padded on the left with spaces" 123)
          ⇒ "  123 is padded on the left with spaces"

フィールド幅が小さすぎる場合でも、‘format’はオブジェクト
のプリント表現を切り詰めません。したがって、情報を失う危
険を犯すことなく、フィールドの最小幅を指定することができ
ます。以下の2つの例では、‘%7s’は最小幅に7を指定します。
1番目の例では、‘%7s’に挿入される文字列は3文字だけなので
、4つのブランクスペースによりパディングされます。2番目の
例では、文字列‘"specification"’は13文字ですが、切り詰め
はされません。

     (format "The word `%7s' has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word `    foo' has 3 letters in it."
     (format "The word `%7s' has %d letters in it."
             "specification" (length "specification"))
          ⇒ "The word `specification' has 13 letters in it."

   ‘%’の直後、オプションのフィールド幅指定の前に、“フラ
グ文字(flag characters)”を置くこともできます。

   フラグ‘+’は、正数の前にプラス符号を挿入するので、数に
は常に符号がつきます。フラグとしてスペースを指定すると、
正数の前に1つのスペースが挿入されます(それ以外は、正数は
最初の数字から開始されます)。これらのフラグは、正数と負
数が同じ列数を使用することを確実にするのに便利です。これ
らは‘%d’、‘%e’、‘%f’、‘%g’以外では無視され、両方が指定さ
れた場合は、‘+’が優先されます。

   フラグ‘#’は“代替形式(alternate form)”を指定し。これは
使用するフォーマットに依存します。‘%o’にたいしては、結果
を‘0’で開始させます。‘%x’と‘%X’にたいしては、結果のプレ
フィクスは‘0x’または‘0X’になります。‘%e’、‘%f’、‘%g’にた
いしては、‘#’フラグは、少数部が0のときも小数点が含まれる
ことを意味します。

   フラグ‘0’は、スペースの代わりに文字‘0’でパディングし
ます。このフラグは‘%s’、‘%S’、‘%c’のような、非数値のフォ
ーマット指定文字では無視されます。もれらのフォーマット指
定文字で‘0’フラグを指定できますが、それでも_スペース_で
パディングされます。

   フラグ‘-’はフィールド幅指定により挿入されるパディング
に作用し、もしパディングがある場合、左側ではなく右側にパ
ディングされます。‘-’と‘0’の両方が指定された場合、‘0’フ
ラグは無視されます。

     (format "%06d is padded on the left with zeros" 123)
          ⇒ "000123 is padded on the left with zeros"

     (format "%-6d is padded on the right" 123)
          ⇒ "123    is padded on the right"

     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          ⇒ "The word `foo    ' actually has 3 letters in it."

   すべてのフォーマット指定文字には、その文字の前(フィー
ルド幅がある場合は、その後)に、オプションで“精度
(precision)”を指定できます。精度は小数点‘.’と、その後に
桁文字列(digit-string)を指定します。浮動少数のフォーマッ
ト指定(‘%e’、‘%f’、‘%g’)では、精度は表示する小数点以下の
桁数を指定します。0の場合は小数点も省略されます。‘%s’と
‘%S’にたいしては、文字列を精度で指定された幅に切り詰めま
す。したがって‘%.3s’では、OBJECTにたいするプリント表現の
最初の3文字だけが表示されます。他のフォーマット指定文字
にたいしては、精度は効果がありません。


File: elisp,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

4.8 Case Conversion in Lisp
===========================

大文字小文字変換関数(character case functions)は、1つの
文字または文字列の内容の大文字小文字を変換します。関数は
通常、アルファベット文字(英字‘A’から‘Z’と‘a’から‘z’、同
様に非ASCIIの英字)だけを変換し、それ以外の文字は変換しま
せん。大文字小文字テーブル(case table。*note Case
Tables::を参照してください)で指定することにより大文字小
文字の変換に異なるマッピングを指定できます。

   これらの関数は、引数として渡された文字列は変更しませ
ん。

   以下の例では文字‘X’と‘x’を使用し、これらのASCIIコード
は88と120です。

 -- Function: downcase string-or-char
     この関数は、STRING-OR-CHAR(文字か文字列)を小文字に
     変換します。

     STRING-OR-CHARが文字列の場合、この関数は引数の大文
     字を小文字に変換した、新しい文字列をreturnします。
     STRING-OR-CHARが文字の場合、この関数は対応する小文
     字(正数)をreturnします。元の文字が小文字の場合、ま
     たは英字でない場合、return値は元の文字と同じです。

          (downcase "The cat in the hat")
               ⇒ "the cat in the hat"

          (downcase ?X)
               ⇒ 120

 -- Function: upcase string-or-char
     この関数は、STRING-OR-CHAR(文字か文字列)を大文字に
     変換します。

     STRING-OR-CHARが文字列の場合、この関数は引数の小文
     字を大文字に変換した、新しい文字列をreturnします。
     STRING-OR-CHARが文字の場合、この関数は対応する大文
     字(正数)をreturnします。元の文字が大文字の場合、ま
     たは英字でない場合、return値は元の文字と同じです。

          (upcase "The cat in the hat")
               ⇒ "THE CAT IN THE HAT"

          (upcase ?x)
               ⇒ 88

 -- Function: capitalize string-or-char
     この関数は文字列または文字をキャピタライズ
     (capitalize: 先頭が大文字で残りは小文字)します。こ
     の関数は、STRING-OR-CHARが文字列の場合、
     STRING-OR-CHARの各単語がキャピタライズされた新しい
     コピーをreturnします。これは各単語の最初の文字が大
     文字に変換され、残りは小文字に変換されることを意味
     します。

     単語の定義は、カレント構文テーブル(current syntax
     table)の単語構成構文クラス(word constituent syntax
     class)に割り当てられた、連続する文字の任意シーケン
     スです(*note Syntax Class Table::を参照してください
     )。

     STRING-OR-CHARが文字の場合、この関数は‘upcase’と同
     じことを行ないます。

          (capitalize "The cat in the hat")
               ⇒ "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               ⇒ "The 77th-Hatted Cat"

          (capitalize ?x)
               ⇒ 88

 -- Function: upcase-initials string-or-char
     この関数は、STRING-OR-CHARが文字列の場合、
     STRING-OR-CHARの中の単語の頭文字をキャピタライズし
     、頭文字以外の文字は変更しません。この関数は、
     STRING-OR-CHARの各単語の頭文字が大文字に変換された
     新しいコピーをreturnします。

     単語の定義は、カレント構文テーブル(current syntax
     table)の単語構成構文クラス(word constituent syntax
     class)に割り当てられた、連続する文字の任意シーケン
     スです(*note Syntax Class Table::を参照してください
     )。

     ‘upcase-initials’の引数が文字の場合、
     ‘upcase-initials’の結果は‘upcase’と同じになります。

          (upcase-initials "The CAT in the hAt")
               ⇒ "The CAT In The HAt"

   文字列を比較する関数(大文字小文字の違いを無視するもの
や、オプションで大文字小文字の違いを無視できるもの)につ
いては、*note Text Comparison::を参照してください。


File: elisp,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

4.9 The Case Table
==================

特別な“大文字小文字テーブル(case table)”をインストールす
ることにより、大文字小文字の変換をカスタマイズできます。
大文字小文字テーブルは大文字と小文字の間のマッピングを指
定します。大文字小文字テーブルはLispオブジェクトにたいす
る大文字小文字変換関数(前のセクションを参照してください
)と、バッファー内のテキストに適用される関数の両方に影響
します。それぞれのバッファーには大文字小文字テーブルがあ
ります。新しいバッファーの大文字小文字テーブルを初期化す
るために使用される、標準の大文字小文字テーブル(standard
case table)もあります。

   大文字小文字テーブルは、サブタイプが‘case-table’の文
字テーブル(char-table。*note Char-Tables::を参照してくだ
さい)です。この文字テーブルは、それぞれの文字を対応する
小文字にマップします。大文字小文字テーブルは、関連するテ
ーブルを保持する、3つの追加スロットをもちます:

UPCASE
     upcase(大文字)テーブルは、それぞれの文字を対応する
     大文字にマップします。
CANONICALIZE
     canonicalize(正準化)テーブルは、大文字小文字に関連
     する文字セットのすべてを、その文字セットの特別なメ
     ンバーにマップします。
EQUIVALENCES
     equivalence(同値)テーブルは、大の字小文字に関連した
     文字セットのそれぞれを、そのセットの次の文字にマッ
     プします。

   単純な例では、小文字へのマッピングを指定することだけ
が必要です。3つの関連するテーブルは、このマッピングから
自動的に計算されます。

   大文字と小文字が1対1で対応しない言語もいくつかありま
す。これらの言語では、2つの異なる小文字が、同じ大文字に
マップされます。このような場合、大文字と小文字の両方にた
いするマップを指定する必要があります。

   追加のCANONICALIZEテーブルは、それぞれの文字を、正準
化された等価文字にマップします。大文字小文字に関連する任
意の2文字は、同じ正準等価文字(canonical equivalent
character)をもちます。たとえば‘a’と‘A’は大文字小文字変換
に関係があるので、これらの文字は同じ正準等価文字(両方の
文字が‘a’、または両方の文字が‘A’)をもつべきです。

   追加のEQUIVALENCESテーブルは、各等価クラスの文字(同じ
正準等価文字をもつ文字)を循環的にマップします(通常の
ASCIIでは、これは‘a’を‘A’に‘A’を‘a’にマップし、他の等価
文字セットにたいしても同様にマップします)。

   大文字小文字テーブルを構築する際は、CANONICALIZEに
‘nil’を指定できます。この場合、Emacsは大文字と小文字のマ
ッピングで、このスロットを充填します。EQUIVALENCESにたい
して‘nil’を指定することもできます。この場合、Emacsは
CANONICALIZEから、このスロットを充填します。実際に使用さ
れる大文字小文字テーブルでは、これらのコンポーネントは非
‘nil’です。CANONICALIZEを指定せずにEQUIVALENCESを指定し
ないでください。

   以下は大文字小文字テーブルに作用する関数です:

 -- Function: case-table-p object
     この述語は、OBJECTが有効な大文字小文字テーブルの場
     合は、非‘nil’をreturnします。

 -- Function: set-standard-case-table table
     この関数は、TABLEを標準大文字小文字テーブルにして、
     これ以降に作成される任意のバッファーにたいしてこの
     テーブルが使用されます。

 -- Function: standard-case-table
     これは標準大文字小文字テーブル(standard case
     table)をreturnします。

 -- Function: current-case-table
     この関数は、カレントバッファーの大文字小文字テーブ
     ルをreturnします。

 -- Function: set-case-table table
     これはカレントバッファーの大文字小文字テーブルを、
     TABLEにセットします。

 -- Macro: with-case-table table body...
     ‘with-case-table’マクロはカレント大文字小文字テーブ
     ルを保存してから、TABLEをカレント大文字小文字テーブ
     ルにセットし、その後にBODYフォームを評価してから、
     最後に大文字小文字テーブルをリストアします。
     return値は、BODYの最後のフォームの値です。‘throw’ま
     たはエラー(*note Nonlocal Exits::を参照してください
     )により異常終了した場合でも、大文字小文字テーブルは
     リストアされます。

   ASCII文字の大文字小文字変換を変更する言語環境
(language environment)がいくつかあります。たとえば
Turkishの言語環境では、ASCII文字の‘I’にたいする小文字は
、Turkishの“dotless i”です。これは、(ASCIIベースのネット
ワークプロトコル実装のような)ASCIIの通常の大文字小文字変
換を要求するコードに干渉する可能性があります。このような
場合は、変数ASCII-CASE-TABLEにたいして
‘with-case-table’マクロを使用します。これにより、変更さ
れていないASCII文字セットの大文字小文字テーブルが保存さ
れます。

 -- Variable: ascii-case-table
     ASCII文字セットにたいする大文字小文字テーブルです。
     すべての言語環境セッティングにおいて、これを変更す
     るべきではありません。

   以下の3つの関数は、非ASCII文字セットを定義するパッケ
ージにたいして便利なサブルーチンです。これらは
CASE-TABLEに指定された大文字小文字テーブルを変更します。
これは標準構文テーブルも変更します。*note Syntax
Tables::を参照してください。通常これらの関数は、標準大文
字小文字テーブルを変更するために使用されます。

 -- Function: set-case-syntax-pair uc lc case-table
     この関数は、対応する文字のペア(一方は大文字、もう一
     方は小文字)を指定します。

 -- Function: set-case-syntax-delims l r case-table
     この関数は文字LとRを、大文字小文字不変区切り
     (case-invariant delimiter)mpマッチングペアにします
     。

 -- Function: set-case-syntax char syntax case-table
     この関数はCHARを、構文SYNTAXの、大文字小文字不変
     (case-invariant)とします。

 -- Command: describe-buffer-case-table
     このコマンドは、カレントバッファーの大文字小文字テ
     ーブルの内容にたいする説明を表示します。


File: elisp,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

5 Lists
*******

“リスト(list)”は0個以上の要素(任意のLispオブジェクト)の
シーケンスを表します。リストとベクターの重要な違いは、、
2つ以上のリストが、構造の一部を共有できることです。加え
て、リスト全体をコピーすることなく、要素の挿入、削除がで
きます。

* Menu:

* Cons Cells::               コンスセルからリストが作られる方法。
* List-related Predicates::  このオブジェクトはリストか?
                               2つのリストを比較する。
* List Elements::            リストの一部を抽出する。
* Building Lists::           リスト構造の作成。
* List Variables::           変数に保存されたリストにたいする変更。
* Modifying Lists::          既存のリストに新しい要素を保存する。
* Sets And Lists::           リストは有限な数学集合を表現できます。
* Association Lists::        リストは有限な関係またはマッピングを表現できます。
* Property Lists::           要素ペアのリスト


File: elisp,  Node: Cons Cells,  Next: List-related Predicates,  Up: Lists

5.1 Lists and Cons Cells
========================

Lispでのリストは基本データ型ではありません。リストは“コ
ンスセル(cons cells)”から構築されます(*note Cons Cell
Type::を参照してください)。コンスセルは、順序つきペアを
表現するデータオブジェクトです。つまり、コンスセルは2つ
のスロットをもち、それぞれのスロットはLispオブジェクトを
“保持(holds)”、または“参照(refers to)”します。1つのスロ
ットはCAR、もう1つはCDRです(これらの名前は歴史的なもので
す。*note Cons Cell Type::を参照してください)。CDRは
“could-er(クダー)”と発音されます。

   わたしたちは、コンスセルのCARスロットに現在保持されて
いるオブジェクトが何であれ、“このコンスセルのCARは、
...”のような言い方をします。これはCDRの場合も同様です。

   リストとは、“互いにつながった(chained together)”一連
のコンスセルであり、各セルは次のセルを参照します。リスト
の各要素にたいして、それぞれ1つのコンスセルがあります。
慣例により、コンスセルのCARはリストの要素を保持し、CDRは
リストをチェーンするのに使用されます(CARとCDRの間の非対
称性は完全に慣例的なものです。コンスセルのレベルでは、
CARスロットとCDRスロットは同じようなプロパティーをもちま
す)。したがって、リスト内の各コンスセルのCDRスロットは、
次のコンスセルを参照します。

   これも慣例的なものですが、リスト内の最後のコンスセル
のCDRは‘nil’です。わたしたちは、このような‘nil’で終端さ
れた構造を、“真リスト(true list)”と呼びます。Emacs Lispで
は、シンボル‘nil’は、シンボルであり、要素なしのリストで
もあります。便宜上、シンボル‘nil’は、そのCDR(および
CAR)に‘nil’をもつと考えます。

   したがって真リストのCDRは、常に真リストです。空でない
真リストのCDRは、1番目の要素以外を含む真リストです。

   リストの最後のコンスセルのCDRが‘nil’以外の何らかの値
の場合、このリストのプリント表現はドットペア表記(dotted
pair notation。*note Dotted Pair Notation::を参照してく
ださい)を使用するので、わたしたちはこの構造を“ドットリス
ト(dotted list)”と呼びます。他の可能性もあります。あるコ
ンスセルのCDRが、そのリストのそれより前にある要素を指す
かもしれません。わたしたちは、この構造を“循環リスト
(circular list)”と呼びます。

   ある目的にたいしては、そのリストが真リストか、循環リ
ストなのか、ドットリストなのかが問題にならない場合もあり
ます。そのプログラムが、リストを充分に下って最後のコンス
セルのCDRを確認しようとしないなら、これは問題になりませ
ん。しかし、リストを処理するの関数のいくつかは、真リスト
を要求し、ドットリストの場合はエラーをシグナルします。リ
ストの最後を探そうと試みる関数のほとんどは、循環リストを
与えると無限ループに突入します。

   ほとんどのコンスセルはリストの一部として使用されるの
で、わたしたちはコンスセルで構成される任意の構造を、“リ
スト構造(list structure)”と呼びます。


File: elisp,  Node: List-related Predicates,  Next: List Elements,  Prev: Cons Cells,  Up: Lists

5.2 Predicates on Lists
=======================

以下の述語は、あるLispオブジェクトがアトムなのか、コンス
セルなのか、それともリストなのか、またはオブジェクトが
‘nil’かどうかテストします(これらの述語の多くは、他の述語
で定義することもできますが、多用されるので、定義する価値
があるのです)。

 -- Function: consp object
     この関数は、OBJECTがコンスセルの場合は‘t’、それ以外
     は‘nil’をreturnします。たとえ‘nil’はリスト_です_が
     、コンスセルではありません。

 -- Function: atom object
     この関数は、OBJECTがアトムの場合は‘t’、それ以外は
     ‘nil’をreturnします。シンボル‘nil’はアトムであり、
     リストでもあります。そのようなLispオブジェクトは
     ‘nil’だけです。

          (atom OBJECT) ≡ (not (consp OBJECT))

 -- Function: listp object
     この関数は、OBJECTがコンスセルか‘nil’の場合は‘t’を
     returnします。それ以外は‘nil’をreturnします。

          (listp '(1))
               ⇒ t
          (listp '())
               ⇒ t

 -- Function: nlistp object
     この関数は‘listp’の反対です。OBJECTがリストでない場
     合は‘t’をreturnします。それ以外は‘nil’をreturnしま
     す。

          (listp OBJECT) ≡ (not (nlistp OBJECT))

 -- Function: null object
     この関数は、OBJECTが‘nil’の場合は‘t’、それ以外は
     ‘nil’をreturnします。この関数は‘not’と等価ですが、
     明解にするために、OBJECTをリストだと考えるときは
     ‘null’、真偽値だと考えるときは‘not’を使用します
     (*note Combining Conditions::の‘not’を参照してくだ
     さい)。

          (null '(1))
               ⇒ nil
          (null '())
               ⇒ t


File: elisp,  Node: List Elements,  Next: Building Lists,  Prev: List-related Predicates,  Up: Lists

5.3 Accessing Elements of Lists
===============================

 -- Function: car cons-cell
     この関数は、コンスセルCONS-CELLの1番目のスロットに
     より参照される値をreturnします。他の言い方をすると
     、この関数はCONS-CELLのCARをreturnします。

     特別なケースとして、CONS-CELLが‘nil’の場合、この関
     数は‘nil’をreturnします。したがって、リストはすべて
     引数として有効です。引数がコンスセルでも‘nil’でもな
     い場合、エラーがシグナルされます。

          (car '(a b c))
               ⇒ a
          (car '())
               ⇒ nil

 -- Function: cdr cons-cell
     この関数は、コンスセルCONS-CELLの2番目のスロットに
     より参照される値をreturnします。他の言い方をすると
     、この関数はCONS-CELLのCDRをreturnします。

     特別なケースとして、CONS-CELLが‘nil’の場合、この関
     数は‘nil’をreturnします。したがって、リストはすべて
     引数として有効です。引数がコンスセルでも‘nil’でもな
     い場合、エラーがシグナルされます。

          (cdr '(a b c))
               ⇒ (b c)
          (cdr '())
               ⇒ nil

 -- Function: car-safe object
     この関数により、他のデータ型によるエラーを起こさず
     に、コンスセルのCARを取得できます。この関数は、
     OBJECTがコンスセルの場合はOBJECTのCAR、それ以外は
     ‘nil’をreturnします。この関数は、OBJECTがリスとでな
     いときはエラーをシグナルする‘car’とは対象的です。

          (car-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     この関数により、他のデータ型によるエラーを起こさず
     に、コンスセルのCDRを取得できます。この関数は、
     OBJECTがコンスセルの場合はOBJECTのCDR、それ以外は
     ‘nil’をreturnします。この関数は、OBJECTがリスとでな
     いときはエラーをシグナルする‘cdr’とは対象的です。

          (cdr-safe OBJECT)
          ≡
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Macro: pop listname
     このマクロはリストのCARを調べて、それをリストから取
     り去るのを1度に行なう便利な方法を提供します。この関
     数はLISTNAMEに格納されたリストにたいして処理を行な
     います。この関数はリストから1番目の要素を削除して、
     CDRをLISTNAMEに保存し、その後で削除した要素を
     returnします。

     1番単純なケースは、リストに名前をつけるためのクォー
     トされていないシンボルの場合です。この場合、このマ
     クロは
     ‘(prog1 (car listname) (setq listname (cdr listname)))’と
     等価です。

          x
               ⇒ (a b c)
          (pop x)
               ⇒ a
          x
               ⇒ (b c)

     より一般的なのは、LISTNAMEが汎変数(generalized
     variable)の場合です。この場合、このマクロは‘setf’を
     使用してLISTNAMEに保存します。*note Generalized
     Variables::を参照してください。

     リストに要素を追加する‘push’マクロについては、*note
     List Variables::を参照してください。

 -- Function: nth n list
     この関数は、LISTのN番目の要素をreturnします。要素は
     0から数えられるので、LISTのCARは要素0になります。
     LISTの長さがN以下の場合、値は‘nil’です。

          (nth 2 '(1 2 3 4))
               ⇒ 3
          (nth 10 '(1 2 3 4))
               ⇒ nil

          (nth n x) ≡ (car (nthcdr n x))

     関数‘elt’は似ていますが、これは任意の種類のシーケン
     スに適用されます。歴史的な理由により、この関数は逆
     の順序で引数を受け取ります。*note Sequence
     Functions::を参照してください。

 -- Function: nthcdr n list
     この関数は、LISTのN番目のCDRをreturnします。他の言
     い方をすると、この関数はLISTの最初のN個のリンクをス
     キップしてから、それ以降をreturnします。

     Nが0の場合、‘nthcdr’はLIST全体をreturnします。
     LISTの長さがN以下の場合、‘nthcdr’は‘nil’をreturnし
     ます。

          (nthcdr 1 '(1 2 3 4))
               ⇒ (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               ⇒ nil
          (nthcdr 0 '(1 2 3 4))
               ⇒ (1 2 3 4)

 -- Function: last list &optional n
     この関数は、LISTの最後のリンクをreturnします。この
     リンクの‘car’は、このリストの最後の要素です。LISTが
     nullの場合、‘nil’がreturnされます。Nが非‘nil’の場合
     、N番目から最後までのリンクがreturnされます。Nが
     LISTの長さより大きい場合は、LIST全体がreturnされま
     す。

 -- Function: safe-length list
     この関数は、エラーや無限ループの危険なしで、LISTの
     長さをreturnします。この関数は一般的に、リスト内の
     コンスセルの個数をreturnします。しかし循環リストで
     は、単に上限値が値となるため、非常に大きくなる場合
     があります。

     LISTが‘nil’でもコンスセルでもない場合、
     ‘safe-length’は0をreturnします。

   循環リストを考慮しなくてもよい場合に、リストの長さを
計算するもっとも一般的な方法は、‘length’を使うことです。
*note Sequence Functions::を参照してください。

 -- Function: caar cons-cell
     これは、‘(car (car CONS-CELL))’と同じです。

 -- Function: cadr cons-cell
     これは、‘(car (cdr CONS-CELL))’または‘(nth 1
     CONS-CELL)’と同じです。

 -- Function: cdar cons-cell
     これは、‘(cdr (car CONS-CELL))’と同じです。

 -- Function: cddr cons-cell
     これは、‘(cdr (cdr CONS-CELL))’または‘(nthcdr 2
     CONS-CELL)’と同じです。

 -- Function: butlast x &optional n
     この関数は、リストXから、最後の要素、または最後の
     N個の要素を削除してreturnします。Nが0より大きい場合
     、この関数はリストのコピーを作成するので、元のリス
     トに影響はありません。一般的に、‘(append (butlast X
     N) (last X N))’は、Xと等しいリストをreturnします。

 -- Function: nbutlast x &optional n
     この関数は、リストのコピーを作成するのではなく、
     ‘cdr’を適切な要素に変更することにより破壊的に機能す
     るバージョンの‘butlast’です。

