This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Region Indent,  Next: Relative Indent,  Prev: Mode-Specific Indent,  Up: Indentation

31.17.3 Indenting an Entire Region
----------------------------------

このセクションでは、リージョン内すべての行をインデントするコマンドを説明
します。これらは予期せぬ値をリターンします。

 -- Command: indent-region start end &optional to-column
     このコマンドは、START(含む)からEND(含まず)で始まる非ブランク行すべ
     てをインデントする。TO-COLUMNが‘nil’なら、‘indent-region’はカレント
     モードのインデント関数、すなわち‘indent-line-function’の値を呼び出
     すことにより、非ブランク行すべてをインデントする。

     TO-COLUMNが非‘nil’なら、それはインデントの列数を指定する整数である
     こと。その場合、この関数は空白文字を追加もしくは削除することにより
     、正確にその量のインデントを各行に与える。

     フィルプレフィクスがある場合、‘indent-region’はそのフィルプレフィク
     スで開始されるように、各行をインデントする。

 -- Variable: indent-region-function
     この変数の値は、ショートカットとして‘indent-region’により使用される
     かもしれない関数である。その関数はリージョンの開始と終了という、2つ
     の引数をとること。その関数はリージョンの行を1行ずつインデントすると
     きと同じような結果を生成するようにデザインするべきだが、おそらくよ
     り高速になるであろう。

     値が‘nil’ならショートカットは存在せず、‘indent-region’は実際に1行ず
     つ機能する。

     ショートカット関数は、‘indent-line-function’が関数定義先頭をスキャ
     ンしなければならない、CモードやLispモードのようなモードに有用で、そ
     れを各行に適用するためには行数の2乗に比例する時間を要するだろう。シ
     ョートカットは各行のインデントとともに移動してスキャン情報を更新で
     き、それは線形時間である。行を個別にインデントするのが高速なモード
     では、ショートカットの必要性はない。

     引数TO-COLUMNが非‘nil’の‘indent-region’では意味は異なり、この変数は
     使用しない。

 -- Command: indent-rigidly start end count
     この関数は、START(含む)からEND(含まず)までのすべての行を、横に
     COUNT列インデントする。これは影響を受けるリージョンの“外観を保ち”、
     それを厳密な単位として移動する。

     これはインデントされていないテキストリージョンのインデントだけでな
     く、フォーマット済みコードのリージョンにたいするインデントにも有用
     である。たとえばCOUNTが3なら、このコマンドは指定されたリージョン内
     で始まるすべての行のインデントに3を追加する。

     プレフィクス引数なしでインタラクティブに呼び出された場合、このコマ
     ンドはインデントを厳密に調整するために、Transient Markモードを呼び
     出す。*note (emacs)Indentation Commands::を参照のこと。

 -- Command: indent-code-rigidly start end columns &optional
          nochange-regexp
     これは‘indent-rigidly’と似ているが、文字列やコメントで始まる行を変
     更しない点が異なる。

     加えて、(NOCHANGE-REGEXPが非‘nil’の場合)NOCHANGE-REGEXPが行先頭にマ
     ッチすれば、その行を変更しない。


File: elisp,  Node: Relative Indent,  Next: Indent Tabs,  Prev: Region Indent,  Up: Indentation

31.17.4 Indentation Relative to Previous Lines
----------------------------------------------

このセクションでは、前の行のコンテンツにもとづいてカレント行をインデント
する、コマンドを2つ説明します。

 -- Command: indent-relative &optional unindented-ok
     このコマンドは、前の非ブランク行の次の“インデントポイント(indent
     point)”と同じ列に拡張されるように、ポイント位置に空白文字を挿入する
     。インデントポイントとは、後に空白文字をともなった非空白文字である
     。次のインデントポイントは、ポイントのカレント列より大きい、最初の
     インデントポイントになる。たとえばポイントがテキスト行の最初の非ブ
     ランク文字の下と左にある場合、空白文字を挿入してその列に移動する。

     前の非ブランク行に次のインデントポイントがない(列の位置が十分大きく
     ない)場合は、(UNINDENTED-OKが非‘nil’なら)何もしないか、あるいは
     ‘tab-to-tab-stop’を呼び出す。したがって、ポイントが短いテキスト行の
     最後の列の下と右にある場合、このコマンドは通常は空白文字を挿入する
     ことにより、次のタブストップにポイントを移動する。

     ‘indent-relative’のリターン値は予測できない。

     以下の例では、ポイントは2行目の先頭にある:

                      This line is indented twelve spaces.
          ★The quick brown fox jumped.

     式‘(indent-relative nil)’の評価により、以下が生成される:

                      This line is indented twelve spaces.
                      ★The quick brown fox jumped.

     次の例では、ポイントは‘jumped’の‘m’と‘p’の間にある:

                      This line is indented twelve spaces.
          The quick brown fox jum★ped.

     式‘(indent-relative nil)’の評価により、以下が生成される:

                      This line is indented twelve spaces.
          The quick brown fox jum  ★ped.

 -- Command: indent-relative-maybe
     このコマンドは、引数UNINDENTED-OKに‘t’を指定して‘indent-relative’を
     呼び出すことにより、前の非ブランク行に倣ってカレント行をインデント
     する。リターン値は予測できない。

     カレント列より先のインデントポイントが前の非ブランク行に存在しなけ
     れば、このコマンドは何もしない。


File: elisp,  Node: Indent Tabs,  Next: Motion by Indent,  Prev: Relative Indent,  Up: Indentation

31.17.5 Adjustable “Tab Stops”
------------------------------

このセクションでは、ユーザー指定の“タブストップ(tab stops)”と、それらを
使用、セットするメカニズムについて説明します。“タブストップ”という名前は
、タイプライターのタブストップと機能が類似しているため使用されています。
この機能は、次のタブストップ列に到達するために、適切な数のスペースとタブ
を挿入することにより機能します。これは、バッファー内のタブ文字の表示に影
響を与えません(*note Usual Display::を参照)。Textモードのような少数のメ
ジャーモードだけが、<TAB>文字を入力として、このタブストップ機能を使用す
ることに注意してください。*note (emacs)Tab Stops::を参照してください。

 -- Command: tab-to-tab-stop
     このコマンドは、‘tab-stop-list’により定義される次のタブストップ列ま
     で、ポイント前にスペースまたはタブを挿入する。

 -- User Option: tab-stop-list
     この変数は、‘tab-to-tab-stop’により使用されるタブストップ列を定義す
     る。これは‘nil’、もしくは増加(均等に増加する必要はない)していく整数
     のリストであること。このリストは暗黙に、最後の要素と最後から2番目の
     要素の間隔(またはリストの要素が2未満なら‘tab-width’)を繰り返すこと
     により、無限に拡張される。値‘nil’は、列‘tab-width’ごとにタブストッ
     プすることを意味する。

     インタラクティブにタブストップの位置を編集するには、‘M-x
     edit-tab-stops’を使用すればよい。


File: elisp,  Node: Motion by Indent,  Prev: Indent Tabs,  Up: Indentation

31.17.6 Indentation-Based Motion Commands
-----------------------------------------

以下のコマンドは主にインタラクティブに使用され、テキスト内のインデントに
もとづいて動作します。

 -- Command: back-to-indentation
     このコマンドは、カレント行(ポイントのある行のこと)の最初の非空白文
     字にポイントを移動する。リターン値は‘nil’。

 -- Command: backward-to-indentation &optional arg
     このコマンドは、後方へARG行ポイントを移動した後に、その行の最初の非
     ブランク文字にポイントを移動する。リターン値は‘nil’。ARGが省略また
     は‘nil’のときのデフォルトは1。

 -- Command: forward-to-indentation &optional arg
     このコマンドは、前方へARG行ポイントを移動した後に、その行の最初の非
     ブランク文字にポイントを移動する。リターン値は‘nil’。ARGが省略また
     は‘nil’のときのデフォルトは1。


File: elisp,  Node: Case Changes,  Next: Text Properties,  Prev: Indentation,  Up: Text

31.18 Case Changes
==================

ここで説明する大文字小文字変換コマンドは、カレントバッファー内のテキスト
に作用します。文字列と文字の大文字小文字変換コマンドは*note Case
Conversion::、大文字または小文字に変換する文字や、その変換方法のカスタマ
イズは*note Case Tables::を参照してください。

 -- Command: capitalize-region start end
     この関数はSTARTとENDで定義されるリージョン内のすべての単語を
     capitalizeする。capitalizeとは、各単語の最初の文字を大文字、残りの
     文字を小文字に変換することを意味する。この関数は‘nil’をリターンする
     。

     リージョンのいずれかの端が単語の中間にある場合は、リージョン内にあ
     る部分を単語全体として扱う。

     インタラクティブに‘capitalize-region’が呼び出された際は、STARTと
     ENDはポイントとマークになり、小さいほうが先になる。

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------

          (capitalize-region 1 37)
          ⇒ nil

          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 -- Command: downcase-region start end
     この関数は、STARTとENDで定義されるリージョン内のすべての英文字を小
     文字に変換する。この関数は‘nil’をリターンする。

     インタラクティブに‘downcase-region’が呼び出された際は、STARTとENDは
     ポイントとマークになり、小さいほうが先になる。

 -- Command: upcase-region start end
     この関数は、STARTとENDで定義されるリージョン内のすべての英文字を大
     文字に変換する。この関数は‘nil’をリターンする。

     インタラクティブに‘upcase-region’が呼び出された際は、STARTとENDはポ
     イントとマークになり、小さいほうが先になる。

 -- Command: capitalize-word count
     この関数は、ポイントの後のCOUNT単語をcapitalizeして、変換後その後に
     ポイントを移動する。capitalizeとは、各単語の先頭を大文字、残りを小
     文字に変換することを意味する。COUNTが負なら、この関数は前の−COUNT単
     語をcapitalizeするが、ポイントは移動しない。値は‘nil’。

     ポイントが単語の中間にある場合、ポイントの前にある単語部分は、前方
     に移動する際は無視される。そして残りの部分が単語全体として扱われる
     。

     インタラクティブに‘capitalize-word’が呼び出された際は、COUNTに数プ
     レフィクス引数がセットされる。

 -- Command: downcase-word count
     この関数は、ポイントの後のCOUNT単語を小文字に変換して、変換後その後
     にポイントを移動する。COUNTが負なら、この関数は前の−COUNT単語を小文
     字に変換するが、ポイントは移動しない。値は‘nil’。

     インタラクティブに‘downcase-word’が呼び出された際は、COUNTに数プレ
     フィクス引数がセットされる。

 -- Command: upcase-word count
     この関数は、ポイントの後のCOUNT単語を大文字に変換して、変換後その後
     にポイントを移動する。COUNTが負なら、この関数は前の−COUNT単語を小文
     字に変換するが、ポイントは移動しない。値は‘nil’。

     インタラクティブに‘upcase-word’が呼び出された際は、COUNTに数プレフ
     ィクス引数がセットされる。


File: elisp,  Node: Text Properties,  Next: Substitution,  Prev: Case Changes,  Up: Text

31.19 Text Properties
=====================

バッファーや文字列内の各文字位置は、シンボルにおけるプロパティリスト
(*note Property Lists::を参照)のように、“テキストプロパティリスト(text
property list)”をもつことができます。特定の位置の特定の文字に属するプロ
パティ、たとえばこのセンテンス先頭の文字‘T’(訳注: 翻訳前のセンテンスは
"The properties belong to a ..."で始まる)、または‘foo’の最初の‘o’など、
もし同じ文字が異なる2箇所に存在する場合、2つの文字は一般的に異なるプロパ
ティをもちます。

   それぞれのプロパティには、名前と値があります。どちらも任意のLispオブ
ジェクトをもつことができますが、名前は通常はシンボルです。典型的には、そ
れぞれのプロパティ名シンボルは、特定の目的のために使用されます。たとえば
、テキストプロパティ‘face’は、文字を表示するためのフェイスを指定します
(*note Special Properties::を参照)。名前を指定してそれに対応する値を尋ね
るのが、このプロパティリストにアクセスするための通常の方法です。

   ある文字が‘category’プロパティをもつ場合は、それをその文字の“プロパテ
ィカテゴリー(property category)”と呼びます。これはシンボルであるべきです
。そのシンボルのプロパティは、その文字のプロパティにたいしてデフォルトと
しての役割をもちます。

   文字列とバッファーの間でテキストをコピーには、文字とともにそのプロパ
ティが保持されます。これには‘substring’、‘insert’、‘buffer-substring’の
ようなさまざまな関数が含まれます。

* Menu:

* Examining Properties::     単一の文字のプロパティを調べる。
* Changing Properties::      テキスト範囲のプロパティをセットする。
* Property Search::          プロパティが値を変更する場所の検索。
* Special Properties::       特別な意味をもつ特定のプロパティ。
* Format Properties::        テキストのフォーマットを表すプロパティ。
* Sticky Properties::        挿入されたテキストが隣接するテキストからプロパティを取得する方法。
* Lazy Properties::          テキストが調べられる際のみ、ものぐさな方法でテキストプロパティを計算する。
* Clickable Text::           テキストプロパティを使用して、テキストリージョンがクリック時に何か行うようにする。
* Fields::                   バッファー内にフィールドを定義する‘field’プロパティ。
* Not Intervals::            テキストプロパティがLispから可視なテキスト間隔をもたない理由。


File: elisp,  Node: Examining Properties,  Next: Changing Properties,  Up: Text Properties

31.19.1 Examining Text Properties
---------------------------------

テキストプロパティを調べるもっともシンプルな方法は、特定の文字の特定のプ
ロパティの値を尋ねる方法です。これを行うには、‘get-text-property’を使用
します。ある文字のプロパティリスト全体を取得するには、
‘text-properties-at’を使用します。複数の文字のプロパティを一度に調べる関
数については、*note Property Search::を参照してください。

   以下の関数は、文字列とバッファーの両方を処理します。バッファー内の位
置は1から始まりますが、文字列内の位置は0から始まることに留意してください
。

 -- Function: get-text-property pos prop &optional object
     この関数は、OBJECT(バッファーまたは文字列)内の位置POSの後にある文字
     のプロパティPROPの値をリターンする。引数OBJECTはオプションで、デフ
     ォルトはカレントバッファー。

     厳密な意味でPROPプロパティが存在しないが、その文字がシンボルである
     ようなプロパティカテゴリーをもつなら、‘get-text-property’はそのシン
     ボルのPROPプロパティをリターンする。

 -- Function: get-char-property position prop &optional object
     この関数は‘get-text-property’と似ているが、まずオーバーレイをチェッ
     クして、次にテキストプロパティをチェックする点が異なる。*note
     Overlays::を参照のこと。

     引数OBJECTは文字列、バッファー、あるいはウィンドウかもしれない。ウ
     ィンドウならそのウィンドウ内に表示されているバッファーのテキストプ
     ロパティとオーバーレイが使用されるが、そのウィンドウにたいしてアク
     ティブなオーバーレイだけが考慮される。OBJECTがバッファーなら、その
     バッファー内のオーバーレイがまず優先順に考慮され、その後にテキスト
     プロパティが考慮される。OBJECTが文字列の場合？文字列は決してオーバ
     ーレイをもたないので、テキストプロパティだけが考慮される。

 -- Function: get-pos-property position prop &optional object
     この関数は‘get-char-property’と似ているが、POSITION(すぐ右)にある文
     字のプロパティのかわりに、プロパティのstickiness(粘着性)とオーバー
     レイのadvancement(前向的)なセッティングに注意を払う点が異なる。

 -- Function: get-char-property-and-overlay position prop &optional
          object
     これは‘get-char-property’と似ているが、そのプロパティ値が由来するオ
     ーバーレイについて追加情報を与える点が異なる。

     その値はCARがプロパティ値であるようなコンスセルで、同じ引数により
     ‘get-char-property’がリターンするであろう値と同じである。CDRはその
     プロパティが見つかった箇所のオーバーレイ、またはテキストプロパティ
     として見つかった場合や見つからなかった場合は‘nil’である。

     POSITIONがOBJECTの終端なら、CARとCDRの値はどちらも‘nil’になる。

 -- Variable: char-property-alias-alist
     この変数は、プロパティ名と代替となるプロパティ名リストをマップする
     alistを保持する。文字があるプロパティにたいして直接値を指定しなけれ
     ば、順に代替プロパティ名が調べられ、最初の非‘nil’値が使用される。こ
     の変数は‘default-text-properties’より優先され、この変数より
     ‘category’プロパティが優先される。

 -- Function: text-properties-at position &optional object
     この関数は、文字列またはバッファーOBJECT内の位置POSITIONにある文字
     のプロパティリスト全体をリターンする。OBJECTが‘nil’なら、デフォルト
     はカレントバッファーとなる。

 -- Variable: default-text-properties
     この変数は、テキストプロパティにたいしてデフォルト値を与えるプロパ
     ティリストを保持する。あるプロパティにたいして文字が直接、あるいは
     カテゴリーシンボルまたは‘char-property-alias-alist’を通じて値を指定
     しないときは常に、このリストに格納された値がかわりに使用される。以
     下は例である:

          (setq default-text-properties '(foo 69)
                char-property-alias-alist nil)
          ;; 文字1は自身のプロパティをもたない
          (set-text-properties 1 2 nil)
          ;; 取得される値はデフォルト値である
          (get-text-property 1 'foo)
               ⇒ 69


File: elisp,  Node: Changing Properties,  Next: Property Search,  Prev: Examining Properties,  Up: Text Properties

31.19.2 Changing Text Properties
--------------------------------

プロパティを変更するプリミティブは、バッファーまたは文字列内の指定された
テキスト範囲に適用されます。関数‘set-text-properties’(セクションの最後を
参照)は、その範囲内のテキストのプロパティリスト全体をセットします。名前
を指定することにより特定のプロパティだけを追加、変更、削除するのにも、よ
り有用です。

   テキストプロパティはバッファー(または文字列)のコンテンツの一部とみな
され、かつスクリーン上でのバッファーの見栄えに影響を与えることができるの
で、バッファー内のテキストプロパティの変更はすべて、バッファーを変更済み
とマークします。バッファーテキストプロパティの変更も、アンドゥできます
(*note Undo::を参照)。バッファー内の位置は1から始まりますが、文字列内の
位置は0から始まります。

 -- Function: put-text-property start end prop value &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTとENDの間のテキス
     トにたいして、プロパティPROPにVALUEをセットする。OBJECTが‘nil’なら
     、デフォルトはカレントバッファーである。

 -- Function: add-text-properties start end props &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTとENDの間のテキス
     トにたいして、テキストプロパティを追加またはオーバーライドする。
     OBJECTが‘nil’なら、デフォルトはカレントバッファーである。

     引数PROPSは、追加するプロパティを指定する。これはプロパティリストの
     形式(*note Property Lists::を参照)、つまりプロパティ名と対応する値
     が交互に出現するような要素を含むリストであること。

     関数が実際に何らかのプロパティの値を変更したら‘t’、それ以外(PROPSが
     ‘nil’、またはプロパティの値がテキスト内のプロパティの値と一致してい
     る場合)は‘nil’がリターン値となる。

     たとえば、以下はテキストの範囲に‘comment’と‘face’のプロパティをセッ
     トする例である:

          (add-text-properties START END
                               '(comment t face highlight))

 -- Function: remove-text-properties start end props &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTとENDの間のテキス
     トから、指定されたテキストプロパティを削除する。OBJECTが‘nil’なら、
     デフォルトはカレントバッファーとなる。

     引数PROPSは、削除するプロパティを指定する。これはプロパティリストの
     形式(*note Property Lists::を参照)、つまりプロパティ名と対応する値
     が交互に出現するような要素を含むリストであること。しかし問題となる
     のは名前であり、付随する値は無視される。たとえば‘face’プロパティを
     削除するには、以下のようにすればよい。

          (remove-text-properties START END '(face nil))

     関数が実際に何らかのプロパティの値を変更したら‘t’、それ以外(PROPSが
     ‘nil’、または指定されたテキスト内にそれらのプロパティをもつ文字がな
     い場合)は‘nil’がリターン値となる。

     特定のテキストからすべてのテキストプロパティを削除するには、新たな
     プロパティリストに‘nil’を指定して、‘set-text-properties’を使用すれ
     ばよい。

 -- Function: remove-list-of-text-properties start end
          list-of-properties &optional object
     ‘remove-text-properties’と同様だが、LIST-OF-PROPERTIESがプロパティ
     名と値が交互になったリストではなく、プロパティ名だけのリストである
     点が異なる。

 -- Function: set-text-properties start end props &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTからENDの間のテキ
     ストにたいするテキストプロパティリストを、完全に置き換える。
     OBJECTが‘nil’なら、デフォルトはカレントバッファーとなる。

     引数PROPSは新たなプロパティリスト。これはプロパティメジャーと対応す
     る値が交互となるような要素のリストであること。

     ‘set-text-properties’のリターン後は、指定された範囲内のすべての文字
     は、等しいプロパティをもつ。

     PROPSが‘nil’なら、指定されたテキスト範囲からすべてのプロパティを取
     り除く効果がある。以下は例である:

          (set-text-properties START END nil)

     この関数のリターン値を信用してはならない。

 -- Function: add-face-text-property start end face &optional appendp
          object
     この関数はSTARTとENDの間のテキストのテキストプロパティ‘face’にフェ
     イスFACEを追加するよう動作する。FACEはフェイス名もしくはanonymousフ
     ェイス(anonymous face: 無名フェイス)のような、‘face’プロパティ
     (*note Special Properties::を参照)にたいして有効な値であること
     (*note Faces::を参照)。

     リージョン内の任意のテキストがすでに非‘nil’の‘face’プロパティをもつ
     場合、それらのフェイスは保たれる。 If any text in the region
     already has a non- property, those face(s) are retained. この関数は
     ‘face’プロパティに、最初の要素(デフォルト)がFACE、以前に存在してい
     たフェイスが残りの要素であるような、フェイスのリストをセットする。
     オプション引数APPENDが非‘nil’なら、FACEはかわりにリストの最後に追加
     される。フェイスリスト内では、各属性にたいして最初に出現する値が優
     先されることに注意。

     たとえば以下のコードでは、STARTとENDの間のテキストに、グリーン斜体
     のフェイスを割り当てるだろう:

          (add-face-text-property START END 'italic)
          (add-face-text-property START END '(:foreground "red"))
          (add-face-text-property START END '(:foreground "green"))

     オプション引数OBJECTが非‘nil’なら、それはカレントバッファーではなく
     、動作するバッファーまたは文字列を指定する。OBJECTが文字列なら、
     STARTとENDは0基準で文字列内をインデックス付けする。

   文字列にテキストプロパティを付するもっとも簡単な方法は、
‘propertize’です:

 -- Function: propertize string &rest properties
     この関数は、テキストプロパティPROPERTIESを追加した、STRINGのコピー
     をリターンする。これらのプロパティは、リターンされる文字列内のすべ
     ての文字に適用される。以下は、‘face’プロパティと‘mouse-face’プロパ
     ティとともに文字列を構築する例である:

          (propertize "foo" 'face 'italic
                      'mouse-face 'bold-italic)
               ⇒ #("foo" 0 3 (mouse-face bold-italic face italic))

     文字列のさまざまな部分に異なるプロパティをputするんは、それぞれの部
     分を‘propertize’で構築して、‘concat’でそれらを結合すればよい:

          (concat
           (propertize "foo" 'face 'italic
                       'mouse-face 'bold-italic)
           " and "
           (propertize "bar" 'face 'italic
                       'mouse-face 'bold-italic))
               ⇒ #("foo and bar"
                           0 3 (face italic mouse-face bold-italic)
                           3 8 nil
                           8 11 (face italic mouse-face bold-italic))

   プロパティではなくバッファーからテキストをコピーする関数
‘buffer-substring-no-properties’については、*note Buffer Contents::を参
照してください。


File: elisp,  Node: Property Search,  Next: Special Properties,  Prev: Changing Properties,  Up: Text Properties

31.19.3 Text Property Search Functions
--------------------------------------

テキストプロパティの通常の使用では、ほとんどの場合は複数または多くの連続
する文字が、同じ値のプロパティをもちます。文字を1つずつ調べるプログラム
を記述するよりも、同じプロパティ値をもつテキスト塊(chunks of text)を処理
するほうが、より高速です。

   以下は、これを行うことに使用できる関数です。これらは、プロパティ値の
比較に‘eq’を使用します。すべての関数において、OBJECTのデフォルトはカレン
トバッファーです。

   より良いパフォーマンスのためには、特に単一のプロパティを検索する関数
においては、LIMIT引数の使用が重要です。そうしないと、興味のあるプロパテ
ィが変化しない場合に、バッファー終端までのスキャンに長い時間を要するでし
ょう。

   これらの関数はポイントを移動しません。そのかわりに位置(または‘nil’)を
リターンします。ポイントは常に文字と文字の間にあることを思い出してくださ
い。これらの関数によりリターンされる位置は、異なるプロパティをもつ、2つ
の文字の間にあります。

 -- Function: next-property-change pos &optional object limit
     この関数は文字列またはバッファーOBJECT内の位置POSから、何らかのテキ
     ストプロパティの変化が見つかるまで、テキストを前方にスキャンして、
     変化のあった位置をリターンする。別の言い方をすると、POSの直後の文字
     とプロパティが等しくない、POSの先にある最初の文字の位置をリターンす
     る。

     LIMITが非‘nil’なら、スキャンは位置LIMITで停止する。そのポイントより
     前にプロパティが変化しなければ、この関数はLIMITをリターンする。

     プロパティがOBJECT終端まで変化せず、かつLIMITが‘nil’なら、値は
     ‘nil’となる。値が非‘nil’なら、それはPOS以上の位置である。LIMITが
     POSと等しいときのみ、値はPOSになる。

     以下は、すべてのプロパティが定数であるようなテキスト塊によりバッフ
     ァーをスキャンする方法の例である:

          (while (not (eobp))
            (let ((plist (text-properties-at (point)))
                  (next-change
                   (or (next-property-change (point) (current-buffer))
                       (point-max))))
              ポイントからNEXT-CHANGEへテキストを処理...
              (goto-char next-change)))

 -- Function: previous-property-change pos &optional object limit
     これは‘next-property-change’と似ているが、POSから前方ではなく後方に
     スキャンする点が異なる。値が非‘nil’なら、それはPOS以下の位置である
     。LIMITとPOSが等しい場合のみ、POSをリターンする。

 -- Function: next-single-property-change pos prop &optional object
          limit
     この関数はプロパティPROP内の変化についてテキストをスキャンして、変
     化があった位置をリターンする。このスキャンは、文字列またはバッファ
     ーOBJECT内の位置POSから、前方に行われる。別の言い方をすると、POSの
     直後の文字とプロパティPROPが等しくない、POSの先にある最初の文字の位
     置をリターンする。

     LIMITが非‘nil’なら、スキャンは位置LIMITで終了する。そのポイントより
     前にプロパティの変化がなければ、‘next-single-property-change’は
     LIMITをリターンする。

     プロパティがOBJECT終端まで変化せず、かつLIMITが‘nil’なら、値は
     ‘nil’となる。値が非‘nil’なら、それはPOS以上の位置である。LIMITが
     POSと等しいときのみ、値はPOSになる。

 -- Function: previous-single-property-change pos prop &optional object
          limit
     これは‘next-single-property-change’と似ているが、POSから前方ではな
     く後方にスキャンする点が異なる。値が非‘nil’なら、それはPOS以下の位
     置である。LIMITとPOSが等しい場合のみ、POSをリターンする。

 -- Function: next-char-property-change pos &optional limit
     ‘next-property-change’と似ているが、これはテキストプロパティと同様
     オーバーレイも考慮し、バッファー終端より前に変化が見つからなければ
     、‘nil’ではなくバッファー位置の最大をリターンする点が異なる(この点
     では‘next-property-change’よりも対応するオーバーレイ関数
     ‘next-overlay-change’と似る)。この関数はカレントバッファーだけを処
     理するので、OBJECTオペランドは存在しない。これは、いずれかの種類の
     プロパティが変化した、次のアドレスをリターンする。

 -- Function: previous-char-property-change pos &optional limit
     これは‘next-char-property-change’と似ているが、POSから前方ではなく
     後方へスキャンすること、および変化が見つからなければバッファー位置
     の最小をリターンする点が異なる。

 -- Function: next-single-char-property-change pos prop &optional object
          limit
     ‘next-single-property-change’と似ているが、これはテキストプロパティ
     と同様オーバーレイも考慮し、OBJECT終端より前に変化が見つからなけれ
     ば、‘nil’ではなくOBJECT内の有効な位置の最大をリターンする点が異なる
     。‘next-char-property-change’と異なり、、この関数はOBJECTオペランド
     を_もつ_。OBJECTが非バッファーなら、テキストプロパティだけが考慮さ
     れる。

 -- Function: previous-single-char-property-change pos prop &optional
          object limit
     これは‘next-single-char-property-change’と似ているが、POSから前方で
     はなく後方へスキャンすること、および変化が見つからなければOBJECT内
     の有効な位置の最小をリターンする点が異なる。

 -- Function: text-property-any start end prop value &optional object
     この関数は、STARTとENDの間に少なくともプロパティPROPに値VALUEをもつ
     文字が1つあれば、非‘nil’をリターンする。より正確には、これはそのよ
     うな最初の文字の位置をリターンし、それ以外は‘nil’をリターンする。

     5つ目のオプション引数OBJECTは、スキャンする文字列またはバッファーを
     指定する。位置はOBJECTにたいして相対的である。OBJECTのデフォルトは
     、カレントバッファー。

 -- Function: text-property-not-all start end prop value &optional
          object
     この関数は、STARTとENDの間に少なくともプロパティPROPに値VALUEをもた
     ない文字が1つあれば、非‘nil’をリターンする。より正確には、これはそ
     のような最初の文字の位置をリターンし、それ以外は‘nil’をリターンする
     。

     5つ目のオプション引数OBJECTは、スキャンする文字列またはバッファーを
     指定する。位置はOBJECTにたいして相対的である。OBJECTのデフォルトは
     、カレントバッファー。


File: elisp,  Node: Special Properties,  Next: Format Properties,  Prev: Property Search,  Up: Text Properties

31.19.4 Properties with Special Meanings
----------------------------------------

以下は、ビルトインで特別な意味をもつテキストプロパティ名のテーブルです。
以降のセクションでは、フィルとプロパティ継承を制御する特別なプロパティ名
をいくつか追加でリストしています。これ以外のすべての名前は特別な意味をも
たず、自由に使用できます。

   注意: プロパティ‘composition’、‘display’、‘invisible’、‘intangible’は
すべてのEmacsコマンドの後に、好ましい箇所にポイントを移動させることもで
きます。*note Adjusting Point::を参照してください。

‘category’
     ある文字が‘category’プロパティをもつ場合は、それをその文字の“プロパ
     ティカテゴリー(property category)”と呼びます。これはシンボルである
     こと。このシンボルのプロパティは、その文字のプロパティのデフォルト
     としての役割をもつ。

‘face’
     ‘face’プロパティはその文字の外観を制御する(*note Faces::を参照)。こ
     のプロパティの値は、以下をとることができる:

        • フェイス名(シンボルか文字列)。

        • anonymousフェイス: ‘(KEYWORD VALUE ...)’形式のプロパティリスト
          。KEYWORDはそれぞれフェイス属性名で、VALUEはその属性の値。

        • フェイスのリスト。各リスト要素はフェイス名かanonymousフェイス
          であること。これはリストされた各フェイス属性を集計したフェイス
          を指定する。このリスト内で最初にあるフェイスが、より高い優先度
          をもつ。

        • ‘(foreground-color . COLOR-NAME)’または‘(background-color .
          COLOR-NAME)’形式のコンスセル。これは‘(:foreground
          COLOR-NAME)’や‘(:background COLOR-NAME)’と同じようにフォアグラ
          ウンドまたはバックグラウンドを指定する。この形式は後方互換のた
          めだけにサポートされており、無視するべきである。

     Font Lockモード(*note Font Lock Mode::を参照)はほとんどのバッファー
     において、コンテキストにもとづき文字の‘face’プロパティを動的に更新
     することにより機能する。

     ‘add-face-text-property’関数は、このプロパティをセットする便利な手
     段を提供する。*note Changing Properties::を参照のこと。

‘font-lock-face’
     このプロパティは、Font Lockモードが配下にあるテキストに適用すべき
     ‘face’プロパティにたいして値を指定する。これはFont Lockモードに使用
     されるフォント表示手法の1つであり、独自のハイライトを実装する特別な
     モードにたいして有用である。*note Precalculated Fontification::を参
     照のこと。Font Lockモードが無効なら、‘font-lock-face’に効果はない。

‘mouse-face’
     このプロパティは、文字上または近傍にマウスがあるとき、‘face’のかわ
     りに使用される。この目的にたいして“近傍”とは、文字間のすべてのテキ
     スト、およびマウスが同じ‘mouse-face’プロパティの値をもつことを意味
     する。

     Emacsはテキストサイズ(‘:height’、‘:weight’、‘:slant’)を変更する
     ‘mouse-face’プロパティ由来の属性すべてを無視する。これらの属性は、
     ハイライトされていないテキストと常に等しい。

‘fontified’
     このプロパティはそのテキストの表示準備が整っているかどうかを告げる
     。‘nil’ならEmacsの再表示ルーチンは、バッファーの該当部分を表示する
     前に、準備のために‘fontification-functions’(*note Auto Faces::を参
     照)の中の関数を呼び出す。これはフォントロックのコードの“just in
     time”により、内部的に使用される。

‘display’
     このプロパティは、テキストが表示される方法を変更する、さまざまな機
     能をアクティブ化する。たとえばこれによりテキスト外観を縦長
     (taller)または縦短(short)したり、高く(higher)または低く(lower)、太
     く(wider)または細く(narrower)したり、あるいはイメージに置き換えるこ
     とができる。*note Display Property::を参照のこと。

‘help-echo’
     テキストが‘help-echo’プロパティに文字列をもつ場合、そのテキスト上に
     マウスを移動した際に、Emacsはエコーエリアかツールチップウィンドウ
     (*note (emacs)Tooltips::を参照)にその文字列を表示する。

     ‘help-echo’プロパティの値が関数なら、その関数はWINDOW、OBJECT、
     POSの3つの引数で呼び出され、ヘルプ文字列、または存在しない場合は
     ‘nil’をリターンすること。1つ目の引数WINDOWは、そのヘルプが見つかっ
     たウィンドウである。2つ目の引数OBJECTは、‘help-echo’プロパティをも
     つバッファー、オーバーレイ、または文字列である。POS引数は以下のとお
     り:

        • OBJECTがバッファーなら、POSはそのバッファー内の位置。
        • OBJECTがオーバーレイなら、そのオーバーレイは‘help-echo’プロパ
          ティをもち、POSはそのオーバーレイのバッファー内の位置である。
        • OBJECTが文字列(オーバーレイ文字列、または‘display’プロパティに
          より表示された文字列)なら、POSはその文字列内の位置。

     ‘help-echo’プロパティの値が関数と文字列のいずれでもない場合、それは
     ヘルプ文字列を得るために評価される。

     変数‘show-help-function’をセットすることにより、ヘルプテキストが表
     示される方法を変更できる(*note Help display::を参照)。

     この機能はモードライン内、およびその他のアクティブテキストにたいし
     て使用される。

‘keymap’
     ‘keymap’プロパティは、コマンドにたいして追加のキーマップを指定する
     。このキーマップを適用する際は、マイナーモードキーマップおよびバッ
     ファーのローカルマップの前に、キー照合にこのマップが使用される。
     *note Active Keymaps::を参照のこと。プロパティ値がシンボルなら、そ
     のシンボルの関数定義がキーマップとして使用される。

     ポイントの前の文字のプロパティの値は、それが非‘nil’でrear-stickyで
     あり、かつポイントの後の文字のプロパティ値が非‘nil’でfront-stickyな
     ら適用される(マウスクリックではポイント位置のかわりにクリック位置が
     使用される)。

‘local-map’
     このプロパティは‘keymap’と同じように機能するが、これはそのバッファ
     ーのローカルマップの_かわりに_使用するキーマップを指定する点が異な
     る。ほとんど(もしかするとすべて)の目的にたいしては、‘keymap’を使用
     するほうが良いだろう。

‘syntax-table’
     ‘syntax-table’プロパティは、特定の文字にたいして、どのシンタックス
     テーブルがオーバーライドするかを告げる。*note Syntax Properties::を
     参照のこと。

‘read-only’
     ある文字がプロパティ‘read-only’をもつなら、その文字の変更は許可され
     ない。これを行おうとするすべてのコマンドは、‘text-read-only’エラー
     を受け取る。プロパティの値が文字列なら、その文字列がエラーメッセー
     ジとして使用される。

     read-only文字に隣接する箇所への挿入は、そこに通常のテキストの行うこ
     とがstickinessによる‘read-only’プロパティを継承するなら、エラーとな
     る。つまりstickinessを制御することにより、read-onlyテキストに隣接す
     る挿入の権限を制御することができる。*note Sticky Properties::を参照
     のこと。

     プロパティ変更はバッファー変更とみなされるので、特別なトリック
     (‘inhibit-read-only’を非‘nil’にバインドしてからプロパティを削除する
     )を知らないかぎり、‘read-only’プロパティを取り除くことは不可能であ
     る。*note Read Only Buffers::を参照のこと。

‘invisible’
     非‘nil’の‘invisible’プロパティにより、スクリーン上で文字を不可視に
     できる。詳細は*note Invisible Text::を参照されたい。

‘intangible’
     連続する文字のグループが非‘nil’の等しい‘intangible’プロパティをもつ
     なら、それらの文字の間にポイントを置くことは不可能である。そのグル
     ープ内に前方へポイントの移動を試みると、ポイントは実際にはそのグル
     ープの終端に移動する。そのグループ内に後方へポイントの移動を試みる
     と、ポイントは実際にはそのグループの先頭に移動する。

     連続する文字のグループが非‘nil’の等しくない‘intangible’プロパティを
     もつなら、それらの文字は個別のグループに属し、各グループは上述のよ
     うに別のグループとして扱われる。

     変数‘inhibit-point-motion-hooks’が非‘nil’なら、‘intangible’プロパテ
     ィは無視される。

     注意せよ: このプロパティは非常に低レベルで処理され、予想害の方法に
     より多くのコードに影響する。そのため使用に際しては特別な注意を要す
     る。誤った使用方法としては、不可視のテキストにintangibleプロパティ
     wpeをputするのが一般的であり、コマンドループは各コマンドの終わりに
     不可視テキストの外部へポイントを移動するだろうから、これは実際には
     必要ない。*note Adjusting Point::を参照されたい。

‘field’
     同じ‘field’プロパティをもつ連続する文字は、“フィールド”を構成する。
     ‘forward-word’や‘beginning-of-line’を含むいくつかの移動関数は、フィ
     ールド境界で移動を停止する。*note Fields::を参照のこと。

‘cursor’
     カーソルは通常、カレントバッファー位置にあるオーバーレイ、およびテ
     キストプロパティ文字列の先頭か終端に表示される。文字に非‘nil’の
     ‘cursor’テキストプロパティを与えることにより、それら文字列内の、任
     意の望む文字にカーソルを置くことができる。加えて‘cursor’プロパティ
     の値が整数なら、それはカーソルがその文字上に表示されるように、オー
     バーレイまたは‘display’プロパティが始まる位置から数えたバッファーの
     文字位置の数字を指定する。特に、ある文字の‘cursor’プロパティの値が
     数字Nなら、カーソルは範囲‘[OVPOS..OVPOS+N)’内の任意のバッファー位置
     にあるその文字上に表示されるだろう。ここでOVPOSは
     ‘overlay-start’(*note Managing Overlays::を参照)により与えられるオ
     ーバーレイ開始位置、またはそのバッファー内で‘display’プロパティが始
     まる位置である。

     他の言い方をすると、文字列の非‘nil’値の‘cursor’プロパティをもつ文字
     は、カーソルが表示される文字である。このプロパティの値は、カーソル
     を表示するバッファーの位置を告げる。値が整数なら、オーバーレイまた
     は‘display’プロパティの始まりからN後ろの位置までの間にポイントがあ
     るとき、カーソルはそこに表示される。値がそれ以外の非‘nil’なら、ポイ
     ントが‘display’プロパティの先頭、または‘overlay-start’の位置だけに
     表示される。

     バッファーに多くのオーバーレイ文字列(*note before-string: Overlay
     Properties.を参照)や文字列であるような‘display’プロパティがある場合
     、それらの文字列を走査する間にカーソルを置く箇所をEmacsに合図するた
     めに、‘cursor’プロパティを使用するのは、よいアイデアである。これは
     Lispプログラムやユーザーがカーソルを配したい箇所で、ディスプレイエ
     ンジンと直接通信する。

‘pointer’
     これはそのテキストやイメージ上にマウスポインターがあるときの、特定
     のマウスシェイプを指定する。利用できるポインターシェイプについては
     、*note Pointer Shape::を参照されたい。

‘line-spacing’
     改行は、改行で終わるディスプレイ行の高さを制御するテキストプロパテ
     ィまたはオーバーレイプロパティ‘line-spacing’をもつことができる。こ
     のプロパティ値は、デフォルトのフレーム行スペーシングと、バッファー
     ローカル変数‘line-spacing’をオーバーライドする。*note Line
     Height::を参照のこと。

‘line-height’
     改行は、改行で終わるディスプレイ行のトータル高さを制御するテキスト
     プロパティ、またはオーバーレイプロパティ‘line-height’をもつことがで
     きる。*note Line Height::を参照のこと。

‘wrap-prefix’
     テキストが‘wrap-prefix’プロパティをもつなら、それが定義するプレフィ
     クスは、テキストラッピング(text wrapping: テキスト折り返し)に由来す
     るすべての継続行の先頭に、表示時に追加されるだろう(行が切り詰められ
     た場合、wrap-prefixが使用されることはない)。これは文字列、イメージ
     (*note Other Display Specs::を参照)、あるいはディスプレイプロパティ
     ‘:width’または‘:align-to’(*note Specified Space::を参照)により指定
     されて空白文字範囲かもしれない。

     wrap-prefixはバッファーローカル変数‘wrap-prefix’を使用して、バッフ
     ァー全体にも指定され得る(が、‘wrap-prefix’テキストプロパティは
     ‘wrap-prefix’変数の値より優先される)。*note Truncation::を参照のこ
     と。

‘line-prefix’
     テキストが‘line-prefix’プロパティをもつなら、それが定義するプレフィ
     クスは表示時に、すべての非継続行の先頭に追加されるだろう。これは文
     字列、イメージ(*note Other Display Specs::を参照)、あるいはディスプ
     レイプロパティ‘:width’または‘:align-to’(*note Specified Space::を参
     照)により指定されて空白文字範囲かもしれない。

     line-prefixはバッファーローカル変数‘line-prefix’を使用して、バッフ
     ァー全体にも指定され得る(が、‘line-prefix’テキストプロパティは
     ‘line-prefix’変数の値より優先される)。*note Truncation::を参照のこ
     と。

‘modification-hooks’
     ある文字がプロパティ‘modification-hooks’をもつなら、その値は関数の
     リストであること。その文字の変更により、実際の変更前にそれらの関数
     すべてが呼び出される。それぞれの関数は、変更されようとするバッファ
     ー部分の先頭と終端という、2つの引数を受け取る。特定のmodificationフ
     ック関数が、単一のプリミティブにより変更されつつある複数の文字に出
     現する場合は、その関数が呼び出される回数を予測することはできない。
     さらに挿入は既存の文字を変更しないので、このフックは文字の削除、他
     の文字への置換、またはそれらのテキストプロパティ変更時のみ実行され
     るだろう。

     これらの関数がバッファーを変更する場合には、これらのフックを呼び出
     す内部的メカニズムの混乱を避けるために、それらの関数はそれを行う前
     後に‘inhibit-modification-hooks’を‘t’にバインドするべきである。

     オーバーレイも‘modification-hooks’プロパティをサポートするが、詳細
     は若干異なる(*note Overlay Properties::を参照)。

‘insert-in-front-hooks’
‘insert-behind-hooks’
     あるバッファーへの挿入操作は、後続文字の‘insert-in-front-hooks’プロ
     パティ、および先行文字の‘insert-behind-hooks’プロパティにリストされ
     る関数も呼び出す。これらの関数は、挿入されるテキストの先頭と終端と
     いう、2つの引数を受け取る。関数は、優先される実際の挿入が行われた
     _後に_呼び出される。

     バッファー内のテキスト変更。に呼び出される他のフックについては、
     *note Change Hooks::も参照されたい。

‘point-entered’
‘point-left’
     スペシャルプロパティ‘point-entered’および‘point-left’は、ポイント移
     動をリポートするフック関数を記録する。ポイントを移動するたびに、
     Emacsは以下の2つのプロパティ値を比較する:

        • 古い位置の後の文字の‘point-left’プロパティ。
        • 新しい位置の後の文字の‘point-entered’プロパティ。

     これらの2つの値が異なる場合、(‘nil’でなければ)古いポイント値と新し
     いポイント値という2つの引数とともにそれらそれぞれ呼び出される。

     同じ比較は古い位置と新しい位置の前の文字にたいしても行われる。この
     結果、2つの‘point-left’関数(同じ関数かもしれない)、および/または2つ
     の‘point-entered’関数(同じ関数かもしれない)が実行される可能性がある
     。ある場合においては、まずすべての‘point-left’関数が呼び出されて、
     その後にすべての‘point-entered’関数が呼び出される。

     さまざまなバッファー位置にたいして、そこにポイントを移動することな
     く文字を調べるために、‘char-after’を使用することができる。実際のポ
     イント値変更だけが、これらのフック関数を呼び出す。

     変数‘inhibit-point-motion-hooks’は‘point-left’および
     ‘point-entered’のフック実行を抑制できる。*note Inhibit point motion
     hooks::を参照のこと。

‘composition’
     このテキストプロパティは、文字シーケンスをコンポーネントから構成さ
     れる単一グリフ(single glyph)として表示するために使用される。しかし
     このプロパティの値自身は完全にEmacsの内部的なものであり、たとえば
     ‘put-text-property’などにより直接操作するべくではない。

 -- Variable: inhibit-point-motion-hooks
     この変数が非‘nil’のときは、‘point-left’と‘point-entered’のフックは
     実行されず、‘intangible’プロパティは効果をもたない。この変数はグロ
     ーバルにセットせず‘let’でバインドすること。

 -- Variable: show-help-function
     この変数が非‘nil’なら、それはヘルプ文字列を表示するために呼び出され
     る関数を指定する。これらは‘help-echo’プロパティ、メニューヘルプ文字
     列(*note Simple Menu Items::と*note Extended Menu Items::を参照)、
     ツールバーヘルプ文字列(*note Tool Bar::を参照)かもしれない。指定さ
     れた関数は、表示するためのヘルプ文字列という、単一の引数とともに呼
     び出される。Tooltipモード(*note (emacs)Tooltips::を参照)が、例を提
     供している。


File: elisp,  Node: Format Properties,  Next: Sticky Properties,  Prev: Special Properties,  Up: Text Properties

31.19.5 Formatted Text Properties
---------------------------------

以下のテキストプロパティは、フィルコマンドの挙動に影響を与えます。これら
はフォーマットされたテキストを表すために使用されます。*note Filling::お
よび*note Margins::を参照してください。

‘hard’
     改行文字がこのプロパティをもつなら、それは“hard”改行である。フィル
     コマンドはhard改行を変更せず、それらを横断して単語を移動しない。し
     かしこのプロパティは、マイナーモード‘use-hard-newlines’が有効な場合
     のみ影響を与える。*note Hard and Soft Newlines: (emacs)Hard and
     Soft Newlines.を参照のこと。

‘right-margin’
     このプロパティは、その部分のテキストのフィルにたいして、余分な右マ
     ージンを指定する。

‘left-margin’
     このプロパティは、その部分のテキストのフィルにたいして、余分な左マ
     ージンを指定する。

‘justification’
     このプロパティは、その部分のテキストのフィルにたいして、位置揃え
     (justification)のスタイルを指定する。


File: elisp,  Node: Sticky Properties,  Next: Lazy Properties,  Prev: Format Properties,  Up: Text Properties

31.19.6 Stickiness of Text Properties
-------------------------------------

自己挿入文字は通常、先行する文字と同じプロパティをもちます。これはプロパ
ティの“継承(inheritance)”と呼ばれます。

   Lispプログラムは継承の有無に関わらず挿入を行うことができ、それは挿入
プリミティブの選択に依存します。‘insert’のような通常のテキスト挿入関数は
、何もプロパティを継承しません。これらは挿入される文字列と正確に同じプロ
パティをもち、それ以外のプロパティはもちません。これはたとえばkillリング
外部にたいしてのように、あるコンテキストから他のコンテキストにテキストを
コピーするプログラムにたいして適正です。継承つきで挿入を行うためには、こ
のセクションで説明するスペシャルプリミティブを使用します。自己挿入文字は
、これらのプリミティブを使用するので、プロパティを継承するのです。

   継承つきで挿入を行う際に、_どの_プロパティがどこから継承されるかは、
“sticky(スティッキー、粘着する)”に依存します。ある文字の後への挿入におけ
る、それらのモジノプロパティ継承は“rear-sticky(後方スティッキー)”です。
ある文字の前への挿入における、それらのモジノプロパティ継承は
“front-sticky(前方スティッキー)”です。これら両側のstickyが、同じプロパテ
ィにたいして異なるsticky値をもつ場合は、前の文字の値が優先します。

   デフォルトでは、テキストプロパティはfront-stickyではなく、
rear-stickyです。したがってデフォルトでは、すべてのプロパティは前の文字
から継承し、後の文字からは何も継承しません。

   さまざまなテキストプロパティのstickiness(スティッキネス、スティッキー
性、粘着性、粘着度)はは、2つのテキストプロパティ‘front-sticky’および
‘rear-nonsticky’と、変数‘text-property-default-nonsticky’で制御できます
。与えられたプロパティにたいして異なるデフォルトを指定するために、この変
数を使用できます。テキストの任意の特定部分に特定のプロパティsticky、また
は非stickyを指定するために、これら2つのテキストプロパティを使用できます
。

   ある文字の‘front-sticky’プロパティが‘t’なら、その文字のすべてのプロパ
ティはfront-stickyです。‘front-sticky’プロパティがリストなら、その文字の
stickyなプロパティは、名前がそのリスト内にあるプロパティです。たとえばあ
る文字が値が‘(face read-only)’であるような‘front-sticky’プロパティをもつ
なら、その文字の前への挿入ではその文字の‘face’プロパティと‘read-only’プ
ロパティは継承できますが、他のプロパティはｐ継承できません。

   ‘rear-nonsticky’は逆の方法で機能します。ほとんどのプロパティはデフォ
ルトでrear-stickyであり、‘rear-nonsticky’プロパティはどのプロパティが
rear-sticky_ではない_かを告げますある文字の‘rear-nosticky’プロパティが
‘t’なら、その文字のすべてのプロパティはrear-stickyではありません。
‘rear-nosticky’プロパティがリストなら、その文字のstickyなプロパティは、
名前がそのリスト内に_ない_プロパティです。

 -- Variable: text-property-default-nonsticky
     この変数は、さまざまなテキストプロパティのデフォルトの
     rear-stickinessを定義するalistである。各要素は‘(PROPERTY .
     NONSTICKINESS)’という形式をもち、これは特定のテキストプロパティ
     PROPERTYのstickinessを定義する。

     NONSTICKINESSが非‘nil’なら、それはプロパティPROPERTYがデフォルトで
     rear-nonstickyであることを意味する。すべてのプロパティはデフォルト
     でfront-nonstickyなので、これによりPROPERTYは両方向にたいしてデフォ
     ルトでnonstickyになる。

     テキストプロパティ‘front-sticky’および‘rear-nonsticky’が使用された
     際には、‘text-property-default-nonsticky’内で指定されたデフォルトの
     NONSTICKINESSより優先される。

   以下はプロパティ継承つきでテキストを挿入する関数です:

 -- Function: insert-and-inherit &rest strings
     関数‘insert’と同じように文字列STRINGSを挿入するが、隣接するテキスト
     からすべてのstickyなプロパティを継承する。

 -- Function: insert-before-markers-and-inherit &rest strings
     関数‘insert-before-markers’と同じように文字列STRINGSを挿入するが、
     隣接するテキストからすべてのstickyなプロパティを継承する。

   継承を行わない通常の挿入関数については、*note Insertion::を参照してく
ださい。


File: elisp,  Node: Lazy Properties,  Next: Clickable Text,  Prev: Sticky Properties,  Up: Text Properties

31.19.7 Lazy Computation of Text Properties
-------------------------------------------

バッファー内のすべてのテキストにたいしてテキストプロパティを計算するかわ
りに、何かがテキスト範囲に依存している場合、その際はテキストプロパティを
計算するようにアレンジできます。

   プロパティとともにバッファーからテキストを抽出するプリミティブは、
‘buffer-substring’です。プロパティを調べる前に、この関数はアブノーマルフ
ック‘buffer-access-fontify-functions’を実行します。

 -- Variable: buffer-access-fontify-functions
     この変数は、テキストプロパティ計算用の関数のリストを保持する。
     ‘buffer-substring’がバッファーの一部のテキストとテキストプロパティ
     をコピーする前に、このリスト内の関数すべてを呼び出す。各関数はアク
     セスされるバッファー範囲を指定する、2つの引数を受け取る(バッファー
     は常にカレントバッファーとなる)。

   関数‘buffer-substring-no-properties’はいずれにせよテキストプロパティ
を無視するので、これらの関数を呼び出さない。

   同じバッファー部分にたいして複数回フック関数が呼び出されるのを防ぐに
は、変数‘buffer-access-fontified-property’を使用できる。

 -- Variable: buffer-access-fontified-property
     この変数の値が非‘nil’なら、それはテキストプロパティ名として使用され
     るシンボルである。そのテキストプロパティにたいする非‘nil’値は、“そ
     の文字にたいする他のテキストプロパティはすでに計算済み”であることを
     意味する。

     ‘buffer-substring’にたいして指定された範囲内のすべての文字が、この
     プロパティにたいする値として非‘nil’をもつなら、‘buffer-substring’は
     ‘buffer-access-fontify-functions’の関数を呼び出さない。それらの文字
     がすでに正しいテキストプロパティをもつとみなし、それらがすでに所有
     するプロパティを単にコピーする。

     ‘buffer-access-fontify-functions’の関数にこのプロパティ、同様に他の
     プロパティを処理対象の文字に追加させるのが、この機能の通常の用途で
     ある。この方法では、同じテキストにたいして、それらの関数が何度も呼
     び出されるのを防ぐことができる。


File: elisp,  Node: Clickable Text,  Next: Fields,  Prev: Lazy Properties,  Up: Text Properties

31.19.8 Defining Clickable Text
-------------------------------

“クリック可能テキスト(clickable text)”とは何らかの結果を生成するために、
マウス、またはキーボードコマンドを通じてクリックできるテキストです。多く
のメジャーモードがテキスト的なハイパーリンク、略して“リンク(link)”を実装
するために、クリック可能テキストを使用しています。

   リンクを挿入および操作するもっとも簡単な方法は、‘button’パッケージの
使用です。*note Buttons::を参照してください。このセクションではテキスト
プロパティを使用して、バッファー内に手作業でクリック可能テキストをセット
アップする方法を説明します。簡略にするために、クリック可能テキストを“リ
ンク”と呼ぶことにします。

   リンクの実装には、(1)リンク上にマウスが移動した際にクリック可能である
ことを示し、(2)そのリンク上の<RET>か‘Mouse-2’で何かを行うようにして、
(3)そのリンクが‘mouse-1-click-follows-link’にしたがうよう‘follow-link’を
セットアップする、という3つのステップが含まれます。

   クリック可能を示すためには、そのリンクのテキストに‘mouse-face’プロパ
ティを追加します。すると、以降Emacsはマウスがその上に移動した際にリンク
をハイライトするでしょう。加えて‘help-echo’テキストプロパティを使用して
、ツールチップかエコーエリアメッセージを定義するべきです。*note Special
Properties::を参照してください。たとえば以下は、Diredがファイル名がクリ
ック可能なことを示す方法です:

      (if (dired-move-to-filename)
          (add-text-properties
            (point)
            (save-excursion
              (dired-move-to-end-of-filename)
              (point))
            '(mouse-face highlight
              help-echo "mouse-2: visit this file in other window")))

   リンクをクリック可能にするためには、 <RET>と‘Mouse-2’を望むアクション
を行うコマンドにバインドします。各コマンドは、リンク上から呼び出されたか
チェックして、それに応じて動作するべきです。たとえばDiredメジャーモード
のキーマップは、‘Mouse-2’を以下のコマンドにバインドします:

     (defun dired-mouse-find-file-other-window (event)
       "In Dired, visit the file or directory name you click on."
       (interactive "e")
       (let ((window (posn-window (event-end event)))
             (pos (posn-point (event-end event)))
             file)
         (if (not (windowp window))
             (error "No file chosen"))
         (with-current-buffer (window-buffer window)
           (goto-char pos)
           (setq file (dired-get-file-for-visit)))
         (if (file-directory-p file)
             (or (and (cdr dired-subdir-alist)
                      (dired-goto-subdir file))
                 (progn
                   (select-window window)
                   (dired-other-window file)))
           (select-window window)
           (find-file-other-window (file-name-sans-versions file t)))))

このコマンドはクリックがどこで発生したかを判断するために、関数
‘posn-window’と‘posn-point’、visitするファイルの判断に関数
‘dired-get-file-for-visit’を使用します。

   マウスコマンドをメジャーモードキーマップ内でバインドするかわりに、
‘keymap’プロパティ(*note Special Properties::を参照)を使用して、リンクテ
キスト内でバインドできます。たとえば:

     (let ((map (make-sparse-keymap)))
       (define-key map [mouse-2] 'operate-this-button)
       (put-text-property link-start link-end 'keymap map))

この手法では、異なるリンクに異なるコマンドを簡単に定義できます。さらに、
そのバッファー内の残りのテキストにたいしては、<RET>と‘Mouse-2’のグローバ
ル定義を利用可能なまま残すことができます。

   リンク上でのクリックにたいするEmacsの基本コマンドは、‘Mouse-2’です。
しかし他のグラフィカルなアプリケーションとの互換性のために、ユーザーがマ
ウスを動かさずに素早くリンクをクリックするという条件の下、Emacsはリンク
上での‘Mouse-1’クリックも認識します。おこ振る舞いは、ユーザーオプション
‘mouse-1-click-follows-link’により制御されます。*note (emacs)Mouse
References::を参照してください。

   ‘mouse-1-click-follows-link’にしたがうようにリンクをセットアップする
には、(1)そのテキストに‘follow-link’テキストプロパティまたはオーバーレイ
プロパティを適用する、または(2)‘follow-link’イベントをキーマップ
(‘keymap’テキストプロパティを通じたメジャーモードキーマップまたはローカ
ルキーマップ)にバインドするかの、いずれかを行わなければなりません。
‘follow-link’プロパティの値、または‘follow-link’イベントにたいするバイン
ディングはリンクアクションにたいする“コンディション(condition)”として機
能します。この条件は、Emacsにたいして2つのことを告げます。それは
‘Mouse-1’のクリックがそのリンクの“内側”で発生したとみなすべき状況、そし
て‘Mouse-1’のクリックを何に変換するかを告げる“アクションコード(action
code)”を計算する方法です。そのリンクのアクション条件は、以下のうちの1つ
です:

‘mouse-face’
     コンディションがシンボル‘mouse-face’の場合、その位置に非‘nil’の
     ‘mouse-face’プロパティがあれば、それはリンク内側の位置である。アク
     ションコードは常に‘t’。

     以下はInfoモードが<Mouse-1>を処理する例である:

          (define-key Info-mode-map [follow-link] 'mouse-face)

関数
     コンディションが関数FUNCの場合、‘(FUNC POS)’が非‘nil’に評価されれば
     、位置POSはリンクの内側である。FUNCがリターンする値は、アクションコ
     ードとして機能する。

     以下はpcvsがファイル名の上でのみ‘Mouse-1’によるリンクのフォローを有
     効にする方法の例である:

          (define-key map [follow-link]
            (lambda (pos)
              (eq (get-char-property pos 'face) 'cvs-filename-face)))

その他
     コンディション値がそれ以外の場合、その位置はリンク内側であり、その
     コンディション自体がアクションコードである。(バッファー全体に適用さ
     れないように)リンクテキストのテキストプロパティまたはオーバーレイプ
     ロパティを通じてコンディションを適用するときのみ、この類のコンディ
     ションを指定すべきなのは明確である。

アクションコードは、‘Mouse-1’がリンクをフォローする方法を告げます:

文字列またはベクター
     アクションコードが文字列かベクターなら、‘Mouse-1’イベントは文字列ま
     たはベクターの最初の要素に変換される。つまり‘Mouse-1’クリックのアク
     ションは、その文字またはシンボルのローカルまたはグローバルバインデ
     ィングである。したがってアクションコードが‘"foo"’なら、‘Mouse-1’は
     ‘f’に変換され、‘[foo]’なら‘Mouse-1’は<foo>に変換される。

その他
     その他非‘nil’のアクションコードでは、‘Mouse-1’イベントは同じ位置の
     ‘Mouse-2’イベントに変換される。

   ‘define-button-type’で定義されるボタンをアクティブにするように
‘Mouse-1’を定義するには、そのボタンに‘follow-link’プロパティを与えます。
このプロパティの値は、上述したリンクのアクションコンディションであること
。*note Buttons::を参照のこと。たとえば以下はHelpモードが‘Mouse-1’を処理
する例である。

     (define-button-type 'help-xref
       'follow-link t
       'action #'help-button-action)

   ‘define-widget’で定義されたウィジェットに‘Mouse-1’を定義するには、そ
のウィジェットに‘:follow-link’プロパティを与えます。このプロパティの値は
、上述したようなリンクのアクションコンディションであるべきです。たとえば
、以下は<Mouse-1>クリックが<RET>に変換されるように、‘link’ウィジェットを
指定する方法の例をです:

     (define-widget 'link 'item
       "An embedded link."
       :button-prefix 'widget-link-prefix
       :button-suffix 'widget-link-suffix
       :follow-link "\C-m"
       :help-echo "Follow the link."
       :format "%[%t%]")

 -- Function: mouse-on-link-p pos
     この関数は、カレントバッファー内の位置POSがリンク上なら、非‘nil’を
     リターンする。POSは‘event-start’がリターンするようなマウスイベント
     位置でもよい(*note Accessing Mouse::を参照)。


File: elisp,  Node: Fields,  Next: Not Intervals,  Prev: Clickable Text,  Up: Text Properties

31.19.9 Defining and Using Fields
---------------------------------

フィールドとはバッファー内にある連続する文字範囲であり、‘field’プロパテ
ィ(テキストプロパティかオーバーレイプロパティ)に同じ値(‘eq’で比較)をもつ
ことにより識別されます。このセクションでは、フィールドの操作に利用できる
スペシャル関数を説明します。

   フィールドは、バッファー位置POSで指定します。各フィールドはバッファー
位置の範囲を含むと考えて、指定した位置はその位置を含むフィールドを表しま
す。

   POSの前または後の文字は同じフィールドに属し、どのフィールドがPOSを含
むかという疑問はありません。それらの文字が属するフィールドが、そのフィー
ルドです。POSがフィールド境界のときは、それがどのフィールドに属すかは、
取り囲む2つの文字の‘field’プロパティのstickinessに依存します(*note
Sticky Properties::を参照)。POSに挿入されたテキストからプロパティが継承
されたフィールドが、POSを含むフィールドです。

   POSに新たに挿入されたテキストが、いずれの側からも‘field’プロパティを
継承しない、異常なケースがあります。これは前の文字の‘field’プロパティが
rear-stickyでなく、後の文字の‘field’プロパティがfront-stickyでもない場合
に発生します。このケースでは、POSは前のフィールドと後のフィールドいずれ
にも属しません。フィールド関数はそれを、開始と終了がPOSの空フィールドに
属するものとして扱います。

   これらすべての関数では、POSが省略または‘nil’の場合は、ポイントの値が
デフォルトとして使用されます。ナローイング(narrowing)が効力をもつ場合、
POSはアクセス可能部分にあるはずです。*note Narrowing::を参照してください
。

 -- Function: field-beginning &optional pos escape-from-edge limit
     この関数は、POSで指定されたフィールドの先頭をリターンする。

     POSが自身のフィールド先頭にあり、かつESCAPE-FROM-EDGEが非‘nil’なら
     、POS周辺の‘field’プロパティのstickinessに関わらず、リターン値は常
     にPOSが終端であるような前のフィールドの先頭になる。

     LIMITが非‘nil’なら、それはバッファーの位置である。そのフィールドの
     先頭がLIMITより前なら、かわりにLIMITがリターンされるだろう。

 -- Function: field-end &optional pos escape-from-edge limit
     この関数は、POSで指定されるフィールドの終端をリターンする。

     POSが自身のフィールド終端にあり、かつESCAPE-FROM-EDGEが非‘nil’なら
     、POS周辺の‘field’プロパティのstickinessに関わらず、リターン値は常
     にPOSが_先頭_であるような後のフィールドの終端になる。

     LIMITが非‘nil’なら、それはバッファーの位置である。そのフィールドの
     終端がLIMITより後なら、かわりにLIMITがリターンされるだろう。

 -- Function: field-string &optional pos
     この関数はPOSで指定されるフィールドのコンテンツを、文字列としてリタ
     ーンする。

 -- Function: field-string-no-properties &optional pos
     この関数は、POSで指定されるフィールドのコンテンツを、テキストプロパ
     ティを無視して、文字列としてリターンする。

 -- Function: delete-field &optional pos
     この関数は、POSで指定されるフィールドのテキストを削除する。

 -- Function: constrain-to-field new-pos old-pos &optional
          escape-from-edge only-in-line inhibit-capture-property
     この関数はNEW-POSをOLD-POSが属するフィールドに“拘束(constrain)”する
     。別の言い方をすると、これは OLD-POSと同じフィールド内でNEW-POSにも
     っとも近い位置をリターンする。

     NEW-POSが‘nil’なら、‘constrain-to-field’はかわりにポイントの値を使
     用して、ポイントをリターンすることに加えて、その位置にポイントを移
     動する。

     OLD-POSが2つのフィールドの境界なら、許容できる最後の位置は引数
     ESCAPE-FROM-EDGEに依存する。ESCAPE-FROM-EDGEが‘nil’なら、NEW-POSは
     新たに文字がOLD-POSが挿入されたときに、継承するであろう値と
     ‘field’プロパティが等しいフィールドでなければならない
     ESCAPE-FROM-EDGEがｐ非‘nil’なら、NEW-POSは隣接する2つのフィールド内
     のどこでも構わない。さらに、2つのフィールドが特別な値‘boundary’によ
     り、他のフィールドで分割されている場合、このスペシャルフィールド内
     のすべてのポイントも、“境界上”とみなされる。

     引数なしの‘C-a’コマンドのように、特別な類の位置に後方へ移動して一度
     そこに留まるには、おそらくESCAPE-FROM-EDGEにたいして‘nil’を指定する
     べきであろう。フィールドをチェックする他の移動コマンドにたいしては
     、おそらく‘t’を渡すべきである。

     オプション引数ONLY-IN-LINEが非‘nil’、かつNEW-POSを通常の方法により
     拘束することにより異なる行へ移動するような場合、NEW-POSは非拘束でリ
     ターンされる。これは‘next-line’や‘beginning-of-line’のような行単位
     の移動コマンドで、それらのコマンドが正しい行へ移動できる場合だけフ
     ィールド境界を尊重するようにするために用いられる。

     オプション引数INHIBIT-CAPTURE-PROPERTYが非‘nil’、かつOLD-POSがその
     名前の非‘nil’なプロパティをもつなら、すべてのフィールド境界は無視さ
     れる。

     変数‘inhibit-field-text-motion’を非‘nil’値にバインドすることにより
     、‘constrain-to-field’にすべてのフィールド境界を無視(何者にも拘束さ
     れることがない)させることができる。


File: elisp,  Node: Not Intervals,  Prev: Fields,  Up: Text Properties

31.19.10 Why Text Properties are not Intervals
----------------------------------------------

ユーザーにテキスト内の“インターバル(訳注: 原文のインターバルはIT用語とし
ては時間や距離などの間隔を示す用語として用いれることが多いと思いますが、
ここでは『範囲』を示す言葉として用いられているようです。他の箇所で『範囲
』と訳したrange等と異なる機能なので、ここではそのまま『インターバル』と
しました)”を指定させて、そのインターバルにプロパティを追加するために、バ
ッファー内のテキストへの属性の追加をサポートするエディターがいくつかあり
ます。それらのエディターは、ユーザーやプログラマーが個別にインターバルの
開始と終了を決定することを許可します。わたしたちは、テキスト変更に関連す
る特定の逆説的振る舞いを避けるために、Emacs Lisp内に、故意に異なる種類の
インターフェイスを提供しました。

   複数のインターバルに細分化することが実際に意味をもつなら、それは特定
のプロパティをもつ単一のインターバルのバッファーと、同じテキストをもち、
両方が同じプロパティをもつ2つのインターバルに分割されたバッファーを区別
できることを意味します。

   インターバルを1つだけもつバッファーがあり、その一部をkillすることを考
えてみてください。そのそのバッファーに残されるのは1つのインターバルであ
り、killリング(とundoリスト)内のコピーは別個のインターバルになります。そ
のkillされたテキストをyankで戻すと、同じプロパティをもつ2つのインターバ
ルを得ることになります。したがって、編集では1つのインターバルと2つのイン
ターバルの違いは保たれません。

   テキスト挿入時に2つのインターバルを結合することにより、この問題に“対
応”したとします。これは、そのバッファーが元々単一のインターバルだったな
ら、上手く機能します。 しかし、かわりに同じプロパティをもつ隣接する2つの
インターバルがあり、そのうちの1つのインターバルからテキストをkillして、
それをyankで戻すことを考えてみてください。あるケースを解決する同じインタ
ーバル結合機能が、他のケースにおいては問題を引き起こすのです。このyank後
、インターバルはただ1つとなります。繰り返します、編集では1つのインターバ
ルと2つのインターバルの違いは保たれないのです。

   インターバルの間の境界上へのテキスト挿入でも、満足できる回答かない問
題が発生します。

   しかし、“バッファーにあるテキスト位置または文字列位置のプロパティは何
?”という形式の問にたいして、編集が一貫した振る舞いをするようアレンジする
のは簡単です。そこで、わたしたちはこれらが合理的な唯一の問いであると判断
したのです。わたしたちはインターバルの開始と終了の場所を問うような実装を
しませんでした。

   実際には、明白にインターバル境界であるような箇所では、通常はテキスト
プロパティ検索関数を使用できます。可能であるならインターバルは常に結合さ
れるとみなすことにより、それらがインターバル境界を探すと考えることができ
ます。*note Property Search::を参照してください。

   Emacsはプレゼンテーション機能として、明示的なインターバルも提供します
。*note Overlays::を参照してください。


File: elisp,  Node: Substitution,  Next: Registers,  Prev: Text Properties,  Up: Text

31.20 Substituting for a Character Code
=======================================

以下の関数は、文字コードにもとづいて、指定されたリージョン内の文字を置き
換えます。

 -- Function: subst-char-in-region start end old-char new-char &optional
          noundo
     この関数は、STARTとENDで定義されるカレントバッファーのリージョン内
     に出現する文字OLD-CHARをNEW-CHARに置き換える。

     NOUNDOが非‘nil’なら、‘subst-char-in-region’はundo用に変更を記録せず
     、バッファーを変更済みとマークしない。これは、古い機能である選択的
     ディスプレイ(*note Selective Display::を参照)にとって有用だった。

     ‘subst-char-in-region’はポイントを移動せず、‘nil’をリターンする。

          ---------- Buffer: foo ----------
          This is the contents of the buffer before.
          ---------- Buffer: foo ----------

          (subst-char-in-region 1 20 ?i ?X)
               ⇒ nil

          ---------- Buffer: foo ----------
          ThXs Xs the contents of the buffer before.
          ---------- Buffer: foo ----------

 -- Command: translate-region start end table
     この関数は、バッファー内の位置STARTとENDの間の文字にたいして、変換
     テーブル(translation table)を適用する。

     変換テーブルTABLEは、文字列、または文字テーブルである。‘(aref TABLE
     OCHAR)’は、OCHARに対応した変換後の文字を与える。TABLEが文字列なら、
     TABLEの長さより大きいコードの文字は、この変更により変更されない。

     ‘translate-region’のリターン値は、その変換により実際に変更された文
     字数である。変換テーブル内でその文字自身にマップされる文字は勘定に
     入らない。


File: elisp,  Node: Registers,  Next: Transposition,  Prev: Substitution,  Up: Text

31.21 Registers
===============

レジスター(register)とは、Emacs内の編集においてさまざまな異なる種類の値
を保持できる、一種の変数のことです。レジスターはそれぞれ、1文字で命名さ
れます。すべてのASCII文字、およびそれらのメタ修飾された変種(ただし
‘C-g’は例外)を、レジスターの命名に使用できます。したがって、利用可能なレ
ジスター数は255になります。Emacs Lispでは、レジスターは自身の名前である
、その文字により指定されます。

 -- Variable: register-alist
     この変数は、要素が‘(NAME .CONTENTS)’という形式のalistである。使用中
     のEmacsレジスターごとに、通常は1つの要素が存在する。

     オブジェクトNAMEは、レジスターを識別する文字(整数)である。

   レジスターのCONTENTSには、いくつかのタイプがある:

数字
     数字はそれ自身を意味する。‘insert-register’はレジスター内の数字を探
     して、その数字を10進数に変換する。

マーカー
     マーカーは、ジャンプ先のバッファー位置を表す。

文字列
     文字列の場合は、レジスター内に保存されたテキスト。

矩形(rectangle)
     矩形は、文字列のリストを表す。

‘(WINDOW-CONFIGURATION POSITION)’
     これは1つのフレームにリストアされるウィンドウ構成、およびカレントバ
     ッファー内のジャンプ先の位置を表す。

‘(FRAME-CONFIGURATION POSITION)’
     これは、リストア用のフレーム構成、およびカレントバッファー内のジャ
     ンプ先の位置である。

(file FILENAME)
     これはvisitするファイルを表し、この値にジャンプすることによりファイ
     ルFILENAMEをvisitする。

(file-query FILENAME POSITION)
     これはvisitするファイル、およびそのファイル内の位置を表す。この値に
     ジャンプすることによりファイルFILENAMEをvisitして、バッファー位置
     POSITIONに移動する。このタイプの位置をリストアすると、まずユーザー
     にたいして確認を求める。

   このセクションの関数は、特に記さない限り予期せぬ値をリターンします。

 -- Function: get-register reg
     この関数はレジスターREGのコンテンツ、コンテンツがなければ‘nil’をリ
     ターンする。

 -- Function: set-register reg value
     この関数は、レジスターREGのコンテンツにVALUEをセットする。レジスタ
     ーには任意の値をセットできるが、その他のレジスター関数は特定のデー
     タ型を期待する。リターン値はVALUE。

 -- Command: view-register reg
     このコマンドは、レジスター REGに何が含まれているかを表示する。

 -- Command: insert-register reg &optional beforep
     このコマンドは、カレントバッファーにレジスターREGのコンテンツを挿入
     する。

     このコマンドは通常、ポイントを挿入したテキストの前、後にマークを置
     く。しかしオプションの第2引きBEFOREPが非‘nil’なら、マークを前、ポイ
     ントを後に置くインタラクティブな呼び出しでは、プレフィクス引数を与
     えることにより、2つ目の引数BEFOREPに‘nil’を渡すことができる。

     レジスターに矩形が含まれる場合、その矩形はポイントの左上隅に挿入さ
     れる。これはそのテキストがカレント行と、その下に続く行に挿入される
     ことを意味する。

     レジスターが保存されたテキスト(文字列)または矩形(リスク)以外の何か
     を含む場合、現在のところは役に立つようなことは起きない。これは将来
     変更されるかもしれない。

 -- Function: register-read-with-preview prompt
     この関数は、PROMPT、およびもしかしたら既存レジスターとそのコンテン
     ツをプレビューしてレジスターの名前を読み取り、レジスター名をリター
     ンする。このプレビューは、ユーザーオプション
     ‘register-preview-delay’と‘register-alist’がいずれも非‘nil’なら、
     ‘register-preview-delay’で指定された遅延の後に、一時ウィンドウ内に
     表示される。このプレビューは、ユーザーが(たとえばヘルプ文字のタイプ
     により)ヘルプを要求した場合も表示される。レジスター名を読み取るスベ
     インタラクティブな関数は、この関数の使用を推奨する。


File: elisp,  Node: Transposition,  Next: Decompression,  Prev: Registers,  Up: Text

31.22 Transposition of Text
===========================

以下の関数は、テキストの一部を置き換えるために使用できます:

 -- Function: transpose-regions start1 end1 start2 end2 &optional
          leave-markers
     この関数は、バッファーの重複しない2つの部分を交換する。引数START1と
     END1は一方の部分の両端、引数START2とEND2はもう一方の部分の両端を指
     定する。

     通常‘transpose-regions’は、置き換えたテキストにともないマーカーを再
     配置する。以前は2つの置き換えたテキストのうちの一方の部分に位置して
     いたマーカーは、しの部分とともに移動されるので、それを挟む2つの文字
     の新たな位置の間に留まることになる。しかしLEAVE-MARKERSが非‘nil’な
     ら、‘transpose-regions’はこれを行わず、すべてのマーカーを再配置せず
     に残す。


File: elisp,  Node: Decompression,  Next: Base 64,  Prev: Transposition,  Up: Text

31.23 Dealing With Compressed Data
==================================

‘auto-compression-mode’が有効なときは、圧縮されたファイルをvisitする際、
Emacsはそれを自動的に解凍し、それを変更して保存する際は自動的に再圧縮し
ます。*note (emacs)Compressed Files::を参照してください。

   上記の機能は、外部の実行可能ファイル(例: ‘gzip’)を呼び出すことにより
機能します。zlibライブラリーを使用したビルトインの解凍サポートつきで
Emacsをコンパイルすることもでき、これは外部プログラムの実行に比べて高速
です。

 -- Function: zlib-available-p
     この関数は、ビルトインzlib解凍が利用可能なら非‘nil’をリターンする。

 -- Function: zlib-decompress-region start end
     この関数はビルトインのzlib解凍を使用して、STARTとENDの間のリージョ
     ンを解凍する。このリージョンには、gzipかzlibで圧縮されたデータが含
     まれていなければならない。成功した場合、この関数はリージョンのコン
     テンツを、解凍されたデータに置き換える。失敗すると、関数はリージョ
     ンを未変更のまま‘nil’をリターンする。この関数は、ユニバイトバッファ
     ーでのみ呼び出すことができる。


File: elisp,  Node: Base 64,  Next: Checksum/Hash,  Prev: Decompression,  Up: Text

31.24 Base 64 Encoding
======================

Base64コードは、8ビットシーケンスをより長いASCIIグラフィック文字シーケン
スにエンコードするために、email内で使用されます。これは、インターネット
RFC2045で定義されます(1)。このセクションでは、このコードへの変換および逆
変換を行う関数について説明します。

 -- Command: base64-encode-region beg end &optional no-line-break
     この関数は、BEGからENDのリージョンを、Base64コードに変換する。これ
     はエンコードされたテキストの長さをリターンする。リージョン内の文字
     がマルチバイトの場合は、エラーをシグナルする(マルチバイトバッファー
     では、リージョンには‘ascii’、‘eight-bit-control’、
     ‘eight-bit-graphic’の文字以外は含まれてはならない)。

     通常この関数は行が長くなりすぎるのを防ぐために、エンコードされたテ
     キストに改行を挿入する。しかしオプション引数NO-LINE-BREAKが非
     ‘nil’なら、これらの改行は追加されず、出力は長い単一の行となる。

 -- Function: base64-encode-string string &optional no-line-break
     この関数は、文字列STRINGをBase64コードに変換する。これはエンコード
     されたテキストを含む文字列をリターンする。‘base64-encode-region’と
     同様、文字列内の文字がマルチバイトならエラーをシグナルする。

     通常この関数は行が長くなりすぎるのを防ぐために、エンコードされたテ
     キストに改行を挿入する。しかしオプション引数NO-LINE-BREAKが非
     ‘nil’なら、これらの改行は追加されず、結果となる文字列は長い単一の行
     となる。

 -- Command: base64-decode-region beg end
     この関数は、BEGからENDのリージョンのBase64コードを、対応するデコー
     ドされたテキストに変換する。これはデコードされたテキストの長さをリ
     ターンする。

     デコード関数は、エンコード済みテキスト内の改行文字を無視する。

 -- Function: base64-decode-string string
     この関数は、モジュールSTRINGを、Base64コードから、対応するデコード
     済みテキストに変換する。これは、デコード済みテキストを含むユニバイ
     トをリターンする。

     デコード関数は、エンコード済みテキスト内の改行文字を無視する。

   ---------- Footnotes ----------

   (1) RFC(“Request for Comments”の略)とは、ナンバーが付与された、標準を
記述するインターネット情報提供ドキュメントです。RFCは通常、自身が先駆的
に活動する技術エキスパートにより記述され、伝統として現実的で、経験主導で
記述されます。


File: elisp,  Node: Checksum/Hash,  Next: Parsing HTML/XML,  Prev: Base 64,  Up: Text

31.25 Checksum/Hash
===================

Emacsには、“暗号化ハッシュ(cryptographic hashes)”計算用のビルトインのサ
ポートがあります。暗号化ハッシュ、または“チェックサム(checksum)”とは、デ
ータ断片にたいするデジタルな“指紋(fingerprint)”であり、そのデータが変更
されていないかチェックするために使用できます。

   EmacsはMD5、SHA-1、SHA-2、SHA-224、SHA-256、SHA-384、SHA-512といった
一般的な暗号化ハッシュアルゴリズムをサポートします。これらのアルゴリズム
のうちMD5はもっとも古く、ネットワーク越しに転送されたメッセージの整合性
をチェックするために、一般的には“メッセージダイジェスト(message
digests)”内で使用されています。MD5は“衝突耐性(collision resistant)”をも
たない(同じMD5ハッシュをもつ異なるデータ片を故意にデザインすることが可能
)ので、セキュリティに関連することに使用するべきではありません。同様な理
論上の欠点は、SHA-1にも存在します。したがって、セキュリティに関連するア
プリケーションにたいしては、SHA-2のような、他のハッシュタイプを使用する
べきです。

 -- Function: secure-hash algorithm object &optional start end binary
     この関数は、OBJECTにたいするハッシュをリターンする。引数ALGORITHMは
     どのハッシュを計算するかを示すシンボルで‘md5’、‘sha1’、‘sha224’、
     ‘sha256’、‘sha384’、‘sha512’のいずれかである。引数OBJECTは、バッフ
     ァーまたは文字列であること。

     オプション引数STARTとENDは、メッセージダイジェストを計算する、
     OBJECT部分を指定する文字位置である。これらが‘nil’または省略された場
     合は、OBJECT全体にたいするハッシュを計算する。

     引数BINARYが省略または‘nil’なら、通常のLisp文字列として、そのハッシ
     ュの“テキスト形式(text form)”をリターンする。BINARYが非‘nil’なら、
     ユニバイト文字列に格納されたバイトシーケンスとして、そのハッシュの
     “バイナリー形式(binary form)”をリターンする。

     この関数は、OBJECTのテキストの内部表現(*note Text
     Representations::を参照)からハッシュを直接計算しない。かわりにコー
     ディングシステム(*note Coding Systems::を参照)を使用してテキストを
     エンコードして、そのエンコード済みテキストからハッシュを計算する。
     OBJECTがバッファーなら、使用されているコーディングが、そのテキスト
     をファイルに書き込むためのデフォルトとして選択される。OBJECTが文字
     列なら、ユーザーの好むコーディングシステムが使用される(*note
     (emacs)Recognize Coding::を参照)。

 -- Function: md5 object &optional start end coding-system noerror
     この関数はMD5ハッシュをリターンする。これはほとんどの目的において、
     ALGORITHM引数に‘md5’を指定して‘secure-hash’を呼び出すのと等価であり
     、半ば時代遅れである。引数のOBJECT、START、ENDは‘secure-hash’のとき
     と同じ意味をもつ。

     CODING-SYSTEMが非‘nil’なら、それはテキストをエンコードするために使
     用する、コーディングシステムを指定する。if omitted or , the default
     coding system is used, like in ‘secure-hash’と同様にデフォルトコー
     ディングシステムが使用される。

     ‘md5’は通常、指定もしくは選択されたコーディングシステムを使用してテ
     キストをエンコードできなければ、エラーをシグナルする。しかし
     NOERRORが非‘nil’なら、かわりに黙って‘raw-text’コーディングシステム
     を使用する。


File: elisp,  Node: Parsing HTML/XML,  Next: Atomic Changes,  Prev: Checksum/Hash,  Up: Text

31.26 Parsing HTML and XML
==========================

Emacsがlibxml2サポートつきでコンパイルされたときは、HTMLやXMLのテキスト
をLispオブジェクトツリーにパースするために、以下の関数が利用可能です。

 -- Function: libxml-parse-html-region start end &optional base-url
     この関数は、STARTとENDの間のテキストをHTMLとしてパースして、HTML“パ
     ースツリー(parse tree)”を表すリストをリターンする。これは構文誤り強
     力に対処することにより、“実世界”のHTMLの処理を試みる。

     オプション引数BASE-URLが非‘nil’なら、リンク内に出現する相対URLにた
     いする、ベースURLを指定する文字列であること。

     パースツリー内では、各HTMLノードは1つ目の要素がノード名を表すシンボ
     ル2つ目の要素がノード属性のalist、残りの要素はサブノードであるよう
     なリストにより表される。

     以下の例でこれを示す。以下の(不正な)HTMLドキュメントを与えると:

          <html><head></head><body width=101><div class=thing>Foo<div>Yes

     ‘libxml-parse-html-region’呼び出しにより以下がリターンされる:

          (html ()
            (head ())
            (body ((width . "101"))
             (div ((class . "thing"))
              "Foo"
              (div ()
                "Yes"))))

 -- Function: shr-insert-document dom
     この関数は、DOM内のパース済みHTMLを、カレントバッファー内に描画する
     。引数DOMは、‘libxml-parse-html-region’で整数されるようなｌリストで
     あること。この関数はたとえば、*note EWW: (eww)Top.により使用される
     。

 -- Function: libxml-parse-xml-region start end &optional base-url
     この関数は‘libxml-parse-html-region’と同様だが、HTMLではなく(構文に
     ついてより厳格な)XMLとしてテキストをパースする点が異なる。


File: elisp,  Node: Atomic Changes,  Next: Change Hooks,  Prev: Parsing HTML/XML,  Up: Text

31.27 Atomic Change Groups
==========================

データベース用語で“アトミック(atomic: 原子的、不可分な)”変更とは、全体と
して成功もしくは失敗することはできるが、部分的にはできない、個別の変更の
ことです。Lispプログラムは単一もしくは複数のバッファーにたいする一連の変
更を“アトミック変更グループ(atomic change group)”にすることができます。
これはその一連の変更全体が、それらのバッファーに適用されるか、またはエラ
ーの場合は何も適用されないかの、いずれかであることを意味します。

   すでにカレントであるような単一のバッファーにたいしてこれを行うには、
以下のように変更を行うこーの周りに、単に‘atomic-change-group’の呼び出し
を記述します:

     (atomic-change-group
       (insert foo)
       (delete-region x y))

‘atomic-change-group’のbody内部でエラー(またはその他の非ローカルexit)が
発生した場合は、そのbody実行の間にそのバッファーでのすべての変更が行われ
なかったことになります。この類の変更グループは、他のバッファーには影響を
与えず、それらのバッファーにたいする変更はそのまま残されます。

   さまざまなバッファー内で行った変更から1つのアトミックグループを構成す
る等、より複雑な何かを必要とする場合は、‘atomic-change-group’が使用する
、より低レベルな関数を直接呼び出さなければなりません。

 -- Function: prepare-change-group &optional buffer
     この関数はBUFFER(デフォルトはカレントバッファー)にたいする変更グル
     ープをセットアップする。これは、その変更グループを表す“handle”をリ
     ターンする。変更グループをactivateしたり、その後でそれを完了するた
     めには、このhandleを使用しなければならない。

   変更グループを使用するためには、それを“activate(アクティブ化)”しなけ
ればなりません。これはBUFFERのテキストを変更する前に行わなければなりませ
ん。

 -- Function: activate-change-group handle
     これは、HANDLEが指定する変更グループをactiveにする。

   変更グループをactivateした後は、そのバッファー内で行ったすべての変更
は、その変更グループの一部となります。そのバッファー内で目論んでいたすべ
ての変更を行ったら、その変更グループを“finish(完了)”しなければなりません
。すべての変更を受け入れる(確定する)か、すべてをキャンセルするという2つ
の方法により、これを行うことができます。

 -- Function: accept-change-group handle
     この関数はHANDLEにより指定される変更グループ内のすべての変更にたい
     して、finalizeすることにより変更を受け入れる。

 -- Function: cancel-change-group handle
     この関数はHANDLEにより指定される変更グループ内のすべての変更をキャ
     ンセルしてundoする。

   グループが常に確実にfinishされるようにするために、コードでは
‘unwind-protect’を使用するべきです。‘activate-change-group’の呼び出しは
、実行直後にユーザーが‘C-g’をタイプする場合に備え、‘unwind-protect’内部
にあるべきです(これが‘prepare-change-group’と‘activate-change-group’が別
関数となっている1つの理由である。なぜなら通常は‘unwind-protect’開始前に
‘prepare-change-group’を呼び出すであろうから)。グループを一度finishした
ら、そのhandleを再度使用してはなりません。特に、同じ変更グループを2回
finishしないでください。

   複数バッファー変更グループ(multibuffer change group)を作成するために
は、カバーしたいバッファーそれぞれで‘prepare-change-group’を一度呼び出し
てから、以下のようにリターン値を結合するために、‘nconc’を使用してくださ
い:

     (nconc (prepare-change-group buffer-1)
            (prepare-change-group buffer-2))

   その後は1回の‘activate-change-group’呼び出しで複数変更グループをアク
ティブにして、1回の‘accept-change-group’または‘cancel-change-group’呼び
出しで、それをfinishしてください。

   同一バッファーにたいするネストされた複数の変更グループ使用は、あなた
が期待するであろう通り機能します。同一バッファーにたいするネストされてい
ない変更グループ使用により、Emacsが混乱した状態になるため、これが発生し
ないようにしてください。与えられた何らかのバッファーにたいして最初に開始
した変更グループは、最後にfinishする変更グループです。


File: elisp,  Node: Change Hooks,  Prev: Atomic Changes,  Up: Text

31.28 Change Hooks
==================

以下のフック変数により、すべてのバッファー(これらをバッファーローカルに
した場合は特定のバッファー)でのすべての変更にたいして、通知を受け取るよ
うにアレンジすることができます。テキストの特定部分にたいする変更の検出方
法については、*note Special Properties::も参照してください。

   これらのフック内で使用する関数は、もしそれらが正規表現を使用して何か
を行う場合は、マッチしたデータの保存とリストアを行うべきです。さもないと
、それらが呼び出す編集処理に、奇妙な方法で干渉するでしょう。

 -- Variable: before-change-functions
     この変数は、何らかのバッファー変更を行う前に呼び出すための、関数の
     リストを保持する。各関数は変更されようとするリージョンの先頭と終端
     を整数で表す、2つの引数を受け取る。変更されようとするバッファーは、
     常にカレントバッファーである。

 -- Variable: after-change-functions
     この変数は、何らかのバッファー変更を行った後に呼び出すための、関数
     のリストを保持する。各関数は正に変更されたリージョンの先頭と終端、
     およびその変更前に存在したテキストの長さである。これら3つの変数は、
     すべて整数である。変更されたバッファーは、常にカレントバッファーで
     ある。

     古いテキストの長さは、変更される前のテキストでの、そのテキストの前
     後のバッファー位置の差である。変更されたテキストでは、その長さは単
     に最初の2つの引数の差である。

   ‘*Messages*’バッファーへのメッセージ出力は、これらの関数を呼び出しま
せん。

 -- Macro: combine-after-change-calls body...
     このマクロは普通にBODYを実行するが、もしそれが安全なように見えるな
     ら、一連の複数の変更にたいして正に一度、after-change関数を呼び出す
     ようにアレンジする。

     そのバッファーの同じ領域内でプログラムが複数のテキスト変更を行う場
     合は、その部分のプログラムの周囲でマクロ
     ‘combine-after-change-calls’を使用することにより、after-changeフッ
     ク使用中の実行がかなり高速になり得る。after-changeフックが最終的に
     呼び出される際、その引数は‘combine-after-change-calls’のbody内で行
     われたすべての変更にたいして含むバッファーの範囲を指定する。

     *警告:* フォーム‘combine-after-change-calls’のbody内で、
     ‘after-change-functions’の値を変更してはならない。

     *警告:* 組み合わされた変更がバッファーの広い範囲にばらばらに発生す
     る場合でも、これは依然として機能するものの、お勧めはできない。なぜ
     ならこれは、ある変更フック関数を、非効率的な挙動へと導くかもしれな
     いからである。

 -- Variable: first-change-hook
     この変数は、以前は未変更の状態だったバッファーが変更された際は常に
     実行されるノーマルフックである。

 -- Variable: inhibit-modification-hooks
     この変数が非‘nil’なら、すべての変更フックは無効になる。それらは何も
     実行されない。これはこのセクションで説明したすべてのフック変数、同
     様に特定のスペシャルテキストプロパティ(*note Special Properties::を
     参照)とオーバーレイプロパティ(*note Overlay Properties::を参照)にア
     タッチされたフックに影響を与える。

     これらの同じフック変数実行の間、バッファー変更によるデフォルトの変
     更フックが他の変更フック実行中に実行されないように、この変数は非
     ‘nil’にバインドされるそれ自体が変更フックから実行される特定のコード
     断片内で変更フックを実行したければ、ローカルに
     ‘inhibit-modification-hooks’を‘nil’に再バインドすること。


File: elisp,  Node: Non-ASCII Characters,  Next: Searching and Matching,  Prev: Text,  Up: Top

32 Non-ASCII Characters
***********************

このチャプターは文字に関する特別な問題と、それらが文字列およびバッファー
に格納される方法についてカバーします。

* Menu:

* Text Representations::     Emacsがテキストを表す方法。
* Disabling Multibyte::      マルチバイト使用を制御する。
* Converting Representations::  ユニバイトとマルチバイトの相互変換。
* Selecting a Representation::  バイトシーケンスをユニバイトやマルチバイトとして扱う。
* Character Codes::          ユニバイトやマルチバイトが個々の文字のコードと関わる方法。
* Character Properties::     文字の挙動と処理を定義する文字属性。
* Character Sets::           利用可能な文字コード空間はさまざまな文字セットに分割される。
* Scanning Charsets::        バッファーで使用されている文字セットは?
* Translation of Characters::  変換に使用される変換テーブル。
* Coding Systems::           コーディングシステムはファイル保存のための変換である。
* Input Methods::            入力メソッドによりユーザーは特別なキーボードなしで非ASCII文字を入力できる。
* Locales::                  POSIX localeとの対話。


File: elisp,  Node: Text Representations,  Next: Disabling Multibyte,  Up: Non-ASCII Characters

32.1 Text Representations
=========================

Emacsのバッファーおよび文字列は、既知のスクリプトで記述されたほとんどす
べてのテキストをユーザーがタイプしたり表示できるよう、多種多様な言語の広
大な文字レパートリーをサポートします。

   多種多様な文字およびスクリプトをサポートするために、Emacsは“Unicode標
準(Unicode Standard)”に厳密にしたがいます。Unicode標準は、すべての文字に
たいしてそれぞれ、“コードポイント(codepoint)”と呼ばれる一意な番号を割り
当てています。コードポイントの範囲はUnicode、またはUnicode“コード空間
(codespace)”により定義され、範囲は‘0..#x10FFFF’(16進表記、範囲両端を含む
)です。Emacsはこれを、範囲‘#x110000..#x3FFFFF’のコードポイント範囲に拡張
します。この範囲はUnicodeとして統一されていない文字や、文字として解釈で
きない“8ビットrawバイト(raw 8-bit bytes)”を表すために使用します。したが
って、Emacs内の文字コードポイントは、22ビットの整数になります。

   メモリー節約のため、Emacsはバッファーおよび文字列内のテキスト文字にた
いするコードポイントである、22ビットの整数を固定長で保持しません。かわり
に、Emacsは文字の内部表現として可変長を使用します。これは、そのコードポ
イントの値に応じて、各文字を5ビットから8ビットのバイトシーケンスとして格
納するものです(1)。たとえばすべてのASCII文字は1バイト、Latin-1文字は2バ
イトといった具合です。わたしたちはこれを、テキストの“マルチバイト
(multibyte)”表現と呼んでいます。

   Emacs外部では、ISO-8859-1、GB-2312、Big-5等のような多種の異なるエンコ
ーディングで文字を表すことができます。Emacsはバッファーまたは文字列への
テキスト読み込み時、およびディスク状のファイルへのテキスト書き込みや他プ
ロセスへの引き渡し時に、これらの外部エンコーディングと、その内部表現の間
で適切な変換を行います。

   Emacsがエンコード済みテキストや非テキストデータを、バッファーや文字列
に保持、あるいは操作する必要がある場合も時折あります。たとえばEmacsがフ
ァイルをvisitする際、まずそのファイルのテキストをそのままバッファーに読
み込み、その後にのみそれを内部表現に変換します。この変換前にバッファーに
保持されてくださいのは、エンコード済みのテキストです。

   Emacsに関する限り、エンコードされたテキストは実際のテキストではなく、
8ビットrawバイトです。エンコード済みテキストを保持するバッファーおよび文
字列は、Emacsがそれらを個々のバイトシーケンスとしてアツカウことから、“ユ
ニバイト(unibyte)”のバッファーまたは文字列と呼んでいます。Emacsは通常、
ユニバイトのバッファーおよび文字列を、‘\237’のような8進コードで表示しま
す。エンコード済みテキストやバイナリー非テキストデータを処理する場合を除
き、ユニバイトバッファーとユニバイト文字列は決して使用しないよう推奨しま
す。

   バッファーにおいては、変数‘enable-multibyte-characters’のバッファーロ
ーカルな値が、使用する表現を指定します。文字列での表現は、その文字列構築
時に判断して、それを文字列内に記録します。

 -- Variable: enable-multibyte-characters
     この変数は、カレントバッファーのテキスト表現を指定する。非‘nil’なら
     バッファーはマルチバイトテキストを含み、それ以外ならエンコード済み
     ユニバイトテキスト、またはバイナリー非テキストデータが含れる。

     この変数は直接セットできない。バッファーの表現を変更するには、かわ
     りに関数‘set-buffer-multibyte’を使用すること。

 -- Function: position-bytes position
     バッファー位置は文字単位で測られる。この関数は、カレントバッファー
     内のバッファー位置を、それに対応するバイト位置でリターンする。これ
     はバッファー先頭を1として、バイト単位で増加方向に数えられる。
     POSITIONが範囲外なら、値は‘nil’になる。

 -- Function: byte-to-position byte-position
     カレントバッファー内で、与えられたBYTE-POSITIONに対応するバッファー
     位置を、文字単位でリターンする。BYTE-POSITIONが範囲外なら、値は
     ‘nil’になる。マルチバイトバッファーでは、BYTE-POSITIONの任意の値が
     文字境界上になく、1文字として表現されたマルチバイトシーケンス内にあ
     るかもしれない。この場合、関数はその文字のマルチバイトシーケンスが
     BYTE-POSITIONを含むようなバッファー位置をリターンする。他の言い方を
     すると、この値は同じ文字に属するすべてのバイト位置にたいして変化し
     ない。

 -- Function: multibyte-string-p string
     STRINGがマルチバイト文字列なら‘t’、それ以外は‘nil’をリターンする。
     この関数は、STRINGが文字列以外の場合にも、‘nil’をリターンする。

 -- Function: string-bytes string
     この関数は、STRING内のバイトの数をリターンする。STRINGがマルチバイ
     ト文字列なら、これは‘(length STRING)’より大きいかもしれない。

 -- Function: unibyte-string &rest bytes
     この関数は引数BYTESをすべて結合して、その結果をユニバイト文字列で作
     成する。

   ---------- Footnotes ----------

   (1) この内部表現は、任意のUnicodeコードポイントを表すための、
“UTF-8”と呼ばれるUnicode標準によるエンコーディングの1つにもとづきますが
、8ビットrawバイトおよびUnicodeに統一されていない文字を使用する追加のコ
ードポイントを表現するために、EmacsはUTF-8を拡張しています。


File: elisp,  Node: Disabling Multibyte,  Next: Converting Representations,  Prev: Text Representations,  Up: Non-ASCII Characters

32.2 Disabling Multibyte Characters
===================================

デフォルトでは、Emacsはマルチバイトモードで開始します。Emacsは、マルチバ
イトシーケンスを使用して非ASCII文字を表現する内部エンコーディングを使用
することにより、バッファーおよび文字列のコンテンツを格納します。マルチバ
イトモードではサポートされるすべての言語とスクリプトを使用できます。

   非常に特別な状況下においては、特定のバッファーでマルチバイト文字のサ
ポートを無効にしたいときがあるかもしれません。あるバッファーにおいてマル
チバイト文字が無効になっているときは、それを“ユニバイトモード(unibyte
mode)”と呼びます。ユニバイトモードでは、バッファー内の各文字は0から
255(8進の0377)の範囲の文字コードをもちます。0から127(8進の0177)はASCII文
字、128から255(8進の0377)は非ASCII文字を表します。

   特定のファイルをユニバイト表現で編集するためには、
‘find-file-literally’を使用してファイルをvisitします。*note Visiting
Functions::を参照してください。マルチバイトバッファーをファイルに保存し
てバッファーをkillした後に、再びそのファイルを‘find-file-literally’で
visitすることにより、マルチバイトバッファーをユニバイトに変換できます。
かわりに‘C-x <RET> c’(‘universal-coding-system-argument’)を使用して、フ
ァイルをvisitまたは保存するコーディングシステムとして‘raw-text’を指定す
ることもできます。*note Specifying a Coding System for File Text:
(emacs)Text Coding.を参照してください。‘find-file-literally’とは異なり、
‘raw-text’としてファイルをvisitしてもフォーマット変換、解凍、自動的なモ
ード選択は無効になりません。

   バッファーローカル変数‘enable-multibyte-characters’は、マルチバイトバ
ッファーなら非‘nil’、ユニバイトバッファーなら‘nil’になります。マルチバイ
トバッファーかどうかは、モードラインにも示されます。グラフィカルなディス
プレイでのマルチバイトバッファーは、文字セット話示すモードライン部分ぬ、
そのバッファーがマルチバイトであること(とそれ以外の事項)を告げるツールチ
ップがあります。ユニバイトバッファーでは、文字セットのインジケーターはあ
りません。したがって(グラフィカルなディスプレイ使用時の)ユニバイトバッフ
ァーでは、入力メソッドを使用していなければ、visitしているファイルの行末
変換(コロン、バックスラッシュ等)の標識の前には通常何も標識はありません。

   特定のバッファーでマルチバイトサポートをオフに切り替えるには、そのバ
ッファー内でコマンド‘toggle-enable-multibyte-characters’を呼び出してくだ
さい。


File: elisp,  Node: Converting Representations,  Next: Selecting a Representation,  Prev: Disabling Multibyte,  Up: Non-ASCII Characters

32.3 Converting Text Representations
====================================

Emacsはユニバイトテキストをマルチバイトに変換できます。マルチバイトテキ
ストに含まれるのがASCIIと8ビットrawバイトだけという条件つきで、マルチバ
イトテキストからユニバイトへの変換もできます。一般的にこれらの変換はバッ
ファーへのテキスト挿入時、または複数の文字列を1つの文字列に合わせてテキ
ストにputするときに発生します。文字列のコンテンツを、いずれかの表現に明
示的に変換することもできます。

   Emacsは、そのテキストの構成にもとづいて、文字列の表現を選択します。一
般的なルールでは、ユニバイトテキストが他のマルチバイトテキストと組み合わ
されている場合は、マルチバイト表現のほうがより一般的であり、ユニバイトテ
キストのすべての文字を保有できるので、ユニバイトテキストをマルチバイトテ
キストに変換します。

   バッファーへのテキスト挿入時、Emacsはそのバッファーの
‘enable-multibyte-characters’で指定されるように、テキストをそのバッファ
ーの表現に変換します。特にユニバイトバッファーへマルチバイトテキストを挿
入する際は、たとえ一般的にはマルチバイトテキスト内のすべての文字を保持す
ることはできなくても、Emacsはテキストをユニバイトに変換します。バッファ
ーコンテンツをマルチバイトに変換するという自然な代替方法は、そのバッファ
ーの表現が自動的にオーバーライドできないユーザーによる選択にもとづく表現
であるため、受け入れられません。

   ユニバイトテキストからマルチバイトテキストへの変換では、ASCII文字は未
変更のまま残され、128から255のコードをもつバイトが8ビットrawバイトのマル
チバイト表現に変換されます。

   マルチバイトテキストからユニバイトテキストへの変換では、すべての
ASCIIと8ビット文字が、それらの1バイト形式に変換されますが、各文字のコー
ドポイントの描い8ビット以外は破棄されるため、非ASCII文字の情報は失われま
す。ユニバイトテキストからマルチバイトテキストに変換して、それをユニバイ
トに戻せば、元のユニバイトテキストが再生成されます。

   以下の2つの関数は、引数STRING、またはテキストプロパティをもたない新た
に作成された文字列のいずれかをリターンします。

 -- Function: string-to-multibyte string
     この関数は、STRINGと同じ文字シーケンスを含むマルチバイト文字列をリ
     ターンする。STRINGがマルチバイト文字列なら、それが未変更のままリタ
     ーンされる。この関数は、STRINGがASCII文字と8ビットrawバイトだけを含
     むと仮定する。後者は‘#x3FFF80’から‘#x3FFFFF’(両端を含む)に対応する
     、8ビットrawバイトのマルチバイト表現に変換される(*note codepoints:
     Text Representations.を参照)。

 -- Function: string-to-unibyte string
     この関数は、STRINGと同じ文字シーケンスを含む、ユニバイト文字列をリ
     ターンする。STRINGに非ASCII文字が含まれる場合は、エラーをシグナルす
     る。STRINGがユニバイト文字列なら、それが未変更のままリターンされる
     。ASCII文字と8ビット文字だけを含むSTRING引数にたいしてのみ、この関
     数を使用すること。

 -- Function: byte-to-string byte
     この関数は、文字データBYTEの単一バイトを含むユニバイト文字列をリタ
     ーンする。BYTEが0から255までの整数でなければ、エラーをシグナルする
     。

 -- Function: multibyte-char-to-unibyte char
     これはマルチバイト文字CHARをユニバイト文字に変換して、その文字をリ
     ターンする。CHARがASCIIと8ビットのいずれでもなければ、この関数は
     −1をリターンする。

 -- Function: unibyte-char-to-multibyte char
     これはCHARがASCIIか8ビットrawバイトのいずれかであると仮定して、ユニ
     バイト文字ASCIIをマルチバイト文字に変換する。


File: elisp,  Node: Selecting a Representation,  Next: Character Codes,  Prev: Converting Representations,  Up: Non-ASCII Characters

32.4 Selecting a Representation
===============================

既存のバッファーまたは文字列がユニバイトの際にそれらをマルチバイトとして
調べたり、その逆を行うことが有用なときがあります。

 -- Function: set-buffer-multibyte multibyte
     カレントバッファーの表現タイプをセットする。MULTIBYTEが非‘nil’なら
     バッファーはマルチバイト、‘nil’ならユニバイトになる。

     この関数は、バイトシーケンスとして認識時には、バッファーを未変更の
     ままとする。結果として、文字として認識時にはコンテンツを変更できる
     。たとえば、マルチバイト表現では1文字として扱われる3バイトのシーケ
     ンスは、ユニバイト表現では3文字として数えられるだろう。例外はrawバ
     イトを表す8ビット文字である。これらはユニバイトバッファーでは1バイ
     トで表現されるが、バッファーをマルチバイトにセットした際は2バイトの
     シーケンスに変換され、その逆の変換も行われる。

     この関数は、どの表現が使用されているかを記録するために、
     ‘enable-multibyte-characters’をセットする。これは以前の同じテキスト
     をカバーするよう、バッファー内のさまざまなデータ(オーバーレイ、テキ
     ストプロパティ、マーカーを含む)を調整する。

     ナローイングはマルチバイト文字シーケンス中間で発生するかもしれない
     ので、この関数はバッファーがナローイングされている場合はエラーをシ
     グナルする。

     そのバッファーがインダイレクトバッファー(indirect buffer: 間接バッ
     ファー)の場合も、エラーをシグナルする。インダイレクトバッファーは、
     常にベースバッファー(base buffer: 基底バッファー)の表現を継承する。

 -- Function: string-as-unibyte string
     STRINGがすでにユニバイト文字列なら、この関数はSTRING自身をリターン
     する。それ以外はSTRINGと同じバイトだが、それぞれの文字を個別の文字
     としてとして扱い、新たな文字列をリターンする(値はSTRINGより多くの文
     字をもつかもしれない)。例外として、rawバイトを表す8ビット文字はそれ
     ぞれ、単一のバイトに変換される。新たに作成された文字列に、テキスト
     プロパティは含まれない。

 -- Function: string-as-multibyte string
     STRINGがすでにマルチバイト文字列なら、この関数はSTRING自身をリター
     ンする。それ以外はSTRINGと同じバイトだが、それぞれのマルチバイトシ
     ーケンスを1つの文字としてとして扱い、新たな文字列をリターンする。こ
     れは、値がSTRINGより少ない文字をもつかもしれないことを意味する。
     STRING内のバイトシーケンスが、単一文字のマルチバイト表現として無効
     なら、そのシーケンスないの各バイトは、8ビットrawバイトとして扱われ
     る。新たに作成された文字列には、テキストプロパティは含まれない


File: elisp,  Node: Character Codes,  Next: Character Properties,  Prev: Selecting a Representation,  Up: Non-ASCII Characters

32.5 Character Codes
====================

ユニバイトおよびマルチバイトのテキスト表現は、異なる文字コードを使用しま
す。ユニバイト表現にたいして有効な文字コードの範囲は0から‘#xFF’(255)で、
これは1バイトに収まる値です。マルチバイト表現にたいして有効な文字コード
の範囲は、0から‘#x3FFFFF’です。このコード空間では値0から‘#x7F’(127)が
ASCII文字用、値‘#x80’(128)から‘#x3FFF7F’(4194175)が非ASCII文字用になりま
す。

   Emacsの文字コードは、Unicode標準の上位集合(superset)です。値0から
‘#x10FFFF’(1114111)は、同じコードポイントのUnicode文字に対応します。値
‘#x110000’(1114112)から‘#x3FFF7F’(4194175)は、Unicodeに統一されていない
文字を、値‘#x3FFF80’ (4194176)から‘#x3FFFFF’(4194303)は8ビットrawバイト
を表します。

 -- Function: characterp charcode
     これはCHARCODEが有効な文字なら‘t’、それ以外は‘nil’をリターンする。

          (characterp 65)
               ⇒ t
          (characterp 4194303)
               ⇒ t
          (characterp 4194304)
               ⇒ nil

 -- Function: max-char
     この関数は、有効な文字コードポイントがもち得る最大の値をリターンす
     る。

          (characterp (max-char))
               ⇒ t
          (characterp (1+ (max-char)))
               ⇒ nil

 -- Function: get-byte &optional pos string
     この関数は、カレントバッファー内の文字位置POSにあるバイトをリターン
     する。カレントバッファーがユニバイトなら、その位置のバイトをそのま
     まリターンする。バッファーがマルチバイトの場合は、8ビットrawバイト
     は8ビットコードに変換される一方、ASCII文字のバ値は文字コードポイン
     トと同じになる。この関数は、POSにある文字が非ASCIIなら、エラーをシ
     グナルする。

     オプション引数STRINGは、カレントバッファーのかわりに、文字列からバ
     イト値を得ることを意味する。


File: elisp,  Node: Character Properties,  Next: Character Sets,  Prev: Character Codes,  Up: Non-ASCII Characters

32.6 Character Properties
=========================

“文字プロパティ(character property”とは、その文字の振る舞いと、テキスト
が処理および表示される間どのように処理されるべきかを指定する、名前つきの
文字属性です。したがって文字プロパティは、その文字の意味を指定するための
重要な一部です。

   全体として、Emacsは自身の文字プロパティ実装においてはUnicode標準にし
たがいます。特にEmacsはUnicode Character Property Model
(http://www.unicode.org/reports/tr23/)をサポートしており、Emacs文字プロ
パティデータベースはUnicode文字データベース(UCD: Unicode Character
Database)から派生したものです。Unicode文字プロパティとその意味についての
詳細な説明は、Character Properties chapter of the Unicode Standard
(http://www.unicode.org/versions/Unicode6.2.0/ch04.pdf)を参照してくださ
い。このセクションでは、あなたがすでにUnicode標準の該当する章に親しんで
いて、その知識をEmacs Lispプログラムに適用したいものと仮定します。

   Emacsでは、各プロパティは名前をもつシンボルであり、そのシンボルは利用
可能な値セットをもち、値の型はプロパティに依存します。ある文字が特定のプ
ロパティをもたなければ、その値は‘nil’になります。一般的なルールとして、
Emacsでの文字プロパティ名は、対応するUnicodeプロパティ名を小文字にして、
文字‘_’をダッシュ文字‘-’で置き換えることにより生成されます。たとえば
‘Canonical_Combining_Class’は‘canonical-combining-class’となります。しか
し簡単に使用できるように、名前を短くすることもあります。

   UCDによりいくつかのコードポイントは“未割り当て(unassigned)”のまま残さ
れており、それらに対応する文字はありません。Unicode標準は、そのようなコ
ードポイントのプロパティにたいしてデフォルト値を定義しています。それらに
ついては、以下の各プロパティごとに注記しています。

   以下は、Emacsが関知するすべての文字プロパティにたいする、値タイプの完
全なリストです:

‘name’
     Unicodeプロパティ‘Name’に対応する。値はラテン大文字のAからZ、数字、
     スペース、ハイフン‘-’の文字から構成される文字列である。未割り当ての
     コードポイントにたいする値は‘nil’。

‘general-category’
     Unicodeプロパティ‘General_Category’に対応する。値は、その文字の分類
     をアルファベット2文字に略したものを名前としてもつようなシンボルであ
     る。未割り当てのコードポイントにたいする値は‘Cn’。

‘canonical-combining-class’
     Unicodeプロパティ‘Canonical_Combining_Class’に対応する。値は整数。
     未割り当てのコードポイントにたいする値は0。

‘bidi-class’
     Unicodeプロパティ‘Bidi_Class’に対応する。値は、その文字のUnicode“方
     向タイプ(directional type)”が名前であるようなシンボル。Emacsは表示
     のために双方向テキストを並び替える際に、このプロパティを使用する
     (*note Bidirectional Display::を参照)。未割り当てのコードポイントに
     たいする値は、そのコードポイントが属するコードブロックに依存する。
     未割り当てのコードポイントのほとんどは‘L’(強い左方向)だが、‘AL’(
     Arabic letter: アラビア文字)や‘R’(強い右方向)を受け取るコースポイン
     トもいくつかある。

‘decomposition’
     Unicodeプロパティの‘Decomposition_Type’と‘Decomposition_Value’に対
     応する。値は、最初の要素が‘small’のような互換性のあるフォーマットタ
     グ(compatibility formatting tag)であるかもしれないリストである(1)。
     他の要素は、その文字の互換性のある分割シーケンス(compatibility
     decomposition sequence)を与える文字です。未割り当てのコードポイント
     にたいする値は、その文字自身。

‘decimal-digit-value’
     ‘Numeric_Type’が‘Decimal’であるような文字Unicodeプロパティ
     ‘Numeric_Value’に対応する。値は整数。未割り当てのコードポイントにた
     いする値は、NaN(“not-a-number”: 数字ではない)を意味する‘nil’。

‘digit-value’
     ‘Numeric_Type’が‘Digit’であるような文字の、Unicodeプロパティ
     ‘Numeric_Value’に対応する。値は整数。このような文字には、互換性のあ
     る添字や上付き数字が含まれ、値は対応する数字である。未割り当てのコ
     ードポイントにたいする値は、NaNを意味する‘nil’である。

‘numeric-value’
     ‘Numeric_Type’が‘Numeric’であるような文字の、Unicodeプロパティ
     ‘Numeric_Value’に対応する。このプロパティの値は数字。このプロパティ
     をもつ文字の例には分数、添字、上付き数字、ローマ数字、通貨分数(訳注
     : 原文は“currency numerators”でベンガル語の分数値用の歴史的な記号を
     指すと思われる)、丸数字が含まれる。たとえば、文字‘U+2155’(VULGAR
     FRACTION ONE FIFTH: (訳注)スラッシュで分子と分母を区切った表記によ
     る5分の1のこと)にたいするこのプロパティの値は‘0.2’。未割り当てのコ
     ードポイントにたいする値は、NaNを意味する‘nil’。

‘mirrored’
     Unicodeプロパティ‘Bidi_Mirrored’に対応する。このプロパティの値は、
     ‘Y’または‘N’いずれかのシンボル。未割り当てのコードポイントにたいす
     る値は‘N’。

‘mirroring’
     Unicodeプロパティ‘Bidi_Mirroring_Glyph’に対応する。このプロパティの
     値は、そのグリフ(glyph)がその文字のグリフの鏡像(mirror image)を表す
     ような文字、定義済みの鏡像グリフがなければ‘nil’である。‘mirrored’プ
     ロパティが‘N’であるようなすべての文字の‘mirroring’プロパティは
     ‘nil’である。しかし‘mirrored’プロパティが‘Y’の文字でも、鏡像をもつ
     適切な文字がないという理由により、‘mirroring’が‘nil’の文字もある。
     Emacsは適切な際は、鏡像を表示するためにこのプロパティを使用する
     (*note Bidirectional Display::を参照)。未割り当てのコードポイントに
     たいする値は‘nil’。

‘old-name’
     Unicodeプロパティ‘Unicode_1_Name’に対応する。値は文字列。未割り当て
     のコードポイント、およびこのプロパティにたいする値をもたない文字で
     は、値は‘nil’である。

‘iso-10646-comment’
     Unicodeプロパティ‘ISO_Comment’に対応する。値は文字列。未割り当ての
     コードポイントの値は空文字列。

‘uppercase’
     Unicodeプロパティ‘Simple_Uppercase_Mapping’に対応する。このプロパテ
     ィの値は、単一の文字。未割り当てのコードポイントの値は‘nil’で、これ
     はその文字自身を意味する。

‘lowercase’
     Unicodeプロパティ‘Simple_Lowercase_Mapping’に対応する。このプロパテ
     ィの値は、単一の文字。未割り当てのコードポイントの値は‘nil’で、これ
     はその文字自身を意味する。

‘titlecase’
     Unicodeプロパティ‘Simple_Titlecase_Mapping’に対応する。“タイトルケ
     ース(title case)”とは、単語の最初の文字を大文字にする必要がある際に
     使用される、文字の特別な形式のこと。このプロパティの値は、単一の文
     字。未割り当てのコードポイントにたいする値は‘nil’で、これはその文字
     自身を意味する。

 -- Function: get-char-code-property char propname
     この関数は、CHARのプロパティPROPNAMEの値をリターンする。

          (get-char-code-property ?\s 'general-category)
               ⇒ Zs
          (get-char-code-property ?1 'general-category)
               ⇒ Nd
          ;; subscript 4
          (get-char-code-property ?\u2084 'digit-value)
               ⇒ 4
          ;; one fifth
          (get-char-code-property ?\u2155 'numeric-value)
               ⇒ 0.2
          ;; Roman IV
          (get-char-code-property ?\u2163 'numeric-value)
               ⇒ 4

 -- Function: char-code-property-description prop value
     この関数はプロパティPROPのVALUEの説明文字列(description string)、
     VALUEが説明をもたなければ‘nil’をリターンする。

          (char-code-property-description 'general-category 'Zs)
               ⇒ "Separator, Space"
          (char-code-property-description 'general-category 'Nd)
               ⇒ "Number, Decimal Digit"
          (char-code-property-description 'numeric-value '1/5)
               ⇒ nil

 -- Function: put-char-code-property char propname value
     この関数は、文字CHARのプロパティPROPNAMEの値として、VALUEを格納する
     。

 -- Variable: unicode-category-table
     この変数の値は、それぞれの文字にたいして、そのUnicodeプロパティ
     ‘General_Category’をシンボルとして指定する、文字テーブルである
     (*note Char-Tables::を参照)。

 -- Variable: char-script-table
     この変数の値は、それぞれの文字がシンボルを指定するような文字テーブ
     ルである。シンボルの名前は、Unicodeコードスペースからスクリプト固有
     ブロックへのUnicode標準分類にしたがった、その文字が属するスクリプト
     である。この文字テーブルは余分のスロットを１つもち、値はすべてのス
     クリプトシンボルのリストである。

 -- Variable: char-width-table
     この変数の値は、、それぞれの文字がスクリーン上で占めるであろう幅を
     列単位で指定する、文字テーブルである。

 -- Variable: printable-chars
     この変数の値は、それぞれの文字にたいして、それがプリント可能かどう
     かを指定する、文字テーブルである。すなわち、‘(aref printable-chars
     char)’を評価した結果が‘t’ならプリント可で、‘nil’なら不可である。

   ---------- Footnotes ----------

   (1) Unicode仕様ではこれらのタグ名を‘<..>’カッコ内に記述しますが、
Emacsでのタグ名にはカッコは含まれません。Unicodeでの‘<small>’指定は、
Emacsでは‘small’となります。


File: elisp,  Node: Character Sets,  Next: Scanning Charsets,  Prev: Character Properties,  Up: Non-ASCII Characters

32.7 Character Sets
===================

Emacsの“文字セット(character set、もしくはcharset)”とは、それぞれの文字
が数字のコードポイントに割り当てられれた、文字セットのことです(Unicode標
準ではこれを“符号化文字集合(coded character set)”と呼ぶ)。Emacsの各文字
セットは、シンボルであるような名前をもちます。1つの文字が、任意の数の異
なる文字セットに属することができますが、各文字セット内で異なるコードポイ
ントをもつのが一般的でしょう。文字セットの例には‘ascii’、‘iso-8859-1’、
‘greek-iso8859-7’、‘windows-1255’が含まれます。文字セット内で文字に割り
当てられるコードポイントは、Emacs内のバッファーや文字列内で使用されるコ
ードポイントとは、通常異なります。

   Emacsは、特別な文字セットをいくつか定義しています。文字セット
‘unicode’は、Emacsコードポイントが‘0..#x10FFFF’の範囲の、すべての文字セ
ットを含みます。文字セット‘emacs’は、すべてのASCII、および非ASCII文字を
含みます。最後に‘eight-bit’文字セットは、8ビットrawバイトを含みます。テ
キスト内でrawバイトを見つけたときに、Emacsはこれを使用します。

 -- Function: charsetp object
     OBJECTは文字セットを命名するシンボルなら‘t’、それ以外は‘nil’をリタ
     ーンする。

 -- Variable: charset-list
     値は、すべての定義済み文字セットの名前のリストである。

 -- Function: charset-priority-list &optional highestp
     この関数は、すべての定義済み文字セットの優先順にソートされたリスト
     をリターンする。HIGHESTPが非‘nil’なら、この関数はもっとも優先度の高
     い文字セット1つをリターンする。

 -- Function: set-charset-priority &rest charsets
     この関数は、CHARSETSをもっとも高い優先度の文字セットにする。

 -- Function: char-charset character &optional restriction
     この関数は、CHARACTERが属する文字セットで、もっとも優先度の高い文字
     セットの名前をリターンする。ただしASCII文字は例外であり、この関数は
     常に‘ascii’をリターンする。

     RESTRICTIONが非‘nil’なら、それは検索する文字セットのリストであるこ
     と。かわりにコーディングシステムも指定でき、その場合はそのコーディ
     ングシステムによりサポートされている必要がある(*note Coding
     Systems::を参照)。

 -- Function: charset-plist charset
     この関数は、文字セットCHARSETのプロパティをリターンする。たとえ
     CHARSETがシンボルだったとしても、これはそのシンボルのプロパティリス
     トと同じではない。文字セットプロパティにはドキュメント文字列、短い
     名前等、その文字セットに関する重要な情報が含まれる。

 -- Function: put-charset-property charset propname value
     この関数は、CHARSETのプロパティPROPNAMEに、与えられたVALUEをセット
     する。

 -- Function: get-charset-property charset propname
     この関数は、CHARSETのプロパティPROPNAMEの値をリターンする。

 -- Command: list-charset-chars charset
     このコマンドは、文字セットCHARSET内の文字のリストを表示する。

   Emacsは文字の内部的な表現と、その文字の特定の文字セット内でのコードポ
イントを相互に変換することができます。以下は、これらをサポートするための
関数です。

 -- Function: decode-char charset code-point
     この関数は、CHARSET内でCODE-POINTに割り当てられた文字を、Emacsの対
     応する文字にデコードして、それをリターンする。そのコードポイントの
     文字がCHARSETに含まれなければ、値は‘nil’である。CODE-POINTがLisp整
     数(*note most-positive-fixnum: Integer Basics.を参照)に収まらない場
     合は、コンスセル‘(HIGH . LOW)’として指定できるかもしれない。ここで
     LOWはその値の下位来る16ビット、HIGHは上位16ビットである。

 -- Function: encode-char char charset
     この関数は、CHARSET内で文字CHARに割り当てられた、コードポイントをリ
     ターンする。結果がLisp整数に収まらない場合は、上述の‘decode-char’の
     2つ目の引数のように、コンスセル‘(HIGH . LOW)’としてリターンされる。
     CHARSETがCHARにたいするコードポイントをもたなければ、値は‘nil’であ
     る。

   以下の関数は、文字セット内の文字の一部、全くすべてにたいして、特定の
関数を適用するのに便利です。

 -- Function: map-charset-chars function charset &optional arg from-code
          to-code
     CHARSET内の文字にたいしてFUNCTIONを呼び出す。FUNCTIONは2つの引数で
     呼び出される。1つ目はコンスセル‘(FROM . TO)’で、FROMとTOは文字セッ
     ト内に含まれる文字の範囲である。ARGは、2つ目の引数としてFUNCTIONに
     渡される。

     デフォルトでは、FUNCTIONに渡されるコードポイントの範囲にはCHARSET内
     のすべての文字が含まれるが、オプション引数FROM-CODEおよびTO-CODEに
     より、それはCHARSETの2つのコードポイント間にある文字範囲に制限され
     る。FROM-CODEまたはTO-CODEのいずれかが‘nil’の場合のデフォルトは、
     CHARSETのコードポイントの最初または最後である。


File: elisp,  Node: Scanning Charsets,  Next: Translation of Characters,  Prev: Character Sets,  Up: Non-ASCII Characters

32.8 Scanning for Character Sets
================================

特定の文字が、どの文字セットに属するか調べられると便利なときがあります。
これの用途の1つは、どのコーディングシステム(*note Coding Systems::を参照
)が問題となっているテキストすべてを表現可能か判断することです。他にも、
そのテキストを表示するフォントの判断があります。

 -- Function: charset-after &optional pos
     この関数は、カレントバッファー内の位置POSにある文字を含む、 もっと
     も高い優先度の文字セットをリターンする。POSが省略または‘nil’の場合
     のデフォルトは、ポイントのカレント値である。POSが範囲外なら、値は
     ‘nil’。

 -- Function: find-charset-region beg end &optional translation
     この関数は、カレントバッファー内の位置BEGからENDの間の文字を含む、
     もっとも優先度の高い文字セットのリストをリターンする。

     オプション引数がTRANSLATIONは、テキストのスキャンに使用するための変
     換テーブルを指定する(*note Translation of Characters::を参照)。これ
     が非‘nil’なら、リージョン内の各文字はそのテーブルを通じて変換され、
     リターンされる値にはバッファーの実際の文字ではなく、変換された文字
     が記述される。

 -- Function: find-charset-string string &optional translation
     この関数は、STRING内の文字を含む、もっとも優先度の高い文字セットの
     リストをリターンする。これは‘find-charset-region’と似ているが、カレ
     ントバッファーの一部ではなくSTRINGのコンテンツに適用される点が異な
     る。


File: elisp,  Node: Translation of Characters,  Next: Coding Systems,  Prev: Scanning Charsets,  Up: Non-ASCII Characters

32.9 Translation of Characters
==============================

“変換テーブル(translation table)”とは？文字から文字へのマッピングを指定
する、文字テーブルです(*note Char-Tables::を参照)。これらのテーブルはエ
ンコーディング、デコーディング、および他の用地にも使用されます。独自に変
換テーブルを指定するコーディングシステムも、いくつかあります。他のすべて
のコーディングシステムに適用される、デフォルトの変換テーブルも存在します
。

   変換テーブルには、余分のスロットが2つあります。1つ目のスロットは
‘nil’、または逆の変換を処理する変換テーブルです。2つ目のスロットは、変換
する文字シーケンスを照合する際の、最大文字数です(以下の
‘make-translation-table-from-alist’の説明を参照)。

 -- Function: make-translation-table &rest translations
     この関数は、引数TRANSLATIONSにもとづいて、変換テーブルをリターンす
     る。TRANSLATIONSの各要素は、‘(FROM . TO)’という形式のリストであるこ
     と。これはFROMからTOへの、文字の変換を指示する。

     各引数内の引数とフォームは順に処理され、もし前のフォームですでに
     TOがたとえばTO-ALTに変換されていれば、FROMもTO-ALTに変換される。

   デコードを行う間、その変換テーブルの変換は、通常のデコーディングの結
果の文字に適用されます。あるコーディングシステムがプロパティ
‘:decode-translation-table’をもつなら、それは使用する変換テーブル、また
は順に適用するべき変換テーブルのリストを指定します(これはコーディングシ
ステムの名前であるようなシンボルのプロパティではなく、
‘coding-system-get’がリターンするような、コーディングシステムのプロパテ
ィである。*note Basic Concepts of Coding Systems: Coding System Basics.を
参照されたい)。最後に、もし‘standard-translation-table-for-decode’が非
‘nil’なら、結果となる文字はそのテーブルにより変換されます。

   エンコードを行う間は、その変換テーブルの変換はバッファー内の文字に適
用され、変換結果は実際にエンコードされます。あるコーディングシステムがプ
ロパティ‘:encode-translation-table’をもつなら、それは使用する変換テーブ
ル、または順に適用するべき変換テーブルのリストを指定します。加えて、もし
変数‘standard-translation-table-for-encode’が非‘nil’なら、それは変換結果
にたいして使用するべき変換テーブルを指定します。

 -- Variable: standard-translation-table-for-decode
     これはデコード用のデフォルトの変換テーブルである。あるコーディング
     システムが独自に変換テーブルを指定する場合、この変数の値が非‘nil’な
     ら、それら独自のテーブル適用後に、この変数の変換テーブルが適用され
     る。

 -- Variable: standard-translation-table-for-encode
     これはエンコード用のデフォルトの変換テーブルである。あるコーディン
     グシステムが独自に変換テーブルを指定する場合、この変数の値が非
     ‘nil’なら、それら独自のテーブル適用後に、この変数の変換テーブルが適
     用される。

 -- Variable: translation-table-for-input
     自己ソウニュ文字は、挿入前にこの変換テーブルを通じて変換が行われる
     。検索コマンドも、バッファー内の内容とより信頼性のある比較ができる
     ように、このテーブルを通じて入力を変換する。

     この変数は、セット時に自動的にバッファーローカルになる。

 -- Function: make-translation-table-from-vector vec
     この関数は、バイト(値は0から#xFF)から文字にマップする256要素の配列
     であるようなVECから作成した変換テーブルをリターンする。未変換のバイ
     トにたいする要素は、‘nil’かもしれない。リターンされるテーブルは、余
     分な1つ目のスロットにそのマッピングを保持する変換テーブル、2つ目の
     余分なスロットに値‘1’をもつ。

     この関数は、各バイトを特定の文字にマップするような、プライベートな
     コーディングシステムを簡単に作成する手段を提供する。
     ‘define-coding-system’のPROPS引数のプロパティ
     ‘:decode-translation-table’と‘:encode-translation-table’に、リター
     ンされるテーブルと、逆変換テーブルを指定できる。

 -- Function: make-translation-table-from-alist alist
     この関数は‘make-translation-table’と似ているが、シンプルな1体1の変
     換テーブルではなく、より複雑な変換テーブルをリターンする。ALISTの各
     要素は‘(FROM . TO)’という形式をもち、ここでFROMおよびTOは、文字また
     は文字シーケンスを指定するベクターである。FROMが文字なら、その文字
     はTO(文字または文字シーケンス)に変換される。FROMが文字のベクターな
     らそのシーケンスはTOに変換される。リターンされるテーブルは、1つ目の
     余分なスロットに逆のマッピングを行う変換テーブル、2つ目の余分なスロ
     ットには文字シーケンスFROMすべての最大長をもつ。


File: elisp,  Node: Coding Systems,  Next: Input Methods,  Prev: Translation of Characters,  Up: Non-ASCII Characters

32.10 Coding Systems
====================

Emacsがファイルにたいして読み書きを行う際、およびEmacsがサブプロセスとテ
キストの送受信を行う際、通常は特定の“コーディングシステム(coding
system)”の指定にしたがって文字コード変換および行末変換を行います。

   コーディングシステムの定義は難解な問題であり、ここには記述しません。

* Menu:

* Coding System Basics::     基本的な概念。
* Encoding and I/O::         ファイル入出力関数がコーディングシステムを扱う方法。
* Lisp and Coding Systems::  コーディングシステム名を処理する関数。
* User-Chosen Coding Systems::  ユーザーにコーディングシステムの選択を求める。
* Default Coding Systems::   デフォルトの選択の制御。
* Specifying Coding Systems::  単一ファイル処理にたいして特定のコーディングシステムを要求する。
* Explicit Encoding::        入出力を伴わないテキストのエンコードおよびデコード。
* Terminal I/O Encoding::    端末入出力にたいするエンコーディングの使用。


File: elisp,  Node: Coding System Basics,  Next: Encoding and I/O,  Up: Coding Systems

32.10.1 Basic Concepts of Coding Systems
----------------------------------------

“文字コード変換(character code conversion)”により、Emacs内部で使用される
文字の内部表現と他のエンコーディングの間で、変換が行われます。Emacsは多
くの異なるエンコーディングをサポートしており、それらは双方向に変換が可能
です。たとえばLatin 1、Latin 2、Latin 3、Latin 4、Latin 5、およびいくつ
かのISO 2022の変種等のようなエンコーディングにたいして、テキストを双方向
に変換できます。あるケースにおいては、同じ文字にたいしてEmacsは複数のエ
ンコーディング候補をサポートします。たとえばキリル(ロシア語)のアルファベ
ットにたいしてはISO、Alternativnyj、KOI8のように3つにコーディングシステ
ムが存在します。

   コーディングシステムはそれぞれ特定の文字コード変換セットを指定します
が、‘undecided’というコーディングシステムは特別です。これはそれぞれのフ
ァイルにたいして、そのファイルのデータにもとづいて発見的に選択が行われる
ように、選択を未指定のままにします。

   一般的に、コーディングシステムは可逆的な同一性を保証しません。あるコ
ーディングシステムを使用してバイトシーケンスをデコードしてから、同じコー
ディングシステムで結果テキストをエンコードしても、異なるバイトシーケンス
が生成される可能性があります。しかし、デコードされたオリジナルのバイトシ
ーケンスとなることを保証するコーディングシステムもいくつかあります。以下
にいくつかの例を挙げます:

     iso-8859-1、utf-8、big5、shift_jis、euc-jp

   バッファーテキストのエンコードと結果のデコードでも、オリジナルテキス
トの再生成に失敗する可能性があります。たとえば、その文字をサポートしない
コーディングシステムで文字をエンコードした場合の結果は予測できず、したが
って同じコーディングシステムを使用してそれをデコードしても、異なるテキス
トが生成されるでしょう。現在のところ、Emacsは未サポート文字のエンコーデ
ィングによる結果をエラーとして報告できません。

   “行末変換(end of line conversion: 改行変換)”は、ファイル内の行末を表
すために、さまざまなシステム上で使用される3つの異なる慣例を扱います。
GNUやUnixシステムで使用されるUnixの慣例では、LF文字(linefeed文字、改行と
も呼ばれる)が使用されます。MS-WindowsやMS-DOSシステムで使用されるDOSの慣
例では、行末にCR文字(carriage-return文字、復帰文字とも呼ばれる)とLF文字
が使用されますMacの慣例ではCR文字だけが使用されます(これはOS X以前の
Macintoshシステムで使用されていた慣例である)。

   ‘latin-1’のような“ベースコーディングシステム(base coding systems: 基
本コーディングシステム)”では、データにもとづいて選択されるよう、行末変換
は未指定となっています。‘latin-1-unix’、‘latin-1-dos’、‘latin-1-mac’のよ
うな“バリアントコーディングシステム(variant coding systems: 変種コーディ
ングシステム)”では、行末変換を明示的に指定します。ほとんどのベースコーデ
ィングシステムは‘-unix’、‘-dos’、‘-mac’を追加した形式の、3つの対応する変
種をもちます。

   ‘raw-text’は、文字コード変換を抑制して、このコーディングシステムで
visitされたバッファーがユニバイトバッファーとなる点において、特殊なコー
ディングシステムです。歴史的な理由により、このコーディングシステムにより
ユニバイトおよびマルチバイト両方のテキストを保存できます。マルチバイトテ
キストのエンコードに‘raw-text’を使用した際は、1文字コード変換を行います
。8ビット文字は、1バイトの外部表現に変換されます。‘raw-text’は通常のよう
にデータにより判断できるように行末変換を指定せず、通常のように行末変換を
指定する3つの変種をもちます。

   ‘no-conversion’(とエイリアスの‘binary’)は、‘raw-text-unix’と等価です
。これは文字コードおよび行末にたいする変換をいずれもしてくださいしません
。

   ‘utf-8-emacs’は、データがEmacsの内部エンコーディング(*note Text
Representations::を参照)で表されることを指定するコーディングシステムです
。コード変換が何も発生しない点で、これは‘raw-text’と似ていますが、結果が
マルチバイトデータである点が異なります。The name ‘emacs-internal’という
名前は、‘utf-8-emacs’にたいするエイリアスです。

 -- Function: coding-system-get coding-system property
     この関数は、コーディングシステムCODING-SYSTEMの、指定されたプロパテ
     ィをリターンする。コーディングシステムのプロパティのほとんどは内部
     的な目的のために存在するが、‘:mime-charset’については有用と思うかも
     しれない。このプロパティの値は、そのコーディングシステムが読み書き
     できる文字コードにたいしてMIME内で使用される名前である。以下に例を
     示す:

          (coding-system-get 'iso-latin-1 :mime-charset)
               ⇒ iso-8859-1
          (coding-system-get 'iso-2022-cn :mime-charset)
               ⇒ iso-2022-cn
          (coding-system-get 'cyrillic-koi8 :mime-charset)
               ⇒ koi8-r

     ‘:mime-charset’プロパティの値は、そのコーディングシステムにたいする
     エイリアスとしても定義されている。

 -- Function: coding-system-aliases coding-system
     この関数は、CODING-SYSTEMのエイリアスのリストをリターンする。


File: elisp,  Node: Encoding and I/O,  Next: Lisp and Coding Systems,  Prev: Coding System Basics,  Up: Coding Systems

32.10.2 Encoding and I/O
------------------------

コーディングシステムの主な目的は、ファイルの読み込みと書き込みへの使用で
す。関数‘insert-file-contents’はファイルデータのデコードにコーディングシ
ステムを使用し、‘write-region’はバッファーコンテンツのエンコードにコーデ
ィングシステムを使用します。

   使用するコーディングシステムは明示的(*note Specifying Coding
Systems::を参照)、またはデフォルトメカニズム(*note Default Coding
Systems::を参照)を使用により暗黙的に指定できます。しかしきれらの手法は、
何を行うかを完全には指定しないかもしれません。たとえば、これらはデータか
ら文字コード変換を行わない‘undefined’のようなコーディングシステムを選択
するかもしれません。このような場合、I/O処理はコーディングシステム選択に
より、その処理を完了します。後でどのコーディングシステムが選択されたか調
べたいことが、頻繁にあるでしょう。

 -- Variable: buffer-file-coding-system
     このバッファーローカル変数は、バッファーの保存、および
     ‘write-region’によるバッファー部分のファイルへの書き出しに使用され
     るコーディングシステムを記録する。書き込まれるテキストが、この変数
     で指定されたコーディングシステムを使用して安全にエンコードできない
     場合、これらの操作は関数‘select-safe-coding-system’を呼び出すことに
     より、代替となるエンコーディングを選択する(*note User-Chosen Coding
     Systems::を参照)。異なるエンコーディングの選択が、ユーザーによるコ
     ーディングシステムの指定を要するなら、‘buffer-file-coding-system’は
     新たに選択されたコーディングシステムに更新される。

     ‘buffer-file-coding-system’は、サブプロセスへのテキスト送信に_影響
     しない_。

 -- Variable: save-buffer-coding-system
     この変数は、(‘buffer-file-coding-system’をオーバーライドして)バッフ
     ァーを保存するためのコーディングシステムを指定する。これは
     ‘write-region’には使用されないことに注意。

     あるコマンドがバッファーを保存するために
     ‘buffer-file-coding-system’(または‘save-buffer-coding-system’)の使
     用を開始して、そのコーディングシステムがバッファー内の実際のテキス
     トを処理できなければ、(‘select-safe-coding-system’を呼び出すことに
     より)そのコマンドは他のコーディングシステムの選択をユーザーに求める
     。これが発生した後は、コマンドはユーザー指定のコーディングシステム
     を表すために、‘buffer-file-coding-system’の更新も行う。

 -- Variable: last-coding-system-used
     ファイルおよびサブプロセスにたいするI/O操作は、使用したコーディング
     システムの名前を、この変数にセットする。明示的にエンコードとデコー
     ドを行う関数(*note Explicit Encoding::を参照)も、この変数をセットす
     る。

     *警告:* サブプロセス出力の受信によりこの変数がセットされるため、こ
     の変数はEmacsがwaitしているとくは常に変更され得る。したがって、興味
     対象となる値を格納する関数呼び出し後は、間を空けずにその値をコピー
     するべきである。

   変数‘selection-coding-system’はウィンドウシステムにたいして、選択
(selection)をエンコードする方法を指定します。*note Window System
Selections::を参照してください。

 -- Variable: file-name-coding-system
     変数‘file-name-coding-system’は、ファイル名のエンコーディングに使用
     するコーディングシステムを指定する。Emacsは、すべてのファイル操作に
     たいして、ファイル名のエンコードにそのコーディングシステムを使用す
     る。‘file-name-coding-system’が‘nil’なら、Emacsは選択された言語環境
     (language environment)により決定された、デフォルトのコーディングシ
     ステムを使用する。デフォルト言語環境では、ファイル名に含まれるすべ
     ての非ASCII文字は、特別にエンコードされない。これらはEmacsの内部表
     現を使用して、ファイルシステム内で表される。

   *警告:* Emacsのセッション中に‘file-name-coding-system’(または言語環境
)を変更した場合、以前のコーディングシステムを使用してエンコードされた名
前をもつファイルをvisitしていると、新たなコーディングシステムでは異なる
ように扱われるので、問題が発生し得る。これらのvisitされたファイル名でこ
れらのバッファーの保存を試みると、保存により間違ったファイル名が使用され
るか、エラーとなるかもしれない。そのような問題が発生したら、そのバッファ
ーにたいして新たなファイル名を指定するために、‘C-x C-w’を使用すること。

   Windows 2000以降では、EmacsはOSに渡すファイル名にデフォルトでUnicode
APIを使用するため、‘file-name-coding-system’の値は大部分が無視される。
Lispレベルでファイル名のエンコードまたはデコードを必要とするLispアプリケ
ーションは、‘system-type’が‘windows-nt’のときは、‘utf-8’をコーディングシ
ステムに使用するべきである。UTF-8でエンコードされたファイル名から、OSと
対話するために適したエンコーディングへの変換は、Emacsにより内部的に処理
される。


File: elisp,  Node: Lisp and Coding Systems,  Next: User-Chosen Coding Systems,  Prev: Encoding and I/O,  Up: Coding Systems

32.10.3 Coding Systems in Lisp
------------------------------

以下はコーディングシステムと連携するLisp機能です:

 -- Function: coding-system-list &optional base-only
     この関数は、すべてのコーディングシステムの名前(シンボル)をリターン
     する。BASE-ONLYが非‘nil’なら、値にはベースコーディングシステムだけ
     が含まれる。それ以外ならエイリアス、およびバリアントコーディングシ
     ステムも同様に含まれる。

 -- Function: coding-system-p object
     この関数は、OBJECTがコーディングシステムの名前、または‘nil’なら、
     ‘t’をリターンする。

 -- Function: check-coding-system coding-system
     この関数は、CODING-SYSTEMの有効性をチェックする。有効なら
     CODING-SYSTEMをリターンする。CODING-SYSTEMが‘nil’なら、この関数は
     ‘nil’をリターンする。それ以外の値にたいしては、‘error-symbol’が
     ‘coding-system-error’であるようなエラーをシグナルする(*note signal:
     Signaling Errors.を参照)。

 -- Function: coding-system-eol-type coding-system
     この関数は、行末(“eol”とも言う)をCODING-SYSTEMで使用されるタイプに
     変換する。CODING-SYSTEMが特定のeol変換を指定する場合、リターン値は
     0、1、2で、それらは順に‘unix’、‘dos’、‘mac’を意味する。
     CODING-SYSTEMが明示的にeol変換を指定しなければ、リターン値は以下の
     ようにそれぞれが可能なeol変換タイプをもつようなコーディングシステム
     のベクターである:

          (coding-system-eol-type 'latin-1)
               ⇒ [latin-1-unix latin-1-dos latin-1-mac]

     この関数がベクターをリターンしたら、Emacsはテキストのエンコードやデ
     コードプロセスの一部として、使用するeol変換を決定するだろう。デコー
     ドでは、テキストの行末フォーマットは自動検知され、eol変換はそれに適
     合するようセットされる(DOSスタイルのCRLFフォーマットは暗黙でeol変換
     に‘dos’をセットする)。エンコードにたいしては、適切なデフォルトコー
     ディングシステム(‘buffer-file-coding-system’にたいする
     ‘buffer-file-coding-system’のデフォルト値)、または配下にあるプラッ
     トフォームにたいして適切なデフォルトeol変換が採用される。

 -- Function: coding-system-change-eol-conversion coding-system eol-type
     この関数は、CODING-SYSTEMと類似するが、‘eol-type’で指定されたeol変
     換の異なるコーディングシステムをリターンする。EOL-TYPEは‘unix’、
     ‘dos’、‘mac’、または‘nil’であること。これが‘nil’なら、リターンされ
     るコーディングシステムは、データのeol変換により決定される。

     EOL-TYPEは‘unix’、‘dos’、‘mac’を意味する0、1、2でもよい。

 -- Function: coding-system-change-text-conversion eol-coding
          text-coding
     この関数は、EOL-CODINGの行末変換と、TEXT-CODINGのテキスト変換を使用
     するコーディングシステムをリターンする。TEXT-CODINGが‘nil’なら、こ
     れは‘undecided’、またはEOL-CODINGに対応するバリアントの1つをリター
     ンする。

 -- Function: find-coding-systems-region from to
     この関数は、FROMとTOの間のテキストのエンコードに使用可能な、コーデ
     ィングシステムのリストをリターンする。このリスト内のすべてのリスト
     は、そのテキスト範囲内にあるすべてのマルチバイト文字を、安全にエン
     コードできる。

     そのテキストがマルチバイト文字を含まれなければ、この関数はリスト
     ‘(undecided)’をリターンする。

 -- Function: find-coding-systems-string string
     この関数は、STRINGのテキストのエンコードに使用可能な、コーディング
     システムのリストをリターンする。このリスト内のすべてのリストは、
     STRINGにあるすべてのマルチバイト文字を、安全にエンコードできる。そ
     のテキストがマルチバイト文字を含まれなければ、この関数はリスト
     ‘(undecided)’をリターンする。

 -- Function: find-coding-systems-for-charsets charsets
     この関数は、リストCHARSETS内のすべての文字セットのエンコードに使用
     可能な、コーディングシステムのリストをリターンする。

 -- Function: check-coding-systems-region start end coding-system-list
     この関数は、リスト‘coding-system-list’内のコーディングシステムが、
     STARTとENDの間のリージョン内にあるすべての文字をエンコード可能かど
     うかをチェックする。このリスト内のすべてのコーディングシステムが指
     定されたテキストをエンコード可能なら、この関数は‘nil’をリターンする
     。ある文字をエンコードできないコーディングシステムがある場合は、各
     要素が‘(CODING-SYSTEM1 POS1 POS2 ...)’という形式のalistが値となる。
     これはCODING-SYSTEM1が、バッファーの位置POS1、POS2、...にある文字を
     エンコードできないことを意味する。

     STARTは文字列かもしれず、その場合ENDは無視され、リターン値はバッフ
     ァー位置のかわりに文字列のインデックスを参照することになる。

 -- Function: detect-coding-region start end &optional highest
     この関数は、STARTからENDのテキストのデコードに適したコーディングシ
     ステムを選択する。このテキストはバイトシーケンス、すなわちユニバイ
     トテキスト、ASCIIのみのマルチバイトテキスト、8ビット文字のシーケン
     スであること(*note Explicit Encoding::を参照)。

     この関数は通常はスキャンしたテキストのデコーディングを処理可能な、
     コーディングシステムのリストをリターンする。これらのコーディングシ
     ステムは優先度降順でリストされる。しかしHIGHESTが非‘nil’なら、リタ
     ーン値はもっとも高い優先度のコーディングシステムただ1つとなる。

     リージョンにISO-2022の‘ESC’のようなISO-2022制御文字を除いてASCII文
     字だけが含まれる場合、値は‘undecided’、‘(undecided)’、またはテキス
     トから推論可能ならeol変換を指定するバリアントとなる。

     リージョンにnullバイトが含まれる場合は、あるコーディングシステムに
     よりエンコードされたテキストがリージョン内に含まれる場合でも、値は
     ‘no-conversion’となる。

 -- Function: detect-coding-string string &optional highest
     この関数は‘detect-coding-region’と似ているが、バッファー内のバイト
     のかわりにSTRINGのコンテンツを処理する点が異なる。

 -- Variable: inhibit-null-byte-detection
     この変数が非‘nil’値をもつなら、リージョンや文字列のエンコーディング
     検出時に、nullバイトを無視する。これによりIndexノードをもつInfoファ
     イルのように、nullバイトを含むテキストのエンコーディングを正しく検
     出できる。

 -- Variable: inhibit-iso-escape-detection
     この変数が非‘nil’値をもつなら、リージョンや文字列のエンコーディング
     検出時に、ISO-2022エスケープシーケンスを無視する。その結果、これま
     でいくつかのISO-2022エンコーディングにおいてエンコード済みと検出さ
     れていたテキストがなくなり、バッファー内ですべてのエスケープシーケ
     ンスが可視になる。*警告:* この変数の使用には特に注意を払うこと。な
     ぜならEmacsディストリビューション内で多くのファイルがISO-2022エンコ
     ーディングを使用するからである。

 -- Function: coding-system-charset-list coding-system
     この関数は、CODING-SYSTEMがサポートする文字セット(*note Character
     Sets::を参照)のリストをリターンする。リストすべき文字セットを非常に
     多くサポートするいくつかのコーディングシステムでは、特別な値がリス
     トされる:
        • CODING-SYSTEMがすべてのEmacs文字をサポートするなら、値は
          ‘(emacs)’。
        • CODING-SYSTEMがすべてのUnicode文字をサポートするなら、値は
          ‘(unicode)’。
        • CODING-SYSTEMがすべてのISO-2022文字をサポートするなら、値は
          ‘iso-2022’。
        • CODING-SYSTEMがEmacsバージョン21(Unicodeサポートの内部的な実装
          以前)で使用される内部的コーディングシステム内のすべての文字を
          サポートするなら、値は‘emacs-mule’。

   サブプロセスへの入出力に使用されるコーディングシステムのチェックやセ
ットの方法については、*note Process Information: Coding systems for a
subprocess.、特に関数‘process-coding-system’および
‘set-process-coding-system’の説明を参照してください。


File: elisp,  Node: User-Chosen Coding Systems,  Next: Default Coding Systems,  Prev: Lisp and Coding Systems,  Up: Coding Systems

32.10.4 User-Chosen Coding Systems
----------------------------------

 -- Function: select-safe-coding-system from to &optional
          default-coding-system accept-default-p file
     この関数は、指定されたテキストをエンコードするために、必要ならユー
     ザーに選択を求めて、コーディングシステムを選択する。指定されるテキ
     ストは、通常はカレントバッファーのFROMとTOの間のテキストである。
     FROMが文字列なら、その文字列はエンコードするテキストを指定し、TOは
     無視される。

     指定されたテキストにrawバイト(*note Text Representations::を参照)が
     含まれる場合、‘select-safe-coding-system’はそのエンコーディングに
     ‘raw-text’を提案する。

     DEFAULT-CODING-SYSTEMが非‘nil’なら、それは試行すべき最初のコーディ
     ングシステムである。それがテキストを処理できるなら、
     ‘select-safe-coding-system’はそのコーディングシステムをリターンする
     。これはコーディングシステムのリストの可能性もある。その場合、この
     関数はそれらを1つずつ試みる。それらをすべて試した後に、
     (‘undecided’以外なら)カレントバッファーの
     ‘buffer-file-coding-system’の値、次に‘buffer-file-coding-system’の
     デフォルト値、最後にユーザーがもっとも好むコーディングシステム(コマ
     ンド‘prefer-coding-system’でセットできる最優先されるコーディングシ
     ステム)を試みる(*note Recognizing Coding Systems: (emacs)Recognize
     Coding.を参照)。

     これらのうちいずれかのコーディングシステムが指定されたテキストすべ
     てを安全にエンコード可能なら、‘select-safe-coding-system’はそれを選
     択およびリターンする。それ以外なら、コーディングシステムのリストか
     らすべてのテキストをエンコードできるコーディングシステムの選択をユ
     ーザーに求めて、ユーザーの選択をリターンする。

     DEFAULT-CODING-SYSTEMは、最初の要素がtで、他の要素がコーディングシ
     ステムであるようなリストかもしれない。その場合、もしリスト内にテキ
     ストを処理できるコーディングシステムがなければ、
     ‘select-safe-coding-system’は上述した3つの代替えいずれを試みること
     なく、即座にユーザーに問い合わせる。

     オプション引数ACCEPT-DEFAULT-Pが非‘nil’なら、それはユーザーとの対話
     なしで選択されたコーディングシステムが許容できるかどうかを判断する
     関数であること。‘select-safe-coding-system’は、選択されたコーディン
     グシステムのベースコーディングシステムを唯一の引数として、この関数
     を呼び出す。ACCEPT-DEFAULT-Pが‘nil’うちリターンしたら、
     ‘select-safe-coding-system’は黙って選択されたコーディングシステムを
     拒絶して、可能な候補リストからコーディングシステムの選択をユーザー
     に求める。

     変数‘select-safe-coding-system-accept-defaultf-p’が非‘nil’なら、そ
     れは1つの引数をとる関数であること。これはACCEPT-DEFAULT-P引数に与え
     られた値をオーバーライドすることにより、ACCEPT-DEFAULT-Pのかわりに
     使用される。

     最後のステップとして、選択されたコーディングシステムをリターンする
     前に、‘select-safe-coding-system’は、もしリージョンのコンテンツがフ
     ァイルから読み込まれたものだったとしたなら選択されたであろうコーデ
     ィングシステムと、そのコーディングシステムが一致するかどうかをチェ
     ックする(異なるなら、その後の再visitと編集でファイル内のデータ汚染
     が起こり得る)。通常、‘select-safe-coding-system’はこの目的のための
     ファイルとして‘buffer-file-name’を使用するが、FILEが非‘nil’なら、か
     わりにそのファイルをかわりに使用する(これは‘write-region’、および類
     似の関数に関連し得る)。明らかな不一致が検出された場合、
     ‘select-safe-coding-system’はそのコーディングシステムを選択する前に
     、ユーザーに問い合わせる。

   以下の2つの関数は、補完つきでユーザーにコーディングシステムの選択を求
めるために使用できます。*note Completion::を参照してください。

 -- Function: read-coding-system prompt &optional default
     この関数は、文字列PROMPTをプロンプトにミニバッファーを使用してコー
     ディングシステムを読み取り、そのコーディングシステムの名前をシンボ
     ルとしてリターンする。DEFAULTは、ユーザーの入力が空の場合にリターン
     するべきコーディングシステムを指定する。これはシンボルまたは文字列
     であること。

 -- Function: read-non-nil-coding-system prompt
     この関数は、文字列PROMPTをプロンプトにミニバッファーを使用してコー
     ディングシステムを読み取り、そのコーディングシステムの名前をシンボ
     ルとしてリターンする。ユーザーが空の入力を試みると、再度ユーザーに
     問い合わせを行う。*note Coding Systems::を参照のこと。


File: elisp,  Node: Default Coding Systems,  Next: Specifying Coding Systems,  Prev: User-Chosen Coding Systems,  Up: Coding Systems

32.10.5 Default Coding Systems
------------------------------

このセクションでは、特定のファイルや特定のサブプロセス実行時のデフォルト
コーディングシステムを指定する変数、およびそれらへアクセスするための
I/O処理が使用する関数について説明します。

   これらの変数は、希望するデフォルトにそれらすべてを一度セットして、そ
の後は再びそれを変更しないというアイデアにもとづいています。Lispプログラ
ム内の特定の処理で特定のコーディングシステムを指定するために、これらの変
数を変更しないでください。かわりに‘coding-system-for-read’および
‘coding-system-for-write’を使用して、それらをオーバーライドしてください
(*note Specifying Coding Systems::を参照)。

 -- User Option: auto-coding-regexp-alist
     この変数は、テキストパターンと対応するコーディングシステムのalistで
     ある。要素はそれぞれ‘(REGEXP . CODING-SYSTEM)’という形式をもつ。冒
     頭の数キロバイトがREGEXPにマッチするファイルは、そのコンテンツをバ
     ッファーに読み込む際は、CODING-SYSTEMによりデコードされる。この
     alist内のセッティングは、ファイル内の‘coding:’タグ、および
     ‘file-coding-system-alist’(以下参照)の内容より優先される。Emacsが自
     動的にBabylフォーマットのメールファイルを認識して、コード変換なしで
     それらを読み取るよう、デフォルト値がセットされている。

 -- User Option: file-coding-system-alist
     この変数は、特定のファイルの読み書きに使用するコーディングシステム
     を指定するalistである。要素はそれぞれ‘(PATTERN . CODING)’という形式
     をもち、PATTERNは特定のファイル名にマッチする正規表現である。この要
     素はPATTERNにマッチするファイル名に適用される。

     要素のCDRとなるCODINGはコーディングシステム、2つのコーディングシス
     テムを含むコンスセル、または関数名(関数定義をもつシンボル)であるこ
     と。CODINGがコーディングシステムなら、そのコーディングシステムはフ
     ァイルの読み込みと書き込みの両方で使用される。CODINGが2つのコーディ
     ングシステムを含むコンスセルなら、CARはデコード用のコーディングシス
     テム、CDRはエンコード用のコーディングシステムを指定する。

     CODINGが関数名なら、それは‘find-operation-coding-system’に渡された
     すべての引数からなるリストを唯一の引数とする関数であること。これは
     コーディングシステム、または2つのコーディングシステムを含むコンスセ
     ルをリターンしなければならない。この値は上記と同じ意味をもつ。

     CODING(または上記関数のリターン値)が‘undecided’なら、通常のコード検
     出が行われる。

 -- User Option: auto-coding-alist
     この変数は、特定のファイルの読み書きに使用するコーディングシステム
     を指定するalistである。この変数の形式は‘file-coding-system-alist’の
     形式と似ているが、後者と異なるのは、この変数がファイル内の
     ‘coding:’タグより優先されることである。

 -- Variable: process-coding-system-alist
     この変数は、何のプログラムがサブプロセス内で実行中かによって、その
     サブプロセスにたいしてどのコーディングシステムを使用するかを指定す
     るalistである。これは‘file-coding-system-alist’と同じように機能する
     が、PATTERNがそのサブプロセスを開始するために使用されたプログラム名
     にたいしてマッチされる点が異なる。コーディングシステム、または
     alist内で指定されたコーディングシステムは、そのサブプロセスへの
     I/Oに使用されるコーディングシステムの初期化に使用されるが、
     ‘set-process-coding-system’を使用して後から他のコーディングシステム
     を指定できる。

   *警告:* データからコーディングシステムを判断する‘undecided’のようなコ
ーディングシステムは、非同期のサブプロセスでは完全な信頼性をもって機能は
しない。これはEmacsが非同期サブプロセスの出力を、到着によりバッチ処理す
るためである。そのコーディングシステムが文字コード変換、または行末変換を
未指定にしておくと、Emacsは一度に1バッチから正しい変換の検出を試みなけれ
ばならず、これは常に機能するとは限らない。

   したがって非同期サブプロセスでは、可能なら文字コード変換と行末変換の
両方を判断するコーディングシステム、つまり‘undecided’や‘latin-1’ではなく
‘latin-1-unix’のようなコーディングシステムを使用すること。

 -- Variable: network-coding-system-alist
     この変数は、ネットワークストリームに使用するコーディングシステムを
     指定するalistである。これは‘file-coding-system-alist’と同じように機
     能するが、要素内のPATTERNがポート番号、または正規表現かもしれない点
     が異なる。正規表現なら、そのネットワークストリームのオープンに使用
     されたネットワークサービス名にたいしてマッチされる。

 -- Variable: default-process-coding-system
     この変数は、他に何を行うか指定されていない際に、サブプロセス(とネッ
     トワークストリーム)への入出力に使用するコーディングシステムを指定す
     る。

     値は、‘(INPUT-CODING . OUTPUT-CODING)’という形式のコンスセルである
     こと。ここでINPUT-CODINGはサブプロセスからの入力、OUTPUT-CODINGはサ
     ブプロセスへの出力に適用される。

 -- User Option: auto-coding-functions
     この変数は、ファイルのデコードされていないコンテンツにもとづいて、
     ファイルにたいするコーディングシステムの判断を試みる関数のリストを
     保持する。

     このリスト内の各関数は、カレントバッファー内のテキストを調べるよう
     に、ただしいいかなる方法にせよそれを変更しないよう記述されるべきで
     ある。そのバッファーは、ファイルの一部であるデコードされていないテ
     キストを含むだろう。各関数はポイントを始点に何文字を調べる可を告げ
     る、唯一の引数SIZEをとること。関数が、そのファイルにたいするコーデ
     ィングシステムの決定に成功したら、そのコーディングシステムをリター
     ンすること。それ以外は‘nil’をリターンするべきである。

     ファイルに‘coding:’タグがある場合は、それが優先されるので、これらの
     関数が呼び出されることはないだろう。

 -- Function: find-auto-coding filename size
     この関数は、FILENAMEに適するコーディングシステムの判定を試みる。こ
     れは、上記で説明した変数により指定されたルールのいずれかにマッチす
     るまで、それらの変数を順に使用して、ファイルをvisitするバッファーを
     調べる。そして‘(CODING . SOURCE)’という形式のコンスセルをリターンす
     る。ここでCODINGは使用するコーディングシステム、SOURCEはは
     ‘auto-coding-alist’、‘auto-coding-regexp-alist’、‘:coding’、
     ‘auto-coding-functions’のいずれかであるようなシンボルで、マッチング
     ルールとして供されるルールを示す。値‘:coding’は、ファイル内の
     ‘coding:’タグによりコーディングシステムが指定されたことを意味する
     (*note coding tag: (emacs)Specify Coding.を参照)。マッチングルール
     を調べる順序は‘auto-coding-alist’、‘auto-coding-regexp-alist’、
     ‘coding:’、‘auto-coding-functions’の順である。マッチングルールが見
     つからなければ、この関数は‘nil’をリターンする。

     2つ目の引数SIZEは、ポイントの後のテキストの文字単位のサイズである。
     この関数は、ポイントの後のSIZE文字のテキストだけを調べる。
     ‘coding:’タグが置かれる箇所としてはファイルの先頭2行が考えられる箇
     所の1つなので、通常はバッファーの先頭位置で、この関数を呼び出すべき
     である。その場合、SIZEはそのバッファーのサイズであること。

 -- Function: set-auto-coding filename size
     この関数は、ファイルFILENAMEに適するコーディングシステムをリターン
     する。これはコーディングシステムを探すために、‘find-auto-coding’を
     使用する。コーディングシステムを決定できなかったら、この関数は
     ‘nil’をリターンする。引数SIZEの意味は、‘find-auto-coding’と同様。

 -- Function: find-operation-coding-system operation &rest arguments
     この関数は、OPERATIONをARGUMENTSで行う際に、(デフォルトで)使用する
     コーディングシステムをリターンする。値は以下の形式である:

          (DECODING-SYSTEM . ENCODING-SYSTEM)

     1つ目の要素DECODING-SYSTEMはデコード(OPERATIONがデコードを行う場合
     )、ENCODING-SYSTEMはエンコード(OPERATIONがエンコードを行う場合)に使
     用するコーディングシステムである。

     引数OPERATIONはシンボルで‘write-region’、‘start-process’、
     ‘call-process’、‘call-process-region’、‘insert-file-contents’、
     ‘open-network-stream’のいずれかであること。これらは文字コード変換と
     行末変換を行うことができる、EmacsのI/Oプリミティブの名前である。

     残りの引数は、対応するI/Oプリミティブに与えられる引数と同じであるこ
     と。そのプリミティブに応じて、これらの引数のうち1つが“ターゲット”と
     して選択される。たとえばOPERATIONがファイルI/Oなら、ファイル名を指
     定する引数がターゲットである。サブプロセス用のプリミティブでは、プ
     ロセス名がターゲットになる。‘open-network-stream’では、サービス名ま
     たはポート番号がターゲットである。

     OPERATIONに応じて、この関数は‘file-coding-system-alist’、
     ‘process-coding-system-alist’、‘network-coding-system-alist’の中か
     らターゲットを探す。このalist内でターゲットが見つかったら、
     ‘find-operation-coding-system’はalist内のassociation(連想: キーと連
     想値からなるコンスセル)をリターンし、それ以外は‘nil’をリターンする
     。

     OPERATIONが‘insert-file-contents’なら、ターゲットに対応する引数は、
     ‘(FILENAME . BUFFER)’という形式のコンスセルだろう。この場合、
     FILENAMEは‘file-coding-system-alist’内で照合されるファイル名であり
     、BUFFERはそのファイルの(デコードされていない)コンテンツを含むバッ
     ファーである。‘file-coding-system-alist’がこのファイルにたいして呼
     び出す関数を指定していて、かつ(通常行われるように)ファイルのコンテ
     ンツを調べる必要があるなら、ファイルを読み込むかわりにBUFFERのコン
     テンツを調べるべきである。


File: elisp,  Node: Specifying Coding Systems,  Next: Explicit Encoding,  Prev: Default Coding Systems,  Up: Coding Systems

32.10.6 Specifying a Coding System for One Operation
----------------------------------------------------

変数‘coding-system-for-read’および/または‘coding-system-for-write’をバイ
ンドすることにより、特定の操作にたいしてコーディングシステムを指定できま
す。

 -- Variable: coding-system-for-read
     この変数が非‘nil’なら、それはファイルの読み込み、または同期サブプロ
     セスプロセスからの入力にたいして使用する、コーディングシステムを指
     定する。

     これは非同期サブプロセスやネットワークストリームにも適用されるが、
     その方法は異なる。サブプロセス開始時、またはネットワークストリーム
     オープン時の‘coding-system-for-read’の値は、サブプロセスまたはネッ
     トワークストリームにたいして入力のデコードメソッドを指定する。その
     サブプロセスまたはネットワークストリームにたいして、それがオーバー
     ライドされるまで、それが使用され続ける。

     特定のI/O操作にたいして‘let’でバインドするのが、この変数の正しい使
     い方である。この変数のグローバル値は常に‘nil’であり、他の値にグロー
     バルにセットするべきではない。以下は、この変数の正しい使用例である:

          ;; 文字コード変換なしでファイルを読み込む
          (let ((coding-system-for-read 'no-conversion))
            (insert-file-contents filename))

     この変数の値が非‘nil’のときは‘file-coding-system-alist’、
     ‘process-coding-system-alist’、‘network-coding-system-alist’を含む
     、入力にたいして使用するコーディングシステムを指定するすべてのメソ
     ッドより、この変数が優先される。

 -- Variable: coding-system-for-write
     これは‘coding-system-for-read’と同じように機能するが、入力ではなく
     出力に適用される点が異なる。これはファイルへの書き込み、同様にサブ
     プロセスおよびネットワークストリームへの出力の送信にも適用される。

     単一の操作が‘call-process-region’や‘start-process’のように、入力と
     出力の両方を行う際は、‘coding-system-for-read’と
     ‘coding-system-for-write’の両方がそれに影響する。

 -- User Option: inhibit-eol-conversion
     この変数が非‘nil’なら、どのコーディングシステムが指定されたかに関わ
     らず、行末変換は何も行われない。これはEmacsすべてのI/Oおよびサブプ
     ロセスにたいするプリミティブ、および明示的なエンコード関数(*note
     Explicit Encoding::を参照)とデコード関数に適用される。

   ある操作にたいして、固定された1つのコーディングシステムではなく、複数
のコーディングシステムを選択する必要があることが、ときおりあります。
Emacsでは、使用するコーディングシステムにたいして優先順位を指定できます
。これは、‘find-coding-systems-region’(*note Lisp and Coding Systems::を
参照)のような関数によりリターンされるコーディングシステムのリストのソー
ト順に影響します。

 -- Function: coding-system-priority-list &optional highestp
     この関数は、コーディングシステムのカレント優先順に、コーディングシ
     ステムのリストをリターンする。オプション引数HIGHESTPが非‘nil’なら、
     それはもっとも高い優先度のコーディングシステムだけをリターンするこ
     とを意味する。

 -- Function: set-coding-system-priority &rest coding-systems
     この関数は、コーディングシステムの優先リストの先頭に
     CODING-SYSTEMSを置き、それらを他のコーディングシステムすべてより高
     い優先度とする。

 -- Macro: with-coding-priority coding-systems &rest body...
     このマクロは、CODING-SYSTEMSをコーディングシステム優先リスト先頭に
     置いて、‘progn’(*note progn: Sequencing.を参照)が行うように、BODYを
     実行する。CODING-SYSTEMSは、BODY実行中に選択するコーディングシステ
     ムのリストであること。


File: elisp,  Node: Explicit Encoding,  Next: Terminal I/O Encoding,  Prev: Specifying Coding Systems,  Up: Coding Systems

32.10.7 Explicit Encoding and Decoding
--------------------------------------

Emacs内外へテキストを転送するすべての操作は、そのテキストをエンコードま
たはデコードする能力をもっています。このセクション内の関数を使用して、テ
キストを明示的にエンコードあるいはデコードすることもできます。

   エンコード結果およびデコーディングへの入力は、通常のテキストではあり
ません。これらは理論的には一連のバイト値から構成され、すなわち一連の
ASCII文字と8ビット文字から構成されます。ユニバイトのバッファーおよび文字
列では、これらの文字は0から#xFF(255)の範囲のコードをもちます。マルチバイ
トのバッファーおよび文字列では、8ビット文字は#xFFより大きい文字コードを
もちますが(*note Text Representations::を参照)、そのようなテキストのエン
コードやデコード時、Emacsは透過的にそれらを単一バイト値に変換します。

   コンテンツを明示的にデコードできるように、バイトシーケンスとしてバッ
ファーにファイルを読み込むには、‘insert-file-contents-literally’(*note
Reading from Files::を参照)を使用するのが通常の方法です。あるいは
‘find-file-noselect’でファイルをvisitする際、引数RAWFILEに非‘nil’を指定
することもできます。これらのメソッドの結果は、ユニバイトバッファーになり
ます。

   テキストを明示的にエンコードした結果であるバイトシーケンスは、たとえ
ばそれを‘write-region’(*note Writing to Files::)で書き込み、
‘coding-system-for-write’を‘no-conversion’にバインドすることによりエンコ
ードを抑制する等、それをファイルまたはプロセスへコピーするのが、通常の使
い方です。

   以下は、エンコードまたはデコードを明示的に行う関数です。エンコード関
数とはバイトシーケンスを生成し、デコード関数とはバイトシーケンスを操作す
る関数のことを意味します。これらの関数はすべて、テキストプロパティを破棄
します。これらは、自身が使用したコーディングシステムを、正確に
‘last-coding-system-used’することも行います。

 -- Command: encode-coding-region start end coding-system &optional
          destination
     このコマンドは、STARTからENDのテキストを、コーディングシステム
     CODING-SYSTEMでエンコードする。通常、バッファー内の元テキストはエン
     コードされたテキストで置き換えられるが、オプション引数DESTINATIONで
     それを変更できる。DESTINATIONがバッファーなら、エンコードされたテキ
     ストはそのバッファーのポイントの後に挿入される(ポイントは移動しない
     )。‘t’なら、このコマンドはエンコードされたテキストを挿入せずに、ユ
     ニバイトとしてリターンする。

     エンコードされたテキストが何らかのバッファーに挿入された場合、この
     コマンドはエンコードされたテキストの長さをリターンする。

     エンコードされた結果は理論的にはバイトシーケンスだが、バッファーが
     以前マルチバイトだったならマルチバイトのまま留まり、すべての8ビット
     のバイトはマルチバイト表現に変換される(*note Text
     Representations::を参照)。

     期待しない結果となる恐れがあるので、テキストのエンコードする際は、
     CODING-SYSTEMに‘undecided’を_使用してはならない_。CODING-SYSTEMにた
     いして自明な適値が存在しなければ、適切なエンコードを提案させるため
     に、かわりに‘select-safe-coding-system’を使用すること(*note
     select-safe-coding-system: User-Chosen Coding Systems.を参照)。

 -- Function: encode-coding-string string coding-system &optional nocopy
          buffer
     この関数は、コーディングシステムCODING-SYSTEMで、STRING内のテキスト
     をエンコードする。これはエンコードされたテキストを含む新たな文字列
     をリターンするが、NOCOPYが非‘nil’の場合、些細なエンコード処理なら、
     この関数はSTRING自身をリターンする。エンコード結果はユニバイト文字
     列である。

 -- Command: decode-coding-region start end coding-system &optional
          destination
     このコマンドは、コーディングシステムCODING-SYSTEMで、STARTからENDの
     テキストをデコードする。明示的なデコードを使いやすくするために、デ
     コード前のテキストはバイトシーケンス値であるべきだが、マルチバイト
     とユニバイトのバッファーいずれでも許すようになっている(マルチバイト
     バッファーの場合rawバイト値は8ビット文字で表現されていること)。通常
     、デコードされたテキストでバッファー内の元のテキストは置き換えられ
     るが、オプション引数DESTINATIONはそれを変更する。DESTINATIONがバッ
     ファーなら、デコードされたテキストは、そのバッファーのポイントの後
     に挿入される(ポイントは移動しない)。これが‘t’なら、このコマンドはデ
     コードされたテキストを挿入せずに、それをマルチバイト文字列としてリ
     ターンする。

     デコードされたテキストが何らかのバッファーに挿入された場合、このコ
     マンドはデコードされたテキストの長さをリターンする。

     このコマンドは、デコードされたテキストに、テキストプロパティ
     ‘charset’をputする。このプロパティの値は、元ののテキストのデコード
     に使用された文字セットを示す。

 -- Function: decode-coding-string string coding-system &optional nocopy
          buffer
     この関数は、CODING-SYSTEMでSTRING内のテキストをデコードする。これは
     デコードされたテキストを含む新たな文字列をリターンするが、NOCOPYが
     非‘nil’の場合、些細なデコード処理ならSTRING自体をリターンするかもし
     れない。明示的なデコードを使いやすくするために、STRINGのコンテンツ
     はバイトシーケンス値をもつユニバイト文字列であるべきだが、マルチバ
     イト文字列も許すようになっている(マルチバイト形式で8ビットバイトを
     含むと仮定する)。

     オプション引数BUFFERがバッファーを指定する場合、デコードされたテキ
     ストは、そのバッファー内のポイントの後に挿入される(ポイントは移動し
     ない)。この場合、リターン値はデコードされたテキストの長さとなる。

     この関数は、デコードされたテキストに、テキストプロパティ‘charset’を
     putする。このプロパティの値は、元のテキストのデコードに使用された、
     文字セットを示す。

          (decode-coding-string "Gr\374ss Gott" 'latin-1)
               ⇒ #("Grüss Gott" 0 9 (charset iso-8859-1))

 -- Function: decode-coding-inserted-region from to filename &optional
          visit beg end replace
     この関数は、FROMからTOのテキストを、あたかもファイルFILENAMEから、
     与えられた残りの引数で‘insert-file-contents’を使用して読み込んだか
     のようにデコードする。

     デコードせずにファイルからテキストを読み込んだ後、やはりデコードす
     ることを決心したときに使用するのが、この関数の通常の使い方である。
     テキストを削除して再度読み込むかわりに、この関数を呼び出せばデコー
     ドして読み込むことができる。


File: elisp,  Node: Terminal I/O Encoding,  Prev: Explicit Encoding,  Up: Coding Systems

32.10.8 Terminal I/O Encoding
-----------------------------

Emacsは、キーボード入力のデコード、および端末出力のエンコードにコーディ
ングシステムを使用できます。これはLatin-1のような、特定のエンコーディン
グを使用したテキストの送信や表示を行う端末にとって有用です。端末I/Oをエ
ンコードまたはデコードする際、Emacsは‘last-coding-system-used’をセットし
ません。

 -- Function: keyboard-coding-system &optional terminal
     この関数は、TERMINALからのキーボード入力をデコードするために使用す
     る、コーディングシステムをリターンする。‘no-conversion’という値は、
     何のデコーディングも行われていないことを意味する。TERMINALが省略ま
     たは‘nil’なら、それは選択されたフレームの端末を意味する。*note
     Multiple Terminals::を参照のこと。

 -- Command: set-keyboard-coding-system coding-system &optional terminal
     このコマンドは、TERMINALからのキーボード入力のデコードに使用するコ
     ーディングシステムとして、CODING-SYSTEMを指定する。CODING-SYSTEMが
     ‘nil’なら、キーボード入力をデコードしないことを意味する。TERMINALが
     フレームなら、それはそのフレームの端末を意味する。‘nil’なら、それは
     カレントで選択されたフレームの端末を意味する。*note Multiple
     Terminals::を参照のこと。

 -- Function: terminal-coding-system &optional terminal
     この関数は、TERMINALからの端末出力のエンコードに使用中のコーディン
     グシステムをリターンする。‘no-conversion’という値は、何のデコーディ
     ングも行われていないことを意味する。TERMINALがフレームなら、それは
     そのフレームの端末を意味する。‘nil’なら、それはカレントで選択された
     フレームの端末を意味する。

 -- Command: set-terminal-coding-system coding-system &optional terminal
     この関数は、TERMINALからの端末出力のエンコードに使用するためののコ
     ーディングシステムとして、CODING-SYSTEMを指定する。CODING-SYSTEMが
     ‘nil’なら、端末出力をエンコードしないことを意味する。TERMINALがフレ
     ームなら、それはそのフレームの端末を意味する。‘nil’なら、それはカレ
     ントで選択されたフレームの端末を意味する。


File: elisp,  Node: Input Methods,  Next: Locales,  Prev: Coding Systems,  Up: Non-ASCII Characters

32.11 Input Methods
===================

“入力メソッド(input methods)”とは、キーボードから非ASCII文字を簡単に入力
する手段を提供します。プログラムが読み取ることを意図して非ASCII文字とエ
ンコーディングを相互に変換するコーディングシステムとは異なり、入力メソッ
ドはヒューマンフレンドリーなコマンドを提供します(テキストを入力するため
にユーザーが入力メソッドを使う方法については、*note (emacs)Input
Methods::を参照のこと)。0入力メソッドの定義方法はまだこのマニュアルには
ありませんが、ここではそれらの使い方について説明します。

   現在のところ、入力メソッドは文字列で名前をもっていますが、将来的には
入力メソッド名として、シンボルも利用可能になるかもしれません。

 -- Variable: current-input-method
     この変数は、カレントバッファーで現在アクティブな、入力メソッドの名
     前を保持する(方法に依らずセット時には各バッファーで自動的にローカル
     になる)。バッファーで現在アクティブな入力メソッドがなければ、値は
     ‘nil’。

 -- User Option: default-input-method
     この変数は、入力メソッドを選択するコマンドにたいして、デフォルトの
     入力メソッドを保持する。‘current-input-method’と異なり、この変数は
     通常はグローバルである。

 -- Command: set-input-method input-method
     このコマンドは、カレントバッファーで入力メソッドINPUT-METHODをアク
     ティブにする。同様に‘default-input-method’にINPUT-METHODのセットも
     行う。INPUT-METHODが‘nil’なら、このコマンドはカレントバッファーで入
     力メソッドを非アクティブにする。

 -- Function: read-input-method-name prompt &optional default
          inhibit-null
     この関数は、プロンプトPROMPTとともに、ミニバッファーで入力メソッド
     の名前を読み取る。DEFAULTが非‘nil’の場合、ユーザーの入力が空なら、
     それがデフォルトとしてリターンされる。しかし、INHIBIT-NULLが非
     ‘nil’なら、空の入力はエラーをシグナルする。

     リターン値は文字列。

 -- Variable: input-method-alist
     この変数は、サポートされているすべての入力メソッドを定義する。各要
     素は1つの入力メソッドを定義し、以下の形式をもつ:

          (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
           TITLE DESCRIPTION ARGS...)

     ここでINPUT-METHODはメソッド名の文字列、LANGUAGE-ENVはこの入力メソ
     ッドが推奨される言語環境の名前の文字列である(これはドキュメントとし
     ての目的のみの役割を果たす)。

     ACTIVATE-FUNCは、このメソッドをアクティブにするために呼び出す関数、
     もしあればARGSはACTIVATE-FUNCに渡す引数である。つまり、
     ACTIVATE-FUNCの引数は、INPUT-METHODとARGSである。

     TITLEは、ソン入力メソッドがアクティブな間、それをモードライン内に表
     示するための文字列、DESCRIPTIONはそのメソッドを説明し、それが何に適
     するかを説明する文字列である。

   入力メソッドのための基本的インターフェースは、変数
‘input-method-function’です。*note Reading One Event::、および*note
Invoking the Input Method::を参照してください。


File: elisp,  Node: Locales,  Prev: Input Methods,  Up: Non-ASCII Characters

32.12 Locales
=============

POSIXには、言語に関連する機能において、使用する言語を制御するための、
“locale”という概念があります。以下のEmacs変数は、Emacsがこれらの機能と相
互作用する方法を制御します。

 -- Variable: locale-coding-system
     この変数は、‘format-time-string’のformat引数、および
     ‘format-time-string’のリターン値にたいして、システムエラーメッセー
     ジ、およびXウィンドウに限りキーボード入力をデコードするために使用す
     るコーディングシステムを指定する。

 -- Variable: system-messages-locale
     この変数は、システムエラーメッセージを生成するために使用する
     localeを指定する。locale変更により、メッセージが異なる言語になった
     り、異なる表記になり得る。この変数が‘nil’なら、通常のPOSIX方式のよ
     うに、localeは環境変数により指定される。

 -- Variable: system-time-locale
     この変数は、タイムバリューをフォーマットするために使用するlocaleを
     指定する。locale変更により、異なる慣習によりメッセージが表示され得
     る。この変数が‘nil’なら、通常のPOSIX方式のように、localeは環境変数
     により指定される。

 -- Function: locale-info item
     この変数は、もし利用可能なら、カレントPOSIX localeにたいする
     localeデータITEMをリターンする。ITEMは以下のシンボルのいずれかであ
     ること:

     ‘codeset’
          文字列として文字セットをリターンする(localeアイテムの
          ‘CODESET’)。

     ‘days’
          曜日名からなる7要素のベクターをリターンする(localeアイテムの
          ‘DAY_1’から‘DAY_7’)。

     ‘months’
          月の名前からなる12要素のベクターをリターンする(localeアイテム
          の‘MON_1’から‘MON_12’)。

     ‘paper’
          ‘(WIDTH HEIGHT)’というリストで、mm単位でデフォルト用紙サイズを
          リターンする(localeアイテム‘PAPER_WIDTH’および
          ‘PAPER_HEIGHT’)。

     システムが要求された情報を提供できない、またはITEMが上記いずれのシ
     ンボルでもなければ、値は‘nil’となる。リターン値内のすべての文字列は
     、‘locale-coding-system’を使用してデコードされる。localeおよび
     localeアイテムについての詳細な情報は、*note (libc)Locales::を参照さ
     れたい。


File: elisp,  Node: Searching and Matching,  Next: Syntax Tables,  Prev: Non-ASCII Characters,  Up: Top

33 Searching and Matching
*************************

GNU Emacsは、バッファーから指定されたテキストを検索するために、２つの手
段を提供します。それは文字列の正確一致検索(exact string search)と、正規
表現検索(regular expression search)です。正規表現検索の後、マッチしたテ
キストが正規表現壱阡にマッチしたのか、それとも正規表現のさまざまな部分に
一致したかを判断するために、“マッチデータ(match data)”を調べることができ
ます。

* Menu:

* String Search::            正確なマッチの検索。
* Searching and Case::       case-independentまたはcase-significantな検索。
* Regular Expressions::      文字列クラスの記述。
* Regexp Search::            regexpにたいするマッチの検索。
* POSIX Regexps::            最長マッチにたいするPOSIXスタイルのマッチ。
* Match Data::               文字列またはregexp検索後に、テキストがマッチした部分を見つける。
* Search and Replace::       検索と置換を繰り返すコマンド。
* Standard Regexps::         センテンスやページ等を探すために有用なregexp。

   ‘skip-chars...’関連の関数も、ある種の検索を行います。*note Skipping
Characters::を参照してください。文字プロパティ内の変更を検索するには、
*note Property Search::を参照してください。


File: elisp,  Node: String Search,  Next: Searching and Case,  Up: Searching and Matching

33.1 Searching for Strings
==========================

バッファー内のテキストを検索するための、プリミティブ関数が存在します。こ
れらはプログラム内での使用を意図したものですが、インタラクティブに呼び出
すこともできます。これらをインタラクティブに呼び出した場合は、検索文字列
の入力を求め、引数LIMITおよびNOERRORは‘nil’、REPEATは1になります。インタ
ラクティブ検索に関するより詳細な情報は、*note Searching and Replacement:
(emacs)Search.を参照してください。

   以下の検索関数は、バッファーがマルチバイトバッファーならマルチバイト
、ユニバイトバッファーならユニバイトに、検索文字列を変換します。*note
Text Representations::を参照してください。

 -- Command: search-forward string &optional limit noerror repeat
     この関数は、STRINGにたいする正確なマッチを、ポイントから前方に検索
     する。成功したら、見つかったマッチの終端にポイントをセットして、ポ
     イントの新たな値をリターンする。マッチが見つからない場合の値と副作
     用は、NOERROR(以下参照)に依存する。

     以下の例では、ポイントは最初は行の先頭にある。その後の
     ‘(search-forward "fox")’により、ポイントは‘fox’の最後の文字の後に移
     動する:

          ---------- Buffer: foo ----------
          ★The quick brown fox jumped over the lazy dog.
          ---------- Buffer: foo ----------

          (search-forward "fox")
               ⇒ 20

          ---------- Buffer: foo ----------
          The quick brown fox★ jumped over the lazy dog.
          ---------- Buffer: foo ----------

     引数LIMITは検索の境界を指定し、それはカレントバッファー内の位置であ
     ること。その位置を超えるようなマッチは、受け入れられない。LIMITが省
     略または‘nil’の場合のデフォルトは、そのバッファーのアクセス可能範囲
     の終端である。

     検索失敗時に何が起こるかは、NOERRORの値に依存する。NOERRORが‘nil’な
     ら、‘search-failed’はエラーをシグナルする。NOERRORが‘t’なら、
     ‘search-forward’は‘nil’をリターンして、何も行わない。NOERRORが
     ‘nil’と‘t’いずれでもなければ、‘search-forward’はポイントを境界上限
     に移動して、‘nil’をリターンする。

     引数NOERRORは、マッチに失敗した有効な検索だけに影響する。無効な引数
     は、NOERRORとは無関係にエラーとなる。

     REPEATが正の数Nなら、それは繰り返し回数の役目をもつ。検索はN回繰り
     返され、前回のマッチの終端から毎回検索が開始される。これらの連続す
     る検索が成功した場合、関数は成功となりポイントを新たな値をリターン
     する。それ以外は検索失敗となり、上述したように結果はNOERRORの値に依
     存する。REPEATが負の数-Nなら、それは逆方向(後方)への検索の繰り返し
     回数Nとしての役目をもつ。

 -- Command: search-backward string &optional limit noerror repeat
     この関数は、ポイントから後方にSTRINGを検索する。これは
     ‘search-forward’と似ているが、前方ではなく後方に検索する点が異なる
     。後方への検索では、ポイントはマッチの先頭に残される。

 -- Command: word-search-forward string &optional limit noerror repeat
     この関数は、ポイントから前方にSTRINGにたいする“単語(word)”のマッチ
     を検索する。マッチが見つかったら、見つかったマッチの終端にポイント
     をセットして、ポイントの新たな値をリターンする。

     単語マッチはSTRINGを単語のシーケンスとみなし、それらを分ける句読点
     は無視する。これはバッファーから、同じ単語シーケンスを検索する。単
     語はそれぞれバッファー内で明確に区別されていなければならないが(単語
     ‘ball’の検索は単語‘balls’にマッチしない)、句読点やスペース等の細部
     は無視される(‘ball boy’を検索すると‘ball. Boy!’にマッチする)。

     以下の例では、ポイントは最初バッファー先頭にある。検索により、ポイ
     ントは‘y’と‘!’の間に残される。

          ---------- Buffer: foo ----------
          ★He said "Please!  Find
          the ball boy!"
          ---------- Buffer: foo ----------

          (word-search-forward "Please find the ball, boy.")
               ⇒ 39

          ---------- Buffer: foo ----------
          He said "Please!  Find
          the ball boy★!"
          ---------- Buffer: foo ----------

     LIMITが非‘nil’なら、それはカレントバッファー内の位置であること。こ
     れはその検索の境界上限を指定する。見つかったマッチは、その位置を超
     えてはならない。

     NOERRORが‘nil’なら、‘word-search-forward’はエラーをシグナルする。
     NOERRORが‘t’なら、エラーをシグナルするかわりに、‘nil’をリターンする
     。NOERRORが‘nil’と‘t’いずれでもなければ、ポイントをLIMIT(またはバッ
     ファーのアクセス可能範囲の終端)に移動して、‘nil’をリターンする。

     REPEATが非‘nil’なら、検索はその回数繰り返される。ポイントは最後のマ
     ッチの終端に置かれる。

     内部的には、‘word-search-forward’と関連する関数は、STRINGから句読点
     を無視した正規表現に変換するために、関数‘word-search-regexp’を使用
     する。

 -- Command: word-search-forward-lax string &optional limit noerror
          repeat
     このコマンドは‘word-search-forward’と同じだが、STRINGが空白で開始ま
     たは終了していなければ、STRINGの先頭または終端が単語境界にマッチす
     る必要がない点が異なる。たとえば‘ball boy’の検索は‘ball boyee’には
     マッチするが、‘balls boy’にはマッチしない。

 -- Command: word-search-backward string &optional limit noerror repeat
     この関数は、ポイントから後方へSTRINGにマッチする単語を検索する。こ
     の関数は‘word-search-forward’と同様だが、後方に検索して、通常はマッ
     チの先頭にポイントを残す点が異なる。

 -- Command: word-search-backward-lax string &optional limit noerror
          repeat
     このコマンドは‘word-search-backward’と同じだが、文字列が空白で開始
     または終了していなければ、STRINGの先頭または終端が単語境界にマッチ
     する必要がない点が異なる。


File: elisp,  Node: Searching and Case,  Next: Regular Expressions,  Prev: String Search,  Up: Searching and Matching

33.2 Searching and Case
=======================

デフォルトのEmacs検索では、検索するテキストの大文字と小文字は無視されま
す。検索対象に‘FOO’を指定すると、‘Foo’や‘foo’もマッチとみなされます。こ
れは正規表現にも適用されます。つまり‘[aB]’は‘a’、‘A’、‘b’、‘B’にもマッチ
するでしょう。

   この機能が望ましくなければ、変数‘case-fold-search’を‘nil’にセットして
ください。その場合、すべての文字は大文字小文字の違いを含めて、正確にマッ
チしなければなりません。これはバッファーローカル変数です。この変数の変更
は、カレントバッファーだけに影響を与えます(*note Intro to
Buffer-Local::を参照)。かわりにデフォルト値を変更することもできます。
Lispコードでは、‘let’を使用して‘case-fold-search’を望む値にバインドする
ほうが、より一般的でしょう。

   ユーザーレベルのインクリメンタル検索機能では、大文字小文字の区別が異
なることに注意してください。検索文字列に含まれるのが小文字だけなら検索は
大文字小文字の違いを無視しますが、検索文字列に1つ以上の大文字が含まれれ
ば検索は大文字小文字の違いを区別するようになります。しかしLispコード内で
使用される検索関数では、これは何も行いません。*note (emacs)Incremental
Search::を参照してください。

 -- User Option: case-fold-search
     このバッファーローカル変数は、検索が大文字小文字の違いを無視するべ
     きかどうかを決定する。この変数が‘nil’なら、検索は大文字小文字の違い
     を無視しない。それ以外(とデフォルト)では、大文字小文字のかも無視す
     る。

 -- User Option: case-replace
     この変数は、高レベルの置換関数が大文字小文字の違いを保持するべきか
     どうかを決定する。この変数が‘nil’なら、それは置換テキストをそのまま
     使用することを意味する。非‘nil’値は、置換されるテキストに応じて、置
     換テキストの大文字小文字を変換することを意味する。

     この変数は、それを関数‘replace-match’の引数として渡すことにより使用
     される。*note Replacing Match::を参照のこと。


File: elisp,  Node: Regular Expressions,  Next: Regexp Search,  Prev: Searching and Case,  Up: Searching and Matching

33.3 Regular Expressions
========================

“正規表現(regular expression)”、略して“regexp”は、文字列の(もしかしたら
無限の)セットを表すパターンのことです。regexpにたいするマッチの検索は、
とても強力な処理です。このセクションではregexpの記述方法、それ以降のセク
ションではそれらを検索する方法を示します。

   正規表現を対話的に開発するために、‘M-x re-builder’コマンドを使用でき
ます。このコマンドは、別のバッファーに即座に視覚的なフィードバックを表示
することにより、正規表現を作成するための便利なインターフェースを提供しま
す。regexp編集とともに、ターゲットとなるバッファーのすべてのマッチがハイ
ライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェ
イスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。

* Menu:

* Syntax of Regexps::        正規表現の記述ルール。
* Regexp Example::           正規表現構文の説明。
* Regexp Functions::         正規表現を操作する関数。


File: elisp,  Node: Syntax of Regexps,  Next: Regexp Example,  Up: Regular Expressions

33.3.1 Syntax of Regular Expressions
------------------------------------

正規表現は、少数の文字が特別な構成要素で、残りは“通常”の文字であるような
構文をもちます。通常の文字は、その文字自身だけにマッチする、シンプルな正
規表現です。特別な文字は‘.’、‘*’、‘+’、‘?’、‘[’、‘^’、‘$’、および‘\’です
。将来、新たなスペシャル文字が定義されることはないでしょう。文字候補で終
わる場合、‘]’はスペシャル文字です。文字候補の間では、‘-’はスペシャル文字
です。‘[:’と、対応する‘:]’は、文字候補内の文字クラスです。正規表現内に出
現する他の文字は、‘\’が前置されていない限り、通常の文字です。

   たとえば‘f’はスペシャル文字ではなく通常文字なので、‘f’は文字列‘f’にマ
ッチし、他の文字にはマッチしない正規表現です(これは文字列‘fg’には_マッチ
しない_が、その文字列の_部分_にマッチする)。同様に、‘o’は‘o’だけにマッチ
します。

   任意の2つの正規表現AとBは、結合することができます。結合した結果は、文
字列の先頭からある長さの文字列がAにマッチし、残りの文字列がBにマッチする
ような文字列にマッチする正規表現になります。

   単純な例として、文字列‘fo’だけにマッチする正規表現の構成要素‘fo’を取
得するために、正規表現‘f’と‘o’を結合できます。

* Menu:

* Regexp Special::           正規表現内のスペシャル文字。
* Char Classes::             正規表現内で使用される文字クラス。
* Regexp Backslash::         正規表現内のバックスラッシュシーケンス。


File: elisp,  Node: Regexp Special,  Next: Char Classes,  Up: Syntax of Regexps

33.3.1.1 Special Characters in Regular Expressions
..................................................

以下は、正規表現内で特別な文字のリストです:

‘.’ (Period)
     これは、改行を除く1文字にマッチする。結合を使用して、‘a.b’のような
     正規表現を作成できる。これは‘a’で始まり‘b’で終わる3文字の文字列にマ
     ッチする。

‘*’
     これは、それ自身が構成要素ではない。これは前置された正規表現を可能
     な限り繰り返したものにマッチすることを意味する、後置演算子である。
     したがって、‘o*’は任意の個数の‘o’にマッチする(‘o’を含まない場合もマ
     ッチする)。

     ‘*’は常に前置された表現の、_最小_の表現に適用される。つまり‘fo*’は
     ‘o’の繰り返しであり、‘fo’の繰り返しではない。これは‘f’、‘fo’、
     ‘foo’、...にマッチする。

     マッチを行う処理は構成要素‘*’を、マッチングにより即座に、見つけ得る
     回数分処理して、その後にパターンの残りを継続する。これが失敗したら
     、残りのパターンのマッチが可能になるかもしれないという期待のもと、
     ‘*’の変更された構成のうちいくつかのマッチを破棄することによる、バッ
     クトラッキングが発生する。たとえば文字列‘caaar’にたいして‘ca*ar’を
     マッチングすると、‘a*’はまず3つすべての‘a’へのマッチを試みる。しか
     し残りのパターンは‘ar’であり、マッチ対象に残されているのは‘r’だけな
     ので、この試みは失敗する。‘a*’にたいする次の代替策は、2つの‘a’だけ
     へのマッチである。この選択では、残りのregexpのマッチは成功する。

     *警告:* ネストされた繰り返し処理は、それらが曖昧なマッチとなるよう
     な場合は、無期限な長時間の実行となり得る。たとえば文字列
     ‘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz’にたいして正規表現
     ‘\(x+y*\)*a’のマッチを試みると、それが最終的に失敗するまでに数時間
     を要し得る。Emacsはその試みのいずれも機能しないと結論する前に、
     ‘x’のグループ家のそれぞれを試みなければならない。さらに悪いことに、
     ‘\(x*\)*’は無数の方法でnull文字列にマッチ可能なので、これは無限ルー
     プを引き起こす。これらの問題を避けるには、ネストされた繰り返しがバ
     ックトラッキングでの組み合わせ爆発(combinatorial explosion)が発生し
     ないことを確実にするために注意深くチェックすること。

‘+’
     これは‘*’のような後置演算子だが、これは前置された表現に少なくとも
     1回マッチしなければならない点が異なる。たとえば‘ca+r’は文字列
     ‘car’や‘caaaar’にマッチするが、文字列‘cr’にはマッチせず、その一方で
     ‘ca*r’はこれら3つすべての文字列にマッチする。

‘?’
     これは‘*’のような後置演算子だが、これは前置された表現に1回、または
     マッチしないかのいずれかでなければならない点が異なる。申‘ca?r’は
     ‘car’と‘cr’にマッチするが、他にはマッチしない。

‘*?’, ‘+?’, ‘??’
     演算子 ‘*’、‘+’、‘?’には“非欲張り(non-greedy)”な変種が存在する。こ
     れらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等
     しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字
     列(含まれる表現全体と等しい)にマッチする。

     たとえば正規表現‘c[ad]*a’が文字列‘cdaaada’に適用されると文字列全体
     にマッチするが、正規表現‘c[ad]*?a’を同じ文字列に適用すると‘cda’だけ
     にマッチする(ここでマッチが許された表現全体にたいする‘[ad]*?’の可能
     な最短マッチは‘d’である)。

‘[ ... ]’
     これは‘[’で始まり‘]’で終端される“文字候補(character alternative)”で
     ある。もっとも単純なケースでは、この２つのカッコ(brackets)の間にあ
     る文字が、この文字候補がマッチ可能な文字である。

     したがって‘[ad]’は1つの‘a’と1つの‘d’の両方にマッチし、‘[ad]*’は
     ‘a’と‘d’だけから構成された任意の文字列(空文字列を含む)にマッチする
     。つまり‘c[ad]*r’は‘cr’、‘car’、‘cdr’、‘caddaar’等にマッチする。

     開始文字と終了文字の間に‘-’を記述することにより、文字候補内に文字範
     囲を含めることができる。つまり‘[a-z]’は小文字のASCIIアルファベット
     文字にマッチする。範囲は‘[a-z$%.]’のように個別の文字と自由に組み合
     わせることができる。これは任意のASCII小文字アルファベットと‘$’、
     ‘%’、またはピリオドとマッチする。

     ‘case-fold-search’が非‘nil’なら、‘[a-z]’は大文字アルファベットにも
     マッチする。‘[a-z]’のような範囲は、そのlocaleの照合順に影響されず、
     常にASCII順のシーケンスを表すことに注意。

     さらに通常のregexpスペシャル文字は文字候補内では特別ではないことに
     も注意されたい。文字候補内部では‘]’、‘-’、‘^’という完全に異なる文字
     セットが特別に扱われる。

     文字候補内に‘]’を含めるには、それを最初の文字にしなければならない。
     たとえば‘[]a]’は、‘]’と‘a’にマッチする。‘-’を含めるには、文字候補の
     最初または最後の文字として‘-’を記述するか、範囲の後に置くこと。つま
     り‘[]-]’は‘]’と‘-’の両方にマッチする。(以下で説明するように、ここで
     は‘\’は特別ではないので、文字候補内に‘]’を含めるために‘\]’は使用で
     きない)。

     文字候補内に‘^’を含めるには、先頭以外のいずれかの場所に置くこと。

     ある範囲がユニバイト文字Cで始まり、マルチバイト文字C2でお話場合、そ
     の範囲は2つの部分に分割される。1つはユニバイト文字‘C..?\377’、もう
     1つはマルチバイト文字‘C1..C2’である。ここでC1はC2が属する文字セット
     の最初の文字である。

     文字候補には、名前付き文字クラスも指定できる(*note Char Classes::を
     参照)。これはPOSIXの機能である。たとえば‘[[:ascii:]]’は、任意の
     ASCII文字にマッチする。文字クラスの使用は、そのクラス内すべての文字
     を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので、
     後者は実際は実現可能ではない。

‘[^ ... ]’
     ‘[^’は“補完文字候補(complemented character alternative)”を開始する
     。これは、指定された以外の任意の文字とマッチする。つまり
     ‘[^a-z0-9A-Z]’はアルファベットと数日前_以外_の、すべての文字にマッ
     チする。

     ‘^’は文字クラス内では、先頭に記述されない限り特別ではない。‘^’に続
     く文字は、あたかもそれが先頭にあるかのように扱われる(別の言い方をす
     ると‘-’や‘]’は、ここでは特別ではない)。

     マッチしない文字の1つとして改行が記述されていなければ、補完文字候補
     は改行にマッチできる。これは‘grep’のようなプログラム内でのregexpの
     扱いとは、対照的である。

     文字候補のように、名前付き文字クラスを指定できる。たとえば
     ‘[^[:ascii:]]’は、任意の非ASCII文字にマッチする。*note Char
     Classes::を参照のこと。

‘^’
     バッファーのマッチング時、‘^’は空文字列、ただしマッチ対象のテキスト
     内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマ
     ッチする。それ以外のマッチは、すべて失敗する。つまり‘^foo’は、行の
     先頭に出現する‘foo’にマッチする。

     バッファーではなく文字列とマッチする際は、‘^’は文字列の先頭、または
     改行文字の後にマッチする。

     歴史的な互換性という理由により、‘^’は正規表現の先頭、または‘\(’、
     ‘\(?:’、‘\|’の後だけで使用できる。

‘$’
     これは‘^’と似ているが、行の終端(またはバッファーのアクセス可能範囲
     の終端)だけにマッチする。つまり‘x+$’は、行末にある1つ以上の‘x’から
     なる文字列にマッチする。

     バッファーではなく文字列とマッチする際は、‘$’は文字列の終端、または
     改行文字の前にマッチする。

     歴史的な互換性という理由により、‘$’は正規表現の先頭、または‘\(’、
     ‘\(?:’、‘\|’の前だけで使用できる。

‘\’
     これは2つの機能をもつ。スペシャル文字(‘\’を含む)のクォートと、追加
     のスペシャル文字の導入である。

     ‘\’はスペシャル文字をクォートするので、‘\$’は‘$’、‘\[’は‘[’だけにマ
     ッチする正規表現といったようになる。

     ‘\’はLisp文字列(*note String Type::を参照)の入力構文(read syntax)内
     でも特別な意味をもち、‘\’でクォートしなければならないことに注意。た
     とえば文字‘\’にマッチする正規表現は‘\\’である。文字‘\\’を含むLisp文
     字列を記述するには、別の‘\\’で‘\\’をクォートすることをLisp構文は要
     求する。したがって‘\’にマッチする正規表現にたいする入力構文は、
     ‘"\\\\"’となる。

   *注意してください:* 歴史的な互換性のために、スペシャル文字はそれらが
もつ特別な意味が意味を成さないコンテキスト内にある場合は、通常の文字とし
て扱われます。たとえば‘*foo’は、‘*’が作用可能な前置された表現がないので
、通常の‘*’として扱われます。この挙動に依存するのは悪い習慣です。どこに
それが出現しようと、スペシャル文字はすべてクォートしてください。

   文字候補内で‘\’は何ら特別ではないので、‘-’や‘]’の特別な意味を取り除く
ことは決してありません。特別な意味をもたないような場合でも、これらの文字
をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマ
ッチする‘[^\]’(Lisp文字列構文では‘"[^\\]"’)内でのように、これらの文字が
_特別な意味_をもつ箇所では、これらの文字にバックスラッシュを前置する正当
性があるので、それほど何も明解にはしないでしょう。

   実際には、正規表現内に出現する‘]’は文字候補に近接しており、それ故にほ
とんどがスペシャル文字です。しかしリテラルの‘[’および‘]’の複雑なパターン
にたいして、マッチを試みることも時にはあるかもしれません。そのような状況
では、文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初か
ら注意深く解析するのが必要なときもあるかもしれません。たとえば‘[^][]]’は
、補完文字候補‘[^][]’(角カッコ以外の任意の1文字とマッチする)と、その後の
リテラルの‘]’により構成されます。

   厳密にはregexp先頭の‘[’は特別で、‘]’は特別ではないというのがルールで
す。これはクォートされていない最初の‘[’で終わり、その後は文字候補になり
ます。(文字クラス開始を除き)‘[’はもはや特別ではありませんが、‘]’は直後に
スペシャル文字‘[’があるか、その‘[’の後に‘^’がある場合を除き、特別です。
これは文字クラス終了ではない次のスペシャル文字‘]’まで続きます。これは文
字候補を終了させて、通常の正規表現の構文をリストアします。クォートされて
いない‘[’は再び特別となり、‘]’は特別ではなくなります。


File: elisp,  Node: Char Classes,  Next: Regexp Backslash,  Prev: Regexp Special,  Up: Syntax of Regexps

33.3.1.2 Character Classes
..........................

以下は文字候補内で使用できるクラスと、その意味についてのテーブルです:

‘[:ascii:]’
     これは任意のASCII文字(コード0 – 127)にマッチする。
‘[:alnum:]’
     これは任意のアルファベットと数字にマッチする(現在のところマルチバイ
     ト文字にたいしては、単語構文をもつものすべてにマッチする)。
‘[:alpha:]’
     これは任意のアルファベットにマッチする(現在のところマルチバイト文字
     にたいしては、単語構文をもつものすべてにマッチする)。
‘[:blank:]’
     これはスペースとタブだけにマッチする。
‘[:cntrl:]’
     これはASCII制御文字にマッチする。
‘[:digit:]’
     これは‘0’から‘9’までにマッチする。つまり‘[-+[:digit:]]’は‘+’と‘-’同
     様、任意の数にマッチする。
‘[:graph:]’
     これはグラフィック文字(ASCII制御文字、スペース、delete文字を除くす
     べての文字)を意味する。
‘[:lower:]’
     これはカレントの大文字小文字テーブル(*note Case Tables::を参照)で小
     文字と判断される文字すべてにマッチする。‘case-fold-search’が非
     ‘nil’なら、これは大文字にもマッチする。
‘[:multibyte:]’
     これは任意のマルチバイト文字にマッチする(*note Text
     Representations::を参照)。
‘[:nonascii:]’
     これは非ASCII文字にマッチする。
‘[:print:]’
     これはプリント文字(ASCII制御文字とdelete文字以外のすべての文字)にマ
     ッチする。
‘[:punct:]’
     これは任意の句読点文字(punctuation character)にマッチする(現在のと
     ころマルチバイト文字にたいしては、単語構文以外のすべてにマッチする
     )。
‘[:space:]’
     これは空白文字構文(*note Syntax Class Table::を参照)をもつ任意の文
     字にマッチする。
‘[:unibyte:]’
     これは任意のユニバイト文字(*note Text Representations::を参照)にマ
     ッチする。
‘[:upper:]’
     これはカレントの大文字小文字テーブル(*note Case Tables::を参照)で大
     文字と判断される文字すべてにマッチする。‘case-fold-search’が非
     ‘nil’なら、これは小文字にもマッチする。
‘[:word:]’
     これは単語構文(*note Syntax Class Table::を参照)をもつ任意の文字に
     マッチする。
‘[:xdigit:]’
     これは16進数の数字‘0’から‘9’、‘a’から‘f’と‘A’から‘F’にマッチする。


File: elisp,  Node: Regexp Backslash,  Prev: Char Classes,  Up: Syntax of Regexps

33.3.1.3 Backslash Constructs in Regular Expressions
....................................................

ほとんどの場合、‘\’の後の任意の文字は、その文字だけにマッチします。しか
し、例外もいくつかあります。‘\’で始まる特定のシーケンスには、特別な意味
をもつものがあります。以下は特別な‘\’構成要素のテーブルです。

‘\|’
     これは選択肢を指定する。2つの正規表現AとB、その間にある‘\|’により、
     AまたはBのいずれかにマッチする表現が形成される。

     つまり‘foo\|bar’は、‘foo’か‘bar’のいずれかにマッチし、他の文字列に
     はマッチしない。

     ‘\|’は周囲の適用可能な最大の表現に適用される。‘\|’を取り囲む‘\( ...
     \)’でグループ化することにより、グループ化の効力を制限できる。

     複数の‘\|’の処理するための、完全なバックトラッキング互換が必要なら
     、POSIX正規表現関数を使用すること(*note POSIX Regexps::を参照)。

‘\{M\}’
     これは、前のパターンを正確にM回繰り返す、後置演算子である。つまり
     ‘x\{5\}’は文字列‘xxxxx’にマッチし、それ以外にはマッチしない。
     ‘c[ad]\{3\}r’は‘caaar’、‘cdddr’、‘cadar’等にマッチする。

‘\{M,N\}’
     これは最小でM回、最大でN回繰り返す、より一般的な後置演算子である。
     M省略時の最小は0、N省略時の最大は存在しない。

     たとえば‘c[ad]\{1,2\}r’は文字列‘car’、‘cdr’、‘caar’、‘cadr’、
     ‘cdar’、‘cddr’にマッチし、それ以外にはマッチしない。
     ‘\{0,1\}’または‘\{,1\}’は、‘?’と同じ。
     ‘\{0,\}’または‘\{,\}’は‘*’と同じ。
     ‘\{1,\}’は‘+’と同じ。

‘\( ... \)’
     これは、以下の3つの目的を果たす役目をもつグループ化構成要素である:

       1. 他の操作のために、一連の‘\|’選択肢を囲う。つまり正規表現
          ‘\(foo\|bar\)x’は、‘foox’か‘barx’のいずれかにマッチする。

       2. 後置演算子‘*’、‘+’、‘?’による複雑な表現を囲う。つまり
          ‘ba\(na\)*’は‘ba’、‘bana’、‘banana’、‘bananana’、...等、任意の
          数(0以上の文字列‘na’にマッチする。

       3. ‘\DIGIT’(以下参照)による将来の参照にたいして、マッチする部分文
          字列を記録する。

     この最後の目的は、カッコによるグループ化というアイデアによるもので
     はない。これは同じ構成要素‘\( ... \)’である2つ目の目的に割当てられ
     た別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が
     発生することがあり、それが内気(shy)なグループの導入をもたらした。

‘\(?: ... \)’
     これは“内気なグループ(shy group)”の構成要素である。内気なグループは
     通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、
     これは番号を取得せず‘\DIGIT’でその値を後方参照できない。内気なグル
     ープは、通常の内気でないグループを変更することなく自動的に追加でき
     るので、機械的に正規表現を構築するのに、特に適している。

     内気なグループ化は、“非キャプチャリング(non-capturing)”、あるいは
     “番号なしグループ(unnumbered groups)”とも呼ばれる。

‘\(?NUM: ... \)’
     これは“明示的番号付きグループ(explicitly numbered group)”の構成要素
     である。通常のグループ化では、位置をもとに番号が暗黙で取得されるが
     、これが不便な場合もあるだろう。この構成要素により、特定のグループ
     に番号を強制できる。番号の付与に特別な制限はなく、複数のグループに
     同じ番号を付与でき、その場合は最後の1つがマッチ(もっとも右のマッチ
     )が採用される。暗黙的に番号付けされたグループは常に、前のグループよ
     り大きい最小の整数となる番号を取得する。

‘\DIGIT’
     これはグループ構成要素(‘\( ... \)’)の、DIGIT番目にマッチしたテキス
     トと同じテキストにマッチする。

     他の言い方をすると、最後のグループの後に、マッチ処理はそのグループ
     によりマッチされたテキストの開始と終了を記憶する。その正規表現の先
     の箇所で、‘\’とその後にDIGITを使用すれば、それが何であれ同じテキス
     トにマッチさせることができる。

     検索またはマッチングを行う関数に渡される、正規表現全体の中で最初の
     9つのグループ化構成要素にマッチする文字列には、その正規表現内で開き
     カッコが出現する順に1から9までの番号が割り当てられる。したがって
     ‘\1’から‘\9’までを使用して、対応するグループ化構成要素によりマッチ
     されたテキストを参照できる。

     たとえば‘\(.*\)\1’は、一方がもう一方と等しいような2つの文字列から構
     成される、改行を含まない任意の文字列にマッチする。‘\(.*\)’は前半分
     にマッチし、これは何でもよいが、それに続く‘\1’はそれと同じテキスト
     に正確にマッチしなければならない。

     構成要素‘\( ... \)’が2回以上マッチする場合(これはたとえば後に‘*’を
     したがえるとき発生し得る)は、最後のマッチだけが記録される。

     正規表現内の特定のグループ化構成要素がマッチしなかった場合、たとえ
     ばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部に
     あるなら、それに対応する‘\DIGIT’構成は何にもマッチしない。人工的な
     例を用いると、‘\(foo\(b*\)\|lose\)\2’は‘lose’にマッチできない。外側
     のグループ内の2つ目の選択肢がマッチするものの、‘\2’が未定義となり、
     何にたいしてもマッチできない。しかし‘foobb’にたいしては、1つ目の選
     択肢が‘foob’にマッチし、‘\2’が‘b’にマッチするので、マッチが可能にな
     る。

‘\w’
     これは任意の単語構成文字にマッチする。エディターの構文テーブルが、
     どの文字が単語構成文字かを決定する。*note Syntax Tables::を参照のこ
     と。

‘\W’
     これは任意の非単語構成文字にマッチする。

‘\sCODE’
     これは、構文がCODEであるような任意の文字にマッチする。ここでCODEは
     、構文コードを表す文字である。‘w’は単語構成要素、‘-’は空白文字、
     ‘(’は開きカッコ、等である。空白文字構文を表すには、‘-’かスペース文
     字のいずれかを使用する。構文コードと、それらを意味する文字のリスト
     は、*note Syntax Class Table::を参照されたい。

‘\SCODE’
     これは、構文がCODEでないような任意の文字にマッチする。

‘\cC’
     これは、カテゴリーがCであるような任意の文字にマッチする。ここでCは
     、カテゴリーを表す文字である。つまり標準カテゴリーテーブルで、‘c’は
     Chinese(中国語)、‘g’はGreek(ギリシャ語)の文字となる。‘M-x
     describe-categories <RET>’で現在定義済みの全カテゴリーのリストを確
     認できる。‘define-category’関数を使用すれば、標準カテゴリーに加えて
     、カテゴリーを独自に定義することもできる(*note Categories::を参照
     )。

‘\CC’
     これは、カテゴリーがCではない任意の文字にマッチする。

   以下は、空文字列にマッチ(つまり文字を何も消費しない)しますが、マッチ
するかどうかはコンテキストに依存するような正規表現を構築します。これらす
べてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかも
そのバッファーの実際の先頭と終端のように扱われます。

‘\`’
     これは空文字列、ただしバッファー先頭、またはマッチ対象の文字列の先
     頭だけにマッチする。

‘\'’
     これは空文字列、ただしバッファー終端、またはマッチ対象の文字列の終
     端だけにマッチする。

‘\=’
     これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマ
     ッチ対象が文字列なら定義されない)。

‘\b’
     これは空文字列、ただし単語の先頭だけにマッチする。つまり‘\bfoo\b’は
     、個別の単語として出現する‘foo’だけにマッチする。‘\bballs?\b’は、個
     別の単語として‘ball’または‘balls’にマッチする。

     ‘\b’は、隣接するテキストが何であるかと無関係に、バッファー(か文字列
     )の先頭または終端にマッチする。

‘\B’
     これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭
     や終端_以外_にマッチする。

‘\<’
     これは空文字列、ただし単語の先頭だけにマッチする。‘\<’は、後に単語
     構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチする。

‘\>’
     これは空文字列、ただし単語の終端だけにマッチする。‘\<’は、コンテン
     ツが単語構成文字で終わる場合のみ、バッファー(か文字列)の終端にマッ
     チする。

‘\_<’
     これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは
     1つ以上の単語かシンボル構成文字のシーケンスである。‘\_<’は、後にシ
     ンボル構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチす
     る。

‘\_>’
     これは空文字列、ただし単語の終端だけにマッチする。‘\_>’は、コンテン
     ツがシンボル構成文字で終わる場合のみ、バッファー(か文字列)の終端に
     マッチする。

   すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の
‘]’がない文字選択肢ないで終わる文字列は無効であり、単一の‘\’で終わる文字
列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると、
‘invalid-regexp’エラーがシグナルされます。


File: elisp,  Node: Regexp Example,  Next: Regexp Functions,  Prev: Syntax of Regexps,  Up: Regular Expressions

33.3.2 Complex Regexp Example
-----------------------------

以下は、後続の空白文字とともにセンテンスの終わりを認識するために、以前の
Emacsで使用されていた、複雑な正規表現の例です(現在のEmacsは、関数
‘sentence-end’により構築される、同様だがより複雑なregexpを使用する。
*note Standard Regexps::を参照されたい)。

   以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列と
してregexpを示し、それを評価した結果を示します。文字列定数の開始と終了は
、ダブルクォーテーションです。‘\"’は文字列の一部としてのダブルクォーテー
ション、‘\\’は文字列の一部としてのバックスラッシュ、‘\t’はタブ、‘\n’は改
行を意味します。

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
          ⇒ "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
     ]*"

改行とタブは、それら自身として出力されます。

   この正規表現は連続する4つのパートを含み、以下のように解読できます:

‘[.?!]’
     この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうち、
     いずれか1つにマッチする文字選択肢である。マッチはこれら3つの文字の
     いずれかで開始されなければならない(これは旧正規表現と、Emacsが使用
     する新たなデフォルトregexpが異なる1つのポイントである。新たな値は、
     後続の空白文字なすでセンテンスを終端する、いくつかの非ASCII文字を許
     容する)。

‘[]\"')}]*’
     パターンの2つ目のパートは任意の0個以上の閉じカッコおよびクォーテー
     ションマークで、後にピリオド、疑問符、感嘆符があるかもしれない。
     ‘\"’は、文字列内でのダブルクォーテーションマークにたいするLisp構文
     である。最後の‘*’は、直前の正規表現(この場合は文字選択肢)の0回以上
     の繰り返しを示す。

‘\\($\\| $\\|\t\\|  \\)’
     パターンの3つ目のパートは、センテンスの後の空白文字、すなわち行の終
     端(スペースがあっても可)、タブ、または2つのスペースにマッチする。
     2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする
     。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダ
     ラー記号は行の終端へのマッチに使用される。

‘[ \t\n]*’
     最後に、パターンの最終パートはセンテンスを終端させるために必要とさ
     れる以上の、余分な空白文字にマッチする。


File: elisp,  Node: Regexp Functions,  Prev: Regexp Example,  Up: Regular Expressions

33.3.3 Regular Expression Functions
-----------------------------------

以下の関数は、正規表現を扱います。

 -- Function: regexp-quote string
     この関数は、STRINGだけに正確にマッチするような正規表現をリターンす
     る。‘looking-at’内でのこの正規表現の使用は、そのバッファー内の次の
     文字がSTRINGのときだけ成功するだろう。検索関数でのこの正規表現の使
     用は、検索されるテキストがSTRINGを含むなら成功するだろう。*note
     Regexp Search::を参照のこと。

     これにより、その正規表現を求める関数呼び出し時に、正確な文字列マッ
     チまたは検索を要求できる。

          (regexp-quote "^The cat$")
               ⇒ "\\^The cat\\$"

     正規表現として記述されたコンテキストにおいて、正確な文字列マッチを
     結合することが、‘regexp-quote’の1つの使い方である。たとえば以下は空
     白文で囲まれた、STRINGの値であるような文字列を検索する:

          (re-search-forward
           (concat "\\s-" (regexp-quote string) "\\s-"))

 -- Function: regexp-opt strings &optional paren
     この関数は、リストSTRINGSの文字列だけにマッチする、効果的な正規表現
     をリターンする。これはマッチングや検索を可能な限り高速にする必要が
     あるとき、たとえばFont Lockモードで有用である(1)。

     オプション引数PARENが非‘nil’なら、その正規表現は少なくとも1つのカッ
     コによるグループ化構成要素に常に囲まれてリターンされる。PARENが
     ‘words’なら、その構成要素は追加で‘\<’と‘\>’で囲まれ、PARENが
     ‘symbols’なら‘\_<’と‘\_>’で囲まれる(プログラミング言語のような文字
     列をマッチングする際は、‘symbols’が適切な場合が多々ある)。

     この単純化された‘regexp-opt’の定義は、実際の値と等価(だが同程度に効
     率的ではない)な正規表現を生成する:

          (defun regexp-opt (strings &optional paren)
            (let ((open-paren (if paren "\\(" ""))
                  (close-paren (if paren "\\)" "")))
              (concat open-paren
                      (mapconcat 'regexp-quote strings "\\|")
                      close-paren)))

 -- Function: regexp-opt-depth regexp
     この関数は、REGEXP内のグループ化された構成要素(カッコで囲まれた正規
     表現)の総数をリターンする。これには内気なグループは含まれない(*note
     Regexp Backslash::を参照)。

 -- Function: regexp-opt-charset chars
     この関数は文字リストCHARS内の文字にマッチする正規表現をリターンする
     。

          (regexp-opt-charset '(?a ?b ?c ?d ?e))
               ⇒ "[a-e]"

   ---------- Footnotes ----------

   (1) ‘regexp-opt’の結果が絶対的にもっとも効率的であるという保証はない
ことに注意してください。手作業でチューニングした正規表現のほうがわずかに
効率的であることがときにありますが、これに努力する価値はほとんどないでし
ょう。


File: elisp,  Node: Regexp Search,  Next: POSIX Regexps,  Prev: Regular Expressions,  Up: Searching and Matching

33.4 Regular Expression Searching
=================================

GNU Emacsでは、インクリメンタル、または非インクリメンタルの両方で、正規
表現(*note Syntax of Regexps::を参照)にたいする次マッチを検索できます。
インクリメンタル検索コマンドについては、*note Regular Expression Search:
(emacs)Regexp Search.を参照してください。ここでは、プログラム内で有用な
検索関数だけを説明します。重要な関数は‘re-search-forward’です。

   これらの検索関数は、バッファーがマルチバイトならルチバイトに、ユニバ
イトならユニバイトに、正規表現を変換します。*note Text
Representations::を参照してください。

 -- Command: re-search-forward regexp &optional limit noerror repeat
     この関数はカレントバッファー内で、正規表現REGEXPにマッチするテキス
     ト文字列を、前方へ検索する。この関数はREGEXPにマッチしない任意の量
     のテキストをスキップして、見つかった最初のマッチの終端にポイントを
     残す。これはポイントの新たな値をリターンする。

     LIMITが非‘nil’なら、それはカレントバッファー内の位置であること。こ
     れは検索にたいする上限を指定する。その位置を超えるマッチは受け入れ
     られない。

     REPEATが与えられたなら、それは正の数でなければならない。検索は、そ
     の回数繰り返される。それぞれの繰り返しは、前のマッチの終端から開始
     される。これら一連の検索すべてが成功したらその検索は成功となり、ポ
     イントを移動してポイントの新たな値をリターンする。それ以外では、検
     索は失敗となる。検索失敗時に‘re-search-forward’が何をおこなうかは、
     NOERRORの値に依存する:

     ‘nil’
          ‘search-failed’エラーをシグナルする。
     ‘t’
          何もせず‘nil’をリターンする。
     その他
          ポイントをLIMIT(またはバッファーのアクセス可能範囲の終端)に移
          動して、‘nil’をリターンする。

     以下の例では、ポイントは最初は‘T’の前にある。この検索を評価すること
     により、その行の終端(‘hat’の‘t’と改行の間)にポイントは移動する。

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (re-search-forward "[a-z]+" nil t 5)
               ⇒ 27

          ---------- Buffer: foo ----------
          I read "The cat in the hat★
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Command: re-search-backward regexp &optional limit noerror repeat
     この関数はカレントバッファー内で、正規表現REGEXPにマッチするテキス
     ト文字列を、後方へ検索して、見つかった最初のマッチの先頭にポイント
     を残す。

     この関数は‘re-search-forward’と似ているが、単なるミラーイメージ
     (mirror-image: 鏡像)ではない。‘re-search-forward’は、先頭が開始ポイ
     ントと可能な限り近いマッチを探す。‘re-search-backward’が完全なミラ
     ーイメージなら、終端が可能な限り近いマッチを探すだろう。しかし実際
     は先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。
     これは、与えられた位置にたいする正規表現マッチングが常に正規表現の
     先頭から終端に機能し、指定された開始位置から開始されるのが理由であ
     る。

     ‘re-search-forward’の真のミラーイメージには、正規表現を終端から先頭
     へマッチする特別な機能が要求されるだろう。それを実装するこによる問
     題に価値はない。

 -- Function: string-match regexp string &optional start
     この関数はSTRING内で、正規表現REGEXPにたいする最初のマッチの開始位
     置のインデックスをリターンする。STRING内のそのインデックスから検索
     は開始される。

     たとえば、

          (string-match
           "quick" "The quick brown fox jumped quickly.")
               ⇒ 4
          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

     文字列の最初の文字のインデックスは1、2文字目は2、...となる。

     この関数リターン後、そのマッチの先の最初の文字のインデックスは、
     ‘(match-end 0)’で利用できる。*note Match Data::を参照のこと。

          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

          (match-end 0)
               ⇒ 32

 -- Function: string-match-p regexp string &optional start
     この述語関数は‘string-match’と同じことを行うが、マッチデータの変更
     を避ける。

 -- Function: looking-at regexp
     この関数は、カレントバッファー内のポイント直後のテキストが、正規表
     現REGEXPにマッチするかどうかを判断する。“直後”の正確な意味は、その
     検索が“固定”され、ポイントの後の最初の文字からマッチが開始する場合
     のみ成功するということである。成功なら結果は‘t’、それ以外は‘nil’と
     なる。

     この関数はポイントを移動しないが、マッチデータは更新する。*note
     Match Data::を参照のこと。マッチデータを変更することなくテストする
     必要があるなら、以下で説明する‘looking-at-p’を使用すること。

     以下の例では、ポイントは‘T’の直前にある。それ以外の場所にある場合、
     結果は‘nil’となるだろう。

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-at "The cat in the hat$")
               ⇒ t

 -- Function: looking-back regexp &optional limit greedy
     この関数は、ポイントの直前(ポイントで終わる)テキストがREGEXPとマッ
     チしたら‘t’、それ以外は‘nil’をリターンする。

     正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチ
     を、ポイントから後方へ検索するように実装された。長い距離を検索する
     必要がある場合、これは極めて低速になり得る。LIMITを指定してその前を
     検索しないよう告げることにより、要する時間を制限できる。この場合、
     マッチデータはLIMIT、またはその後で始まらなければならない。以下は例
     である:

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-back "read \"" 3)
               ⇒ t
          (looking-back "read \"" 4)
               ⇒ nil

     GREEDYが非‘nil’なら、この関数は可能な限り後方へマッチを拡張し、前方
     の1文字がregexpがマッチの一部とならなければ停止する。マッチが拡張さ
     れたときは、マッチ開始位置がLIMITの前にあっても許される。

     一般的に‘looking-back’は低速なので、可能な限り使用は避けることを推
     奨する。この理由により、‘looking-back-p’の追加は計画されていない。

 -- Function: looking-at-p regexp
     この述語関数は‘looking-at’と同様に機能するが、マッチデータを更新し
     ない。

 -- Variable: search-spaces-regexp
     この変数が非‘nil’なら、それは空白文字を検索する方法を告げる正規表現
     であること。この場合、検索される正規表現内のすべてのスペース属は、
     この正規表現を使用することを意味する。しかし‘[...]’、‘*’‘+’、‘?’の
     ような構成要素内のスペースは、‘search-spaces-regexp’の影響を受けな
     い。

     この変数はすべての正規表現検索、およびマッチ構成要素に影響するので
     、コードの可能な限り狭い範囲にたいして、一時的にバインドするべきで
     ある。


File: elisp,  Node: POSIX Regexps,  Next: Match Data,  Prev: Regexp Search,  Up: Searching and Matching

33.5 POSIX Regular Expression Searching
=======================================

通常の正規表現関数は、‘\|’や繰り返しの構成要素を処理するために必要なとき
だけバックトラッキングを行いますが、_何らか_のマッチが見つかるまでの間だ
け、これを継続します。そして成功した後に、見つかった最初のマッチを報告し
ます。

   このセクションでは、正規表現にたいしてPOSIX標準で指定された完全なバッ
クトラッキングを処理する、他の検索関数を説明します。これらはPOSIXが要求
する最長マッチを報告できるように、すべての可能なマッチを試み、すべてのマ
ッチが見つかるまでバックトラッキングを継続します。これは非常に低速なので
、本当に最長マッチが必要なときだけ、これらの関数を使用してください。

   POSIXの検索およびマッチ関数は、非欲張りな繰り返し演算子(*note
non-greedy: Regexp Special.を参照)を正しくサポートしません。これは
POSIXのバックトラッキングが、非欲張りな繰り返しのセマンチックと競合する
からです。

 -- Command: posix-search-forward regexp &optional limit noerror repeat
     これは‘re-search-forward’と似ているが、正規表現マッチングにたいして
     POSIX標準が指定する、完全なバックトラッキングを行う点が▼異なる。

 -- Command: posix-search-backward regexp &optional limit noerror repeat
     これは‘re-search-backward’と似ているが、正規表現マッチングにたいし
     てPOSIX標準が指定する、完全なバックトラッキングを行う点が異なる。

 -- Function: posix-looking-at regexp
     これは‘looking-at’と似ているが、正規表現マッチングにたいしてPOSIX標
     準が指定する、完全なバックトラッキングを行う。

 -- Function: posix-string-match regexp string &optional start
     これは‘string-match’と似ているが、正規表現にたいしてPOSIX標準が指定
     する、完全なバックトラッキングを行う。


File: elisp,  Node: Match Data,  Next: Search and Replace,  Prev: POSIX Regexps,  Up: Searching and Matching

33.6 The Match Data
===================

Emacsは、検索の間に見つかったテキスト片の開始と終了の位置を追跡していま
す。これは“マッチデータ(match data)”と呼ばれます。このマッチデータのおか
げで、メールメッセージ内のデータのような複雑なパターンを検索した後、その
パターンの制御下でマッチ部分を抽出できるのです。

   マッチデータには通常、もっとも最近の検索だけが記述されるので、後で参
照したい検索と、そのマッチデータの使用の間に、誤って別の検索を行わないよ
うに、注意しなければなりません。誤って別の検索を避けるのが不可能な場合は
、マッチデータの上書きを防ぐために、その前後でマッチデータの保存とリスト
アを行わなければなりません。

   上書きを行わないと明記されていない限り、すべての関数は上書きを許され
ていることに注意してください。結果としてバックグラウンド(*note Timers::お
よび*note Idle Timers::を参照されたい)で暗黙に実行される関数は、おそらく
明示的にマッチデータの保存とリストアを行うべきでしょう。

* Menu:

* Replacing Match::          マッチされた部分文字列の置換。
* Simple Match Data::        特定の部分式開始箇所のような、マッチデータの単一アイテムへのアクセス。
* Entire Match Data::        リストとしてマッチデータ全体に一度にアクセスする。
* Saving Match Data::        マッチデータの保存とリストア。


File: elisp,  Node: Replacing Match,  Next: Simple Match Data,  Up: Match Data

33.6.1 Replacing the Text that Matched
--------------------------------------

以下の関数は、最後の検索でマッチされたテキストのすべて、または一部を置換
します。これはマッチデータにより機能します。

 -- Function: replace-match replacement &optional fixedcase literal
          string subexp
     この関数はバッファー、または文字列にたいして置換処理を行う。

     あるバッファーで最後の検索を行った場合は、STRING引数を省略または
     ‘nil’を指定するべきである。また最後に検索を行ったバッファーがカレン
     トバッファーであることを確認すること。その場合、この関数はマッチし
     たテキストをREPLACEMENTで置換することにより、そのバッファーを編集す
     る。これは、置換したテキスト終端にポイントを残す。

     文字列にたいして最後の検索を行った場合は、同じ文字列がSTRINGに渡さ
     れる。その場合、この関数はマッチしたテキストがREPLACEMENTに置き換え
     られた、新たなテキストをリターンする。

     FIXEDCASEが非‘nil’なら、‘replace-match’は大文字小文字を変更せずに置
     換テキストを使用し、それ以外は置換されるテキストのcapitalize(先頭が
     大文字)されているかどうかに応じて、置換テキストを変換する。元のテキ
     ストがすべて大文字なら、置換テキストを大文字に変換する。元のテキス
     トの単語すべてがcapitalizeされていたら、置換テキストのすべての単語
     をcapitalizeする。すべての単語が1文字かつ大文字なら、それらはすべて
     大文字の単語ではなく、capitalizeされた単語として扱われる。

     LITERALが非‘nil’なら、REPLACEMENTはそのまま挿入されるが、必要に応じ
     て大文字小文字の変更だけが行われる。これが‘nil’(デフォルト)なら、文
     字‘\’は特別に扱われる。REPLACEMENT内に‘\’が出現した場合、それは以下
     のシーケンスのいずれかの一部でなければならない:

     ‘\&’
          これは置換されるテキスト全体を意味する。

     ‘\N’ （Nは数字)
          これは、元のregexpのN番目の部分式にマッチするテキストを意味す
          る。この部分式とは‘\(...\)’の内部にグループかされた式である。
          N番目のマッチがなければ、空文字列が代用される。

     ‘\\’
          これは置換テキスト内で、単一の‘\’を意味する。

     ‘\?’
          これは自身を意味する(‘replace-regexp’と関連するコマンドの互換
          用。*note (emacs)Regexp Replace::を参照されたい)。

     これら以外の‘\’に続く文字は、エラーをシグナルする。

     ‘\&’および‘\N’により行われる代替えは、もしあれば大文字小文字変換の
     後に発生する。したがって、代替えする文字列は決して大文字小文字変換
     されない。

     SUBEXPが非‘nil’なら、それは全体のマッチではなく、マッチされた
     regexpの部分式番号SUBEXPだけを置換することを指定する。たとえば‘foo
     \(ba*r\)’のマッチング後に‘replace-match’を呼び出すと、SUBEXPが1なら
     ‘\(ba*r\)’にマッチしたテキストだけを置換することを意味する。

 -- Function: match-substitute-replacement replacement &optional
          fixedcase literal string subexp
     この関数は、‘replace-match’によりバッファーに挿入されるであろうテキ
     ストをリターンするが、バッファーを変更しない。これは‘\N’や‘\&’のよ
     うな構成要素を、マッチしたグループで置き換えた実際の結果を、ユーザ
     ーに示したいとき有用である。引数REPLACEMENT、およびオプションの
     FIXEDCASE、LITERAL、STRING、SUBEXPは、‘replace-match’のときと同じ意
     味をもつ。

