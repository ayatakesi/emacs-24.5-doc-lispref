This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Adaptive Fill,  Next: Auto Filling,  Prev: Margins,  Up: Text

31.13 Adaptive Fill Mode
========================

“Adaptive Fillモード”が有効なとき、Emacsは事前定義された
値を使用するのではなく、フィルされる各パラグラフのテキス
トから自動的に、フィルプレフィクスを決定します。このフィ
ルプレフィクスはフィルの間、*note Filling::と*note Auto
Filling::で説明されているように、そのパラグラフの2行目以
降の行頭に挿入されます。

 -- User Option: adaptive-fill-mode
     この変数が非‘nil’なら、Adaptive Fillモードは有効で
     ある。デフォルトは‘t’。

 -- Function: fill-context-prefix from to
     この関数は、Adaptive Fillモードの肝を実装する。これ
     はFROMからTO、通常はパラグラフの開始から終了にある
     テキストにもとづいて、フィルプレフィクスを選択する
     。これは、以下で説明する変数にもとづき、そのパラグ
     ラフの最初の2行を調べることにより、これを行う。

     この関数は通常、文字列としてフィルプレフィクスをリ
     ターンする。しかしこれを行う前に、この関数はそのプ
     レフィクスで始まる行がパラグラフの開始とは見えない
     だろうか、最終チェックを行う(以降では特に明記しない
     )。これが発生した場合、この関数はかわりに‘nil’をリ
     ターンすることにより、異常を通知する。

     以下が、‘fill-context-prefix’が行う詳細である:

       1. 1行目からフィルプレフィクス候補を取得するため
          に、(もしあれば)まず‘adaptive-fill-function’内
          の関数、次に‘adaptive-fill-regexp’(以下参照)の
          正規表現を試みる。これらの非‘nil’の最初の結果
          、いずれも‘nil’なら空文字列が1行目の候補となる
          。
       2. そのパラグラフが1行だけなら、関数は見つかった
          プレフィクス候補の妥当性をテストする。その後、
          この関数はそれが妥当ならその候補を、それ以外は
          スペース文字列をリターンする(以下の
          ‘adaptive-fill-first-line-regexp’の説明を参照
          )。
       3. すでにそのパラグラフが2行以上なら、この関数は
          次に1行目にたいして行なったのとまったく同じ方
          法で、2行目でプレフィクス候補を探す。見つから
          なければ‘nil’をリターンする。
       4. ここで、この関数は発見的手法により2つのプレフ
          ィクス候補を比較する。2行目の候補の非空白文字
          の並びが1行目の候補と同じなら、この関数は2行目
          の候補をリターンする。それ以外では、2つの候補
          に共通するもっとも長い先頭の部分文字列(これは
          空文字列かもしれない)をリターンする。

 -- User Option: adaptive-fill-regexp
     Adaptive Fillモードは、(もしあれば)行の左マージン空
     白文字の後から開始されるテキストにたいして、この正
     規表現をマッチする。マッチする文字列が、その行のフ
     ィルプレフィクス候補である。

     デフォルト値は、空白文字と特定の句読点文字が混在し
     た文字列にマッチする。

 -- User Option: adaptive-fill-first-line-regexp
     この正規表現は1行だけのパラグラフに使用され、1つの
     可能なフィルプレフィクス候補の追加の妥当性評価とし
     て機能する。その候補は、この正規表現にマッチするか
     、‘comment-start-skip’にマッチしなければならない。
     マッチしなければ、‘fill-context-prefix’はその候補を
     “同じ幅”のスペース文字列に置き換える。

     この変数のデフォルト値は ‘"\\`[ \t]*\\'"’で、これは
     空白文字列だけにマッチする。このデフォルトの効果は
     、1行パラグラフで見つかったフィルプレフィクスが、常
     に純粋な空白文字となるよう強制することである。

 -- User Option: adaptive-fill-function
     この変数に関数をセットすることにより、自動的なフィ
     ルプレフィクス選択にたいして、より複雑な方法を指定
     することが可能になる。その関数は、(もしあれば)行の
     左マージンの後のポイントで呼び出され、かつポイント
     を保たなければならない。その関数は、“その行”のフィ
     ルプレフィクス、またはプレフィクスの判断に失敗した
     ことを意味する‘nil’のいずれかをリターンすること。


File: elisp,  Node: Auto Filling,  Next: Sorting,  Prev: Adaptive Fill,  Up: Text

31.14 Auto Filling
==================

Auto Fillモードは、テキスト挿入とともに自動的に行をフィ
ルするマイナーモードです。このセクションでは、Auto Fillモ
ードにより使用されるフックを説明します。既存テキストを明
示的にフィルしたり位置揃えすることができる関数の説明は、
*note Filling::を参照してください。

   Auto Fillモードでは、テキスの一部を再フィルするために
、マージンや位置揃えを変更する関数も利用できます。*note
Margins::を参照してください。

 -- Variable: auto-fill-function
     このバッファーローカル変数の値は、テーブル
     ‘auto-fill-chars’からの文字の自己挿入後に呼び出され
     る関数(引数なし)であること。‘nil’も可で、その場合は
     特に何もしない。

     Auto-Fillモードが有効なら、‘auto-fill-function’の値
     は‘do-auto-fill’である。これは、行ブレークにたいす
     る通常の戦略を実装することを唯一の目的とする関数で
     ある。

 -- Variable: normal-auto-fill-function
     この変数は、もしAuto Fillがオンのときは
     ‘auto-fill-function’にたいして使用する関数を指定す
     る。Auto Fillの動作方法を変更するために、メジャーモ
     ードはこの変数にバッファーローカル値をセットである
     。

 -- Variable: auto-fill-chars
     文字が自己挿入された際に‘auto-fill-function’を呼び
     出す文字(ほとんどの言語環境においてはスペースと改行
     )からなる文字テーブル。


File: elisp,  Node: Sorting,  Next: Columns,  Prev: Auto Filling,  Up: Text

31.15 Sorting Text
==================

このセクションで説明するソート関数はすべて、バッファー内
のテキストを再配置し。これはリスト要素を再配置する
‘sort’関数とは対照的です(*note Rearrangement::)。これら
の関数がリターンする値に意味はありません。

 -- Function: sort-subr reverse nextrecfun endrecfun
          &optional startkeyfun endkeyfun predicate
     この関数はバッファーをレコードに細分してそれらをソ
     ートする、一般的なテキストソートルーチンである。こ
     のセクションのコマンドのほとんどは、この関数を使用
     する。

     ‘sort-subr’が機能する方法を理解するためには、バッフ
     ァーのアクセス可能範囲を“ソートレコード(sort
     records)”と呼ばれる、分離された断片に分割すると考え
     ればよい。レコードは連続、あるいは非連続かもしれな
     いが、オーバーラップしてはならない。各ソートレコー
     ドの一部(全体かもしれない)は、ソートキーとして指定
     される。これらソートキーによるソートにより、レコー
     ドは再配置される。

     通常、レコードはソートキー昇順で再配置される。
     ‘sort-subr’の1つ目の引数REVERSEが非‘nil’なら、レコ
     ードはソートキー降順にソートされて再配置される。

     ‘sort-subr’にたいする以下の4つの引数は、ソートレコ
     ード間でポイントを移動するために呼び出される。これ
     らは‘sort-subr’内で頻繁に呼び出される。

       1. NEXTRECFUNは、レコード終端のポイントで呼び出さ
          れる。この関数は次のレコードの先頭にポイントを
          移動する。‘sort-subr’が呼び出された際は、ポイ
          ント位置が1つ目のレコードの開始とみなされる。
          したがって‘sort-subr’を呼び出す前は、通常はそ
          のバッファーの先頭にポイントを移動すること。

          この関数はバッファー終端にポイントを残すことに
          より、それ以上のソートレコードがないことを示す
          ことができるできる。

       2. ENDRECFUNは、レコード内にあるポイントで呼び出
          される。これはレコード終端にポイントを移動する
          。

       3. STARTKEYFUNは、ポイントをレコード先頭からソー
          トキー先頭に移動する。この引数はオプションで、
          省略された場合はレコード全体がソートキーとなる
          。もし与えられた場合、その関数はソートキーとし
          て使用する非‘nil’値、または‘nil’(ソートキーは
          そのバッファー内のポイント位置から始まることを
          示す)のいずれかをリターンすること。後者の場合
          は、ソートキー終端を見るけるためにENDKEYFUNが
          呼び出される。

       4. ENDKEYFUNは、ソートキー先頭からソートキー終端
          にポイントを移動するために呼び出される。引数は
          オプション。STARTKEYFUNが‘nil’をリターンし、か
          つこの引数が省略(または‘nil’)の場合、そのソー
          トキーはレコード終端まで拡張される。
          STARTKEYFUNが非‘nil’値をリターンした場合、
          ENDKEYFUNは不要。

     引数PREDICATEは、キーを比較するために使用される関数
     である。キーが数字の場合のデフォルトは‘<’、それ以外
     では‘string<’がデフォルトである。

     ‘sort-subr’の例として、以下は‘sort-lines’関数の完全
     な定義である:

          ;; ドキュメント文字列の冒頭2行は
          ;; ユーザー閲覧時には1行となることに注意
          (defun sort-lines (reverse beg end)
            "リージョン内の行をアルファベット順にソート;\
           引数は降順を意味する
          プログラムから呼び出す場合は、以下の3つの引数がある:
          REVERSE(非nilは逆順の意)、\
          およびBEGとEND(ソートするリージョン)
          変数`sort-fold-case'は英字\
          大文字小文字の違いが
          ソート順に影響するかどうかを決定する"
            (interactive "P\nr")
            (save-excursion
              (save-restriction
                (narrow-to-region beg end)
                (goto-char (point-min))
                (let ((inhibit-field-text-motion t))
                  (sort-subr reverse 'forward-line 'end-of-line)))))

     ここで、‘forward-line’は次のレコードの先頭にポイン
     トを移動し、‘end-of-line’はレコードの終端にポイント
     を移動する。レコード全体をソートキーとするため、引
     数STARTKEYFUNおよびENDKEYFUNは渡していない。

     ‘sort-paragraphs’はほとんど同じだが、‘sort-subr’呼
     び出しが以下のようになる:

          (sort-subr reverse
                     (function
                      (lambda ()
                        (while (and (not (eobp))
                                    (looking-at paragraph-separate))
                          (forward-line 1))))
                     'forward-paragraph)

     ソートレコード内を指す任意のマーカーは、
     ‘sort-subr’リターン後は無意味なマーカー位置のまま取
     り残される。

 -- User Option: sort-fold-case
     この変数が非‘nil’なら‘sort-subr’、およびその他のバ
     ッファーソート関数は、文字列比較時に大文字小文字の
     違いを無視する。

 -- Command: sort-regexp-fields reverse record-regexp
          key-regexp start end
     このコマンドは、STARTからENDの間のリージョンを、
     RECORD-REGEXPおよびKEY-REGEXPで指定されたようにアル
     ファベット順にソートする。REVERSEが負の整数なら、逆
     順にソートする。

     アルファベット順のソートとは、2つのソートキーにたい
     して、それぞれの1つ目の文字同士、2つ目の文字同士と
     いったように比較することにより、キーを比較すること
     を意味する。文字が一致しなければ、それはソートキー
     が不等なことを意味する。最初の不一致箇所で文字が小
     さいソートキーが、小さいソートキーとなる。個別の文
     字は、Emacs文字セット内の文字コードの数値に応じて比
     較される。

     引数RECORD-REGEXPの値は、バッファーをソートレコード
     に分割する方法を指定する。各レコードの終端で、この
     正規表現にたいする検索は完了し、これにマッチするテ
     キストが次のレコードとして採用される。たとえば、改
     行の前に少なくとも1つの文字がある行にマッチする正規
     表現‘^.+$’は、そのような行をソートレコードとするだ
     ろう。正規表現の構文と意味については、*note Regular
     Expressions::を参照のこと。

     引数KEY-REGEXPの値は、各レコードのどの部分がソート
     キーかを指定する。KEY-REGEXPはレコード全体、または
     その一部にマッチすることができる。後者の場合、レコ
     ードの残りの部分はソート順に影響しないが、レコード
     が新たな位置に移動される際は、ともに移動される。

     引数KEY-REGEXPは、RECORD-REGEXPの部分式
     (subexpression)、またはその正規表現自体にマッチした
     テキストを参照できる。

     KEY-REGEXPは、以下を指定できる:

     ‘\DIGIT’
          RECORD-REGEXP内でDIGIT番目のカッコ‘\(...\)’で
          グループ化によりマッチしたテキストがソートキー
          になる。

     ‘\&’
          レコード全体がソートキーとなる。

     正規表現
          ‘sort-regexp-fields’は、そのレコード内で正規表
          現にたいするマッチを検索する。そのようなマッチ
          があれば、それがソートキーである。レコード内に
          KEY-REGEXPにたいするマッチがなければそのレコー
          ドは無視され、そのバッファー内でのレコードの位
          置は変更されないことを意味する(他のレコードが
          そのレコードを移動するかもしれない)。

     たとえば、リージョン内のすべての行にたいして、最初
     の単語が文字‘f’で始まる行をソートすることを目論む場
     合は、RECORD-REGEXPを‘^.*$’、KEY-REGEXPを
     ‘\<f\w*\>’にセットするべきである。結果は、以下のよ
     うな式になるだろう

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     ‘sort-regexp-fields’をインタラクティブに呼び出した
     場合は、ミニバッファー内でRECORD-REGEXPと
     KEY-REGEXPの入力を求める。

 -- Command: sort-lines reverse start end
     このコマンドは、STARTとENDの間のリージョン内の行を
     、アルファベット順にソートする。REVERSEが非‘nil’な
     ら、逆順にソートする。

 -- Command: sort-paragraphs reverse start end
     このコマンドは、STARTとENDの間のリージョン内のパラ
     グラフを、アルファベット順にソートする。REVERSEが非
     ‘nil’なら、逆順にソートする。

 -- Command: sort-pages reverse start end
     このコマンドは、STARTとENDの間のリージョン内のペー
     ジを、アルファベット順にソートする。REVERSEが非
     ‘nil’なら、逆順にソートする。

 -- Command: sort-fields field start end
     このコマンドは、STARTとENDの間のリージョン内の行に
     たいして、各行のFIELD番目のフィールドをアルファベッ
     ト順に比較することに、行をソートする。FIELDは空白文
     字により区切られ、1から数えられる。FIELDが負なら、
     行の終端から−FIELD番目のフィールドでソートする。こ
     のコマンドは、テーブルのソートに有用である。

 -- Command: sort-numeric-fields field start end
     このコマンドは、STARTとENDの間のリージョン内の行に
     たいして、各行のFIELD番目のフィールドを数値的に比較
     することにより、行をソートする。FIELDは空白文字によ
     り区切られ、1から数えられる。リージョン内の各行の指
     定されたフィールドは、数字を含んでいなければならな
     い。0で始まる数字は8進数、‘0x’で始まる数字は16進数
     として扱われる。

     FIELDが負なら、行の終端から−FIELD番目のフィールドで
     ソートする。このコマンドは、テーブルのソートに有用
     である。

 -- User Option: sort-numeric-base
     この変数は、‘sort-numeric-fields’にたいして、数字を
     解析するための基本基数を指定する。

 -- Command: sort-columns reverse &optional beg end
     このコマンドは、BEGとENDの間にある行にたいして、特
     定の列範囲をアルファベット順に比較することによりソ
     ートする。BEGとENDの列位置は、ソートが行われる列範
     囲にバインドされる。

     REVERSEが非‘nil’なら、逆順にソートする。

     このコマンドが普通と異なるのは、位置BEGを含む行全体
     と、位置ENDを含む行全体が、ソートされるリージョンに
     含まれることである。

     タブは指定された列に分割される可能性があるので、
     ‘sort-columns’はタブを含むテキストを受け付けないこ
     とに注意。ソート前に‘M-x untabify’を使用して、タブ
     をスペースに変換すること。

     可能なら、ユーティリティプログラム‘sort’を呼び出す
     ことにより、このコマンドは実際に機能する。


File: elisp,  Node: Columns,  Next: Indentation,  Prev: Sorting,  Up: Text

31.16 Counting Columns
======================

列関数は、文字位置(バッファー先頭から数えた文字数)と、列
位置(行先頭から数えたスクリーン文字数)を変換する関数です
。

   これら列関数は、スクリーン上占める列数に応じて、各文
字を数えます。これはコントロール文字は‘ctl-arrow’の値に
応じて2列、または4列を、タブは‘tab-width’の値と、タブが
始まる列の位置に依存する列数を占めるものとして数えられる
ことを意味します。*Note Usual Display::を参照してくださ
い。

   列数計算はウィンドウ幅と水平スクロール量を無視します
。結果として、列値は任意に大きくなる可能性があります。最
初(または左端)の列は0と数えられます。列値は不可視性を別
として、オーバーレイとテキストプロパティを無視します。

 -- Function: current-column
     この関数は、左マージンを0として、列単位で数えたポイ
     ントの水平位置をリターンする。列の位置は、カレント
     行の開始からポイントまでの間の文字の表示上の表現す
     べての幅の和である。

     ‘current-column’の使用例は、*note Text Lines::にあ
     る‘count-lines’の説明を参照されたい。

 -- Command: move-to-column column &optional force
     この関数は、カレント行のCOLUMNにポイントを移動する
     。COLUMNの計算には、行の開始からポイントまでの文字
     の表示上の表現の幅が考慮される。

     インタラクティブに呼び出された際は、COLUMNはプレフ
     ィクス数引数の値である。COLUMNが整数でなければエラ
     ーがシグナルされる。

     列COLUMNが、タブのような複数列を占める文字の中間に
     あるために列を移動することが不可能な場合、ポイント
     はその文字の終端に移動される。しかしFORCEが非
     ‘nil’、かつCOLUMNがタブの中間にあるなら、
     ‘move-to-column’はタブをスペースに変換して、正確に
     列COLUMNに移動することができる。それ以外の複数列文
     字については、それらを分割する手段がないので、
     FORCE指定に関わらず、異常を引き起こす恐れがある。

     その行が列COLUMNに達するほど長くない場合にも、引数
     FORCEは効果をもつ。COLUMNが‘t’なら、その列に達する
     よう行端に空白を追加することを意味する。

     リターン値は、実際に移動した列である。


File: elisp,  Node: Indentation,  Next: Case Changes,  Prev: Columns,  Up: Text

31.17 Indentation
=================

インデント関数は、行の先頭にある空白文字の調査、移動、変
更に使用されます。行の他の箇所にある空白文字を変更できる
関数も、いくつかあります。列およびインデントは、左マージ
ンを0として数えられます。

* Menu:

* Primitive Indent::         インデントのカウントと挿入に使用される関数。
* Mode-Specific Indent::     異なるモード用にインデントをカスタマイズする。
* Region Indent::            リージョン内すべての行のインデント。
* Relative Indent::          前の行にもとづきカレント行をインデントする。
* Indent Tabs::              調整可能なタイプライター形式のタブストップ。
* Motion by Indent::         最初の非ブランク文字への移動。


File: elisp,  Node: Primitive Indent,  Next: Mode-Specific Indent,  Up: Indentation

31.17.1 Indentation Primitives
------------------------------

このセクションでは、インデントのカウントと挿入に使用され
るプリミティブ関数について説明します。以降のセクションの
関数は、これらのプリミティブを使用します。関連する関数に
ついては、*note Size of Displayed Text::を参照してくださ
い。

 -- Function: current-indentation
     この関数は、カレント行のインデント、すなわち最初の
     非ブランク文字の水平位置をリターンする。行のコンテ
     ンツ全体がブランクなら、それは行終端の水平位置であ
     る。

 -- Command: indent-to column &optional minimum
     この関数は、ポイントからCOLUMNに達するまで、タブと
     スペースでインデントを行う。MINIMUMが指定され、かつ
     それが非‘nil’なら、たとえCOLUMNを超えることが要求さ
     れる場合であっても、少なくともその個数のスペースが
     挿入される。それ以外では、ポイントがすでにCOLUMNを
     超える場合、この関数は何も行わない。値は、挿入され
     たインデントの終端列である。

     挿入される空白文字は、周囲のテキスト(通常は先行する
     テキストのみ)のテキストプロパティを継承する。*note
     Sticky Properties::を参照のこと。

 -- User Option: indent-tabs-mode
     この変数が非‘nil’なら、インデント関数はスペースと同
     様、タブを挿入でき、それ以外ではスペースだけを挿入
     できる。この変数をセットすることにより、自動的にカ
     レントバッファー内でバッファーローカルになる。


File: elisp,  Node: Mode-Specific Indent,  Next: Region Indent,  Prev: Primitive Indent,  Up: Indentation

31.17.2 Indentation Controlled by Major Mode
--------------------------------------------

すべてのメジャーモードにとって重要な関数は、編集対象の言
語にたいして正しくインデントを行うように、<TAB>キーをカ
スタマイズします。このセクションでは、<TAB>キーのメカニ
ズムと、それを制御する方法について説明します。このセクシ
ョンの関数は、予期せぬ値をリターンします。

 -- Command: indent-for-tab-command &optional rigid
     これはほとんどの編集用モードで、<TAB>にバインドされ
     るコマンドである。これの通常の動作はカレント行のイ
     ンデントだが、かわりにタブ文字の挿入や、リージョン
     のインデントを行うこともできる。

     これは以下のことを行う:

        • まずTransient Markモードが有効か、そしてリージ
          ョンがアクティブかどうかをチェックする。もしそ
          うなら、リージョン内のテキストすべてをインデン
          トするために‘indent-region’を呼び出す(*note
          Region Indent::を参照)。

        • それ以外なら、‘indent-line-function’内のインデ
          ント関数が‘indent-to-left-margin’の場合、また
          は変数‘tab-always-indent’が挿入する文字として
          タブ文字を指定する場合(以下参照)は、タブ文字を
          挿入する。

        • それ以外なら、カレント行をインデントする。これ
          は‘indent-line-function’内の関数を呼び出すこと
          により行われる。その行がすでにインデント済みで
          、かつ‘tab-always-indent’の値が‘complete’(以下
          参照)なら、ポイント位置のテキストの補完を試み
          る。

     RIGIDが非‘nil’(インタラクティブな場合はプレフィクス
     引数)の場合、このコマンドが行をインデントした後、あ
     るいはタブを挿入後、新たなインデントを反映するため
     に、このコマンドはカレント行先頭にあるバランスされ
     た式全体も厳正にインデントする。この引数は、コマン
     ドがリージョンをインデントする場合は無視される。

 -- Variable: indent-line-function
     この変数の値はカレント行をインデントするために
     ‘indent-for-tab-command’、およびその他種々のインデ
     ントコマンドにより使用される関数である。これは通常
     メジャーモードにより割り当てられ、たとえばLispモー
     ドはこれを‘lisp-indent-line’、Cモードは
     ‘c-indent-line’、のようにセットする。デフォルト値は
     ‘indent-relative’。*note Auto-Indentation::を参照の
     こと。

 -- Command: indent-according-to-mode
     このコマンドは、カレントのメジャーモードに適した方
     法でカレント行をインデントするために、
     ‘indent-line-function’内の関数を呼び出す。

 -- Command: newline-and-indent
     この関数は改行を挿入後、メジャーモードに応じて新た
     な行(挿入した改行の次の行)をインデントする。これは
     ‘indent-according-to-mode’を呼び出すことによりイン
     デントを行う。

 -- Command: reindent-then-newline-and-indent
     このコマンドは、カレント行の再インデント、ポイント
     位置への改行の挿入、その後新たな行(挿入した改行の次
     の行)のインデントを行う。これは
     ‘indent-according-to-mode’を呼び出すことにより、両
     方の行をインデントする。

 -- User Option: tab-always-indent
     この変数は、<TAB>(‘indent-for-tab-command’)コマンド
     の挙動のカスタマイズに使用できる。値が‘t’(デフォル
     ト)なら、コマンドは通常カレント行だけをインデントす
     る。値が‘nil’なら、コマンドはポイントが左マージン、
     またはその行のインデント内ににあるときのみ、カレン
     ト行をインデントし、それ以外はタブ文字を挿入する。
     値が‘complete’なら、コマンドはまずカレント行のイン
     デントを試み、その行がすでにインデント済みならポイ
     ント位置のテキストを補完するために
     ‘completion-at-point’を呼び出す(*note Completion in
     Buffers::を参照)。


File: elisp,  Node: Region Indent,  Next: Relative Indent,  Prev: Mode-Specific Indent,  Up: Indentation

31.17.3 Indenting an Entire Region
----------------------------------

このセクションでは、リージョン内すべての行をインデントす
るコマンドを説明します。これらは予期せぬ値をリターンしま
す。

 -- Command: indent-region start end &optional to-column
     このコマンドは、START(含む)からEND(含まず)で始まる
     非ブランク行すべてをインデントする。TO-COLUMNが
     ‘nil’なら、‘indent-region’はカレントモードのインデ
     ント関数、すなわち‘indent-line-function’の値を呼び
     出すことにより、非ブランク行すべてをインデントする
     。

     TO-COLUMNが非‘nil’なら、それはインデントの列数を指
     定する整数であること。その場合、この関数は空白文字
     を追加もしくは削除することにより、正確にその量のイ
     ンデントを各行に与える。

     フィルプレフィクスがある場合、‘indent-region’はその
     フィルプレフィクスで開始されるように、各行をインデ
     ントする。

 -- Variable: indent-region-function
     この変数の値は、ショートカットとして
     ‘indent-region’により使用されるかもしれない関数であ
     る。その関数はリージョンの開始と終了という、2つの引
     数をとること。その関数はリージョンの行を1行ずつイン
     デントするときと同じような結果を生成するようにデザ
     インするべきだが、おそらくより高速になるであろう。

     値が‘nil’ならショートカットは存在せず、
     ‘indent-region’は実際に1行ずつ機能する。

     ショートカット関数は、‘indent-line-function’が関数
     定義先頭をスキャンしなければならない、Cモードや
     Lispモードのようなモードに有用で、それを各行に適用
     するためには行数の2乗に比例する時間を要するだろう。
     ショートカットは各行のインデントとともに移動してス
     キャン情報を更新でき、それは線形時間である。行を個
     別にインデントするのが高速なモードでは、ショートカ
     ットの必要性はない。

     引数TO-COLUMNが非‘nil’の‘indent-region’では意味は異
     なり、この変数は使用しない。

 -- Command: indent-rigidly start end count
     この関数は、START(含む)からEND(含まず)までのすべて
     の行を、横にCOUNT列インデントする。これは影響を受け
     るリージョンの“外観を保ち”、それを厳密な単位として
     移動する。

     これはインデントされていないテキストリージョンのイ
     ンデントだけでなく、フォーマット済みコードのリージ
     ョンにたいするインデントにも有用である。たとえば
     COUNTが3なら、このコマンドは指定されたリージョン内
     で始まるすべての行のインデントに3を追加する。

     プレフィクス引数なしでインタラクティブに呼び出され
     た場合、このコマンドはインデントを厳密に調整するた
     めに、Transient Markモードを呼び出す。*note
     (emacs)Indentation Commands::を参照のこと。

 -- Command: indent-code-rigidly start end columns
          &optional nochange-regexp
     これは‘indent-rigidly’と似ているが、文字列やコメン
     トで始まる行を変更しない点が異なる。

     加えて、(NOCHANGE-REGEXPが非‘nil’の場合
     )NOCHANGE-REGEXPが行先頭にマッチすれば、その行を変
     更しない。


File: elisp,  Node: Relative Indent,  Next: Indent Tabs,  Prev: Region Indent,  Up: Indentation

31.17.4 Indentation Relative to Previous Lines
----------------------------------------------

このセクションでは、前の行のコンテンツにもとづいてカレン
ト行をインデントする、コマンドを2つ説明します。

 -- Command: indent-relative &optional unindented-ok
     このコマンドは、前の非ブランク行の次の“インデントポ
     イント(indent point)”と同じ列に拡張されるように、ポ
     イント位置に空白文字を挿入する。インデントポイント
     とは、後に空白文字をともなった非空白文字である。次
     のインデントポイントは、ポイントのカレント列より大
     きい、最初のインデントポイントになる。たとえばポイ
     ントがテキスト行の最初の非ブランク文字の下と左にあ
     る場合、空白文字を挿入してその列に移動する。

     前の非ブランク行に次のインデントポイントがない(列の
     位置が十分大きくない)場合は、(UNINDENTED-OKが非
     ‘nil’なら)何もしないか、あるいは‘tab-to-tab-stop’を
     呼び出す。したがって、ポイントが短いテキスト行の最
     後の列の下と右にある場合、このコマンドは通常は空白
     文字を挿入することにより、次のタブストップにポイン
     トを移動する。

     ‘indent-relative’のリターン値は予測できない。

     以下の例では、ポイントは2行目の先頭にある:

                      This line is indented twelve spaces.
          ★The quick brown fox jumped.

     式‘(indent-relative nil)’の評価により、以下が生成さ
     れる:

                      This line is indented twelve spaces.
                      ★The quick brown fox jumped.

     次の例では、ポイントは‘jumped’の‘m’と‘p’の間にある:

                      This line is indented twelve spaces.
          The quick brown fox jum★ped.

     式‘(indent-relative nil)’の評価により、以下が生成さ
     れる:

                      This line is indented twelve spaces.
          The quick brown fox jum  ★ped.

 -- Command: indent-relative-maybe
     このコマンドは、引数UNINDENTED-OKに‘t’を指定して
     ‘indent-relative’を呼び出すことにより、前の非ブラン
     ク行に倣ってカレント行をインデントする。リターン値
     は予測できない。

     カレント列より先のインデントポイントが前の非ブラン
     ク行に存在しなければ、このコマンドは何もしない。


File: elisp,  Node: Indent Tabs,  Next: Motion by Indent,  Prev: Relative Indent,  Up: Indentation

31.17.5 Adjustable “Tab Stops”
------------------------------

このセクションでは、ユーザー指定の“タブストップ(tab
stops)”と、それらを使用、セットするメカニズムについて説
明します。“タブストップ”という名前は、タイプライターのタ
ブストップと機能が類似しているため使用されています。この
機能は、次のタブストップ列に到達するために、適切な数のス
ペースとタブを挿入することにより機能します。これは、バッ
ファー内のタブ文字の表示に影響を与えません(*note Usual
Display::を参照)。Textモードのような少数のメジャーモード
だけが、<TAB>文字を入力として、このタブストップ機能を使
用することに注意してください。*note (emacs)Tab Stops::を
参照してください。

 -- Command: tab-to-tab-stop
     このコマンドは、‘tab-stop-list’により定義される次の
     タブストップ列まで、ポイント前にスペースまたはタブ
     を挿入する。

 -- User Option: tab-stop-list
     この変数は、‘tab-to-tab-stop’により使用されるタブス
     トップ列を定義する。これは‘nil’、もしくは増加(均等
     に増加する必要はない)していく整数のリストであること
     。このリストは暗黙に、最後の要素と最後から2番目の要
     素の間隔(またはリストの要素が2未満なら
     ‘tab-width’)を繰り返すことにより、無限に拡張される
     。値‘nil’は、列‘tab-width’ごとにタブストップするこ
     とを意味する。

     インタラクティブにタブストップの位置を編集するには
     、‘M-x edit-tab-stops’を使用すればよい。


File: elisp,  Node: Motion by Indent,  Prev: Indent Tabs,  Up: Indentation

31.17.6 Indentation-Based Motion Commands
-----------------------------------------

以下のコマンドは主にインタラクティブに使用され、テキスト
内のインデントにもとづいて動作します。

 -- Command: back-to-indentation
     このコマンドは、カレント行(ポイントのある行のこと
     )の最初の非空白文字にポイントを移動する。リターン値
     は‘nil’。

 -- Command: backward-to-indentation &optional arg
     このコマンドは、後方へARG行ポイントを移動した後に、
     その行の最初の非ブランク文字にポイントを移動する。
     リターン値は‘nil’。ARGが省略または‘nil’のときのデフ
     ォルトは1。

 -- Command: forward-to-indentation &optional arg
     このコマンドは、前方へARG行ポイントを移動した後に、
     その行の最初の非ブランク文字にポイントを移動する。
     リターン値は‘nil’。ARGが省略または‘nil’のときのデフ
     ォルトは1。


File: elisp,  Node: Case Changes,  Next: Text Properties,  Prev: Indentation,  Up: Text

31.18 Case Changes
==================

ここで説明する大文字小文字変換コマンドは、カレントバッフ
ァー内のテキストに作用します。文字列と文字の大文字小文字
変換コマンドは*note Case Conversion::、大文字または小文
字に変換する文字や、その変換方法のカスタマイズは*note
Case Tables::を参照してください。

 -- Command: capitalize-region start end
     この関数はSTARTとENDで定義されるリージョン内のすべ
     ての単語をcapitalizeする。capitalizeとは、各単語の
     最初の文字を大文字、残りの文字を小文字に変換するこ
     とを意味する。この関数は‘nil’をリターンする。

     リージョンのいずれかの端が単語の中間にある場合は、
     リージョン内にある部分を単語全体として扱う。

     インタラクティブに‘capitalize-region’が呼び出された
     際は、STARTとENDはポイントとマークになり、小さいほ
     うが先になる。

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------

          (capitalize-region 1 37)
          ⇒ nil

          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 -- Command: downcase-region start end
     この関数は、STARTとENDで定義されるリージョン内のす
     べての英文字を小文字に変換する。この関数は‘nil’をリ
     ターンする。

     インタラクティブに‘downcase-region’が呼び出された際
     は、STARTとENDはポイントとマークになり、小さいほう
     が先になる。

 -- Command: upcase-region start end
     この関数は、STARTとENDで定義されるリージョン内のす
     べての英文字を大文字に変換する。この関数は‘nil’をリ
     ターンする。

     インタラクティブに‘upcase-region’が呼び出された際は
     、STARTとENDはポイントとマークになり、小さいほうが
     先になる。

 -- Command: capitalize-word count
     この関数は、ポイントの後のCOUNT単語をcapitalizeして
     、変換後その後にポイントを移動する。capitalizeとは
     、各単語の先頭を大文字、残りを小文字に変換すること
     を意味する。COUNTが負なら、この関数は前の−COUNT単語
     をcapitalizeするが、ポイントは移動しない。値は
     ‘nil’。

     ポイントが単語の中間にある場合、ポイントの前にある
     単語部分は、前方に移動する際は無視される。そして残
     りの部分が単語全体として扱われる。

     インタラクティブに‘capitalize-word’が呼び出された際
     は、COUNTに数プレフィクス引数がセットされる。

 -- Command: downcase-word count
     この関数は、ポイントの後のCOUNT単語を小文字に変換し
     て、変換後その後にポイントを移動する。COUNTが負なら
     、この関数は前の−COUNT単語を小文字に変換するが、ポ
     イントは移動しない。値は‘nil’。

     インタラクティブに‘downcase-word’が呼び出された際は
     、COUNTに数プレフィクス引数がセットされる。

 -- Command: upcase-word count
     この関数は、ポイントの後のCOUNT単語を大文字に変換し
     て、変換後その後にポイントを移動する。COUNTが負なら
     、この関数は前の−COUNT単語を小文字に変換するが、ポ
     イントは移動しない。値は‘nil’。

     インタラクティブに‘upcase-word’が呼び出された際は、
     COUNTに数プレフィクス引数がセットされる。


File: elisp,  Node: Text Properties,  Next: Substitution,  Prev: Case Changes,  Up: Text

31.19 Text Properties
=====================

バッファーや文字列内の各文字位置は、シンボルにおけるプロ
パティリスト(*note Property Lists::を参照)のように、“テ
キストプロパティリスト(text property list)”をもつことが
できます。特定の位置の特定の文字に属するプロパティ、たと
えばこのセンテンス先頭の文字‘T’(訳注: 翻訳前のセンテンス
は"The properties belong to a ..."で始まる)、または
‘foo’の最初の‘o’など、もし同じ文字が異なる2箇所に存在す
る場合、2つの文字は一般的に異なるプロパティをもちます。

   それぞれのプロパティには、名前と値があります。どちら
も任意のLispオブジェクトをもつことができますが、名前は通
常はシンボルです。典型的には、それぞれのプロパティ名シン
ボルは、特定の目的のために使用されます。たとえば、テキス
トプロパティ‘face’は、文字を表示するためのフェイスを指定
します(*note Special Properties::を参照)。名前を指定して
それに対応する値を尋ねるのが、このプロパティリストにアク
セスするための通常の方法です。

   ある文字が‘category’プロパティをもつ場合は、それをそ
の文字の“プロパティカテゴリー(property category)”と呼び
ます。これはシンボルであるべきです。そのシンボルのプロパ
ティは、その文字のプロパティにたいしてデフォルトとしての
役割をもちます。

   文字列とバッファーの間でテキストをコピーには、文字と
ともにそのプロパティが保持されます。これには
‘substring’、‘insert’、‘buffer-substring’のようなさまざ
まな関数が含まれます。

* Menu:

* Examining Properties::     単一の文字のプロパティを調べる。
* Changing Properties::      テキスト範囲のプロパティをセットする。
* Property Search::          プロパティが値を変更する場所の検索。
* Special Properties::       特別な意味をもつ特定のプロパティ。
* Format Properties::        テキストのフォーマットを表すプロパティ。
* Sticky Properties::        挿入されたテキストが隣接するテキストからプロパティを取得する方法。
* Lazy Properties::          テキストが調べられる際のみ、ものぐさな方法でテキストプロパティを計算する。
* Clickable Text::           テキストプロパティを使用して、テキストリージョンがクリック時に何か行うようにする。
* Fields::                   バッファー内にフィールドを定義する‘field’プロパティ。
* Not Intervals::            テキストプロパティがLispから可視なテキスト間隔をもたない理由。


File: elisp,  Node: Examining Properties,  Next: Changing Properties,  Up: Text Properties

31.19.1 Examining Text Properties
---------------------------------

テキストプロパティを調べるもっともシンプルな方法は、特定
の文字の特定のプロパティの値を尋ねる方法です。これを行う
には、‘get-text-property’を使用します。ある文字のプロパ
ティリスト全体を取得するには、‘text-properties-at’を使用
します。複数の文字のプロパティを一度に調べる関数について
は、*note Property Search::を参照してください。

   以下の関数は、文字列とバッファーの両方を処理します。
バッファー内の位置は1から始まりますが、文字列内の位置は
0から始まることに留意してください。

 -- Function: get-text-property pos prop &optional
          object
     この関数は、OBJECT(バッファーまたは文字列)内の位置
     POSの後にある文字のプロパティPROPの値をリターンする
     。引数OBJECTはオプションで、デフォルトはカレントバ
     ッファー。

     厳密な意味でPROPプロパティが存在しないが、その文字
     がシンボルであるようなプロパティカテゴリーをもつな
     ら、‘get-text-property’はそのシンボルのPROPプロパテ
     ィをリターンする。

 -- Function: get-char-property position prop &optional
          object
     この関数は‘get-text-property’と似ているが、まずオー
     バーレイをチェックして、次にテキストプロパティをチ
     ェックする点が異なる。*note Overlays::を参照のこと
     。

     引数OBJECTは文字列、バッファー、あるいはウィンドウ
     かもしれない。ウィンドウならそのウィンドウ内に表示
     されているバッファーのテキストプロパティとオーバー
     レイが使用されるが、そのウィンドウにたいしてアクテ
     ィブなオーバーレイだけが考慮される。OBJECTがバッフ
     ァーなら、そのバッファー内のオーバーレイがまず優先
     順に考慮され、その後にテキストプロパティが考慮され
     る。OBJECTが文字列の場合？文字列は決してオーバーレ
     イをもたないので、テキストプロパティだけが考慮され
     る。

 -- Function: get-pos-property position prop &optional
          object
     この関数は‘get-char-property’と似ているが、
     POSITION(すぐ右)にある文字のプロパティのかわりに、
     プロパティのstickiness(粘着性)とオーバーレイの
     advancement(前向的)なセッティングに注意を払う点が異
     なる。

 -- Function: get-char-property-and-overlay position
          prop &optional object
     これは‘get-char-property’と似ているが、そのプロパテ
     ィ値が由来するオーバーレイについて追加情報を与える
     点が異なる。

     その値はCARがプロパティ値であるようなコンスセルで、
     同じ引数により‘get-char-property’がリターンするであ
     ろう値と同じである。CDRはそのプロパティが見つかった
     箇所のオーバーレイ、またはテキストプロパティとして
     見つかった場合や見つからなかった場合は‘nil’である。

     POSITIONがOBJECTの終端なら、CARとCDRの値はどちらも
     ‘nil’になる。

 -- Variable: char-property-alias-alist
     この変数は、プロパティ名と代替となるプロパティ名リ
     ストをマップするalistを保持する。文字があるプロパテ
     ィにたいして直接値を指定しなければ、順に代替プロパ
     ティ名が調べられ、最初の非‘nil’値が使用される。この
     変数は‘default-text-properties’より優先され、この変
     数より‘category’プロパティが優先される。

 -- Function: text-properties-at position &optional
          object
     この関数は、文字列またはバッファーOBJECT内の位置
     POSITIONにある文字のプロパティリスト全体をリターン
     する。OBJECTが‘nil’なら、デフォルトはカレントバッフ
     ァーとなる。

 -- Variable: default-text-properties
     この変数は、テキストプロパティにたいしてデフォルト
     値を与えるプロパティリストを保持する。あるプロパテ
     ィにたいして文字が直接、あるいはカテゴリーシンボル
     または‘char-property-alias-alist’を通じて値を指定し
     ないときは常に、このリストに格納された値がかわりに
     使用される。以下は例である:

          (setq default-text-properties '(foo 69)
                char-property-alias-alist nil)
          ;; 文字1は自身のプロパティをもたない
          (set-text-properties 1 2 nil)
          ;; 取得される値はデフォルト値である
          (get-text-property 1 'foo)
               ⇒ 69


File: elisp,  Node: Changing Properties,  Next: Property Search,  Prev: Examining Properties,  Up: Text Properties

31.19.2 Changing Text Properties
--------------------------------

プロパティを変更するプリミティブは、バッファーまたは文字
列内の指定されたテキスト範囲に適用されます。関数
‘set-text-properties’(セクションの最後を参照)は、その範
囲内のテキストのプロパティリスト全体をセットします。名前
を指定することにより特定のプロパティだけを追加、変更、削
除するのにも、より有用です。

   テキストプロパティはバッファー(または文字列)のコンテ
ンツの一部とみなされ、かつスクリーン上でのバッファーの見
栄えに影響を与えることができるので、バッファー内のテキス
トプロパティの変更はすべて、バッファーを変更済みとマーク
します。バッファーテキストプロパティの変更も、アンドゥで
きます(*note Undo::を参照)。バッファー内の位置は1から始
まりますが、文字列内の位置は0から始まります。

 -- Function: put-text-property start end prop value
          &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTと
     ENDの間のテキストにたいして、プロパティPROPに
     VALUEをセットする。OBJECTが‘nil’なら、デフォルトは
     カレントバッファーである。

 -- Function: add-text-properties start end props
          &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTと
     ENDの間のテキストにたいして、テキストプロパティを追
     加またはオーバーライドする。OBJECTが‘nil’なら、デフ
     ォルトはカレントバッファーである。

     引数PROPSは、追加するプロパティを指定する。これはプ
     ロパティリストの形式(*note Property Lists::を参照
     )、つまりプロパティ名と対応する値が交互に出現するよ
     うな要素を含むリストであること。

     関数が実際に何らかのプロパティの値を変更したら‘t’、
     それ以外(PROPSが‘nil’、またはプロパティの値がテキス
     ト内のプロパティの値と一致している場合)は‘nil’がリ
     ターン値となる。

     たとえば、以下はテキストの範囲に‘comment’と‘face’の
     プロパティをセットする例である:

          (add-text-properties START END
                               '(comment t face highlight))

 -- Function: remove-text-properties start end props
          &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTと
     ENDの間のテキストから、指定されたテキストプロパティ
     を削除する。OBJECTが‘nil’なら、デフォルトはカレント
     バッファーとなる。

     引数PROPSは、削除するプロパティを指定する。これはプ
     ロパティリストの形式(*note Property Lists::を参照
     )、つまりプロパティ名と対応する値が交互に出現するよ
     うな要素を含むリストであること。しかし問題となるの
     は名前であり、付随する値は無視される。たとえば
     ‘face’プロパティを削除するには、以下のようにすれば
     よい。

          (remove-text-properties START END '(face nil))

     関数が実際に何らかのプロパティの値を変更したら‘t’、
     それ以外(PROPSが‘nil’、または指定されたテキスト内に
     それらのプロパティをもつ文字がない場合)は‘nil’がリ
     ターン値となる。

     特定のテキストからすべてのテキストプロパティを削除
     するには、新たなプロパティリストに‘nil’を指定して、
     ‘set-text-properties’を使用すればよい。

 -- Function: remove-list-of-text-properties start end
          list-of-properties &optional object
     ‘remove-text-properties’と同様だが、
     LIST-OF-PROPERTIESがプロパティ名と値が交互になった
     リストではなく、プロパティ名だけのリストである点が
     異なる。

 -- Function: set-text-properties start end props
          &optional object
     この関数は、文字列またはバッファーOBJECT内のSTARTか
     らENDの間のテキストにたいするテキストプロパティリス
     トを、完全に置き換える。OBJECTが‘nil’なら、デフォル
     トはカレントバッファーとなる。

     引数PROPSは新たなプロパティリスト。これはプロパティ
     メジャーと対応する値が交互となるような要素のリスト
     であること。

     ‘set-text-properties’のリターン後は、指定された範囲
     内のすべての文字は、等しいプロパティをもつ。

     PROPSが‘nil’なら、指定されたテキスト範囲からすべて
     のプロパティを取り除く効果がある。以下は例である:

          (set-text-properties START END nil)

     この関数のリターン値を信用してはならない。

 -- Function: add-face-text-property start end face
          &optional appendp object
     この関数はSTARTとENDの間のテキストのテキストプロパ
     ティ‘face’にフェイスFACEを追加するよう動作する。
     FACEはフェイス名もしくはanonymousフェイス(anonymous
     face: 無名フェイス)のような、‘face’プロパティ(*note
     Special Properties::を参照)にたいして有効な値である
     こと(*note Faces::を参照)。

     リージョン内の任意のテキストがすでに非‘nil’の
     ‘face’プロパティをもつ場合、それらのフェイスは保た
     れる。 If any text in the region already has a non-
     property, those face(s) are retained. この関数は
     ‘face’プロパティに、最初の要素(デフォルト)がFACE、
     以前に存在していたフェイスが残りの要素であるような
     、フェイスのリストをセットする。オプション引数
     APPENDが非‘nil’なら、FACEはかわりにリストの最後に追
     加される。フェイスリスト内では、各属性にたいして最
     初に出現する値が優先されることに注意。

     たとえば以下のコードでは、STARTとENDの間のテキスト
     に、グリーン斜体のフェイスを割り当てるだろう:

          (add-face-text-property START END 'italic)
          (add-face-text-property START END '(:foreground "red"))
          (add-face-text-property START END '(:foreground "green"))

     オプション引数OBJECTが非‘nil’なら、それはカレントバ
     ッファーではなく、動作するバッファーまたは文字列を
     指定する。OBJECTが文字列なら、STARTとENDは0基準で文
     字列内をインデックス付けする。

   文字列にテキストプロパティを付するもっとも簡単な方法
は、‘propertize’です:

 -- Function: propertize string &rest properties
     この関数は、テキストプロパティPROPERTIESを追加した
     、STRINGのコピーをリターンする。これらのプロパティ
     は、リターンされる文字列内のすべての文字に適用され
     る。以下は、‘face’プロパティと‘mouse-face’プロパテ
     ィとともに文字列を構築する例である:

          (propertize "foo" 'face 'italic
                      'mouse-face 'bold-italic)
               ⇒ #("foo" 0 3 (mouse-face bold-italic face italic))

     文字列のさまざまな部分に異なるプロパティをputするん
     は、それぞれの部分を‘propertize’で構築して、
     ‘concat’でそれらを結合すればよい:

          (concat
           (propertize "foo" 'face 'italic
                       'mouse-face 'bold-italic)
           " and "
           (propertize "bar" 'face 'italic
                       'mouse-face 'bold-italic))
               ⇒ #("foo and bar"
                           0 3 (face italic mouse-face bold-italic)
                           3 8 nil
                           8 11 (face italic mouse-face bold-italic))

   プロパティではなくバッファーからテキストをコピーする
関数‘buffer-substring-no-properties’については、*note
Buffer Contents::を参照してください。


File: elisp,  Node: Property Search,  Next: Special Properties,  Prev: Changing Properties,  Up: Text Properties

31.19.3 Text Property Search Functions
--------------------------------------

テキストプロパティの通常の使用では、ほとんどの場合は複数
または多くの連続する文字が、同じ値のプロパティをもちます
。文字を1つずつ調べるプログラムを記述するよりも、同じプ
ロパティ値をもつテキスト塊(chunks of text)を処理するほう
が、より高速です。

   以下は、これを行うことに使用できる関数です。これらは
、プロパティ値の比較に‘eq’を使用します。すべての関数にお
いて、OBJECTのデフォルトはカレントバッファーです。

   より良いパフォーマンスのためには、特に単一のプロパテ
ィを検索する関数においては、LIMIT引数の使用が重要です。
そうしないと、興味のあるプロパティが変化しない場合に、バ
ッファー終端までのスキャンに長い時間を要するでしょう。

   これらの関数はポイントを移動しません。そのかわりに位
置(または‘nil’)をリターンします。ポイントは常に文字と文
字の間にあることを思い出してください。これらの関数により
リターンされる位置は、異なるプロパティをもつ、2つの文字
の間にあります。

 -- Function: next-property-change pos &optional object
          limit
     この関数は文字列またはバッファーOBJECT内の位置POSか
     ら、何らかのテキストプロパティの変化が見つかるまで
     、テキストを前方にスキャンして、変化のあった位置を
     リターンする。別の言い方をすると、POSの直後の文字と
     プロパティが等しくない、POSの先にある最初の文字の位
     置をリターンする。

     LIMITが非‘nil’なら、スキャンは位置LIMITで停止する。
     そのポイントより前にプロパティが変化しなければ、こ
     の関数はLIMITをリターンする。

     プロパティがOBJECT終端まで変化せず、かつLIMITが
     ‘nil’なら、値は‘nil’となる。値が非‘nil’なら、それは
     POS以上の位置である。LIMITがPOSと等しいときのみ、値
     はPOSになる。

     以下は、すべてのプロパティが定数であるようなテキス
     ト塊によりバッファーをスキャンする方法の例である:

          (while (not (eobp))
            (let ((plist (text-properties-at (point)))
                  (next-change
                   (or (next-property-change (point) (current-buffer))
                       (point-max))))
              ポイントからNEXT-CHANGEへテキストを処理...
              (goto-char next-change)))

 -- Function: previous-property-change pos &optional
          object limit
     これは‘next-property-change’と似ているが、POSから前
     方ではなく後方にスキャンする点が異なる。値が非
     ‘nil’なら、それはPOS以下の位置である。LIMITとPOSが
     等しい場合のみ、POSをリターンする。

 -- Function: next-single-property-change pos prop
          &optional object limit
     この関数はプロパティPROP内の変化についてテキストを
     スキャンして、変化があった位置をリターンする。この
     スキャンは、文字列またはバッファーOBJECT内の位置
     POSから、前方に行われる。別の言い方をすると、POSの
     直後の文字とプロパティPROPが等しくない、POSの先にあ
     る最初の文字の位置をリターンする。

     LIMITが非‘nil’なら、スキャンは位置LIMITで終了する。
     そのポイントより前にプロパティの変化がなければ、
     ‘next-single-property-change’はLIMITをリターンする
     。

     プロパティがOBJECT終端まで変化せず、かつLIMITが
     ‘nil’なら、値は‘nil’となる。値が非‘nil’なら、それは
     POS以上の位置である。LIMITがPOSと等しいときのみ、値
     はPOSになる。

 -- Function: previous-single-property-change pos prop
          &optional object limit
     これは‘next-single-property-change’と似ているが、
     POSから前方ではなく後方にスキャンする点が異なる。値
     が非‘nil’なら、それはPOS以下の位置である。LIMITと
     POSが等しい場合のみ、POSをリターンする。

 -- Function: next-char-property-change pos &optional
          limit
     ‘next-property-change’と似ているが、これはテキスト
     プロパティと同様オーバーレイも考慮し、バッファー終
     端より前に変化が見つからなければ、‘nil’ではなくバッ
     ファー位置の最大をリターンする点が異なる(この点では
     ‘next-property-change’よりも対応するオーバーレイ関
     数‘next-overlay-change’と似る)。この関数はカレント
     バッファーだけを処理するので、OBJECTオペランドは存
     在しない。これは、いずれかの種類のプロパティが変化
     した、次のアドレスをリターンする。

 -- Function: previous-char-property-change pos
          &optional limit
     これは‘next-char-property-change’と似ているが、
     POSから前方ではなく後方へスキャンすること、および変
     化が見つからなければバッファー位置の最小をリターン
     する点が異なる。

 -- Function: next-single-char-property-change pos prop
          &optional object limit
     ‘next-single-property-change’と似ているが、これはテ
     キストプロパティと同様オーバーレイも考慮し、
     OBJECT終端より前に変化が見つからなければ、‘nil’では
     なくOBJECT内の有効な位置の最大をリターンする点が異
     なる。‘next-char-property-change’と異なり、、この関
     数はOBJECTオペランドを_もつ_。OBJECTが非バッファー
     なら、テキストプロパティだけが考慮される。

 -- Function: previous-single-char-property-change pos
          prop &optional object limit
     これは‘next-single-char-property-change’と似ている
     が、POSから前方ではなく後方へスキャンすること、およ
     び変化が見つからなければOBJECT内の有効な位置の最小
     をリターンする点が異なる。

 -- Function: text-property-any start end prop value
          &optional object
     この関数は、STARTとENDの間に少なくともプロパティ
     PROPに値VALUEをもつ文字が1つあれば、非‘nil’をリター
     ンする。より正確には、これはそのような最初の文字の
     位置をリターンし、それ以外は‘nil’をリターンする。

     5つ目のオプション引数OBJECTは、スキャンする文字列ま
     たはバッファーを指定する。位置はOBJECTにたいして相
     対的である。OBJECTのデフォルトは、カレントバッファ
     ー。

 -- Function: text-property-not-all start end prop value
          &optional object
     この関数は、STARTとENDの間に少なくともプロパティ
     PROPに値VALUEをもたない文字が1つあれば、非‘nil’をリ
     ターンする。より正確には、これはそのような最初の文
     字の位置をリターンし、それ以外は‘nil’をリターンする
     。

     5つ目のオプション引数OBJECTは、スキャンする文字列ま
     たはバッファーを指定する。位置はOBJECTにたいして相
     対的である。OBJECTのデフォルトは、カレントバッファ
     ー。


File: elisp,  Node: Special Properties,  Next: Format Properties,  Prev: Property Search,  Up: Text Properties

31.19.4 Properties with Special Meanings
----------------------------------------

以下は、ビルトインで特別な意味をもつテキストプロパティ名
のテーブルです。以降のセクションでは、フィルとプロパティ
継承を制御する特別なプロパティ名をいくつか追加でリストし
ています。これ以外のすべての名前は特別な意味をもたず、自
由に使用できます。

   注意: プロパティ‘composition’、‘display’、
‘invisible’、‘intangible’はすべてのEmacsコマンドの後に、
好ましい箇所にポイントを移動させることもできます。*note
Adjusting Point::を参照してください。

‘category’
     ある文字が‘category’プロパティをもつ場合は、それを
     その文字の“プロパティカテゴリー(property
     category)”と呼びます。これはシンボルであること。こ
     のシンボルのプロパティは、その文字のプロパティのデ
     フォルトとしての役割をもつ。

‘face’
     ‘face’プロパティはその文字の外観を制御する(*note
     Faces::を参照)。このプロパティの値は、以下をとるこ
     とができる:

        • フェイス名(シンボルか文字列)。

        • anonymousフェイス: ‘(KEYWORD VALUE ...)’形式の
          プロパティリスト。KEYWORDはそれぞれフェイス属
          性名で、VALUEはその属性の値。

        • フェイスのリスト。各リスト要素はフェイス名か
          anonymousフェイスであること。これはリストされ
          た各フェイス属性を集計したフェイスを指定する。
          このリスト内で最初にあるフェイスが、より高い優
          先度をもつ。

        • ‘(foreground-color . COLOR-NAME)’または
          ‘(background-color . COLOR-NAME)’形式のコンス
          セル。これは‘(:foreground COLOR-NAME)’や
          ‘(:background COLOR-NAME)’と同じようにフォアグ
          ラウンドまたはバックグラウンドを指定する。この
          形式は後方互換のためだけにサポートされており、
          無視するべきである。

     Font Lockモード(*note Font Lock Mode::を参照)はほと
     んどのバッファーにおいて、コンテキストにもとづき文
     字の‘face’プロパティを動的に更新することにより機能
     する。

     ‘add-face-text-property’関数は、このプロパティをセ
     ットする便利な手段を提供する。*note Changing
     Properties::を参照のこと。

‘font-lock-face’
     このプロパティは、Font Lockモードが配下にあるテキス
     トに適用すべき‘face’プロパティにたいして値を指定す
     る。これはFont Lockモードに使用されるフォント表示手
     法の1つであり、独自のハイライトを実装する特別なモー
     ドにたいして有用である。*note Precalculated
     Fontification::を参照のこと。Font Lockモードが無効
     なら、‘font-lock-face’に効果はない。

‘mouse-face’
     このプロパティは、文字上または近傍にマウスがあると
     き、‘face’のかわりに使用される。この目的にたいして
     “近傍”とは、文字間のすべてのテキスト、およびマウス
     が同じ‘mouse-face’プロパティの値をもつことを意味す
     る。

     Emacsはテキストサイズ(‘:height’、‘:weight’、
     ‘:slant’)を変更する‘mouse-face’プロパティ由来の属性
     すべてを無視する。これらの属性は、ハイライトされて
     いないテキストと常に等しい。

‘fontified’
     このプロパティはそのテキストの表示準備が整っている
     かどうかを告げる。‘nil’ならEmacsの再表示ルーチンは
     、バッファーの該当部分を表示する前に、準備のために
     ‘fontification-functions’(*note Auto Faces::を参照
     )の中の関数を呼び出す。これはフォントロックのコード
     の“just in time”により、内部的に使用される。

‘display’
     このプロパティは、テキストが表示される方法を変更す
     る、さまざまな機能をアクティブ化する。たとえばこれ
     によりテキスト外観を縦長(taller)または縦短(short)し
     たり、高く(higher)または低く(lower)、太く(wider)ま
     たは細く(narrower)したり、あるいはイメージに置き換
     えることができる。*note Display Property::を参照の
     こと。

‘help-echo’
     テキストが‘help-echo’プロパティに文字列をもつ場合、
     そのテキスト上にマウスを移動した際に、Emacsはエコー
     エリアかツールチップウィンドウ(*note
     (emacs)Tooltips::を参照)にその文字列を表示する。

     ‘help-echo’プロパティの値が関数なら、その関数は
     WINDOW、OBJECT、POSの3つの引数で呼び出され、ヘルプ
     文字列、または存在しない場合は‘nil’をリターンするこ
     と。1つ目の引数WINDOWは、そのヘルプが見つかったウィ
     ンドウである。2つ目の引数OBJECTは、‘help-echo’プロ
     パティをもつバッファー、オーバーレイ、または文字列
     である。POS引数は以下のとおり:

        • OBJECTがバッファーなら、POSはそのバッファー内
          の位置。
        • OBJECTがオーバーレイなら、そのオーバーレイは
          ‘help-echo’プロパティをもち、POSはそのオーバー
          レイのバッファー内の位置である。
        • OBJECTが文字列(オーバーレイ文字列、または
          ‘display’プロパティにより表示された文字列)なら
          、POSはその文字列内の位置。

     ‘help-echo’プロパティの値が関数と文字列のいずれでも
     ない場合、それはヘルプ文字列を得るために評価される
     。

     変数‘show-help-function’をセットすることにより、ヘ
     ルプテキストが表示される方法を変更できる(*note Help
     display::を参照)。

     この機能はモードライン内、およびその他のアクティブ
     テキストにたいして使用される。

‘keymap’
     ‘keymap’プロパティは、コマンドにたいして追加のキー
     マップを指定する。このキーマップを適用する際は、マ
     イナーモードキーマップおよびバッファーのローカルマ
     ップの前に、キー照合にこのマップが使用される。*note
     Active Keymaps::を参照のこと。プロパティ値がシンボ
     ルなら、そのシンボルの関数定義がキーマップとして使
     用される。

     ポイントの前の文字のプロパティの値は、それが非
     ‘nil’でrear-stickyであり、かつポイントの後の文字の
     プロパティ値が非‘nil’でfront-stickyなら適用される
     (マウスクリックではポイント位置のかわりにクリック位
     置が使用される)。

‘local-map’
     このプロパティは‘keymap’と同じように機能するが、こ
     れはそのバッファーのローカルマップの_かわりに_使用
     するキーマップを指定する点が異なる。ほとんど(もしか
     するとすべて)の目的にたいしては、‘keymap’を使用する
     ほうが良いだろう。

‘syntax-table’
     ‘syntax-table’プロパティは、特定の文字にたいして、
     どのシンタックステーブルがオーバーライドするかを告
     げる。*note Syntax Properties::を参照のこと。

‘read-only’
     ある文字がプロパティ‘read-only’をもつなら、その文字
     の変更は許可されない。これを行おうとするすべてのコ
     マンドは、‘text-read-only’エラーを受け取る。プロパ
     ティの値が文字列なら、その文字列がエラーメッセージ
     として使用される。

     read-only文字に隣接する箇所への挿入は、そこに通常の
     テキストの行うことがstickinessによる‘read-only’プロ
     パティを継承するなら、エラーとなる。つまり
     stickinessを制御することにより、read-onlyテキストに
     隣接する挿入の権限を制御することができる。*note
     Sticky Properties::を参照のこと。

     プロパティ変更はバッファー変更とみなされるので、特
     別なトリック(‘inhibit-read-only’を非‘nil’にバインド
     してからプロパティを削除する)を知らないかぎり、
     ‘read-only’プロパティを取り除くことは不可能である。
     *note Read Only Buffers::を参照のこと。

‘invisible’
     非‘nil’の‘invisible’プロパティにより、スクリーン上
     で文字を不可視にできる。詳細は*note Invisible
     Text::を参照されたい。

‘intangible’
     連続する文字のグループが非‘nil’の等しい
     ‘intangible’プロパティをもつなら、それらの文字の間
     にポイントを置くことは不可能である。そのグループ内
     に前方へポイントの移動を試みると、ポイントは実際に
     はそのグループの終端に移動する。そのグループ内に後
     方へポイントの移動を試みると、ポイントは実際にはそ
     のグループの先頭に移動する。

     連続する文字のグループが非‘nil’の等しくない
     ‘intangible’プロパティをもつなら、それらの文字は個
     別のグループに属し、各グループは上述のように別のグ
     ループとして扱われる。

     変数‘inhibit-point-motion-hooks’が非‘nil’なら、
     ‘intangible’プロパティは無視される。

     注意せよ: このプロパティは非常に低レベルで処理され
     、予想害の方法により多くのコードに影響する。そのた
     め使用に際しては特別な注意を要する。誤った使用方法
     としては、不可視のテキストにintangibleプロパティ
     wpeをputするのが一般的であり、コマンドループは各コ
     マンドの終わりに不可視テキストの外部へポイントを移
     動するだろうから、これは実際には必要ない。*note
     Adjusting Point::を参照されたい。

‘field’
     同じ‘field’プロパティをもつ連続する文字は、“フィー
     ルド”を構成する。‘forward-word’や
     ‘beginning-of-line’を含むいくつかの移動関数は、フィ
     ールド境界で移動を停止する。*note Fields::を参照の
     こと。

‘cursor’
     カーソルは通常、カレントバッファー位置にあるオーバ
     ーレイ、およびテキストプロパティ文字列の先頭か終端
     に表示される。文字に非‘nil’の‘cursor’テキストプロパ
     ティを与えることにより、それら文字列内の、任意の望
     む文字にカーソルを置くことができる。加えて
     ‘cursor’プロパティの値が整数なら、それはカーソルが
     その文字上に表示されるように、オーバーレイまたは
     ‘display’プロパティが始まる位置から数えたバッファー
     の文字位置の数字を指定する。特に、ある文字の
     ‘cursor’プロパティの値が数字Nなら、カーソルは範囲
     ‘[OVPOS..OVPOS+N)’内の任意のバッファー位置にあるそ
     の文字上に表示されるだろう。ここでOVPOSは
     ‘overlay-start’(*note Managing Overlays::を参照)に
     より与えられるオーバーレイ開始位置、またはそのバッ
     ファー内で‘display’プロパティが始まる位置である。

     他の言い方をすると、文字列の非‘nil’値の‘cursor’プロ
     パティをもつ文字は、カーソルが表示される文字である
     。このプロパティの値は、カーソルを表示するバッファ
     ーの位置を告げる。値が整数なら、オーバーレイまたは
     ‘display’プロパティの始まりからN後ろの位置までの間
     にポイントがあるとき、カーソルはそこに表示される。
     値がそれ以外の非‘nil’なら、ポイントが‘display’プロ
     パティの先頭、または‘overlay-start’の位置だけに表示
     される。

     バッファーに多くのオーバーレイ文字列(*note
     before-string: Overlay Properties.を参照)や文字列で
     あるような‘display’プロパティがある場合、それらの文
     字列を走査する間にカーソルを置く箇所をEmacsに合図す
     るために、‘cursor’プロパティを使用するのは、よいア
     イデアである。これはLispプログラムやユーザーがカー
     ソルを配したい箇所で、ディスプレイエンジンと直接通
     信する。

‘pointer’
     これはそのテキストやイメージ上にマウスポインターが
     あるときの、特定のマウスシェイプを指定する。利用で
     きるポインターシェイプについては、*note Pointer
     Shape::を参照されたい。

‘line-spacing’
     改行は、改行で終わるディスプレイ行の高さを制御する
     テキストプロパティまたはオーバーレイプロパティ
     ‘line-spacing’をもつことができる。このプロパティ値
     は、デフォルトのフレーム行スペーシングと、バッファ
     ーローカル変数‘line-spacing’をオーバーライドする。
     *note Line Height::を参照のこと。

‘line-height’
     改行は、改行で終わるディスプレイ行のトータル高さを
     制御するテキストプロパティ、またはオーバーレイプロ
     パティ‘line-height’をもつことができる。*note Line
     Height::を参照のこと。

‘wrap-prefix’
     テキストが‘wrap-prefix’プロパティをもつなら、それが
     定義するプレフィクスは、テキストラッピング(text
     wrapping: テキスト折り返し)に由来するすべての継続行
     の先頭に、表示時に追加されるだろう(行が切り詰められ
     た場合、wrap-prefixが使用されることはない)。これは
     文字列、イメージ(*note Other Display Specs::を参照
     )、あるいはディスプレイプロパティ‘:width’または
     ‘:align-to’(*note Specified Space::を参照)により指
     定されて空白文字範囲かもしれない。

     wrap-prefixはバッファーローカル変数‘wrap-prefix’を
     使用して、バッファー全体にも指定され得る(が、
     ‘wrap-prefix’テキストプロパティは‘wrap-prefix’変数
     の値より優先される)。*note Truncation::を参照のこと
     。

‘line-prefix’
     テキストが‘line-prefix’プロパティをもつなら、それが
     定義するプレフィクスは表示時に、すべての非継続行の
     先頭に追加されるだろう。これは文字列、イメージ
     (*note Other Display Specs::を参照)、あるいはディス
     プレイプロパティ‘:width’または‘:align-to’(*note
     Specified Space::を参照)により指定されて空白文字範
     囲かもしれない。

     line-prefixはバッファーローカル変数‘line-prefix’を
     使用して、バッファー全体にも指定され得る(が、
     ‘line-prefix’テキストプロパティは‘line-prefix’変数
     の値より優先される)。*note Truncation::を参照のこと
     。

‘modification-hooks’
     ある文字がプロパティ‘modification-hooks’をもつなら
     、その値は関数のリストであること。その文字の変更に
     より、実際の変更前にそれらの関数すべてが呼び出され
     る。それぞれの関数は、変更されようとするバッファー
     部分の先頭と終端という、2つの引数を受け取る。特定の
     modificationフック関数が、単一のプリミティブにより
     変更されつつある複数の文字に出現する場合は、その関
     数が呼び出される回数を予測することはできない。さら
     に挿入は既存の文字を変更しないので、このフックは文
     字の削除、他の文字への置換、またはそれらのテキスト
     プロパティ変更時のみ実行されるだろう。

     これらの関数がバッファーを変更する場合には、これら
     のフックを呼び出す内部的メカニズムの混乱を避けるた
     めに、それらの関数はそれを行う前後に
     ‘inhibit-modification-hooks’を‘t’にバインドするべき
     である。

     オーバーレイも‘modification-hooks’プロパティをサポ
     ートするが、詳細は若干異なる(*note Overlay
     Properties::を参照)。

‘insert-in-front-hooks’
‘insert-behind-hooks’
     あるバッファーへの挿入操作は、後続文字の
     ‘insert-in-front-hooks’プロパティ、および先行文字の
     ‘insert-behind-hooks’プロパティにリストされる関数も
     呼び出す。これらの関数は、挿入されるテキストの先頭
     と終端という、2つの引数を受け取る。関数は、優先され
     る実際の挿入が行われた_後に_呼び出される。

     バッファー内のテキスト変更。に呼び出される他のフッ
     クについては、*note Change Hooks::も参照されたい。

‘point-entered’
‘point-left’
     スペシャルプロパティ‘point-entered’および
     ‘point-left’は、ポイント移動をリポートするフック関
     数を記録する。ポイントを移動するたびに、Emacsは以下
     の2つのプロパティ値を比較する:

        • 古い位置の後の文字の‘point-left’プロパティ。
        • 新しい位置の後の文字の‘point-entered’プロパテ
          ィ。

     これらの2つの値が異なる場合、(‘nil’でなければ)古い
     ポイント値と新しいポイント値という2つの引数とともに
     それらそれぞれ呼び出される。

     同じ比較は古い位置と新しい位置の前の文字にたいして
     も行われる。この結果、2つの‘point-left’関数(同じ関
     数かもしれない)、および/または2つの
     ‘point-entered’関数(同じ関数かもしれない)が実行され
     る可能性がある。ある場合においては、まずすべての
     ‘point-left’関数が呼び出されて、その後にすべての
     ‘point-entered’関数が呼び出される。

     さまざまなバッファー位置にたいして、そこにポイント
     を移動することなく文字を調べるために、
     ‘char-after’を使用することができる。実際のポイント
     値変更だけが、これらのフック関数を呼び出す。

     変数‘inhibit-point-motion-hooks’は‘point-left’およ
     び‘point-entered’のフック実行を抑制できる。*note
     Inhibit point motion hooks::を参照のこと。

‘composition’
     このテキストプロパティは、文字シーケンスをコンポー
     ネントから構成される単一グリフ(single glyph)として
     表示するために使用される。しかしこのプロパティの値
     自身は完全にEmacsの内部的なものであり、たとえば
     ‘put-text-property’などにより直接操作するべくではな
     い。

 -- Variable: inhibit-point-motion-hooks
     この変数が非‘nil’のときは、‘point-left’と
     ‘point-entered’のフックは実行されず、‘intangible’プ
     ロパティは効果をもたない。この変数はグローバルにセ
     ットせず‘let’でバインドすること。

 -- Variable: show-help-function
     この変数が非‘nil’なら、それはヘルプ文字列を表示する
     ために呼び出される関数を指定する。これらは
     ‘help-echo’プロパティ、メニューヘルプ文字列(*note
     Simple Menu Items::と*note Extended Menu Items::を
     参照)、ツールバーヘルプ文字列(*note Tool Bar::を参
     照)かもしれない。指定された関数は、表示するためのヘ
     ルプ文字列という、単一の引数とともに呼び出される。
     Tooltipモード(*note (emacs)Tooltips::を参照)が、例
     を提供している。


File: elisp,  Node: Format Properties,  Next: Sticky Properties,  Prev: Special Properties,  Up: Text Properties

31.19.5 Formatted Text Properties
---------------------------------

以下のテキストプロパティは、フィルコマンドの挙動に影響を
与えます。これらはフォーマットされたテキストを表すために
使用されます。*note Filling::および*note Margins::を参照
してください。

‘hard’
     改行文字がこのプロパティをもつなら、それは“hard”改
     行である。フィルコマンドはhard改行を変更せず、それ
     らを横断して単語を移動しない。しかしこのプロパティ
     は、マイナーモード‘use-hard-newlines’が有効な場合の
     み影響を与える。*note Hard and Soft Newlines:
     (emacs)Hard and Soft Newlines.を参照のこと。

‘right-margin’
     このプロパティは、その部分のテキストのフィルにたい
     して、余分な右マージンを指定する。

‘left-margin’
     このプロパティは、その部分のテキストのフィルにたい
     して、余分な左マージンを指定する。

‘justification’
     このプロパティは、その部分のテキストのフィルにたい
     して、位置揃え(justification)のスタイルを指定する。


File: elisp,  Node: Sticky Properties,  Next: Lazy Properties,  Prev: Format Properties,  Up: Text Properties

31.19.6 Stickiness of Text Properties
-------------------------------------

自己挿入文字は通常、先行する文字と同じプロパティをもちま
す。これはプロパティの“継承(inheritance)”と呼ばれます。

   Lispプログラムは継承の有無に関わらず挿入を行うことが
でき、それは挿入プリミティブの選択に依存します。
‘insert’のような通常のテキスト挿入関数は、何もプロパティ
を継承しません。これらは挿入される文字列と正確に同じプロ
パティをもち、それ以外のプロパティはもちません。これはた
とえばkillリング外部にたいしてのように、あるコンテキスト
から他のコンテキストにテキストをコピーするプログラムにた
いして適正です。継承つきで挿入を行うためには、このセクシ
ョンで説明するスペシャルプリミティブを使用します。自己挿
入文字は、これらのプリミティブを使用するので、プロパティ
を継承するのです。

   継承つきで挿入を行う際に、_どの_プロパティがどこから
継承されるかは、“sticky(スティッキー、粘着する)”に依存し
ます。ある文字の後への挿入における、それらのモジノプロパ
ティ継承は“rear-sticky(後方スティッキー)”です。ある文字
の前への挿入における、それらのモジノプロパティ継承は
“front-sticky(前方スティッキー)”です。これら両側の
stickyが、同じプロパティにたいして異なるsticky値をもつ場
合は、前の文字の値が優先します。

   デフォルトでは、テキストプロパティはfront-stickyでは
なく、rear-stickyです。したがってデフォルトでは、すべて
のプロパティは前の文字から継承し、後の文字からは何も継承
しません。

   さまざまなテキストプロパティのstickiness(スティッキネ
ス、スティッキー性、粘着性、粘着度)はは、2つのテキストプ
ロパティ‘front-sticky’および‘rear-nonsticky’と、変数
‘text-property-default-nonsticky’で制御できます。与えら
れたプロパティにたいして異なるデフォルトを指定するために
、この変数を使用できます。テキストの任意の特定部分に特定
のプロパティsticky、または非stickyを指定するために、これ
ら2つのテキストプロパティを使用できます。

   ある文字の‘front-sticky’プロパティが‘t’なら、その文字
のすべてのプロパティはfront-stickyです。‘front-sticky’プ
ロパティがリストなら、その文字のstickyなプロパティは、名
前がそのリスト内にあるプロパティです。たとえばある文字が
値が‘(face read-only)’であるような‘front-sticky’プロパテ
ィをもつなら、その文字の前への挿入ではその文字の‘face’プ
ロパティと‘read-only’プロパティは継承できますが、他のプ
ロパティはｐ継承できません。

   ‘rear-nonsticky’は逆の方法で機能します。ほとんどのプ
ロパティはデフォルトでrear-stickyであり、
‘rear-nonsticky’プロパティはどのプロパティが
rear-sticky_ではない_かを告げますある文字の
‘rear-nosticky’プロパティが‘t’なら、その文字のすべてのプ
ロパティはrear-stickyではありません。‘rear-nosticky’プロ
パティがリストなら、その文字のstickyなプロパティは、名前
がそのリスト内に_ない_プロパティです。

 -- Variable: text-property-default-nonsticky
     この変数は、さまざまなテキストプロパティのデフォル
     トのrear-stickinessを定義するalistである。各要素は
     ‘(PROPERTY . NONSTICKINESS)’という形式をもち、これ
     は特定のテキストプロパティPROPERTYのstickinessを定
     義する。

     NONSTICKINESSが非‘nil’なら、それはプロパティ
     PROPERTYがデフォルトでrear-nonstickyであることを意
     味する。すべてのプロパティはデフォルトで
     front-nonstickyなので、これによりPROPERTYは両方向に
     たいしてデフォルトでnonstickyになる。

     テキストプロパティ‘front-sticky’および
     ‘rear-nonsticky’が使用された際には、
     ‘text-property-default-nonsticky’内で指定されたデフ
     ォルトのNONSTICKINESSより優先される。

   以下はプロパティ継承つきでテキストを挿入する関数です:

 -- Function: insert-and-inherit &rest strings
     関数‘insert’と同じように文字列STRINGSを挿入するが、
     隣接するテキストからすべてのstickyなプロパティを継
     承する。

 -- Function: insert-before-markers-and-inherit &rest
          strings
     関数‘insert-before-markers’と同じように文字列
     STRINGSを挿入するが、隣接するテキストからすべての
     stickyなプロパティを継承する。

   継承を行わない通常の挿入関数については、*note
Insertion::を参照してください。


File: elisp,  Node: Lazy Properties,  Next: Clickable Text,  Prev: Sticky Properties,  Up: Text Properties

31.19.7 Lazy Computation of Text Properties
-------------------------------------------

バッファー内のすべてのテキストにたいしてテキストプロパテ
ィを計算するかわりに、何かがテキスト範囲に依存している場
合、その際はテキストプロパティを計算するようにアレンジで
きます。

   プロパティとともにバッファーからテキストを抽出するプ
リミティブは、‘buffer-substring’です。プロパティを調べる
前に、この関数はアブノーマルフック
‘buffer-access-fontify-functions’を実行します。

 -- Variable: buffer-access-fontify-functions
     この変数は、テキストプロパティ計算用の関数のリスト
     を保持する。‘buffer-substring’がバッファーの一部の
     テキストとテキストプロパティをコピーする前に、この
     リスト内の関数すべてを呼び出す。各関数はアクセスさ
     れるバッファー範囲を指定する、2つの引数を受け取る
     (バッファーは常にカレントバッファーとなる)。

   関数‘buffer-substring-no-properties’はいずれにせよテ
キストプロパティを無視するので、これらの関数を呼び出さな
い。

   同じバッファー部分にたいして複数回フック関数が呼び出
されるのを防ぐには、変数
‘buffer-access-fontified-property’を使用できる。

 -- Variable: buffer-access-fontified-property
     この変数の値が非‘nil’なら、それはテキストプロパティ
     名として使用されるシンボルである。そのテキストプロ
     パティにたいする非‘nil’値は、“その文字にたいする他
     のテキストプロパティはすでに計算済み”であることを意
     味する。

     ‘buffer-substring’にたいして指定された範囲内のすべ
     ての文字が、このプロパティにたいする値として非
     ‘nil’をもつなら、‘buffer-substring’は
     ‘buffer-access-fontify-functions’の関数を呼び出さな
     い。それらの文字がすでに正しいテキストプロパティを
     もつとみなし、それらがすでに所有するプロパティを単
     にコピーする。

     ‘buffer-access-fontify-functions’の関数にこのプロパ
     ティ、同様に他のプロパティを処理対象の文字に追加さ
     せるのが、この機能の通常の用途である。この方法では
     、同じテキストにたいして、それらの関数が何度も呼び
     出されるのを防ぐことができる。


File: elisp,  Node: Clickable Text,  Next: Fields,  Prev: Lazy Properties,  Up: Text Properties

31.19.8 Defining Clickable Text
-------------------------------

“クリック可能テキスト(clickable text)”とは何らかの結果を
生成するために、マウス、またはキーボードコマンドを通じて
クリックできるテキストです。多くのメジャーモードがテキス
ト的なハイパーリンク、略して“リンク(link)”を実装するため
に、クリック可能テキストを使用しています。

   リンクを挿入および操作するもっとも簡単な方法は、
‘button’パッケージの使用です。*note Buttons::を参照して
ください。このセクションではテキストプロパティを使用して
、バッファー内に手作業でクリック可能テキストをセットアッ
プする方法を説明します。簡略にするために、クリック可能テ
キストを“リンク”と呼ぶことにします。

   リンクの実装には、(1)リンク上にマウスが移動した際にク
リック可能であることを示し、(2)そのリンク上の<RET>か
‘Mouse-2’で何かを行うようにして、(3)そのリンクが
‘mouse-1-click-follows-link’にしたがうよう
‘follow-link’をセットアップする、という3つのステップが含
まれます。

   クリック可能を示すためには、そのリンクのテキストに
‘mouse-face’プロパティを追加します。すると、以降Emacsは
マウスがその上に移動した際にリンクをハイライトするでしょ
う。加えて‘help-echo’テキストプロパティを使用して、ツー
ルチップかエコーエリアメッセージを定義するべきです。
*note Special Properties::を参照してください。たとえば以
下は、Diredがファイル名がクリック可能なことを示す方法で
す:

      (if (dired-move-to-filename)
          (add-text-properties
            (point)
            (save-excursion
              (dired-move-to-end-of-filename)
              (point))
            '(mouse-face highlight
              help-echo "mouse-2: visit this file in other window")))

   リンクをクリック可能にするためには、 <RET>と
‘Mouse-2’を望むアクションを行うコマンドにバインドします
。各コマンドは、リンク上から呼び出されたかチェックして、
それに応じて動作するべきです。たとえばDiredメジャーモー
ドのキーマップは、‘Mouse-2’を以下のコマンドにバインドし
ます:

     (defun dired-mouse-find-file-other-window (event)
       "In Dired, visit the file or directory name you click on."
       (interactive "e")
       (let ((window (posn-window (event-end event)))
             (pos (posn-point (event-end event)))
             file)
         (if (not (windowp window))
             (error "No file chosen"))
         (with-current-buffer (window-buffer window)
           (goto-char pos)
           (setq file (dired-get-file-for-visit)))
         (if (file-directory-p file)
             (or (and (cdr dired-subdir-alist)
                      (dired-goto-subdir file))
                 (progn
                   (select-window window)
                   (dired-other-window file)))
           (select-window window)
           (find-file-other-window (file-name-sans-versions file t)))))

このコマンドはクリックがどこで発生したかを判断するために
、関数‘posn-window’と‘posn-point’、visitするファイルの判
断に関数‘dired-get-file-for-visit’を使用します。

   マウスコマンドをメジャーモードキーマップ内でバインド
するかわりに、‘keymap’プロパティ(*note Special
Properties::を参照)を使用して、リンクテキスト内でバイン
ドできます。たとえば:

     (let ((map (make-sparse-keymap)))
       (define-key map [mouse-2] 'operate-this-button)
       (put-text-property link-start link-end 'keymap map))

この手法では、異なるリンクに異なるコマンドを簡単に定義で
きます。さらに、そのバッファー内の残りのテキストにたいし
ては、<RET>と‘Mouse-2’のグローバル定義を利用可能なまま残
すことができます。

   リンク上でのクリックにたいするEmacsの基本コマンドは、
‘Mouse-2’です。しかし他のグラフィカルなアプリケーション
との互換性のために、ユーザーがマウスを動かさずに素早くリ
ンクをクリックするという条件の下、Emacsはリンク上での
‘Mouse-1’クリックも認識します。おこ振る舞いは、ユーザー
オプション‘mouse-1-click-follows-link’により制御されます
。*note (emacs)Mouse References::を参照してください。

   ‘mouse-1-click-follows-link’にしたがうようにリンクを
セットアップするには、(1)そのテキストに‘follow-link’テキ
ストプロパティまたはオーバーレイプロパティを適用する、ま
たは(2)‘follow-link’イベントをキーマップ(‘keymap’テキス
トプロパティを通じたメジャーモードキーマップまたはローカ
ルキーマップ)にバインドするかの、いずれかを行わなければ
なりません。‘follow-link’プロパティの値、または
‘follow-link’イベントにたいするバインディングはリンクア
クションにたいする“コンディション(condition)”として機能
します。この条件は、Emacsにたいして2つのことを告げます。
それは‘Mouse-1’のクリックがそのリンクの“内側”で発生した
とみなすべき状況、そして‘Mouse-1’のクリックを何に変換す
るかを告げる“アクションコード(action code)”を計算する方
法です。そのリンクのアクション条件は、以下のうちの1つで
す:

‘mouse-face’
     コンディションがシンボル‘mouse-face’の場合、その位
     置に非‘nil’の‘mouse-face’プロパティがあれば、それは
     リンク内側の位置である。アクションコードは常に‘t’。

     以下はInfoモードが<Mouse-1>を処理する例である:

          (define-key Info-mode-map [follow-link] 'mouse-face)

関数
     コンディションが関数FUNCの場合、‘(FUNC POS)’が非
     ‘nil’に評価されれば、位置POSはリンクの内側である。
     FUNCがリターンする値は、アクションコードとして機能
     する。

     以下はpcvsがファイル名の上でのみ‘Mouse-1’によるリン
     クのフォローを有効にする方法の例である:

          (define-key map [follow-link]
            (lambda (pos)
              (eq (get-char-property pos 'face) 'cvs-filename-face)))

その他
     コンディション値がそれ以外の場合、その位置はリンク
     内側であり、そのコンディション自体がアクションコー
     ドである。(バッファー全体に適用されないように)リン
     クテキストのテキストプロパティまたはオーバーレイプ
     ロパティを通じてコンディションを適用するときのみ、
     この類のコンディションを指定すべきなのは明確である
     。

アクションコードは、‘Mouse-1’がリンクをフォローする方法
を告げます:

文字列またはベクター
     アクションコードが文字列かベクターなら、‘Mouse-1’イ
     ベントは文字列またはベクターの最初の要素に変換され
     る。つまり‘Mouse-1’クリックのアクションは、その文字
     またはシンボルのローカルまたはグローバルバインディ
     ングである。したがってアクションコードが‘"foo"’なら
     、‘Mouse-1’は‘f’に変換され、‘[foo]’なら‘Mouse-1’は
     <foo>に変換される。

その他
     その他非‘nil’のアクションコードでは、‘Mouse-1’イベ
     ントは同じ位置の‘Mouse-2’イベントに変換される。

   ‘define-button-type’で定義されるボタンをアクティブに
するように‘Mouse-1’を定義するには、そのボタンに
‘follow-link’プロパティを与えます。このプロパティの値は
、上述したリンクのアクションコンディションであること。
*note Buttons::を参照のこと。たとえば以下はHelpモードが
‘Mouse-1’を処理する例である。

     (define-button-type 'help-xref
       'follow-link t
       'action #'help-button-action)

   ‘define-widget’で定義されたウィジェットに‘Mouse-1’を
定義するには、そのウィジェットに‘:follow-link’プロパティ
を与えます。このプロパティの値は、上述したようなリンクの
アクションコンディションであるべきです。たとえば、以下は
<Mouse-1>クリックが<RET>に変換されるように、‘link’ウィジ
ェットを指定する方法の例をです:

     (define-widget 'link 'item
       "An embedded link."
       :button-prefix 'widget-link-prefix
       :button-suffix 'widget-link-suffix
       :follow-link "\C-m"
       :help-echo "Follow the link."
       :format "%[%t%]")

 -- Function: mouse-on-link-p pos
     この関数は、カレントバッファー内の位置POSがリンク上
     なら、非‘nil’をリターンする。POSは‘event-start’がリ
     ターンするようなマウスイベント位置でもよい(*note
     Accessing Mouse::を参照)。


File: elisp,  Node: Fields,  Next: Not Intervals,  Prev: Clickable Text,  Up: Text Properties

31.19.9 Defining and Using Fields
---------------------------------

フィールドとはバッファー内にある連続する文字範囲であり、
‘field’プロパティ(テキストプロパティかオーバーレイプロパ
ティ)に同じ値(‘eq’で比較)をもつことにより識別されます。
このセクションでは、フィールドの操作に利用できるスペシャ
ル関数を説明します。

   フィールドは、バッファー位置POSで指定します。各フィー
ルドはバッファー位置の範囲を含むと考えて、指定した位置は
その位置を含むフィールドを表します。

   POSの前または後の文字は同じフィールドに属し、どのフィ
ールドがPOSを含むかという疑問はありません。それらの文字
が属するフィールドが、そのフィールドです。POSがフィール
ド境界のときは、それがどのフィールドに属すかは、取り囲む
2つの文字の‘field’プロパティのstickinessに依存します
(*note Sticky Properties::を参照)。POSに挿入されたテキス
トからプロパティが継承されたフィールドが、POSを含むフィ
ールドです。

   POSに新たに挿入されたテキストが、いずれの側からも
‘field’プロパティを継承しない、異常なケースがあります。
これは前の文字の‘field’プロパティがrear-stickyでなく、後
の文字の‘field’プロパティがfront-stickyでもない場合に発
生します。このケースでは、POSは前のフィールドと後のフィ
ールドいずれにも属しません。フィールド関数はそれを、開始
と終了がPOSの空フィールドに属するものとして扱います。

   これらすべての関数では、POSが省略または‘nil’の場合は
、ポイントの値がデフォルトとして使用されます。ナローイン
グ(narrowing)が効力をもつ場合、POSはアクセス可能部分にあ
るはずです。*note Narrowing::を参照してください。

 -- Function: field-beginning &optional pos
          escape-from-edge limit
     この関数は、POSで指定されたフィールドの先頭をリター
     ンする。

     POSが自身のフィールド先頭にあり、かつ
     ESCAPE-FROM-EDGEが非‘nil’なら、POS周辺の‘field’プロ
     パティのstickinessに関わらず、リターン値は常にPOSが
     終端であるような前のフィールドの先頭になる。

     LIMITが非‘nil’なら、それはバッファーの位置である。
     そのフィールドの先頭がLIMITより前なら、かわりに
     LIMITがリターンされるだろう。

 -- Function: field-end &optional pos escape-from-edge
          limit
     この関数は、POSで指定されるフィールドの終端をリター
     ンする。

     POSが自身のフィールド終端にあり、かつ
     ESCAPE-FROM-EDGEが非‘nil’なら、POS周辺の‘field’プロ
     パティのstickinessに関わらず、リターン値は常にPOSが
     _先頭_であるような後のフィールドの終端になる。

     LIMITが非‘nil’なら、それはバッファーの位置である。
     そのフィールドの終端がLIMITより後なら、かわりに
     LIMITがリターンされるだろう。

 -- Function: field-string &optional pos
     この関数はPOSで指定されるフィールドのコンテンツを、
     文字列としてリターンする。

 -- Function: field-string-no-properties &optional pos
     この関数は、POSで指定されるフィールドのコンテンツを
     、テキストプロパティを無視して、文字列としてリター
     ンする。

 -- Function: delete-field &optional pos
     この関数は、POSで指定されるフィールドのテキストを削
     除する。

 -- Function: constrain-to-field new-pos old-pos
          &optional escape-from-edge only-in-line
          inhibit-capture-property
     この関数はNEW-POSをOLD-POSが属するフィールドに“拘束
     (constrain)”する。別の言い方をすると、これは
     OLD-POSと同じフィールド内でNEW-POSにもっとも近い位
     置をリターンする。

     NEW-POSが‘nil’なら、‘constrain-to-field’はかわりに
     ポイントの値を使用して、ポイントをリターンすること
     に加えて、その位置にポイントを移動する。

     OLD-POSが2つのフィールドの境界なら、許容できる最後
     の位置は引数ESCAPE-FROM-EDGEに依存する。
     ESCAPE-FROM-EDGEが‘nil’なら、NEW-POSは新たに文字が
     OLD-POSが挿入されたときに、継承するであろう値と
     ‘field’プロパティが等しいフィールドでなければならな
     いESCAPE-FROM-EDGEがｐ非‘nil’なら、NEW-POSは隣接す
     る2つのフィールド内のどこでも構わない。さらに、2つ
     のフィールドが特別な値‘boundary’により、他のフィー
     ルドで分割されている場合、このスペシャルフィールド
     内のすべてのポイントも、“境界上”とみなされる。

     引数なしの‘C-a’コマンドのように、特別な類の位置に後
     方へ移動して一度そこに留まるには、おそらく
     ESCAPE-FROM-EDGEにたいして‘nil’を指定するべきであろ
     う。フィールドをチェックする他の移動コマンドにたい
     しては、おそらく‘t’を渡すべきである。

     オプション引数ONLY-IN-LINEが非‘nil’、かつNEW-POSを
     通常の方法により拘束することにより異なる行へ移動す
     るような場合、NEW-POSは非拘束でリターンされる。これ
     は‘next-line’や‘beginning-of-line’のような行単位の
     移動コマンドで、それらのコマンドが正しい行へ移動で
     きる場合だけフィールド境界を尊重するようにするため
     に用いられる。

     オプション引数INHIBIT-CAPTURE-PROPERTYが非‘nil’、か
     つOLD-POSがその名前の非‘nil’なプロパティをもつなら
     、すべてのフィールド境界は無視される。

     変数‘inhibit-field-text-motion’を非‘nil’値にバイン
     ドすることにより、‘constrain-to-field’にすべてのフ
     ィールド境界を無視(何者にも拘束されることがない)さ
     せることができる。


File: elisp,  Node: Not Intervals,  Prev: Fields,  Up: Text Properties

31.19.10 Why Text Properties are not Intervals
----------------------------------------------

ユーザーにテキスト内の“インターバル(訳注: 原文のインター
バルはIT用語としては時間や距離などの間隔を示す用語として
用いれることが多いと思いますが、ここでは『範囲』を示す言
葉として用いられているようです。他の箇所で『範囲』と訳し
たrange等と異なる機能なので、ここではそのまま『インター
バル』としました)”を指定させて、そのインターバルにプロパ
ティを追加するために、バッファー内のテキストへの属性の追
加をサポートするエディターがいくつかあります。それらのエ
ディターは、ユーザーやプログラマーが個別にインターバルの
開始と終了を決定することを許可します。わたしたちは、テキ
スト変更に関連する特定の逆説的振る舞いを避けるために、
Emacs Lisp内に、故意に異なる種類のインターフェイスを提供
しました。

   複数のインターバルに細分化することが実際に意味をもつ
なら、それは特定のプロパティをもつ単一のインターバルのバ
ッファーと、同じテキストをもち、両方が同じプロパティをも
つ2つのインターバルに分割されたバッファーを区別できるこ
とを意味します。

   インターバルを1つだけもつバッファーがあり、その一部を
killすることを考えてみてください。そのそのバッファーに残
されるのは1つのインターバルであり、killリング(とundoリス
ト)内のコピーは別個のインターバルになります。そのkillさ
れたテキストをyankで戻すと、同じプロパティをもつ2つのイ
ンターバルを得ることになります。したがって、編集では1つ
のインターバルと2つのインターバルの違いは保たれません。

   テキスト挿入時に2つのインターバルを結合することにより
、この問題に“対応”したとします。これは、そのバッファーが
元々単一のインターバルだったなら、上手く機能します。 し
かし、かわりに同じプロパティをもつ隣接する2つのインター
バルがあり、そのうちの1つのインターバルからテキストを
killして、それをyankで戻すことを考えてみてください。ある
ケースを解決する同じインターバル結合機能が、他のケースに
おいては問題を引き起こすのです。このyank後、インターバル
はただ1つとなります。繰り返します、編集では1つのインター
バルと2つのインターバルの違いは保たれないのです。

   インターバルの間の境界上へのテキスト挿入でも、満足で
きる回答かない問題が発生します。

   しかし、“バッファーにあるテキスト位置または文字列位置
のプロパティは何?”という形式の問にたいして、編集が一貫し
た振る舞いをするようアレンジするのは簡単です。そこで、わ
たしたちはこれらが合理的な唯一の問いであると判断したので
す。わたしたちはインターバルの開始と終了の場所を問うよう
な実装をしませんでした。

   実際には、明白にインターバル境界であるような箇所では
、通常はテキストプロパティ検索関数を使用できます。可能で
あるならインターバルは常に結合されるとみなすことにより、
それらがインターバル境界を探すと考えることができます。
*note Property Search::を参照してください。

   Emacsはプレゼンテーション機能として、明示的なインター
バルも提供します。*note Overlays::を参照してください。


File: elisp,  Node: Substitution,  Next: Registers,  Prev: Text Properties,  Up: Text

31.20 Substituting for a Character Code
=======================================

以下の関数は、文字コードにもとづいて、指定されたリージョ
ン内の文字を置き換えます。

 -- Function: subst-char-in-region start end old-char
          new-char &optional noundo
     この関数は、STARTとENDで定義されるカレントバッファ
     ーのリージョン内に出現する文字OLD-CHARをNEW-CHARに
     置き換える。

     NOUNDOが非‘nil’なら、‘subst-char-in-region’はundo用
     に変更を記録せず、バッファーを変更済みとマークしな
     い。これは、古い機能である選択的ディスプレイ(*note
     Selective Display::を参照)にとって有用だった。

     ‘subst-char-in-region’はポイントを移動せず、‘nil’を
     リターンする。

          ---------- Buffer: foo ----------
          This is the contents of the buffer before.
          ---------- Buffer: foo ----------

          (subst-char-in-region 1 20 ?i ?X)
               ⇒ nil

          ---------- Buffer: foo ----------
          ThXs Xs the contents of the buffer before.
          ---------- Buffer: foo ----------

 -- Command: translate-region start end table
     この関数は、バッファー内の位置STARTとENDの間の文字
     にたいして、変換テーブル(translation table)を適用す
     る。

     変換テーブルTABLEは、文字列、または文字テーブルであ
     る。‘(aref TABLE OCHAR)’は、OCHARに対応した変換後の
     文字を与える。TABLEが文字列なら、TABLEの長さより大
     きいコードの文字は、この変更により変更されない。

     ‘translate-region’のリターン値は、その変換により実
     際に変更された文字数である。変換テーブル内でその文
     字自身にマップされる文字は勘定に入らない。


File: elisp,  Node: Registers,  Next: Transposition,  Prev: Substitution,  Up: Text

31.21 Registers
===============

レジスター(register)とは、Emacs内の編集においてさまざま
な異なる種類の値を保持できる、一種の変数のことです。レジ
スターはそれぞれ、1文字で命名されます。すべてのASCII文字
、およびそれらのメタ修飾された変種(ただし‘C-g’は例外)を
、レジスターの命名に使用できます。したがって、利用可能な
レジスター数は255になります。Emacs Lispでは、レジスター
は自身の名前である、その文字により指定されます。

 -- Variable: register-alist
     この変数は、要素が‘(NAME .CONTENTS)’という形式の
     alistである。使用中のEmacsレジスターごとに、通常は
     1つの要素が存在する。

     オブジェクトNAMEは、レジスターを識別する文字(整数
     )である。

   レジスターのCONTENTSには、いくつかのタイプがある:

数字
     数字はそれ自身を意味する。‘insert-register’はレジス
     ター内の数字を探して、その数字を10進数に変換する。

マーカー
     マーカーは、ジャンプ先のバッファー位置を表す。

文字列
     文字列の場合は、レジスター内に保存されたテキスト。

矩形(rectangle)
     矩形は、文字列のリストを表す。

‘(WINDOW-CONFIGURATION POSITION)’
     これは1つのフレームにリストアされるウィンドウ構成、
     およびカレントバッファー内のジャンプ先の位置を表す
     。

‘(FRAME-CONFIGURATION POSITION)’
     これは、リストア用のフレーム構成、およびカレントバ
     ッファー内のジャンプ先の位置である。

(file FILENAME)
     これはvisitするファイルを表し、この値にジャンプする
     ことによりファイルFILENAMEをvisitする。

(file-query FILENAME POSITION)
     これはvisitするファイル、およびそのファイル内の位置
     を表す。この値にジャンプすることによりファイル
     FILENAMEをvisitして、バッファー位置POSITIONに移動す
     る。このタイプの位置をリストアすると、まずユーザー
     にたいして確認を求める。

   このセクションの関数は、特に記さない限り予期せぬ値を
リターンします。

 -- Function: get-register reg
     この関数はレジスターREGのコンテンツ、コンテンツがな
     ければ‘nil’をリターンする。

 -- Function: set-register reg value
     この関数は、レジスターREGのコンテンツにVALUEをセッ
     トする。レジスターには任意の値をセットできるが、そ
     の他のレジスター関数は特定のデータ型を期待する。リ
     ターン値はVALUE。

 -- Command: view-register reg
     このコマンドは、レジスター REGに何が含まれているか
     を表示する。

 -- Command: insert-register reg &optional beforep
     このコマンドは、カレントバッファーにレジスターREGの
     コンテンツを挿入する。

     このコマンドは通常、ポイントを挿入したテキストの前
     、後にマークを置く。しかしオプションの第2引き
     BEFOREPが非‘nil’なら、マークを前、ポイントを後に置
     くインタラクティブな呼び出しでは、プレフィクス引数
     を与えることにより、2つ目の引数BEFOREPに‘nil’を渡す
     ことができる。

     レジスターに矩形が含まれる場合、その矩形はポイント
     の左上隅に挿入される。これはそのテキストがカレント
     行と、その下に続く行に挿入されることを意味する。

     レジスターが保存されたテキスト(文字列)または矩形(リ
     スク)以外の何かを含む場合、現在のところは役に立つよ
     うなことは起きない。これは将来変更されるかもしれな
     い。

 -- Function: register-read-with-preview prompt
     この関数は、PROMPT、およびもしかしたら既存レジスタ
     ーとそのコンテンツをプレビューしてレジスターの名前
     を読み取り、レジスター名をリターンする。このプレビ
     ューは、ユーザーオプション
     ‘register-preview-delay’と‘register-alist’がいずれ
     も非‘nil’なら、‘register-preview-delay’で指定された
     遅延の後に、一時ウィンドウ内に表示される。このプレ
     ビューは、ユーザーが(たとえばヘルプ文字のタイプによ
     り)ヘルプを要求した場合も表示される。レジスター名を
     読み取るスベインタラクティブな関数は、この関数の使
     用を推奨する。


File: elisp,  Node: Transposition,  Next: Decompression,  Prev: Registers,  Up: Text

31.22 Transposition of Text
===========================

以下の関数は、テキストの一部を置き換えるために使用できま
す:

 -- Function: transpose-regions start1 end1 start2 end2
          &optional leave-markers
     この関数は、バッファーの重複しない2つの部分を交換す
     る。引数START1とEND1は一方の部分の両端、引数
     START2とEND2はもう一方の部分の両端を指定する。

     通常‘transpose-regions’は、置き換えたテキストにとも
     ないマーカーを再配置する。以前は2つの置き換えたテキ
     ストのうちの一方の部分に位置していたマーカーは、し
     の部分とともに移動されるので、それを挟む2つの文字の
     新たな位置の間に留まることになる。しかし
     LEAVE-MARKERSが非‘nil’なら、‘transpose-regions’はこ
     れを行わず、すべてのマーカーを再配置せずに残す。


File: elisp,  Node: Decompression,  Next: Base 64,  Prev: Transposition,  Up: Text

31.23 Dealing With Compressed Data
==================================

‘auto-compression-mode’が有効なときは、圧縮されたファイ
ルをvisitする際、Emacsはそれを自動的に解凍し、それを変更
して保存する際は自動的に再圧縮します。*note
(emacs)Compressed Files::を参照してください。

   上記の機能は、外部の実行可能ファイル(例: ‘gzip’)を呼
び出すことにより機能します。zlibライブラリーを使用したビ
ルトインの解凍サポートつきでEmacsをコンパイルすることも
でき、これは外部プログラムの実行に比べて高速です。

 -- Function: zlib-available-p
     この関数は、ビルトインzlib解凍が利用可能なら非
     ‘nil’をリターンする。

 -- Function: zlib-decompress-region start end
     この関数はビルトインのzlib解凍を使用して、STARTと
     ENDの間のリージョンを解凍する。このリージョンには、
     gzipかzlibで圧縮されたデータが含まれていなければな
     らない。成功した場合、この関数はリージョンのコンテ
     ンツを、解凍されたデータに置き換える。失敗すると、
     関数はリージョンを未変更のまま‘nil’をリターンする。
     この関数は、ユニバイトバッファーでのみ呼び出すこと
     ができる。


File: elisp,  Node: Base 64,  Next: Checksum/Hash,  Prev: Decompression,  Up: Text

31.24 Base 64 Encoding
======================

Base64コードは、8ビットシーケンスをより長いASCIIグラフィ
ック文字シーケンスにエンコードするために、email内で使用
されます。これは、インターネットRFC2045で定義されます
(1)。このセクションでは、このコードへの変換および逆変換
を行う関数について説明します。

 -- Command: base64-encode-region beg end &optional
          no-line-break
     この関数は、BEGからENDのリージョンを、Base64コード
     に変換する。これはエンコードされたテキストの長さを
     リターンする。リージョン内の文字がマルチバイトの場
     合は、エラーをシグナルする(マルチバイトバッファーで
     は、リージョンには‘ascii’、‘eight-bit-control’、
     ‘eight-bit-graphic’の文字以外は含まれてはならない
     )。

     通常この関数は行が長くなりすぎるのを防ぐために、エ
     ンコードされたテキストに改行を挿入する。しかしオプ
     ション引数NO-LINE-BREAKが非‘nil’なら、これらの改行
     は追加されず、出力は長い単一の行となる。

 -- Function: base64-encode-string string &optional
          no-line-break
     この関数は、文字列STRINGをBase64コードに変換する。
     これはエンコードされたテキストを含む文字列をリター
     ンする。‘base64-encode-region’と同様、文字列内の文
     字がマルチバイトならエラーをシグナルする。

     通常この関数は行が長くなりすぎるのを防ぐために、エ
     ンコードされたテキストに改行を挿入する。しかしオプ
     ション引数NO-LINE-BREAKが非‘nil’なら、これらの改行
     は追加されず、結果となる文字列は長い単一の行となる
     。

 -- Command: base64-decode-region beg end
     この関数は、BEGからENDのリージョンのBase64コードを
     、対応するデコードされたテキストに変換する。これは
     デコードされたテキストの長さをリターンする。

     デコード関数は、エンコード済みテキスト内の改行文字
     を無視する。

 -- Function: base64-decode-string string
     この関数は、モジュールSTRINGを、Base64コードから、
     対応するデコード済みテキストに変換する。これは、デ
     コード済みテキストを含むユニバイトをリターンする。

     デコード関数は、エンコード済みテキスト内の改行文字
     を無視する。

   ---------- Footnotes ----------

   (1) RFC(“Request for Comments”の略)とは、ナンバーが付
与された、標準を記述するインターネット情報提供ドキュメン
トです。RFCは通常、自身が先駆的に活動する技術エキスパー
トにより記述され、伝統として現実的で、経験主導で記述され
ます。


File: elisp,  Node: Checksum/Hash,  Next: Parsing HTML/XML,  Prev: Base 64,  Up: Text

31.25 Checksum/Hash
===================

Emacsには、“暗号化ハッシュ(cryptographic hashes)”計算用
のビルトインのサポートがあります。暗号化ハッシュ、または
“チェックサム(checksum)”とは、データ断片にたいするデジタ
ルな“指紋(fingerprint)”であり、そのデータが変更されてい
ないかチェックするために使用できます。

   EmacsはMD5、SHA-1、SHA-2、SHA-224、SHA-256、SHA-384、
SHA-512といった一般的な暗号化ハッシュアルゴリズムをサポ
ートします。これらのアルゴリズムのうちMD5はもっとも古く
、ネットワーク越しに転送されたメッセージの整合性をチェッ
クするために、一般的には“メッセージダイジェスト(message
digests)”内で使用されています。MD5は“衝突耐性(collision
resistant)”をもたない(同じMD5ハッシュをもつ異なるデータ
片を故意にデザインすることが可能)ので、セキュリティに関
連することに使用するべきではありません。同様な理論上の欠
点は、SHA-1にも存在します。したがって、セキュリティに関
連するアプリケーションにたいしては、SHA-2のような、他の
ハッシュタイプを使用するべきです。

 -- Function: secure-hash algorithm object &optional
          start end binary
     この関数は、OBJECTにたいするハッシュをリターンする
     。引数ALGORITHMはどのハッシュを計算するかを示すシン
     ボルで‘md5’、‘sha1’、‘sha224’、‘sha256’、‘sha384’、
     ‘sha512’のいずれかである。引数OBJECTは、バッファー
     または文字列であること。

     オプション引数STARTとENDは、メッセージダイジェスト
     を計算する、OBJECT部分を指定する文字位置である。こ
     れらが‘nil’または省略された場合は、OBJECT全体にたい
     するハッシュを計算する。

     引数BINARYが省略または‘nil’なら、通常のLisp文字列と
     して、そのハッシュの“テキスト形式(text form)”をリタ
     ーンする。BINARYが非‘nil’なら、ユニバイト文字列に格
     納されたバイトシーケンスとして、そのハッシュの“バイ
     ナリー形式(binary form)”をリターンする。

     この関数は、OBJECTのテキストの内部表現(*note Text
     Representations::を参照)からハッシュを直接計算しな
     い。かわりにコーディングシステム(*note Coding
     Systems::を参照)を使用してテキストをエンコードして
     、そのエンコード済みテキストからハッシュを計算する
     。OBJECTがバッファーなら、使用されているコーディン
     グが、そのテキストをファイルに書き込むためのデフォ
     ルトとして選択される。OBJECTが文字列なら、ユーザー
     の好むコーディングシステムが使用される(*note
     (emacs)Recognize Coding::を参照)。

 -- Function: md5 object &optional start end
          coding-system noerror
     この関数はMD5ハッシュをリターンする。これはほとんど
     の目的において、ALGORITHM引数に‘md5’を指定して
     ‘secure-hash’を呼び出すのと等価であり、半ば時代遅れ
     である。引数のOBJECT、START、ENDは‘secure-hash’のと
     きと同じ意味をもつ。

     CODING-SYSTEMが非‘nil’なら、それはテキストをエンコ
     ードするために使用する、コーディングシステムを指定
     する。if omitted or , the default coding system is
     used, like in ‘secure-hash’と同様にデフォルトコーデ
     ィングシステムが使用される。

     ‘md5’は通常、指定もしくは選択されたコーディングシス
     テムを使用してテキストをエンコードできなければ、エ
     ラーをシグナルする。しかしNOERRORが非‘nil’なら、か
     わりに黙って‘raw-text’コーディングシステムを使用す
     る。


File: elisp,  Node: Parsing HTML/XML,  Next: Atomic Changes,  Prev: Checksum/Hash,  Up: Text

31.26 Parsing HTML and XML
==========================

Emacsがlibxml2サポートつきでコンパイルされたときは、
HTMLやXMLのテキストをLispオブジェクトツリーにパースする
ために、以下の関数が利用可能です。

 -- Function: libxml-parse-html-region start end
          &optional base-url
     この関数は、STARTとENDの間のテキストをHTMLとしてパ
     ースして、HTML“パースツリー(parse tree)”を表すリス
     トをリターンする。これは構文誤り強力に対処すること
     により、“実世界”のHTMLの処理を試みる。

     オプション引数BASE-URLが非‘nil’なら、リンク内に出現
     する相対URLにたいする、ベースURLを指定する文字列で
     あること。

     パースツリー内では、各HTMLノードは1つ目の要素がノー
     ド名を表すシンボル2つ目の要素がノード属性のalist、
     残りの要素はサブノードであるようなリストにより表さ
     れる。

     以下の例でこれを示す。以下の(不正な)HTMLドキュメン
     トを与えると:

          <html><head></head><body width=101><div class=thing>Foo<div>Yes

     ‘libxml-parse-html-region’呼び出しにより以下がリタ
     ーンされる:

          (html ()
            (head ())
            (body ((width . "101"))
             (div ((class . "thing"))
              "Foo"
              (div ()
                "Yes"))))

 -- Function: shr-insert-document dom
     この関数は、DOM内のパース済みHTMLを、カレントバッフ
     ァー内に描画する。引数DOMは、
     ‘libxml-parse-html-region’で整数されるようなｌリス
     トであること。この関数はたとえば、*note EWW:
     (eww)Top.により使用される。

 -- Function: libxml-parse-xml-region start end
          &optional base-url
     この関数は‘libxml-parse-html-region’と同様だが、
     HTMLではなく(構文についてより厳格な)XMLとしてテキス
     トをパースする点が異なる。


File: elisp,  Node: Atomic Changes,  Next: Change Hooks,  Prev: Parsing HTML/XML,  Up: Text

31.27 Atomic Change Groups
==========================

データベース用語で“アトミック(atomic: 原子的、不可分な
)”変更とは、全体として成功もしくは失敗することはできるが
、部分的にはできない、個別の変更のことです。Lispプログラ
ムは単一もしくは複数のバッファーにたいする一連の変更を
“アトミック変更グループ(atomic change group)”にすること
ができます。これはその一連の変更全体が、それらのバッファ
ーに適用されるか、またはエラーの場合は何も適用されないか
の、いずれかであることを意味します。

   すでにカレントであるような単一のバッファーにたいして
これを行うには、以下のように変更を行うこーの周りに、単に
‘atomic-change-group’の呼び出しを記述します:

     (atomic-change-group
       (insert foo)
       (delete-region x y))

‘atomic-change-group’のbody内部でエラー(またはその他の非
ローカルexit)が発生した場合は、そのbody実行の間にそのバ
ッファーでのすべての変更が行われなかったことになります。
この類の変更グループは、他のバッファーには影響を与えず、
それらのバッファーにたいする変更はそのまま残されます。

   さまざまなバッファー内で行った変更から1つのアトミック
グループを構成する等、より複雑な何かを必要とする場合は、
‘atomic-change-group’が使用する、より低レベルな関数を直
接呼び出さなければなりません。

 -- Function: prepare-change-group &optional buffer
     この関数はBUFFER(デフォルトはカレントバッファー)に
     たいする変更グループをセットアップする。これは、そ
     の変更グループを表す“handle”をリターンする。変更グ
     ループをactivateしたり、その後でそれを完了するため
     には、このhandleを使用しなければならない。

   変更グループを使用するためには、それを“activate(アク
ティブ化)”しなければなりません。これはBUFFERのテキストを
変更する前に行わなければなりません。

 -- Function: activate-change-group handle
     これは、HANDLEが指定する変更グループをactiveにする
     。

   変更グループをactivateした後は、そのバッファー内で行
ったすべての変更は、その変更グループの一部となります。そ
のバッファー内で目論んでいたすべての変更を行ったら、その
変更グループを“finish(完了)”しなければなりません。すべて
の変更を受け入れる(確定する)か、すべてをキャンセルすると
いう2つの方法により、これを行うことができます。

 -- Function: accept-change-group handle
     この関数はHANDLEにより指定される変更グループ内のす
     べての変更にたいして、finalizeすることにより変更を
     受け入れる。

 -- Function: cancel-change-group handle
     この関数はHANDLEにより指定される変更グループ内のす
     べての変更をキャンセルしてundoする。

   グループが常に確実にfinishされるようにするために、コ
ードでは‘unwind-protect’を使用するべきです。
‘activate-change-group’の呼び出しは、実行直後にユーザー
が‘C-g’をタイプする場合に備え、‘unwind-protect’内部にあ
るべきです(これが‘prepare-change-group’と
‘activate-change-group’が別関数となっている1つの理由であ
る。なぜなら通常は‘unwind-protect’開始前に
‘prepare-change-group’を呼び出すであろうから)。グループ
を一度finishしたら、そのhandleを再度使用してはなりません
。特に、同じ変更グループを2回finishしないでください。

   複数バッファー変更グループ(multibuffer change group)を
作成するためには、カバーしたいバッファーそれぞれで
‘prepare-change-group’を一度呼び出してから、以下のように
リターン値を結合するために、‘nconc’を使用してください:

     (nconc (prepare-change-group buffer-1)
            (prepare-change-group buffer-2))

   その後は1回の‘activate-change-group’呼び出しで複数変
更グループをアクティブにして、1回の
‘accept-change-group’または‘cancel-change-group’呼び出し
で、それをfinishしてください。

   同一バッファーにたいするネストされた複数の変更グルー
プ使用は、あなたが期待するであろう通り機能します。同一バ
ッファーにたいするネストされていない変更グループ使用によ
り、Emacsが混乱した状態になるため、これが発生しないよう
にしてください。与えられた何らかのバッファーにたいして最
初に開始した変更グループは、最後にfinishする変更グループ
です。


File: elisp,  Node: Change Hooks,  Prev: Atomic Changes,  Up: Text

31.28 Change Hooks
==================

以下のフック変数により、すべてのバッファー(これらをバッ
ファーローカルにした場合は特定のバッファー)でのすべての
変更にたいして、通知を受け取るようにアレンジすることがで
きます。テキストの特定部分にたいする変更の検出方法につい
ては、*note Special Properties::も参照してください。

   これらのフック内で使用する関数は、もしそれらが正規表
現を使用して何かを行う場合は、マッチしたデータの保存とリ
ストアを行うべきです。さもないと、それらが呼び出す編集処
理に、奇妙な方法で干渉するでしょう。

 -- Variable: before-change-functions
     この変数は、何らかのバッファー変更を行う前に呼び出
     すための、関数のリストを保持する。各関数は変更され
     ようとするリージョンの先頭と終端を整数で表す、2つの
     引数を受け取る。変更されようとするバッファーは、常
     にカレントバッファーである。

 -- Variable: after-change-functions
     この変数は、何らかのバッファー変更を行った後に呼び
     出すための、関数のリストを保持する。各関数は正に変
     更されたリージョンの先頭と終端、およびその変更前に
     存在したテキストの長さである。これら3つの変数は、す
     べて整数である。変更されたバッファーは、常にカレン
     トバッファーである。

     古いテキストの長さは、変更される前のテキストでの、
     そのテキストの前後のバッファー位置の差である。変更
     されたテキストでは、その長さは単に最初の2つの引数の
     差である。

   ‘*Messages*’バッファーへのメッセージ出力は、これらの
関数を呼び出しません。

 -- Macro: combine-after-change-calls body...
     このマクロは普通にBODYを実行するが、もしそれが安全
     なように見えるなら、一連の複数の変更にたいして正に
     一度、after-change関数を呼び出すようにアレンジする
     。

     そのバッファーの同じ領域内でプログラムが複数のテキ
     スト変更を行う場合は、その部分のプログラムの周囲で
     マクロ‘combine-after-change-calls’を使用することに
     より、after-changeフック使用中の実行がかなり高速に
     なり得る。after-changeフックが最終的に呼び出される
     際、その引数は‘combine-after-change-calls’のbody内
     で行われたすべての変更にたいして含むバッファーの範
     囲を指定する。

     *警告:* フォーム‘combine-after-change-calls’の
     body内で、‘after-change-functions’の値を変更しては
     ならない。

     *警告:* 組み合わされた変更がバッファーの広い範囲に
     ばらばらに発生する場合でも、これは依然として機能す
     るものの、お勧めはできない。なぜならこれは、ある変
     更フック関数を、非効率的な挙動へと導くかもしれない
     からである。

 -- Variable: first-change-hook
     この変数は、以前は未変更の状態だったバッファーが変
     更された際は常に実行されるノーマルフックである。

 -- Variable: inhibit-modification-hooks
     この変数が非‘nil’なら、すべての変更フックは無効にな
     る。それらは何も実行されない。これはこのセクション
     で説明したすべてのフック変数、同様に特定のスペシャ
     ルテキストプロパティ(*note Special Properties::を参
     照)とオーバーレイプロパティ(*note Overlay
     Properties::を参照)にアタッチされたフックに影響を与
     える。

     これらの同じフック変数実行の間、バッファー変更によ
     るデフォルトの変更フックが他の変更フック実行中に実
     行されないように、この変数は非‘nil’にバインドされる
     それ自体が変更フックから実行される特定のコード断片
     内で変更フックを実行したければ、ローカルに
     ‘inhibit-modification-hooks’を‘nil’に再バインドする
     こと。


File: elisp,  Node: Non-ASCII Characters,  Next: Searching and Matching,  Prev: Text,  Up: Top

32 Non-ASCII Characters
***********************

このチャプターは文字に関する特別な問題と、それらが文字列
およびバッファーに格納される方法についてカバーします。

* Menu:

* Text Representations::     Emacsがテキストを表す方法。
* Disabling Multibyte::      マルチバイト使用を制御する。
* Converting Representations::  ユニバイトとマルチバイトの相互変換。
* Selecting a Representation::  バイトシーケンスをユニバイトやマルチバイトとして扱う。
* Character Codes::          ユニバイトやマルチバイトが個々の文字のコードと関わる方法。
* Character Properties::     文字の挙動と処理を定義する文字属性。
* Character Sets::           利用可能な文字コード空間はさまざまな文字セットに分割される。
* Scanning Charsets::        バッファーで使用されている文字セットは?
* Translation of Characters::  変換に使用される変換テーブル。
* Coding Systems::           コーディングシステムはファイル保存のための変換である。
* Input Methods::            入力メソッドによりユーザーは特別なキーボードなしで非ASCII文字を入力できる。
* Locales::                  POSIX localeとの対話。


File: elisp,  Node: Text Representations,  Next: Disabling Multibyte,  Up: Non-ASCII Characters

32.1 Text Representations
=========================

Emacsのバッファーおよび文字列は、既知のスクリプトで記述
されたほとんどすべてのテキストをユーザーがタイプしたり表
示できるよう、多種多様な言語の広大な文字レパートリーをサ
ポートします。

   多種多様な文字およびスクリプトをサポートするために、
Emacsは“Unicode標準(Unicode Standard)”に厳密にしたがいま
す。Unicode標準は、すべての文字にたいしてそれぞれ、“コー
ドポイント(codepoint)”と呼ばれる一意な番号を割り当ててい
ます。コードポイントの範囲はUnicode、またはUnicode“コー
ド空間(codespace)”により定義され、範囲は
‘0..#x10FFFF’(16進表記、範囲両端を含む)です。Emacsはこれ
を、範囲‘#x110000..#x3FFFFF’のコードポイント範囲に拡張し
ます。この範囲はUnicodeとして統一されていない文字や、文
字として解釈できない“8ビットrawバイト(raw 8-bit bytes)”を
表すために使用します。したがって、Emacs内の文字コードポ
イントは、22ビットの整数になります。

   メモリー節約のため、Emacsはバッファーおよび文字列内の
テキスト文字にたいするコードポイントである、22ビットの整
数を固定長で保持しません。かわりに、Emacsは文字の内部表
現として可変長を使用します。これは、そのコードポイントの
値に応じて、各文字を5ビットから8ビットのバイトシーケンス
として格納するものです(1)。たとえばすべてのASCII文字は
1バイト、Latin-1文字は2バイトといった具合です。わたした
ちはこれを、テキストの“マルチバイト(multibyte)”表現と呼
んでいます。

   Emacs外部では、ISO-8859-1、GB-2312、Big-5等のような多
種の異なるエンコーディングで文字を表すことができます。
Emacsはバッファーまたは文字列へのテキスト読み込み時、お
よびディスク状のファイルへのテキスト書き込みや他プロセス
への引き渡し時に、これらの外部エンコーディングと、その内
部表現の間で適切な変換を行います。

   Emacsがエンコード済みテキストや非テキストデータを、バ
ッファーや文字列に保持、あるいは操作する必要がある場合も
時折あります。たとえばEmacsがファイルをvisitする際、まず
そのファイルのテキストをそのままバッファーに読み込み、そ
の後にのみそれを内部表現に変換します。この変換前にバッフ
ァーに保持されてくださいのは、エンコード済みのテキストで
す。

   Emacsに関する限り、エンコードされたテキストは実際のテ
キストではなく、8ビットrawバイトです。エンコード済みテキ
ストを保持するバッファーおよび文字列は、Emacsがそれらを
個々のバイトシーケンスとしてアツカウことから、“ユニバイ
ト(unibyte)”のバッファーまたは文字列と呼んでいます。
Emacsは通常、ユニバイトのバッファーおよび文字列を、
‘\237’のような8進コードで表示します。エンコード済みテキ
ストやバイナリー非テキストデータを処理する場合を除き、ユ
ニバイトバッファーとユニバイト文字列は決して使用しないよ
う推奨します。

   バッファーにおいては、変数
‘enable-multibyte-characters’のバッファーローカルな値が
、使用する表現を指定します。文字列での表現は、その文字列
構築時に判断して、それを文字列内に記録します。

 -- Variable: enable-multibyte-characters
     この変数は、カレントバッファーのテキスト表現を指定
     する。非‘nil’ならバッファーはマルチバイトテキストを
     含み、それ以外ならエンコード済みユニバイトテキスト
     、またはバイナリー非テキストデータが含れる。

     この変数は直接セットできない。バッファーの表現を変
     更するには、かわりに関数‘set-buffer-multibyte’を使
     用すること。

 -- Function: position-bytes position
     バッファー位置は文字単位で測られる。この関数は、カ
     レントバッファー内のバッファー位置を、それに対応す
     るバイト位置でリターンする。これはバッファー先頭を
     1として、バイト単位で増加方向に数えられる。
     POSITIONが範囲外なら、値は‘nil’になる。

 -- Function: byte-to-position byte-position
     カレントバッファー内で、与えられたBYTE-POSITIONに対
     応するバッファー位置を、文字単位でリターンする。
     BYTE-POSITIONが範囲外なら、値は‘nil’になる。マルチ
     バイトバッファーでは、BYTE-POSITIONの任意の値が文字
     境界上になく、1文字として表現されたマルチバイトシー
     ケンス内にあるかもしれない。この場合、関数はその文
     字のマルチバイトシーケンスがBYTE-POSITIONを含むよう
     なバッファー位置をリターンする。他の言い方をすると
     、この値は同じ文字に属するすべてのバイト位置にたい
     して変化しない。

 -- Function: multibyte-string-p string
     STRINGがマルチバイト文字列なら‘t’、それ以外は
     ‘nil’をリターンする。この関数は、STRINGが文字列以外
     の場合にも、‘nil’をリターンする。

 -- Function: string-bytes string
     この関数は、STRING内のバイトの数をリターンする。
     STRINGがマルチバイト文字列なら、これは‘(length
     STRING)’より大きいかもしれない。

 -- Function: unibyte-string &rest bytes
     この関数は引数BYTESをすべて結合して、その結果をユニ
     バイト文字列で作成する。

   ---------- Footnotes ----------

   (1) この内部表現は、任意のUnicodeコードポイントを表す
ための、“UTF-8”と呼ばれるUnicode標準によるエンコーディン
グの1つにもとづきますが、8ビットrawバイトおよびUnicodeに
統一されていない文字を使用する追加のコードポイントを表現
するために、EmacsはUTF-8を拡張しています。


File: elisp,  Node: Disabling Multibyte,  Next: Converting Representations,  Prev: Text Representations,  Up: Non-ASCII Characters

32.2 Disabling Multibyte Characters
===================================

デフォルトでは、Emacsはマルチバイトモードで開始します。
Emacsは、マルチバイトシーケンスを使用して非ASCII文字を表
現する内部エンコーディングを使用することにより、バッファ
ーおよび文字列のコンテンツを格納します。マルチバイトモー
ドではサポートされるすべての言語とスクリプトを使用できま
す。

   非常に特別な状況下においては、特定のバッファーでマル
チバイト文字のサポートを無効にしたいときがあるかもしれま
せん。あるバッファーにおいてマルチバイト文字が無効になっ
ているときは、それを“ユニバイトモード(unibyte mode)”と呼
びます。ユニバイトモードでは、バッファー内の各文字は0か
ら255(8進の0377)の範囲の文字コードをもちます。0から
127(8進の0177)はASCII文字、128から255(8進の0377)は非
ASCII文字を表します。

   特定のファイルをユニバイト表現で編集するためには、
‘find-file-literally’を使用してファイルをvisitします。
*note Visiting Functions::を参照してください。マルチバイ
トバッファーをファイルに保存してバッファーをkillした後に
、再びそのファイルを‘find-file-literally’でvisitすること
により、マルチバイトバッファーをユニバイトに変換できます
。かわりに‘C-x <RET>
c’(‘universal-coding-system-argument’)を使用して、ファイ
ルをvisitまたは保存するコーディングシステムとして
‘raw-text’を指定することもできます。*note Specifying a
Coding System for File Text: (emacs)Text Coding.を参照し
てください。‘find-file-literally’とは異なり、
‘raw-text’としてファイルをvisitしてもフォーマット変換、
解凍、自動的なモード選択は無効になりません。

   バッファーローカル変数‘enable-multibyte-characters’は
、マルチバイトバッファーなら非‘nil’、ユニバイトバッファ
ーなら‘nil’になります。マルチバイトバッファーかどうかは
、モードラインにも示されます。グラフィカルなディスプレイ
でのマルチバイトバッファーは、文字セット話示すモードライ
ン部分ぬ、そのバッファーがマルチバイトであること(とそれ
以外の事項)を告げるツールチップがあります。ユニバイトバ
ッファーでは、文字セットのインジケーターはありません。し
たがって(グラフィカルなディスプレイ使用時の)ユニバイトバ
ッファーでは、入力メソッドを使用していなければ、visitし
ているファイルの行末変換(コロン、バックスラッシュ等)の標
識の前には通常何も標識はありません。

   特定のバッファーでマルチバイトサポートをオフに切り替
えるには、そのバッファー内でコマンド
‘toggle-enable-multibyte-characters’を呼び出してください
。


File: elisp,  Node: Converting Representations,  Next: Selecting a Representation,  Prev: Disabling Multibyte,  Up: Non-ASCII Characters

32.3 Converting Text Representations
====================================

Emacsはユニバイトテキストをマルチバイトに変換できます。
マルチバイトテキストに含まれるのがASCIIと8ビットrawバイ
トだけという条件つきで、マルチバイトテキストからユニバイ
トへの変換もできます。一般的にこれらの変換はバッファーへ
のテキスト挿入時、または複数の文字列を1つの文字列に合わ
せてテキストにputするときに発生します。文字列のコンテン
ツを、いずれかの表現に明示的に変換することもできます。

   Emacsは、そのテキストの構成にもとづいて、文字列の表現
を選択します。一般的なルールでは、ユニバイトテキストが他
のマルチバイトテキストと組み合わされている場合は、マルチ
バイト表現のほうがより一般的であり、ユニバイトテキストの
すべての文字を保有できるので、ユニバイトテキストをマルチ
バイトテキストに変換します。

   バッファーへのテキスト挿入時、Emacsはそのバッファーの
‘enable-multibyte-characters’で指定されるように、テキス
トをそのバッファーの表現に変換します。特にユニバイトバッ
ファーへマルチバイトテキストを挿入する際は、たとえ一般的
にはマルチバイトテキスト内のすべての文字を保持することは
できなくても、Emacsはテキストをユニバイトに変換します。
バッファーコンテンツをマルチバイトに変換するという自然な
代替方法は、そのバッファーの表現が自動的にオーバーライド
できないユーザーによる選択にもとづく表現であるため、受け
入れられません。

   ユニバイトテキストからマルチバイトテキストへの変換で
は、ASCII文字は未変更のまま残され、128から255のコードを
もつバイトが8ビットrawバイトのマルチバイト表現に変換され
ます。

   マルチバイトテキストからユニバイトテキストへの変換で
は、すべてのASCIIと8ビット文字が、それらの1バイト形式に
変換されますが、各文字のコードポイントの描い8ビット以外
は破棄されるため、非ASCII文字の情報は失われます。ユニバ
イトテキストからマルチバイトテキストに変換して、それをユ
ニバイトに戻せば、元のユニバイトテキストが再生成されます
。

   以下の2つの関数は、引数STRING、またはテキストプロパテ
ィをもたない新たに作成された文字列のいずれかをリターンし
ます。

 -- Function: string-to-multibyte string
     この関数は、STRINGと同じ文字シーケンスを含むマルチ
     バイト文字列をリターンする。STRINGがマルチバイト文
     字列なら、それが未変更のままリターンされる。この関
     数は、STRINGがASCII文字と8ビットrawバイトだけを含む
     と仮定する。後者は‘#x3FFF80’から‘#x3FFFFF’(両端を含
     む)に対応する、8ビットrawバイトのマルチバイト表現に
     変換される(*note codepoints: Text Representations.を
     参照)。

 -- Function: string-to-unibyte string
     この関数は、STRINGと同じ文字シーケンスを含む、ユニ
     バイト文字列をリターンする。STRINGに非ASCII文字が含
     まれる場合は、エラーをシグナルする。STRINGがユニバ
     イト文字列なら、それが未変更のままリターンされる。
     ASCII文字と8ビット文字だけを含むSTRING引数にたいし
     てのみ、この関数を使用すること。

 -- Function: byte-to-string byte
     この関数は、文字データBYTEの単一バイトを含むユニバ
     イト文字列をリターンする。BYTEが0から255までの整数
     でなければ、エラーをシグナルする。

 -- Function: multibyte-char-to-unibyte char
     これはマルチバイト文字CHARをユニバイト文字に変換し
     て、その文字をリターンする。CHARがASCIIと8ビットの
     いずれでもなければ、この関数は−1をリターンする。

 -- Function: unibyte-char-to-multibyte char
     これはCHARがASCIIか8ビットrawバイトのいずれかである
     と仮定して、ユニバイト文字ASCIIをマルチバイト文字に
     変換する。


File: elisp,  Node: Selecting a Representation,  Next: Character Codes,  Prev: Converting Representations,  Up: Non-ASCII Characters

32.4 Selecting a Representation
===============================

既存のバッファーまたは文字列がユニバイトの際にそれらをマ
ルチバイトとして調べたり、その逆を行うことが有用なときが
あります。

 -- Function: set-buffer-multibyte multibyte
     カレントバッファーの表現タイプをセットする。
     MULTIBYTEが非‘nil’ならバッファーはマルチバイト、
     ‘nil’ならユニバイトになる。

     この関数は、バイトシーケンスとして認識時には、バッ
     ファーを未変更のままとする。結果として、文字として
     認識時にはコンテンツを変更できる。たとえば、マルチ
     バイト表現では1文字として扱われる3バイトのシーケン
     スは、ユニバイト表現では3文字として数えられるだろう
     。例外はrawバイトを表す8ビット文字である。これらは
     ユニバイトバッファーでは1バイトで表現されるが、バッ
     ファーをマルチバイトにセットした際は2バイトのシーケ
     ンスに変換され、その逆の変換も行われる。

     この関数は、どの表現が使用されているかを記録するた
     めに、‘enable-multibyte-characters’をセットする。こ
     れは以前の同じテキストをカバーするよう、バッファー
     内のさまざまなデータ(オーバーレイ、テキストプロパテ
     ィ、マーカーを含む)を調整する。

     ナローイングはマルチバイト文字シーケンス中間で発生
     するかもしれないので、この関数はバッファーがナロー
     イングされている場合はエラーをシグナルする。

     そのバッファーがインダイレクトバッファー(indirect
     buffer: 間接バッファー)の場合も、エラーをシグナルす
     る。インダイレクトバッファーは、常にベースバッファ
     ー(base buffer: 基底バッファー)の表現を継承する。

 -- Function: string-as-unibyte string
     STRINGがすでにユニバイト文字列なら、この関数は
     STRING自身をリターンする。それ以外はSTRINGと同じバ
     イトだが、それぞれの文字を個別の文字としてとして扱
     い、新たな文字列をリターンする(値はSTRINGより多くの
     文字をもつかもしれない)。例外として、rawバイトを表
     す8ビット文字はそれぞれ、単一のバイトに変換される。
     新たに作成された文字列に、テキストプロパティは含ま
     れない。

 -- Function: string-as-multibyte string
     STRINGがすでにマルチバイト文字列なら、この関数は
     STRING自身をリターンする。それ以外はSTRINGと同じバ
     イトだが、それぞれのマルチバイトシーケンスを1つの文
     字としてとして扱い、新たな文字列をリターンする。こ
     れは、値がSTRINGより少ない文字をもつかもしれないこ
     とを意味する。STRING内のバイトシーケンスが、単一文
     字のマルチバイト表現として無効なら、そのシーケンス
     ないの各バイトは、8ビットrawバイトとして扱われる。
     新たに作成された文字列には、テキストプロパティは含
     まれない


File: elisp,  Node: Character Codes,  Next: Character Properties,  Prev: Selecting a Representation,  Up: Non-ASCII Characters

32.5 Character Codes
====================

ユニバイトおよびマルチバイトのテキスト表現は、異なる文字
コードを使用します。ユニバイト表現にたいして有効な文字コ
ードの範囲は0から‘#xFF’(255)で、これは1バイトに収まる値
です。マルチバイト表現にたいして有効な文字コードの範囲は
、0から‘#x3FFFFF’です。このコード空間では値0から
‘#x7F’(127)がASCII文字用、値‘#x80’(128)から
‘#x3FFF7F’(4194175)が非ASCII文字用になります。

   Emacsの文字コードは、Unicode標準の上位集合
(superset)です。値0から‘#x10FFFF’(1114111)は、同じコード
ポイントのUnicode文字に対応します。値
‘#x110000’(1114112)から‘#x3FFF7F’(4194175)は、Unicodeに
統一されていない文字を、値‘#x3FFF80’ (4194176)から
‘#x3FFFFF’(4194303)は8ビットrawバイトを表します。

 -- Function: characterp charcode
     これはCHARCODEが有効な文字なら‘t’、それ以外は
     ‘nil’をリターンする。

          (characterp 65)
               ⇒ t
          (characterp 4194303)
               ⇒ t
          (characterp 4194304)
               ⇒ nil

 -- Function: max-char
     この関数は、有効な文字コードポイントがもち得る最大
     の値をリターンする。

          (characterp (max-char))
               ⇒ t
          (characterp (1+ (max-char)))
               ⇒ nil

 -- Function: get-byte &optional pos string
     この関数は、カレントバッファー内の文字位置POSにある
     バイトをリターンする。カレントバッファーがユニバイ
     トなら、その位置のバイトをそのままリターンする。バ
     ッファーがマルチバイトの場合は、8ビットrawバイトは
     8ビットコードに変換される一方、ASCII文字のバ値は文
     字コードポイントと同じになる。この関数は、POSにある
     文字が非ASCIIなら、エラーをシグナルする。

     オプション引数STRINGは、カレントバッファーのかわり
     に、文字列からバイト値を得ることを意味する。


File: elisp,  Node: Character Properties,  Next: Character Sets,  Prev: Character Codes,  Up: Non-ASCII Characters

32.6 Character Properties
=========================

“文字プロパティ(character property”とは、その文字の振る
舞いと、テキストが処理および表示される間どのように処理さ
れるべきかを指定する、名前つきの文字属性です。したがって
文字プロパティは、その文字の意味を指定するための重要な一
部です。

   全体として、Emacsは自身の文字プロパティ実装においては
Unicode標準にしたがいます。特にEmacsはUnicode Character
Property Model (http://www.unicode.org/reports/tr23/)を
サポートしており、Emacs文字プロパティデータベースは
Unicode文字データベース(UCD: Unicode Character
Database)から派生したものです。Unicode文字プロパティとそ
の意味についての詳細な説明は、Character Properties
chapter of the Unicode Standard
(http://www.unicode.org/versions/Unicode6.2.0/ch04.pdf)を
参照してください。このセクションでは、あなたがすでに
Unicode標準の該当する章に親しんでいて、その知識をEmacs
Lispプログラムに適用したいものと仮定します。

   Emacsでは、各プロパティは名前をもつシンボルであり、そ
のシンボルは利用可能な値セットをもち、値の型はプロパティ
に依存します。ある文字が特定のプロパティをもたなければ、
その値は‘nil’になります。一般的なルールとして、Emacsでの
文字プロパティ名は、対応するUnicodeプロパティ名を小文字
にして、文字‘_’をダッシュ文字‘-’で置き換えることにより生
成されます。たとえば‘Canonical_Combining_Class’は
‘canonical-combining-class’となります。しかし簡単に使用
できるように、名前を短くすることもあります。

   UCDによりいくつかのコードポイントは“未割り当て
(unassigned)”のまま残されており、それらに対応する文字は
ありません。Unicode標準は、そのようなコードポイントのプ
ロパティにたいしてデフォルト値を定義しています。それらに
ついては、以下の各プロパティごとに注記しています。

   以下は、Emacsが関知するすべての文字プロパティにたいす
る、値タイプの完全なリストです:

‘name’
     Unicodeプロパティ‘Name’に対応する。値はラテン大文字
     のAからZ、数字、スペース、ハイフン‘-’の文字から構成
     される文字列である。未割り当てのコードポイントにた
     いする値は‘nil’。

‘general-category’
     Unicodeプロパティ‘General_Category’に対応する。値は
     、その文字の分類をアルファベット2文字に略したものを
     名前としてもつようなシンボルである。未割り当てのコ
     ードポイントにたいする値は‘Cn’。

‘canonical-combining-class’
     Unicodeプロパティ‘Canonical_Combining_Class’に対応
     する。値は整数。未割り当てのコードポイントにたいす
     る値は0。

‘bidi-class’
     Unicodeプロパティ‘Bidi_Class’に対応する。値は、その
     文字のUnicode“方向タイプ(directional type)”が名前で
     あるようなシンボル。Emacsは表示のために双方向テキス
     トを並び替える際に、このプロパティを使用する(*note
     Bidirectional Display::を参照)。未割り当てのコード
     ポイントにたいする値は、そのコードポイントが属する
     コードブロックに依存する。未割り当てのコードポイン
     トのほとんどは‘L’(強い左方向)だが、‘AL’( Arabic
     letter: アラビア文字)や‘R’(強い右方向)を受け取るコ
     ースポイントもいくつかある。

‘decomposition’
     Unicodeプロパティの‘Decomposition_Type’と
     ‘Decomposition_Value’に対応する。値は、最初の要素が
     ‘small’のような互換性のあるフォーマットタグ
     (compatibility formatting tag)であるかもしれないリ
     ストである(1)。他の要素は、その文字の互換性のある分
     割シーケンス(compatibility decomposition sequence)を
     与える文字です。未割り当てのコードポイントにたいす
     る値は、その文字自身。

‘decimal-digit-value’
     ‘Numeric_Type’が‘Decimal’であるような文字Unicodeプ
     ロパティ‘Numeric_Value’に対応する。値は整数。未割り
     当てのコードポイントにたいする値は、
     NaN(“not-a-number”: 数字ではない)を意味する‘nil’。

‘digit-value’
     ‘Numeric_Type’が‘Digit’であるような文字の、
     Unicodeプロパティ‘Numeric_Value’に対応する。値は整
     数。このような文字には、互換性のある添字や上付き数
     字が含まれ、値は対応する数字である。未割り当てのコ
     ードポイントにたいする値は、NaNを意味する‘nil’であ
     る。

‘numeric-value’
     ‘Numeric_Type’が‘Numeric’であるような文字の、
     Unicodeプロパティ‘Numeric_Value’に対応する。このプ
     ロパティの値は数字。このプロパティをもつ文字の例に
     は分数、添字、上付き数字、ローマ数字、通貨分数(訳注
     : 原文は“currency numerators”でベンガル語の分数値用
     の歴史的な記号を指すと思われる)、丸数字が含まれる。
     たとえば、文字‘U+2155’(VULGAR FRACTION ONE FIFTH:
     (訳注)スラッシュで分子と分母を区切った表記による5分
     の1のこと)にたいするこのプロパティの値は‘0.2’。未割
     り当てのコードポイントにたいする値は、NaNを意味する
     ‘nil’。

‘mirrored’
     Unicodeプロパティ‘Bidi_Mirrored’に対応する。このプ
     ロパティの値は、‘Y’または‘N’いずれかのシンボル。未
     割り当てのコードポイントにたいする値は‘N’。

‘mirroring’
     Unicodeプロパティ‘Bidi_Mirroring_Glyph’に対応する。
     このプロパティの値は、そのグリフ(glyph)がその文字の
     グリフの鏡像(mirror image)を表すような文字、定義済
     みの鏡像グリフがなければ‘nil’である。‘mirrored’プロ
     パティが‘N’であるようなすべての文字の‘mirroring’プ
     ロパティは‘nil’である。しかし‘mirrored’プロパティが
     ‘Y’の文字でも、鏡像をもつ適切な文字がないという理由
     により、‘mirroring’が‘nil’の文字もある。Emacsは適切
     な際は、鏡像を表示するためにこのプロパティを使用す
     る(*note Bidirectional Display::を参照)。未割り当て
     のコードポイントにたいする値は‘nil’。

‘old-name’
     Unicodeプロパティ‘Unicode_1_Name’に対応する。値は文
     字列。未割り当てのコードポイント、およびこのプロパ
     ティにたいする値をもたない文字では、値は‘nil’である
     。

‘iso-10646-comment’
     Unicodeプロパティ‘ISO_Comment’に対応する。値は文字
     列。未割り当てのコードポイントの値は空文字列。

‘uppercase’
     Unicodeプロパティ‘Simple_Uppercase_Mapping’に対応す
     る。このプロパティの値は、単一の文字。未割り当ての
     コードポイントの値は‘nil’で、これはその文字自身を意
     味する。

‘lowercase’
     Unicodeプロパティ‘Simple_Lowercase_Mapping’に対応す
     る。このプロパティの値は、単一の文字。未割り当ての
     コードポイントの値は‘nil’で、これはその文字自身を意
     味する。

‘titlecase’
     Unicodeプロパティ‘Simple_Titlecase_Mapping’に対応す
     る。“タイトルケース(title case)”とは、単語の最初の
     文字を大文字にする必要がある際に使用される、文字の
     特別な形式のこと。このプロパティの値は、単一の文字
     。未割り当てのコードポイントにたいする値は‘nil’で、
     これはその文字自身を意味する。

 -- Function: get-char-code-property char propname
     この関数は、CHARのプロパティPROPNAMEの値をリターン
     する。

          (get-char-code-property ?\s 'general-category)
               ⇒ Zs
          (get-char-code-property ?1 'general-category)
               ⇒ Nd
          ;; subscript 4
          (get-char-code-property ?\u2084 'digit-value)
               ⇒ 4
          ;; one fifth
          (get-char-code-property ?\u2155 'numeric-value)
               ⇒ 0.2
          ;; Roman IV
          (get-char-code-property ?\u2163 'numeric-value)
               ⇒ 4

 -- Function: char-code-property-description prop value
     この関数はプロパティPROPのVALUEの説明文字列
     (description string)、VALUEが説明をもたなければ
     ‘nil’をリターンする。

          (char-code-property-description 'general-category 'Zs)
               ⇒ "Separator, Space"
          (char-code-property-description 'general-category 'Nd)
               ⇒ "Number, Decimal Digit"
          (char-code-property-description 'numeric-value '1/5)
               ⇒ nil

 -- Function: put-char-code-property char propname value
     この関数は、文字CHARのプロパティPROPNAMEの値として
     、VALUEを格納する。

 -- Variable: unicode-category-table
     この変数の値は、それぞれの文字にたいして、その
     Unicodeプロパティ‘General_Category’をシンボルとして
     指定する、文字テーブルである(*note Char-Tables::を
     参照)。

 -- Variable: char-script-table
     この変数の値は、それぞれの文字がシンボルを指定する
     ような文字テーブルである。シンボルの名前は、
     Unicodeコードスペースからスクリプト固有ブロックへの
     Unicode標準分類にしたがった、その文字が属するスクリ
     プトである。この文字テーブルは余分のスロットを１つ
     もち、値はすべてのスクリプトシンボルのリストである
     。

 -- Variable: char-width-table
     この変数の値は、、それぞれの文字がスクリーン上で占
     めるであろう幅を列単位で指定する、文字テーブルであ
     る。

 -- Variable: printable-chars
     この変数の値は、それぞれの文字にたいして、それがプ
     リント可能かどうかを指定する、文字テーブルである。
     すなわち、‘(aref printable-chars char)’を評価した結
     果が‘t’ならプリント可で、‘nil’なら不可である。

   ---------- Footnotes ----------

   (1) Unicode仕様ではこれらのタグ名を‘<..>’カッコ内に記
述しますが、Emacsでのタグ名にはカッコは含まれません。
Unicodeでの‘<small>’指定は、Emacsでは‘small’となります。


File: elisp,  Node: Character Sets,  Next: Scanning Charsets,  Prev: Character Properties,  Up: Non-ASCII Characters

32.7 Character Sets
===================

Emacsの“文字セット(character set、もしくはcharset)”とは
、それぞれの文字が数字のコードポイントに割り当てられれた
、文字セットのことです(Unicode標準ではこれを“符号化文字
集合(coded character set)”と呼ぶ)。Emacsの各文字セットは
、シンボルであるような名前をもちます。1つの文字が、任意
の数の異なる文字セットに属することができますが、各文字セ
ット内で異なるコードポイントをもつのが一般的でしょう。文
字セットの例には‘ascii’、‘iso-8859-1’、
‘greek-iso8859-7’、‘windows-1255’が含まれます。文字セッ
ト内で文字に割り当てられるコードポイントは、Emacs内のバ
ッファーや文字列内で使用されるコードポイントとは、通常異
なります。

   Emacsは、特別な文字セットをいくつか定義しています。文
字セット‘unicode’は、Emacsコードポイントが
‘0..#x10FFFF’の範囲の、すべての文字セットを含みます。文
字セット‘emacs’は、すべてのASCII、および非ASCII文字を含
みます。最後に‘eight-bit’文字セットは、8ビットrawバイト
を含みます。テキスト内でrawバイトを見つけたときに、
Emacsはこれを使用します。

 -- Function: charsetp object
     OBJECTは文字セットを命名するシンボルなら‘t’、それ以
     外は‘nil’をリターンする。

 -- Variable: charset-list
     値は、すべての定義済み文字セットの名前のリストであ
     る。

 -- Function: charset-priority-list &optional highestp
     この関数は、すべての定義済み文字セットの優先順にソ
     ートされたリストをリターンする。HIGHESTPが非‘nil’な
     ら、この関数はもっとも優先度の高い文字セット1つをリ
     ターンする。

 -- Function: set-charset-priority &rest charsets
     この関数は、CHARSETSをもっとも高い優先度の文字セッ
     トにする。

 -- Function: char-charset character &optional
          restriction
     この関数は、CHARACTERが属する文字セットで、もっとも
     優先度の高い文字セットの名前をリターンする。ただし
     ASCII文字は例外であり、この関数は常に‘ascii’をリタ
     ーンする。

     RESTRICTIONが非‘nil’なら、それは検索する文字セット
     のリストであること。かわりにコーディングシステムも
     指定でき、その場合はそのコーディングシステムにより
     サポートされている必要がある(*note Coding
     Systems::を参照)。

 -- Function: charset-plist charset
     この関数は、文字セットCHARSETのプロパティをリターン
     する。たとえCHARSETがシンボルだったとしても、これは
     そのシンボルのプロパティリストと同じではない。文字
     セットプロパティにはドキュメント文字列、短い名前等
     、その文字セットに関する重要な情報が含まれる。

 -- Function: put-charset-property charset propname
          value
     この関数は、CHARSETのプロパティPROPNAMEに、与えられ
     たVALUEをセットする。

 -- Function: get-charset-property charset propname
     この関数は、CHARSETのプロパティPROPNAMEの値をリター
     ンする。

 -- Command: list-charset-chars charset
     このコマンドは、文字セットCHARSET内の文字のリストを
     表示する。

   Emacsは文字の内部的な表現と、その文字の特定の文字セッ
ト内でのコードポイントを相互に変換することができます。以
下は、これらをサポートするための関数です。

 -- Function: decode-char charset code-point
     この関数は、CHARSET内でCODE-POINTに割り当てられた文
     字を、Emacsの対応する文字にデコードして、それをリタ
     ーンする。そのコードポイントの文字がCHARSETに含まれ
     なければ、値は‘nil’である。CODE-POINTがLisp整数
     (*note most-positive-fixnum: Integer Basics.を参照
     )に収まらない場合は、コンスセル‘(HIGH . LOW)’として
     指定できるかもしれない。ここでLOWはその値の下位来る
     16ビット、HIGHは上位16ビットである。

 -- Function: encode-char char charset
     この関数は、CHARSET内で文字CHARに割り当てられた、コ
     ードポイントをリターンする。結果がLisp整数に収まら
     ない場合は、上述の‘decode-char’の2つ目の引数のよう
     に、コンスセル‘(HIGH . LOW)’としてリターンされる。
     CHARSETがCHARにたいするコードポイントをもたなければ
     、値は‘nil’である。

   以下の関数は、文字セット内の文字の一部、全くすべてに
たいして、特定の関数を適用するのに便利です。

 -- Function: map-charset-chars function charset
          &optional arg from-code to-code
     CHARSET内の文字にたいしてFUNCTIONを呼び出す。
     FUNCTIONは2つの引数で呼び出される。1つ目はコンスセ
     ル‘(FROM . TO)’で、FROMとTOは文字セット内に含まれる
     文字の範囲である。ARGは、2つ目の引数として
     FUNCTIONに渡される。

     デフォルトでは、FUNCTIONに渡されるコードポイントの
     範囲にはCHARSET内のすべての文字が含まれるが、オプシ
     ョン引数FROM-CODEおよびTO-CODEにより、それは
     CHARSETの2つのコードポイント間にある文字範囲に制限
     される。FROM-CODEまたはTO-CODEのいずれかが‘nil’の場
     合のデフォルトは、CHARSETのコードポイントの最初また
     は最後である。


File: elisp,  Node: Scanning Charsets,  Next: Translation of Characters,  Prev: Character Sets,  Up: Non-ASCII Characters

32.8 Scanning for Character Sets
================================

特定の文字が、どの文字セットに属するか調べられると便利な
ときがあります。これの用途の1つは、どのコーディングシス
テム(*note Coding Systems::を参照)が問題となっているテキ
ストすべてを表現可能か判断することです。他にも、そのテキ
ストを表示するフォントの判断があります。

 -- Function: charset-after &optional pos
     この関数は、カレントバッファー内の位置POSにある文字
     を含む、 もっとも高い優先度の文字セットをリターンす
     る。POSが省略または‘nil’の場合のデフォルトは、ポイ
     ントのカレント値である。POSが範囲外なら、値は
     ‘nil’。

 -- Function: find-charset-region beg end &optional
          translation
     この関数は、カレントバッファー内の位置BEGからENDの
     間の文字を含む、もっとも優先度の高い文字セットのリ
     ストをリターンする。

     オプション引数がTRANSLATIONは、テキストのスキャンに
     使用するための変換テーブルを指定する(*note
     Translation of Characters::を参照)。これが非‘nil’な
     ら、リージョン内の各文字はそのテーブルを通じて変換
     され、リターンされる値にはバッファーの実際の文字で
     はなく、変換された文字が記述される。

 -- Function: find-charset-string string &optional
          translation
     この関数は、STRING内の文字を含む、もっとも優先度の
     高い文字セットのリストをリターンする。これは
     ‘find-charset-region’と似ているが、カレントバッファ
     ーの一部ではなくSTRINGのコンテンツに適用される点が
     異なる。


File: elisp,  Node: Translation of Characters,  Next: Coding Systems,  Prev: Scanning Charsets,  Up: Non-ASCII Characters

32.9 Translation of Characters
==============================

“変換テーブル(translation table)”とは？文字から文字への
マッピングを指定する、文字テーブルです(*note
Char-Tables::を参照)。これらのテーブルはエンコーディング
、デコーディング、および他の用地にも使用されます。独自に
変換テーブルを指定するコーディングシステムも、いくつかあ
ります。他のすべてのコーディングシステムに適用される、デ
フォルトの変換テーブルも存在します。

   変換テーブルには、余分のスロットが2つあります。1つ目
のスロットは‘nil’、または逆の変換を処理する変換テーブル
です。2つ目のスロットは、変換する文字シーケンスを照合す
る際の、最大文字数です(以下の
‘make-translation-table-from-alist’の説明を参照)。

 -- Function: make-translation-table &rest translations
     この関数は、引数TRANSLATIONSにもとづいて、変換テー
     ブルをリターンする。TRANSLATIONSの各要素は、‘(FROM
     . TO)’という形式のリストであること。これはFROMから
     TOへの、文字の変換を指示する。

     各引数内の引数とフォームは順に処理され、もし前のフ
     ォームですでにTOがたとえばTO-ALTに変換されていれば
     、FROMもTO-ALTに変換される。

   デコードを行う間、その変換テーブルの変換は、通常のデ
コーディングの結果の文字に適用されます。あるコーディング
システムがプロパティ‘:decode-translation-table’をもつな
ら、それは使用する変換テーブル、または順に適用するべき変
換テーブルのリストを指定します(これはコーディングシステ
ムの名前であるようなシンボルのプロパティではなく、
‘coding-system-get’がリターンするような、コーディングシ
ステムのプロパティである。*note Basic Concepts of Coding
Systems: Coding System Basics.を参照されたい)。最後に、
もし‘standard-translation-table-for-decode’が非‘nil’なら
、結果となる文字はそのテーブルにより変換されます。

   エンコードを行う間は、その変換テーブルの変換はバッフ
ァー内の文字に適用され、変換結果は実際にエンコードされま
す。あるコーディングシステムがプロパティ
‘:encode-translation-table’をもつなら、それは使用する変
換テーブル、または順に適用するべき変換テーブルのリストを
指定します。加えて、もし変数
‘standard-translation-table-for-encode’が非‘nil’なら、そ
れは変換結果にたいして使用するべき変換テーブルを指定しま
す。

 -- Variable: standard-translation-table-for-decode
     これはデコード用のデフォルトの変換テーブルである。
     あるコーディングシステムが独自に変換テーブルを指定
     する場合、この変数の値が非‘nil’なら、それら独自のテ
     ーブル適用後に、この変数の変換テーブルが適用される
     。

 -- Variable: standard-translation-table-for-encode
     これはエンコード用のデフォルトの変換テーブルである
     。あるコーディングシステムが独自に変換テーブルを指
     定する場合、この変数の値が非‘nil’なら、それら独自の
     テーブル適用後に、この変数の変換テーブルが適用され
     る。

 -- Variable: translation-table-for-input
     自己ソウニュ文字は、挿入前にこの変換テーブルを通じ
     て変換が行われる。検索コマンドも、バッファー内の内
     容とより信頼性のある比較ができるように、このテーブ
     ルを通じて入力を変換する。

     この変数は、セット時に自動的にバッファーローカルに
     なる。

 -- Function: make-translation-table-from-vector vec
     この関数は、バイト(値は0から#xFF)から文字にマップす
     る256要素の配列であるようなVECから作成した変換テー
     ブルをリターンする。未変換のバイトにたいする要素は
     、‘nil’かもしれない。リターンされるテーブルは、余分
     な1つ目のスロットにそのマッピングを保持する変換テー
     ブル、2つ目の余分なスロットに値‘1’をもつ。

     この関数は、各バイトを特定の文字にマップするような
     、プライベートなコーディングシステムを簡単に作成す
     る手段を提供する。‘define-coding-system’のPROPS引数
     のプロパティ‘:decode-translation-table’と
     ‘:encode-translation-table’に、リターンされるテーブ
     ルと、逆変換テーブルを指定できる。

 -- Function: make-translation-table-from-alist alist
     この関数は‘make-translation-table’と似ているが、シ
     ンプルな1体1の変換テーブルではなく、より複雑な変換
     テーブルをリターンする。ALISTの各要素は‘(FROM .
     TO)’という形式をもち、ここでFROMおよびTOは、文字ま
     たは文字シーケンスを指定するベクターである。FROMが
     文字なら、その文字はTO(文字または文字シーケンス)に
     変換される。FROMが文字のベクターならそのシーケンス
     はTOに変換される。リターンされるテーブルは、1つ目の
     余分なスロットに逆のマッピングを行う変換テーブル、
     2つ目の余分なスロットには文字シーケンスFROMすべての
     最大長をもつ。


File: elisp,  Node: Coding Systems,  Next: Input Methods,  Prev: Translation of Characters,  Up: Non-ASCII Characters

32.10 Coding Systems
====================

Emacsがファイルにたいして読み書きを行う際、およびEmacsが
サブプロセスとテキストの送受信を行う際、通常は特定の“コ
ーディングシステム(coding system)”の指定にしたがって文字
コード変換および行末変換を行います。

   コーディングシステムの定義は難解な問題であり、ここに
は記述しません。

* Menu:

* Coding System Basics::     基本的な概念。
* Encoding and I/O::         ファイル入出力関数がコーディングシステムを扱う方法。
* Lisp and Coding Systems::  コーディングシステム名を処理する関数。
* User-Chosen Coding Systems::  ユーザーにコーディングシステムの選択を求める。
* Default Coding Systems::   デフォルトの選択の制御。
* Specifying Coding Systems::  単一ファイル処理にたいして特定のコーディングシステムを要求する。
* Explicit Encoding::        入出力を伴わないテキストのエンコードおよびデコード。
* Terminal I/O Encoding::    端末入出力にたいするエンコーディングの使用。


File: elisp,  Node: Coding System Basics,  Next: Encoding and I/O,  Up: Coding Systems

32.10.1 Basic Concepts of Coding Systems
----------------------------------------

“文字コード変換(character code conversion)”により、
Emacs内部で使用される文字の内部表現と他のエンコーディン
グの間で、変換が行われます。Emacsは多くの異なるエンコー
ディングをサポートしており、それらは双方向に変換が可能で
す。たとえばLatin 1、Latin 2、Latin 3、Latin 4、Latin 5、
およびいくつかのISO 2022の変種等のようなエンコーディング
にたいして、テキストを双方向に変換できます。あるケースに
おいては、同じ文字にたいしてEmacsは複数のエンコーディン
グ候補をサポートします。たとえばキリル(ロシア語)のアルフ
ァベットにたいしてはISO、Alternativnyj、KOI8のように3つ
にコーディングシステムが存在します。

   コーディングシステムはそれぞれ特定の文字コード変換セ
ットを指定しますが、‘undecided’というコーディングシステ
ムは特別です。これはそれぞれのファイルにたいして、そのフ
ァイルのデータにもとづいて発見的に選択が行われるように、
選択を未指定のままにします。

   一般的に、コーディングシステムは可逆的な同一性を保証
しません。あるコーディングシステムを使用してバイトシーケ
ンスをデコードしてから、同じコーディングシステムで結果テ
キストをエンコードしても、異なるバイトシーケンスが生成さ
れる可能性があります。しかし、デコードされたオリジナルの
バイトシーケンスとなることを保証するコーディングシステム
もいくつかあります。以下にいくつかの例を挙げます:

     iso-8859-1、utf-8、big5、shift_jis、euc-jp

   バッファーテキストのエンコードと結果のデコードでも、
オリジナルテキストの再生成に失敗する可能性があります。た
とえば、その文字をサポートしないコーディングシステムで文
字をエンコードした場合の結果は予測できず、したがって同じ
コーディングシステムを使用してそれをデコードしても、異な
るテキストが生成されるでしょう。現在のところ、Emacsは未
サポート文字のエンコーディングによる結果をエラーとして報
告できません。

   “行末変換(end of line conversion: 改行変換)”は、ファ
イル内の行末を表すために、さまざまなシステム上で使用され
る3つの異なる慣例を扱います。GNUやUnixシステムで使用され
るUnixの慣例では、LF文字(linefeed文字、改行とも呼ばれる
)が使用されます。MS-WindowsやMS-DOSシステムで使用される
DOSの慣例では、行末にCR文字(carriage-return文字、復帰文
字とも呼ばれる)とLF文字が使用されますMacの慣例ではCR文字
だけが使用されます(これはOS X以前のMacintoshシステムで使
用されていた慣例である)。

   ‘latin-1’のような“ベースコーディングシステム(base
coding systems: 基本コーディングシステム)”では、データに
もとづいて選択されるよう、行末変換は未指定となっています
。‘latin-1-unix’、‘latin-1-dos’、‘latin-1-mac’のような
“バリアントコーディングシステム(variant coding systems:
変種コーディングシステム)”では、行末変換を明示的に指定し
ます。ほとんどのベースコーディングシステムは‘-unix’、
‘-dos’、‘-mac’を追加した形式の、3つの対応する変種をもち
ます。

   ‘raw-text’は、文字コード変換を抑制して、このコーディ
ングシステムでvisitされたバッファーがユニバイトバッファ
ーとなる点において、特殊なコーディングシステムです。歴史
的な理由により、このコーディングシステムによりユニバイト
およびマルチバイト両方のテキストを保存できます。マルチバ
イトテキストのエンコードに‘raw-text’を使用した際は、1文
字コード変換を行います。8ビット文字は、1バイトの外部表現
に変換されます。‘raw-text’は通常のようにデータにより判断
できるように行末変換を指定せず、通常のように行末変換を指
定する3つの変種をもちます。

   ‘no-conversion’(とエイリアスの‘binary’)は、
‘raw-text-unix’と等価です。これは文字コードおよび行末に
たいする変換をいずれもしてくださいしません。

   ‘utf-8-emacs’は、データがEmacsの内部エンコーディング
(*note Text Representations::を参照)で表されることを指定
するコーディングシステムです。コード変換が何も発生しない
点で、これは‘raw-text’と似ていますが、結果がマルチバイト
データである点が異なります。The name ‘emacs-internal’と
いう名前は、‘utf-8-emacs’にたいするエイリアスです。

 -- Function: coding-system-get coding-system property
     この関数は、コーディングシステムCODING-SYSTEMの、指
     定されたプロパティをリターンする。コーディングシス
     テムのプロパティのほとんどは内部的な目的のために存
     在するが、‘:mime-charset’については有用と思うかもし
     れない。このプロパティの値は、そのコーディングシス
     テムが読み書きできる文字コードにたいしてMIME内で使
     用される名前である。以下に例を示す:

          (coding-system-get 'iso-latin-1 :mime-charset)
               ⇒ iso-8859-1
          (coding-system-get 'iso-2022-cn :mime-charset)
               ⇒ iso-2022-cn
          (coding-system-get 'cyrillic-koi8 :mime-charset)
               ⇒ koi8-r

     ‘:mime-charset’プロパティの値は、そのコーディングシ
     ステムにたいするエイリアスとしても定義されている。

 -- Function: coding-system-aliases coding-system
     この関数は、CODING-SYSTEMのエイリアスのリストをリタ
     ーンする。


File: elisp,  Node: Encoding and I/O,  Next: Lisp and Coding Systems,  Prev: Coding System Basics,  Up: Coding Systems

32.10.2 Encoding and I/O
------------------------

コーディングシステムの主な目的は、ファイルの読み込みと書
き込みへの使用です。関数‘insert-file-contents’はファイル
データのデコードにコーディングシステムを使用し、
‘write-region’はバッファーコンテンツのエンコードにコーデ
ィングシステムを使用します。

   使用するコーディングシステムは明示的(*note Specifying
Coding Systems::を参照)、またはデフォルトメカニズム
(*note Default Coding Systems::を参照)を使用により暗黙的
に指定できます。しかしきれらの手法は、何を行うかを完全に
は指定しないかもしれません。たとえば、これらはデータから
文字コード変換を行わない‘undefined’のようなコーディング
システムを選択するかもしれません。このような場合、I/O処
理はコーディングシステム選択により、その処理を完了します
。後でどのコーディングシステムが選択されたか調べたいこと
が、頻繁にあるでしょう。

 -- Variable: buffer-file-coding-system
     このバッファーローカル変数は、バッファーの保存、お
     よび‘write-region’によるバッファー部分のファイルへ
     の書き出しに使用されるコーディングシステムを記録す
     る。書き込まれるテキストが、この変数で指定されたコ
     ーディングシステムを使用して安全にエンコードできな
     い場合、これらの操作は関数
     ‘select-safe-coding-system’を呼び出すことにより、代
     替となるエンコーディングを選択する(*note
     User-Chosen Coding Systems::を参照)。異なるエンコー
     ディングの選択が、ユーザーによるコーディングシステ
     ムの指定を要するなら、‘buffer-file-coding-system’は
     新たに選択されたコーディングシステムに更新される。

     ‘buffer-file-coding-system’は、サブプロセスへのテキ
     スト送信に_影響しない_。

 -- Variable: save-buffer-coding-system
     この変数は、(‘buffer-file-coding-system’をオーバー
     ライドして)バッファーを保存するためのコーディングシ
     ステムを指定する。これは‘write-region’には使用され
     ないことに注意。

     あるコマンドがバッファーを保存するために
     ‘buffer-file-coding-system’(または
     ‘save-buffer-coding-system’)の使用を開始して、その
     コーディングシステムがバッファー内の実際のテキスト
     を処理できなければ、(‘select-safe-coding-system’を
     呼び出すことにより)そのコマンドは他のコーディングシ
     ステムの選択をユーザーに求める。これが発生した後は
     、コマンドはユーザー指定のコーディングシステムを表
     すために、‘buffer-file-coding-system’の更新も行う。

 -- Variable: last-coding-system-used
     ファイルおよびサブプロセスにたいするI/O操作は、使用
     したコーディングシステムの名前を、この変数にセット
     する。明示的にエンコードとデコードを行う関数(*note
     Explicit Encoding::を参照)も、この変数をセットする
     。

     *警告:* サブプロセス出力の受信によりこの変数がセッ
     トされるため、この変数はEmacsがwaitしているとくは常
     に変更され得る。したがって、興味対象となる値を格納
     する関数呼び出し後は、間を空けずにその値をコピーす
     るべきである。

   変数‘selection-coding-system’はウィンドウシステムにた
いして、選択(selection)をエンコードする方法を指定します
。*note Window System Selections::を参照してください。

 -- Variable: file-name-coding-system
     変数‘file-name-coding-system’は、ファイル名のエンコ
     ーディングに使用するコーディングシステムを指定する
     。Emacsは、すべてのファイル操作にたいして、ファイル
     名のエンコードにそのコーディングシステムを使用する
     。‘file-name-coding-system’が‘nil’なら、Emacsは選択
     された言語環境(language environment)により決定され
     た、デフォルトのコーディングシステムを使用する。デ
     フォルト言語環境では、ファイル名に含まれるすべての
     非ASCII文字は、特別にエンコードされない。これらは
     Emacsの内部表現を使用して、ファイルシステム内で表さ
     れる。

   *警告:* Emacsのセッション中に
‘file-name-coding-system’(または言語環境)を変更した場合
、以前のコーディングシステムを使用してエンコードされた名
前をもつファイルをvisitしていると、新たなコーディングシ
ステムでは異なるように扱われるので、問題が発生し得る。こ
れらのvisitされたファイル名でこれらのバッファーの保存を
試みると、保存により間違ったファイル名が使用されるか、エ
ラーとなるかもしれない。そのような問題が発生したら、その
バッファーにたいして新たなファイル名を指定するために、
‘C-x C-w’を使用すること。

   Windows 2000以降では、EmacsはOSに渡すファイル名にデフ
ォルトでUnicode APIを使用するため、
‘file-name-coding-system’の値は大部分が無視される。
Lispレベルでファイル名のエンコードまたはデコードを必要と
するLispアプリケーションは、‘system-type’が
‘windows-nt’のときは、‘utf-8’をコーディングシステムに使
用するべきである。UTF-8でエンコードされたファイル名から
、OSと対話するために適したエンコーディングへの変換は、
Emacsにより内部的に処理される。


File: elisp,  Node: Lisp and Coding Systems,  Next: User-Chosen Coding Systems,  Prev: Encoding and I/O,  Up: Coding Systems

32.10.3 Coding Systems in Lisp
------------------------------

以下はコーディングシステムと連携するLisp機能です:

 -- Function: coding-system-list &optional base-only
     この関数は、すべてのコーディングシステムの名前(シン
     ボル)をリターンする。BASE-ONLYが非‘nil’なら、値には
     ベースコーディングシステムだけが含まれる。それ以外
     ならエイリアス、およびバリアントコーディングシステ
     ムも同様に含まれる。

 -- Function: coding-system-p object
     この関数は、OBJECTがコーディングシステムの名前、ま
     たは‘nil’なら、‘t’をリターンする。

 -- Function: check-coding-system coding-system
     この関数は、CODING-SYSTEMの有効性をチェックする。有
     効ならCODING-SYSTEMをリターンする。CODING-SYSTEMが
     ‘nil’なら、この関数は‘nil’をリターンする。それ以外
     の値にたいしては、‘error-symbol’が
     ‘coding-system-error’であるようなエラーをシグナルす
     る(*note signal: Signaling Errors.を参照)。

 -- Function: coding-system-eol-type coding-system
     この関数は、行末(“eol”とも言う)をCODING-SYSTEMで使
     用されるタイプに変換する。CODING-SYSTEMが特定の
     eol変換を指定する場合、リターン値は0、1、2で、それ
     らは順に‘unix’、‘dos’、‘mac’を意味する。
     CODING-SYSTEMが明示的にeol変換を指定しなければ、リ
     ターン値は以下のようにそれぞれが可能なeol変換タイプ
     をもつようなコーディングシステムのベクターである:

          (coding-system-eol-type 'latin-1)
               ⇒ [latin-1-unix latin-1-dos latin-1-mac]

     この関数がベクターをリターンしたら、Emacsはテキスト
     のエンコードやデコードプロセスの一部として、使用す
     るeol変換を決定するだろう。デコードでは、テキストの
     行末フォーマットは自動検知され、eol変換はそれに適合
     するようセットされる(DOSスタイルのCRLFフォーマット
     は暗黙でeol変換に‘dos’をセットする)。エンコードにた
     いしては、適切なデフォルトコーディングシステム
     (‘buffer-file-coding-system’にたいする
     ‘buffer-file-coding-system’のデフォルト値)、または
     配下にあるプラットフォームにたいして適切なデフォル
     トeol変換が採用される。

 -- Function: coding-system-change-eol-conversion
          coding-system eol-type
     この関数は、CODING-SYSTEMと類似するが、‘eol-type’で
     指定されたeol変換の異なるコーディングシステムをリタ
     ーンする。EOL-TYPEは‘unix’、‘dos’、‘mac’、または
     ‘nil’であること。これが‘nil’なら、リターンされるコ
     ーディングシステムは、データのeol変換により決定され
     る。

     EOL-TYPEは‘unix’、‘dos’、‘mac’を意味する0、1、2でも
     よい。

 -- Function: coding-system-change-text-conversion
          eol-coding text-coding
     この関数は、EOL-CODINGの行末変換と、TEXT-CODINGのテ
     キスト変換を使用するコーディングシステムをリターン
     する。TEXT-CODINGが‘nil’なら、これは‘undecided’、ま
     たはEOL-CODINGに対応するバリアントの1つをリターンす
     る。

 -- Function: find-coding-systems-region from to
     この関数は、FROMとTOの間のテキストのエンコードに使
     用可能な、コーディングシステムのリストをリターンす
     る。このリスト内のすべてのリストは、そのテキスト範
     囲内にあるすべてのマルチバイト文字を、安全にエンコ
     ードできる。

     そのテキストがマルチバイト文字を含まれなければ、こ
     の関数はリスト‘(undecided)’をリターンする。

 -- Function: find-coding-systems-string string
     この関数は、STRINGのテキストのエンコードに使用可能
     な、コーディングシステムのリストをリターンする。こ
     のリスト内のすべてのリストは、STRINGにあるすべての
     マルチバイト文字を、安全にエンコードできる。そのテ
     キストがマルチバイト文字を含まれなければ、この関数
     はリスト‘(undecided)’をリターンする。

 -- Function: find-coding-systems-for-charsets charsets
     この関数は、リストCHARSETS内のすべての文字セットの
     エンコードに使用可能な、コーディングシステムのリス
     トをリターンする。

 -- Function: check-coding-systems-region start end
          coding-system-list
     この関数は、リスト‘coding-system-list’内のコーディ
     ングシステムが、STARTとENDの間のリージョン内にある
     すべての文字をエンコード可能かどうかをチェックする
     。このリスト内のすべてのコーディングシステムが指定
     されたテキストをエンコード可能なら、この関数は
     ‘nil’をリターンする。ある文字をエンコードできないコ
     ーディングシステムがある場合は、各要素が
     ‘(CODING-SYSTEM1 POS1 POS2 ...)’という形式のalistが
     値となる。これはCODING-SYSTEM1が、バッファーの位置
     POS1、POS2、...にある文字をエンコードできないことを
     意味する。

     STARTは文字列かもしれず、その場合ENDは無視され、リ
     ターン値はバッファー位置のかわりに文字列のインデッ
     クスを参照することになる。

 -- Function: detect-coding-region start end &optional
          highest
     この関数は、STARTからENDのテキストのデコードに適し
     たコーディングシステムを選択する。このテキストはバ
     イトシーケンス、すなわちユニバイトテキスト、ASCIIの
     みのマルチバイトテキスト、8ビット文字のシーケンスで
     あること(*note Explicit Encoding::を参照)。

     この関数は通常はスキャンしたテキストのデコーディン
     グを処理可能な、コーディングシステムのリストをリタ
     ーンする。これらのコーディングシステムは優先度降順
     でリストされる。しかしHIGHESTが非‘nil’なら、リター
     ン値はもっとも高い優先度のコーディングシステムただ
     1つとなる。

     リージョンにISO-2022の‘ESC’のようなISO-2022制御文字
     を除いてASCII文字だけが含まれる場合、値は
     ‘undecided’、‘(undecided)’、またはテキストから推論
     可能ならeol変換を指定するバリアントとなる。

     リージョンにnullバイトが含まれる場合は、あるコーデ
     ィングシステムによりエンコードされたテキストがリー
     ジョン内に含まれる場合でも、値は‘no-conversion’とな
     る。

 -- Function: detect-coding-string string &optional
          highest
     この関数は‘detect-coding-region’と似ているが、バッ
     ファー内のバイトのかわりにSTRINGのコンテンツを処理
     する点が異なる。

 -- Variable: inhibit-null-byte-detection
     この変数が非‘nil’値をもつなら、リージョンや文字列の
     エンコーディング検出時に、nullバイトを無視する。こ
     れによりIndexノードをもつInfoファイルのように、
     nullバイトを含むテキストのエンコーディングを正しく
     検出できる。

 -- Variable: inhibit-iso-escape-detection
     この変数が非‘nil’値をもつなら、リージョンや文字列の
     エンコーディング検出時に、ISO-2022エスケープシーケ
     ンスを無視する。その結果、これまでいくつかの
     ISO-2022エンコーディングにおいてエンコード済みと検
     出されていたテキストがなくなり、バッファー内ですべ
     てのエスケープシーケンスが可視になる。*警告:* この
     変数の使用には特に注意を払うこと。なぜならEmacsディ
     ストリビューション内で多くのファイルがISO-2022エン
     コーディングを使用するからである。

 -- Function: coding-system-charset-list coding-system
     この関数は、CODING-SYSTEMがサポートする文字セット
     (*note Character Sets::を参照)のリストをリターンす
     る。リストすべき文字セットを非常に多くサポートする
     いくつかのコーディングシステムでは、特別な値がリス
     トされる:
        • CODING-SYSTEMがすべてのEmacs文字をサポートする
          なら、値は‘(emacs)’。
        • CODING-SYSTEMがすべてのUnicode文字をサポートす
          るなら、値は‘(unicode)’。
        • CODING-SYSTEMがすべてのISO-2022文字をサポート
          するなら、値は‘iso-2022’。
        • CODING-SYSTEMがEmacsバージョン21(Unicodeサポー
          トの内部的な実装以前)で使用される内部的コーデ
          ィングシステム内のすべての文字をサポートするな
          ら、値は‘emacs-mule’。

   サブプロセスへの入出力に使用されるコーディングシステ
ムのチェックやセットの方法については、*note Process
Information: Coding systems for a subprocess.、特に関数
‘process-coding-system’および
‘set-process-coding-system’の説明を参照してください。


File: elisp,  Node: User-Chosen Coding Systems,  Next: Default Coding Systems,  Prev: Lisp and Coding Systems,  Up: Coding Systems

32.10.4 User-Chosen Coding Systems
----------------------------------

 -- Function: select-safe-coding-system from to
          &optional default-coding-system
          accept-default-p file
     この関数は、指定されたテキストをエンコードするため
     に、必要ならユーザーに選択を求めて、コーディングシ
     ステムを選択する。指定されるテキストは、通常はカレ
     ントバッファーのFROMとTOの間のテキストである。
     FROMが文字列なら、その文字列はエンコードするテキス
     トを指定し、TOは無視される。

     指定されたテキストにrawバイト(*note Text
     Representations::を参照)が含まれる場合、
     ‘select-safe-coding-system’はそのエンコーディングに
     ‘raw-text’を提案する。

     DEFAULT-CODING-SYSTEMが非‘nil’なら、それは試行すべ
     き最初のコーディングシステムである。それがテキスト
     を処理できるなら、‘select-safe-coding-system’はその
     コーディングシステムをリターンする。これはコーディ
     ングシステムのリストの可能性もある。その場合、この
     関数はそれらを1つずつ試みる。それらをすべて試した後
     に、(‘undecided’以外なら)カレントバッファーの
     ‘buffer-file-coding-system’の値、次に
     ‘buffer-file-coding-system’のデフォルト値、最後にユ
     ーザーがもっとも好むコーディングシステム(コマンド
     ‘prefer-coding-system’でセットできる最優先されるコ
     ーディングシステム)を試みる(*note Recognizing
     Coding Systems: (emacs)Recognize Coding.を参照)。

     これらのうちいずれかのコーディングシステムが指定さ
     れたテキストすべてを安全にエンコード可能なら、
     ‘select-safe-coding-system’はそれを選択およびリター
     ンする。それ以外なら、コーディングシステムのリスト
     からすべてのテキストをエンコードできるコーディング
     システムの選択をユーザーに求めて、ユーザーの選択を
     リターンする。

     DEFAULT-CODING-SYSTEMは、最初の要素がtで、他の要素
     がコーディングシステムであるようなリストかもしれな
     い。その場合、もしリスト内にテキストを処理できるコ
     ーディングシステムがなければ、
     ‘select-safe-coding-system’は上述した3つの代替えい
     ずれを試みることなく、即座にユーザーに問い合わせる
     。

     オプション引数ACCEPT-DEFAULT-Pが非‘nil’なら、それは
     ユーザーとの対話なしで選択されたコーディングシステ
     ムが許容できるかどうかを判断する関数であること。
     ‘select-safe-coding-system’は、選択されたコーディン
     グシステムのベースコーディングシステムを唯一の引数
     として、この関数を呼び出す。ACCEPT-DEFAULT-Pが
     ‘nil’うちリターンしたら、
     ‘select-safe-coding-system’は黙って選択されたコーデ
     ィングシステムを拒絶して、可能な候補リストからコー
     ディングシステムの選択をユーザーに求める。

     変数‘select-safe-coding-system-accept-defaultf-p’が
     非‘nil’なら、それは1つの引数をとる関数であること。
     これはACCEPT-DEFAULT-P引数に与えられた値をオーバー
     ライドすることにより、ACCEPT-DEFAULT-Pのかわりに使
     用される。

     最後のステップとして、選択されたコーディングシステ
     ムをリターンする前に、‘select-safe-coding-system’は
     、もしリージョンのコンテンツがファイルから読み込ま
     れたものだったとしたなら選択されたであろうコーディ
     ングシステムと、そのコーディングシステムが一致する
     かどうかをチェックする(異なるなら、その後の再
     visitと編集でファイル内のデータ汚染が起こり得る)。
     通常、‘select-safe-coding-system’はこの目的のための
     ファイルとして‘buffer-file-name’を使用するが、
     FILEが非‘nil’なら、かわりにそのファイルをかわりに使
     用する(これは‘write-region’、および類似の関数に関連
     し得る)。明らかな不一致が検出された場合、
     ‘select-safe-coding-system’はそのコーディングシステ
     ムを選択する前に、ユーザーに問い合わせる。

   以下の2つの関数は、補完つきでユーザーにコーディングシ
ステムの選択を求めるために使用できます。*note
Completion::を参照してください。

 -- Function: read-coding-system prompt &optional
          default
     この関数は、文字列PROMPTをプロンプトにミニバッファ
     ーを使用してコーディングシステムを読み取り、そのコ
     ーディングシステムの名前をシンボルとしてリターンす
     る。DEFAULTは、ユーザーの入力が空の場合にリターンす
     るべきコーディングシステムを指定する。これはシンボ
     ルまたは文字列であること。

 -- Function: read-non-nil-coding-system prompt
     この関数は、文字列PROMPTをプロンプトにミニバッファ
     ーを使用してコーディングシステムを読み取り、そのコ
     ーディングシステムの名前をシンボルとしてリターンす
     る。ユーザーが空の入力を試みると、再度ユーザーに問
     い合わせを行う。*note Coding Systems::を参照のこと
     。


File: elisp,  Node: Default Coding Systems,  Next: Specifying Coding Systems,  Prev: User-Chosen Coding Systems,  Up: Coding Systems

32.10.5 Default Coding Systems
------------------------------

このセクションでは、特定のファイルや特定のサブプロセス実
行時のデフォルトコーディングシステムを指定する変数、およ
びそれらへアクセスするためのI/O処理が使用する関数につい
て説明します。

   これらの変数は、希望するデフォルトにそれらすべてを一
度セットして、その後は再びそれを変更しないというアイデア
にもとづいています。Lispプログラム内の特定の処理で特定の
コーディングシステムを指定するために、これらの変数を変更
しないでください。かわりに‘coding-system-for-read’および
‘coding-system-for-write’を使用して、それらをオーバーラ
イドしてください(*note Specifying Coding Systems::を参照
)。

 -- User Option: auto-coding-regexp-alist
     この変数は、テキストパターンと対応するコーディング
     システムのalistである。要素はそれぞれ‘(REGEXP .
     CODING-SYSTEM)’という形式をもつ。冒頭の数キロバイト
     がREGEXPにマッチするファイルは、そのコンテンツをバ
     ッファーに読み込む際は、CODING-SYSTEMによりデコード
     される。このalist内のセッティングは、ファイル内の
     ‘coding:’タグ、および‘file-coding-system-alist’(以
     下参照)の内容より優先される。Emacsが自動的にBabylフ
     ォーマットのメールファイルを認識して、コード変換な
     しでそれらを読み取るよう、デフォルト値がセットされ
     ている。

 -- User Option: file-coding-system-alist
     この変数は、特定のファイルの読み書きに使用するコー
     ディングシステムを指定するalistである。要素はそれぞ
     れ‘(PATTERN . CODING)’という形式をもち、PATTERNは特
     定のファイル名にマッチする正規表現である。この要素
     はPATTERNにマッチするファイル名に適用される。

     要素のCDRとなるCODINGはコーディングシステム、2つの
     コーディングシステムを含むコンスセル、または関数名
     (関数定義をもつシンボル)であること。CODINGがコーデ
     ィングシステムなら、そのコーディングシステムはファ
     イルの読み込みと書き込みの両方で使用される。
     CODINGが2つのコーディングシステムを含むコンスセルな
     ら、CARはデコード用のコーディングシステム、CDRはエ
     ンコード用のコーディングシステムを指定する。

     CODINGが関数名なら、それは
     ‘find-operation-coding-system’に渡されたすべての引
     数からなるリストを唯一の引数とする関数であること。
     これはコーディングシステム、または2つのコーディング
     システムを含むコンスセルをリターンしなければならな
     い。この値は上記と同じ意味をもつ。

     CODING(または上記関数のリターン値)が‘undecided’なら
     、通常のコード検出が行われる。

 -- User Option: auto-coding-alist
     この変数は、特定のファイルの読み書きに使用するコー
     ディングシステムを指定するalistである。この変数の形
     式は‘file-coding-system-alist’の形式と似ているが、
     後者と異なるのは、この変数がファイル内の‘coding:’タ
     グより優先されることである。

 -- Variable: process-coding-system-alist
     この変数は、何のプログラムがサブプロセス内で実行中
     かによって、そのサブプロセスにたいしてどのコーディ
     ングシステムを使用するかを指定するalistである。これ
     は‘file-coding-system-alist’と同じように機能するが
     、PATTERNがそのサブプロセスを開始するために使用され
     たプログラム名にたいしてマッチされる点が異なる。コ
     ーディングシステム、またはalist内で指定されたコーデ
     ィングシステムは、そのサブプロセスへのI/Oに使用され
     るコーディングシステムの初期化に使用されるが、
     ‘set-process-coding-system’を使用して後から他のコー
     ディングシステムを指定できる。

   *警告:* データからコーディングシステムを判断する
‘undecided’のようなコーディングシステムは、非同期のサブ
プロセスでは完全な信頼性をもって機能はしない。これは
Emacsが非同期サブプロセスの出力を、到着によりバッチ処理
するためである。そのコーディングシステムが文字コード変換
、または行末変換を未指定にしておくと、Emacsは一度に1バッ
チから正しい変換の検出を試みなければならず、これは常に機
能するとは限らない。

   したがって非同期サブプロセスでは、可能なら文字コード
変換と行末変換の両方を判断するコーディングシステム、つま
り‘undecided’や‘latin-1’ではなく‘latin-1-unix’のようなコ
ーディングシステムを使用すること。

 -- Variable: network-coding-system-alist
     この変数は、ネットワークストリームに使用するコーデ
     ィングシステムを指定するalistである。これは
     ‘file-coding-system-alist’と同じように機能するが、
     要素内のPATTERNがポート番号、または正規表現かもしれ
     ない点が異なる。正規表現なら、そのネットワークスト
     リームのオープンに使用されたネットワークサービス名
     にたいしてマッチされる。

 -- Variable: default-process-coding-system
     この変数は、他に何を行うか指定されていない際に、サ
     ブプロセス(とネットワークストリーム)への入出力に使
     用するコーディングシステムを指定する。

     値は、‘(INPUT-CODING . OUTPUT-CODING)’という形式の
     コンスセルであること。ここでINPUT-CODINGはサブプロ
     セスからの入力、OUTPUT-CODINGはサブプロセスへの出力
     に適用される。

 -- User Option: auto-coding-functions
     この変数は、ファイルのデコードされていないコンテン
     ツにもとづいて、ファイルにたいするコーディングシス
     テムの判断を試みる関数のリストを保持する。

     このリスト内の各関数は、カレントバッファー内のテキ
     ストを調べるように、ただしいいかなる方法にせよそれ
     を変更しないよう記述されるべきである。そのバッファ
     ーは、ファイルの一部であるデコードされていないテキ
     ストを含むだろう。各関数はポイントを始点に何文字を
     調べる可を告げる、唯一の引数SIZEをとること。関数が
     、そのファイルにたいするコーディングシステムの決定
     に成功したら、そのコーディングシステムをリターンす
     ること。それ以外は‘nil’をリターンするべきである。

     ファイルに‘coding:’タグがある場合は、それが優先され
     るので、これらの関数が呼び出されることはないだろう
     。

 -- Function: find-auto-coding filename size
     この関数は、FILENAMEに適するコーディングシステムの
     判定を試みる。これは、上記で説明した変数により指定
     されたルールのいずれかにマッチするまで、それらの変
     数を順に使用して、ファイルをvisitするバッファーを調
     べる。そして‘(CODING . SOURCE)’という形式のコンスセ
     ルをリターンする。ここでCODINGは使用するコーディン
     グシステム、SOURCEはは‘auto-coding-alist’、
     ‘auto-coding-regexp-alist’、‘:coding’、
     ‘auto-coding-functions’のいずれかであるようなシンボ
     ルで、マッチングルールとして供されるルールを示す。
     値‘:coding’は、ファイル内の‘coding:’タグによりコー
     ディングシステムが指定されたことを意味する(*note
     coding tag: (emacs)Specify Coding.を参照)。マッチン
     グルールを調べる順序は‘auto-coding-alist’、
     ‘auto-coding-regexp-alist’、‘coding:’、
     ‘auto-coding-functions’の順である。マッチングルール
     が見つからなければ、この関数は‘nil’をリターンする。

     2つ目の引数SIZEは、ポイントの後のテキストの文字単位
     のサイズである。この関数は、ポイントの後のSIZE文字
     のテキストだけを調べる。‘coding:’タグが置かれる箇所
     としてはファイルの先頭2行が考えられる箇所の1つなの
     で、通常はバッファーの先頭位置で、この関数を呼び出
     すべきである。その場合、SIZEはそのバッファーのサイ
     ズであること。

 -- Function: set-auto-coding filename size
     この関数は、ファイルFILENAMEに適するコーディングシ
     ステムをリターンする。これはコーディングシステムを
     探すために、‘find-auto-coding’を使用する。コーディ
     ングシステムを決定できなかったら、この関数は‘nil’を
     リターンする。引数SIZEの意味は、
     ‘find-auto-coding’と同様。

 -- Function: find-operation-coding-system operation
          &rest arguments
     この関数は、OPERATIONをARGUMENTSで行う際に、(デフォ
     ルトで)使用するコーディングシステムをリターンする。
     値は以下の形式である:

          (DECODING-SYSTEM . ENCODING-SYSTEM)

     1つ目の要素DECODING-SYSTEMはデコード(OPERATIONがデ
     コードを行う場合)、ENCODING-SYSTEMはエンコード
     (OPERATIONがエンコードを行う場合)に使用するコーディ
     ングシステムである。

     引数OPERATIONはシンボルで‘write-region’、
     ‘start-process’、‘call-process’、
     ‘call-process-region’、‘insert-file-contents’、
     ‘open-network-stream’のいずれかであること。これらは
     文字コード変換と行末変換を行うことができる、Emacsの
     I/Oプリミティブの名前である。

     残りの引数は、対応するI/Oプリミティブに与えられる引
     数と同じであること。そのプリミティブに応じて、これ
     らの引数のうち1つが“ターゲット”として選択される。た
     とえばOPERATIONがファイルI/Oなら、ファイル名を指定
     する引数がターゲットである。サブプロセス用のプリミ
     ティブでは、プロセス名がターゲットになる。
     ‘open-network-stream’では、サービス名またはポート番
     号がターゲットである。

     OPERATIONに応じて、この関数は
     ‘file-coding-system-alist’、
     ‘process-coding-system-alist’、
     ‘network-coding-system-alist’の中からターゲットを探
     す。このalist内でターゲットが見つかったら、
     ‘find-operation-coding-system’はalist内の
     association(連想: キーと連想値からなるコンスセル)を
     リターンし、それ以外は‘nil’をリターンする。

     OPERATIONが‘insert-file-contents’なら、ターゲットに
     対応する引数は、‘(FILENAME . BUFFER)’という形式のコ
     ンスセルだろう。この場合、FILENAMEは
     ‘file-coding-system-alist’内で照合されるファイル名
     であり、BUFFERはそのファイルの(デコードされていない
     )コンテンツを含むバッファーである。
     ‘file-coding-system-alist’がこのファイルにたいして
     呼び出す関数を指定していて、かつ(通常行われるように
     )ファイルのコンテンツを調べる必要があるなら、ファイ
     ルを読み込むかわりにBUFFERのコンテンツを調べるべき
     である。


File: elisp,  Node: Specifying Coding Systems,  Next: Explicit Encoding,  Prev: Default Coding Systems,  Up: Coding Systems

32.10.6 Specifying a Coding System for One Operation
----------------------------------------------------

変数‘coding-system-for-read’および/または
‘coding-system-for-write’をバインドすることにより、特定
の操作にたいしてコーディングシステムを指定できます。

 -- Variable: coding-system-for-read
     この変数が非‘nil’なら、それはファイルの読み込み、ま
     たは同期サブプロセスプロセスからの入力にたいして使
     用する、コーディングシステムを指定する。

     これは非同期サブプロセスやネットワークストリームに
     も適用されるが、その方法は異なる。サブプロセス開始
     時、またはネットワークストリームオープン時の
     ‘coding-system-for-read’の値は、サブプロセスまたは
     ネットワークストリームにたいして入力のデコードメソ
     ッドを指定する。そのサブプロセスまたはネットワーク
     ストリームにたいして、それがオーバーライドされるま
     で、それが使用され続ける。

     特定のI/O操作にたいして‘let’でバインドするのが、こ
     の変数の正しい使い方である。この変数のグローバル値
     は常に‘nil’であり、他の値にグローバルにセットするべ
     きではない。以下は、この変数の正しい使用例である:

          ;; 文字コード変換なしでファイルを読み込む
          (let ((coding-system-for-read 'no-conversion))
            (insert-file-contents filename))

     この変数の値が非‘nil’のときは
     ‘file-coding-system-alist’、
     ‘process-coding-system-alist’、
     ‘network-coding-system-alist’を含む、入力にたいして
     使用するコーディングシステムを指定するすべてのメソ
     ッドより、この変数が優先される。

 -- Variable: coding-system-for-write
     これは‘coding-system-for-read’と同じように機能する
     が、入力ではなく出力に適用される点が異なる。これは
     ファイルへの書き込み、同様にサブプロセスおよびネッ
     トワークストリームへの出力の送信にも適用される。

     単一の操作が‘call-process-region’や
     ‘start-process’のように、入力と出力の両方を行う際は
     、‘coding-system-for-read’と
     ‘coding-system-for-write’の両方がそれに影響する。

 -- User Option: inhibit-eol-conversion
     この変数が非‘nil’なら、どのコーディングシステムが指
     定されたかに関わらず、行末変換は何も行われない。こ
     れはEmacsすべてのI/Oおよびサブプロセスにたいするプ
     リミティブ、および明示的なエンコード関数(*note
     Explicit Encoding::を参照)とデコード関数に適用され
     る。

   ある操作にたいして、固定された1つのコーディングシステ
ムではなく、複数のコーディングシステムを選択する必要があ
ることが、ときおりあります。Emacsでは、使用するコーディ
ングシステムにたいして優先順位を指定できます。これは、
‘find-coding-systems-region’(*note Lisp and Coding
Systems::を参照)のような関数によりリターンされるコーディ
ングシステムのリストのソート順に影響します。

 -- Function: coding-system-priority-list &optional
          highestp
     この関数は、コーディングシステムのカレント優先順に
     、コーディングシステムのリストをリターンする。オプ
     ション引数HIGHESTPが非‘nil’なら、それはもっとも高い
     優先度のコーディングシステムだけをリターンすること
     を意味する。

 -- Function: set-coding-system-priority &rest
          coding-systems
     この関数は、コーディングシステムの優先リストの先頭
     にCODING-SYSTEMSを置き、それらを他のコーディングシ
     ステムすべてより高い優先度とする。

 -- Macro: with-coding-priority coding-systems &rest
          body...
     このマクロは、CODING-SYSTEMSをコーディングシステム
     優先リスト先頭に置いて、‘progn’(*note progn:
     Sequencing.を参照)が行うように、BODYを実行する。
     CODING-SYSTEMSは、BODY実行中に選択するコーディング
     システムのリストであること。


File: elisp,  Node: Explicit Encoding,  Next: Terminal I/O Encoding,  Prev: Specifying Coding Systems,  Up: Coding Systems

32.10.7 Explicit Encoding and Decoding
--------------------------------------

Emacs内外へテキストを転送するすべての操作は、そのテキス
トをエンコードまたはデコードする能力をもっています。この
セクション内の関数を使用して、テキストを明示的にエンコー
ドあるいはデコードすることもできます。

   エンコード結果およびデコーディングへの入力は、通常の
テキストではありません。これらは理論的には一連のバイト値
から構成され、すなわち一連のASCII文字と8ビット文字から構
成されます。ユニバイトのバッファーおよび文字列では、これ
らの文字は0から#xFF(255)の範囲のコードをもちます。マルチ
バイトのバッファーおよび文字列では、8ビット文字は#xFFよ
り大きい文字コードをもちますが(*note Text
Representations::を参照)、そのようなテキストのエンコード
やデコード時、Emacsは透過的にそれらを単一バイト値に変換
します。

   コンテンツを明示的にデコードできるように、バイトシー
ケンスとしてバッファーにファイルを読み込むには、
‘insert-file-contents-literally’(*note Reading from
Files::を参照)を使用するのが通常の方法です。あるいは
‘find-file-noselect’でファイルをvisitする際、引数
RAWFILEに非‘nil’を指定することもできます。これらのメソッ
ドの結果は、ユニバイトバッファーになります。

   テキストを明示的にエンコードした結果であるバイトシー
ケンスは、たとえばそれを‘write-region’(*note Writing to
Files::)で書き込み、‘coding-system-for-write’を
‘no-conversion’にバインドすることによりエンコードを抑制
する等、それをファイルまたはプロセスへコピーするのが、通
常の使い方です。

   以下は、エンコードまたはデコードを明示的に行う関数で
す。エンコード関数とはバイトシーケンスを生成し、デコード
関数とはバイトシーケンスを操作する関数のことを意味します
。これらの関数はすべて、テキストプロパティを破棄します。
これらは、自身が使用したコーディングシステムを、正確に
‘last-coding-system-used’することも行います。

 -- Command: encode-coding-region start end
          coding-system &optional destination
     このコマンドは、STARTからENDのテキストを、コーディ
     ングシステムCODING-SYSTEMでエンコードする。通常、バ
     ッファー内の元テキストはエンコードされたテキストで
     置き換えられるが、オプション引数DESTINATIONでそれを
     変更できる。DESTINATIONがバッファーなら、エンコード
     されたテキストはそのバッファーのポイントの後に挿入
     される(ポイントは移動しない)。‘t’なら、このコマンド
     はエンコードされたテキストを挿入せずに、ユニバイト
     としてリターンする。

     エンコードされたテキストが何らかのバッファーに挿入
     された場合、このコマンドはエンコードされたテキスト
     の長さをリターンする。

     エンコードされた結果は理論的にはバイトシーケンスだ
     が、バッファーが以前マルチバイトだったならマルチバ
     イトのまま留まり、すべての8ビットのバイトはマルチバ
     イト表現に変換される(*note Text Representations::を
     参照)。

     期待しない結果となる恐れがあるので、テキストのエン
     コードする際は、CODING-SYSTEMに‘undecided’を_使用し
     てはならない_。CODING-SYSTEMにたいして自明な適値が
     存在しなければ、適切なエンコードを提案させるために
     、かわりに‘select-safe-coding-system’を使用すること
     (*note select-safe-coding-system: User-Chosen
     Coding Systems.を参照)。

 -- Function: encode-coding-string string coding-system
          &optional nocopy buffer
     この関数は、コーディングシステムCODING-SYSTEMで、
     STRING内のテキストをエンコードする。これはエンコー
     ドされたテキストを含む新たな文字列をリターンするが
     、NOCOPYが非‘nil’の場合、些細なエンコード処理なら、
     この関数はSTRING自身をリターンする。エンコード結果
     はユニバイト文字列である。

 -- Command: decode-coding-region start end
          coding-system &optional destination
     このコマンドは、コーディングシステムCODING-SYSTEMで
     、STARTからENDのテキストをデコードする。明示的なデ
     コードを使いやすくするために、デコード前のテキスト
     はバイトシーケンス値であるべきだが、マルチバイトと
     ユニバイトのバッファーいずれでも許すようになってい
     る(マルチバイトバッファーの場合rawバイト値は8ビット
     文字で表現されていること)。通常、デコードされたテキ
     ストでバッファー内の元のテキストは置き換えられるが
     、オプション引数DESTINATIONはそれを変更する。
     DESTINATIONがバッファーなら、デコードされたテキスト
     は、そのバッファーのポイントの後に挿入される(ポイン
     トは移動しない)。これが‘t’なら、このコマンドはデコ
     ードされたテキストを挿入せずに、それをマルチバイト
     文字列としてリターンする。

     デコードされたテキストが何らかのバッファーに挿入さ
     れた場合、このコマンドはデコードされたテキストの長
     さをリターンする。

     このコマンドは、デコードされたテキストに、テキスト
     プロパティ‘charset’をputする。このプロパティの値は
     、元ののテキストのデコードに使用された文字セットを
     示す。

 -- Function: decode-coding-string string coding-system
          &optional nocopy buffer
     この関数は、CODING-SYSTEMでSTRING内のテキストをデコ
     ードする。これはデコードされたテキストを含む新たな
     文字列をリターンするが、NOCOPYが非‘nil’の場合、些細
     なデコード処理ならSTRING自体をリターンするかもしれ
     ない。明示的なデコードを使いやすくするために、
     STRINGのコンテンツはバイトシーケンス値をもつユニバ
     イト文字列であるべきだが、マルチバイト文字列も許す
     ようになっている(マルチバイト形式で8ビットバイトを
     含むと仮定する)。

     オプション引数BUFFERがバッファーを指定する場合、デ
     コードされたテキストは、そのバッファー内のポイント
     の後に挿入される(ポイントは移動しない)。この場合、
     リターン値はデコードされたテキストの長さとなる。

     この関数は、デコードされたテキストに、テキストプロ
     パティ‘charset’をputする。このプロパティの値は、元
     のテキストのデコードに使用された、文字セットを示す
     。

          (decode-coding-string "Gr\374ss Gott" 'latin-1)
               ⇒ #("Grüss Gott" 0 9 (charset iso-8859-1))

 -- Function: decode-coding-inserted-region from to
          filename &optional visit beg end replace
     この関数は、FROMからTOのテキストを、あたかもファイ
     ルFILENAMEから、与えられた残りの引数で
     ‘insert-file-contents’を使用して読み込んだかのよう
     にデコードする。

     デコードせずにファイルからテキストを読み込んだ後、
     やはりデコードすることを決心したときに使用するのが
     、この関数の通常の使い方である。テキストを削除して
     再度読み込むかわりに、この関数を呼び出せばデコード
     して読み込むことができる。


File: elisp,  Node: Terminal I/O Encoding,  Prev: Explicit Encoding,  Up: Coding Systems

32.10.8 Terminal I/O Encoding
-----------------------------

Emacsは、キーボード入力のデコード、および端末出力のエン
コードにコーディングシステムを使用できます。これは
Latin-1のような、特定のエンコーディングを使用したテキス
トの送信や表示を行う端末にとって有用です。端末I/Oをエン
コードまたはデコードする際、Emacsは
‘last-coding-system-used’をセットしません。

 -- Function: keyboard-coding-system &optional terminal
     この関数は、TERMINALからのキーボード入力をデコード
     するために使用する、コーディングシステムをリターン
     する。‘no-conversion’という値は、何のデコーディング
     も行われていないことを意味する。TERMINALが省略また
     は‘nil’なら、それは選択されたフレームの端末を意味す
     る。*note Multiple Terminals::を参照のこと。

 -- Command: set-keyboard-coding-system coding-system
          &optional terminal
     このコマンドは、TERMINALからのキーボード入力のデコ
     ードに使用するコーディングシステムとして、
     CODING-SYSTEMを指定する。CODING-SYSTEMが‘nil’なら、
     キーボード入力をデコードしないことを意味する。
     TERMINALがフレームなら、それはそのフレームの端末を
     意味する。‘nil’なら、それはカレントで選択されたフレ
     ームの端末を意味する。*note Multiple Terminals::を
     参照のこと。

 -- Function: terminal-coding-system &optional terminal
     この関数は、TERMINALからの端末出力のエンコードに使
     用中のコーディングシステムをリターンする。
     ‘no-conversion’という値は、何のデコーディングも行わ
     れていないことを意味する。TERMINALがフレームなら、
     それはそのフレームの端末を意味する。‘nil’なら、それ
     はカレントで選択されたフレームの端末を意味する。

 -- Command: set-terminal-coding-system coding-system
          &optional terminal
     この関数は、TERMINALからの端末出力のエンコードに使
     用するためののコーディングシステムとして、
     CODING-SYSTEMを指定する。CODING-SYSTEMが‘nil’なら、
     端末出力をエンコードしないことを意味する。
     TERMINALがフレームなら、それはそのフレームの端末を
     意味する。‘nil’なら、それはカレントで選択されたフレ
     ームの端末を意味する。


File: elisp,  Node: Input Methods,  Next: Locales,  Prev: Coding Systems,  Up: Non-ASCII Characters

32.11 Input Methods
===================

“入力メソッド(input methods)”とは、キーボードから非
ASCII文字を簡単に入力する手段を提供します。プログラムが
読み取ることを意図して非ASCII文字とエンコーディングを相
互に変換するコーディングシステムとは異なり、入力メソッド
はヒューマンフレンドリーなコマンドを提供します(テキスト
を入力するためにユーザーが入力メソッドを使う方法について
は、*note (emacs)Input Methods::を参照のこと)。0入力メソ
ッドの定義方法はまだこのマニュアルにはありませんが、ここ
ではそれらの使い方について説明します。

   現在のところ、入力メソッドは文字列で名前をもっていま
すが、将来的には入力メソッド名として、シンボルも利用可能
になるかもしれません。

 -- Variable: current-input-method
     この変数は、カレントバッファーで現在アクティブな、
     入力メソッドの名前を保持する(方法に依らずセット時に
     は各バッファーで自動的にローカルになる)。バッファー
     で現在アクティブな入力メソッドがなければ、値は
     ‘nil’。

 -- User Option: default-input-method
     この変数は、入力メソッドを選択するコマンドにたいし
     て、デフォルトの入力メソッドを保持する。
     ‘current-input-method’と異なり、この変数は通常はグ
     ローバルである。

 -- Command: set-input-method input-method
     このコマンドは、カレントバッファーで入力メソッド
     INPUT-METHODをアクティブにする。同様に
     ‘default-input-method’にINPUT-METHODのセットも行う
     。INPUT-METHODが‘nil’なら、このコマンドはカレントバ
     ッファーで入力メソッドを非アクティブにする。

 -- Function: read-input-method-name prompt &optional
          default inhibit-null
     この関数は、プロンプトPROMPTとともに、ミニバッファ
     ーで入力メソッドの名前を読み取る。DEFAULTが非
     ‘nil’の場合、ユーザーの入力が空なら、それがデフォル
     トとしてリターンされる。しかし、INHIBIT-NULLが非
     ‘nil’なら、空の入力はエラーをシグナルする。

     リターン値は文字列。

 -- Variable: input-method-alist
     この変数は、サポートされているすべての入力メソッド
     を定義する。各要素は1つの入力メソッドを定義し、以下
     の形式をもつ:

          (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
           TITLE DESCRIPTION ARGS...)

     ここでINPUT-METHODはメソッド名の文字列、
     LANGUAGE-ENVはこの入力メソッドが推奨される言語環境
     の名前の文字列である(これはドキュメントとしての目的
     のみの役割を果たす)。

     ACTIVATE-FUNCは、このメソッドをアクティブにするため
     に呼び出す関数、もしあればARGSはACTIVATE-FUNCに渡す
     引数である。つまり、ACTIVATE-FUNCの引数は、
     INPUT-METHODとARGSである。

     TITLEは、ソン入力メソッドがアクティブな間、それをモ
     ードライン内に表示するための文字列、DESCRIPTIONはそ
     のメソッドを説明し、それが何に適するかを説明する文
     字列である。

   入力メソッドのための基本的インターフェースは、変数
‘input-method-function’です。*note Reading One Event::、
および*note Invoking the Input Method::を参照してくださ
い。


File: elisp,  Node: Locales,  Prev: Input Methods,  Up: Non-ASCII Characters

32.12 Locales
=============

POSIXには、言語に関連する機能において、使用する言語を制
御するための、“locale”という概念があります。以下の
Emacs変数は、Emacsがこれらの機能と相互作用する方法を制御
します。

 -- Variable: locale-coding-system
     この変数は、‘format-time-string’のformat引数、およ
     び‘format-time-string’のリターン値にたいして、シス
     テムエラーメッセージ、およびXウィンドウに限りキーボ
     ード入力をデコードするために使用するコーディングシ
     ステムを指定する。

 -- Variable: system-messages-locale
     この変数は、システムエラーメッセージを生成するため
     に使用するlocaleを指定する。locale変更により、メッ
     セージが異なる言語になったり、異なる表記になり得る
     。この変数が‘nil’なら、通常のPOSIX方式のように、
     localeは環境変数により指定される。

 -- Variable: system-time-locale
     この変数は、タイムバリューをフォーマットするために
     使用するlocaleを指定する。locale変更により、異なる
     慣習によりメッセージが表示され得る。この変数が
     ‘nil’なら、通常のPOSIX方式のように、localeは環境変
     数により指定される。

 -- Function: locale-info item
     この変数は、もし利用可能なら、カレントPOSIX localeに
     たいするlocaleデータITEMをリターンする。ITEMは以下
     のシンボルのいずれかであること:

     ‘codeset’
          文字列として文字セットをリターンする(localeア
          イテムの‘CODESET’)。

     ‘days’
          曜日名からなる7要素のベクターをリターンする
          (localeアイテムの‘DAY_1’から‘DAY_7’)。

     ‘months’
          月の名前からなる12要素のベクターをリターンする
          (localeアイテムの‘MON_1’から‘MON_12’)。

     ‘paper’
          ‘(WIDTH HEIGHT)’というリストで、mm単位でデフォ
          ルト用紙サイズをリターンする(localeアイテム
          ‘PAPER_WIDTH’および‘PAPER_HEIGHT’)。

     システムが要求された情報を提供できない、または
     ITEMが上記いずれのシンボルでもなければ、値は‘nil’と
     なる。リターン値内のすべての文字列は、
     ‘locale-coding-system’を使用してデコードされる。
     localeおよびlocaleアイテムについての詳細な情報は、
     *note (libc)Locales::を参照されたい。


File: elisp,  Node: Searching and Matching,  Next: Syntax Tables,  Prev: Non-ASCII Characters,  Up: Top

33 Searching and Matching
*************************

GNU Emacsは、バッファーから指定されたテキストを検索する
ために、２つの手段を提供します。それは文字列の正確一致検
索(exact string search)と、正規表現検索(regular
expression search)です。正規表現検索の後、マッチしたテキ
ストが正規表現壱阡にマッチしたのか、それとも正規表現のさ
まざまな部分に一致したかを判断するために、“マッチデータ
(match data)”を調べることができます。

* Menu:

* String Search::            正確なマッチの検索。
* Searching and Case::       case-independentまたはcase-significantな検索。
* Regular Expressions::      文字列クラスの記述。
* Regexp Search::            regexpにたいするマッチの検索。
* POSIX Regexps::            最長マッチにたいするPOSIXスタイルのマッチ。
* Match Data::               文字列またはregexp検索後に、テキストがマッチした部分を見つける。
* Search and Replace::       検索と置換を繰り返すコマンド。
* Standard Regexps::         センテンスやページ等を探すために有用なregexp。

   ‘skip-chars...’関連の関数も、ある種の検索を行います。
*note Skipping Characters::を参照してください。文字プロ
パティ内の変更を検索するには、*note Property Search::を
参照してください。


File: elisp,  Node: String Search,  Next: Searching and Case,  Up: Searching and Matching

33.1 Searching for Strings
==========================

バッファー内のテキストを検索するための、プリミティブ関数
が存在します。これらはプログラム内での使用を意図したもの
ですが、インタラクティブに呼び出すこともできます。これら
をインタラクティブに呼び出した場合は、検索文字列の入力を
求め、引数LIMITおよびNOERRORは‘nil’、REPEATは1になります
。インタラクティブ検索に関するより詳細な情報は、*note
Searching and Replacement: (emacs)Search.を参照してくだ
さい。

   以下の検索関数は、バッファーがマルチバイトバッファー
ならマルチバイト、ユニバイトバッファーならユニバイトに、
検索文字列を変換します。*note Text Representations::を参
照してください。

 -- Command: search-forward string &optional limit
          noerror repeat
     この関数は、STRINGにたいする正確なマッチを、ポイン
     トから前方に検索する。成功したら、見つかったマッチ
     の終端にポイントをセットして、ポイントの新たな値を
     リターンする。マッチが見つからない場合の値と副作用
     は、NOERROR(以下参照)に依存する。

     以下の例では、ポイントは最初は行の先頭にある。その
     後の‘(search-forward "fox")’により、ポイントは
     ‘fox’の最後の文字の後に移動する:

          ---------- Buffer: foo ----------
          ★The quick brown fox jumped over the lazy dog.
          ---------- Buffer: foo ----------

          (search-forward "fox")
               ⇒ 20

          ---------- Buffer: foo ----------
          The quick brown fox★ jumped over the lazy dog.
          ---------- Buffer: foo ----------

     引数LIMITは検索の境界を指定し、それはカレントバッフ
     ァー内の位置であること。その位置を超えるようなマッ
     チは、受け入れられない。LIMITが省略または‘nil’の場
     合のデフォルトは、そのバッファーのアクセス可能範囲
     の終端である。

     検索失敗時に何が起こるかは、NOERRORの値に依存する。
     NOERRORが‘nil’なら、‘search-failed’はエラーをシグナ
     ルする。NOERRORが‘t’なら、‘search-forward’は‘nil’を
     リターンして、何も行わない。NOERRORが‘nil’と‘t’いず
     れでもなければ、‘search-forward’はポイントを境界上
     限に移動して、‘nil’をリターンする。

     引数NOERRORは、マッチに失敗した有効な検索だけに影響
     する。無効な引数は、NOERRORとは無関係にエラーとなる
     。

     REPEATが正の数Nなら、それは繰り返し回数の役目をもつ
     。検索はN回繰り返され、前回のマッチの終端から毎回検
     索が開始される。これらの連続する検索が成功した場合
     、関数は成功となりポイントを新たな値をリターンする
     。それ以外は検索失敗となり、上述したように結果は
     NOERRORの値に依存する。REPEATが負の数-Nなら、それは
     逆方向(後方)への検索の繰り返し回数Nとしての役目をも
     つ。

 -- Command: search-backward string &optional limit
          noerror repeat
     この関数は、ポイントから後方にSTRINGを検索する。こ
     れは‘search-forward’と似ているが、前方ではなく後方
     に検索する点が異なる。後方への検索では、ポイントは
     マッチの先頭に残される。

 -- Command: word-search-forward string &optional limit
          noerror repeat
     この関数は、ポイントから前方にSTRINGにたいする“単語
     (word)”のマッチを検索する。マッチが見つかったら、見
     つかったマッチの終端にポイントをセットして、ポイン
     トの新たな値をリターンする。

     単語マッチはSTRINGを単語のシーケンスとみなし、それ
     らを分ける句読点は無視する。これはバッファーから、
     同じ単語シーケンスを検索する。単語はそれぞれバッフ
     ァー内で明確に区別されていなければならないが(単語
     ‘ball’の検索は単語‘balls’にマッチしない)、句読点や
     スペース等の細部は無視される(‘ball boy’を検索すると
     ‘ball. Boy!’にマッチする)。

     以下の例では、ポイントは最初バッファー先頭にある。
     検索により、ポイントは‘y’と‘!’の間に残される。

          ---------- Buffer: foo ----------
          ★He said "Please!  Find
          the ball boy!"
          ---------- Buffer: foo ----------

          (word-search-forward "Please find the ball, boy.")
               ⇒ 39

          ---------- Buffer: foo ----------
          He said "Please!  Find
          the ball boy★!"
          ---------- Buffer: foo ----------

     LIMITが非‘nil’なら、それはカレントバッファー内の位
     置であること。これはその検索の境界上限を指定する。
     見つかったマッチは、その位置を超えてはならない。

     NOERRORが‘nil’なら、‘word-search-forward’はエラーを
     シグナルする。NOERRORが‘t’なら、エラーをシグナルす
     るかわりに、‘nil’をリターンする。NOERRORが‘nil’と
     ‘t’いずれでもなければ、ポイントをLIMIT(またはバッフ
     ァーのアクセス可能範囲の終端)に移動して、‘nil’をリ
     ターンする。

     REPEATが非‘nil’なら、検索はその回数繰り返される。ポ
     イントは最後のマッチの終端に置かれる。

     内部的には、‘word-search-forward’と関連する関数は、
     STRINGから句読点を無視した正規表現に変換するために
     、関数‘word-search-regexp’を使用する。

 -- Command: word-search-forward-lax string &optional
          limit noerror repeat
     このコマンドは‘word-search-forward’と同じだが、
     STRINGが空白で開始または終了していなければ、
     STRINGの先頭または終端が単語境界にマッチする必要が
     ない点が異なる。たとえば‘ball boy’の検索は‘ball
     boyee’にはマッチするが、‘balls boy’にはマッチしない
     。

 -- Command: word-search-backward string &optional limit
          noerror repeat
     この関数は、ポイントから後方へSTRINGにマッチする単
     語を検索する。この関数は‘word-search-forward’と同様
     だが、後方に検索して、通常はマッチの先頭にポイント
     を残す点が異なる。

 -- Command: word-search-backward-lax string &optional
          limit noerror repeat
     このコマンドは‘word-search-backward’と同じだが、文
     字列が空白で開始または終了していなければ、STRINGの
     先頭または終端が単語境界にマッチする必要がない点が
     異なる。


File: elisp,  Node: Searching and Case,  Next: Regular Expressions,  Prev: String Search,  Up: Searching and Matching

33.2 Searching and Case
=======================

デフォルトのEmacs検索では、検索するテキストの大文字と小
文字は無視されます。検索対象に‘FOO’を指定すると、‘Foo’や
‘foo’もマッチとみなされます。これは正規表現にも適用され
ます。つまり‘[aB]’は‘a’、‘A’、‘b’、‘B’にもマッチするでし
ょう。

   この機能が望ましくなければ、変数‘case-fold-search’を
‘nil’にセットしてください。その場合、すべての文字は大文
字小文字の違いを含めて、正確にマッチしなければなりません
。これはバッファーローカル変数です。この変数の変更は、カ
レントバッファーだけに影響を与えます(*note Intro to
Buffer-Local::を参照)。かわりにデフォルト値を変更するこ
ともできます。Lispコードでは、‘let’を使用して
‘case-fold-search’を望む値にバインドするほうが、より一般
的でしょう。

   ユーザーレベルのインクリメンタル検索機能では、大文字
小文字の区別が異なることに注意してください。検索文字列に
含まれるのが小文字だけなら検索は大文字小文字の違いを無視
しますが、検索文字列に1つ以上の大文字が含まれれば検索は
大文字小文字の違いを区別するようになります。しかしLispコ
ード内で使用される検索関数では、これは何も行いません。
*note (emacs)Incremental Search::を参照してください。

 -- User Option: case-fold-search
     このバッファーローカル変数は、検索が大文字小文字の
     違いを無視するべきかどうかを決定する。この変数が
     ‘nil’なら、検索は大文字小文字の違いを無視しない。そ
     れ以外(とデフォルト)では、大文字小文字のかも無視す
     る。

 -- User Option: case-replace
     この変数は、高レベルの置換関数が大文字小文字の違い
     を保持するべきかどうかを決定する。この変数が‘nil’な
     ら、それは置換テキストをそのまま使用することを意味
     する。非‘nil’値は、置換されるテキストに応じて、置換
     テキストの大文字小文字を変換することを意味する。

     この変数は、それを関数‘replace-match’の引数として渡
     すことにより使用される。*note Replacing Match::を参
     照のこと。


File: elisp,  Node: Regular Expressions,  Next: Regexp Search,  Prev: Searching and Case,  Up: Searching and Matching

33.3 Regular Expressions
========================

“正規表現(regular expression)”、略して“regexp”は、文字列
の(もしかしたら無限の)セットを表すパターンのことです。
regexpにたいするマッチの検索は、とても強力な処理です。こ
のセクションではregexpの記述方法、それ以降のセクションで
はそれらを検索する方法を示します。

   正規表現を対話的に開発するために、‘M-x re-builder’コ
マンドを使用できます。このコマンドは、別のバッファーに即
座に視覚的なフィードバックを表示することにより、正規表現
を作成するための便利なインターフェースを提供します。
regexp編集とともに、ターゲットとなるバッファーのすべての
マッチがハイライトされます。カッコで括られたregexpの部分
式(sub-expression)は別のフェイスで表示され、非常に複雑な
regexpを簡単に検証することが可能になります。

* Menu:

* Syntax of Regexps::        正規表現の記述ルール。
* Regexp Example::           正規表現構文の説明。
* Regexp Functions::         正規表現を操作する関数。


File: elisp,  Node: Syntax of Regexps,  Next: Regexp Example,  Up: Regular Expressions

33.3.1 Syntax of Regular Expressions
------------------------------------

正規表現は、少数の文字が特別な構成要素で、残りは“通常”の
文字であるような構文をもちます。通常の文字は、その文字自
身だけにマッチする、シンプルな正規表現です。特別な文字は
‘.’、‘*’、‘+’、‘?’、‘[’、‘^’、‘$’、および‘\’です。将来、
新たなスペシャル文字が定義されることはないでしょう。文字
候補で終わる場合、‘]’はスペシャル文字です。文字候補の間
では、‘-’はスペシャル文字です。‘[:’と、対応する‘:]’は、
文字候補内の文字クラスです。正規表現内に出現する他の文字
は、‘\’が前置されていない限り、通常の文字です。

   たとえば‘f’はスペシャル文字ではなく通常文字なので、
‘f’は文字列‘f’にマッチし、他の文字にはマッチしない正規表
現です(これは文字列‘fg’には_マッチしない_が、その文字列
の_部分_にマッチする)。同様に、‘o’は‘o’だけにマッチしま
す。

   任意の2つの正規表現AとBは、結合することができます。結
合した結果は、文字列の先頭からある長さの文字列がAにマッ
チし、残りの文字列がBにマッチするような文字列にマッチす
る正規表現になります。

   単純な例として、文字列‘fo’だけにマッチする正規表現の
構成要素‘fo’を取得するために、正規表現‘f’と‘o’を結合でき
ます。

* Menu:

* Regexp Special::           正規表現内のスペシャル文字。
* Char Classes::             正規表現内で使用される文字クラス。
* Regexp Backslash::         正規表現内のバックスラッシュシーケンス。


File: elisp,  Node: Regexp Special,  Next: Char Classes,  Up: Syntax of Regexps

33.3.1.1 Special Characters in Regular Expressions
..................................................

以下は、正規表現内で特別な文字のリストです:

‘.’ (Period)
     これは、改行を除く1文字にマッチする。結合を使用して
     、‘a.b’のような正規表現を作成できる。これは‘a’で始
     まり‘b’で終わる3文字の文字列にマッチする。

‘*’
     これは、それ自身が構成要素ではない。これは前置され
     た正規表現を可能な限り繰り返したものにマッチするこ
     とを意味する、後置演算子である。したがって、‘o*’は
     任意の個数の‘o’にマッチする(‘o’を含まない場合もマッ
     チする)。

     ‘*’は常に前置された表現の、_最小_の表現に適用される
     。つまり‘fo*’は‘o’の繰り返しであり、‘fo’の繰り返し
     ではない。これは‘f’、‘fo’、‘foo’、...にマッチする。

     マッチを行う処理は構成要素‘*’を、マッチングにより即
     座に、見つけ得る回数分処理して、その後にパターンの
     残りを継続する。これが失敗したら、残りのパターンの
     マッチが可能になるかもしれないという期待のもと、
     ‘*’の変更された構成のうちいくつかのマッチを破棄する
     ことによる、バックトラッキングが発生する。たとえば
     文字列‘caaar’にたいして‘ca*ar’をマッチングすると、
     ‘a*’はまず3つすべての‘a’へのマッチを試みる。しかし
     残りのパターンは‘ar’であり、マッチ対象に残されてい
     るのは‘r’だけなので、この試みは失敗する。‘a*’にたい
     する次の代替策は、2つの‘a’だけへのマッチである。こ
     の選択では、残りのregexpのマッチは成功する。

     *警告:* ネストされた繰り返し処理は、それらが曖昧な
     マッチとなるような場合は、無期限な長時間の実行とな
     り得る。たとえば文字列
     ‘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz’にたいして
     正規表現‘\(x+y*\)*a’のマッチを試みると、それが最終
     的に失敗するまでに数時間を要し得る。Emacsはその試み
     のいずれも機能しないと結論する前に、‘x’のグループ家
     のそれぞれを試みなければならない。さらに悪いことに
     、‘\(x*\)*’は無数の方法でnull文字列にマッチ可能なの
     で、これは無限ループを引き起こす。これらの問題を避
     けるには、ネストされた繰り返しがバックトラッキング
     での組み合わせ爆発(combinatorial explosion)が発生し
     ないことを確実にするために注意深くチェックすること
     。

‘+’
     これは‘*’のような後置演算子だが、これは前置された表
     現に少なくとも1回マッチしなければならない点が異なる
     。たとえば‘ca+r’は文字列‘car’や‘caaaar’にマッチする
     が、文字列‘cr’にはマッチせず、その一方で‘ca*r’はこ
     れら3つすべての文字列にマッチする。

‘?’
     これは‘*’のような後置演算子だが、これは前置された表
     現に1回、またはマッチしないかのいずれかでなければな
     らない点が異なる。申‘ca?r’は‘car’と‘cr’にマッチする
     が、他にはマッチしない。

‘*?’, ‘+?’, ‘??’
     演算子 ‘*’、‘+’、‘?’には“非欲張り(non-greedy)”な変
     種が存在する。これらの演算子が可能な最長の部分文字
     列(含まれる表現全体へのマッチと等しい)とマッチする
     のにたいして、非欲張りな変種は可能な最短の部分文字
     列(含まれる表現全体と等しい)にマッチする。

     たとえば正規表現‘c[ad]*a’が文字列‘cdaaada’に適用さ
     れると文字列全体にマッチするが、正規表現
     ‘c[ad]*?a’を同じ文字列に適用すると‘cda’だけにマッチ
     する(ここでマッチが許された表現全体にたいする
     ‘[ad]*?’の可能な最短マッチは‘d’である)。

‘[ ... ]’
     これは‘[’で始まり‘]’で終端される“文字候補(character
     alternative)”である。もっとも単純なケースでは、この
     ２つのカッコ(brackets)の間にある文字が、この文字候
     補がマッチ可能な文字である。

     したがって‘[ad]’は1つの‘a’と1つの‘d’の両方にマッチ
     し、‘[ad]*’は‘a’と‘d’だけから構成された任意の文字列
     (空文字列を含む)にマッチする。つまり‘c[ad]*r’は
     ‘cr’、‘car’、‘cdr’、‘caddaar’等にマッチする。

     開始文字と終了文字の間に‘-’を記述することにより、文
     字候補内に文字範囲を含めることができる。つまり
     ‘[a-z]’は小文字のASCIIアルファベット文字にマッチす
     る。範囲は‘[a-z$%.]’のように個別の文字と自由に組み
     合わせることができる。これは任意のASCII小文字アルフ
     ァベットと‘$’、‘%’、またはピリオドとマッチする。

     ‘case-fold-search’が非‘nil’なら、‘[a-z]’は大文字ア
     ルファベットにもマッチする。‘[a-z]’のような範囲は、
     そのlocaleの照合順に影響されず、常にASCII順のシーケ
     ンスを表すことに注意。

     さらに通常のregexpスペシャル文字は文字候補内では特
     別ではないことにも注意されたい。文字候補内部では
     ‘]’、‘-’、‘^’という完全に異なる文字セットが特別に扱
     われる。

     文字候補内に‘]’を含めるには、それを最初の文字にしな
     ければならない。たとえば‘[]a]’は、‘]’と‘a’にマッチ
     する。‘-’を含めるには、文字候補の最初または最後の文
     字として‘-’を記述するか、範囲の後に置くこと。つまり
     ‘[]-]’は‘]’と‘-’の両方にマッチする。(以下で説明する
     ように、ここでは‘\’は特別ではないので、文字候補内に
     ‘]’を含めるために‘\]’は使用できない)。

     文字候補内に‘^’を含めるには、先頭以外のいずれかの場
     所に置くこと。

     ある範囲がユニバイト文字Cで始まり、マルチバイト文字
     C2でお話場合、その範囲は2つの部分に分割される。1つ
     はユニバイト文字‘C..?\377’、もう1つはマルチバイト文
     字‘C1..C2’である。ここでC1はC2が属する文字セットの
     最初の文字である。

     文字候補には、名前付き文字クラスも指定できる(*note
     Char Classes::を参照)。これはPOSIXの機能である。た
     とえば‘[[:ascii:]]’は、任意のASCII文字にマッチする
     。文字クラスの使用は、そのクラス内すべての文字を記
     述するのと等しい。しかし異なる文字数千を含むクラス
     もあるので、後者は実際は実現可能ではない。

‘[^ ... ]’
     ‘[^’は“補完文字候補(complemented character
     alternative)”を開始する。これは、指定された以外の任
     意の文字とマッチする。つまり‘[^a-z0-9A-Z]’はアルフ
     ァベットと数日前_以外_の、すべての文字にマッチする
     。

     ‘^’は文字クラス内では、先頭に記述されない限り特別で
     はない。‘^’に続く文字は、あたかもそれが先頭にあるか
     のように扱われる(別の言い方をすると‘-’や‘]’は、ここ
     では特別ではない)。

     マッチしない文字の1つとして改行が記述されていなけれ
     ば、補完文字候補は改行にマッチできる。これは
     ‘grep’のようなプログラム内でのregexpの扱いとは、対
     照的である。

     文字候補のように、名前付き文字クラスを指定できる。
     たとえば‘[^[:ascii:]]’は、任意の非ASCII文字にマッチ
     する。*note Char Classes::を参照のこと。

‘^’
     バッファーのマッチング時、‘^’は空文字列、ただしマッ
     チ対象のテキスト内にある行の先頭(またはバッファーの
     アクセス可能範囲の先頭)だけにマッチする。それ以外の
     マッチは、すべて失敗する。つまり‘^foo’は、行の先頭
     に出現する‘foo’にマッチする。

     バッファーではなく文字列とマッチする際は、‘^’は文字
     列の先頭、または改行文字の後にマッチする。

     歴史的な互換性という理由により、‘^’は正規表現の先頭
     、または‘\(’、‘\(?:’、‘\|’の後だけで使用できる。

‘$’
     これは‘^’と似ているが、行の終端(またはバッファーの
     アクセス可能範囲の終端)だけにマッチする。つまり
     ‘x+$’は、行末にある1つ以上の‘x’からなる文字列にマッ
     チする。

     バッファーではなく文字列とマッチする際は、‘$’は文字
     列の終端、または改行文字の前にマッチする。

     歴史的な互換性という理由により、‘$’は正規表現の先頭
     、または‘\(’、‘\(?:’、‘\|’の前だけで使用できる。

‘\’
     これは2つの機能をもつ。スペシャル文字(‘\’を含む)の
     クォートと、追加のスペシャル文字の導入である。

     ‘\’はスペシャル文字をクォートするので、‘\$’は‘$’、
     ‘\[’は‘[’だけにマッチする正規表現といったようになる
     。

     ‘\’はLisp文字列(*note String Type::を参照)の入力構
     文(read syntax)内でも特別な意味をもち、‘\’でクォー
     トしなければならないことに注意。たとえば文字‘\’にマ
     ッチする正規表現は‘\\’である。文字‘\\’を含むLisp文
     字列を記述するには、別の‘\\’で‘\\’をクォートするこ
     とをLisp構文は要求する。したがって‘\’にマッチする正
     規表現にたいする入力構文は、‘"\\\\"’となる。

   *注意してください:* 歴史的な互換性のために、スペシャ
ル文字はそれらがもつ特別な意味が意味を成さないコンテキス
ト内にある場合は、通常の文字として扱われます。たとえば
‘*foo’は、‘*’が作用可能な前置された表現がないので、通常
の‘*’として扱われます。この挙動に依存するのは悪い習慣で
す。どこにそれが出現しようと、スペシャル文字はすべてクォ
ートしてください。

   文字候補内で‘\’は何ら特別ではないので、‘-’や‘]’の特別
な意味を取り除くことは決してありません。特別な意味をもた
ないような場合でも、これらの文字をクォートするべきではあ
りません。バックスラッシュ以外の任意の1文字にマッチする
‘[^\]’(Lisp文字列構文では‘"[^\\]"’)内でのように、これら
の文字が_特別な意味_をもつ箇所では、これらの文字にバック
スラッシュを前置する正当性があるので、それほど何も明解に
はしないでしょう。

   実際には、正規表現内に出現する‘]’は文字候補に近接して
おり、それ故にほとんどがスペシャル文字です。しかしリテラ
ルの‘[’および‘]’の複雑なパターンにたいして、マッチを試み
ることも時にはあるかもしれません。そのような状況では、文
字候補を囲う角カッコがどれなのかを判断するために、
regexpを最初から注意深く解析するのが必要なときもあるかも
しれません。たとえば‘[^][]]’は、補完文字候補‘[^][]’(角カ
ッコ以外の任意の1文字とマッチする)と、その後のリテラルの
‘]’により構成されます。

   厳密にはregexp先頭の‘[’は特別で、‘]’は特別ではないと
いうのがルールです。これはクォートされていない最初の
‘[’で終わり、その後は文字候補になります。(文字クラス開始
を除き)‘[’はもはや特別ではありませんが、‘]’は直後にスペ
シャル文字‘[’があるか、その‘[’の後に‘^’がある場合を除き
、特別です。これは文字クラス終了ではない次のスペシャル文
字‘]’まで続きます。これは文字候補を終了させて、通常の正
規表現の構文をリストアします。クォートされていない‘[’は
再び特別となり、‘]’は特別ではなくなります。

