This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Simple Match Data,  Next: Entire Match Data,  Prev: Replacing Match,  Up: Match Data

33.6.2 Simple Match Data Access
-------------------------------

このセクションでは、最後の検索またはマッチング操作で、それが成功した場合
に何がマッチされたのかを調べるための、マッチデータ使用の方法を説明します
。

   マッチしたテキスト全体、または正規表現の特定のカッコで括られた部分式
にたいして、問い合わせることができます。以下の関数でCOUNTは、どの部分式
かを指定できます。COUNTが0ならマッチ全体を、COUNTが正なら望む部分式を指
定します。

   正規表現での部分式とは、エスケープされたカッコ‘\(...\)’でグループ化さ
れた表現であることを思い出してください。COUNT番目の部分式は、正規表現全
体の先頭から‘\(’を数えることにより見つけられます。最初の部分式が1、2つ目
が2、...となります。正規表現だけが部分式をもつことができ、単純な文字列検
索の後で利用できるのはマッチ全体の情報だけです。

   成功した検索すべては、マッチデータをセットします。したがって検索後は
、別の検索を行うかもしれない関数を呼び出す前に、直後にマッチデータを問い
合わせるべきです。別の検索を呼び出すかもしれない関数の前後で、かわりにマ
ッチデータの保存とリストアすることもできます(*note Saving Match Data::を
参照)。または‘string-match-p’のような、マッチデータを変更しないと明示さ
れている関数を使用してください。

   検索が成功しようと失敗しようと、マッチデータは変更されます。現在はこ
のように実装されていますが、これは将来変更されるかもしれません。失敗した
後のマッチデータを、信用しないでください。

 -- Function: match-string count &optional in-string
     この関数は、最後の検索またはマッチ処理でマッチしたテキストを、文字
     列としてリターンする。これはCOUNTが0ならテキスト全体、COUNTが正なら
     COUNT番目のカッコで括られた部分式に対応する部分だけをリターンする。

     そのような最後の処理が、文字列にたいする‘string-match’呼び出しの場
     合は、引数IN-STRINGに同じ文字列を渡すべきである。バッファーの検索ま
     たはマッチ後は、IN-STRINGを省略するか‘nil’を渡すべきである。しかし
     、最後に検索またはマッチを行ったバッファーが、‘match-string’呼び出
     し時にカレントバッファーであることを確認すること。このアドバイスに
     したがわない場合は、誤った結果となるだろう。

     COUNTが範囲外か、‘\|’選択肢内部の部分式が使用されない、または0回の
     繰り返しなら、値は‘nil’となる。

 -- Function: match-string-no-properties count &optional in-string
     この関数は‘match-string’と似ているが、結果がテキストプロパティをも
     たない点が異なる。

 -- Function: match-beginning count
     この関数は、最後に検索された正規表現またはその部分式によりマッチさ
     れた、テキストの開始位置をリターンする。

     COUNTが0なら、値はマッチ全体の開始位置となる。それ以外なら、COUNTは
     正規表現内の部分式を指定し、この関数の値はその部分式にたいするマッ
     チの開始位置である。

     使用されない、あるいは0回の繰り返しであるような‘\|’選択肢内部の部分
     式にたいして、値は‘nil’になる。

 -- Function: match-end count
     この関数は‘match-beginning’と似ているが、マッチの開始ではなく終了位
     置である点が異なる。

   以下はマッチデータを使用する例です。コメントの数字はテキスト内での位
置を示しています:

     (string-match "\\(qu\\)\\(ick\\)"
                   "The quick fox jumped quickly.")
                   ;0123456789
          ⇒ 4

     (match-string 0 "The quick fox jumped quickly.")
          ⇒ "quick"
     (match-string 1 "The quick fox jumped quickly.")
          ⇒ "qu"
     (match-string 2 "The quick fox jumped quickly.")
          ⇒ "ick"

     (match-beginning 1)       ; ‘qu’にたいするマッチ先頭の
          ⇒ 4                 ;   インデックスは4

     (match-beginning 2)       ; ‘ick’にたいするマッチ先頭の
          ⇒ 6                 ;   インデックスは6

     (match-end 1)             ; ‘qu’にたいするマッチ終端の
          ⇒ 6                 ;   インデックスは6

     (match-end 2)             ; ‘ick’にたいするマッチ終端の
          ⇒ 9                 ;   インデックスは9

   別の例を以下に示します。ポイントは最初、行の先頭にあります。検索によ
り、ポイントはスペースと単語‘in’の間にあります。マッチ全体の先頭はバッフ
ァーの9つ目の文字(‘T’)、1つ目の部分式にたいするマッチの先頭は13番目の文
字(‘c’)です。

     (list
       (re-search-forward "The \\(cat \\)")
       (match-beginning 0)
       (match-beginning 1))
         ⇒ (17 9 13)

     ---------- Buffer: foo ----------
     I read "The cat ★in the hat comes back" twice.
             ^   ^
             9  13
     ---------- Buffer: foo ----------

(この場合、リターンされるインデックスはバッファー位置で、バッファーの1つ
目の文字を1と数える。)


File: elisp,  Node: Entire Match Data,  Next: Saving Match Data,  Prev: Simple Match Data,  Up: Match Data

33.6.3 Accessing the Entire Match Data
--------------------------------------

関数‘match-data’および‘set-match-data’は、マッチデータ全体を一度に読み取
り、または書き込みます。

 -- Function: match-data &optional integers reuse reseat
     この関数は、最後の検索によりマッチしたテキストのすべての情報を記録
     する、位置(マーカーか整数)をリターンする。要素0は、正規表現全体にた
     いするマッチの、先頭の位置である。要素1は、その正規表現にたいするマ
     ッチの、終端の位置である。次の2つの要素は、1つ目の部分式にたいする
     マッチの先頭と終了、...となる。一般的に要素番号 2N は
     ‘(match-beginning N)’に対応し、要素番号 2N + 1 は‘(match-end N)’に
     対応する。

     すべての要素は通常はマーカーか‘nil’だが、もしINTEGERSが非‘nil’なら
     、それはマーカーのかわりに整数を使用することを意味する(この場合、マ
     ッチデータの完全なリストアwpey容易にするために、リストの最後の要素
     として、そのバッファー自身が追加される)。‘string-match’により、最後
     の検索が文字列にたいして行われた場合、マーカーは文字列無いをポイン
     トできないので、常に整数が使用される。

     REUSEが非‘nil’なら、それはリストであること。この場合、
     ‘match-data’はマッチデータをREUSE内に格納する。つまりREUSEは、破壊
     的に変更される。REUSEが、正しい長さである必要はない。特定のマッチデ
     ータにたいして長さが十分でなければ、リストは拡張される。REUSEが長過
     ぎる場合、長さはそのままで使用しない要素には‘nil’がセットされる。こ
     の機能には、ガベージコレクションの必要頻度を減らす目的がある。

     RESEATが非‘nil’なら、REUSEリスト内のすべてのマーカーは、存在しない
     場所を指すよう再設定される。

     他の場合と同様、検索関数とその検索のマッチデータへのアクセスを意図
     する‘match-data’呼び出しの間に介入するような検索があってはならない
     。

          (match-data)
               ⇒  (#<marker at 9 in foo>
                    #<marker at 17 in foo>
                    #<marker at 13 in foo>
                    #<marker at 17 in foo>)

 -- Function: set-match-data match-list &optional reseat
     この関数は、MATCH-LISTの要素からマッチデータをセットする。
     MATCH-LISTは、前の‘match-data’呼び出しの値であるようなリストである
     こと(正確には同じフォーマットなら他のものでも機能するだろう)。

     MATCH-LISTが存在しないバッファーを参照する場合でも、エラーとはなら
     ない。これは無意味だが害のない方法で、マッチデータをセットする。

     RESEATが非‘nil’なら、リストMATCH-LIST内のすべてのマーカーは、存在し
     ない場所を指すよう再設定される。

     ‘store-match-data’は、半ば時代遅れな‘set-match-data’のエイリアスで
     ある。


File: elisp,  Node: Saving Match Data,  Prev: Entire Match Data,  Up: Match Data

33.6.4 Saving and Restoring the Match Data
------------------------------------------

以前に行った検索にたいするマッチデータを後で使用するために保護する必要が
あるなら、検索を行うかもしれない関数の呼び出し時に、その呼び出し前後でマ
ッチデータの保存とリストアを行う必要があるでしょう。以下はマッチデータ保
存に失敗した場合に発生する問題を示す例です:

     (re-search-forward "The \\(cat \\)")
          ⇒ 48
     (foo)                   ; ‘foo’が他の検索を行うと
     (match-end 0)
          ⇒ 61              ; 結果は期待する48と異なる!

   ‘save-match-data’で、マッチデータの保存とリストアができます:

 -- Macro: save-match-data body...
     このマクロはBODYを実行して、その前後のマッチデータの保存とリストア
     をする。リターン値は、BODY内の最後のフォームの値。

   ‘set-match-data’と‘match-data’を一緒に使用して、‘save-match-data’の効
果を真似ることができます。以下は、その方法です:

     (let ((data (match-data)))
       (unwind-protect
           ...   ; 元のマッチデータを変更してもOK
         (set-match-data data)))

   プロセスフィルター関数(*note Filter Functions::)、およびプロセスセン
チネル(*note Sentinels::)実行時は、Emacsが自動的にマッチデータの保存とリ
ストアを行います。


File: elisp,  Node: Search and Replace,  Next: Standard Regexps,  Prev: Match Data,  Up: Searching and Matching

33.7 Search and Replace
=======================

バッファーのある部分で、regexpにたいするすべてのマッチを見つけてそれらを
置換したい場合は、以下のように‘re-search-forward’と‘replace-match’を使用
して、明示的なループを記述するのが最良の方法です:

     (while (re-search-forward "foo[ \t]+bar" nil t)
       (replace-match "foobar"))

‘replace-match’の説明は、*note Replacing the Text that Matched:
Replacing Match.を参照してください。

   しかし文字列内のマッチの置換、特にそれを効果的に行いたい場合は、より
複雑になります。そのため、Emacsはこれを行うための関数を提供します。

 -- Function: replace-regexp-in-string regexp rep string &optional
          fixedcase literal subexp start
     この関数はSTRINGをコピーしてREGEXPにたいするマッチを検索し、それら
     をREPに置き換える。これは変更されたコピーwリターンする。STARTが非
     ‘nil’なら、マッチにたいする検索はSTRING内のそのインデックスから開始
     され、そのインデックスより前で始まるマッチは変更されない。

     この関数は置換を行うために‘replace-match’を使用し、オプション引数
     FIXEDCASE、LITERAL、SUBEXPを‘replace-match’に渡す。

     文字列のかわりに、REPは関数でもよい。この場合、
     ‘replace-regexp-in-string’はそれぞれのマッチにたいして、そのテキス
     トを単一の引数としてREPを呼び出す。これはREPがリターンする値を収集
     して、それを置換文字列として‘replace-match’に渡す。この時点でのマッ
     チデータはSTRINGの部分文字列にたいするREGEXPのマッチ結果である。

   ‘query-replace’の行に関するコマンドを記述したい場合は、
‘perform-replace’を使用してこれを行うことができる。

 -- Function: perform-replace from-string replacements query-flag
          regexp-flag delimited-flag &optional repeat-count map start
          end
     これは‘query-replace’および関連するコマンドの根幹となる関数である。
     これは位置STARTとENDの間にあるテキスト内に出現するFROM-STRINGの一部
     またはすべてを置換する。STARTが‘nil’(または省略された)ならかわりに
     ポイントガ使用され、ENDにはそのバッファーのアクセス可能範囲の終端が
     使用される。

     QUERY-FLAGが‘nil’なら、マッチすべてを置換する。それ以外の場合は、そ
     れぞれにたいしてユーザーにたいして何をすべきか問い合わせる。

     REGEXP-FLAGが非‘nil’ならFROM-STRINGは正規表現とみなされ、それ以外は
     リテラルとしてマッチしなければならない。DELIMITED-FLAGが非‘nil’なら
     、単語境界に囲まれた置換だけが考慮される。

     引数REPLACEMENTSは、マッチを何で置き換えるかを指定する。文字列なら
     その文字列を使用する。サイクル順に使用される文字列リストでもよい。

     REPLACEMENTSがコンスセル‘(FUNCTION . DATA)’なら、これは置換テキスト
     を取得するためにそれぞれのマッチ後にFUNCTIONを呼び出すことを意味す
     る。この関数はDATAと、すでに置換された個数という、2つの引数で呼び出
     される。

     REPEAT-COUNTが非‘nil’なら、それは整数であること。その場合、サイクル
     を次に進める前に、REPLACEMENTSリスト内の各文字列を何度使用するかを
     指定する。

     FROM-STRINGが大文字アルファベットを含む場合、‘perform-replace’は
     ‘case-fold-search’を‘nil’にバインドして、大文字小文字を変換せずに
     REPLACEMENTSを使用する。

     キーマップ‘query-replace-map’は通常、問い合わせにたいして可能なユー
     ザー応答を定義する。引数MAPが非‘nil’なら、それは
     ‘query-replace-map’のかわりに使用するキーマップを指定する。

     この関数はFROM-STRINGの次のマッチを検索するために、2つの関数のうち
     1つを使用する。これらの関数は2つの変数
     ‘replace-re-search-function’と‘replace-search-function’により指定さ
     れる。引数REGEXP-FLAGが非‘nil’なら前者、‘nil’なら後者が呼び出される
     。

 -- Variable: query-replace-map
     この変数は‘perform-replace’にたいする有効なユーザー応答を定義するス
     ペシャルキーマップを保持し、コマンドは‘y-or-n-p’や‘map-y-or-n-p’と
     同様に、それを使用する。このマップは2つの点において普通のマップと異
     なる。

        • “キーバインディング”がコマンドではなく、このマップを使用する関
          数にとって意味のある単なるシンボルであること。

        • プレフィクスキーはサポートされない。各キーバインディングは単一
          イベントキーシーケンスでなければならない。これは入力を取得する
          ために、関数が‘read-key-sequence’を使用せず、かわりに単一イベ
          ントを読み取って、それを“手動”で照合する。

   ‘query-replace-map’にたいして意味をもつ“バインディング”があります。そ
れらのうちいくつかは、‘query-replace’とその同族にたいしてのみ意味をもち
ます。

‘act’
     判断している対象にたいしてアクションを起こす(別の言い方をすると
     “yes”)。

‘skip’
     この問いにたいしてアクションを起こさない(別の言い方をすると“no”)。

‘exit’
     この問いにたいして“no”を答えて、一連の問いすべてにたいして“no”が応
     答されたとみなし、問い合わせをあきらめる。

‘exit-prefix’
     ‘exit’と似ているが、‘unread-command-events’にたいして押下されたキー
     を追加する(*note Event Input Misc::を参照)。

‘act-and-exit’
     この問いにたいして“yes”を答えて、一連の問いすべてにたいして後続の問
     いに“no”が応答されるとみなし、問い合わせをあきらめる。

‘act-and-show’
     この問いに“yes”を答えるが結果を表示して、まだ次の問いへ進まない。

‘automatic’
     これ以上のユーザーとの対話を行わず、この問いと後続の問いにたいして
     “yes”を答える。

‘backup’
     前に問い合わせた以前の場所に戻る。

‘edit’
     この問いに対処するために、通常とられるアクションのかわりに再帰編集
     にエンターする。

‘edit-replacement’
     ミニバッファー内で、この問いにたいする置換を編集する。

‘delete-and-edit’
     検討中のテキストを削除して、それを置換するために再帰編集にエンター
     する。

‘recenter’
‘scroll-up’
‘scroll-down’
‘scroll-other-window’
‘scroll-other-window-down’
     指定されたウィンドウスクロール操作を行い、同じ問いを再度尋ねる。こ
     の問いには‘y-or-n-p’と、関連する関数だけが使用される。

‘quit’
     即座にquitを行う。この問いには‘y-or-n-p’と、関連する関数だけが使用
     される。

‘help’
     ヘルプを表示して、再度尋ねる。

 -- Variable: multi-query-replace-map
     この変数は、マルチバッファー置換で有用な追加キーバインディングを提
     供することにより‘query-replace-map’を拡張するキーマップを保持する。
     追加される“バインディング”は以下のとおり:

     ‘automatic-all’
          残りすべてのバッファーにたいして、それ以上の対話をせず、その問
          いと後続のすべての問いに“yes”を答える。

     ‘exit-current’
          この問いに“no”を答えて、カレントバッファーにたいする一連の問い
          すべてをあきらめる。そしてシーケンス内の次のバッファーへ問いを
          継続する。

 -- Variable: replace-search-function
     この変数は、置換する次の文字列を検索するために‘perform-replace’が呼
     び出す関数を指定する。デフォルト値は‘search-forward’。それ以外の値
     の場合は、‘search-forward’の最初の3つの引数を引数とする関数を指定す
     ること(*note String Search::を参照)。

 -- Variable: replace-re-search-function
     この変数は、置換する次のregexpを検索するために‘perform-replace’が呼
     び出す関数を指定する。デフォルト値は‘re-search-forward’。それ以外の
     値の場合は、‘re-search-forward’の最初の3つの引数を引数とする関数を
     指定すること(*note Regexp Search::を参照)。


File: elisp,  Node: Standard Regexps,  Prev: Search and Replace,  Up: Searching and Matching

33.8 Standard Regular Expressions Used in Editing
=================================================

このセクションでは、編集において特定の目的のために使用される正規表現を保
持する変数をいくつか説明します。

 -- User Option: page-delimiter
     これはページを分割する行開始を記述する、正規表現である。デフォルト
     値は‘"^\014"’(‘"^^L"’または‘"^\C-l"’のこと)。これはフォームフィード
     文字(改頁文字)で始まる行とマッチする。

   以下の2つの正規表現を、常に行頭からマッチが始まる正規表現とみなすべき
では_ありません_。これらを‘^’にマッチするアンカーとして使用するべきでは
ありません。ほとんどの場合、パラグラフコマンドは行頭にたいしてのみマッチ
のチェックを行い、これは‘^’が不要であることを意味します。非0の左マージン
が存在する場合、これらは左マージンの後から始まるマッチに適用されます。そ
の場合、‘^’は不適切でしょう。しかし左マージンを決して使用しないモードで
は、‘^’は無害でしょう。

 -- User Option: paragraph-separate
     これは、パラグラフを分割する行の開始を認識する正規表現である(これを
     変更する場合は‘paragraph-start’も変更する必要があるかもしれない)。
     デフォルト値は‘"[ \t\f]*$"’で、これは(左マージン以降)すべてがスペー
     ス、タブ、フォームフィードで構成される行とマッチする。

 -- User Option: paragraph-start
     これは、パラグラフを開始_または_分割する行の開始を認識する正規表現
     である。デフォルト値は‘"\f\\|[ \t]*$"’で、これは(左マージン以降)す
     べてが空白文字で構成される行、またはフォームフィードで始まる行とマ
     ッチする。

 -- User Option: sentence-end
     非‘nil’なら、以降に続く空白文字を含めてセンテンスの終わりを記述する
     正規表現であること(これとは無関係にパラグラフ境界もセンテンスを終了
     させる)。

     値が‘nil’(デフォルト)なら、関数‘sentence-end’がregexpを構築する。セ
     ンテンス終端の認識に使用するregexpを得るのに、常に関数
     ‘sentence-end’を使用するべきなのは、これが理由である。

 -- Function: sentence-end
     この関数は、変数‘sentence-end’が非‘nil’なら、その値をリターンする。
     それ以外なら、変数‘sentence-end-double-space’(*note Definition of
     sentence-end-double-space::を参照)、‘sentence-end-without-period’、
     ‘sentence-end-without-space’にもとづくデフォルト値をリターンする。


File: elisp,  Node: Syntax Tables,  Next: Abbrevs,  Prev: Searching and Matching,  Up: Top

34 Syntax Tables
****************

“構文テーブル(syntax table)”は、バッファー内のそれぞれの文字にたいして、
構文的な役割を指定します。単語、シンボル、その他の構文要素の開始と終了の
判定に、これを使用できます。この情報はFont Lockモード(*note Font Lock
Mode::を参照)や、種々の複雑な移動コマンド(*note Motion::を参照)を含む、
多くのEmacs機能により使用されます。

* Menu:

* Basics: Syntax Basics.     構文テーブルの基本的概念。
* Syntax Descriptors::       文字がクラス分けされる方法。
* Syntax Table Functions::   構文テーブルを作成、調査、変更する方法。
* Syntax Properties::        テキストプロパティによる構文テーブルのオーバーライド。
* Motion and Syntax::        特定の構文による文字間の移動。
* Parsing Expressions::      構文テーブル使用によるバランスのとれた式の解析。
* Syntax Table Internals::   構文テーブルの情報が格納される方法。
* Categories::               文字構文をクラス分けする別の手段。


File: elisp,  Node: Syntax Basics,  Next: Syntax Descriptors,  Up: Syntax Tables

34.1 Syntax Table Concepts
==========================

構文テーブルとは、それぞれの文字の“構文クラス(syntax class)”や、その他の
構文的プロパティを照合するために使用できる、データ構造のことです。構文テ
ーブルは、テキストを横断したスキャンや移動のために、Lispプログラムにより
使用されます。

   構文テーブルは、内部的には文字テーブルです(*note Char-Tables::を参照
)。インデックスCの要素はコードCの文字を記述します。値は該当する文字の構
文を指定するコンスセルです。詳細は*Note Syntax Table Internals::を参照し
てください。しかし構文テーブルの内容を変更または調べるために‘aset’や
‘aref’を使用するかわりに、通常は高レベルな関数‘char-syntax’や
‘modify-syntax-entry’を使用するべきです。これらについては*note Syntax
Table Functions::で説明します。

 -- Function: syntax-table-p object
     この関数はOBJECTが構文テーブルなら、‘t’をリターンする。

   バッファーはそれぞれ自身のメジャーモードをもち、それぞれのメジャーモ
ードはさまざまな文字の構文クラスにたいして独自のアイデアをもっています。
たとえばLisモードでは文字‘;’はコメントの開始ですが、Cモードでは命令文の
終端になります。これらのバリエーションをサポートするために、構文テーブル
はそれぞれのバッファーにたいしてローカルです。一般的に各メジャーモードは
自身の構文テーブルをもち、そのモードを使用するすべてのバッファーにそれが
インストールされます。たとえば変数‘emacs-lisp-mode-syntax-table’は
EmacsのLispモードが使用する構文テーブル、‘c-mode-syntax-table’はCモード
が使用する構文テーブルを保持します。あるメジャーモードの構文テーブルを変
更すると、そのモードのバッファー、およびその後でそのモードに置かれるすべ
てのバッファーの構文も同様に変更されます。複数の類似するモードが1つの構
文テーブルを共有することが、ときおりあります。構文テーブルをセットアップ
する方法の例は、*note Example Major Modes::を参照してください。

   別の構文テーブルから構文テールを“継承(inherit)”できます。これを“親構
文テーブル(parent syntax table)”と呼びます。構文テーブルは、ある文字にた
いして構文クラス“inherit”を与えることにより、構文クラスを未指定にしてお
くことができます。そのような文字は、親構文テーブルが指定する構文クラスを
取得します(*note Syntax Class Table::を参照)。Emacsは“標準構文テーブル
(standard syntax table)”を定義します。これはデフォルトとなる親構文テーブ
ルであり、Fundamentalモードが使用する構文テーブルでもあります。

 -- Function: standard-syntax-table
     この関数はFundamentalモードが使用する構文テーブルである、標準構文テ
     ーブルをリターンする。

   Emacs Lispリーダーは変更不可な独自のビルトイン構文ルールをもつので、
構文テーブルは使用しません(いくつかのLispシステムはリード構文を再定義す
る手段を提供するが、わたしたちは単純化のためこの機能をEmacs Lisp外部に留
める決定をした)。


File: elisp,  Node: Syntax Descriptors,  Next: Syntax Table Functions,  Prev: Syntax Basics,  Up: Syntax Tables

34.2 Syntax Descriptors
=======================

“構文クラス(syntax class)”の文字は、その文字の構文的な役割を記述します。
各構文テーブルは、それぞれの文字の構文クラスを指定します。ある構文テーブ
ルでの文字のクラスと、別のテーブルにおけるその文字のクラスとの間に関連性
がある必要はありません。

   構文テーブルはそれぞれニーモニック文字(mnemonic character)により選別
され、クラスを指定する必要がある際にはそのクラスの名前としての役割を果た
します。この指定子文字(designator character)は通常、そのクラスに割当てら
れることが多々あります。しかしその指定子としての意味は不変であり、その文
字がカレントでもつ構文とは独立しています。つまりカレント構文テーブルにお
いて実際に文字‘\’が構文をもつかどうかに関係なく、指定子文字としての‘\’は
常に“エスケープ文字(escape characte)r”を意味します。 構文クラスとそれら
の指定子文字のリストは、*note Syntax Class Table::を参照してください。

   “構文記述子(syntax descriptor)”とは、文字の構文クラスと、その他の構文
的なプロパティを記述するLisp文字列のことです。ある文字の構文を変更したい
際、それは関数‘modify-syntax-entry’を呼び出して、その引数に構文記述子を
渡すことにより行われます(*note Syntax Table Functions::を参照)。

   構文記述子の1つ目の文字は、構文クラスの指定子文字でなければなりません
。2つ目の文字がもしあれば、マッチング文字を指定します(Lispでは‘(’にたい
するマッチング文字は‘)’)。スペースはマッチング文字が存在しないことを指定
します。その後に続く文字は、追加の構文プロパティを指定します(*note
Syntax Flags::を参照)。

   マッチング文字やフラグが必要なければ、(構文クラスを指定する)1つの文字
だけで十分です。

   たとえばCモードでの文字‘*’の構文記述子は‘". 23"’(区切り記号、マッチン
グ文字用スロットは未使用、コメント開始記号の2つ目の文字、コメント終了記
号の1つ目の文字)、‘/’にたいするエントリーは‘. 14’(区切り記号、マッチング
文字用スロットは未使用、コメント開始記号の1つ目の文字、コメント終了記号
の2つ目の文字)です。

   Emacsは、低レベルでの構文クラスを記述するために使用される“raw構文記述
子(raw syntax descriptors)”も定義しています。*note Syntax Table
Internals::を参照してください。

* Menu:

* Syntax Class Table::       構文クラスのテーブル。
* Syntax Flags::             各文字が所有できる追加のフラグ。


File: elisp,  Node: Syntax Class Table,  Next: Syntax Flags,  Up: Syntax Descriptors

34.2.1 Table of Syntax Classes
------------------------------

以下は構文クラス、それらの指定子となる文字とそれらの意味、およびそれらの
使用例を示すテーブルです。

空白文字: ‘ ’、または‘-’
     シンボルおよび単語を区別する文字。空白文字は通常は他の構文的な意義
     をもたず、複数の空白文字は構文的には単一の空白文字と等しい。スペー
     ス、タブ、フォームフィードは、ほとんどすべてのメジャーモードにおい
     て空白文字にクラスっ分けされる。

     この構文クラスは‘ ’または‘-’により指定できる。両指定子は等価である
     。

単語構成文字: ‘w’
     人間の言語における単語の一部。これらは通常は、プログラム内において
     変数やコマンドの名前として使用される。通常、すべての大文字と小文字
     、および数字は単語構成文字である。

シンボル構成文字: ‘_’
     単語構成文字とともに変数やコマンドの名前で使用される、追加の文字。
     例としてはLispモードの文字‘$&*+-_<>’が含まれ、これらはたとえ英単語
     の一部でないとしても、シンボルの名前の一部となり得る。標準Cでは、シ
     ンボル内において非単語構成文字で有効な文字はアンダースコア(‘_’)だけ
     である。

区切り文字: ‘.’
     人間の言語において句読点として使用される文字、またはプログラミング
     言語でシンボルを別のシンボルと区別するために使用される文字。Emacs
     Lispモードのようないくつかのプログラミング言語のモードでは、単語構
     成文字およびシンボル構成文字のいずれでもないいくつかの文字はすべて
     、他の用途をもつので、このクラスの文字をもたない。Cモードのような他
     のプログラミング言語のモードでは、演算子にたいして区切り文字構文が
     使用される。

開カッコ文字: ‘(’
閉カッコ文字: ‘)’
     文や式を囲うために、異なるペアーとして使用される文字。そのようなグ
     ループ化は開カッコで開始され、閉カッコで終了する。開カッコ文字はそ
     れぞれ特定の閉カッコ文字にマッチし、その逆も成り立つ。Emacsqは通常
     、閉カッコ挿入字に、マッチする開カッコを示す。*note Blinking::を参
     照のこと。

     人間の言語、およびCのコードではカッコのペアーは‘()’、‘[]’、‘{}’であ
     る。Emacs Lispではリストとベクターにたいする区切り文字(‘()’および
     ‘[]’)は、カッコ文字としてクラス分けされる。

文字列クォート: ‘"’
     文字列定数を区切るために使用される文字。文字列の先頭と終端に、同じ
     文字列クォート文字が出現する。このようなクォート文字列はネストされ
     ない。

     Emacsのパース機能は、文字列を単一のトークンとみなす。文字列内では、
     その文字の通常の構文的な意味は抑制される。

     Lispモードはダブルクォーテーション(‘"’)、および垂直バー(‘|’)とう、
     2つの文字列クォート文字をもつ。Emacs Lispでは‘|’は使用しないが、
     Common Lispでは使用される。Cも文字列にたいするダブルクォート文字、
     および文字定数にたいするシングルクォート文字(‘'’)という、2つのクォ
     ート文字をもつ。

     人間用のテキストには文字列クォート文字がない。そのクォーテーション
     内の別の文字の通常の構文的プロパティを、クォーテーションマークがオ
     フに切り替えるのを、わたしたちは望まない。

エスケープ構文文字: ‘\’
     文字列や文字定数内で使用されるような、エスケープシーケンスで始まる
     文字。CとLispの両方で、文字‘\’はこのクラスに属する(Cでは文字列内で
     のみ使用されるが、Cコード中を通じてこのように扱っても問題ないことが
     わかった)。

     ‘words-include-escapes’が非‘nil’な、このクラスの文字は単語の一部と
     みなされる。*note Word Motion::を参照のこと。

文字クォート: ‘/’
     その文字の通常の構文的な意義を失うよう、後続の文字をクォートするた
     めに使用される文字。これは直後に続く文字だけに影響する点が、エスケ
     ープ文字と異なる。

     ‘words-include-escapes’が非‘nil’な、このクラスの文字は単語の一部と
     みなされる。*note Word Motion::を参照のこと。

     このクラスはTeXモードのバックスラッシュにたいして使用される。

区切りペアー: ‘$’
     文字列クォート文字と似ているが、この区切りの間にある文字の構文的な
     プロパティは抑制されない点が異なる。現在のところTeXモードだけが区切
     りペアーを使用する(‘$’によりmathモードに出入りする)。

式プレフィクス: ‘'’
     式に隣接して出現した場合に、その式の一部とみなされる、構文的演算子
     にたいして使用される文字。Lispモードではアポストロフィー‘'’(クォー
     トに使用)、カンマ‘,’(マクロに使用)、‘#’(特定のデータ型にたいするリ
     ード構文として使用)が、これらの文字に含まれる。

コメント開始文字: ‘<’
コメント終了文字: ‘>’
     さまざまな言語において、コメントを区切るために使用する文字。人間用
     のテキストはコメント文字をもたない。Lispでは、セミコロン(‘;’)がコメ
     ントの開始で、改行かフォームフィードで終了する。

標準構文の継承: ‘@’
     この構文クラスは、特定の構文を指定しない。これは、その文字の構文を
     探すために標準構文テーブルを照合するよう告げる。

汎用コメント区切り: ‘!’
     特殊なコメントを開始または終了させる文字。_任意_の汎用コメント区切
     りは、_任意_の汎用コメント区切りにマッチするが、コメント開始とコメ
     ント終了とはマッチできない。汎用コメント区切りは、汎用コメント区切
     り同士としかマッチできない。

     この構文クラスは主として‘syntax-table’テキストプロパティ(*note
     Syntax Properties::を参照)とともに使用することを意図している。任意
     の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それら
     が汎用コメント区切りであることを示す‘syntax-table’プロパティを付与
     することにより、その範囲がコメントを形成するとマークすることができ
     る。

汎用文字列区切り: ‘|’
     文字列を開始または終了させる文字。_任意_の汎用文字列区切りは、_任意
     _の汎用文字列区切りにマッチするが、通常の文字列クォート文字とはマッ
     チできない。

     この構文クラスは主として‘syntax-table’テキストプロパティ(*note
     Syntax Properties::を参照)とともに使用することを意図している。任意
     の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それら
     が汎用文字列区切りであることを示す‘syntax-table’プロパティを付与す
     ることにより、その範囲が文字列定数を形成するとマークすることができ
     る。


File: elisp,  Node: Syntax Flags,  Prev: Syntax Class Table,  Up: Syntax Descriptors

34.2.2 Syntax Flags
-------------------

構文テーブル内の文字全体にたいして、構文クラスに加えてフラグを指定できま
す。利用できる8つのフラグがあり、それらは文字‘1’、‘2’、‘3’、‘4’、‘b’、
‘c’、‘n’、‘p’で表されます。

   ‘p’を除くすべてのフラグは、コメント区切りを記述するために使用されます
。数字のフラグは2文字から構成されるコメント区切りにたいして使用されます
。これらは、文字の文字クラスに関連付けられた構文的プロパティに加えて、そ
の文字も_同様_にコメントシーケンスの一部となれることを示します。Cモード
では区切り文字であり、_かつ_コメントシーケンス開始(‘/*’)の2文字目であり
、_かつ_コメントシーケンス終了(‘*/’)の1文字目である‘*’のような文字のため
に、フラグとクラスは互いに独立しています。フラグ‘b’、‘c’、‘n’は対応する
コメント区切りを限定するために使用されます。

   以下は文字Cにたいして利用できるフラグと、それらの意味を示すテーブルで
す:

   • ‘1’は、Cが2文字からなるコメント開始シーケンスの開始であることを意味
     する。

   • ‘2’は、Cがそのようなシーケンスの2文字目であることを意味する。

   • ‘3’は、Cが2文字からなるコメント終了シーケンスの開始であることを意味
     する。

   • ‘4’は、Cがそのようなシーケンスの2文字目であることを意味する。

   • ‘b’は、Cが代替えのコメントスタイル“b”に属するコメント区切りであるこ
     とを意味する。このフラグは2文字のコメント開始では2文字目、2文字のコ
     メント終了では1文字目にたいしてのみ意味をもつ。

   • ‘c’は、Cが代替えのコメントスタイル“c”に属するコメント区切りであるこ
     とを意味する。2文字からなるコメント区切りにたいしては、そのいずれか
     が‘c’であればスタイル“c”となる。

   • コメント区切り文字での‘n’は、この種のコメントがネスト可能であること
     を指定する。2文字からなるコメント区切りにたいしては、そのいずれかが
     ‘n’であればネスト可能となる。

     Emacsは任意の構文テーブル1つにたいして、同時に複数のコメントスタイ
     ルをサポートする。コメントスタイルはフラグ‘b’、‘c’、‘n’の組み合わせ
     なので、8個の異なるコメントスタイルが可能である。コメント区切りはそ
     れぞれスタイルをもち、同じスタイルのコメント区切りとのみマッチでき
     る。つまりコメントがスタイル“bn”のコメント開始シーケンスで開始され
     るなら、そのコメントは次のスタイル“bn”のコメント終了シーケンスにマ
     ッチするまで拡張されるだろう。

     C++にたいして適切なコメント構文は、以下のようになる:

     ‘/’
          ‘124’
     ‘*’
          ‘23b’
     newline
          ‘>’

     これは4つのコメント区切りシーケンスを定義する:

     ‘/*’
          これは2文字目の‘*’が‘b’フラグをもつので、“b”スタイルのコメント
          開始シーケンスである。

     ‘//’
          これは2文字目の‘/’が‘b’フラグをもたないので、“a”スタイルのコメ
          ント開始シーケンスである。

     ‘*/’
          これは1文字目の‘*’が‘b’フラグをもつので、“b”スタイルのコメント
          終了シーケンスである。

     newline
          これは改行▼文字が‘b’フラグをもたないので、“a”スタイルのコメン
          ト終了シーケンスである。

   • ‘p’はLisp構文にたいして、追加のプレフィクス文字を識別する。これらが
     式の間に出現した際は、空白文字として扱われる。これらが式の内部に出
     現したときは、それらの通常の構文クラスに応じて処理される。

     関数‘backward-prefix-chars’はこれらの文字と、同様にメインの構文クラ
     スがプレフィクスであるような文字(‘'’)を超えて、後方に移動する。
     *note Motion and Syntax::を参照のこと。


File: elisp,  Node: Syntax Table Functions,  Next: Syntax Properties,  Prev: Syntax Descriptors,  Up: Syntax Tables

34.3 Syntax Table Functions
===========================

このセクションでは、構文テーブルを作成、アクセス、変更する関数を説明しま
す。

 -- Function: make-syntax-table &optional table
     この関数は、新たに構文テーブルを作成する。TABLEが非‘nil’なら、新た
     な構文テーブルの親はTABLE、それ以外なら標準構文テーブルが親になる。

     新たな構文テーブルでは最初は、すべての文字に構文クラス
     “inherit”(‘@’)が与えられ、それらの構文は親テーブルから継承される
     (*note Syntax Class Table::を参照)。

 -- Function: copy-syntax-table &optional table
     この関数はTABLEのコピーを構築して、それをリターンする。TABLEが省略
     または‘nil’なら、標準構文テーブルのコピーをリターンする。それ以外の
     場合、TABLEが構文テーブルでなければエラーをシグナルする。

 -- Command: modify-syntax-entry char syntax-descriptor &optional table
     この関数はSYNTAX-DESCRIPTORに応じて、CHARの構文エントリーをセットす
     る。CHARは文字、または‘(MIN . MAX)’という形式のコンスセルでなければ
     ならない。後者の場合、この関数はMINとMAX(両端を含む)の間のすべての
     文字にたいして、構文エントリーをセットする。

     構文はTABLE(デフォルトはカレントバッファーの構文テーブル)にたいして
     のみ変更され、他のすべての構文テーブルにたいしては変更されない。

     引数SYNTAX-DESCRIPTORは構文記述子、すなわち1文字目が構文クラス指定
     子、2文字目以降がオプションでマッチング文字と構文フラグを指定する文
     字列である。*note Syntax Descriptors::を参照のこと。
     SYNTAX-DESCRIPTORが有効な構文記述子でなければ、エラーがシグナルされ
     る。

     この関数は、常に‘nil’をリターンする。この文字にたいするテーブル内の
     古い構文情報は、破棄される。

     ▼例:

          ;; 空白文字クラスのスペースをputする
          (modify-syntax-entry ?\s " ")
               ⇒ nil

          ;; ‘$’を開カッコ文字にして、
          ;;   ‘^’を対応する閉カッコにする
          (modify-syntax-entry ?$ "(^")
               ⇒ nil

          ;; ‘^’閉カッコ文字にして
          ;;   ‘$’を対応する開カッコにする
          (modify-syntax-entry ?^ ")$")
               ⇒ nil

          ;; ‘/’を区切り文字で
          ;;   コメント開始シーケンス1文字目、
          ;;   かつコメント終了シーケンス2文字目とする
          ;;   これはCモードで使用される
          (modify-syntax-entry ?/ ". 14")
               ⇒ nil

 -- Function: char-syntax character
     この関数は、指定子文字(*note Syntax Class Table::を参照)の表現で、
     CHARACTERの構文クラスをリターンする。これはクラス_だけ_をリターンし
     、マッチング文字や構文フラグはリターンしない。

     以下をCモードにたいして適用してみる(‘char-syntax’がリターンする文字
     を確認しやすいよう‘string’を使用する)。

          ;; スペース文字は空白文字構文クラスをもつ
          (string (char-syntax ?\s))
               ⇒ " "

          ;; スラッシュ文字は区切り文字構文をもつ。
          ;; コメント開始やコメント終了シーケンスの一部でもある場合、
          ;; char-syntax呼び出しはこれを明らかにしないことに注意。
          (string (char-syntax ?/))
               ⇒ "."

          ;; 開カッコ文字は開カッコ構文をもつ。
          ;; これがまっちんぐ文字‘)’をもつことは
          ;; char-syntax呼び出しでは明らかにならないことに注意。
          (string (char-syntax ?\())
               ⇒ "("

 -- Function: set-syntax-table table
     この関数は、カレントバッファーの構文テーブルをTABLEにする。これは
     TABLEをリターンする。

 -- Function: syntax-table
     この関数はカレント構文テーブル(カレントバッファーのテーブル)をリタ
     ーンする。

 -- Command: describe-syntax &optional buffer
     このコマンドは、BUFFER(デフォルトはカレントバッファー)の構文テーブ
     ルのコンテンツをhelpバッファーに表示する。

 -- Macro: with-syntax-table table body...
     このまくろはTABLEをカレント構文テーブルとして使用して、BODYを実行す
     る。これは古いカレント構文テーブルのリストア後に、BODYの最後のフォ
     ームの値をリターンする。

     各バッファーは独自にカレント構文テーブルをもつので、マクロはこれを
     入念に行う。‘with-syntax-table’はマクロ実行開始時、そのときカレント
     のバッファーが何であれ、カレント構文テーブルを一時的に変更する。他
     のバッファーは影響を受けない。


File: elisp,  Node: Syntax Properties,  Next: Motion and Syntax,  Prev: Syntax Table Functions,  Up: Syntax Tables

34.4 Syntax Properties
======================

ある言語の構文を指定するのに構文テーブルが十分に柔軟でないときは、 バッ
ファー内に出現する特定の文字にたいして、テキストプロパティ
‘syntax-table’を適用することにより、構文テーブルをオーバーライドできます
。テキストプロパティを適用する方法については、*note Text Properties::を
参照してください。

   以下はテキストプロパティ‘syntax-table’の有効な値です:

SYNTAX-TABLE
     プロパティの値が構文テーブルなら、根底となるテキスト文字の構文を決
     定するカレントバッファーの構文テーブルのかわりに、そのテーブルが使
     用される。

‘(SYNTAX-CODE . MATCHING-CHAR)’
     この形式のコンスセルは、根底となるテキスト文字の構文クラスを直接指
     定する、raw構文テーブル(*note Syntax Table Internals::を参照)である
     。

‘nil’
     このプロパティが‘nil’なら、その文字の構文はカレント構文テーブルによ
     り通常の方法で決定される。

 -- Variable: parse-sexp-lookup-properties
     これが非‘nil’なら、‘forward-sexp’のような構文をスキャンする関数は、
     syntax-tableテキストプロパティに注意を払い、それ以外ならカレント構
     文テーブルだけを使用する。

 -- Variable: syntax-propertize-function
     この変数が非‘nil’なら、特定のテキスト範囲にたいして‘syntax-table’プ
     ロパティを適用する関数を格納するべきである。これは、モードに適した
     方法で‘syntax-table’プロパティを適用する関数をインストールするため
     に、メジャーモードに使用されることを意図している。

     この関数は‘syntax-ppss’(*note Position Parse::を参照)、および構文フ
     ォント表示化(*note Syntactic Font Lock::を参照)の間にFont Lockモー
     ドにより呼び出される。これは作用すべきテキスト部分の開始STARTと終了
     ENDという、2つの引数で呼び出される。これはENDの前の任意の位置で、
     ‘syntax-ppss’を呼び出すことが許されている。しかし
     ‘syntax-ppss-flush-cache’を呼び出すべきではなく、そのため、ある位置
     で‘syntax-ppss’を呼び出して、後からバッファー内の前の位置を変更する
     ことは許されていない。

 -- Variable: syntax-propertize-extend-region-functions
     このアブノーマルフックは‘syntax-propertize-function’呼び出しに先立
     ち、構文解析コードにより実行される。これは
     ‘syntax-propertize-function’に渡すための、安全なバッファーの開始お
     よび終了位置を見つける助けをする役割をもつ。たとえばメジャーモード
     は、複数行の構文構成を識別して、境界が複数行の中間にならないよう、
     このフックに関数を追加できる。

     このフック内の各関数は、引数STARTとENDを受け取ること。これは2つのバ
     ッファー位置を調整するコンスセル‘(NEW-START . NEW-END)’、調整が必要
     なければ‘nil’をリターンするべきである。フック関数は、それらすべてが
     ‘nil’をリターンするまで、順番に繰り返し実行される。


File: elisp,  Node: Motion and Syntax,  Next: Parsing Expressions,  Prev: Syntax Properties,  Up: Syntax Tables

34.5 Motion and Syntax
======================

このセクションでは、特定の構文クラスをもつ文字間を横断して移動する関数を
説明します。

 -- Function: skip-syntax-forward syntaxes &optional limit
     この関数は、SYNTAXESで指定された構文クラス(構文クラスの文字列)をも
     つ文字を横断して、ポイントを前方に移動する。バッファー終端か、(与え
     られた場合は)位置LIMITに到達、またはスキップしない文字に達した際に
     停止する。

     SYNTAXESが‘^’で始まる場合、この関数は構文がSYNTAXESでは_ない_文字を
     スキップする。

     リターン値は、移動した距離を表す非負の整数。

 -- Function: skip-syntax-backward syntaxes &optional limit
     この関数は、SYNTAXESで指定された構文クラスをもつ文字を横断して、ポ
     イントを後方に移動する。バッファー先頭か、(与えられた場合は)位置
     LIMITに到達、またはスキップしない文字に達した際に停止する。

     SYNTAXESが‘^’で始まる場合、この関数は構文がSYNTAXESでは_ない_文字を
     スキップする。

     リターン値は、移動した距離を表す0以下の整数。

 -- Function: backward-prefix-chars
     この関数は、式プレフィクス構文の任意個数の文字を横断して、後方にポ
     イントを移動する。これには式プレフィクス構文クラスと、フラグ‘p’の文
     字の両方が含まれる。


File: elisp,  Node: Parsing Expressions,  Next: Syntax Table Internals,  Prev: Motion and Syntax,  Up: Syntax Tables

34.6 Parsing Expressions
========================

このセクションでは、バランスのとれた式の解析やスキャンを行う関数を説明し
ます。たとえこれらの関数がLisp以外の言語にたいして作用可能であったとして
も、Lisp用語にしたがい、そのような式のことは“sexps”という用語で参照する
ことにします。基本的にsexpは、バランスのとれたカッコによるグループ化、ま
たは文字列、“symbol”(構文が単語構成要素かシンボル構成要素である文字シー
ケンス)のいずれかです。しかし式プレフィクス構文(*note Syntax Class
Table::を参照)の文字は、それらがsexpに隣接する場合は、sexpの一部として扱
われます。

   構文テーブルは文字の解釈を制御するので、これらの関数はLispモードでの
Lisp式、CモードでのCの式にたいして使用できます。バランスのとれた式にたい
する、有用な高レベル関数については、*note List Motion::を参照してくださ
い。

   ある文字の構文は、パーサー自身の状態の記述ではなく、パーサー状態の変
更方法を制御します。たとえば文字列区切り文字は、“in-string”と
“in-code”,の間でパーサー状態をトグルしますが、文字の構文が直接文字列内部
にあるかどうかを告げることはありません。たとえば(15は汎用文字列区切りの
構文コードであることに注意)、

     (put-text-property 1 9 'syntax-table '(15 . nil))

これはEmacsにたいして、カレントバッファーの最初の8文字が文字列であること
を告げますが、それらはすべて文字列区切りです。結果としてEmacsはそれらを
、連続する4つの空文字列定数として扱います。

* Menu:

* Motion via Parsing::       パースにより機能する移動関数。
* Position Parse::           ある位置の構文状態を判断する。
* Parser State::             Emacsが構文状態を表す方法。
* Low-Level Parsing::        指定されたリージョンを横断するパース。
* Control Parsing::          パースに影響するパラメーター。


File: elisp,  Node: Motion via Parsing,  Next: Position Parse,  Up: Parsing Expressions

34.6.1 Motion Commands Based on Parsing
---------------------------------------

このセクションでは、式のパースにもとづいて処理を行う、シンプルなポイント
移動関数を説明します。

 -- Function: scan-lists from count depth
     この関数は、位置FROMからバランスのとれたカッコのグループをCOUNT個、
     前方にスキャンする。これはスキャンが停止した位置をリターンする。
     COUNTが負なら、スキャンは後方に移動する。

     DEPTHが非0なら、開始位置のカッコのネスト深さをDEPTHとして扱う。スキ
     ャナーは、ネスト深さが0になるまでCOUNT回、繰り返し前方または後方に
     移動する。そのため、正のDEPTHは開始位置からカッコをDEPTHレベル抜け
     出して移動する効果があり、負のDEPTHはカッコがDEPTHレベル深くなるよ
     う移動する効果をもつ。

     ‘parse-sexp-ignore-comments’が非‘nil’なら、スキャンはコメントを無視
     する。

     COUNT個のカッコのグループをスキャンする前に、スキャンがバッファーの
     アクセス可能範囲の先頭か終端に達した場合、そのポイントのネスト深さ
     が0なら、値‘nil’をリターンする。ネスト深さが非0なら、‘scan-error’エ
     ラーをシグナルする。

 -- Function: scan-sexps from count
     この関数は位置FROMから、COUNT個のsexpを前方にスキャンする。これは、
     スキャンが停止した位置をリターンする。COUNTが負なら、スキャンは後方
     へ移動する。

     ‘parse-sexp-ignore-comments’が非‘nil’なら、スキャンはコメントを無視
     する。

     カッコのグループの中間でバッファー(のアクセス可能範囲)の先頭か終端
     に達した場合は、エラーをシグナルする。COUNT個を消費する前に、カッコ
     のグループの間でバッファーの先頭か終端に達した場合は、‘nil’をリター
     ンする。ネスト深さが非0なら、‘scan-error’エラーをシグナルする。

 -- Function: forward-comment count
     この関数は、COUNT個の完全なコメント(すなわち、もしあれば開始区切り
     と終了区切りを含む)、および途中で遭遇する任意の空白文字を横断して、
     ポイントを前方に移動する。COUNTが負なら、後方に移動する。コメントま
     たは空白文字以外のものに遭遇したら停止して、その停止位置にポイント
     を残す。これには、(たとえば)前方に移動してコメント開始を調べる際に
     、コメント終了を探すことも含まれる。この関数は、指定された個数の完
     全なコメントを横断して移動した後も、即座に停止する。空白以外のもの
     がコメント間に存在せずに、期待どおりCOUNT個のコメントが見つかったら
     ‘t’を、それ以外は‘nil’をリターンする。

     この関数は、“コメント”を横断する際、それが文字列内に埋め込まれてい
     るかどうか区別できない。コメントのように見えれば、それらはコメント
     として扱われる。

     ポイント後のすべてのコメントと空白文字を飛び越して移動するには、
     ‘(forward-comment (buffer-size))’を使用する。バッファー内のコメント
     数は‘(buffer-size)’を超えることはできないので、これは引数としての使
     用に適す。


File: elisp,  Node: Position Parse,  Next: Parser State,  Prev: Motion via Parsing,  Up: Parsing Expressions

34.6.2 Finding the Parse State for a Position
---------------------------------------------

インデントのような構文分析にとっては、与えられたバッファー位置に応じた構
文状態の計算が有用なことが多々あります。それを手軽に行うのが、この関数で
す。

 -- Function: syntax-ppss &optional pos
     この関数は、パーサーがバッファー先頭から開始して位置POSで停止するだ
     ろうという、パーサー状態をリターンする。 パーサー状態の説明は、
     *note Parser State::を参照のこと 。

     リターン値は、バッファー先頭からPOSまでパースするために低レベル関数
     ‘parse-partial-sexp’(*note Low-Level Parsing::を参照)を呼び出した場
     合と同じようになる。しかし‘syntax-ppss’は、計算速度向上のために、キ
     ャッシュを使用する。この最適化のため、リターンされるパーサー状態の
     うち2つ目の値(前の完全な部分式)と6つ目の値(最小のカッコ深さ)は意味
     をもたない。

     この関数は、‘syntax-ppss-flush-cache’(以下参照)にたいして、
     ‘before-change-functions’(*note Change Hooks::を参照)にバッファーロ
     ーカルなエントリーを追加するという副作用をもつ。このエントリーは、
     バッファー変更にたいして、キャッシュの一貫性を保つ。とはいえ、
     ‘before-change-functions’が一時的にletでバインドされている間に
     ‘syntax-ppss’が呼び出された場合、または
     ‘inhibit-modification-hooks’使用時のようにバッファーがフックを実行
     せずに変更される場合、キャッシュは更新されないかもしれない。そのよ
     うな場合は、明示的に‘syntax-ppss-flush-cache’を呼び出す必要がある。

 -- Function: syntax-ppss-flush-cache beg &rest ignored-args
     この関数は、‘syntax-ppss’が使用するキャッシュを、位置BEGからフラッ
     シュする。残りの引数IGNORED-ARGSは無視される。
     ‘before-change-functions’(*note Change Hooks::を参照)のような関数で
     直接使用できるよう、この関数はそれらの引数を受け入れる。

   メジャーモードは、パース開始を要する箇所を指定することにより、
‘syntax-ppss’の実行をより高速にできます。

 -- Variable: syntax-begin-function
     これが非‘nil’なら、それはパーサー状態が‘nil’であるような以前のバッ
     ファー位置(別の言い方をすると任意のコメント、文字列、カッコの外部で
     あるような位置)に移動する関数であること。キャッシュが助けとならない
     際、‘syntax-ppss’はその計算をおり最適化するためにこれを使用する。


File: elisp,  Node: Parser State,  Next: Low-Level Parsing,  Prev: Position Parse,  Up: Parsing Expressions

34.6.3 Parser State
-------------------

“パーサー状態(parser state)”とは、バッファー内の指定された開始位置と終了
位置の間のテキストをパースした後の、構文パーサーの状態を記述する10要素の
リストです。‘syntax-ppss’のようなパース関数 (*note Position Parse::を参
照) は、値としてパーサー状態をリターンします。いくつかのパース関数は、パ
ースを再開するために、引数としてパーサー状態を受け取ります。

   以下は、パーサー状態の要素の意味です:

  0. 0から数えたカッコの深さ。*警告:* パーサーの開始位置と終了位置の間に
     開カッコより多くの閉カッコがあれば、負になることもある。

  1. 停止位置を含む最内のカッコグループの開始文字位置。なければ‘nil’。

  2. 最後の終端された完全な部分式の開始文字位置。なければ‘nil’。

  3. 文字列内部なら非‘nil’。より正確には、文字列を終端させるであろう文字
     か、汎用文字列区切りが終端すべきような場合は‘t’となる。

  4. ネスト不可なコメント(または任意のコメントスタイル。*note Syntax
     Flags::を参照されたい)の内部なら‘t’、ネスト可なコメントの内部ならコ
     メントのネストレベル。

  5. 終了位置がクォート文字直後なら‘t’。

  6. 当該スキャン中に遭遇した最小のカッコ深さ。

  7. アクティブなコメントの種類。コメント以外、またはスタイル‘a’のコメン
     ト内なら‘nil’、スタイル‘b’のコメントなら1、スタイル‘c’のコメントな
     ら2、汎用コメント区切り文字で終端されるべきコメントなら
     ‘syntax-table’。

  8. 文字列またはコメントの開始位置。コメント内部ならコメントが始まる位
     置。文字列内部なら文字列が始まる位置。文字列またはコメントの外部な
     ら、この要素は‘nil’になる。

  9. パースを継続するための内部データ。このデータのもつ意味は、変更され
     得る。これは、他の呼び出しのSTATE引数としてこのリストを渡す場合に使
     用される。

   パース継続のために渡す場合、要素1、2、6は無視され、要素8と9は特に重要
ではない場面でのみ使用されます。これらの要素は主に、パーサーコードにより
内部的に使用されます。

   以下の関数を使用することにより、さらに追加でパーサー状態から有用な情
報を利用できます:

 -- Function: syntax-ppss-toplevel-pos state
     この関数はパーサー状態STATEから、文法構造上トップレベルでのパースに
     おける、スキャンした最後の位置をリターンする。“トップレベル”とは、
     すべてのカッコ、コメント、文字列の外部であることを意味する。

     STATEがトップレベルの位置に到達したパースを表す場合、値は‘nil’とな
     る。


File: elisp,  Node: Low-Level Parsing,  Next: Control Parsing,  Prev: Parser State,  Up: Parsing Expressions

34.6.4 Low-Level Parsing
------------------------

式パーサーを使用するもっとも基本的な方法は、特定の状態で与えられた位置か
らパースを開始して、指定した位置でパースを終了するよう指示する方法です。

 -- Function: parse-partial-sexp start limit &optional target-depth
          stop-before state stop-comment
     この関数は、カレントバッファー内のsexpを、STARTから開始してLIMITを
     超えてスキャンしないようパースを行う。これは位置LIMIT、または以下に
     記述する特定の条件に適合したら停止して、パースが停止した位置にポイ
     ントをセットする。これはポイントが停止した位置でのパースの状態を記
     述するパーサー状態 (*note Parser State::を参照) をリターンする。

     3つ目の引数TARGET-DEPTHが非‘nil’の場合、カッコの深さが
     TARGET-DEPTHと等しくなったら、パースを停止する。この深さは0、または
     STATE内で与えられる深さなら何であれ、そこより開始される。

     4つ目の引数STOP-BEFOREが非‘nil’の場合、sexp開始となる任意の文字に到
     達したらパースは停止する。STOP-COMMENTが非‘nil’なら、コメントの開始
     でパースは停止する。STOP-COMMENTがシンボル‘syntax-table’なら、コメ
     ントか文字列の開始の後、またはコメントか文字列の終了のいずれか先に
     到達した方でパースは停止する。

     STATEが‘nil’なら、STARTは関数定義先頭のような、カッコ構造のトップレ
     ベルであるとみなされる。かわりにこの構造の中間でパースを再開したい
     と思うかもしれない。これを行うには、パースの初期状態を記述する
     STATE引数を提供しなければならない。前の‘parse-partial-sexp’呼び出し
     でリターンされた値で、これをうまく行うことができるだろう。


File: elisp,  Node: Control Parsing,  Prev: Low-Level Parsing,  Up: Parsing Expressions

34.6.5 Parameters to Control Parsing
------------------------------------

 -- Variable: multibyte-syntax-as-symbol
     この変数が非‘nil’なら、構文テーブルがそれらについて何と言っているか
     に関わらず、‘scan-sexps’はすべての非ASCII文字をシンボル構成要素とし
     て扱う(とはいえ依然としてテキストプロパティは構文をオーバーラードで
     きるが)。

 -- User Option: parse-sexp-ignore-comments
     この値が非‘nil’なら、このセクション内の関数、および‘forward-sexp’、
     ‘scan-lists’、‘scan-sexps’はコメントを空白文字として扱う。

   ‘parse-partial-sexp’の振る舞いも、‘parse-sexp-lookup-properties’の影
響を受けます(*note Syntax Properties::を参照)。

   1つ、または複数のコメントを横断して前方または後方に移動するには、
‘forward-comment’を使用できます。


File: elisp,  Node: Syntax Table Internals,  Next: Categories,  Prev: Parsing Expressions,  Up: Syntax Tables

34.7 Syntax Table Internals
===========================

構文テーブルは文字テーブル(*note Char-Tables::を参照)として実装されてい
ますが、ほとんどのLispプログラムが直接それらの要素に作用することはありま
せん。構文テーブルは構文データとして構文記述子を格納しません(*note
Syntax Descriptors::を参照)。それらは内部的なフォーマットを使用しており
、それについてはこのセクションで説明します。この内部的フォーマットは、構
文プロパティとして割り当てることもできます(*note Syntax Properties::を参
照)。

   構文テーブル内の各要素は“raw構文記述子(raw syntax descriptor)”という
、‘(SYNTAX-CODE . MATCHING-CHAR)’という形式のコンスセルです。
SYNTAX-CODEは、下記のテーブルに応じて構文クラスと構文フラグをエンコード
する整数です。MATCHING-CHARが非‘nil’なら、それはマッチング文字(構文記述
子内の2つ目の文字と同様)を指定します。

   以下は、さまざまな構文クラスに対応する構文コードです。

Code           Class                  Code           Class
0              空白文字               8              区切り文字ペアー
1              句読点                 9              エスケープ
2              単語                   10             文字クォート
3              シンボル               11             コメント開始
4              開カッコ               12             コメント終了
5              閉カッコ               13             継承
6              式プレフィクス         14             汎用コメント
7              文字列クォート         15             汎用文字列

たとえば標準構文テーブルでは、‘(’にたいするエントリーは‘(4 . 41)’であり
、41は‘)’の文字コードです。

   構文フラグは、最下位ビットから16ビット目より始まる、高位ビットにエン
コードされます。以下のテーブルは、対応する各構文フラグにたいして、2のべ
き乗を与えます。

Prefix      Flag                   Prefix      Flag
‘1’         ‘(lsh 1 16)’           ‘p’         ‘(lsh 1 20)’
‘2’         ‘(lsh 1 17)’           ‘b’         ‘(lsh 1 21)’
‘3’         ‘(lsh 1 18)’           ‘n’         ‘(lsh 1 22)’
‘4’         ‘(lsh 1 19)’

 -- Function: string-to-syntax desc
     与えられた構文記述子DESC(文字列)にたいして、この関数は対応するraw構
     文記述子をリターンする。

 -- Function: syntax-after pos
     この関数は、バッファー内の位置POSの後の文字にたいして、構文テーブル
     と同様に構文プロパティも考慮した、raw構文記述子をリターンする。
     POSがバッファーのアクセス可能範囲(*note accessible portion:
     Narrowing.を参照)の外部なら、リターン値は‘nil’となる。

 -- Function: syntax-class syntax
     この関数はraw構文記述子SYNTAXにたいする、構文コードをリターンする。
     より正確には、これはraw構文記述子のSYNTAX-CODE要素から、構文フラグ
     を記録する高位16ビットをマスクして、その結果の整数をリターンする。

     SYNTAXが‘nil’なら、リターン値は‘nil’となる。これは以下の式

          (syntax-class (syntax-after pos))

     は、‘pos’がバッファーのアクセス可能範囲外部なら、エラーをthrowした
     り不正なコードをリターンすることなく、‘nil’に評価されるからである。


File: elisp,  Node: Categories,  Prev: Syntax Table Internals,  Up: Syntax Tables

34.8 Categories
===============

“カテゴリー(categories)”は、構文的に文字をクラス分けする別の手段を提供し
ます。必要に応じて複数のカテゴリーを定義して、それぞれの文字に独立して
1つ以上のカテゴリーを割り当てることができます。構文クラスと異なり、カテ
ゴリーは互いに排他ではありません。1つの文字が複数のカテゴリーに属すのは
、普通のことです。

   バッファーはそれぞれ“カテゴリーテーブル(category table)”をもっていま
す。これはどのカテゴリーが定義されていて、各カテゴリーにどの文字が属すか
を記録しています。カテゴリーテールは自身のカテゴリーを定義しますが、標準
カテゴリーはすべてのモードで利用可能なので、通常これらは標準カテゴリーテ
ーブルをコピーすることにより初期化されます。

   カテゴリーはそれぞれ、‘ ’から‘~’の範囲のASCIIプリント文字による名前を
もちます。‘define-category’で定義する際は、カテゴリーの名前を指定します
。

   カテゴリーテーブルは、実際には文字テーブルです(*note Char-Tables::を
参照)。カテゴリーテーブルのインデックスCの要素は、文字Cが属するカテゴリ
ーを示す“カテゴリーセット(category set)”というブールベクターです。このカ
テゴリーセット内で、もしインデックスCATの要素が‘t’なら、CATはそのセット
のメンバーであり、その文字CはカテゴリーCATに属することを意味します。

   以下の3つの関数では、オプション引数TABLEのデフォルトはカレントバッフ
ァーのカテゴリーテーブルです。

 -- Function: define-category char docstring &optional table
     この関数はカテゴリーテーブルTABLEにたいして、名前がCHAR、ドキュメン
     トがDOCSTRINGであるような、新たなカテゴリーを定義する。

     以下に強い右から左への指向性をもつ文字(*note Bidirectional
     Display::を参照)にたいするカテゴリーを新たに定義して、それを特別な
     カテゴリーテーブル内で使用する例を示す:

          (defvar special-category-table-for-bidi
            (let ((category-table (make-category-table))
          	(uniprop-table (unicode-property-table-internal 'bidi-class)))
              (define-category ?R "Characters of bidi-class R, AL, or RLO"
                               category-table)
              (map-char-table
               #'(lambda (key val)
          	 (if (memq val '(R AL RLO))
          	     (modify-category-entry key ?R category-table)))
               uniprop-table)
              category-table))

 -- Function: category-docstring category &optional table
     この関数は、カテゴリーテーブルTABLE内のカテゴリーCATEGORYの、ドキュ
     メント文字列をリターンする。

          (category-docstring ?a)
               ⇒ "ASCII"
          (category-docstring ?l)
               ⇒ "Latin"

 -- Function: get-unused-category &optional table
     この関数は、TABLE内で現在のところ未定義なカテゴリーの名前(文字)をリ
     ターンする。TABLE内で利用可能なカテゴリーがすべて使用済みなら、
     ‘nil’をリターンする。

 -- Function: category-table
     この関数は、カレントバッファーのカテゴリーテーブルをリターンする。

 -- Function: category-table-p object
     この関数は、OBJECTがカテゴリーテーブルなら‘t’、それ以外は‘nil’をリ
     ターンする。

 -- Function: standard-category-table
     この関数は、標準カテゴリーテーブルをリターンする。

 -- Function: copy-category-table &optional table
     この関数は、TABLEのコピーを構築して、それをリターンする。TABLEが与
     えられない(または‘nil’)場合は、標準カテゴリーテーブルのコピーをリタ
     ーンする。それ以外の場合は、もしTABLEがカテゴリーテーブルでなければ
     、エラーをシグナルする。

 -- Function: set-category-table table
     この関数は、TABLEをカレントバッファーのカテゴリーテーブルにする。リ
     ターン値はTABLE。

 -- Function: make-category-table
     これは空のカテゴリーテーブルを作成してリターンする。 This creates
     and returns an empty category table. 空のカテゴリーテーブルでは、ど
     のカテゴリーも割り当てられておらず、何らかのカテゴリーに属する文字
     もない。

 -- Function: make-category-set categories
     この関数は、初期内容が文字列CATEGORIESにリストされるカテゴリーであ
     るような、新たなカテゴリーセット(ブールベクター)をリターンする。
     CATEGORIESの要素はカテゴリー名であること。新たなカテゴリーセットは
     それらのカテゴリーにたいして‘t’、それ以外のすべてのカテゴリーにたい
     して‘nil’をもつ。

          (make-category-set "al")
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: char-category-set char
     この関数は、カレントバッファーのカテゴリーテーブル内で、文字CHARに
     たいするカテゴリーセットをリターンする。これは文字CHARが属するカテ
     ゴリーを記録するブールベクターである。関数‘char-category-set’は、カ
     テゴリーテーブル内にある同じブールベクターをリターンするので、メモ
     リーの割り当ては行わない。

          (char-category-set ?a)
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: category-set-mnemonics category-set
     この関数は、カテゴリーセットCATEGORY-SETを、そのセットのメンバーの
     カテゴリーを指定する文字を含む文字列に変換する。

          (category-set-mnemonics (char-category-set ?a))
               ⇒ "al"

 -- Function: modify-category-entry char category &optional table reset
     この関数は、カテゴリーテーブルTABLE(デフォルトはカレントバッファー
     のカテゴリーテーブル)内の、CHARのカテゴリーセットを変更する。CHARに
     は文字、または‘(MIN . MAX)’という形式のコンスセルを指定できる。後者
     の場合、この関数はMINとMAXの間(両端を含む)の範囲にある、すべての文
     字のカテゴリーセットを変更する。

     これは通常、カテゴリーセットにCATEGORYを追加することにより、変更を
     行う。しかしRESETが非‘nil’なら、かわりにCATEGORYを削除する。

 -- Command: describe-categories &optional buffer-or-name
     この関数は、カレントカテゴリーテーブル内のカテゴリー仕様を説明する
     。これはその説明をバッファーに挿入してから、そのバッファーを表示す
     る。BUFFER-OR-NAMEが非‘nil’なら、かわりにそのバッファーのカテゴリー
     テーブルを説明する。


File: elisp,  Node: Abbrevs,  Next: Processes,  Prev: Syntax Tables,  Up: Top

35 Abbrevs and Abbrev Expansion
*******************************

略語(abbreviation)、または“abbrev”は、より長い文字列へと展開される文字列
です。ユーザーはabbrev文字列を挿入して、それを探して自動的にabbrevの展開
形に置換できます。これによりタイプ量を節約できます。

   カレントで効果をもつabbrevsのセットは、“abbrevテーブル(abbrev
table)”内に記録されます。バッファーはそれぞれローカルにabbrevテーブルを
もちますが、通常は同一のメジャーモードにあるすべてのバッファーが1つの
abbrevテーブルを共有します。グローバルabbrevテーブルも存在します。通常は
両者が使用されます。

   abbrevテーブルはobarrayとして表されます。obarraysについての情報は、
*note Creating Symbols::を参照してください。,abbrevはそれぞれ、obarray内
のシンボルとして表現されます。そのシンボルの名前がabbrevで、値が展開形に
なります。シンボルの関数定義は展開を行うフック関数です(*note Defining
Abbrevs::を参照)。また、シンボルノプロパティセルには、使用回数やその
abbrevが展開された回数を含む、さまざまな追加プロパティが含まれます(*note
Abbrev Properties::を参照)。

   “システムabbrev(system abbrevs)”と呼ばれる特定のabbrevは、ユーザーで
はなくメジャーモードにより定義されます。システムabbrevは、非‘nil’の
‘:system’プロパティにより識別されます(*note Abbrev Properties::を参照)。
abbrevがabbrevファイルに保存される際、システムabbrevは省略されます。
*note Abbrev Files::を参照してください。

   abbrevに使用されるシンボルは通常のobarrayにinternされないので、Lisp式
の読み取り結果として現れることは決してありません。実際に、通常はabbrevを
扱うコードを除き、それらが使用されることはありません。したがって、それら
を非標準的な方法で使用しても安全なのです。

   マイナーモードであるAbbrevモードが有効な場合、バッファーローカル変数
‘abbrev-mode’は非‘nil’となり、そのバッファー内で、abbrevは自動的に展開さ
れます。abbrev用のユーザーレベルのコマンドについては、*note Abbrev Mode:
(emacs)Abbrevs.を参照してください。

* Menu:

* Tables: Abbrev Tables.     abbrevテーブルの作成と操作。
* Defining Abbrevs::         略語の指定とそれらの展開。
* Files: Abbrev Files.       ファイルへのabbrevの保存。
* Expansion: Abbrev Expansion.  展開の制御と展開サブルーチン。
* Standard Abbrev Tables::   種々メジャーモードに使用されるabbrevテーブル。
* Abbrev Properties::        abbrevプロパティの読み取りとセットを行う方法。どのプロパティが何の効果をもつか。
* Abbrev Table Properties::  abbrevテーブルプロパティの読み取りとセットを行う方法。どのプロパティが効果をもつか。


File: elisp,  Node: Abbrev Tables,  Next: Defining Abbrevs,  Up: Abbrevs

35.1 Abbrev Tables
==================

このセクションでは、abbrevテーブルの作成と操作を行う方法について説明しま
す。

 -- Function: make-abbrev-table &optional props
     この関数は、空のabbrevテーブル(シンボルを含まないobarray)を作成して
     リターンする。これは0で充填されたベクターである。PROPSは、新たなテ
     ーブルに適用されるプロパティリストである(*note Abbrev Table
     Properties::を参照)。

 -- Function: abbrev-table-p object
     この関数は、OBJECTがabbrevテーブルなら、非‘nil’をリターンする。

 -- Function: clear-abbrev-table abbrev-table
     この関数は、ABBREV-TABLE内のabbrevをすべて未定義とし、空のまま残す
     。

 -- Function: copy-abbrev-table abbrev-table
     この関数は、ABBREV-TABLEのコピー(同じabbrev定義を含む新たなabbrevテ
     ーブル)をリターンする。これは名前、値、関数だけをコピーし、プロパテ
     ィリストは何も_コピーしない_。

 -- Function: define-abbrev-table tabname definitions &optional
          docstring &rest props
     この関数はabbrevテーブル名(値がabbrevテーブルであるような変数)とし
     てTABNAME(シンボル)を定義する。これは、そのテーブル内に
     DEFINITIONSに応じて、abbrevを定義する。DEFINITIONSは、‘(ABBREVNAME
     EXPANSION [HOOK] [PROPS...])’という形式の要素をもつリストである。こ
     れらの要素は引数として、‘define-abbrev’に渡される。

     オプション文字列DOCSTRINGは、変数TABNAMEのドキュメント文字列である
     。プロパティリストPROPSは、abbrevテーブルに適用される(*note Abbrev
     Table Properties::を参照)。

     同一のTABNAMEにたいしてこの関数が複数回呼び出された場合は、元のコン
     テンツ全体を上書きせずに、後続の呼び出しはDEFINITIONS内の定義を
     TABNAMEに追加する(後続の呼び出しでは、DEFINITIONS内で明示的に再定義
     または未定義にした場合のみabbrevを上書きできる)。

 -- Variable: abbrev-table-name-list
     これは、値がabbrevテーブルであるようなシンボルのリストである。
     ‘define-abbrev-table’は、このリストに新たなabbrevテーブル名を追加す
     る。

 -- Function: insert-abbrev-table-description name &optional human
     この関数は、ポイントの前に名前がNAMEのabbrevテーブルの説明を挿入す
     る。引数NAMEは、値がabbrevテーブルであるようなシンボルである。

     HUMANが非‘nil’なら、説明は人間向けになる。システムabbrevはそのよう
     にリストされ、識別される。それ以外なら説明はLisp式(カレントで定義さ
     れているようにNAMEを定義するが、システムabbrevとしては定義しないよ
     うな‘define-abbrev-table’呼び出し)となる(NAMEを使用するモードまたは
     パッケージは、それらを個別にNAMEに追加すると想定されている)。


File: elisp,  Node: Defining Abbrevs,  Next: Abbrev Files,  Prev: Abbrev Tables,  Up: Abbrevs

35.2 Defining Abbrevs
=====================

‘define-abbrev’は、abbrevテーブル内にabbrevを定義するための基本的な低レ
ベル関数です。

   メジャーモードがシステムabbrevを定義する際は、‘:system’プロパティに
‘t’を指定して‘define-abbrev’を呼び出すべきです。すべての保存された非“シ
ステム”abbrevは起動時(何らかのメジャーモードがロードされる前)にリストア
されることに注意してください。したがってメジャーモードは、最初にそのモー
ドがロードされた際、それらのモードのabbrevテーブルが空であると仮定するべ
きではありません。

 -- Function: define-abbrev abbrev-table name expansion &optional hook
          &rest props
     この関数は、ABBREV-TABLE内にNAMEという名前で、EXPANSIONに展開され、
     HOOKを呼び出すabbrevを、プロパティPROPS(*note Abbrev Properties::を
     参照)とともに定義する。リターン値はNAME。ここでは、PROPS内の
     ‘:system’プロパティは特別に扱われる。このプロパティが値‘force’をも
     つなら、たとえ同じ名前の非“システム”abbrevでも、既存の定義を上書き
     するだろう。

     NAMEは文字列であること。引数EXPANSIONは通常は望む展開形(文字列)であ
     り、‘nil’ならそのabbrevを未定義とする。これが文字列または‘nil’以外
     の何かなら、そのabbrevはHOOKを実行することにより、単に“展開”される
     。

     引数HOOKは、関数または‘nil’であること。HOOKが非‘nil’なら、abbrevが
     EXPANSIONに置換された後に、引数なしでそれが呼び出される。HOOK呼び出
     し時、ポイントはEXPANSIONの終端に置かれる。

     HOOKが、‘no-self-insert’プロパティが非‘nil’であるような、非‘nil’の
     シンボルなら、HOOKは展開をトリガーするような自己挿入入力文字を挿入
     できるかどうかを、明示的に制御できる。この場合、HOOKが非‘nil’をリタ
     ーンしたら、その文字の挿入を抑止する。対照的に、HOOKが‘nil’をリター
     ンした場合は、あたかも実際には展開が行われなかったかのように、
     ‘expand-abbrev’(または‘abbrev-insert’)も‘nil’をリターンする。

     通常‘define-abbrev’は、実際にabbrevを変更した場合は、変数
     ‘abbrevs-changed’に‘t’をセットする。これはいくつかのコマンドが、
     abbrevの保存を提案するためである。システムabbrevは、いずれにせよ保
     存されないので、システムabbrevにたいして、これは行われない。

 -- User Option: only-global-abbrevs
     この変数が非‘nil’なら、それはユーザーがグローバルabbrevのみの使用を
     計画していることを意味する。これはモード固有のabbrevを定義するコマ
     ンドにたいして、かわりにグローバルabbrevを定義するよう指示する。こ
     の変数は、このセクション内の関数の振る舞いを変更しない。それは呼び
     出し側により検証される。


File: elisp,  Node: Abbrev Files,  Next: Abbrev Expansion,  Prev: Defining Abbrevs,  Up: Abbrevs

35.3 Saving Abbrevs in Files
============================

abbrev定義が保存されたファイルは、実際にはLispコードのファイルです。
abbrevは、同じコンテンツの同じabbrevテーブルを定義する、Lispプログラムの
形式で保存されます。したがってそのファイルは、‘load’でロードすることがで
きます(*note How Programs Do Loading::を参照)。しかし、より簡便なインタ
ーフェースとして、関数‘quietly-read-abbrev-file’が提供されています。起動
時に、Emacsは自動的にこの関数を呼び出します。

   ‘save-some-buffers’のようなユーザーレベルの機能は、ここで説明する変数
の制御下で、自動的にabbrevをファイルに保存できます。

 -- User Option: abbrev-file-name
     これは、abbrevの読み込みと保存のための、デフォルトのファイル名であ
     る。

 -- Function: quietly-read-abbrev-file &optional filename
     この関数は、以前に‘write-abbrev-file’で書き込まれた、FILENAMEという
     名前のファイルから、abbrevの定義を読み込む。FILENAMEが省略または
     ‘nil’なら、‘abbrev-file-name’内で指定されているファイルが使用される
     。

     その名前が暗示するように、この関数は何のメッセージも表示しない。

 -- User Option: save-abbrevs
     ‘save-abbrevs’にたいする非‘nil’値は、ファイル保存時に、(もし何か変
     更されていれば)Emacsがabbrevの保存を提案するべきであることを意味す
     る。値が‘silently’なら、Emacsはユーザーに尋ねることなく、abbrevを保
     存する。‘abbrev-file-name’は、abbrevを保存するファイルを指定する。

 -- Variable: abbrevs-changed
     この変数は、abbrev(システムabbrevを除く)の定義または変更によりセッ
     トされる。これは、さまざまなEmacsコマンドにとって、ユーザーに
     abbrevの保存を提案するための、フラグとしての役目をもつ。

 -- Command: write-abbrev-file &optional filename
     ‘abbrev-table-name-list’内にリストされたすべてのabbrevテーブルにた
     いして、すべてのabbrev定義(システムabbrevを除く)を、ロード時に同じ
     abbrevを定義するであろうLispプログラム形式で、ファイルFILENAME内に
     保存する。FILENAMEが‘nil’なら、‘abbrev-file-name’が仕様される。この
     関数は‘nil’をリターンする。


File: elisp,  Node: Abbrev Expansion,  Next: Standard Abbrev Tables,  Prev: Abbrev Files,  Up: Abbrevs

35.4 Looking Up and Expanding Abbreviations
===========================================

abbrevは通常、‘self-insert-command’を含む、特定のinteractiveなコマンドに
より展開されます。このセクションでは、そのようなコマンドの記述に使用され
るサブルーチン、並びに通信のために使用される変数について説明します。

 -- Function: abbrev-symbol abbrev &optional table
     この関数は、ABBREVという名前のabbrevを表すシンボルをリターンする。
     そのabbrevが定義されていなければ、‘nil’をリターンする。オプションの
     2つ目の引数TABLEは、それを照合するためのabbrevテーブルである。
     TABLEが‘nil’なら、この関数はまずカレントバッファーのローカル
     abbrevテーブル、次にグローバルabbrevテーブルを試みる。

 -- Function: abbrev-expansion abbrev &optional table
     この関数は、ABBREVが展開されるであろう文字列(カレントバッファーにた
     いして使用されるabbrevテーブルで定義される文字列)をリターンする。こ
     れはABBREVが有効なabbrevでなければ、‘nil’をリターンする。オプション
     引数TABLEは‘abbrev-symbol’の場合と同様、使用するabbrevテーブルを指
     定する。

 -- Command: expand-abbrev
     このコマンドは、(もしあれば)ポイントの前のabbrevを展開する。ポイン
     トがabbrevの後になければ、このコマンドは何もしない。展開を行うため
     に、これは変数‘abbrev-expand-function’の値となっている関数を引数な
     しで呼び出し、何であれその関数がリターンしたものをリターンする。

     デフォルトの展開関数は、展開を行ったらabbrevのシンボル、それ以外は
     ‘nil’をリターンする。そのabbrevシンボルが、‘no-self-insert’プロパテ
     ィが非‘nil’のシンボルであるようなフック関数をもち、そのフック関数が
     値として‘nil’をリターンした場合は、たとえ展開が行われたとしても、デ
     フォルト展開関数は‘nil’をリターンする。

 -- Function: abbrev-insert abbrev &optional name start end
     この関数は、‘start’と‘end’の間のテキストを置換することにより、
     ‘abbrev’のabbrev展開形を挿入する。‘start’が省略された場合のデフォル
     トは、ポイントである。‘name’が非‘nil’なら、それはこのabbrevが見つか
     った名前(文字列)であること。これは展開形のcapitalizationを調整する
     かどうかを判断するために使用される。この関数は、abbrevの挿入に成功
     したら‘abbrev’をリターンする。

 -- Command: abbrev-prefix-mark &optional arg
     このコマンドは、ポイントのカレント位置を、abbrevの開始としてマーク
     する。‘expand-abbrev’の次回呼び出しでは、通常のように以前の単語では
     なく、ここからポイント(その時点での位置)にあるテキストが展開するべ
     きabbrevとして使用される。

     このコマンドはまず、ARGが‘nil’なら、ポイントの前の任意のabbrevを展
     開する(インタラクティブな呼び出しでは、ARGはプレフィクス引数である
     )。それから、展開する次のabbrevの開始を示すために、ポイントの前にハ
     イフンを挿入する。実際の展開では、ハイフンは削除される。

 -- User Option: abbrev-all-caps
     これが非‘nil’にセットされているときは、すべて大文字で入力された
     abbrevは、すべて大文字を使用して展開される。それ以外なら、すべて大
     文字で入力されたabbrevは、展開形の単語ごとにcapitalizeして展開され
     る。

 -- Variable: abbrev-start-location
     この変数の値は、次にabbrevを展開する開始位置として‘expand-abbrev’に
     使用される、バッファー位置である。値は‘nil’も可能で、かわりにポイン
     トの前の単語を使用することを意味する。‘abbrev-start-location’は、
     ‘expand-abbrev’の呼び出しごとに、毎回‘nil’にセットされる。この変数
     は、‘abbrev-prefix-mark’によってもセットされる。

 -- Variable: abbrev-start-location-buffer
     この変数の値は、‘abbrev-start-location’がセットされたバッファーであ
     る。他のバッファーでabbrev展開を試みることにより、
     ‘abbrev-start-location’はクリアーされる。この変数は、
     ‘abbrev-prefix-mark’によりセットされる。

 -- Variable: last-abbrev
     これは、直近のabbrev展開の‘abbrev-symbol’である。これは、
     ‘unexpand-abbrev’コマンド(*note Expanding Abbrevs: (emacs)Expanding
     Abbrevs.を参照)のために、‘expand-abbrev’により残された情報である。

 -- Variable: last-abbrev-location
     これは、直近の.abbrev展開の場所である。これには、
     ‘unexpand-abbrev’コマンドのために‘expand-abbrev’により残された情報
     が含まれる。

 -- Variable: last-abbrev-text
     これは直近のabbrev展開の正確な展開形を、(もしあれば)大文字小文字変
     換した後のテキストである。そのabbrevがすでに非展開されていれば、値
     は‘nil’になる。これには‘unexpand-abbrev’コマンドのために、
     ‘expand-abbrev’により残された情報が含まれる。

 -- Variable: abbrev-expand-function
     この変数の値は、展開を行うために‘expand-abbrev’が引数なしで呼び出す
     であろう関数である。この関数では、展開を行う前後に行いたいことを行
     うことができる。展開が行われた場合は、そのabbrevシンボルをリターン
     すること。

   以下のサンプルコードで、‘abbrev-expand-function’のシンプルな使い方を
示します。このサンプルでは、‘foo-mode’が‘#’で始まる行がコメントであるよ
うな、特定のファイルを編集するためのモードであるとします。それらコメント
行にたいしては、Textモードのabbrevの使用が望ましく、その他すべての行にた
いしては、正規のローカルabbrevテーブル‘foo-mode-abbrev-table’が適してい
ます。‘local-abbrev-table’と‘text-mode-abbrev-table’の定義については、
*note Standard Abbrev Tables::を参照してください。‘add-function’について
の詳細は、*note Advising Functions::を参照してください。

     (defun foo-mode-abbrev-expand-function (expand)
       (if (not (save-excursion (forward-line 0) (eq (char-after) ?#)))
           ;; 通常の展開を行う
           (funcall expand)
         ;; コメント内はtext-modeのabbrevを使用
         (let ((local-abbrev-table text-mode-abbrev-table))
           (funcall expand))))

     (add-hook 'foo-mode-hook
               #'(lambda ()
                   (add-function :around (local 'abbrev-expand-function)
                                 #'foo-mode-abbrev-expand-function)))


File: elisp,  Node: Standard Abbrev Tables,  Next: Abbrev Properties,  Prev: Abbrev Expansion,  Up: Abbrevs

35.5 Standard Abbrev Tables
===========================

以下は、Emacsの事前ロードされるメジャーモード用のabbrevテーブルを保持す
る変数のリストです。

 -- Variable: global-abbrev-table
     これは、モード非依存なabbrev用のabbrevテーブルである。この中で定義
     されるabbrevは、すべてのバッファーに適用される。各バッファーはロー
     カルabbrevテーブルももつかもしれず、それのabbrev定義はグローバルテ
     ーブル内のabbrev定義より優先される。

 -- Variable: local-abbrev-table
     このバッファーローカル変数の値は、カレントバッファーの(モード固有の
     )abbrevテーブルである。これは、そのようなテーブルのリストでもあり得
     る。

 -- Variable: abbrev-minor-mode-table-alist
     この変数の値は、‘(MODE . ABBREV-TABLE)’という形式のリストである。こ
     こでMODEは変数の名前である。その変数が非‘nil’にバインドされていれば
     ABBREV-TABLEはアクティブで、それ以外なら無視される。ABBREV-TABLEは
     、abbrevテーブルのリストでもあり得る。

 -- Variable: fundamental-mode-abbrev-table
     これは、Fundamentalモードで使用される、ローカルabbrevテーブルである
     。別の言い方をすると、これはFundamentalモードにあるすべてのバッファ
     ーの、ローカルabbrevテーブルである。

 -- Variable: text-mode-abbrev-table
     これは、Textモードで使用される、ローカルabbrevテーブルである。

 -- Variable: lisp-mode-abbrev-table
     これはLispモードで使用されるローカルabbrevテーブルであり、Emacs
     Lispモードで使用されるローカルabbrevテーブルの親テーブルである。
     *note Abbrev Table Properties::を参照のこと。


File: elisp,  Node: Abbrev Properties,  Next: Abbrev Table Properties,  Prev: Standard Abbrev Tables,  Up: Abbrevs

35.6 Abbrev Properties
======================

abbrevはプロパティをもち、それらのいくつかはabbrevの働きに影響します。こ
れらのプロパティを‘define-abbrev’の引数として提供して、以下の関数で操作
できます:

 -- Function: abbrev-put abbrev prop val
     ABBREVのプロパティPROPに値VALをセットする。

 -- Function: abbrev-get abbrev prop
     ABBREVのプロパティPROP、そのabbrevがそのようなプロパティをもたなけ
     れば‘nil’をリターンする。

   以下のプロパティには特別な意味があります:

‘:count’
     このプロパティは、そのabbrevが展開された回数を計数する。明示的にセ
     ットしなければ、‘define-abbrev’により0に初期化される。

‘:system’
     非‘nil’なら、このプロパティはシステムabbrevとして、そのabbrevをマス
     クする。そのようなabbrevは保存されない(*note Abbrev Files::を参照
     )。

‘:enable-function’
     非‘nil’の場合、そのabbrevが使用されるべきでなければ‘nil’、それ以外
     なら‘t’をリターンするような、引数なしの関数であること。

‘:case-fixed’
     非‘nil’なら、このプロパテぃはそのabbrevの大文字小文字には意味があり
     、同じパターンにcapitalizeされたテキストだけにマッチすべきことを示
     す。これは展開のcapitalizationを変更するコードも無効にする。


File: elisp,  Node: Abbrev Table Properties,  Prev: Abbrev Properties,  Up: Abbrevs

35.7 Abbrev Table Properties
============================

abbrevと同じようにabbrevテーブルもプロパティをもち、それらのいくつかは
abbrevテーブルの働きに影響を与えます。これらのプロパティを
‘define-abbrev-table’の引数として提供して、それらを関数で操作できます:

 -- Function: abbrev-table-put table prop val
     abbrevテーブルTABLEのプロパティPROPに、値VALをセットする。

 -- Function: abbrev-table-get table prop
     abbrevテーブルのプロパティPROP、そのabbrevテーブルがそのようなをプ
     ロパティもたなければ‘nil’をリターンする。

   以下のプロパティには特別な意味があります:

‘:enable-function’
     abbrevプロパティ‘:enable-function’と似ているが、そのテーブル内のす
     べてのabbrevに適用される点が異なる。これはポイントの前のabbrevを探
     すことを試みる前にも使用されるので、abbrevテーブルを動的に変更する
     ことが可能である。

‘:case-fixed’
     これはabbrevプロパティ‘:case-fixed’と似ているが、そのテーブル内のす
     べてのabbrevに適用される点が異なる。

‘:regexp’
     非‘nil’なら、このプロパティはそのテーブルを照合する前に、ポイント前
     のabbrev名を抽出するための方法を示す正規表現である。その正規表現が
     ポイントの前にマッチしたときは、そのabbrev名はsubmatchの1と期待され
     る。このプロパティが‘nil’なら、デフォルトは‘backward-word’と
     ‘forward-word’を使用して、abbrevの名前を探す。このプロパティにより
     、単語構文以外の文字を含む名前のabbrevが使用できる。

‘:parents’
     このプロパティは、他のabbrevを継承したテーブルのリストを保持する。

‘:abbrev-table-modiff’
     このプロパティは、そのテーブルにabbrevが追加される度に増分されるカ
     ウンターを保持する。


File: elisp,  Node: Processes,  Next: Display,  Prev: Abbrevs,  Up: Top

36 Processes
************

オペレーティングシステムの用語では、“プロセス(process)”とはプログラムを
実行できるスペースのことです。Emacsはプロセス内で実行されます。Emacs
Lispプログラムは、別のプログラムをそれら自身のプロセス内で呼び出すことが
できます。これらは、“親プロセス(parent process)”であるEmacsプロセスの“サ
ブプロセス(subprocesses)”、または“子プロセス(child processes)”と呼ばれま
す。

   Emacsのサブプロセスは“同期(synchronous)”、または“非同期
(asynchronous)”であり、それはそれらが作成された方法に依存します。同期サ
ブプロセスを作成した際、Lispプログラムは実行を継続する前に、そのサブプロ
セスの終了を待機します。非同期サブプロセスを作成したときは、それをLispプ
ログラムと並行して実行できます。この種のサブプロセスは、EmacsではLispオ
ブジェクととして表現され、そのオブジェクトも“プロセス”と呼ばれています。
Lispプログラムはサブプロセスとのやり取りや、サブプロセスの制御のために、
このオブジェクトを使用できます。たとえばシグナル送信、ステータス情報の取
得、プロセス出力の受信や、プロセスへ入力を送信することができます。

 -- Function: processp object
     この関数は、OBJECTがEmacsのサブプロセスを表すなら‘t’、それ以外は
     ‘nil’をリターンする。

   カレントEmacsセッションのサブプロセスに加えて、そのマシン上で実行中の
他のプロセスにアクセスすることもできます。*note System Processes::を参照
してください。

* Menu:

* Subprocess Creation::      サブプロセスを開始する関数。
* Shell Arguments::          shellに渡すために引数をクォートする。
* Synchronous Processes::    同期サブプロセス使用の詳細。
* Asynchronous Processes::   非同期サブプロセスの起動。
* Deleting Processes::       非同期サブプロセスの削除。
* Process Information::      実行状態および他の属性へのアクセス。
* Input to Processes::       非同期サブプロセスへの入力の送信。
* Signals to Processes::     非同期サブプロセスの停止、継続、割り込み。
* Output from Processes::    非同期サブプロセスからの出力の収集。
* Sentinels::                プロセスの実行状態変更時に実行されるセンチネル。
* Query Before Exit::        exitによりプロセスがkillされる場合に問い合わせるかどうか。
* System Processes::         そのシステム上で実行中の別プロセスへのアクセス。
* Transaction Queues::       サブプロセスとのトランザクションベースのコミュニケション。
* Network::                  ネットワーク接続のopen。
* Network Servers::          Emacsによるネット接続のacceptを可能にするネットワークサーバー。
* Datagrams::                UDPネットワーク接続。
* Low-Level Network::        接続およびサーバーを作成するための、より低レベルだがより汎用的な関数。
* Misc Network::             ネット接続用の追加の関連関数。
* Serial Ports::             シリアルポートでのやり取り。
* Byte Packing::             bindatを使用したバイナリーデータのpackとunpack。


File: elisp,  Node: Subprocess Creation,  Next: Shell Arguments,  Up: Processes

36.1 Functions that Create Subprocesses
=======================================

内部でプログラムを実行するサブプロセスを作成するために、3つのプリミティ
ブが存在します。1つは‘start-process’で、これは非同期プロセスを作成して、
プロセスオブジェクトをリターンします(*note Asynchronous Processes::を参
照)。他の2つは‘call-process’と‘call-process-region’で、これらは同期プロ
セスを作成して、プロセスオブジェクとをリターンしません(*note Synchronous
Processes::を参照)。特定のタイプのプロセスを実行するために、これらのプリ
ミティブを利用する、さまざまな高レベル関数が存在します。

   同期プロセスと非同期プロセスについては、以降のセクションで説明します
。この3つの関数はすべて類似した様式で呼び出されるので、ここでそれらに共
通の引数について説明します。

   すべての場合において、その関数のPROGRAM引数は、実行するプログラムを指
定します。ファイルが見つからなかったり、実行できない場合は、エラーがシグ
ナルされます。ファイル名が相対的な場合、検索するディレクトリーのリストは
、変数‘exec-path’に格納されています。Emacsは起動時、環境変数‘PATH’の値に
もとづいて、‘exec-path’を初期化します。‘exec-path’内では、標準的なファイ
ル名構成要素‘~’、‘.’、‘..’は通常どおり解釈されますが、環境変数の置換
(‘$HOME’等)は認識されません。それらの置換を行うには、
‘substitute-in-file-name’を使用してください(*note File Name Expansion::を
参照)。このリスト内で‘nil’は、‘default-directory’を参照します。

   プログラムの実行では、指定された名前にサフィックスの追加を試みること
もできます:

 -- User Option: exec-suffixes
     この変数は、指定されたプログラムファイル名への追加を試みるための、
     サフィックス(文字列)のリストである。指定されたとおりの名前を試みた
     いなら、このリストに‘""’を含めること。デフォルト値はシステムに依存
     する。

   *注意してください:* 引数PROGRAMにはプログラム名だけが含まれ、コマンド
ライン引数を含めることはできない。これらを提供するために、以下で説明する
別の引数ARGSを使用しなければならない。

   サブプロセス作成関数にはそれぞれ、BUFFER-OR-NAME引数があります。これ
はプログラムの標準出力の行き先を指定します。これはバッファーかバッファー
名であるべきです。バッファー名なら、もしそのバッファーがまだ作成されてい
なければ、そのバッファーを作成します。‘nil’を指定することもでき、その場
合はカスタム製のフィルター関数が出力を処理するのでなければ、出力を破棄す
るよう指示します(*note Filter Functions::、および*note Read and Print::を
参照のこと)。通常は、出力がランダムに混在してしまうため、同一バッファー
に複数プロセスの出力を送信するのは避けるべきです。同期プロセスにたいして
は、バッファーのかわりにファイルに出力を送信できます。

   これら3つのサブプロセス作成関数はすべて、‘&rest’引数であるARGSをもっ
ています。ARGSはすべて文字列でなければならず、それらは個別のコマンドライ
ン引数として、PROGRAMに与えられます。これらの文字列は指定されたプログラ
ムに直接渡されるので、文字列内ではワイルドカード文字やその他のshell構成
要素は特別な意味をもちません。

   サブプロセスはその環境をEmacsから継承しますが、
‘process-environment’でそれをオーバーラードするよう指定することができま
す。*note System Environment::を参照してください。サブプロセスは自身のカ
レントディレクトリーを、‘default-directory’の値から取得します。

 -- Variable: exec-directory
     この変数の値は、GNU Emacsとともに配布され、Emacsにより呼び出される
     ことを意図したプログラムを含むディレクトリーの名前(文字列)である。
     プログラム‘movemail’はそのようなプログラムの例であり、Rmailは
     inboxから新しいメールを読み込むためにこのプログラムを使用する。

 -- User Option: exec-path
     この変数の値は、サブプロセス内で実行するためのプログラムを検索する
     ための、ディレクトリーのリストである。要素はそれぞれ、ディレクトリ
     ーの名前(文字列)、または‘nil’のいずれかである。‘nil’はデフォルトデ
     ィレクトリー(‘default-directory’の値)を意味する。

     ‘exec-path’の値は、PROGRAM引数が絶対ファイル名でないとき、
     ‘call-process’および‘start-process’により使用される。

     一般的には、‘exec-path’を直接変更するべきではない。かわりにEmacs起
     動前に、環境変数‘PATH’が適切にセットされているか確認すること。
     ‘PATH’とは独立に‘exec-path’の変更を試みると、混乱した結果へと導かれ
     得る。


File: elisp,  Node: Shell Arguments,  Next: Synchronous Processes,  Prev: Subprocess Creation,  Up: Processes

36.2 Shell Arguments
====================

Lispプログラムがshellを実行して、ユーザーが指定したファイル名を含むコマ
ンドを与える必要がある場合が時折あります。これらのプログラムは、任意の有
効なファイル名をサポート可能であるはずです。しかしshellは特定の文字を特
別に扱い、それらの文字がファイル名に含まれていると、shellを混乱させるで
しょう。これらの文字を処理するためには、関数‘shell-quote-argument’を使用
します。

 -- Function: shell-quote-argument argument
     この関数は、実際のコンテンツがARGUMENTであるような引数を表す文字列
     を、shellの構文でリターンする。リターン値をshellコマンドに結合して
     、実行のためにそれをshellに渡すことにより、信頼性をもって機能するは
     ずである。

     この関数が正確に何を行うかは、オペレーティングシステムに依存する。
     この関数は、そのシステムの標準shellの構文で機能するようデザインされ
     ている。非標準のshellを使用する場合は、この関数を再定義する必要があ
     るだろう。

          ;; この例はGNUおよびUnixシステムでの挙動を示す
          (shell-quote-argument "foo > bar")
               ⇒ "foo\\ \\>\\ bar"

          ;; この例はMS-DOSおよびMS-Windowsでの挙動を示す
          (shell-quote-argument "foo > bar")
               ⇒ "\"foo > bar\""

     以下は‘shell-quote-argument’を使用して、shellコマンドを構築する例で
     ある:

          (concat "diff -c "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))

   以下の2つの関数は、コマンドライン引数の文字列のリストを単一の文字列に
結合したり、単一の文字列を個別のコマンドライン引数のリストへ分割するため
に有用です。これらの関数は主に、ミニバッファーでのユーザー入力である
Lisp文字列を‘call-process’や‘start-process’に渡す文字列引数のリストへ変
換したり、そのような引数のリストをミニバッファーやエコーエリアに表示する
ためのLisp文字列に変換することを意図しています。

 -- Function: split-string-and-unquote string &optional separators
     この関数は‘split-string’(*note Creating Strings::を参照)が行うよう
     に、正規表現SEPARATORSにたいするマッチで、STRINGを部分文字列に分割
     する。さらに加えて、その部分文字列からクォートを削除する。それから
     部分文字列のリストを作成して、それをリターンする。

     SEPARATORSが省略、または‘nil’の場合のデフォルトは‘"\\s-+"’で、これ
     は空白文字構文(*note Syntax Class Table::を参照)をもつ1つ以上の文字
     にマッチする正規表現である。

     この関数は、2つのタイプのクォートをサポートする。1つは文字列全体を
     ダブルクォートで囲う‘"..."’のようなクォートで、もう1つはバックスラ
     ッシュ‘\’によるエスケープで文字を個別にクォートするタイプである。後
     者はLisp文字列内でも使用されるので、この関数はそれらも同様に扱うこ
     とができる。

 -- Function: combine-and-quote-strings list-of-strings &optional
          separator
     この関数は、LIST-OF-STRINGSの各文字を必要に応じてクォートして、単一
     の文字列に結合する。これはさらに各文字ペアーの間に、SEPARATOR文字列
     も挿入する。SEPARATORが省略または‘nil’の場合のデフォルトは‘" "’。リ
     ターン値は、その結果の文字列である。

     LIST-OF-STRINGS内のクォートを要する文字列には、部分文字列として
     SEPARATORを含むものが該当する。文字列のクォートは、それをダブルクォ
     ートで‘"..."’のように囲う。もっとも単純な例では、個別のコマンドライ
     ン引数からコマンドをコンス(cons)する場合は、埋め込まれたブランクを
     含む文字列はそれぞれクォートされるだろう。


File: elisp,  Node: Synchronous Processes,  Next: Asynchronous Processes,  Prev: Shell Arguments,  Up: Processes

36.3 Creating a Synchronous Process
===================================

“同期プロセス(synchronous process)”の作成後、Emacsは継続の前にそのプロセ
スが終了するのを待機します。GNUやUnix(1)でのDiredの起動が、この例です。
プロセスは同期的なので、Emacsがそれにたいして何か行おうと試みる前に、デ
ィレクトリーのリスト全体がバッファーに到着します。

   同期サブプロセス終了をEmacsが待機する間、ユーザーは‘C-g’をタイプする
ことによりquitができます。最初のは‘C-g’は‘SIGINT’シグナルにより、サブプ
ロセスのkillを試みます。しかしこれはquitする前に、実際にそのサブプロセス
が終了されるまで待機します。その間にユーザーがさらに‘C-g’をタイプすると
、それは‘SIGKILL’で即座にサブプロセスをkillしてquitします(別プロセスの
killが機能しないMS-DOSを除く)。*note Quitting::を参照してください。

   同期サブプロセス関数は、プロセスがどのように終了したかの識別をリター
ンします。

   同期サブプロセスからの出力は、ファイルからのテキスト読み込みと同じよ
うに、一般的にはコーディングシステムを使用してデコードされます。
‘call-process-region’によりサブプロセスに送信された入力は、ファイルへの
テキスト書き込みと同じように、コーディングシステムを使用してエンコードさ
れます。*note Coding Systems::を参照してください。

 -- Function: call-process program &optional infile destination display
          &rest args
     この関数はPROGRAMを呼び出して、それが完了するまで待機する。

     サブプロセスのカレントワーキングディレクトリーは、
     ‘default-directory’である。

     新たなプロセスの標準入力は、INFILEが非‘nil’ならファイル‘nil’から、
     それ以外ならnullデバイスからとなる。引数DESTINATIONは、プロセスの出
     力をどこに送るかを指定する。以下は可能な値である:

     バッファー
          そのバッファーの、ポイントの前に出力を挿入する。これにはプロセ
          スの、標準出力ストリームと標準エラーストリームの両方が含まれる
          。

     文字列
          その名前のバッファーの、ポイントの前に出力を挿入する。

     ‘t’
          カレントバッファーの、ポイントの前に出力を挿入する。

     ‘nil’
          出力を破棄する。

     0
          出力を破棄して、サブプロセス完了を待機することなく、即座に
          ‘nil’をリターンする。

          この場合、プロセスはEmacsと並列に実行可能なので、真に同期的で
          はない。しかしこの関数リターン後は、本質的にはすみやかに
          Emacsがサブプロセスを終了するという点から、これを同期的と考え
          ることができる。

          MS-DOSは非同期サブプロセスをサポートせず、このオプションは機能
          しない。

     ‘(:file FILE-NAME)’
          指定されたファイルに出力を送信し、ファイルが既に存在すれば上書
          きする。

     ‘(REAL-DESTINATION ERROR-DESTINATION)’
          標準出力ストリームを、標準エラーストリームと分けて保つ。通常の
          出力はREAL-DESTINATIONの指定にしたがって扱い、エラー出力は
          ERROR-DESTINATIONにしたがって処分する。ERROR-DESTINATIONが
          ‘nil’ならエラー出力の破棄、‘t’なら通常の出力と混合することを意
          味し、文字列ならそれはエラー出力をリダイレクトするファイルの名
          前である。

          エラー出力先に直接バッファーを指定することはできない。ただしエ
          ラー出力を一時ファイルに送信して、そのファイルをバッファーに挿
          入すれば、これを達成できる。

     DISPLAYが非‘nil’なら、‘call-process’は出力の挿入にしたがって、バッ
     ファーを再表示する(しかし出力のデコードに選択されたコーディングシス
     テムが、実データからエンコーディングを推論することを意味する
     ‘undecided’の場合は、非ASCIIに一度遭遇すると再表示が継続不能になる
     ことがある。これを修正するのが困難な根本的理由が存在する。*note
     Output from Processes::を参照されたい)。

     それ以外なら関数‘call-process’は再表示を行わず、通常のイベントに由
     来するEmacsの再表示時だけ、スクリーン上で結果が可視になります。

     残りの引数ARGSは、そのプログラムにたいしてコマンドライン引数を指定
     する文字列です。

     (待機するよう告げた場合)‘call-process’がリターンする値は、プロセス
     が終了した理由を示します。この数字は、そのサブプロセスのexitステー
     タスで0が成功、それ以外のすべての値は失敗を意味します。シグナルによ
     りそのプロセスが終了された場合、‘call-process’はそれを記述する文字
     列をリターンします。

     以下の例では、カレントバッファーは‘foo’です。

          (call-process "pwd" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          /home/lewis/manual
          ---------- Buffer: foo ----------

          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               ⇒ 0

          ---------- Buffer: bar ----------
          lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

          ---------- Buffer: bar ----------

     以下は‘call-process’の使用法の例で、このような使用例は
     ‘insert-directory’関数の定義内で見ることができます:

          (call-process insert-directory-program nil t nil switches
                        (if full-directory-p
                            (concat (file-name-as-directory file) ".")
                          file))

 -- Function: process-file program &optional infile buffer display &rest
          args
     この関数は、別プロセス内でファイルを同期的に処理する。これは
     ‘call-process’と似ているが、サブプロセスのカレントワーキングディレ
     クトリーを指定する、変数‘default-directory’の値にもとづく、ファイル
     ハンドラーを呼び出すかもしれない。

     引数は‘call-process’の場合とほとんど同様の方法で処理されるが、以下
     の違いがある:

     引数INFILE、BUFFER、DISPLAYの組み合わせと形式.をサポートしないファ
     イルハンドラーがあるかもしれない。たとえば実際に渡された値とは無関
     係に、DISPLAYが‘nil’であるかのように振る舞うファイルハンドラーがい
     くつかある。他の例としては、BUFFER引数で標準出力とエラー出力を分離
     するのをサポートしないかもしれないファイルハンドラーがいくつか存在
     する。

     ファイルハンドラーが呼び出されると、1つ目の引数PROGRAMにもとづき、
     実行するプログラムを決定する。たとえばリモートファイルにたいするハ
     ンドラーが呼び出されたと考えてみよ。その.場合、プログラムの検索に使
     用されるパスは、‘exec-path’とは異なるかもしれない。

     2つ目の引数INFILEは、ファイルハンドラーを呼び出すかもしれない。その
     ファイルハンドラーは、‘process-file’関数自身にたいして選択されたハ
     ンドラーと異なり得る(たとえば‘default-directory’がリモートホスト上
     にあり、INFILEは別のリモートホスト上の場合があり得る。もしくは
     ‘default-directory’は普通だが、INFILEはリモートホスト上にあるかもし
     れない).

     BUFFERが‘(REAL-DESTINATION ERROR-DESTINATION)’という形式のリストで
     、ERROR-DESTINATIONがファイルの名前なら、INFILEと同じ注意が適用され
     る。

     残りの引数(ARGS)は、そのままプロセスに渡される。Emacsは、ARGS内で与
     えられたファイル名の処理に関与しない。混乱を避けるためには、ARGS内
     で絶対ファイル名を使用しないのが最善であり、‘default-directory’から
     の相対ファイル名ですべてのファイルを指定するほうがよいだろう。関数
     ‘file-relative-name’は、そのような相対ファイル名の構築に有用である
     。

 -- Variable: process-file-side-effects
     この変数は、‘process-file’呼び出しがリモートファイルを変更するかど
     うかを示す。

     この変数はデフォルトでは常に、‘process-file’呼び出しがリモートホス
     ト上の、任意のファイルを潜在的に変更し得ることを意味する‘t’にセット
     される。‘nil’にセットされた際は、リモートファイル属性のキャッシュに
     したがうことにより、ファイルハンドラーの挙動を最適化できる可能性が
     ある。

     この変数は決して‘setq’ではなく、常にletバインディングによってのみ変
     更されるべきである。

 -- Function: call-process-region start end program &optional delete
          destination display &rest args
     この関数はSTARTからENDのテキストを、実行中のプロセスPROGRAMに、標準
     入力として送信する。これはDELETEが非‘nil’なら、送信したテキストを削
     除する。これは出力をカレントバッファーの入力箇所に挿入するために、
     DESTINATIONを‘t’に指定している際に有用である。

     引数DESTINATIONとDISPLAYは、サブロセスからの出力にたいして何を行う
     か、および出力の到着にともない表示を更新するかどうかを制御する。詳
     細は上述の、‘call-process’の説明を参照されたい。DESTINATIONが整数の
     0なら、‘call-process-region’は出力を破棄して、サブプロセス完了を待
     機せずに、即座に‘nil’をリターンする(これは非同期サブプロセスがサポ
     ートされる場合、つまりMS-DOS以外でのみ機能する)。

     残りの引数ARGSは、そのプログラムにたいしてコマンドライン引数を指定
     する文字列です。

     ‘call-process-region’のリターン値は、‘call-process’の場合と同じであ
     る。待機せずにリターンするよう指示した場合は‘nil’、数字か文字列なら
     それはサブプロセスが終了した方法を表す。

     以下の例では、バッファー‘foo’内の最初の5文字(単語‘input’)を標準入力
     として、‘call-process-region’を使用して‘cat’ユーティリティを実行す
     る。‘cat’は自身の標準入力を、標準出力へコピーする。引数
     DESTINATIONが‘t’なので、その出力はカレントバッファーに挿入される。

          ---------- Buffer: foo ----------
          input★
          ---------- Buffer: foo ----------

          (call-process-region 1 6 "cat" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          inputinput★
          ---------- Buffer: foo ----------

     たとえば‘shell-command-on-region’コマンドは、以下のような方法で
     ‘call-process-region’を使用する:

          (call-process-region
           start end
           shell-file-name      ; プログラム名
           nil                  ; リージョンを削除しない
           buffer               ; 出力を‘buffer’に送信
           nil                  ; 出力中に再表示を行わない
           "-c" command)        ; shellへの引数

 -- Function: call-process-shell-command command &optional infile
          destination display
     この関数はshellコマンドCOMMANDを、非同期に実行する。引数は
     ‘call-process’の場合と同様に処理される。古い呼び出し規約は、
     DISPLAYの後に任意個数の追加引数を許容し、これはCOMMANDに結合される
     。これはまだサポートされるものの、使用しないことを強く推奨する。

 -- Function: process-file-shell-command command &optional infile
          destination display
     この関数は‘call-process-shell-command’と同様だが、内部的に
     ‘process-file’を使用する点が異なる。‘default-directory’に依存して、
     COMMANDはリモートホスト上でも実行可能である。古い呼び出し規約は、
     DISPLAYの後に任意個数の追加引数を許容し、これはCOMMANDに結合される
     。これはまだサポートされるものの、使用しないことを強く推奨する。

 -- Function: shell-command-to-string command
     この関数はshellコマンドとしてCOMMAND(文字列)を実行して、そのコマン
     ドの出力を文字列としてリターンする。

 -- Function: process-lines program &rest args
     この関数はPROGRAMを実行して完了を待機し、出力を文字列のリストとして
     リターンする。リスト内の各文字列は、プログラムのテキスト出力の1つの
     行を保持する。各行のEOL文字(行末文字)は取り除かれる。PROGRAMの後の
     引数ARGSは、そのプログラム実行に際し、コマンドライン引数を指定する
     文字列である。

     PROGRAMが非0のexitステータスでexitした場合、この関数はエラーをシグ
     ナルする。

     この関数は‘call-process’を呼び出すことにより機能し、プログラムの出
     力は‘call-process’の場合と同じ方法でデコードされる。

   ---------- Footnotes ----------

   (1) 他のシステムでは、Emacsは‘ls’のLispエミュレーションを使用します。
*note Contents of Directories::を参照してください。


File: elisp,  Node: Asynchronous Processes,  Next: Deleting Processes,  Prev: Synchronous Processes,  Up: Processes

36.4 Creating an Asynchronous Process
=====================================

このセクションでは、“非同期プロセス(asynchronous process)”を作成する方法
について説明します。非同期プロセスは作成後、Emacsと並列して実行され、
Emacsは以降のセクション(*note Input to Processes::および*note Output
from Processes::を参照)で説明する関数を使用してプロセスとコミュニケーシ
ョンができます。プロセスコミュニケーションは、部分的に非同期なだけである
ことに注意してください。Emacsは特定の関数を呼び出したときだけプロセスに
データを送信でき、Emacsは入力の待機中または一定の遅延時間の後にのみ、プ
ロセスのデータを受け取ることができます。

   非同期プロセスは“pty(pseudo-terminal: 疑似端末)”、または“pipe”の、い
ずれかを通じて制御されます。ptyかpipeの選択は、変数
‘process-connection-type’(以下参照)の値にもとづき、プロセス作成時に行わ
れます。ptyは通常、Shellモード内のようにユーザーから可視なプロセスに適し
ています。それはpipeでは不可能な、そのプロセスおよびその子プロセスとの間
でジョブ制御(‘C-c’、‘C-z’、...等)が可能だからです。プログラムの内部的な
目的のために使用されるサブプロセスにたいしては、pipeのほうが適している場
合が多々あります。それはpipeがより効率的であり、ptyが大量の文字
(500byte前後)にたいして導入する迷入文字インジェクション(stray character
injections)にたいして免疫があるのが理由です。さらに多くのしすてむでは
ptyの合計数に制限があり、それを浪費するのは得策ではありません。

 -- Function: start-process name buffer-or-name program &rest args
     この関数は新たな非同期サブプロセスを作成して、その中でプログラム
     PROGRAMの実行を開始する。これはLisp内で新たなサブプロセスを意味する
     、プロセスオブジェクトをリターンする。引数NAMEは、そのプロセスオブ
     ジェクトにたいして、名前を指定する。その名前のプロセスがすでに存在
     する場合、(‘<1>’を追加することにより)一意になるよう、NAMEを変更する
     。バッファーBUFFER-OR-NAMEは、そのプロセスに関連付けられたバッファ
     ーである。

     PROGRAMが‘nil’なら、Emacsは疑似端末(pty)を新たにオープンして、サブ
     プロセスを新たに作成することなく、ptyの入力と出力をBUFFER-OR-NAMEに
     関連付ける。この場合、残りの引数ARGSは無視される。

     残りの引数ARGSは、サブプロセスにコマンドライン引数を指定する文字列
     である。

     以下の例では、1つ目のプロセスが開始して、100秒間実行(というよりは
     sleep)される。その間に2つ目のプロセスが開始して、一意性を保つために
     ‘my-process<1>’という名前が与えられる。これは1つ目のプロセスが終了
     する前に、バッファー‘foo’の最後にディレクトリーのリストを挿入する。
     その後、2つ目のプロセスは終了して、その旨のメッセージがバッファーに
     挿入される。さらに遅れて1つ目のプロセスが終了して、バッファーに別の
     メッセージが挿入される。

          (start-process "my-process" "foo" "sleep" "100")
               ⇒ #<process my-process>

          (start-process "my-process" "foo" "ls" "-l" "/bin")
               ⇒ #<process my-process<1>>

          ---------- Buffer: foo ----------
          total 8336
          -rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
          -rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
          ...
          -rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

          Process my-process<1> finished

          Process my-process finished
          ---------- Buffer: foo ----------

 -- Function: start-file-process name buffer-or-name program &rest args
     ‘start-process’と同様、この関数は非同期サブプロセスを開始して、その
     内部でPROGRAMを実行して、そのプロセスオブジェクトをリターンする。

     ‘start-process’との違いは、この関数が‘default-directory’の値にもと
     づいて、ファイルハンドラーを呼び出すかもしれないという点である。こ
     のハンドラーはローカルホスト上、あるいは‘default-directory’に応じた
     リモートホスト上で、PROGRAMを実行するべきである。後者の場合、
     ‘default-directory’のローカル部分は、そのプロセスのワーキングディレ
     クトリーになる。

     この関数はPROGRAM、またはPROGRAM-ARGSにたいしてファイル名ハンドラー
     の呼び出しを試みない。

     そのファイルハンドラーの実装によっては、リターン結果のプロセスオブ
     ジェクトに‘process-filter’または‘process-sentinel’を適用することが
     できないかもしれない。*note Filter Functions::および*note
     Sentinels::を参照されたい。

     いくつかのファイルハンドラーは‘start-file-process’をサポートしない
     かもしれない(たとえば‘ange-ftp-hook-function’関数)。そのような場合
     、この関数は何も行わずに‘nil’をリターンする。

 -- Function: start-process-shell-command name buffer-or-name command
     この関数は‘start-process’と同様だが、指定されたコマンドの実行に
     shellを使用する点が異なる。引数COMMANDは、shellコマンド名である。変
     数‘shell-file-name’は、どのshellを使用するかを指定する。

     ‘start-process’でプログラムを実行せずにshellを通じて実行することの
     要点は、引数内のワイルドカード展開のようなshell機能を利用可能にする
     ためである。そのためにはコマンド内に任意のユーザー指定引数を含める
     なら、任意の特別なshell文字が、shellでの特別な意味を_もたない_よう
     に、まず‘shell-quote-argument’でそれらをクォートするべきである。
     *note Shell Arguments::を参照のこと。ユーザー入力にもとづいたコマン
     ド実行時には、当然セキュリティ上の影響も考慮するべきである。

 -- Function: start-file-process-shell-command name buffer-or-name
          command
     この関数は‘start-process-shell-command’と似ているが、内部的に
     ‘start-file-process’を使用する点が異なる。これにより、
     ‘default-directory’に応じてリモートホスト上でも、COMMANDを実行でき
     る。

 -- Variable: process-connection-type
     この変数は、非同期サブプロセスと対話するために使用する、デバイスタ
     イプを制御する。これが非‘nil’の場合、利用可能ならpty、それ以外なら
     pipeが使用される。

     ‘process-connection-type’の値は、‘start-process’の呼び出し時に効果
     を発揮する。そのため、‘start-process’の呼び出し前後でこの変数をバイ
     ンドすることにより、サブプロセスとやり取りする方法を指定できる。

          (let ((process-connection-type nil))  ; pipeを使用
            (start-process ...))

     与えられたサブプロセスが実際にはpipeとptyのどちらを取得したかを判断
     するには、関数‘process-tty-name’を使用する(*note Process
     Information::を参照)。


File: elisp,  Node: Deleting Processes,  Next: Process Information,  Prev: Asynchronous Processes,  Up: Processes

36.5 Deleting Processes
=======================

“プロセス削除(deleting a process)”とは、Emacsをサブプロセスから即座に切
断することです。プロセスは終了後に自動的に削除されますが、即座に削除され
る必要はありません。任意のタイミングで、明示的にプロセスを削除できます。
終了したプロセスが自動的に削除される前に明示的に削除しても、それに害はあ
りません。実行中のプロセスの削除は、プロセス(もしあれば子プロセスにも)を
終了するためにシグナルを送信して、プロセスセンチネルを呼び出します。
*note Sentinels::を参照してください。

   プロセスが削除される際、そのプロセスオブジェクト自体は、それを参照す
る別のLispオブジェクトが存在する限り、継続し続けます。プロセスオブジェク
トに作用するすべてのLispプリミティブはプロセスの削除を受け入れますが、
I/Oを行ったりシグナルを送信するプリミティブは、エラーを報告するでしょう
。プロセスマークは、通常はプロセスからの出力がバッファーに挿入される箇所
である、以前と同じ箇所をポイントし続けます。

 -- User Option: delete-exited-processes
     この変数は、(‘exit’呼び出しやシグナルにより)終了したプロセスの、自
     動的な削除を制御する。これが‘nil’なら、ユーザーが‘list-processes’を
     実行するまでプロセスは存在し続け、それ以外ならexit後に即座に削除さ
     れる。

 -- Function: delete-process process
     この関数は、‘SIGKILL’シグナルでkillすることにより、プロセスを削除す
     る。引数はプロセス、プロセスの名前、バッファー、バッファーの名前か
     もしれない(バッファーやバッファー名の場合は、‘get-buffer-process’が
     リターンするプロセスを意味する)。実行中のプロセスに
     ‘delete-process’を呼び出すことにより、プロセスを終了してプロセス状
     態を更新して、即座にセンチネルを実行する。そのプロセスがすでに終了
     している場合、‘delete-process’呼び出しはプロセス状態、または(遅かれ
     早かれ発生するであろう)プロセスセンチネルの実行に影響を与えない。

          (delete-process "*shell*")
               ⇒ nil


File: elisp,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

36.6 Process Information
========================

プロセスの状態に関する情報をリターンする関数がいくつかあり。

 -- Command: list-processes &optional query-only buffer
     このコマンドは、すべての生きたプロセスのリストを表示する。加えてこ
     れは最後に、状態が‘Exited’か‘Signaled’だったすべてのプロセスを削除
     する。このコマンドは‘nil’をリターンする。

     プロセスは、メジャーモードがProcess Menuモードであるような、
     ‘*Process List*’という名前(オプション引数BUFFERで他の名前を指定して
     いない場合)のバッファーに表示される。

     QUERY-ONLYが非‘nil’なら、queryフラグが非‘nil’のプロセスだけをリスト
     する。*note Query Before Exit::を参照のこと。

 -- Function: process-list
     この関数は、削除されていないすべてのプロセスのリストをリターンする
     。

          (process-list)
               ⇒ (#<process display-time> #<process shell>)

 -- Function: get-process name
     この関数はNAME(文字列)というプロセス、存在しなければ‘nil’をリターン
     する。

          (get-process "shell")
               ⇒ #<process shell>

 -- Function: process-command process
     この関数は、PROCESSを開始するために実行されたコマンドをリターンする
     。これは文字列のリストで、1つ目の文字列は実行されたプログラム、残り
     の文字列はそのプログラムに与えられた引数である。

          (process-command (get-process "shell"))
               ⇒ ("bash" "-i")

 -- Function: process-contact process &optional key

     この関数は、ネットワークプロセスまたはシリアルプロセスがセットアッ
     プされた方法についての情報をリターンする。 This function returns
     information about how a network or serial process was set up.  KEYが
     ‘nil’なら、ネットワークプロセスにたいしては‘(HOSTNAME SERVICE)’、シ
     リアルプロセスにたいしては‘(PORT SPEED)’をリターンする。普通の子プ
     ロセスにたいしては、この関数は常に‘t’をリターンする。

     KEYが‘t’なら、値はその接続、サーバー、またはシリアルポートについて
     の完全な状態情報、すなわち‘make-network-process’または
     ‘make-serial-process’内で指定されるキーワードと値のリストとなる。た
     だしいくつかの値については、指定した値のかわりに、カレント状態を表
     す値となる。

     ネットワークプロセスにたいしては、その値が含まれる(完全なリストにつ
     いては、‘make-network-process’を参照されたい)。

     ‘:buffer’
          値にはプロセスのバッファーが割り当てられる。
     ‘:filter’
          値にはプロセスのフィルター関数が割り当てられる。
     ‘:sentinel’
          値にはプロセスのセンチネル関数が割り当てられる。
     ‘:remote’
          接続にたいしては、内部的なフォーマットによる、リモートピアーの
          アドレス。
     ‘:local’
          内部的なフォーマットによる、ローカルアドレス。
     ‘:service’
          サーバーにおいては、SERVICEに‘t’を指定した場合、この値は実際の
          ポート番号。

     ‘make-network-process’内で明示的に指定されていなくても、‘:local’と
     ‘:remote’は値に含まれる。

     シリアルプロセスについては‘make-serial-process’、キーのリストについ
     ては‘serial-process-configure’を参照されたい。

     KEYがキーワードなら、この関数はそのキーワードに対応する値をリターン
     する。

 -- Function: process-id process
     この関数は、PROCESSのPIDをリターンする。これは同じコンピューター上
     でカレント時に実行中の他のすべてのプロセスから、プロセスPROCESSを区
     別するための整数である。プロセスのPIDは、そのプロセスの開始時にオペ
     レーティングシステムのカーネルにより選択され、そのプロセスが存在す
     る限り定数として保たれる。

 -- Function: process-name process
     この関数はPROCESSの名前を、文字列としてリターンする。

 -- Function: process-status process-name
     この関数はPROCESS-NAMEの状態を、文字列としてリターンする。引数
     PROCESS-NAMEはプロセス、バッファー、またはプロセス名(文字列)かもし
     れない。

     実際のサブプセスにたいして可能な値は:

     ‘run’
          実行中のプロセス。
     ‘stop’
          停止しているが継続可能なプロセス。
     ‘exit’
          exitしたプロセス。
     ‘signal’
          致命的なシグナルを受信したプロセス。
     ‘open’
          オープンされたネットワーク接続。
     ‘closed’
          クローズされたネットワーク接続。一度クローズされた接続は、たと
          え同じ場所にたいして新たな接続をオープンすることができたとして
          も、再度オープンすることはできない。
     ‘connect’
          完了を待つ非ブロッキング接続。
     ‘failed’
          完了に失敗した非ブロッキング接続。
     ‘listen’
          listen中のネットワークサーバー。
     ‘nil’
          PROCESS-NAMEが既存のプロセス名でない場合。

          (process-status (get-buffer "*shell*"))
               ⇒ run

     ネットワーク接続にたいしては、‘process-status’は‘open’か‘closed’の
     シンボルいずれかをリターンする。後者は相手側が接続をクローズしたか
     、Emacsが‘delete-process’を行なったことを意味する。

 -- Function: process-live-p process
     この関数は、PROCESSがアクティブなら、非‘nil’をリターンする。状態が
     ‘run’、‘open’、‘listen’、‘connect’、‘stop’のプロセスはアクティブと
     みなされる。

 -- Function: process-type process
     この関数はネットワーク接続またはサーバーにたいしてはシンボル
     ‘network’、シリアルポート接続にたいしては‘serial’、実際のサブプロセ
     スにたいしては‘real’をリターンする。

 -- Function: process-exit-status process
     この関数はPROCESSのexitステータス、またはプロセスをkillしたシグナル
     番号をリターンする(いずれかであるかの判定には、‘process-status’の結
     果を使用する)。PROCESSがまだ終了していなければ、値は0。

 -- Function: process-tty-name process
     この関数はPROCESSがEmacsとの対話に使用する端末名、端末のかわりに
     pipeを使用する場合は‘nil’をリターンする(*note Asynchronous
     Processes::の‘process-connection-type’を参照)。PROCESSがリモートホ
     スト上で実行中のプログラムを表す場合は、プロセスの‘remote-tty’プロ
     パティとして、リモートホスト上でそのプログラムに使用される端末名が
     提供される。

 -- Function: process-coding-system process
     この関数は、PROCESSからの出力のデコードに使用するコーディングシステ
     ム、PROCESSへの入力のエンコードに使用するコーディングシステムを記述
     するコンスセル‘(DECODE . ENCODE)’をリターンする(*note Coding
     Systems::を参照)。

 -- Function: set-process-coding-system process &optional
          decoding-system encoding-system
     この関数は、PROCESSにたいする後続の入出力に使用するコーディングシス
     テムを指定する。これはサブプロセスの出力のデコードに
     DECODING-SYSTEM、入力のエンコードにENCODING-SYSTEMを使用するだろう
     。

   すべてのプロセスには、そのプロセスに関連するさまざまな値を格納するた
めに使用できる、プロパティリストもあります。

 -- Function: process-get process propname
     この関数は、PROCESSのプロパティPROPNAMEの値をリターンする。

 -- Function: process-put process propname value
     この関数は、PROCESSのプロパティPROPNAMEの値にVALUEをセットする。

 -- Function: process-plist process
     この関数は、PROCESSのプロセスplistをリターンする。

 -- Function: set-process-plist process plist
     この関数は、PROCESSのプロセスplistにPLISTをセットする。


File: elisp,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

36.7 Sending Input to Processes
===============================

非同期サブプロセスは、Emacsにより入力が送信されたときに入力を受信し、そ
れはこのセクション内の関数で行われます。これを行うには入力を送信するプロ
セスと、送信するための入力データを指定しなければなりません。そのデータは
、サブプロセスの“標準入力”として表れます。

   オペレーティングシステムには、ptyのバッファーされた入力にたいして制限
をもつものがいくつかあります。それらのシステムでは、Emacsは他の文字列の
間に定期的かつ強制的に、EOFを送信します。ほとんどのプログラムにたいして
、これらのEOFは無害です。

   サブプロセスの入力は通常、テキストをファイルに書き込むときと同じよう
に、サブプロセスが受信する前に、コーディングシステムを使用してエンコード
されます。どのコーディングシステムを使用するかを指定するには、
‘set-process-coding-system’を使用できます(*note Process Information::を
参照)。それ以外の場合、非‘nil’なら‘coding-system-for-write’がコーディン
グシステムとなり、さもなくばデフォルトのメカニズムがコーディングシステム
を決定します(*note Default Coding Systems::を参照)。

   入力バッファーが一杯のため、システムがプロセスからの入力を受け取るこ
とができないことがあります。これが発生したときは、送信関数はしばらく待機
して、サブプロセスの出力を受け取り、再度送信を試みます。これは保留となっ
ている更なる入力を読み取り、バッファーに空きを作る機会をサブプロセスに与
えます。これはフィルター、センチネル、タイマーの実行も可能にするので、コ
ードを記述する際はそれを考慮してください。

   以下の関数では、PROCESS引数はプロセス、プロセス名、またはバッファー、
バッファー名(これは‘get-buffer-process’で取得されるプロセスを意味する)。
‘nil’は、カレントバッファーのプロセスを意味します。

 -- Function: process-send-string process string
     この関数はSTRINGのコンテンツを、標準入力としてPROCESSに送信する。た
     とえばファイルをリストするShellバッファーを作成するには:

          (process-send-string "shell<1>" "ls\n")
               ⇒ nil

 -- Function: process-send-region process start end
     この関数はSTARTとENDで定義されるリージョンのテキストを、標準入力と
     してPROCESSに送信する。

     STARTとENDが、カレントバッファー内の位置を示す整数かマーカーでなけ
     れば、エラーがシグナルされる(いずれかの大小は重要ではない)。

 -- Function: process-send-eof &optional process
     この関数は、PROCESSが入力内のEOF(end-of-file)を見ることを可能にする
     。EOFは、すべての送信済みテキストの後になる。この関数はPROCESSをリ
     ターンする。

          (process-send-eof "shell")
               ⇒ "shell"

 -- Function: process-running-child-p &optional process
     この関数は、PROCESSが自身の子プロセスに端末の制御を与えたかどうかを
     告げるだろう。値‘t’はそれが真であるか、あるいはEmacsがそれを告げる
     ことができないことを意味し、‘nil’はなら偽であることをEmacsは保証し
     ます。


File: elisp,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

36.8 Sending Signals to Processes
=================================

サブプロセスへの“シグナル送信(sending a signal)”は、プロセスの活動に割り
込む手段の1つです。異なる複数のシグナルがあり、それぞれが独自の意味をも
っています。シグナルのセットとそれらの意味は、オペレーティングシステムに
より定義されます。たとえばシグナル‘SIGINT’は、ユーザーが‘C-c’をタイプし
たか、それに類似する何かが発生したことを意味します。

   各シグナルは、サブプロセスに標準的な効果をもちます。ほとんどのシグナ
ルはサブプロセスをkillしますが、かわりに実行を停止(あるいは再開)するもの
もいくつかあります。ほとんどのシグナルは、オプションでプログラムによりハ
ンドル((処理)することができます。プログラムがそのシグナルをハンドルする
場合、その影響についてわたしたちは一般的には何も言うことはできません。

   このセクション内の関数を呼び出すことにより、明示的にシグナルを送信で
きます。Emacsも、特定のタイミングで自動的にシグナルを送信します。バッフ
ァーのkillにより、それに関連するプロセスには‘SIGHUP’シグナルが送信され、
Emacsのkillにより、残されたすべてのプロセスに‘SIGHUP’シグナルが送信され
ます(‘SIGHUP’は通常、ユーザーが“hung up the phone”、電話を切った、つまり
接続を断ったことを示す)。

   シグナル送信関数はそれぞれPROCESSとCURRENT-GROUPいう、2つのオプション
引数を受け取ります。

   引数PROCESSはプロセス、プロセス名、バッファー、バッファー名、または
‘nil’のいずれかでなければなりません。バッファーまたはバッファー名は、
‘get-buffer-process’を通じて得られるプロセスを意味します。‘nil’は、カレ
ントバッファーに関連付けられたプロセスを意味します。PROCESSがプロセスを
識別しなければ、エラーがシグナルされます。

   引数CURRENT-GROUPは、Emacsのサブプロセスとしてジョブ制御
shell(job-control shell)を実行中の場合に、異なる処理を行うためのフラグで
す。これが非‘nil’なら、そのシグナルはEmacsがサブプロセスとの対話に使用す
る端末のカレントプロセスグループに送信されます。そのプロセスがジョブ制御
shellなら、これはそのshellのカレントのsubジョブになります。‘nil’なら、そ
のシグナルはEmacs自身のサブプロセスのプロセスグループに送信されます。そ
のプロセスがジョブ制御shellなら、それはshell自身になります。

   サブプロセスとの対話にpipeが使用されている際は、オペレーティングシス
テムがpipeでの区別をサポートしないので、フラグCURRENT-GROUPに効果はあり
ません。同じ理由により、pipeが使用されている場合は、ジョブ制御shellは機
能しないでしょう。*note Asynchronous Processes::内の
‘process-connection-type’を参照してください。

 -- Function: interrupt-process &optional process current-group
     この関数は、シグナル‘SIGINT’を送信することにより、プロセスPROCESSに
     割り込む。Emacs外部では、“interrupt character”(割り込み文字。通常い
     くつかのシステムでは‘C-c’、それ以外のシステムでは<DEL>)をタイプする
     ことにより、このシグナルが送信される。引数CURRENT-GROUPが非‘nil’の
     ときは、Emacsがサブプロセスと対話する端末上で“‘C-c’がタイプされた
     ”と考えることができる。

 -- Function: kill-process &optional process current-group
     この関数は、シグナル‘SIGKILL’を送信することにより、プロセス
     PROCESSをkillする。このシグナルは即座にサブプロセスをkillして、サブ
     プロセスでハンドルすることはできない。

 -- Function: quit-process &optional process current-group
     この関数は、プロセスPROCESSにシグナル‘SIGQUIT’を送信する。これは
     Emacs外部では“quit character”(通常は‘C-b’か‘C-\’)により送信されるシ
     グナルである。

 -- Function: stop-process &optional process current-group
     この関数は、シグナル‘SIGTSTP’を送信することにより、プロセス
     PROCESSを停止する。実行の再開には、‘continue-process’を使用する。

     ジョブ制御をもつシステム上のEmacs外部では、“stop character”(通常は
     ‘C-z’)がこのシグナルを送信する。CURRENT-GROUPが非‘nil’なら、この関
     数をサブプロセスとの対話にEmacsが使用する端末上で“‘C-z’がタイプされ
     た”と考えることができる。

 -- Function: continue-process &optional process current-group
     この関数は、シグナル‘SIGCONT’を送信することにより、プロセス
     PROCESSの実行を再開する。これはPROCESSが以前に停止されたものと推定
     する。

 -- Command: signal-process process signal
     この関数は、プロセスPROCESSにシグナルを送信する。引数SIGNALは、どの
     シグナルを送信するかを指定する。これは整数、または名前がシグナルで
     あるようなシンボルであること。

     PROCESS引数にはシステムプロセスID(整数)を指定できる。これにより
     Emacsの子プロセス以外のプロセスにシグナルを送信できる。*note System
     Processes::を参照のこと。


File: elisp,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

36.9 Receiving Output from Processes
====================================

サブプロセスが自身の標準出力に書き込んだ出力は、“フィルター関数(filter
function)”と呼ばれる関数に渡されます。デフォルトのフィルター関数は単に出
力をバッファーに挿入します。このバッファーを、そのプロセスに関連付けられ
たバッファーと呼びます(*note Process Buffers::を参照)。プロセスがバッフ
ァーをもたなければ、デフォルトフィルターは出力を破棄します。

   サブプロセス終了時、Emacsは保留中の出力を読み取り、その後そのサブプロ
セスからの出力の読み取りを停止します。したがって、そのサブプロセスに生き
た子プロセスがあり、まだ出力を生成するような場合、Emacsはその出力を受け
取らないでしょう。

   サブプロセスからの出力は、Emacsが待機している間、端末入力読み取り時
(関数‘waiting-for-user-input-p’、*note Waiting::の‘sit-for’と
‘sleep-for’、および*note Accepting Output::の‘accept-process-output’を参
照されたい)のみ到着可能です。これは、並列プログラミングで普遍的に悩みの
種である、タイミングエラーの問題を最小化します。たとえば、安全にプロセス
を作成して、その後でのみプロセスのバッファーやフィルター関数を指定できま
す。その間にあるコードが待機するプリミティブを何も呼び出さなければ、完了
するまで到着可能な出力はありません。

 -- Variable: process-adaptive-read-buffering
     いくつかのシステムでは、Emacsがサブプロセスの出力を読み取る際、出力
     データを非常に小さいブロックで読み取るため、結果として潜在的に非常
     に貧弱なパフォーマンスとなることがる。この挙動は、変数
     ‘process-adaptive-read-buffering’を非‘nil’値(デフォルト)にセットし
     て拡張することにより改善し得る。これにより、そのようなプロセスから
     の読み取りを自動的に遅延して、Emacsが読み取りを試みる前に、出力がよ
     り生成されるようになる。

   Emacsは通常、疑似端末(pseudo-TTY)内部でサブプロセスをspawnし、かつ疑
似端末は出力チャンネルを1つしかもてないので、サブプロセスの標準出力スト
リームと標準エラーストリームを区別するのは不可能です。それらのストリーム
の出力を区別して保ちたい場合は、たとえば適当なshellコマンドを使用して、
いずれか1つをファイルにリダイレクトするべきです。

* Menu:

* Process Buffers::          デフォルトでは、出力はバッファーに送信される。
* Filter Functions::         フィルター関数はプロセスからの出力を受け取る。
* Decoding Output::          フィルターはユニバイトおよびマルチバイトの文字列を取得できる。
* Accepting Output::         プロセスの出力到着まで待機する方法。


File: elisp,  Node: Process Buffers,  Next: Filter Functions,  Up: Output from Processes

36.9.1 Process Buffers
----------------------

プロセスは“関連付けられたバッファー(associated buffer)”をもつことができ
ます(通常はもつ)。これは普通のEmacsバッファーであり、2つの目的のために使
用されます。1つはプロセスからの出力の格納、もう1つはプロセスをkillする時
期を判断するためです。通常の習慣では、任意の与えられたバッファーにたいし
て関連付けられるプロセスは1つだけなので、処理対象のプロセスを識別するた
めにそのバッファーを使用することもできます。プロセス使用の多くはプロセス
に送信する入力を編集するためにもこのバッファーを使用しますが、これは
Emacs Lispに組み込まれてはいません。

   デフォルトでは、プロセスの出力は関連付けられたバッファーに挿入されま
す(カスタムフィルター関数の定義により変更可能。*note Filter Functions::を
参照されたい)。出力を挿入する位置は、‘process-mark’により決定されます。
これは正に挿入されたテキストの終端に、ポイントを更新します。通常、ただし
常にではありませんが、‘process-mark’はバッファーの終端になります。

   プロセスに関連付けられたバッファーをkillすることにより、そのプロセス
もkillされます。そのプロセスの‘process-query-on-exit-flag’が非‘nil’なら
、Emacsはまず確認を求めます(*note Query Before Exit::を参照)。この確認は
関数‘process-kill-buffer-query-function’により行われ、これは
‘kill-buffer-query-functions’から実行されます(*note Killing Buffers::を
参照)。

 -- Function: process-buffer process
     この関数は、プロセスPROCESSの関連付けられたバッファーをリターンする
     。

          (process-buffer (get-process "shell"))
               ⇒ #<buffer *shell*>

 -- Function: process-mark process
     この関数は、PROCESSにたいするプロセスマーカーをリターンする。これは
     プロセスからの出力をどこに挿入するかを示すマーカーである。

     PROCESSバッファーをもたなければ、‘process-mark’は存在しない場所を指
     すマーカーをリターンする。

     デフォルトフィルター関数は、プロセス出力の挿入場所の決定にこのマー
     カーを使用し、挿入したテキストの後にポイントを更新する。連続するバ
     ッチ出力が、連続して挿入されるのは、これが理由である。

     カスタムフィルター関数は、このマーカーを通常は同じ方式で使用するべ
     きである。‘process-mark’を使用するフィルター関数の例は、*note
     Process Filter Example::を参照のこと。

     ユーザーにプロセスバッファー内でプロセスに送信するための入力を期待
     する際は、プロセスマーカーは以前の出力から新たな入力を区別する。

 -- Function: set-process-buffer process buffer
     この関数は、PROCESSに関連付けられたバッファーに、BUFFERをセットする
     。BUFFERが‘nil’なら、プロセスはバッファーに関連付けられない。

 -- Function: get-buffer-process buffer-or-name
     この関数は、BUFFER-OR-NAMEで指定されるバッファーに関連付けられた、
     削除されていないプロセスをリターンする。そのバッファーに複数のプロ
     セスが関連付けられている場合、この関数はいずれか1つ(現在のところも
     っとも最近作成されたプロセスだが、これを当てにしないこと)を選択する
     。プロセスの削除(‘delete-process’を参照)により、そのプロセスはこの
     関数がリターンするプロセスとしては不適格となる。

     同一のバッファーに複数のプロセスを関連付けるのは、通常は悪いアイデ
     アである。

          (get-buffer-process "*shell*")
               ⇒ #<process shell>

     プロセスのバッファーをkillすることにより、‘SIGHUP’シグナルでサブプ
     ロセスをkillして、プロセスを削除する(*note Signals to Processes::を
     参照)。


File: elisp,  Node: Filter Functions,  Next: Decoding Output,  Prev: Process Buffers,  Up: Output from Processes

36.9.2 Process Filter Functions
-------------------------------

プロセスの“フィルター関数(filter function)”は、関連付けられたプロセスか
らの標準出力を受信します。そのプロセスの_すべて_の出力は、そのフィルター
に渡されます。デフォルトのフィルターは単に、プロセスバッファーに直接出力
します。

   サブプロセスからの出力は、Emacsが何かを待機している間だけ到着するので
、フィルター関数はそのようなときだけ呼び出し可能です。Emacsは端末入力読
み取り時(関数‘waiting-for-user-input-p’、*note Waiting::の‘sit-for’と
‘sleep-for’、および*note Accepting Output::の‘accept-process-output’を参
照されたい)に待機します。

   フィルター関数は関連付けられたプロセス、およびそのプロセスから正に受
信した出力である文字列という、2つの引数を受け取らなければなりません。関
数はその後、出力にたいして何であれ、自由に行うことができます。

   quitは通常はフィルター関数内では抑制されます。さもないと、コマンドレ
ベルでの‘C-g’のタイプ、またはユーザーコマンドのquitは予測できません。フ
ィルター関数内部でのquitを許可したければ、‘inhibit-quit’を‘nil’にバイン
ドしてください。ほとんどの場合において、これを行う正しい方法はマクロ
‘with-local-quit’です。*note Quitting::を参照してください。

   フィルター関数の実行中にエラーが発生した場合、フィルター開始時に実行
中だったプログラムが何であれ実行を停止しないように、自動的にcatchされま
す。しかし‘debug-on-error’が非‘nil’なら、エラーはcatchされません。これに
より、Lispデバッガーを使用したフィルター関数のデバッグが可能になります。
*note Debugger::を参照してください。

   多くのフィルター関数は時折(または常に)、デフォルトフィルターの動作を
真似て、プロセスのバッファーにその出力を挿入します。そのようなフィルター
関数は確実にカレントバッファーの保存と、(もし異なるなら)出力を挿入する前
に正しいバッファーを選択して、その後に元のバッファーをリストアする必要が
あります。また、そのバッファーがまだ生きているか、プロセスマーカーを更新
しているか、そしていくつかのケースにおいてはポイントの値を更新しているか
もチェックするべきです。以下はこれらを行う方法です:

     (defun ordinary-insertion-filter (proc string)
       (when (buffer-live-p (process-buffer proc))
         (with-current-buffer (process-buffer proc)
           (let ((moving (= (point) (process-mark proc))))
             (save-excursion
               ;; テキストを挿入してプロセスマーカーを進める
               (goto-char (process-mark proc))
               (insert string)
               (set-marker (process-mark proc) (point)))
             (if moving (goto-char (process-mark proc)))))))

   新たなテキスト到着時にフィルターが強制的にプロセスバッファーを可視に
するために、‘with-current-buffer’構成の直前に以下のような行を挿入できま
す:

     (display-buffer (process-buffer proc))

   以前の位置に関わらず、新たな出力の終端にポイントを強制するには、変数
‘moving’を削除して、無条件で‘goto-char’を呼び出してください。

   フィルター関数実行中、Emacsは自動的にマッチデータの保存とリストアを行
うことに注意してください。*note Match Data::を参照してください。

   フィルターへの出力は、任意のサイズのchunkで到着する可能性があります。
同じ出力を連続して2回生成するプログラムは、一度に200文字を1回のバッチで
送信して、次に40文字を5回のバッチで送信するかもしれません。フィルターが
特定のテキスト文字列をサブプロセスの出力から探す場合は、それらの文字列が
2回以上のバッチ出力を横断するケースに留意して処理してください。これを行
うには、受信したテキストを一時的なバッファーに挿入してから、それを検索す
るのが1つの方法です。

 -- Function: set-process-filter process filter
     この関数は、PROCESSにフィルター関数FILTERを与える。FILTERが‘nil’な
     らそのプロセスにたいして、プロセスバッファーにプロセス出力を挿入す
     る、デフォルトフィルターを与える。

 -- Function: process-filter process
     この関数は、PROCESSのフィルター関数をリターンする。

   そのプロセスの出力を複数のフィルターに渡す必要がある場合は、既存のフ
ィルターに新たなフィルターを組み合わせるために、‘add-function’を使用でき
る。*note Advising Functions::を参照のこと。

   以下は、フィルター関数の使用例である:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          ⇒ keep-output
     (setq kept nil)
          ⇒ nil
     (set-process-filter (get-process "shell") 'keep-output)
          ⇒ keep-output
     (process-send-string "shell" "ls ~/other\n")
          ⇒ nil
     kept
          ⇒ ("lewis@slug:$ "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")


File: elisp,  Node: Decoding Output,  Next: Accepting Output,  Prev: Filter Functions,  Up: Output from Processes

36.9.3 Decoding Process Output
------------------------------

Emacsが直接マルチバイトバッファーにプロセス出力を書き込む際は、プロセス
出力のコーディングシステムに応じて、出力をデコードします。コーディングシ
ステムが‘raw-text’か‘no-conversion’なら、Emacsは‘string-to-multibyte’を
使用してユニバイト出力をマルチバイトに変換して、その結果のマルチバイトテ
キストを挿入します。

   どのコーディングシステムを使用するかは、‘set-process-coding-system’を
使用して指定できます(*note Process Information::を参照)。それ以外では、
‘coding-system-for-read’が非‘nil’ならそのコーディングシステム、‘nil’なら
デフォルトのメカニズムが使用されます(*note Default Coding Systems::を参
照)。プロセスのテキスト出力にnullバイトが含まれる場合、Emacsはそれにたい
してデフォルトでは‘no-conversion’を使用します。この挙動を制御する方法に
ついては、*note inhibit-null-byte-detection: Lisp and Coding Systems.を
参照してください。

   *警告:* データからコーディングシステムを‘undecided’のようなコーディン
グシステムは、非同期サブプロセスの出力にたいして完全な信頼性をもって機能
しません。これはEmacsが、到着に応じて非同期サブプロセスの出力をバッチで
処理する必要があるからです。Emacsは1つのバッチが到着するたびに正しいコー
ディングシステムを検出しなければならず、これは常には機能しません。したが
って、可能であれば文字コード変換とEOL変換の両方を決定するコーディングシ
ステム、つまり‘latin-1-unix’、‘undecided’、‘latin-1’のようなコーディング
システムを指定してください。

   Emacsがプロセスフィルター関数を呼び出す際は、そのプロセスのフィルター
のコーディングシステムに応じて、Emacsはプロセス出力をマルチバイト文字列
、またはユニバイト文字列で提供します。Emacsはプロセス出力のコーディング
システムに応じて出力をデコードします。これは‘binary’や‘raw-text’のような
コーディングシステムを除き、通常はマルチバイト文字列を生成します。


File: elisp,  Node: Accepting Output,  Prev: Decoding Output,  Up: Output from Processes

36.9.4 Accepting Output from Processes
--------------------------------------

非同期サブプロセスからの出力は通常、Emacsが時間の経過や端末入力のような
、ある種の外部イベントを待機する間だけ到着します。特定のポイントで出力の
到着を明示的に許可したり、あるいはプロセスからの出力が到着するまで待機す
ることさえ、Lispプログラムでは有用な場合が時折あります。

 -- Function: accept-process-output &optional process seconds millisec
          just-this-one
     この関数はプロセスからの保留中の出力を、Emacsが読み取ることを許す。
     この出力は、プロセスのフィルター関数により与えられる。PROCESSが非
     ‘nil’なら、この関数はPROCESSから何らかの出力を受け取るまでリターン
     しない。

     引数SECONDSとMILLISECにより、タイムアウトの長さを指定できる。前者は
     秒単位、後者はミリ秒単位でタイムアウトを指定する。この2つの秒数は、
     互いに足し合わせることによりタイムアウトを指定し、その秒数経過後は
     サブプロセスの出力の有無に関わらずリターンする。

     SECONDSに浮動小数点数を指定することにより、秒を少数点で指定できるの
     で、引数MILLISECは時代遅れである(そして使用するべきではない)。
     SECONDSが0なら、この関数は保留中の出力が何であれ受け取り、待機しな
     い。

     PROCESSがプロセスで、引数JUST-THIS-ONEが非‘nil’なら、そのプロセスか
     らの出力だけが処理され、そのプロセスからの出力を受信するか、タイム
     アウトとなるまで、他のプロセスの出力は停止される。JUST-THIS-ONEが整
     数なら、タイマーの実行も抑制される。この機能は一般的には推奨されな
     いが、音声合成のような特定のアプリケーションにとっては必要かもしれ
     ない。

     関数‘accept-process-output’は、何らかの出力を取得したら非‘nil’、出
     力の到着前にタイムアウトが到来したら‘nil’をリターンする。


File: elisp,  Node: Sentinels,  Next: Query Before Exit,  Prev: Output from Processes,  Up: Processes

36.10 Sentinels: Detecting Process Status Changes
=================================================

“プロセスセンチネル(process sentinel: プロセス番兵)”とは、(Emacsにより送
信されたか、そのプロセス自身の動作が原因で送信された)プロセスを終了、停
止、継続するシグナルを含む、何らかの理由により関連付けられたプロセスの状
態が変化した際は常に呼び出される関数のことです。プロセスがexitする際にも
、プロセスセンチネルが呼び出されます。センチネルは、イベントが発生したプ
ロセスと、イベントのタイプを記述する文字列という、2つの引数を受け取りま
す。

   イベントを記述する文字列は、以下のいずれかのような外見をもちます:

   • ‘"finished\n"’.

   • ‘"exited abnormally with code EXITCODE\n"’.

   • ‘"NAME-OF-SIGNAL\n"’.

   • ‘"NAME-OF-SIGNAL (core dumped)\n"’.

   センチネルは、Emacsが(端末入力や時間経過、またはプロセス出力を)待機し
ている間だけ実行されます。これは、他のLispプログラムの途中のランダムな箇
所で実行されるセンチネルが原因となる、タイミングエラーを無視します。プロ
グラムはセンチネルが実行されるように、‘sit-for’や‘sleep-for’(*note
Waiting::を参照)、または‘accept-process-output’(*note Accepting
Output::を参照)を呼び出すことにより待機することができます。Emacsはコマン
ドループが入力を読み取る際にも、センチネルの実行を許可します。
‘delete-process’は、実行中のプログラムを終了させる際に、センチネルを呼び
出します。

   Emacsは1つのプロセスのセンチネル呼び出しの理由のために複数のキューを
保持しません。これはカレント状態と、変化があった事実だけを記録します。し
たがって非常に短い間隔で、連続して状態に2つの変化があった場合は、一度だ
けセンチネルが呼び出されます。しかしプロセスの終了は、常に正確に1回セン
チネルを実行するでしょう。これは終了後にプロセス状態が再び変更されること
はないからです。

   Emacsはプロセスセンチネル実行の前に、プロセスからの出力をチェックしま
す。プロセス終了によりセンチネルが一度実行されると、そのプロセスから更な
る出力は到着しません。

   プロセスのバッファーに出力を書き込むセンチネルは、そのバッファーがま
だ生きているかチェックするべきです。死んだバッファーへの挿入を試みた場合
は、エラーとなるでしょう。そのバッファーがすでに死んでいれば、
‘(buffer-name (process-buffer PROCESS))’は‘nil’をリターンします。

   quitは通常はセンチネル内では抑制されます。さもないと、コマンドレベル
での‘C-g’のタイプ、またはユーザーコマンドのquitは予測できません。センチ
ネル内部でのquitを許可したければ、‘inhibit-quit’を‘nil’にバインドしてく
ださい。ほとんどの場合において、これを行う正しい方法はマクロ
‘with-local-quit’です。*note Quitting::を参照してください。

   センチネルの実行中にエラーが発生した場合、センチネル開始時に実行中だ
ったプログラムが何であれ実行を停止しないように、自動的にcatchされます。
しかし‘debug-on-error’が非‘nil’なら、エラーはcatchされません。これにより
、Lispデバッガーを使用したセンチネルのデバッグが可能になります。*note
Debugger::を参照してください。

   センチネル実行中、センチネルが再帰的に実行されないよう、プロセスセン
チネルは一時的に‘nil’にセットされます。この理由により、センチネルが新た
にセンチネルを指定することはできません。

   センチネル実行中、Emacsは自動的にマッチデータの保存とリストアを行うこ
とに注意してください。*note Match Data::を参照してください。

 -- Function: set-process-sentinel process sentinel
     この関数は、PROCESSに関連付ける。SENTINELが‘nil’なら、そのプロセス
     はプロセス状態変更時にプロセスのバッファーにメッセージを挿入する、
     デフォルトのセンチネルをもつことになるだろう。

     プロセスセンチネルの変更は、即座に効果を発揮する。そのセンチネルが
     実行される予定だが、まだ呼び出されておらず、かつ新たなセンチネルを
     指定した場合、最終的なセンチネル呼び出しには、新たなセンチネルが使
     用されるだろう。

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event `%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               ⇒ msg-me
          (kill-process (get-process "shell"))
               ⊣ Process: #<process shell> had the event `killed'
               ⇒ #<process shell>

 -- Function: process-sentinel process
     この関数は、PROCESSのセンチネルをリターンする。

   あるプロセス状態の変化を複数のセンチネルに渡す必要がある場合は、既存
のセンチネルと新たなセンチネルを組み合わせるために、‘add-function’を使用
できます。*note Advising Functions::を参照してください。

 -- Function: waiting-for-user-input-p
     この関数は、センチネルまたはフィルター関数の実行中、もしEmacsがセン
     チネルまたはフィルター関数呼び出し時にユーザーのキーボード入力を待
     機していたら非‘nil’、そうでなければ‘nil’をリターンする。


File: elisp,  Node: Query Before Exit,  Next: System Processes,  Prev: Sentinels,  Up: Processes

36.11 Querying Before Exit
==========================

Emacsがexitする際は、すべてのサブプロセスに‘SIGHUP’を送信することにより
、すべてのサブプロセスを終了します。それらのサブプロセスはさまざまな処理
を行っているかもしれないので、Emacsは通常ユーザーにたいしてそれらを終了
しても大丈夫か、確認を求めます。各プロセスはquery(問い合わせ)のためのフ
ラグをもち、これが非‘nil’なら、Emacsはプロセスをkillしてexitする前に確認
を行うべきであることを示します。queryフラグにたいするデフォルトは‘t’で、
これは問い合わせを_行う_ことを意味します。

 -- Function: process-query-on-exit-flag process
     これは、PROCESSのqueryフラグをリターンする。

 -- Function: set-process-query-on-exit-flag process flag
     この関数は、PROCESSのqueryフラグをFLAGにセットする。これはFLAGをリ
     ターンする。

     以下はshellプロセス上で、問い合わせを回避するために
     ‘set-process-query-on-exit-flag’を使用する例である:

          (set-process-query-on-exit-flag (get-process "shell") nil)
               ⇒ nil


File: elisp,  Node: System Processes,  Next: Transaction Queues,  Prev: Query Before Exit,  Up: Processes

36.12 Accessing Other Processes
===============================

カレントEmacsセッションのサブプロセスにたいするアクセスと操作に加えて、
同一マシン上で実行中の他のプロセスにたいして、Emacs Lispプログラムがアク
セスすることもできます。Emacsのサブプロセスと区別するために、わたしたち
はこれらを“システムプロセス(system processes)”と呼んでいます。

   Emacsは、システムプロセスへのアクセス用のプリミティブをいくつか提供し
ます。これらのプリミティブは、すべてのプラットフォームではサポートされま
せん。サポートしないシステムでは、これらのプリミティブは‘nil’をリターン
します。

 -- Function: list-system-processes
     この関数は、そのシステム上で実行中の、すべてのプロセスのリストをリ
     ターンする。各プロセスは、PIDというOSから割り当てられた数値によるプ
     ロセスIDにより識別され、同一時に同一マシン上で実行中の他のプロセス
     と区別される。

 -- Function: process-attributes pid
     この関数は、プロセスID PIDで指定されるプロセスにたいする、属性の
     alistをリターンする。このalist内の各属性は‘(KEY . VALUE)’という形式
     で、KEYは属性を指定し、VALUEはその属性の値である。この関数がリター
     ン可能な、さまざまな属性にたいするKEYを、以下にリストした。これらす
     べての属性を、すべてのプラットフォームがサポートする訳ではない。あ
     る属性がサポートされていなければ、その連想値はリターンされるalist内
     に出現しない。数値であるような値は整数か浮動小数点数のいずれかが可
     能で、それは値の大小に依存する。

     ‘euid’
          そのプロセスを呼び出したユーザーの、実効ユーザーID(effective
          user ID)。対応するVALUEは数値。プロセスがカレントEmacsセッショ
          ンを実行したユーザーと同じなら、値は‘user-uid’がリターンする値
          と等しくなる(*note User Identification::を参照)。

     ‘user’
          そのプロセスの実効ユーザーIDに対応するユーザー名であるような文
          字列。

     ‘egid’
          実行ユーザーIDのグループIDであるような数値。

     ‘group’
          実効ユーザーのグループIDに対応するグループ名であるような文字列
          。

     ‘comm’
          そのプロセス内で実効したコマンドの名前。これは通常、先行するデ
          ィレクトリーを除いた実行可能ファイル名を指定する文字列である。
          しかし、いくつかの特別なシステムプロセスは、実行可能ファイルま
          たはプログラムに対応しない文字列を報告する可能性がある。

     ‘state’
          そのプロセスの状態コード。これはそのプロセスのスケジューリング
          状態をエンコードする短い文字列である。以下は頻繁に目にするコー
          ドのリストである:

          ‘"D"’
               割り込み不可のsleep(通常はI/Oによる)
          ‘"R"’
               実行中
          ‘"S"’
               割り込み可能なsleep(何らかのイベント待ち)
          ‘"T"’
               たとえばジョブ制御シグナルにより停止された
          ‘"Z"’
               “zombie”: 終了したが親プロセスに回収されていないプロセス

          可能な状態の完全なリストは、‘ps’コマンドのman pageを参照された
          い。

     ‘ppid’
          親プロセスのプロセスIDであるような数値。

     ‘pgrp’
          そのプロセスのプロセスグループIDであるような数値。

     ‘sess’
          そのプロセスのセッションID。これはそのプロセスの“セッションリ
          ーダー(session leader)”のプロセスIDであるような数値である。

     ‘ttname’
          そのプロセスの制御端末の名前であるような文字列。Unixおよび
          GNUシステムでは、これは通常は‘/dev/pts65’のような、対応する端
          末デバイスのファイル名である。

     ‘tpgid’
          そのプロセスの端末を使用するフォアグラウンドプロセスグループの
          、プロセスグループIDであるような数値。

     ‘minflt’
          そのプロセス開始以降に発生したマイナーなページフォルト数(マイ
          ナーなページフォルトとはディスクからの読み込みを発生させないペ
          ージフォルトのこと)。

     ‘majflt’
          そのプロセス開始以降に発生したメジャーなページフォルト数(メジ
          ャーなページフォルトとは、ディスクからの読み込みを要し、それ故
          にマイナーページフォルトより高価なページフォルトのこと)。

     ‘cminflt’
     ‘cmajflt’
          ‘minflt’と‘majflt’と似ているが、与えられたプロセスのすべての子
          プロセスのページフォルト数を含む。

     ‘utime’
          アプリケーションのコード実行にたいして、ユーザーコンテキスト内
          でプロセスに消費された時間。対応するVALUEは
          ‘(HIGH LOW MICROSEC PICOSEC)’というフォーマットで、これは関数
          ‘current-time’が使用するフォーマットと同じである(*note
          current-time: Time of Day.)および*note File Attributes::の
          ‘file-attributes’を参照)。

     ‘stime’
          システムコールの処理にたいして、システム(kernel)コンテキスト内
          でプロセスに消費された時間。対応するVALUEは‘utime’と同じフォー
          マット。

     ‘time’
          ‘utime’と‘stime’の和。対応するVALUEは‘utime’と同じフォーマット
          。

     ‘cutime’
     ‘cstime’
     ‘ctime’
          ‘utime’や‘stime’と同様だが、与えられたプロセスのすべての子プロ
          セスの時間が含まれる点が異なる。

     ‘pri’
          そのプロセスの数値的な優先度。

     ‘nice’
          そのプロセスの“nice値(nice value)”であるような数値(小さい
          nice値のプロセスがより優先的にスケジュールされる)。

     ‘thcount’
          そのプロセス内のスレッド数。

     ‘start’
          ‘file-attributes’および‘current-time’が使用するのと同じフォー
          マット‘(HIGH LOW MICROSEC PICOSEC)’による、そのプロセスが開始
          された時刻。

     ‘etime’
          ‘(HIGH LOW MICROSEC PICOSEC)’というフォーマットによる、そのプ
          ロセスが開始されてから経過した時間。

     ‘vsize’
          そのプロセスの仮想メモリーのKB単位でのサイズ。

     ‘rss’
          そのプロセスがマシンの物理メモリー内で占める“常駐セット
          (resident set)”のKB単位でのサイズ。

     ‘pcpu’
          プロセス開始以降に使用されたCPU時間のパーセンテージ。対応する
          VALUEは0から100の間の浮動小数点数。

     ‘pmem’
          マシンにインストールされた物理メモリー合計のうち、そのプロセス
          の常駐セットのパーセンテージ。値は0から100の間の浮動小数点数。

     ‘args’
          そのプロセスが呼び出されたときのコマンドライン。これは個々のコ
          マンドライン引数がブランクで区切られた文字列である。引数に埋め
          込まれた空白文字は、そのシステムに応じて適切にクォートされる。
          GNUおよびUnixではバックスラッシュ文字によるエスケープ、
          Windowsではダブルクォート文字で囲まれる。つまりこのコマンドラ
          イン文字列は、‘shell-command’のようなプリミティブにより直接使
          用できる。


File: elisp,  Node: Transaction Queues,  Next: Network,  Prev: System Processes,  Up: Processes

36.13 Transaction Queues
========================

トランザクションを用いてサブプロセスと対話するために、“トランザクション
キュー(transaction queue)”を使用できます。まず‘tq-create’を使用して、指
定したプロセスと対話するためのトランザクションキューを作成します。それか
らトランザクションを送信するために、‘tq-enqueue’を呼び出すことができます
。

 -- Function: tq-create process
     この関数は、PROCESSと対話するトランザクションキューを作成してリター
     ンする。引数PROCESSは、バイトストリームを送受信する能力をもつサブプ
     ロセスであること。これは子プロセス、または(おそらく別のマシン上の
     )サーバーへのTCP接続かもしれない。

 -- Function: tq-enqueue queue question regexp closure fn &optional
          delay-question
     この関数は、キューQUEUEにトランザクションを送信する。キューの指定は
     、対話するサブプロセスを指定する効果をもつ。

     引数QUESTIONは、トランザクションを開始するために発信するメッセージ
     である。引数FNは、それにたいする応答が返信された際に呼び出す関数で
     ある。これはCLOSUREと受信した応答という、2つの引数で呼び出される。

     引数REGEXPは応答全体の終端にマッチし、それより前にはマッチしない正
     規表現であること。これが応答の終わりを‘tq-enqueue’が決定する方法で
     ある。

     引数DELAY-QUESTIONが非‘nil’なら、そのプロセスが以前に発信したすべて
     のメッセージへの返信が完了するまで、このメッセージの送信を遅延する
     。これは、いくつかのプロセスにたいしてより信頼性のある結果が生成さ
     れる。

 -- Function: tq-close queue
     保留中のすべてのトランザクションの完了を待機して、トランザクション
     キューQUEUEをシャットダウンし、それから接続または子プロセスを終了す
     る。

   トランザクションキューは、フィルター関数により実装されています。*note
Filter Functions::を参照してください。


File: elisp,  Node: Network,  Next: Network Servers,  Prev: Transaction Queues,  Up: Processes

36.14 Network Connections
=========================

Emacs Lispプログラムは、同一マシンまたは他のマシン上の別プロセスにたいし
て、ストリーム(TCP)およびデータグラム(UDP)のネットワーク接続(*note
Datagrams::を参照)をオープンできます。ネットワーク接続はLispにより、サブ
プロセスと同様に処理され、プロセスオブジェクトとして表されます。しかし対
話を行うそのプロセスは、Emacsの子プロセスではなく、プロセスIDをもたず、
それをkillしたりシグナルを送信することはできません。行うことができるのは
、データの送信と受信だけです。‘delete-process’は接続をクローズしますが、
他端のプログラムをkillしません。そのプログラムは接続のクローズについて何
を行うか、決定しなければなりません。

   ネットワークサーバーを作成することにより、Lispプログラムは接続を
listenできます。ネットワークサーバーもある種のプロセスオブジェクトとして
表されますが、ネットワーク接続とは異なり、ネットワークサーバーがデータ自
体を転送することは決してありません。接続リクエストを受信したときは、それ
にたいして作成した接続を表す、新たなネットワーク接続を作成します(そのネ
ットワーク接続はサーバーから、プロセスplistを含む特定の情報を継承する)。
その後、ネットワークサーバーは更なる接続リクエストのlistenに戻ります。

   ネットワーク接続およびサーバーは、キーワード/引数のペアーで構成される
引数リストで‘make-network-process’を呼び出すことにより作成されます。たと
えば‘:server t’はサーバープロセス、‘:type 'datagram’はデータグラム接続を
作成します。詳細は*note Low-Level Network::を参照してください。以下で説
明する‘open-network-stream’を使用することもできます。

   異なるプロセスのタイプを区別するために、‘process-type’関数はネットワ
ーク接続またはサーバーにたいしてはシンボル‘network’、シリアルポート接続
は‘serial’、実際のサブプロセスにたいしては‘real’をリターンします。

   ネットワーク接続にたいして、‘process-status’関数は‘open’、‘closed’、
‘connect’、‘failed’をリターンします。ネットワークサーバーにたいしては、
状態は常に‘listen’になります。実際のサブプロセスにたいしては、これらの値
はリターンされません。*note Process Information::を参照してください。

   ‘stop-process’と‘continue-process’を呼び出すことにより、ネットワーク
プロセスの処理の停止と再開が可能です。サーバープロセスにたいする停止は、
新たな接続の受け付けないことを意味します(サーバー再開時は5つまでの接続リ
クエストがキューされる。これがOSによる制限でなければこの制限は増やすこと
ができる。*note Network Processes::の‘make-network-process’の‘:server’を
参照されたい)。ネットワークストリーム接続にたいしては、停止は入力の処理
を行わないことを意味します(到着するすべての入力は接続の再開まで待つ)。デ
ータグラム接続にたいしては、いくらかのパケットはキューされますが、入力は
失われるかもしれません。ネットワーク接続またはサーバーが停止しているかど
うかを判断するために、関数‘process-command’を使用できます。これが非
‘nil’なら停止しています。

   ビルトインまたは外部のサポートを使用することにより、Emacsは暗号化され
たネットワーク接続を作成できます。ビルトインのサポートはGnuTLSライブラリ
ー(“TLS: Transport Layer Security”)を使用します。the GnuTLS project page
(http://www.gnu.org/software/gnutls/)を参照してください。GnuTLSサポート
つきでEmacsをコンパイルした場合は、関数‘gnutls-available-p’が定義され、
非‘nil’をリターンします。詳細は*note Overview: (emacs-gnutls)Top.を参照
してください。外部のサポートの場合は、‘starttls.el’ライブラリーを使用し
ます。これはシステム上に‘gnutls-cli’のようなヘルパーユーティリティーのイ
ンストールを必要とします。‘open-network-stream’関数は、何であれ利用可能
なサポートを使用して、暗号化接続作成の詳細を透過的に処理できます。

 -- Function: open-network-stream name buffer host service &rest
          parameters
     この関数は、オプションで暗号つきでTCP接続をオープンして、その接続を
     表すプロセスオブジェクトをリターンする。

     NAME引数は、プロセスオブジェクトの名前を指定する。これは必要に応じ
     て一意になるよう修正される。

     BUFFER引数は、その接続に関連付けるバッファーである。その接続からの
     出力は、その出力を処理する独自のフィルター関数を指定していなければ
     、BUFFERが‘nil’なら、その接続はバッファーに関連付けられない。

     引数HOSTとSERVICEは、どこに接続するかを指定する。HOSTはホスト名(文
     字列)、SERVICEは定義済みのネットワークサービス名(文字列)、またはポ
     ート番号(数字)である。

     残りの引数PARAMETERSは、主に暗号化された接続に関連する、キーワード
     /引数のペアーである:

     ‘:nowait BOOLEAN’
          非‘nil’なら非同期接続を試みる。

     ‘:type TYPE’
          接続のタイプ。オプションは以下のとおり:

          ‘plain’
               通常の暗号化されていない接続。
          ‘tls’
          ‘ssl’
               TLS(“Transport Layer Security”)接続。
          ‘nil’
          ‘network’
               plain接続を開始して、パラメーター‘:success’および
               ‘:capability-command’が与えられたら、STARTTLSを通じて暗号
               化接続への更新を試みる。これが失敗したら、暗号化されてい
               ない接続のまま留まる。
          ‘starttls’
               ‘nil’と同様だが、STARTTLSが失敗したらその接続を切断する。
          ‘shell’
               shell接続。

     ‘:always-query-capabilities BOOLEAN’
          非‘nil’なら、たとえ‘plain’な接続を行っているときでも、常にサー
          バーの能力を問い合わせる。

     ‘:capability-command CAPABILITY-COMMAND’
          ホストの能力を問い合わせるためのコマンド文字列。

     ‘:end-of-command REGEXP’
     ‘:end-of-capability REGEXP’
          コマンドの終端、またはコマンドCAPABILITY-COMMANDの終端にマッチ
          する正規表現。前者は後者のデフォルトである。

     ‘:starttls-function FUNCTION’
          単一の引数(CAPABILITY-COMMANDにたいする応答)をとり‘nil’、また
          はサポートされていればSTARTTLSをアクティブにするコマンドをリタ
          ーンする関数。

     ‘:success REGEXP’
          成功したSTARTTLSネゴシェーションにマッチする正規表現。

     ‘:use-starttls-if-possible BOOLEAN’
          非‘nil’なら、たとえEmacsがビルトインのTLSサポートをもっていな
          くても、日和見的(opportunistic)にSTARTTLSアップグレードを行う
          。

     ‘:client-certificate LIST-OR-T’
          証明書(certificate)のキーと、証明書のファイル自身を命名する
          ‘(KEY-FILE CERT-FILE)’という形式のリスト、またはこの情報にたい
          して‘auth-source’を尋ねることを意味する‘t’のいずれか(*note
          Overview: (auth)Top.を参照)。TLSまたはSTARTTLSにたいしてのみ使
          用される。

     ‘:return-list CONS-OR-NIL’
          この関数のリターン値。省略または‘nil’なら、プロセスオブジェク
          トをリターンする。それ以外なら、‘(PROCESS-OBJECT . PLIST)’とい
          う形式のコンスセルをリターンする。ここでPLISTは以下のキーワー
          ドである:

          ‘:greeting STRING-OR-NIL’
               非‘nil’なら、ホストからリターンされたgreeting(挨拶)文字列
               。
          ‘:capabilities STRING-OR-NIL’
               非‘nil’なら、ホストの能力(capability)文字列。
          ‘:type SYMBOL’
               接続タイプで、‘plain’か‘tls’のいずれか。


File: elisp,  Node: Network Servers,  Next: Datagrams,  Prev: Network,  Up: Processes

36.15 Network Servers
=====================

‘:server t’で‘make-network-process’を呼び出すことによりサーバーが作成さ
れます(*note Network Processes::を参照)。そのサーバーは、クライアントか
らの接続リクエストをlistenするでしょう。クライアントの接続リクエストを
accept(受け入れる)する際は、以下のようなパラメーターで、それ自体がプロセ
スオブジェクトであるようなネットワーク接続を作成します。

   • その接続のプロセス名は、サーバープロセスのNAMEと、クライアント識別
     文字列を結合して構築される。IPv4接続にたいするクライアント識別文字
     列は、アドレスとポート番号を表す、‘<A.B.C.D:P>’のような文字列である
     。それ以外なら、‘<NNN>’のようにカッコで囲まれた一意な数字である。こ
     の数字は、そのEmacsセッション内のそれぞれの接続にたいして一意である
     。

   • サーバーが非デフォルトのフィルターをもつ場合、その接続プロセスは別
     個にプロセスバッファーを取得しない。それ以外なら、Emacsはその目的の
     ために新たにバッファーを作成する。サーバーのバッファー名またはプロ
     セス名にクライアント識別文字列に結合したものがバッファー名になる。

     サーバーのプロセスバッファーの値が直接使用されることは決してないが
     、log関数はそれを取得して、そこにテキストを挿入することにより、接続
     のログを記録するために使用することができる。

   • 通信タイプ(communication type)、プロセスフィルター、およびセンチネ
     ルはそれぞれ、サーバーのものから継承される。サーバーが直接フィルタ
     ーとセンチネルを使用することは決してない。それらの唯一の目的は、サ
     ーバーへの接続を初期化することである。

   • その接続のプロセスコンタクト情報は、クライアントのアドレス情報(通常
     はIPアドレスとポート番号)に応じてセットされる。この情報は、
     ‘process-contact’のキーワード‘:host’、‘:service’、‘:remote’に関連付
     けられる。

   • その接続のローカルアドレスは、それが使用するポート番号に応じてセッ
     トアップされる。

   • クライアントプロセスのplistは、サーバーのplistからインストールされ
     る。


File: elisp,  Node: Datagrams,  Next: Low-Level Network,  Prev: Network Servers,  Up: Processes

36.16 Datagrams
===============

“データグラム(datagram)”接続は、データストリームではなく個別のパッケージ
で対話します。‘process-send’を呼び出すたびに1つのデータグラムパケット
(*note Input to Processes::)が送信され、受信されたデータグラムごとに1回
フィルター関数が呼び出されます。

   データグラム接続は、毎回同じリモートピア(remote peer)と対話する必要は
ありません。データグラム接続は、データグラムの送信先を指定する、“リモー
トピアアドレス(remote peer address)”をもちます。フィルター関数にたいして
受信されたデータグラムが渡されるたびに、そのデータグラムの送信元アドレス
がピアアドレスにセットされます。このように、もしフィルター関数がデータグ
ラムを送信したら、それは元の場所へ戻ることになります。‘:remote’キーワー
ドを使用してデータグラム接続を作成する際は、リモートピアアドレスを指定で
きます。‘set-process-datagram-address’を呼び出すことにより、後からそれを
変更できます。

 -- Function: process-datagram-address process
     PROCESSがデータグラム接続またはサーバーなら、この関数はそれのリモー
     トピアアドレスをリターンする。

 -- Function: set-process-datagram-address process address
     PROCESSがデータグラム接続またはサーバーなら、この関数はそのリモート
     ピアアドレスにADDRESSをセットする。


File: elisp,  Node: Low-Level Network,  Next: Misc Network,  Prev: Datagrams,  Up: Processes

36.17 Low-Level Network Access
==============================

‘make-network-process’を使用することにより、‘open-network-stream’より低
レベルでの処理により、ネットワーク接続を作成することもできます。

* Menu:

* Proc: Network Processes.   ‘make-network-process’の使用。
* Options: Network Options.  更なるネットワーク接続の制御。
* Features: Network Feature Testing.  使用中マシン上で動作するネットワーク機能を判断する。


File: elisp,  Node: Network Processes,  Next: Network Options,  Up: Low-Level Network

36.17.1 ‘make-network-process’
------------------------------

ネットワーク接続およびネットワークサーバーを作成する基本的な関数は、
‘make-network-process’です。これは与えられた引数に応じて、これらの仕事の
いずれかを行うことができます。

 -- Function: make-network-process &rest args
     この関数は、ネットワーク接続またはサーバーを作成して、それを表すプ
     ロセスオブジェクトをリターンする。引数ARGSは、キーワード/引数のペア
     からなるリストである。キーワードの省略は‘:coding’、
     ‘:filter-multibyte’、‘:reuseaddr’を除き、常に値として‘nil’を指定し
     たのと同じことになる。重要なキーワードを以下に示す(ネットワークオプ
     ションに対応するキーワードを、以降のセクションにリストする)。

     :name NAME
          プロセス名として、文字列NAMEを使用する。一意にするために、必要
          に応じて変更され得る。

     :type TYPE
          コミュニケーションのタイプを指定する。値‘nil’はストリーム接続
          (デフォルト)、‘datagram’はデータグラム接続、‘seqpacket’は“シー
          ケンスパケットストリーム(sequenced packet stream)”による接続を
          指定する。接続およびサーバーの両方で、これらのタイプを指定でき
          る。

     :server SERVER-FLAG
          SERVER-FLAGが非‘nil’ならサーバー、それ以外なら接続を作成する。
          ストリームタイプのサーバーでは、SERVER-FLAGはそのサーバーへの
          保留中の接続キューの長さを指定する、整数を指定できる。キューの
          デフォルト長は5。

     :host HOST
          接続するホストを指定する。HOSTは、ホスト名またはインターネット
          アドレスを表す文字列、またはローカルホストを表すシンボル
          ‘local’であること。サーバーのときにHOSTを指定する場合は、有効
          なローカルホストのアドレスを指定しなければならず、そのアドレス
          に接続するクライアントだけが受け入れられるだろう。

     :service SERVICE
          SERVICEは接続先のポート番号、またはサーバーにたいしては
          listenするポート番号である。これはポート番号に変換されるような
          サービス名、または直接ポート番号を指定する整数であること。サー
          バーにたいしては‘t’も指定でき、これは未使用のポート番号をシス
          テムに選択させることを意味する。

     :family FAMILY
          FAMILYは、接続のアドレス(またはプロトコル)のファミリーを指定す
          る。‘nil’は、与えられたHOSTとSERVICEにたいして、自動的に適切な
          アドレスファミリーを決定する。‘local’はUnixのsocketを指定し、
          この場合HOSTは無視される。‘ipv4’と‘ipv6’はそれぞれ、IPv4と
          IPv6の使用を指定する。

     :local LOCAL-ADDRESS
          サーバープロセスでは、LOCAL-ADDRESSはlistenするアドレスである
          。これはFAMILY、HOST、SERVICEをオーバーライドするので、これら
          を指定しないこともできる。

     :remote REMOTE-ADDRESS
          接続プロセスでは、REMOTE-ADDRESSは接続先のアドレスである。これ
          はFAMILY、HOST、SERVICEをオーバーライドするので、これらを指定
          しないこともできる。

          データグラムサーバーでは、REMOTE-ADDRESSはリモートデータグラム
          アドレスの初期セッティングを指定する。

          LOCAL-ADDRESSとREMOTE-ADDRESSのフォーマットは、そのアドレスフ
          ァミリーに依存する:

             - IPv4アドレスは、4つの8ビット整数と1つの16ビット整数からな
               る5要素のベクター‘[A B C D P]’で表され、それぞれ数値的な
               IPv4アドレスA.B.C.D、およびポート番号Pに対応する。

             - IPv6アドレスは、9要素の16ビット整数ベクター‘[A B C D E F
               G H P]’で表され、それぞれ数値的なIPv６アドレス
               A:B:C:D:E:F:G:H、およびポート番号Pに対応する。

             - ローカルアドレスは、ローカルアドレススペース内でアドレス
               を指定する文字列として表される。

             - “未サポートファミリー(unsupported family)”のアドレスは、
               コンスセル‘(F . AV)’で表される。ここでFはファミリー名、
               AVはアドレスデータバイトごとに1つの要素を使用する、ソケッ
               トアドレスを指定するベクターである。可搬性のあるコードで
               このフォーマットを信頼してはならない。これは実装定義の定
               数、データサイズ、データ構造のアライメントに依存する可能
               性があるからだ。

     :nowait BOOL
          ストリーム接続にたいしてBOOLが非‘nil’なら、その接続の完了を待
          機せずにリターンする。接続が成功または失敗時には、Emacsは
          ‘"open"’(成功時)、または‘"failed"’(失敗時)にマッチするような第
          2引数により、センチネル関数を呼び出すだろう。デフォルトでは
          waitせずにblockするので、‘make-network-process’はその接続が成
          功または失敗するまで、リターンしない。

     :stop STOPPED
          STOPPEDが非‘nil’なら、“stopped”の状態でネットワーク接続、また
          はサーバーを開始する。

     :buffer BUFFER
          プロセスバッファーとしてBUFFERを使用する。

     :coding CODING
          このプロセスにたいするコーディングシステムとして、CODINGを使用
          する。接続からのデータのデコード、および接続への送信データのエ
          ンコードに異なるコーディングシステムを指定するには、CODINGにた
          いして‘(DECODING . ENCODING)’と指定する。

          このキーワードをまったく指定しないかった場合のデフォルトは、そ
          のデータからコーディングシステムを判断する。

     :noquery QUERY-FLAG
          プロセスqueryフラグをQUERY-FLAGに初期化する。*note Query
          Before Exit::を参照のこと。

     :filter FILTER
          プロセスフィルターをFILTERに初期化する。

     :filter-multibyte MULTIBYTE
          MULTIBYTEが非‘nil’ならマルチバイト文字列、それ以外ならユニバイ
          ト文字列がプロセスフィルターに与えられるデフォルトは、
          ‘enable-multibyte-characters’のデフォルト値である。

     :sentinel SENTINEL
          プロセスセンチネルをSENTINELに初期化する。

     :log LOG
          サーバープロセスのlog関数を、LOGに初期化する。サーバーがクライ
          アントからネットワーク接続をacceptするたびに、そのlog関数が呼
          び出される。log関数に渡される引数はSERVER、CONNECTION、
          MESSAGEである。ここでSERVERはサーバープロセス、CONNECTIONはそ
          の接続にたいする新たなプロセス、MESSAGEは何が発生したかを説明
          する文字列である。

     :plist PLIST
          プロセスplistをPLISTに初期化する。

     実際の接続情報で修正されたオリジナルの引数リストは、
     ‘process-contact’を通じて利用できる。


File: elisp,  Node: Network Options,  Next: Network Feature Testing,  Prev: Network Processes,  Up: Low-Level Network

36.17.2 Network Options
-----------------------

以下のネットワークオプションは、ネットワークプロセス作成時に指定できます
。‘:reuseaddr’を除き、‘set-network-process-option’を使用して、これらのオ
プションを後からセットまたは変更することもできます。

   サーバープロセスにたいしては、‘make-network-process’で指定されたオプ
ションはクライアントに継承されないので、子接続が作成されるたびに、必要な
オプションをセットする必要があるでしょう。

:bindtodevice DEVICE-NAME
     DEVICE-NAMEが空でないネットワークインターフェースを指定する文字列な
     ら、そのインターフェースで受信したパケットだけを処理する。
     DEVICE-NAMEが‘nil’(デフォルト)なら、任意のインターフェースが受信し
     たパケットを処理する。

     このオプションの使用にたいして、特別な特権を要求するシステムがいく
     つかあるかもしれない。

:broadcast BROADCAST-FLAG
     データグラムプロセスにたいしてBROADCAST-FLAGが非‘nil’なら、そのプロ
     セスはブロードキャストアドレスに送信されたデータグラムパケットを受
     信し、ブロードキャストアドレスにパケットを送信できるだろう。これは
     ストリーム接続では無視される。

:dontroute DONTROUTE-FLAG
     DONTROUTE-FLAGが非‘nil’なら、プロセスはローカルホストと同一ネットワ
     ーク上のホストだけに送信することができる。

:keepalive KEEPALIVE-FLAG
     ストリーム接続にたいしてKEEPALIVE-FLAGが非‘nil’なら、低レベルの
     keep-aliveメッセージの交換が有効になる。

:linger LINGER-ARG
     LINGER-ARGが非‘nil’なら、接続を削除(‘delete-process’を参照)する前に
     キューされたすべてのパケットの送信が成功するまで待機する。
     LINGER-ARGが整数なら、接続クローズ前のキュー済みパケット送信のため
     に待機する、最大の秒数を指定する。デフォルトは‘nil’で、これはプロセ
     ス削除時に未送信のキュー済みパケットを破棄することを意味する。

:oobinline OOBINLINE-FLAG
     ストリーム接続にたいしてOOBINLINE-FLAGが非‘nil’なら、通常のデータス
     トリーム内の帯域外(out-of-band)データを受信し、それ以外なら帯域外デ
     ータは破棄する。

:priority PRIORITY
     この接続で送信するパケットの優先順位を、整数PRIORITYにセットする。
     たとえばこの接続で送信するIPパケットのTOS(type of service)フィール
     ドにセットする等、この数字の解釈はプロトコル固有である。また、その
     ネットワークインターフェース上で特定の出力キューを選択する等、これ
     にはシステム依存の効果もある。

:reuseaddr REUSEADDR-FLAG
     ストリームプロセスサーバーにたいしてREUSEADDR-FLAGが非‘nil’(デフォ
     ルト)なら、そのホスト上の別プロセスがそのポートですでにlistenしてい
     なければ、このサーバーは特定のポート番号(‘:service’を参照)を再使用
     できる。REUSEADDR-FLAGが‘nil’なら、(そのホスト上の任意のプロセスが
     )そのポートを最後に使用した後、そのポート上で新たなサーバーを作成す
     るのが不可能となるような、一定の期間が存在するかもしれない。

 -- Function: set-network-process-option process option value &optional
          no-error
     この関数はネットワークプロセスPROCESSにたいして、ネットワークオプシ
     ョンのセットまたは変更を行う。指定できるオプションは
     ‘make-network-process’と同様。NO-ERRORが非‘nil’なら、OPTIONがサポー
     トされないオプションの場合に、この関数はエラーをシグナルせずに、
     ‘nil’をリターンする。この関数が成功裏に完了したら、‘t’をリターンす
     る。

     あるオプションのカレントのセッティングは、‘process-contact’関数を通
     じて利用できる。


File: elisp,  Node: Network Feature Testing,  Prev: Network Options,  Up: Low-Level Network

36.17.3 Testing Availability of Network Features
------------------------------------------------

与えられネットワーク機能が▼利用可能かテストするためには、以下のように
‘featurep’を使用します:

     (featurep 'make-network-process '(KEYWORD VALUE))

このフォームの結果は、‘make-network-process’内でKEYWORDに値VALUEを指定す
ることが機能するなら、‘t’になります。以下は、この方法でテストできる
KEYWORD/VALUEペアーのいくつかです。

‘(:nowait t)’
     非ブロッキング接続がサポートされていれば非‘nil’。
‘(:type datagram)’
     データグラムがサポートされていれば非‘nil’。
‘(:family local)’
     ローカルsocket(別名“UNIX domain”)がサポートされていれば非‘nil’。
‘(:family ipv6)’
     IPv6がサポートされていれば非‘nil’。
‘(:service t)’
     サーバーにたいしてシステムがポートを選択できれば非‘nil’。

   与えられたネットワークオプションが利用可能かテストするためには、以下
のように‘featurep’を使用します:

     (featurep 'make-network-process 'KEYWORD)

指定できるKEYWORDの値は‘:bindtodevice’等です。完全なリストは*note
Network Options::を参照してください。このフォームは、
‘make-network-process’(または‘set-network-process-option’)が特定のネット
ワークオプションをサポートしていれば、非‘nil’をリターンする。


File: elisp,  Node: Misc Network,  Next: Serial Ports,  Prev: Low-Level Network,  Up: Processes

36.18 Misc Network Facilities
=============================

以下の追加の関数は、ネットワーク接続の作成や操作に有用です。これらは、い
くつかのシステムでのみサポートされることに注意してください。

 -- Function: network-interface-list
     この関数は、使用しているマシン上のネットワークインターフェースを記
     述する、リストをリターンする。値は、要素が‘(NAME . ADDRESS)’という
     形式をもつようなalistである。ADDRESSは、‘make-network-process’の引
     数LOCAL-ADDRESSおよびREMOTE-ADDRESSと同じ形式をもつ。

 -- Function: network-interface-info ifname
     この関数は、IFNAMEという名前のネットワークインターフェースに関する
     情報をリターンする。値は、‘(ADDR BCAST NETMASK HWADDR FLAGS)’という
     形式をもつリストである。

     ADDR
          インターネットプロトコルアドレス。
     BCAST
          ブロードキャストアドレス。
     NETMASK
          ネットワークマスク。
     HWADDR
          レイヤー2アドレス(たとえばイーサネットMACアドレス)。
     FLAGS
          そのインターフェースのカレントのフラグ。

 -- Function: format-network-address address &optional omit-port
     この関数は、ネットワークアドレスのLisp表現を文字列に変換する。

     5要素のベクター‘[A B C D P]’はIPv4アドレスA.B.C.D、およびポート番号
     Pを表す。‘format-network-address’はこれを、文字列‘\"A.B.C.D:P\"’に
     変換する。

     9要素のベクター‘[A B C D E F G H P]’はポート番号とともに、IPv6アド
     レスを表す。‘format-network-address’はこれを、文字列
     ‘"[A:B:C:D:E:F:G:H]:P"’に変換する。

     このベクターにポート番号が含まれない、またはOMIT-PORTが非‘nil’なら
     、結果にサフィックス‘:P’は含まれない。


File: elisp,  Node: Serial Ports,  Next: Byte Packing,  Prev: Misc Network,  Up: Processes

36.19 Communicating with Serial Ports
=====================================

Emacsはシリアルポートと対話できます。インタラクティブな使用、‘M-x
serial-term’にたいしては端末ウィンドウをオープンし、Lispプログラム
‘make-serial-process’にたいしてはプロセスオブジェクトを作成します。

   シリアルポートは、クローズと再オープンなして、実行時に設定することが
できます。関数‘serial-process-configure’によりスピード、バイトサイズ、お
よびその他のパラメーターを変更できます。‘serial-term’で作成された端末ウ
ィンドウでは、モードラインをクリックして設定を行うことができます。

   シリアル接続はプロセスオブジェクトとして表され、サブプロセスやネット
ワークプロセスと同様の方法で使用できます。これによりデータの送受信や、シ
リアルポートの設定ができます。しかし、シリアルプロセスオブジェクトにプロ
セスIDはありません。それにたいしてシグナルの送信はできず、ステータスコー
ドは他のタイプのプロセスオブジェクトとは異なります。プロセスオブジェクト
への‘delete-process’、またはプロセスバッファーにたいする‘kill-buffer’は
接続をクローズしますが、そのシリアルポートに接続されたデバイスに影響はあ
りません。

   関数‘process-type’は、シリアルポート接続を表すプロセスオブジェクトに
たいする、シンボル‘serial’をリターンします。

   シリアルポートはGNU/Linux、Unix、およびMS Windowsのシステムで利用でき
ます。

 -- Command: serial-term port speed
     新たなバッファー内で、シリアルポートにたいする端末エミュレーターを
     開始する。PORTは、接続先のシリアルポートの名前である。たとえば
     Unixでは、これは‘/dev/ttyS0’のようになるだろう。MS Windowsでは、
     ‘COM1’や‘\\.\COM10’のようになるかもしれない(Lisp文字列ではバックス
     ラッシュは2重にする)。

     SPEEDは、ビット毎秒でのシリアルポートのスピードである。一般的な値は
     9600。そのバッファーはTermモードになる。このバッファーで使用するコ
     マンドについては、*note (emacs)Term Mode::を参照のこと。モードライ
     ンメニューから、スピードと設定を変更できる。

 -- Function: make-serial-process &rest args
     この関数は、プロセスとバッファーを作成する。引数は、キーワード/引数
     ペアーで指定する。以下は意味のあるキーワードのリストで、最初の2つ
     (PORTとSPEED)は必須である:

     ‘:port PORT’
          これは、シリアルポートの名前である。UnixおよびGNUシステムでは
          ‘/dev/ttyS0’のようなファイル名、Windowsでは‘COM1’、‘COM9’より
          高位のポートでは‘\\.\COM10’のようになるかもしれない(Lisp文字列
          ではバックスラッシュは2重にする)。

     ‘:speed SPEED’
          ビット毎秒でのシリアルポートのスピード。この関数は
          ‘serial-process-configure’を呼び出すことにより、スピードを操作
          する。この関数の更なる詳細については、以降のドキュメントを参照
          されたい。

     ‘:name NAME’
          そのプロセスの名前。NAMEが与えられなければ、PORTが同様にプロセ
          ス名の役目を果たす。

     ‘:buffer BUFFER’
          そのプロセスに関連付けられたバッファー。値はバッファー、または
          それがバッファーの名前であるような文字列かもしれない。出力を処
          理するために出力ストリーム、あるいはフィルター関数を指定しなけ
          れば、プロセス出力はそのバッファーの終端に出力される。BUFFERが
          与えられなければ、そのプロセスバッファーの名前は、‘:name’キー
          ワードから取得される。

     ‘:coding CODING’
          CODINGは、このプロセスにたいする読み書きに使用される、コーディ
          ングシステムを指定する。CODINGがコンス‘(DECODING . ENCODING)’な
          ら、読み取りにDECODING、書き込みにはENCODINGが使用される。指定
          されない場合のデフォルトは、データ自身から判断されるコーディン
          グシステムである。

     ‘:noquery QUERY-FLAG’
          プロセスqueryフラグを、QUERY-FLAGに初期化する。*note Query
          Before Exit::を参照のこと。未指定の場合のフラグのデフォルトは
          ‘nil’。

     ‘:stop BOOL’
          BOOLが非‘nil’なら、“stopped”の状態でプロセスを開始する。
          stopped状態では、シリアルプロセスは入力データを受け付けないが
          、出力データの送信は可能。stopped状態のクリアーは
          ‘continue-process’、セットは‘stop-process’で行う。

     ‘:filter FILTER’
          プロセスフィルターとして、FILTERをインストールする。

     ‘:sentinel SENTINEL’
          プロセスセンチネルとして、SENTINELをインストールする。

     ‘:plist PLIST’
          プロセスの初期plistとして、PLISTをインストールする。

     ‘:bytesize’
     ‘:parity’
     ‘:stopbits’
     ‘:flowcontrol’
          これらは、‘make-serial-process’が呼び出す、
          ‘serial-process-configure’により処理される。

     後の設定により変更され得るオリジナルの引数リストは、関数
     ‘process-contact’を通じて利用可能。

     以下に例を示す:

          (make-serial-process :port "/dev/ttyS0" :speed 9600)

 -- Function: serial-process-configure &rest args

     この関数は、シリアルポート接続を設定する。引数はキーワード/引数ペア
     ーで指定する。与えられない属性は、そのプロセスのカレントの設定(関数
     ‘process-contact’を通じて利用可能)から再初期化されるか、妥当なデフ
     ォルトにセットされる。以下の引数が定義されている:

     ‘:process PROCESS’
     ‘:name NAME’
     ‘:buffer BUFFER’
     ‘:port PORT’
          設定するプロセスを識別するために、これらの引数のいずれかを与え
          られる。これらの引数が何も与えられなければ、カレントバッファー
          のプロセスが使用される。

     ‘:speed SPEED’
          ビット毎秒、別名“ボーレート(baud rate)”での、シリアルポートの
          スピード。値には任意の数字が可能だが、ほとんどのシリアルポート
          は1200から115200の間の数少ない定義済みの値でのみ機能し、もっと
          も一般的な値は9600である。SPEEDが‘nil’なら、この関数は他のすべ
          ての引数を無視して、そのポートを設定しない。これは接続を通じて
          送信された‘AT’コマンドでのみ設定可能な、Bluetooth/シリアル変換
          アダプターのような、特殊なシリアルポートで有用かもしれない。
          SPEEDにたいする値‘nil’は、‘make-serial-process’または
          ‘serial-term’の呼び出しにより、すでにオープン済みの接続にたい
          してのみ有効である。

     ‘:bytesize BYTESIZE’
          ビット/バイトでの数値で、7か8を指定できる。BYTESIZEが与えられ
          ない、または‘nil’の場合のデフォルトは8。

     ‘:parity PARITY’
          値には‘nil’(パリティなし)、シンボル‘odd’(奇数パリティ)、シンボ
          ル‘even’(偶数パリティ)を指定できる。PARITYが与えられない場合の
          デフォルトはパリティなし。

     ‘:stopbits STOPBITS’
          各バイトの送信を終了するために使用されるストップビットの数値。
          STOPBITSには1か2が可能。STOPBITSが与えられない、または‘nil’の
          場合のデフォルトは1。

     ‘:flowcontrol FLOWCONTROL’
          この接続にたいして使用するフロー制御のタイプで、‘nil’(フロー制
          御を使用しない)、シンボル‘hw’(RTS/CTSハードウェアフロー制御)、
          シンボル‘sw’(XON/XOFFソフトウェアフロー制御)のいずれか。
          FLOWCONTROLが与えられない場合のデフォルトは、フロー制御なし。

     シリアルポートの初期設定のために、‘make-serial-process’は内部的に
     ‘serial-process-configure’を呼び出す。


File: elisp,  Node: Byte Packing,  Prev: Serial Ports,  Up: Processes

36.20 Packing and Unpacking Byte Arrays
=======================================

このセクションでは、通常はバイナリーのネットワークプロトコル用のバイト配
列を、packおよびunpackする朴を説明します。以下の関数は、バイト配列と
alistとの間で相互に変換を行います。バイト配列はユニバイト文字列、または
整数ベクターとして表現することができます。一方alistはシンボルを固定サイ
ズのオブジェクト、または再帰的な複alistのいずれかに関連付けます。このセ
クションで参照する関数を使用するためには、‘bindat’ライブラリーをロードし
てください。

   バイト配列からネストされたalistへの変換は、逆方向への変換が“シリアラ
イズ化(serializing)”、または“pack化(packing)”として呼ばれることから、“非
シリアル化【deserializing)”、または“unpack化(unpacking)”として知られてい
ます。

* Menu:

* Bindat Spec::              データレイアウトの記述。
* Bindat Functions::         unpack化とpack化を行う。
* Bindat Examples::          bindat.elが行えることのサンプル。


File: elisp,  Node: Bindat Spec,  Next: Bindat Functions,  Up: Byte Packing

36.20.1 Describing Data Layout
------------------------------

unpackとpackを制御するためには、“データレイアウト仕様(data layout
specification)”を記述します。これは名前付きで、かつタイプ付けされた“フィ
ールド(field)”を記述する、特別なネスト化リストです。これは、処理する各フ
ィールドの長さ、およびそれをpackおよびunpackする方法を制御します。わたし
たちは、名前が‘-bindat-spec’で終わる変数では、bindatの仕様を遵守します。
この類の変数名は、自動的に“risky(危険)”だと認識されます。

   フィールドの“タイプ(type)”は、そのフィールドが表すオブジェクトのサイ
ズ(バイト単位)、およびそれがマルチバイトフィールドなら、そのフィールがバ
イトオーダーされる方法を記述します。可能なオーダーは“ビッグエンディアン
(big endian。ネットワークバイトオーダーとも呼ばれる)”、および“リトルエン
ディアン(little endian)”の2つです。たとえば数字‘#x23cd’(10進の9165)のビ
ッグエンディアンは‘#x23’ ‘#xcd’の2バイト、リトルエンディアンは‘#xcd’
‘#x23’になるでしょう。以下は可能なタイプの値です:

‘u8’
‘byte’
     長さ1の符号なしタイプ。

‘u16’
‘word’
‘short’
     長さ2の、ネットワークバイトオーダーによる符号なし整数。

‘u24’
     長さ3の、ネットワークバイトオーダーによる符号なし整数。

‘u32’
‘dword’
‘long’
     長さ4の、ネットワークバイトオーダーによる符号なし整数。注意: これら
     の値はEmacsの整数の実装に制限されるだろう。

‘u16r’
‘u24r’
‘u32r’
     それぞれ長さ2、3、4のリトルエンディアンオーダーによる符号なし整数。

‘str LEN’
     長さLENの文字列。

‘strz LEN’
     長さLENの固定長フィールド内の、NUL終端された文字列。

‘vec LEN [TYPE]’
     タイプTYPE(デフォルトはbyte)のLEN要素のベクター。TYPEは上述した単純
     なタイプのいずれか、あるいは‘(vec LEN [TYPE])’という形式のリストに
     よる別ベクターの指定である。

‘ip’
     インターネット 」アドレスを表す、4つのbyteのベクター。たとえば
     localhostは‘[127 0 0 1]’。

‘bits LEN’
     LENバイト内のセットされたビット位置のリスト。バイトはビッグエンディ
     アンで、ビット位置は‘8 * LEN − 1’で始まり0で終わるよう番号が付与さ
     れる。たとえば‘bits 2’では、‘#x28’ ‘#x1c’は‘(2 3 4 11 13)’、‘#x1c’
     ‘#x28’は‘(3 5 10 11 12)’にunpackされる。

‘(eval FORM)’
     FORMは、フィールドがpackまたはunpackされた瞬間に評価されるLisp式。
     評価した結果は、上記にリストしたタイプ使用のいずれかであること。

   固定長フィールドでは長さLENが、フィールド内のバイト数を指定する整数と
して与えられます。

   フィールド長が固定でない場合、通常は先行するフィールドの値に依存しま
す。この場合、長さLENは後述の‘bindat-get-field’のフォーマット指定により
“フィールド名(field name)”を指定するリスト‘(NAME ...)’、または式‘(eval
FORM)’(FORMはフィールド長を指定する整数に評価されること)のいずれかで与え
ることもできます。

   フィールド仕様は一般的に‘([NAME] HANDLER)’という形式をもち、NAMEはオ
プションです。紛らわしくなるので、タイプ仕様(上述)やハンドラー仕様(後述
)で意味をもつシンボルの名前は使用しないでください。NAMEはシンボルまたは
式‘(eval FORM)’でもよく、この場合FORMはシンボルに評価される必要がありま
す。

   HANDLERはそのフィールドがpackまたはunpackされる方法を記述し、以下のい
ずれかを指定できます:

‘TYPE’
     タイプ仕様TYPEに応じてこのフィールドのunpack/packを行う。

‘eval FORM’
     副作用のためだけにLisp式FORMを評価する。フィールド名が指定された場
     合、値はそのフィールド名にバインドされる。

‘fill LEN’
     LENバイトをスキップする。pack化ではそれらを未変更のままとし、通常そ
     れらは0のままとなることを意味する。unpack化では、それらが無視される
     ことを意味する。

‘align LEN’
     LENバイトの次の倍数にスキップする。

‘struct SPEC-NAME’
     副仕様(sub-specification)としてSPEC-NAMEを処理する。これは別の構造
     体内にネストされる構造体を記述する。

‘union FORM (TAG SPEC)...’
     Lisp式FORMを評価して、それにマッチする最初のTAGを探し、それに関連付
     けられたレイアウト仕様SPECを処理する。マッチングは以下の3つのいずれ
     かで発生し得る:

        • TAGが‘(eval EXPR)’という形式をもつ場合、変数‘tag’を動的に
          FORMの値にバインドして、EXPRを評価する。結果が非‘nil’ならマッ
          チを示す。

        • TAGがFORMの値と‘equal’ならマッチ。

        • TAGが‘t’なら無条件にマッチ。

‘repeat COUNT FIELD-SPECS...’
     FIELD-SPECSを順次、再帰的に処理した後、最初のものから繰り返して、す
     べての仕様全体をCOUNT回処理する。COUNTはフィールド長と同じフォーマ
     ットを使用して与えられる。‘eval’フォームが使用された場合は、1回だけ
     評価される。正しく処理されるには、FIELD-SPECS内の各仕様は名前を含ま
     なければならない。

   bindat仕様内で仕様される‘(eval FORM)’フォームでは、評価の間にFORMはこ
れらの動的にバインドされた変数へのアクセスと更新が可能である。

‘last’
     最後に処理されたフィールドの値。

‘bindat-raw’
     バイト配列のデータ。

‘bindat-idx’
     unpack化/pack化にたいする、(‘bindat-raw’での)カレントインデックス。

‘struct’
     これまでにunpackされた構造化データ、またはpackされた構造体全体を含
     むalist。この構造体の特定のフィールドにアクセスするために、
     ‘bindat-get-field’を使用できる。

‘count’
‘index’
     ‘repeat’ブロック内部では、これらは(COUNTパラメーターで指定された)繰
     り返しの最大回数、および(0から数えた)カレント繰り返し回数を含む。
     ‘count’を0にセットすることにより、カレントの繰り返し終了後に、最内
     繰り返しブロックを終了する。


File: elisp,  Node: Bindat Functions,  Next: Bindat Examples,  Prev: Bindat Spec,  Up: Byte Packing

36.20.2 Functions to Unpack and Pack Bytes
------------------------------------------

以降のドキュメントでは、SPECはデータレイアウト仕様、‘bindat-raw’はバイト
配列、STRUCTはunpackされたフィールドデータを表すalistを参照します。

 -- Function: bindat-unpack spec bindat-raw &optional bindat-idx
     この関数はユニバイト文字列、またはバイト配列‘bindat-raw’のデータを
     、SPECに▼応じてunpackする。これは通常はバイト配列の先頭からunpack化
     を開始するが、BINDAT-IDXが非‘nil’なら、それはかわりに使用する0基準
     の開始位置を指定する。

     値は、それぞれの要素がunpackされたフィールドを記述する、alistまたは
     ネストされたalist。

 -- Function: bindat-get-field struct &rest name
     この関数はネストされたalistであるSTRUCTから、フィールドのデータを選
     択する。STRUCTは通常、‘bindat-unpack’がリターンしたもの。NAMEが単一
     の引数に対応する場合、それはトップレベルのフィールド値を抽出するこ
     とを意味する。複数のNAME引数は、副構造体を繰り返して照合することを
     指定する。整数の名前は、配列のインデックスとして動作する。

     たとえばNAMEが‘(a b 2 c)’なら、それはフィールド‘a’の副フィールド
     ‘b’の3番目の要素内のフィールド‘c’(Cでは‘struct.a.b[2].c’に相当)を意
     味する。

   packまたはunpackの処理をすることにより、メモリー内でデータ構造が変化
しても、そのデータの全フィールド長の合計バイト数である、“トータル長
(total length)”は保たれます。この値は一般的に仕様またはalist単独では、固
有ではありません。そのかわり、これら両方の情報が、この計算に役立つのです
。同様に、unpackされる文字列や配列の長さは、仕様の記述にしたがい、そのデ
ータのトータル長より長くなるかもしれません。

 -- Function: bindat-length spec struct
     この関数はSTRUCT内のデータの、SPECに応じたトータル長をリターンする
     。

 -- Function: bindat-pack spec struct &optional bindat-raw bindat-idx
     この関数は、alist STRUCT内のデータから、SPECに応じてpackされたバイ
     ト配列をリターンする。これは通常、先頭から充填された、新たなバイト
     配列を作成する。しかしBINDAT-RAWが非‘nil’なら、それはpack先として事
     前に割り当てられたユニバイト文字列、またはベクターを指定する。
     BINDAT-IDXが非‘nil’なら、それは‘bindat-raw’へpackする開始オフセット
     を指定する。

     事前に割り当てる際には、out-of-rangeエラーを避けるために、‘(length
     BINDAT-RAW)’がトータル長またはそれ以上であることを確認すること。

 -- Function: bindat-ip-to-string ip
     インターネットアドレスのベクターIPを、通常のドット表記による文字列
     に変換する。

          (bindat-ip-to-string [127 0 0 1])
               ⇒ "127.0.0.1"


File: elisp,  Node: Bindat Examples,  Prev: Bindat Functions,  Up: Byte Packing

36.20.3 Examples of Byte Unpacking and Packing
----------------------------------------------

以下は、バイトにたいしてunpackおよびpackを行う完全な例です:

     (require 'bindat)

     (defvar fcookie-index-spec
       '((:version  u32)
         (:count    u32)
         (:longest  u32)
         (:shortest u32)
         (:flags    u32)
         (:delim    u8)
         (:ignored  fill 3)
         (:offset   repeat (:count) (:foo u32)))
       "fortuneクッキーのインデックスファイル内容")

     (defun fcookie (cookies &optional index)
       "ファイルCOOKIESからランダムなfortuneクッキーを表示する。
     オプションの第2引数INDEXは関連付けられるインデックス
     ファイル名を指定し、デフォルトは\"COOKIES.dat\"。
     バッファー\"*Fortune Cookie: BASENAME*\"内にクッキーを表示。
     BASENAMEはディレクトリー部分を除いたCOOKIES"
       (interactive "fCookies file: ")
       (let* ((info (with-temp-buffer
                      (insert-file-contents-literally
                       (or index (concat cookies ".dat")))
                      (bindat-unpack fcookie-index-spec
                                     (buffer-string))))
              (sel (random (bindat-get-field info :count)))
              (beg (cdar (bindat-get-field info :offset sel)))
              (end (or (cdar (bindat-get-field info
                                               :offset (1+ sel)))
                       (nth 7 (file-attributes cookies)))))
         (switch-to-buffer
          (get-buffer-create
           (format "*Fortune Cookie: %s*"
                   (file-name-nondirectory cookies))))
         (erase-buffer)
         (insert-file-contents-literally
          cookies nil beg (- end 3))))

     (defun fcookie-create-index (cookies &optional index delim)
       "ファイルCOOKIESをスキャンしてインデックスファイルに書き込む。
     オプション引数INDEXは、インデックスファイル名を指定。デフォルトは\"COOKIES.dat\"。
     オプション引数DELIMはユニバイト文字で、それがCOOKIES内
     のある行で見つかったら、その行はエントリー間の境界を示す。"
       (interactive "fCookies file: ")
       (setq delim (or delim ?%))
       (let ((delim-line (format "\n%c\n" delim))
             (count 0)
             (max 0)
             min p q len offsets)
         (unless (= 3 (string-bytes delim-line))
           (error "Delimiter cannot be represented in one byte"))
         (with-temp-buffer
           (insert-file-contents-literally cookies)
           (while (and (setq p (point))
                       (search-forward delim-line (point-max) t)
                       (setq len (- (point) 3 p)))
             (setq count (1+ count)
                   max (max max len)
                   min (min (or min max) len)
                   offsets (cons (1- p) offsets))))
         (with-temp-buffer
           (set-buffer-multibyte nil)
           (insert
            (bindat-pack
             fcookie-index-spec
             `((:version . 2)
               (:count . ,count)
               (:longest . ,max)
               (:shortest . ,min)
               (:flags . 0)
               (:delim . ,delim)
               (:offset . ,(mapcar (lambda (o)
                                     (list (cons :foo o)))
                                   (nreverse offsets))))))
           (let ((coding-system-for-write 'raw-text-unix))
             (write-file (or index (concat cookies ".dat")))))))

   以下は複雑な構造体を定義してunpackする例です。以下のようなCの構造体が
あるものとします:

     struct header {
         unsigned long    dest_ip;
         unsigned long    src_ip;
         unsigned short   dest_port;
         unsigned short   src_port;
     };

     struct data {
         unsigned char    type;
         unsigned char    opcode;
         unsigned short   length;  /* ネットワークバイトオーダー */
         unsigned char    id[8];   /* NUL終端文字列 */
         unsigned char    data[/* (length + 3) & ~3 */];
     };

     struct packet {
         struct header    header;
         unsigned long    counters[2];  /* リトルエンディアンオーダー */
         unsigned char    items;
         unsigned char    filler[3];
         struct data      item[/* items */];

     };

   対応するデータレイアウト仕様が以下です:

     (setq header-spec
           '((dest-ip   ip)
             (src-ip    ip)
             (dest-port u16)
             (src-port  u16)))

     (setq data-spec
           '((type      u8)
             (opcode    u8)
             (length    u16)  ; ネットワークバイトオーダー
             (id        strz 8)
             (data      vec (length))
             (align     4)))

     (setq packet-spec
           '((header    struct header-spec)
             (counters  vec 2 u32r)   ; リトルエンディアンオーダー
             (items     u8)
             (fill      3)
             (item      repeat (items)
                        (struct data-spec))))

   バイナリーデータによる表現は:

     (setq binary-data
           [ 192 168 1 100 192 168 1 101 01 28 21 32
             160 134 1 0 5 1 0 0 2 0 0 0
             2 3 0 5 ?A ?B ?C ?D ?E ?F 0 0 1 2 3 4 5 0 0 0
             1 4 0 7 ?B ?C ?D ?E ?F ?G 0 0 6 7 8 9 10 11 12 0 ])

   対応するデコードされた構造体は:

     (setq decoded (bindat-unpack packet-spec binary-data))
          ⇒
     ((header
       (dest-ip   . [192 168 1 100])
       (src-ip    . [192 168 1 101])
       (dest-port . 284)
       (src-port  . 5408))
      (counters . [100000 261])
      (items . 2)
      (item ((data . [1 2 3 4 5])
             (id . "ABCDEF")
             (length . 5)
             (opcode . 3)
             (type . 2))
            ((data . [6 7 8 9 10 11 12])
             (id . "BCDEFG")
             (length . 7)
             (opcode . 4)
             (type . 1))))

   以下はこの構造体からデータを取得する例です:

     (bindat-get-field decoded 'item 1 'id)
          ⇒ "BCDEFG"


File: elisp,  Node: Display,  Next: System Interface,  Prev: Processes,  Up: Top

37 Emacs Display
****************

このチャプターでは、Emacsによるユーザーへのプレゼンテーションである、表
示に関連する機能のいくつかを説明します。

* Menu:

* Refresh Screen::           スクリーン上にあるすべてのもののクリアーと再描画。
* Forcing Redisplay::        再描画の強制。
* Truncation::               長いテキストの折り畳みと折り返し。
* The Echo Area::            スクリーン最下部へのメッセージ表示。
* Warnings::                 ユーザーへの警告メッセージの表示。
* Invisible Text::           バッファーのテキストの一部を隠す。
* Selective Display::        バッファーのテキストの一部を隠す(旧来の方式)。
* Temporary Displays::       自動的に消える表示。
* Overlays::                 オーバーレイを使用したバッファーの一部のハイライト。
* Size of Displayed Text::   表示されたテキストの大きさ。
* Line Height::              行の高さの制御。
* Faces::                    テキスト文字のグラフィカルスタイル(フォント、カラー等)を定義するフェイス。
* Fringes::                  ウィンドウフリンジの制御。
* Scroll Bars::              垂直スクロールバーの制御。
* Window Dividers::          ウィンドウを視覚的に区別する。
* Display Property::         特別な表示機能の有効化。
* Images::                   Emacsバッファー内でのイメージ表示。
* Buttons::                  Emacsバッファー内へのイメージ表示クリック可能ボタン追加。
* Abstract Display::         オブジェクトコレクション用のEmacsウィジェット。
* Blinking::                 Emacsがマッチする開カッコを表示する方法。
* Character Display::        Emacsがマッチする個々の文字を表示する方法。
* Beeping::                  ユーザーへの可聴シグナル。
* Window Systems::           どのウィンドウシステムが使用されているか。
* Bidirectional Display::    アラビア語やペルシア語のような、双方向スクリプトの表示。


File: elisp,  Node: Refresh Screen,  Next: Forcing Redisplay,  Up: Display

37.1 Refreshing the Screen
==========================

関数‘redraw-frame’は、与えられたフレーム(*note Frames::を参照)のコンテン
ツ全体にたいして、クリアーおよび再描画を行います。これはスクリーンが壊れ
ている(corrupted)場合に有用です。

 -- Function: redraw-frame frame
     この関数は、フレームFRAMEのクリアーと再描画を行う。

   更に強力なのが‘redraw-display’です:

 -- Command: redraw-display
     この関数は、すべての可視なフレームのクリアーと再描画を行う。

   Emacsでは、ユーザー入力は再描画より優先されます。入力が可能なときにこ
れらの関数を呼び出すと、これらはすぐに再描画はしませんが、要求された再描
画はやがて、すべての入力処理後に行われます。

   テキスト端末では、Emacsのサスペントと再開により、通常はスクリーンのリ
フレッシュも行われます。Emacsのようなディスプレイ指向のプログラムと、通
常のシーケンシャル表示のプログラムで、コンテンツを区別して記録する端末エ
ミュレーターがいくつかあります。そのような端末を使用する場合は、おそらく
再開時の再表示を抑制したいでしょう。

 -- User Option: no-redraw-on-reenter
     この変数は、Emacsがサスペンドおよび再開された後に、スクリーン全体を
     再描画するかどうかを制御する。非‘nil’なら再描画は不要、‘nil’なら再
     描画が必要であることを意味する。デフォルトは‘nil’。


File: elisp,  Node: Forcing Redisplay,  Next: Truncation,  Prev: Refresh Screen,  Up: Display

37.2 Forcing Redisplay
======================

Emacsは入力の待機時は常に、再表示を試みます。以下の関数により、実際に入
力を待機することなく、Lispコードの中から、即座に再表示を試みることを要求
できます。

 -- Function: redisplay &optional force
     この関数は、即座に再表示を試みる。オプション引数FORCEが非‘nil’なら
     、入力が保留中に横取りされるかわりに、強制的に再表示が行われる。

     この関数は実際に再表示が試行されたなら‘t’、それ以外は‘nil’をリター
     ンする。‘t’という値は、再表示の試行が完了したことを意味しない。新た
     に到着した入力に横取りされた可能性がある。

 -- Variable: pre-redisplay-function
     再表示の直前に実行される関数。これは、再表示されるウィンドウセット
     を単一の引数として呼び出される。

   ‘redisplay’が即座に再表示を試みたとしても、Emacsがフレーム(複数可)の
どの部分を再表示するか決定する方法を変更するわけではありません。それとは
対照的に、以下の関数は特定のウィンドウを(あたかもコンテンツが完全に変更
されたかのように)、保留中の再表示処理に追加します。しかし再描画を即座に
は試みません。

 -- Function: force-window-update &optional object
     この関数は、Emacsが次に再表示を行う際にいくつか、あるいはすべてのウ
     ィンドウが更新されるよう強制する。OBJECTがウィンドウならそのウィン
     ドウ、バッファーまたはバッファー名ならそのバッファーを表示するすべ
     てのウィンドウ、‘nil’(または省略)の場合はすべてのウィンドウが更新さ
     れる。

     この関数は、即座に再表示を行わない。再表示はEmacsが入力を待機時、ま
     たは関数‘redisplay’呼び出し時に行われる。


File: elisp,  Node: Truncation,  Next: The Echo Area,  Prev: Forcing Redisplay,  Up: Display

37.3 Truncation
===============

テキスト行がウィンドウ右端を超過する際、Emacsはその行を“継続
(continue)”させる(次のスクリーン行へ“wrap”、すなわち折り返す)か、あるい
はその行を“切り詰める(truncate)”て表示(その行をスクリーン行の1行に制限
)することができます。長いテキスト行を表示するために使用される追加のスク
リーン行は、“継続(continuation)”行と呼ばれます。継続はフィルとは異なりま
す。継続はバッファーのコンテンツ内ではなくスクリーン上でのみ発生し、単語
境界ではなく正確に右マージンで行をブレークします。*note Filling::を参照
してください。

   グラフィカルなディスプレイでは、切り詰めと継続はウィンドウフリンジ内
の小さな矢印イメージで示されます(*note Fringes::を参照)。テキスト端末で
は、切り詰めはそのウィンドウの最右列の‘$’、“折り返し”は最右列の‘\’で示さ
れます(ディスプレイテーブルにより、これを行うための代替え文字を指定でき
る。*note Display Tables::を参照されたい)。

 -- User Option: truncate-lines
     このバッファーローカル変数が非‘nil’なら、ウィンドウ右端を超過する行
     は切り詰められ、それ以外なら継続される。特別な例外として、“部分幅
     (partial-width)”ウィンドウ(フレーム全体の幅を占有しないウィンドウ
     )では、変数‘truncate-partial-width-windows’が優先される。

 -- User Option: truncate-partial-width-windows
     この変数は、“部分幅(partial-width)”ウィンドウ内の、行の切り詰めを制
     御する。部分幅ウィンドウとは、フレーム全体の幅を占有しないウィンド
     ウである(*note Splitting Windows::を参照)。値が‘nil’なら、行の切り
     詰めは変数‘truncate-lines’(上記参照)により決定される。値が整数Nの場
     合は、部分幅ウィンドウの列数がNより小さければ、‘truncate-lines’の値
     とは無関係に行は切り詰められ、部分幅ウィンドウの列数がN以上なら、行
     の切り詰めは‘truncate-lines’により決定される。それ以外の非‘nil’値で
     は、‘truncate-lines’の値とは無関係にすべての部分幅ウィンドウで行は
     切り詰められる。

   ウィンドウ内で水平スクロール(*note Horizontal Scrolling::を参照)を使
用中は、切り詰めが強制されます。

 -- Variable: wrap-prefix
     このバッファーローカル変数が非‘nil’なら、それはEmacsが各継続行の先
     頭に表示する、“折り返しプレフィックス(wrap prefix)”を定義する(行を
     切り詰めている場合、‘wrap-prefix’は使用されない)。この値は文字列、
     イメージ(*note Other Display Specs::を参照)、またはディスプレイプロ
     パティ‘:width’や‘:align-to’で指定されるような、伸長された空白文字を
     指定できる(*note Specified Space::を参照)。値はテキストプロパティ
     ‘display’と同じ方法で解釈される。*note Display Property::を参照のこ
     と。

     折り返しプレフィックスは、テキストプロパティまたはオーバーレイプロ
     パティ‘wrap-prefix’を使用することにより、テキストのリージョンにたい
     して指定することもできる。これは‘wrap-prefix’変数より優先される。
     *note Special Properties::を参照のこと。

 -- Variable: line-prefix
     このバッファーローカル変数が非‘nil’なら、それはEmacsがすべての非継
     続行の先頭に表示する、“行プレフィックス(line prefix)”を定義する。こ
     の値は文字列、イメージ(*note Other Display Specs::を参照)、またはデ
     ィスプレイプロパティ‘:width’や‘:align-to’で指定されるような、伸長さ
     れた空白文字を指定できる(*note Specified Space::を参照)。値はテキス
     トプロパティ‘display’と同じ方法で解釈される。*note Display
     Property::を参照のこと。

     行プレフィックスは、テキストプロパティまたはオーバーレイプロパティ
     ‘line-prefix’を使用することにより、テキストのリージョンにたいして指
     定することもできる。これは‘line-prefix’変数より優先される。*note
     Special Properties::を参照のこと。


File: elisp,  Node: The Echo Area,  Next: Warnings,  Prev: Truncation,  Up: Display

37.4 The Echo Area
==================

“エコーエリア(echo area)”はエラーメッセージ(*note Errors::)や、
‘message’プリミティブで作成されたメッセージの表示、およびキーストローク
をエコーするために使用されます。(アクティブ時には)ミニバッファーがスクリ
ーン上のエコーエリアと同じ場所に表示されるという事実にも関わらず、エコー
エリアはミニバッファーと同じではありません。*note The Minibuffer:
(emacs)Minibuffer.を参照してください。

   このセクションに記述された関数とは別に、出力ストリームとして‘t’を指定
することにより、エコーエリアにLispオブジェクトをプリントできます。*note
Output Streams::を参照してください。

* Menu:

* Displaying Messages::      エコーエリア内に明示的にテキストを表示する。
* Progress::                 長時間の処理の進行状況をユーザーに知らせる。
* Logging Messages::         ユーザー用にログされるエコーエリアメッセージ。
* Echo Area Customization::  エコーエリアの制御。


File: elisp,  Node: Displaying Messages,  Next: Progress,  Up: The Echo Area

37.4.1 Displaying Messages in the Echo Area
-------------------------------------------

このセクションでは、エコーエリア内にメッセージを表示する、標準的な関数を
説明します。

 -- Function: message format-string &rest arguments
     この関数は、エコーエリア内にメッセージを表示する。‘format’関数
     (*note Formatting Strings::を参照)の場合と同様、FORMAT-STRINGはフォ
     ーマット文字列、ARGUMENTSはそのフォーマット仕様にたいするオブジェク
     トである。フォーマットされた結果文字列は、エコーエリア内に表示され
     る。それに‘face’テキストプロパティが含まれる場合、指定されたフェイ
     スにより表示される(*note Faces::を参照)。この文字列は‘*Messages*’バ
     ッファーにも追加されるが、テキストプロパティは含まれない(*note
     Logging Messages::を参照)。

     バッチモードでは、後に改行が付加されたメッセージが、標準エラースト
     リームにプリントされる。

     FORMAT-STRINGが‘nil’か空文字列なら、‘message’はエコーエリアをクリア
     ーする。エコーエリアが自動的に拡張されていたら、これにより通常のサ
     イズに復元される。ミニバッファーがアクティブなら、これによりスクリ
     ーン上に即座にミニバッファーのコンテンツが復元される。

          (message "Minibuffer depth is %d."
                   (minibuffer-depth))
           ⊣ Minibuffer depth is 0.
          ⇒ "Minibuffer depth is 0."

          ---------- Echo Area ----------
          Minibuffer depth is 0.
          ---------- Echo Area ----------

     エコーエリアやポップバッファー内に、自動的にメッセージを表示するに
     は、そのサイズに応じて‘display-message-or-buffer’(以下参照)を使用す
     る。

 -- Macro: with-temp-message message &rest body
     この構成はBODY実行の間、エコーエリア内にメッセージを一時的に表示す
     る。これはMESSAGEを表示してBODYを実行し、それからエコーエリアの前の
     コンテンツをリストアするとともに、bodyの最後のフォームの値をリター
     ンする。

 -- Function: message-or-box format-string &rest arguments
     この関数は‘message’と同様にメッセージを表示するが、エコーエリアでは
     なくダイアログボックスにメッセージを表示するかもしれない。この関数
     があるコマンド内からマウスを使用して呼び出された場合 — より正確には
     ‘last-nonmenu-event’(*note Command Loop Info::を参照)が‘nil’かリス
     トなら、そのメッセージの表示にダイアログボックスまたはポップアップ
     メニューを使用する。それ以外の場合は、エコーエリアを使用する(これは
     ‘y-or-n-p’が同様の決定を行う際に使用する条件と同じである。*note
     Yes-or-No Queries::を参照されたい)。

     呼び出しの前後で‘last-nonmenu-event’を適切な値にバインドすることに
     より、エコーエリアでのマウスの使用を強制できる。

 -- Function: message-box format-string &rest arguments
     この関数は‘message’と同様にメッセージを表示するが、利用可能なら常に
     ダイアログボックス(かポップアップメニュー)を使用する。端末がサポー
     トしないために、ダイアログボックスまたはポップアップメニューが使用
     できなければ、‘message-box’は‘message’と同様にエコーエリアを使用す
     る。

 -- Function: display-message-or-buffer message &optional buffer-name
          not-this-window frame
     この関数はメッセージMESSAGEを表示する。MESSAGEは文字列かバッファー
     を指定できる。これが‘max-mini-window-height’で定義されるエコーエリ
     アの最大高さより小さければ、‘message’を使用してエコーエリアに表示さ
     れる。それ以外なら、メッセージを表示するために‘display-buffer’はポ
     ップアップバッファーを使用する。

     エコーエリアに表示したメッセージ、またはポップアップバッファー使用
     時はその表示に使用したウィンドウをリターンする。

     MESSAGEが文字列なら、オプション引数BUFFER-NAMEはポップアップバッフ
     ァー使用時にメッセージ表示に使用するバッファー名(デフォルトは
     ‘*Message*’)である。MESSAGEが文字列でエコーエリアに表示されてる場合
     は、いずれにせよコンテンツをバッファーに挿入するかどうかは指定され
     ない。

     オプション引数NOT-THIS-WINDOWとFRAMEは、‘display-buffer’の場合と同
     様に、バッファーが表示されている場合のみ使用される。

 -- Function: current-message
     この関数は、エコーエリア内にカレントで表示されているメッセージ、ま
     たはそれが存在しなければ‘nil’をリターンする。


File: elisp,  Node: Progress,  Next: Logging Messages,  Prev: Displaying Messages,  Up: The Echo Area

37.4.2 Reporting Operation Progress
-----------------------------------

処理の完了まで暫く時間を要するかもしれない際は、その進行状況についてユー
ザーに通知するべきです。これによりユーザーが残り時間を予測するとともに、
Emacsがhungしているのではなく、処理中であえうことが明確に確認できます。
“プログレスリポーター(progress reporter: 進行状況リポーター)”を使用する
のが、これを行う便利な方法です。

   以下は、何も有用なことを行わない、実行可能な例です:

     (let ((progress-reporter
            (make-progress-reporter "Collecting mana for Emacs..."
                                    0  500)))
       (dotimes (k 500)
         (sit-for 0.01)
         (progress-reporter-update progress-reporter k))
       (progress-reporter-done progress-reporter))

 -- Function: make-progress-reporter message &optional min-value
          max-value current-value min-change min-time
     この関数は、以下に挙げる他の関数として使用されるであろう、プログレ
     スリポーターオブジェクトを作成して、リターンする。これはプログレス
     リポーターを高速にするように、可能なかぎり多くのデータを事前に計算
     するというアイデアが元である。

     この後にこのプログレスリポーターを使用する際は、進行状況のパーセン
     テージを後に付加してMESSAGEが表示されるだろう。MESSAGEは、単なる文
     字列として扱われる。たとえばファイル名に依存させる必要があるなら、
     この関数の呼び出し前に、‘format’を使えばよい。

     引数MIN-VALUEとMAX-VALUEは、その処理の開始と終了を意味する数値であ
     ること。たとえばバッファーを“スキャン”する処理なら、これらをそれぞ
     れ‘point-min’と‘point-max’にセットするべきだろう。MAX-VALUEは
     MIN-VALUEより大であること。

     かわりに、MIN-VALUEとMAX-VALUEを‘nil’にセットすることができる。この
     場合、プログレスリポーターは進行状況のパーセンテージを報告しない。
     かわりにプログレスリポーターを更新するたびに刻み(notch)を回転する
     “スピナー(spinner)”を表示する。

     MIN-VALUEとMAX-VALUEが数値なら、進行状況の初期の数値を与える引数
     CURRENT-VALUEを与えることができる。省略時のデフォルトはMIN-VALUE。

     残りの引数は、エコーエリアの更新レートを制御する。プログレスリポー
     ターは次のメッセージを表示する前に、その処理が少なくとも
     MIN-CHANGEパーセントより多く完了するまで待機する。デフォルトは1パー
     セント。MIN-TIMEは連続するプリントの間に空ける最小時間をミリ秒単位
     で指定する(いくつかのオペレーティングシステムでは、プログレスリポー
     ターは秒の少数部をさまざまな制度で処理するかもしれない)。

     この関数は‘progress-reporter-update’を呼び出すた、最初のメッセージ
     は即座にプリントされる。

 -- Function: progress-reporter-update reporter &optional value
     この関数は、操作の進行状況報告に関する、主要な機能を担う。これは
     REPORTERのメッセージと、その後にVALUEにより決定された進行状況のパー
     センテージを表示する。パーセンテージが0、または引数MIN-CHANGEと
     MIN-TIMEに比べて十分0に近ければ、出力は省略される。

     REPORTERは、‘make-progress-reporter’呼び出しがリターンした結果でな
     ければならない。VALUEは処理のカレント状況を指定し、
     ‘make-progress-reporter’に渡されたMIN-VALUEとMAX-VALUEの間(両端を含
     む)でなければならない。たとえばバッファーのスキャンにおいては、
     VALUEは‘point’び呼び出し結果であるべきだろう。

     この関数は‘make-progress-reporter’に渡されたMIN-CHANGEとMIN-TIMEに
     したがい、毎回の呼び出しで新たなメッセージを出力しない。したがって
     これは非常に高速であり、通常はこれを呼び出す回数を減らすことを試み
     るべきではない。結果として生じるオーバーヘッドは、あなたの努力をほ
     ぼ否定するだろう。

 -- Function: progress-reporter-force-update reporter &optional value
          new-message
     この関数は‘progress-reporter-update’と同様だが、これは無条件にメッ
     セージをエコーエリアにプリントする点が異なる。

     最初の2つの引数は、‘progress-reporter-update’の場合と同じ意味をもつ
     。オプションのNEW-MESSAGEで、REPORTERのメッセージを変更できる。この
     関数は常にエコーエリアを更新するので、そのような変更は即座にユーザ
     ーに示されるだろう。

 -- Function: progress-reporter-done reporter
     この関数は、処理の完了時に呼び出されるべきである。これはエコーエリ
     ア内に、単語“done”が付加されたREPORTERのメッセージを表示する。

     あなたは‘progress-reporter-update’に“100%”とプリントさせようとせず
     、常にこの関数を呼び出すべきである。まず、この関数は決してそれをプ
     リントしないだろうし、これが発生しないために多くの正当な理由がある
     。次に“done”はより自明である。

 -- Macro: dotimes-with-progress-reporter (var count [result]) message
          body...
     これは‘dotimes’と同じ方法で機能するが、上述の関数を使用してループ進
     行状況(loop progress)の報告も行う、便利なマクロである。これにより、
     タイプ量を幾分節約できる。

     以下の方法でこのマクロを使用することにより、このセクション冒頭の例
     を書き換えることができる:

          (dotimes-with-progress-reporter
              (k 500)
              "Collecting some mana for Emacs..."
            (sit-for 0.01))


File: elisp,  Node: Logging Messages,  Next: Echo Area Customization,  Prev: Progress,  Up: The Echo Area

37.4.3 Logging Messages in ‘*Messages*’
---------------------------------------

エコーエリア内に表示されるほとんどすべてのメッセージは、ユーザーが後で参
照できるように、‘*Messages*’バッファー内にも記録されます。これには
‘message’により出力されたメッセージも含まれます。デフォルトではこのバッ
ファーは読み取り専用で、メジャーモード‘messages-buffer-mode’を使用します
。ユーザーによる‘*Messages*’バッファーのkillを妨げるものは何もありません
が、次回のメッセージ表示でバッファーは再作成されます。‘*Messages*’バッフ
ァーに直接アクセスする必要があり、それが確実に存在するようにしたいLispコ
ードはすべて、関数‘messages-buffer’を使用するべきです。

 -- Function: messages-buffer
     この関数は、‘*Messages*’バッファーをリターンする。バッファーが存在
     しなければ作成して、そのバッファーを‘messages-buffer-mode’に切り替
     える。

 -- User Option: message-log-max
     この変数は、‘*Messages*’バッファー内に保持するべき行数を指定する。
     値‘t’は保持すべき行数に制限がないことを意味し、値‘nil’はメッセージ
     のロギングを完全に無効にする。以下は、メッセージを表示して、それが
     ロギングされることを防ぐ例である:

          (let (message-log-max)
            (message ...))

   ‘*Messages*’にたいするユーザーの利便性を向上させるために、ロギング機
能は連続する同じメッセージを結合します。さらに、2つのケースのために連続
する関連メッセージの結合も行います。2つのケースとは、応答を後にともなう
質問(question followed by answer)と、一連のプログレスメッセージ(series
of progress messages)です。

   “応答を後にともなう質問(question followed by an answer)”とは、
‘y-or-n-p’により生成されるような、これは1つ目が‘QUESTION’、2つ目が
‘QUESTION...ANSWER’のような、2つのメッセージです。1つ目のメッセージには
、2つ目のメッセージ以上の追加の情報は伝えないので、2つ目のメッセージをロ
ギングして、1つ目のメッセージは破棄します。

   “一連のプログレスメッセージ(series of progress messages)”とは、
‘make-progress-reporter’が生成するような、連続するメッセージを意味します
。これらは‘BASE...HOW-FAR’のような形式をもち、HOW-FARは毎回異なりますが
、BASEは常に同じです。このシリーズ内の各メッセージのロギングでは、そのメ
ッセージが前のメッセージと連続していれば、前のメッセージを破棄します。

   関数‘make-progress-reporter’および‘y-or-n-p’は、メッセージログ結合機
能をアクティブにするために、何ら特別なことを行う必要はありません。これは
‘...’で終わる共通のプレフィックスを共有する、連続する2つのメッセージをロ
グする際は、常にこの処理を行います。

