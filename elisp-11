This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Char Classes,  Next: Regexp Backslash,  Prev: Regexp Special,  Up: Syntax of Regexps

33.3.1.2 Character Classes
..........................

以下は文字候補内で使用できるクラスと、その意味についての
テーブルです:

‘[:ascii:]’
     これは任意のASCII文字(コード0 – 127)にマッチする。
‘[:alnum:]’
     これは任意のアルファベットと数字にマッチする(現在の
     ところマルチバイト文字にたいしては、単語構文をもつ
     ものすべてにマッチする)。
‘[:alpha:]’
     これは任意のアルファベットにマッチする(現在のところ
     マルチバイト文字にたいしては、単語構文をもつものす
     べてにマッチする)。
‘[:blank:]’
     これはスペースとタブだけにマッチする。
‘[:cntrl:]’
     これはASCII制御文字にマッチする。
‘[:digit:]’
     これは‘0’から‘9’までにマッチする。つまり
     ‘[-+[:digit:]]’は‘+’と‘-’同様、任意の数にマッチする
     。
‘[:graph:]’
     これはグラフィック文字(ASCII制御文字、スペース、
     delete文字を除くすべての文字)を意味する。
‘[:lower:]’
     これはカレントの大文字小文字テーブル(*note Case
     Tables::を参照)で小文字と判断される文字すべてにマッ
     チする。‘case-fold-search’が非‘nil’なら、これは大文
     字にもマッチする。
‘[:multibyte:]’
     これは任意のマルチバイト文字にマッチする(*note Text
     Representations::を参照)。
‘[:nonascii:]’
     これは非ASCII文字にマッチする。
‘[:print:]’
     これはプリント文字(ASCII制御文字とdelete文字以外の
     すべての文字)にマッチする。
‘[:punct:]’
     これは任意の句読点文字(punctuation character)にマッ
     チする(現在のところマルチバイト文字にたいしては、単
     語構文以外のすべてにマッチする)。
‘[:space:]’
     これは空白文字構文(*note Syntax Class Table::を参照
     )をもつ任意の文字にマッチする。
‘[:unibyte:]’
     これは任意のユニバイト文字(*note Text
     Representations::を参照)にマッチする。
‘[:upper:]’
     これはカレントの大文字小文字テーブル(*note Case
     Tables::を参照)で大文字と判断される文字すべてにマッ
     チする。‘case-fold-search’が非‘nil’なら、これは小文
     字にもマッチする。
‘[:word:]’
     これは単語構文(*note Syntax Class Table::を参照)を
     もつ任意の文字にマッチする。
‘[:xdigit:]’
     これは16進数の数字‘0’から‘9’、‘a’から‘f’と‘A’から
     ‘F’にマッチする。


File: elisp,  Node: Regexp Backslash,  Prev: Char Classes,  Up: Syntax of Regexps

33.3.1.3 Backslash Constructs in Regular Expressions
....................................................

ほとんどの場合、‘\’の後の任意の文字は、その文字だけにマ
ッチします。しかし、例外もいくつかあります。‘\’で始まる
特定のシーケンスには、特別な意味をもつものがあります。以
下は特別な‘\’構成要素のテーブルです。

‘\|’
     これは選択肢を指定する。2つの正規表現AとB、その間に
     ある‘\|’により、AまたはBのいずれかにマッチする表現
     が形成される。

     つまり‘foo\|bar’は、‘foo’か‘bar’のいずれかにマッチ
     し、他の文字列にはマッチしない。

     ‘\|’は周囲の適用可能な最大の表現に適用される。
     ‘\|’を取り囲む‘\( ... \)’でグループ化することにより
     、グループ化の効力を制限できる。

     複数の‘\|’の処理するための、完全なバックトラッキン
     グ互換が必要なら、POSIX正規表現関数を使用すること
     (*note POSIX Regexps::を参照)。

‘\{M\}’
     これは、前のパターンを正確にM回繰り返す、後置演算子
     である。つまり‘x\{5\}’は文字列‘xxxxx’にマッチし、そ
     れ以外にはマッチしない。‘c[ad]\{3\}r’は‘caaar’、
     ‘cdddr’、‘cadar’等にマッチする。

‘\{M,N\}’
     これは最小でM回、最大でN回繰り返す、より一般的な後
     置演算子である。M省略時の最小は0、N省略時の最大は存
     在しない。

     たとえば‘c[ad]\{1,2\}r’は文字列‘car’、‘cdr’、
     ‘caar’、‘cadr’、‘cdar’、‘cddr’にマッチし、それ以外
     にはマッチしない。
     ‘\{0,1\}’または‘\{,1\}’は、‘?’と同じ。
     ‘\{0,\}’または‘\{,\}’は‘*’と同じ。
     ‘\{1,\}’は‘+’と同じ。

‘\( ... \)’
     これは、以下の3つの目的を果たす役目をもつグループ化
     構成要素である:

       1. 他の操作のために、一連の‘\|’選択肢を囲う。つま
          り正規表現‘\(foo\|bar\)x’は、‘foox’か‘barx’の
          いずれかにマッチする。

       2. 後置演算子‘*’、‘+’、‘?’による複雑な表現を囲う
          。つまり‘ba\(na\)*’は‘ba’、‘bana’、‘banana’、
          ‘bananana’、...等、任意の数(0以上の文字列
          ‘na’にマッチする。

       3. ‘\DIGIT’(以下参照)による将来の参照にたいして、
          マッチする部分文字列を記録する。

     この最後の目的は、カッコによるグループ化というアイ
     デアによるものではない。これは同じ構成要素‘\( ...
     \)’である2つ目の目的に割当てられた別の機能だが、実
     際のところ2つの意味は衝突しない。しかし稀に衝突が発
     生することがあり、それが内気(shy)なグループの導入を
     もたらした。

‘\(?: ... \)’
     これは“内気なグループ(shy group)”の構成要素である。
     内気なグループは通常のグループの最初の2つの役目(他
     の演算子のネスト制御)を果たすが、これは番号を取得せ
     ず‘\DIGIT’でその値を後方参照できない。内気なグルー
     プは、通常の内気でないグループを変更することなく自
     動的に追加できるので、機械的に正規表現を構築するの
     に、特に適している。

     内気なグループ化は、“非キャプチャリング
     (non-capturing)”、あるいは“番号なしグループ
     (unnumbered groups)”とも呼ばれる。

‘\(?NUM: ... \)’
     これは“明示的番号付きグループ(explicitly numbered
     group)”の構成要素である。通常のグループ化では、位置
     をもとに番号が暗黙で取得されるが、これが不便な場合
     もあるだろう。この構成要素により、特定のグループに
     番号を強制できる。番号の付与に特別な制限はなく、複
     数のグループに同じ番号を付与でき、その場合は最後の
     1つがマッチ(もっとも右のマッチ)が採用される。暗黙的
     に番号付けされたグループは常に、前のグループより大
     きい最小の整数となる番号を取得する。

‘\DIGIT’
     これはグループ構成要素(‘\( ... \)’)の、DIGIT番目に
     マッチしたテキストと同じテキストにマッチする。

     他の言い方をすると、最後のグループの後に、マッチ処
     理はそのグループによりマッチされたテキストの開始と
     終了を記憶する。その正規表現の先の箇所で、‘\’とその
     後にDIGITを使用すれば、それが何であれ同じテキストに
     マッチさせることができる。

     検索またはマッチングを行う関数に渡される、正規表現
     全体の中で最初の9つのグループ化構成要素にマッチする
     文字列には、その正規表現内で開きカッコが出現する順
     に1から9までの番号が割り当てられる。したがって
     ‘\1’から‘\9’までを使用して、対応するグループ化構成
     要素によりマッチされたテキストを参照できる。

     たとえば‘\(.*\)\1’は、一方がもう一方と等しいような
     2つの文字列から構成される、改行を含まない任意の文字
     列にマッチする。‘\(.*\)’は前半分にマッチし、これは
     何でもよいが、それに続く‘\1’はそれと同じテキストに
     正確にマッチしなければならない。

     構成要素‘\( ... \)’が2回以上マッチする場合(これはた
     とえば後に‘*’をしたがえるとき発生し得る)は、最後の
     マッチだけが記録される。

     正規表現内の特定のグループ化構成要素がマッチしなか
     った場合、たとえばそれが使用されない選択肢内にあっ
     たり、回数が0回の繰り返しの内部にあるなら、それに対
     応する‘\DIGIT’構成は何にもマッチしない。人工的な例
     を用いると、‘\(foo\(b*\)\|lose\)\2’は‘lose’にマッチ
     できない。外側のグループ内の2つ目の選択肢がマッチす
     るものの、‘\2’が未定義となり、何にたいしてもマッチ
     できない。しかし‘foobb’にたいしては、1つ目の選択肢
     が‘foob’にマッチし、‘\2’が‘b’にマッチするので、マッ
     チが可能になる。

‘\w’
     これは任意の単語構成文字にマッチする。エディターの
     構文テーブルが、どの文字が単語構成文字かを決定する
     。*note Syntax Tables::を参照のこと。

‘\W’
     これは任意の非単語構成文字にマッチする。

‘\sCODE’
     これは、構文がCODEであるような任意の文字にマッチす
     る。ここでCODEは、構文コードを表す文字である。‘w’は
     単語構成要素、‘-’は空白文字、‘(’は開きカッコ、等で
     ある。空白文字構文を表すには、‘-’かスペース文字のい
     ずれかを使用する。構文コードと、それらを意味する文
     字のリストは、*note Syntax Class Table::を参照され
     たい。

‘\SCODE’
     これは、構文がCODEでないような任意の文字にマッチす
     る。

‘\cC’
     これは、カテゴリーがCであるような任意の文字にマッチ
     する。ここでCは、カテゴリーを表す文字である。つまり
     標準カテゴリーテーブルで、‘c’はChinese(中国語)、
     ‘g’はGreek(ギリシャ語)の文字となる。‘M-x
     describe-categories <RET>’で現在定義済みの全カテゴ
     リーのリストを確認できる。‘define-category’関数を使
     用すれば、標準カテゴリーに加えて、カテゴリーを独自
     に定義することもできる(*note Categories::を参照)。

‘\CC’
     これは、カテゴリーがCではない任意の文字にマッチする
     。

   以下は、空文字列にマッチ(つまり文字を何も消費しない
)しますが、マッチするかどうかはコンテキストに依存するよ
うな正規表現を構築します。これらすべてにたいして、そのバ
ッファーのアクセス可能範囲の先頭と終端は、あたかもそのバ
ッファーの実際の先頭と終端のように扱われます。

‘\`’
     これは空文字列、ただしバッファー先頭、またはマッチ
     対象の文字列の先頭だけにマッチする。

‘\'’
     これは空文字列、ただしバッファー終端、またはマッチ
     対象の文字列の終端だけにマッチする。

‘\=’
     これは空文字列、ただしポイント位置だけにマッチする
     (この構成要素はマッチ対象が文字列なら定義されない
     )。

‘\b’
     これは空文字列、ただし単語の先頭だけにマッチする。
     つまり‘\bfoo\b’は、個別の単語として出現する‘foo’だ
     けにマッチする。‘\bballs?\b’は、個別の単語として
     ‘ball’または‘balls’にマッチする。

     ‘\b’は、隣接するテキストが何であるかと無関係に、バ
     ッファー(か文字列)の先頭または終端にマッチする。

‘\B’
     これは空文字列、単語の先頭や終端、またはバッファー
     (か文字列)の先頭や終端_以外_にマッチする。

‘\<’
     これは空文字列、ただし単語の先頭だけにマッチする。
     ‘\<’は、後に単語構成文字が続く場合のみ、バッファー
     (か文字列)の先頭にマッチする。

‘\>’
     これは空文字列、ただし単語の終端だけにマッチする。
     ‘\<’は、コンテンツが単語構成文字で終わる場合のみ、
     バッファー(か文字列)の終端にマッチする。

‘\_<’
     これは空文字列、ただしシンボルの先頭だけにマッチす
     る。シンボルとは1つ以上の単語かシンボル構成文字のシ
     ーケンスである。‘\_<’は、後にシンボル構成文字が続く
     場合のみ、バッファー(か文字列)の先頭にマッチする。

‘\_>’
     これは空文字列、ただし単語の終端だけにマッチする。
     ‘\_>’は、コンテンツがシンボル構成文字で終わる場合の
     み、バッファー(か文字列)の終端にマッチする。

   すべての文字列が、有効な正規表現な訳ではありません。
たとえば終端の‘]’がない文字選択肢ないで終わる文字列は無
効であり、単一の‘\’で終わる文字列も同様です。いずれかの
検索関数にたいして無効な正規表現が渡されると、
‘invalid-regexp’エラーがシグナルされます。


File: elisp,  Node: Regexp Example,  Next: Regexp Functions,  Prev: Syntax of Regexps,  Up: Regular Expressions

33.3.2 Complex Regexp Example
-----------------------------

以下は、後続の空白文字とともにセンテンスの終わりを認識す
るために、以前のEmacsで使用されていた、複雑な正規表現の
例です(現在のEmacsは、関数‘sentence-end’により構築される
、同様だがより複雑なregexpを使用する。*note Standard
Regexps::を参照されたい)。

   以下ではまず、(スペースとタブ文字を区別するために
)Lisp構文の文字列としてregexpを示し、それを評価した結果
を示します。文字列定数の開始と終了は、ダブルクォーテーシ
ョンです。‘\"’は文字列の一部としてのダブルクォーテーショ
ン、‘\\’は文字列の一部としてのバックスラッシュ、‘\t’はタ
ブ、‘\n’は改行を意味します。

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
          ⇒ "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
     ]*"

改行とタブは、それら自身として出力されます。

   この正規表現は連続する4つのパートを含み、以下のように
解読できます:

‘[.?!]’
     この正規表現の1つ目のパートはピリオド、疑問符、感嘆
     符の3つのうち、いずれか1つにマッチする文字選択肢で
     ある。マッチはこれら3つの文字のいずれかで開始されな
     ければならない(これは旧正規表現と、Emacsが使用する
     新たなデフォルトregexpが異なる1つのポイントである。
     新たな値は、後続の空白文字なすでセンテンスを終端す
     る、いくつかの非ASCII文字を許容する)。

‘[]\"')}]*’
     パターンの2つ目のパートは任意の0個以上の閉じカッコ
     およびクォーテーションマークで、後にピリオド、疑問
     符、感嘆符があるかもしれない。‘\"’は、文字列内での
     ダブルクォーテーションマークにたいするLisp構文であ
     る。最後の‘*’は、直前の正規表現(この場合は文字選択
     肢)の0回以上の繰り返しを示す。

‘\\($\\| $\\|\t\\|  \\)’
     パターンの3つ目のパートは、センテンスの後の空白文字
     、すなわち行の終端(スペースがあっても可)、タブ、ま
     たは2つのスペースにマッチする。2連バックスラッシュ
     はカッコと垂直バーを正規表現構文としてマークする。
     すなわちカッコはグループを句切り、垂直バーは選択肢
     を区別する。ダラー記号は行の終端へのマッチに使用さ
     れる。

‘[ \t\n]*’
     最後に、パターンの最終パートはセンテンスを終端させ
     るために必要とされる以上の、余分な空白文字にマッチ
     する。


File: elisp,  Node: Regexp Functions,  Prev: Regexp Example,  Up: Regular Expressions

33.3.3 Regular Expression Functions
-----------------------------------

以下の関数は、正規表現を扱います。

 -- Function: regexp-quote string
     この関数は、STRINGだけに正確にマッチするような正規
     表現をリターンする。‘looking-at’内でのこの正規表現
     の使用は、そのバッファー内の次の文字がSTRINGのとき
     だけ成功するだろう。検索関数でのこの正規表現の使用
     は、検索されるテキストがSTRINGを含むなら成功するだ
     ろう。*note Regexp Search::を参照のこと。

     これにより、その正規表現を求める関数呼び出し時に、
     正確な文字列マッチまたは検索を要求できる。

          (regexp-quote "^The cat$")
               ⇒ "\\^The cat\\$"

     正規表現として記述されたコンテキストにおいて、正確
     な文字列マッチを結合することが、‘regexp-quote’の1つ
     の使い方である。たとえば以下は空白文で囲まれた、
     STRINGの値であるような文字列を検索する:

          (re-search-forward
           (concat "\\s-" (regexp-quote string) "\\s-"))

 -- Function: regexp-opt strings &optional paren
     この関数は、リストSTRINGSの文字列だけにマッチする、
     効果的な正規表現をリターンする。これはマッチングや
     検索を可能な限り高速にする必要があるとき、たとえば
     Font Lockモードで有用である(1)。

     オプション引数PARENが非‘nil’なら、その正規表現は少
     なくとも1つのカッコによるグループ化構成要素に常に囲
     まれてリターンされる。PARENが‘words’なら、その構成
     要素は追加で‘\<’と‘\>’で囲まれ、PARENが‘symbols’な
     ら‘\_<’と‘\_>’で囲まれる(プログラミング言語のような
     文字列をマッチングする際は、‘symbols’が適切な場合が
     多々ある)。

     この単純化された‘regexp-opt’の定義は、実際の値と等
     価(だが同程度に効率的ではない)な正規表現を生成する:

          (defun regexp-opt (strings &optional paren)
            (let ((open-paren (if paren "\\(" ""))
                  (close-paren (if paren "\\)" "")))
              (concat open-paren
                      (mapconcat 'regexp-quote strings "\\|")
                      close-paren)))

 -- Function: regexp-opt-depth regexp
     この関数は、REGEXP内のグループ化された構成要素(カッ
     コで囲まれた正規表現)の総数をリターンする。これには
     内気なグループは含まれない(*note Regexp
     Backslash::を参照)。

 -- Function: regexp-opt-charset chars
     この関数は文字リストCHARS内の文字にマッチする正規表
     現をリターンする。

          (regexp-opt-charset '(?a ?b ?c ?d ?e))
               ⇒ "[a-e]"

   ---------- Footnotes ----------

   (1) ‘regexp-opt’の結果が絶対的にもっとも効率的である
という保証はないことに注意してください。手作業でチューニ
ングした正規表現のほうがわずかに効率的であることがときに
ありますが、これに努力する価値はほとんどないでしょう。


File: elisp,  Node: Regexp Search,  Next: POSIX Regexps,  Prev: Regular Expressions,  Up: Searching and Matching

33.4 Regular Expression Searching
=================================

GNU Emacsでは、インクリメンタル、または非インクリメンタ
ルの両方で、正規表現(*note Syntax of Regexps::を参照)に
たいする次マッチを検索できます。インクリメンタル検索コマ
ンドについては、*note Regular Expression Search:
(emacs)Regexp Search.を参照してください。ここでは、プロ
グラム内で有用な検索関数だけを説明します。重要な関数は
‘re-search-forward’です。

   これらの検索関数は、バッファーがマルチバイトならルチ
バイトに、ユニバイトならユニバイトに、正規表現を変換しま
す。*note Text Representations::を参照してください。

 -- Command: re-search-forward regexp &optional limit
          noerror repeat
     この関数はカレントバッファー内で、正規表現REGEXPに
     マッチするテキスト文字列を、前方へ検索する。この関
     数はREGEXPにマッチしない任意の量のテキストをスキッ
     プして、見つかった最初のマッチの終端にポイントを残
     す。これはポイントの新たな値をリターンする。

     LIMITが非‘nil’なら、それはカレントバッファー内の位
     置であること。これは検索にたいする上限を指定する。
     その位置を超えるマッチは受け入れられない。

     REPEATが与えられたなら、それは正の数でなければなら
     ない。検索は、その回数繰り返される。それぞれの繰り
     返しは、前のマッチの終端から開始される。これら一連
     の検索すべてが成功したらその検索は成功となり、ポイ
     ントを移動してポイントの新たな値をリターンする。そ
     れ以外では、検索は失敗となる。検索失敗時に
     ‘re-search-forward’が何をおこなうかは、NOERRORの値
     に依存する:

     ‘nil’
          ‘search-failed’エラーをシグナルする。
     ‘t’
          何もせず‘nil’をリターンする。
     その他
          ポイントをLIMIT(またはバッファーのアクセス可能
          範囲の終端)に移動して、‘nil’をリターンする。

     以下の例では、ポイントは最初は‘T’の前にある。この検
     索を評価することにより、その行の終端(‘hat’の‘t’と改
     行の間)にポイントは移動する。

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (re-search-forward "[a-z]+" nil t 5)
               ⇒ 27

          ---------- Buffer: foo ----------
          I read "The cat in the hat★
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Command: re-search-backward regexp &optional limit
          noerror repeat
     この関数はカレントバッファー内で、正規表現REGEXPに
     マッチするテキスト文字列を、後方へ検索して、見つか
     った最初のマッチの先頭にポイントを残す。

     この関数は‘re-search-forward’と似ているが、単なるミ
     ラーイメージ(mirror-image: 鏡像)ではない。
     ‘re-search-forward’は、先頭が開始ポイントと可能な限
     り近いマッチを探す。‘re-search-backward’が完全なミ
     ラーイメージなら、終端が可能な限り近いマッチを探す
     だろう。しかし実際は先頭が可能な限り近い(かつ開始ポ
     イントの前で終わる)マッチを探す。これは、与えられた
     位置にたいする正規表現マッチングが常に正規表現の先
     頭から終端に機能し、指定された開始位置から開始され
     るのが理由である。

     ‘re-search-forward’の真のミラーイメージには、正規表
     現を終端から先頭へマッチする特別な機能が要求される
     だろう。それを実装するこによる問題に価値はない。

 -- Function: string-match regexp string &optional start
     この関数はSTRING内で、正規表現REGEXPにたいする最初
     のマッチの開始位置のインデックスをリターンする。
     STRING内のそのインデックスから検索は開始される。

     たとえば、

          (string-match
           "quick" "The quick brown fox jumped quickly.")
               ⇒ 4
          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

     文字列の最初の文字のインデックスは1、2文字目は2、
     ...となる。

     この関数リターン後、そのマッチの先の最初の文字のイ
     ンデックスは、‘(match-end 0)’で利用できる。*note
     Match Data::を参照のこと。

          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               ⇒ 27

          (match-end 0)
               ⇒ 32

 -- Function: string-match-p regexp string &optional
          start
     この述語関数は‘string-match’と同じことを行うが、マ
     ッチデータの変更を避ける。

 -- Function: looking-at regexp
     この関数は、カレントバッファー内のポイント直後のテ
     キストが、正規表現REGEXPにマッチするかどうかを判断
     する。“直後”の正確な意味は、その検索が“固定”され、
     ポイントの後の最初の文字からマッチが開始する場合の
     み成功するということである。成功なら結果は‘t’、それ
     以外は‘nil’となる。

     この関数はポイントを移動しないが、マッチデータは更
     新する。*note Match Data::を参照のこと。マッチデー
     タを変更することなくテストする必要があるなら、以下
     で説明する‘looking-at-p’を使用すること。

     以下の例では、ポイントは‘T’の直前にある。それ以外の
     場所にある場合、結果は‘nil’となるだろう。

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-at "The cat in the hat$")
               ⇒ t

 -- Function: looking-back regexp &optional limit greedy
     この関数は、ポイントの直前(ポイントで終わる)テキス
     トがREGEXPとマッチしたら‘t’、それ以外は‘nil’をリタ
     ーンする。

     正規表現マッチングは前方だけに機能するので、ポイン
     トで終わるマッチを、ポイントから後方へ検索するよう
     に実装された。長い距離を検索する必要がある場合、こ
     れは極めて低速になり得る。LIMITを指定してその前を検
     索しないよう告げることにより、要する時間を制限でき
     る。この場合、マッチデータはLIMIT、またはその後で始
     まらなければならない。以下は例である:

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-back "read \"" 3)
               ⇒ t
          (looking-back "read \"" 4)
               ⇒ nil

     GREEDYが非‘nil’なら、この関数は可能な限り後方へマッ
     チを拡張し、前方の1文字がregexpがマッチの一部となら
     なければ停止する。マッチが拡張されたときは、マッチ
     開始位置がLIMITの前にあっても許される。

     一般的に‘looking-back’は低速なので、可能な限り使用
     は避けることを推奨する。この理由により、
     ‘looking-back-p’の追加は計画されていない。

 -- Function: looking-at-p regexp
     この述語関数は‘looking-at’と同様に機能するが、マッ
     チデータを更新しない。

 -- Variable: search-spaces-regexp
     この変数が非‘nil’なら、それは空白文字を検索する方法
     を告げる正規表現であること。この場合、検索される正
     規表現内のすべてのスペース属は、この正規表現を使用
     することを意味する。しかし‘[...]’、‘*’‘+’、‘?’のよ
     うな構成要素内のスペースは、
     ‘search-spaces-regexp’の影響を受けない。

     この変数はすべての正規表現検索、およびマッチ構成要
     素に影響するので、コードの可能な限り狭い範囲にたい
     して、一時的にバインドするべきである。


File: elisp,  Node: POSIX Regexps,  Next: Match Data,  Prev: Regexp Search,  Up: Searching and Matching

33.5 POSIX Regular Expression Searching
=======================================

通常の正規表現関数は、‘\|’や繰り返しの構成要素を処理する
ために必要なときだけバックトラッキングを行いますが、_何
らか_のマッチが見つかるまでの間だけ、これを継続します。
そして成功した後に、見つかった最初のマッチを報告します。

   このセクションでは、正規表現にたいしてPOSIX標準で指定
された完全なバックトラッキングを処理する、他の検索関数を
説明します。これらはPOSIXが要求する最長マッチを報告でき
るように、すべての可能なマッチを試み、すべてのマッチが見
つかるまでバックトラッキングを継続します。これは非常に低
速なので、本当に最長マッチが必要なときだけ、これらの関数
を使用してください。

   POSIXの検索およびマッチ関数は、非欲張りな繰り返し演算
子(*note non-greedy: Regexp Special.を参照)を正しくサポ
ートしません。これはPOSIXのバックトラッキングが、非欲張
りな繰り返しのセマンチックと競合するからです。

 -- Command: posix-search-forward regexp &optional limit
          noerror repeat
     これは‘re-search-forward’と似ているが、正規表現マッ
     チングにたいしてPOSIX標準が指定する、完全なバックト
     ラッキングを行う点が▼異なる。

 -- Command: posix-search-backward regexp &optional
          limit noerror repeat
     これは‘re-search-backward’と似ているが、正規表現マ
     ッチングにたいしてPOSIX標準が指定する、完全なバック
     トラッキングを行う点が異なる。

 -- Function: posix-looking-at regexp
     これは‘looking-at’と似ているが、正規表現マッチング
     にたいしてPOSIX標準が指定する、完全なバックトラッキ
     ングを行う。

 -- Function: posix-string-match regexp string &optional
          start
     これは‘string-match’と似ているが、正規表現にたいし
     てPOSIX標準が指定する、完全なバックトラッキングを行
     う。


File: elisp,  Node: Match Data,  Next: Search and Replace,  Prev: POSIX Regexps,  Up: Searching and Matching

33.6 The Match Data
===================

Emacsは、検索の間に見つかったテキスト片の開始と終了の位
置を追跡しています。これは“マッチデータ(match data)”と呼
ばれます。このマッチデータのおかげで、メールメッセージ内
のデータのような複雑なパターンを検索した後、そのパターン
の制御下でマッチ部分を抽出できるのです。

   マッチデータには通常、もっとも最近の検索だけが記述さ
れるので、後で参照したい検索と、そのマッチデータの使用の
間に、誤って別の検索を行わないように、注意しなければなり
ません。誤って別の検索を避けるのが不可能な場合は、マッチ
データの上書きを防ぐために、その前後でマッチデータの保存
とリストアを行わなければなりません。

   上書きを行わないと明記されていない限り、すべての関数
は上書きを許されていることに注意してください。結果として
バックグラウンド(*note Timers::および*note Idle
Timers::を参照されたい)で暗黙に実行される関数は、おそら
く明示的にマッチデータの保存とリストアを行うべきでしょう
。

* Menu:

* Replacing Match::          マッチされた部分文字列の置換。
* Simple Match Data::        特定の部分式開始箇所のような、マッチデータの単一アイテムへのアクセス。
* Entire Match Data::        リストとしてマッチデータ全体に一度にアクセスする。
* Saving Match Data::        マッチデータの保存とリストア。


File: elisp,  Node: Replacing Match,  Next: Simple Match Data,  Up: Match Data

33.6.1 Replacing the Text that Matched
--------------------------------------

以下の関数は、最後の検索でマッチされたテキストのすべて、
または一部を置換します。これはマッチデータにより機能しま
す。

 -- Function: replace-match replacement &optional
          fixedcase literal string subexp
     この関数はバッファー、または文字列にたいして置換処
     理を行う。

     あるバッファーで最後の検索を行った場合は、STRING引
     数を省略または‘nil’を指定するべきである。また最後に
     検索を行ったバッファーがカレントバッファーであるこ
     とを確認すること。その場合、この関数はマッチしたテ
     キストをREPLACEMENTで置換することにより、そのバッフ
     ァーを編集する。これは、置換したテキスト終端にポイ
     ントを残す。

     文字列にたいして最後の検索を行った場合は、同じ文字
     列がSTRINGに渡される。その場合、この関数はマッチし
     たテキストがREPLACEMENTに置き換えられた、新たなテキ
     ストをリターンする。

     FIXEDCASEが非‘nil’なら、‘replace-match’は大文字小文
     字を変更せずに置換テキストを使用し、それ以外は置換
     されるテキストのcapitalize(先頭が大文字)されている
     かどうかに応じて、置換テキストを変換する。元のテキ
     ストがすべて大文字なら、置換テキストを大文字に変換
     する。元のテキストの単語すべてがcapitalizeされてい
     たら、置換テキストのすべての単語をcapitalizeする。
     すべての単語が1文字かつ大文字なら、それらはすべて大
     文字の単語ではなく、capitalizeされた単語として扱わ
     れる。

     LITERALが非‘nil’なら、REPLACEMENTはそのまま挿入され
     るが、必要に応じて大文字小文字の変更だけが行われる
     。これが‘nil’(デフォルト)なら、文字‘\’は特別に扱わ
     れる。REPLACEMENT内に‘\’が出現した場合、それは以下
     のシーケンスのいずれかの一部でなければならない:

     ‘\&’
          これは置換されるテキスト全体を意味する。

     ‘\N’ （Nは数字)
          これは、元のregexpのN番目の部分式にマッチする
          テキストを意味する。この部分式とは‘\(...\)’の
          内部にグループかされた式である。N番目のマッチ
          がなければ、空文字列が代用される。

     ‘\\’
          これは置換テキスト内で、単一の‘\’を意味する。

     ‘\?’
          これは自身を意味する(‘replace-regexp’と関連す
          るコマンドの互換用。*note (emacs)Regexp
          Replace::を参照されたい)。

     これら以外の‘\’に続く文字は、エラーをシグナルする。

     ‘\&’および‘\N’により行われる代替えは、もしあれば大
     文字小文字変換の後に発生する。したがって、代替えす
     る文字列は決して大文字小文字変換されない。

     SUBEXPが非‘nil’なら、それは全体のマッチではなく、マ
     ッチされたregexpの部分式番号SUBEXPだけを置換するこ
     とを指定する。たとえば‘foo \(ba*r\)’のマッチング後
     に‘replace-match’を呼び出すと、SUBEXPが1なら
     ‘\(ba*r\)’にマッチしたテキストだけを置換することを
     意味する。

 -- Function: match-substitute-replacement replacement
          &optional fixedcase literal string subexp
     この関数は、‘replace-match’によりバッファーに挿入さ
     れるであろうテキストをリターンするが、バッファーを
     変更しない。これは‘\N’や‘\&’のような構成要素を、マ
     ッチしたグループで置き換えた実際の結果を、ユーザー
     に示したいとき有用である。引数REPLACEMENT、およびオ
     プションのFIXEDCASE、LITERAL、STRING、SUBEXPは、
     ‘replace-match’のときと同じ意味をもつ。


File: elisp,  Node: Simple Match Data,  Next: Entire Match Data,  Prev: Replacing Match,  Up: Match Data

33.6.2 Simple Match Data Access
-------------------------------

このセクションでは、最後の検索またはマッチング操作で、そ
れが成功した場合に何がマッチされたのかを調べるための、マ
ッチデータ使用の方法を説明します。

   マッチしたテキスト全体、または正規表現の特定のカッコ
で括られた部分式にたいして、問い合わせることができます。
以下の関数でCOUNTは、どの部分式かを指定できます。COUNTが
0ならマッチ全体を、COUNTが正なら望む部分式を指定します。

   正規表現での部分式とは、エスケープされたカッコ
‘\(...\)’でグループ化された表現であることを思い出してく
ださい。COUNT番目の部分式は、正規表現全体の先頭から
‘\(’を数えることにより見つけられます。最初の部分式が1、
2つ目が2、...となります。正規表現だけが部分式をもつこと
ができ、単純な文字列検索の後で利用できるのはマッチ全体の
情報だけです。

   成功した検索すべては、マッチデータをセットします。し
たがって検索後は、別の検索を行うかもしれない関数を呼び出
す前に、直後にマッチデータを問い合わせるべきです。別の検
索を呼び出すかもしれない関数の前後で、かわりにマッチデー
タの保存とリストアすることもできます(*note Saving Match
Data::を参照)。または‘string-match-p’のような、マッチデ
ータを変更しないと明示されている関数を使用してください。

   検索が成功しようと失敗しようと、マッチデータは変更さ
れます。現在はこのように実装されていますが、これは将来変
更されるかもしれません。失敗した後のマッチデータを、信用
しないでください。

 -- Function: match-string count &optional in-string
     この関数は、最後の検索またはマッチ処理でマッチした
     テキストを、文字列としてリターンする。これはCOUNTが
     0ならテキスト全体、COUNTが正ならCOUNT番目のカッコで
     括られた部分式に対応する部分だけをリターンする。

     そのような最後の処理が、文字列にたいする
     ‘string-match’呼び出しの場合は、引数IN-STRINGに同じ
     文字列を渡すべきである。バッファーの検索またはマッ
     チ後は、IN-STRINGを省略するか‘nil’を渡すべきである
     。しかし、最後に検索またはマッチを行ったバッファー
     が、‘match-string’呼び出し時にカレントバッファーで
     あることを確認すること。このアドバイスにしたがわな
     い場合は、誤った結果となるだろう。

     COUNTが範囲外か、‘\|’選択肢内部の部分式が使用されな
     い、または0回の繰り返しなら、値は‘nil’となる。

 -- Function: match-string-no-properties count &optional
          in-string
     この関数は‘match-string’と似ているが、結果がテキス
     トプロパティをもたない点が異なる。

 -- Function: match-beginning count
     この関数は、最後に検索された正規表現またはその部分
     式によりマッチされた、テキストの開始位置をリターン
     する。

     COUNTが0なら、値はマッチ全体の開始位置となる。それ
     以外なら、COUNTは正規表現内の部分式を指定し、この関
     数の値はその部分式にたいするマッチの開始位置である
     。

     使用されない、あるいは0回の繰り返しであるような
     ‘\|’選択肢内部の部分式にたいして、値は‘nil’になる。

 -- Function: match-end count
     この関数は‘match-beginning’と似ているが、マッチの開
     始ではなく終了位置である点が異なる。

   以下はマッチデータを使用する例です。コメントの数字は
テキスト内での位置を示しています:

     (string-match "\\(qu\\)\\(ick\\)"
                   "The quick fox jumped quickly.")
                   ;0123456789
          ⇒ 4

     (match-string 0 "The quick fox jumped quickly.")
          ⇒ "quick"
     (match-string 1 "The quick fox jumped quickly.")
          ⇒ "qu"
     (match-string 2 "The quick fox jumped quickly.")
          ⇒ "ick"

     (match-beginning 1)       ; ‘qu’にたいするマッチ先頭の
          ⇒ 4                 ;   インデックスは4

     (match-beginning 2)       ; ‘ick’にたいするマッチ先頭の
          ⇒ 6                 ;   インデックスは6

     (match-end 1)             ; ‘qu’にたいするマッチ終端の
          ⇒ 6                 ;   インデックスは6

     (match-end 2)             ; ‘ick’にたいするマッチ終端の
          ⇒ 9                 ;   インデックスは9

   別の例を以下に示します。ポイントは最初、行の先頭にあ
ります。検索により、ポイントはスペースと単語‘in’の間にあ
ります。マッチ全体の先頭はバッファーの9つ目の文字(‘T’)、
1つ目の部分式にたいするマッチの先頭は13番目の文字(‘c’)で
す。

     (list
       (re-search-forward "The \\(cat \\)")
       (match-beginning 0)
       (match-beginning 1))
         ⇒ (17 9 13)

     ---------- Buffer: foo ----------
     I read "The cat ★in the hat comes back" twice.
             ^   ^
             9  13
     ---------- Buffer: foo ----------

(この場合、リターンされるインデックスはバッファー位置で
、バッファーの1つ目の文字を1と数える。)


File: elisp,  Node: Entire Match Data,  Next: Saving Match Data,  Prev: Simple Match Data,  Up: Match Data

33.6.3 Accessing the Entire Match Data
--------------------------------------

関数‘match-data’および‘set-match-data’は、マッチデータ全
体を一度に読み取り、または書き込みます。

 -- Function: match-data &optional integers reuse reseat
     この関数は、最後の検索によりマッチしたテキストのす
     べての情報を記録する、位置(マーカーか整数)をリター
     ンする。要素0は、正規表現全体にたいするマッチの、先
     頭の位置である。要素1は、その正規表現にたいするマッ
     チの、終端の位置である。次の2つの要素は、1つ目の部
     分式にたいするマッチの先頭と終了、...となる。一般的
     に要素番号 2N は‘(match-beginning N)’に対応し、要素
     番号 2N + 1 は‘(match-end N)’に対応する。

     すべての要素は通常はマーカーか‘nil’だが、もし
     INTEGERSが非‘nil’なら、それはマーカーのかわりに整数
     を使用することを意味する(この場合、マッチデータの完
     全なリストアwpey容易にするために、リストの最後の要
     素として、そのバッファー自身が追加される)。
     ‘string-match’により、最後の検索が文字列にたいして
     行われた場合、マーカーは文字列無いをポイントできな
     いので、常に整数が使用される。

     REUSEが非‘nil’なら、それはリストであること。この場
     合、‘match-data’はマッチデータをREUSE内に格納する。
     つまりREUSEは、破壊的に変更される。REUSEが、正しい
     長さである必要はない。特定のマッチデータにたいして
     長さが十分でなければ、リストは拡張される。REUSEが長
     過ぎる場合、長さはそのままで使用しない要素には
     ‘nil’がセットされる。この機能には、ガベージコレクシ
     ョンの必要頻度を減らす目的がある。

     RESEATが非‘nil’なら、REUSEリスト内のすべてのマーカ
     ーは、存在しない場所を指すよう再設定される。

     他の場合と同様、検索関数とその検索のマッチデータへ
     のアクセスを意図する‘match-data’呼び出しの間に介入
     するような検索があってはならない。

          (match-data)
               ⇒  (#<marker at 9 in foo>
                    #<marker at 17 in foo>
                    #<marker at 13 in foo>
                    #<marker at 17 in foo>)

 -- Function: set-match-data match-list &optional reseat
     この関数は、MATCH-LISTの要素からマッチデータをセッ
     トする。MATCH-LISTは、前の‘match-data’呼び出しの値
     であるようなリストであること(正確には同じフォーマッ
     トなら他のものでも機能するだろう)。

     MATCH-LISTが存在しないバッファーを参照する場合でも
     、エラーとはならない。これは無意味だが害のない方法
     で、マッチデータをセットする。

     RESEATが非‘nil’なら、リストMATCH-LIST内のすべてのマ
     ーカーは、存在しない場所を指すよう再設定される。

     ‘store-match-data’は、半ば時代遅れな
     ‘set-match-data’のエイリアスである。


File: elisp,  Node: Saving Match Data,  Prev: Entire Match Data,  Up: Match Data

33.6.4 Saving and Restoring the Match Data
------------------------------------------

以前に行った検索にたいするマッチデータを後で使用するため
に保護する必要があるなら、検索を行うかもしれない関数の呼
び出し時に、その呼び出し前後でマッチデータの保存とリスト
アを行う必要があるでしょう。以下はマッチデータ保存に失敗
した場合に発生する問題を示す例です:

     (re-search-forward "The \\(cat \\)")
          ⇒ 48
     (foo)                   ; ‘foo’が他の検索を行うと
     (match-end 0)
          ⇒ 61              ; 結果は期待する48と異なる!

   ‘save-match-data’で、マッチデータの保存とリストアがで
きます:

 -- Macro: save-match-data body...
     このマクロはBODYを実行して、その前後のマッチデータ
     の保存とリストアをする。リターン値は、BODY内の最後
     のフォームの値。

   ‘set-match-data’と‘match-data’を一緒に使用して、
‘save-match-data’の効果を真似ることができます。以下は、
その方法です:

     (let ((data (match-data)))
       (unwind-protect
           ...   ; 元のマッチデータを変更してもOK
         (set-match-data data)))

   プロセスフィルター関数(*note Filter Functions::)、お
よびプロセスセンチネル(*note Sentinels::)実行時は、
Emacsが自動的にマッチデータの保存とリストアを行います。


File: elisp,  Node: Search and Replace,  Next: Standard Regexps,  Prev: Match Data,  Up: Searching and Matching

33.7 Search and Replace
=======================

バッファーのある部分で、regexpにたいするすべてのマッチを
見つけてそれらを置換したい場合は、以下のように
‘re-search-forward’と‘replace-match’を使用して、明示的な
ループを記述するのが最良の方法です:

     (while (re-search-forward "foo[ \t]+bar" nil t)
       (replace-match "foobar"))

‘replace-match’の説明は、*note Replacing the Text that
Matched: Replacing Match.を参照してください。

   しかし文字列内のマッチの置換、特にそれを効果的に行い
たい場合は、より複雑になります。そのため、Emacsはこれを
行うための関数を提供します。

 -- Function: replace-regexp-in-string regexp rep string
          &optional fixedcase literal subexp start
     この関数はSTRINGをコピーしてREGEXPにたいするマッチ
     を検索し、それらをREPに置き換える。これは変更された
     コピーwリターンする。STARTが非‘nil’なら、マッチにた
     いする検索はSTRING内のそのインデックスから開始され
     、そのインデックスより前で始まるマッチは変更されな
     い。

     この関数は置換を行うために‘replace-match’を使用し、
     オプション引数FIXEDCASE、LITERAL、SUBEXPを
     ‘replace-match’に渡す。

     文字列のかわりに、REPは関数でもよい。この場合、
     ‘replace-regexp-in-string’はそれぞれのマッチにたい
     して、そのテキストを単一の引数としてREPを呼び出す。
     これはREPがリターンする値を収集して、それを置換文字
     列として‘replace-match’に渡す。この時点でのマッチデ
     ータはSTRINGの部分文字列にたいするREGEXPのマッチ結
     果である。

   ‘query-replace’の行に関するコマンドを記述したい場合は
、‘perform-replace’を使用してこれを行うことができる。

 -- Function: perform-replace from-string replacements
          query-flag regexp-flag delimited-flag
          &optional repeat-count map start end
     これは‘query-replace’および関連するコマンドの根幹と
     なる関数である。これは位置STARTとENDの間にあるテキ
     スト内に出現するFROM-STRINGの一部またはすべてを置換
     する。STARTが‘nil’(または省略された)ならかわりにポ
     イントガ使用され、ENDにはそのバッファーのアクセス可
     能範囲の終端が使用される。

     QUERY-FLAGが‘nil’なら、マッチすべてを置換する。それ
     以外の場合は、それぞれにたいしてユーザーにたいして
     何をすべきか問い合わせる。

     REGEXP-FLAGが非‘nil’ならFROM-STRINGは正規表現とみな
     され、それ以外はリテラルとしてマッチしなければなら
     ない。DELIMITED-FLAGが非‘nil’なら、単語境界に囲まれ
     た置換だけが考慮される。

     引数REPLACEMENTSは、マッチを何で置き換えるかを指定
     する。文字列ならその文字列を使用する。サイクル順に
     使用される文字列リストでもよい。

     REPLACEMENTSがコンスセル‘(FUNCTION . DATA)’なら、こ
     れは置換テキストを取得するためにそれぞれのマッチ後
     にFUNCTIONを呼び出すことを意味する。この関数は
     DATAと、すでに置換された個数という、2つの引数で呼び
     出される。

     REPEAT-COUNTが非‘nil’なら、それは整数であること。そ
     の場合、サイクルを次に進める前に、REPLACEMENTSリス
     ト内の各文字列を何度使用するかを指定する。

     FROM-STRINGが大文字アルファベットを含む場合、
     ‘perform-replace’は‘case-fold-search’を‘nil’にバイ
     ンドして、大文字小文字を変換せずにREPLACEMENTSを使
     用する。

     キーマップ‘query-replace-map’は通常、問い合わせにた
     いして可能なユーザー応答を定義する。引数MAPが非
     ‘nil’なら、それは‘query-replace-map’のかわりに使用
     するキーマップを指定する。

     この関数はFROM-STRINGの次のマッチを検索するために、
     2つの関数のうち1つを使用する。これらの関数は2つの変
     数‘replace-re-search-function’と
     ‘replace-search-function’により指定される。引数
     REGEXP-FLAGが非‘nil’なら前者、‘nil’なら後者が呼び出
     される。

 -- Variable: query-replace-map
     この変数は‘perform-replace’にたいする有効なユーザー
     応答を定義するスペシャルキーマップを保持し、コマン
     ドは‘y-or-n-p’や‘map-y-or-n-p’と同様に、それを使用
     する。このマップは2つの点において普通のマップと異な
     る。

        • “キーバインディング”がコマンドではなく、このマ
          ップを使用する関数にとって意味のある単なるシン
          ボルであること。

        • プレフィクスキーはサポートされない。各キーバイ
          ンディングは単一イベントキーシーケンスでなけれ
          ばならない。これは入力を取得するために、関数が
          ‘read-key-sequence’を使用せず、かわりに単一イ
          ベントを読み取って、それを“手動”で照合する。

   ‘query-replace-map’にたいして意味をもつ“バインディン
グ”があります。それらのうちいくつかは、‘query-replace’と
その同族にたいしてのみ意味をもちます。

‘act’
     判断している対象にたいしてアクションを起こす(別の言
     い方をすると“yes”)。

‘skip’
     この問いにたいしてアクションを起こさない(別の言い方
     をすると“no”)。

‘exit’
     この問いにたいして“no”を答えて、一連の問いすべてに
     たいして“no”が応答されたとみなし、問い合わせをあき
     らめる。

‘exit-prefix’
     ‘exit’と似ているが、‘unread-command-events’にたいし
     て押下されたキーを追加する(*note Event Input
     Misc::を参照)。

‘act-and-exit’
     この問いにたいして“yes”を答えて、一連の問いすべてに
     たいして後続の問いに“no”が応答されるとみなし、問い
     合わせをあきらめる。

‘act-and-show’
     この問いに“yes”を答えるが結果を表示して、まだ次の問
     いへ進まない。

‘automatic’
     これ以上のユーザーとの対話を行わず、この問いと後続
     の問いにたいして“yes”を答える。

‘backup’
     前に問い合わせた以前の場所に戻る。

‘edit’
     この問いに対処するために、通常とられるアクションの
     かわりに再帰編集にエンターする。

‘edit-replacement’
     ミニバッファー内で、この問いにたいする置換を編集す
     る。

‘delete-and-edit’
     検討中のテキストを削除して、それを置換するために再
     帰編集にエンターする。

‘recenter’
‘scroll-up’
‘scroll-down’
‘scroll-other-window’
‘scroll-other-window-down’
     指定されたウィンドウスクロール操作を行い、同じ問い
     を再度尋ねる。この問いには‘y-or-n-p’と、関連する関
     数だけが使用される。

‘quit’
     即座にquitを行う。この問いには‘y-or-n-p’と、関連す
     る関数だけが使用される。

‘help’
     ヘルプを表示して、再度尋ねる。

 -- Variable: multi-query-replace-map
     この変数は、マルチバッファー置換で有用な追加キーバ
     インディングを提供することにより
     ‘query-replace-map’を拡張するキーマップを保持する。
     追加される“バインディング”は以下のとおり:

     ‘automatic-all’
          残りすべてのバッファーにたいして、それ以上の対
          話をせず、その問いと後続のすべての問いに
          “yes”を答える。

     ‘exit-current’
          この問いに“no”を答えて、カレントバッファーにた
          いする一連の問いすべてをあきらめる。そしてシー
          ケンス内の次のバッファーへ問いを継続する。

 -- Variable: replace-search-function
     この変数は、置換する次の文字列を検索するために
     ‘perform-replace’が呼び出す関数を指定する。デフォル
     ト値は‘search-forward’。それ以外の値の場合は、
     ‘search-forward’の最初の3つの引数を引数とする関数を
     指定すること(*note String Search::を参照)。

 -- Variable: replace-re-search-function
     この変数は、置換する次のregexpを検索するために
     ‘perform-replace’が呼び出す関数を指定する。デフォル
     ト値は‘re-search-forward’。それ以外の値の場合は、
     ‘re-search-forward’の最初の3つの引数を引数とする関
     数を指定すること(*note Regexp Search::を参照)。


File: elisp,  Node: Standard Regexps,  Prev: Search and Replace,  Up: Searching and Matching

33.8 Standard Regular Expressions Used in Editing
=================================================

このセクションでは、編集において特定の目的のために使用さ
れる正規表現を保持する変数をいくつか説明します。

 -- User Option: page-delimiter
     これはページを分割する行開始を記述する、正規表現で
     ある。デフォルト値は‘"^\014"’(‘"^^L"’または
     ‘"^\C-l"’のこと)。これはフォームフィード文字(改頁文
     字)で始まる行とマッチする。

   以下の2つの正規表現を、常に行頭からマッチが始まる正規
表現とみなすべきでは_ありません_。これらを‘^’にマッチす
るアンカーとして使用するべきではありません。ほとんどの場
合、パラグラフコマンドは行頭にたいしてのみマッチのチェッ
クを行い、これは‘^’が不要であることを意味します。非0の左
マージンが存在する場合、これらは左マージンの後から始まる
マッチに適用されます。その場合、‘^’は不適切でしょう。し
かし左マージンを決して使用しないモードでは、‘^’は無害で
しょう。

 -- User Option: paragraph-separate
     これは、パラグラフを分割する行の開始を認識する正規
     表現である(これを変更する場合は‘paragraph-start’も
     変更する必要があるかもしれない)。デフォルト値は
     ‘"[ \t\f]*$"’で、これは(左マージン以降)すべてがスペ
     ース、タブ、フォームフィードで構成される行とマッチ
     する。

 -- User Option: paragraph-start
     これは、パラグラフを開始_または_分割する行の開始を
     認識する正規表現である。デフォルト値は
     ‘"\f\\|[ \t]*$"’で、これは(左マージン以降)すべてが
     空白文字で構成される行、またはフォームフィードで始
     まる行とマッチする。

 -- User Option: sentence-end
     非‘nil’なら、以降に続く空白文字を含めてセンテンスの
     終わりを記述する正規表現であること(これとは無関係に
     パラグラフ境界もセンテンスを終了させる)。

     値が‘nil’(デフォルト)なら、関数‘sentence-end’が
     regexpを構築する。センテンス終端の認識に使用する
     regexpを得るのに、常に関数‘sentence-end’を使用する
     べきなのは、これが理由である。

 -- Function: sentence-end
     この関数は、変数‘sentence-end’が非‘nil’なら、その値
     をリターンする。それ以外なら、変数
     ‘sentence-end-double-space’(*note Definition of
     sentence-end-double-space::を参照)、
     ‘sentence-end-without-period’、
     ‘sentence-end-without-space’にもとづくデフォルト値
     をリターンする。


File: elisp,  Node: Syntax Tables,  Next: Abbrevs,  Prev: Searching and Matching,  Up: Top

34 Syntax Tables
****************

“構文テーブル(syntax table)”は、バッファー内のそれぞれの
文字にたいして、構文的な役割を指定します。単語、シンボル
、その他の構文要素の開始と終了の判定に、これを使用できま
す。この情報はFont Lockモード(*note Font Lock Mode::を参
照)や、種々の複雑な移動コマンド(*note Motion::を参照)を
含む、多くのEmacs機能により使用されます。

* Menu:

* Basics: Syntax Basics.     構文テーブルの基本的概念。
* Syntax Descriptors::       文字がクラス分けされる方法。
* Syntax Table Functions::   構文テーブルを作成、調査、変更する方法。
* Syntax Properties::        テキストプロパティによる構文テーブルのオーバーライド。
* Motion and Syntax::        特定の構文による文字間の移動。
* Parsing Expressions::      構文テーブル使用によるバランスのとれた式の解析。
* Syntax Table Internals::   構文テーブルの情報が格納される方法。
* Categories::               文字構文をクラス分けする別の手段。


File: elisp,  Node: Syntax Basics,  Next: Syntax Descriptors,  Up: Syntax Tables

34.1 Syntax Table Concepts
==========================

構文テーブルとは、それぞれの文字の“構文クラス(syntax
class)”や、その他の構文的プロパティを照合するために使用
できる、データ構造のことです。構文テーブルは、テキストを
横断したスキャンや移動のために、Lispプログラムにより使用
されます。

   構文テーブルは、内部的には文字テーブルです(*note
Char-Tables::を参照)。インデックスCの要素はコードCの文字
を記述します。値は該当する文字の構文を指定するコンスセル
です。詳細は*Note Syntax Table Internals::を参照してくだ
さい。しかし構文テーブルの内容を変更または調べるために
‘aset’や‘aref’を使用するかわりに、通常は高レベルな関数
‘char-syntax’や‘modify-syntax-entry’を使用するべきです。
これらについては*note Syntax Table Functions::で説明しま
す。

 -- Function: syntax-table-p object
     この関数はOBJECTが構文テーブルなら、‘t’をリターンす
     る。

   バッファーはそれぞれ自身のメジャーモードをもち、それ
ぞれのメジャーモードはさまざまな文字の構文クラスにたいし
て独自のアイデアをもっています。たとえばLisモードでは文
字‘;’はコメントの開始ですが、Cモードでは命令文の終端にな
ります。これらのバリエーションをサポートするために、構文
テーブルはそれぞれのバッファーにたいしてローカルです。一
般的に各メジャーモードは自身の構文テーブルをもち、そのモ
ードを使用するすべてのバッファーにそれがインストールされ
ます。たとえば変数‘emacs-lisp-mode-syntax-table’は
EmacsのLispモードが使用する構文テーブル、
‘c-mode-syntax-table’はCモードが使用する構文テーブルを保
持します。あるメジャーモードの構文テーブルを変更すると、
そのモードのバッファー、およびその後でそのモードに置かれ
るすべてのバッファーの構文も同様に変更されます。複数の類
似するモードが1つの構文テーブルを共有することが、ときお
りあります。構文テーブルをセットアップする方法の例は、
*note Example Major Modes::を参照してください。

   別の構文テーブルから構文テールを“継承(inherit)”できま
す。これを“親構文テーブル(parent syntax table)”と呼びま
す。構文テーブルは、ある文字にたいして構文クラス
“inherit”を与えることにより、構文クラスを未指定にしてお
くことができます。そのような文字は、親構文テーブルが指定
する構文クラスを取得します(*note Syntax Class Table::を
参照)。Emacsは“標準構文テーブル(standard syntax table)”を
定義します。これはデフォルトとなる親構文テーブルであり、
Fundamentalモードが使用する構文テーブルでもあります。

 -- Function: standard-syntax-table
     この関数はFundamentalモードが使用する構文テーブルで
     ある、標準構文テーブルをリターンする。

   Emacs Lispリーダーは変更不可な独自のビルトイン構文ル
ールをもつので、構文テーブルは使用しません(いくつかの
Lispシステムはリード構文を再定義する手段を提供するが、わ
たしたちは単純化のためこの機能をEmacs Lisp外部に留める決
定をした)。


File: elisp,  Node: Syntax Descriptors,  Next: Syntax Table Functions,  Prev: Syntax Basics,  Up: Syntax Tables

34.2 Syntax Descriptors
=======================

“構文クラス(syntax class)”の文字は、その文字の構文的な役
割を記述します。各構文テーブルは、それぞれの文字の構文ク
ラスを指定します。ある構文テーブルでの文字のクラスと、別
のテーブルにおけるその文字のクラスとの間に関連性がある必
要はありません。

   構文テーブルはそれぞれニーモニック文字(mnemonic
character)により選別され、クラスを指定する必要がある際に
はそのクラスの名前としての役割を果たします。この指定子文
字(designator character)は通常、そのクラスに割当てられる
ことが多々あります。しかしその指定子としての意味は不変で
あり、その文字がカレントでもつ構文とは独立しています。つ
まりカレント構文テーブルにおいて実際に文字‘\’が構文をも
つかどうかに関係なく、指定子文字としての‘\’は常に“エスケ
ープ文字(escape characte)r”を意味します。 構文クラスとそ
れらの指定子文字のリストは、*note Syntax Class Table::を
参照してください。

   “構文記述子(syntax descriptor)”とは、文字の構文クラス
と、その他の構文的なプロパティを記述するLisp文字列のこと
です。ある文字の構文を変更したい際、それは関数
‘modify-syntax-entry’を呼び出して、その引数に構文記述子
を渡すことにより行われます(*note Syntax Table
Functions::を参照)。

   構文記述子の1つ目の文字は、構文クラスの指定子文字でな
ければなりません。2つ目の文字がもしあれば、マッチング文
字を指定します(Lispでは‘(’にたいするマッチング文字は
‘)’)。スペースはマッチング文字が存在しないことを指定しま
す。その後に続く文字は、追加の構文プロパティを指定します
(*note Syntax Flags::を参照)。

   マッチング文字やフラグが必要なければ、(構文クラスを指
定する)1つの文字だけで十分です。

   たとえばCモードでの文字‘*’の構文記述子は‘". 23"’(区切
り記号、マッチング文字用スロットは未使用、コメント開始記
号の2つ目の文字、コメント終了記号の1つ目の文字)、‘/’にた
いするエントリーは‘. 14’(区切り記号、マッチング文字用ス
ロットは未使用、コメント開始記号の1つ目の文字、コメント
終了記号の2つ目の文字)です。

   Emacsは、低レベルでの構文クラスを記述するために使用さ
れる“raw構文記述子(raw syntax descriptors)”も定義してい
ます。*note Syntax Table Internals::を参照してください。

* Menu:

* Syntax Class Table::       構文クラスのテーブル。
* Syntax Flags::             各文字が所有できる追加のフラグ。


File: elisp,  Node: Syntax Class Table,  Next: Syntax Flags,  Up: Syntax Descriptors

34.2.1 Table of Syntax Classes
------------------------------

以下は構文クラス、それらの指定子となる文字とそれらの意味
、およびそれらの使用例を示すテーブルです。

空白文字: ‘ ’、または‘-’
     シンボルおよび単語を区別する文字。空白文字は通常は
     他の構文的な意義をもたず、複数の空白文字は構文的に
     は単一の空白文字と等しい。スペース、タブ、フォーム
     フィードは、ほとんどすべてのメジャーモードにおいて
     空白文字にクラスっ分けされる。

     この構文クラスは‘ ’または‘-’により指定できる。両指
     定子は等価である。

単語構成文字: ‘w’
     人間の言語における単語の一部。これらは通常は、プロ
     グラム内において変数やコマンドの名前として使用され
     る。通常、すべての大文字と小文字、および数字は単語
     構成文字である。

シンボル構成文字: ‘_’
     単語構成文字とともに変数やコマンドの名前で使用され
     る、追加の文字。例としてはLispモードの文字
     ‘$&*+-_<>’が含まれ、これらはたとえ英単語の一部でな
     いとしても、シンボルの名前の一部となり得る。標準Cで
     は、シンボル内において非単語構成文字で有効な文字は
     アンダースコア(‘_’)だけである。

区切り文字: ‘.’
     人間の言語において句読点として使用される文字、また
     はプログラミング言語でシンボルを別のシンボルと区別
     するために使用される文字。Emacs Lispモードのような
     いくつかのプログラミング言語のモードでは、単語構成
     文字およびシンボル構成文字のいずれでもないいくつか
     の文字はすべて、他の用途をもつので、このクラスの文
     字をもたない。Cモードのような他のプログラミング言語
     のモードでは、演算子にたいして区切り文字構文が使用
     される。

開カッコ文字: ‘(’
閉カッコ文字: ‘)’
     文や式を囲うために、異なるペアーとして使用される文
     字。そのようなグループ化は開カッコで開始され、閉カ
     ッコで終了する。開カッコ文字はそれぞれ特定の閉カッ
     コ文字にマッチし、その逆も成り立つ。Emacsqは通常、
     閉カッコ挿入字に、マッチする開カッコを示す。*note
     Blinking::を参照のこと。

     人間の言語、およびCのコードではカッコのペアーは
     ‘()’、‘[]’、‘{}’である。Emacs Lispではリストとベク
     ターにたいする区切り文字(‘()’および‘[]’)は、カッコ
     文字としてクラス分けされる。

文字列クォート: ‘"’
     文字列定数を区切るために使用される文字。文字列の先
     頭と終端に、同じ文字列クォート文字が出現する。この
     ようなクォート文字列はネストされない。

     Emacsのパース機能は、文字列を単一のトークンとみなす
     。文字列内では、その文字の通常の構文的な意味は抑制
     される。

     Lispモードはダブルクォーテーション(‘"’)、および垂直
     バー(‘|’)とう、2つの文字列クォート文字をもつ。Emacs
     Lispでは‘|’は使用しないが、Common Lispでは使用され
     る。Cも文字列にたいするダブルクォート文字、および文
     字定数にたいするシングルクォート文字(‘'’)という、
     2つのクォート文字をもつ。

     人間用のテキストには文字列クォート文字がない。その
     クォーテーション内の別の文字の通常の構文的プロパテ
     ィを、クォーテーションマークがオフに切り替えるのを
     、わたしたちは望まない。

エスケープ構文文字: ‘\’
     文字列や文字定数内で使用されるような、エスケープシ
     ーケンスで始まる文字。CとLispの両方で、文字‘\’はこ
     のクラスに属する(Cでは文字列内でのみ使用されるが、
     Cコード中を通じてこのように扱っても問題ないことがわ
     かった)。

     ‘words-include-escapes’が非‘nil’な、このクラスの文
     字は単語の一部とみなされる。*note Word Motion::を参
     照のこと。

文字クォート: ‘/’
     その文字の通常の構文的な意義を失うよう、後続の文字
     をクォートするために使用される文字。これは直後に続
     く文字だけに影響する点が、エスケープ文字と異なる。

     ‘words-include-escapes’が非‘nil’な、このクラスの文
     字は単語の一部とみなされる。*note Word Motion::を参
     照のこと。

     このクラスはTeXモードのバックスラッシュにたいして使
     用される。

区切りペアー: ‘$’
     文字列クォート文字と似ているが、この区切りの間にあ
     る文字の構文的なプロパティは抑制されない点が異なる
     。現在のところTeXモードだけが区切りペアーを使用する
     (‘$’によりmathモードに出入りする)。

式プレフィクス: ‘'’
     式に隣接して出現した場合に、その式の一部とみなされ
     る、構文的演算子にたいして使用される文字。Lispモー
     ドではアポストロフィー‘'’(クォートに使用)、カンマ
     ‘,’(マクロに使用)、‘#’(特定のデータ型にたいするリー
     ド構文として使用)が、これらの文字に含まれる。

コメント開始文字: ‘<’
コメント終了文字: ‘>’
     さまざまな言語において、コメントを区切るために使用
     する文字。人間用のテキストはコメント文字をもたない
     。Lispでは、セミコロン(‘;’)がコメントの開始で、改行
     かフォームフィードで終了する。

標準構文の継承: ‘@’
     この構文クラスは、特定の構文を指定しない。これは、
     その文字の構文を探すために標準構文テーブルを照合す
     るよう告げる。

汎用コメント区切り: ‘!’
     特殊なコメントを開始または終了させる文字。_任意_の
     汎用コメント区切りは、_任意_の汎用コメント区切りに
     マッチするが、コメント開始とコメント終了とはマッチ
     できない。汎用コメント区切りは、汎用コメント区切り
     同士としかマッチできない。

     この構文クラスは主として‘syntax-table’テキストプロ
     パティ(*note Syntax Properties::を参照)とともに使用
     することを意図している。任意の文字範囲にたいして、
     その範囲の最初と最後の文字にたいして、それらが汎用
     コメント区切りであることを示す‘syntax-table’プロパ
     ティを付与することにより、その範囲がコメントを形成
     するとマークすることができる。

汎用文字列区切り: ‘|’
     文字列を開始または終了させる文字。_任意_の汎用文字
     列区切りは、_任意_の汎用文字列区切りにマッチするが
     、通常の文字列クォート文字とはマッチできない。

     この構文クラスは主として‘syntax-table’テキストプロ
     パティ(*note Syntax Properties::を参照)とともに使用
     することを意図している。任意の文字範囲にたいして、
     その範囲の最初と最後の文字にたいして、それらが汎用
     文字列区切りであることを示す‘syntax-table’プロパテ
     ィを付与することにより、その範囲が文字列定数を形成
     するとマークすることができる。


File: elisp,  Node: Syntax Flags,  Prev: Syntax Class Table,  Up: Syntax Descriptors

34.2.2 Syntax Flags
-------------------

構文テーブル内の文字全体にたいして、構文クラスに加えてフ
ラグを指定できます。利用できる8つのフラグがあり、それら
は文字‘1’、‘2’、‘3’、‘4’、‘b’、‘c’、‘n’、‘p’で表されます
。

   ‘p’を除くすべてのフラグは、コメント区切りを記述するた
めに使用されます。数字のフラグは2文字から構成されるコメ
ント区切りにたいして使用されます。これらは、文字の文字ク
ラスに関連付けられた構文的プロパティに加えて、その文字も
_同様_にコメントシーケンスの一部となれることを示します。
Cモードでは区切り文字であり、_かつ_コメントシーケンス開
始(‘/*’)の2文字目であり、_かつ_コメントシーケンス終了
(‘*/’)の1文字目である‘*’のような文字のために、フラグとク
ラスは互いに独立しています。フラグ‘b’、‘c’、‘n’は対応す
るコメント区切りを限定するために使用されます。

   以下は文字Cにたいして利用できるフラグと、それらの意味
を示すテーブルです:

   • ‘1’は、Cが2文字からなるコメント開始シーケンスの開始
     であることを意味する。

   • ‘2’は、Cがそのようなシーケンスの2文字目であることを
     意味する。

   • ‘3’は、Cが2文字からなるコメント終了シーケンスの開始
     であることを意味する。

   • ‘4’は、Cがそのようなシーケンスの2文字目であることを
     意味する。

   • ‘b’は、Cが代替えのコメントスタイル“b”に属するコメン
     ト区切りであることを意味する。このフラグは2文字のコ
     メント開始では2文字目、2文字のコメント終了では1文字
     目にたいしてのみ意味をもつ。

   • ‘c’は、Cが代替えのコメントスタイル“c”に属するコメン
     ト区切りであることを意味する。2文字からなるコメント
     区切りにたいしては、そのいずれかが‘c’であればスタイ
     ル“c”となる。

   • コメント区切り文字での‘n’は、この種のコメントがネス
     ト可能であることを指定する。2文字からなるコメント区
     切りにたいしては、そのいずれかが‘n’であればネスト可
     能となる。

     Emacsは任意の構文テーブル1つにたいして、同時に複数
     のコメントスタイルをサポートする。コメントスタイル
     はフラグ‘b’、‘c’、‘n’の組み合わせなので、8個の異な
     るコメントスタイルが可能である。コメント区切りはそ
     れぞれスタイルをもち、同じスタイルのコメント区切り
     とのみマッチできる。つまりコメントがスタイル“bn”の
     コメント開始シーケンスで開始されるなら、そのコメン
     トは次のスタイル“bn”のコメント終了シーケンスにマッ
     チするまで拡張されるだろう。

     C++にたいして適切なコメント構文は、以下のようになる
     :

     ‘/’
          ‘124’
     ‘*’
          ‘23b’
     newline
          ‘>’

     これは4つのコメント区切りシーケンスを定義する:

     ‘/*’
          これは2文字目の‘*’が‘b’フラグをもつので、“b”ス
          タイルのコメント開始シーケンスである。

     ‘//’
          これは2文字目の‘/’が‘b’フラグをもたないので、
          “a”スタイルのコメント開始シーケンスである。

     ‘*/’
          これは1文字目の‘*’が‘b’フラグをもつので、“b”ス
          タイルのコメント終了シーケンスである。

     newline
          これは改行▼文字が‘b’フラグをもたないので、
          “a”スタイルのコメント終了シーケンスである。

   • ‘p’はLisp構文にたいして、追加のプレフィクス文字を識
     別する。これらが式の間に出現した際は、空白文字とし
     て扱われる。これらが式の内部に出現したときは、それ
     らの通常の構文クラスに応じて処理される。

     関数‘backward-prefix-chars’はこれらの文字と、同様に
     メインの構文クラスがプレフィクスであるような文字
     (‘'’)を超えて、後方に移動する。*note Motion and
     Syntax::を参照のこと。


File: elisp,  Node: Syntax Table Functions,  Next: Syntax Properties,  Prev: Syntax Descriptors,  Up: Syntax Tables

34.3 Syntax Table Functions
===========================

このセクションでは、構文テーブルを作成、アクセス、変更す
る関数を説明します。

 -- Function: make-syntax-table &optional table
     この関数は、新たに構文テーブルを作成する。TABLEが非
     ‘nil’なら、新たな構文テーブルの親はTABLE、それ以外
     なら標準構文テーブルが親になる。

     新たな構文テーブルでは最初は、すべての文字に構文ク
     ラス“inherit”(‘@’)が与えられ、それらの構文は親テー
     ブルから継承される(*note Syntax Class Table::を参照
     )。

 -- Function: copy-syntax-table &optional table
     この関数はTABLEのコピーを構築して、それをリターンす
     る。TABLEが省略または‘nil’なら、標準構文テーブルの
     コピーをリターンする。それ以外の場合、TABLEが構文テ
     ーブルでなければエラーをシグナルする。

 -- Command: modify-syntax-entry char syntax-descriptor
          &optional table
     この関数はSYNTAX-DESCRIPTORに応じて、CHARの構文エン
     トリーをセットする。CHARは文字、または‘(MIN .
     MAX)’という形式のコンスセルでなければならない。後者
     の場合、この関数はMINとMAX(両端を含む)の間のすべて
     の文字にたいして、構文エントリーをセットする。

     構文はTABLE(デフォルトはカレントバッファーの構文テ
     ーブル)にたいしてのみ変更され、他のすべての構文テー
     ブルにたいしては変更されない。

     引数SYNTAX-DESCRIPTORは構文記述子、すなわち1文字目
     が構文クラス指定子、2文字目以降がオプションでマッチ
     ング文字と構文フラグを指定する文字列である。*note
     Syntax Descriptors::を参照のこと。
     SYNTAX-DESCRIPTORが有効な構文記述子でなければ、エラ
     ーがシグナルされる。

     この関数は、常に‘nil’をリターンする。この文字にたい
     するテーブル内の古い構文情報は、破棄される。

     ▼例:

          ;; 空白文字クラスのスペースをputする
          (modify-syntax-entry ?\s " ")
               ⇒ nil

          ;; ‘$’を開カッコ文字にして、
          ;;   ‘^’を対応する閉カッコにする
          (modify-syntax-entry ?$ "(^")
               ⇒ nil

          ;; ‘^’閉カッコ文字にして
          ;;   ‘$’を対応する開カッコにする
          (modify-syntax-entry ?^ ")$")
               ⇒ nil

          ;; ‘/’を区切り文字で
          ;;   コメント開始シーケンス1文字目、
          ;;   かつコメント終了シーケンス2文字目とする
          ;;   これはCモードで使用される
          (modify-syntax-entry ?/ ". 14")
               ⇒ nil

 -- Function: char-syntax character
     この関数は、指定子文字(*note Syntax Class Table::を
     参照)の表現で、CHARACTERの構文クラスをリターンする
     。これはクラス_だけ_をリターンし、マッチング文字や
     構文フラグはリターンしない。

     以下をCモードにたいして適用してみる(‘char-syntax’が
     リターンする文字を確認しやすいよう‘string’を使用す
     る)。

          ;; スペース文字は空白文字構文クラスをもつ
          (string (char-syntax ?\s))
               ⇒ " "

          ;; スラッシュ文字は区切り文字構文をもつ。
          ;; コメント開始やコメント終了シーケンスの一部でもある場合、
          ;; char-syntax呼び出しはこれを明らかにしないことに注意。
          (string (char-syntax ?/))
               ⇒ "."

          ;; 開カッコ文字は開カッコ構文をもつ。
          ;; これがまっちんぐ文字‘)’をもつことは
          ;; char-syntax呼び出しでは明らかにならないことに注意。
          (string (char-syntax ?\())
               ⇒ "("

 -- Function: set-syntax-table table
     この関数は、カレントバッファーの構文テーブルを
     TABLEにする。これはTABLEをリターンする。

 -- Function: syntax-table
     この関数はカレント構文テーブル(カレントバッファーの
     テーブル)をリターンする。

 -- Command: describe-syntax &optional buffer
     このコマンドは、BUFFER(デフォルトはカレントバッファ
     ー)の構文テーブルのコンテンツをhelpバッファーに表示
     する。

 -- Macro: with-syntax-table table body...
     このまくろはTABLEをカレント構文テーブルとして使用し
     て、BODYを実行する。これは古いカレント構文テーブル
     のリストア後に、BODYの最後のフォームの値をリターン
     する。

     各バッファーは独自にカレント構文テーブルをもつので
     、マクロはこれを入念に行う。‘with-syntax-table’はマ
     クロ実行開始時、そのときカレントのバッファーが何で
     あれ、カレント構文テーブルを一時的に変更する。他の
     バッファーは影響を受けない。


File: elisp,  Node: Syntax Properties,  Next: Motion and Syntax,  Prev: Syntax Table Functions,  Up: Syntax Tables

34.4 Syntax Properties
======================

ある言語の構文を指定するのに構文テーブルが十分に柔軟でな
いときは、 バッファー内に出現する特定の文字にたいして、
テキストプロパティ‘syntax-table’を適用することにより、構
文テーブルをオーバーライドできます。テキストプロパティを
適用する方法については、*note Text Properties::を参照し
てください。

   以下はテキストプロパティ‘syntax-table’の有効な値です:

SYNTAX-TABLE
     プロパティの値が構文テーブルなら、根底となるテキス
     ト文字の構文を決定するカレントバッファーの構文テー
     ブルのかわりに、そのテーブルが使用される。

‘(SYNTAX-CODE . MATCHING-CHAR)’
     この形式のコンスセルは、根底となるテキスト文字の構
     文クラスを直接指定する、raw構文テーブル(*note
     Syntax Table Internals::を参照)である。

‘nil’
     このプロパティが‘nil’なら、その文字の構文はカレント
     構文テーブルにより通常の方法で決定される。

 -- Variable: parse-sexp-lookup-properties
     これが非‘nil’なら、‘forward-sexp’のような構文をスキ
     ャンする関数は、syntax-tableテキストプロパティに注
     意を払い、それ以外ならカレント構文テーブルだけを使
     用する。

 -- Variable: syntax-propertize-function
     この変数が非‘nil’なら、特定のテキスト範囲にたいして
     ‘syntax-table’プロパティを適用する関数を格納するべ
     きである。これは、モードに適した方法で
     ‘syntax-table’プロパティを適用する関数をインストー
     ルするために、メジャーモードに使用されることを意図
     している。

     この関数は‘syntax-ppss’(*note Position Parse::を参
     照)、および構文フォント表示化(*note Syntactic Font
     Lock::を参照)の間にFont Lockモードにより呼び出され
     る。これは作用すべきテキスト部分の開始STARTと終了
     ENDという、2つの引数で呼び出される。これはENDの前の
     任意の位置で、‘syntax-ppss’を呼び出すことが許されて
     いる。しかし‘syntax-ppss-flush-cache’を呼び出すべき
     ではなく、そのため、ある位置で‘syntax-ppss’を呼び出
     して、後からバッファー内の前の位置を変更することは
     許されていない。

 -- Variable: syntax-propertize-extend-region-functions
     このアブノーマルフックは
     ‘syntax-propertize-function’呼び出しに先立ち、構文
     解析コードにより実行される。これは
     ‘syntax-propertize-function’に渡すための、安全なバ
     ッファーの開始および終了位置を見つける助けをする役
     割をもつ。たとえばメジャーモードは、複数行の構文構
     成を識別して、境界が複数行の中間にならないよう、こ
     のフックに関数を追加できる。

     このフック内の各関数は、引数STARTとENDを受け取るこ
     と。これは2つのバッファー位置を調整するコンスセル
     ‘(NEW-START . NEW-END)’、調整が必要なければ‘nil’を
     リターンするべきである。フック関数は、それらすべて
     が‘nil’をリターンするまで、順番に繰り返し実行される
     。


File: elisp,  Node: Motion and Syntax,  Next: Parsing Expressions,  Prev: Syntax Properties,  Up: Syntax Tables

34.5 Motion and Syntax
======================

このセクションでは、特定の構文クラスをもつ文字間を横断し
て移動する関数を説明します。

 -- Function: skip-syntax-forward syntaxes &optional
          limit
     この関数は、SYNTAXESで指定された構文クラス(構文クラ
     スの文字列)をもつ文字を横断して、ポイントを前方に移
     動する。バッファー終端か、(与えられた場合は)位置
     LIMITに到達、またはスキップしない文字に達した際に停
     止する。

     SYNTAXESが‘^’で始まる場合、この関数は構文が
     SYNTAXESでは_ない_文字をスキップする。

     リターン値は、移動した距離を表す非負の整数。

 -- Function: skip-syntax-backward syntaxes &optional
          limit
     この関数は、SYNTAXESで指定された構文クラスをもつ文
     字を横断して、ポイントを後方に移動する。バッファー
     先頭か、(与えられた場合は)位置LIMITに到達、またはス
     キップしない文字に達した際に停止する。

     SYNTAXESが‘^’で始まる場合、この関数は構文が
     SYNTAXESでは_ない_文字をスキップする。

     リターン値は、移動した距離を表す0以下の整数。

 -- Function: backward-prefix-chars
     この関数は、式プレフィクス構文の任意個数の文字を横
     断して、後方にポイントを移動する。これには式プレフ
     ィクス構文クラスと、フラグ‘p’の文字の両方が含まれる
     。


File: elisp,  Node: Parsing Expressions,  Next: Syntax Table Internals,  Prev: Motion and Syntax,  Up: Syntax Tables

34.6 Parsing Expressions
========================

このセクションでは、バランスのとれた式の解析やスキャンを
行う関数を説明します。たとえこれらの関数がLisp以外の言語
にたいして作用可能であったとしても、Lisp用語にしたがい、
そのような式のことは“sexps”という用語で参照することにし
ます。基本的にsexpは、バランスのとれたカッコによるグルー
プ化、または文字列、“symbol”(構文が単語構成要素かシンボ
ル構成要素である文字シーケンス)のいずれかです。しかし式
プレフィクス構文(*note Syntax Class Table::を参照)の文字
は、それらがsexpに隣接する場合は、sexpの一部として扱われ
ます。

   構文テーブルは文字の解釈を制御するので、これらの関数
はLispモードでのLisp式、CモードでのCの式にたいして使用で
きます。バランスのとれた式にたいする、有用な高レベル関数
については、*note List Motion::を参照してください。

   ある文字の構文は、パーサー自身の状態の記述ではなく、
パーサー状態の変更方法を制御します。たとえば文字列区切り
文字は、“in-string”と“in-code”,の間でパーサー状態をトグ
ルしますが、文字の構文が直接文字列内部にあるかどうかを告
げることはありません。たとえば(15は汎用文字列区切りの構
文コードであることに注意)、

     (put-text-property 1 9 'syntax-table '(15 . nil))

これはEmacsにたいして、カレントバッファーの最初の8文字が
文字列であることを告げますが、それらはすべて文字列区切り
です。結果としてEmacsはそれらを、連続する4つの空文字列定
数として扱います。

* Menu:

* Motion via Parsing::       パースにより機能する移動関数。
* Position Parse::           ある位置の構文状態を判断する。
* Parser State::             Emacsが構文状態を表す方法。
* Low-Level Parsing::        指定されたリージョンを横断するパース。
* Control Parsing::          パースに影響するパラメーター。


File: elisp,  Node: Motion via Parsing,  Next: Position Parse,  Up: Parsing Expressions

34.6.1 Motion Commands Based on Parsing
---------------------------------------

このセクションでは、式のパースにもとづいて処理を行う、シ
ンプルなポイント移動関数を説明します。

 -- Function: scan-lists from count depth
     この関数は、位置FROMからバランスのとれたカッコのグ
     ループをCOUNT個、前方にスキャンする。これはスキャン
     が停止した位置をリターンする。COUNTが負なら、スキャ
     ンは後方に移動する。

     DEPTHが非0なら、開始位置のカッコのネスト深さを
     DEPTHとして扱う。スキャナーは、ネスト深さが0になる
     までCOUNT回、繰り返し前方または後方に移動する。その
     ため、正のDEPTHは開始位置からカッコをDEPTHレベル抜
     け出して移動する効果があり、負のDEPTHはカッコが
     DEPTHレベル深くなるよう移動する効果をもつ。

     ‘parse-sexp-ignore-comments’が非‘nil’なら、スキャン
     はコメントを無視する。

     COUNT個のカッコのグループをスキャンする前に、スキャ
     ンがバッファーのアクセス可能範囲の先頭か終端に達し
     た場合、そのポイントのネスト深さが0なら、値‘nil’を
     リターンする。ネスト深さが非0なら、‘scan-error’エラ
     ーをシグナルする。

 -- Function: scan-sexps from count
     この関数は位置FROMから、COUNT個のsexpを前方にスキャ
     ンする。これは、スキャンが停止した位置をリターンす
     る。COUNTが負なら、スキャンは後方へ移動する。

     ‘parse-sexp-ignore-comments’が非‘nil’なら、スキャン
     はコメントを無視する。

     カッコのグループの中間でバッファー(のアクセス可能範
     囲)の先頭か終端に達した場合は、エラーをシグナルする
     。COUNT個を消費する前に、カッコのグループの間でバッ
     ファーの先頭か終端に達した場合は、‘nil’をリターンす
     る。ネスト深さが非0なら、‘scan-error’エラーをシグナ
     ルする。

 -- Function: forward-comment count
     この関数は、COUNT個の完全なコメント(すなわち、もし
     あれば開始区切りと終了区切りを含む)、および途中で遭
     遇する任意の空白文字を横断して、ポイントを前方に移
     動する。COUNTが負なら、後方に移動する。コメントまた
     は空白文字以外のものに遭遇したら停止して、その停止
     位置にポイントを残す。これには、(たとえば)前方に移
     動してコメント開始を調べる際に、コメント終了を探す
     ことも含まれる。この関数は、指定された個数の完全な
     コメントを横断して移動した後も、即座に停止する。空
     白以外のものがコメント間に存在せずに、期待どおり
     COUNT個のコメントが見つかったら‘t’を、それ以外は
     ‘nil’をリターンする。

     この関数は、“コメント”を横断する際、それが文字列内
     に埋め込まれているかどうか区別できない。コメントの
     ように見えれば、それらはコメントとして扱われる。

     ポイント後のすべてのコメントと空白文字を飛び越して
     移動するには、‘(forward-comment (buffer-size))’を使
     用する。バッファー内のコメント数は‘(buffer-size)’を
     超えることはできないので、これは引数としての使用に
     適す。


File: elisp,  Node: Position Parse,  Next: Parser State,  Prev: Motion via Parsing,  Up: Parsing Expressions

34.6.2 Finding the Parse State for a Position
---------------------------------------------

インデントのような構文分析にとっては、与えられたバッファ
ー位置に応じた構文状態の計算が有用なことが多々あります。
それを手軽に行うのが、この関数です。

 -- Function: syntax-ppss &optional pos
     この関数は、パーサーがバッファー先頭から開始して位
     置POSで停止するだろうという、パーサー状態をリターン
     する。 パーサー状態の説明は、*note Parser State::を
     参照のこと 。

     リターン値は、バッファー先頭からPOSまでパースするた
     めに低レベル関数‘parse-partial-sexp’(*note
     Low-Level Parsing::を参照)を呼び出した場合と同じよ
     うになる。しかし‘syntax-ppss’は、計算速度向上のため
     に、キャッシュを使用する。この最適化のため、リター
     ンされるパーサー状態のうち2つ目の値(前の完全な部分
     式)と6つ目の値(最小のカッコ深さ)は意味をもたない。

     この関数は、‘syntax-ppss-flush-cache’(以下参照)にた
     いして、‘before-change-functions’(*note Change
     Hooks::を参照)にバッファーローカルなエントリーを追
     加するという副作用をもつ。このエントリーは、バッフ
     ァー変更にたいして、キャッシュの一貫性を保つ。とは
     いえ、‘before-change-functions’が一時的にletでバイ
     ンドされている間に‘syntax-ppss’が呼び出された場合、
     または‘inhibit-modification-hooks’使用時のようにバ
     ッファーがフックを実行せずに変更される場合、キャッ
     シュは更新されないかもしれない。そのような場合は、
     明示的に‘syntax-ppss-flush-cache’を呼び出す必要があ
     る。

 -- Function: syntax-ppss-flush-cache beg &rest
          ignored-args
     この関数は、‘syntax-ppss’が使用するキャッシュを、位
     置BEGからフラッシュする。残りの引数IGNORED-ARGSは無
     視される。‘before-change-functions’(*note Change
     Hooks::を参照)のような関数で直接使用できるよう、こ
     の関数はそれらの引数を受け入れる。

   メジャーモードは、パース開始を要する箇所を指定するこ
とにより、‘syntax-ppss’の実行をより高速にできます。

 -- Variable: syntax-begin-function
     これが非‘nil’なら、それはパーサー状態が‘nil’である
     ような以前のバッファー位置(別の言い方をすると任意の
     コメント、文字列、カッコの外部であるような位置)に移
     動する関数であること。キャッシュが助けとならない際
     、‘syntax-ppss’はその計算をおり最適化するためにこれ
     を使用する。


File: elisp,  Node: Parser State,  Next: Low-Level Parsing,  Prev: Position Parse,  Up: Parsing Expressions

34.6.3 Parser State
-------------------

“パーサー状態(parser state)”とは、バッファー内の指定され
た開始位置と終了位置の間のテキストをパースした後の、構文
パーサーの状態を記述する10要素のリストです。
‘syntax-ppss’のようなパース関数 (*note Position Parse::を
参照) は、値としてパーサー状態をリターンします。いくつか
のパース関数は、パースを再開するために、引数としてパーサ
ー状態を受け取ります。

   以下は、パーサー状態の要素の意味です:

  0. 0から数えたカッコの深さ。*警告:* パーサーの開始位置
     と終了位置の間に開カッコより多くの閉カッコがあれば
     、負になることもある。

  1. 停止位置を含む最内のカッコグループの開始文字位置。
     なければ‘nil’。

  2. 最後の終端された完全な部分式の開始文字位置。なけれ
     ば‘nil’。

  3. 文字列内部なら非‘nil’。より正確には、文字列を終端さ
     せるであろう文字か、汎用文字列区切りが終端すべきよ
     うな場合は‘t’となる。

  4. ネスト不可なコメント(または任意のコメントスタイル。
     *note Syntax Flags::を参照されたい)の内部なら‘t’、
     ネスト可なコメントの内部ならコメントのネストレベル
     。

  5. 終了位置がクォート文字直後なら‘t’。

  6. 当該スキャン中に遭遇した最小のカッコ深さ。

  7. アクティブなコメントの種類。コメント以外、またはス
     タイル‘a’のコメント内なら‘nil’、スタイル‘b’のコメン
     トなら1、スタイル‘c’のコメントなら2、汎用コメント区
     切り文字で終端されるべきコメントなら
     ‘syntax-table’。

  8. 文字列またはコメントの開始位置。コメント内部ならコ
     メントが始まる位置。文字列内部なら文字列が始まる位
     置。文字列またはコメントの外部なら、この要素は
     ‘nil’になる。

  9. パースを継続するための内部データ。このデータのもつ
     意味は、変更され得る。これは、他の呼び出しのSTATE引
     数としてこのリストを渡す場合に使用される。

   パース継続のために渡す場合、要素1、2、6は無視され、要
素8と9は特に重要ではない場面でのみ使用されます。これらの
要素は主に、パーサーコードにより内部的に使用されます。

   以下の関数を使用することにより、さらに追加でパーサー
状態から有用な情報を利用できます:

 -- Function: syntax-ppss-toplevel-pos state
     この関数はパーサー状態STATEから、文法構造上トップレ
     ベルでのパースにおける、スキャンした最後の位置をリ
     ターンする。“トップレベル”とは、すべてのカッコ、コ
     メント、文字列の外部であることを意味する。

     STATEがトップレベルの位置に到達したパースを表す場合
     、値は‘nil’となる。


File: elisp,  Node: Low-Level Parsing,  Next: Control Parsing,  Prev: Parser State,  Up: Parsing Expressions

34.6.4 Low-Level Parsing
------------------------

式パーサーを使用するもっとも基本的な方法は、特定の状態で
与えられた位置からパースを開始して、指定した位置でパース
を終了するよう指示する方法です。

 -- Function: parse-partial-sexp start limit &optional
          target-depth stop-before state stop-comment
     この関数は、カレントバッファー内のsexpを、STARTから
     開始してLIMITを超えてスキャンしないようパースを行う
     。これは位置LIMIT、または以下に記述する特定の条件に
     適合したら停止して、パースが停止した位置にポイント
     をセットする。これはポイントが停止した位置でのパー
     スの状態を記述するパーサー状態 (*note Parser
     State::を参照) をリターンする。

     3つ目の引数TARGET-DEPTHが非‘nil’の場合、カッコの深
     さがTARGET-DEPTHと等しくなったら、パースを停止する
     。この深さは0、またはSTATE内で与えられる深さなら何
     であれ、そこより開始される。

     4つ目の引数STOP-BEFOREが非‘nil’の場合、sexp開始とな
     る任意の文字に到達したらパースは停止する。
     STOP-COMMENTが非‘nil’なら、コメントの開始でパースは
     停止する。STOP-COMMENTがシンボル‘syntax-table’なら
     、コメントか文字列の開始の後、またはコメントか文字
     列の終了のいずれか先に到達した方でパースは停止する
     。

     STATEが‘nil’なら、STARTは関数定義先頭のような、カッ
     コ構造のトップレベルであるとみなされる。かわりにこ
     の構造の中間でパースを再開したいと思うかもしれない
     。これを行うには、パースの初期状態を記述するSTATE引
     数を提供しなければならない。前の
     ‘parse-partial-sexp’呼び出しでリターンされた値で、
     これをうまく行うことができるだろう。


File: elisp,  Node: Control Parsing,  Prev: Low-Level Parsing,  Up: Parsing Expressions

34.6.5 Parameters to Control Parsing
------------------------------------

 -- Variable: multibyte-syntax-as-symbol
     この変数が非‘nil’なら、構文テーブルがそれらについて
     何と言っているかに関わらず、‘scan-sexps’はすべての
     非ASCII文字をシンボル構成要素として扱う(とはいえ依
     然としてテキストプロパティは構文をオーバーラードで
     きるが)。

 -- User Option: parse-sexp-ignore-comments
     この値が非‘nil’なら、このセクション内の関数、および
     ‘forward-sexp’、‘scan-lists’、‘scan-sexps’はコメン
     トを空白文字として扱う。

   ‘parse-partial-sexp’の振る舞いも、
‘parse-sexp-lookup-properties’の影響を受けます(*note
Syntax Properties::を参照)。

   1つ、または複数のコメントを横断して前方または後方に移
動するには、‘forward-comment’を使用できます。


File: elisp,  Node: Syntax Table Internals,  Next: Categories,  Prev: Parsing Expressions,  Up: Syntax Tables

34.7 Syntax Table Internals
===========================

構文テーブルは文字テーブル(*note Char-Tables::を参照)と
して実装されていますが、ほとんどのLispプログラムが直接そ
れらの要素に作用することはありません。構文テーブルは構文
データとして構文記述子を格納しません(*note Syntax
Descriptors::を参照)。それらは内部的なフォーマットを使用
しており、それについてはこのセクションで説明します。この
内部的フォーマットは、構文プロパティとして割り当てること
もできます(*note Syntax Properties::を参照)。

   構文テーブル内の各要素は“raw構文記述子(raw syntax
descriptor)”という、‘(SYNTAX-CODE . MATCHING-CHAR)’とい
う形式のコンスセルです。SYNTAX-CODEは、下記のテーブルに
応じて構文クラスと構文フラグをエンコードする整数です。
MATCHING-CHARが非‘nil’なら、それはマッチング文字(構文記
述子内の2つ目の文字と同様)を指定します。

   以下は、さまざまな構文クラスに対応する構文コードです
。

Code        Class             Code        Class
0           空白文字          8           区切り文字ペア
                                          ー
1           句読点            9           エスケープ
2           単語              10          文字クォート
3           シンボル          11          コメント開始
4           開カッコ          12          コメント終了
5           閉カッコ          13          継承
6           式プレフィクス    14          汎用コメント
7           文字列クォート    15          汎用文字列

たとえば標準構文テーブルでは、‘(’にたいするエントリーは
‘(4 . 41)’であり、41は‘)’の文字コードです。

   構文フラグは、最下位ビットから16ビット目より始まる、
高位ビットにエンコードされます。以下のテーブルは、対応す
る各構文フラグにたいして、2のべき乗を与えます。

Prefix   Flag              Prefix   Flag
‘1’      ‘(lsh 1 16)’      ‘p’      ‘(lsh 1 20)’
‘2’      ‘(lsh 1 17)’      ‘b’      ‘(lsh 1 21)’
‘3’      ‘(lsh 1 18)’      ‘n’      ‘(lsh 1 22)’
‘4’      ‘(lsh 1 19)’

 -- Function: string-to-syntax desc
     与えられた構文記述子DESC(文字列)にたいして、この関
     数は対応するraw構文記述子をリターンする。

 -- Function: syntax-after pos
     この関数は、バッファー内の位置POSの後の文字にたいし
     て、構文テーブルと同様に構文プロパティも考慮した、
     raw構文記述子をリターンする。POSがバッファーのアク
     セス可能範囲(*note accessible portion: Narrowing.を
     参照)の外部なら、リターン値は‘nil’となる。

 -- Function: syntax-class syntax
     この関数はraw構文記述子SYNTAXにたいする、構文コード
     をリターンする。より正確には、これはraw構文記述子の
     SYNTAX-CODE要素から、構文フラグを記録する高位16ビッ
     トをマスクして、その結果の整数をリターンする。

     SYNTAXが‘nil’なら、リターン値は‘nil’となる。これは
     以下の式

          (syntax-class (syntax-after pos))

     は、‘pos’がバッファーのアクセス可能範囲外部なら、エ
     ラーをthrowしたり不正なコードをリターンすることなく
     、‘nil’に評価されるからである。


File: elisp,  Node: Categories,  Prev: Syntax Table Internals,  Up: Syntax Tables

34.8 Categories
===============

“カテゴリー(categories)”は、構文的に文字をクラス分けする
別の手段を提供します。必要に応じて複数のカテゴリーを定義
して、それぞれの文字に独立して1つ以上のカテゴリーを割り
当てることができます。構文クラスと異なり、カテゴリーは互
いに排他ではありません。1つの文字が複数のカテゴリーに属
すのは、普通のことです。

   バッファーはそれぞれ“カテゴリーテーブル(category
table)”をもっています。これはどのカテゴリーが定義されて
いて、各カテゴリーにどの文字が属すかを記録しています。カ
テゴリーテールは自身のカテゴリーを定義しますが、標準カテ
ゴリーはすべてのモードで利用可能なので、通常これらは標準
カテゴリーテーブルをコピーすることにより初期化されます。

   カテゴリーはそれぞれ、‘ ’から‘~’の範囲のASCIIプリント
文字による名前をもちます。‘define-category’で定義する際
は、カテゴリーの名前を指定します。

   カテゴリーテーブルは、実際には文字テーブルです(*note
Char-Tables::を参照)。カテゴリーテーブルのインデックス
Cの要素は、文字Cが属するカテゴリーを示す“カテゴリーセッ
ト(category set)”というブールベクターです。このカテゴリ
ーセット内で、もしインデックスCATの要素が‘t’なら、CATは
そのセットのメンバーであり、その文字CはカテゴリーCATに属
することを意味します。

   以下の3つの関数では、オプション引数TABLEのデフォルト
はカレントバッファーのカテゴリーテーブルです。

 -- Function: define-category char docstring &optional
          table
     この関数はカテゴリーテーブルTABLEにたいして、名前が
     CHAR、ドキュメントがDOCSTRINGであるような、新たなカ
     テゴリーを定義する。

     以下に強い右から左への指向性をもつ文字(*note
     Bidirectional Display::を参照)にたいするカテゴリー
     を新たに定義して、それを特別なカテゴリーテーブル内
     で使用する例を示す:

          (defvar special-category-table-for-bidi
            (let ((category-table (make-category-table))
          	(uniprop-table (unicode-property-table-internal 'bidi-class)))
              (define-category ?R "Characters of bidi-class R, AL, or RLO"
                               category-table)
              (map-char-table
               #'(lambda (key val)
          	 (if (memq val '(R AL RLO))
          	     (modify-category-entry key ?R category-table)))
               uniprop-table)
              category-table))

 -- Function: category-docstring category &optional
          table
     この関数は、カテゴリーテーブルTABLE内のカテゴリー
     CATEGORYの、ドキュメント文字列をリターンする。

          (category-docstring ?a)
               ⇒ "ASCII"
          (category-docstring ?l)
               ⇒ "Latin"

 -- Function: get-unused-category &optional table
     この関数は、TABLE内で現在のところ未定義なカテゴリー
     の名前(文字)をリターンする。TABLE内で利用可能なカテ
     ゴリーがすべて使用済みなら、‘nil’をリターンする。

 -- Function: category-table
     この関数は、カレントバッファーのカテゴリーテーブル
     をリターンする。

 -- Function: category-table-p object
     この関数は、OBJECTがカテゴリーテーブルなら‘t’、それ
     以外は‘nil’をリターンする。

 -- Function: standard-category-table
     この関数は、標準カテゴリーテーブルをリターンする。

 -- Function: copy-category-table &optional table
     この関数は、TABLEのコピーを構築して、それをリターン
     する。TABLEが与えられない(または‘nil’)場合は、標準
     カテゴリーテーブルのコピーをリターンする。それ以外
     の場合は、もしTABLEがカテゴリーテーブルでなければ、
     エラーをシグナルする。

 -- Function: set-category-table table
     この関数は、TABLEをカレントバッファーのカテゴリーテ
     ーブルにする。リターン値はTABLE。

 -- Function: make-category-table
     これは空のカテゴリーテーブルを作成してリターンする
     。 This creates and returns an empty category
     table. 空のカテゴリーテーブルでは、どのカテゴリーも
     割り当てられておらず、何らかのカテゴリーに属する文
     字もない。

 -- Function: make-category-set categories
     この関数は、初期内容が文字列CATEGORIESにリストされ
     るカテゴリーであるような、新たなカテゴリーセット(ブ
     ールベクター)をリターンする。CATEGORIESの要素はカテ
     ゴリー名であること。新たなカテゴリーセットはそれら
     のカテゴリーにたいして‘t’、それ以外のすべてのカテゴ
     リーにたいして‘nil’をもつ。

          (make-category-set "al")
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: char-category-set char
     この関数は、カレントバッファーのカテゴリーテーブル
     内で、文字CHARにたいするカテゴリーセットをリターン
     する。これは文字CHARが属するカテゴリーを記録するブ
     ールベクターである。関数‘char-category-set’は、カテ
     ゴリーテーブル内にある同じブールベクターをリターン
     するので、メモリーの割り当ては行わない。

          (char-category-set ?a)
               ⇒ #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: category-set-mnemonics category-set
     この関数は、カテゴリーセットCATEGORY-SETを、そのセ
     ットのメンバーのカテゴリーを指定する文字を含む文字
     列に変換する。

          (category-set-mnemonics (char-category-set ?a))
               ⇒ "al"

 -- Function: modify-category-entry char category
          &optional table reset
     この関数は、カテゴリーテーブルTABLE(デフォルトはカ
     レントバッファーのカテゴリーテーブル)内の、CHARのカ
     テゴリーセットを変更する。CHARには文字、または‘(MIN
     . MAX)’という形式のコンスセルを指定できる。後者の場
     合、この関数はMINとMAXの間(両端を含む)の範囲にある
     、すべての文字のカテゴリーセットを変更する。

     これは通常、カテゴリーセットにCATEGORYを追加するこ
     とにより、変更を行う。しかしRESETが非‘nil’なら、か
     わりにCATEGORYを削除する。

 -- Command: describe-categories &optional
          buffer-or-name
     この関数は、カレントカテゴリーテーブル内のカテゴリ
     ー仕様を説明する。これはその説明をバッファーに挿入
     してから、そのバッファーを表示する。
     BUFFER-OR-NAMEが非‘nil’なら、かわりにそのバッファー
     のカテゴリーテーブルを説明する。


File: elisp,  Node: Abbrevs,  Next: Processes,  Prev: Syntax Tables,  Up: Top

35 Abbrevs and Abbrev Expansion
*******************************

略語(abbreviation)、または“abbrev”は、より長い文字列へと
展開される文字列です。ユーザーはabbrev文字列を挿入して、
それを探して自動的にabbrevの展開形に置換できます。これに
よりタイプ量を節約できます。

   カレントで効果をもつabbrevsのセットは、“abbrevテーブ
ル(abbrev table)”内に記録されます。バッファーはそれぞれ
ローカルにabbrevテーブルをもちますが、通常は同一のメジャ
ーモードにあるすべてのバッファーが1つのabbrevテーブルを
共有します。グローバルabbrevテーブルも存在します。通常は
両者が使用されます。

   abbrevテーブルはobarrayとして表されます。obarraysにつ
いての情報は、*note Creating Symbols::を参照してください
。,abbrevはそれぞれ、obarray内のシンボルとして表現されま
す。そのシンボルの名前がabbrevで、値が展開形になります。
シンボルの関数定義は展開を行うフック関数です(*note
Defining Abbrevs::を参照)。また、シンボルノプロパティセ
ルには、使用回数やそのabbrevが展開された回数を含む、さま
ざまな追加プロパティが含まれます(*note Abbrev
Properties::を参照)。

   “システムabbrev(system abbrevs)”と呼ばれる特定の
abbrevは、ユーザーではなくメジャーモードにより定義されま
す。システムabbrevは、非‘nil’の‘:system’プロパティにより
識別されます(*note Abbrev Properties::を参照)。abbrevが
abbrevファイルに保存される際、システムabbrevは省略されま
す。*note Abbrev Files::を参照してください。

   abbrevに使用されるシンボルは通常のobarrayにinternされ
ないので、Lisp式の読み取り結果として現れることは決してあ
りません。実際に、通常はabbrevを扱うコードを除き、それら
が使用されることはありません。したがって、それらを非標準
的な方法で使用しても安全なのです。

   マイナーモードであるAbbrevモードが有効な場合、バッフ
ァーローカル変数‘abbrev-mode’は非‘nil’となり、そのバッフ
ァー内で、abbrevは自動的に展開されます。abbrev用のユーザ
ーレベルのコマンドについては、*note Abbrev Mode:
(emacs)Abbrevs.を参照してください。

* Menu:

* Tables: Abbrev Tables.     abbrevテーブルの作成と操作。
* Defining Abbrevs::         略語の指定とそれらの展開。
* Files: Abbrev Files.       ファイルへのabbrevの保存。
* Expansion: Abbrev Expansion.  展開の制御と展開サブルーチン。
* Standard Abbrev Tables::   種々メジャーモードに使用されるabbrevテーブル。
* Abbrev Properties::        abbrevプロパティの読み取りとセットを行う方法。どのプロパティが何の効果をもつか。
* Abbrev Table Properties::  abbrevテーブルプロパティの読み取りとセットを行う方法。どのプロパティが効果をもつか。


File: elisp,  Node: Abbrev Tables,  Next: Defining Abbrevs,  Up: Abbrevs

35.1 Abbrev Tables
==================

このセクションでは、abbrevテーブルの作成と操作を行う方法
について説明します。

 -- Function: make-abbrev-table &optional props
     この関数は、空のabbrevテーブル(シンボルを含まない
     obarray)を作成してリターンする。これは0で充填された
     ベクターである。PROPSは、新たなテーブルに適用される
     プロパティリストである(*note Abbrev Table
     Properties::を参照)。

 -- Function: abbrev-table-p object
     この関数は、OBJECTがabbrevテーブルなら、非‘nil’をリ
     ターンする。

 -- Function: clear-abbrev-table abbrev-table
     この関数は、ABBREV-TABLE内のabbrevをすべて未定義と
     し、空のまま残す。

 -- Function: copy-abbrev-table abbrev-table
     この関数は、ABBREV-TABLEのコピー(同じabbrev定義を含
     む新たなabbrevテーブル)をリターンする。これは名前、
     値、関数だけをコピーし、プロパティリストは何も_コピ
     ーしない_。

 -- Function: define-abbrev-table tabname definitions
          &optional docstring &rest props
     この関数はabbrevテーブル名(値がabbrevテーブルである
     ような変数)としてTABNAME(シンボル)を定義する。これ
     は、そのテーブル内にDEFINITIONSに応じて、abbrevを定
     義する。DEFINITIONSは、‘(ABBREVNAME EXPANSION
     [HOOK] [PROPS...])’という形式の要素をもつリストであ
     る。これらの要素は引数として、‘define-abbrev’に渡さ
     れる。

     オプション文字列DOCSTRINGは、変数TABNAMEのドキュメ
     ント文字列である。プロパティリストPROPSは、abbrevテ
     ーブルに適用される(*note Abbrev Table Properties::を
     参照)。

     同一のTABNAMEにたいしてこの関数が複数回呼び出された
     場合は、元のコンテンツ全体を上書きせずに、後続の呼
     び出しはDEFINITIONS内の定義をTABNAMEに追加する(後続
     の呼び出しでは、DEFINITIONS内で明示的に再定義または
     未定義にした場合のみabbrevを上書きできる)。

 -- Variable: abbrev-table-name-list
     これは、値がabbrevテーブルであるようなシンボルのリ
     ストである。‘define-abbrev-table’は、このリストに新
     たなabbrevテーブル名を追加する。

 -- Function: insert-abbrev-table-description name
          &optional human
     この関数は、ポイントの前に名前がNAMEのabbrevテーブ
     ルの説明を挿入する。引数NAMEは、値がabbrevテーブル
     であるようなシンボルである。

     HUMANが非‘nil’なら、説明は人間向けになる。システム
     abbrevはそのようにリストされ、識別される。それ以外
     なら説明はLisp式(カレントで定義されているように
     NAMEを定義するが、システムabbrevとしては定義しない
     ような‘define-abbrev-table’呼び出し)となる(NAMEを使
     用するモードまたはパッケージは、それらを個別に
     NAMEに追加すると想定されている)。


File: elisp,  Node: Defining Abbrevs,  Next: Abbrev Files,  Prev: Abbrev Tables,  Up: Abbrevs

35.2 Defining Abbrevs
=====================

‘define-abbrev’は、abbrevテーブル内にabbrevを定義するた
めの基本的な低レベル関数です。

   メジャーモードがシステムabbrevを定義する際は、
‘:system’プロパティに‘t’を指定して‘define-abbrev’を呼び
出すべきです。すべての保存された非“システム”abbrevは起動
時(何らかのメジャーモードがロードされる前)にリストアされ
ることに注意してください。したがってメジャーモードは、最
初にそのモードがロードされた際、それらのモードのabbrevテ
ーブルが空であると仮定するべきではありません。

 -- Function: define-abbrev abbrev-table name expansion
          &optional hook &rest props
     この関数は、ABBREV-TABLE内にNAMEという名前で、
     EXPANSIONに展開され、HOOKを呼び出すabbrevを、プロパ
     ティPROPS(*note Abbrev Properties::を参照)とともに
     定義する。リターン値はNAME。ここでは、PROPS内の
     ‘:system’プロパティは特別に扱われる。このプロパティ
     が値‘force’をもつなら、たとえ同じ名前の非“システム
     ”abbrevでも、既存の定義を上書きするだろう。

     NAMEは文字列であること。引数EXPANSIONは通常は望む展
     開形(文字列)であり、‘nil’ならそのabbrevを未定義とす
     る。これが文字列または‘nil’以外の何かなら、その
     abbrevはHOOKを実行することにより、単に“展開”される
     。

     引数HOOKは、関数または‘nil’であること。HOOKが非
     ‘nil’なら、abbrevがEXPANSIONに置換された後に、引数
     なしでそれが呼び出される。HOOK呼び出し時、ポイント
     はEXPANSIONの終端に置かれる。

     HOOKが、‘no-self-insert’プロパティが非‘nil’であるよ
     うな、非‘nil’のシンボルなら、HOOKは展開をトリガーす
     るような自己挿入入力文字を挿入できるかどうかを、明
     示的に制御できる。この場合、HOOKが非‘nil’をリターン
     したら、その文字の挿入を抑止する。対照的に、HOOKが
     ‘nil’をリターンした場合は、あたかも実際には展開が行
     われなかったかのように、‘expand-abbrev’(または
     ‘abbrev-insert’)も‘nil’をリターンする。

     通常‘define-abbrev’は、実際にabbrevを変更した場合は
     、変数‘abbrevs-changed’に‘t’をセットする。これはい
     くつかのコマンドが、abbrevの保存を提案するためであ
     る。システムabbrevは、いずれにせよ保存されないので
     、システムabbrevにたいして、これは行われない。

 -- User Option: only-global-abbrevs
     この変数が非‘nil’なら、それはユーザーがグローバル
     abbrevのみの使用を計画していることを意味する。これ
     はモード固有のabbrevを定義するコマンドにたいして、
     かわりにグローバルabbrevを定義するよう指示する。こ
     の変数は、このセクション内の関数の振る舞いを変更し
     ない。それは呼び出し側により検証される。


File: elisp,  Node: Abbrev Files,  Next: Abbrev Expansion,  Prev: Defining Abbrevs,  Up: Abbrevs

35.3 Saving Abbrevs in Files
============================

abbrev定義が保存されたファイルは、実際にはLispコードのフ
ァイルです。abbrevは、同じコンテンツの同じabbrevテーブル
を定義する、Lispプログラムの形式で保存されます。したがっ
てそのファイルは、‘load’でロードすることができます(*note
How Programs Do Loading::を参照)。しかし、より簡便なイン
ターフェースとして、関数‘quietly-read-abbrev-file’が提供
されています。起動時に、Emacsは自動的にこの関数を呼び出
します。

   ‘save-some-buffers’のようなユーザーレベルの機能は、こ
こで説明する変数の制御下で、自動的にabbrevをファイルに保
存できます。

 -- User Option: abbrev-file-name
     これは、abbrevの読み込みと保存のための、デフォルト
     のファイル名である。

 -- Function: quietly-read-abbrev-file &optional
          filename
     この関数は、以前に‘write-abbrev-file’で書き込まれた
     、FILENAMEという名前のファイルから、abbrevの定義を
     読み込む。FILENAMEが省略または‘nil’なら、
     ‘abbrev-file-name’内で指定されているファイルが使用
     される。

     その名前が暗示するように、この関数は何のメッセージ
     も表示しない。

 -- User Option: save-abbrevs
     ‘save-abbrevs’にたいする非‘nil’値は、ファイル保存時
     に、(もし何か変更されていれば)Emacsがabbrevの保存を
     提案するべきであることを意味する。値が‘silently’な
     ら、Emacsはユーザーに尋ねることなく、abbrevを保存す
     る。‘abbrev-file-name’は、abbrevを保存するファイル
     を指定する。

 -- Variable: abbrevs-changed
     この変数は、abbrev(システムabbrevを除く)の定義また
     は変更によりセットされる。これは、さまざまなEmacsコ
     マンドにとって、ユーザーにabbrevの保存を提案するた
     めの、フラグとしての役目をもつ。

 -- Command: write-abbrev-file &optional filename
     ‘abbrev-table-name-list’内にリストされたすべての
     abbrevテーブルにたいして、すべてのabbrev定義(システ
     ムabbrevを除く)を、ロード時に同じabbrevを定義するで
     あろうLispプログラム形式で、ファイルFILENAME内に保
     存する。FILENAMEが‘nil’なら、‘abbrev-file-name’が仕
     様される。この関数は‘nil’をリターンする。


File: elisp,  Node: Abbrev Expansion,  Next: Standard Abbrev Tables,  Prev: Abbrev Files,  Up: Abbrevs

35.4 Looking Up and Expanding Abbreviations
===========================================

abbrevは通常、‘self-insert-command’を含む、特定の
interactiveなコマンドにより展開されます。このセクション
では、そのようなコマンドの記述に使用されるサブルーチン、
並びに通信のために使用される変数について説明します。

 -- Function: abbrev-symbol abbrev &optional table
     この関数は、ABBREVという名前のabbrevを表すシンボル
     をリターンする。そのabbrevが定義されていなければ、
     ‘nil’をリターンする。オプションの2つ目の引数TABLEは
     、それを照合するためのabbrevテーブルである。TABLEが
     ‘nil’なら、この関数はまずカレントバッファーのローカ
     ルabbrevテーブル、次にグローバルabbrevテーブルを試
     みる。

 -- Function: abbrev-expansion abbrev &optional table
     この関数は、ABBREVが展開されるであろう文字列(カレン
     トバッファーにたいして使用されるabbrevテーブルで定
     義される文字列)をリターンする。これはABBREVが有効な
     abbrevでなければ、‘nil’をリターンする。オプション引
     数TABLEは‘abbrev-symbol’の場合と同様、使用する
     abbrevテーブルを指定する。

 -- Command: expand-abbrev
     このコマンドは、(もしあれば)ポイントの前のabbrevを
     展開する。ポイントがabbrevの後になければ、このコマ
     ンドは何もしない。展開を行うために、これは変数
     ‘abbrev-expand-function’の値となっている関数を引数
     なしで呼び出し、何であれその関数がリターンしたもの
     をリターンする。

     デフォルトの展開関数は、展開を行ったらabbrevのシン
     ボル、それ以外は‘nil’をリターンする。そのabbrevシン
     ボルが、‘no-self-insert’プロパティが非‘nil’のシンボ
     ルであるようなフック関数をもち、そのフック関数が値
     として‘nil’をリターンした場合は、たとえ展開が行われ
     たとしても、デフォルト展開関数は‘nil’をリターンする
     。

 -- Function: abbrev-insert abbrev &optional name start
          end
     この関数は、‘start’と‘end’の間のテキストを置換する
     ことにより、‘abbrev’のabbrev展開形を挿入する。
     ‘start’が省略された場合のデフォルトは、ポイントであ
     る。‘name’が非‘nil’なら、それはこのabbrevが見つかっ
     た名前(文字列)であること。これは展開形の
     capitalizationを調整するかどうかを判断するために使
     用される。この関数は、abbrevの挿入に成功したら
     ‘abbrev’をリターンする。

 -- Command: abbrev-prefix-mark &optional arg
     このコマンドは、ポイントのカレント位置を、abbrevの
     開始としてマークする。‘expand-abbrev’の次回呼び出し
     では、通常のように以前の単語ではなく、ここからポイ
     ント(その時点での位置)にあるテキストが展開するべき
     abbrevとして使用される。

     このコマンドはまず、ARGが‘nil’なら、ポイントの前の
     任意のabbrevを展開する(インタラクティブな呼び出しで
     は、ARGはプレフィクス引数である)。それから、展開す
     る次のabbrevの開始を示すために、ポイントの前にハイ
     フンを挿入する。実際の展開では、ハイフンは削除され
     る。

 -- User Option: abbrev-all-caps
     これが非‘nil’にセットされているときは、すべて大文字
     で入力されたabbrevは、すべて大文字を使用して展開さ
     れる。それ以外なら、すべて大文字で入力された
     abbrevは、展開形の単語ごとにcapitalizeして展開され
     る。

 -- Variable: abbrev-start-location
     この変数の値は、次にabbrevを展開する開始位置として
     ‘expand-abbrev’に使用される、バッファー位置である。
     値は‘nil’も可能で、かわりにポイントの前の単語を使用
     することを意味する。‘abbrev-start-location’は、
     ‘expand-abbrev’の呼び出しごとに、毎回‘nil’にセット
     される。この変数は、‘abbrev-prefix-mark’によっても
     セットされる。

 -- Variable: abbrev-start-location-buffer
     この変数の値は、‘abbrev-start-location’がセットされ
     たバッファーである。他のバッファーでabbrev展開を試
     みることにより、‘abbrev-start-location’はクリアーさ
     れる。この変数は、‘abbrev-prefix-mark’によりセット
     される。

 -- Variable: last-abbrev
     これは、直近のabbrev展開の‘abbrev-symbol’である。こ
     れは、‘unexpand-abbrev’コマンド(*note Expanding
     Abbrevs: (emacs)Expanding Abbrevs.を参照)のために、
     ‘expand-abbrev’により残された情報である。

 -- Variable: last-abbrev-location
     これは、直近の.abbrev展開の場所である。これには、
     ‘unexpand-abbrev’コマンドのために‘expand-abbrev’に
     より残された情報が含まれる。

 -- Variable: last-abbrev-text
     これは直近のabbrev展開の正確な展開形を、(もしあれば
     )大文字小文字変換した後のテキストである。その
     abbrevがすでに非展開されていれば、値は‘nil’になる。
     これには‘unexpand-abbrev’コマンドのために、
     ‘expand-abbrev’により残された情報が含まれる。

 -- Variable: abbrev-expand-function
     この変数の値は、展開を行うために‘expand-abbrev’が引
     数なしで呼び出すであろう関数である。この関数では、
     展開を行う前後に行いたいことを行うことができる。展
     開が行われた場合は、そのabbrevシンボルをリターンす
     ること。

   以下のサンプルコードで、‘abbrev-expand-function’のシ
ンプルな使い方を示します。このサンプルでは、‘foo-mode’が
‘#’で始まる行がコメントであるような、特定のファイルを編
集するためのモードであるとします。それらコメント行にたい
しては、Textモードのabbrevの使用が望ましく、その他すべて
の行にたいしては、正規のローカルabbrevテーブル
‘foo-mode-abbrev-table’が適しています。
‘local-abbrev-table’と‘text-mode-abbrev-table’の定義につ
いては、*note Standard Abbrev Tables::を参照してください
。‘add-function’についての詳細は、*note Advising
Functions::を参照してください。

     (defun foo-mode-abbrev-expand-function (expand)
       (if (not (save-excursion (forward-line 0) (eq (char-after) ?#)))
           ;; 通常の展開を行う
           (funcall expand)
         ;; コメント内はtext-modeのabbrevを使用
         (let ((local-abbrev-table text-mode-abbrev-table))
           (funcall expand))))

     (add-hook 'foo-mode-hook
               #'(lambda ()
                   (add-function :around (local 'abbrev-expand-function)
                                 #'foo-mode-abbrev-expand-function)))


File: elisp,  Node: Standard Abbrev Tables,  Next: Abbrev Properties,  Prev: Abbrev Expansion,  Up: Abbrevs

35.5 Standard Abbrev Tables
===========================

以下は、Emacsの事前ロードされるメジャーモード用の
abbrevテーブルを保持する変数のリストです。

 -- Variable: global-abbrev-table
     これは、モード非依存なabbrev用のabbrevテーブルであ
     る。この中で定義されるabbrevは、すべてのバッファー
     に適用される。各バッファーはローカルabbrevテーブル
     ももつかもしれず、それのabbrev定義はグローバルテー
     ブル内のabbrev定義より優先される。

 -- Variable: local-abbrev-table
     このバッファーローカル変数の値は、カレントバッファ
     ーの(モード固有の)abbrevテーブルである。これは、そ
     のようなテーブルのリストでもあり得る。

 -- Variable: abbrev-minor-mode-table-alist
     この変数の値は、‘(MODE . ABBREV-TABLE)’という形式の
     リストである。ここでMODEは変数の名前である。その変
     数が非‘nil’にバインドされていればABBREV-TABLEはアク
     ティブで、それ以外なら無視される。ABBREV-TABLEは、
     abbrevテーブルのリストでもあり得る。

 -- Variable: fundamental-mode-abbrev-table
     これは、Fundamentalモードで使用される、ローカル
     abbrevテーブルである。別の言い方をすると、これは
     Fundamentalモードにあるすべてのバッファーの、ローカ
     ルabbrevテーブルである。

 -- Variable: text-mode-abbrev-table
     これは、Textモードで使用される、ローカルabbrevテー
     ブルである。

 -- Variable: lisp-mode-abbrev-table
     これはLispモードで使用されるローカルabbrevテーブル
     であり、Emacs Lispモードで使用されるローカル
     abbrevテーブルの親テーブルである。*note Abbrev
     Table Properties::を参照のこと。


File: elisp,  Node: Abbrev Properties,  Next: Abbrev Table Properties,  Prev: Standard Abbrev Tables,  Up: Abbrevs

35.6 Abbrev Properties
======================

abbrevはプロパティをもち、それらのいくつかはabbrevの働き
に影響します。これらのプロパティを‘define-abbrev’の引数
として提供して、以下の関数で操作できます:

 -- Function: abbrev-put abbrev prop val
     ABBREVのプロパティPROPに値VALをセットする。

 -- Function: abbrev-get abbrev prop
     ABBREVのプロパティPROP、そのabbrevがそのようなプロ
     パティをもたなければ‘nil’をリターンする。

   以下のプロパティには特別な意味があります:

‘:count’
     このプロパティは、そのabbrevが展開された回数を計数
     する。明示的にセットしなければ、‘define-abbrev’によ
     り0に初期化される。

‘:system’
     非‘nil’なら、このプロパティはシステムabbrevとして、
     そのabbrevをマスクする。そのようなabbrevは保存され
     ない(*note Abbrev Files::を参照)。

‘:enable-function’
     非‘nil’の場合、そのabbrevが使用されるべきでなければ
     ‘nil’、それ以外なら‘t’をリターンするような、引数な
     しの関数であること。

‘:case-fixed’
     非‘nil’なら、このプロパテぃはそのabbrevの大文字小文
     字には意味があり、同じパターンにcapitalizeされたテ
     キストだけにマッチすべきことを示す。これは展開の
     capitalizationを変更するコードも無効にする。


File: elisp,  Node: Abbrev Table Properties,  Prev: Abbrev Properties,  Up: Abbrevs

35.7 Abbrev Table Properties
============================

abbrevと同じようにabbrevテーブルもプロパティをもち、それ
らのいくつかはabbrevテーブルの働きに影響を与えます。これ
らのプロパティを‘define-abbrev-table’の引数として提供し
て、それらを関数で操作できます:

 -- Function: abbrev-table-put table prop val
     abbrevテーブルTABLEのプロパティPROPに、値VALをセッ
     トする。

 -- Function: abbrev-table-get table prop
     abbrevテーブルのプロパティPROP、そのabbrevテーブル
     がそのようなをプロパティもたなければ‘nil’をリターン
     する。

   以下のプロパティには特別な意味があります:

‘:enable-function’
     abbrevプロパティ‘:enable-function’と似ているが、そ
     のテーブル内のすべてのabbrevに適用される点が異なる
     。これはポイントの前のabbrevを探すことを試みる前に
     も使用されるので、abbrevテーブルを動的に変更するこ
     とが可能である。

‘:case-fixed’
     これはabbrevプロパティ‘:case-fixed’と似ているが、そ
     のテーブル内のすべてのabbrevに適用される点が異なる
     。

‘:regexp’
     非‘nil’なら、このプロパティはそのテーブルを照合する
     前に、ポイント前のabbrev名を抽出するための方法を示
     す正規表現である。その正規表現がポイントの前にマッ
     チしたときは、そのabbrev名はsubmatchの1と期待される
     。このプロパティが‘nil’なら、デフォルトは
     ‘backward-word’と‘forward-word’を使用して、abbrevの
     名前を探す。このプロパティにより、単語構文以外の文
     字を含む名前のabbrevが使用できる。

‘:parents’
     このプロパティは、他のabbrevを継承したテーブルのリ
     ストを保持する。

‘:abbrev-table-modiff’
     このプロパティは、そのテーブルにabbrevが追加される
     度に増分されるカウンターを保持する。


File: elisp,  Node: Processes,  Next: Display,  Prev: Abbrevs,  Up: Top

36 Processes
************

オペレーティングシステムの用語では、“プロセス
(process)”とはプログラムを実行できるスペースのことです。
Emacsはプロセス内で実行されます。Emacs Lispプログラムは
、別のプログラムをそれら自身のプロセス内で呼び出すことが
できます。これらは、“親プロセス(parent process)”である
Emacsプロセスの“サブプロセス(subprocesses)”、または“子プ
ロセス(child processes)”と呼ばれます。

   Emacsのサブプロセスは“同期(synchronous)”、または“非同
期(asynchronous)”であり、それはそれらが作成された方法に
依存します。同期サブプロセスを作成した際、Lispプログラム
は実行を継続する前に、そのサブプロセスの終了を待機します
。非同期サブプロセスを作成したときは、それをLispプログラ
ムと並行して実行できます。この種のサブプロセスは、
EmacsではLispオブジェクととして表現され、そのオブジェク
トも“プロセス”と呼ばれています。Lispプログラムはサブプロ
セスとのやり取りや、サブプロセスの制御のために、このオブ
ジェクトを使用できます。たとえばシグナル送信、ステータス
情報の取得、プロセス出力の受信や、プロセスへ入力を送信す
ることができます。

 -- Function: processp object
     この関数は、OBJECTがEmacsのサブプロセスを表すなら
     ‘t’、それ以外は‘nil’をリターンする。

   カレントEmacsセッションのサブプロセスに加えて、そのマ
シン上で実行中の他のプロセスにアクセスすることもできます
。*note System Processes::を参照してください。

* Menu:

* Subprocess Creation::      サブプロセスを開始する関数。
* Shell Arguments::          shellに渡すために引数をクォートする。
* Synchronous Processes::    同期サブプロセス使用の詳細。
* Asynchronous Processes::   非同期サブプロセスの起動。
* Deleting Processes::       非同期サブプロセスの削除。
* Process Information::      実行状態および他の属性へのアクセス。
* Input to Processes::       非同期サブプロセスへの入力の送信。
* Signals to Processes::     非同期サブプロセスの停止、継続、割り込み。
* Output from Processes::    非同期サブプロセスからの出力の収集。
* Sentinels::                プロセスの実行状態変更時に実行されるセンチネル。
* Query Before Exit::        exitによりプロセスがkillされる場合に問い合わせるかどうか。
* System Processes::         そのシステム上で実行中の別プロセスへのアクセス。
* Transaction Queues::       サブプロセスとのトランザクションベースのコミュニケション。
* Network::                  ネットワーク接続のopen。
* Network Servers::          Emacsによるネット接続のacceptを可能にするネットワークサーバー。
* Datagrams::                UDPネットワーク接続。
* Low-Level Network::        接続およびサーバーを作成するための、より低レベルだがより汎用的な関数。
* Misc Network::             ネット接続用の追加の関連関数。
* Serial Ports::             シリアルポートでのやり取り。
* Byte Packing::             bindatを使用したバイナリーデータのpackとunpack。


File: elisp,  Node: Subprocess Creation,  Next: Shell Arguments,  Up: Processes

36.1 Functions that Create Subprocesses
=======================================

内部でプログラムを実行するサブプロセスを作成するために、
3つのプリミティブが存在します。1つは‘start-process’で、
これは非同期プロセスを作成して、プロセスオブジェクトをリ
ターンします(*note Asynchronous Processes::を参照)。他の
2つは‘call-process’と‘call-process-region’で、これらは同
期プロセスを作成して、プロセスオブジェクとをリターンしま
せん(*note Synchronous Processes::を参照)。特定のタイプ
のプロセスを実行するために、これらのプリミティブを利用す
る、さまざまな高レベル関数が存在します。

   同期プロセスと非同期プロセスについては、以降のセクシ
ョンで説明します。この3つの関数はすべて類似した様式で呼
び出されるので、ここでそれらに共通の引数について説明しま
す。

   すべての場合において、その関数のPROGRAM引数は、実行す
るプログラムを指定します。ファイルが見つからなかったり、
実行できない場合は、エラーがシグナルされます。ファイル名
が相対的な場合、検索するディレクトリーのリストは、変数
‘exec-path’に格納されています。Emacsは起動時、環境変数
‘PATH’の値にもとづいて、‘exec-path’を初期化します。
‘exec-path’内では、標準的なファイル名構成要素‘~’、‘.’、
‘..’は通常どおり解釈されますが、環境変数の置換(‘$HOME’等
)は認識されません。それらの置換を行うには、
‘substitute-in-file-name’を使用してください(*note File
Name Expansion::を参照)。このリスト内で‘nil’は、
‘default-directory’を参照します。

   プログラムの実行では、指定された名前にサフィックスの
追加を試みることもできます:

 -- User Option: exec-suffixes
     この変数は、指定されたプログラムファイル名への追加
     を試みるための、サフィックス(文字列)のリストである
     。指定されたとおりの名前を試みたいなら、このリスト
     に‘""’を含めること。デフォルト値はシステムに依存す
     る。

   *注意してください:* 引数PROGRAMにはプログラム名だけが
含まれ、コマンドライン引数を含めることはできない。これら
を提供するために、以下で説明する別の引数ARGSを使用しなけ
ればならない。

   サブプロセス作成関数にはそれぞれ、BUFFER-OR-NAME引数
があります。これはプログラムの標準出力の行き先を指定しま
す。これはバッファーかバッファー名であるべきです。バッフ
ァー名なら、もしそのバッファーがまだ作成されていなければ
、そのバッファーを作成します。‘nil’を指定することもでき
、その場合はカスタム製のフィルター関数が出力を処理するの
でなければ、出力を破棄するよう指示します(*note Filter
Functions::、および*note Read and Print::を参照のこと)。
通常は、出力がランダムに混在してしまうため、同一バッファ
ーに複数プロセスの出力を送信するのは避けるべきです。同期
プロセスにたいしては、バッファーのかわりにファイルに出力
を送信できます。

   これら3つのサブプロセス作成関数はすべて、‘&rest’引数
であるARGSをもっています。ARGSはすべて文字列でなければな
らず、それらは個別のコマンドライン引数として、PROGRAMに
与えられます。これらの文字列は指定されたプログラムに直接
渡されるので、文字列内ではワイルドカード文字やその他の
shell構成要素は特別な意味をもちません。

   サブプロセスはその環境をEmacsから継承しますが、
‘process-environment’でそれをオーバーラードするよう指定
することができます。*note System Environment::を参照して
ください。サブプロセスは自身のカレントディレクトリーを、
‘default-directory’の値から取得します。

 -- Variable: exec-directory
     この変数の値は、GNU Emacsとともに配布され、Emacsに
     より呼び出されることを意図したプログラムを含むディ
     レクトリーの名前(文字列)である。プログラム
     ‘movemail’はそのようなプログラムの例であり、Rmailは
     inboxから新しいメールを読み込むためにこのプログラム
     を使用する。

 -- User Option: exec-path
     この変数の値は、サブプロセス内で実行するためのプロ
     グラムを検索するための、ディレクトリーのリストであ
     る。要素はそれぞれ、ディレクトリーの名前(文字列)、
     または‘nil’のいずれかである。‘nil’はデフォルトディ
     レクトリー(‘default-directory’の値)を意味する。

     ‘exec-path’の値は、PROGRAM引数が絶対ファイル名でな
     いとき、‘call-process’および‘start-process’により使
     用される。

     一般的には、‘exec-path’を直接変更するべきではない。
     かわりにEmacs起動前に、環境変数‘PATH’が適切にセット
     されているか確認すること。‘PATH’とは独立に
     ‘exec-path’の変更を試みると、混乱した結果へと導かれ
     得る。


File: elisp,  Node: Shell Arguments,  Next: Synchronous Processes,  Prev: Subprocess Creation,  Up: Processes

36.2 Shell Arguments
====================

Lispプログラムがshellを実行して、ユーザーが指定したファ
イル名を含むコマンドを与える必要がある場合が時折あります
。これらのプログラムは、任意の有効なファイル名をサポート
可能であるはずです。しかしshellは特定の文字を特別に扱い
、それらの文字がファイル名に含まれていると、shellを混乱
させるでしょう。これらの文字を処理するためには、関数
‘shell-quote-argument’を使用します。

 -- Function: shell-quote-argument argument
     この関数は、実際のコンテンツがARGUMENTであるような
     引数を表す文字列を、shellの構文でリターンする。リタ
     ーン値をshellコマンドに結合して、実行のためにそれを
     shellに渡すことにより、信頼性をもって機能するはずで
     ある。

     この関数が正確に何を行うかは、オペレーティングシス
     テムに依存する。この関数は、そのシステムの標準
     shellの構文で機能するようデザインされている。非標準
     のshellを使用する場合は、この関数を再定義する必要が
     あるだろう。

          ;; この例はGNUおよびUnixシステムでの挙動を示す
          (shell-quote-argument "foo > bar")
               ⇒ "foo\\ \\>\\ bar"

          ;; この例はMS-DOSおよびMS-Windowsでの挙動を示す
          (shell-quote-argument "foo > bar")
               ⇒ "\"foo > bar\""

     以下は‘shell-quote-argument’を使用して、shellコマン
     ドを構築する例である:

          (concat "diff -c "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))

   以下の2つの関数は、コマンドライン引数の文字列のリスト
を単一の文字列に結合したり、単一の文字列を個別のコマンド
ライン引数のリストへ分割するために有用です。これらの関数
は主に、ミニバッファーでのユーザー入力であるLisp文字列を
‘call-process’や‘start-process’に渡す文字列引数のリスト
へ変換したり、そのような引数のリストをミニバッファーやエ
コーエリアに表示するためのLisp文字列に変換することを意図
しています。

 -- Function: split-string-and-unquote string &optional
          separators
     この関数は‘split-string’(*note Creating Strings::を
     参照)が行うように、正規表現SEPARATORSにたいするマッ
     チで、STRINGを部分文字列に分割する。さらに加えて、
     その部分文字列からクォートを削除する。それから部分
     文字列のリストを作成して、それをリターンする。

     SEPARATORSが省略、または‘nil’の場合のデフォルトは
     ‘"\\s-+"’で、これは空白文字構文(*note Syntax Class
     Table::を参照)をもつ1つ以上の文字にマッチする正規表
     現である。

     この関数は、2つのタイプのクォートをサポートする。
     1つは文字列全体をダブルクォートで囲う‘"..."’のよう
     なクォートで、もう1つはバックスラッシュ‘\’によるエ
     スケープで文字を個別にクォートするタイプである。後
     者はLisp文字列内でも使用されるので、この関数はそれ
     らも同様に扱うことができる。

 -- Function: combine-and-quote-strings list-of-strings
          &optional separator
     この関数は、LIST-OF-STRINGSの各文字を必要に応じてク
     ォートして、単一の文字列に結合する。これはさらに各
     文字ペアーの間に、SEPARATOR文字列も挿入する。
     SEPARATORが省略または‘nil’の場合のデフォルトは‘"
     "’。リターン値は、その結果の文字列である。

     LIST-OF-STRINGS内のクォートを要する文字列には、部分
     文字列としてSEPARATORを含むものが該当する。文字列の
     クォートは、それをダブルクォートで‘"..."’のように囲
     う。もっとも単純な例では、個別のコマンドライン引数
     からコマンドをコンス(cons)する場合は、埋め込まれた
     ブランクを含む文字列はそれぞれクォートされるだろう
     。


File: elisp,  Node: Synchronous Processes,  Next: Asynchronous Processes,  Prev: Shell Arguments,  Up: Processes

36.3 Creating a Synchronous Process
===================================

“同期プロセス(synchronous process)”の作成後、Emacsは継続
の前にそのプロセスが終了するのを待機します。GNUや
Unix(1)でのDiredの起動が、この例です。プロセスは同期的な
ので、Emacsがそれにたいして何か行おうと試みる前に、ディ
レクトリーのリスト全体がバッファーに到着します。

   同期サブプロセス終了をEmacsが待機する間、ユーザーは
‘C-g’をタイプすることによりquitができます。最初のは
‘C-g’は‘SIGINT’シグナルにより、サブプロセスのkillを試み
ます。しかしこれはquitする前に、実際にそのサブプロセスが
終了されるまで待機します。その間にユーザーがさらに
‘C-g’をタイプすると、それは‘SIGKILL’で即座にサブプロセス
をkillしてquitします(別プロセスのkillが機能しない
MS-DOSを除く)。*note Quitting::を参照してください。

   同期サブプロセス関数は、プロセスがどのように終了した
かの識別をリターンします。

   同期サブプロセスからの出力は、ファイルからのテキスト
読み込みと同じように、一般的にはコーディングシステムを使
用してデコードされます。‘call-process-region’によりサブ
プロセスに送信された入力は、ファイルへのテキスト書き込み
と同じように、コーディングシステムを使用してエンコードさ
れます。*note Coding Systems::を参照してください。

 -- Function: call-process program &optional infile
          destination display &rest args
     この関数はPROGRAMを呼び出して、それが完了するまで待
     機する。

     サブプロセスのカレントワーキングディレクトリーは、
     ‘default-directory’である。

     新たなプロセスの標準入力は、INFILEが非‘nil’ならファ
     イル‘nil’から、それ以外ならnullデバイスからとなる。
     引数DESTINATIONは、プロセスの出力をどこに送るかを指
     定する。以下は可能な値である:

     バッファー
          そのバッファーの、ポイントの前に出力を挿入する
          。これにはプロセスの、標準出力ストリームと標準
          エラーストリームの両方が含まれる。

     文字列
          その名前のバッファーの、ポイントの前に出力を挿
          入する。

     ‘t’
          カレントバッファーの、ポイントの前に出力を挿入
          する。

     ‘nil’
          出力を破棄する。

     0
          出力を破棄して、サブプロセス完了を待機すること
          なく、即座に‘nil’をリターンする。

          この場合、プロセスはEmacsと並列に実行可能なの
          で、真に同期的ではない。しかしこの関数リターン
          後は、本質的にはすみやかにEmacsがサブプロセス
          を終了するという点から、これを同期的と考えるこ
          とができる。

          MS-DOSは非同期サブプロセスをサポートせず、この
          オプションは機能しない。

     ‘(:file FILE-NAME)’
          指定されたファイルに出力を送信し、ファイルが既
          に存在すれば上書きする。

     ‘(REAL-DESTINATION ERROR-DESTINATION)’
          標準出力ストリームを、標準エラーストリームと分
          けて保つ。通常の出力はREAL-DESTINATIONの指定に
          したがって扱い、エラー出力は
          ERROR-DESTINATIONにしたがって処分する。
          ERROR-DESTINATIONが‘nil’ならエラー出力の破棄、
          ‘t’なら通常の出力と混合することを意味し、文字
          列ならそれはエラー出力をリダイレクトするファイ
          ルの名前である。

          エラー出力先に直接バッファーを指定することはで
          きない。ただしエラー出力を一時ファイルに送信し
          て、そのファイルをバッファーに挿入すれば、これ
          を達成できる。

     DISPLAYが非‘nil’なら、‘call-process’は出力の挿入に
     したがって、バッファーを再表示する(しかし出力のデコ
     ードに選択されたコーディングシステムが、実データか
     らエンコーディングを推論することを意味する
     ‘undecided’の場合は、非ASCIIに一度遭遇すると再表示
     が継続不能になることがある。これを修正するのが困難
     な根本的理由が存在する。*note Output from
     Processes::を参照されたい)。

     それ以外なら関数‘call-process’は再表示を行わず、通
     常のイベントに由来するEmacsの再表示時だけ、スクリー
     ン上で結果が可視になります。

     残りの引数ARGSは、そのプログラムにたいしてコマンド
     ライン引数を指定する文字列です。

     (待機するよう告げた場合)‘call-process’がリターンす
     る値は、プロセスが終了した理由を示します。この数字
     は、そのサブプロセスのexitステータスで0が成功、それ
     以外のすべての値は失敗を意味します。シグナルにより
     そのプロセスが終了された場合、‘call-process’はそれ
     を記述する文字列をリターンします。

     以下の例では、カレントバッファーは‘foo’です。

          (call-process "pwd" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          /home/lewis/manual
          ---------- Buffer: foo ----------

          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               ⇒ 0

          ---------- Buffer: bar ----------
          lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

          ---------- Buffer: bar ----------

     以下は‘call-process’の使用法の例で、このような使用
     例は‘insert-directory’関数の定義内で見ることができ
     ます:

          (call-process insert-directory-program nil t nil switches
                        (if full-directory-p
                            (concat (file-name-as-directory file) ".")
                          file))

 -- Function: process-file program &optional infile
          buffer display &rest args
     この関数は、別プロセス内でファイルを同期的に処理す
     る。これは‘call-process’と似ているが、サブプロセス
     のカレントワーキングディレクトリーを指定する、変数
     ‘default-directory’の値にもとづく、ファイルハンドラ
     ーを呼び出すかもしれない。

     引数は‘call-process’の場合とほとんど同様の方法で処
     理されるが、以下の違いがある:

     引数INFILE、BUFFER、DISPLAYの組み合わせと形式.をサ
     ポートしないファイルハンドラーがあるかもしれない。
     たとえば実際に渡された値とは無関係に、DISPLAYが
     ‘nil’であるかのように振る舞うファイルハンドラーがい
     くつかある。他の例としては、BUFFER引数で標準出力と
     エラー出力を分離するのをサポートしないかもしれない
     ファイルハンドラーがいくつか存在する。

     ファイルハンドラーが呼び出されると、1つ目の引数
     PROGRAMにもとづき、実行するプログラムを決定する。た
     とえばリモートファイルにたいするハンドラーが呼び出
     されたと考えてみよ。その.場合、プログラムの検索に使
     用されるパスは、‘exec-path’とは異なるかもしれない。

     2つ目の引数INFILEは、ファイルハンドラーを呼び出すか
     もしれない。そのファイルハンドラーは、
     ‘process-file’関数自身にたいして選択されたハンドラ
     ーと異なり得る(たとえば‘default-directory’がリモー
     トホスト上にあり、INFILEは別のリモートホスト上の場
     合があり得る。もしくは‘default-directory’は普通だが
     、INFILEはリモートホスト上にあるかもしれない).

     BUFFERが‘(REAL-DESTINATION ERROR-DESTINATION)’とい
     う形式のリストで、ERROR-DESTINATIONがファイルの名前
     なら、INFILEと同じ注意が適用される。

     残りの引数(ARGS)は、そのままプロセスに渡される。
     Emacsは、ARGS内で与えられたファイル名の処理に関与し
     ない。混乱を避けるためには、ARGS内で絶対ファイル名
     を使用しないのが最善であり、‘default-directory’から
     の相対ファイル名ですべてのファイルを指定するほうが
     よいだろう。関数‘file-relative-name’は、そのような
     相対ファイル名の構築に有用である。

 -- Variable: process-file-side-effects
     この変数は、‘process-file’呼び出しがリモートファイ
     ルを変更するかどうかを示す。

     この変数はデフォルトでは常に、‘process-file’呼び出
     しがリモートホスト上の、任意のファイルを潜在的に変
     更し得ることを意味する‘t’にセットされる。‘nil’にセ
     ットされた際は、リモートファイル属性のキャッシュに
     したがうことにより、ファイルハンドラーの挙動を最適
     化できる可能性がある。

     この変数は決して‘setq’ではなく、常にletバインディン
     グによってのみ変更されるべきである。

 -- Function: call-process-region start end program
          &optional delete destination display &rest
          args
     この関数はSTARTからENDのテキストを、実行中のプロセ
     スPROGRAMに、標準入力として送信する。これはDELETEが
     非‘nil’なら、送信したテキストを削除する。これは出力
     をカレントバッファーの入力箇所に挿入するために、
     DESTINATIONを‘t’に指定している際に有用である。

     引数DESTINATIONとDISPLAYは、サブロセスからの出力に
     たいして何を行うか、および出力の到着にともない表示
     を更新するかどうかを制御する。詳細は上述の、
     ‘call-process’の説明を参照されたい。DESTINATIONが整
     数の0なら、‘call-process-region’は出力を破棄して、
     サブプロセス完了を待機せずに、即座に‘nil’をリターン
     する(これは非同期サブプロセスがサポートされる場合、
     つまりMS-DOS以外でのみ機能する)。

     残りの引数ARGSは、そのプログラムにたいしてコマンド
     ライン引数を指定する文字列です。

     ‘call-process-region’のリターン値は、
     ‘call-process’の場合と同じである。待機せずにリター
     ンするよう指示した場合は‘nil’、数字か文字列ならそれ
     はサブプロセスが終了した方法を表す。

     以下の例では、バッファー‘foo’内の最初の5文字(単語
     ‘input’)を標準入力として、‘call-process-region’を使
     用して‘cat’ユーティリティを実行する。‘cat’は自身の
     標準入力を、標準出力へコピーする。引数DESTINATIONが
     ‘t’なので、その出力はカレントバッファーに挿入される
     。

          ---------- Buffer: foo ----------
          input★
          ---------- Buffer: foo ----------

          (call-process-region 1 6 "cat" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          inputinput★
          ---------- Buffer: foo ----------

     たとえば‘shell-command-on-region’コマンドは、以下の
     ような方法で‘call-process-region’を使用する:

          (call-process-region
           start end
           shell-file-name      ; プログラム名
           nil                  ; リージョンを削除しない
           buffer               ; 出力を‘buffer’に送信
           nil                  ; 出力中に再表示を行わない
           "-c" command)        ; shellへの引数

 -- Function: call-process-shell-command command
          &optional infile destination display
     この関数はshellコマンドCOMMANDを、非同期に実行する
     。引数は‘call-process’の場合と同様に処理される。古
     い呼び出し規約は、DISPLAYの後に任意個数の追加引数を
     許容し、これはCOMMANDに結合される。これはまだサポー
     トされるものの、使用しないことを強く推奨する。

 -- Function: process-file-shell-command command
          &optional infile destination display
     この関数は‘call-process-shell-command’と同様だが、
     内部的に‘process-file’を使用する点が異なる。
     ‘default-directory’に依存して、COMMANDはリモートホ
     スト上でも実行可能である。古い呼び出し規約は、
     DISPLAYの後に任意個数の追加引数を許容し、これは
     COMMANDに結合される。これはまだサポートされるものの
     、使用しないことを強く推奨する。

 -- Function: shell-command-to-string command
     この関数はshellコマンドとしてCOMMAND(文字列)を実行
     して、そのコマンドの出力を文字列としてリターンする
     。

 -- Function: process-lines program &rest args
     この関数はPROGRAMを実行して完了を待機し、出力を文字
     列のリストとしてリターンする。リスト内の各文字列は
     、プログラムのテキスト出力の1つの行を保持する。各行
     のEOL文字(行末文字)は取り除かれる。PROGRAMの後の引
     数ARGSは、そのプログラム実行に際し、コマンドライン
     引数を指定する文字列である。

     PROGRAMが非0のexitステータスでexitした場合、この関
     数はエラーをシグナルする。

     この関数は‘call-process’を呼び出すことにより機能し
     、プログラムの出力は‘call-process’の場合と同じ方法
     でデコードされる。

   ---------- Footnotes ----------

   (1) 他のシステムでは、Emacsは‘ls’のLispエミュレーショ
ンを使用します。*note Contents of Directories::を参照し
てください。


File: elisp,  Node: Asynchronous Processes,  Next: Deleting Processes,  Prev: Synchronous Processes,  Up: Processes

36.4 Creating an Asynchronous Process
=====================================

このセクションでは、“非同期プロセス(asynchronous
process)”を作成する方法について説明します。非同期プロセ
スは作成後、Emacsと並列して実行され、Emacsは以降のセクシ
ョン(*note Input to Processes::および*note Output from
Processes::を参照)で説明する関数を使用してプロセスとコミ
ュニケーションができます。プロセスコミュニケーションは、
部分的に非同期なだけであることに注意してください。
Emacsは特定の関数を呼び出したときだけプロセスにデータを
送信でき、Emacsは入力の待機中または一定の遅延時間の後に
のみ、プロセスのデータを受け取ることができます。

   非同期プロセスは“pty(pseudo-terminal: 疑似端末)”、ま
たは“pipe”の、いずれかを通じて制御されます。ptyかpipeの
選択は、変数‘process-connection-type’(以下参照)の値にも
とづき、プロセス作成時に行われます。ptyは通常、Shellモー
ド内のようにユーザーから可視なプロセスに適しています。そ
れはpipeでは不可能な、そのプロセスおよびその子プロセスと
の間でジョブ制御(‘C-c’、‘C-z’、...等)が可能だからです。
プログラムの内部的な目的のために使用されるサブプロセスに
たいしては、pipeのほうが適している場合が多々あります。そ
れはpipeがより効率的であり、ptyが大量の文字(500byte前後
)にたいして導入する迷入文字インジェクション(stray
character injections)にたいして免疫があるのが理由です。
さらに多くのしすてむではptyの合計数に制限があり、それを
浪費するのは得策ではありません。

 -- Function: start-process name buffer-or-name program
          &rest args
     この関数は新たな非同期サブプロセスを作成して、その
     中でプログラムPROGRAMの実行を開始する。これはLisp内
     で新たなサブプロセスを意味する、プロセスオブジェク
     トをリターンする。引数NAMEは、そのプロセスオブジェ
     クトにたいして、名前を指定する。その名前のプロセス
     がすでに存在する場合、(‘<1>’を追加することにより)一
     意になるよう、NAMEを変更する。バッファー
     BUFFER-OR-NAMEは、そのプロセスに関連付けられたバッ
     ファーである。

     PROGRAMが‘nil’なら、Emacsは疑似端末(pty)を新たにオ
     ープンして、サブプロセスを新たに作成することなく、
     ptyの入力と出力をBUFFER-OR-NAMEに関連付ける。この場
     合、残りの引数ARGSは無視される。

     残りの引数ARGSは、サブプロセスにコマンドライン引数
     を指定する文字列である。

     以下の例では、1つ目のプロセスが開始して、100秒間実
     行(というよりはsleep)される。その間に2つ目のプロセ
     スが開始して、一意性を保つために‘my-process<1>’とい
     う名前が与えられる。これは1つ目のプロセスが終了する
     前に、バッファー‘foo’の最後にディレクトリーのリスト
     を挿入する。その後、2つ目のプロセスは終了して、その
     旨のメッセージがバッファーに挿入される。さらに遅れ
     て1つ目のプロセスが終了して、バッファーに別のメッセ
     ージが挿入される。

          (start-process "my-process" "foo" "sleep" "100")
               ⇒ #<process my-process>

          (start-process "my-process" "foo" "ls" "-l" "/bin")
               ⇒ #<process my-process<1>>

          ---------- Buffer: foo ----------
          total 8336
          -rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
          -rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
          ...
          -rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

          Process my-process<1> finished

          Process my-process finished
          ---------- Buffer: foo ----------

 -- Function: start-file-process name buffer-or-name
          program &rest args
     ‘start-process’と同様、この関数は非同期サブプロセス
     を開始して、その内部でPROGRAMを実行して、そのプロセ
     スオブジェクトをリターンする。

     ‘start-process’との違いは、この関数が
     ‘default-directory’の値にもとづいて、ファイルハンド
     ラーを呼び出すかもしれないという点である。このハン
     ドラーはローカルホスト上、あるいは
     ‘default-directory’に応じたリモートホスト上で、
     PROGRAMを実行するべきである。後者の場合、
     ‘default-directory’のローカル部分は、そのプロセスの
     ワーキングディレクトリーになる。

     この関数はPROGRAM、またはPROGRAM-ARGSにたいしてファ
     イル名ハンドラーの呼び出しを試みない。

     そのファイルハンドラーの実装によっては、リターン結
     果のプロセスオブジェクトに‘process-filter’または
     ‘process-sentinel’を適用することができないかもしれ
     ない。*note Filter Functions::および*note
     Sentinels::を参照されたい。

     いくつかのファイルハンドラーは
     ‘start-file-process’をサポートしないかもしれない(た
     とえば‘ange-ftp-hook-function’関数)。そのような場合
     、この関数は何も行わずに‘nil’をリターンする。

 -- Function: start-process-shell-command name
          buffer-or-name command
     この関数は‘start-process’と同様だが、指定されたコマ
     ンドの実行にshellを使用する点が異なる。引数
     COMMANDは、shellコマンド名である。変数
     ‘shell-file-name’は、どのshellを使用するかを指定す
     る。

     ‘start-process’でプログラムを実行せずにshellを通じ
     て実行することの要点は、引数内のワイルドカード展開
     のようなshell機能を利用可能にするためである。そのた
     めにはコマンド内に任意のユーザー指定引数を含めるな
     ら、任意の特別なshell文字が、shellでの特別な意味を
     _もたない_ように、まず‘shell-quote-argument’でそれ
     らをクォートするべきである。*note Shell
     Arguments::を参照のこと。ユーザー入力にもとづいたコ
     マンド実行時には、当然セキュリティ上の影響も考慮す
     るべきである。

 -- Function: start-file-process-shell-command name
          buffer-or-name command
     この関数は‘start-process-shell-command’と似ているが
     、内部的に‘start-file-process’を使用する点が異なる
     。これにより、‘default-directory’に応じてリモートホ
     スト上でも、COMMANDを実行できる。

 -- Variable: process-connection-type
     この変数は、非同期サブプロセスと対話するために使用
     する、デバイスタイプを制御する。これが非‘nil’の場合
     、利用可能ならpty、それ以外ならpipeが使用される。

     ‘process-connection-type’の値は、‘start-process’の
     呼び出し時に効果を発揮する。そのため、
     ‘start-process’の呼び出し前後でこの変数をバインドす
     ることにより、サブプロセスとやり取りする方法を指定
     できる。

          (let ((process-connection-type nil))  ; pipeを使用
            (start-process ...))

     与えられたサブプロセスが実際にはpipeとptyのどちらを
     取得したかを判断するには、関数‘process-tty-name’を
     使用する(*note Process Information::を参照)。


File: elisp,  Node: Deleting Processes,  Next: Process Information,  Prev: Asynchronous Processes,  Up: Processes

36.5 Deleting Processes
=======================

“プロセス削除(deleting a process)”とは、Emacsをサブプロ
セスから即座に切断することです。プロセスは終了後に自動的
に削除されますが、即座に削除される必要はありません。任意
のタイミングで、明示的にプロセスを削除できます。終了した
プロセスが自動的に削除される前に明示的に削除しても、それ
に害はありません。実行中のプロセスの削除は、プロセス(も
しあれば子プロセスにも)を終了するためにシグナルを送信し
て、プロセスセンチネルを呼び出します。*note Sentinels::を
参照してください。

   プロセスが削除される際、そのプロセスオブジェクト自体
は、それを参照する別のLispオブジェクトが存在する限り、継
続し続けます。プロセスオブジェクトに作用するすべての
Lispプリミティブはプロセスの削除を受け入れますが、I/Oを
行ったりシグナルを送信するプリミティブは、エラーを報告す
るでしょう。プロセスマークは、通常はプロセスからの出力が
バッファーに挿入される箇所である、以前と同じ箇所をポイン
トし続けます。

 -- User Option: delete-exited-processes
     この変数は、(‘exit’呼び出しやシグナルにより)終了し
     たプロセスの、自動的な削除を制御する。これが‘nil’な
     ら、ユーザーが‘list-processes’を実行するまでプロセ
     スは存在し続け、それ以外ならexit後に即座に削除され
     る。

 -- Function: delete-process process
     この関数は、‘SIGKILL’シグナルでkillすることにより、
     プロセスを削除する。引数はプロセス、プロセスの名前
     、バッファー、バッファーの名前かもしれない(バッファ
     ーやバッファー名の場合は、‘get-buffer-process’がリ
     ターンするプロセスを意味する)。実行中のプロセスに
     ‘delete-process’を呼び出すことにより、プロセスを終
     了してプロセス状態を更新して、即座にセンチネルを実
     行する。そのプロセスがすでに終了している場合、
     ‘delete-process’呼び出しはプロセス状態、または(遅か
     れ早かれ発生するであろう)プロセスセンチネルの実行に
     影響を与えない。

          (delete-process "*shell*")
               ⇒ nil


File: elisp,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

36.6 Process Information
========================

プロセスの状態に関する情報をリターンする関数がいくつかあ
り。

 -- Command: list-processes &optional query-only buffer
     このコマンドは、すべての生きたプロセスのリストを表
     示する。加えてこれは最後に、状態が‘Exited’か
     ‘Signaled’だったすべてのプロセスを削除する。このコ
     マンドは‘nil’をリターンする。

     プロセスは、メジャーモードがProcess Menuモードであ
     るような、‘*Process List*’という名前(オプション引数
     BUFFERで他の名前を指定していない場合)のバッファーに
     表示される。

     QUERY-ONLYが非‘nil’なら、queryフラグが非‘nil’のプロ
     セスだけをリストする。*note Query Before Exit::を参
     照のこと。

 -- Function: process-list
     この関数は、削除されていないすべてのプロセスのリス
     トをリターンする。

          (process-list)
               ⇒ (#<process display-time> #<process shell>)

 -- Function: get-process name
     この関数はNAME(文字列)というプロセス、存在しなけれ
     ば‘nil’をリターンする。

          (get-process "shell")
               ⇒ #<process shell>

 -- Function: process-command process
     この関数は、PROCESSを開始するために実行されたコマン
     ドをリターンする。これは文字列のリストで、1つ目の文
     字列は実行されたプログラム、残りの文字列はそのプロ
     グラムに与えられた引数である。

          (process-command (get-process "shell"))
               ⇒ ("bash" "-i")

 -- Function: process-contact process &optional key

     この関数は、ネットワークプロセスまたはシリアルプロ
     セスがセットアップされた方法についての情報をリター
     ンする。 This function returns information about
     how a network or serial process was set up.  KEYが
     ‘nil’なら、ネットワークプロセスにたいしては
     ‘(HOSTNAME SERVICE)’、シリアルプロセスにたいしては
     ‘(PORT SPEED)’をリターンする。普通の子プロセスにた
     いしては、この関数は常に‘t’をリターンする。

     KEYが‘t’なら、値はその接続、サーバー、またはシリア
     ルポートについての完全な状態情報、すなわち
     ‘make-network-process’または‘make-serial-process’内
     で指定されるキーワードと値のリストとなる。ただしい
     くつかの値については、指定した値のかわりに、カレン
     ト状態を表す値となる。

     ネットワークプロセスにたいしては、その値が含まれる
     (完全なリストについては、‘make-network-process’を参
     照されたい)。

     ‘:buffer’
          値にはプロセスのバッファーが割り当てられる。
     ‘:filter’
          値にはプロセスのフィルター関数が割り当てられる
          。
     ‘:sentinel’
          値にはプロセスのセンチネル関数が割り当てられる
          。
     ‘:remote’
          接続にたいしては、内部的なフォーマットによる、
          リモートピアーのアドレス。
     ‘:local’
          内部的なフォーマットによる、ローカルアドレス。
     ‘:service’
          サーバーにおいては、SERVICEに‘t’を指定した場合
          、この値は実際のポート番号。

     ‘make-network-process’内で明示的に指定されていなく
     ても、‘:local’と‘:remote’は値に含まれる。

     シリアルプロセスについては‘make-serial-process’、キ
     ーのリストについては‘serial-process-configure’を参
     照されたい。

     KEYがキーワードなら、この関数はそのキーワードに対応
     する値をリターンする。

 -- Function: process-id process
     この関数は、PROCESSのPIDをリターンする。これは同じ
     コンピューター上でカレント時に実行中の他のすべての
     プロセスから、プロセスPROCESSを区別するための整数で
     ある。プロセスのPIDは、そのプロセスの開始時にオペレ
     ーティングシステムのカーネルにより選択され、そのプ
     ロセスが存在する限り定数として保たれる。

 -- Function: process-name process
     この関数はPROCESSの名前を、文字列としてリターンする
     。

 -- Function: process-status process-name
     この関数はPROCESS-NAMEの状態を、文字列としてリター
     ンする。引数PROCESS-NAMEはプロセス、バッファー、ま
     たはプロセス名(文字列)かもしれない。

     実際のサブプセスにたいして可能な値は:

     ‘run’
          実行中のプロセス。
     ‘stop’
          停止しているが継続可能なプロセス。
     ‘exit’
          exitしたプロセス。
     ‘signal’
          致命的なシグナルを受信したプロセス。
     ‘open’
          オープンされたネットワーク接続。
     ‘closed’
          クローズされたネットワーク接続。一度クローズさ
          れた接続は、たとえ同じ場所にたいして新たな接続
          をオープンすることができたとしても、再度オープ
          ンすることはできない。
     ‘connect’
          完了を待つ非ブロッキング接続。
     ‘failed’
          完了に失敗した非ブロッキング接続。
     ‘listen’
          listen中のネットワークサーバー。
     ‘nil’
          PROCESS-NAMEが既存のプロセス名でない場合。

          (process-status (get-buffer "*shell*"))
               ⇒ run

     ネットワーク接続にたいしては、‘process-status’は
     ‘open’か‘closed’のシンボルいずれかをリターンする。
     後者は相手側が接続をクローズしたか、Emacsが
     ‘delete-process’を行なったことを意味する。

 -- Function: process-live-p process
     この関数は、PROCESSがアクティブなら、非‘nil’をリタ
     ーンする。状態が‘run’、‘open’、‘listen’、
     ‘connect’、‘stop’のプロセスはアクティブとみなされる
     。

 -- Function: process-type process
     この関数はネットワーク接続またはサーバーにたいして
     はシンボル‘network’、シリアルポート接続にたいしては
     ‘serial’、実際のサブプロセスにたいしては‘real’をリ
     ターンする。

 -- Function: process-exit-status process
     この関数はPROCESSのexitステータス、またはプロセスを
     killしたシグナル番号をリターンする(いずれかであるか
     の判定には、‘process-status’の結果を使用する)。
     PROCESSがまだ終了していなければ、値は0。

 -- Function: process-tty-name process
     この関数はPROCESSがEmacsとの対話に使用する端末名、
     端末のかわりにpipeを使用する場合は‘nil’をリターンす
     る(*note Asynchronous Processes::の
     ‘process-connection-type’を参照)。PROCESSがリモート
     ホスト上で実行中のプログラムを表す場合は、プロセス
     の‘remote-tty’プロパティとして、リモートホスト上で
     そのプログラムに使用される端末名が提供される。

 -- Function: process-coding-system process
     この関数は、PROCESSからの出力のデコードに使用するコ
     ーディングシステム、PROCESSへの入力のエンコードに使
     用するコーディングシステムを記述するコンスセル
     ‘(DECODE . ENCODE)’をリターンする(*note Coding
     Systems::を参照)。

 -- Function: set-process-coding-system process
          &optional decoding-system encoding-system
     この関数は、PROCESSにたいする後続の入出力に使用する
     コーディングシステムを指定する。これはサブプロセス
     の出力のデコードにDECODING-SYSTEM、入力のエンコード
     にENCODING-SYSTEMを使用するだろう。

   すべてのプロセスには、そのプロセスに関連するさまざま
な値を格納するために使用できる、プロパティリストもありま
す。

 -- Function: process-get process propname
     この関数は、PROCESSのプロパティPROPNAMEの値をリター
     ンする。

 -- Function: process-put process propname value
     この関数は、PROCESSのプロパティPROPNAMEの値に
     VALUEをセットする。

 -- Function: process-plist process
     この関数は、PROCESSのプロセスplistをリターンする。

 -- Function: set-process-plist process plist
     この関数は、PROCESSのプロセスplistにPLISTをセットす
     る。


File: elisp,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

36.7 Sending Input to Processes
===============================

非同期サブプロセスは、Emacsにより入力が送信されたときに
入力を受信し、それはこのセクション内の関数で行われます。
これを行うには入力を送信するプロセスと、送信するための入
力データを指定しなければなりません。そのデータは、サブプ
ロセスの“標準入力”として表れます。

   オペレーティングシステムには、ptyのバッファーされた入
力にたいして制限をもつものがいくつかあります。それらのシ
ステムでは、Emacsは他の文字列の間に定期的かつ強制的に、
EOFを送信します。ほとんどのプログラムにたいして、これら
のEOFは無害です。

   サブプロセスの入力は通常、テキストをファイルに書き込
むときと同じように、サブプロセスが受信する前に、コーディ
ングシステムを使用してエンコードされます。どのコーディン
グシステムを使用するかを指定するには、
‘set-process-coding-system’を使用できます(*note Process
Information::を参照)。それ以外の場合、非‘nil’なら
‘coding-system-for-write’がコーディングシステムとなり、
さもなくばデフォルトのメカニズムがコーディングシステムを
決定します(*note Default Coding Systems::を参照)。

   入力バッファーが一杯のため、システムがプロセスからの
入力を受け取ることができないことがあります。これが発生し
たときは、送信関数はしばらく待機して、サブプロセスの出力
を受け取り、再度送信を試みます。これは保留となっている更
なる入力を読み取り、バッファーに空きを作る機会をサブプロ
セスに与えます。これはフィルター、センチネル、タイマーの
実行も可能にするので、コードを記述する際はそれを考慮して
ください。

   以下の関数では、PROCESS引数はプロセス、プロセス名、ま
たはバッファー、バッファー名(これは
‘get-buffer-process’で取得されるプロセスを意味する)。
‘nil’は、カレントバッファーのプロセスを意味します。

 -- Function: process-send-string process string
     この関数はSTRINGのコンテンツを、標準入力として
     PROCESSに送信する。たとえばファイルをリストする
     Shellバッファーを作成するには:

          (process-send-string "shell<1>" "ls\n")
               ⇒ nil

 -- Function: process-send-region process start end
     この関数はSTARTとENDで定義されるリージョンのテキス
     トを、標準入力としてPROCESSに送信する。

     STARTとENDが、カレントバッファー内の位置を示す整数
     かマーカーでなければ、エラーがシグナルされる(いずれ
     かの大小は重要ではない)。

 -- Function: process-send-eof &optional process
     この関数は、PROCESSが入力内のEOF(end-of-file)を見る
     ことを可能にする。EOFは、すべての送信済みテキストの
     後になる。この関数はPROCESSをリターンする。

          (process-send-eof "shell")
               ⇒ "shell"

 -- Function: process-running-child-p &optional process
     この関数は、PROCESSが自身の子プロセスに端末の制御を
     与えたかどうかを告げるだろう。値‘t’はそれが真である
     か、あるいはEmacsがそれを告げることができないことを
     意味し、‘nil’はなら偽であることをEmacsは保証します
     。


File: elisp,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

36.8 Sending Signals to Processes
=================================

サブプロセスへの“シグナル送信(sending a signal)”は、プロ
セスの活動に割り込む手段の1つです。異なる複数のシグナル
があり、それぞれが独自の意味をもっています。シグナルのセ
ットとそれらの意味は、オペレーティングシステムにより定義
されます。たとえばシグナル‘SIGINT’は、ユーザーが‘C-c’を
タイプしたか、それに類似する何かが発生したことを意味しま
す。

   各シグナルは、サブプロセスに標準的な効果をもちます。
ほとんどのシグナルはサブプロセスをkillしますが、かわりに
実行を停止(あるいは再開)するものもいくつかあります。ほと
んどのシグナルは、オプションでプログラムによりハンドル
((処理)することができます。プログラムがそのシグナルをハ
ンドルする場合、その影響についてわたしたちは一般的には何
も言うことはできません。

   このセクション内の関数を呼び出すことにより、明示的に
シグナルを送信できます。Emacsも、特定のタイミングで自動
的にシグナルを送信します。バッファーのkillにより、それに
関連するプロセスには‘SIGHUP’シグナルが送信され、Emacsの
killにより、残されたすべてのプロセスに‘SIGHUP’シグナルが
送信されます(‘SIGHUP’は通常、ユーザーが“hung up the
phone”、電話を切った、つまり接続を断ったことを示す)。

   シグナル送信関数はそれぞれPROCESSとCURRENT-GROUPいう
、2つのオプション引数を受け取ります。

   引数PROCESSはプロセス、プロセス名、バッファー、バッフ
ァー名、または‘nil’のいずれかでなければなりません。バッ
ファーまたはバッファー名は、‘get-buffer-process’を通じて
得られるプロセスを意味します。‘nil’は、カレントバッファ
ーに関連付けられたプロセスを意味します。PROCESSがプロセ
スを識別しなければ、エラーがシグナルされます。

   引数CURRENT-GROUPは、Emacsのサブプロセスとしてジョブ
制御shell(job-control shell)を実行中の場合に、異なる処理
を行うためのフラグです。これが非‘nil’なら、そのシグナル
はEmacsがサブプロセスとの対話に使用する端末のカレントプ
ロセスグループに送信されます。そのプロセスがジョブ制御
shellなら、これはそのshellのカレントのsubジョブになりま
す。‘nil’なら、そのシグナルはEmacs自身のサブプロセスのプ
ロセスグループに送信されます。そのプロセスがジョブ制御
shellなら、それはshell自身になります。

   サブプロセスとの対話にpipeが使用されている際は、オペ
レーティングシステムがpipeでの区別をサポートしないので、
フラグCURRENT-GROUPに効果はありません。同じ理由により、
pipeが使用されている場合は、ジョブ制御shellは機能しない
でしょう。*note Asynchronous Processes::内の
‘process-connection-type’を参照してください。

 -- Function: interrupt-process &optional process
          current-group
     この関数は、シグナル‘SIGINT’を送信することにより、
     プロセスPROCESSに割り込む。Emacs外部では、
     “interrupt character”(割り込み文字。通常いくつかの
     システムでは‘C-c’、それ以外のシステムでは<DEL>)をタ
     イプすることにより、このシグナルが送信される。引数
     CURRENT-GROUPが非‘nil’のときは、Emacsがサブプロセス
     と対話する端末上で“‘C-c’がタイプされた”と考えること
     ができる。

 -- Function: kill-process &optional process
          current-group
     この関数は、シグナル‘SIGKILL’を送信することにより、
     プロセスPROCESSをkillする。このシグナルは即座にサブ
     プロセスをkillして、サブプロセスでハンドルすること
     はできない。

 -- Function: quit-process &optional process
          current-group
     この関数は、プロセスPROCESSにシグナル‘SIGQUIT’を送
     信する。これはEmacs外部では“quit character”(通常は
     ‘C-b’か‘C-\’)により送信されるシグナルである。

 -- Function: stop-process &optional process
          current-group
     この関数は、シグナル‘SIGTSTP’を送信することにより、
     プロセスPROCESSを停止する。実行の再開には、
     ‘continue-process’を使用する。

     ジョブ制御をもつシステム上のEmacs外部では、“stop
     character”(通常は‘C-z’)がこのシグナルを送信する。
     CURRENT-GROUPが非‘nil’なら、この関数をサブプロセス
     との対話にEmacsが使用する端末上で“‘C-z’がタイプされ
     た”と考えることができる。

 -- Function: continue-process &optional process
          current-group
     この関数は、シグナル‘SIGCONT’を送信することにより、
     プロセスPROCESSの実行を再開する。これはPROCESSが以
     前に停止されたものと推定する。

 -- Command: signal-process process signal
     この関数は、プロセスPROCESSにシグナルを送信する。引
     数SIGNALは、どのシグナルを送信するかを指定する。こ
     れは整数、または名前がシグナルであるようなシンボル
     であること。

     PROCESS引数にはシステムプロセスID(整数)を指定できる
     。これによりEmacsの子プロセス以外のプロセスにシグナ
     ルを送信できる。*note System Processes::を参照のこ
     と。


File: elisp,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

36.9 Receiving Output from Processes
====================================

サブプロセスが自身の標準出力に書き込んだ出力は、“フィル
ター関数(filter function)”と呼ばれる関数に渡されます。デ
フォルトのフィルター関数は単に出力をバッファーに挿入しま
す。このバッファーを、そのプロセスに関連付けられたバッフ
ァーと呼びます(*note Process Buffers::を参照)。プロセス
がバッファーをもたなければ、デフォルトフィルターは出力を
破棄します。

   サブプロセス終了時、Emacsは保留中の出力を読み取り、そ
の後そのサブプロセスからの出力の読み取りを停止します。し
たがって、そのサブプロセスに生きた子プロセスがあり、まだ
出力を生成するような場合、Emacsはその出力を受け取らない
でしょう。

   サブプロセスからの出力は、Emacsが待機している間、端末
入力読み取り時(関数‘waiting-for-user-input-p’、*note
Waiting::の‘sit-for’と‘sleep-for’、および*note Accepting
Output::の‘accept-process-output’を参照されたい)のみ到着
可能です。これは、並列プログラミングで普遍的に悩みの種で
ある、タイミングエラーの問題を最小化します。たとえば、安
全にプロセスを作成して、その後でのみプロセスのバッファー
やフィルター関数を指定できます。その間にあるコードが待機
するプリミティブを何も呼び出さなければ、完了するまで到着
可能な出力はありません。

 -- Variable: process-adaptive-read-buffering
     いくつかのシステムでは、Emacsがサブプロセスの出力を
     読み取る際、出力データを非常に小さいブロックで読み
     取るため、結果として潜在的に非常に貧弱なパフォーマ
     ンスとなることがる。この挙動は、変数
     ‘process-adaptive-read-buffering’を非‘nil’値(デフォ
     ルト)にセットして拡張することにより改善し得る。これ
     により、そのようなプロセスからの読み取りを自動的に
     遅延して、Emacsが読み取りを試みる前に、出力がより生
     成されるようになる。

   Emacsは通常、疑似端末(pseudo-TTY)内部でサブプロセスを
spawnし、かつ疑似端末は出力チャンネルを1つしかもてないの
で、サブプロセスの標準出力ストリームと標準エラーストリー
ムを区別するのは不可能です。それらのストリームの出力を区
別して保ちたい場合は、たとえば適当なshellコマンドを使用
して、いずれか1つをファイルにリダイレクトするべきです。

* Menu:

* Process Buffers::          デフォルトでは、出力はバッファーに送信される。
* Filter Functions::         フィルター関数はプロセスからの出力を受け取る。
* Decoding Output::          フィルターはユニバイトおよびマルチバイトの文字列を取得できる。
* Accepting Output::         プロセスの出力到着まで待機する方法。


File: elisp,  Node: Process Buffers,  Next: Filter Functions,  Up: Output from Processes

36.9.1 Process Buffers
----------------------

プロセスは“関連付けられたバッファー(associated buffer)”を
もつことができます(通常はもつ)。これは普通のEmacsバッフ
ァーであり、2つの目的のために使用されます。1つはプロセス
からの出力の格納、もう1つはプロセスをkillする時期を判断
するためです。通常の習慣では、任意の与えられたバッファー
にたいして関連付けられるプロセスは1つだけなので、処理対
象のプロセスを識別するためにそのバッファーを使用すること
もできます。プロセス使用の多くはプロセスに送信する入力を
編集するためにもこのバッファーを使用しますが、これは
Emacs Lispに組み込まれてはいません。

   デフォルトでは、プロセスの出力は関連付けられたバッフ
ァーに挿入されます(カスタムフィルター関数の定義により変
更可能。*note Filter Functions::を参照されたい)。出力を
挿入する位置は、‘process-mark’により決定されます。これは
正に挿入されたテキストの終端に、ポイントを更新します。通
常、ただし常にではありませんが、‘process-mark’はバッファ
ーの終端になります。

   プロセスに関連付けられたバッファーをkillすることによ
り、そのプロセスもkillされます。そのプロセスの
‘process-query-on-exit-flag’が非‘nil’なら、Emacsはまず確
認を求めます(*note Query Before Exit::を参照)。この確認
は関数‘process-kill-buffer-query-function’により行われ、
これは‘kill-buffer-query-functions’から実行されます
(*note Killing Buffers::を参照)。

 -- Function: process-buffer process
     この関数は、プロセスPROCESSの関連付けられたバッファ
     ーをリターンする。

          (process-buffer (get-process "shell"))
               ⇒ #<buffer *shell*>

 -- Function: process-mark process
     この関数は、PROCESSにたいするプロセスマーカーをリタ
     ーンする。これはプロセスからの出力をどこに挿入する
     かを示すマーカーである。

     PROCESSバッファーをもたなければ、‘process-mark’は存
     在しない場所を指すマーカーをリターンする。

     デフォルトフィルター関数は、プロセス出力の挿入場所
     の決定にこのマーカーを使用し、挿入したテキストの後
     にポイントを更新する。連続するバッチ出力が、連続し
     て挿入されるのは、これが理由である。

     カスタムフィルター関数は、このマーカーを通常は同じ
     方式で使用するべきである。‘process-mark’を使用する
     フィルター関数の例は、*note Process Filter
     Example::を参照のこと。

     ユーザーにプロセスバッファー内でプロセスに送信する
     ための入力を期待する際は、プロセスマーカーは以前の
     出力から新たな入力を区別する。

 -- Function: set-process-buffer process buffer
     この関数は、PROCESSに関連付けられたバッファーに、
     BUFFERをセットする。BUFFERが‘nil’なら、プロセスはバ
     ッファーに関連付けられない。

 -- Function: get-buffer-process buffer-or-name
     この関数は、BUFFER-OR-NAMEで指定されるバッファーに
     関連付けられた、削除されていないプロセスをリターン
     する。そのバッファーに複数のプロセスが関連付けられ
     ている場合、この関数はいずれか1つ(現在のところもっ
     とも最近作成されたプロセスだが、これを当てにしない
     こと)を選択する。プロセスの削除(‘delete-process’を
     参照)により、そのプロセスはこの関数がリターンするプ
     ロセスとしては不適格となる。

     同一のバッファーに複数のプロセスを関連付けるのは、
     通常は悪いアイデアである。

          (get-buffer-process "*shell*")
               ⇒ #<process shell>

     プロセスのバッファーをkillすることにより、
     ‘SIGHUP’シグナルでサブプロセスをkillして、プロセス
     を削除する(*note Signals to Processes::を参照)。


File: elisp,  Node: Filter Functions,  Next: Decoding Output,  Prev: Process Buffers,  Up: Output from Processes

36.9.2 Process Filter Functions
-------------------------------

プロセスの“フィルター関数(filter function)”は、関連付け
られたプロセスからの標準出力を受信します。そのプロセスの
_すべて_の出力は、そのフィルターに渡されます。デフォルト
のフィルターは単に、プロセスバッファーに直接出力します。

   サブプロセスからの出力は、Emacsが何かを待機している間
だけ到着するので、フィルター関数はそのようなときだけ呼び
出し可能です。Emacsは端末入力読み取り時(関数
‘waiting-for-user-input-p’、*note Waiting::の‘sit-for’と
‘sleep-for’、および*note Accepting Output::の
‘accept-process-output’を参照されたい)に待機します。

   フィルター関数は関連付けられたプロセス、およびそのプ
ロセスから正に受信した出力である文字列という、2つの引数
を受け取らなければなりません。関数はその後、出力にたいし
て何であれ、自由に行うことができます。

   quitは通常はフィルター関数内では抑制されます。さもな
いと、コマンドレベルでの‘C-g’のタイプ、またはユーザーコ
マンドのquitは予測できません。フィルター関数内部での
quitを許可したければ、‘inhibit-quit’を‘nil’にバインドし
てください。ほとんどの場合において、これを行う正しい方法
はマクロ‘with-local-quit’です。*note Quitting::を参照し
てください。

   フィルター関数の実行中にエラーが発生した場合、フィル
ター開始時に実行中だったプログラムが何であれ実行を停止し
ないように、自動的にcatchされます。しかし
‘debug-on-error’が非‘nil’なら、エラーはcatchされません。
これにより、Lispデバッガーを使用したフィルター関数のデバ
ッグが可能になります。*note Debugger::を参照してください
。

   多くのフィルター関数は時折(または常に)、デフォルトフ
ィルターの動作を真似て、プロセスのバッファーにその出力を
挿入します。そのようなフィルター関数は確実にカレントバッ
ファーの保存と、(もし異なるなら)出力を挿入する前に正しい
バッファーを選択して、その後に元のバッファーをリストアす
る必要があります。また、そのバッファーがまだ生きているか
、プロセスマーカーを更新しているか、そしていくつかのケー
スにおいてはポイントの値を更新しているかもチェックするべ
きです。以下はこれらを行う方法です:

     (defun ordinary-insertion-filter (proc string)
       (when (buffer-live-p (process-buffer proc))
         (with-current-buffer (process-buffer proc)
           (let ((moving (= (point) (process-mark proc))))
             (save-excursion
               ;; テキストを挿入してプロセスマーカーを進める
               (goto-char (process-mark proc))
               (insert string)
               (set-marker (process-mark proc) (point)))
             (if moving (goto-char (process-mark proc)))))))

   新たなテキスト到着時にフィルターが強制的にプロセスバ
ッファーを可視にするために、‘with-current-buffer’構成の
直前に以下のような行を挿入できます:

     (display-buffer (process-buffer proc))

   以前の位置に関わらず、新たな出力の終端にポイントを強
制するには、変数‘moving’を削除して、無条件で
‘goto-char’を呼び出してください。

   フィルター関数実行中、Emacsは自動的にマッチデータの保
存とリストアを行うことに注意してください。*note Match
Data::を参照してください。

   フィルターへの出力は、任意のサイズのchunkで到着する可
能性があります。同じ出力を連続して2回生成するプログラム
は、一度に200文字を1回のバッチで送信して、次に40文字を
5回のバッチで送信するかもしれません。フィルターが特定の
テキスト文字列をサブプロセスの出力から探す場合は、それら
の文字列が2回以上のバッチ出力を横断するケースに留意して
処理してください。これを行うには、受信したテキストを一時
的なバッファーに挿入してから、それを検索するのが1つの方
法です。

 -- Function: set-process-filter process filter
     この関数は、PROCESSにフィルター関数FILTERを与える。
     FILTERが‘nil’ならそのプロセスにたいして、プロセスバ
     ッファーにプロセス出力を挿入する、デフォルトフィル
     ターを与える。

 -- Function: process-filter process
     この関数は、PROCESSのフィルター関数をリターンする。

   そのプロセスの出力を複数のフィルターに渡す必要がある
場合は、既存のフィルターに新たなフィルターを組み合わせる
ために、‘add-function’を使用できる。*note Advising
Functions::を参照のこと。

   以下は、フィルター関数の使用例である:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          ⇒ keep-output
     (setq kept nil)
          ⇒ nil
     (set-process-filter (get-process "shell") 'keep-output)
          ⇒ keep-output
     (process-send-string "shell" "ls ~/other\n")
          ⇒ nil
     kept
          ⇒ ("lewis@slug:$ "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")


File: elisp,  Node: Decoding Output,  Next: Accepting Output,  Prev: Filter Functions,  Up: Output from Processes

36.9.3 Decoding Process Output
------------------------------

Emacsが直接マルチバイトバッファーにプロセス出力を書き込
む際は、プロセス出力のコーディングシステムに応じて、出力
をデコードします。コーディングシステムが‘raw-text’か
‘no-conversion’なら、Emacsは‘string-to-multibyte’を使用
してユニバイト出力をマルチバイトに変換して、その結果のマ
ルチバイトテキストを挿入します。

   どのコーディングシステムを使用するかは、
‘set-process-coding-system’を使用して指定できます(*note
Process Information::を参照)。それ以外では、
‘coding-system-for-read’が非‘nil’ならそのコーディングシ
ステム、‘nil’ならデフォルトのメカニズムが使用されます
(*note Default Coding Systems::を参照)。プロセスのテキス
ト出力にnullバイトが含まれる場合、Emacsはそれにたいして
デフォルトでは‘no-conversion’を使用します。この挙動を制
御する方法については、*note inhibit-null-byte-detection:
Lisp and Coding Systems.を参照してください。

   *警告:* データからコーディングシステムを‘undecided’の
ようなコーディングシステムは、非同期サブプロセスの出力に
たいして完全な信頼性をもって機能しません。これはEmacsが
、到着に応じて非同期サブプロセスの出力をバッチで処理する
必要があるからです。Emacsは1つのバッチが到着するたびに正
しいコーディングシステムを検出しなければならず、これは常
には機能しません。したがって、可能であれば文字コード変換
とEOL変換の両方を決定するコーディングシステム、つまり
‘latin-1-unix’、‘undecided’、‘latin-1’のようなコーディン
グシステムを指定してください。

   Emacsがプロセスフィルター関数を呼び出す際は、そのプロ
セスのフィルターのコーディングシステムに応じて、Emacsは
プロセス出力をマルチバイト文字列、またはユニバイト文字列
で提供します。Emacsはプロセス出力のコーディングシステム
に応じて出力をデコードします。これは‘binary’や
‘raw-text’のようなコーディングシステムを除き、通常はマル
チバイト文字列を生成します。


File: elisp,  Node: Accepting Output,  Prev: Decoding Output,  Up: Output from Processes

36.9.4 Accepting Output from Processes
--------------------------------------

非同期サブプロセスからの出力は通常、Emacsが時間の経過や
端末入力のような、ある種の外部イベントを待機する間だけ到
着します。特定のポイントで出力の到着を明示的に許可したり
、あるいはプロセスからの出力が到着するまで待機することさ
え、Lispプログラムでは有用な場合が時折あります。

 -- Function: accept-process-output &optional process
          seconds millisec just-this-one
     この関数はプロセスからの保留中の出力を、Emacsが読み
     取ることを許す。この出力は、プロセスのフィルター関
     数により与えられる。PROCESSが非‘nil’なら、この関数
     はPROCESSから何らかの出力を受け取るまでリターンしな
     い。

     引数SECONDSとMILLISECにより、タイムアウトの長さを指
     定できる。前者は秒単位、後者はミリ秒単位でタイムア
     ウトを指定する。この2つの秒数は、互いに足し合わせる
     ことによりタイムアウトを指定し、その秒数経過後はサ
     ブプロセスの出力の有無に関わらずリターンする。

     SECONDSに浮動小数点数を指定することにより、秒を少数
     点で指定できるので、引数MILLISECは時代遅れである(そ
     して使用するべきではない)。SECONDSが0なら、この関数
     は保留中の出力が何であれ受け取り、待機しない。

     PROCESSがプロセスで、引数JUST-THIS-ONEが非‘nil’なら
     、そのプロセスからの出力だけが処理され、そのプロセ
     スからの出力を受信するか、タイムアウトとなるまで、
     他のプロセスの出力は停止される。JUST-THIS-ONEが整数
     なら、タイマーの実行も抑制される。この機能は一般的
     には推奨されないが、音声合成のような特定のアプリケ
     ーションにとっては必要かもしれない。

     関数‘accept-process-output’は、何らかの出力を取得し
     たら非‘nil’、出力の到着前にタイムアウトが到来したら
     ‘nil’をリターンする。


File: elisp,  Node: Sentinels,  Next: Query Before Exit,  Prev: Output from Processes,  Up: Processes

36.10 Sentinels: Detecting Process Status Changes
=================================================

“プロセスセンチネル(process sentinel: プロセス番兵)”とは
、(Emacsにより送信されたか、そのプロセス自身の動作が原因
で送信された)プロセスを終了、停止、継続するシグナルを含
む、何らかの理由により関連付けられたプロセスの状態が変化
した際は常に呼び出される関数のことです。プロセスがexitす
る際にも、プロセスセンチネルが呼び出されます。センチネル
は、イベントが発生したプロセスと、イベントのタイプを記述
する文字列という、2つの引数を受け取ります。

   イベントを記述する文字列は、以下のいずれかのような外
見をもちます:

   • ‘"finished\n"’.

   • ‘"exited abnormally with code EXITCODE\n"’.

   • ‘"NAME-OF-SIGNAL\n"’.

   • ‘"NAME-OF-SIGNAL (core dumped)\n"’.

   センチネルは、Emacsが(端末入力や時間経過、またはプロ
セス出力を)待機している間だけ実行されます。これは、他の
Lispプログラムの途中のランダムな箇所で実行されるセンチネ
ルが原因となる、タイミングエラーを無視します。プログラム
はセンチネルが実行されるように、‘sit-for’や
‘sleep-for’(*note Waiting::を参照)、または
‘accept-process-output’(*note Accepting Output::を参照
)を呼び出すことにより待機することができます。Emacsはコマ
ンドループが入力を読み取る際にも、センチネルの実行を許可
します。‘delete-process’は、実行中のプログラムを終了させ
る際に、センチネルを呼び出します。

   Emacsは1つのプロセスのセンチネル呼び出しの理由のため
に複数のキューを保持しません。これはカレント状態と、変化
があった事実だけを記録します。したがって非常に短い間隔で
、連続して状態に2つの変化があった場合は、一度だけセンチ
ネルが呼び出されます。しかしプロセスの終了は、常に正確に
1回センチネルを実行するでしょう。これは終了後にプロセス
状態が再び変更されることはないからです。

   Emacsはプロセスセンチネル実行の前に、プロセスからの出
力をチェックします。プロセス終了によりセンチネルが一度実
行されると、そのプロセスから更なる出力は到着しません。

   プロセスのバッファーに出力を書き込むセンチネルは、そ
のバッファーがまだ生きているかチェックするべきです。死ん
だバッファーへの挿入を試みた場合は、エラーとなるでしょう
。そのバッファーがすでに死んでいれば、‘(buffer-name
(process-buffer PROCESS))’は‘nil’をリターンします。

   quitは通常はセンチネル内では抑制されます。さもないと
、コマンドレベルでの‘C-g’のタイプ、またはユーザーコマン
ドのquitは予測できません。センチネル内部でのquitを許可し
たければ、‘inhibit-quit’を‘nil’にバインドしてください。
ほとんどの場合において、これを行う正しい方法はマクロ
‘with-local-quit’です。*note Quitting::を参照してくださ
い。

   センチネルの実行中にエラーが発生した場合、センチネル
開始時に実行中だったプログラムが何であれ実行を停止しない
ように、自動的にcatchされます。しかし‘debug-on-error’が
非‘nil’なら、エラーはcatchされません。これにより、Lispデ
バッガーを使用したセンチネルのデバッグが可能になります。
*note Debugger::を参照してください。

   センチネル実行中、センチネルが再帰的に実行されないよ
う、プロセスセンチネルは一時的に‘nil’にセットされます。
この理由により、センチネルが新たにセンチネルを指定するこ
とはできません。

   センチネル実行中、Emacsは自動的にマッチデータの保存と
リストアを行うことに注意してください。*note Match
Data::を参照してください。

 -- Function: set-process-sentinel process sentinel
     この関数は、PROCESSに関連付ける。SENTINELが‘nil’な
     ら、そのプロセスはプロセス状態変更時にプロセスのバ
     ッファーにメッセージを挿入する、デフォルトのセンチ
     ネルをもつことになるだろう。

     プロセスセンチネルの変更は、即座に効果を発揮する。
     そのセンチネルが実行される予定だが、まだ呼び出され
     ておらず、かつ新たなセンチネルを指定した場合、最終
     的なセンチネル呼び出しには、新たなセンチネルが使用
     されるだろう。

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event `%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               ⇒ msg-me
          (kill-process (get-process "shell"))
               ⊣ Process: #<process shell> had the event `killed'
               ⇒ #<process shell>

 -- Function: process-sentinel process
     この関数は、PROCESSのセンチネルをリターンする。

   あるプロセス状態の変化を複数のセンチネルに渡す必要が
ある場合は、既存のセンチネルと新たなセンチネルを組み合わ
せるために、‘add-function’を使用できます。*note Advising
Functions::を参照してください。

 -- Function: waiting-for-user-input-p
     この関数は、センチネルまたはフィルター関数の実行中
     、もしEmacsがセンチネルまたはフィルター関数呼び出し
     時にユーザーのキーボード入力を待機していたら非
     ‘nil’、そうでなければ‘nil’をリターンする。


File: elisp,  Node: Query Before Exit,  Next: System Processes,  Prev: Sentinels,  Up: Processes

36.11 Querying Before Exit
==========================

Emacsがexitする際は、すべてのサブプロセスに‘SIGHUP’を送
信することにより、すべてのサブプロセスを終了します。それ
らのサブプロセスはさまざまな処理を行っているかもしれない
ので、Emacsは通常ユーザーにたいしてそれらを終了しても大
丈夫か、確認を求めます。各プロセスはquery(問い合わせ)の
ためのフラグをもち、これが非‘nil’なら、Emacsはプロセスを
killしてexitする前に確認を行うべきであることを示します。
queryフラグにたいするデフォルトは‘t’で、これは問い合わせ
を_行う_ことを意味します。

 -- Function: process-query-on-exit-flag process
     これは、PROCESSのqueryフラグをリターンする。

 -- Function: set-process-query-on-exit-flag process
          flag
     この関数は、PROCESSのqueryフラグをFLAGにセットする
     。これはFLAGをリターンする。

     以下はshellプロセス上で、問い合わせを回避するために
     ‘set-process-query-on-exit-flag’を使用する例である:

          (set-process-query-on-exit-flag (get-process "shell") nil)
               ⇒ nil


File: elisp,  Node: System Processes,  Next: Transaction Queues,  Prev: Query Before Exit,  Up: Processes

36.12 Accessing Other Processes
===============================

カレントEmacsセッションのサブプロセスにたいするアクセス
と操作に加えて、同一マシン上で実行中の他のプロセスにたい
して、Emacs Lispプログラムがアクセスすることもできます。
Emacsのサブプロセスと区別するために、わたしたちはこれら
を“システムプロセス(system processes)”と呼んでいます。

   Emacsは、システムプロセスへのアクセス用のプリミティブ
をいくつか提供します。これらのプリミティブは、すべてのプ
ラットフォームではサポートされません。サポートしないシス
テムでは、これらのプリミティブは‘nil’をリターンします。

 -- Function: list-system-processes
     この関数は、そのシステム上で実行中の、すべてのプロ
     セスのリストをリターンする。各プロセスは、PIDという
     OSから割り当てられた数値によるプロセスIDにより識別
     され、同一時に同一マシン上で実行中の他のプロセスと
     区別される。

 -- Function: process-attributes pid
     この関数は、プロセスID PIDで指定されるプロセスにた
     いする、属性のalistをリターンする。このalist内の各
     属性は‘(KEY . VALUE)’という形式で、KEYは属性を指定
     し、VALUEはその属性の値である。この関数がリターン可
     能な、さまざまな属性にたいするKEYを、以下にリストし
     た。これらすべての属性を、すべてのプラットフォーム
     がサポートする訳ではない。ある属性がサポートされて
     いなければ、その連想値はリターンされるalist内に出現
     しない。数値であるような値は整数か浮動小数点数のい
     ずれかが可能で、それは値の大小に依存する。

     ‘euid’
          そのプロセスを呼び出したユーザーの、実効ユーザ
          ーID(effective user ID)。対応するVALUEは数値。
          プロセスがカレントEmacsセッションを実行したユ
          ーザーと同じなら、値は‘user-uid’がリターンする
          値と等しくなる(*note User Identification::を参
          照)。

     ‘user’
          そのプロセスの実効ユーザーIDに対応するユーザー
          名であるような文字列。

     ‘egid’
          実行ユーザーIDのグループIDであるような数値。

     ‘group’
          実効ユーザーのグループIDに対応するグループ名で
          あるような文字列。

     ‘comm’
          そのプロセス内で実効したコマンドの名前。これは
          通常、先行するディレクトリーを除いた実行可能フ
          ァイル名を指定する文字列である。しかし、いくつ
          かの特別なシステムプロセスは、実行可能ファイル
          またはプログラムに対応しない文字列を報告する可
          能性がある。

     ‘state’
          そのプロセスの状態コード。これはそのプロセスの
          スケジューリング状態をエンコードする短い文字列
          である。以下は頻繁に目にするコードのリストであ
          る:

          ‘"D"’
               割り込み不可のsleep(通常はI/Oによる)
          ‘"R"’
               実行中
          ‘"S"’
               割り込み可能なsleep(何らかのイベント待ち)
          ‘"T"’
               たとえばジョブ制御シグナルにより停止され
               た
          ‘"Z"’
               “zombie”: 終了したが親プロセスに回収され
               ていないプロセス

          可能な状態の完全なリストは、‘ps’コマンドのman
          pageを参照されたい。

     ‘ppid’
          親プロセスのプロセスIDであるような数値。

     ‘pgrp’
          そのプロセスのプロセスグループIDであるような数
          値。

     ‘sess’
          そのプロセスのセッションID。これはそのプロセス
          の“セッションリーダー(session leader)”のプロセ
          スIDであるような数値である。

     ‘ttname’
          そのプロセスの制御端末の名前であるような文字列
          。UnixおよびGNUシステムでは、これは通常は
          ‘/dev/pts65’のような、対応する端末デバイスのフ
          ァイル名である。

     ‘tpgid’
          そのプロセスの端末を使用するフォアグラウンドプ
          ロセスグループの、プロセスグループIDであるよう
          な数値。

     ‘minflt’
          そのプロセス開始以降に発生したマイナーなページ
          フォルト数(マイナーなページフォルトとはディス
          クからの読み込みを発生させないページフォルトの
          こと)。

     ‘majflt’
          そのプロセス開始以降に発生したメジャーなページ
          フォルト数(メジャーなページフォルトとは、ディ
          スクからの読み込みを要し、それ故にマイナーペー
          ジフォルトより高価なページフォルトのこと)。

     ‘cminflt’
     ‘cmajflt’
          ‘minflt’と‘majflt’と似ているが、与えられたプロ
          セスのすべての子プロセスのページフォルト数を含
          む。

     ‘utime’
          アプリケーションのコード実行にたいして、ユーザ
          ーコンテキスト内でプロセスに消費された時間。対
          応するVALUEは‘(HIGH LOW MICROSEC PICOSEC)’とい
          うフォーマットで、これは関数‘current-time’が使
          用するフォーマットと同じである(*note
          current-time: Time of Day.)および*note File
          Attributes::の‘file-attributes’を参照)。

     ‘stime’
          システムコールの処理にたいして、システム
          (kernel)コンテキスト内でプロセスに消費された時
          間。対応するVALUEは‘utime’と同じフォーマット。

     ‘time’
          ‘utime’と‘stime’の和。対応するVALUEは‘utime’と
          同じフォーマット。

     ‘cutime’
     ‘cstime’
     ‘ctime’
          ‘utime’や‘stime’と同様だが、与えられたプロセス
          のすべての子プロセスの時間が含まれる点が異なる
          。

     ‘pri’
          そのプロセスの数値的な優先度。

     ‘nice’
          そのプロセスの“nice値(nice value)”であるような
          数値(小さいnice値のプロセスがより優先的にスケ
          ジュールされる)。

     ‘thcount’
          そのプロセス内のスレッド数。

     ‘start’
          ‘file-attributes’および‘current-time’が使用す
          るのと同じフォーマット‘(HIGH LOW MICROSEC
          PICOSEC)’による、そのプロセスが開始された時刻
          。

     ‘etime’
          ‘(HIGH LOW MICROSEC PICOSEC)’というフォーマッ
          トによる、そのプロセスが開始されてから経過した
          時間。

     ‘vsize’
          そのプロセスの仮想メモリーのKB単位でのサイズ。

     ‘rss’
          そのプロセスがマシンの物理メモリー内で占める
          “常駐セット(resident set)”のKB単位でのサイズ。

     ‘pcpu’
          プロセス開始以降に使用されたCPU時間のパーセン
          テージ。対応するVALUEは0から100の間の浮動小数
          点数。

     ‘pmem’
          マシンにインストールされた物理メモリー合計のう
          ち、そのプロセスの常駐セットのパーセンテージ。
          値は0から100の間の浮動小数点数。

     ‘args’
          そのプロセスが呼び出されたときのコマンドライン
          。これは個々のコマンドライン引数がブランクで区
          切られた文字列である。引数に埋め込まれた空白文
          字は、そのシステムに応じて適切にクォートされる
          。GNUおよびUnixではバックスラッシュ文字による
          エスケープ、Windowsではダブルクォート文字で囲
          まれる。つまりこのコマンドライン文字列は、
          ‘shell-command’のようなプリミティブにより直接
          使用できる。


File: elisp,  Node: Transaction Queues,  Next: Network,  Prev: System Processes,  Up: Processes

36.13 Transaction Queues
========================

トランザクションを用いてサブプロセスと対話するために、
“トランザクションキュー(transaction queue)”を使用できま
す。まず‘tq-create’を使用して、指定したプロセスと対話す
るためのトランザクションキューを作成します。それからトラ
ンザクションを送信するために、‘tq-enqueue’を呼び出すこと
ができます。

 -- Function: tq-create process
     この関数は、PROCESSと対話するトランザクションキュー
     を作成してリターンする。引数PROCESSは、バイトストリ
     ームを送受信する能力をもつサブプロセスであること。
     これは子プロセス、または(おそらく別のマシン上の)サ
     ーバーへのTCP接続かもしれない。

 -- Function: tq-enqueue queue question regexp closure
          fn &optional delay-question
     この関数は、キューQUEUEにトランザクションを送信する
     。キューの指定は、対話するサブプロセスを指定する効
     果をもつ。

     引数QUESTIONは、トランザクションを開始するために発
     信するメッセージである。引数FNは、それにたいする応
     答が返信された際に呼び出す関数である。これは
     CLOSUREと受信した応答という、2つの引数で呼び出され
     る。

     引数REGEXPは応答全体の終端にマッチし、それより前に
     はマッチしない正規表現であること。これが応答の終わ
     りを‘tq-enqueue’が決定する方法である。

     引数DELAY-QUESTIONが非‘nil’なら、そのプロセスが以前
     に発信したすべてのメッセージへの返信が完了するまで
     、このメッセージの送信を遅延する。これは、いくつか
     のプロセスにたいしてより信頼性のある結果が生成され
     る。

 -- Function: tq-close queue
     保留中のすべてのトランザクションの完了を待機して、
     トランザクションキューQUEUEをシャットダウンし、それ
     から接続または子プロセスを終了する。

   トランザクションキューは、フィルター関数により実装さ
れています。*note Filter Functions::を参照してください。


File: elisp,  Node: Network,  Next: Network Servers,  Prev: Transaction Queues,  Up: Processes

36.14 Network Connections
=========================

Emacs Lispプログラムは、同一マシンまたは他のマシン上の別
プロセスにたいして、ストリーム(TCP)およびデータグラム
(UDP)のネットワーク接続(*note Datagrams::を参照)をオープ
ンできます。ネットワーク接続はLispにより、サブプロセスと
同様に処理され、プロセスオブジェクトとして表されます。し
かし対話を行うそのプロセスは、Emacsの子プロセスではなく
、プロセスIDをもたず、それをkillしたりシグナルを送信する
ことはできません。行うことができるのは、データの送信と受
信だけです。‘delete-process’は接続をクローズしますが、他
端のプログラムをkillしません。そのプログラムは接続のクロ
ーズについて何を行うか、決定しなければなりません。

   ネットワークサーバーを作成することにより、Lispプログ
ラムは接続をlistenできます。ネットワークサーバーもある種
のプロセスオブジェクトとして表されますが、ネットワーク接
続とは異なり、ネットワークサーバーがデータ自体を転送する
ことは決してありません。接続リクエストを受信したときは、
それにたいして作成した接続を表す、新たなネットワーク接続
を作成します(そのネットワーク接続はサーバーから、プロセ
スplistを含む特定の情報を継承する)。その後、ネットワーク
サーバーは更なる接続リクエストのlistenに戻ります。

   ネットワーク接続およびサーバーは、キーワード/引数のペ
アーで構成される引数リストで‘make-network-process’を呼び
出すことにより作成されます。たとえば‘:server t’はサーバ
ープロセス、‘:type 'datagram’はデータグラム接続を作成し
ます。詳細は*note Low-Level Network::を参照してください
。以下で説明する‘open-network-stream’を使用することもで
きます。

   異なるプロセスのタイプを区別するために、
‘process-type’関数はネットワーク接続またはサーバーにたい
してはシンボル‘network’、シリアルポート接続は‘serial’、
実際のサブプロセスにたいしては‘real’をリターンします。

   ネットワーク接続にたいして、‘process-status’関数は
‘open’、‘closed’、‘connect’、‘failed’をリターンします。
ネットワークサーバーにたいしては、状態は常に‘listen’にな
ります。実際のサブプロセスにたいしては、これらの値はリタ
ーンされません。*note Process Information::を参照してく
ださい。

   ‘stop-process’と‘continue-process’を呼び出すことによ
り、ネットワークプロセスの処理の停止と再開が可能です。サ
ーバープロセスにたいする停止は、新たな接続の受け付けない
ことを意味します(サーバー再開時は5つまでの接続リクエスト
がキューされる。これがOSによる制限でなければこの制限は増
やすことができる。*note Network Processes::の
‘make-network-process’の‘:server’を参照されたい)。ネット
ワークストリーム接続にたいしては、停止は入力の処理を行わ
ないことを意味します(到着するすべての入力は接続の再開ま
で待つ)。データグラム接続にたいしては、いくらかのパケッ
トはキューされますが、入力は失われるかもしれません。ネッ
トワーク接続またはサーバーが停止しているかどうかを判断す
るために、関数‘process-command’を使用できます。これが非
‘nil’なら停止しています。

   ビルトインまたは外部のサポートを使用することにより、
Emacsは暗号化されたネットワーク接続を作成できます。ビル
トインのサポートはGnuTLSライブラリー(“TLS: Transport
Layer Security”)を使用します。the GnuTLS project page
(http://www.gnu.org/software/gnutls/)を参照してください
。GnuTLSサポートつきでEmacsをコンパイルした場合は、関数
‘gnutls-available-p’が定義され、非‘nil’をリターンします
。詳細は*note Overview: (emacs-gnutls)Top.を参照してくだ
さい。外部のサポートの場合は、‘starttls.el’ライブラリー
を使用します。これはシステム上に‘gnutls-cli’のようなヘル
パーユーティリティーのインストールを必要とします。
‘open-network-stream’関数は、何であれ利用可能なサポート
を使用して、暗号化接続作成の詳細を透過的に処理できます。

 -- Function: open-network-stream name buffer host
          service &rest parameters
     この関数は、オプションで暗号つきでTCP接続をオープン
     して、その接続を表すプロセスオブジェクトをリターン
     する。

     NAME引数は、プロセスオブジェクトの名前を指定する。
     これは必要に応じて一意になるよう修正される。

     BUFFER引数は、その接続に関連付けるバッファーである
     。その接続からの出力は、その出力を処理する独自のフ
     ィルター関数を指定していなければ、BUFFERが‘nil’なら
     、その接続はバッファーに関連付けられない。

     引数HOSTとSERVICEは、どこに接続するかを指定する。
     HOSTはホスト名(文字列)、SERVICEは定義済みのネットワ
     ークサービス名(文字列)、またはポート番号(数字)であ
     る。

     残りの引数PARAMETERSは、主に暗号化された接続に関連
     する、キーワード/引数のペアーである:

     ‘:nowait BOOLEAN’
          非‘nil’なら非同期接続を試みる。

     ‘:type TYPE’
          接続のタイプ。オプションは以下のとおり:

          ‘plain’
               通常の暗号化されていない接続。
          ‘tls’
          ‘ssl’
               TLS(“Transport Layer Security”)接続。
          ‘nil’
          ‘network’
               plain接続を開始して、パラメーター
               ‘:success’および‘:capability-command’が与
               えられたら、STARTTLSを通じて暗号化接続へ
               の更新を試みる。これが失敗したら、暗号化
               されていない接続のまま留まる。
          ‘starttls’
               ‘nil’と同様だが、STARTTLSが失敗したらその
               接続を切断する。
          ‘shell’
               shell接続。

     ‘:always-query-capabilities BOOLEAN’
          非‘nil’なら、たとえ‘plain’な接続を行っていると
          きでも、常にサーバーの能力を問い合わせる。

     ‘:capability-command CAPABILITY-COMMAND’
          ホストの能力を問い合わせるためのコマンド文字列
          。

     ‘:end-of-command REGEXP’
     ‘:end-of-capability REGEXP’
          コマンドの終端、またはコマンド
          CAPABILITY-COMMANDの終端にマッチする正規表現。
          前者は後者のデフォルトである。

     ‘:starttls-function FUNCTION’
          単一の引数(CAPABILITY-COMMANDにたいする応答)を
          とり‘nil’、またはサポートされていれば
          STARTTLSをアクティブにするコマンドをリターンす
          る関数。

     ‘:success REGEXP’
          成功したSTARTTLSネゴシェーションにマッチする正
          規表現。

     ‘:use-starttls-if-possible BOOLEAN’
          非‘nil’なら、たとえEmacsがビルトインのTLSサポ
          ートをもっていなくても、日和見的
          (opportunistic)にSTARTTLSアップグレードを行う
          。

     ‘:client-certificate LIST-OR-T’
          証明書(certificate)のキーと、証明書のファイル
          自身を命名する‘(KEY-FILE CERT-FILE)’という形式
          のリスト、またはこの情報にたいして
          ‘auth-source’を尋ねることを意味する‘t’のいずれ
          か(*note Overview: (auth)Top.を参照)。TLSまた
          はSTARTTLSにたいしてのみ使用される。

     ‘:return-list CONS-OR-NIL’
          この関数のリターン値。省略または‘nil’なら、プ
          ロセスオブジェクトをリターンする。それ以外なら
          、‘(PROCESS-OBJECT . PLIST)’という形式のコンス
          セルをリターンする。ここでPLISTは以下のキーワ
          ードである:

          ‘:greeting STRING-OR-NIL’
               非‘nil’なら、ホストからリターンされた
               greeting(挨拶)文字列。
          ‘:capabilities STRING-OR-NIL’
               非‘nil’なら、ホストの能力(capability)文字
               列。
          ‘:type SYMBOL’
               接続タイプで、‘plain’か‘tls’のいずれか。


File: elisp,  Node: Network Servers,  Next: Datagrams,  Prev: Network,  Up: Processes

36.15 Network Servers
=====================

‘:server t’で‘make-network-process’を呼び出すことにより
サーバーが作成されます(*note Network Processes::を参照
)。そのサーバーは、クライアントからの接続リクエストを
listenするでしょう。クライアントの接続リクエストを
accept(受け入れる)する際は、以下のようなパラメーターで、
それ自体がプロセスオブジェクトであるようなネットワーク接
続を作成します。

   • その接続のプロセス名は、サーバープロセスのNAMEと、
     クライアント識別文字列を結合して構築される。IPv4接
     続にたいするクライアント識別文字列は、アドレスとポ
     ート番号を表す、‘<A.B.C.D:P>’のような文字列である。
     それ以外なら、‘<NNN>’のようにカッコで囲まれた一意な
     数字である。この数字は、そのEmacsセッション内のそれ
     ぞれの接続にたいして一意である。

   • サーバーが非デフォルトのフィルターをもつ場合、その
     接続プロセスは別個にプロセスバッファーを取得しない
     。それ以外なら、Emacsはその目的のために新たにバッフ
     ァーを作成する。サーバーのバッファー名またはプロセ
     ス名にクライアント識別文字列に結合したものがバッフ
     ァー名になる。

     サーバーのプロセスバッファーの値が直接使用されるこ
     とは決してないが、log関数はそれを取得して、そこにテ
     キストを挿入することにより、接続のログを記録するた
     めに使用することができる。

   • 通信タイプ(communication type)、プロセスフィルター
     、およびセンチネルはそれぞれ、サーバーのものから継
     承される。サーバーが直接フィルターとセンチネルを使
     用することは決してない。それらの唯一の目的は、サー
     バーへの接続を初期化することである。

   • その接続のプロセスコンタクト情報は、クライアントの
     アドレス情報(通常はIPアドレスとポート番号)に応じて
     セットされる。この情報は、‘process-contact’のキーワ
     ード‘:host’、‘:service’、‘:remote’に関連付けられる
     。

   • その接続のローカルアドレスは、それが使用するポート
     番号に応じてセットアップされる。

   • クライアントプロセスのplistは、サーバーのplistから
     インストールされる。


File: elisp,  Node: Datagrams,  Next: Low-Level Network,  Prev: Network Servers,  Up: Processes

36.16 Datagrams
===============

“データグラム(datagram)”接続は、データストリームではなく
個別のパッケージで対話します。‘process-send’を呼び出すた
びに1つのデータグラムパケット(*note Input to
Processes::)が送信され、受信されたデータグラムごとに1回
フィルター関数が呼び出されます。

   データグラム接続は、毎回同じリモートピア(remote
peer)と対話する必要はありません。データグラム接続は、デ
ータグラムの送信先を指定する、“リモートピアアドレス
(remote peer address)”をもちます。フィルター関数にたいし
て受信されたデータグラムが渡されるたびに、そのデータグラ
ムの送信元アドレスがピアアドレスにセットされます。このよ
うに、もしフィルター関数がデータグラムを送信したら、それ
は元の場所へ戻ることになります。‘:remote’キーワードを使
用してデータグラム接続を作成する際は、リモートピアアドレ
スを指定できます。‘set-process-datagram-address’を呼び出
すことにより、後からそれを変更できます。

 -- Function: process-datagram-address process
     PROCESSがデータグラム接続またはサーバーなら、この関
     数はそれのリモートピアアドレスをリターンする。

 -- Function: set-process-datagram-address process
          address
     PROCESSがデータグラム接続またはサーバーなら、この関
     数はそのリモートピアアドレスにADDRESSをセットする。


File: elisp,  Node: Low-Level Network,  Next: Misc Network,  Prev: Datagrams,  Up: Processes

36.17 Low-Level Network Access
==============================

‘make-network-process’を使用することにより、
‘open-network-stream’より低レベルでの処理により、ネット
ワーク接続を作成することもできます。

* Menu:

* Proc: Network Processes.   ‘make-network-process’の使用。
* Options: Network Options.  更なるネットワーク接続の制御。
* Features: Network Feature Testing.  使用中マシン上で動作するネットワーク機能を判断する。


File: elisp,  Node: Network Processes,  Next: Network Options,  Up: Low-Level Network

36.17.1 ‘make-network-process’
------------------------------

ネットワーク接続およびネットワークサーバーを作成する基本
的な関数は、‘make-network-process’です。これは与えられた
引数に応じて、これらの仕事のいずれかを行うことができます
。

 -- Function: make-network-process &rest args
     この関数は、ネットワーク接続またはサーバーを作成し
     て、それを表すプロセスオブジェクトをリターンする。
     引数ARGSは、キーワード/引数のペアからなるリストであ
     る。キーワードの省略は‘:coding’、
     ‘:filter-multibyte’、‘:reuseaddr’を除き、常に値とし
     て‘nil’を指定したのと同じことになる。重要なキーワー
     ドを以下に示す(ネットワークオプションに対応するキー
     ワードを、以降のセクションにリストする)。

     :name NAME
          プロセス名として、文字列NAMEを使用する。一意に
          するために、必要に応じて変更され得る。

     :type TYPE
          コミュニケーションのタイプを指定する。値
          ‘nil’はストリーム接続(デフォルト)、
          ‘datagram’はデータグラム接続、‘seqpacket’は“シ
          ーケンスパケットストリーム(sequenced packet
          stream)”による接続を指定する。接続およびサーバ
          ーの両方で、これらのタイプを指定できる。

     :server SERVER-FLAG
          SERVER-FLAGが非‘nil’ならサーバー、それ以外なら
          接続を作成する。ストリームタイプのサーバーでは
          、SERVER-FLAGはそのサーバーへの保留中の接続キ
          ューの長さを指定する、整数を指定できる。キュー
          のデフォルト長は5。

     :host HOST
          接続するホストを指定する。HOSTは、ホスト名また
          はインターネットアドレスを表す文字列、またはロ
          ーカルホストを表すシンボル‘local’であること。
          サーバーのときにHOSTを指定する場合は、有効なロ
          ーカルホストのアドレスを指定しなければならず、
          そのアドレスに接続するクライアントだけが受け入
          れられるだろう。

     :service SERVICE
          SERVICEは接続先のポート番号、またはサーバーに
          たいしてはlistenするポート番号である。これはポ
          ート番号に変換されるようなサービス名、または直
          接ポート番号を指定する整数であること。サーバー
          にたいしては‘t’も指定でき、これは未使用のポー
          ト番号をシステムに選択させることを意味する。

     :family FAMILY
          FAMILYは、接続のアドレス(またはプロトコル)のフ
          ァミリーを指定する。‘nil’は、与えられたHOSTと
          SERVICEにたいして、自動的に適切なアドレスファ
          ミリーを決定する。‘local’はUnixのsocketを指定
          し、この場合HOSTは無視される。‘ipv4’と‘ipv6’は
          それぞれ、IPv4とIPv6の使用を指定する。

     :local LOCAL-ADDRESS
          サーバープロセスでは、LOCAL-ADDRESSはlistenす
          るアドレスである。これはFAMILY、HOST、
          SERVICEをオーバーライドするので、これらを指定
          しないこともできる。

     :remote REMOTE-ADDRESS
          接続プロセスでは、REMOTE-ADDRESSは接続先のアド
          レスである。これはFAMILY、HOST、SERVICEをオー
          バーライドするので、これらを指定しないこともで
          きる。

          データグラムサーバーでは、REMOTE-ADDRESSはリモ
          ートデータグラムアドレスの初期セッティングを指
          定する。

          LOCAL-ADDRESSとREMOTE-ADDRESSのフォーマットは
          、そのアドレスファミリーに依存する:

             - IPv4アドレスは、4つの8ビット整数と1つの
               16ビット整数からなる5要素のベクター‘[A B
               C D P]’で表され、それぞれ数値的なIPv4アド
               レスA.B.C.D、およびポート番号Pに対応する
               。

             - IPv6アドレスは、9要素の16ビット整数ベクタ
               ー‘[A B C D E F G H P]’で表され、それぞれ
               数値的なIPv６アドレスA:B:C:D:E:F:G:H、お
               よびポート番号Pに対応する。

             - ローカルアドレスは、ローカルアドレススペ
               ース内でアドレスを指定する文字列として表
               される。

             - “未サポートファミリー(unsupported
               family)”のアドレスは、コンスセル‘(F .
               AV)’で表される。ここでFはファミリー名、
               AVはアドレスデータバイトごとに1つの要素を
               使用する、ソケットアドレスを指定するベク
               ターである。可搬性のあるコードでこのフォ
               ーマットを信頼してはならない。これは実装
               定義の定数、データサイズ、データ構造のア
               ライメントに依存する可能性があるからだ。

     :nowait BOOL
          ストリーム接続にたいしてBOOLが非‘nil’なら、そ
          の接続の完了を待機せずにリターンする。接続が成
          功または失敗時には、Emacsは‘"open"’(成功時)、
          または‘"failed"’(失敗時)にマッチするような第
          2引数により、センチネル関数を呼び出すだろう。
          デフォルトではwaitせずにblockするので、
          ‘make-network-process’はその接続が成功または失
          敗するまで、リターンしない。

     :stop STOPPED
          STOPPEDが非‘nil’なら、“stopped”の状態でネット
          ワーク接続、またはサーバーを開始する。

     :buffer BUFFER
          プロセスバッファーとしてBUFFERを使用する。

     :coding CODING
          このプロセスにたいするコーディングシステムとし
          て、CODINGを使用する。接続からのデータのデコー
          ド、および接続への送信データのエンコードに異な
          るコーディングシステムを指定するには、CODINGに
          たいして‘(DECODING . ENCODING)’と指定する。

          このキーワードをまったく指定しないかった場合の
          デフォルトは、そのデータからコーディングシステ
          ムを判断する。

     :noquery QUERY-FLAG
          プロセスqueryフラグをQUERY-FLAGに初期化する。
          *note Query Before Exit::を参照のこと。

     :filter FILTER
          プロセスフィルターをFILTERに初期化する。

     :filter-multibyte MULTIBYTE
          MULTIBYTEが非‘nil’ならマルチバイト文字列、それ
          以外ならユニバイト文字列がプロセスフィルターに
          与えられるデフォルトは、
          ‘enable-multibyte-characters’のデフォルト値で
          ある。

     :sentinel SENTINEL
          プロセスセンチネルをSENTINELに初期化する。

     :log LOG
          サーバープロセスのlog関数を、LOGに初期化する。
          サーバーがクライアントからネットワーク接続を
          acceptするたびに、そのlog関数が呼び出される。
          log関数に渡される引数はSERVER、CONNECTION、
          MESSAGEである。ここでSERVERはサーバープロセス
          、CONNECTIONはその接続にたいする新たなプロセス
          、MESSAGEは何が発生したかを説明する文字列であ
          る。

     :plist PLIST
          プロセスplistをPLISTに初期化する。

     実際の接続情報で修正されたオリジナルの引数リストは
     、‘process-contact’を通じて利用できる。


File: elisp,  Node: Network Options,  Next: Network Feature Testing,  Prev: Network Processes,  Up: Low-Level Network

36.17.2 Network Options
-----------------------

以下のネットワークオプションは、ネットワークプロセス作成
時に指定できます。‘:reuseaddr’を除き、
‘set-network-process-option’を使用して、これらのオプショ
ンを後からセットまたは変更することもできます。

   サーバープロセスにたいしては、
‘make-network-process’で指定されたオプションはクライアン
トに継承されないので、子接続が作成されるたびに、必要なオ
プションをセットする必要があるでしょう。

:bindtodevice DEVICE-NAME
     DEVICE-NAMEが空でないネットワークインターフェースを
     指定する文字列なら、そのインターフェースで受信した
     パケットだけを処理する。DEVICE-NAMEが‘nil’(デフォル
     ト)なら、任意のインターフェースが受信したパケットを
     処理する。

     このオプションの使用にたいして、特別な特権を要求す
     るシステムがいくつかあるかもしれない。

:broadcast BROADCAST-FLAG
     データグラムプロセスにたいしてBROADCAST-FLAGが非
     ‘nil’なら、そのプロセスはブロードキャストアドレスに
     送信されたデータグラムパケットを受信し、ブロードキ
     ャストアドレスにパケットを送信できるだろう。これは
     ストリーム接続では無視される。

:dontroute DONTROUTE-FLAG
     DONTROUTE-FLAGが非‘nil’なら、プロセスはローカルホス
     トと同一ネットワーク上のホストだけに送信することが
     できる。

:keepalive KEEPALIVE-FLAG
     ストリーム接続にたいしてKEEPALIVE-FLAGが非‘nil’なら
     、低レベルのkeep-aliveメッセージの交換が有効になる
     。

:linger LINGER-ARG
     LINGER-ARGが非‘nil’なら、接続を削除
     (‘delete-process’を参照)する前にキューされたすべて
     のパケットの送信が成功するまで待機する。
     LINGER-ARGが整数なら、接続クローズ前のキュー済みパ
     ケット送信のために待機する、最大の秒数を指定する。
     デフォルトは‘nil’で、これはプロセス削除時に未送信の
     キュー済みパケットを破棄することを意味する。

:oobinline OOBINLINE-FLAG
     ストリーム接続にたいしてOOBINLINE-FLAGが非‘nil’なら
     、通常のデータストリーム内の帯域外(out-of-band)デー
     タを受信し、それ以外なら帯域外データは破棄する。

:priority PRIORITY
     この接続で送信するパケットの優先順位を、整数
     PRIORITYにセットする。たとえばこの接続で送信する
     IPパケットのTOS(type of service)フィールドにセット
     する等、この数字の解釈はプロトコル固有である。また
     、そのネットワークインターフェース上で特定の出力キ
     ューを選択する等、これにはシステム依存の効果もある
     。

:reuseaddr REUSEADDR-FLAG
     ストリームプロセスサーバーにたいして
     REUSEADDR-FLAGが非‘nil’(デフォルト)なら、そのホスト
     上の別プロセスがそのポートですでにlistenしていなけ
     れば、このサーバーは特定のポート番号(‘:service’を参
     照)を再使用できる。REUSEADDR-FLAGが‘nil’なら、(その
     ホスト上の任意のプロセスが)そのポートを最後に使用し
     た後、そのポート上で新たなサーバーを作成するのが不
     可能となるような、一定の期間が存在するかもしれない
     。

 -- Function: set-network-process-option process option
          value &optional no-error
     この関数はネットワークプロセスPROCESSにたいして、ネ
     ットワークオプションのセットまたは変更を行う。指定
     できるオプションは‘make-network-process’と同様。
     NO-ERRORが非‘nil’なら、OPTIONがサポートされないオプ
     ションの場合に、この関数はエラーをシグナルせずに、
     ‘nil’をリターンする。この関数が成功裏に完了したら、
     ‘t’をリターンする。

     あるオプションのカレントのセッティングは、
     ‘process-contact’関数を通じて利用できる。


File: elisp,  Node: Network Feature Testing,  Prev: Network Options,  Up: Low-Level Network

36.17.3 Testing Availability of Network Features
------------------------------------------------

与えられネットワーク機能が▼利用可能かテストするためには
、以下のように‘featurep’を使用します:

     (featurep 'make-network-process '(KEYWORD VALUE))

このフォームの結果は、‘make-network-process’内で
KEYWORDに値VALUEを指定することが機能するなら、‘t’になり
ます。以下は、この方法でテストできるKEYWORD/VALUEペアー
のいくつかです。

‘(:nowait t)’
     非ブロッキング接続がサポートされていれば非‘nil’。
‘(:type datagram)’
     データグラムがサポートされていれば非‘nil’。
‘(:family local)’
     ローカルsocket(別名“UNIX domain”)がサポートされてい
     れば非‘nil’。
‘(:family ipv6)’
     IPv6がサポートされていれば非‘nil’。
‘(:service t)’
     サーバーにたいしてシステムがポートを選択できれば非
     ‘nil’。

   与えられたネットワークオプションが利用可能かテストす
るためには、以下のように‘featurep’を使用します:

     (featurep 'make-network-process 'KEYWORD)

指定できるKEYWORDの値は‘:bindtodevice’等です。完全なリス
トは*note Network Options::を参照してください。このフォ
ームは、‘make-network-process’(または
‘set-network-process-option’)が特定のネットワークオプシ
ョンをサポートしていれば、非‘nil’をリターンする。


File: elisp,  Node: Misc Network,  Next: Serial Ports,  Prev: Low-Level Network,  Up: Processes

36.18 Misc Network Facilities
=============================

以下の追加の関数は、ネットワーク接続の作成や操作に有用で
す。これらは、いくつかのシステムでのみサポートされること
に注意してください。

 -- Function: network-interface-list
     この関数は、使用しているマシン上のネットワークイン
     ターフェースを記述する、リストをリターンする。値は
     、要素が‘(NAME . ADDRESS)’という形式をもつような
     alistである。ADDRESSは、‘make-network-process’の引
     数LOCAL-ADDRESSおよびREMOTE-ADDRESSと同じ形式をもつ
     。

 -- Function: network-interface-info ifname
     この関数は、IFNAMEという名前のネットワークインター
     フェースに関する情報をリターンする。値は、‘(ADDR
     BCAST NETMASK HWADDR FLAGS)’という形式をもつリスト
     である。

     ADDR
          インターネットプロトコルアドレス。
     BCAST
          ブロードキャストアドレス。
     NETMASK
          ネットワークマスク。
     HWADDR
          レイヤー2アドレス(たとえばイーサネットMACアド
          レス)。
     FLAGS
          そのインターフェースのカレントのフラグ。

 -- Function: format-network-address address &optional
          omit-port
     この関数は、ネットワークアドレスのLisp表現を文字列
     に変換する。

     5要素のベクター‘[A B C D P]’はIPv4アドレスA.B.C.D、
     およびポート番号Pを表す。‘format-network-address’は
     これを、文字列‘\"A.B.C.D:P\"’に変換する。

     9要素のベクター‘[A B C D E F G H P]’はポート番号と
     ともに、IPv6アドレスを表す。
     ‘format-network-address’はこれを、文字列
     ‘"[A:B:C:D:E:F:G:H]:P"’に変換する。

     このベクターにポート番号が含まれない、または
     OMIT-PORTが非‘nil’なら、結果にサフィックス‘:P’は含
     まれない。


File: elisp,  Node: Serial Ports,  Next: Byte Packing,  Prev: Misc Network,  Up: Processes

36.19 Communicating with Serial Ports
=====================================

Emacsはシリアルポートと対話できます。インタラクティブな
使用、‘M-x serial-term’にたいしては端末ウィンドウをオー
プンし、Lispプログラム‘make-serial-process’にたいしては
プロセスオブジェクトを作成します。

   シリアルポートは、クローズと再オープンなして、実行時
に設定することができます。関数
‘serial-process-configure’によりスピード、バイトサイズ、
およびその他のパラメーターを変更できます。
‘serial-term’で作成された端末ウィンドウでは、モードライ
ンをクリックして設定を行うことができます。

   シリアル接続はプロセスオブジェクトとして表され、サブ
プロセスやネットワークプロセスと同様の方法で使用できます
。これによりデータの送受信や、シリアルポートの設定ができ
ます。しかし、シリアルプロセスオブジェクトにプロセスIDは
ありません。それにたいしてシグナルの送信はできず、ステー
タスコードは他のタイプのプロセスオブジェクトとは異なりま
す。プロセスオブジェクトへの‘delete-process’、またはプロ
セスバッファーにたいする‘kill-buffer’は接続をクローズし
ますが、そのシリアルポートに接続されたデバイスに影響はあ
りません。

   関数‘process-type’は、シリアルポート接続を表すプロセ
スオブジェクトにたいする、シンボル‘serial’をリターンしま
す。

   シリアルポートはGNU/Linux、Unix、およびMS Windowsのシ
ステムで利用できます。

 -- Command: serial-term port speed
     新たなバッファー内で、シリアルポートにたいする端末
     エミュレーターを開始する。PORTは、接続先のシリアル
     ポートの名前である。たとえばUnixでは、これは
     ‘/dev/ttyS0’のようになるだろう。MS Windowsでは、
     ‘COM1’や‘\\.\COM10’のようになるかもしれない(Lisp文
     字列ではバックスラッシュは2重にする)。

     SPEEDは、ビット毎秒でのシリアルポートのスピードであ
     る。一般的な値は9600。そのバッファーはTermモードに
     なる。このバッファーで使用するコマンドについては、
     *note (emacs)Term Mode::を参照のこと。モードライン
     メニューから、スピードと設定を変更できる。

 -- Function: make-serial-process &rest args
     この関数は、プロセスとバッファーを作成する。引数は
     、キーワード/引数ペアーで指定する。以下は意味のある
     キーワードのリストで、最初の2つ(PORTとSPEED)は必須
     である:

     ‘:port PORT’
          これは、シリアルポートの名前である。Unixおよび
          GNUシステムでは‘/dev/ttyS0’のようなファイル名
          、Windowsでは‘COM1’、‘COM9’より高位のポートで
          は‘\\.\COM10’のようになるかもしれない(Lisp文字
          列ではバックスラッシュは2重にする)。

     ‘:speed SPEED’
          ビット毎秒でのシリアルポートのスピード。この関
          数は‘serial-process-configure’を呼び出すことに
          より、スピードを操作する。この関数の更なる詳細
          については、以降のドキュメントを参照されたい。

     ‘:name NAME’
          そのプロセスの名前。NAMEが与えられなければ、
          PORTが同様にプロセス名の役目を果たす。

     ‘:buffer BUFFER’
          そのプロセスに関連付けられたバッファー。値はバ
          ッファー、またはそれがバッファーの名前であるよ
          うな文字列かもしれない。出力を処理するために出
          力ストリーム、あるいはフィルター関数を指定しな
          ければ、プロセス出力はそのバッファーの終端に出
          力される。BUFFERが与えられなければ、そのプロセ
          スバッファーの名前は、‘:name’キーワードから取
          得される。

     ‘:coding CODING’
          CODINGは、このプロセスにたいする読み書きに使用
          される、コーディングシステムを指定する。
          CODINGがコンス‘(DECODING . ENCODING)’なら、読
          み取りにDECODING、書き込みにはENCODINGが使用さ
          れる。指定されない場合のデフォルトは、データ自
          身から判断されるコーディングシステムである。

     ‘:noquery QUERY-FLAG’
          プロセスqueryフラグを、QUERY-FLAGに初期化する
          。*note Query Before Exit::を参照のこと。未指
          定の場合のフラグのデフォルトは‘nil’。

     ‘:stop BOOL’
          BOOLが非‘nil’なら、“stopped”の状態でプロセスを
          開始する。stopped状態では、シリアルプロセスは
          入力データを受け付けないが、出力データの送信は
          可能。stopped状態のクリアーは
          ‘continue-process’、セットは‘stop-process’で行
          う。

     ‘:filter FILTER’
          プロセスフィルターとして、FILTERをインストール
          する。

     ‘:sentinel SENTINEL’
          プロセスセンチネルとして、SENTINELをインストー
          ルする。

     ‘:plist PLIST’
          プロセスの初期plistとして、PLISTをインストール
          する。

     ‘:bytesize’
     ‘:parity’
     ‘:stopbits’
     ‘:flowcontrol’
          これらは、‘make-serial-process’が呼び出す、
          ‘serial-process-configure’により処理される。

     後の設定により変更され得るオリジナルの引数リストは
     、関数‘process-contact’を通じて利用可能。

     以下に例を示す:

          (make-serial-process :port "/dev/ttyS0" :speed 9600)

 -- Function: serial-process-configure &rest args

     この関数は、シリアルポート接続を設定する。引数はキ
     ーワード/引数ペアーで指定する。与えられない属性は、
     そのプロセスのカレントの設定(関数
     ‘process-contact’を通じて利用可能)から再初期化され
     るか、妥当なデフォルトにセットされる。以下の引数が
     定義されている:

     ‘:process PROCESS’
     ‘:name NAME’
     ‘:buffer BUFFER’
     ‘:port PORT’
          設定するプロセスを識別するために、これらの引数
          のいずれかを与えられる。これらの引数が何も与え
          られなければ、カレントバッファーのプロセスが使
          用される。

     ‘:speed SPEED’
          ビット毎秒、別名“ボーレート(baud rate)”での、
          シリアルポートのスピード。値には任意の数字が可
          能だが、ほとんどのシリアルポートは1200から
          115200の間の数少ない定義済みの値でのみ機能し、
          もっとも一般的な値は9600である。SPEEDが‘nil’な
          ら、この関数は他のすべての引数を無視して、その
          ポートを設定しない。これは接続を通じて送信され
          た‘AT’コマンドでのみ設定可能な、Bluetooth/シリ
          アル変換アダプターのような、特殊なシリアルポー
          トで有用かもしれない。SPEEDにたいする値‘nil’は
          、‘make-serial-process’または‘serial-term’の呼
          び出しにより、すでにオープン済みの接続にたいし
          てのみ有効である。

     ‘:bytesize BYTESIZE’
          ビット/バイトでの数値で、7か8を指定できる。
          BYTESIZEが与えられない、または‘nil’の場合のデ
          フォルトは8。

     ‘:parity PARITY’
          値には‘nil’(パリティなし)、シンボル‘odd’(奇数
          パリティ)、シンボル‘even’(偶数パリティ)を指定
          できる。PARITYが与えられない場合のデフォルトは
          パリティなし。

     ‘:stopbits STOPBITS’
          各バイトの送信を終了するために使用されるストッ
          プビットの数値。STOPBITSには1か2が可能。
          STOPBITSが与えられない、または‘nil’の場合のデ
          フォルトは1。

     ‘:flowcontrol FLOWCONTROL’
          この接続にたいして使用するフロー制御のタイプで
          、‘nil’(フロー制御を使用しない)、シンボル
          ‘hw’(RTS/CTSハードウェアフロー制御)、シンボル
          ‘sw’(XON/XOFFソフトウェアフロー制御)のいずれか
          。FLOWCONTROLが与えられない場合のデフォルトは
          、フロー制御なし。

     シリアルポートの初期設定のために、
     ‘make-serial-process’は内部的に
     ‘serial-process-configure’を呼び出す。


File: elisp,  Node: Byte Packing,  Prev: Serial Ports,  Up: Processes

36.20 Packing and Unpacking Byte Arrays
=======================================

このセクションでは、通常はバイナリーのネットワークプロト
コル用のバイト配列を、packおよびunpackする朴を説明します
。以下の関数は、バイト配列とalistとの間で相互に変換を行
います。バイト配列はユニバイト文字列、または整数ベクター
として表現することができます。一方alistはシンボルを固定
サイズのオブジェクト、または再帰的な複alistのいずれかに
関連付けます。このセクションで参照する関数を使用するため
には、‘bindat’ライブラリーをロードしてください。

   バイト配列からネストされたalistへの変換は、逆方向への
変換が“シリアライズ化(serializing)”、または“pack化
(packing)”として呼ばれることから、“非シリアル化【
deserializing)”、または“unpack化(unpacking)”として知られ
ています。

* Menu:

* Bindat Spec::              データレイアウトの記述。
* Bindat Functions::         unpack化とpack化を行う。
* Bindat Examples::          bindat.elが行えることのサンプル。


File: elisp,  Node: Bindat Spec,  Next: Bindat Functions,  Up: Byte Packing

36.20.1 Describing Data Layout
------------------------------

unpackとpackを制御するためには、“データレイアウト仕様
(data layout specification)”を記述します。これは名前付き
で、かつタイプ付けされた“フィールド(field)”を記述する、
特別なネスト化リストです。これは、処理する各フィールドの
長さ、およびそれをpackおよびunpackする方法を制御します。
わたしたちは、名前が‘-bindat-spec’で終わる変数では、
bindatの仕様を遵守します。この類の変数名は、自動的に
“risky(危険)”だと認識されます。

   フィールドの“タイプ(type)”は、そのフィールドが表すオ
ブジェクトのサイズ(バイト単位)、およびそれがマルチバイト
フィールドなら、そのフィールがバイトオーダーされる方法を
記述します。可能なオーダーは“ビッグエンディアン(big
endian。ネットワークバイトオーダーとも呼ばれる)”、および
“リトルエンディアン(little endian)”の2つです。たとえば数
字‘#x23cd’(10進の9165)のビッグエンディアンは‘#x23’
‘#xcd’の2バイト、リトルエンディアンは‘#xcd’ ‘#x23’になる
でしょう。以下は可能なタイプの値です:

‘u8’
‘byte’
     長さ1の符号なしタイプ。

‘u16’
‘word’
‘short’
     長さ2の、ネットワークバイトオーダーによる符号なし整
     数。

‘u24’
     長さ3の、ネットワークバイトオーダーによる符号なし整
     数。

‘u32’
‘dword’
‘long’
     長さ4の、ネットワークバイトオーダーによる符号なし整
     数。注意: これらの値はEmacsの整数の実装に制限される
     だろう。

‘u16r’
‘u24r’
‘u32r’
     それぞれ長さ2、3、4のリトルエンディアンオーダーによ
     る符号なし整数。

‘str LEN’
     長さLENの文字列。

‘strz LEN’
     長さLENの固定長フィールド内の、NUL終端された文字列
     。

‘vec LEN [TYPE]’
     タイプTYPE(デフォルトはbyte)のLEN要素のベクター。
     TYPEは上述した単純なタイプのいずれか、あるいは‘(vec
     LEN [TYPE])’という形式のリストによる別ベクターの指
     定である。

‘ip’
     インターネット 」アドレスを表す、4つのbyteのベクタ
     ー。たとえばlocalhostは‘[127 0 0 1]’。

‘bits LEN’
     LENバイト内のセットされたビット位置のリスト。バイト
     はビッグエンディアンで、ビット位置は‘8 * LEN − 1’で
     始まり0で終わるよう番号が付与される。たとえば‘bits
     2’では、‘#x28’ ‘#x1c’は‘(2 3 4 11 13)’、‘#x1c’
     ‘#x28’は‘(3 5 10 11 12)’にunpackされる。

‘(eval FORM)’
     FORMは、フィールドがpackまたはunpackされた瞬間に評
     価されるLisp式。評価した結果は、上記にリストしたタ
     イプ使用のいずれかであること。

   固定長フィールドでは長さLENが、フィールド内のバイト数
を指定する整数として与えられます。

   フィールド長が固定でない場合、通常は先行するフィール
ドの値に依存します。この場合、長さLENは後述の
‘bindat-get-field’のフォーマット指定により“フィールド名
(field name)”を指定するリスト‘(NAME ...)’、または式
‘(eval FORM)’(FORMはフィールド長を指定する整数に評価され
ること)のいずれかで与えることもできます。

   フィールド仕様は一般的に‘([NAME] HANDLER)’という形式
をもち、NAMEはオプションです。紛らわしくなるので、タイプ
仕様(上述)やハンドラー仕様(後述)で意味をもつシンボルの名
前は使用しないでください。NAMEはシンボルまたは式‘(eval
FORM)’でもよく、この場合FORMはシンボルに評価される必要が
あります。

   HANDLERはそのフィールドがpackまたはunpackされる方法を
記述し、以下のいずれかを指定できます:

‘TYPE’
     タイプ仕様TYPEに応じてこのフィールドのunpack/packを
     行う。

‘eval FORM’
     副作用のためだけにLisp式FORMを評価する。フィールド
     名が指定された場合、値はそのフィールド名にバインド
     される。

‘fill LEN’
     LENバイトをスキップする。pack化ではそれらを未変更の
     ままとし、通常それらは0のままとなることを意味する。
     unpack化では、それらが無視されることを意味する。

‘align LEN’
     LENバイトの次の倍数にスキップする。

‘struct SPEC-NAME’
     副仕様(sub-specification)としてSPEC-NAMEを処理する
     。これは別の構造体内にネストされる構造体を記述する
     。

‘union FORM (TAG SPEC)...’
     Lisp式FORMを評価して、それにマッチする最初のTAGを探
     し、それに関連付けられたレイアウト仕様SPECを処理す
     る。マッチングは以下の3つのいずれかで発生し得る:

        • TAGが‘(eval EXPR)’という形式をもつ場合、変数
          ‘tag’を動的にFORMの値にバインドして、EXPRを評
          価する。結果が非‘nil’ならマッチを示す。

        • TAGがFORMの値と‘equal’ならマッチ。

        • TAGが‘t’なら無条件にマッチ。

‘repeat COUNT FIELD-SPECS...’
     FIELD-SPECSを順次、再帰的に処理した後、最初のものか
     ら繰り返して、すべての仕様全体をCOUNT回処理する。
     COUNTはフィールド長と同じフォーマットを使用して与え
     られる。‘eval’フォームが使用された場合は、1回だけ評
     価される。正しく処理されるには、FIELD-SPECS内の各仕
     様は名前を含まなければならない。

   bindat仕様内で仕様される‘(eval FORM)’フォームでは、評
価の間にFORMはこれらの動的にバインドされた変数へのアクセ
スと更新が可能である。

‘last’
     最後に処理されたフィールドの値。

‘bindat-raw’
     バイト配列のデータ。

‘bindat-idx’
     unpack化/pack化にたいする、(‘bindat-raw’での)カレン
     トインデックス。

‘struct’
     これまでにunpackされた構造化データ、またはpackされ
     た構造体全体を含むalist。この構造体の特定のフィール
     ドにアクセスするために、‘bindat-get-field’を使用で
     きる。

‘count’
‘index’
     ‘repeat’ブロック内部では、これらは(COUNTパラメータ
     ーで指定された)繰り返しの最大回数、および(0から数え
     た)カレント繰り返し回数を含む。‘count’を0にセットす
     ることにより、カレントの繰り返し終了後に、最内繰り
     返しブロックを終了する。

