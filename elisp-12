This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Echo Area Customization,  Prev: Logging Messages,  Up: The Echo Area

37.4.4 Echo Area Customization
------------------------------

以下の変数は、エコーエリアが機能する方法の詳細を制御します。

 -- Variable: cursor-in-echo-area
     この変数は、エコーエリア内にメッセージ表示時に、カーソルを表示する
     場所を制御する。これが非‘nil’なら、カーソルはメッセージの終端に表示
     される。それ以外なら、カーソルはエコーエリア内ではなく、ポイント位
     置に表示される。

     この値は、通常は‘nil’である。Lispプログラムは短時間の間、これを
     ‘t’にバインドする。

 -- Variable: echo-area-clear-hook
     このノーマルフックは‘(message nil)’、または別の何らかの理由によりエ
     コーエリアが作成されると、常に実行される。

 -- User Option: echo-keystrokes
     この変数は、コマンド文字をエコーする前に、どれだけの時間を待機する
     かを決定する。この値は数字でなければならず、エコー前に待機する秒数
     を指定する。ユーザーが(‘C-x’のような)プレフィックスキーをタイプして
     から、継続してタイプを継続するのをこの秒数遅延した場合、エコーエリ
     ア内にそのプレフィックスキーがエコーされる(あるキーシーケンスで一度
     エコーが開始されると、同一のキーシーケンス内の後続するすべての文字
     は、即座にエコーされる)。

     値が0なら、コマンド入力はエコーされない。

 -- Variable: message-truncate-lines
     通常、長いメッセージの表示により、そのメッセージ全体を表示するため
     に、エコーエリアはリサイズされる。しかし変数
     ‘message-truncate-lines’が非‘nil’なら、エコーエリアをリサイズせず、
     エコーエリアに収まるようメッセージは切り詰められる。

   ミニバッファーウィンドウのリサイズの最大高さを指定する変数
‘max-mini-window-height’は、エコーエリアにも適用される(エコーエリアは真
にミニバッファーウィンドウの特殊な使い方である。*note Minibuffer Misc::を
参照されたい)。


File: elisp,  Node: Warnings,  Next: Invisible Text,  Prev: The Echo Area,  Up: Display

37.5 Reporting Warnings
=======================

“警告(warnings)”とは、プログラムがユーザーにたいして問題の可能性を知らせ
るが、実行は継続するための機能です。

* Menu:

* Warning Basics::           警告の概念と、それらを報告するための関数。
* Warning Variables::        プログラムが警告をカスタマイズするためにバインドする変数。
* Warning Options::          ユーザーが警告の表示を制御するためにセットする変数。
* Delayed Warnings::         コマンド終了まで警告を延期する。


File: elisp,  Node: Warning Basics,  Next: Warning Variables,  Up: Warnings

37.5.1 Warning Basics
---------------------

すべての警告は、ユーザーに問題を説明するためのテキストのメッセージと、
“重大レベル(severity level)”をもっています。重大レベルはシンボルです。以
下は可能性のある重大レベルとその意味を、重大度の降順でリストしたものです
:

‘:emergency’
     直ちに対処しなければ、Emacs処理が間もなく深刻に害される問題。
‘:error’
     本質的に悪いデータまたは状況のリポート。
‘:warning’
     本質的に悪くはないが、可能性のある問題を励起する恐れのあるデータま
     たは状況のリポート。
‘:debug’
     デバッグ中なら有用かもしれない情報のリポート。

   あなたのプログラムが無効な入力データに遭遇した際には、‘error’呼び出し
によるLispエラーのシグナルするか、または重大度‘:error’の警告をリポートす
ることができます。Lispエラーのシグナルはもっとも簡単に行えることですが、
それはプログラムが処理を継続できないことを意味します。間違ったデータでも
処理を継続するための方法を実装するために、そのトラブルを受け取めたい場合
には、その問題をユーザーに知らせるために、重大度‘:error’の警告をリポート
するのが正しい方法です。たとえばEmacs Lispバイトコンパイラーはこの方法に
よりエラーを報告して、他の関数のコンパイルを継続できます(プログラムが
Lispエラーをシグナルして、それを‘condition-case’でhandleしたなら、ユーザ
ーがそのエラーを確認することはないだろう。これは警告としてリポートするこ
とにより、ユーザーにメッセージを示すことができる)。

   クラス分けのために、それぞれの警告には“警告タイプ(warning type)”があ
ります。このタイプはシンボルのリストです。最初のシンボルは、そのプログラ
ムのユーザーオプションとして使用する、カスタムグループであるべきです。た
とえばバイトコンパイラーの警告は、警告タイプ‘(bytecomp)’を使用します。も
し望むなら、このリスト内で更にシンボルを使用することにより、警告をサブカ
テゴリー化することもできます。

 -- Function: display-warning type message &optional level buffer-name
     この関数はメッセージとしてMESSAGE、警告タイプとしてTYPEを使用して、
     警告をリポートする。LEVELは重大レベルであること。デフォルトは
     ‘:warning’。

     BUFFER-NAMEが非‘nil’なら、それは警告をロギングするためのバッファー
     名を指定する。デフォルトは‘*Warnings*’。

 -- Function: lwarn type level message &rest args
     この関数は、‘*Warnings*’バッファー内のメッセージとして‘(format
     MESSAGE ARGS...)’の値を使用して、、警告をリポートする。他の点では、
     これは‘display-warning’と同じである。

 -- Function: warn message &rest args
     この関数はメッセージとして‘(format MESSAGE ARGS...)’の値、タイプと
     して‘(emacs)’、重大レベルとして‘:warning’を使用して、警告をリポート
     する。これは互換性のためだけに存在する。固有な警告タイプを指定する
     べきであり、この関数の使用は推奨しない。


File: elisp,  Node: Warning Variables,  Next: Warning Options,  Prev: Warning Basics,  Up: Warnings

37.5.2 Warning Variables
------------------------

プログラムは、このセクション内で説明する変数をバインドすることにより、警
告が表示される方法をカスタマイズできます。

 -- Variable: warning-levels
     このリストは、警告の重大レベルの意味と、重大度の順序を定義する。そ
     れぞれの要素は1つの重大レベルを定義し、それらは重大度の降順で配置さ
     れる。

     各要素は‘(LEVEL STRING FUNCTION)’という形式をもち、LEVELはその要素
     が定義する重大レベルである。STRINGはそのレベルのテキストによる説明
     である。STRINGは警告タイプ情報の配置箇所の指定に‘%s’を使用するか、
     さもなくばその情報を含まぬよう‘%s’を省略できる。

     オプションのFUNCTIONが非‘nil’なら、これはユーザーの注目を得るために
     引数なしで呼び出される関数であること。

     通常は、この変数の値を変更するべきではない。

 -- Variable: warning-prefix-function
     値が非‘nil’なら、それは警告用にプレフィックスを生成する関数であるこ
     と。プログラムは、この変数を適切な関数にバインドできる。
     ‘display-warning’はwarningsバッファーがカレントの状態でこの関数を呼
     び出し、関数はそのバッファーにテキストを挿入できる。そのテキストが
     、警告メッセージの先頭になる。

     この関数は重大レベル、および‘warning-levels’内でのその重大レベルの
     エントリーという、2つの引数で呼び出される。これは、エントリーとして
     使用するためのリストをリターンするべきである(この値は
     ‘warning-levels’の実際のメンバーである必要はない)。この値を構築する
     ことにより、関数はその警告の重大レベルを変更したり、与えられた重大
     レベルにたいして異なる処理を指定することができる。

     この変数の値が‘nil’なら、呼び出される関数は存在しない。

 -- Variable: warning-series
     プログラムは、次の警告がシリーズの開始であることを告げるために、こ
     の変数を‘t’にバインドできる。複数の警告がシリーズを形成するというこ
     とは、それぞれの警告にたいしてポイントが維持されるよう移動して、最
     後の警告にポイントが表示されるのではなく、そのシリーズの最初の警告
     にポイントを残すことを意味する。このシリーズは、そのローカルバイン
     ドが非バインドされて、‘warning-series’が再び‘nil’になったときに終了
     する。

     この値は、関数定義をもつシンボルでもよい。これは、次の警告により
     warningsバッファーがカレントの状態で、引数なしでその関数が呼び出さ
     れることを除き、‘t’と等価である。この関数は、その警告シリーズのヘッ
     ダーの役目をもつであろうテキストを挿入できる。

     あるシリーズが開始されると、その値はwarningsバッファー内でシリーズ
     開始となるバッファー位置を指すマーカーとなる。

     この変数の通常の値は‘nil’で、これはそれぞれの警告を個別に処理するこ
     とを意味する。

 -- Variable: warning-fill-prefix
     この変数が非‘nil’なら、それは各警告テキストのフィルに使用する、フィ
     ルプレフィックスを指定する。

 -- Variable: warning-type-format
     この変数は、警告メッセージ内の警告タイプを表示するための、フォーマ
     ットを指定する。この方法でフォーマットされたタイプは、
     ‘warning-levels’内のエントリー内の文字列制御下にあるメッセージに含
     まれることになる。デフォルト値は‘" (%s)"’。これを‘""’にバインドする
     と、警告タイプはまったく表示されなくなる。


File: elisp,  Node: Warning Options,  Next: Delayed Warnings,  Prev: Warning Variables,  Up: Warnings

37.5.3 Warning Options
----------------------

以下の変数は、何が発生したときにLispプログラムが警告をリポートするかを、
ユーザーが制御するために使用されます。

 -- User Option: warning-minimum-level
     このユーザーオプションは、ユーザーにたいして即座に表示されるべき、
     最小の重大レベルを指定する。デフォルトは‘:warning’で、これは
     ‘:debug’警告を除くすべての警告が即座に表示されることを意味する。

 -- User Option: warning-minimum-log-level
     このユーザーオプションは、warningsバッファー内にログされるべき、最
     小の重大レベルを指定する。デフォルトは‘:warning’で、これは
     ‘:debug’警告を除くすべての警告がログされることを意味する。

 -- User Option: warning-suppress-types
     このリストは、ユーザーにたいしてどの警告タイプを即座に表示するべき
     ではないかを指定する。このリスト内の各要素は、シンボルのリストであ
     ること。それの要素が警告タイプ内の最初の要素にマッチしたら、その警
     告は即座に表示されない。

 -- User Option: warning-suppress-log-types
     このリストは、ユーザーにたいしてどの警告タイプがwarningsバッファー
     にログされるべきではないかを指定する。このリスト内の各要素は、シン
     ボルのリストであること。それの要素が警告タイプ内の最初の数要素にマ
     ッチしたら、その警告はログされない。


File: elisp,  Node: Delayed Warnings,  Prev: Warning Options,  Up: Warnings

37.5.4 Delayed Warnings
-----------------------

コマンド実行中には警告の表示を避けて、コマンドの終わりでのみ警告を表示し
たいことがあるかもしれません。これは、変数‘delayed-warnings-list’により
行うことができます。

 -- Variable: delayed-warnings-list
     この変数の値は、カレントのコマンド完了後に表示される警告のリストで
     ある。各要素は以下のようなリストでなければならない:

          (TYPE MESSAGE [LEVEL [BUFFER-NAME]])

     これらは、は‘display-warning’の引数リストと同じ形式、同じ意味である
     (*note Warning Basics::を参照)。‘post-command-hook’(*note Command
     Overview::を参照)の実行直後、Emacsのコマンドループはこの変数で指定
     されたすべての警告を表示してから、変数を‘nil’にリセットする。

   遅延警告メカニズムをよりカスタマイズする必要があるプログラムは、変数
‘delayed-warnings-hook’を変更することができます:

 -- Variable: delayed-warnings-hook
     これは遅延警告を処理して表示するために、‘post-command-hook’の後に
     Emacsコマンドループが実行する、ノーマルフックである。

     デフォルト値は、2つの関数からなるリストである:

          (collapse-delayed-warnings display-delayed-warnings)

     関数‘collapse-delayed-warnings’は、‘delayed-warnings-list’から重複
     するエントリーを削除する。関数‘display-delayed-warnings’は、
     ‘delayed-warnings-list’内の各要素にたいして順次‘display-warning’を
     呼び出してから、‘delayed-warnings-list’を‘nil’にセットする。


File: elisp,  Node: Invisible Text,  Next: Selective Display,  Prev: Warnings,  Up: Display

37.6 Invisible Text
===================

‘invisible’プロパティにより、スクリーン上に表示されないように、文字を“不
可視(invisible)”にすることができます。これはテキストプロパティ(*note
Text Properties::を参照)、またはオーバーレイプロパティ(*note Overlays::を
参照)のいずれかで行うことができます。カーソル移動も、これらの文字を部分
的に無視します。あるコマンドの後に、不可視テキスト範囲内にポイントがある
ことをコマンドループが検知した場合、コマンドループはポイントをそのテキス
トの別サイドへ再配置します。

   もっともシンプルなケースでは、非‘nil’の‘invisible’プロパティにより、
文字は不可視になります。これがデフォルトのケースであり、もし
‘buffer-invisibility-spec’のデフォルト値を変更したくない場合は、これが
‘invisible’プロパティを機能させる方法です。自身で
‘buffer-invisibility-spec’をセットする予定がなければ、‘invisible’プロパ
ティの値として、通常は‘t’を使用するべきです。

   より一般的には、どの‘invisible’の値がテキストを不可視にするかを制御す
るために、変数‘buffer-invisibility-spec’を使用できます。テキストにたいし
て異なる‘invisible’の値を与えることにより、事前に別のサブセットへテキス
トをクラス分けした後に、‘buffer-invisibility-spec’の値を変更して、さまざ
まなサブセットを可視または不可視にすることができます。

   特にデータベース内のエントリーのリストを表示するプログラム内では、
‘buffer-invisibility-spec’による可視性の制御は有用です。これにより、デー
タベース内の一部だけを閲覧するフィルターコマンドを、簡便に実装することが
可能になります。この変数をセットするのは非常に高速で、バッファー内のすべ
てのテキストにたいしてプロパティが変更されたかスキャンするより、はるかに
高速です。

 -- Variable: buffer-invisibility-spec
     この変数は、どの種類の‘invisible’プロパティが、実際に文字を不可視に
     するかを指定する。この変数はセットすることにより、バッファーローカ
     ルになる。

     ‘t’
          ‘invisible’プロパティが非‘nil’なら、その文字は不可視になる。こ
          れがデフォルトである。

     リスト
          このリスト内の各要素は、不可視性の条件を指定する。ある文字の
          ‘invisible’プロパティがこれらの条件のいずれかに適合したら、そ
          の文字は不可視になる。このリストは2種類の要素をもつことができ
          る:

          ‘ATOM’
               ‘invisible’プロパティの値がATOM、またはATOMをメンバーにも
               つリストなら、その文字は不可視になる。比較は‘eq’により行
               われる。

          ‘(ATOM . t)’
               ‘invisible’プロパティの値がATOM、またはATOMをメンバーにも
               つリストなら、その文字は不可視になる。比較は‘eq’により行
               われる。さらに、そのような文字シーケンスは省略記号
               (ellipsis)として表示される。

   特に‘buffer-invisibility-spec’への要素の追加と削除のために、2つの関数
が提供されています。

 -- Function: add-to-invisibility-spec element
     この関数は、‘buffer-invisibility-spec’に要素ELEMENTを追加する。
     ‘buffer-invisibility-spec’が‘t’なら、これはリスト‘(t)’に変更され、
     ‘invisible’プロパティが‘t’のテキストは不可視のまま留まる。

 -- Function: remove-from-invisibility-spec element
     この関数は、‘buffer-invisibility-spec’から要素ELEMENTを削除する。リ
     スト内にELEMENTがなければ、何も行わない。

   ‘buffer-invisibility-spec’を使用するための規約として、メジャーモード
は‘buffer-invisibility-spec’の要素、および‘invisible’プロパティの値とし
て、自身のモード名を使用することになっている。

     ;; 省略記号を表示したければ:
     (add-to-invisibility-spec '(my-symbol . t))
     ;; 表示したくなければ:
     (add-to-invisibility-spec 'my-symbol)

     (overlay-put (make-overlay beginning end)
                  'invisible 'my-symbol)

     ;; 不可視状態が終わったら:
     (remove-from-invisibility-spec '(my-symbol . t))
     ;; または各々を:
     (remove-from-invisibility-spec 'my-symbol)

   以下の関数を使用することにより、不可視性をチェックできます:

 -- Function: invisible-p pos-or-prop
     POS-OR-PROPがマーカーか数字の場合、その位置のテキストが不可視なら、
     この関数は非‘nil’をリターンする。

     POS-OR-PROPが別の類のLispオブジェクトなら、テキストプロパティまたは
     オーバーレイプロパティとして可能な値を意味すると解釈される。この場
     合、‘buffer-invisibility-spec’のカレント値にもとづき、もしその値が
     テキストを不可視とするようなら、この関数は非‘nil’をリターンする。

   通常、テキストを操作したりポイントを移動する関数は、そのテキストが不
可視かどうかに注意を払わず、可視および不可視のテキストを同様に処理します
。‘next-line’や‘previous-line’のようなユーザーレベルの行移動関数は、
‘line-move-ignore-invisible’が非‘nil’(デフォルト)なら、不可視な改行を無
視します。これらの関数は不可視な改行がそのバッファーに存在しないかのよう
に振る舞いますが、これはそう振る舞うよう、明示的にプログラムされているか
らです。

   あるコマンドが、不可視テキストの境界内側のポイントで終了した場合、メ
イン編集ループはその不可視テキストの両端のうちのいずれかにポイントを再配
置します。そのコマンドの移動関数の全体的な方向と同じになるように、
Emacsが再配置の方向は決定します。これに疑問がある場合には、挿入された文
字が‘invisible’プロパティを継承しないような位置を優先してください。加え
て、そのテキストが省略記号で置換されず、コマンドが不可視テキスト内への移
動のみを行う場合、ポイントを1文字余計に移動して、目に見えるようカーソル
を移動することにより、そのコマンドの移動を反映するよう試みます。

   したがって,コマンドが(通常のstickinessをもつ)不可視範囲に、後方へとポ
イントを移動した場合、Emacsはポイントをその範囲の先頭へと、後方に移動し
ます。コマンドが不可視範囲へ前方にポイントを移動した場合には、Emacsは不
可視テキストの前にある最初の可視文字へと、前方にポイントを移動して、その
後さらに前方へ1文字余計に移動します。

   これら不可視テキスト中間で終了するポイントにたいするこれらの“調整
(adjustments)”は、‘disable-point-adjustment’を非‘nil’にセットすることに
より無効にできます。*note Adjusting Point::を参照してください。

   インクリメンタル検索はマッチが不可視テキストを含む場合は、一時的およ
び/または永続的に不可視オーバーレイを可視にすることができます。これを有
効にするためには、そのオーバーレイが非‘nil’の‘isearch-open-invisible’プ
ロパティをもつ必要があります。プロパティの値は、そのオーバーレイを引数と
して呼び出される関数であるべきです。その関数は、オーバーレイを永続的に可
視にする必要があります。これは検索からのexit時にマッチがそのオーバーレイ
に重なるときに使用されます。

   検索の間、そのようなオーバーレイのinvisible、およびintangibleプロパテ
ィを一時的に変更することにより、オーバーレイは一時的に可視にされます。特
定のオーバーレイにたいして、異なる方法でこれを行いたいなら、それを
‘isearch-open-invisible-temporary’プロパティ(関数)に与えてください。その
関数は2つの引数により呼び出されます。1つ目はそのオーバーレイ、2つ目は
‘nil’ならオーバーレイを可視に、‘t’なら再び不可視にします。


File: elisp,  Node: Selective Display,  Next: Temporary Displays,  Prev: Invisible Text,  Up: Display

37.7 Selective Display
======================

“選択的表示(selective display)”とは、スクリーン上で特定の行を隠蔽する、
関連する機能ペアーを指します。

   1つ目の変種は明示的な選択的表示で、これはLispプログラム内で使用するよ
うにデザインされています。これはテキスト変更により、どの行を隠すかを制御
します。この種の隠蔽は現在では時代遅れです。かわりに‘invisible’プロパテ
ィで同じ効果を得ることができます(*note Invisible Text::を参照)。

   2つ目の変種は、インデントにもとづいて隠す行の選択を自動的に行います。
この変種は、ユーザーレベルの機能としてデザインされています。

   選択的表示を明示的に制御する方法では、改行(control-j)を復帰
(control-m)に置換します。以前は行末に改行があった行は、これにより隠蔽さ
れます。厳密に言うと、改行だけが行を分離できるので、これはもはや一時的に
は行ではなく、前の行の一部です。

   選択的表示は編集コマンドに直接影響を与えません。たとえば
‘C-f’(‘forward-char’)は、隠蔽された行へ気軽にポイントを移動します。しか
し復帰文字による改行文字の置換は、いくつかの編集コマンドに影響を与えます
。たとえば‘next-line’は改行だけを検索するため、隠蔽された行をスキップし
ます。選択的表示を使用するモードは、改行を考慮するコマンドを定義したり、
テキストのどの部分を隠すか制御することもできます。

   選択的表示されたバッファーをファイルに書き込む際には、control-mはすべ
て改行として出力されます。これはファイル内のテキストを読み取る際には、す
べて問題なく隠蔽されずに表示されることを意味します。選択的表示は、
Emacs内でだけ見られる効果です。

 -- Variable: selective-display
     このバッファーローカル変数は、選択的表示を有効にする。これは行、ま
     たは行の一部を隠すことができることを意味する。

        • ‘selective-display’の値が‘t’なら、文字control-mが隠蔽されたテ
          キストの開始をマークする。control-mと、それに後続する行の残り
          は表示されない。これは明示的な選択的表示である。

        • ‘selective-display’の値が正の整数なら、それより多くの列による
          インデントで始まる行は表示されない。

     バッファーの一部が隠蔽されている際は、垂直移動コマンドはあたかもそ
     の部分を存在しないかのように処理して、1回の‘next-line’コマンドで任
     意の行数の隠蔽された行をスキップできる。しかし(‘forward-char’のよう
     な)文字移動コマンドは隠蔽された部分をスキップせず、(注意すれば)隠蔽
     された部分にたいしてテキストの挿入と削除が可能である。

     以下の例では、‘selective-display’の値の変更による、バッファー
     ‘foo’の_外観表示_を示す。このバッファーの_コンテンツ_は変更されない
     。

          (setq selective-display nil)
               ⇒ nil

          ---------- Buffer: foo ----------
          1 on this column
           2on this column
            3n this column
            3n this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

          (setq selective-display 2)
               ⇒ 2

          ---------- Buffer: foo ----------
          1 on this column
           2on this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

 -- User Option: selective-display-ellipses
     このバッファーローカル変数が非‘nil’なら、Emacsは隠蔽されたテキスト
     を後にともなう行の終端に、‘...’を表示する。この例は、前の例からの継
     続である。

          (setq selective-display-ellipses t)
               ⇒ t

          ---------- Buffer: foo ----------
          1 on this column
           2on this column ...
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

     省略記号(‘...’)にたいして他のテキストを代替えするために、ディスプレ
     イテーブルを使用できる。*note Display Tables::を参照のこと。


File: elisp,  Node: Temporary Displays,  Next: Overlays,  Prev: Selective Display,  Up: Display

37.8 Temporary Displays
=======================

一時的表示(temporary display)は、出力をバッファーに配して、それを編集用
ではなく閲覧用としてユーザーに示すために、Lispプログラムにより使用されま
す。多くのヘルプコマンドは、この機能を使用します。

 -- Macro: with-output-to-temp-buffer buffer-name body...
     この関数は、BUFFER-NAMEという名前のバッファー(必要なら最初に作成さ
     れる)にプリントされた任意の出力が挿入されるようアレンジ、さらにバッ
     ファーをHelpモードにして、BODY内のフォームを実行する(類似する以下の
     フォーム‘with-temp-buffer-window’を参照されたい)。最後に、そのバッ
     ファーはいずれかのウィンドウに表示されるが、そのウィンドウは選択さ
     れない。

     BODY内のフォームが出力バッファーのメジャーモードを変更しないため、
     実行の最後においても依然としてHelpモードにあるなら、
     ‘with-output-to-temp-buffer’は最後にそのバッファーを読み取り専用す
     るとともに、クリック可能なクロスリファレンスとなるよう、関数名と変
     数名のスキャンも行う。特にドキュメント文字列内のハイパーリンク上ア
     イテムに関する詳細は、*note Tips for Documentation Strings:
     Docstring hyperlinks.を参照のこと。

     文字列BUFFER-NAMEは一時的なバッファーを指定し、これはあらかじめ存在
     する必要はない。引数はバッファーではなく文字列でなければならない。
     そのバッファーは最初に消去され(確認なし)、
     ‘with-output-to-temp-buffer’のexit後は未変更(unmodified)とマークさ
     れる。

     ‘with-output-to-temp-buffer’は‘standard-output’を一時的バッファーに
     バインドして、BODY内のフォームを評価する。BODY内のLisp出力関数を使
     用した出力のデフォルト出力先は、そのバッファーになる(しかしスクリー
     ン表示、エコーエリア内のメッセージは、一般的な世界の感覚では“出力
     ”であるものの、影響は受けない)。*note Output Functions::を参照のこ
     と。

     この構成の振る舞いをカスタマイズするために利用できるフックがいくつ
     かあり、それらは以下にリストしてある。

     リターン値は、BODY内の最後のフォームの値である。

          ---------- Buffer: foo ----------
           This is the contents of foo.
          ---------- Buffer: foo ----------

          (with-output-to-temp-buffer "foo"
              (print 20)
              (print standard-output))
          ⇒ #<buffer foo>

          ---------- Buffer: foo ----------

          20

          #<buffer foo>

          ---------- Buffer: foo ----------

 -- User Option: temp-buffer-show-function
     この変数が非‘nil’なら、‘with-output-to-temp-buffer’はヘルプバッファ
     ーを表示する処理を行うために、その関数を呼び出す。この関数は、表示
     すべきバッファーという、1つの引数を受け取る。

     ‘with-output-to-temp-buffer’が通常行うように、
     ‘save-selected-window’内部や選択されたウィンドウ内で、バッファーか
     選択された状態で、‘temp-buffer-show-hook’を実行するのは、この関数に
     とってよいアイデアである。

 -- Variable: temp-buffer-setup-hook
     このノーマルフックは、BODYを評価する前に、
     ‘with-output-to-temp-buffer’により実行される。フック実行時は、一時
     的バッファーがカレントになる。このフックは通常、そのバッファーを
     Helpモードにするための関数にセットアップされる。

 -- Variable: temp-buffer-show-hook
     このノーマルフックは、一時的バッファー表示後に、
     ‘with-output-to-temp-buffer’により実行される。フック実行時は一時的
     バッファーがカレントになり、それが表示されているウィンドウが選択さ
     れる。

 -- Macro: with-temp-buffer-window buffer-or-name action quit-function
          body...
     このマクロは‘with-output-to-temp-buffer’と類似している。
     ‘with-output-to-temp-buffer’構成同様、これはプリントされる任意の出
     力がBUFFER-OR-NAMEという名前のバッファーに挿入されるようにアレンジ
     してBODYを実行し、そのバッファーをいぜれかのウィンドウに表示する。
     しかし‘with-output-to-temp-buffer’とは異なり、このマクロはそのバッ
     ファーを自動的にHelpモードに切り替えない。

     ‘with-output-to-temp-buffer’と同様、これはBUFFER-OR-NAMEで指定され
     るバッファーを、BODY実行時カレントにしない。 BODYを実行するために、
     そのバッファーをカレントにする点以外は等価なマクロ
     ‘with-current-buffer-window’を使用できる。

     引数BUFFER-OR-NAMEは、一時的バッファーを指定する。これはバッファー
     (既存でなければならない)、または文字列を指定でき、文字列の場合は必
     要ならその名前のバッファーが作成される。そのバッファーは
     ‘with-temp-buffer-window’のexit時、未変更かる読み取り専用とマークさ
     れる。

     このマクロは‘temp-buffer-show-function’を呼び出さない。かわりにその
     バッファーを表示するために、ACTION引数を‘display-buffer’に渡す。

     引数QUIT-FUNCTIONが指定されていなければ、BODY内の最後のフォームの値
     がリターンされる。指定されている場合、それはそのバッファーを表示す
     るウィンドウと、BODYの結果という、2つの引数で呼び出される。その場合
     、最終的なリターン値は何であれQUIT-FUNCTIONがリターンした値となる。

     このマクロは、‘with-output-to-temp-buffer’により実行される類似フッ
     クのかわりに、ノーマルフック‘temp-buffer-window-setup-hook’と
     ‘temp-buffer-window-show-hook’使用する。

 -- Function: momentary-string-display string position &optional char
          message
     この関数は、カレントバッファー内のPOSITIONに、STRINGを瞬間表示
     (momentarily display)する。これはundoリストや、そのバッファーの変更
     状態(modification status)に影響を与えない。

     瞬間表示は、次の入力イベントまで留まる。次の入力イベントがCHARなら
     、‘momentary-string-display’はそれを無視してリターンする。それ以外
     なら、そのイベントは後続の入力として使用するためにバッファーされる
     。つまりCHARとタイプすると、表示からその文字列を単に削除して、
     CHARではない(たとえば)‘C-f’とタイプすると表示からその文字列を削除し
     て、後で(おそらく)ポイントを前方へ移動するだろう。引数CHARのデフォ
     ルトはスペース。

     ‘momentary-string-display’のリターン値に意味はない。

     文字列STRINGがコントロール文字を含まなければ、‘before-string’プロパ
     ティでオーバーレイを作成(してその後削除)することで、より一般的に同
     じことを行うことができる。*note Overlay Properties::を参照のこと。

     MESSAGEgが非‘nil’なら、バッファー内にSTRINGが表示されている間は、エ
     コーエリアにそれが表示される。‘nil’ならデフォルトは、継続するために
     はCHARをタイプするよう告げるメッセージである。

     以下の例ではポイントは最初、2行目の先頭に置かれている:

          ---------- Buffer: foo ----------
          This is the contents of foo.
          ★Second line.
          ---------- Buffer: foo ----------

          (momentary-string-display
            "**** Important Message! ****"
            (point) ?\r
            "Type RET when done reading")
          ⇒ t

          ---------- Buffer: foo ----------
          This is the contents of foo.
          **** Important Message! ****Second line.
          ---------- Buffer: foo ----------

          ---------- Echo Area ----------
          Type RET when done reading
          ---------- Echo Area ----------


File: elisp,  Node: Overlays,  Next: Size of Displayed Text,  Prev: Temporary Displays,  Up: Display

37.9 Overlays
=============

プレゼンテーション機能として、バッファーのテキストのスクリーン上の見栄え
を変更するために、“オーバーレイ(overlay)”を使用できます。オーバーレイと
は、個々のバッファーに属するオブジェクトであり、指定された開始と終了をも
っています。確認したりセットすることができるプロパティももっています。そ
れらはオーバーレイをもつテキストの表示に影響を与えます。

   オーバーレイの視覚的効果は、対応するテキストプロパティと同様です
(*note Text Properties::を参照)。しかし実装が異なるため、オーバーレイは
一般的にスケーラブルではありません(処理数に応じて、バッファー内のオーバ
ーレイ数に比例した時間を要する)。バッファー内の多数の部分の視覚的外観に
効果を及ぼす必要がある場合は、テキストプロパティの使用を推奨します。

   オーバーレイは、その開始と終了を記録するために、マーカーを使用します
。したがってバッファーのテキスト編集では、すべてのオーバーレイがそのテキ
ストに留まるように、開始と終了が調整されます。オーバーレイ作成時には、オ
ーバーレイ先頭、同様に終端にテキストが挿入された場合に、それがオーバーレ
イの内側あるいは外側であるべきかを指定できます。

* Menu:

* Managing Overlays::        オーバーレイの作成と変更。
* Overlay Properties::       プロパティ読み取りおよびセットの方法。どのプロパティがスクリーン表示に何を行うか。
* Finding Overlays::         オーバーレイにたいする検索。


File: elisp,  Node: Managing Overlays,  Next: Overlay Properties,  Up: Overlays

37.9.1 Managing Overlays
------------------------

このセクションでは、オーバーレイの作成、削除、移動、およびそれらのコンテ
ンツを調べる関数を説明します。オーバーレイはバッファーのコンテンツの一部
ではないので、その変更はバッファーのundoリストに記録されません。

 -- Function: overlayp object
     この関数は、OBJECTがオーバーレイなら‘t’をリターンする。

 -- Function: make-overlay start end &optional buffer front-advance
          rear-advance
     この関数はBUFFERに属し、STARTからENDの範囲のオーバーレイを作成して
     リターンする。STARTとENDはいずれもバッファーの位置を指定しなければ
     ならず、整数またはマーカーを指定できる。BUFFERが省略された場合、そ
     のオーバーレイはカレントバッファーに作成される。

     引数FRONT-ADVANCEとREAR-ADVANCEはそれぞれ、オーバーレイの開始と終了
     にたいするマーカーの挿入タイプを指定する。*note Marker Insertion
     Types::を参照のこと。どちらも‘nil’(デフォルト)なら、そのオーバーレ
     イは先頭に挿入された任意のテキストを含むように拡張されるが、終端に
     挿入されたテキストにたいしては拡張されない。FRONT-ADVANCEが非
     ‘nil’なら、オーバーレイの先頭に挿入されたテキストは、オーバーレイか
     ら除外される。REAR-ADVANCEが非‘nil’なら、オーバーレイの終端に挿入さ
     れたテキストは、オーバーレイに含まれる。

 -- Function: overlay-start overlay
     この関数は、OVERLAYが開始する位置を整数でリターンする。

 -- Function: overlay-end overlay
     この関数は、OVERLAYが終了する位置を整数でリターンする。

 -- Function: overlay-buffer overlay
     この関数は、OVERLAYが所属するバッファーをリターンする。OVERLAYが削
     除されていれば‘nil’をリターンする。

 -- Function: delete-overlay overlay
     この関数はOVERLAYを削除する。そのオーバーレイはLispオブジェクトとし
     て存在し続け、そのプロパティリストは変更されないが、バッファーへの
     所属と表示にたいするすべての効果は失う。

     削除済みオーバーレイが、永続的に非接続という訳ではない。
     ‘move-overlay’を呼び出すことにより、バッファー内の位置を与えること
     ができる。

 -- Function: move-overlay overlay start end &optional buffer
     この関数はOVERLAYをBUFFERに移動して、その境界をSTARTとENDに配する。
     STARTとENDの引数はいずれもバッファーの位置を指定しなければならず、
     整数またはマーカーを指定できる。

     BUFFERが省略された場合、OVERLAYはすでに関連付けられている同じバッフ
     ァーに留まる。さらにOVERLAYが削除されていたら、それをカレントバッフ
     ァーに所属させる。

     リターン値はOVERLAY。

     これはオーバーレイの両端位置を変更する、唯一有効な方法である。手作
     業でオーバーレイ内のマーカーの変更を試みてはならない。それにより他
     の重要なデータ構造の更新が失敗して、いくつかのオーバーレイが“失われ
     る”可能性がある。

 -- Function: remove-overlays &optional start end name value
     この関数は、プロパティNAMEが値VALUEをもつ、STARTとENDの間のすべての
     オーバーレイを削除する。これによりオーバーレイの両端位置が変更され
     たり、分割される可能がある。

     NAMEが省略または‘nil’なら、それは指定されたリージョン内のすべてのオ
     ーバーレイを削除することを意味する。STARTおよび/またはENDが省略また
     は‘nil’なら、それぞれバッファーの先頭と終端を意味する。したがって
     ‘(remove-overlays)’は、カレントバッファー内のすべてのオーバーレイを
     削除する。

 -- Function: copy-overlay overlay
     この関数はOVERLAYのコピーをリターンする。このコピーはOVERLAYと同じ
     両端位置とプロパティをもつ。しかしオーバーレイの開始と終了にたいす
     るマーカー挿入タイプは、デフォルト値にセットされる(*note Marker
     Insertion Types::を参照)。

   以下にいくつか例を示します:

     ;; オーバーレイの作成
     (setq foo (make-overlay 1 10))
          ⇒ #<overlay from 1 to 10 in display.texi>
     (overlay-start foo)
          ⇒ 1
     (overlay-end foo)
          ⇒ 10
     (overlay-buffer foo)
          ⇒ #<buffer display.texi>
     ;; 後でチェックできるようプロパティ付与
     (overlay-put foo 'happy t)
          ⇒ t
     ;; プロパティが付与されたか検証
     (overlay-get foo 'happy)
          ⇒ t
     ;; オーバーレイを移動
     (move-overlay foo 5 20)
          ⇒ #<overlay from 5 to 20 in display.texi>
     (overlay-start foo)
          ⇒ 5
     (overlay-end foo)
          ⇒ 20
     ;; オーバーレイを削除
     (delete-overlay foo)
          ⇒ nil
     ;; 削除されたか検証
     foo
          ⇒ #<overlay in no buffer>
     ;; 削除済みオーバーレイは位置をもたない
     (overlay-start foo)
          ⇒ nil
     (overlay-end foo)
          ⇒ nil
     (overlay-buffer foo)
          ⇒ nil
     ;; オーバーレイの削除取り消し
     (move-overlay foo 1 20)
          ⇒ #<overlay from 1 to 20 in display.texi>
     ;; 結果の検証
     (overlay-start foo)
          ⇒ 1
     (overlay-end foo)
          ⇒ 20
     (overlay-buffer foo)
          ⇒ #<buffer display.texi>
     ;; オーバーレイの移動と削除では、オーバーレイのプロパティは変更されない
     (overlay-get foo 'happy)
          ⇒ t

   Emacsはそれぞれのバッファーのオーバーレイを、任意の“中心位置(center
position)”で分割される、2つのリストに格納します。一方のリストはバッファ
ーの中心位置から後方へ拡張され、もう一方は中心位置から前方へと拡張されま
す。中心位置は、バッファーの任意の位置をとることができます。

 -- Function: overlay-recenter pos
     この関数は、カレントバッファーのオーバーレイを、位置POSの周辺に再セ
     ンタリングする。これにより位置POS近傍のオーバーレイの照合は高速にな
     るが、POSから離れた位置にたいしては低速になる。

   バッファーを前方にスキャンしてオーバーレイを作成するループは、最初に
‘(overlay-recenter (point-max))’を行うことにより高速になる可能性がありま
す。


File: elisp,  Node: Overlay Properties,  Next: Finding Overlays,  Prev: Managing Overlays,  Up: Overlays

37.9.2 Overlay Properties
-------------------------

オーバーレイプロパティは、文字が表示される方法をどちらのソースからも取得
できるという点において、テキストプロパティと似ています。しかしほとんどの
観点で、両者は異なります。これらの比較は*note Text Properties::を参照し
てください。

   テキストプロパティは、そのテキストの一部として考えることができます。
オーバーレイとそのプロパティは、特にテキストの一部としてはみなされません
。したがって、さまざまなバッファーや文字列の間でテキストをコピーすると、
テキストプロパティは保持されますが、オーバーレイを保持しようとは試みませ
ん。バッファーのテキストプロパティの変更は、そのバッファーを変更済みとマ
ークしますが、オーバーレイの移動やプロパティの変更は違います。テキストプ
ロパティの変更とは異なり、オーバーレイプロパティの変更は、バッファーの
undoリストに記録されません。

   複数のオーバーレイが同じ文字にたいしてプロパティ値を指定できるので、
Emacsは各オーバーレイにたいして優先度の指定を促します。2つのオーバーレイ
が同じ値の優先度をもち、一方が他方にネストされている場合には、内側のオー
バーレイが外側のオーバーレイより高い優先度をもちます。いずれのオーバーレ
イも他方をネストしない場合には、どちらのオーバーレイが優先されるかについ
て予測するべきではありません。

   以下の関数は、オーバーレイのプロパティの読み取りとセットを行います:

 -- Function: overlay-get overlay prop
     この関数は、OVERLAY内に記録されたプロパティPROPの値をリターンする。
     そのプロパティにたいしてOVERLAYが何も値を記録していないが、シンボル
     であるような‘category’プロパティをもつ場合は、そのシンボルのPROPプ
     ロパティが使用される。それ以外なら値は‘nil’。

 -- Function: overlay-put overlay prop value
     この関数は、OVERLAY内に記録されたプロパティPROPの値に、VALUEをセッ
     トする。リターン値はVALUE。

 -- Function: overlay-properties overlay
     これは、OVERLAYのプロパティリストのコピーをリターンする。

   与えられた文字にたいしてテキストプロパティとオーバーレイプロパティの
両方をチェックする関数‘get-char-property’も参照してください。*note
Examining Properties::を参照してください。

   多くのオーバーレイプロパティには特別な意味があります。以下はそれらの
テーブルです:

‘priority’
     このプロパティの値は、そのオーバーレイの優先度を決定する。優先度に
     たいして値を指定したければ、‘nil’(か0)、または正の整数を使用するこ
     と。それ以外のすべての値にたいして、動作は未定義である。

     2つ以上のオーバーレイが同じ文字をカバーし、いずれもが同じプロパティ
     を指定する場合には、優先度が重要になる。他より‘priority’の値が大き
     いほうが他をオーバーライドする。‘face’プロパティにたいしては、より
     高い優先度のオーバーレイの値は、他の値を完全にはオーバーライドしな
     い。かわりにより低い優先度の‘face’プロパティのface属性を、高い優先
     度のface属性がオーバーライドする。

     現在のところ、すべてのオーバーレイはテキストプロパティより優先され
     る。

     Emacsは内部的なオーバーレイのいくつかにたいして、非数値の優先度を使
     用することがあるので、(自分が作成したオーバーレイでない場合は)オー
     バーレイ優先度の算術演算を試みないよう注意すること。オーバーレイを
     優先度順に配す必要があるなら、‘overlays-at’のSORTED引数を使用するこ
     と。*note Finding Overlays::を参照されたい。

‘window’
     ‘window’プロパティが非‘nil’なら、そのオーバーレイはそのウィンドウだ
     けに適用される。

‘category’
     オーバーレイが‘category’プロパティをもつなら、それをそのオーバーレ
     イの“カテゴリー(category)”と呼ぶ。これはシンボルであること。そのシ
     ンボルのプロパティは、そのオーバーレイのプロパティにたいしてデフォ
     ルトの役割を果たす。

‘face’
     このプロパティはテキストの外観を制御する(*note Faces::を参照)。プロ
     パティの値は以下のいずれか:

        • フェイス名(シンボルか文字列)。

        • anonymousフェイス: ‘(KEYWORD VALUE ...)’という形式のプロパティ
          リストで、KEYWORDはフェイス属性名、VALUEはその属性の値。

        • フェイスのリスト。リストの要素はそれぞれフェイス名か、
          anonymousフェイスのいずれかであること。これはリストされた各フ
          ェイスの属性を集約するフェイスを指定する。このリスト内で先に出
          現するフェイスが、より高い優先度をもつ。

        • ‘(foreground-color . COLOR-NAME)’または‘(background-color .
          COLOR-NAME)’という形式のコンスセル。これは‘(:foreground
          COLOR-NAME)’や‘(:background COLOR-NAME)’と同様、フォアグラウン
          ドとバックグラウンドのカラーを指定する。この形式は後方互換性の
          ためだけにサポートされており、避けるべきである。

‘mouse-face’
     このプロパティは、マウスがオーバーレイ範囲内にあるとき、‘face’のか
     わりに使用される。しかしEmacsは、このプロパティのテキストのサイズを
     変更する、すべてのフェイス属性(‘:height’、‘:weight’、‘:slant’)を無
     視する。これらの属性は、ハイライトされていないテキストでは、常に同
     一である。

‘display’
     このプロパティは、テキストが表示される方法を変更する、さまざまな機
     能をアクティブにする。たとえばこれは、テキストの外観を縦長
     (taller)や横長(shorter)にしたり、高く(higher)したり低く(lower)した
     り、イメージで置き換える。*note Display Property::を参照のこと。

‘help-echo’
     あるオーバーレイが‘help-echo’プロパティをもつなら、そのオーバーレイ
     内のテキスト上にマウスを移動した際、Emacsはエコーエリアまたはツール
     チップウィンドウにヘルプ文字列を表示する。詳細は*note Text
     help-echo::を参照のこと。

‘field’
     同じ‘field’プロパティをもつ連続する文字は、_フィールド(field)_を形
     成する。‘forward-word’や‘beginning-of-line’を含むいくつかの移動関数
     は、フィールド境界で移動を停止する。*note Fields::を参照のこと。

‘modification-hooks’
     このプロパティの値は、オーバーレイ内の任意の文字の変更、またはオー
     バーレイの厳密に内側にテキストが挿入された場合に呼び出される、関数
     のリストである。

     このフックの関数は、各変更の前後両方で呼び出される。これらの関数が
     受け取った情報を保存し、呼び出し間で記録を比較すれば、バッファー内
     のテキストでどのような変更が行われたかを、正確に判断できる。

     変更前に呼び出された際、各関数はオーバーレイ、‘nil’、変更されたテキ
     スト範囲の開始と終了という、4つの引数を受け取る。

     変更後に呼び出された際、各関数はオーバーレイ、‘t’、変更されたテキス
     ト範囲の開始と終了、およびその範囲により置き換えられた変更前のテキ
     スト長という、5つの引数を受け取る(変更前の長さは、挿入では0、削除で
     は削除された文字数であり、変更後の先頭と終端が等しくなる)。

     これらの関数がバッファーを変更する場合は、これらのフックを呼び出す
     内部的メカニズムの混乱を避けるために、それを行う前後で
     ‘inhibit-modification-hooks’を‘t’にバインドすること。

     テキストプロパティも‘modification-hooks’プロパティをサポートするが
     、詳細は幾分か異なる(*note Special Properties::を参照)。

‘insert-in-front-hooks’
     このプロパティの値は、オーバーレイ先頭へのテキスト挿入前後に呼び出
     される、関数のリストである。呼び出し方は、‘modification-hooks’の関
     数と同様。

‘insert-behind-hooks’
     このプロパティの値は、オーバーレイ終端へのテキスト挿入前後に呼び出
     される、関数のリストである。呼び出し方は、‘modification-hooks’の関
     数と同様。

‘invisible’
     ‘invisible’プロパティにより、オーバーレイ内のテキストを不可視似出来
     る。これはそのテキストが、スクリーン上に表示されないことを意味する
     。詳細は、*Note Invisible Text::を下さいのこと。

‘intangible’
     オーバーレイの‘intangible’プロパティは、正に‘intangible’テキストプ
     ロパティと同様に機能する。詳細は*Note Special Properties::を参照の
     こと。

‘isearch-open-invisible’
     このプロパティは、インクリメンタル検索にたいして、最後のマッチがそ
     のオーバーレイに重なる場合に、不可視なオーバーレイを永続的に可視に
     する方法を告げる。*note Invisible Text::を参照のこと。

‘isearch-open-invisible-temporary’
     このプロパティは、インクリメンタル検索にたいして、検索の間に、不可
     視なオーバーレイを一時的に可視にする方法を告げる。*note Invisible
     Text::を参照のこと。

‘before-string’
     このプロパティの値は、オーバーレイ先頭に表示するために追加する文字
     列である。この文字列は、いかなる意味においてもバッファー内には表れ
     ず、スクリーン上にのみ表れる。

‘after-string’
     このプロパティの値は、オーバーレイ終端に表示するために追加する文字
     列である。この文字列は、いかなる意味においてもバッファー内には表れ
     ず、スクリーン上にのみ表れる。

‘line-prefix’
     このプロパティは、表示時にそれぞれの非継続行の後に追加する、表示仕
     様(display spec)を指定する。*note Truncation::を参照のこと。

‘wrap-prefix’
     このプロパティは、表示時にそれぞれの継続行の前に追加する、表示仕様
     (display spec)を指定する。*note Truncation::を参照のこと。

‘evaporate’
     このプロパティが非‘nil’の場合は、そのオーバーレイが空(長さが0)にな
     ったら、自動的に削除される。空のオーバーレイにたいして非‘nil’の
     ‘evaporate’プロパティを与えた場合は、即座に削除される。

‘keymap’
     このプロパティがから‘nil’なら、それはそのテキスト範囲にたいしてキー
     マップを指定する。このキーマップは、ポイントの後の文字がそのオーバ
     ーレイ内にあるときに使用され、他のほとんどのキーマップより優先され
     る。*note Active Keymaps::を参照のこと。

‘local-map’
     ‘local-map’プロパティは‘keymap’プロパティと同様だが、既存のキーマッ
     プに付け加えるのではなく、バッファーのローカルマップを置き換える点
     が異なる。これは、そのキーマップがマイナーモードキーマップより低い
     優先度をもつことも意味する。

   ‘keymap’と‘local-map’プロパティは、‘before-string’、‘after-string’、
‘display’プロパティにより表示された文字列には影響しません。これはポイン
トがその文字列上にない場合の、マウスクリックや、その文字列に関する他のマ
ウスイベントにのみ関係があります。その文字列に特別なマウスイベントをバイ
ンドするには、そのイベントを‘keymap’か‘local-map’プロパティに割り当てま
す。*note Special Properties::を参照してください。


File: elisp,  Node: Finding Overlays,  Prev: Overlay Properties,  Up: Overlays

37.9.3 Searching for Overlays
-----------------------------

 -- Function: overlays-at pos &optional sorted
     この関数は、カレントバッファー内の位置POSにある文字をカバーする、す
     べてオーバーレイのリストをリターンする。SORTEDが非‘nil’ならリストは
     優先度降順、それ以外なら特定の順にはソートされない。オーバーレイが
     POS、またはそれより前から始まり、かつPOSの後で終わる場合、位置POSは
     オーバーレイに含まれる。

     使い方を説明するために、ポイント位置の文字にたいして、プロパティ
     PROPを指定するオーバーレイのリストをリターンするLisp関数である:

          (defun find-overlays-specifying (prop)
            (let ((overlays (overlays-at (point)))
                  found)
              (while overlays
                (let ((overlay (car overlays)))
                  (if (overlay-get overlay prop)
                      (setq found (cons overlay found))))
                (setq overlays (cdr overlays)))
              found))

 -- Function: overlays-in beg end
     この関数は、BEGからENDのリージョンと重複(overlap)する、オーバーレイ
     のリストをリターンする。“重複”とは、少なくとも1つの文字がそのオーバ
     ーレイに含まれ、かつ指定されたリージョンにも含まれることを意味する
     。しかし、空のオーバーレイがBEG、厳密に言うとBEGとENDにある場合、ま
     たはENDがバッファーの終端を示す場合は、その空のオーバーレイも結果に
     含まれる。

 -- Function: next-overlay-change pos
     この関数はPOSの後にあるオーバーレイの、開始または終了となるバッファ
     ー位置をリターンする。それが存在しなければ‘(point-max)’をリターンす
     る。

 -- Function: previous-overlay-change pos
     この関数はPOSの前にあるオーバーレイの、開始または終了となるバッファ
     ー位置をリターンする。それが存在しなければ‘(point-min)’をリターンす
     る。

   以下に例として、プリミティブ関数
‘next-single-char-property-change’(*note Property Search::を参照)の、単
純化(かつ非効率的な)したバージョンを示します。これは位置POSから前方へ、
与えられたプロパティ‘prop’にたいして、オーバーレイプロパティまたはテキス
トプロパティのいずれかの値が変化した、次の位置を検索します。

     (defun next-single-char-property-change (position prop)
       (save-excursion
         (goto-char position)
         (let ((propval (get-char-property (point) prop)))
           (while (and (not (eobp))
                       (eq (get-char-property (point) prop) propval))
             (goto-char (min (next-overlay-change (point))
                             (next-single-property-change (point) prop)))))
         (point)))


File: elisp,  Node: Size of Displayed Text,  Next: Line Height,  Prev: Overlays,  Up: Display

37.10 Size of Displayed Text
============================

すべての文字が同じ幅をもつ訳ではないので、以下の関数により文字の幅をチェ
ックできます。関連する関数については、*note Primitive Indent::と*note
Screen Lines::を参照してください。

 -- Function: char-width char
     この関数は、文字CHARがカレントバッファーに表示された場合(つまりその
     バッファーのディスプレイテーブルがあれば、それを考慮に入れる。*note
     Display Tables::を参照されたい)の幅を、列数でリターンする。タブ文字
     の幅は、通常は‘tab-width’である(*note Usual Display::を参照)。

 -- Function: string-width string
     この関数は、文字列STRINGがカレントバッファー、および選択されたウィ
     ンドウに表示された場合の幅を、列数でリターンする。

 -- Function: truncate-string-to-width string width &optional
          start-column padding ellipsis
     この関数はSTRINGの一部を、列数WIDTHにフィット新たな文字列としてリタ
     ーンする。

     STRINGがWIDTHに満たない場合、その文字列終端が結果の終端となる。
     STRING内の1つの複数列文字が、列WIDTHを超えて跨がる場合、その文字は
     結果に含まれない。つまり結果はWIDTHより短くなるかもしれないが、それ
     を超えることはできない。

     オプション引数START-COLUMNは、開始列を指定する。これが非‘nil’なら、
     その文字列の最初のSTART-COLUMN列は、値から省かれる。STRING内の1つの
     複数列文字が、列START-COLUMNを超えて跨がる場合、その文字は結果に含
     まれない。

     オプション引数PADDINGが非‘nil’なら、結果となる文字列の幅を正確に
     WIDTH列に拡張するために、パディング文字が追加される。結果文字列が
     WIDTHより短ければ、結果文字列の終端にパディング文字が使用される。
     STRING内の1つの複数列文字が列START-COLUMNを跨ぐ場合は、先頭にもパデ
     ィング文字が使用される。

     ELLIPSISが非‘nil’なら、それはSTRINGの表示幅がELLIPSISの表示幅以下で
     なければ、WIDTHを超えてしまう場合に、STRINGの終端(任意のパディング
     を含む)を置き換える文字列であること。ELLIPSISが非‘nil’、かつ文字列
     以外なら、それは‘"..."’を意味する。

          (truncate-string-to-width "\tab\t" 12 4)
               ⇒ "ab"
          (truncate-string-to-width "\tab\t" 12 4 ?\s)
               ⇒ "    ab  "

   以下の関数は、あるテキストが与えられたウィンドウに表示されたときのサ
イズを、ピクセル単位でリターンします。この関数は、テキストを含むためにウ
ィンドウを十分大きくするために、‘fit-window-to-buffer’(*note Resizing
Windows::を参照)と‘fit-frame-to-buffer’(*note Size and Position::を参照
)により使用されます。

 -- Function: window-text-pixel-size &optional window from to x-limit
          y-limit mode-and-header-line
     この関数は、WINDOWのバッファーのテキストサイズを、ピクセル単位でリ
     ターンする。WINDOWは生きたウィンドウでなければならず、デフォルトは
     選択されたウィンドウ。リターン値は、任意のテキスト行の最大ピクセル
     幅と、すべてのテキスト行の最大ピクセル高さのコンスである。

     オプション引数FROMが非‘nil’なら、それは考慮すべき最初のテキスト位置
     を指定し、デフォルトはそのバッファーのアクセス可能な最小の位置であ
     る。FROMが‘t’なら、それは改行文字ではない、アクセス可能な最小位置を
     使用する。オプション引数TOが非‘nil’なら、それは考慮すべき最後のテキ
     スト位置を指定し、デフォルトはそのバッファーのアクセス可能な最大の
     位置である。TOが‘t’なら、それは改行文字ではない、アクセス可能な最大
     位置を使用する。

     オプション引数X-LIMITが非‘nil’なら、それはリターンされ得る、最大ピ
     クセル幅を指定する。X-LIMITが‘nil’または省略された場合には、
     WINDOWのbody(*note Window Sizes::を参照)のピクセル幅を使用する。こ
     れは、呼び出し側がWINDOWの幅の変更を意図しない場合に有用である。そ
     れ以外なら、呼び出し側はここで想定されるWINDOWのbodyの、最大幅を指
     定するべきである。X座標を超えるテキストのX-LIMITは無視される。長い
     行の幅の計算には多くの時間を要する可能性があるので、特にいずれにせ
     よ切り詰められるであろう長い行を含むバッファーの場合には、必要に応
     じて、この引数の値を小さくすることは、よいアイデアである。

     オプション引数Y-LIMITが非‘nil’なら、それはリターンされ得る、最大ピ
     クセル高さを指定する。Y座標を超えるテキストのY-LIMITは無視される。
     大きなバッファーのピクセル高さの計算には多くの時間を要する可能性が
     あるので、特に呼び出し側がバッファーのサイズを知らない場合、この変
     数の指定は合理的である。

     オプション引数MODE-AND-HEADER-LINEが‘nil’または省略された場合は、リ
     ターン値にWINDOWのモードラインとヘッダーラインの高さを含めないこと
     を意味する。これがシンボル‘mode-line’または‘header-line’のいずれか
     なら、それらが存在する場合は、リターン値にそのラインの高さだけを含
     める。これが‘t’なら、存在する場合は両方の高さをリターン値に含める。


File: elisp,  Node: Line Height,  Next: Faces,  Prev: Size of Displayed Text,  Up: Display

37.11 Line Height
=================

各ディスプレイ行のトータル高さは、その行のコンテンツ高さに、そのディスプ
レイ上部または下部にオプションで追加される垂直行スペーシングを加えて構成
されます。

   行のコンテンツ高さは、もしあれば最後の改行を含む、そのディスプレイ行
の文字またはイメージの最大高さです(継続されるディスプレイ行には最後の改
行が含まれない)。特にこれより大きい高さを指定しなければ、これがデフォル
トの行高さになります(一般的には、これはデフォルトのフレームフォント高さ
に等しい)。

   より大きい行高さを明示的に指定するためにはディスプレイ行の絶対高さ、
または垂直スペースを指定することによる、複数の方法が存在します。しかし何
を指定したかに関わらず、実際の行高さがデフォルトの高さより小さくなること
はありません。

   改行は、その改行で終わるディスプレイ行のトータル高さを制御する、テキ
ストプロパティまたはオーバーレイプロパティ‘line-height’をもつことができ
ます。

   プロパティの値が‘t’なら、改行文字はその行の表示高さにたいして効果をも
たず、可視なコンテンツだけが高さを決定します。これはイメージ間に追加のブ
ランク領域をもたない、小さなイメージ(またはイメージスライス)にたいして有
用です。

   プロパティの値が‘(HEIGHT TOTAL)’という形式のリストなら、これはディス
プレイ行の_下部_に余分なスペースを追加します。最初にEmacsは、その行の_上
部_の余分なスペースを制御するための高さspecとして、HEIGHTを使用します。
それから行のトータル高さをTOTALにするために、行の_下部_に必要なスペース
を追加します。この場合、行のスペーシングを指定する他の方法は無視されます
。

   他の種類のプロパティ値は高さspec(height spec)です。これは行の高さを指
定する数値に変換されます。高さspecを記述するためには複数の方法があります
。以下はそれらが数値に変換される方法です:

‘INTEGER’
     高さspecが正の整数なら、高さの値はその整数。
‘FLOAT’
     高さspecが浮動小数点数FLOATなら、高さ数値はそのフレームのデフォルト
     行高さのFLOAT倍。
‘(FACE . RATIO)’
     高さspecがこのフォーマットのコンスなら、高さ数値はフェイスFACEの高
     さのRATIO倍。RATIOには任意の型の数値を指定でき、‘nil’は1のratioを意
     味する。FACEが‘t’なら、カレントフェイスを参照する。
‘(nil . RATIO)’
     高さspecがこのフォーマットのコンスなら、高さ数値はその行のコンテン
     ツ高さのRATIO倍。

   したがって、任意の有効な種々の高さspecにより、ピクセル単位で高さが決
定されます。行のコンテンツ高さがこれより小さければ、Emacsは指定されたト
ータル高さになるよう、余分な垂直スペースを行の上部に追加します。

   ‘line-height’プロパティを指定しない場合、その行の高さは行のコンテンツ
高さとに行スペーシングを追加して構成されます。Emacsの異なるさまざまな部
分のテキストにたいして、行スペーシングを指定する複数の方法が存在します。

   グラフィカルなディスプレイでは、フレームパラメーター
‘line-spacing’(*note Layout Parameters::を参照)を使用することにより、フ
レーム内のすべての行にたいして行スペーシングを指定できます。しかし
‘line-spacing’のデフォルト値が非‘nil’なら、それはそのフレームのフレーム
パラメーター‘line-spacing’をオーバーライドします。整数は行の下部に配する
ピクセル数を指定します。浮動小数点数はフレームのデフォルト行高さに相対的
にスペーシングを指定します。

   バッファーローカル変数‘line-spacing’を通じて、バッファー内のすべての
行の行スペーシングを指定できます。整数は行の下部に配するピクセル数を指定
します。浮動小数点数はデフォルトフレーム行高さに相対的にスペーシングを指
定します。これは、そのフレームにたいして指定された行スペーシングをオーバ
ーライドします。

   最後に改行は、改行で終わるディスプレイ行にたいして、デフォルトフレー
ム行スペーシングおよびバッファーローカル変数‘line-spacing’をオーバーライ
ドする、テキストプロパティまたはオーバーレイプロパティ‘line-spacing’をも
つことができます。

   種々の方法により、これらのメカニズムは各行のスペーシングにたいする
Lisp値を指定します。値は高さspecで、これは上述したLisp値に変換されます。
しかしこの場合高さ数値は行高さではなく行スペーシングを指定します。

   テキスト端末では、行スペーシングは変更できません。


File: elisp,  Node: Faces,  Next: Fringes,  Prev: Line Height,  Up: Display

37.12 Faces
===========

“フェイス(face)”とはフォント、フォアグラウンドカラー、バックグラウンドカ
ラー、オプションのアンダーライン等のテキストを表示するための、グラフィカ
ルな属性のコレクションのことです。フェイスはEmacsがバッファー内、同様に
モードラインのようなフレームの他の部分で、テキストを表示する方法を制御し
ます。

   フェイスを表現する1つの方法として、‘(:foreground "red" :weight
bold)’のような属性のプロパティリストがあります。このようなリストは、
“anonymousフェイス(anonymous face)”と呼ばれます。たとえば‘face’テキスト
プロパティとしてanonymousフェイスを割り当てることができ、Emacsは指定され
た属性でテキストを表示するでしょう。*note Special Properties::を参照して
ください。

   より一般的には、フェイスは“フェイス名(face name)”を通じて参照されます
。これはフェイス属性のセットに関連付けられたLispシンボル(1)。です。名前
つきフェイスは‘defface’マクロを使用して定義できます(*note Defining
Faces::を参照)。Emacsにはいくつかの標準名前つきフェイスが同梱されていま
す(*note Basic Faces::を参照)。

   Emacsの多くの箇所で名前つきフェイスが要求され、anonymousフェイスは受
け入れられません。これらには*note Attribute Functions::に記述される関数
、および変数‘font-lock-keywords’(*note Search-based Fontification::を参
照)が含まれます。特に明記しないかぎり、名前つきフェイスの参照だけに用語
“フェイス”を使用することとします。

 -- Function: facep object
     この関数はOBJECTが名前つきフェイス(フェイス名の役目をもつLispシンボ
     ルまたは文字列)なら、非‘nil’をリターンする。それ以外なら‘nil’をリタ
     ーンする。

* Menu:

* Face Attributes::          フェイスとは?
* Defining Faces::           フェイスを定義する方法。
* Attribute Functions::      フェイス属性の確認およびセットを行う関数。
* Displaying Faces::         ある文字にたいして指定されたフェイスをEmacsが組み合わせる方法。
* Face Remapping::           フェイスを別の定義にリマップする。
* Face Functions::           フェイスの定義、および確認する方法。
* Auto Faces::               自動的にフェイスを割り当てるフック。
* Basic Faces::              デフォルトで定義されるフェイス。
* Font Selection::           あるフェイスに最適なフォントを見つける。
* Font Lookup::              利用可能なフォント名とそれらの情報の照会。
* Fontsets::                 フォントセット、それは文字セットの範囲を処理するフォントコレクションである。
* Low-Level Font::           文字表示フォントのLisp表現。

   ---------- Footnotes ----------

   (1) 後方互換のため、フェイス名の指定に文字列も使用できます。これは同
名のLispシンボルと等価です。


File: elisp,  Node: Face Attributes,  Next: Defining Faces,  Up: Faces

37.12.1 Face Attributes
-----------------------

“フェイス属性(Face attributes)”は、フェイスの視覚的外観を決定します。以
下はすべてのフェイス属性と、それらの可能な値と効果に関するテーブルです。

   以下の値とは別に、各フェイス属性は値‘unspecified’をもつことができます
。この特殊な値は、フェイスがその属性を直接指定しないことを意味します。
‘unspecified’属性は、Emacsにかわりに親フェイス(以下の‘:inherit’属性の記
述を参照)を参照すること、それに失敗した場合は基礎フェイス(*note
Displaying Faces::を参照)を参照することを指示します。‘default’フェイスは
すべての属性を指定しなければなりません。

   これらの属性のいくつかは、特定の種類のディスプレイにおいてのみ意味が
あります。ディスプレイが特定の属性を処理できなければ、その属性は無視され
ます。

‘:family’
     フォントファミリーまたはフォントセット(文字列)。フォントファミリー
     に関する詳細は、*Note (emacs)Fonts::を参照のこと。関数
     ‘font-family-list’(以下参照)は、利用可能なファミリー名のリストをリ
     ターンする。フォントセットに関する情報は、*note Fontsets::を参照さ
     れたい。

‘:foundry’
     ‘:family’属性により指定されるフォントファミリーにたいする“フォント
     foundry(font foundry)”(文字列)。*note (emacs)Fonts::を参照のこと。

‘:width’
     相対的な文字幅。これはシンボル‘ultra-condensed’、
     ‘extra-condensed’、‘condensed’、‘semi-condensed’、‘normal’、
     ‘semi-expanded’、‘expanded’、‘extra-expanded’、‘ultra-expanded’のい
     ずれかであること。

‘:height’
     フォントの高さ。もっともシンプルなケースでは1/10ポイントを単位とす
     る整数。

     値には“基礎フェイス(underlying face)”にたいして相対的に高さを指定す
     る浮動小数点数、または関数も指定できる(*note Displaying Faces::を参
     照)。浮動小数点数は基礎フェイスの高さをスケーリングする量を指定する
     。関数値は基礎フェイスの高さを単一の引数として呼び出され、新たなフ
     ェイスの高さをリターンする。関数が整数を引数として渡された場合には
     、整数をリターンしなければならない。

     デフォルトフェイスの高さは、整数を使用して指定しなければならない。
     浮動小数点数および関数は受け入れられない。

‘:weight’
     フォントのweight。(太字から細字順に)シンボル‘ultra-bold’、
     ‘extra-bold’、‘bold’、‘semi-bold’、‘normal’、‘semi-light’、
     ‘light’、‘extra-light’、‘ultra-light’のいずれか。可変輝度テキストを
     サポートするテキスト端末では、normalより大なweightはより高輝度、小
     なweightはより低輝度で表示される。

‘:slant’
     フォントのslant。シンボル‘italic’、‘oblique’、‘normal’、
     ‘reverse-italic’、‘reverse-oblique’のいずれか。可変輝度テキストをサ
     ポートするテキスト端末では、slantされたテキストはhalf-brightで表示
     される。

‘:foreground’
     フォアグラウンドカラー(文字列)。値にはシステム定義済みカラー、また
     は16進カラー仕様を指定できる。*note Color Names::を参照のこと。白黒
     ディスプレイでは、特定のグレー色調が点描パターンで実装されている。

‘:distant-foreground’
     代替えのフォアグラウンドカラー(文字列)。これは‘:foreground’と似てい
     るが、使用されるであろうフォアグラウンドカラーが、バックグラウンド
     カラーに近いときのみフォアグラウンドカラーとして使用される点が異な
     る。これはたとえばテキストをマーク時(リージョンフェイス)に有用であ
     る。そのテキストが、リージョンフェイスとして可視なフォアグラウンド
     をもつ場合は、そのフォアグラウンドが使用される。フォアグラウンドが
     リージョンフェイスのバックグラウンドに近ければ、テキストを可読にす
     るために‘:distant-foreground’が使用される。

‘:background’
     バックグラウンドカラー(文字列)。値にはシステム定義済みカラー、また
     は16進カラー仕様を指定できる。*note Color Names::を参照のこと。

‘:underline’
     文字にアンダーラインを引くべきか否かと、その方法。‘:underline’属性
     として可能な値は以下のとおり:

     ‘nil’
          アンダーラインを引かない。

     ‘t’
          そのフェイスのフォアグラウンドカラーでアンダーラインを引く。

     COLOR
          文字列COLORで指定されたカラーでアンダーラインを引く。

     ‘(:color COLOR :style STYLE)’
          COLORは文字列、またはそのフェイスのフォアグラウンドカラーを意
          味するシンボル‘foreground-color’。属性‘:color’の省略は、そのフ
          ェイスのフォアグラウンドカラーの使用を意味する。STYLEには直線
          を意味する‘line’、または波線を意味する‘wave’いずれかのシンボル
          であること。属性‘:style’の省略は直線を意味する。

‘:overline’
     文字にオーバーラインを引くべきか否かと、そのカラー。値が‘t’なら、そ
     のフェイスのフォアグラウンドカラーを使用してオーバーラインを引く。
     値が文字列なら、そのカラーを使用してオーバーラインを引く。値‘nil’は
     オーバーラインを引かないことを意味する。

‘:strike-through’
     文字に取り消し線を引くべきか否かと、そのカラー。値は‘:overline’で使
     用される値と同じ。

‘:box’
     文字周囲に枠(box)を描画するか否か、そのカラー、枠線の幅、3D外観。以
     下は‘:box’の可能な値と意味である:

     ‘nil’
          枠を描画しない。

     ‘t’
          幅1の枠線、フォアグラウンドカラーで枠を描画する。

     COLOR
          幅1の枠線、カラーCOLORで枠を描画する。

     ‘(:line-width WIDTH :color COLOR :style STYLE)’
          この方法では、枠のすべての形相を明示的に指定できる。値WIDTHは
          描画する線の幅を指定し、デフォルトは1。負の幅-Nは、基礎テキス
          トのスペースを占有する線幅Nを意味し、文字の高さまたは幅を避け
          ることができる。

          値COLORは描画するカラーを指定する。シンプルな枠線ではフェイス
          のフォアグラウンドカラー、3D枠線ではフェイスのバックグラウンド
          カラーがデフォルト。

          値STYLEは3D枠線を描画するか否かを指定する。‘released-button’な
          ら、枠は押下された3Dボタンのような外観、‘pressed-button’なら押
          下されていない3Dボタンのような外観、‘nil’または省略された場合
          は2D枠線が使用される。

‘:inverse-video’
     文字が反転表示されて表示されるべきか否か。値は‘t’(反転表示する)、ま
     たは‘nil’(反転表示しない)であること。

‘:stipple’
     バックグラウンドの点描(ビットマップ)。

     値には文字列を指定でき、それは外部形式Xビットマップデータを含むファ
     イルの名前であること。ファイルは変数‘x-bitmap-file-path’にリストさ
     れるディレクトリー内で検索される。

     かわりに‘(WIDTH HEIGHT DATA)’という形式のリストにより、ビットマップ
     で直接値を指定できる。ここでWIDTHとHEIGHTはピクセル単位によるサイズ
     、DATAは行単位でビットマップのrawビットを含む文字列。各行は文字列内
     で連続する(WIDTH + 7) / 8バイトを占める(最善の結果を得るためにはユ
     ニバイト文字列であるべき)。これは各行が常に少なくとも、1バイト全体
     を占めることを意味する。

     値が‘nil’なら、点描パターンを使用しないことを意味する。

     これは特定のグレー色調を処理するために自動的に使用されるので、通常
     はstipple属性のセットは必要ない。

‘:font’
     そのフェイスの表示に使用されるフォント。値はフォントオブジェクトで
     あること。フォントオブジェクト、フォントスペース、フォントエンティ
     ティーに関する情報は、*note Low-Level Font::を参照のこと。

     ‘set-face-attribute’(*note Attribute Functions::を参照)を使用してこ
     の属性を指定する際にはフォントspec、フォントエンティティー、または
     文字列を与えることもできる。Emacsはそのような値を適切なフォントオブ
     ジェクトに変換して、実際の属性値としてそのフォントオブジェクトを格
     納する。文字列を指定する場合、その文字列のコンテンツはフォント名で
     あること(*note (emacs)Fonts::を参照)。フォント名がワイルドカードを
     含むXLFDなら、Emacsはそれらのワイルドカードに最初にマッチするフォン
     トを選択する。この属性の指定により、‘:family’、‘:foundry’、
     ‘:width’、‘:height’、‘:weight’、‘:slant’の属性値も変更される。

‘:inherit’
     属性を継承するフェイス名、またはフェイス名のリスト。継承フェイス由
     来の属性は、基礎フェイスより高い優先度で、基礎フェイスの場合と同じ
     ような方法でマージされる(*note Displaying Faces::を参照)。フェイス
     のリストが使用された場合、リスト内先頭側フェイスの属性が末尾側フェ
     イスの属性をオーバーライドする。

 -- Function: font-family-list &optional frame
     この関数は、利用可能なフォントファミリー名のリストをリターンする。
     オプション引数FRAMEはそのテキストが表示されるフレームを指定する。こ
     れが‘nil’なら選択されたフレームが使用される。

 -- User Option: underline-minimum-offset
     この変数は、アンダーラインが引かれたテキスト表示時に、ベースライン
     とアンダーライン間の最小距離を、ピクセル単位で指定する。

 -- User Option: x-bitmap-file-path
     この変数は‘:stipple’属性のビットマップファイルを検索する、ディレク
     トリーのリストを指定する。

 -- Function: bitmap-spec-p object
     これはOBJECTが、‘:stipple’(上記参照)での使用に適す有効なビットマッ
     プ仕様なら‘t’、それ以外なら‘nil’をリターンする。


File: elisp,  Node: Defining Faces,  Next: Attribute Functions,  Prev: Face Attributes,  Up: Faces

37.12.2 Defining Faces
----------------------

フェイスを定義する通常の方法は、‘defface’マクロを通じて定義する方法です
。このマクロはフェイス名(シンボル)を、デフォルトの“フェイスspec(face
spec)”と関連付けます。フェイスspecは、任意の与えられた端末上でフェイスが
どの属性をもつべきかを指定する構成です。たとえばあるフェイスspecは、高カ
ラー端末ではあるフォアグラウンドカラーを指定し、低カラー端末では異なるフ
ォアグラウンドカラーを指定するかもしれません。

   値がフェイス名であるような変数を作りたがる人がいます。ほとんどの場合
、これは必要ありません。通常手順は、‘defface’でフェイスを定義して、その
名前を直接使用することです。

 -- Macro: defface face spec doc [keyword value]...
     このマクロは、SPECによりデフォルトフェイスspecが与えられるような、
     名前つきフェイスとしてFACEを宣言する。シンボルFACEはクォートせず、
     ‘-face’で終わらないこと(冗長であろう)。引数DOCは、そのフェイスにた
     いするドキュメント文字列。追加のKEYWORD引数は、‘defgroup’および
     ‘defcustom’の場合と同じ意味をもつ(*note Common Keywords::を参照)。

     If FACE already has a default face spec, this macro does nothing.

     デフォルトフェイスspecは、何もカスタマイゼーション(*note
     Customization::を参照)の効果がないときに、FACEの外観を決定する。
     FACEが、(Customテーマやinitファイルから読み込んだカスタマイズにより
     )すでにカスタマイズ済みなら、その外観はデフォルトフェイスspecの
     SPECをオーバーライドする、カスタムフェイスspecにより決定される。し
     かしその後カスタマイゼーションが削除されたなら、FACEの外観は再びそ
     のデフォルトフェイスspecにより決定されるだろう。

     例外として、Emacs Lispモードで‘C-M-x’(‘eval-defun’)から‘defface’を
     評価した場合は、‘eval-defun’の特別な機能により、‘defface’が何を指示
     するかをフェイスが正確に反映するように、そのフェイス上の任意のカス
     タムフェイスをオーバーライドする。

     SPEC引数は、異なる種別の端末上でそのフェイスがどのような外観で表示
     されるべきかを示す、“フェイスspec”である。これは各要素が以下の形式
     であるようなalistであること

          (DISPLAY . PLIST)

     DISPLAYは端末のクラス(以下参照)を指定する。PLISTは、そのような端末
     上でフェイスがどのような外観かを指定する、フェイス属性とその値から
     なるプロパティリストであること。後方互換性のために、‘(DISPLAY
     PLIST)’のように要素を記述することもできる。

     SPECの要素のDISPLAYの部分は、その要素がマッチする端末を決定する。与
     えられた端末にたいして複数の要素がマッチした場合は、最初にマッチし
     た要素がその端末にたいして使用される。DISPLAYには以下の3つが可能:

     ‘default’
          SPECのこの要素は、どの端末にもマッチしない。かわりにすべての端
          末に適用されるデフォルトを指定する。この要素が仕様された場合は
          、SPECの最初の要素でなければならない。この後の要素はこれらのデ
          フォルトの一部、またはすべてをオーバーライドできる。

     ‘t’
          SPECのこの要素は、すべての端末にマッチする。したがってSPECの後
          続要素が使用されることはない。通常‘t’は、SPECの最後(または唯一
          )の要素として使用される。

     リスト
          DISPLAYがリストなら、各要素は‘(CHARACTERISTIC VALUE...)’という
          形式をもつこと。ここでCHARACTERISTICは端末をクラス分けする方法
          、VALUEはDISPLAYに適用されるべき可能なクラス分類である。
          CHARACTERISTICで利用可能な値は:

          ‘type’
               その端末が使用するウィンドウシステムの種類で‘graphic’(任
               意のグラフィック対応ディスプレイ)、‘x’、‘pc’(MS-DOSコンソ
               ール)、‘w32’ (MS Windows 9X/NT/2K/XP)、または‘tty’(グラフ
               ィック非対応ディスプレイ)のいずれか。*note window-system:
               Window Systems.を参照のこと。

          ‘class’
               その端末がサポートするカラーの種類で、‘color’、
               ‘grayscale’、または‘mono’のいずれか。

          ‘background’
               バックグラウンドの種類で‘light’か‘dark’のいずれか。

          ‘min-colors’
               その端末がサポートするべき最小カラー数を表す整数。端末の
               ‘display-color-cells’の値が少なくとも指定された整数なら、
               その端末にマッチする。

          ‘supports’
               その端末がVALUE...で与えられたフェイス属性を表示可能か否
               か(*note Face Attributes::を参照)。このテストがどのように
               行われるかについてのより正確な情報は、*note Display Face
               Attribute Testing::を参照のこと。

          与えられたCHARACTERISTICにたいして、DISPLAYの要素が複数の
          VALUEを指定する場合は、いずれの値も許容され得る。DISPLAYが複数
          の要素をもつ場合、各要素は異なるCHARACTERISTICを指定すること。
          その端末の_それぞれ_のcharacteristicは、DISPLAY内で指定された
          値のいずれか1つとマッチしなければならない。

   たとえば以下は、標準フェイス‘highlight’の定義です:

     (defface highlight
       '((((class color) (min-colors 88) (background light))
          :background "darkseagreen2")
         (((class color) (min-colors 88) (background dark))
          :background "darkolivegreen")
         (((class color) (min-colors 16) (background light))
          :background "darkseagreen2")
         (((class color) (min-colors 16) (background dark))
          :background "darkolivegreen")
         (((class color) (min-colors 8))
          :background "green" :foreground "black")
         (t :inverse-video t))
       "Basic face for highlighting."
       :group 'basic-faces)

   内部的には、Emacsはフェイスのシンボルプロパティ‘face-defface-spec’内
にそれぞれのフェイスのデフォルトspecを格納します(*note Symbol
Properties::を参照)。‘saved-face’プロパティは、カスタマイゼーションバッ
ファーを使用してユーザーが保存した、任意のフェイスspecを格納します。
‘customized-face’プロパティは、カレントセッションにたいしてカスタマイズ
された保存されていないフェイスspecを格納します。そして‘theme-face’プロパ
ティは、そのフェイスにたいするアクティブなカスタマイゼーションセッティン
グと、フェイスspecをもつCustomテーマを関連付けるalistです。そのフェイス
のドキュメント文字列は、‘face-documentation’プロパティ内に格納されます。

   通常フェイスは‘defface’を使用して1回だけ宣言され、その外観にたいする
それ以上の変更はCustomizeフレームワーク(Customizeユーザーインターフェー
ス、または‘custom-set-faces’関数を通じて。*note Applying
Customizations::を参照されたい)、またはフェイスリマッピング(*note Face
Remapping::を参照)により行われます。Lispから触接フェイスspec変更を要する
稀な機会では、‘face-spec-set’関数を使用できます。

 -- Function: face-spec-set face spec &optional spec-type
     この関数は、‘face’にたいするフェイスspecとして、SPECを適用する。
     SPECは、上述した‘defface’にたいするフェイスspecであること。

     この関数は、もしそれが既存のものでなければ、有効なフェイス名として
     FACEを定義して、既存フレームのその属性を(再)計算することも行う。

     引数SPEC-TYPEは、どのspecをセットするべきかを決定する。これが
     ‘nil’または‘face-override-spec’なら、この関数は“オーバーライド
     spec(override spec)”をセットする。これはFACE上の他のすべてのフェイ
     スspecをオーバーライドする。‘customized-face’または‘saved-face’なら
     、この関数はカスタマイズされたspec、または保存されたカスタムspecを
     セットする。‘face-defface-spec’なら、この関数はデフォルトフェイス
     spec(‘defface’によりセットされるものと同一)をセットする。‘reset’な
     ら、この関数はFACEからすべてのカスタマイゼーションspecとオーバーラ
     イドspecをクリアーする(この場合、SPECの値は無視される)。SPEC-TYPEに
     たいする他のすべての値は、内部的な使用のために予約済みである。


File: elisp,  Node: Attribute Functions,  Next: Displaying Faces,  Prev: Defining Faces,  Up: Faces

37.12.3 Face Attribute Functions
--------------------------------

このセクションでは、名前つきフェイスの属性に直接アクセスしたり、変更する
関数を説明します。

 -- Function: face-attribute face attribute &optional frame inherit
     この関数は、FRAME上のFACEにたいする、属性ATTRIBUTEの値をリターンす
     る。

     FRAMEが‘nil’なら、それは選択されたフレームを意味する(*note Input
     Focus::を参照)。FRAMEが‘t’なら、この関数は新たに作成されるフレーム
     にたいする、指定された属性の値をリターンする(これは下記の
     ‘set-face-attribute’を使用して何らかの値を指定していなければ、通常
     は‘unspecified’である)。

     INHERITが‘nil’なら、FACEにより定義される属性だけが考慮されるので、
     リターンされる値は‘unspecified’、または相対的な値かもしれない。
     INHERITが非‘nil’なら、FACEのATTRIBUTEの定義が、‘:inherit’属性で指定
     されたフェイスとマージされる。しかしリターンされる値は依然として
     ‘unspecified’、または相対的な値かもしれない。INHERITがフェイス、ま
     たはフェイスのリストなら、指定された絶対的な値になるまで、結果はそ
     のフェイス(1つ以上)と更にマージされる。

     リターン値が指定されていて、かつ絶対的であることを保証するためには
     、INHERITにたいして‘default’の値を使用すること。(常に完全に指定され
     る)‘default’フェイスとマージすることにより、すべての未指定または相
     対的な値は解決されるだろう。

     たとえば

          (face-attribute 'bold :weight)
               ⇒ bold

 -- Function: face-attribute-relative-p attribute value
     この関数はVALUEがフェイス属性ATTRIBUTEの値として使用された際に相対
     的なら、非‘nil’をリターンする。This function returns non- if , when
     used as the value of the face attribute , is relative.これはフェイ
     スリスト内の後続のフェイス、または継承した他のフェイスが由来となる
     、任意の値で完全にオーバーライドするのではなく、変更されるであろう
     ことを意味する。

     すべての属性にたいして、‘unspecified’は相対的な値である。
     ‘:height’にたいしては、浮動小数点数と関数値も相対的である。

     たとえば:

          (face-attribute-relative-p :height 2.0)
               ⇒ t

 -- Function: face-all-attributes face &optional frame
     この関数は、FACEの属性のalistをリターンする。結果の要素は、
     ‘(ATTR-NAME . ATTR-VALUE)’という形式の、名前/値ペアーである。オプシ
     ョン引数FRAMEは、リターンするべきFACEの定義をもつフレームを指定する
     。省略または‘nil’なら、リターン値には新たに作成されるフレームにたい
     する、FACEのデフォルト属性が記述される。

 -- Function: merge-face-attribute attribute value1 value2
     VALUE1がフェイス属性ATTRIBUTEにたいして相対的な値なら、基礎的な値
     VALUE2とマージしてリターンする。それ以外の場合、VALUE1がフェイス属
     性ATTRIBUTEにたいして絶対的な値なら、VALUE1を変更せずにリターンする
     。

   通常、Emacsは各フレームのフェイス属性を自動的に計算するために、各フェ
イスのフェイスspecを使用します(*note Defining Faces::を参照)。関数
‘set-face-attribute’は、特定またはすべてのフレームのフェイスに直接属性を
割り当てることにより、この計算をオーバーライドできます。この関数は主とし
て、内部的な使用を意図したものです。

 -- Function: set-face-attribute face frame &rest arguments
     この関数は、FRAMEにたいするFACEの1つ以上の属性をセットする。この方
     法で指定された属性は、FACEに属するフェイスspec(1つ以上)をオーバーラ
     イドする。

     余分の引数ARGUMENTSは、セットするべき属性と、それらの値を指定する。
     これらは、(‘:family’や‘:underline’のような)属性名と、値が交互になる
     よう構成されていること。すなわち、

          (set-face-attribute 'foo nil :weight 'bold :slant 'italic)

     これは属性‘:weight’を‘bold’、.属性‘:slant’を‘italic’にセットする。

     FRAMEが‘t’なら、この関数は新たに作成されるフレームにたいする、デフ
     ォルト属性をセットする。FRAMEが‘nil’なら、この関数はすべての既存フ
     レーム、同様に新たに作成されるフレームにたいして、その属性をセット
     する。

   以下のコマンドと関数は主として、古いバージョンのEmacsにたいする互換性
のために提供されます。これらは‘set-face-attribute’を呼び出すことにより機
能します。これらのFRAME引数にたいする値‘t’と‘nil’は、
‘set-face-attribute’および‘face-attribute’の場合と同様に処理されます。コ
マンドがインタラクティブに呼び出された場合は、ミニバッファーを使用して引
数を読み取ります。

 -- Command: set-face-foreground face color &optional frame
 -- Command: set-face-background face color &optional frame
     これらはそれぞれFACEの‘:foreground’属性、または‘:background’属性に
     COLORをセットする。

 -- Command: set-face-stipple face pattern &optional frame
     これはFACEの‘:stipple’属性に、PATTERNをセットする。

 -- Command: set-face-font face font &optional frame
     これはFACEの‘:font’属性に、FONTをセットする。

 -- Function: set-face-bold face bold-p &optional frame
     これはFACEの‘:weight’属性にたいして、BOLD-Pが‘nil’ならNORMAL、それ
     以外ならBOLDをセットする。

 -- Function: set-face-italic face italic-p &optional frame
     これはFACEの‘:slant’属性にたいして、ITALIC-Pが‘nil’ならNORMAL、それ
     以外ならITALICをセットする。

 -- Function: set-face-underline face underline &optional frame
     これはFACEの‘:underline’属性に、UNDERLINEをセットする。

 -- Function: set-face-inverse-video face inverse-video-p &optional
          frame
     これはFACEの‘:inverse-video’属性に、INVERSE-VIDEO-Pをセットする。

 -- Command: invert-face face &optional frame
     これはフェイスFACEのフォアグラウンドカラーとバックグラウンドカラー
     を交換する。

   以下は、フェイスの属性を調べる関数です。これらは主として、古いバージ
ョンのEmacsとの互換性のために提供されます。これらにたいしてFRAMEを指定し
なければ選択されたフレームを、‘t’なら新たなフレームにたいするデフォルト
データを参照します。フェイスがその属性にたいして何の値も定義していなけれ
ば、‘unspecified’がリターンされます。INHERITが‘nil’なら、そのフェイスに
より直接定義された属性だけがリターンされます。INHERITが非‘nil’なら、その
フェイスの‘:inherit’属性により指定される任意のフェイスを、INHERITがフェ
イスまたはフェイスのリストなら、指定された属性が見つかるまで、それらも考
慮されます。リターンされる値が常に指定された値であることを保証するために
は、INHERITにたいして値‘default’を使用してください。

 -- Function: face-font face &optional frame
     この関数は、フェイスFACEのフォント名をリターンする。

 -- Function: face-foreground face &optional frame inherit
 -- Function: face-background face &optional frame inherit
     これらの関数はそれぞれ、フェイスFACEのフォアグラウンドカラーまたは
     バックグラウンドカラーを、文字列としてリターンする。

 -- Function: face-stipple face &optional frame inherit
     この関数は、フェイスFACEのバックグラウンド点描パターンの名前、もし
     なければ‘nil’をリターンする。

 -- Function: face-bold-p face &optional frame inherit
     この関数はFACEの‘:weight’属性がnormalよりbold寄り(‘semi-bold’、
     ‘bold’、 ‘extra-bold’、‘ultra-bold’のいずれか)なら、非‘nil’、それ以
     外なら‘nil’をリターンする。

 -- Function: face-italic-p face &optional frame inherit
     この関数は、FACEの‘:slant’属性が‘italic’か‘oblique’なら非‘nil’、そ
     れ以外なら‘nil’をリターンする。

 -- Function: face-underline-p face &optional frame inherit
     この関数は、フェイスFACEが非‘nil’の‘:underline’属性を指定する場合は
     、非‘nil’をリターンする。

 -- Function: face-inverse-video-p face &optional frame inherit
     この関数は、フェイスFACEが非‘nil’の‘:inverse-video’属性を指定する場
     合は、非‘nil’をリターンする。


File: elisp,  Node: Displaying Faces,  Next: Face Remapping,  Prev: Attribute Functions,  Up: Faces

37.12.4 Displaying Faces
------------------------

Emacsが与えられたテキスト断片を表示する際、そのテキストの視覚的外観は異
なるソースから描画されるフェイスにより決定されるかもしれません。これら種
々のソースが、特定の文字にいたいして複数のフェイスを指定する場合、
Emacsはそれらのさまざまなフェイスの属性をマージします。以下に、Emacsがフ
ェイスをマージする順序を優先度順に記します:

   • そのテキストが特別なグリフで構成される場合、そのグリフは特定のフェ
     イスを指定できる。*note Glyphs::を参照のこと。

   • アクティブなリージョンにテキストがある場合、Emacsは‘region’フェイス
     を使用してそれをハイライトする。*note (emacs)Standard Faces::を参照
     のこと。

   • 非‘nil’の‘face’属性をもつオーバーレイにテキストがある場合、Emacsは
     そのプロパティにより指定されるフェイス(1つ以上)を適用する。そのオー
     バーレイが‘mouse-face’プロパティをもち、マウスがそのオーバーレイに
     “十分に近い”場合、Emacsはかわりに‘mouse-face’で指定されるフェイスま
     たはフェイス属性を適用する。*note Overlay Properties::を参照のこと
     。

     1つの文字を複数のオーバーレイがカバーする場合は、高優先度のオーバー
     レイが低優先度のオーバーレイをオーバーライドする。*note Overlays::を
     参照のこと。

   • そのテキストが‘face’または‘mouse-face’プロパティを含む場合、Emacsは
     指定されたフェイスおよびフェイス属性を適用する。*note Special
     Properties::を参照のこと(これはFont Lockモードのフェイス適用方法で
     ある。*note Font Lock Mode::を参照されたい)。

   • そのテキストが選択されたウィンドウのモードラインにある場合、Emacsは
     ‘mode-line’フェイスを適用する。選択されていないウィンドウのモードラ
     インでは、Emacsは‘mode-line-inactive’フェイスを使用する。ヘッダーラ
     インにたいしては、Emacsは‘header-line’フェイスを適用する。

   • 先行ステップの間に、与えられた属性が指定されなければ、Emacsは
     ‘default’フェイスの属性を適用する。

   各ステージにおいて、フェイスが有効な‘:inherit’属性をもつ場合、Emacsは
値‘unspecified’をもつすべての属性が、親フェイス(1つ以上)由来で描画される
、対応する値をもつものとして扱います。*note Face Attributes::を参照して
ください。親フェイスでも、属性がunspecifiedのままかもしれないことに注意
してください。その場合には、フェイスマージの次レベルでも、その属性は
unspecifiedのままです。


File: elisp,  Node: Face Remapping,  Next: Face Functions,  Prev: Displaying Faces,  Up: Faces

37.12.5 Face Remapping
----------------------

変数‘face-remapping-alist’は、あるフェイスの外観のバッファーローカル、ま
たはグローバルな変更にたいして使用されます。たとえばこれは、
‘text-scale-adjust’コマンド(*note (emacs)Text Scale::を参照)の実装に使用
されています。

 -- Variable: face-remapping-alist
     この変数の値は、要素が‘(FACE . REMAPPING)’という形式をもつalistであ
     る。これによりEmacsは、フェイスFACEをもつ任意のテキストを、通常の
     FACEの定義ではなく、REMAPPINGで表示する。

     REMAPPINGには、テキストプロパティ‘face’にたいして適切な任意のフェイ
     スspec、すなわちフェイス(フェイス名または属性/値ペアーのプロパティ
     リスト)、またはフェイスのリストのいずれかを指定できる。詳細は、
     *note Special Properties::の‘face’テキストプロパティの記述を参照の
     こと。REMAPPINGはリマップされるフェイスにたいる、完全な仕様としての
     役目をもつ。これは通常のFACEを変更せずに置き換える。

     ‘face-remapping-alist’がバッファーローカルなら、そのローカル値はそ
     のバッファーでのみ効果をもつ。

     注意: フェイスのリマッピングは再帰的ではない。REMAPPINGが同じフェイ
     ス名FACEを参照する場合、直接またはREMAPPING内の他の何らかのフェイス
     の‘:inherit’属性を通じて、その参照はFACEの通常の定義を使用する。た
     とえば‘mode-line’フェイスが、‘face-remapping-alist’内の以下のエント
     リーでリマップされる場合:

          (mode-line italic mode-line)

     ‘mode-line’フェイスの新たな定義は‘italic’フェイス、および(リマップ
     されていない)_通常_の‘mode-line’フェイスの定義から継承される。

   以下の関数は、‘face-remapping-alist’にたいする高レベルなインターフェ
ースを実装します。ほとんどのLispコードは、リマッピングが他の場所に適用さ
れてしまうのを避けるために、‘face-remapping-alist’を直接セットするのでは
なく、これらの関数を使用するべきです。これらの関数はバッファーローカルな
リマッピングを意図しており、すべてが副作用として‘face-remapping-alist’を
バッファーローカルにします。これらは、以下の形式の
‘face-remapping-alist’エントリーを管理します

       (FACE RELATIVE-SPEC-1 RELATIVE-SPEC-2 ... BASE-SPEC)

上述したように、RELATIVE-SPEC-NとBASE-SPECはそれぞれ、フェイス名または属
性/値ペアーのプロパティリストです。“相対的リマッピング(relative
remapping)”エントリーRELATIVE-SPEC-Nはそれぞれ、
‘face-remap-add-relative’および‘face-remap-remove-relative’関数により管
理されます。これらはテキストサイズ変更のような、単純な変更を意図していま
す。“ベースリマッピング(base remapping)”エントリーBASE-SPECは最低の優先
度をもち、‘face-remap-set-base’および‘face-remap-reset-base’関数により管
理されます。これは、メジャーモードが制御下のバッファーでフェイスをリマッ
プするために用いることを意図しています。

 -- Function: face-remap-add-relative face &rest specs
     この関数は、カレントバッファー内のフェイスFACEにたいして、相対的リ
     マッピングとして、SPECS内にフェイスspecを追加する。残りの引数
     SPECSはフェイス名のリスト、または属性/値ペアーのプロパティリストと
     いう、いずれかの形式であること。

     リターン値は、“cookie”としての役目をもつLispオブジェクトである。後
     でそのリマッピングの削除を要する場合は、引数として
     ‘face-remap-remove-relative’にこのオブジェクトを渡すことができる。

          ;; `escape-glyph'フェイスを`highlight'と`italic'
          ;; の組み合わせにリマップ:
          (face-remap-add-relative 'escape-glyph 'highlight 'italic)

          ;; `default'フェイスのサイズを50%増加:
          (face-remap-add-relative 'default :height 1.5)

 -- Function: face-remap-remove-relative cookie
     この関数は、以前‘face-remap-add-relative’で追加された相対的リマッピ
     ングを削除する。COOKIEは、そのリマッピングが追加されたときに、
     ‘face-remap-add-relative’がリターンしたLispオブジェクトであること。

 -- Function: face-remap-set-base face &rest specs
     この関数は、カレントバッファー内のFACEのベースリマッピングを、
     SPECSにセットする。SPECSが空なら、‘face-remap-reset-base’(以下参照
     )を呼び出したように、デフォルトベースリマッピングがリストアされる。
     これは単一の値‘nil’を含むSPECSとは異なることに注意。これは逆の結果
     をもたらす(FACEのグローバル定義は無視される)。

     これは、グローバルなフェイス定義を継承した、デフォルトのBASE-SPECを
     上書きするので、必要ならそのような継承を追加するのは呼び出し側の責
     任である。

 -- Function: face-remap-reset-base face
     この関数は、FACEのベースリマッピングに、FACEのグローバル定義から継
     承した、デフォルト値にセットする。


File: elisp,  Node: Face Functions,  Next: Auto Faces,  Prev: Face Remapping,  Up: Faces

37.12.6 Functions for Working with Faces
----------------------------------------

以下はフェイスを作成および処理するための、追加の関数です。

 -- Function: face-list
     この関数は、すべての定義済みフェイス名のリストをリターンする。

 -- Function: face-id face
     この関数は、フェイスFACEの“フェイス番号(face number)”をリターンする
     。これはEmacs内の低レベルで、フェイスを一意に識別する番号である。フ
     ェイス番号によるフェイス参照を要するのは稀である。

 -- Function: face-documentation face
     この関数は、フェイスFACEのドキュメント文字列、それが指定されていな
     ければ‘nil’をリターンする。

 -- Function: face-equal face1 face2 &optional frame
     これは、フェイスFACE1とフェイスFACE2が、表示にたいして同じ属性をも
     つなら‘t’をリターンする。

 -- Function: face-differs-from-default-p face &optional frame
     これはフェイスFACEの表示がデフォルトフェイスと異なるなら、非‘nil’を
     リターンする。

   “フェイスエイリアス(face alias)”は、あるフェイスにたいして等価な名前
を提供します。エイリアスシンボルの‘face-alias’プロパティに対象となるフェ
イス名を与えることにより、フェイスエイリアスを定義できます。以下の例では
、‘mode-line’フェイスにたいするエイリアスとして、‘modeline’を作成します
。

     (put 'modeline 'face-alias 'mode-line)

 -- Macro: define-obsolete-face-alias obsolete-face current-face when
     このマクロは、CURRENT-FACEのエイリアスとして‘obsolete-face’を定義す
     るとともに、将来に削除されるかもしれないことを示すためにobsolete(時
     代遅れ)とマークする。WHENは、‘obsolete-face’がobsoleteになる時期を
     示す文字列(通常はバージョン番号文字列)であること。


File: elisp,  Node: Auto Faces,  Next: Basic Faces,  Prev: Face Functions,  Up: Faces

37.12.7 Automatic Face Assignment
---------------------------------

以下のフックは、バッファー内のテキストに自動的にフェイスを割り当てるため
に使用されます。これはJit-Lockモードの実装の一部であり、Font-Lockにより
使用されます。

 -- Variable: fontification-functions
     この変数は、再表示を行う直前に、Emacsの再表示により呼び出される関数
     のリストを保持する。これらはFont Lockが有効でないときでも呼び出され
     る。Font Lockモードが有効なら、この変数は通常は単一の関数
     ‘jit-lock-function’だけを保持する。

     関数は、バッファー位置POSを単一の引数として、リストされた順に呼び出
     される。これらは、カレントバッファー内のPOSで開始されるテキストにた
     いして、集合的にフェイスの割り当てを試みるべきである。

     関数は‘face’プロパティをセットするおとにより、割り当てるフェイスを
     記録すること。またフェイスを割り当てたすべてのテキストに、非‘nil’の
     ‘fontified’プロパティも追加するべきである。このプロパティは再表示に
     、そのテキストにたいしてそのフェイスがすでに割り当て済みであること
     を告げる。

     POSの後の文字がすでに非‘nil’の‘fontified’プロパティをもつが、フォン
     ト表示化を要さない場合に、何も行わない関数を追加するのは、おそらく
     よいアイデアである。ある関数が、前の関数による割り当てをオーバーラ
     イドする場合には、実際に問題となるのは最後の関数終了後のプロパティ
     である。

     効率化のために、通常は各呼び出しにおいて400から600前後の文字にフェ
     イスを割り当てるように、これらの関数を記述することを推奨する。


File: elisp,  Node: Basic Faces,  Next: Font Selection,  Prev: Auto Faces,  Up: Faces

37.12.8 Basic Faces
-------------------

テキストにたいしてEmacs Lispプログラムが何らかのフェイス割り当てを要する
場合は、完全に新たなフェイスを定義するより、特定の既存フェイス、またはそ
れらを継承したフェイスを使用するほうが、よいアイデアである場合がしばしば
あります。Emacsに特定の外観を与えるために別のユーザーが基本フェイス
(basic face)をカスタマイズしていても、この方法なら追加のカスタマイズなし
でプログラムは“適合”することでしょう。

   以下にEmacsが定義する基本フェイスのいくつかをリストしました。これらに
加えて、ハイライトがFont Lockモードによりまだ処理されていなかったり、い
くつかのFont Lockフェイスが使用されていなければ、構文的ハイライトのため
に、Font Lockフェイスを使うようにしたいと思うかもしれません。*note Faces
for Font Lock::を参照してください。

‘default’
     属性がすべて指定されたデフォルトフェイス。他のすべてのフェイスは、
     暗にこのフェイスを継承する。未指定(unspecified)な任意の属性は、この
     フェイスの属性をデフォルトとする(*note Face Attributes::を参照)。

‘bold’
‘italic’
‘bold-italic’
‘underline’
‘fixed-pitch’
‘variable-pitch’
     これらは、名前に示されるような属性をもち(‘bold’はboldの‘:weight’属
     性をもつ)、それ以外のすべての属性は未指定である(そのため‘default’に
     より与えられる)。

‘shadow’
     テキストの“淡色表示(dimmed out)”用。たとえばこれは、ミニバッファー
     内で無視されるファイル名部分に使用される(*note Minibuffers for File
     Names: (emacs)Minibuffer File.を参照)。

‘link’
‘link-visited’
     ユーザーを別のバッファーや“位置”へと送る、クリック可能テキストボタ
     ン用。

‘highlight’
     一時的に強調するべきテキスト範囲用。たとえば一般的に、カーソルのハ
     イライトには‘mouse-face’プロパティが割り当てられる(*note Special
     Properties::を参照)。

‘match’
     検索コマンドによりマッチしたテキスト用。

‘error’
‘warning’
‘success’
     エラー、警告、成功に関するテキスト用。たとえば‘*Compilation*’内のメ
     ッセージにたいして使用される。


File: elisp,  Node: Font Selection,  Next: Font Lookup,  Prev: Basic Faces,  Up: Faces

37.12.9 Font Selection
----------------------

Emacsがグラフィカルなディスプレイ上で文字を描画可能になる前に、まずその
文字にたいする“フォント(font)”を選択しなければなりません(1)。*note
(emacs)Fonts::を参照してください。通常、Emacsはその文字に割り当てられた
フェイス、特にフェイス属性‘:family’、‘:weight’、‘:slant’、‘:width’(*note
Face Attributes::を参照)にもとづいて、自動的にフォントを選択します。フォ
ントの選択は、表示される文字にも依存します。表示できるのは文字セットが限
定されているフォントもいくつかあります。利用可能なフォントがこの要件を完
全に満たさない場合、Emacsは“もっとも近いフォント(closest matching
font)”を探します。このセクション内の変数は、Emacsがこの選択を行う方法を
制御します。

 -- User Option: face-font-family-alternatives
     あるfamilyが指定されたが存在しない場合、この変数は試みるべき代替え
     のフォントファミリーを指定する。各要素は以下の形式をもつ:

          (FAMILY ALTERNATE-FAMILIES...)

     FAMILYが指定されたが利用できなければ、EmacsはALTERNATE-FAMILIESで与
     えられるファミリーで存在するものが見つかるまで、1つずつファミリーを
     試みる。

 -- User Option: face-font-selection-order
     希望するすべてのフェイス属性(‘:width’、‘:height’、‘:weight’、
     ‘:slant’)に完全にマッチするフォントが存在しない場合、この変数はもっ
     とも近いフォントの選択時に考慮すべき、これらの属性の順序を指定する
     。値はこれらの属性シンボルを重要度降順で含むリストであること。デフ
     ォルトは‘(:width :height :weight :slant)’。

     フォント選択はまず、このリスト内の最初の属性にたいして利用可能な最
     適マッチを探す。その後、この方法で最適なフォントの中から、2つ目の属
     性にたいして最適なマッチを検索、...のように選択を行う。

     属性‘:weight’および‘:width’は、‘normal’を中心とする範囲のような、シ
     ンボリック値をもつ。より極端(‘normal’から離れた)なマッチは、より極
     端ではない(‘normal’に近い)マッチより、幾分優先される。これは、可能
     なかぎり非normalなフェイスが、normalなフェイスとは対照的になること
     を保証するようにデザインされている。

     この変数が違いを生むケースの例は、デフォルトフォントに等価なイタリ
     ックがない場合である。デフォルトの順では、‘italic’フェイスは、デフ
     ォルトのフォントに類似した非イタリックのフォントを使用するだろう。
     しかし‘:height’の前に‘:slant’を置くと、‘italic’フェイスはたとえ
     heightが同じでなくとも、イタリックフォントを使用するだろう。

 -- User Option: face-font-registry-alternatives
     この変数は、registryが指定されたがそれが存在しない場合に試みるべき
     、代替えのフォントレジストリーを指定する。各要素は以下の形式をもつ:

          (REGISTRY ALTERNATE-REGISTRIES...)

     REGISTRYが指定されたが利用できなければ、Emacsは
     ALTERNATE-REGISTRIES内で存在するレジストリーが見つかるまで、他のレ
     ジストリーを1つずつ試みる。

   Emacsがスケーラブルフォントを使用するようにできますが、デフォルトでは
それらを使用しないようになっています。

 -- User Option: scalable-fonts-allowed
     この変数は、どのスケーラブルフォントを使用するかを制御する。値
     ‘nil’(デフォルト)は、スケーラブルフォントを使用しないことを意味する
     。‘t’はそのテキストにたいして適切と思われる、任意のスケーラブルフォ
     ントを使用することを意味する。

     それ以外なら、値は正規表現のリストであること。その場合、名前がこの
     リスト内の正規表現にマッチする、任意のスケーラブルフォントの使用が
     有効になる。たとえば、

          (setq scalable-fonts-allowed '("iso10646-1$"))

     これは、レジストリーが‘iso10646-1’のようなスケーラブルフォントの使
     用を可能にする。

 -- Variable: face-font-rescale-alist
     この変数は、特定のフォントにたいするスケーリングを指定する。値は、
     以下の形式の要素をもつリストであること

          (FONTNAME-REGEXP . SCALE-FACTOR)

     使用しようとするフォントの名前がFONTNAME-REGEXPにマッチする場合、こ
     れはファクターSCALE-FACTORに対応した、同様な大きさのフォントの選択
     を指示する。特定のフォントが提示する通常のheightやwidthが大きい、ま
     たは小さい場合に、フォントサイズを正規化するためにこの機能を使用で
     きるだろう。

   ---------- Footnotes ----------

   (1) このコンテキストでは、用語“font”はFont Lock(*note Font Lock
Mode::を参照)にたいして何も行いません。


File: elisp,  Node: Font Lookup,  Next: Fontsets,  Prev: Font Selection,  Up: Faces

37.12.10 Looking Up Fonts
-------------------------

 -- Function: x-list-fonts name &optional reference-face frame maximum
          width
     この関数は、NAMEにマッチする利用可能なフォント名のリストをリターン
     する。NAMEはFontconfig、GTK、またはXLFDのいずれかのフォーマットによ
     るフォント名を含む文字列であること(*note (emacs)Fonts::を参照)。
     XLFD文字列では、ワイルドカード文字が使用できる。‘*’文字は任意の部分
     文字列、‘?’は任意の単一文字にマッチする。フォント名のマッチングでは
     、大文字小文字の違いは無視される。

     オプション引数REFERENCE-FACEおよびFRAMEが指定された場合は、リターン
     されるリストにはその時点でフレームFRAME上でのREFERENCE-FACE(フェイ
     ス名)と同じサイズのフォントだけが含まれる。

     オプション引数MAXIMUMは、リターンされるフォント数の制限をセットする
     。これが非‘nil’なら、リターン値は最初にマッチしたMAXIMUM個のフォン
     トの後が切り捨てられる。MAXIMUMに小さい値を指定すれば、そのパターン
     に多くのフォントがマッチするような場合に、この関数をより高速にでき
     る。

     オプション引数WIDTHは、希望するフォントの幅を指定する。これが非
     ‘nil’なら、この関数は文字の幅(平均)が、REFERENCE-FACEのWIDTH倍の幅
     であるようなフォントだけをリターンする。

 -- Function: x-family-fonts &optional family frame
     この関数は、FRAME上のファミリーFAMILYにたいして利用可能なフォントを
     記述するリストをリターンする。FAMILYが省略または‘nil’なら、このリス
     トはすべてのファミリーに適用され、すなわち利用可能なすべてのフォン
     トを含む。それ以外なら、FAMILYは文字列であること。これにはワイルド
     カード‘?’と‘*’を含めることができる。

     このリストは、FRAMEのあるディスプレイを記述する。FRAMEが省略または
     ‘nil’なら、これは選択されたフレームのディスプレイに適用される(*note
     Input Focus::を参照)。

     このリスト内の各要素は、以下の形式のベクターであること:

          [FAMILY WIDTH POINT-SIZE WEIGHT SLANT
           FIXED-P FULL REGISTRY-AND-ENCODING]

     最初の5つの要素はフェイス属性に対応する。あるフェイスにたいしてこれ
     らの属性を指定した場合は、このフォントが使用されるだろう。

     最後の3つの要素は、そのフォントに関する追加の情報を与える。そのフォ
     ントが固定ピッチ(fixed-pitch)でなければ、FIXED-Pは非‘nil’である。
     FULLはそのフォントのフルネーム、REGISTRY-AND-ENCODINGはそのフォント
     のレジストリーとエンコーディングを与える。


File: elisp,  Node: Fontsets,  Next: Low-Level Font,  Prev: Font Lookup,  Up: Faces

37.12.11 Fontsets
-----------------

“フォントセット(fontset)”とは、それぞれが文字コードの範囲に割り当てられ
る、フォントのリストのことです。個々のフォントでは、Emacsがサポートする
文字の全範囲を表示できませんが、フォントセットであれば表示することができ
ます。フォントのようにフォントセットは名前をもつことができ、フレームやフ
ェイスにたいして“フォント”を指定する際、フォント名としてフォントセット名
を使用できます。以下は、Lispプログラム制御下でのフォントセット定義に関す
る情報です。

 -- Function: create-fontset-from-fontset-spec fontset-spec &optional
          style-variant-p noerror
     この関数は、仕様文字列FONTSET-SPECに応じて、新たなフォントセットを
     定義する。この文字列は以下のような形式であること:

          FONTPATTERN, [CHARSET:FONT]...

     カンマの前後の空白文字は無視される。

     この文字列の最初の部分FONTPATTERNは、最後の2つのフィールドが
     ‘fontset-ALIAS’であることを除外して、標準Xフォント名形式をもつこと
     。

     新たなフォントセットはlong名とshort名という、2つの名前をもつ。
     long名は、それ全体がFONTPATTERNであり、short名は‘fontset-ALIAS’であ
     る。いずれの名前でもこのフォントセットを参照できる。同じ名前がすで
     に存在するフォントセットでは、NOERRORが‘nil’ならエラーがシグナルさ
     れ、NOERRORが非‘nil’ならこの関数は何も行わない。

     オプション引数STYLE-VARIANT-Pが非‘nil’なら、そのフォントセットの
     bold、italic、およびbold-italicも同様に作成するよう指示する。これら
     の変種フォントセットはshort名をもたず、bold、および/またはitalicを
     示すようにFONTPATTERNを変更して作成したlong名だけをもつ。

     仕様文字列は、そのフォントセット内でどのフォントを使用するかも宣言
     する。詳細は以下を参照。

   構成‘CHARSET:FONT’は、ある特定の文字セットにたいして、(このフォントセ
ット内の)どのフォントを使用するかを指定します。ここでCHARSETは文字セット
の名前、FONTはその文字セットにたいして使用するフォントです。仕様文字列内
で、この構成を任意の回数使用できます。

   明示的に指定しなかった残りの文字セットにたいして、Emacsは
FONTPATTERNにもとづきフォントを選択します。これは‘fontset-ALIAS’を、その
文字セットを命名する値に置き換えます。文字セットASCIIにたいしては、
‘fontset-ALIAS’は‘ISO8859-1’に置き換えられます。

   加えて、後続の複数フィールドがワイルドカードなら、Emacsはそれらを1つ
のワイルドカードにまとめます。これは自動スケールフォント(auto-scaled
fonts)の使用を防ぐためです。フォントを大きくスケーリングすることにより作
成されたフォントは編集に使用できず、小さくスケーリングされたフォントは、
それ自身のサイズがより小さいフォントを使用する(Emacsが行う方法)ほうがよ
いので、有用ではありません。

   つまり、以下のようなFONTPATTERNなら

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCIIにたいするフォントspecは、以下のようになるでしょう:

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また、Chinese GB2312文字にたいするフォントspecは、以下のようになるでしょ
う:

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

   上記のフォントspecにマッチするChineseフォントをもっていないかもしれま
せん。ほとんどのXディストリビューションには、FAMILYフィールドに‘song
ti’か‘fangsong ti’をもつChineseフォントだけが含まれます。そのような場合
には、以下のように‘Fontset-N’を指定できます:

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

この場合、Chinese GB2312以外のすべての文にたいするフォントspecはFAMILYフ
ィールドに‘fixed’をもち、Chinese GB2312にたいするフォントspecはFAMILYフ
ィールドにワイルドカード‘*’をもちます。

 -- Function: set-fontset-font name character font-spec &optional frame
          add
     この関数は、文字CHARACTERにたいして、FONT-SPECのフォントマッチング
     を使用するよう、既存のフォントセットNAMEを変更する。

     NAMEが‘nil’なら、この関数はFRAMEのフォントセット、FRAMEが‘nil’なら
     選択されたフレームのフォントセットを変更する。

     NAMEが‘t’なら、この関数はshort名が‘fontset-default’であるような、デ
     フォルトフォントセットを変更する。

     CHARACTERには‘(FROM . TO)’のようなコンスを指定できる。ここでFROMと
     TOは文字コードポイントである。この場合、範囲FROMからTO(両端を含む
     )までのすべての文字にたいして、FONT-SPECを使用する。

     CHARACTERには文字セットも指定できる。この場合は、その文字セット内の
     すべての文字にたいして、FONT-SPECを使用する。

     CHARACTERにはスクリプト名も指定できる。この場合は、その文字セット内
     のすべての文字にたいして、FONT-SPECを使用する。

     FONT-SPECにはコンス‘(FAMILY . REGISTRY)’を指定できる。ここで
     FAMILYはフォントのファミリー名(先頭にfoundry名が含まれるかもしれな
     い)、REGISTRYはフォントのレジストリー名(末尾にエンコーディング名が
     含まれるかもしれない)である。

     FONT-SPECには、フォント名文字列も指定できる。

     オプション引数ADDが非‘nil’なら、以前セットされたフォントspecに
     FONT-SPECを追加する方法を指定する。‘prepend’ならFONT-SPECは先頭に、
     ‘append’ならFONT-SPECは末尾に追加される。デフォルトでは、
     FONT-SPECは以前のセッティングをオーバーライドする。

     たとえば、以下は文字セット‘japanese-jisx0208’に属するすえての文字に
     たいして、ファミリー名が‘Kochi Gothic’であるようなフォントを使用す
     るように、デフォルトフォントセットを変更する。

          (set-fontset-font t 'japanese-jisx0208
                            (font-spec :family "Kochi Gothic"))

 -- Function: char-displayable-p char
     この関数は、EmacsがCHARを表示できるべきなら、‘t’をリターンする。よ
     り正確には、選択されたフレームのフォントセットが、CHARが属する文字
     セットを表示するためのフォントをもつ場合は、‘t’をリターンする。

     フォントセットは、文字単位でフォントを指定できる。フォントセットが
     これを行う場合、この関数の値は正確ではないかもしれない。


File: elisp,  Node: Low-Level Font,  Prev: Fontsets,  Up: Faces

37.12.12 Low-Level Font Representation
--------------------------------------

通常は、フォントを直接扱う必要はありません。これを行う必要がある場合には
、このセクションでその方法を説明します。

   Emacs Lispでは、フォントは“フォントオブジェクト(font objects)”、“フォ
ントspec(font specs)”、“フォントエンティティー(font entities)”という、
3つの異なるLispオブジェクトを使用して表現されます。

 -- Function: fontp object &optional type
     OBJECTがフォントオブジェクト、フォントspec、フォントエンティティー
     なら‘t’、それ以外なら‘nil’をリターンする。

     オプション引数TYPEが非‘nil’なら、チェックするLispオブジェクトの正確
     なタイプを決定する。この場合、TYPEは‘font-object’、‘font-spec’、
     ‘font-entity’のいずれかであること。

   フォントオブジェクトは、Emacsが“オープンした”フォントを表します。
Lispでフォントオブジェクトは変更できませんが、調べることはできます。

 -- Function: font-at position &optional window string
     ウィンドウWINDOW内の位置POSITIONにある文字を表示するために使用され
     ている、フォントオブジェクトをリターンする。WINDOWが‘nil’の場合のデ
     フォルトは、選択されたウィンドウである。STRINGが‘nil’なら、
     POSITIONはカレントバッファー内の位置を指定する。それ以外なら、
     STRINGは文字列で、POSITIONはその文字列内での位置を指定すること。

   フォントspecは、フォントを探すために使用できる仕様セットを含むLispオ
ブジェクトです。フォントspec内の仕様にたいして、1つ以上のフォントがマッ
チすることができます。

 -- Function: font-spec &rest arguments
     ARGUMENTS内の仕様を使用して、新たなフォントspecをリターンする。これ
     は‘property’-‘value’のペアーであること。可能な仕様は以下のとおり:

     ‘:name’
          XLFD、Fontconfig、GTKいずれかのフォーマットによるフォント名(文
          字列)。*note (emacs)Fonts::を参照のこと。

     ‘:family’
     ‘:foundry’
     ‘:weight’
     ‘:slant’
     ‘:width’
          これらは、同名のフェイス属性と同じ意味をもつ。*note Face
          Attributes::を参照のこと。

     ‘:size’
          フォントサイズ。非負の整数はピクセル単位、浮動小数点数ならポイ
          ントサイズを指定する。

     ‘:adstyle’
          ‘sans’のように、そのフォントにたいするタイポグラフィックスタイ
          ル(typographic style)の追加情報。値は文字列またはシンボルであ
          ること。

     ‘:registry’
          ‘iso8859-1’のような、フォントの文字セットレジストリーとエンコ
          ーディング。値は文字列またはシンボルであること。

     ‘:script’
          そのフォントがサポートしなければならないスクリプト(シンボル)。

     ‘:otf’
          Emacsが‘libotf’サポートつきでコンパイルされている場合、そのフ
          ォントはそれらのOpenType機能をサポートする、OpenTypeフォントで
          なければならない。値は以下の形式のリストでなければならない

               (SCRIPT-TAG LANGSYS-TAG GSUB GPOS)

          ここでSCRIPT-TAGはOpenTypeスクリプトタグシンボル、
          LANGSYS-TAGはOpenType言語システムタグシンボル(‘nil’ならデフォ
          ルト言語システムを使用)、‘gsub’はOpenType GSUB機能タグシンボル
          (何も要求されない場合は‘nil’)、‘gpos’はOpenType GPOS機能タグシ
          ンボルのリスト(何も要求されない場合は‘nil’)である。‘gsub’また
          は‘gpos’がリストなら、そのリスト内の‘nil’要素は、そのフォント
          が残りすべてのタグシンボルにマッチしてはならないことを意味する
          。‘gpos’は省略することができる。

 -- Function: font-put font-spec property value
     フォントspec FONT-SPEC内のプロパティPROPERTYに、VALUEをセットする。

   フォントエンティティーは、オープンする必要がないフォントへの参照です
。フォントオブジェクトとフォントspecの中間的な性質をもち、フォントspecと
は異なり、フォントオブジェクトと同様、単一かつ特定のフォントを参照します
。フォントオブジェクトとは異なり、フォントエンティティーの作成では、その
フォントのコンテンツはコンピューターへのメモリーにロードされません。
Emacsは、スケーラブルフォントを参照するために単一のフォントエンティティ
ーから、複数の異なるサイズのフォントオブジェクトをオープンするかもしれま
せん。

 -- Function: find-font font-spec &optional frame
     この関数は、フレームFRAME上のフォントspec FONT-SPECにもっともマッチ
     するフォントエンティティーをリターンする。FRAMEが‘nil’の場合のデフ
     ォルトは、選択されたフレームである。

 -- Function: list-fonts font-spec &optional frame num prefer
     この関数は、フォントspec FONT-SPECにマッチする、すべてのフォントエ
     ンティティーのリストをリターンする。

     オプション引数FRAMEが非‘nil’なら、そのフォントが表示されるフレーム
     を指定する。オプション引数NUMが非‘nil’なら、それはリターンされるリ
     ストの最大長を指定する整数だること。オプション引数PREFERが非‘nil’な
     ら、それはリターンされるリスト順を制御するために使用する、別のフォ
     ントspecであること。リターンされるフォントspecはそのフォントspecに
     “もっとも近い”降順にソートされて格納される。

   ‘:font’属性の値としてフォントspec、フォントエンティティー、フォント名
文字列を渡して‘set-face-attribute’を呼び出すと、Emacsは表示に利用できる
もっとも“マッチする”フォントをオープンします。そして。そのフェイスにたい
する‘:font’属性の実際の値として、対応するフォントオブジェクトを格納しま
す。

   以下の関数は、フォントに関する情報を取得するために使用できます。これ
らの関数のFONT引数にはフォントオブジェクト、フォントエンティティー、また
はフォントspecを指定できます。

 -- Function: font-get font property
     この関数は、FONTにたいするフォントプロパティPROPERTYの値をリターン
     する。

     FONTがフォントspecで、そのフォントspecがPROPERTYを指定しなければ、
     リターン値は‘nil’である。FONTがフォントオブジェクト、またはフォント
     エンティティーなら、:SCRIPTプロパティにたいする値は、そのフォントが
     サポートするスクリプトのリストかもしれない。

 -- Function: font-face-attributes font &optional frame
     この関数は、FONTに対応するフェイス属性のリストをリターンする。オプ
     ション引数FRAMEは、そのフォントが表示されるフレームを指定する。これ
     が‘nil’なら、選択されたフレームが使用される。リターン値は以下の形式
     である

          (:family FAMILY :height HEIGHT :weight WEIGHT
             :slant SLANT :width WIDTH)

     ここでFAMILY、HEIGHT、WEIGHT、SLANT、WIDTHの値は、フェイス属性の値
     である。FONTにより指定されない場合いくつかのキー/属性ペアーは、この
     リストから省略されるかもしれない。

 -- Function: font-xlfd-name font &optional fold-wildcards
     この関数は、FONTにマッチするXLFD((X Logical Font Descriptor))を文字
     列としてリターンする。XLFDに関する情報は、*note (emacs)Fonts::を参
     照のこと。その名前がXLFD(最大255文字を含むことが可能)にたいして長す
     ぎる場合、この関数は‘nil’をリターンする。

     オプション引数FOLD-WILDCARDSが非‘nil’なら、連続するワイルドカードは
     1つにまとめられる。


File: elisp,  Node: Fringes,  Next: Scroll Bars,  Prev: Faces,  Up: Display

37.13 Fringes
=============

グラフィカルなディスプレイでは、Emacsは各ウィンドウの隣に“フリンジ
(fringes)”を描画します。これは切り詰め(truncation)、継続(continuation)、
水平スクロールを示すビットマップを表示できる、側面の細い垂直ストリップで
す。

* Menu:

* Fringe Size/Pos::          ウィンドウフリンジを置く場所を指定する。
* Fringe Indicators::        ウィンドウフリンジ内にインジケーターアイコンを表示する。
* Fringe Cursors::           右フリンジ内にカーソルを表示する。
* Fringe Bitmaps::           フリンジインジケーターにたいしてビットマップを指定する。
* Customizing Bitmaps::      フリンジ内で使用する独自ビットマップの指定。
* Overlay Arrow::            位置を示す矢印の表示。


File: elisp,  Node: Fringe Size/Pos,  Next: Fringe Indicators,  Up: Fringes

37.13.1 Fringe Size and Position
--------------------------------

以下のバッファーローカル変数は、そのバッファーを表示するウィンドウのフリ
ンジの位置と幅を制御します。

 -- Variable: fringes-outside-margins
     フリンジは通常、ディスプレイマージンとウィンドウテキストの間に表示
     される。この値が非‘nil’なら、フリンジはディスプレイマージンの外側に
     表示される。*note Display Margins::を参照のこと。

 -- Variable: left-fringe-width
     この変数が非‘nil’なら、それは左フリンジの幅をピクセル単位で指定する
     。値‘nil’は、そのウィンドウのフレームの左フリンジ幅を使用することを
     意味する。

 -- Variable: right-fringe-width
     この変数が非‘nil’なら、それは右フリンジの幅をピクセル単位で指定する
     。値‘nil’は、そのウィンドウのフレームの右フリンジ幅を使用することを
     意味する。

   これらの変数にたいして値を指定しないすべてのバッファーは、フレームパ
ラメーター‘left-fringe’および‘right-fringe’で指定された値を使用します
(*note Layout Parameters::を参照)。

   上記の変数は、サブルーチンとして‘set-window-fringes’を呼び出す、関数
‘set-window-buffer’(*note Buffers and Windows::を参照)を通じて実際に効果
をもちます。これらの変数のいずれかを変更しても、影響を受ける各ウィンドウ
で‘set-window-buffer’を呼び出さなければ、そのバッファーを表示する既存の
ウィンドウのフリンジ表示は更新されません。個別のウィンドウでのフリンジ表
示を制御するために、‘set-window-fringes’を使用することもできます。

 -- Function: set-window-fringes window left &optional right
          outside-margins
     この関数は、ウィンドウWINDOWのフリンジ幅をセットする。WINDOWが
     ‘nil’なら、選択されたウィンドウが使用される。

     引数LEFTは左フリンジ、同様にRIGHTは右フリンジにたいして、ピクセル単
     位で幅を指定する。いずれかにたいする値‘nil’は、デフォルトの幅を意味
     する。OUTSIDE-MARGINSが非‘nil’なら、フリンジをディスプレイマージン
     の外側に表示することを指定する。

 -- Function: window-fringes &optional window
     この関数は、ウィンドウWINDOWのフリンジに関する情報をリターンする。
     WINDOWが省略または‘nil’なら、選択されたウィンドウが使用される。値は
     ‘(LEFT-WIDTH RIGHT-WIDTH OUTSIDE-MARGINS)’の形式をもつ。


File: elisp,  Node: Fringe Indicators,  Next: Fringe Cursors,  Prev: Fringe Size/Pos,  Up: Fringes

37.13.2 Fringe Indicators
-------------------------

“フリンジインジケーター(Fringe indicators)”は、行の切り詰めや継続、バッ
ファー境界などを示す、ウィンドウフリンジ内に表示される小さいアイコンのこ
とです。

 -- User Option: indicate-empty-lines
     これが非‘nil’なら、Emacsはグラフィカルなディスプレイ上で、バッファ
     ー終端にある空行それぞれにたいして、フリンジ内に特別なグリフを表示
     する。*note Fringes::を参照のこと。この変数はすべてのバッファーにお
     いて、自動的にバッファーローカルになる。

 -- User Option: indicate-buffer-boundaries
     このバッファーローカル変数は、ウィンドウフリンジ内でバッファー境界
     とウィンドウのスクロールを示す方法を制御する。

     Emacsはバッファー境界(そのバッファーの最初の行と最後の行)がスクリー
     ン上に表示された際、それを三角アイコン(angle icon)で示すことができ
     る。加えて、スクリーンより上にテキストが存在する場合は上矢印
     (up-arrow)、スクリーンの下にテキストが存在する場合は下矢印
     (down-arrow)をフリンジ内に表示して、それを示すことができる。

     基本的な値として3つの値がある:

     ‘nil’
          これらのフリンジアイコンを何も表示しない。
     ‘left’
          左フリンジに三角アイコンと矢印を表示する。
     ‘right’
          右フリンジに三角アイコンと矢印を表示する。
     その他の非alist
          左フリンジに三角アイコンを表示して、矢印を表示しない。

     値がそれ以外なら、どのフリンジインジケーターをどこに表示するかを指
     定する、alistであること。alistの各要素は、‘(INDICATOR . POSITION)’の
     ような形式をもつ。ここでINDICATORは‘top’、‘bottom’、‘up’、‘down’、
     または‘t’(指定されていないすべてのアイコンをカバーする)のいずれかで
     あり、POSITIONは‘left’、‘right’、または‘nil’のいずれかである。

     たとえば‘((top . left) (t . right))’は左フリンジにtop angleビットマ
     ップを、右フリンジにbottom angleビットマップと両arrowビットマップを
     配置する。左フリンジにangleビットマップを表示してarrowビットマップ
     を表示しないようにするには、‘((top . left) (bottom . left))’を使用
     する。

 -- Variable: fringe-indicator-alist
     このバッファーローカル変数は、論理的ロジカルフリンジインジケーター
     から、ウィンドウフリンジ内に実際に表示されるビットマップへのマッピ
     ングを指定する。値は‘(INDICATOR . BITMAPS)’のような要素をもつ
     alistである。ここでINDICATORは論理的インジケータータイプ、BITMAPSは
     そのインジケーターに使用するフリンジビットマップを指定する。

     INDICATORはそれぞれ、以下のシンボルのいずれかであること:

     ‘truncation’, ‘continuation’.
          行の切り詰めと継続に使用される。

     ‘up’, ‘down’, ‘top’, ‘bottom’, ‘top-bottom’
          ‘indicate-buffer-boundaries’が非‘nil’の際に使用される。‘up’お
          よび‘down’は、そのウィンドウ端より上または下にあるバッファー境
          界を示す。‘top’および‘bottom’はバッファーの最上端または最下端
          のテキスト行を示す。‘top-bottom’はバッファー内にテキスト行1行
          だけが存在することを示す。

     ‘empty-line’
          ‘indicate-empty-lines’が非‘nil’の際に、空行を示すために使用さ
          れる。

     ‘overlay-arrow’
          オーバーレイ矢印に使用される(*note Overlay Arrow::を参照)。

     各BITMAPSの値には、シンボルのリスト‘(LEFT RIGHT [LEFT1 RIGHT1])’を
     指定できる。シンボルLEFTとRIGHTは、特定のインジケーターにたいして左
     、および/または右フリンジに表示するビットマップを指定する。LEFT1と
     RIGHT1は、インジケーター‘bottom’と‘top-bottom’に固有であり、最後の
     改行をもたない最後のテキスト行を示すために使用される。かわりに、
     BITMAPSに左フリンジと右フリンジの両方で使用される、単一のシンボルを
     指定することもできる。

     標準のビットマップシンボルのリストと、自身で定義する方法については
     、*note Fringe Bitmaps::を参照のこと。加えて、‘nil’は空ビットマップ
     (表示されないインジケーター)を表す。

     ‘fringe-indicator-alist’がバッファーローカルな値をもち、論理的イン
     ジケーターにたいしてビットマップが定義されていない、またはビットマ
     ップが‘t’ならば、‘fringe-indicator-alist’のデフォルト値から、対応す
     る値が使用される。


File: elisp,  Node: Fringe Cursors,  Next: Fringe Bitmaps,  Prev: Fringe Indicators,  Up: Fringes

37.13.3 Fringe Cursors
----------------------

ある行がウィンドウと正確に同じ幅なとき、2行を使用するかわりにEmacsは右フ
リンジ内にカーソルを表示します。フリンジ内のカーソルを表すために使用され
るビットマップの違いは、カレントバッファーのカーソルタイプに依存します。

 -- User Option: overflow-newline-into-fringe
     これが非‘nil’なら、ウィンドウと正確に同じ幅の(最後の改行文字に継続
     されない)行は、継続されない。ポイントが行端に達した際は、かわりにカ
     ーソルは右フリンジに表示される。

 -- Variable: fringe-cursor-alist
     この変数は、論理的カーソルタイプから、右フリンジ内に実際に表示され
     るフリンジビットマップへのマッピングを指定する。値は、各要素が
     ‘(CURSOR-TYPE . BITMAP)’のような形式をもつようなalistである。ここで
     BITMAPは使用するフリンジビットマップ、CURSOR-TYPEは表示するカーソル
     タイプである。

     CURSOR-TYPEはそれぞれ‘box’、‘hollow’、‘bar’、‘hbar’、
     ‘hollow-small’のいずれかであること。最初の4つはフレームパラメーター
     ‘cursor-type’の場合と同じ意味をもつ(*note Cursor Parameters::を参照
     )。‘hollow-small’タイプは、特定のディスプレイ行にたいして通常の
     ‘hollow-rectangle’が高すぎる際に、‘hollow’のかわりに使用される。

     BITMAPはそれぞれ、その論理的カーソルタイプにたいして表示される、フ
     リンジビットマップを指定するシンボルであること。 詳細は、*note
     Fringe Bitmaps::を参照のこと。

     ‘fringe-cursor-alist’がバッファーローカルな値をもち、カーソルタイプ
     にたいして定義されたビットマップが存在しなければ、
     ‘fringes-indicator-alist’のデフォルト値の、対応する値が使用される。


File: elisp,  Node: Fringe Bitmaps,  Next: Customizing Bitmaps,  Prev: Fringe Cursors,  Up: Fringes

37.13.4 Fringe Bitmaps
----------------------

“フリンジビットマップ(fringe bitmaps)”は、行の切り詰めや継続、バッファー
境界、オーバーレイ矢印等にたいする論理的フリンジインジケーターを表現する
、実際のビットマップです。それぞれのビットマップはシンボルにより表されま
す。 これらのシンボルは、フリンジインジケーターからビットマップへのマッ
ピングを行う変数‘fringe-indicator-alist’(*note Fringe Indicators::を参照
)、およびフリンジカーソルからビットマップへのマッピングを行う変数
‘fringe-cursor-alist’(*note Fringe Cursors::を参照)により参照されます。

   Lispプログラムも、その行内に出現する文字の1つに‘display’プロパティを
使用することにより、左フリンジまたは右フリンジ内に、ビットマップを直接表
示することができます。そのような表示指定は、以下の形式をもちます

     (FRINGE BITMAP [FACE])

FRINGEは、‘left-fringe’か‘right-fringe’いずれかのシンボルです。BITMAPは
表示するビットマップを識別するシンボルです。オプションのFACEは、そのフォ
アグラウンドカラーをビットマップの表示に使用するフェイスの名前です。この
フェイスは、自動的に‘fringe’フェイスにマージされます。

   以下はEmacsが定義する、標準的なフリンジビットマップと、
(‘fringe-indicator-alist’および‘fringe-cursor-alist’を通じて)Emacs内で現
在それらが使用される方法のリストです。

‘left-arrow’, ‘right-arrow’
     切り詰められた行を示すために使用される。

‘left-curly-arrow’, ‘right-curly-arrow’
     継続された行を示すために使用される。

‘right-triangle’, ‘left-triangle’
     前者はオーバーレイ矢印により使用され、後者は使用されない。

‘up-arrow’, ‘down-arrow’, ‘top-left-angle’ ‘top-right-angle’
‘bottom-left-angle’, ‘bottom-right-angle’
‘top-right-angle’, ‘top-left-angle’
‘left-bracket’, ‘right-bracket’, ‘top-right-angle’, ‘top-left-angle’
     バッファー境界を示すために使用される。

‘filled-rectangle’, ‘hollow-rectangle’
‘filled-square’, ‘hollow-square’
‘vertical-bar’, ‘horizontal-bar’
     フリンジカーソルの異なるタイプにたいして使用される。

‘empty-line’, ‘exclamation-mark’, ‘question-mark’, ‘exclamation-mark’
     Emacsの中核機能では使用されない。

次のサブセクションでは、フリンジビットマップを独自に定義する方法を説明し
ます。

 -- Function: fringe-bitmaps-at-pos &optional pos window
     この関数は、、ウィンドウWINDOW内の位置POSを含むディスプレイ行の、フ
     リンジビットマップをリターンする。リターン値は‘(LEFT RIGHT OV)’とい
     う形式をもつ。ここでLEFTは左フリンジ内のフリンジビットマップにたい
     するシンボル(ビットマップなしなら‘nil’)、RIGHTは同様に右フリンジに
     たいして、OVが非‘nil’なら左ふりんじ にオーバーレイ矢印が存在するこ
     とを意味する。

     WINDOW内でPOSが可視でなければ、値は‘nil’となる。WINDOWが‘nil’なら、
     それは選択されたウィンドウを意味する。POSが‘nil’なら、それは
     WINDOW内のポイントの値を意味する。


File: elisp,  Node: Customizing Bitmaps,  Next: Overlay Arrow,  Prev: Fringe Bitmaps,  Up: Fringes

37.13.5 Customizing Fringe Bitmaps
----------------------------------

 -- Function: define-fringe-bitmap bitmap bits &optional height width
          align
     この関数は、シンボルBITMAPを新たなフリンジビットマップとして定義、
     またはその名前の既存のビットマップを置き換える。

     引数BITSは、使用するイメージを指定する。これは、各要素(整数)が対応
     するビットマップの1行を指定する、文字列または整数ベクターであること
     。整数の各ビットはそのビットマップの1ピクセルに対応し、低位ビットは
     そのビットマップの最右ピクセルに対応する。

     高さは通常、BITSの長さである。しかし非‘nil’のHEIGHTにより、異なる高
     さを指定できる。幅は通常は8だが、非‘nil’のWIDTHにより、異なる幅を指
     定できる。widthは、1から16の整数でなければならない。

     引数ALIGNは、そのビットマップが使用される行範囲に相対的な、ビットマ
     ップの位置を指定する。デフォルトは、そのビットマップの中央である。
     指定できる値は‘top’、‘center’、‘bottom’。

     ALIGN引数にはリスト‘(ALIGN PERIODIC)’も指定でき、ALIGNは上述のよう
     に解釈される。PERIODICが非‘nil’なら、それは‘bits’内の行が指定される
     高さに達するのに十分な回数繰り返されるべきであることを指定する。

 -- Function: destroy-fringe-bitmap bitmap
     この関数は、BITMAPにより識別されるフリンジビットマップを破棄する。
     BITMAPが標準フリンジビットマップを識別する場合は、それを完全に消去
     するかわりに、実際はそのビットマップの標準定義をリストアする。

 -- Function: set-fringe-bitmap-face bitmap &optional face
     これはフリンジビットマップBITMAPにたいするフェイスに、FACEをセット
     する。FACEが‘nil’なら、‘fringe’フェイスを選択する。ビットマップのフ
     ェイスは、それを描画するカラーを制御する。

     FACEは‘fringe’にマージされるため、通常FACEはフォアグラウンドカラー
     だけを指定すること。


File: elisp,  Node: Overlay Arrow,  Prev: Customizing Bitmaps,  Up: Fringes

37.13.6 The Overlay Arrow
-------------------------

“オーバーレイ矢印(overlay arrow)”は、バッファー内の特定の行にたいして、
ユーザーに注意を促すために有用です。たとえば、デバッガーでのインターフェ
ースに使用されるモードでは、オーバーレイ矢印は実行されているコード行を示
します。この機能は“オーバーレイ(overlays)”にたいして、何も行いません
(*note Overlays::を参照)。

 -- Variable: overlay-arrow-string
     この変数は、特定の行にたいして注意を喚起するために表示する文字列、
     または矢印機能が使用されていなければ‘nil’を保持する。グラフィカルな
     ディスプレイでは、この文字列のコンテンツは無視され、かわりにフリン
     ジ領域からディスプレイ領域左側にグリフが表示される。

 -- Variable: overlay-arrow-position
     この変数は、オーバーレイ矢印を表示する箇所を示すマーカーを保持する
     。これは行の先頭となるポイントであること。非グラフィカルなディスプ
     レイでは、その行の先頭に矢印テキストが表示され、矢印テキストが表示
     されないときに表示されるべきテキストがオーバーレイされる。その矢印
     は通常は短く、行は普通はインデントで開始されるので、通常は上書きが
     問題となることはない。

     オーバーレイ矢印の文字列は、そのバッファーの
     ‘overlay-arrow-position’の値が、そのバッファー内を指す場合は、与え
     られた任意のバッファーで表示される。したがって、
     ‘overlay-arrow-position’のバッファーローカルなバインディングを作成
     することにより、複数のオーバーレイ矢印の表示が可能である。しかしこ
     れを達成するためには、‘overlay-arrow-variable-list’を使用するほうが
     、通常はより明快である。

   ‘before-string’プロパティをもつオーバーレイを作成することにより、同様
のことを行うことができます。*note Overlay Properties::を参照してください
。

   変数‘overlay-arrow-variable-list’を通じて、複数のオーバーレイ矢印を定
義できます。

 -- Variable: overlay-arrow-variable-list
     この変数の値は、それぞれがオーバーレイ矢印の位置を指定する、変数の
     リストである。変数‘overlay-arrow-position’はこのリスト上にあるため
     、通常の意味をもつ。

   このリスト上の各変数は、対応するオーバーレイ矢印位置に表示するための
、オーバーレイ矢印文字列を指定する‘overlay-arrow-string’プロパティ(テキ
スト端末用)、およびフリンジビットマップを指定する
‘overlay-arrow-bitmap’プロパティ(グラフィカル端末用)をもつことができます
。これらのプロパティがセットされていなければ、デフォルトのフリンジインジ
ケーター‘overlay-arrow-string’と‘overlay-arrow’が使用されます。


File: elisp,  Node: Scroll Bars,  Next: Window Dividers,  Prev: Fringes,  Up: Display

37.14 Scroll Bars
=================

通常、フレームパラメーター‘vertical-scroll-bars’はそのフレーム内のウィン
ドウが垂直スクロールバーをもつべきかと、それらが左か右のいずれかに配置さ
れるべきかを制御します。フレームパラメーター‘scroll-bar-width’は、それら
の幅を指定します(‘nil’はデフォルトを意味する)。*note Layout
Parameters::を参照してください。

 -- Function: frame-current-scroll-bars &optional frame
     この関数は、フレームFRAMEのスクロールバータイプのセッティングを報告
     する。値はコンスセル‘(VERTICAL-TYPE . HORIZONTAL-TYPE)’である。ここ
     でVERTICAL-TYPEは‘left’、‘right’、または‘nil’(スクロールバーなしを
     意味する)のいずれかである。HORIZONTAL-TYPEは水平スクロールバータイ
     プの指定を意図しているが、これはまだ実装されていないので常に‘nil’で
     ある。

   変数‘vertical-scroll-bar’をセットすることにより、特定のバッファーにた
いして、スクロールバーを有効または無効にできます。この変数はセット時に、
自動的にバッファーローカルになります。可能な値は‘left’、‘right’、そのフ
レームのデフォルトの使用を意味する‘t’、スクロールバーなしの‘nil’のいずれ
かです。

   個々のウィンドウにたいして、これを制御することもできます。特定のウィ
ンドウにたいして何を行うか指定するためには、関数
‘set-window-scroll-bars’を呼び出します:

 -- Function: set-window-scroll-bars window width &optional
          vertical-type horizontal-type
     この関数は、ウィンドウWINDOWにたいして、スクロールバーの幅とタイプ
     をセットする。

     WIDTHはピクセル単位でスクロールバーの幅を指定する(‘nil’はそのフレー
     ムにたいして指定された幅の使用を意味する)。VERTICAL-TYPEは、垂直ス
     クロールバーをもつかどうか、もつ場合はその位置を指定する。可能な値
     は‘left’、‘right’、および‘nil’で、これはフレームパラメーター
     ‘vertical-scroll-bars’の値と同様である。

     引数HORIZONTAL-TYPEは水平スクロールバーをもつべきかと、その位置を指
     定するが、まだ実装されていないため効果はない。WINDOWが‘nil’なら、選
     択されたウィンドウが使用される。

 -- Function: window-scroll-bars &optional window
     WINDOWに指定されたスクロールバーの幅とタイプを報告する。WINDOWが省
     略または‘nil’なら、選択されたウィンドウが使用される。値は、‘(WIDTH
     COLS VERTICAL-TYPE HORIZONTAL-TYPE)’という形式のリストである。値
     WIDTHは、幅にたいして指定された値である(‘nil’かもしれない)。COLSは
     、スクロールバーが実際に占有する列数である。

     HORIZONTAL-TYPEは実際には無意味である。

 -- Function: window-scroll-bar-width &optional window
     この関数は、WINDOWの垂直スクロールバーの幅をピクセル単位でリターン
     する。WINDOWは生きたウィンドウでなければならず、デフォルトは選択さ
     れたウィンドウである。

   あるウィンドウにたいして‘set-window-scroll-bars’によりこれらの値を指
定しない場合は、表示されるバッファーのバッファーローカル変数
‘scroll-bar-mode’と‘scroll-bar-width’が、そのウィンドウの垂直スクロール
バーを制御します。‘set-window-buffer’は、これらの変数を調べる関数です。
あるウィンドウですでに可視なバッファーでこれらを変更した場合は、すでに表
示されているのと同じバッファーを指定して‘set-window-buffer’を呼び出すこ
とにより、そのウィンドウに新たな値を記録させることができます。

 -- User Option: scroll-bar-mode
     この変数はすべてのバッファーにおいて常にバッファーローカルであり、
     そのバッファーを表示するウィンドウにスクロールバーを配すべきかと、
     その場所を制御する。可能な値は、スクロールバーなしの‘nil’、左にスク
     ロールバーを配置する‘left’、右にスクロールバーを配置する‘right’のい
     ずれかである。

 -- Function: window-current-scroll-bars &optional window
     この関数は、ウィンドウWINDOWにたいするスクロールバータイプを報告す
     る。WINDOWが省略または‘nil’なら、選択されたウィンドウが使用される。
     値はコンスセル‘(VERTICAL-TYPE . HORIZONTAL-TYPE)’である。
     ‘window-scroll-bars’とは異なり、フレームのデフォルトと
     ‘scroll-bar-mode’を考慮して、実際に使用されているスクロールバータイ
     プを報告する。

 -- Variable: scroll-bar-width
     この変数はすべてのバッファーにおいて常にローカルであり、そのバッフ
     ァーのスクロールバーをピクセル単位で量った幅を指定する。値‘nil’は、
     そのフレームにより指定された値の使用を意味する。


File: elisp,  Node: Window Dividers,  Next: Display Property,  Prev: Scroll Bars,  Up: Display

37.15 Window Dividers
=====================

ウィンドウディバイダーとは、フレームのウィンドウ間に描画されるバーのこと
です。“右(right)”ディバイダーは、あるウィンドウと、その右に隣接する任意
のウィンドウの間に描画されます。その幅(厚さ)は、フレームパラメーター
‘right-divider-width’で指定されます。“下(bottom)”ディバイダーは、あるウ
ィンドウと、その下に隣接するウィンドウ、またはエコーエリアとの間に描画さ
れます。その幅は、フレームパラメーター‘bottom-divider-width’で指定されま
す。いずれの場合も、幅に0を指定すると、そのようなディバイダーを描画しな
いことを意味します。*note Layout Parameters::を参照してください。

   技術的には、右ディバイダーはそれの左にあるウィンドウに“所属”し、その
幅がそのウィンドウのトータル幅に寄与することを意味します。下ディバイダー
は上にあるウィンドウに“所属”し、その幅がそのウィンドウのトータル高さに寄
与することを意味します。*note Window Sizes::を参照してください。あるウィ
ンドウが右ディバイダーと左ディバイダーの両方をもつ場合、下ディバイダーが
“優勢”になります。これは、右ディバイダーが下ディバイダーの上で終端される
のに比べて、下ディバイダーはそのウィンドウの完全なトータル幅で描画される
ことを意味します。

   ディバイダーはマウスでドラッグでき、それゆえマウスで隣接するウィンド
ウのサイズを調整するために有用です。これらはスクロールバーやモードライン
が表示されていないときに、隣接するウィンドウを視覚的に分離する役目もあり
ます。以下の3つのフェイスにより、ディバイダーの外観をカスタマイズできま
す:

‘window-divider’
     ディバイダーの幅が3ピクセル未満のときは、このフェイスのフォアグラウ
     ンドカラーで塗りつぶしで描画される。これより広いディバイダーでは、
     最初と最後のピクセルを除く、内部にたいしてのみこのフェイスが使用さ
     れる。

‘window-divider-first-pixel’
     これは少なくとも幅が3ピクセルあるディバイダーの、最初のピクセルを描
     画するために使用される。塗りつぶし(solid)の外観を得るためには、
     ‘window-divider’フェイスに使用されるのと同じ値をセットすること。

‘window-divider-last-pixel’
     これは少なくとも幅が3ピクセルあるディバイダーの、最後のピクセルを描
     画するために使用される。塗りつぶし(solid)の外観を得るためには、
     ‘window-divider’フェイスに使用されるのと同じ値をセットすること。

   以下の2つの関数により、特定のウィンドウのディバイダーのサイズを取得で
きます。

 -- Function: window-right-divider-width &optional window
     WINDOWの右ディバイダーの幅(厚さ)を、ピクセル単位でリターンする。
     WINDOWは生きたウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。最右ウィンドウにたいするリターン値は、常に0である。

 -- Function: window-bottom-divider-width &optional window
     WINDOWの下ディバイダーの幅(厚さ)を、ピクセル単位でリターンする。
     WINDOWは生きたウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。ミニバッファーウィンドウ、またはミニバッファーがな
     いフレームの最下ウィンドウにたいするリターン値は、常に0である。


File: elisp,  Node: Display Property,  Next: Images,  Prev: Window Dividers,  Up: Display

37.16 The ‘display’ Property
============================

テキストプロパティ(またはオーバーレイプロパティ)‘display’は、テキストへ
のイメージ挿入、およびテキスト表示のその他の事相を制御します。
‘display’プロパティの値は、ディスプレイ仕様、または複数のディスプレイ仕
様を含むリストかベクターであるべきです。同じ‘display’プロパティ値内のデ
ィスプレイ仕様は、一般的にはそれらがカバーするテキストにたいして並行して
適用されます。

   複数のソース(オーバーレイ、および/またはテキストプロパティ)が
‘display’プロパティにたいして値を指定しますが、1つの値だけが効果をもち、
これは‘get-char-property’のルールにしたがいます。*note Examining
Properties::を参照してください。

   このセクションの残りの部分では、複数の種類のディスプレイ仕様と、それ
らの意味を説明します。

* Menu:

* Replacing Specs::          テキストを置換するディスプレイspec。
* Specified Space::          指定された幅に1つのスペースを表示する。
* Pixel Specification::      ピクセル単位でスペースの幅または高さを指定する。
* Other Display Specs::      イメージの表示。高さ、スペーシング、その他のテキストプロパティの調整。
* Display Margins::          メインテキスト側面へのテキストまたはイメージの表示。


File: elisp,  Node: Replacing Specs,  Next: Specified Space,  Up: Display Property

37.16.1 Display Specs That Replace The Text
-------------------------------------------

ある種のディスプレイ仕様は、そのプロパティをもつテキストのかわりに表示す
る何かを指定します。これらは“置換(replacing)”ディスプレイ仕様と呼ばれま
す。Emacsはユーザーにたいして、この方法で置換されたバッファーテキストの
中間への対話的なポイント移動を許していません。

   ディスプレイ仕様のリストに1つ以上の置換ディスプレイ仕様が含まれる場合
は、最初の置換ディスプレイ仕様が残りをオーバーライドします。置換ディスプ
レイ仕様は、他のほとんどのディスプレイ仕様は置換を許容しないので、それら
とは無関係です。

   置換ディスプレイ仕様では、“そのプロパティをもつテキスト”とは、
‘display’プロパティとして同一のLispオブジェクトをもつ、連続したすべての
文字を意味します。これらの文字は単一の単位として置換されます。
‘display’プロパティに異なるLispオブジェクト(‘eq’ではないオブジェクト)を
もつ2つの文字は、個別に処理されます。

   以下は、この要点を示すための例です。文字列が置換ディスプレイ仕様とし
ての役割をもち、指定された文字列のプロパティをもつテキストを置換します
(*note Other Display Specs::を参照)。以下の関数を考えてみてください:

     (defun foo ()
       (dotimes (i 5)
         (let ((string (concat "A"))
               (start (+ i i (point-min))))
           (put-text-property start (1+ start) 'display string)
           (put-text-property start (+ 2 start) 'display string))))

この関数は、バッファー内の最初の10文字それぞれにたいして、文字列‘"A"’で
あるような‘display’プロパティを与えますが、これらはすべて同じ文字列オブ
ジェクトを取得しません。最初の2文字は同じ文字列オブジェクトなので、1つの
‘A’に置換されます。2つの別々の‘put-text-property’呼び出しでそのディスプ
レイプロパティが割り当てられたという事実は、無関係です。同様に次の2文字
は2つ目の文字列(‘concat’により新たに作成された文字列オブジェクト)を取得
するので、1つの‘A’で置換され、...となります。したがって、10文字は5つの
Aで表示されます。


File: elisp,  Node: Specified Space,  Next: Pixel Specification,  Prev: Replacing Specs,  Up: Display Property

37.16.2 Specified Spaces
------------------------

指定された幅、および/または高さのスペースを表示するためには、‘(space .
PROPS)’という形式のディスプレイ仕様を使用します。このプロパティを、1つ以
上の連続する文字にputすることができます。これら_すべて_の文字のかわりに
、指定された高さと幅のスペースが表示されます。以下は、スペースのウェイト
を指定するために、PROPS内で使用できるプロパティです:

‘:width WIDTH’
     WIDTHが数字なら、それはスペースの幅が通常の文字幅のWIDTH倍であるべ
     きかを指定する。WIDTHは“ピクセル幅(pixel width)”仕様でも可(*note
     Pixel Specification::を参照)。

‘:relative-width FACTOR’
     同じ‘display’プロパティをもつ連続する文字グループ内の最初の文字から
     計算される、範囲の幅を指定する。スペースの幅は、FACTORを乗じたその
     文字の幅。

‘:align-to HPOS’
     スペースがHPOSに達するほど、十分に広くあるべきことを指定する。
     HPOSが数字なら、それは通常の文字幅の単位で量られる。HPOSは“ピクセル
     幅(pixel width)”仕様でも可(*note Pixel Specification::を参照)。

   上記プロパティのいずれか1つのみを使用するべきです。以下のプロパティで
、スペースの高さも指定できます:

‘:height HEIGHT’
     スペースの高さを指定する。HEIGHTが数字なら、それはスペースの高さが
     通常の文字高さのHEIGHT倍であるべきことを指定する。HEIGHTは“ピクセル
     高さ仕様(pixel height)”でも可(*note Pixel Specification::を参照)。

‘:relative-height FACTOR’
     このディスプレイ仕様をもつテキストの通常の高さにFACTORを乗じること
     により、スペースの高さを指定する。

‘:ascent ASCENT’
     ASCENTの値が非負の100以下の数字なら、スペースの高さのASCENTパーセン
     トをスペースのアセント(ascent: 上方)、すなわちベースラインより上の
     部分とみなす。“ピクセルアセント(pixel ascent)”仕様により、アセント
     をピクセル単位で指定することも可(*note Pixel Specification::を参照
     )。

   ‘:height’と‘:relative-height’を両方一緒に使用しないでください。

   ‘:width’と‘:align-to’プロパティは非グラフィック端末でサポートされます
が、このセクションのその他のスペースプロパティはサポートされません。

   スペースプロパティは、双方向テキスト表示の並べ替えのために、パラグラ
フ区切りとして扱われます。詳細は、*note Bidirectional Display::を参照し
てください。


File: elisp,  Node: Pixel Specification,  Next: Other Display Specs,  Prev: Specified Space,  Up: Display Property

37.16.3 Pixel Specification for Spaces
--------------------------------------

プロパティ‘:width’、‘:align-to’、‘:height’、‘:ascent’の値は再表示の間に
評価される、特別な種類の式です。その評価の結果は、ピクセルの絶対数として
使用されます。

   以下の式がサポートされています:

       EXPR ::= NUM | (NUM) | UNIT | ELEM | POS | IMAGE | FORM
       NUM  ::= INTEGER | FLOAT | SYMBOL
       UNIT ::= in | mm | cm | width | height
       ELEM ::= left-fringe | right-fringe | left-margin | right-margin
             |  scroll-bar | text
       POS  ::= left | center | right
       FORM ::= (NUM . EXPR) | (OP EXPR ...)
       OP   ::= + | -

   フォームNUMは、デフォルトフレームフォントの高さか幅を、フォーム
‘(NUM)’は絶対ピクセル数を指定します。NUMがシンボルSYMBOLなら、それのバッ
ファーローカルな変数バインディングが使用されます。

   単位‘in’、‘mm’、‘cm’はそれぞれインチ、ミリメートル、センチメートルご
とのピクセル数を指定します。単位‘width’と‘height’はそれぞれ、カレントフ
ェイスのデフォルトの幅と高さに対応します。イメージ仕様‘image’は、そのイ
メージの幅、または高さに対応します。

   要素‘left-fringe’、‘right-fringe’、‘left-margin’、‘right-margin’、
‘scroll-bar’、‘text’は、そのウィンドウの対応する領域の幅を指定します。

   位置‘left’、‘center’、‘right’はテキストエリアの左端、中央、右端から相
対的に位置を指定するために、‘:align-to’とともに使用できます。

   (‘text’を除く)上記ウィンドウ要素は、与えられたエリアの左端から相対的
に位置を指定するために、‘:align-to’とともに使用することもできます。 Any
of the above window elements (except ) can also be used with to specify
that the position is relative to the left edge of the given area.  (最初
に出現するこれらシンボルのいずれかにより)相対的位置にたいするベースオフ
セットが一度セットがされると、残りのシンボルは指定されたエリアの幅として
解釈されます。たとえば左マージンの中央に位置揃えするには、以下のようにし
ます

     :align-to (+ left-margin (0.5 . left-margin))

   位置揃えにたいしてベースオフセットが何も指定されなければ、テキストエ
リア左端にたいして常に相対的になります。たとえばヘッダーライン内の
‘:align-to 0’は、テキストエリアの最初のテキスト行に位置揃えします。

   ‘(NUM . EXPR)’という形式の値は、NUMとEXPRにより生成される値を意味しま
す。たとえば‘(2 . in)’は2インチの幅、‘(0.5 . IMAGE)’は指定されたイメージ
の幅(または高さ)の半分を指定します。

   フォーム‘(+ EXPR ...)’は、式の値を合計します。フォーム‘(- EXPR ...)’は
式の値を否定または減算します。


File: elisp,  Node: Other Display Specs,  Next: Display Margins,  Prev: Pixel Specification,  Up: Display Property

37.16.4 Other Display Specifications
------------------------------------

以下は、‘display’テキストプロパティ内で使用できる、その他のディスプレイ
仕様です。

‘STRING’
     このプロパティをもつテキストのかわりに、STRINGを表示する。

     再帰的なディスプレイ仕様はサポートされない。つまりSTRINGの
     ‘display’プロパティがあっても、それは使用されない。

‘(image . IMAGE-PROPS)’
     この種のディスプレイ仕様は、イメージディスクリプタである(*note
     Images::を参照)。ディスプレイ仕様として使用時は、そのディスプレイ仕
     様をもつテキストのかわりに表示するイメージを意味する。

‘(slice X Y WIDTH HEIGHT)’
     この仕様は‘image’とともに、表示するイメージの“スライス(slice: イメ
     ージの特定の領域)”を指定する。要素YとXは、そのイメージ内での左上隅
     を指定し、WIDTHとHEIGHTはそのスライスの幅と高さを指定する。整数はピ
     クセル数、0.0から1.0までの浮動小数点数はイメージ全体の幅または高さ
     の割合を意味する。A floating-point number in the range 0.0–1.0
     stands for that fraction of the width or height of the entire
     image.

‘((margin nil) STRING)’
     この形式のディスプレイ仕様は、このディスプレイ仕様をもつテキストの
     かわりに、そのテキストと同じ位置に表示するSTRINGを意味する。これは
     単にSTRINGを使用するのと同じだが、マージン表示(*note Display
     Margins::を参照)の特殊なケースとして行われる点が異なる。

‘(left-fringe BITMAP [FACE])’
‘(right-fringe BITMAP [FACE])’
     テキスト行の任意の文字がこのディスプレイ仕様をもつ場合は、その文字
     のかわりにその行の左または右フリンジに表示するBITMAPを指定する。オ
     プションのFACEは、そのビットマップにたいして使用するカラーを指定す
     る。詳細は*note Fringe Bitmaps::を参照のこと。

‘(space-width FACTOR)’
     このディスプレイ仕様は、この仕様をもつテキスト内のすべてのスペース
     文字に効果を及ぼす。これらすべてのスペースは、通常の幅のFACTOR倍の
     幅で表示される。要素FACTORは整数か浮動小数点数であること。スペース
     以外の文字は影響を受けない。特に、これはタブ文字に影響を与えない。

‘(height HEIGHT)’
     このディスプレイ仕様は、テキストを高く(taller)、または低く
     (shorter)する。HEIGHTには以下を指定できる:

     ‘(+ N)’
          これは、Nステップ大きいフォントの使用を意味する。“ステップ”は
          利用可能なフォントのセットから定義される。具体的に“ステップ”は
          、このテキストに指定されたheight以外のすべての属性にマッチする
          。適切なフォントの各サイズは、別のステップとして利用可能とみな
          される。Nは整数であること。

     ‘(- N)’
          これはNステップ小さいフォントの使用を意味する。

     FACTOR(数値)
          数値FACTORは、デフォルトフォントのFACTOR倍高いフォントの使用を
          意味する。

     FUNCTION(シンボル)
          高さを計算する関数。この関数はカレントの高さを引数として呼び出
          され、使用する新たな高さをリターンすること。

     FORM(上記以外)
          HEIGHTの値が上記のいずれにもマッチしなければ、それはフォームで
          ある。Emacsは‘height’をカレントで指定されたフォントの高さにバ
          インドして、新たな高さを取得するために、そのフォームを評価する
          。

‘(raise FACTOR)’
     この種のディスプレイ仕様は、その行のベースラインに相対的に、テキス
     トを上(raise)、または下(lower)に指定する。

     FACTORは、影響を受けるテキストの高さにたいする乗数として解釈される
     数値でなければならない。これが正なら、その文字を上に、負なら下に表
     示することを意味する。

     そのテキストが‘height’ディスプレイ仕様ももつ場合、それは上または下
     に表示する量には影響を与えない。上または下に表示する量は、そのテキ
     ストにたいして使用されるフェイスにもとづく。

   任意のディスプレイ仕様にたいして、条件を作成できます。これを行うには
、‘(when CONDITION . SPEC)’という形式の別リスト内にパッケージします。こ
の場合、仕様SPECはCONDITIONが非‘nil’値に評価されたときだけ適用されます。
この評価の間、‘object’は条件つき‘display’プロパティをもつ文字列、または
バッファーにバインドされます。‘position’と‘buffer-position’はそれぞれ
‘object’内の位置、および‘display’プロパティが見つかったバッファー位置に
バインドされます。‘object’が文字列の際は、両者の位置は異なるかもしれませ
ん。


File: elisp,  Node: Display Margins,  Prev: Other Display Specs,  Up: Display Property

37.16.5 Displaying in the Margins
---------------------------------

バッファーはその左側と右側に、“ディスプレイマージン(display margins)”と
呼ばれる、ブランクエリアをもつことができます。それらのエリア内には、通常
はテキストが出現することはありませんが、‘display’プロパティを使用して、
ディスプレイマージン内に何かを配置することができます。現在のところ、マー
ジン内のテキストやイメージをマウスセンシティブにする方法はありません。

   マージン内に何かを表示するには、テキストの‘display’プロパティのマージ
ン表示仕様(margin display specification)で、それを指定します。これは、配
置したテキストが表示されないことを意味する、置換表示仕様です。マージン表
示は表示されますが、そのテキストは表示されません。

   マージン表示仕様とは‘((margin right-margin) SPEC)’や‘((margin
left-margin) SPEC)’のようなものです。ここでSPECは、マージン内に何を表示
するかを告げる、別の表示仕様です。典型的にはこれは表示するテキスト文字列
、またはイメージディスクリプタです。

   特定のバッファーテキストに_関連する_マージンに何かを表示するためには
、そのテキストに‘before-string’プロパティを付して、そのコンテンツとして
マージン表示仕様をputします。

   ディスプレイマージンが何かを表示可能になる前に、それらに非0の幅を与え
なければなりません。これを行う通常の方法は、以下の変数をセットする方法で
す:

 -- Variable: left-margin-width
     この変数は左マージンの幅を、文字セル(別名は“列”)単位で指定する。こ
     れは、すべてのバッファーでバッファーローカルである。値‘nil’は、左マ
     ージンエリアなしを意味する。

 -- Variable: right-margin-width
     この変数は右マージンの幅を、文字セル単位で指定する。これは、すべて
     のバッファーでバッファーローカルである。値‘nil’は、右マージンエリア
     なしを意味する。

   これらの変数をセットしても、そのウィンドウには即座には反映されません
。これらの変数は、そのウィンドウ内に新たなバッファーを表示する際にチェッ
クされます。したがって、‘set-window-buffer’を呼び出すことにより、変更を
反映することができます。

   マージン幅を即座にセットすることもできます。

 -- Function: set-window-margins window left &optional right
     この関数は、ウィンドウWINDOWのマージン幅を、文字セル単位で指定する
     。引数LEFTは左マージン、RIGHTは右マージン(デフォルトは‘0’)を制御す
     る。

 -- Function: window-margins &optional window
     この関数は、WINDOWの左マージンと右マージンの幅を、
     ‘(LEFT . RIGHT)’という形式のコンスセルでリターンする。2つのマージン
     エリアのいずれか一方が存在しなければ、その幅は‘nil’としてリターンさ
     れる。2つのマージンがどちらも存在しない場合、この関数は‘(nil)’をリ
     ターンする。WINDOWが‘nil’なら、選択されたウィンドウが使用される。


File: elisp,  Node: Images,  Next: Buttons,  Prev: Display Property,  Up: Display

37.17 Images
============

Emacsバッファー内にイメージを表示するためには、最初にイメージディスクリ
プタを作成して、それを表示されるテキストの‘display’プロパティ(*note
Display Property::を参照)内のディスプレイ指定子として使用しなければなり
ません。

   Emacsはグラフィカルな端末で実行時は、通常はイメージの表示が可能です。
テキスト端末、イメージサポートを欠く特定のグラフ^ィカル端末、またはイメ
ージサポートなしでコンパイルされたEmacsでは、イメージは表示できません。
原則イメージが表示可能か判断するためには、関数‘display-images-p’を使用で
きます(*note Display Feature Testing::を参照)。

* Menu:

* Image Formats::            サポートされるイメージフォーマット。
* Image Descriptors::        ‘:display’内で使用されるイメージの指定方法。
* XBM Images::               XBMフォーマット用の特別な機能。
* XPM Images::               XPMフォーマット用の特別な機能。
* PostScript Images::        PostScriptフォーマット用の特別な機能。
* ImageMagick Images::       ImageMagickを通じて利用できる特別な機能。
* Other Image Types::        サポートされるその他さまざまなフォーマット。
* Defining Images::          後で使用するためにイメージを定義する便利な方法。
* Showing Images::           一度定義されたイメージを表示するための便利な方法。
* Multi-Frame Images::       1つ以上のフレームを含むイメージ。
* Image Cache::              イメージ表示の内部的メカニズム。


File: elisp,  Node: Image Formats,  Next: Image Descriptors,  Up: Images

37.17.1 Image Formats
---------------------

Emacsは、いくつかの異なるフォーマットのイメージを表示できます。これらの
イメージフォーマットのいくつかは、特定のサポートライブラリーがインストー
ルされている場合のみサポートされます。いくつかのプラットフォームでは、
Emacsはオンデマンドでサポートライブラリーをロードできます。そのような場
合には、それらの動的ライブラリーにたいする既知の名前セットを変更するため
に、変数‘dynamic-library-alist’を使用できます。*note Dynamic
Libraries::を参照してください。

   サポートされるイメージフォーマット(と要求されるサポートライブラリー
)にはPBMとXBM(サポートライブラリーに依存せず常に利用可能)、
XPM(‘libXpm’)、GIF (‘libgif’または‘libungif’)、PostScript(‘gs’)、
JPEG(‘libjpeg’)、TIFF(‘libtiff’)、PNG(‘libpng’)、SVG (‘librsvg’)が含まれ
ます。

   これらのイメージフォーマットはそれぞれ、“イメージタイプシンボル(image
type symbol)”に関連付けられます。上記のフォーマットにたいするシンボルは
順に‘pbm’、‘xbm’、‘xpm’、‘gif’、‘postscript’、‘jpeg’、‘tiff’、‘png’、
‘svg’になります。

   さらにImageMagick(‘libMagickWand’)のサポートつきでEmacsをビルドした場
合には、EmacsはImageMagickが表示可能なイメージフォーマットを表示できます
。*note ImageMagick Images::を参照してください。ImageMagickを通じて表示
されるすべてのイメージは、タイプシンボル‘imagemagick’をもちます。

 -- Variable: image-types
     この変数はカレント構成で潜在的にサポートされるイメージフォーマット
     にたいする、タイプシンボルのリストを含む。

     “潜在的”とは、Emacsがそのイメージタイプを知っていることを意味してお
     り、実際に使用可能である必要はない(たとえば動的ライブラリーが利用で
     きないせいかもしれない)。どのイメージタイプが実際に利用できるか知る
     ためには、‘image-type-available-p’を使用すること。

 -- Function: image-type-available-p type
     この関数は、タイプTYPEのイメージのロードおよび表示が可能なら非
     ‘nil’をリターンする。TYPEはイメージタイプシンボルであること。

     サポートライブラリーが静的にリンクされたイメージタイプにたいして、
     この関数は常に‘t’をリターンする。サポートライブラリーが動的にロード
     されるイメージタイプにたいしては、そのライブラリーがロード可能なら
     ‘t’、それ以外なら‘nil’をリターンする。


File: elisp,  Node: Image Descriptors,  Next: XBM Images,  Prev: Image Formats,  Up: Images

37.17.2 Image Descriptors
-------------------------

“イメージディスクリプタ(image descriptor)”とは、イメージにたいする基礎的
なデータと、それを表示する方法を指定するリストです。これは通常、オーバー
レイプロパティまたはテキストプロパティ‘display’(*note Other Display
Specs::を参照)の値を通じて使用されますが、バッファーにイメージを挿入する
便利なヘルパー関数については、*note Showing Images::を参照してください。

   イメージディスクリプタはそれぞれ‘(image . PROPS)’という形式をもちます
。ここでPROPSはキーワードシンボルと値のペアーからなるプロパティリストで
、少なくともそのイメージタイプを指定するペアー‘:type TYPE’を含みます。

   以下は、すべてのイメージタイプにたいして意味のあるプロパティのリスト
です(以降のサブセクションで説明するように、特定のイメージタイプにたいし
てのみ意味があるプロパティも存在する):

‘:type TYPE’
     イメージタイプ。 *note Image Formats::を参照のこと。 すべてのイメー
     ジディスクリプタは。このプロパティを含まなければならない。

‘:file FILE’
     これは、ファイルFILEからイメージをロードすることを意味する。FILEが
     絶対ファイル名でなければ、それは‘data-directory’内で展開される。

‘:data DATA’
     これは、rawイメージデータを指定する。すべてのイメージディスクリプタ
     は、‘:data’か‘:file’のいずれかをもたなければならないが、両方もつこ
     とはできない。

     ほとんどのイメージタイプにたいして、‘:data’プロパティの値はイメージ
     データを含む、文字列であること。いくつかのイメージタイプは、
     ‘:data’をサポートしない。それ以外のイメージタイプにたいしては、
     ‘:data’単独では不十分であり、‘:data’とともに他のイメージプロパティ
     を使用する必要がある。詳細は、以下のサブセクションを参照のこと。

‘:margin MARGIN’
     これは、そのイメージ周囲に余分なマージンとして、何ピクセル追加する
     かを指定する。値MARGINは非負の数値、またはそのような数値のペアー‘(X
     . Y)’でなければならない。ペアーの場合、Xは水平方向に追加するピクセ
     ル数、Yは垂直方向に追加するピクセル数を指定する。‘:margin’が指定さ
     れない場合のデフォルトは0。

‘:ascent ASCENT’
     これは、イメージのアセント(ベースラインの上の部分)に使用する、その
     イメージの高さの分量を指定する。値ASCENTは、から100の数値、またはシ
     ンボル‘center’でなければならない。

     ASCENTが数値なら、アセントに使用するイメージの高さのパーセンテージ
     であること。

     ASCENTが‘center’なら、そのイメージにたいしてテキストプロパティおよ
     びオーバーレイプロパティにより指定される方法で、センターライン(その
     イメージ位置にテキストを描画する際の垂直方向のセンターライン)の垂直
     方向中心にイメージが配置される。

     このプロパティが省略された場合のデフォルトは500。

‘:relief RELIEF’
     これは、イメージ注意にシャドー矩形を追加する。値RELIEFは、シャドー
     ライン幅をピクセルで指定する。RELIEFが負ならボタンを押下した状態、
     それ以外はボタンを押下していない状態のイメージでシャドーを描画する
     。

‘:conversion ALGORITHM’
     これは、イメージを表示する前に適用するべき、変換アルゴリズムを指定
     する。値ALGORITHMは、どのアルゴリズムかを指定する。

     ‘laplace’
     ‘emboss’
          カラーの大きい差異を強調して小さな差異を不鮮明にする、ラプラス
          エッジ検出アルゴリズム(Laplace edge detection algorithm)を指定
          する。“無効”なボタンのイメージ表示に、これが役立つと考える人も
          います。

     ‘(edge-detection :matrix MATRIX :color-adjust ADJUST)’
          一般的なエッジ検出アルゴリズムを指定する。MATRIXは数値からなる
          9要素のリスト、またはベクターでなければならない。変換されたイ
          メージ内の位置x/yにあるピクセルは、その位置周辺にある元のピク
          セルから計算される。MATRIXは、x/yに近接する各ピクセルにたいし
          て、そのピクセルが変換先ピクセルに影響するファクター(factor: 要
          因)を指定する。以下のように、要素0はx-1/y-1にあるピクセルのフ
          ァクター、要素1はx/y-1にあるピクセルにたいするファクター、
          ...を指定する。
                 (x-1/y-1  x/y-1  x+1/y-1
                  x-1/y    x/y    x+1/y
                  x-1/y+1  x/y+1  x+1/y+1)

          結果のピクセルは、周辺ピクセルのRGB値を合計したカラーを指定さ
          れたファクターで乗じ、その合計をファクター絶対値の合計で除した
          色強度から計算される。

          ラプラスエッジ検出は、現在のところは以下のマトリクス
                 (1  0  0
                  0  0  0
                  0  0 -1)

          エンボスエッジ検出(Emboss edge-detection)は以下のマトリクスを
          使用する
                 ( 2 -1  0
                  -1  0  1
                   0  1 -2)

     ‘disabled’
          イメージが“無効(disabled)”に見えるよう変換することを指定する。

‘:mask MASK’
     MASKが‘heuristic’か‘(heuristic BG)’なら、フレームのバックグラウンド
     がイメージ背後に見えるよう、そのイメージのクリッピングマスクを構築
     する。BGが未指定または‘t’なら、イメージ4隅に最頻するカラーをそのイ
     メージのバックグラウンドカラーとみなしてバックグラウンドカラーを決
     定する。それ以外ならBGは、そのイメージのバックグラウンドとみなすべ
     きカラーを指定するリスト‘(RED GREEN BLUE)’でなければならない。

     MASKが‘nil’なら、イメージがマスクをもつ場合はマスクを削除する。マス
     クを含むフォーマットのイメージは、‘:mask nil’を指定することにより削
     除される可能性がある。

‘:pointer SHAPE’
     これはマウスポインターがそのイメージ上にある際の、ポインターシェイ
     プを指定する。利用可能なポインターシェイプについては、*note Pointer
     Shape::を参照のこと。

‘:map MAP’
     これは、そのイメージに“ホットスポット(hot spots)”のイメージマップを
     関連付ける。

     イメージマップは、各要素が‘(AREA ID PLIST)’という形式をもつalistで
     ある。AREAはにはrectangle(矩形)、circle(円)、またはpolygon(ポリゴン
     、多角形)のいずれかを指定する。

     rectangleは、矩形エリアの左上隅と右下隅のピクセル座標を指定するコン
     ス‘(rect . ((X0 . Y0) . (X1 . Y1)))’である。

     circleは、円の中心と半径を指定するコンス‘(circle . ((X0 . Y0) .
     R))’である。Rは整数または浮動小数点数。

     polygonは、各ペアーが多角形の1つの頂点を記述するコンス‘(poly . [X0
     Y0 X1 Y1 ...])’である。

     マウスポインターがホットスポット上にある際は、そのホットスポットの
     PLISTが参照される。これが‘help-echo’プロパティを含むならそのホット
     スポットのツールチップを指定し、‘pointer’プロパティを含む場合はマウ
     スカーソルがホットスポット上にあるときのマウスカーソルのシェイプを
     指定する。利用可能なポインターシェイプについては、*note Pointer
     Shape::を参照のこと。

     マウスポインターがホットスポット上にあるときにマウスをクリックした
     ときのイベントは、ホットスポットのIDとマウスイベントを組み合わせて
     構成される。たとえば、ホットスポットのIDが‘area4’なら、‘[area4
     mouse-1]’となる。

 -- Function: image-mask-p spec &optional frame
     この関数は、イメージSPECがマスクビットマップをもつなら、‘t’をリター
     ンする。FRAMEはそのイメージが表示されるフレームである。FRAMEが
     ‘nil’または省略された場合は、選択されたフレームが使用される(*note
     Input Focus::を参照)。


File: elisp,  Node: XBM Images,  Next: XPM Images,  Prev: Image Descriptors,  Up: Images

37.17.3 XBM Images
------------------

XBMフォーマットを使用するには、イメージタイプとして‘xbm’を指定します。こ
のイメージフォーマットは外部ライブラリーを要求せず、このタイプのイメージ
は常にサポートされます。

   ‘xbm’イメージタイプにたいして、追加のイメージプロパティがサポートされ
ます:

‘:foreground FOREGROUND’
     値FOREGROUNDはそのイメージのフォアグラウンドカラーを指定する文字列
     、またはデフォルトカラーを指定する‘nil’であること。このカラーは
     XBM内の1の各ピクセルに使用される。デフォルトは、そのフレームのフォ
     アグラウンドカラーである。

‘:background BACKGROUND’
     値BACKGROUNDはそのイメージのバックグラウンドカラーを指定する文字列
     、またはデフォルトカラーを指定する‘nil’であること。このカラーは
     XBM内の0の各ピクセルに使用される。デフォルトは、そのフレームのバッ
     クグラウンドカラーである。

   外部ファイルのかわりに、Emacs内のデータを指定してXBMイメージを指定す
るには、以下の3つのプロパティを使用する:

‘:data DATA’
     値DATAは、そのイメージのコンテンツを指定する。DATAとして使用できる
     、3つのフォーマットが存在する:

        • それぞれがイメージの1ラインを指定するような、文字列ベクターま
          たはboolベクター。‘:height’と‘:width’を指定する。

        • 文字列なら、XBMファイルが含むのと同じバイトシーケンスを含む。
          この場合は‘:height’と‘:width’を指定してはならない。これらを省
          略することが、そのデータがXBMファイルのフォーマットをもつこと
          を示すからである。イメージの高さと幅は、ファイルのコンテンツに
          より指定される。

        • イメージのビット(もしかしたら終端の使用されない余分なビットを
          含む)を含む文字列、またはboolベクター。少なくともWIDTH *
          ‘height’ビットを含むこと。この場合は、その文字列がXBMファイル
          全体ではなく、単にビットだけを含むことを示すとともに、そのイメ
          ージのサイズを指定するために、‘:height’と‘:width’を指定しなけ
          ればならない。

‘:width WIDTH’
     値WIDTHは、ピクセル単位でイメージの幅を指定する。

‘:height HEIGHT’
     値HEIGHTは、ピクセル単位でイメージの高さを指定する。


File: elisp,  Node: XPM Images,  Next: PostScript Images,  Prev: XBM Images,  Up: Images

37.17.4 XPM Images
------------------

XPMフォーマットを使用するには、イメージタイプに‘xpm’を指定します。
‘xpm’イメージタイプでは、追加のプロパティ‘:color-symbols’にも意味があり
ます。

‘:color-symbols SYMBOLS’
     値SYMBOLSは、要素が‘(NAME . COLOR)’という形式をもつようなalistであ
     ること。各要素において、NAMEはイメージファイル内に出現するカラー名
     、COLORはそのカラー名の実際の表示に使用するカラーを指定する。


File: elisp,  Node: PostScript Images,  Next: ImageMagick Images,  Prev: XPM Images,  Up: Images

37.17.5 PostScript Images
-------------------------

あるイメージにたいしてPostScriptを使用するには、イメージタイプ
‘postscript’を指定します。これは、Ghostscriptがインストールされている場
合のみ機能します。常に以下の3つのプロパティを使用しなければなりません:

‘:pt-width WIDTH’
     値WIDTHはポイント(1/72インチ)単位で測ったイメージの幅を指定する。
     WIDTHは整数でなければならない。

‘:pt-height HEIGHT’
     値HEIGHTはポイント(1/72インチ)単位で測ったイメージの高さを指定する
     。HEIGHTは整数でなければならない。

‘:bounding-box BOX’
     値BOXは、4つの整数からなるリストかベクターでなければならない。これ
     らの整数は、PostScriptファイルの‘BoundingBox’に類似した、
     PostScriptイメージのバウンディングボックスを指定する。

          %%BoundingBox: 22 171 567 738


File: elisp,  Node: ImageMagick Images,  Next: Other Image Types,  Prev: PostScript Images,  Up: Images

37.17.6 ImageMagick Images
--------------------------

ImageMagickのサポートつきでEmacsをビルドした場合には、多くくのイメージフ
ォーマットをロードするために、ImageMagickライブラリーを使用できます
(*note (emacs)File Conveniences::を参照)。ImageMagickを通じてロードした
イメージのイメージタイプシンボルは、基礎となる実際のイメージフォーマット
とは無関係に、‘imagemagick’になります。

 -- Function: imagemagick-types
     この関数は、カレントのImageMagickインストールによりサポートされる、
     イメージファイル拡張子のリストをリターンする。リストの各要素は、
     ‘.bmp’イメージは‘BMP’のように、イメージタイプにたいして内部的な
     ImageMagick名を表すシンボルである。

 -- User Option: imagemagick-enabled-types
     この変数の値は、EmacsがImageMagickを使用してレンダリングを試みるか
     もしれない、ImageMagickイメージタイプのリストである。リストの各要素
     は、‘imagemagick-types’がリターンするリスト内のシンボルのいずれか、
     または等価な文字列である。もしくは値‘t’はImageMagickにたいして利用
     できるすべてのイメージタイプを有効にする。この変数の値とは関係なく
     、‘imagemagick-types-inhibit’(以下参照)が優先される。

 -- User Option: imagemagick-types-inhibit
     この変数の値は、‘imagemagick-enabled-types’の値とは無関係に、
     ImageMagickを使用して決してレンダリングされることのない、
     ImageMagickイメージタイプのリストである。値‘t’は、ImageMagickを完全
     に無効にする。

 -- Variable: image-format-suffixes
     この変数は、イメージタイプをファイル名拡張子にマッピングするalistで
     ある。Emacsは、ImageMagickライブラリーにイメージのタイプに関するヒ
     ントを与えるために、この変数と‘:format’イメージプロパティ(以下参照
     )を組み合わせて使用する。各要素は‘(TYPE EXTENSION)’という形式をもち
     、TYPEはイメージのcontent-typeを指定するシンボル、EXTENSIONは関連付
     けられるファイル名拡張子を指定する文字列である。

   ImageMagickによりロードされたイメージは、追加で以下のイメージディスク
リプタプロパティをサポートします:

‘:background BACKGROUND’
     BACKGROUNDが非‘nil’なら、カラーを指定する文字列であること。これはイ
     メージが透明度をサポートする場合に、そのイメージのバックグラウンド
     カラーとして使用される。値が‘nil’の場合のデフォルトは、そのフレーム
     のバックグラウンドカラー。

‘:width WIDTH, :height HEIGHT’
     キーワード‘:width’と‘:height’は、イメージのスケーリングに使用される
     。いずれか一方のみが指定された場合には、アスペクト比を保つために、
     もう一方は算出される。両方が指定された場合には、アスペクト比は保た
     れないかもしれない。

‘:max-width MAX-WIDTH, :max-height MAX-HEIGHT’
     キーワード‘:max-width’と‘:max-height’は、イメージのサイズがこれらの
     値を超過した場合のスケーリングに使用される。‘:width’がセットされた
     場合には‘max-width’より優先され、‘:height’がセットされた場合には
     ‘max-height’より優先されるだろうが、それ以外ではこれらのキーワード
     を望むように混交できる。‘:max-width’と‘:max-height’は常に、アスペク
     ト比を保つであろう。

‘:format TYPE’
     値TYPEは、‘image-format-suffixes’で見られるような、イメージのタイプ
     を指定するシンボルであること。これはイメージが関連付けられたファイ
     ル名をもたない際に、そのイメージタイプを検出する助けとなるヒントを
     ImageMagickに提供する。

‘:rotation ANGLE’
     回転角度を度数で指定する。

‘:index FRAME’
     *note Multi-Frame Images::を参照のこと。


File: elisp,  Node: Other Image Types,  Next: Defining Images,  Prev: ImageMagick Images,  Up: Images

37.17.7 Other Image Types
-------------------------

PBMイメージには、イメージタイプ‘pbm’を指定します。カラー、グレースケール
、およびモノクロのイメージがサポートされます。モノクロのPBMイメージにた
いしては、2つの追加イメージプロパティがサポートされます。

‘:foreground FOREGROUND’
     値FOREGROUNDは、そのイメージのフォアグラウンドカラーを指定する文字
     列、またはデフォルトカラーなら‘nil’であること。このカラーは、その
     PBM内の1であるようなピクセルすべてに使用される。デフォルトは、フレ
     ームのフォアグラウンドカラー。

‘:background BACKGROUND’
     値BACKGROUNDは、そのイメージのバックグラウンドカラーを指定する文字
     列、またはデフォルトカラーなら‘nil’であること。このカラーは、その
     PBM内の0であるようなピクセルすべてに使用される。デフォルトは、フレ
     ームのバックグラウンドカラー。

Emacsがサポート可能な、残りのイメージタイプは以下のとおり:

GIF
     イメージタイプ‘gif’。‘:index’プロパティをサポートする。*note
     Multi-Frame Images::を参照のこと。

JPEG
     イメージタイプ‘jpeg’。

PNG
     イメージタイプ‘png’。

SVG
     イメージタイプ‘svg’。

TIFF
     イメージタイプ‘tiff’。‘:index’プロパティをサポートする。*note
     Multi-Frame Images::を参照のこと。


File: elisp,  Node: Defining Images,  Next: Showing Images,  Prev: Other Image Types,  Up: Images

37.17.8 Defining Images
-----------------------

関数‘create-image’、‘defimage’、‘find-image’はイメージディスクリプタを作
成するための便利な手段を提供します。

 -- Function: create-image file-or-data &optional type data-p &rest
          props
     この関数は、FILE-OR-DATA内のデータを使用するイメージディスクリプタ
     を作成してリターンする。FILE-OR-DATAはファイル名、またはイメージデ
     ータを含む文字列を指定できる。前者の場合DATA-Pは‘nil’、後者なら非
     ‘nil’であること。

     オプション引数TYPEは、イメージタイプを指定するシンボルである。
     TYPEが省略または‘nil’なら、‘create-image’はファイル先頭の数バイト、
     またはファイル名からイメージタイプの判断を試みる。

     残りの引数PROPSは追加のイメージプロパティを指定する。たとえば、

          (create-image "foo.xpm" 'xpm nil :heuristic-mask t)

     このタイプのイメージがサポートされていなければ、この関数は‘nil’、そ
     れ以外ならイメージディスクリプタをリターンする。

 -- Macro: defimage symbol specs &optional doc
     このマクロは、イメージマクロとしてSYMBOLを定義する。引数SPECSは、そ
     のイメージの表示方法を指定するリストである。3つ目の引数DOCは、オプ
     ションのドキュメント文字列である。

     SPECS内の各要素はプロパティリストの形式をもち、それぞれが少なくとも
     ‘:type’プロパティと、‘:file’か‘:data’いずれかのプロパティをもつべき
     である。‘:type’の値はイメージタイプを指定するシンボル、‘:file’の値
     はイメージをロードするファイル、‘:data’の値は実際のイメージデータを
     含む文字列であること。以下は例である:

          (defimage test-image
            ((:type xpm :file "~/test1.xpm")
             (:type xbm :file "~/test1.xbm")))

     ‘defimage’はそれが使用可能か、つまりそのタイプがサポートされている
     かとファイルが存在するかを確認するために、各要素を1つずつテストする
     。最初に使用可能な引数が、SYMBOL内に格納するイメージディスクリプタ
     を作成するために使用される。

     機能する候補がなければ、SYMBOLは‘nil’として定義される。

 -- Function: find-image specs
     この関数は、イメージ仕様SPECSのリストの1つを満足するイメージを探す
     、便利な手段を提供する。

     SPECS内の各仕様は、イメージタイプに応じた内容のプロパティリストであ
     る。すべての仕様は少なくとも‘:type TYPE’、および‘:file FILE’か
     ‘:data DATA’いずれかのプロパティを含まなければならない。ここで
     TYPEは‘xbm’のようにイメージタイプを指定するシンボル、FILEはイメージ
     をロードするファイル、DATAは実際のイメージデータを含む文字列である
     。このリスト内でTYPEがサポートされていて、かつFILEが存在する最初の
     仕様は、リターンされるイメージ仕様の構築に使用される。満足する仕様
     がなければ、‘nil’がリターンされる。

     イメージは、‘image-load-path’内で検索される。

 -- Variable: image-load-path
     この変数の値は、イメージファイルを検索する場所のリストである。要素
     が文字列、または値が文字列であるような変数シンボルなら、その文字列
     は検索を行うディレクトリーとされる。値がリストであるような変数シン
     ボルの場合、それは検索を行うディレクトリーのリストとされる。

     デフォルトでは‘data-directory’で指定されたディレクトリーのサブディ
     レクトリー‘images’、次に‘data-directory’で指定されたディレクトリー
     、最後に‘load-path’で指定されたディレクトリー内を検索する。サブディ
     レクトリーは自動的には検索に含まれないので、イメージファイルをサブ
     ディレクトリー内に配置した場合は、サブディレクトリー名を明示的に与
     える必要がある。たとえば‘data-directory’内でイメージ
     ‘images/foo/bar.xpm’を見つけるには、以下のようにそのイメージを指定
     すること:

          (defimage foo-image '((:type xpm :file "foo/bar.xpm")))

 -- Function: image-load-path-for-library library image &optional path
          no-error
     この関数は、LispパッケージLIBRARYにより使用されるイメージにたいして
     、適切な検索パスをリターンする。

     この関数はまず‘image-load-path’(‘data-directory/images’を除外)を使
     用し、次に‘load-path’の後にLIBRARYにとって適切なパス(ライブラリーフ
     ァイル自身にたいする相対パス‘../../etc/images’と‘../etc/images’を含
     む)を補い、最後に‘data-directory/images’からIMAGEを検索する。

     その後にこの関数は、先頭にIMAGEが見つかったディレクトリー、その後に
     ‘load-path’の値が続く、ディレクトリーのリストをリターンする。PATHが
     与えられた場合は、それを‘load-path’のかわりに使用する。

     NO-ERRORが非‘nil’で、かつ適切なパスが見つからない場合に、エラーをシ
     グナルしない。かわりに前記のディレクトリーリストをリターンするが、
     イメージのディレクトリーの箇所に‘nil’が出現する点が異なる。

     以下は‘image-load-path-for-library’の使用例である:

          (defvar image-load-path) ; shush compiler
          (let* ((load-path (image-load-path-for-library
                              "mh-e" "mh-logo.xpm"))
                 (image-load-path (cons (car load-path)
                                        image-load-path)))
            (mh-tool-bar-folder-buttons-init))


File: elisp,  Node: Showing Images,  Next: Multi-Frame Images,  Prev: Defining Images,  Up: Images

37.17.9 Showing Images
----------------------

自分で‘display’プロパティをセットアップすることでイメージディスクリプタ
を使用できますが、このセクションの関数を使用するほうがより簡単です。

 -- Function: insert-image image &optional string area slice
     この関数は、カレントバッファーのポイント位置にIMAGEを挿入する。
     IMAGEは、イメージディスクリプタであること。これは‘create-image’によ
     りリターンされた値、または‘defimage’で定義されたシンボルの値かもし
     れない。引数STRINGは、イメージを保持するためにバッファー内に配すテ
     キストを指定する。これが省略または‘nil’なら、‘insert-image’はデフォ
     ルトで‘" "’を使用する。

     引数AREAは、マージン内にイメージを置くかどうかを指定する。これが
     ‘left-margin’なら左マージンにイメージが表示され、‘right-margin’なら
     右マージンを指定する。AREAが‘nil’または省略された場合、イメージはバ
     ッファーのテキスト内のポイント位置に表示される。

     引数SLICEは、挿入するイメージのスライスを指定する。SLICEが‘nil’また
     は省略された場合は、そのイメージ全体が挿入される。それ以外では、
     SLICEがリスト‘(X Y WIDTH HEIGHT)’ならXとYは位置、WIDTHとHEIGHTは挿
     入するイメージの領域を指定する。整数値はピクセル単位。0.0から1.0ま
     での浮動小数点数は、イメージ全体の幅または高さにたいする割合を指定
     する。

     内部的には、この関数はバッファー内にSTRINGを挿入して、IMAGEを指定す
     る‘display’プロパティにそれを渡す。*note Display Property::を参照の
     こと。

 -- Function: insert-sliced-image image &optional string area rows cols
     この関数は‘insert-image’と同様、カレントバッファー内にIMAGEを挿入す
     るが、イメージをROWS✕COLSの同一サイズのスライスに分割する。

     イメージが“スライス”されて挿入されると、Emacsは各スライスを個別のイ
     メージとして表示して、(巨大な)イメージを表示するバッファーのページ
     ングの際、イメージ全体を上下にジャンプするのではなく、より直感的な
     上下スクロールが可能になる。

 -- Function: put-image image pos &optional string area
     この関数は、カレントバッファー内のPOSの前に、イメージIMAGEを配置す
     る。引数POSは整数、またはマーカーであること。これは、イメージが表示
     されるべきバッファー位置を指定する。引数STRINGは、代替として表示さ
     れるべきデフォルトのイメージを保持するテキストであること。

     引数IMAGEはイメージディスクリプタでなければならず、それは
     ‘create-image’がリターンされたか、あるいは‘defimage’により格納され
     たイメージディスクリプタかもしれない。

     引数AREAは、マージン内にイメージを置くかどうかを指定する。これが
     ‘left-margin’なら左マージンにイメージが表示され、‘right-margin’なら
     右マージンを指定する。AREAが‘nil’または省略された場合、イメージはバ
     ッファーのテキスト内のポイント位置に表示される。

     内部的には、この関数はオーバーレイを作成して、値がそのイメージであ
     るような‘display’プロパティをもつテキストを含む、‘before-string’プ
     ロパティをそのオーバーレイに与えている(なんと!)。

 -- Function: remove-images start end &optional buffer
     この関数は、BUFFERの位置STARTとENDの間のイメージを削除する。
     BUFFERが省略または‘nil’なら、カレントバッファーからイメージを削除す
     る。

     これは‘put-image’が行う方法でBUFFERに配置されたイメージだけを削除し
     、‘insert-image’や他の方法で挿入されたイメージは削除しない。

 -- Function: image-size spec &optional pixels frame
     この関数は、ペアー‘(WIDTH . HEIGHT)’として、イメージのサイズをリタ
     ーンする。SPECはイメージ仕様である。PIXELSが非‘nil’ならピクセル単位
     、それ以外ならcanonicalな文字単位(そのフレームのデフォルトフォント
     の幅/高さの割合)で量ったサイズをリターンする。FRAMEは、イメージが表
     示されるフレームである。FRAMEが‘nil’または省略された場合は、選択さ
     れたフレームを使用する(*note Input Focus::を参照)。

 -- Variable: max-image-size
     この変数は、Emacsがロードするイメージの最大サイズを定義するために使
     用される。Emacsはこの制限より大きいイメージのロード(と表示)を拒絶す
     るだろう。

     値が整数なら、それはピクセル単位で量ったイメージの最大の高さと幅を
     、直接指定する。浮動小数点数なら、そのフレームの高さおよび幅にたい
     する比率として、イメージの最大の高さと幅を指定する。値が数値でなけ
     れば、イメージサイズにたいする明示的な制限は存在しない。

     この変数の目的は、意図せずEmacsに不当に大きなイメージがロードされる
     とを防ぐことである。これは、イメージの初回ロード時だけ効果がある。
     イメージが一度イメージキャッシュに置かれると、その後
     ‘max-image-size’の値が変更されても、そのイメージは常に表示可能であ
     る(*note Image Cache::を参照)。


File: elisp,  Node: Multi-Frame Images,  Next: Image Cache,  Prev: Showing Images,  Up: Images

37.17.10 Multi-Frame Images
---------------------------

複数のイメージを含むことができるイメージファイルがいくつかあります。わた
したちはこのような場合、イメージ内に複数の“フレーム”があると表現していま
す。現在のところ、EmacsはGIF、TIFF、およびDJVMのような特定の
ImageMagickフォーマットにたいして、複数フレームをサポートします。

   フレームは、複数の“ページ”を表現するため(通常は、たとえばマルチフレー
ムTIFFの場合)、あるいはアニメーションを作成するため(通常はマルチフレーム
GIFファイルの場合)に使用できます。

   マルチフレームイメージは、表示されるフレームを指定する整数値(0から数
える)が値であるような、プロパティ‘:index’をもっています。

 -- Function: image-multi-frame-p image
     この関数は、IMAGEが2つ以上のフレームを含む場合は、非‘nil’をリターン
     する。実際のリターン値はコンス‘(NIMAGES . DELAY)’で、NIMAGESはフレ
     ーム数、DELAYはフレーム間の遅延秒数、イメージが遅延を指定しない場合
     は‘nil’である。通常、アニメーションを意図されたイメージはフレームの
     遅延を指定し、複数ページとして扱われることを意図したイメージは指定
     しない。

 -- Function: image-current-frame image
     この関数はIMAGEにたいして、0から数えたカレントフレーム番号のインデ
     ックスをリターンする。

 -- Function: image-show-frame image n &optional nocheck
     この関数は、IMAGEをフレーム番号Nとスイッチする。NOCHECKが‘nil’なら
     、有効範囲外のフレーム番号を範囲終端に置き換える。IMAGEが指定された
     番号のフレームを含まなければ、イメージは中貫きの四角(hollow box)で
     表示される。

 -- Function: image-animate image &optional index limit
     この関数は、IMAGEをアニメーション表示する。オプションの整数INDEXは
     、開始するフレームを指定する(デフォルトは0)。オプション引数LIMITは
     、アニメーションの長さを制御する。これが省略または‘nil’なら、アニメ
     ーション回数は1回、‘t’なら永久にループ表示する。数値なら、その秒数
     後にアニメーションは停止する。

アニメーションはタイマーにより処理されます。Emacsは最小のフレーム遅延を
0.01秒(‘image-minimum-frame-delay’)とすることに注意してください。そのイ
メージ自身が遅延を指定しなければ、Emacsは‘image-default-frame-delay’を使
用します。

 -- Function: image-animate-timer image
     この関数は、もし存在すればIMAGEのアニメーションに責任をもつタイマー
     をリターンする。


File: elisp,  Node: Image Cache,  Prev: Multi-Frame Images,  Up: Images

37.17.11 Image Cache
--------------------

Emacsはイメージをより効果的に再表示できるように、イメージをキャッシュし
ます。Emacsがイメージを表示する際、既存のイメージ仕様が望む仕様と
‘equal’なイメージキャッシュを検索します。マッチが見つかったら、そのイメ
ージはキャッシュから表示され、それ以外ではイメージは通常のようにロードさ
れます。

 -- Function: image-flush spec &optional frame
     この関数は、フレームFRAMEのイメージキャッシュから、仕様SPECのイメー
     ジを削除する。イメージ仕様の比較には、‘equal’を使用する。FRAMEが
     ‘nil’の場合のデフォルトは選択されたフレーム。FRAMEが‘t’なら、そのイ
     メージはすべての既存フレームでフラッシュされる。

     Emacsのカレント実装では、各グラフィカル端末はイメージキャッシュを処
     理して、それはその端末上のすべてのフレームにより共有される(*note
     Multiple Terminals::を参照)。つまりあるフレームでイメージをリフレッ
     シュすると、同一端末上の他のすべてのフレームでもリフレッシュされる
     。

   ‘image-flush’の1つの用途は、Emacsにイメージファイルの変更を伝えること
です。イメージ仕様が‘:file’プロパティを含む場合、そのイメージの初回表示
時にそのファイルコンテンツにもとづいて、イメージがキャッシュされます。た
とえその後にファイルが変更されても、Emacsはそのイメージの古いバージョン
を表示し続けます。‘image-flush’を呼び出すことによりそのイメージはキャッ
シュからフラッシュされ、そのイメージの表示が次回必要になった際に、
Emacsにファイルの再読み込みを強制します。

   ‘image-flush’の他の用途は、メモリー節約です。Lispプログラムで
‘image-cache-eviction-delay’(以下参照)より遥かに短い期間に多数の一時イメ
ージを作成する場合には、Emacsが自動的に行うことを待たずに、自身で使用さ
れていないイメージのフラッシュを選択できます。

 -- Function: clear-image-cache &optional filter
     この関数は、イメージキャッシュ内に格納されたすべてのイメージを削除
     して、イメージキャッシュをクリアーする。FILTERが省略または‘nil’なら
     、選択されたフレームにたいしてキャッシュをクリアーする。FILTERがフ
     レームなら、そのフレームにたいしてキャッシュをクリアーする。
     FILTERが‘t’なら、すべてのイメージキャッシュをクリアーする。それ以外
     なら、FILTERはファイル名として解釈され、すべてのイメージキャッシュ
     からそのファイル名に関連付けられたすべてのイメージを削除する。

   イメージキャッシュ内のイメージが指定された期間内に表示されなければ、
Emacsはそれをキャッシュから削除して、割り当てられたメモリーを解放します
。

 -- Variable: image-cache-eviction-delay
     この変数は、表示されることなくイメージがキャッシュ内に残留できる秒
     数を指定する。あるイメージがこの秒数の間に表示されなければ、Emacsは
     それをイメージキャッシュから削除する。

     ある状況下では、もしキャッシュ内のイメージ数が大きくなり過ぎた場合
     には、実際の立ち退き遅延(eviction delay)はこれより短くなり得る。

     値が‘nil’なら、明示的にキャッシュをクリアーした場合を除き、Emacsは
     キャッシュからイメージを削除しない。このモードはデバッグ時に有用か
     もしれない。


File: elisp,  Node: Buttons,  Next: Abstract Display,  Prev: Images,  Up: Display

37.18 Buttons
=============

Buttonパッケージは、マウスまたはキーボードコマンドによりアクティブ化する
ことができる、“ボタン(buttons)”の挿入と操作に関する関数を定義します。こ
れらのボタンは典型的には、種々のハイパーリンクに使用されます。

   本質的にボタンとは、バッファー内のテキスト範囲にアタッチされた、テキ
ストプロパティまたはオーバーレイプロパティのセットです。これらのプロパテ
ィは、“ボタンプロパティ(button properties)”と呼ばれます。これらのプロパ
ティのうちの1つは“アクションプロパティ(action property)”で、これはユーザ
ーがキーボードかマウスを使用してボタンを呼び出した際に呼び出される関数を
指定します。アクション関数はボタンを調べて、必要に応じて他のプロパティを
使用できます。

   いくつかの点において、ButtonパッケージとWidgetパッケージは機能的に重
複しています。*note Introduction: (widget)Top.を参照してください。
Buttonパッケージの利点は、より高速で小さく、プログラムにたいしてよりシン
プルであることです。ユーザーの観点からは、2つのパッケージが提供するイン
ターフェイスは非常に類似しています。

* Menu:

* Button Properties::        特別な意味をもつボタンプロパティ。
* Button Types::             ボタンのクラスにたいして一般的なプロパティを定義する。
* Making Buttons::           Emacsバッファーへのボタンの追加。
* Manipulating Buttons::     ボタンプロパティの取得とセット。
* Button Buffer Commands::   ボタンにたいするバッファー規模のコマンドとバインディング。


File: elisp,  Node: Button Properties,  Next: Button Types,  Up: Buttons

37.18.1 Button Properties
-------------------------

ボタンはその外観と振る舞いを定義するプロパティの連想リスト(associated
list)をもち、アプリケーションの特別な目的のために、他の任意のプロパティ
を使用できます。以下のプロパティは、Buttonパッケージにたいして特別な意味
をもちます:

‘action’
     ユーザーがボタンを呼び出した際に呼び出す関数で、単一の引数BUTTONを
     渡して呼び出される。デフォルトではこれは、何も行わない‘ignore’であ
     る。

‘mouse-action’
     これは‘action’と似ているが、もし与えられた際には、(<RET>押下のかわ
     りに)マウスクリックによりボタンが呼び出された場合は、‘action’のかわ
     りに使用される。与えられない場合、マウスクリックはかわりに
     ‘action’を使用する。

‘face’
     これは、このタイプのボタンが表示される方法を制御するEmacsフェイスで
     ある。デフォルトでは‘button’フェイス。

‘mouse-face’
     これはボタン上にマウスがある際の外観を制御する、追加のフェイスであ
     る(通常のbuttonフェイスとマージされる)。デフォルトでは、これは
     Emacsの通常の‘highlight’フェイスである。

‘keymap’
     そのボタンリージョン(button region)でアクティブなバインディングを定
     義する、ボタンのキーマップである。デフォルトでは、変数
     ‘button-map’に格納された、通常のボタンリージョンキーマップで、これ
     はボタン呼び出しにたいして<RET>と<mouse-2>を定義している。

‘type’
     ボタンのタイプ。*note Button Types::を参照のこと。

‘help-echo’
     Emacsのツールチップヘルプシステムにより表示あれる文字列。デフォルト
     では‘"mouse-2, RET: Push this button"’。

‘follow-link’
     このボタンにたいして<Mouse-1>クリックが振る舞う方法を定義する
     follow-linkプロパティ。*note Clickable Text::を参照のこと。

‘button’
     すべてのボタンは非‘nil’の‘button’プロパティをもち、これはボタンを含
     むテキストリージョンを探すのに有用かもしれない()標準的なボタン関数
     はこれを行う。

   ボタン内のテキストリージョンにたいして定義された他のプロパティも存在
しますが、それらは典型的な用途にたいしては一般的に関係ないでしょう。


File: elisp,  Node: Button Types,  Next: Making Buttons,  Prev: Button Properties,  Up: Buttons

37.18.2 Button Types
--------------------

すべてのボタンは、そのボタンのプロパティにたいするデフォルト値を定義する
、“ボタンタイプ(button type)”をもっています。ボタンタイプは、より汎用的
なタイプから特化したタイプへと継承される階層構造で構成されており、特定の
タスクにたいしては、特殊用途のボタンを簡単に定義できます。

 -- Function: define-button-type name &rest properties
     NAME(シンボル)と呼ばれるボタンタイプを定義する。残りの引数は
     PROPERTY VALUEペアーのシーケンスを形成する。これは、そのタイプのボ
     タンにたいする、デフォルトのプロパティ値を指定する(ボタンのタイプは
     キーワード引数‘:type’を使用して、ボタン作成時にそれを‘type’プロパテ
     ィに与えることによりセット可能)。

     加えて、NAMEがデフォルトプロパティ値を継承するボタンタイプ指定する
     ために、キーワード引数‘:supertype’を使用できる。この継承は、NAMEの
     定義時のみ発生することに注意。その後にsupertypeに行われた変更は、そ
     のsubtypeには反映されない。

   ‘define-button-type’を使用してボタンのデフォルトプロパティを定義する
のは必須ではありません — 特定のタイプをもたないボタンはビルトインのボタ
ンタイプ‘button’を使用します — が推奨されません。これを行うことにより通
常はコードがより明快かつ効果的になるからです。


File: elisp,  Node: Making Buttons,  Next: Manipulating Buttons,  Prev: Button Types,  Up: Buttons

37.18.3 Making Buttons
----------------------

ボタンは、ボタン固有の情報を保持するために、オーバーレイプロパティかテキ
ストプロパティを使用して、テキストのリージョンに関連付けられます。これら
はすべて、そのボタンのタイプ(デフォルトはビルトインのボタンタイプ
‘button’)から初期化されます。すべてのEmacsテキストと同様、ボタンの外観は
‘face’プロパティにより制御されます。(ボタンタイプ‘button’から継承された
‘face’プロパティを通じることにより)デフォルトでは典型的なウェブページリ
ンクのような、シンプルなアンダーラインです。

   簡便さのために2種類のボタン作成関数があります。1つはバッファーの既存
リージョンにボタンプロパティを追加する、‘make-...button’と呼ばれる関数と
、ボタンテキストを挿入する‘insert-...button’と呼ばれる関数です。

   すべてのボタン作成関数は、‘&rest’引数のPROPERTIESを受け取ります。これ
はボタンに追加するプロパティを指定する、PROPERTY VALUEペアーのシーケンス
である必要があります。*note Button Properties::を参照してください。これ
に加えて、他のプロパティの継承元となるボタンタイプの指定に、キーワード引
数‘:type’を使用できます。*note Button Types::を参照してください。作成の
間に明示的に指定されなかったプロパティは、(そのタイプがそのようなプロパ
ティを定義していれば)そのボタンのタイプから継承されます。

   以下の関数は、ボタンプロパティを保持するために、オーバーレイを使用し
てボタンを追加します(*note Overlays::を参照)。

 -- Function: make-button beg end &rest properties
     これはカレントバッファー内のBEGからENDにボタンを作成して、それをリ
     ターンする。

 -- Function: insert-button label &rest properties
     これはポイント位置にラベルLABELのボタンを挿入して、それをリターンす
     る。

   以下の関数も同様ですが、ボタンプロパティを保持するためにテキストプロ
パティを使用します(*note Text Properties::を参照)。この種のボタンはバッ
ファーにマーカーを追加せず、非常に多数のボタンが存在しても、バッファーで
の編集が低速になることはありません。しかしそのテキストに既存のfaceテキス
トプロパティが存在する場合(たとえばFont Lockモードにより割り当てられたフ
ェイス)、そのボタンのフェイスは可視にならないかもしれません。これらの関
数はいずれも、新たなボタンの開始位置をリターンします。

 -- Function: make-text-button beg end &rest properties
     これはテキストプロパティを使用して、カレントバッファー内のBEGから
     ENDにボタンを作成する。

 -- Function: insert-text-button label &rest properties
     これはテキストプロパティを使用して、ポイント位置にラベルLABELのボタ
     ンを挿入する。


File: elisp,  Node: Manipulating Buttons,  Next: Button Buffer Commands,  Prev: Making Buttons,  Up: Buttons

37.18.4 Manipulating Buttons
----------------------------

ボタンのプロパティの取得、およびセットを行う関数が存在します。これらは何
を行うかを判断するために、ボタンが呼び出す価数によりよく使用される関数で
す。

   BUTTONパラメーターが指定された場合は、オーバーレイ(オーバーレイボタン
の場合)、またはバッファー位置やマーカー(テキストプロパティボタンの場合
)いずれかの、特定のボタンを参照するオブジェクトを意味します。そのような
オブジェクトは、ボタンが関数を呼び出す際に1つ目の引数として渡されます。

 -- Function: button-start button
     BUTTONが開始される位置をリターンする。

 -- Function: button-end button
     BUTTONが終了する位置をリターンする。

 -- Function: button-get button prop
     ボタンBUTTONのPROPという名前のプロパティを取得する。

 -- Function: button-put button prop val
     BUTTONのPROPプロパティにVALをセットする。

 -- Function: button-activate button &optional use-mouse-action
     BUTTONの‘action’プロパティを呼び出す(単一の引数BUTTONを渡して、その
     プロパティの値である関数を呼び出す)。USE-MOUSE-ACTIONが非‘nil’なら
     、‘action’のかわりにそのボタンの‘mouse-action’プロパティの呼び出し
     を試みる。ボタンが‘mouse-action’プロパティをもたなければ、通常どお
     り‘action’を使用する。

 -- Function: button-label button
     BUTTONのテキストラベルをリターンする。

 -- Function: button-type button
     BUTTONのボタンタイプをリターンする。

 -- Function: button-has-type-p button type
     BUTTONがボタンタイプTYPE、またはTYPEのsubtypeのいずれかをもつなら
     ‘t’をリターンする。

 -- Function: button-at pos
     カレントバッファー内の位置POSにあるボタン、または‘nil’をリターンす
     る。POSにあるボタンがテキストプロパティボタンなら、リターン値は
     POSを指すマーカーとなる。

 -- Function: button-type-put type prop val
     ボタンタイプTYPEのPROPプロパティに、VALをセットする。

 -- Function: button-type-get type prop
     ボタンタイプTYPEの、PROPという名前のプロパティを取得する。

 -- Function: button-type-subtype-p type supertype
     ボタンタイプTYPEがSUPERTYPEのsubtypeなら、‘t’をリターンする。


File: elisp,  Node: Button Buffer Commands,  Prev: Manipulating Buttons,  Up: Buttons

37.18.5 Button Buffer Commands
------------------------------

Emacsバッファー内に、ボタンの配置や操作を行うコマンドや関数が存在します
。

   ‘push-button’はユーザーが実際にボタンを‘押下’するために使用するコマン
ドであり、そのボタンのオーバーレイプロパティ、またはテキストプロパティを
使用することにより、そのボタンの<RET>および<mouse-2>にデフォルトでバイン
ドされます。ボタン自身の外部で有用な‘forward-button’や
‘backward-button’のようなコマンドは、‘button-buffer-map’に格納されたキー
マップ内で追加で利用可能です。ボタンを使用するモードは、そのキーマップの
親キーマップとして、‘button-buffer-map’の使用を望むかもしれません。

   ボタンが非‘nil’の‘follow-link’プロパティをもち、かつ
‘mouse-1-click-follows-link’がセットされている場合は、素早い<Mouse-1>ク
リックにより‘push-button’コマンドもアクティブになるでしょう。*note
Clickable Text::を参照してください。

 -- Command: push-button &optional pos use-mouse-action
     位置POSにあるボタンが指定するアクションを行う。POSはバッファー位置
     、またはマウスイベントのいずれか。USE-MOUSE-ACTIONが非‘nil’、または
     POSがマウスイベントなら、‘action’のかわりにそのボタンの
     ‘mouse-action’プロパティの呼び出しを試み、ボタンに‘mouse-action’プ
     ロパティがなければ、通常のように‘action’を使用する。‘push-button’が
     マウスイベントの結果としてインタラクティブに呼び出されたときはその
     マウスイベントの位置、それ以外ではポイントの位置が、POSのデフォルト
     になる。POSにボタンがなければ何もせずに‘nil’をリターンし、それ以外
     なら‘t’をリターンする。

 -- Command: forward-button n &optional wrap display-message
     次のN番目、Nが負なら前のN番目のボタンに移動する。Nが0なら、ポイント
     位置にある任意のボタンの開始に移動する。WRAPが非‘nil’なら、バッファ
     ーの先頭または終端を超えて、もう一方の端へ移動を継続する。
     DISPLAY-MESSAGEが非‘nil’なら、そのボタンのhelp-echo文字列が表示され
     る。非‘nil’の‘skip’プロパティをもつボタンは、すべてスキップされる。
     見つかったボタンをリターンする。

 -- Command: backward-button n &optional wrap display-message
     前のN番目、Nが負なら次のN番目のボタンに移動する。Nが0なら、ポイント
     位置にある任意のボタンの開始に移動する。WRAPが非‘nil’なら、バッファ
     ーの先頭または終端を超えて、もう一方の端へ移動を継続する。
     DISPLAY-MESSAGEが非‘nil’なら、そのボタンのhelp-echo文字列が表示され
     る。非‘nil’の‘skip’プロパティをもつボタンは、すべてスキップされる。
     見つかったボタンをリターンする。

 -- Function: next-button pos &optional count-current
 -- Function: previous-button pos &optional count-current
     カレントバッファー内の位置POSの次(‘next-button’の場合)、または前
     (‘previous-button’の場合)のボタンをリターンする。COUNT-CURRENTが非
     ‘nil’なら、次のボタンから検索を開始するかわりに、POSにある任意のボ
     タンを考慮する。


File: elisp,  Node: Abstract Display,  Next: Blinking,  Prev: Buttons,  Up: Display

37.19 Abstract Display
======================

Ewocパッケージは、Lispオブジェクトの構造を表すバッファーテキストを構成し
、その構造体の変更にしたがってテキストを更新します。これはデザインパラダ
イム“model/view/controller”内の、“view”コンポーネントと似ています。
Ewocは、“Emacs’s Widget for Object Collections(オブジェクトコレクション
用Emacsウィジェット)”を意味します。

   “ewoc”は特定のLispデータを表現するバッファーテキストの構築に要される
情報を組織化します。ewocのバッファーテキストは順番に、まず固定された
“header”テキスト、次に一連のデータ要素のテキスト記述(あなたが指定する
Lispオブジェクト)、最後に固定された“footer”テキストという、3つのパートを
もっています。具体的には、ewocは以下の情報を含んでいます:

   • そのテキストが生成されたバッファー。

   • バッファー内でのそのテキストの開始位置。

   • ヘッダー文字列とフッター文字列。

   • 2重リンクされた“ノード(nodes)”のチェーン。各ノードは以下を含む:

        • “データ要素(data element)”。単一のLispオブジェクトである。

        • そのチェーン内で先行および後続するノードへのリンク。

   • カレントバッファー内にデータ要素値のテキスト表現を挿入する責務をも
     つ、“pretty-printer”関数。

   通常は‘ewoc-create’によりewocを定義して、その結果のewoc構造体内にノー
ドを構築するために、それをEwocパッケージ内の別の関数に渡してバッファー内
に表示します。バッファー内でこれが一度表示されれば、他の関数はバッファー
位置とノードの対応を判断したり、あるノードのテキスト表現から別のノードの
テキスト表現への移動等を行います。*note Abstract Display Functions::を参
照してください。

   ノードは、変数が値を保持するのと同じ方法で、データ要素を“カプセル化
(encapsulate)”します。カプセル化は通常、ewocへのノード追加の一部として発
生します。以下のように、データ要素値を取得して、その場所に新たな値を配置
することができます:

     (ewoc-data NODE)
     ⇒ value

     (ewoc-set-data NODE NEW-VALUE)
     ⇒ NEW-VALUE

データ要素値として、“実際”の値のコンテナーであるようなLispオブジェクト
(リストまたはベクター)、または他の構造体へのインデックスも使用できます。
例(*note Abstract Display Example::を参照)では、後者のアプローチを使用し
ています。

   データが変更された際には、バッファー内のテキストを更新したいでしょう
。‘ewoc-refresh’呼び出しにより全ノード、‘ewoc-invalidate’を使用して特定
のノード、または‘ewoc-map’を使用して述語を満足するすべてのノードを更新で
きます。あるいは、‘ewoc-delete’を使用して無効なノードを削除したり、その
場所に新たなノードを追加できます。ewocからのノード削除は、バッファーから
それに関連付けられたテキスト記述も同様に削除します。

* Menu:

* Abstract Display Functions::  Ewocパッケージ内の関数。
* Abstract Display Example::  Ewocの使用例。


File: elisp,  Node: Abstract Display Functions,  Next: Abstract Display Example,  Up: Abstract Display

37.19.1 Abstract Display Functions
----------------------------------

このセクションでは、EWOCとNODEは上述(*note Abstract Display::を参照)の構
造体を、DATAはデータ要素として使用される任意のLispオブジェクトを意味しま
す。

 -- Function: ewoc-create pretty-printer &optional header footer nosep
     これは、ノード(とデータ要素)をもたない新たなewocを構築してリターン
     する。PRETTY-PRINTERは1つの引数をとる関数であること。この引数は当該
     ewoc内で使用を計画する類のデータ要素であり、‘insert’を使用してポイ
     ント位置にそのテキスト記述を挿入する(Ewocパッケージの内部的メカニズ
     ムと干渉するため‘insert-before-markers’は決して使用しない)。

     通常ヘッダー、フッター、およびすべてのノードのテキスト記述の後には
     、自動的に改行が挿入される。NOSEPが非‘nil’なら、改行は何も挿入され
     ない。これはewoc全体を単一行に表示したり、これらのノードにたいして
     何も行わないようPRETTY-PRINTERをアレンジすることによりノードを“不可
     視”にするために有用かもしれない。

     ewocは作成時にカレントだったバッファー内のテキストを保守するので、
     ‘ewoc-create’呼び出し前に意図するバッファーへ切り替えること。

 -- Function: ewoc-buffer ewoc
     これは、EWOCがそのテキストを保守するバッファーをリターンする。

 -- Function: ewoc-get-hf ewoc
     これは、EWOCのヘッダーとフッターから作成された、コンスセル‘(HEADER
     . FOOTER)’をリターンする。

 -- Function: ewoc-set-hf ewoc header footer
     これは、EWOCのヘッダーおよびフッターに、文字列HEADERおよびFOOTERを
     セットする。

 -- Function: ewoc-enter-first ewoc data
 -- Function: ewoc-enter-last ewoc data
     これらはそれぞれ、DATAを新たなノードにカプセル化して、それをEWOCの
     チェーンノードの先頭または終端に配置する。

 -- Function: ewoc-enter-before ewoc node data
 -- Function: ewoc-enter-after ewoc node data
     これらはそれぞれ、DATAを新たなノードにカプセル化して、それをEWOCの
     NODEの前または後に追加する。

 -- Function: ewoc-prev ewoc node
 -- Function: ewoc-next ewoc node
     これらはそれぞれ、EWOC内のNODEの前、または次のノードをリターンする
     。

 -- Function: ewoc-nth ewoc n
     これは、EWOC内で0基準のインデックスNで見つかったノードをリターンす
     る。負のNは、終端から数えることを意味する。Nが範囲外なら、
     ‘ewoc-nth’は‘nil’をリターンする。

 -- Function: ewoc-data node
     これは、NODEにカプセル化されたデータを抽出して、それをリターンする
     。

 -- Function: ewoc-set-data node data
     これは、NODEにカプセル化されるデータとして、DATAをセットする。

 -- Function: ewoc-locate ewoc &optional pos guess
     これはポイント(指定された場合はPOS)を含むEWOC内のノードを判断して、
     そのノードをリターンする。EWOCがノードをもたなければ、‘nil’をリター
     ンする。POSが最初のノードの前なら最初のノード、最後のノードの後なら
     最後のノードをリターンする。オプションの3つ目の引数GUESSは、POS近傍
     にあると思われるノードであること。これは結果を変更しないが、関数の
     実行を高速にする。

 -- Function: ewoc-location node
     これは、NODEの開始位置をリターンする。

 -- Function: ewoc-goto-prev ewoc arg
 -- Function: ewoc-goto-next ewoc arg
     これらはそれぞれ、EWOC内の前、または次のARG番目のノードにポイントを
     移動する。すでに最初のノードにポイントがある場合、またはEWOCが空の
     場合、‘ewoc-goto-prev’は移動しない。また‘ewoc-goto-next’が最後のノ
     ードを超えて移動した場合、結果は‘nil’となる。この特殊なケースを除き
     、これらの関数は移動先のノードをリターンする。

 -- Function: ewoc-goto-node ewoc node
     これは、EWOC内のNODEの開始にポイントを移動する。

 -- Function: ewoc-refresh ewoc
     この関数は、EWOCのテキストを再生成する。これはヘッダーとフッターの
     間のテキスト、すなわちすべてのデータ要素の表現を削除して、各ノード
     にたいして1つずつ順にpretty-printer関数を呼び出すことによりすること
     により機能する。

 -- Function: ewoc-invalidate ewoc &rest nodes
     これは‘ewoc-refresh’と似ているが、EWOC内のノードセット全体ではなく
     、NODESだけを対象とする点が異なる。

 -- Function: ewoc-delete ewoc &rest nodes
     これは、EWOCからNODES内の各要素を削除する。

 -- Function: ewoc-filter ewoc predicate &rest args
     これはEWOC内の各データ要素にたいしてPREDICATEを呼び出し、
     PREDICATEが‘nil’をリターンしたノードを削除する。任意のARGSを、
     PREDICATEに渡すことができる。

 -- Function: ewoc-collect ewoc predicate &rest args
     これはEWOC内の各データ要素にたいしてPREDICATEを呼び出し、
     PREDICATEが非‘nil’をリターンしたノードのリストをリターンする。リス
     ト内の要素は、そのバッファー内での順序になる。任意のARGSを、
     PREDICATEに渡すことができる。

 -- Function: ewoc-map map-function ewoc &rest args
     これはEWOC内の各データ要素にたいしてMAP-FUNCTIONを呼び出し、
     MAP-FUNCTIONが非‘nil’をリターンしたノードを更新する。任意のARGSを、
     MAP-FUNCTIONに渡すことができる。


File: elisp,  Node: Abstract Display Example,  Prev: Abstract Display Functions,  Up: Abstract Display

37.19.2 Abstract Display Example
--------------------------------

以下は、3つの整数からなるベクターを表すバッファー内の領域である、“color
components display”を、ewocパッケージ内の関数を使用して、さまざまな方法
で実装するシンプルな例です。

     (setq colorcomp-ewoc nil
           colorcomp-data nil
           colorcomp-mode-map nil
           colorcomp-labels ["Red" "Green" "Blue"])

     (defun colorcomp-pp (data)
       (if data
           (let ((comp (aref colorcomp-data data)))
             (insert (aref colorcomp-labels data) "\t: #x"
                     (format "%02X" comp) " "
                     (make-string (ash comp -2) ?#) "\n"))
         (let ((cstr (format "#%02X%02X%02X"
                             (aref colorcomp-data 0)
                             (aref colorcomp-data 1)
                             (aref colorcomp-data 2)))
               (samp " (sample text) "))
           (insert "Color\t: "
                   (propertize samp 'face
                               `(foreground-color . ,cstr))
                   (propertize samp 'face
                               `(background-color . ,cstr))
                   "\n"))))

     (defun colorcomp (color)
       "新たなバッファー内でCOLORの編集を許可する。
     そのバッファーはColor Componentsモードになる。"
       (interactive "sColor (name or #RGB or #RRGGBB): ")
       (when (string= "" color)
         (setq color "green"))
       (unless (color-values color)
         (error "No such color: %S" color))
       (switch-to-buffer
        (generate-new-buffer (format "originally: %s" color)))
       (kill-all-local-variables)
       (setq major-mode 'colorcomp-mode
             mode-name "Color Components")
       (use-local-map colorcomp-mode-map)
       (erase-buffer)
       (buffer-disable-undo)
       (let ((data (apply 'vector (mapcar (lambda (n) (ash n -8))
                                          (color-values color))))
             (ewoc (ewoc-create 'colorcomp-pp
                                "\nColor Components\n\n"
                                (substitute-command-keys
                                 "\n\\{colorcomp-mode-map}"))))
         (set (make-local-variable 'colorcomp-data) data)
         (set (make-local-variable 'colorcomp-ewoc) ewoc)
         (ewoc-enter-last ewoc 0)
         (ewoc-enter-last ewoc 1)
         (ewoc-enter-last ewoc 2)
         (ewoc-enter-last ewoc nil)))

   この例は、‘colorcomp-data’の変更して、選択プロセスを“完了”し、それら
を互いに簡便に結ぶキーマップを定義することにより(別の言い方をすると
“model/view/controller”デザインパラダイムのcontroller部分)、“color
selection widget”への拡張が可能です。

     (defun colorcomp-mod (index limit delta)
       (let ((cur (aref colorcomp-data index)))
         (unless (= limit cur)
           (aset colorcomp-data index (+ cur delta)))
         (ewoc-invalidate
          colorcomp-ewoc
          (ewoc-nth colorcomp-ewoc index)
          (ewoc-nth colorcomp-ewoc -1))))

     (defun colorcomp-R-more () (interactive) (colorcomp-mod 0 255 1))
     (defun colorcomp-G-more () (interactive) (colorcomp-mod 1 255 1))
     (defun colorcomp-B-more () (interactive) (colorcomp-mod 2 255 1))
     (defun colorcomp-R-less () (interactive) (colorcomp-mod 0 0 -1))
     (defun colorcomp-G-less () (interactive) (colorcomp-mod 1 0 -1))
     (defun colorcomp-B-less () (interactive) (colorcomp-mod 2 0 -1))

     (defun colorcomp-copy-as-kill-and-exit ()
       "color componentsをkillリングにコピーしてバッファーをkill。
     文字列は#RRGGBB(6桁16進が付加されたハッシュ)にフォーマットされる。"
       (interactive)
       (kill-new (format "#%02X%02X%02X"
                         (aref colorcomp-data 0)
                         (aref colorcomp-data 1)
                         (aref colorcomp-data 2)))
       (kill-buffer nil))

     (setq colorcomp-mode-map
           (let ((m (make-sparse-keymap)))
             (suppress-keymap m)
             (define-key m "i" 'colorcomp-R-less)
             (define-key m "o" 'colorcomp-R-more)
             (define-key m "k" 'colorcomp-G-less)
             (define-key m "l" 'colorcomp-G-more)
             (define-key m "," 'colorcomp-B-less)
             (define-key m "." 'colorcomp-B-more)
             (define-key m " " 'colorcomp-copy-as-kill-and-exit)
             m))

   わたしたちが決して各ノード内のデータを変更していないことに注意してく
ださい。それらのデータはewoc作成時に‘nil’、または実際のカラーコンポーネ
ントであるベクター‘colorcomp-data’にたいするインデックスに固定されていま
す。


File: elisp,  Node: Blinking,  Next: Character Display,  Prev: Abstract Display,  Up: Display

37.20 Blinking Parentheses
==========================

このセクションでは、ユーザーが閉カッコを挿入した際に、マッチする開カッコ
をEmacsが示すメカニズムを説明します。

 -- Variable: blink-paren-function
     この変数の値は、閉カッコ構文(close parenthesis syntax)の文字が挿入
     された際に、常に呼び出される関数(引数なし)であること。
     ‘blink-paren-function’の値は‘nil’も可能で、この場合は何も行わない。

 -- User Option: blink-matching-paren
     この変数が‘nil’なら、‘blink-matching-open’は何も行わない。

 -- User Option: blink-matching-paren-distance
     この変数は、ギブアップする前にマッチするカッコをスキャンする、最大
     の距離を指定する。

 -- User Option: blink-matching-delay
     この変数は、マッチするカッコを示し続ける秒数を指定する。分数の秒も
     よい結果をもたらすことがあるが、デフォルトはすべてのシステムで機能
     する1である。

 -- Command: blink-matching-open
     この関数は、‘blink-paren-function’のデフォルト値である。この関数は
     、閉カッコ構文の文字の後にポイントがあると仮定し、マッチする開カッ
     コに瞬時適切な効果を適用する。その文字がまだスクリーン上になければ
     、エコーエリア内にその文字のコンテキストを表示する。長い遅延を避け
     るために、この関数は文字数‘blink-matching-paren-distance’より遠くを
     検索しない。

     以下は、この関数を明示的に呼び出す例である。

          (defun interactive-blink-matching-open ()
            "ポイント前のカッコによるsexp開始を瞬時示す"
            (interactive)
            (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))


File: elisp,  Node: Character Display,  Next: Beeping,  Prev: Blinking,  Up: Display

37.21 Character Display
=======================

このセクションでは、文字がEmacsにより実際に表示される方法について説明し
ます。文字は通常“グリフ(glyph)”として表示されます。グリフとは、スクリー
ン上で1文字の位置を占めるグラフィカルなシンボルであり、その外観はその文
字自身に対応します。たとえば文字‘a’(文字コード97)は、‘a’と表示されます。
しかし、いくつかの文字は特別な方法で表示されます。たとえば、改頁文字(文
字コード12)は、通常は2つのグリフのシーケンス‘^L’で表示され、改行文字(文
字コード10)は新たなスクリーン行を開始します。

   “ディスプレイテーブル(display table)”を定義することにより、各文字が表
示される方法を変更できます。これはそれぞれの文字を、グリフのシーケンスに
マップするテーブルです。*note Display Tables::を参照してください。

* Menu:

* Usual Display::            文字の表示にたいする通常の慣習。
* Display Tables::           ディスプレイテーブルの構成要素。
* Active Display Table::     使用するディスプレイテーブルをEmacsが選択する方法。
* Glyphs::                   グリフの定義方法とグリフの意味。
* Glyphless Chars::          グリフなしの文字の描画方法。


File: elisp,  Node: Usual Display,  Next: Display Tables,  Up: Character Display

37.21.1 Usual Display Conventions
---------------------------------

以下は、各文字コードの表示にたいする慣習です(ディスプレイテーブルが存在
しなければ、これらの慣習をオーバーライドできる 。*note Display
Tables::)を参照されたい)。

   • コード32から126の“プリント可能ASCII文字(printable ASCII characters:
     数字、英文字、および‘#’のようなシンボル)”は、文字通りそのまま表示さ
     れる。

   • タブ文字(文字コード9)は、次のタブストップ列まで伸長された空白文字と
     して表示される。*note (emacs)Text Display::を参照のこと。変数
     ‘tab-width’は、タブストップごとのスペース数を制御する(以下参照)。

   • 改行文字(文字コード10)は特殊効果をもつ。これは先行する行を終端して
     、新たな行を開始する。

   • 非プリント可能“ASCII制御文字(ASCII control characters)” — 文字コー
     ド0から31と<DEL>文字(文字コード127) — は、変数‘ctl-arrow’に応じて
     2つの方法のいずれかで表示される。この変数が非‘nil’(デフォルト)なら
     、たとえば<DEL>にたいしては‘^?’のように、これらの文字は1つ目のグリ
     フが‘^’(‘^’のかわりに使用する文字をディスプレイテーブルで指定できる
     )のような、2つのグリフのシーケンスとして表示される。

     ‘ctl-arrow’が‘nil’なら、これらの文字は8進エスケープとして表示される
     (以下参照)。

     このルールは、バッファー内に復帰文字(CR: carriage return、文字コー
     ド13)があれば、それにも適用される。しかし復帰文字は、通常はバッファ
     ーテキスト内には存在しない。これらは、行末変換(end-of-line
     conversion)の一部として除去される(*note Coding System Basics::を参
     照)。

   • “rawバイト(raw bytes)”とは、コード128から255の非ASCII文字である。こ
     れらの文字は“8進エスケープ(octal escapes)”として表示される。これは
     1つ目が‘\’にたいするASCIIコードのグリフで、残りがその文字のコードを
     8進で表した数字である(ディスプレイテーブルで‘\’のかわりに使用するグ
     リフを指定できる)。

   • 255を超える非ASCII文字は、端末がサポートしていればそのまま表示され
     る。端末がサポートしない場合、その文字は“グリフなし(glyphless)”と呼
     ばれ、通常はプレースホルダーグリフを使用して表示される。たとえば、
     ある文字にたいしてグラフィカル端末がフォントをもたなければ、Emacsは
     通常は16進文字コードを含むボックスを表示する。*note Glyphless
     Chars::を参照のこと。

   上記の表示慣習は、たとえディスプレイテーブルがあっても、アクティブデ
ィスプレイテーブル内のエントリーが‘nil’であるような、すべての文字にたい
して適用されます。したがってディスプレイテーブルのセットアップ時に指定が
必要なのは、特別な振る舞いを望む文字だけです。

   以下の変数は、スクリーン上で特定の文字が表示される方法に影響します。
これらはその文字が占める列数を変更するので、インデント関数にも影響を与え
ます。また、モードラインが表示される方法にも影響があります。新たな値を使
用してモードラインを強制的に再表示するには、関数
‘force-mode-line-update’を呼び出してください(*note Mode Line Format::を
参照)。

 -- User Option: ctl-arrow
     このバッファーローカル変数は、コントロール文字が表示される方法を制
     御する。非‘nil’なら‘^A’のようにカレットとその文字のように表示され、
     ‘nil’なら‘\001’のようにバックスラッシュと8進3桁のように8進エスケー
     プとして表示される。

 -- User Option: tab-width
     このバッファーローカル変数の値は、Emacsバッファー内でのタブ文字表示
     で使用する、タブストップ間のスペース数である。値は列単位で、デフォ
     ルトは8。この機能は、コマンド‘tab-to-tab-stop’で使用される、ユーザ
     ー設定可能なタブストップとは完全に無関係であることに注意。*note
     Indent Tabs::を参照のこと。


File: elisp,  Node: Display Tables,  Next: Active Display Table,  Prev: Usual Display,  Up: Character Display

37.21.2 Display Tables
----------------------

ディスプレイテーブルとは、サブタイプとして‘display-table’をもつ特殊用途
の文字テーブル(*note Char-Tables::)で、文字の通常の表示慣習をオーバーラ
イドするために使用されます。このセクションではディスプレイテーブルオブジ
ェクトの作成と調査、および要素を割り当てる方法について説明します。

 -- Function: make-display-table
     これは、ディスプレイテーブルを作成してリターンする。テーブルは初期
     状態では、すべての要素に‘nil’をもつ。

   ディスプレイテーブルの通常の要素は、文字コードによりインデックス付け
される。インデックスCの要素は、コードCの表示方法を示す。値は‘nil’(これは
通常の表示慣習に応じて文字Cを表示することを意味する。*note Usual
Display::を参照のこと)、またはグリフコードのベクター(これらのグリフとし
て文字Cを表示することを意味する。*note Glyphs::を参照のこと)のいずれかで
あること。

   *警告:* 改行文字の表示を変更するためにディスプレイテーブルを使用する
と、バッファー全体が1つの長い“行”として表示されるだろう。

   ディスプレイテーブルは特殊用途向けに、6つの“エクストラスロット(extra
slots)”をもつこともできます。以下は、それらの意味についてのテーブルです
。‘nil’のスロットは、以下で示すそのスロットにたいするデフォルトの使用を
意味します。

0
     切り詰められたスクリーン行終端のグリフ(デフォルトでは‘$’)。*note
     Glyphs::を参照のこと。グラフィカルな端末では、Emacsは切り詰められた
     ことをフリンジ内の矢印で示し、ディスプレイテーブルは使用しない。

1
     継続行終端のグリフ(デフォルトは‘\’)。グラフィカルな端末では、
     Emacsは継続ををフリンジ内の曲矢印で示し、ディスプレイテーブルは使用
     しない。

2
     8進文字コードとして表示される文字を示すグリフ(デフォルトは‘\’)。

3
     コントロール文字を示す(デフォルトは‘^’)。

4
     不可視行があることを示すグリフのベクター(デフォルトは‘...’)。*note
     Selective Display::を参照のこと。

5
     横並びのウィンドウ間のボーダー描画に使用されるグリフ(デフォルトは
     ‘|’)。*note Splitting Windows::を参照のこと。これは、スクロールバー
     が存在するときだけ効果をもつ。スクロールバーがサポートされていて使
     用中なら、スクロールバーが2つのウィンドウを分割する。

   たとえば以下は、関数‘make-glyph-code’にたいして‘ctl-arrow’に非‘nil’を
セットして得られる効果を模倣するディスプレイテーブル(*note Glyphs::を参
照のこと)を構築する例です:

     (setq disptab (make-display-table))
     (dotimes (i 32)
       (or (= i ?\t)
           (= i ?\n)
           (aset disptab i
                 (vector (make-glyph-code ?^ 'escape-glyph)
                         (make-glyph-code (+ i 64) 'escape-glyph)))))
     (aset disptab 127
           (vector (make-glyph-code ?^ 'escape-glyph)
                   (make-glyph-code ?? 'escape-glyph)))))

 -- Function: display-table-slot display-table slot
     この関数は、DISPLAY-TABLEのエクストラスロットSLOTの値をリターンする
     。引数SLOTには0から5の数字(両端含む)、またはスロット名(シンボル)を
     指定できる。有効なシンボルは‘truncation’、‘wrap’、‘escape’、
     ‘control’、‘selective-display’、‘vertical-border’。

 -- Function: set-display-table-slot display-table slot value
     この関数は、DISPLAY-TABLEのエクストラスロットSLOTにVALUEを格納する
     。引数SLOTには0から5の数字(両端含む)、またはスロット名(シンボル)を
     指定できる。有効なシンボルは‘truncation’、‘wrap’、‘escape’、
     ‘control’、‘selective-display’、‘vertical-border’。

 -- Function: describe-display-table display-table
     この関数は、ヘルプバッファーにディスプレイテーブルDISPLAY-TABLEの説
     明を表示する。

 -- Command: describe-current-display-table
     このコマンドは、ヘルプバッファーにカレントディスプレイテーブルの説
     明を表示する。


File: elisp,  Node: Active Display Table,  Next: Glyphs,  Prev: Display Tables,  Up: Character Display

37.21.3 Active Display Table
----------------------------

ウィンドウはそれぞれディスプレイテーブルを指定でき、各バッファーもディス
プレイテーブルを指定できます。もしウィンドウにディスプレイテーブルがあれ
ば、それはバッファーのディスプレイテーブルより優先されます。ウィンドウと
バッファーのいずれもディスプレイテーブルをもたなければ、Emacsは標準的な
ディスプレイテーブルの使用を試みます。標準ディスプレイテーブルが‘nil’な
ら、Emacsは通常の文字表示慣習を使用します(*note Usual Display::を参照)。

   ディスプレイテーブルはモードラインが表示される方法に影響を与えるので
、新たなディスプレイテーブルを使用してモードラインを強制的に再表示するに
は、‘force-mode-line-update’を使用することに注意してください(*note Mode
Line Format::を参照)。

 -- Function: window-display-table &optional window
     この関数はWINDOWのディスプレイテーブル、ディスプレイテーブルがなけ
     れば‘nil’をリターンする。WINDOWのデフォルトは、選択されたウィンドウ
     。

 -- Function: set-window-display-table window table
     この関数は、WINDOWのディスプレイテーブルにTABLEをセットする。引数
     TABLEはディスプレイテーブル、または‘nil’のいずれかであること。

 -- Variable: buffer-display-table
     この変数は、すべてのバッファーにおいて自動的にバッファーローカルに
     なる。変数の値は、そのバッファーのディスプレイテーブルを指定する。
     これが‘nil’なら、バッファーのディスプレイテーブルは存在しない。

 -- Variable: standard-display-table
     この変数の値は、ウィンドウ内にバッファーを表示する際、ウィンドウデ
     ィスプレイテーブルとバッファーディスプレイテーブルのいずれも定義さ
     れていないときに、Emacsが使用する標準ディスプレイテーブル(standard
     display table)である。デフォルトは‘nil’。

   ‘disp-table’ライブラリーでは、標準ディスプレイテーブルを変更するため
に、いくつかの関数を定義されています。

