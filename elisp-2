This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Building Lists,  Next: List Variables,  Prev: List Elements,  Up: Lists

5.4 Building Cons Cells and Lists
=================================

リストはLispの核にあるので、リストを構築する多くの関数があります。
‘cons’はリストを構築する基本的な関数です。しかしEmacsのソースコードでは
、‘cons’より‘list’のほうが多く使用されているのは興味深いことです。

 -- Function: cons object1 object2
     この関数は、新しいリスト構造を構築するための、もっとも基本的な関数
     です。この関数は、OBJECT1をCAR、OBJECT2をCDRとする、新しいコンスセ
     ルを作成して、それから新しいコンスセルをreturnします。引数OBJECT1と
     OBJECT2は、任意のLispオブジェクトを指定できますが、ほとんどの場合、
     OBJECT2はリストです。

          (cons 1 '(2))
               ⇒ (1 2)
          (cons 1 '())
               ⇒ (1)
          (cons 1 2)
               ⇒ (1 . 2)

     リストの先頭に1つの要素を追加するために、‘cons’がよく使用されます。
     これは、“リストに要素をコンスする”と言います。(1)たとえば:

          (setq list (cons newelt list))

     この例で使用されている‘list’という名前の変数と、以下で説明する
     ‘list’という名前の関数は、競合しないことに注意してください。任意の
     シンボルは、両方の役割を果たすことができます。

 -- Function: list &rest objects
     この関数は、OBJECTSを要素とするリストを作成します。結果となるリスト
     は、常に‘nil’終端されます。OBJECTSを指定しない場合、空リストが
     returnされます。

          (list 1 2 3 4 5)
               ⇒ (1 2 3 4 5)
          (list 1 2 '(3 4 5) 'foo)
               ⇒ (1 2 (3 4 5) foo)
          (list)
               ⇒ nil

 -- Function: make-list length object
     この関数は、各要素がOBJECTの、LENGTH個の要素からなるリストを作成し
     ます。‘make-list’と‘make-string’(*note Creating Strings::を参照して
     ください)を比較してみてください。

          (make-list 3 'pigs)
               ⇒ (pigs pigs pigs)
          (make-list 0 'pigs)
               ⇒ nil
          (setq l (make-list 3 '(a b)))
               ⇒ ((a b) (a b) (a b))
          (eq (car l) (cadr l))
               ⇒ t

 -- Function: append &rest sequences
     この関数は、SEQUENCESのすべての要素を服務リストをreturnします。
     SEQUENCESには、リスト、ベクター、ブールベクター、文字列も指定できま
     すが、通常は最後にリストを指定するべきです。最後の引数を除くすべて
     の引数はコピーされるので、変更される引数はありません(コピーを行なわ
     ずにリストを結合する方法については、*note Rearrangement::の
     ‘nconc’を参照してください)。

     より一般的には、‘append’にたいする最後の引数は、任意のLispオブジェ
     クトかもしれません。最後の引数は、コピーまたは変換されません。最後
     の引数は、新しいリストの最後のコンスセルのCDRになります。最後の引数
     もリストならば、このリストの要素は、実質的には結果リストの要素にな
     ります。最後の要素がリストでない場合、最後のCDRが(真リストで要求さ
     れる)‘nil’ではないので、結果はドットリストになります。

   以下は‘append’を使用した例です:

     (setq trees '(pine oak))
          ⇒ (pine oak)
     (setq more-trees (append '(maple birch) trees))
          ⇒ (maple birch pine oak)

     trees
          ⇒ (pine oak)
     more-trees
          ⇒ (maple birch pine oak)
     (eq trees (cdr (cdr more-trees)))
          ⇒ t

   ‘append’がどのように機能するか、ボックスダイアグラムで見ることができ
ます。変数‘trees’はリスト‘(pine oak)’にセットされ、それから変数
‘more-trees’にリスト‘(maple birch pine oak)’がセットされます。しかし変数
‘trees’は継続して元のリストを参照します:

     more-trees                trees
     |                           |
     |     --- ---      --- ---   -> --- ---      --- ---
      --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
           --- ---      --- ---      --- ---      --- ---
            |            |            |            |
            |            |            |            |
             --> maple    -->birch     --> pine     --> oak

   空のシーケンスは、‘append’によりreturnされる値に寄与しません。この結
果、最後の引数に‘nil’を指定すると、それより前の引数のコピーを強制するこ
とになります。

     trees
          ⇒ (pine oak)
     (setq wood (append trees nil))
          ⇒ (pine oak)
     wood
          ⇒ (pine oak)
     (eq wood trees)
          ⇒ nil

これは関数‘copy-sequence’が導入される以前は、リストをコピーする通常の方
法でした。*note Sequences Arrays Vectors::を参照してください。

   以下は、‘append’の引数としてベクターと文字列を使用する例です:

     (append [a b] "cd" nil)
          ⇒ (a b 99 100)

   ‘apply’ (*note Calling Functions::を参照してください)の助けを借りるこ
とにより、リストのリストの中の、すべてのリストをappendできます。

     (apply 'append '((a b c) nil (x y z) nil))
          ⇒ (a b c x y z)

   SEQUENCESが与えられない場合、‘nil’がreturnされます:

     (append)
          ⇒ nil

   以下は、最後の引数がリストでない場合の例です:

     (append '(x y) 'z)
          ⇒ (x y . z)
     (append '(x y) [z])
          ⇒ (x y . [z])

2番目の例は、最後の引数はシーケンスですがリスとではない場合で、このシー
ケンスの要素は、結果リストの要素にはなりません。かわりに、最後の引数がリ
ストでないときと同様、シーケンスが最後のCDRになります。

 -- Function: reverse list
     この関数は、要素はLISTの要素ですが、順序が逆の新しいリストを作成し
     ます。元の引数LISTは、変更_されません_。

          (setq x '(1 2 3 4))
               ⇒ (1 2 3 4)
          (reverse x)
               ⇒ (4 3 2 1)
          x
               ⇒ (1 2 3 4)

 -- Function: copy-tree tree &optional vecp
     この関数はツリー‘tree’のコピーをreturnします。TREEがコンスセルの場
     合、同じCARとCDRをもつ新しいコンスセルを作成してから、同じ方法によ
     りCARとCDRを再帰的にコピーします。

     通常、TREEがコンスセル以外の場合、‘copy-tree’は単にTREEをreturnしま
     す。しかし、VECPが非‘nil’の場合、この関数はベクターでもコピーします
     (そしてベクターの要素を再帰的に処理します)。

 -- Function: number-sequence from &optional to separation
     これは、FROMからSEPARATIONづつインクリメントして、TOの直前で終わる
     、数字のリストをreturnします。SEPARATIONには正または負の数を指定で
     き、デフォルトは1です。TOが‘nil’、または数的にFROMと等しい場合、値
     は1要素のリスト‘(FROM)’になります。SEPARATIONが正でTOがFROMより小さ
     い場合、またはSEPARATIONが負でTOがFROMより大きい場合、これらの引数
     は空のシーケンスを指示することになるので、値は‘nil’になります。

     SEPARATIONが0で、TOが‘nil’でもなく、数的にFROMとも等しくない場合、
     これらの引数は無限シーケンスを指示することになるので、エラーがシグ
     ナルされます。

     引数はすべて数字です。浮動少数の計算は正確ではないので、浮動少数の
     引数には用心する必要があります。たとえばマシンに依存して、
     ‘(number-sequence 0.4 0.8 0.2)’が3要素のリストをreturnするのに、
     ‘(number-sequence 0.4 0.6 0.2)’が1要素のリスト‘(0.4)’をreturnするこ
     とがよく起こります。リストのN番目の要素は、厳密に‘(+ FROM (* N
     SEPARATION))’という式により計算されます。したがって、リストに確実に
     TOが含まれるようにするには、この式に適切な型のTOを渡すことができま
     す。別の方法として、TOを少しだけ大きな値(SEPARATIONが負の場合は、少
     しだけ小さな値)に置き換えることもできます。

     いくつか例を示します:

          (number-sequence 4 9)
               ⇒ (4 5 6 7 8 9)
          (number-sequence 9 4 -1)
               ⇒ (9 8 7 6 5 4)
          (number-sequence 9 4 -2)
               ⇒ (9 7 5)
          (number-sequence 8)
               ⇒ (8)
          (number-sequence 8 5)
               ⇒ nil
          (number-sequence 5 8 -1)
               ⇒ nil
          (number-sequence 1.5 6 2)
               ⇒ (1.5 3.5 5.5)

   ---------- Footnotes ----------

   (1) リストの最後に要素を追加するための、これと完全に同等な方法はあり
ません。LISTNAMEをコピーすることにより、新しいリストを作成してから、
NEWELTをそのリストの最後に追加する、‘(append LISTNAME (list NEWELT))’を
使用することができます。すべてのCDRを辿って、終端の‘nil’を置き換える、
‘(nconc LISTNAME (list NEWELT))’を使用することもできます。コピーも変更も
行なわずに、リストの先頭に要素を追加する‘cons’と比較してみてください。


File: elisp,  Node: List Variables,  Next: Modifying Lists,  Prev: Building Lists,  Up: Lists

5.5 Modifying List Variables
============================

これらの関数、および1つのマクロは、変数に格納されたリストを変更する便利
な方法を提供します。

 -- Macro: push element listname
     このマクロは、CARがELEMENTで、CDRがLISTNAMEで指定されたリストである
     ような新しいリストを作成して、そのリストをLISTNAMEに保存します。単
     純なのは、LISTNAMEはリストに名前をつけるクォートされていないシンボ
     ルのときで、この場合マクロは
     ‘(setq LISTNAME (cons ELEMENT LISTNAME))’と等価です。

          (setq l '(a b))
               ⇒ (a b)
          (push 'c l)
               ⇒ (c a b)
          l
               ⇒ (c a b)

     より一般的なのは、‘listname’が汎変数の場合です。この場合、このマク
     ロは‘(setf LISTNAME (cons ELEMENT LISTNAME))’と等価です。*note
     Generalized Variables::を参照してください。

     リストから1番目の要素を取り出す‘pop’マクロについては、*note List
     Elements::を参照してください。

   以下の2つの関数は、変数の値であるリストを変更します。

 -- Function: add-to-list symbol element &optional append compare-fn
     この関数は、ELEMENTがSYMBOLの値のメンバーでない場合は、SYMBOLに
     ELEMENTをコンスすることにより、変数SYMBOLをセットします。この関数は
     、リストが更新されているかに関わらず、結果のリストをreturnします
     SYMBOLの値は、呼び出し前にすでにリストであることが望ましいです。
     ELEMENTがリストの既存メンバーか比較するために、‘add-to-list’は
     COMPARE-FNを使用します。COMPARE-FNが‘nil’の場合は、‘equal’を使用し
     ます。

     ELEMENTが追加される場合は通常、SYMBOLの前に追加されますが、オプショ
     ンの引数APPENDが非‘nil’の場合は、最後に追加されます。

     引数SYMBOLは、暗黙にクォートされません。‘setq’とは異なり、
     ‘add-to-list’は‘set’のような通常の関数です。クォートしたい場合は自
     分で引数をクォートします。

   以下は‘add-to-list’を使用する方法をシナリオで示します:

     (setq foo '(a b))
          ⇒ (a b)

     (add-to-list 'foo 'c)     ;; ‘c’を追加。
          ⇒ (c a b)

     (add-to-list 'foo 'b)     ;; 効果なし。
          ⇒ (c a b)

     foo                       ;; ‘foo’が変更された。
          ⇒ (c a b)

   以下は‘(add-to-list 'VAR VALUE)’と等価な式です:

     (or (member VALUE VAR)
         (setq VAR (cons VALUE VAR)))

 -- Function: add-to-ordered-list symbol element &optional order
     この関数は、古い値(リストでなければなりません)のORDERで指定された位
     置に、ELEMENTを挿入することにより、変数SYMBOLをセットします。
     ELEMENTがすでにこのリストのメンバーである場合、リスト内の要素の位置
     はORDERにしたがって調整されます。メンバーかどうかは、‘eq’を使用して
     テストされます。この関数は、更新されているかどうかに関わらず、結果
     のリストをreturnします。

     ORDERは通常、数字(正数か浮動小数)で、リストの要素は、その数字の昇順
     で並べられます。

     ORDERを省略または‘nil’にすることもできます。これにより、リストに
     ELEMENTがすでに存在する場合、ELEMENTの数字順序は変更されません。そ
     れ以外では、ELEMENTは数字順序をもちません。リストの数字順序をもたな
     い要素は、リストの最後に配され、特別な順序はつきません。

     ORDERに他の値を指定した場合、ELEMENTがすでに数字順序をもつときは数
     字順序が削除されます。それ以外は、‘nil’と同じです。

     引数SYMBOLは、暗黙にクォートされません。‘add-to-ordered-list’は、
     ‘setq’などとは異なり、‘set’のような通常の関数です。必要な場合は引数
     を自分でクォートしてください。

     順序の情報は、SYMBOLの‘list-order’プロパティーのハッシュテーブルに
     保存されます。

   以下に‘add-to-ordered-list’を使用する方法をシナリオで示します:

     (setq foo '())
          ⇒ nil

     (add-to-ordered-list 'foo 'a 1)     ;; ‘a’を追加。
          ⇒ (a)

     (add-to-ordered-list 'foo 'c 3)     ;; ‘c’を追加。
          ⇒ (a c)

     (add-to-ordered-list 'foo 'b 2)     ;; ‘b’を追加。
          ⇒ (a b c)

     (add-to-ordered-list 'foo 'b 4)     ;; ‘b’を移動。
          ⇒ (a c b)

     (add-to-ordered-list 'foo 'd)       ;; ‘d’を後に追加。
          ⇒ (a c b d)

     (add-to-ordered-list 'foo 'e)       ;; ‘e’を追加。
          ⇒ (a c b e d)

     foo                       ;; ‘foo’が変更された。
          ⇒ (a c b e d)


File: elisp,  Node: Modifying Lists,  Next: Sets And Lists,  Prev: List Variables,  Up: Lists

5.6 Modifying Existing List Structure
=====================================

基本関数‘setcar’および‘setcdr’により、コンスセルのCARおよびCDRの内容を変
更できます。わたしたちは、これらが既存のリスト構造を変更することから、こ
れらを“破壊的”処理と呼びます。

     Common Lispに関する注意: Common Lispはリスト構造の変更に‘rplaca’お
     よび‘rplacd’を使用します。これらは‘setcar’や‘setcdr’と同じ方法でリ
     スト構造を変更しますが、‘setcar’と‘setcdr’は新しいCARまたはCDRを
     returnするのにたいし、Common Lispの関数はコンスセルをreturnします。

* Menu:

* Setcar::                   リスト内の要素の置き換え。
* Setcdr::                   リストの根幹部分の置き換え。これは要素の追加や削除に使用されます。
* Rearrangement::            リスト内の要素の再配置、リストの合成。


File: elisp,  Node: Setcar,  Next: Setcdr,  Up: Modifying Lists

5.6.1 Altering List Elements with ‘setcar’
------------------------------------------

コンスセルのCARの変更は、‘setcar’により行なわれます。リストにたいして使
用された場合、‘setcar’はリストの1つの要素を、他の要素に置き換えます。

 -- Function: setcar cons object
     この関数は、以前のCARを置き換えて、CONSの新しいCARにOBJECTを格納し
     ます。他の言い方をすると、この関数はCONSのCARスロットを、OBJECTを参
     照するように変更します。この関数は値OBJECTをreturnします。たとえば:

          (setq x '(1 2))
               ⇒ (1 2)
          (setcar x 4)
               ⇒ 4
          x
               ⇒ (4 2)

   コンスセルが、複数のリストが共有された構造の一部の場合、コンスに新し
いCARを格納することにより、これら共有されたリストの各1つの要素を変更しま
す。以下は例です:

     ;; 部分的に共有された2つのリストを作成。
     (setq x1 '(a b c))
          ⇒ (a b c)
     (setq x2 (cons 'z (cdr x1)))
          ⇒ (z b c)

     ;; 共有されたリンクのCARを置き換え。
     (setcar (cdr x1) 'foo)
          ⇒ foo
     x1                           ; 両方のリストが変更された。
          ⇒ (a foo c)
     x2
          ⇒ (z foo c)

     ;; 共有されていないリンクのCARを置き換え。
     (setcar x1 'baz)
          ⇒ baz
     x1                           ; 1つのリストだけが変更された。
          ⇒ (baz foo c)
     x2
          ⇒ (z foo c)

   なぜ‘b’を置き換えると両方が変更されるのかを説明するために、変数‘x1’と
‘x2’の2つのリストによる共有構造を視覚化してみましょう:

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

   同じ関係を別のボックス図で示すと、以下のようになります:

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------


File: elisp,  Node: Setcdr,  Next: Rearrangement,  Prev: Setcar,  Up: Modifying Lists

5.6.2 Altering the CDR of a List
--------------------------------

CDRを変更するもっとも低レベルの基本関数は、‘setcdr’です:

 -- Function: setcdr cons object
     この関数は前のCDRを置き換えて、CONSの新しいCDRにOBJECTを格納します
     。他の言い方をすると、この関数はCONSのCDRを、OBJECTを参照するように
     変更します。この関数は値OBJECTをreturnします。

   以下はリストのCDRを、他のリストに置き換える例です。1番目の要素以外の
すべての要素は、別のシーケンスまたは要素のために取り除かれます。1番目の
要素はリストのCARなので変更されず、CDRを通じて到達することもできないから
です。

     (setq x '(1 2 3))
          ⇒ (1 2 3)
     (setcdr x '(4))
          ⇒ (4)
     x
          ⇒ (1 4)

   リスト内のコンスセルのCDRを変更することにより、リストの途中から要素を
削除できます。たとえば以下では、1番目のコンスセルのCDRを変更することによ
り、2番目の要素‘b’を、リスト‘(a b c)’から削除します。

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cdr (cdr x1)))
          ⇒ (c)
     x1
          ⇒ (a c)

   以下に結果をボックス表記で示します:

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

以前は要素‘b’を保持していた2番目のコンスセルは、依然として存在して、その
CARも‘b’のままですが、すでにこのリストの一部を形成していません。

   CDRを変更して、新しい要素を挿入するのも、同じくらい簡単です:

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          ⇒ (d b c)
     x1
          ⇒ (a d b c)

   以下に結果をボックス表記で示します:

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------


File: elisp,  Node: Rearrangement,  Prev: Setcdr,  Up: Modifying Lists

5.6.3 Functions that Rearrange Lists
------------------------------------

以下では、リストの構成要素であるコンスセルのCDRを変更することにより、リ
ストを“破壊的”に再配置する関数をいくつか示します。これらの関数が“破壊的
”だという理由は、これらの関数が引数として渡された元のリストを処理して、
return値となる新しいリストを形成するために、リストのコンスセルを再リンク
するからです。

   コンスセルを変更する他の関数については、*note Sets And Lists::の
‘delq’を参照してください。

 -- Function: nconc &rest lists
     この関数は、LISTSの要素すべてを含むリストをreturnします。‘append’
     (*note Building Lists::を参照してください)とは異なり、LISTSはコピー
     _されません_。かわりにLISTSの各リストの最後のCDRが、次のリストを参
     照するように変更されます。LISTSの最後のリストは、変更されません。た
     とえば:

          (setq x '(1 2 3))
               ⇒ (1 2 3)
          (nconc x '(4 5))
               ⇒ (1 2 3 4 5)
          x
               ⇒ (1 2 3 4 5)

     ‘nconc’の最後の引数は変更されないので、上記の例のように、‘'(4 5)’の
     ような定数リストを使用するのが理に適っています。また、同じ理由によ
     り、最後の引数がリスとである必要はありません。

          (setq x '(1 2 3))
               ⇒ (1 2 3)
          (nconc x 'z)
               ⇒ (1 2 3 . z)
          x
               ⇒ (1 2 3 . z)

     しかし、(最後を除くすべての)他の引数はリストでなければなりません。

     一般的な落とし穴としては、‘nconc’にたいしてクォートされたリスト定数
     を、最後以外の引数として使用したときです。これを行なう場合、実行す
     るごとにプログラムはリスト定数を変更するでしょう! 何が起こるのかを
     以下に示します:

          (defun add-foo (x)            ; この関数では‘foo’
            (nconc '(foo) x))           ;   を引数の前に追加させたい。

          (symbol-function 'add-foo)
               ⇒ (lambda (x) (nconc (quote (foo)) x))

          (setq xx (add-foo '(1 2)))    ; 動いているように見える。
               ⇒ (foo 1 2)
          (setq xy (add-foo '(3 4)))    ; 何が起きているのか?
               ⇒ (foo 1 2 3 4)
          (eq xx xy)
               ⇒ t

          (symbol-function 'add-foo)
               ⇒ (lambda (x) (nconc (quote (foo 1 2 3 4) x)))

 -- Function: nreverse list
     この関数は、LISTの要素の順番を逆転します。‘reverse’とは異なり、
     ‘nreverse’はリストを形成するCDR内のコンスセルを逆転することにより、
     引数を変更します。LISTの最後に使用されているコンスセルは、最初のコ
     ンスセルになります。

     たとえば:

          (setq x '(a b c))
               ⇒ (a b c)
          x
               ⇒ (a b c)
          (nreverse x)
               ⇒ (c b a)
          ;; 最初のコンスセルが最後になった。
          x
               ⇒ (a)

     わたしたちは通常、混乱を避けるために、‘nreverse’の結果を、元のリス
     トを保持していたのと同じ変数に格納します:

          (setq x (nreverse x))

     以下は、‘(a b c)’を視覚的に表した、‘nreverse’の例です:

          元のリストの先頭:                         逆転されたリスト:
           -------------        -------------        ------------
          | car  | cdr  |      | car  | cdr  |      | car | cdr  |
          |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
          |      |      |   |  |      |   |  |   |  |     |   |  |
           -------------    |   --------- | -    |   -------- | -
                            |             |      |            |
                             -------------        ------------

 -- Function: sort list predicate
     この関数は、LISTを安定的(しかし破壊的)にソートして、ソートされたリ
     ストをreturnします。この関数はPREDICATEを使用して要素を比較します。
     安定ソート(stable sort)では、同じソートキーをもつ要素が、ソートの前
     後で相対的に同じ順序が維持されます。安定性は、異なる条件によりソー
     トするために要素を並び替えるために、連続したソートが使用されるとき
     に重要です。

     引数PREDICATEは、2つの引数をとる関数でなければなりません。この関数
     はLISTの2つの要素を引数として呼び出されます。昇順のソートを得るため
     のPREDICATEは、1番目の引数が、2番目の引数より“小さい”ときは非
     ‘nil’、それ以外は‘nil’をreturnするようにします。

     比較関数PREDICATEは、少なくとも単独の‘sort’呼び出しにおいて、任意の
     与えられた引数にたいして信頼できる結果を与えなければありません。比
     較関数は“非対称的(antisymmetric)” — つまりAがBより小さいとき、Bは
     Aより小さくない — でなければなりません。比較関数は“推移的
     (transitive)” — つまりAがBより小さく、BがCより小さい場合、CはAより
     小さい — でなければなりません。これらの要求を満たさない比較関数を使
     用した場合、‘sort’の結果は予測できません。

     ‘sort’の破壊的な側面は、CDRを変更することにより、LISTを形成するコン
     スセルを再配置することです。非破壊的なソート関数の場合は、ソートさ
     れた要素を格納するために、あたらしいコンスセルを作成します。元のリ
     ストを破壊せずにソートされたコピーを作成したい場合は、
     ‘copy-sequence’で最初にコピーしてから、それをソートします。

     ソートはLIST内のコンスセルのCARは変更しません。LIST内でCARに要素
     ‘a’を保持していたコンスセル、ソート後にも‘a’を保持しますが、CDRは変
     更されるので、ソート後の位置は異なります。たとえば:

          (setq nums '(1 3 2 6 5 4 0))
               ⇒ (1 3 2 6 5 4 0)
          (sort nums '<)
               ⇒ (0 1 2 3 4 5 6)
          nums
               ⇒ (1 2 3 4 5 6)

     *警告*: ‘nums’のリストには0が含まれていないことに注意してください。
     これは前と同じコンスセルですが、リストの1番目ではなくなります。引数
     を保持するように形成された変数が、ソートされたリストでも保持される
     と仮定しないでください! かわりに‘sort’の結果を保存して、それを使用
     してください。元のリストを保持していた変数に、結果を書き戻すことは
     よく行なわれます。

          (setq nums (sort nums '<))

     ソート処理を行なう他の関数については、*note Sorting::を参照してくだ
     さい。‘sort’の有用な例は、*note Accessing Documentation::の
     ‘documentation’を参照してください。


File: elisp,  Node: Sets And Lists,  Next: Association Lists,  Prev: Modifying Lists,  Up: Lists

5.7 Using Lists as Sets
=======================

リストは順序なしの数学的集合 — リスト内に要素があれば集合の要素の値とさ
れ、リスト内の順序は無視される — を表すことができます。2つの集合を結合
(union)するには、(重複する要素を気にしない場合は)‘append’を使用します。
‘equal’である重複を取り除くには、‘delete-dups’を使用します。集合にたいす
る他の有用な関数には、‘memq’や‘delq’、およびこれらの‘equal’バージョンで
ある‘member’と‘delete’が含まれます。

     Common Lispに関する注意: 集合を処理するために、Common Lispには(要素
     の重複がない)関数‘union’があります。これらの関数は標準のGNU Emacs
     Lispにはありませんが、‘cl-lib’はこれらを提供します。*note (cl)Lists
     as Sets::を参照してください。

 -- Function: memq object list
     この関数は、OBJECTがLISTのメンバーかどうかをテストします。メンバー
     の場合、‘memq’はOBJECTで最初に見つかった要素から開始されるリストを
     returnします。メンバーでない場合は、‘nil’をreturnします。‘memq’の文
     字‘q’は、この関数がOBJECTとリスト内の要素の比較に、‘eq’を使用するこ
     とを示します。たとえば:

          (memq 'b '(a b c b a))
               ⇒ (b c b a)
          (memq '(2) '((1) (2)))    ; ‘(2)’と‘(2)’は‘eq’ではない。
               ⇒ nil

 -- Function: delq object list
     この関数LISTからはOBJECTと‘eq’なすべての要素を破壊的に取り除いて、
     結果のリストをreturnします。‘delq’の文字‘q’は、この関数がOBJECTとリ
     スト内の要素の比較に、‘eq’を使用することを示します(‘memq’や‘remq’と
     同様)。

     ‘delq’を呼び出すときは通常、元のリストを保持していた変数にreturn値
     を割り当てて使用する必要があります(理由は以下参照)。

   ‘delq’関数がリストの銭湯にある要素を削除する場合は、単にリストを読み
進めて、この要素の後から開始される部分リストをreturnします。つまり:

     (delq 'a '(a b c)) ≡ (cdr '(a b c))

リストの途中にある要素を削除するときは、必要なCDR(*note Setcdr::を参照し
てください)を変更することにより削除します。

     (setq sample-list '(a b c (4)))
          ⇒ (a b c (4))
     (delq 'a sample-list)
          ⇒ (b c (4))
     sample-list
          ⇒ (a b c (4))
     (delq 'c sample-list)
          ⇒ (a b (4))
     sample-list
          ⇒ (a b (4))

   ‘(delq 'a sample-list)’は何も取り除きませんが(これは単に短いリストを
returnします)、‘(delq 'c sample-list)’は3番目の要素を取り除いて、
‘sample-list’を変更することに注意してください。引数LISTを保持するように
形成された変数が、実行後にもっと少ない要素になる、または元のリストを保持
すると仮定しないでください! かわりに‘delq’の結果を保存して、それを使用し
てください。元のリストを保持していた変数に、結果を書き戻すことはよく行な
われます。

     (setq flowers (delq 'rose flowers))

   以下の例では、‘delq’が比較しようとしている‘(4)’と、‘sample-list’内の
‘(4)’は、‘eq’ではありません:

     (delq '(4) sample-list)
          ⇒ (a c (4))

   与えられた値と‘equal’な要素を削除したい場合は、‘delete’(以下参照)を使
用してください。

 -- Function: remq object list
     この関数は、OBJECTと‘eq’なすべての要素が除かれた、LISTのコピーを
     returnします。‘remq’の文字‘q’は、この関数がOBJECTとリスト内の要素の
     比較に、‘eq’を使用することを示します。

          (setq sample-list '(a b c a b c))
               ⇒ (a b c a b c)
          (remq 'a sample-list)
               ⇒ (b c b c)
          sample-list
               ⇒ (a b c a b c)

 -- Function: memql object list
     関数‘memql’は、‘eql’(浮動少数の要素は値で比較される)を使用してメン
     バーと‘eql’を比較することにより、OBJECTがLISTのメンバーかどうかをテ
     ストします。OBJECTがメンバーの場合、‘memql’はLIST内で最初に見つかっ
     た要素から開始されるリストをreturnします。それ以外は‘nil’をreturnし
     ます。

     これを‘memq’と比較してみましょう:

          (memql 1.2 '(1.1 1.2 1.3))  ; ‘1.2’と‘1.2’は‘eql’。
               ⇒ (1.2 1.3)
          (memq 1.2 '(1.1 1.2 1.3))  ; ‘1.2’と‘1.2’は‘eq’ではない。
               ⇒ nil

   以下の3つの関数は‘memq’、‘delq’、‘remq’と似ていますが、要素の比較に
‘eq’ではなく、‘equal’を使用します。*note Equality Predicates::を参照して
ください。

 -- Function: member object list
     関数‘member’は、メンバーとOBJECTを‘equal’を使用して比較して、
     OBJECTがLISTのメンバーかどうかをテストします。OBJECTがメンバーの場
     合、‘member’はLISTで最初に見つかったところから開始されるリストを
     returnします。それ以外は‘nil’を参照してください。

     これを‘memq’と比較してみましょう:

          (member '(2) '((1) (2)))  ; ‘(2)’ and ‘(2)’ are ‘equal’.
               ⇒ ((2))
          (memq '(2) '((1) (2)))    ; ‘(2)’と‘(2)’は‘eq’ではない。
               ⇒ nil
          ;; 同じ内容の2つの文字列は‘equal’。
          (member "foo" '("foo" "bar"))
               ⇒ ("foo" "bar")

 -- Function: delete object sequence
     この関数は、SEQUENCEからOBJECTと‘equal’な要素を取り除いて、結果のシ
     ーケンスをreturnします。

     SEQUENCEがリストの場合、‘delete’が‘delq’に対応するように、
     ‘member’は‘memq’に対応します。つまり、この関数は‘member’と同様、要
     素とOBJECTの比較に‘equal’を使用します。マッチする要素が見つかったら
     、‘delq’が行なうように、その要素を取り除きます。‘delq’と同様、通常
     は元のリストを保持していた変数にreturn値を割り当てて使用します。

     ‘sequence’がベクターまたは文字列の場合、‘delete’は‘object’と
     ‘equal’なすべての要素を取り除いた、‘sequence’のコピーをreturnします
     。

     たとえば:

          (setq l '((2) (1) (2)))
          (delete '(2) l)
               ⇒ ((1))
          l
               ⇒ ((2) (1))
          ;; ‘l’の変更に信頼性を要するときは
          ;; ‘(setq l (delete '(2) l))’と記述する。
          (setq l '((2) (1) (2)))
          (delete '(1) l)
               ⇒ ((2) (2))
          l
               ⇒ ((2) (2))
          ;; このケースでは‘l’のセットの有無に違いはない
          ;; しかし他のケースに倣ってセットするべき。
          (delete '(2) [(2) (1) (2)])
               ⇒ [(1)]

 -- Function: remove object sequence
     この関数は、‘delete’に対応する非破壊的な関数です。この関数は、
     ‘object’と‘equal’な要素を取り除いた、‘sequence’(リスト、ベクター、
     文字列)のコピーをreturnします。たとえば:

          (remove '(2) '((2) (1) (2)))
               ⇒ ((1))
          (remove '(2) [(2) (1) (2)])
               ⇒ [(1)]

     Common Lispに関する注意: GNU Emacs Lispの関数‘member’、‘delete’、
     ‘remove’は、Common Lispではなく、Maclispを継承しています。Common
     Lispでは、比較に‘equal’を使用しません。

 -- Function: member-ignore-case object list
     この関数は、‘member’と同様ですが、OBJECTが文字列で、大文字小文字と
     テキスト表現の違いを無視します。文字の大文字と小文字は等しいものと
     して扱われ、比較に先立ちユニバイト文字列はマルチバイト文字列に変換
     されます。

 -- Function: delete-dups list
     この関数は、LISTからすべての‘equal’な重複を、破壊的に取り除いて。、
     結果をLISTに保管して、それをreturnします。LIST内の要素に‘equal’な要
     素がいくつかある場合、‘delete-dups’は最初の要素を残します。

   変数に格納されたリストに要素を追加したり、それを集合として使用する方
法については、*note List Variables::の関数‘add-to-list’も参照してくださ
い。


File: elisp,  Node: Association Lists,  Next: Property Lists,  Prev: Sets And Lists,  Up: Lists

5.8 Association Lists
=====================

“連想配列(association list。短くはalist)”は、キーと値のマッピングを記録
します。これは“連想(associations)”と呼ばれるコンスセルのリストです。各コ
ンスセルにおいて、CARは“キー(key)”で、CDRは“連想値(associated value)”に
なります。(1)

   以下はalistの例です。キー‘pine’は、値‘cones’に関連付けられます。キー
‘oak’は、‘acorns’に関連付けられます。キー‘maple’は、‘seeds’に関連付けら
れます。

     ((pine . cones)
      (oak . acorns)
      (maple . seeds))

   alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば
以下のalist0では、シンボル‘a’は数字‘1’に、文字列‘"b"’は_リスト_‘(2
3)’(alist要素のCDR)に関連付けられます。

     ((a . 1) ("b" 2 3))

   要素のCDRのCARに連想値を格納するようにalistデザインするほうがよい場合
があります。以下は、そのようなalistです。

     ((rose red) (lily white) (buttercup yellow))

この例では、‘red’が‘rose’に関連付けられる値だと考えます。この種のalistの
利点は、CDRのCDRの中に、他の関連する情報 — 他のアイテムのリストでさえ —
を格納することができることです。不利な点は、与えられた値を含む要素を見つ
けるために‘rassq’(以下参照)を使用できないことです。これらを検討すること
が重要でない場合には、任意の与えられたalistにたいして一貫している限り、
選択は好みの問題といえます。

   上記で示したのと同じalistは、要素のCDRに連想値をもつと考えることがで
きます。この場合、‘rose’に関連付けられる値は、リスト‘(red)’になるでしょ
う。

   連想リストは、新しい連想を簡単にリストの先頭に追加できるので、スタッ
クに保持したいような情報を記録するのによく使用されます。連想リストから与
えられたキーにたいする連想を検索する場合、それが複数ある場合は、最初に見
つかったものがreturnされます。

   Emacs Lispでは、連想リストがコンスセルではない場合、それはエラーでは
_ありません_。alist検索関数は、単にそのような要素を無視します。多くの他
のバージョンのLいspでは、このような場合はエラーをシグナルします。

   いくつかの観点において、プロパティーリストは連想リストと似ていること
に注意してください。それぞれのキーが1度だけ出現するような場合、プロパテ
ィーリストは連想リストと同様に振る舞います。プロパティーリストと連想リス
トの比較については、*note Property Lists::を参照してください。

 -- Function: assoc key alist
     この関数は、alist要素にたいしてKEYを比較するのに‘equal’を使用して、
     ALIST内からKEYをもつ最初の連想をreturnします。CARがKEYと‘equal’の連
     想がALISTにない場合、この関数は‘nil’をreturnします。たとえば:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               ⇒ (oak . acorns)
          (cdr (assoc 'oak trees))
               ⇒ acorns
          (assoc 'birch trees)
               ⇒ nil

     以下はキーと値がシンボルでない場合の例です:

          (setq needles-per-cluster
                '((2 "Austrian Pine" "Red Pine")
                  (3 "Pitch Pine")
                  (5 "White Pine")))

          (cdr (assoc 3 needles-per-cluster))
               ⇒ ("Pitch Pine")
          (cdr (assoc 2 needles-per-cluster))
               ⇒ ("Austrian Pine" "Red Pine")

   関数‘assoc-string’は‘assoc’と似ていますが、文字列間の特定の違いを無視
する点が異なります。*note Text Comparison::を参照してください。

 -- Function: rassoc value alist
     この関数は、ALISTの中から、値VALUEをもつ最初の連想をreturnします。
     CDRがVALUEと‘equal’の連想がALISTにない場合、この関数は‘nil’を
     returnします。

     ‘rassoc’は‘assoc’と似ていますが、CARではなく、ALISTの連想のCDRを比
     較します。この関数を、与えられた値に対応するキーを探す、“reverse
     ‘assoc’”と考えることができます。

 -- Function: assq key alist
     この関数は、ALISTからKEYをもつ最初の連想をreturnする点は‘assoc’と同
     様ですが、比較に‘equal’ではなく‘eq’を使用します。CARがKEYと‘eq’な連
     想がALIST内に存在しない場合、‘assq’は‘nil’をreturnします。‘eq’は
     ‘equal’より早く、ほとんどのalistはキーにシンボルを使用するので、こ
     の関数は‘assoc’より多用されます。*note Equality Predicates::を参照
     してください。

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
          (assq 'pine trees)
               ⇒ (pine . cones)

     反対に、キーがシンボルではないalistでは通常、‘assq’は有用ではありま
     せん:

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))

          (assq "simple leaves" leaves)
               ⇒ nil
          (assoc "simple leaves" leaves)
               ⇒ ("simple leaves" . oak)

 -- Function: rassq value alist
     この関数は、ALIST内から値VALUEをもつ最初の連想をreturnします。
     ALIST内にCDRがVALUEと‘eq’な連想が存在しない場合は、‘nil’をreturnし
     ます。

     ‘rassq’は‘assq’と似ていますが、CARではなく、ALISTの各連想のCDRを比
     較します。この関数を、与えられた値に対応するキーを探す、“reverse
     ‘assq’”と考えることができます。

     たとえば:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

          (rassq 'acorns trees)
               ⇒ (oak . acorns)
          (rassq 'spores trees)
               ⇒ nil

     ‘rassq’は、要素のCDRのCARに保管された値の検索はできません:

          (setq colors '((rose red) (lily white) (buttercup yellow)))

          (rassq 'white colors)
               ⇒ nil

     この場合、連想‘(lily white)’のCDRは‘white’ではなく、リスト
     ‘(white)’です。これは連想をドットペア表記で記述すると明確になります
     :

          (lily white) ≡ (lily . (white))

 -- Function: assoc-default key alist &optional test default
     この関数は、KEYにたいするマッチをALISTから検索します。ALISTの各要素
     にたいして、この関数は、KEYと要素(アトムの場合)、または要素のCAR(コ
     ンスの場合)を比較します。比較はTESTに2つの引数 — 要素(または要素の
     CAR)とKEY — を与えて呼び出すことにより行なわれます。引数はこの順番
     で渡されるので、正規表現(*note Regexp Search::を参照してください)を
     含むalistでは、‘string-match’を使用することにより有益な結果を得るこ
     とができます。TESTが省略されているか‘nil’の場合は、比較に‘equal’が
     使用されます。

     alistの要素がこの条件によりKEYとマッチした場合、‘assoc-default’はこ
     の要素の値をreturnします。要素がコンスの場合、値は要素のCDRです。そ
     れ以外の場合、return値はDEFAULTです。

     KEYにマッチする要素がalistに存在しない場合、‘assoc-default’は
     ‘nil’をreturnします。

 -- Function: copy-alist alist
     この関数は、深さ2がレベルのALISTのコピーをreturnします。この関数は
     各連想の新しいコピーを作成するので、元のalistを変更せずに、新しい
     alistを変更できます。

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . ("Pitch Pine"))
                  (5 . ("White Pine"))))
          ⇒
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (setq copy (copy-alist needles-per-cluster))
          ⇒
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (eq needles-per-cluster copy)
               ⇒ nil
          (equal needles-per-cluster copy)
               ⇒ t
          (eq (car needles-per-cluster) (car copy))
               ⇒ nil
          (cdr (car (cdr needles-per-cluster)))
               ⇒ ("Pitch Pine")
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               ⇒ t

     以下の例は、どのようにして‘copy-alist’が他に影響を与えずにコピーの
     連想を変更可能なのかを示します:

          (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
          (cdr (assq 3 needles-per-cluster))
               ⇒ ("Pitch Pine")

 -- Function: assq-delete-all key alist
     この関数は、ALISTから、(‘delq’を使用した場合は、そのような要素を1つ
     ずつ削除するのにたいして)CARがKEYと‘eq’な要素すべてを削除します。こ
     の関数は短くなったalistをreturnし、ALISTの元のリスト構造を変更する
     こともよくあります。正しい結果を得るために、ALISTに保存された値では
     なく、‘assq-delete-all’のreturn値を使用してください。

          (setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
               ⇒ ((foo 1) (bar 2) (foo 3) (lose 4))
          (assq-delete-all 'foo alist)
               ⇒ ((bar 2) (lose 4))
          alist
               ⇒ ((foo 1) (bar 2) (lose 4))

 -- Function: rassq-delete-all value alist
     この関数は、ALISTからCDRがVALUEと‘eq’なすべての要素を削除します。こ
     の関数は短くなったリストをreturnし、ALISTの元のリスト構造を変更する
     こともよくあります。‘rassq-delete-all’は‘assq-delete-all’と似ていま
     すが、CARではなくALISTの各連想のCDRを比較します。

   ---------- Footnotes ----------

   (1) ここでの“キー(key)”の使い方は、用語“キーシーケンス(key
sequence)”とは関係ありません。キーはテーブルにあるアイテムを探すために使
用される値という意味です。この場合、テーブルはalistでありalistはアイテム
に関連付けられます。


File: elisp,  Node: Property Lists,  Prev: Association Lists,  Up: Lists

5.9 Property Lists
==================

“プロパティーリスト(property list。短くはplist)”は、ペアになった要素のリ
ストです。各ペアはプロパティー名(通常はシンボル)とプロパティー値を対応づ
けます。以下はプロパティーリストの例です:

     (pine cones numbers (1 2 3) color "blue")

このプロパティーリストは、‘pine’を‘cones’、‘numbers’を‘(1 2 3)’、
‘color’を‘"blue"’に関連づけます。プロパティー名とプロパティー値には任意
のLispオブジェクトを指定できますが、通常プロパティー名は(この例のように
)シンボルです。

   いくつかのコンテキストでプロパティーリストが使用されます。たとえば、
関数‘put-text-property’はプロパティーリストを引数にとり、文字列またはバ
ッファー内のテキストにたいして、テキストプロパティーと、テキストに適用す
るプロパティー値を指定します。*note Text Properties::を参照してください
。

   プロパティーリストが頻繁に使用される他の例は、シンボルプロパティーの
保管です。すべてのシンボルは、シンボルに関する様々な情報を記録するために
、プロパティーのリストを処理します。これらのプロパティーはプロパティーリ
ストの形式で保管されます。*note Symbol Properties::を参照してください。

* Menu:

* Plists and Alists::        プロパティーリストと連想リストの利点の比較。
* Plist Access::             他の場所に保管されたプロパティーリストへのアクセス。


File: elisp,  Node: Plists and Alists,  Next: Plist Access,  Up: Property Lists

5.9.1 Property Lists and Association Lists
------------------------------------------

連想リスト(*note Association Lists::を参照してください)は、プロパティー
リストとよく似ています。連想リストとは対照的に、プロパティー名は一意でな
ければならないので、プロパティーリスト内でペアの順序に意味はありません。

   様々なLisp関数や変数に情報を付加するためには、連想リストよりプロパテ
ィーリストの方が適しています。プログラムでこのような情報すべてを1つの連
想リストに保持する場合、特定のLisp関数や変数にたいする連想をチェックする
度に、リスト全体を検索する必要が生じ、それにより遅くなる可能性があります
。対照的に、関数名や変数自体のプロパティーリストに同じ情報を保持すれば、
検索ごとにそのプロパティーリストの長さだけを検索するようになり、通常はこ
ちらの方が短い時間で済みます。変数のドキュメントが
‘variable-documentation’という名前のプロパティーに記録されているのは、こ
れが理由です。同様にバイトコンパイラーも、特別に扱う必要がある関数を記録
するためにプロパティーを使用します。

   連想リストにも独自の利点があります。アプリケーションに依存しますが、
プロパティーを更新するより、連想リストの先頭に連想を追加する方が速いでし
ょう。シンボルにたいするすべてのプロパティーは同じプロパティーリストに保
管されるので、プロパティー名を異なる用途のために使用すると衝突の可能性が
あります(この理由により、そのプログラムで通常の変数や関数の名前につける
プレフィクスをプロパティー名の先頭につけることにより、一意と思われるプロ
パティー名を選ぶのはよいアイデアです)。連想リストは、連想をリストの先頭
にpushし、後にある連想は無視されるので、スタックと同様に使用できます。こ
れはプロパティーリストでは不可能です。


File: elisp,  Node: Plist Access,  Prev: Plists and Alists,  Up: Property Lists

5.9.2 Property Lists Outside Symbols
------------------------------------

以下の関数はプロパティーリストを操作するために使用されます。これらの関数
はすべて、プロパティー名の比較に‘eq’を使用します。

 -- Function: plist-get plist property
     この関数は、プロパティーリストPLISTに保管された、プロパティー
     PROPERTYの値をreturnします。この関数には、変形された
     (malformed)PLIST引数を指定できます。PLISTでPROPERTYが見つからなかっ
     た場合、この関数は‘nil’をreturnします。たとえば、

          (plist-get '(foo 4) 'foo)
               ⇒ 4
          (plist-get '(foo 4 bad) 'foo)
               ⇒ 4
          (plist-get '(foo 4 bad) 'bad)
               ⇒ nil
          (plist-get '(foo 4 bad) 'bar)
               ⇒ nil

 -- Function: plist-put plist property value
     この関数は、プロパティーリストPLISTに、プロパティーPROPERTYの値とし
     て、VALUEを保管します。この関数はPLISTを破壊的に変更するかもしれず
     、元のリスト構造を変更せずに新しいリストを構築することもあります。
     この関数は変更されたプロパティーリストをreturnするので、PLISTを取得
     した場所に書き戻すことができます。たとえば、

          (setq my-plist '(bar t foo 4))
               ⇒ (bar t foo 4)
          (setq my-plist (plist-put my-plist 'foo 69))
               ⇒ (bar t foo 69)
          (setq my-plist (plist-put my-plist 'quux '(a)))
               ⇒ (bar t foo 69 quux (a))

 -- Function: lax-plist-get plist property
     ‘plist-get’と同様ですが、プロパティーの比較に‘eq’ではなく‘equal’を
     使用します。

 -- Function: lax-plist-put plist property value
     ‘plist-put’と同様ですが、プロパティーの比較に‘eq’ではなく‘equal’を
     使用します。

 -- Function: plist-member plist property
     この関数は与えられたPROPERTYがPLISTに含まれる場合は、非‘nil’を
     returnします。‘plist-get’とは異なり、この関数は存在しないプロパティ
     ーと、値が‘nil’のプロパティーを区別できます。実際にreturnされる値は
     、‘car’がPROPERTYで始まる、PLISTの後尾部分です。


File: elisp,  Node: Sequences Arrays Vectors,  Next: Hash Tables,  Prev: Lists,  Up: Top

6 Sequences, Arrays, and Vectors
********************************

“シーケンス(sequence)”型は、2つの異なるLisp型 — リストと配列 — を結合し
た型です。他の言い方をすると、任意のリストはシーケンスであり、任意の配列
はシーケンスです。すべてのシーケンスがもつ共通な属性は、それぞれが順序づ
けされた要素のコレクションであることです。

   “配列(array)”は各スロットが要素である、固定長のオブジェクトです。すべ
ての要素に一定時間でアクセスできます。配列の4つの型として、文字列、ベク
ター、文字テーブル、ブールベクターがあります。

   リストは要素のシーケンスですが、要素は単一の基本オブジェクトではあり
ません。リストはコンスセルにより作られ、要素ごとに1つのセルをもちます。
N番目の要素を探すには、N個のコンスセルを走査する必要があるので、先頭から
離れた要素ほどアクセスに時間を要します。しかしリストは要素の追加や削除が
可能です。

   以下の図は、これらの型の関連を表します:

               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

* Menu:

* Sequence Functions::       任意の種類のシーケンスを許す関数。
* Arrays::                   Emacs Lispの配列の特徴。
* Array Functions::          配列に特化した関数。
* Vectors::                  Emacs Lispベクターの特質。
* Vector Functions::         ベクターのための特別な関数。
* Char-Tables::              文字テーブルを扱う方法。
* Bool-Vectors::             ブールベクターを扱う方法。
* Rings::                    オブジェクトの固定サイズのリングを管理する。


File: elisp,  Node: Sequence Functions,  Next: Arrays,  Up: Sequences Arrays Vectors

6.1 Sequences
=============

このセクションでは、任意の種類のシーケンスを許す関数を説明します。

 -- Function: sequencep object
     この関数は、OBJECTがリスト、ベクター、文字列、ブールベクター、文字
     テーブルの場合は‘t’、それ以外は‘nil’をreturnします。

 -- Function: length sequence
     この関数は、SEQUENCE内の要素の数をreturnします。SEQUENCEがドットリ
     ストの場合、‘wrong-type-argument’エラーがシグナルされます。循環リス
     トは無限ループを引き起こします。文字テーブルでは、Emacsの最大文字コ
     ードより、常に1大きい値がreturnされます。

     関連する関数‘safe-length’については、*note Definition of
     safe-length::を参照してください。

          (length '(1 2 3))
              ⇒ 3
          (length ())
              ⇒ 0
          (length "foobar")
              ⇒ 6
          (length [1 2 3])
              ⇒ 3
          (length (make-bool-vector 5 nil))
              ⇒ 5

*note Text Representations::の‘string-bytes’も参照してください。

   ディスプレー上での文字列の幅を計算する必要がある場合、文字数だけを数
えて各文字のディスプレー幅を計算しない‘length’ではなく、‘string-width’
(*note Size of Displayed Text::を参照してください)を使用するべきです。

 -- Function: elt sequence index
     この関数は、INDEXによりインデックスづけされた、SEQUENCEの要素を
     returnします。INDEXの値として妥当なのは、0からSEQUENCEの長さより1小
     さい数までの範囲の整数です。SEQUENCEがリストの場合、範囲外の値は
     ‘nth’と同じように振る舞います。*note Definition of nth::を参照して
     ください。それ以外の場合、範囲外の値は‘args-out-of-range’エラーを引
     き起こします。

          (elt [1 2 3 4] 2)
               ⇒ 3
          (elt '(1 2 3 4) 2)
               ⇒ 3
          ;; ‘elt’がどの文字をreturnするか明確にするために‘string’を使用。
          (string (elt "1234" 2))
               ⇒ "3"
          (elt [1 2 3 4] 4)
               error→ Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error→ Args out of range: [1 2 3 4], -1

     この関数は、‘aref’ (*note Array Functions::い)と‘nth’ (*note
     Definition of nth::を参照してください)を一般化したものです。

 -- Function: copy-sequence sequence
     この関数は、SEQUENCEのコピーをreturnします。コピーは元のシーケンス
     と同じ型で、同じ要素が同じ順番でもちます。

     コピーに新しい要素を格納するのは、元のSEQUENCEに影響を与えず、その
     逆も真です。しかし新しいシーケンス内の要素がコピーされたものでない
     場合は、元のシーケンスの要素と同一(‘eq’)になります。したがって、コ
     ピーされたシーケンスを通じて見つかった要素を変更すると、この変更は
     元のシーケンスでも見ることができます。

     シーケンスがテキストプロパティーをともなう文字列の場合、コピー内の
     プロパティーリスト自身もコピーとなり、元のシーケンスのプロパティー
     リストと共有はされません。しかし、プロパティーリストの実際の値は共
     有されます。*note Text Properties::を参照してください。

     この関数は、ドットリストでは機能しません。循環リストのコピーは、無
     限ループを起こすでしょう。

     シーケンスをコピーする別の方法は、*note Building Lists::の
     ‘append’、*note Creating Strings::の‘concat’、*note Vector
     Functions::の‘vconcat’も参照してください。

          (setq bar '(1 2))
               ⇒ (1 2)
          (setq x (vector 'foo bar))
               ⇒ [foo (1 2)]
          (setq y (copy-sequence x))
               ⇒ [foo (1 2)]

          (eq x y)
               ⇒ nil
          (equal x y)
               ⇒ t
          (eq (elt x 1) (elt y 1))
               ⇒ t

          ;; 一方のシーケンスの要素を置き換え。
          (aset x 0 'quux)
          x ⇒ [quux (1 2)]
          y ⇒ [foo (1 2)]

          ;; 共有された要素の内部を変更。
          (setcar (aref x 1) 69)
          x ⇒ [quux (69 2)]
          y ⇒ [foo (69 2)]


File: elisp,  Node: Arrays,  Next: Array Functions,  Prev: Sequence Functions,  Up: Sequences Arrays Vectors

6.2 Arrays
==========

“配列(array)”オブジェクトは、いくつかのLispオブジェクトを保持するスロッ
トをもち、これらのオブジェクトは配列の要素と呼ばれます。配列内の任意の要
素は、一定時間でアクセスされます。対照的に、リスト内の要素のアクセスに要
する時間は、その要素がリスト内のどの位置にあるかに比例します。

   Emacsは4つの配列型 —“文字列(strings。*note String Type::を参照してく
ださい)”、“ベクター(vectors。*note Vector Type::を参照してください)”、
“ブールベクター(bool-vectors。*note Bool-Vector Type::を参照してください
)”、“文字テーブル(char-tables。*note Char-Table Type::を参照してください
)” — を定義し、これらはすべて1次元です。ベクターと文字テーブルは任意の型
の要素を保持できますが、文字列は文字だけ、ブールベクターは‘t’か‘nil’しか
保持できません。

   4種のすべての配列は、これらの特性を共有します:

   • 配列の1番目の要素はインデックス0、2番目はインデックス1、...となりま
     す。これは“0基準(zero-origin)”のインデックスづけと呼ばれます。たと
     えば、4つの要素の配列のインデックスは0、1、2、3です。

   • 配列の長さは、1度配列が作成されたら固定されるので、既存の配列の長さ
     は変更できません。

   • 評価において、配列は定数 — つまりそれ自身に評価されます。

   • 配列の要素は、関数‘aref’により参照されたり、関数‘aset’により変更さ
     れるかもしれません(*note Array Functions::を参照してください)。

   配列を作成したとき、文字テーブル以外では、長さを指定しなければなりま
せん。文字テーブルの長さは、文字コードの範囲により決定されるので、長さを
指定できません。

   原則として、テキスト文字の配列が欲しい場合は、文字列とベクターのどち
らかを使用できます。実際のところ、そのような用途にたいしては、4つの理由
により、わたしたちは常に文字列を選択します:

   • 文字列は、同じ要素をもつベクターと比較して、占めるスペースが1/4です
     。

   • 文字列の内容は、テキストとしてより明解な方法によりプリントされます
     。

   • 文字列はテキストプロパティーを保持できます。*note Text
     Properties::を参照してください。

   • Emacsがもつ特化された編集機能およびI/O機能の多くが、文字列だけに適
     用されます。たとえば、文字列をバッファーに挿入する方法では、文字の
     ベクターをバッファーに挿入できません。*note Strings and
     Characters::を参照してください

   対照的に、(キーシーケンスのような)キーボード入力文字の配列では、多く
のキーボード入力文字は、文字列に収まる範囲の外にあるので、ベクターが必要
になるでしょう。*note Key Sequence Input::を参照してください。


File: elisp,  Node: Array Functions,  Next: Vectors,  Prev: Arrays,  Up: Sequences Arrays Vectors

6.3 Functions that Operate on Arrays
====================================

このセクションでは、すべての型の配列に適用される関数を説明します。

 -- Function: arrayp object
     この関数は、OBJECTが配列(ベクター、文字列、ブールベクター、文字テー
     ブル)の場合は、‘t’をreturnします。

          (arrayp [a])
               ⇒ t
          (arrayp "asdf")
               ⇒ t
          (arrayp (syntax-table))    ;; 文字テーブル。
               ⇒ t

 -- Function: aref array index
     この関数は、ARRAYのINDEX番目の要素をreturnします。1番目の要素のイン
     デクスは0です。

          (setq primes [2 3 5 7 11 13])
               ⇒ [2 3 5 7 11 13]
          (aref primes 4)
               ⇒ 11
          (aref "abcdefg" 1)
               ⇒ 98           ; ‘b’のASCIIコードは98。

     *note Sequence Functions::の関数‘elt’も参照してください。

 -- Function: aset array index object
     この関数は、ARRAYのINDEX番目の要素を、OBJECTにセットします。この関
     数はOBJECTをeturnします。

          (setq w [foo bar baz])
               ⇒ [foo bar baz]
          (aset w 0 'fu)
               ⇒ fu
          w
               ⇒ [fu bar baz]

          (setq x "asdfasfd")
               ⇒ "asdfasfd"
          (aset x 3 ?Z)
               ⇒ 90
          x
               ⇒ "asdZasfd"

     ARRAYが文字列でOBJECTが文字でない場合、結果は
     ‘wrong-type-argument’エラーになります。この関数は、文字列の挿入で必
     要な場合は、ユニバイト文字列をマルチバイト文字列に変換します。

 -- Function: fillarray array object
     この関数は配列ARRAYをOBJECTで充填するので、ARRAYのすべての要素は
     OBJECTになります。この関数はARRAYをreturnします。

          (setq a [a b c d e f g])
               ⇒ [a b c d e f g]
          (fillarray a 0)
               ⇒ [0 0 0 0 0 0 0]
          a
               ⇒ [0 0 0 0 0 0 0]
          (setq s "When in the course")
               ⇒ "When in the course"
          (fillarray s ?-)
               ⇒ "------------------"

     ARRAYが文字列でOBJECTが文字でない場合、結果は
     ‘wrong-type-argument’エラーになります。

   配列と判っているオブジェクトにたいしては、一般的なシーケンス関数
‘copy-sequence’および‘length’が有用なときが多くあります。*note Sequence
Functions::を参照してください。


File: elisp,  Node: Vectors,  Next: Vector Functions,  Prev: Array Functions,  Up: Sequences Arrays Vectors

6.4 Vectors
===========

“ベクター(vector)”とは、任意のLispオブジェクトを要素にもつことができる、
一般用途のための配列です(対照的に、文字列の要素は文字だけです*note
Strings and Characters::を参照してください)。Emacsではベクターは、キーシ
ーケンス(*note Key Sequences::を参照してください)、シンボル検索用のテー
ブル(*note Creating Symbols::を参照してください)、バイトコンパイルされた
関数表現の一部(*note Byte Compilation::を参照してください)など、多くの目
的で使用されます。

   他の配列と同様、ベクターは０基準のインデックスづけを使用し、1番目の要
素はインデックス0になります。

   ベクターは、角カッコ(square brackets)で囲まれた要素としてプリントされ
ます。したがって、シンボル‘a’、‘b’、‘a’を要素にもつベクターは、‘[a b
a]’とプリントされます。Lisp入力として、同じ方法でベクターを記述できます
。

   文字列や数値と同様に、ベクターは定数として評価され、評価された結果は
同じベクターになります。ベクターの要素は評価も確認もされません。*note
Self-Evaluating Forms::を参照してください。

   以下はこれらの原理を表す例です:

     (setq avector [1 two '(three) "four" [five]])
          ⇒ [1 two (quote (three)) "four" [five]]
     (eval avector)
          ⇒ [1 two (quote (three)) "four" [five]]
     (eq avector (eval avector))
          ⇒ t


File: elisp,  Node: Vector Functions,  Next: Char-Tables,  Prev: Vectors,  Up: Sequences Arrays Vectors

6.5 Functions for Vectors
=========================

ベクターに関連した関数をいくつか示します:

 -- Function: vectorp object
     この関数は、OBJECTがベクターの場合は、‘t’をreturnします。

          (vectorp [a])
               ⇒ t
          (vectorp "asdf")
               ⇒ nil

 -- Function: vector &rest objects
     この関数は、引数OBJECTSを要素にもつベクターを作成してreturnします。

          (vector 'foo 23 [bar baz] "rats")
               ⇒ [foo 23 [bar baz] "rats"]
          (vector)
               ⇒ []

 -- Function: make-vector length object
     この関数は、OBJECTに初期化されたLENGTH個の要素からなる、新しいベク
     ターをreturnします。

          (setq sleepy (make-vector 9 'Z))
               ⇒ [Z Z Z Z Z Z Z Z Z]

 -- Function: vconcat &rest sequences
     この関数は、SEQUENCESのすべての要素を含む、新しいベクターをreturnし
     ます。引数SEQUENCESは真リスト、ベクター、文字列、ブールベクターです
     。SEQUENCESが与えられない場合、空のベクターがreturnされます。

     値は空のベクター、または任意の既存のベクターと‘eq’ではない、新しい
     空ではないベクターのどちらかです。

          (setq a (vconcat '(A B C) '(D E F)))
               ⇒ [A B C D E F]
          (eq a (vconcat a))
               ⇒ nil
          (vconcat)
               ⇒ []
          (vconcat [A B C] "aa" '(foo (6 7)))
               ⇒ [A B C 97 97 foo (6 7)]

     ‘vconcat’関数は、引数としてバイトコード関数オブジェクトもとることが
     できます。これは、バイトコード関数オブジェクトの内容全体にアクセス
     するのを容易にするための、特別な機能です。*note Byte-Code
     Objects::を参照してください。

     結合を行なう他の関数については、*note Mapping Functions::の
     ‘mapconcat’、*note Creating Strings::の‘concat’、*note Building
     Lists::の‘append’を参照してください。

   ‘append’関数は、ベクターを同じ要素をもつリストに変換する方法も提供し
ます:

     (setq avector [1 two (quote (three)) "four" [five]])
          ⇒ [1 two (quote (three)) "four" [five]]
     (append avector nil)
          ⇒ (1 two (quote (three)) "four" [five])


File: elisp,  Node: Char-Tables,  Next: Bool-Vectors,  Prev: Vector Functions,  Up: Sequences Arrays Vectors

6.6 Char-Tables
===============

文字テーブル(char-table)はベクターとよく似ていますが、文字テーブルは文字
コードによりインデックスづけされます。文字テーブルのインデックスには、修
飾キーをともなわない任意の有効な文字コードを使用できます。他の配列と同様
に、‘aref’と‘aset’で、文字テーブルの要素にアクセスできます。加えて、文字
テーブルは、追加のデータを保持するために、特定の文字コードに関連づけられ
ていない、“エキストラスロット(extra slots)”をもつことができます。ベクタ
ーと同様、文字テーブルは、定数として評価され、任意の型の要素を保持できま
す。

   文字テーブルはそれぞれ“サブタイプ(subtype)”をもち、これは2つの目的を
担うシンボルです:

   • サブタイプは、それがなんのための文字テーブルなのか、簡単に表す方法
     を提供します。たとえば、ディスプレーテーブル(display tables)はサブ
     タイプが‘display-table’の文字テーブルであり、構文テーブル(syntax
     tables)は、サブタイプが‘syntax-table’の文字テーブルです。以下で説明
     するように、関数‘char-table-subtype’を使用して、サブタイプを問い合
     わせることができます。

   • サブタイプは文字テーブル内のいくつかの“エキストラスロット(extra
     slots)”を制御します。エキストラスロットの数は、そのサブタイプの
     ‘char-table-extra-slots’シンボルプロパティー(*note Symbol
     Properties::を参照してください)により指定され、値は0から10の整数で
     す。サブタイプにそのようなシンボルプロパティーがない場合、その文字
     テーブルはエキストラスロットをもちません。

   文字テーブルは“親(parent)”をもつことができ、これは他の文字テーブルで
す。文字テーブルが親をもつ場合、その文字テーブルで特定の文字Cにたいして
‘nil’が指定されているときは、親として指定された文字テーブルで指定された
値を継承します。言い方を変えると、文字テーブルCHAR-TABLEでCに‘nil’が指定
されている場合、‘(aref CHAR-TABLE C)’はCHAR-TABLEの親の値をreturnします
。

   文字テーブルは“デフォルト値(default value)”をもつこともできます。デフ
ォルト値をもつとき、文字テーブルCHAR-TABLEがCにたいして‘nil’値を指定する
と、‘(aref CHAR-TABLE C)’はデフォルト値をreturnします。

 -- Function: make-char-table subtype &optional init
     サブタイプSUBTYPE(シンボル)をもつ、新たに作成された文字テーブルを
     returnします。各要素はINITに初期化され、デフォルトは‘nil’です。文字
     テーブルが作成された後で、文字テーブルのサブタイプを変更することは
     できません。

     すべての文字テーブルは、インデックスとなる任意の有効な文字テーブル
     のための空間をもつので、文字テーブルの長さを指定する引数はありませ
     ん。

     SUBTYPEが‘char-table-extra-slots’シンボルプロパティーをもつ場合、そ
     れはその文字列テーブル内のエキストラスロットの数を指定します。値に
     は0から10の整数を指定し、これ以外の場合‘make-char-table’はエラーと
     なります。SUBTYPEが‘char-table-extra-slots’シンボルプロパティー
     (*note Property Lists::を参照してください)をもたない場合、その文字
     テーブルはエキストラスロットをもちません。

 -- Function: char-table-p object
     この関数は、OBJECTが文字テーブルの場合は‘t’、それ以外は‘nil’を
     returnします。

 -- Function: char-table-subtype char-table
     この関数は、CHAR-TABLEのサブタイプのシンボルをreturnします。

   文字テーブルのデフォルト値にアクセスするための、特別な関数は存在しま
せん。これを行なうには、‘char-table-range’を使用します(以下参照)。

 -- Function: char-table-parent char-table
     この関数は、CHAR-TABLEの親をreturnします。親は常に、‘nil’、または他
     の文字テーブルです。

 -- Function: set-char-table-parent char-table new-parent
     この関数は、CHAR-TABLEの親を、NEW-PARENTにセットします。

 -- Function: char-table-extra-slot char-table n
     このガン数は、CHAR-TABLEのエキストラスロットNの内容をreturnします。
     文字テーブルのエキストラスロットの数は、文字テーブルのサブタイプに
     より決定されます。

 -- Function: set-char-table-extra-slot char-table n value
     この関数は、CHAR-TABLEのエキストラスロットNに、VALUEを格納します。

   文字テーブルは、1つの文字コードにたいして、1つの要素値(element
value)を指定できます。文字テーブルは文字セット全体にたいして値を指定する
こともできます。

 -- Function: char-table-range char-table range
     この関数は、文字範囲RANGEにたいして、CHAR-TABLEで指定された値を
     returnします。可能なRANGEは以下のとおりです:

     ‘nil’
          デフォルト値への参照。

     CHAR
          文字CHARにたいする要素への参照(CHARは有効な文字コードであると
          仮定)。

     ‘(FROM . TO)’
          包括的な範囲‘[FROM..TO]’内のすべての文字を参照するコンスセル。

 -- Function: set-char-table-range char-table range value
     この関数は、CHAR-TABLE内の文字範囲RANGEにたいして値をセットします。
     可能なRANGEは、以下のとおりです:

     ‘nil’
          デフォルト値への参照。

     ‘t’
          文字コード範囲の全体を参照。

     CHAR
          文字CHARにたいする要素への参照(CHARは有効な文字コードであると
          仮定)。

     ‘(FROM . TO)’
          包括的な範囲‘[FROM..TO]’内のすべての文字を参照するコンスセル。

 -- Function: map-char-table function char-table
     この関数は、CHAR-TABLEの非‘nil’値ではない各要素にたいして、引数
     FUNCTIONを呼び出します。FUNCTIONの呼び出しでは、2つの引数(keyと
     value)が指定されます。keyは‘char-table-range’にたいする可能なRANGE
     — 有効な文字か、同じ値を共有する文字範囲を指定するコンスセル‘(FROM
     . TO)’です。valueは、‘(char-table-range CHAR-TABLE KEY)’がreturnす
     る値です。

     全体的に見て、FUNCTIONに渡されるkey-valueのペアは、CHAR-TABLEに格納
     されたすべての値を表します。

     return値はm常に‘nil’です。‘map-char-table’呼び出しを有用にするため
     に、FUNCTIONは副作用をもつべきです。たとえば、以下は構文テーブルを
     調べる方法です:

          (let (accumulator)
             (map-char-table
              #'(lambda (key value)
                  (setq accumulator
                        (cons (list
                               (if (consp key)
                                   (list (car key) (cdr key))
                                 key)
                               value)
                              accumulator)))
              (syntax-table))
             accumulator)
          ⇒
          (((2597602 4194303) (2)) ((2597523 2597601) (3))
           ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))
           ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))


File: elisp,  Node: Bool-Vectors,  Next: Rings,  Prev: Char-Tables,  Up: Sequences Arrays Vectors

6.7 Bool-vectors
================

ブールベクター(bool-vector)はベクターとよく似ていますが、値に‘t’と
‘nil’しか格納できません。ブールベクターの要素に非‘nil’値の格納を試みた場
合、そこに‘t’が格納されます。すべての配列と同様、ブールベクターのインデ
ックスは0から開始され、1度ブールベクターが作成されたら、長さを変更するこ
とはできません。ブールベクターは定数として評価されます。

   ブールベクターを処理する、特別な関数が2つあります。その関数意外にも、
他の種類の配列に使用されるのと同じ関数で、ブールベクターを操作できます。

 -- Function: make-bool-vector length initial
     INITIALに初期化された、LENGTH要素の新しいブールベクターをreturnしま
     す。

 -- Function: bool-vector-p object
     この関数は、OBJECTがブールベクターであれば‘t’、それ以外は‘nil’を
     returnします。

   以下で説明するように、ブールベクターのセット処理を行なう関数がいくつ
かあります:

 -- Function: bool-vector-exclusive-or a b &optional c
     ブールベクターAとBの、“ビットごとの排他的論理和(bitwise exclusive
     or)”をreturnします。オプション引数Cが与えられた場合、この処理の結果
     はCに格納されます。引数はすべて、同じ長さのブールベクターを指定しま
     す。

 -- Function: bool-vector-union a b &optional c
     ブールベクターAとBの、“ビットごとの論理和(bitwise or)”をreturnしま
     す。オプション引数Cが与えられた場合、この処理の結果はCに格納されま
     す。引数はすべて、同じ長さのブールベクターを指定します。

 -- Function: bool-vector-intersection a b &optional c
     ブールベクターAとBの、“ビットごとの論理積(bitwise and)”をreturnしま
     す。オプション引数Cが与えられた場合、この処理の結果はCに格納されま
     す。引数はすべて、同じ長さのブールベクターを指定します。

 -- Function: bool-vector-set-difference a b &optional c
     ブールベクターAとBの、“差集合(set difference)”をreturnします。オプ
     ション引数Cが与えられた場合、この処理の結果はCに格納されます。引数
     はすべて、同じ長さのブールベクターを指定します。

 -- Function: bool-vector-not a &optional b
     ブールベクターAの、“補集合(set complement)”をreturnします。オプショ
     ン引数Bが与えられた場合、この処理の結果はBに格納されます。引数はす
     べて、同じ長さのブールベクターを指定します。

 -- Function: bool-vector-subsetp a b
     A内のすべての‘t’値が、Bでも‘t’値の場合は‘t’、それ以外は‘nil’を
     returnします。引数はすべて、同じ長さのブールベクターを指定します。

 -- Function: bool-vector-count-consecutive a b i
     Iから始まるAの、Bと等しい連続する要素の数をreturnします。‘a’はブー
     ルベクターで、Bは‘t’か‘nil’、Iは‘a’のインデックスです。

 -- Function: bool-vector-count-population a
     ブールベクターAの、‘t’の要素の数をreturnします。

   以下はブールベクターを作成、確認、更新する例です。長さ8以下のブール値
のプリント表記は、1つの文字で表されることに注意してください。

     (setq bv (make-bool-vector 5 t))
          ⇒ #&5"^_"
     (aref bv 1)
          ⇒ t
     (aset bv 3 nil)
          ⇒ nil
     bv
          ⇒ #&5"^W"

control-_の2進コードは11111、control-Wは10111なので、この結果は理解でき
るでしょう。


File: elisp,  Node: Rings,  Prev: Bool-Vectors,  Up: Sequences Arrays Vectors

6.8 Managing a Fixed-Size Ring of Objects
=========================================

“リング(ring)”は、挿入、削除、ローテーション、剰余(modulo)でインデックス
づけされた参照と走査(traversal)をサポートする、固定長のデータ構造です。
‘ring’パッケージにより、効率的なリングデータ構造が実装されています。この
パッケージは、このセクションにリストされた関数を提供します。

   killリングやマークリングのような、Emacsにあるいくつかの“リング”は、実
際には単なるリストとして実装されていることに注意してください。したがって
、これらのリングにたいしては、以下の関数は機能しないでしょう。

 -- Function: make-ring size
     この関数は、SIZEオブジェクトを保持できる、新しいリングをreturnしま
     す。SIZEは整数です。

 -- Function: ring-p object
     この関数は、OBJECTがリングの場合は‘t’、それ以外は‘nil’をreturnしま
     す。

 -- Function: ring-size ring
     この関数は、RINGの最大の要素数をreturnします。

 -- Function: ring-length ring
     この関数は、RINGに現在含まれている、オブジェクトの数をreturnします
     。値は、‘ring-size’でreturnされる値を超えることはありません。

 -- Function: ring-elements ring
     この関数は、RING内のオブジェクトのリストをreturnします。リストの順
     序は、新しいオブジェクトが先頭になります。

 -- Function: ring-copy ring
     個の関数は、RINGのコピーを新しいリングとしてreturnします。新しいリ
     ングは、RINGと同じ(‘eq’な)オブジェクトを含みます。

 -- Function: ring-empty-p ring
     この関数は、RINGが空の場合は‘t’、それ以外は‘nil’をreturnします。

   リング内の1番新しい要素は、常にインデックス0をもちます。より大きいイ
ンデックスは、より古い要素に対応します。インデックスは、リング長の
moduloにより計算されます。インデックス−1は1番古い要素、−2は次に古い要素
、...となります。

 -- Function: ring-ref ring index
     この関数はインデックスINDEXにあるRING内のオブジェクトをreturnします
     。INDEXには負、またはリング長より大きい数を指定できます。RINGがから
     の場合、‘ring-ref’はエラーをシグナルします。

 -- Function: ring-insert ring object
     この関数は、1番新しい要素としてOBJECTをRINGに挿入し、OBJECTを
     returnします。

     リングが一杯の場合、新しい要素のための空きを作るため、挿入により1番
     古い要素が削除されます。

 -- Function: ring-remove ring &optional index
     RINGからオブジェクトを削除して、そのオブジェクトをreturnします。引
     数INDEXは、どのアイテムを削除するかを指定します。これが‘nil’の場合
     、それは1番古いアイテムを削除することを意味します。RINGが空の場合、
     ‘ring-remove’はエラーをシグナルします。

 -- Function: ring-insert-at-beginning ring object
     この関数は、1番古い要素として、OBJECTをRINGに挿入します。return値は
     、意味をもちません。

     リングが一杯の場合、この関数は挿入される要素のための空きを作るため
     に、1番新しい要素を削除します。

   リングサイズを超えることを気にしない場合、そのリングを
FIFO(first-in-first-out: 先入れ先出し)のキューとして使用することができま
す。たとえば:

     (let ((fifo (make-ring 5)))
       (mapc (lambda (obj) (ring-insert fifo obj))
             '(0 one "two"))
       (list (ring-remove fifo) t
             (ring-remove fifo) t
             (ring-remove fifo)))
          ⇒ (0 t one t "two")


File: elisp,  Node: Hash Tables,  Next: Symbols,  Prev: Sequences Arrays Vectors,  Up: Top

7 Hash Tables
*************

ハッシュテーブル(hash table)は、非常に高速なルックアップテーブルの一種で
、キーを対応する値にマップするという点では、alist(*note Association
Lists::を参照してください)に似ています。ハッシュテーブルは、以下の点で
alistと異なります:

   • ハッシュテーブルでのルックアップ(lookup: 照合)は、巨大なテーブルに
     たいして非常に高速です — 実際のところ、ルックアップに必要な時間は、
     そのテーブルにいくつの要素が格納されているかとは、基本的に_無関係
     _です。ハッシュテーブルには多少の一定なオーバーヘッドがあるので、小
     さいテーブル(数十の要素)では、alistのほうが高速でしょう。

   • ハッシュテーブル内の対応には、特定の順序はありません。

   • 2つのalistが共通の末尾(tail)を共有する方法のように、2つのハッシュテ
     ーブル間で構造を共有する方法はありません。

   Emacs Lispは、それらを処理する一連の関数とともに、一般的な用途のハッ
シュテーブルデータ型を提供します。ハッシュテーブルは特別なプリント表現を
もち、それは‘#s’と、その後にハッシュテーブルのプロパティーと内容お指定す
るリストが続きます。*note Creating Hash::を参照してください。(用語“ハッ
シュ表記(hash notation)”は、プリント表現の最初に‘#’を使用する、入力構文
をもたないオブジェクトのことを指し、これは用語“ハッシュテーブル(hash
table)”にたいしては使用されません。*note Printed Representation::を参照
してください。)

   obarray(オブジェクト配列)もハッシュテーブルの一種ですが、これらは異な
る型のオブジェクトで、intern(インターン)されたシンボルを記録するためだけ
に使用されます(*note Creating Symbols::を参照してください)。

* Menu:

* Creating Hash::            ハッシュテーブルを作成する関数。
* Hash Access::              ハッシュテーブルの内容の読み書き。
* Defining Hash::            新たな比較方法の定義。
* Other Hash::               その他。


File: elisp,  Node: Creating Hash,  Next: Hash Access,  Up: Hash Tables

7.1 Creating Hash Tables
========================

ハッシュテーブルを作成する基本的な関数は、‘make-hash-table’です。

 -- Function: make-hash-table &rest keyword-args
     この関数は、指定された引数に対応する、新しいハッシュテーブルを作成
     します。引数は、キーワード(特別に認識される独自のシンボル)と、それ
     に対応する値を交互に指定することにより構成されます。

     ‘make-hash-table’では、いくつかのキーワードが意味をもちますが、実際
     に知る必要があるのは、‘:test’と‘:weakness’の2つだけです。

     ‘:test TEST’
          これは、このハッシュテーブルにたいしてキーを照合する方法を指定
          します。デフォルトは‘eql’であり、他の代替としては‘eq’や
          ‘equal’があります:

          ‘eql’
               キーが数字の場合、それらが‘equal’であれば、つまり、それら
               の値が等しく、どちらも整数、あるいはどちらも浮動少数の場
               合は“同一”です。それ以外では、2つの別々のオブジェクトは、
               決して“同一”になりません。

          ‘eq’
               2つの個別のLispオブジェクトはすべて、“別”のキーです。

          ‘equal’
               2つの個別のLispオブジェクトにたいして、それらが‘equal’の
               場合、“同一”のキーです。

          TESTにたいして追加の選択肢を定義するために、
          ‘define-hash-table-test’ (*note Defining Hash::を参照してくだ
          さい)を使用することができます。

     ‘:weakness WEAK’
          ハッシュテーブルのweakness(強度)は、ハッシュテーブル内に存在す
          るキーと値を、ガーベージコレクションから保護するかどうかを指定
          します。

          値WEAKは、‘nil’、‘key’、‘value’、‘key-or-value’、
          ‘key-and-value’、または‘t’(‘key-and-value’のエイリアス)のうち
          の1つを指定しなければなりません。WEAKが‘key’の場合、そのハッシ
          ュテーブルは、(キーが他の場所で参照されていなければ)ハッシュテ
          ーブルのキーがガーベージコレクトされるのを妨げません。ある特定
          のキーがガーベージコレクトされた場合、それに対応する連想は、ハ
          ッシュテーブルから削除されます。

          WEAKが‘value’の場合、そのハッシュテーブルは、(値が他の場所で参
          照されていなければ)ハッシュテーブルの値がガベージコレクトされ
          るのを妨げません。あるP特定の値がガーベージコレクトされた場合
          、それに対応する連想は、ハッシュテーブルから削除されます。

          WEAKが‘key-and-value’(または‘t’)の場合、その連想を保護するため
          に、キーと値の両方が生きていなければなりません。したがって、そ
          のハッシュテーブルは、キーと値のどちらかをガーベージコレクトか
          ら守ることはしません。キーか値のどちらか一方がガーベージコレク
          トされたら、その連想は削除されます。

          WEAKが‘key-or-value’の場合、キーか値のどちらか一方で、その連想
          を保護することができます。したがって、キーと値の両方がガベージ
          コレクトされたときだけ(それがハッシュテーブル自体にたいする参
          照でなければ)、ハッシュテーブルからその連想が削除されます。

          WEAKにたいするデフォルトは‘nil’なので、ハッシュテーブルから参
          照されているキーと値のすべては、ガーベージコレクションから保護
          されます。

     ‘:size SIZE’
          これは、そのハッシュテーブルに連想を保管しようと計画している、
          連想の数にたいするヒントを指定します。数が概算で判っている場合
          、この方法でそれを指定することにより、処理を少し効率的にするこ
          とができます。小さすぎるサイズを指定した場合、そのハッシュテー
          ブルは必要に応じて自動的に拡張子マスが、これを行なうには時間が
          余計にかかります。

          デフォルトのサイズは65です。

     ‘:rehash-size REHASH-SIZE’
          ハッシュテーブルに連想を追加するとき、そのテーブルが“一杯
          (full)”の場合、テーブルは自動的に拡張します。この値は、そのと
          きどれだけハッシュテーブルを拡張するかを指定します。

          REHASH-SIZEが整数の場合(それは正であるべきです)、通常のサイズ
          にREHASH-SIZEを加えることにより、ハッシュテーブルが拡張されま
          す。REHASH-SIZEが浮動小数の場合(1より大きい方がよい)は、古いサ
          イズにその数を乗じることにより、ガッシュテーブルが拡張されます
          。

          デフォルト値は1.5です。

     ‘:rehash-threshold THRESHOLD’
          これは、ハッシュテーブルが“一杯(full)”(なのでもっと大きく拡張
          する必要がある)だと判断される基準を指定します。THRESHOLDの値は
          、1以下の、正の浮動小数点数であるべきです。実際のエントリー数
          が、通常のサイズにたいする指定した割合を超えた場合、そのハッシ
          ュテーブルは“一杯”になります。THRESHOLDのデフォルトは、0.8です
          。

 -- Function: makehash &optional test
     この関数は‘make-hash-table’と同じですが、異なるスタイルの引数リスト
     を指定します。引数TESTは、キーを照合する方法を指定します。

     この関数は時代遅れです。かわりに‘make-hash-table’を使用してください
     。

   ハッシュテーブルのプリント表現を使用して、新しいハッシュテーブルを作
成することもできます。指定されたハッシュテーブル内の各要素が、有効な入力
構文(*note Printed Representation::を参照してください)をもっていれば、
Lispリーダーをこのプリント表現を読み取ることができます。たとえば以下は、
値‘val1’(シンボル)と‘300’(数字)に関連づけられた、キー‘key1’と‘key2’(両方
ともシンボル)を、新しいハッシュテーブルを指定します。

     #s(hash-table size 30 data (key1 val1 key2 300))

ハッシュテーブルのプリント表現は、‘#s’と、その後の‘hash-table’で始まるリ
ストにより構成されます。このリストの残りの部分は、そのハッシュテーブルの
プロパティーと初期内容を指定する、0個以上のプロパティーと値のペアで構成
されるべきです。プロパティーと値は、そのまま読み取られます。有効なプロパ
ティー名は、‘size’、‘test’、‘weakness’、‘rehash-size’、
‘rehash-threshold’、および‘data’です。‘data’プロパティーは、初期ないよう
にたいするキーと値のペアのリストであるべきです。他のプロパティーは、上記
で説明した‘make-hash-table’のキーワード(‘:size’、‘:test’など)と同じ意味
をもちます。

   バッファーやフレームのような、入力構文をもたないオブジェクトを含む初
期内容をもつハッシュテーブルを指定できないことに注意してください。そのよ
うなオブジェクトは、ハッシュテーブルが作成された後に追加します。


File: elisp,  Node: Hash Access,  Next: Defining Hash,  Prev: Creating Hash,  Up: Hash Tables

7.2 Hash Table Access
=====================

このセクションでは、ハッシュテーブルにアクセスしたり、連想を保管する関数
を説明します。一般的に、比較方法による制限がない限り、任意のLispオブジェ
クトをハッシュキーとして使用できます。

 -- Function: gethash key table &optional default
     この関数はTABLEのKEYを照合して、それに関連づけられたVALUE — TABLE内
     にKEYをもつ連想が存在しない場合はDEFAULT — をreturnします。

 -- Function: puthash key value table
     この関数は、TABLE内に、値VALUEをもつKEYの連想を挿入します。TABLEが
     すでにKEYの連想をもつ場合、VALUEにより古い連想値が置き換えられます
     。

 -- Function: remhash key table
     この関数は、TABLEにKEYの連想がある場合は、それを削除します。KEYが連
     想をもたない場合、‘remhash’は何も行ないません。

     Common Lispに関する注意: Common Lispでは、‘remhash’が実際に連想を削
     除したときは非‘nil’、それ以外は‘nil’をreturnします。Emacs Lispでは
     、‘remhash’は常に‘nil’をreturnします。

 -- Function: clrhash table
     この関数は、ハッシュテーブルTABLEからすべての連想を削除するので、そ
     のハッシュテーブルは空になります。これはハッシュテーブルの“クリーニ
     ング(clearing)”とも呼ばれます。

     Common Lispに関する注意: Common Lispでは、‘clrhash’は空のTABLEを
     returnします。Emacs Lispでは‘nil’をreturnします。

 -- Function: maphash function table
     この関数は、TABLE内の各連想にたいして、1度ずつFUNCTIONを呼び出しま
     す。関数FUNCTIONは2つの引数 — TABLEにリストされたKEYと、それに関連
     づけられたVALUE — をとるべきです。‘maphash’は‘nil’をreturnします。


File: elisp,  Node: Defining Hash,  Next: Other Hash,  Prev: Hash Access,  Up: Hash Tables

7.3 Defining Hash Comparisons
=============================

‘define-hash-table-test’により、キーを照合する新しい方法を定義できます。
この機能を使用するには、ハッシュテーブルの動作方法と、“ハッシュコード
(hash code)”の意味を理解する必要があります。

   概念的にはハッシュテーブルを、1つの連想を保持できるスロットがたくさん
ある巨大な配列として考えることができます。キーを照合するには、まず
‘gethash’が、キーから整数のハッシュコード(hash code)を計算します。配列内
のインデックスを生成するために、‘gethash’は、配列の長さにより、この整数
のmoduloを得ます。それからキーが見つかったかどうか確認するために、そのス
ロット、もし必要なら近くのスロットを探します。

   したがってキー照合の新しい方法を定義するためには、キーからハッシュコ
ードを計算する関数と、2つのキーを直接比較する関数の両方が必要です。

 -- Function: define-hash-table-test name test-fn hash-fn
     この関数は、NAMEという名前の、新たなハッシュテーブルテストを定義し
     ます。

     この方法でNAMEを定義した後では、‘make-hash-table’の引数TESTにこれを
     使用することができます。それを行なう場合、そのハッシュテーブルはキ
     ー値の比較にTEST-FN、キー値から“ハッシュコード”を計算するために
     HASH-FNを使用することになります。

     関数TEST-FNは2つの引数(2つのキー)をとり、それらが“同一”と判断された
     ときは非‘nil’をreturnします。

     関数HASH-FNは1つの引数(キー)をとり、そのキーの“ハッシュコード”(整数
     )をreturnします。よい結果を得るために、この関数は負の整数を含む整数
     の全範囲を、ハッシュコードに使用するべきです。

     指定された関数は、プロパティー‘hash-table-test’の配下の、NAMEという
     プロパティーリストに格納されます。そのプロパティーの値形式は、
     ‘(TEST-FN HASH-FN)’です。

 -- Function: sxhash obj
     この関数は、LispオブジェクトOBJにたいするハッシュコードをreturnしま
     す。return値は、OBJと、それが指す別のLispオブジェクトの内容を表す整
     数です。

     2つのオブジェクトOBJ1とOBJ2がequalの場合、‘(sxhash OBJ1)’と‘(sxhash
     OBJ2)’は同じ整数になります。

     2つのオブジェクトがequalでない場合、通常は‘sxhash’がreturnする値は
     異なりますが、常に異なるとは限りません。稀にですが(運次第)、
     ‘sxhash’が同じ結果を与える、2つの異なって見えるオブジェクトに遭遇す
     るかもしれません。

   以下は、大の字小文字を区別しない、文字列のキーをもつハッシュテーブル
を作成する例です。

     (defun case-fold-string= (a b)
       (eq t (compare-strings a nil nil b nil nil t)))
     (defun case-fold-string-hash (a)
       (sxhash (upcase a)))

     (define-hash-table-test 'case-fold
       'case-fold-string= 'case-fold-string-hash)

     (make-hash-table :test 'case-fold)

   以下は、事前に定義されたテスト値‘equal’と等価なテストを行なうハッシュ
テーブルを定義できるという例です。キーは任意のLispオブジェクトで、
equalに見えるオブジェクトは、同じキーと判断されます。

     (define-hash-table-test 'contents-hash 'equal 'sxhash)

     (make-hash-table :test 'contents-hash)


File: elisp,  Node: Other Hash,  Prev: Defining Hash,  Up: Hash Tables

7.4 Other Hash Table Functions
==============================

以下は、ハッシュテーブルに機能する他の関数です。

 -- Function: hash-table-p table
     この関数は、TABLEがハッシュテーブルオブジェクトの場合は、非‘nil’を
     returnします。

 -- Function: copy-hash-table table
     この関数は、TABLEのコピーを作成してreturnします。そのテーブル自体が
     コピーされたものである場合だけ、キーと値が共有されます。

 -- Function: hash-table-count table
     この関数はTABLE内の実際のエントリー数をreturnします。

 -- Function: hash-table-test table
     この関数は、ハッシュを行なう方法と、キーを比較する方法を指定するた
     めに、TABLEが作成されたときに与えられたTESTの値をreturnします。
     *note Creating Hash::の‘make-hash-table’を参照してください。

 -- Function: hash-table-weakness table
     この関数は、ハッシュテーブルTABLEに指定されたWEAKの値をreturnします
     。

 -- Function: hash-table-rehash-size table
     この関数は、TABLEのrehash-sizeをreturnします。

 -- Function: hash-table-rehash-threshold table
     この関数は、TABLEのrehash-thresholdをreturnします。

 -- Function: hash-table-size table
     この関数は、TABLEの現在の定義されたサイズをreturnします。


File: elisp,  Node: Symbols,  Next: Evaluation,  Prev: Hash Tables,  Up: Top

8 Symbols
*********

“シンボル(symbol)”は、一意な名前をもつオブジェクトです。このチャプターで
は、シンボル、シンボルの構成要素やプロパティーリスト、およびシンボルを作
成、インターンする方法を説明します。別のチャプターでは、シンボルを変数と
して使用したり、関数名として使用する方法が説明されています。*note
Variables::と*note Functions::を参照してください。シンボルの正確な入力構
文については、*note Symbol Type::を参照してください。

   任意のLispオブジェクトがシンボルかどうかを、‘symbolp’でテストできます
:

 -- Function: symbolp object
     この関数は、OBJECTがシンボルの場合は‘t’、それ以外は‘nil’をreturnし
     ます。

* Menu:

* Symbol Components::        シンボルは名前、値、関数定義、プロパティーリストをもつ。
* Definitions::              定義は、シンボルが使用される方法を示す。
* Creating Symbols::         シンボルが一意に保たれる方法。
* Symbol Properties::        さまざまな情報を記録するために、各シンボルはプロパティーリストをもつ。


File: elisp,  Node: Symbol Components,  Next: Definitions,  Up: Symbols

8.1 Symbol Components
=====================

各シンボルは4つの構成要素(もしくは“セル”)をもち、各構成要素はそれぞれ別
のオブジェクトを参照します:

プリント名(print name)
     そのシンボルの名前。

値(value)
     そのシンボルの、変数としての現在の値。

関数(function)
     そのシンボルの関数定義。これはシンボル、キーマップ、キーボードマク
     ロも保持できる。

プロパティーリスト(property list)
     そのシンボルのプロパティーリスト。

プリント名のセルは常に文字列を保持し、それを変更することはできません。他
の3つのセルには、任意のLispオブジェクトをセットすることができます。

   プリントメイのセルは、シンボルの名前となる文字列を保持します。シンボ
ルは、シンボル名によりテキストとして表されるので、2つのシンボルが同じな
前をもたないことが重要です。Lispリーダーは、シンボルを読み取るごとに、新
たにそれを作成する前に、指定されたシンボルがすでに存在するか調べます。シ
ンボルの名前を得るには、関数‘symbol-name’(*note Creating Symbols::を参照
してください)を使用します。

   値のセルは、シンボルの変数としての値(そのシンボル自身がLisp式として評
価されたときに得る値)を保持します。“ローカルバインディング(local
binding)”や“スコーピングルール(scoping rules)”などのような複雑なものを含
め、変数がセットされたり、取得される方法については、*Note Variables::を
参照してください。ほとんどのシンボルは、値として任意のLispオブジェクトを
もつことができますが、一部の特別なシンボルは変更できない値をもちます。こ
れらには、‘nil’、‘t’、および名前が‘:’で始まる任意のシンボル(“キーワード
(keyword)”と呼ばれます)が含まれます。*note Constant Variables::を参照し
てください。

   関数のセルは、シンボルの関数定義を保持します。実際は、‘foo’の関数セル
の中に保管されている関数を意味するとき、“関数‘foo’”といってそれを参照す
ることがよくあります。わたしたちは、必要な土岐だけ、これを明確に区別する
ことにします。関数セルは通常、関数(*note Functions::を参照してください
)か、マクロ(*note Macros::を参照してください)を保持するために使用されま
す。しかし、関数セルはシンボル(*note Function Indirection::を参照してく
ださい)、キーボードマクロ(*note Keyboard Macros::)、キーマップ(*note
Keymaps::)、またはオートロードオブジェクト(*note Autoloading::を参照して
ください)を保持するためにも使用できます。シンボルの関数セルの内容を得る
には、関数‘symbol-function’ (*note Function Cells::を参照してください)を
使用します。

   プロパティーリストのセルは通常、正しくフォーマットされたプロパティー
リストを保持するべきです。シンボルのプロパティーリストを得るには、関数
‘symbol-plist’を使用します。*note Symbol Properties::を参照してください
。

   巻子失せると値セルが、“void(空)”のときもあります。voidとは、そのセル
がどのオブジェクトも参照していないことを意味します(これは、シンボル
‘void’を保持することとは異なり、シンボル‘nil’を保持することとも異なりま
す)。voidの関数セルまたは値セルを調べようとすると、結果は‘Symbol's value
as variable is void’のようなエラーとなります。

   それぞれのシンボルは値セルと関数セルを別個にもつので、変数名と関数名
が衝突することはありません。たとえば、シンボル‘buffer-file-name’が、値
(カレントバッファーでvisitされているファイルの名前)をもち、同様に関数定
義(ファイルの名前をreturnする基本関数)をもつことができます:

     buffer-file-name
          ⇒ "/gnu/elisp/symbols.texi"
     (symbol-function 'buffer-file-name)
          ⇒ #<subr buffer-file-name>


File: elisp,  Node: Definitions,  Next: Creating Symbols,  Prev: Symbol Components,  Up: Symbols

8.2 Defining Symbols
====================

“定義(definition)”とは、特別な方法で使用を意図することを宣言する、特別な
種類のLisp式です。定義とは通常、シンボルにたいする値を指定するか、シンボ
ルにたいする1つの種類の使用についての意味と、この方法で使用するときのシ
ンボルの意味にたいするドキュメントを指定します。したがって、シンボルを変
数として定義した場合、その変数の初期値と、加えてその変数のドキュメントを
提供できます。

   ‘defvar’および‘defconst’は、“グローバル変数(global variable)” — Lispプ
ログラムの任意の箇所からアクセスできる変数 — として定義するスペシャルフ
ォームです。変数についての詳細は、*note Variables::を参照してください。
カスタマイズ可能な変数を定義するには、‘defcustom’(これはサブルーチンとし
て‘defvar’も呼び出します)を使用します(*note Customization::を参照してく
ださい)。

   原則として、最初にシンボルが変数として定義されていなくても、‘setq’で
任意のシンボルに値を割り当てることができます。しかし、使用したいそれぞれ
のグローバル変数にたいして、変数定義を記述するべきです。さもないと、レキ
シカルスコープ(*note Variable Scoping::を参照してください)が有効なときに
変数が評価された場合、あなたのLispプログラムは正しく動作しないでしょう。

   ‘defun’は、ラムダ式(lambda expression)を生成して、そのシンボルの関数
セルにそれを格納することにより、シンボルを関数として定義します。したがっ
て、このシンボルの関数定義は、このラムダ式になります(関数セルの内容を意
味する用語“関数定義(function definition)”は、‘defun’がシンボルに関数とし
ての定義を与えるというアイデアに由来します)。*note Functions::を参照して
ください。

   ‘defmacro’は、シンボルをマクロとして定義します。これはマクロオブジェ
クトを作成して、そのシンボルの関数セルにそれを格納します。シンボルにはマ
クロと関数を与えることができますが、マクロと関数定義はどちらも関数セルに
保持されるのにたいし、関数セルに保持できるのは常にただ1つのLispオブジェ
クトなので、両方1度にそれを行なうことはできないことに注意してください。
*note Macros::を参照してください。

   前に注記したように、Emacs Lispではシンボルを(たとえば‘defvar’で)変数
として定義して、同じシンボルを(たとえば‘defun’で)関数やマクロとして、両
方定義することができます。このような定義は衝突しません。

   これらの定義は、プログラミングツールのガイドを果たすこともできます。
たとえば、‘C-h f’および‘C-h v’コマンドは、関係ある変数、関数、マクロ定義
へのリンクを含むヘルプバッファーを作成します。*note (emacs)Name Help::を
参照してください。


File: elisp,  Node: Creating Symbols,  Next: Symbol Properties,  Prev: Definitions,  Up: Symbols

8.3 Creating and Interning Symbols
==================================

GNU Emacs Lispでシンボルが作成される方法を理解するには、Lispがシンボルを
読み取る方法を理解しなければなりません。Lispは、同じ文字綴りを読み取った
ら、毎回同じシンボルを見つけることを保証しなければなりません。これに失敗
すると、完全な混乱を招くでしょう。

   Lispリーダーがシンボルに出会うと、Lispリーダーは名前のすべての文字を
読み取ります。その後Lispリーダーは、“obarray(オブジェクト配列)”と呼ばれ
るテーブル内のインデックスを決めるために、これらの文字を“ハッシュ
(hash)”します。ハッシュ化(hashing)は何かを照合するのに効果的な方法です。
たとえば、Jan Jonesを見つけるときは、電話帳を表紙から1頁ずつ探すのではな
く、Jから探し始めます。これは簡単なバージョンのハッシュ化です。obarrayの
各要素は、与えられたハッシュコードとともにすべてのシンボルを保持する、
“バケット(bucket)”です。与えられた名前を探すためには、バケットの中からそ
の名前のハッシュコードのすべてのシンボルを探すのが効果的です(同じアイデ
アは一般的なEmacsのハッシュテーブルでも使用されていますが、これらは異な
るデータ型です。*note Hash Tables::を参照してください)。

   探している名前のシンボルが見つかったら、リーダーはそのシンボルを使用
します。obarrayにその名前のシンボルが含まれない場合、リーダーは新しいシ
ンボルを作成して、それをobarrayに追加します。特定の名前のシンボルを探し
て追加することを、“インターン(intern)”すると言い、これが行なわれた後、そ
のシンボルは“インターンされたシンボル(interned symbol)”と呼ばれます。

   インターンすることにより、ある特定の名前のシンボルは、それぞれの
obarrayに1つだけであることが保証されます。同じ名前のシンボルは他に存在す
るかもしれませんが、同じobarrayではありません。したがってリーダーは、(同
じobarrayを読みつづける限り)同じ名前にたいして、同じシンボルを取得します
。

   インターンは通常、リーダー内で自動的に発生しますが、他のプログラムが
これを行なう必要がある場合もあります。たとえば、‘M-x’コマンドは、その後
ミニバッファーを使用してコマンド名を文字列として取得し、その文字列をイン
ターンして、インターンされたその名前のシンボルを得ます。

   すべてのシンボルを含むobarrayはありません。実際、どのobarrayにも含ま
れないシンボルがいくつかあります。これらは、“インターンされていないシン
ボル(uninterned symbols)”と呼ばれます。インターンされていないシンボルも
、他のシンボルと同じく4つのセルをもちます。しかし、インターンされていな
いシンボルへのアクセスを得る唯一の方法は、他の何らかのオブジェクトとして
探すか、変数の値として探す方法だけです。

   インターンされていないシンボルの作成は、Lispコードを生成するとき有用
です。なぜなら、作成されたコード内で変数として使用されているインターンさ
れていないシンボルは、他のLispプログラムで使用されている任意の変数と競合
することはありえないからです。

   Emacs Lispでは、obarrayはベクターです。ベクター内の各要素がバケットに
なります。要素の値は、名前がそのバケットにハッシュされるインターンされた
シンボル、またはバケットが空のときは0です。インターンされたシンボルは、
そのバケット内の次のシンボルへの、内部リンク(ユーザーからは見えない)をも
ちます。これらのリンクは不可視なので、‘mapatoms’を使用する方法をのぞき
(以下参照)、obarray内のすべてのシンボルを探す方法はありません。バケット
内のシンボルの順番に、意味はありません。

   空のobarrayでは、すべての要素が0なので、‘(make-vector LENGTH 0)’で
obarrayを作成することができます。*obarrayを作成する有効な方法は、これだ
けです。*長さに素数を指定すると、よいハッシュ化がされる傾向があります。
2の累乗から1減じた長さも、よい結果を生む傾向があります。

   *自分でobarrayにシンボルを置かないでください。*これはうまくいきません
— obarrayに正しくシンボルを入力できるのは、‘intern’だけです。

     Common Lispに関する注意: Common Lispとは異なり、Emacs Lispは1つのシ
     ンボルを複数のobarrayにインターンする方法を提供しません。

   以下の関数のほとんどは、引数に名前とobarrayをとります。名前が文字列で
はない、またはobarrayがベクターでない場合は、‘wrong-type-argument’エラー
がシグナルされます。

 -- Function: symbol-name symbol
     この関数は、SYMBOLの名前を文字列としてreturnします。たとえば:

          (symbol-name 'foo)
               ⇒ "foo"

     *警告: *文字の置き換えにより文字列を変更すると、それはシンボルの名
     前を変更しますが、obarrayの更新には失敗するので、行なわないでくださ
     い!

 -- Function: make-symbol name
     この関数は、新たに割り当てられた、名前がNAME(文字列でなかればならな
     い)のインターンされていないシンボルをreturnします。このシンボルの値
     と関数はvoidで、プロパティーリストは‘nil’です。以下の例では、
     ‘sym’の値は‘foo’と‘eq’ではありません。なぜなら、これは名前が‘foo’の
     インターンされていないシンボルだからです。

          (setq sym (make-symbol "foo"))
               ⇒ foo
          (eq sym 'foo)
               ⇒ nil

 -- Function: intern name &optional obarray
     この関数は、名前がNAMEの、インターンされたシンボルをreturnします。
     オブジェクト配列OBARRAYの中にそのようなシンボルが存在しない場合、
     ‘intern’はあたらしいシンボルを作成してobarrayに追加し、それを
     returnします。OBARRAYが省略された場合、グローバル変数‘obarray’の値
     が使用されます。

          (setq sym (intern "foo"))
               ⇒ foo
          (eq sym 'foo)
               ⇒ t

          (setq sym1 (intern "foo" other-obarray))
               ⇒ foo
          (eq sym1 'foo)
               ⇒ nil

     Common Lispに関する注意: Common Lispでは、既存のシンボルをobarrayに
     インターンできます。Emacs Lispでは、‘intern’の引数はシンボルではな
     く文字列なので、これを行なうことはできません。

 -- Function: intern-soft name &optional obarray
     この関数は、OBARRAY内の名前がNAMEのシンボル、OBARRAYにその名前のシ
     ンボルが存在しない場合は‘nil’をreturnします。したがって、与えられた
     名前のシンボルがすでにインターンされているかテストするために、
     ‘intern-soft’を使用することができます。OBARRAYが省略された場合は、
     グローバル変数‘obarray’の値が使用されます。

     引数NAMEにはシンボルも使用できます。この場合、指定されたobarrayに
     NAMEがインターンされていればNAME、それ以外は‘nil’をreturnします。

          (intern-soft "frazzle")        ; そのようなシンボルは存在しない。
               ⇒ nil
          (make-symbol "frazzle")        ; インターンされていないシンボルを作成する。
               ⇒ frazzle
          (intern-soft "frazzle")        ; そのようなシンボルは見つからない。
               ⇒ nil
          (setq sym (intern "frazzle"))  ; インターンされたシンボルを作成する。
               ⇒ frazzle
          (intern-soft "frazzle")        ; シンボルが見つかった!
               ⇒ frazzle
          (eq sym 'frazzle)              ; そして、それは同じシンボル。
               ⇒ t

 -- Variable: obarray
     この変数は、‘intern’および‘read’で使用される、標準のobarrayです。

 -- Function: mapatoms function &optional obarray
     この関数は、オブジェクト配列OBARRAYの中のシンボルに1つにたいして、
     1度ずつFUNCTIONを呼び出し、その後‘nil’をreturnします。OBARRAYが省略
     された場合は、通常のシンボルにたいする標準のオブジェクト配列
     ‘obarray’の値がデフォルトになります。

          (setq count 0)
               ⇒ 0
          (defun count-syms (s)
            (setq count (1+ count)))
               ⇒ count-syms
          (mapatoms 'count-syms)
               ⇒ nil
          count
               ⇒ 1871

     ‘mapatoms’を使用する他の例については、*note Accessing
     Documentation::の‘documentation’を参照してください。

 -- Function: unintern symbol obarray
     この関数は、オブジェクト配列OBARRAYから、SYMBOLを削除します。
     obarrayの中に‘symbol’が存在しない場合、‘unintern’は何も行ないません
     。OBARRAYが‘nil’の場合は、現在のobarrayが使用されます。

     SYMBOLにシンボルではなく文字列を与えた場合、それはシンボルの名前を
     意味します。この場合、‘unintern’は、(もしあれば)obarrayからその名前
     のシンボルを削除します。そのようなシンボルが存在する場合、
     ‘unintern’は何も行ないません。

     ‘unintern’がシンボルを削除した場合は‘t’、それ以外は‘nil’をreturnし
     ます。


File: elisp,  Node: Symbol Properties,  Prev: Creating Symbols,  Up: Symbols

8.4 Symbol Properties
=====================

シンボルは、そのシンボルについての様々な情報を記録するために使用される、
任意の数の“シンボルプロパティー(symbol properties)”をもつことができます
。たとえば、シンボルの‘risky-local-variable’プロパティーが‘nil’の場合は
、その変数の名前が、危険なファイルローカル変数(*note File Local
Variables::を参照してください)であることを意味します。

   シンボルのプロパティーとプロパティー値はそれぞれ、、シンボルのプロパ
ティーリストセル(*note Symbol Components::を参照してください)に、プロパ
ティーリスト形式(*note Property Lists::を参照してください)で格納されます
。

* Menu:

* Symbol Plists::            シンボルプロパティーへのアクセス。
* Standard Properties::      シンボルプロパティーの標準的な意味。


File: elisp,  Node: Symbol Plists,  Next: Standard Properties,  Up: Symbol Properties

8.4.1 Accessing Symbol Properties
---------------------------------

以下の関数は、シンボルプロパティーへのアクセスに使用できます。

 -- Function: get symbol property
     この関数は、SYMBOLのプロパティーリスト内の、PROPERTYという名前のプ
     ロパティーの値をreturnします。そのようなプロパティーが存在しない場
     合は、‘nil’をreturnします。したがって、値が‘nil’のときと、プロパテ
     ィーが存在しない場合の違いはありません。

     名前PROPERTYは、‘eq’を使用して既存のプロパティーと比較されるので、
     任意のオブジェクトはプロパティーとして適正です。

     例は‘put’を参照してください。

 -- Function: put symbol property value
     この関数は、SYMBOLのプロパティーリストの、プロパティー名PROPERTYに
     VALUEを配して、以前のプロパティー値を置き換えます。‘put’関数は、
     VALUEをreturnします。

          (put 'fly 'verb 'transitive)
               ⇒'transitive
          (put 'fly 'noun '(a buzzing little bug))
               ⇒ (a buzzing little bug)
          (get 'fly 'verb)
               ⇒ transitive
          (symbol-plist 'fly)
               ⇒ (verb transitive noun (a buzzing little bug))

 -- Function: symbol-plist symbol
     この関数は、SYMBOLののののプロパティーリストをreturnします。

 -- Function: setplist symbol plist
     この関数は、SYMBOLのプロパティーリストを、PLISTにセットします。
     PLISTは通常、適正なプロパティーリストであるべきですが、これは強制で
     はありません。return値はPLISTです。

          (setplist 'foo '(a 1 b (2 3) c nil))
               ⇒ (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               ⇒ (a 1 b (2 3) c nil)

     通常の用途には使用されない、特別なobarray内のシンボルでは、非標準的
     で方法でプロパティーリストセルを使用することに意味があるかもしれま
     せん。実際に、abbrev(*note Abbrevs::を参照してください)のメカニズム
     は、これを行なっています。

     以下のように、‘setplist’と‘plist-put’により、‘put’を定義できます:

          (defun put (symbol prop value)
            (setplist symbol
                      (plist-put (symbol-plist symbol) prop value)))

 -- Function: function-get symbol property
     この関数は、‘get’と同じですが、SYMBOLが関数エイリアス(function
     alias)の場合は、実際の関数の名づけるシンボルのプロパティーリストを
     参照します。*note Defining Functions::を参照してください。


File: elisp,  Node: Standard Properties,  Prev: Symbol Plists,  Up: Symbol Properties

8.4.2 Standard Symbol Properties
--------------------------------

以下に、Emacsで特別な目的のために使用されるシンボルプロパティーをリスト
します。以下の表で、“名づけられた関数(the named function)”と言うときは、
関数名がそのシンボルである関数を意味します。“名づけられた変数(the named
variable)”などの場合も、同様です。

‘:advertised-binding’
     このプロパティーリストは、名づけられた関数のドキュメントを表示する
     ときの、優先されるキーバインディングを指定します。*note Keys in
     Documentation::を参照してください。

‘char-table-extra-slots’
     値が非‘nil’の場合は、名づけられた文字テーブル型の追加スロットの数を
     指定します。*note Char-Tables::を参照してください。

‘customized-face’
‘face-defface-spec’
‘saved-face’
‘theme-face’
     これらのプロパティーは、フェイスの標準のフェイススペック(face
     specs)、およびフォントスペックsaved-fase、customized-face、
     themed-faceを記録するために使用されます。これらのプロパティーを直接
     セットしないでください。これらのプロパティーは‘defface’、および関連
     する関数により管理されます。*note Defining Faces::を参照してくださ
     い。

‘customized-value’
‘saved-value’
‘standard-value’
‘theme-value’
     これらのプロパティーは、カスタマイズ可能な変数のstandard-value、
     saved-value、customized-value(しかし保存はされない)、themed-valueを
     記録するために使用されます。これらのプロパティーを直接セットしない
     でください。これらは‘defcustom’、および関連する関数により管理されま
     す。*note Variable Definitions::を参照してください。

‘disabled’
     値が非‘nil’の場合、名づけられた関数はコマンドとして無効になります。
     *note Disabling Commands::を参照してください。

‘face-documentation’
     値には、名づけられたフェイスのドキュメント文字列が格納されます。こ
     れは、‘defface’により自動的にセットされます。*note Defining
     Faces::を参照してください。

‘history-length’
     値が非‘nil’の場合、名づけられたヒストリーリスト変数の、ミニバッファ
     ーヒストリーの最大長を指定します。*note Minibuffer History::を参照
     してください。

‘interactive-form’
     この値は、名づけられた関数の、インタラクティブ形式です。通常、これ
     を直接セットするべきではありません。かわりに、スペシャルフォーム
     ‘interactive’を使用してください。*note Interactive Call::を参照して
     ください。

‘menu-enable’
     この値は、名づけられたメニューアイテムが、メニュー内で有効であるべ
     きかを決定するための式です。*note Simple Menu Items::を参照してくだ
     さい。

‘mode-class’
     値が‘special’の場合、名づけられたメジャーモードは“special(特別)”で
     す。*note Major Mode Conventions::を参照してください。

‘permanent-local’
     値が非‘nil’の場合、名づけられた変数はバッファーローカル変数となり、
     変数の値はメジャーモードの変更によりリセットされません。*note
     Creating Buffer-Local::を参照してください。

‘permanent-local-hook’
     値が非‘nil’の場合、名づけられた変数はメジャーモードを変更したとき、
     フック変数のローカル値から削除されません。*note Setting Hooks::を参
     照してください。

‘pure’
     値が非‘nil’の場合、名づけられた関数は、副作用の影響を受けないとみな
     されます。定数の引数で呼び出された場合、コンパイル時に評価すること
     ができます。これは、実行時のエラーをコンパイル時へとシフトします。

‘risky-local-variable’
     値が非‘nil’の場合、名づけられた変数は、ファイルローカル変数としては
     危険だとみなされます。*note File Local Variables::を参照してくださ
     い。

‘safe-function’
     値が非‘nil’の場合、名づけられた関数は、評価において一般的に安全だと
     みなされます。*note Function Safety::を参照してください。

‘safe-local-eval-function’
     値が非‘nil’の場合、名づけられた関数は、ファイルローカルの評価フォー
     ム内で、安全に呼び出すことができます。*note File Local Variables::を
     参照してください。

‘safe-local-variable’
     値は、名付けられた変数の、安全なファイルローカル値を決定する関数を
     指定します。*note File Local Variables::を参照してください。

‘side-effect-free’
     非‘nil’値は、関数の安全性(*note Function Safety::を参照してください
     )、およびバイトコンパイラーの最適化を決定するために、名づけられた関
     数が副作用から自由であることを示します。これをセットしないでくださ
     い。

‘variable-documentation’
     非‘nil’の場合、それは名づけられた変数のドキュメント文字列を指定しま
     す。ドキュメント文字列は、‘defvar’および関連する関数により、自動的
     にセットされます。*note Defining Faces::を参照してください。


File: elisp,  Node: Evaluation,  Next: Control Structures,  Prev: Symbols,  Up: Top

9 Evaluation
************

Emacs Lispでの式の“評価(evaluation)”は、“Lispインタープリター” — 入力と
してLispオブジェクトを受け取り、それの“式としての値(value as an
expression)”を計算します — により処理されます。評価を行なう方法は、その
オブジェクトのデータ型に依存し、それはこのチャプターで説明するルールによ
り行なわれます。インタープリターは、プログラムの一部を評価するために自動
的に実行されますが、Lisp基本関数の‘eval’を通じて、明示的に呼び出すことも
できます。

* Menu:

* Intro Eval::               事の在り方における評価。
* Forms::                    さまざまなオブジェクト類が評価される方法。
* Quoting::                  (プログラム内に定数を配すための)評価の回避。
* Backquote::                リスト構造の、より簡単な構築。
* Eval::                     Lispインタープリターを明示的に呼び出す方法。


File: elisp,  Node: Intro Eval,  Next: Forms,  Up: Evaluation

9.1 Introduction to Evaluation
==============================

Lispインタープリター(またはLispエバリュエーター)は、Emacsの一部で、与え
られた式の値を計算します。Lispで記述された関数が呼び出されるとき、エバリ
ュエーターはその関数のbody(本文)の中の式を評価することにより、その関数の
値を計算します。したがって、Lispプログラムを実行するとは、実際にはLispイ
ンタープリターを実行することを意味します。

   評価されることを意図したLispオブジェクトは、“フォーム(form)”、または
“式(expression)”と呼ばれます(1)。フォームはデータオブジェクトであり、単
なるテキストではないというのは、Lisp風の言語と、通常のプログラミング言語
との間にある、基本的な相違の1つです。任意のオブジェクトを評価できますが
、実際に評価される事が非常に多いのは数字、シンボル、リスト、文字列です。

   以降のセクションでは、各種フォームにたいして、それを評価することが何
を意味するかの詳細を説明します。

   Lispフォームを読み取り、それからそのフォームを評価するのは、非常に一
般的なアクティビティーですが、読み取りと評価は別のアクティビティーであり
、どちらか一方を単独で処理することができます。読み取りだけでは、何も評価
されません。読み取りはLispオブジェクトのプリント表現を、そのオブジェクト
自体に変換します。このオブジェクトは評価されるべきフォームなのか、そのれ
ともまったく違う目的をもつかを指定するのは、‘read’の呼び出し元の役目です
*note Input Functions::を参照してください。

   評価とは再帰的な処理であり、あるフォームを評価することにより、そのフ
ォームの一部が評価されるといったことがよくあります。たとえば、‘(car x)’の
ような“関数呼び出し(function call)”のフォームを評価する場合、Emacsは最初
にその引数(サブフォーム‘x’)を評価します。引数を評価した後、Emacsはその関
数(‘car’)を“実行(executes)”します。その関数がLispで記述されている場合は
、関数の“body(本文)”を評価することにより、実行が行なわれます(しかし、こ
の例で使用している‘car’はLisp関数ではなく、Cで実装された基本関数です)。
関数と関数呼び出しについての情報は、*note Functions::を参照してください
。

   評価は、“環境(environment)”と呼ばれるコンテキストの内部で行なわれます
。環境は、すべてのLisp変数(*note Variables::を参照してください)のカレン
ト値とバインディングにより構成されます。(2)フォームが新たなバインディン
グを作成することなく、変数を参照するとき、その変数はカレントの環境により
与えられる値に評価されます。フォームの評価は、変数のバインディングにより
、一時的にその環境を変更することもあります(*note Local Variables::を参照
してください)。

   フォームの評価が、永続する変更を行なうこともあります。これらの変更は
、“副作用(side effects)”と呼ばれます。副作用を生成するフォームの例は、
‘(setq foo 1)’です。

   コマンドキー解釈にたいする評価と混同しないでください。エディターのコ
マンドループは、アクティブなキーマップを使用して、キーボード入力をコマン
ド(インタラクティブに呼び出すことができる関数)に変換してから、そのコマン
ドを実行するために‘call-interactively’を使用します。そのコマンドはLispで
記述されている場合、コマンドの実行は通常、評価を伴います。しかし、このス
テップはコマンドキー解釈の一部とは考えません。*note Command Loop::を参照
してください。

   ---------- Footnotes ----------

   (1) “S式(S-expression)”、短くは“sexp”という言葉でも呼ばれることがあり
ますが、わたしたちは通常、このマニュアル内ではこの用語は使用しません。

   (2) “環境”にたいするこの定義は、プログラムの結果に影響し得るすべての
データを特に意図するものではありません。


File: elisp,  Node: Forms,  Next: Quoting,  Prev: Intro Eval,  Up: Evaluation

9.2 Kinds of Forms
==================

評価される事を意図したLispオブジェクトは、“フォーム(form)”または“式
(expression)”)と呼ばれます。Emacsがフォームを評価する方法は、フォームの
データ型に依存します。Emacsは、3種の異なるフォーム — シンボル、リスト、
および“その他すべての型” — を持ち、それらは評価される方法は異なります。
このセクションでは、まず最初は自己評価フォームの“その他すべての型”から開
始して、3つの種類をすべて1つずつ説明します。

* Menu:

* Self-Evaluating Forms::    自分自身を評価するフォーム。
* Symbol Forms::             変数として評価されるシンボル。
* Classifying Lists::        さまざまな種類のリストフォームを区別する方法。
* Function Indirection::     シンボルがリストのcarにある場合、そのシンボルを通じて実際の関数を見つけます。
* Function Forms::           関数を呼び出すフォーム。
* Macro Forms::              マクロを呼び出すフォーム。
* Special Forms::            "スペシャルフォーム"は特有な基本のフォームで、それらのほとんどがとても重要です。
* Autoloading::              実際の定義を含むファイルのロードをセットアップする関数。


File: elisp,  Node: Self-Evaluating Forms,  Next: Symbol Forms,  Up: Forms

9.2.1 Self-Evaluating Forms
---------------------------

“自己評価フォーム(self-evaluating form)”は、リストやシンボルではない、任
意のフォームです。自己評価フォームは、フォーム自身を評価します。評価の結
果は、評価されたのと同じオブジェクトです。したがって、数字の25は25に評価
され、文字列‘"foo"’は文字列‘"foo"’に評価されます。同様に、ベクターの評価
では、ベクターの要素の評価は起こりません — 内容が変更されずに同じベクタ
ーがreturnされます。

     '123               ; 評価されずに表示される数字。
          ⇒ 123
     123                ; 通常どおり評価され、同じものがreturnされる。
          ⇒ 123
     (eval '123)        ; “手動”による評価 — 同じものがreturnされる。
          ⇒ 123
     (eval (eval '123)) ; 2度評価しても何も変わらない。
          ⇒ 123

   事項評価されるという事実による利点から、数字、文字、文字列、そしてベ
クターでさえ、Lispコード内で記述されるのは一般的です。しかし、入力構文が
ない型にたいしてこれを行なうのは極めて異例です。なぜなら、これらをテキス
ト的に記述する方法がないからです。Lispプログラムを使用して、これらの型を
含むLisp式を構築するのは、可能です。以下は例です:

     ;; バッファーオブジェクトを含む式を構築する。
     (setq print-exp (list 'print (current-buffer)))
          ⇒ (print #<buffer eval.texi>)
     ;; それを評価する。
     (eval print-exp)
          ⊣ #<buffer eval.texi>
          ⇒ #<buffer eval.texi>


File: elisp,  Node: Symbol Forms,  Next: Classifying Lists,  Prev: Self-Evaluating Forms,  Up: Forms

9.2.2 Symbol Forms
------------------

シンボルが評価されるときは、変数として扱われます。それが値をもつ場合、結
果はその変数の値になります。そのシンボルが変数としての値をもたない場合、
Lispインタープリターはエラーをシグナルします。変数の使用法についての情報
は、*note Variables::を参照してください。

   以降の例では、‘setq’でシンボルに値をセットしています。その後シンボル
を評価してから、その値を‘setq’に戻します。

     (setq a 123)
          ⇒ 123
     (eval 'a)
          ⇒ 123
     a
          ⇒ 123

   シンボル‘nil’と‘t’は特別に扱われるので、‘nil’の値は常に‘nil’になり、
‘t’の値は常に‘t’になります。これらに他の値をセットしたり、他の値にバイン
ドすることはできません。したがって、この2つのシンボルは、(たとえ‘eval’が
それらを他の任意のシンボルと同じように扱うとはいえ)自己評価フォームと同
じように振る舞います。名前が‘:’で始まるシンボルも、同じ方法で自己評価さ
れます。そして、(通常は)値を変更できない点も同じです。*note Constant
Variables::を参照してください。


File: elisp,  Node: Classifying Lists,  Next: Function Indirection,  Prev: Symbol Forms,  Up: Forms

9.2.3 Classification of List Forms
----------------------------------

空ではないリストフォームは、関数呼び出し、マクロ呼び出し、スペシャルフォ
ームのいずれかで、それは1番目の引数にしたがいます。これら3種のフォームは
、以下で説明するように、異なる方法で評価されます。残りの要素は関数、マク
ロ、またはスペシャルフォームにたいする“引数(arguments)”を構成します。

   空ではないリストを評価する最初のステップは、1番目の要素の確認です。こ
の要素は単独で、そのリストがどの種類のフォームか、そして残りの引数をどの
ように処理するがを決定します。SchemeのようなLisp方言とは異なり、1番目の
要素は評価されません。


File: elisp,  Node: Function Indirection,  Next: Function Forms,  Prev: Classifying Lists,  Up: Forms

9.2.4 Symbol Function Indirection
---------------------------------

リストの最初の要素がシンボルの場合、評価はそのシンボルの関数セルを調べて
、元のシンボルの代わりに、関数セルの内容を使用します。その内容が他のシン
ボルの場合、シンボルではないものが得られるまで、このプロセスが繰り返され
ます。このプロセスを“シンボル関数インダイレクション(symbol function
indirection: indirectionは間接の意)”と呼びます。シンボル関数インダイレク
ションについての情報は、*note Function Names::を参照してください。

   このプロセスの結果、シンボルの関数競るが同じシンボルを参照する場合、
無限ループを起こす可能性があります。それ以外は、最終的には非シンボルにた
どりつき、これは関数か、他の適切なオブジェクトであるはずです。

   より正確に言うと、それはLisp関数(ラムダ式)、バイトコード関数、基本関
数、Lispマクロ、スペシャルフォーム、またはオートロードオブジェクトである
べきです。これらの型のそれぞれについては、以降のセクションで説明します。
これらの型以外のオブジェクトの場合、emacsは‘invalid-function’エラーをシ
グナルします。

   以下の例は、シンボルインダイレクションのプロセスを説明するものです。
わたしたちは、シンボルの関数セルに関数をセットするのに‘fset’、関数セルの
内容(*note Function Cells::を参照してください)を得るために
‘symbol-function’を使用します。具体的に言うと、‘first’の関数セルにシンボ
ル‘car’を格納し、シンボル‘first’を‘erste’の関数セルに格納します。

     ;; この関数セルのリンクを構築する:
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------
     (symbol-function 'car)
          ⇒ #<subr car>
     (fset 'first 'car)
          ⇒ car
     (fset 'erste 'first)
          ⇒ first
     (erste '(1 2 3))   ; ‘erste’により参照される関数を呼び出す。
          ⇒ 1

   対照的に、以下の例はシンボル関数インダイレクションを使用せずに関数を
呼び出します。なぜなら、1番目の要素はシンボルではなく、無名Lisp関数
(anonymous Lisp function)だからです。

     ((lambda (arg) (erste arg))
      '(1 2 3))
          ⇒ 1

関数自身を実行すると、その関数のbodyを評価します。これは、‘erste’を呼び
出すとき、シンボル関数インダイレクションが行なわれます。

   このフォームが使用されるのは稀で、今では推奨されません。かわりに以下
のように記述するべきです:

     (funcall (lambda (arg) (erste arg))
              '(1 2 3))
   または単に
     (let ((arg '(1 2 3))) (erste arg))

   ビルトイン関数の‘indirect-function’は、明示的にシンボル関数インダイレ
クションを処理するための、簡単な方法を提供します。

 -- Function: indirect-function function &optional noerror
     この関数は、FUNCTIONが意味するものを、関数としてreturnします。
     FUNCTIONがシンボルの場合は、FUNCTIONの関数定義を探して、その値で最
     初からやり直します。FUNCTIONがシンボルでない場合は、FUNCTION自身を
     returnします。

     この関数は、最後のシンボルがバインドされておらず、オプション引数
     NOERRORが省略されているか‘nil’の場合は、‘void-function’エラーをシグ
     ナルします。それ以外は、NOERRORが非‘nil’の場合は、最後のシンボルが
     バインドされていなければ‘nil’をreturnします。

     特定のシンボル内にループがある場合、この関数は
     ‘cyclic-function-indirection’エラーをシグナルします。

     以下は、Lispで‘indirect-function’を定義できるという例です:

          (defun indirect-function (function)
            (if (symbolp function)
                (indirect-function (symbol-function function))
              function))


File: elisp,  Node: Function Forms,  Next: Macro Forms,  Prev: Function Indirection,  Up: Forms

9.2.5 Evaluation of Function Forms
----------------------------------

リストの1番目の要素がLispの関数オブジェクト。バイトコードオブジェクト、
基本関数オブジェクトと評価された場合、そのリストは“関数呼び出し(function
call)”になります。たとえば、以下は関数‘+’を呼び出します:

     (+ 1 x)

   関数呼び出しを評価する最初のステップは、そのリストの残りの要素を左か
ら右に評価します。結果は引数の実際の値で、リストの各要素にたいして1つの
値となります。次のステップは、関数‘apply’(*note Calling Functions::を参
照してください)を使用して、引数のリストでその関数を呼び出します。関数が
Lispで記述されている場合、引数はその関数の引数変数にバインドするために使
用されます。その後、関数body内のフォームが順番に評価され、listのbodyフォ
ームの値は、関数呼び出しの値になります。


File: elisp,  Node: Macro Forms,  Next: Special Forms,  Prev: Function Forms,  Up: Forms

9.2.6 Lisp Macro Evaluation
---------------------------

リストの最初の要素がマクロオブジェクトと評価された場合、そのリストは“マ
クロ呼び出し(macro call)”になります。マクロ呼び出しが評価されるとき、リ
ストの残りの要素は、最初は評価され_ません_。そのかわり、これらの要素自体
が、マクロの引数に使用されます。そのマクロ定義は、これは元のフォームの場
所で評価される、置き換えのフォームを計算します。これは、マクロの“展開
(expansion)”と呼ばれます。展開した結果は、任意の種類のフォーム — 自己評
価定数、シンボル、リストになります。展開した結果自体がマクロ呼び出しの場
合、結果が他の種類のフォームになるまで、繰り返し展開処理が行なわれます。

   通常のマクロ展開は、その展開形を評価することにより終了します。しかし
、他のプログラムもマクロ呼び出しを展開し、それらが展開形を評価するかもし
れないし、評価しないかもしれないので、そのマクロ展開がすぐに、または最終
的に評価される必要がない場合があります。

   引き数式は通常、マクロ展開の計算の一部としては評価されませんが、展開
の部分として現れるので、展開形が評価されるとき計算されます。

   たとえば、以下のようなマクロ定義が与えられたとします:

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

‘(cadr (assq 'handler list))’のような式はマクロ呼び出しであり、展開形は
以下のようになります:

     (car (cdr (assq 'handler list)))

引数‘(assq 'handler list)’が、展開形に含まれることに注意してください。

   Emacs Lispマクロの完全な説明は、*note Macros::を参照してください。


File: elisp,  Node: Special Forms,  Next: Autoloading,  Prev: Macro Forms,  Up: Forms

9.2.7 Special Forms
-------------------

“スペシャルフォーム(special form)”は特別だとマークされた基本関数で、その
引数のすべては評価されません。もっともスペシャルなフォームは、制御構造の
定義や、変数バインディングの処理など、関数ではできないことを行ないます。

   スペシャルフォームはそれぞれ、どの引数が評価されて、どの引数が評価さ
れないかについて、独自のルールをもちます。特定の引数が評価されるかどうか
は、他の引数を評価した結果に依存します。

   式の最初のシンボルがスペシャルフォームの場合、その式はそのスペシャル
フォームのルールにしたがう必要があります。それ以外では、Emacsの挙動は(た
とえクラッシュしなくても)定義されていません。たとえば‘((lambda (x) x .
3) 4)’は、‘lambda’で始まるサブ式を含みますが、これは適正な‘lambda’式では
ないので、Emacsはエラーをシグナルするか、3、または4、または‘nil’、もしか
したら他の挙動を示すかもしれません。

 -- Function: special-form-p object
     この述語は、引数がスペシャルフォームかをテストし、スペシャルフォー
     ムなら‘t’、それ以外は‘nil’をreturnします。

   以下に、Emacs Lispのスペシャルフォームすべてと、それらがどこで説明さ
れているかのリファレンスとともに、アルファベット順でリストします。

‘and’
     *note Combining Conditions::

‘catch’
     *note Catch and Throw::

‘cond’
     *note Conditionals::

‘condition-case’
     *note Handling Errors::

‘defconst’
     *note Defining Variables::

‘defvar’
     *note Defining Variables::

‘function’
     *note Anonymous Functions::

‘if’
     *note Conditionals::

‘interactive’
     *note Interactive Call::

‘lambda’
     *note Lambda Expressions::

‘let’
‘let*’
     *note Local Variables::

‘or’
     *note Combining Conditions::

‘prog1’
‘prog2’
‘progn’
     *note Sequencing::

‘quote’
     *note Quoting::

‘save-current-buffer’
     *note Current Buffer::

‘save-excursion’
     *note Excursions::

‘save-restriction’
     *note Narrowing::

‘setq’
     *note Setting Variables::

‘setq-default’
     *note Creating Buffer-Local::

‘track-mouse’
     *note Mouse Tracking::

‘unwind-protect’
     *note Nonlocal Exits::

‘while’
     *note Iteration::

     Common Lispに関する注意: ここで、GNU Emacsのスペシャルフォームと、
     Common Lispのスペシャルフォームを比較してみます。‘setq’、‘if’、
     ‘catch’は、Emacs LispとCommon Lispの両方でスペシャルフォームです。
     ‘save-excursion’はEmacs Lispではスペシャルフォームですが、Common
     Lispには存在しません。‘throw’はCommon Lispではスペシャルフォーム(な
     ぜなら複数の値をthrowできなければならない)ですが、Emacs Lispでは(複
     数の値をもたない)関数です。


File: elisp,  Node: Autoloading,  Prev: Special Forms,  Up: Forms

9.2.8 Autoloading
-----------------

“オートロード(autoload)”機能により、関数定義がだEmacsにロードされていな
い関数(またはマクロ)を呼び出すことができます。オートロードは、定義がどの
ファイルに含まれるかを指定します。オートロードオブジェクトがシンボルの関
数定義にある場合、関数としてそのシンボルを呼び出すことにより、自動的に指
定されたファイルがロードされます。その後、ファイルからロードされた実際の
定義を呼び出します。シンボル内の関数定義としてオートロードオブジェクトを
アレンジする方法は、*note Autoload::で説明します。


File: elisp,  Node: Quoting,  Next: Backquote,  Prev: Forms,  Up: Evaluation

9.3 Quoting
===========

スペシャルフォーム‘quote’は、単一の引数を、記述されたとおり、評価せずに
returnします。これはプログラムに、自己評価オブジェクトではない、定数シン
ボルや定数リストを含める方法を提供します(数字、文字列、ベクターのような
自己評価オブジェクトをクォートする必要はありません)。

 -- Special Form: quote object
     このスペシャルフォームは、評価せずにOBJECTをreturnします。

   プログラム中で‘quote’はよく使用されるので、Lispはそれにたいする便利な
入力構文を提供します。アポストロフィー文字(‘'’)に続けてLispオブジェクト
(の入力構文)を記述すると、それは1番目の要素が‘quote’で、2番目の要素がそ
のオブジェクトであるリストに展開されます。したがって、入力構文‘'x’は、
‘(quote x)’の略記になります。

   以下に、‘quote’を使用した式の例をいくつか示します:

     (quote (+ 1 2))
          ⇒ (+ 1 2)
     (quote foo)
          ⇒ foo
     'foo
          ⇒ foo
     ''foo
          ⇒ (quote foo)
     '(quote foo)
          ⇒ (quote foo)
     ['foo]
          ⇒ [(quote foo)]

   他のクォート構成には、コンパイル用にLispで記述された無名のラムダ式の
元になる‘function’(*note Anonymous Functions::を参照してください)、およ
び、リストを計算して置き換える際に、リストの一部だけをクォートするのに使
用される‘`’(*note Backquote::を参照してください)があります。


File: elisp,  Node: Backquote,  Next: Eval,  Prev: Quoting,  Up: Evaluation

9.4 Backquote
=============

“バッククォート構成(backquote constructs)”を使用することにより、リストを
クォートして、そのリストのある要素を選択的に評価することができます。もっ
とも簡単な使い方では、スペシャルフォーム‘quote’と同じです (前のセクショ
ンで説明しています。*note Quoting::を参照してください)。 たとえば、以下
の2つのフォームは同じ結果を生みます:

     `(a list of (+ 2 3) elements)
          ⇒ (a list of (+ 2 3) elements)
     '(a list of (+ 2 3) elements)
          ⇒ (a list of (+ 2 3) elements)

   バッククォートする引数の内側でスペシャルマーカー‘,’を使用すると、それ
は値が定数でないことを示します。Emacs Lispエバリュエーターは‘,’がついた
引数を放火して、リスト構造内にその値を配します:

     `(a list of ,(+ 2 3) elements)
          ⇒ (a list of 5 elements)

‘,’による置き換え、リスト構造のより深いレベルでも使用できます。たとえば:

     `(1 2 (3 ,(+ 4 5)))
          ⇒ (1 2 (3 9))

   スペシャルマーカー‘,@’を使用すれば、評価された値を結果リストに“継ぎ足
す(splice)”こともできます。継ぎ足されたリストの要素は、結果リスト内の他
の要素を同じレベルになります。‘`’を使用しない等価なコードは、しばしば読
むのが困難です。以下にいくつかの例を示します:

     (setq some-list '(2 3))
          ⇒ (2 3)
     (cons 1 (append some-list '(4) some-list))
          ⇒ (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
          ⇒ (1 2 3 4 2 3)

     (setq list '(hack foo bar))
          ⇒ (hack foo bar)
     (cons 'use
       (cons 'the
         (cons 'words (append (cdr list) '(as elements)))))
          ⇒ (use the words foo bar as elements)
     `(use the words ,@(cdr list) as elements)
          ⇒ (use the words foo bar as elements)


File: elisp,  Node: Eval,  Prev: Backquote,  Up: Evaluation

9.5 Eval
========

ほとんどの場合、実行されるプログラム内に出現することにより、フォームは自
動的に評価されます。稀に、実行時 — たとえば編集されているテキストや、プ
ロパティーリストから取得したフォームを読み取った後 — に計算されるように
、フォームを評価するコードを記述する必要があるかもしれません。このような
ときは、‘eval’関数を使用します。‘eval’が不必要だったり、かわりに他の何か
を使用すべきときが、しばしばあります。たとえば、変数から値を取得するには
、‘eval’も機能しますが、‘symbol-value’のほうが適しています。‘eval’で評価
するためにプロパティーリストに式を格納するより、かわりに‘funcall’に渡す
ように関数を格納した方がよいでしょう。

   このセクションで説明する関数と変数は、フォームの評価、評価処理の制限
の指定、最後にreturnされた値の記録を行なうものです。ファイルのロードでも
評価が行なわれます(*note Loading::を参照してください)。

   データ構造に式を格納してそれを評価するより、データ構造に関数を格納し
て、それを‘funcall’や‘apply’で呼び出すほうが、より明解かつ柔軟です。関数
を使用することにより、引数に情報を渡す能力が提供されます。

 -- Function: eval form &optional lexical
     これは、式を評価する、基本的な関数です。この関数は、カレント環境内
     でFORMを評価して、その結果をreturnします。FORMオブジェクトの型は、
     それが評価される方法を決定します。*note Forms::を参照してください。

     引数LEXICALは、ローカル変数にたいするスコープ規則(*note Variable
     Scoping::を参照してください)を指定します。これが省略されるか‘nil’の
     場合、デフォルトのダイナミックスコープ規則を使用してFORMを評価する
     ことを意味します。‘t’の場合は、レキシカルスコープ規則が使用されるこ
     とを意味します。LEXICALの値には、レキシカルバインディングにたいする
     特定の“レキシカル環境(lexical environment)”を指定する、空ではない
     alistも指定できます。しかし、この機能はEmacs Lispデバッガーのような
     、特別な目的にたいしてのみ有用です。*note Lexical Binding::を参照し
     てください。

     ‘eval’は関数なので、‘eval’呼び出しに現れる引数式は2回 — 1度は
     ‘eval’が呼び出される前の準備、そして‘eval’関数自身によりもう1度 — 評
     価されます。以下は例です:

          (setq foo 'bar)
               ⇒ bar
          (setq bar 'baz)
               ⇒ baz
          ;; ‘eval’が引数‘foo’を受け取る。
          (eval 'foo)
               ⇒ bar
          ;; ‘eval’が、‘foo’の値である、引数‘bar’を受け取る。
          (eval foo)
               ⇒ baz

     ‘eval’により現在アクティブな呼び出しの数は、‘max-lisp-eval-depth’に
     制限されます(以下参照)。

 -- Command: eval-region start end &optional stream read-function
     この関数は、カレントバッファー内の、位置STARTとENDで定義されるリー
     ジョン内のフォームを評価します。この関数はそのリージョンからフォー
     ムを読み取り、それらにたいし‘eval’を呼び出します。これは、リージョ
     ンの最後に達するまで、または処理されないエラーがシグナルされるまで
     行なわれます。

     デフォルトでは、‘eval-region’は何の出力も生成しません。しかし、
     STREAMが非‘nil’の場合、出力関数(*note Output Functions::を参照して
     ください)で生成された任意の出力、同様にリージョン内の式を評価した結
     果の値は、STREAMを使用してプリントされます。*note Output Streams::を
     参照してください。

     READ-FUNCTIONが非‘nil’の場合、‘read’のかわりに1つずつ式を読み取るた
     めに使用する関数を指定します。これは、入力を読み取るストリームを指
     定する、1つの引数で呼び出される関数です。この関数を指定するために変
     数‘load-read-function’(*note How Programs Do Loading: Definition of
     load-read-function.を参照してください)も使用できますが、引数
     READ-FUNCTIONを使用するほうが確実です。

     ‘eval-region’はポイントを移動しません。つねに‘nil’をreturnします。

 -- Command: eval-buffer &optional buffer-or-name stream filename
          unibyte print
     この関数は‘eval-region’と似ていますが、引数は異なるオプション機能を
     提供します。‘eval-buffer’は、バッファーBUFFER-OR-NAMEのアクセス可能
     な部分全体を処理します。BUFFER-OR-NAMEにはバッファー名(文字列)を指
     定でき、‘nil’(または省略)のときはカレントバッファーを意味します。
     STREAMが‘nil’かつPRINTが非‘nil’でない場合、‘eval-region’のように
     STREAMが使用されます。この場合、式の評価による結果の値は依然として
     破棄されますが、出力関数による出力はエコーエリアにプリントされます
     。FILENAMEは、‘load-history’(*note Unloading::を参照してください)に
     使用されるファイル名で、デフォルトは‘buffer-file-name’(*note Buffer
     File Name::を参照してください)です。UNIBYTEが非‘nil’の場合、可能な
     限り‘read’は文字列をユニコードに変換します。

     ‘eval-current-buffer’は、このコマンドのエイリアスです。

 -- User Option: max-lisp-eval-depth
     この変数は、エラー(エラーメッセージは‘"Lisp nesting exceeds
     max-lisp-eval-depth"’)がシグナルされる前に、‘eval’、‘apply’、
     ‘funcall’の呼び出しで許される最大の深さを定義します。

     制限を超えたときのエラーをもつこの制限は、Emacs Lispで誤って定義さ
     れた関数による無限再帰を避ける方法の1つです。
     ‘max-lisp-eval-depth’の値を過大に増加させた場合、そのようなコードは
     かわりにスタックオーバーフローを起こすでしょう。

     たとえば、Lisp式に記述された関数の呼び出し、関数呼び出しの引数と、
     関数bodyフォームにたいする再帰評価、Lispコード内での明示的な呼び出
     しなどにたいして、深さ制限を数えるために、内部的に‘eval’、‘apply’、
     ‘funcall’を使用します。

     この変数のデフォルト値は400です。この値を100未満にセットした場合、
     値が与えられた値に達すると、Lispはそれを100にリセットします。空きが
     少ない場合、デバッガー自身を実行するために空きが必要になるので、
     Lispデバッガーに入ったときは、この値が増加されます。

     ‘max-specpdl-size’はネストの他の制限を提供します。*note Local
     Variables: Definition of max-specpdl-size.を参照してください。

 -- Variable: values
     この変数の値は、読み取り、評価、プリントを行なった標準的なEmacsコマ
     ンドにより、バッファー(ミニバッファーを含む)からreturnされる値のリ
     ストです(これには‘*ielm*’バッファーでの評価や、
     ‘lisp-interaction-mode’での‘C-j’を使用した評価は含まれ_ない_ことに
     注意してください)。要素の順番は、もっとも最近のものが最初になります
     。

          (setq x 1)
               ⇒ 1
          (list 'A (1+ 2) auto-save-default)
               ⇒ (A 3 t)
          values
               ⇒ ((A 3 t) 1 ...)

     この変数は、最近評価されたフォームの値を後で参照するのに便利です。
     ‘values’自体の値をプリントするのは、それがおそらく非常に長くなるの
     で、通常は悪いアイデアです。かわりに、以下のように特定の要素を調べ
     ます:

          ;; もっとも最近評価された結果を参照する。
          (nth 0 values)
               ⇒ (A 3 t)
          ;; これは新たな要素をputするので、
          ;;   すべての要素が1つ後に移動する。
          (nth 1 values)
               ⇒ (A 3 t)
          ;; これは次に新しい、この例の前の次に新しい要素を取得する。
          (nth 3 values)
               ⇒ 1


File: elisp,  Node: Control Structures,  Next: Variables,  Prev: Evaluation,  Up: Top

10 Control Structures
*********************

Lispプログラムは、一連の“式(expressions)”、あるいは“フォーム
(forms)”(*note Forms::を参照してください)により形成されます。これらのフ
ォームの実行順は、それらを“制御構造(control structures)”で囲むことにより
制御します。制御構造とは、その制御構造が含むフォームをいつ、どのような条
件で、何回実行するかを制御する、スペシャルフォームです。

   もっとも単純な実行順は、1番目はA、2番目はB、...という、シーケンシャル
実行(sequential execution: 順番に実行)です。これは、関数のbody内の連続す
る複数のフォームや、Lispコードのファイル内のトップレベルを記述したときに
発生します — つまり、フォームは記述した順に実行されます。わたしたちはこ
れを“テキスト順(textual order)”と呼びます。たとえば、関数のbodyが2つのフ
ォームAとBから構成される場合、関数の評価は、最初にAを評価し、次にBを評価
します。Bを評価した結果が、その関数の値となります。

   明示的に制御構造を使用することにより、シーケンシャルではない順番での
実行が可能になります。

   Emacs Lispは、他の様々な順序づけ、条件、繰り返し、(制御された)ジャン
プを含む、複数の種類の制御構造を提供し、以下ではそれらすべてを記述します
。ビルトインの制御構造は、制御構造のサブフォームが評価される必要がなかっ
たり、順番に評価される必要がないので、スペシャルフォームです。独自の制御
構造を構築するためにマクロを使用することができます(*note Macros::を参照
してください)。

* Menu:

* Sequencing::               テキスト順の評価。
* Conditionals::             ‘if’、‘cond’、‘when’、‘unless’。
* Combining Conditions::     ‘and’、‘or’、‘not’。
* Iteration::                ‘while’ループ。
* Nonlocal Exits::           シーケンスの外へジャンプ。


File: elisp,  Node: Sequencing,  Next: Conditionals,  Up: Control Structures

10.1 Sequencing
===============

フォームが出現する順番に評価するのは、あるフォームから別のフォームに制御
を渡す、もっとも一般的な制御です。関数のbodyのような、あるコンテキストに
おいては、自動的にこれが行なわれます。他の場所では、これを行なうために制
御構造を使用しなければなりません。Lispで一単純な制御構造は、‘progn’です
。

   スペシャルフォーム‘progn’は、以下のようなものです:

     (progn A B C ...)

これは、順番にA、B、C、...を実行するよう指定します。これらは‘progn’フォ
ームの“body”と呼ばれます。body内の最後のフォームの値が、‘progn’全体の値
になります。‘(progn)’は‘nil’をreturnします。

   初期のLispでは、‘progn’は、連続で複数のフォームを実行して最後のフォー
ムの値を使用する、唯一の方法でした。しかしプログラマーは、関数のbodyの、
(その時点では)1つのフォームだけが許される場所で、‘progn’を使用する必要が
多いことに気づきました。そのため、関数のbodyを“暗黙の‘progn’”にして、
‘progn’のbodyのように複数のフォームを記述出きるようにしました。他の多く
の制御構造も、同様に暗黙の‘progn’を含みます。結果として、昔ほど‘progn’は
多用されなくなりました。現在では、‘progn’が必要になるのは、
‘unwind-protect’、‘and’、‘or’、‘if’のTHENパートの中がほとんどです。

 -- Special Form: progn forms...
     このスペシャルフォームは、FORMSのすべてをテキスト順に評価して、のフ
     ォームの結果をreturnします。

          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The third form"

   他の2つの構成は、一連のフォームを同様に評価しますが、異なる値を
returnします:

 -- Special Form: prog1 form1 forms...
     このスペシャルフォームは、FORM1とFORMSのすべてをテキスト順に評価し
     て、FORM1の結果をreturnします。

          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The first form"

     以下の例は、変数‘x’のリストから1番目の要素を削除して、削除した1番目
     の要素の値をreturnします:

          (prog1 (car x) (setq x (cdr x)))

 -- Special Form: prog2 form1 form2 forms...
     このスペシャルフォームは、FORM1、FORM2、その後のFORMSのすべてをテキ
     スト順で評価して、FORM2の結果をreturnします。

          (prog2 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               ⊣ "The first form"
               ⊣ "The second form"
               ⊣ "The third form"
          ⇒ "The second form"


File: elisp,  Node: Conditionals,  Next: Combining Conditions,  Prev: Sequencing,  Up: Control Structures

10.2 Conditionals
=================

条件による制御構造は、候補の中から選択を行ないます。Emacs Lispは4つの条
件フォームをもちます。‘if’は他の言語のものとほとんど同じです。‘when’と
‘unless’は、‘if’の変種です。‘cond’は一般化されたcase命令です。

 -- Special Form: if condition then-form else-forms...
     ‘if’は、CONDITIONの値にもとづいて、THEN-FORMとELSE-FORMSを選択しま
     す。評価されたCONDITIONが非‘nil’の場合は、THEN-FORMが評価されて、そ
     の結果がreturnされます。それ以外は、ELSE-FORMSがテキスト順に評価さ
     れて、最後のフォームの値がreturnされます(‘if’のELSEパートは、暗黙の
     ‘progn’の例です。*note Sequencing::を参照してください)。

     CONDITIONの値が‘nil’で、ELSE-FORMSが与えられない場合、‘if’は‘nil’を
     returnします。

     選択されなかったブランチは決して評価されない — 無視される — ので、
     ‘if’はスペシャルフォームです。したがって、以下の例では‘print’は呼び
     出されることはないので、‘true’はプリントされません。

          (if nil
              (print 'true)
            'very-false)
          ⇒ very-false

 -- Macro: when condition then-forms...
     これは、ELSE-FORMSがなく、複数のTHEN-FORMSがあるかもしれない、
     ‘if’の変種です。特に、

          (when CONDITION A B C)

     は以下と完全に等価です

          (if CONDITION (progn A B C) nil)

 -- Macro: unless condition forms...
     これはTHEN-FORMがない、‘if’の変種です:

          (unless CONDITION A B C)

     は以下と完全に等価です

          (if CONDITION nil
             A B C)

 -- Special Form: cond clause...
     ‘cond’は、任意の数の候補から選択を行ないます。‘cond’内の各CLAUSEは
     、リストでなければなりません。このリストのCARはCONDITIONで、(もしあ
     れば)残りの要素はBODY-FORMSです。したがって、条項は以下のようになり
     ます:

          (CONDITION BODY-FORMS...)

     ‘cond’は、各条項のCONDITIONを評価することにより、テキスト順で条項を
     試験します。CONDITIONの値が非‘nil’の場合、その条項は“成り立ち”ます
     。その後、‘cond’は、その条項のBODY-FORMSを評価して、BODY-FORMSの最
     後の値をreturnします。残りの条項は無視されます。

     CONDITIONの値が‘nil’の場合、その条項は“成り立たず”、‘cond’は次の条
     項に移動して、その条項のCONDITIONを試験します。

     以下のようなものも、条項になります:

          (CONDITION)

     CONDITIONがテストされたときに非‘nil’なら、‘cond’フォームは
     CONDITIONの値をreturnします。

     すべてのCONDITIONが‘nil’に評価された場合 — つまりすべての条項が不成
     立の場合、‘cond’は‘nil’をreturnします。

     以下の例は4つの条項をもち、‘x’の値が数字か、文字列化、バッファーか
     、シンボルかをテストします:

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; 1つの条項に
                 (buffer-name x))        ; 複数bodyフォーム。
                ((symbolp x) (symbol-value x)))

     前の条項が不成立のとき、最後の条項を実行したいときがよくあります。
     これを行なうには、‘(t BODY-FORMS)’のように、CONDITIONの最後の条項に
     ‘t’を使用します。フォーム‘t’は‘t’に評価され、決して‘nil’にならない
     ので、この条項が不成立になることはなく、最終的に‘cond’はこの条項に
     到達します。たとえば:

          (setq a 5)
          (cond ((eq a 'hack) 'foo)
                (t "default"))
          ⇒ "default"

     この‘cond’式は、‘a’の値が‘hack’の場合は‘foo’、それ以外は文字列
     ‘"default"’をreturnします。

   任意の条件構成は、‘cond’か‘if’で表すことができます。したがって、どち
らを選択するかは、スタイルの問題です、たとえば:

     (if A B C)
     ≡
     (cond (A B) (t C))

* Menu:

* Pattern matching case statement::


File: elisp,  Node: Pattern matching case statement,  Up: Conditionals

10.2.1 Pattern matching case statement
--------------------------------------

特定の値を、可能なさまざまの場合にたいして比較するには、マクロ‘pcase’が
便利です。これは以下のフォームをとります:

     (pcase EXP BRANCH1 BRANCH2 BRANCH3 ...)

   各BRANCHは、‘(UPATTERN BODY-FORMS...)’というフォームです。

   これは最初にEXPを評価してから、どのBRANCHを使用するか、その値を各
UPATTERNと比較して、その後で対応するBODY-FORMS実行します。一般的なのは、
少数の異なる定数値を区別するために使用される場合です:

     (pcase (get-return-code x)
       (`success       (message "Done!"))
       (`would-block   (message "Sorry, can't do it now"))
       (`read-only     (message "The shmliblick is read-only"))
       (`access-denied (message "You do not have the needed rights"))
       (code           (message "Unknown return code %S" code)))

   最後の条項の‘code’は、‘(get-return-code x)’からreturnされた値にバイン
ドされる変数です。

   もっと複雑な例として、以下のような小さな式言語のための単純なインター
プリターを示します(この例ではレキシカルバインディングが必要なことに注意
してください):

     (defun evaluate (exp env)
       (pcase exp
         (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
         (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
         (`(fn ,arg ,body)   (lambda (val)
                               (evaluate body (cons (cons arg val) env))))
         ((pred numberp)     exp)
         ((pred symbolp)     (cdr (assq exp env)))
         (_                  (error "Unknown expression %S" exp))))

   ‘`(add ,x ,y)’は、‘exp’がシンボル‘add’で始まる3要素のリストかチェック
して、その後2番目と3番目の要素を抽出し、それらを変数‘x’と‘y’にバインドす
るパターンです。‘(pred numberp)’は‘exp’が数字かを単にチェックし、‘_’はす
べてのものにマッチするcatch-allパターンです。

   以下に、いくつかの例を評価した結果とともに示します:

     (evaluate '(add 1 2) nil)                 ;=> 3
     (evaluate '(add x y) '((x . 1) (y . 2)))  ;=> 3
     (evaluate '(call (fn x (add 1 x)) 2) nil) ;=> 3
     (evaluate '(sub 1 2) nil)                 ;=> error

   ‘pcase’に関係する2種類のパターンがあり、それらは_U-patterns_、
_Q-patterns_と呼ばれます。上述のUPATTERNはU-patternsで、以下の形式をもつ
ことができます:

‘`QPATTERN’
     これは、もっとも一般的なパターンの1つです。このパターンの意図は、バ
     ッククォートマクロの模倣です。このパターンは、バッククォート式によ
     り構築されるような値にマッチします。わたしたちが行なうのは値の構築
     ではなくパターンマッチングなので、非クォートは式をどこに挿入するか
     示すのではなく、かわりにその位置で値にマッチすべき1つのU-patternを
     指定します。

     より具体的には、Q-patternは以下のフォームをもつことができます:
     ‘(QPATTERN1 . QPATTERN2)’
          このパターンは、‘car’がQPATTERN1、‘cdr’がPATTERN2にマッチする
          、任意のコンスセルにマッチします。
     ‘ATOM’
          このパターンは、ATOMに‘equal’な任意のアトムにマッチします。
     ‘,UPATTERN’
          このパターンは、UPATTERNにマッチする任意のオブジェクトにマッチ
          します。

‘SYMBOL’
     U-pattern内の単なるシンボルはすべてにマッチし、さらにマッチした値に
     そのシンボルをバインドするので、BODY-FORMSや皇族のパターンから、そ
     れを参照することができます。
‘_’
     このパターン — いわゆる_don’t care_パターン — はシンボルパターンと
     同様、すべてのものにマッチしますが、シンボルパターンとは異なり、変
     数へのバインドを行ないません。
‘(pred PRED)’
     このパターンは、マッチされるオブジェクトで関数PREDが呼び出したとき
     、非‘nil’をreturnするものにマッチします。
‘(or UPATTERN1 UPATTERN2...)’
     このパターンは、引数のパターンから最初に成立したパターンにマッチし
     ます。すべての引数パターンは、同じ変数にバインドされるべきです。
‘(and UPATTERN1 UPATTERN2...)’
     このパターンは、すべての引数パターンが成立したときだけマッチします
     。
‘(guard EXP)’
     このパターンは調べられるオブジェクトを無視して、EXPが非‘nil’に評価
     されたときは成立、それ以外は不成立となります。これは通常、‘and’パタ
     ーンの内部で使用されます。たとえば、‘(and x (guard (< x 10)))’は
     10より小さい任意の数字にマッチして、それを変数‘x’にバインドします。


File: elisp,  Node: Combining Conditions,  Next: Iteration,  Prev: Conditionals,  Up: Control Structures

10.3 Constructs for Combining Conditions
========================================

このセクションは、複雑な条件を表現するために、‘if’や‘cond’とともによく使
用される3つの構成を記述します。‘and’と‘or’の構成は、ある種の複数条件の構
成として、個別に使用することもできます。

 -- Function: not condition
     この関数は、CONDITIONが偽であることをテストします。この関数は
     CONDITIONが‘nil’の場合は‘t’、それ以外は‘nil’をreturnします。関数
     ‘not’は‘null’と等価で、わたしたちは空のリストをテストする場合は、
     ‘null’の使用を推奨します。

 -- Special Form: and conditions...
     スペシャルフォーム‘and’は、すべてのCONDITIONSが真かどうかをテストし
     ます。この関数は、CONDITIONSを記述された順に1つずつ評価することによ
     り機能します。

     あるCONDITIONSが‘nil’に評価された場合、残りのCONDITIONSに関係なく、
     ‘and’は‘nil’をreturnしなければなりません。この場合、‘and’は即座に
     ‘nil’をreturnし、残りのCONDITIONSは無視されます。

     すべてのCONDITIONSが非‘nil’の場合、それらの最後の値が‘and’フォーム
     の値になります。CONDITIONSのない単独の‘(and)’は、‘t’をreturnします
     。なぜなら、すべてのCONDITIONSが非‘nil’となるので(考えてみてくださ
     い。そうでないのはどれですか?)、これは適切です。

     以下に例を示します。1番目の条件は整数1をretuenし、これは‘nil’ではあ
     りません。同様に2番目の条件は整数2をreturnし、これも‘nil’ではありま
     せん。3番目の条件は‘nil’なので、のこりの条件が評価されることは決し
     てありません。

          (and (print 1) (print 2) nil (print 3))
               ⊣ 1
               ⊣ 2
          ⇒ nil

     以下は、‘and’を使用した、より現実的な例です:

          (if (and (consp foo) (eq (car foo) 'x))
              (message "foo is a list starting with x"))

     ‘(consp foo)’が‘nil’をreturnした場合、‘(car foo)’は実行されないので
     、エラーにならないことに注意してください。

     ‘if’か‘cond’のどちらかを使用して、‘and’式を記述することもできます。
     以下はその方法です:

          (and ARG1 ARG2 ARG3)
          ≡
          (if ARG1 (if ARG2 ARG3))
          ≡
          (cond (ARG1 (cond (ARG2 ARG3))))

 -- Special Form: or conditions...
     スペシャルフォーム‘or’は、少なくとも1つのCONDITIONSが真かどうかをテ
     ストします。この関数は、すべてのCONDITIONSを1つずつ、記述された順に
     評価することにより機能します。

     あるCONDITIONSが非‘nil’値に評価された場合、‘or’の結果は非‘nil’でな
     ければなりません。この場合、‘or’は即座にreturnし、残りの
     CONDITIONSは無視されます。この関数がreturnする値は、非‘nil’値に評価
     された条件の値そのものです。

     すべてのCONDITIONSが‘nil’になった場合、‘or’式は‘nil’をreturnします
     。CONDITIONSのない単独の‘(or)’は、‘nil’をreturnします。なぜなら、す
     べてのCONDITIONSが‘nil’になるので(考えてみてください。そうでないの
     はどれですか?)、これは適切です。

     たとえば、この式は‘x’が‘nil’または整数0かどうかをテストします:

          (or (eq x nil) (eq x 0))

     ‘and’構成と同様に、‘or’を‘cond’に置き換えて記述することができます。
     たとえば:

          (or ARG1 ARG2 ARG3)
          ≡
          (cond (ARG1)
                (ARG2)
                (ARG3))

     ほとんどの場合、‘or’を‘if’に置き換えて記述できますが、完全ではあり
     ません:

          (if ARG1 ARG1
            (if ARG2 ARG2
              ARG3))

     これは完全に同一ではありません。なぜならARG1またはARG2を2回評価する
     かもしれないからです。対照的に、‘(or ARG1 ARG2 ARG3)’は2回以上引数
     を評価することは、決してありません。


File: elisp,  Node: Iteration,  Next: Nonlocal Exits,  Prev: Combining Conditions,  Up: Control Structures

10.4 Iteration
==============

繰り返し(iteration)とは、プログラムの一部を繰り返し実行することを意味し
ます。たとえば、リストの各要素、または0からNの整数にたいして、1度ずつ繰
り返し何らかの計算をおこないたいとしましょうEmacs Lispでは、スペシャルフ
ォーム‘while’でこれを行なうことができます:

 -- Special Form: while condition forms...
     ‘while’は、最初にCONDITIONを評価します。結果が非‘nil’の場合は、
     FORMSをテキスト順に評価します。その後CONDITIONを再評価して、結果が
     非‘nil’の場合、再度FORMSを評価します。この処理は、CONDITIONが
     ‘nil’に評価されるまで繰り返されます。

     繰り返し回数に制限はありません。このループは、CONDITIONが‘nil’に評
     価されるか、エラーとなるか、‘throw’で抜け出す(*note Nonlocal
     Exits::を参照してください)まで計測されるでしょう

     ‘while’フォームの値は、常に‘nil’です。

          (setq num 0)
               ⇒ 0
          (while (< num 4)
            (princ (format "Iteration %d." num))
            (setq num (1+ num)))
               ⊣ Iteration 0.
               ⊣ Iteration 1.
               ⊣ Iteration 2.
               ⊣ Iteration 3.
               ⇒ nil

     各繰り返しごとに何かを実行して、その後も終了テストを行なう
     “repeat...until”ループを記述するには、以下のように‘while’の1番目の
     引数として、bodyの後に終了テストを記述して、それを‘progn’の中に配し
     ます:

          (while (progn
                   (forward-line 1)
                   (not (looking-at "^$"))))

     これは1行前方に移動して、空行に達するまで行単位の移動を継続します。
     独特なのは、‘while’がbodyをもたず、終了テスト(これはポイント移動の
     実処理も行ないます)だけという点です。

   マクロ‘dolist’および‘dotimes’は、2つの一般的な種類のループを記述する
、便利な方法を提供します。

 -- Macro: dolist (var list [result]) body...
     この構成は、LISTの各要素にたいして1度BODYを実行し、カレント要素をロ
     ーカルに保持するように、変数VARにバインドします。その後、RESULTを評
     価した値、またはRESULTが省略された場合は‘nil’をreturnします。たとえ
     ば、以下は‘reverse’関数を定義するために、‘dolist’を使用する方法の例
     です:

          (defun reverse (list)
            (let (value)
              (dolist (elt list value)
                (setq value (cons elt value)))))

 -- Macro: dotimes (var count [result]) body...
     この構成は、0以上COUNT未満の各整数にたいして1度BODYを実行し、その繰
     り返しでの整数を、変数VARにバインドします。その後、RESULTの値、また
     はRESULTが省略された場合は‘nil’をreturnします。以下は、‘dotimes’を
     使用して、何らかの処理を100回行なう例です:

          (dotimes (i 100)
            (insert "I will not obey absurd orders\n"))


File: elisp,  Node: Nonlocal Exits,  Prev: Iteration,  Up: Control Structures

10.5 Nonlocal Exits
===================

“非ローカル脱出(nonlocal exit)”とは、プログラム内のある位置から、別の離
れた位置へ、制御を移します。Emacs Lispでは、エラーの結果として非ローカル
脱出が発生することがあります。明示的な制御の下で非ローカル脱出を使用する
こともできます。非ローカル脱出は、脱出しようとしている構成により作成され
た、すべての変数バインディングのバインドを外します。

* Menu:

* Catch and Throw::          プログラム自身の目的による非ローカル脱出。
* Examples of Catch::        このような非ローカル脱出が記述される方法を示します。
* Errors::                   エラーがシグナル・処理される方法。
* Cleanups::                 エラーが発生した場合のクリーンアップフォーム実行のアレンジ。


File: elisp,  Node: Catch and Throw,  Next: Examples of Catch,  Up: Nonlocal Exits

10.5.1 Explicit Nonlocal Exits: ‘catch’ and ‘throw’
---------------------------------------------------

ほとんどの制御構造は、そのコンストラクト自身内部の制御フローだけに影響し
ます。関数‘throw’は、通常のプログラム実行でのこのルールの例外です。これ
は、リクエストにより非ローカル脱出を行ないます(他にも例外はありますが、
それらはエラー処理だけのものです)。‘throw’は‘catch’の内部で試用され、
‘catch’に制御を戻します。たとえば:

     (defun foo-outer ()
       (catch 'foo
         (foo-inner)))

     (defun foo-inner ()
       ...
       (if x
           (throw 'foo t))
       ...)

‘throw’フォームが実行された場合は、対応する‘catch’に制御を移し、
‘catch’は即座にreturnします。‘throw’の後のコードは実行されません。
‘throw’の2番目の引数は、‘catch’のreturn値として使用されます。

   関数‘throw’は、1番目の引数にもとづいて、それにマッチする‘catch’を探し
ます。‘throw’は、1番目の引数が、‘throw’で指定されたものと‘eq’な‘catch’を
検索します。複数の該当する‘catch’がある場合、最内のものが優先されます。
したがって、上記の例では‘throw’が‘foo’を指定し、‘foo-outer’内の‘catch’が
同じシンボルを指定しているので、(この間に他のマッチする‘catch’は存在しな
いと仮定すると)‘catch’が該当します。

   ‘throw’の実行により、マッチする‘catch’までのすべてのリスプ構成(関数呼
び出しを含む)を脱出します。この方法により‘let’や関数呼び出しのようなバイ
ンディング構成を脱出する場合、これらの構成を正常にexitしたときのように、
そのバインディングは解かれます(*note Local Variables::を参照してください
)。同様に‘throw’は、‘save-excursion’(*note Excursions::を参照してくださ
い)により保存されたバッファーと位置を復元します。‘throw’が、スペシャルフ
ォーム‘unwind-protect’を脱出した場合、‘unwind-protect’により設定されたい
くつかのクリーンアップも実行します。

   ジャンプ先となる‘catch’内にレキシカル(局所的)である必要はありません。
‘throw’は、‘catch’内で呼び出された別の関数から、同じようにに呼び出すこと
ができます。‘throw’が行なわれたのが、順序的に、‘catch’に入った後でexitす
る前である限り、その‘throw’は‘catch’にアクセスできます。エディターのコマ
ンドループから戻る‘exit-recursive-edit’のようなコマンドで、‘throw’が使用
されるのは、これが理由です。

     Common Lispに関する注意: Common Lispを含む、他のほとんどのバージョ
     ンのLispは、非シーケンシャルに制御を移す、いくつかの方法 — たとえば
     ‘return’、‘return-from’、‘go’ — をもちます。Emacs Lispの場合は、
     ‘throw’だけです。‘cl-lib’ライブラリーは、これらのうちいくつかを提供
     します。*note (cl)Blocks and Exits::を参照してください。

 -- Special Form: catch tag body...
     ‘catch’は、‘throw’関数にたいするreturn位置を確立します。return位置
     はTAGにより、そのような他のreturn位置と区別されます。TAGは、‘nil’以
     外の任意のLispオブジェクトです。引数TAGはreturn位置が確立される前に
     、通常どおり評価されます。

     return位置が効果をもつことにより、‘catch’はBODYのフォームをテキスト
     順に評価します。フォームが(エラーは非ローカル脱出なしで)通常に実行
     された場合、bodyの最後のフォームの値が、‘catch’からreturnされます。

     BODYの実効の間に‘throw’が実行された場合、TAGと同じ値を指定すると、
     ‘catch’フォームは即座にexitします。returnされる値は、それが何であれ
     、‘throw’の2番目の引数に指定された値です。

 -- Function: throw tag value
     ‘throw’の目的は、以前に‘catch’により確立されたreturn位置に戻ること
     です。引数TAGは、既存のさまざまなreturn位置からrturn位置を選択する
     ために使用されます。複数のreturn位置がTAGにマッチする場合、最内のも
     のが使用されます。

     引数VALUEは、‘catch’からreturnされる値として使用されます。

     タグTAGのreturn位置が存在しない場合、データ‘(TAG VALUE)’とともに、
     ‘no-catch’エラーがシグナルされます。


File: elisp,  Node: Examples of Catch,  Next: Errors,  Prev: Catch and Throw,  Up: Nonlocal Exits

10.5.2 Examples of ‘catch’ and ‘throw’
--------------------------------------

2重にネストされたループから脱出する1つの方法は、‘catch’と‘throw’を使うこ
とです(ほとんどの言語では、これは“goto”により行なわれるでしょう)。ここで
は、IとJを、0から9に変化させて‘(foo I J)’を計算します:

     (defun search-foo ()
       (catch 'loop
         (let ((i 0))
           (while (< i 10)
             (let ((j 0))
               (while (< j 10)
                 (if (foo i j)
                     (throw 'loop (list i j)))
                 (setq j (1+ j))))
             (setq i (1+ i))))))

‘foo’が非‘nil’をreturnした場合、即座に処理を止めて、IとJのリストを
returnしています。‘foo’が常に‘nil’をreturnする場合、‘catch’は通常どおり
returnし、その値は‘while’の結果である‘nil’となります。

   以下では、2つのreturn位置を1度に表す、微妙に異なるトリッキーな例を2つ
示します。最初に、同じタグ‘hack’にたいする2つのreturn位置があります:

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     ⇒ catch2

     (catch 'hack
       (print (catch2 'hack))
       'no)
     ⊣ yes
     ⇒ no

どちらのreturn位置も‘throw’にマッチするタグをもつので、内側のもの、つま
り‘catch2’で確立されたものにgotoします。したがって‘catch2’は通常どおり値
‘yes’をreturnするので、その値がプリントされます。最後に外側の‘catch’の
2番目のbody、つまり‘'no’が評価されて、外側の‘catch’からそれがreturnされ
ます。

   ここで、‘catch2’に与える引数を変更してみます:

     (catch 'hack
       (print (catch2 'quux))
       'no)
     ⇒ yes

この場合も2つのreturn位置がありますが、今回は外側だけがタグ‘hack’をもち
、内側のものは、かわりにタグ‘quux’をもちます。したがって、‘throw’により
、外側の‘catch’が値‘yes’をreturnします。関数‘print’が呼び出されることは
なく、bodyのフォーム‘'no’も決して評価されません。


File: elisp,  Node: Errors,  Next: Cleanups,  Prev: Examples of Catch,  Up: Nonlocal Exits

10.5.3 Errors
-------------

Emacs Lispが、何らかの理由により評価できないようなフォームの評価を試みた
場合には、“エラー(error)”が“シグナル(signal)”されます。

   エラーがシグナルされた場合、エラーメッセージの表示とカレントこまんど
の実行の終了が、Emacsデフォルトの反応です。たとえばバッファーの最後で
‘C-f’とタイプしたときのように、ほとんどの場合、これは正しい反応です。

   複雑なプログラムでは、単なる終了が望ましくない場合もあるでしょう。た
とえば、そのプログラムはデータ構造に一時的に変更を行なっていたり、プログ
ラム終了前に削除すべき一時バッファーを作成しているかもしれません。このよ
うな場合、エラー時に評価される“クリーンアップ式(cleanup expressions)”を
設定するために、‘unwind-protect’を使用するでしょう(*note Cleanups::を参
照してください)。サブルーチン内のエラーにもかかわらずに、プログラムの実
行を継続したいときがあるかもしれません。この場合、エラー時のリカバリーを
制御するための“エラーハンドラー(error handlers)”を設定するために、
‘condition-case’を使用するでしょう。

   エラーハンドリングを使用せずに、プログラムの一部から別の部分へ制御を
移すためには、‘catch’と‘throw’を使用します。*note Catch and Throw::を参
照してください。

* Menu:

* Signaling Errors::         エラーを報告する方法。
* Processing of Errors::     エラーを報告するときEmacsが何を行なうか。
* Handling Errors::          エラーをトラップして実行を継続する方法。
* Error Symbols::            エラートラッピングのために、エラーをクラス分けする方法。


File: elisp,  Node: Signaling Errors,  Next: Processing of Errors,  Up: Errors

10.5.3.1 How to Signal an Error
...............................

エラーの“シグナリング(signaling)”とは、エラーの処理を開始することを意味
します。エラー処理は通常、実行中のプログラムのすべて、または一部をアボー
ト(abort)して、エラーをハンドルするためにセットアップされた位置に
returnします。ここでは、エラーをシグナルする方法を記述します。

   ほとんどのエラーは、たとえば、整数にたいしてCARを求めたり、バッファー
の最後で1文字前方に移動したときなどのように、他の目的のために呼び出した
Lisp基本関数の中で、“自動的”にシグナルされます。関数‘error’と‘signal’で
、明示的にエラーをシグナルすることもできます。

   ユーザーが‘C-g’をタイプしたときに発生するquitは、エラーとは判断されま
せんが、ほとんどはエラーと同様に扱われます。*note Quitting::を参照してく
ださい。

   すべてのエラーメッセージはそれぞれ、何らかのエラーメッセージを指定し
ます。そのメッセージは、何が悪いのか(“File does not exist”)、物事がどう
してそうあるべきではない(“File must exist”)かを示すべきです。Emacs Lispの
監修では、エラーメッセージは大文字で開始され、句読点で終わるべきではあり
ません。

 -- Function: error format-string &rest args
     この関数は、FORMAT-STRINGとARGSにたいして、‘format’(*note
     Formatting Strings::を参照してください)を適用することにより構築され
     たエラーメッセージとともに、エラーをシグナルします。

     以下は、‘error’を使用する典型的な例です:

          (error "That is an error -- try something else")
               error→ That is an error -- try something else

          (error "You have committed %d errors" 10)
               error→ You have committed 10 errors

     2つの引数 — エラーシンボル‘error’と、‘format’によりreturnされる文字
     列を含むリスト — で‘signal’を呼び出すことにより、‘error’は機能しま
     す。

     *警告: *エラーメッセージとして固定の文字列を使用したい場合、単に
     ‘(error STRING)’とは記述しないでください。もしSTRINGが‘%’を含む場合
     、それはフォーマット指定子(format specifier)として解釈されてしまう
     ので、望む結果は得られません。かわりに、‘(error "%s" STRING)’を使用
     してください。

 -- Function: signal error-symbol data
     この関数は、ERROR-SYMBOLにより命名されるエラーをシグナルします。引
     数DATAは、エラーの状況に関連する追加のLispオブジェクトのリストです
     。

     引数ERROR-SYMBOLは、“エラーシンボル(error symbol)” —
     ‘define-error’により定義されYたシンボル — でなければなりません。こ
     れはEmacs Lispが異なる種類のエラーをクラス分けする方法です。エラー
     シンボル(error symbol)、エラーコンディション(error condition)、コン
     ディション名(condition name)の説明については、*note Error
     Symbols::を参照してください。

     エラーが処理されない場合、エラーメッセージをプリントするために2つの
     引数が使用されます。このエラーメッセージは通常、ERROR-SYMBOLの
     ‘error-message’プロパティーにより提供されます。DATAが非‘nil’の場合
     、その後にコロンと、DATAの評価されていない要素を、カンマで区切った
     リストが続きます。‘error’が発生した場合、エラーメッセージは、DATAの
     CAR(文字列でなければなりません)です。‘file-error’のサブカテゴリーは
     、特別に処理されます。

     DATA内のオブジェクトの数と重要性は、ERROR-SYMBOLに依存します。たと
     えば、‘wrong-type-argument’エラーでは、リスト内には2つのオブジェク
     ト — 期待する型を記述する述語と、その型への適合に失敗したオブジェク
     ト — であるべきです。

     エラーを処理する任意のエラーハンドラーにたいして、ERROR-SYMBOLと
     DATAの両方を利用できます。‘condition-case’は、ローカル変数を
     ‘(ERROR-SYMBOL . DATA)’というフォームでバインドします(*note
     Handling Errors::を参照してください)。

     関数‘signal’は、決してreturnしません。

          (signal 'wrong-number-of-arguments '(x y))
               error→ Wrong number of arguments: x, y

          (signal 'no-such-error '("My unknown error condition"))
               error→ peculiar error: "My unknown error condition"

 -- Function: user-error format-string &rest args
     この関数は、‘error’とまったく同じように振る舞いますが、‘error’では
     なく、‘user-error’というエラーシンボルを使用します。名前が示唆する
     ように、このエラーはコード自身のエラーではなく、ユーザーパートのエ
     ラーの報告を意図しています。たとえば、Infoの閲覧履歴の開始を超えて
     履歴を遡るためにコマンド‘Info-history-back’ (‘l’)を使用した場合、
     Emacsは‘user-error’をシグナルします。このようなエラーでは、たとえ
     ‘debug-on-error’が非‘nil’であっても、デバッガーへのエントリーは発生
     しません。*note Error Debugging::を参照してください。

     Common Lispに関する注意: Emacs Lispには、Common Lispのような継続可
     能なエラーのような概念は存在しません。


File: elisp,  Node: Processing of Errors,  Next: Handling Errors,  Prev: Signaling Errors,  Up: Errors

10.5.3.2 How Emacs Processes Errors
...................................

エラーがシグナルされたとき、‘signal’は、そのエラーにたいするアクティブな
“ハンドラー(handler)”を検索します。ハンドラーとは、Lispプログラムの一部
でエラーが発生したときに実行するよう意図された、Lisp式のシーケンスです。
そのエラーが適切なハンドラーをもつ場合、そのハンドラーが実行され、そのハ
ンドラーの後から実行が再開されます。ハンドラーは、そのハンドラーが設定さ
れた‘condition-case’の環境内で実行されます。‘condition-case’内のすべての
関数呼び出しはすでに終了しているので、ハンドラーがそれらにreturnすること
はありません。

   そのエラーにたいする適切なハンドラーが存在しない場合は、カレントコマ
ンドを終了して、エディターのコマンドループに制御をreturnします(コマンド
ループは、すべての種類のエラーにたいする暗黙のハンドラーをもちます)。コ
マンドループのハンドラーは、エラーメッセージをプリントするために、エラー
シンボルと、関連付けられたデータを使用します。変数
‘command-error-function’を使用して、これが行なわれる方法を制御できます:

 -- Variable: command-error-function
     この変数は、もし非‘nil’の場合はEmacsのコマンドループに制御を
     returnしたエラーの処理に使用する関数を指定します。この関数は3つの引
     数をとります。1つ目はDATAで、‘condition-case’が自身の変数にバインド
     するのと同じフォームです。2つ目はCONTEXTで、これはエラーが発生した
     状況を記述する文字列、または‘nil’（よくある）です。3つ目はCALLERで
     、これはエラーをシグナルした基本関数を呼び出したLisp関数です。

   明示的なハンドラーのないエラーは、Lispデバッガーを呼び出すかもしれま
せん。変数‘debug-on-error’ (*note Error Debugging::を参照してください)が
非‘nil’の場合、デバッガーが有効です。エラーハンドラーとは異なり、デバッ
ガーはそのエラーの環境内で実行されるので、エラー時の変数の値を正確に調べ
ることができます。


File: elisp,  Node: Handling Errors,  Next: Error Symbols,  Prev: Processing of Errors,  Up: Errors

10.5.3.3 Writing Code to Handle Errors
......................................

エラーをシグナルすることによる通常の効果は、実行されていたコマンドを終了
して、Emacsエディターのコマンドループに即座にreturnすることです。スペシ
ャルフォーム‘condition-case’を使用して、エラーハンドラーを設定することに
より、プログラム内の一部で発生するエラーのをトラップを調整することができ
ます。以下は単純な例です:

     (condition-case nil
         (delete-file filename)
       (error nil))

これは、FILENAMEという名前のファイルを削除して、任意のエラーをcatchして
、エラーが発生した場合は‘nil’を参照してください(このような単純なケースで
は、マクロ‘ignore-errors’を使用することもできます。以下を参照してくださ
い)。

   ‘condition-case’構成は、‘insert-file-contents’呼び出しでのファイルオ
ープンの失敗のような、予想できるエラーをトラップするために多用されます。
‘condition-case’構成は、ユーザーからの読み取った式を評価するプログラムの
ような、完全に予測できないエラーのトラップにも使用されます。

   ‘condition-case’の2番目の引数は、“保護されたフォーム(protected
form)”と呼ばれます(上記の例では、保護されたフォームは、‘delete-file’の呼
び出しです)。このフォームの実行が開始されると、エラーハンドラーは効果を
もち、このフォームがreturnすると不活性になります。その間のすべてにおいて
、エラーハンドラーは効果をもちます。特に、このフォームで呼び出された関数
、およびそのサブルーチンなどを実行する間、エラーハンドラーは効果をもちま
す。厳密にいうと、保護されたフォーム自身ではなく、保護されたフォームによ
り呼び出されたLisp基本関数(‘signal’と‘error’を含む)だけがシグナルされる
というのは、よいことです。

   保護されたフォームの後の引数はハンドラーです。各ハンドラーは、どのエ
ラーを処理するかを指定する、1つ以上の“コンディション名(condition
names)”(シンボル)をリストします。エラーがシグナルされたとき、エラーシン
ボルはコンディション名のリストも定義します。エラーが共通の条件名をもつ場
合、そのハンドラーはそのエラーに適用されます。上記の例では、1つのハンド
ラーがあり、それはすべてのエラーをカバーする条件名‘error’を指定していま
す。

   適切なハンドラーの検索は、もっとも最近に設定されたハンドラーから開始
して、設定されたすべてのハンドラーをチェックします。したがって、ネストさ
れた‘condition-case’フォームに同じエラー処理がある場合、内側のハンドラー
がそれを処理します。

   何らかの‘condition-case’によりエラーが処理された場合、
‘debug-on-error’でエラーによりデバッガーが呼び出されるようにしていても、
通常はデバッガーの実行が抑制されます。

   ‘condition-case’により補足されるようなエラーをデバッグできるようにし
たい場合は、変数‘debug-on-signal’に非‘nil’値をセットします。以下のように
コンディションの中に‘debug’を記述することにより、最初にデバッガーを実行
するような、特定のハンドラーを指定することもできます:

     (condition-case nil
         (delete-file filename)
       ((debug error) nil))

ここでの‘debug’の効果は、デバッガー呼び出しを抑制する‘condition-case’を
防ぐことだけです。‘debug-on-error’およびその他のフィルタリングメカニズム
がデバッガーを呼び出すように指定されているときだけ、エラーによりデバッガ
ーが呼び出されます。*note Error Debugging::を参照してください。

 -- Macro: condition-case-unless-debug var protected-form handlers...
     マクロ‘condition-case-unless-debug’は、そのようなフォームのデバッギ
     ングを処理する、別の方法を提供します。このマクロは、変数
     ‘debug-on-error’が‘nil’の場合、つまり任意のエラーを処理しないような
     ケース以外は、‘condition-case’とまったく同様に振る舞います。

   特定のハンドラーがそのエラーを処理するとEmacsが判断すると、Emacsは制
御をそのハンドラーにreturnします。これを行うために、Emacsはそのとき脱出
しつつあるバインディング構成により作成されたすべての変数のバインドを解き
、そのとき脱出しつつあるすべての‘unwind-protect’フォームを実行します。制
御がそのハンドラーに達すると、そのハンドラーのbodyが通常どおり実行されま
す。

   そのハンドラーのbodyを実行した後、‘condition-case’フォームから実行が
returnされます。保護されたフォームは、そのハンドラーの実行の前に完全に
exitしているので、そのハンドラーはそのエラーの位置から実行を再開すること
はできず、その保護されたフォーム内で作られた変数のバインディングを調べる
こともできません。ハンドラーが行なえることは、クリーンアップと、処理を進
行させることだけです。

   エラーのシグナルとハンドルには、‘throw’と‘catch’(*note Catch and
Throw::)に類似する点がいくつかありますが、これらは完全に別の機能です。エ
ラーは‘catch’でキャッチできず、‘throw’をエラーハンドラーで処理することは
できません(しかし対応する‘catch’が存在しないときに‘throw’を仕様すること
によりシグナルされるエラーは、処理できます)。

 -- Special Form: condition-case var protected-form handlers...
     このスペシャルフォームは、PROTECTED-FORMの実行を囲い込むエラーハン
     ドラーHANDLERSを確立します。エラーなしでPROTECTED-FORMが実行された
     場合、returnされる値は‘condition-case’フォームの値になります。この
     場合、‘condition-case’は効果をもちません。PROTECTED-FORMの間にエラ
     ーが発生した場合、‘condition-case’は違いをもちます。

     それぞれのHANDLERSは、‘(CONDITIONS BODY...)’というフォームのリスト
     です。ここでCONDITIONSは、ハンドルされるエラーコンディション名、ま
     たはそのハンドラーの前にデバッガーを実行するためのコンディション名
     (‘debug’を含みます)です。BODYは、このハンドラーがエラーを処理すると
     きに実行される、1つ以上のLisp式です。

          (error nil)

          (arith-error (message "Division by zero"))

          ((arith-error file-error)
           (message
            "Either division by zero or failure to open a file"))

     発生するエラーはそれぞれ、それが何の種類のエラーかを記述する“エラー
     シンボル(error symbol)”をもち、これはコンディション名のリストも記述
     します(*note Error Symbols::を参照してください)。Emacsは、1つ以上の
     コンディション名を指定するハンドラーにたいして、すべてのアクティブ
     な‘condition-case’フォームを検索します。‘condition-case’の最内のマ
     ッチは、そのエラーを処理します。この‘condition-case’では、最初に適
     合したハンドラーが、そのエラーを処理します。

     ハンドラーのbodyを実行した後、‘condition-case’は通常どおりreturnし
     、ハンドラーのbodyの最後の値を、ハンドラー全体の値として使用します
     。

     引数VARは変数です。PROTECTED-FORMを実行するとき、‘condition-case’は
     この変数をバインドせず、エラーを処理するときだけバインドします。そ
     の場合は、VARを“エラー記述(error description)”にバインドします。こ
     れはエラーの詳細を与えるリストです。このエラー記述は、
     ‘(ERROR-SYMBOL . DATA)’というフォームをもちます。ハンドラーは、何を
     行なうか決定するために、このリストを参照することができます。たとえ
     ば、ファイルオープンの失敗にたいするエラーの場合、ファイル名が
     DATA(エラー記述の3番目の要素)の2番目の要素になります。

     VARが‘nil’の場合、それはバインドされた変数がないことを意味します。
     この場合、エラーシンボルおよび関連するデータは、そのハンドラーでは
     利用できません。

     より外側のレベルのハンドラーにcatchさせるために、‘condition-case’に
     よりcatchされたシグナルを再度throwする必要がある場合もあります。以
     下はこれを行なう方法です:

            (signal (car err) (cdr err))

     ここで‘err’はエラー記述変数(error description variable)で、
     ‘condition-case’の1番目の引数は、再throwしたいエラーコンディション
     です。*note Definition of signal::を参照してください。

 -- Function: error-message-string error-descriptor
     この関数は、与えられたエラー記述子(error descriptor)にたいするエラ
     ーメッセージ文字列をreturnします。これは、そのエラーにたいする通常
     のエラーメッセージをプリントすることにより、エラーを処理したい場合
     に有用です。*note Definition of signal::を参照してください。

   以下は、0除算の結果によるエラーを処理するために、‘condition-case’を使
用する例です。このハンドラーは、(beepなしで)エラーメッセージを表示して、
非常に大きい数をreturnします。

     (defun safe-divide (dividend divisor)
       (condition-case err
           ;; 保護されたフォーム。
           (/ dividend divisor)
         ;; ハンドラー。
         (arith-error                        ; Condition.
          ;; このエラーにたいする、通常のメッセージを表示する。
          (message "%s" (error-message-string err))
          1000000)))
     ⇒ safe-divide

     (safe-divide 5 0)
          ⊣ Arithmetic error: (arith-error)
     ⇒ 1000000

このハンドラーはコンディション名‘arith-error’を指定するので、
division-by-zero(0除算)エラーだけを処理します。他の種類のエラーは(この
‘condition-case’によっては)、処理されません。したがって:

     (safe-divide nil 3)
          error→ Wrong type argument: number-or-marker-p, nil

   以下は、‘error’によるエラーを含む、すべての種類のエラーをcatchする
‘condition-case’です:

     (setq baz 34)
          ⇒ 34

     (condition-case err
         (if (eq baz 35)
             t
           ;; 関数‘error’の呼び出し
           (error "Rats!  The variable %s was %s, not 35" 'baz baz))
       ;; フォームではないハンドラー。
       (error (princ (format "The error was: %s" err))
              2))
     ⊣ The error was: (error "Rats!  The variable baz was 34, not 35")
     ⇒ 2

 -- Macro: ignore-errors body...
     これは、その実行中に発生する任意のエラーを無視して、BODYの実行を構
     築します。その実行にエラーがなかった場合、‘ignore-errors’はBODY内の
     最後のフォームの値をreturnし、それ以外は‘nil’をreturnします。

     以下は、このセクションの最初の例を、‘ignore-errors’を使用して記述す
     る例です:

            (ignore-errors
             (delete-file filename))

 -- Macro: with-demoted-errors format body...
     このマクロは、いわば‘ignore-errors’の穏やかなバージョンです。これは
     エラーを完全に抑止するのではなく、エラーをメッセージに変換します。
     これはメッセージのフォーマットに、文字列FORMATを使用します。
     FORMATは、‘"Error: %S"’のように、単一の‘%’シーケンスを含むべきです
     。エラーをシグナルすると予測されないが、もし発生した場合は堅牢であ
     るべきようなコードの周囲に、‘with-demoted-errors’を使用します。この
     マクロは、‘condition-case’ではなく、‘condition-case-unless-debug’を
     使用することに注意してください。


File: elisp,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors

10.5.3.4 Error Symbols and Condition Names
..........................................

エラーをシグナルするとき、想定するエラーの種類を指定するために、“エラー
シンボル(error symbol)”を指定します。エラーはそれぞれ、それをカテゴリー
分けするために、ただ1つのエラーシンボルをもちます。これはEmacs Lisp言語
で定義されるエラーの、もっとも良い分類方法です。

   これら狭義の分類は、“エラー条件(error conditions)”と呼ばれる、より広
義のクラス階層にグループ化され、それらは“コンディション名(condition
names)”により識別されます。そのようなもっとも狭義なクラスは、エラーシン
ボル自体に属します。つまり各エラーシンボルは、コンディション名でもあるの
です。すべての種類のエラー(‘quit’を除く)を引き受けるコンディション名
‘error’に至る、より広義のクラスにたいするコンディション名も存在します。
したがって、各エラーは1つ以上のコンディション名をもちます。つまり、
‘error’、‘error’とは区別されるエラーシンボル、もしかしたらその中間に分類
されるものかもしれません。

 -- Function: define-error name message &optional parent
     シンボルをエラーシンボルとするために、シンボルは親コンディションを
     とる‘define-error’で定義されなければなりません。この親は、この種の
     エラーが属するコンディションを定義します。親の推移的な集合は、常に
     そのエラーシンボルと、シンボル‘error’を含みます。quitはエラーと判断
     されないので、‘quit’の親の集合は、単なる‘(quit)’です。

   親のコンディションに加えて、エラーシンボルはメッセージ(MESSAGE)をもち
、これは処理されないエラーがシグナルされたときプリントされる文字列です。
そのメッセージが有効でない場合、エラーメッセージ‘peculiar error’が使用さ
れます。*note Definition of signal::を参照してください。

   内部的には、親の集合はエラーシンボルの‘error-conditions’プロパティー
に格納され、メッセージはエラーシンボルの‘error-message’プロパティーに格
納されます。

   以下は、新しいエラーシンボル‘new-error’を定義する例です:

     (define-error 'new-error "A new error" 'my-own-errors)

このエラーは複数のコンディション名 — もっとも狭義の分類‘new-error’、より
広義の分類を想定する‘my-own-errors’、および‘my-own-errors’のコンディショ
ンすべてを含む‘error’で、これはすべての中でもっとも広義なものです。

   エラー文字列は大文字で開始されるべきですが、ピリオドで終了すべきでは
ありません。これはEmacsの他の部分との整合性のためです。

   もちろんEmacs自身が‘new-error’をシグナルすることはありません。あなた
のコード内で明示的に‘signal’(*note Definition of signal::を参照してくだ
さい)を呼び出すことにより、これを行なうことができるのです。

     (signal 'new-error '(x y))
          error→ A new error: x, y

   このエラーは、エラーの任意のコンディション名により処理することができ
ます。以下の例は、‘new-error’とクラス‘my-own-errors’内の他の任意のエラー
を処理します:

     (condition-case foo
         (bar nil t)
       (my-own-errors nil))

   エラーが分類される有効な方法は、コンディション名による方法で、その名
前はハンドラーのエラーのマッチに使用されます。エラーシンボルは、意図され
たエラーメッセージと、コンディション名のリストを指定する便利な方法である
という役割だけです。1つのエラーシンボルではなく、コンディション名のリス
トを‘signal’に与えるのは、面倒でしょう。

   対照的に、コンディション名を伴わずにエラーシンボルだけを使用した場合
、それは‘condition-case’の効果を著しく減少させるでしょう。コンディション
名は、エラーハンドラーを記述するとき、一般性のさまざまなレベルにおいて、
エラーをカテゴリー分けすることを可能にします。エラーシンボルを単独で使用
することは、もっとも狭義なレベルの分類を除くすべてを捨てることです。

   主要なエラーシンボルと、それらのコンディションについては、*note
Standard Errors::を参照してください。


File: elisp,  Node: Cleanups,  Prev: Errors,  Up: Nonlocal Exits

10.5.4 Cleaning Up from Nonlocal Exits
--------------------------------------

‘unwind-protect’構成は、データ構造を一時的に不整合な状態に置くときは、重
要です。これはエラーやthrouのイベントにより、再びデータを整合された状態
にすることができます(バッファー内容の変更だけに使用される、他のクリーン
アップ構成は、アトミックな変更グループです。*note Atomic Changes::を参照
してください)。

 -- Special Form: unwind-protect body-form cleanup-forms...
     ‘unwind-protect’は、制御がBODY-FORMを離れる場合に、CLEANUP-FORMSが
     評価されるという保証の下、なにが起こった可に関わらず、BODY-FORMを実
     行します。BODY-FORMは通常どおり完了するかもしれず、
     ‘unwind-protect’の外で‘throw’が実行されたり、エラーが発生するかもし
     れませんが、CLEANUP-FORMSは評価されます。

     BODY-FORMが正常に終了した場合、‘unwind-protect’はCLEANUP-FORMSを評
     価した後で、BODY-FORMの値をreturnします。BODY-FORMが終了しなかった
     場合、‘unwind-protect’は通常の意味における値は、returnしません。

     ‘unwind-protect’により保護されるのは、BODY-FORMだけです。
     CLEANUP-FORMS自体の任意のフォームが、(‘throw’またはエラーにより)非
     ローカルにexitした場合、‘unwind-protect’は残りのフォームが評価され
     ることを保証_しません_。CLEANUP-FORMSの中の1つが失敗することが問題
     となる場合は、そのフォームの周囲に他の‘unwind-protect’を配して保護
     します。

     現在アクティブな‘unwind-protect’フォーム数と、ローカルの変数バイン
     ディング数の和は、‘max-specpdl-size’(*note Local Variables:
     Definition of max-specpdl-size.を参照してください)により制限されま
     す。

   たとえば、以下は一時的な使用のために不可視のバッファーを作成して、終
了する前に確実にそのバッファーをkillする例です:

     (let ((buffer (get-buffer-create " *temp*")))
       (with-current-buffer buffer
         (unwind-protect
             BODY-FORM
           (kill-buffer buffer))))

‘(kill-buffer (current-buffer))’のように記述して、変数‘buffer’を使用せず
に、同様のことを行えると思うかもしれません。しかし上の例は、別のバッファ
ーにスイッチしたときにBODY-FORMでエラーが発生した場合、より安全なのです
(一時的なバッファーをkillするとき、そのバッファーがカレントとなることを
確実にするために、かわりにBODY-FORMの周囲に‘save-current-buffer’を記述す
ることもできます)。

   Emacsには、上のコードとおおよそ等しいコードに展開される、
‘with-temp-buffer’という標準マクロが含まれます(*note Current Buffer:
Definition of with-temp-buffer.を参照してください)。このマニュアル中で定
義されるいくつかのマクロは、この方法で‘unwind-protect’を使用します。

   以下は、FTPパッケージ由来の、実際の例です。これは、リモートマシンへの
接続の確立を試みるために、プロセス(*note Processes::を参照してください
)を作成します。関数‘ftp-login’は、関数のライター(writer)が予想できないこ
とによる多くの問題から非常に影響を受けるので、失敗イベントでプロセスの削
除を保証するフォームで保護されています。そうしないと、Emacsは無用なサブ
プロセスで一杯になってしまうでしょう。

     (let ((win nil))
       (unwind-protect
           (progn
             (setq process (ftp-setup-buffer host file))
             (if (setq win (ftp-login process host user password))
                 (message "Logged in")
               (error "Ftp login failed")))
         (or win (and process (delete-process process)))))

   この例には小さなバグがあります。ユーザーがquitするために‘C-g’とタイプ
した場合、関数‘ftp-setup-buffer’がreturnした後、即座にquitが発生しますが
、それは変数‘process’がセットされる前なので、そのプロセスはkillされない
でしょう。このバグを簡単に訂正する方法はありませんが、少なくともこれは非
常に稀なことだと言えます。


File: elisp,  Node: Variables,  Next: Functions,  Prev: Control Structures,  Up: Top

11 Variables
************

“変数(variable)”とは、プログラム内で値を表すために使用される名前です。
Lispでは、変数はそれぞれLispシンボルとして表されます(*note Symbols::を参
照してください)。変数名は単にそのシンボルの名前であり、変数の値はそのシ
ンボルの値セル(value cell)に格納されます(1)。*note Symbol Components::を
参照してください。Emacs Lispでは、シンボルを変数として使用することは、同
じシンボルを関数名として使用することと関係ありません。

   このマニュアル中で前に記したとおり、Lispプログラムはまず第1にLispオブ
ジェクトとして表され、副次的にテキストとして表現されます。Lispプログラム
のテキスト的な形式は、そのプログラムを構成するLispオブジェクトの入力構文
により与えられます。したがって、Lispプログラム内の変数のテキスト的な形式
は、その変数を表すシンボルの入力構文を使用して記述されます。

* Menu:

* Global Variables::         どの場所でも永続的に存在する変数の値。
* Constant Variables::       変更されることのない値を持つ、ある種の"変数"。
* Local Variables::          一時的にのみ存在する存在する変数の値。
* Void Variables::           値を持たないシンボル。
* Defining Variables::       シンボルが変数として使用されていることを宣言する定義。
* Tips for Defining::        変数を定義するときに考慮すべき事項。
* Accessing Variables::      実行時に判明する名前をもつ変数の値を確認する。
* Setting Variables::        変数に新しい値を格納する。
* Variable Scoping::         Lispがローカル値とグローバル値を選択する方法。
* Buffer-Local Variables::   1つのバッファーないだけで効果をもつ変数の値。
* File Local Variables::     ファイル内にリストされたローカル変数の処理。
* Directory Local Variables::  ディレクトリー内のすべてのファイルで共通のローカル変数。
* Variable Aliases::         他の変数のエイリアスとなる変数。
* Variables with Restricted Values::  任意のLispオブジェクトを値とすることが_できない_、定数ではない変数。
* Generalized Variables::    変数の概念の拡張。

   ---------- Footnotes ----------

   (1) 正確に言うと、デフォルトの“ダイナミックスコープ(dynamic
scoping)”のルールでは、値セルは常にその変数のカレント値を保持しますが、
“レキシカルスコープ(lexical scoping)”では異なります。詳細は、*note
Variable Scoping::を参照してください。


File: elisp,  Node: Global Variables,  Next: Constant Variables,  Up: Variables

11.1 Global Variables
=====================

変数を使用するための一番シンプルな方法は、“グローバル(globally)”に使用す
る方法です。これは、ある時点でその変数はただ1つの値をもち、その値が(少な
くともその時点では)Lispシステム全体で効果をもつことを意味します。あらた
な値を指定するまで、その値が効果をもちます。新しい値で古い値を置き換える
とき、古い値を追跡する情報は変数内に残りません。

   シンボルの値は‘setq’で指定します。たとえば、

     (setq x '(a b))

これは、変数‘x’に値‘(a b)’を与えます。‘setq’はスペシャルフォームであるこ
とに注意してください。これは1番目の引数(変数の名前)は評価しませんが、2番
目の引数(新しい値)は評価します。

   変数が1度値をもつと、そのシンボル自身を式として使用することにより、参
照することができます。したがって、

     x ⇒ (a b)

これは上記の‘setq’フォームが実行された場合です。

   同じ変数を再びセットした場合、新しい値は古い値を置き換えます:

     x
          ⇒ (a b)
     (setq x 4)
          ⇒ 4
     x
          ⇒ 4


File: elisp,  Node: Constant Variables,  Next: Local Variables,  Prev: Global Variables,  Up: Variables

11.2 Variables that Never Change
================================

Emacs Lispでは、特定のシンボルは、通常は自分自身に評価されます。これらの
シンボルには‘nil’と‘t’、同様に名前が‘:’で始まる任意のシンボル(これらは
“キーワード”と呼ばれます)が含まれます。これらのシンボルは、リバインドや
、値の変更はできません。‘nil’や‘t’へのセットやリバインドは、
‘setting-constant’エラーをシグナルします。これはキーワード(名前が‘:’で始
まるシンボル)についても当てはまります。ただしキーワードが標準のobarrayに
internされている場合、そのようなシンボルを自分自身にセットしてもエラーに
なりません。

     nil ≡ 'nil
          ⇒ nil
     (setq nil 500)
     error→ Attempt to set constant symbol: nil

 -- Function: keywordp object
     この関数は、OBJECTが‘:’で始まる名前のシンボルで、標準のobarrayに
     internされているの場合は‘t’、それ以外は‘nil’をreturnします。

   これらの定数はスペシャルフォーム‘defconst’(*note Defining
Variables::を参照してください)を使用して定義された“定数(constant)”とは、
根本的に異なります。‘defconst’フォームは、人間の読み手に値の変更を意図し
ない変数であることを知らせる役目は果たしますが、実際にそれを変更しても、
Emacsはエラーを起こしません。


File: elisp,  Node: Local Variables,  Next: Void Variables,  Prev: Constant Variables,  Up: Variables

11.3 Local Variables
====================

グローバル変数は、新しい値で明示的に置き換えるまで値が持続します。変数に
“ローカル値(local value)” — Lispプログラム内の特定の部分で効果をもつを与
えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数
がその値に“ローカルにバインド(locally bound)”と言い、その変数を“ローカル
変数(local variable)”と呼びます。

   たとえば、関数が呼び出されるとき、関数の引数となる変数はローカル値(そ
の関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これら
のローカルバインディングは、その関数のbody内で効果をもちます。他にも、た
とえばスペシャルフォーム‘let’は特定の変数にたいして明示的にローカルなバ
インディングを確立し、これは‘let’フォームのbody内で効果を持ちます。

   これにたいして“グローバルなバインディング(global binding)”とは、(概念
的には)グローバルな値が保持される場所です。

   ローカルバインディングを確立すると、その変数の以前の値は他の場所に保
存されます(または失われます)。わたしたちはこれを、以前の値が“シャドーさ
れた(shadowed)”と言います。シャドーはグローバル変数とローカル変数の両方
で発生し得ます。ローカルバインディングが効果を持つとき、ローカル変数に
‘setq’を使用することにより、ローカルバインディングに指定された値を格納し
ます。ローカルバインディングが効果を持たなくなったとき、以前にシャドーさ
れた値が復元されます(または失われます)。

   変数は同時に複数のローカルバインディングを持つことができます(たとえば
その変数をバインドするネストされた‘let’)。“カレントバインディング
(current binding)”とは、実際に効果を持つローカルバインディングのことです
。カレントバインディングは、その変数の評価によりreturnされる値を決定し、
‘setq’により影響を受けるバインディングです。

   ほとんどの用途において、“最内(innermost)”のローカルバインディング、ロ
ーカルバインディングがないときはグローバルバインディングを、カレントバイ
ンディングと考えることができます。より正確に言うと、“スコープルール
(scoping rule)”と呼ばれるルールは、プログラム内でローカルバインディング
が効果を持つ任意の与えられた場所を決定します。Emacs Lispのスコープルール
は“ダイナミックスコープ(dynamic scoping)”と呼ばれ、これは単に実行中のプ
ログラム内の与えられた位置でのカレントバインディングを示し、その変数がま
だ存在する場合は、その変数にたいしてもっとも最近作成されたバインディング
です。ダイナミックスコープについての詳細と、その代替である“レキシカルス
コープ(lexical scoping)”と呼ばれるスコープルールについては、*note
Variable Scoping::を参照してください。

   スペシャルフォーム‘let’および‘let*’は、ローカルバインディングを作成す
るために存在します:

 -- Special Form: let (bindings...) forms...
     このスペシャルフォームは、BINDINGSにより指定される特定の変数セット
     にたいするローカルバインディングをセットアップしてから、FORMSのすべ
     てをテキスト順に評価します。これはFORMS内の最後のフォームの値を
     returnします。

     BINDINGSの各バインディングは2つの形式のどちらかです。(i) シンボルの
     場合。この場合、そのシンボルは‘nil’にローカルにバインドされます。
     (ii) フォーム‘(SYMBOL VALUE-FORM)’のリストの場合。この場合SYMBOLは
     VALUE-FORMを評価した結果にローカルにバインドされます。VALUE-FORMが
     省略された場合は、‘nil’が使用されます。

     BINDINGS内のすべてのVALUE-FORMは、シンボルがそれらにバインドされる
     _前_に、記述された順番に評価されます。以下は例では、‘z’は‘y’の新し
     い場合(つまり1)にではなく、古い値(つまり2)にバインドされます。

          (setq y 2)
               ⇒ 2

          (let ((y 1)
                (z y))
            (list y z))
               ⇒ (1 2)

 -- Special Form: let* (bindings...) forms...
     このスペシャルフォームは‘let’と似ていますが、次の変数値にたいするロ
     ーカル値を計算する前に、ローカル値を計算してそれを変数にバインドし
     ます。したがて、BINDINGS内の式は、この‘let*’フォーム内の前のシンボ
     ルのバインドを参照できます。以下の例を、上記‘let’の例と比較してくだ
     さい。

          (setq y 2)
               ⇒ 2

          (let* ((y 1)
                 (z y))    ; ‘y’の値に今計算されたばかりの値を使用する。
            (list y z))
               ⇒ (1 1)

   以下は、ローカルバインディングを作成する、他の機能のリストです:

   • 関数呼び出し(*note Functions::を参照してください)。

   • マクロ呼び出し(*note Macros::を参照してください)。

   • ‘condition-case’ (*note Errors::を参照してください)。

   変数はバッファーローカルなバインディングを持つこともできます(*note
Buffer-Local Variables::を参照してください)。数は多くありませんが、端末
ローカル(terminal-local)なバインディングをもつ変数もあります(*note
Multiple Terminals::を参照してください)これらの種類のバインディングは、
通常のローカルバインディングのように機能することもありますが、これらは
Emacs内の“どこ”であるかに依存してローカライズされます。

 -- User Option: max-specpdl-size
     この変数は、ローカルな変数バインディングと、‘unwind-protect’にゆる
     クリーンアップ(*note Cleaning Up from Nonlocal Exits: Cleanups.の総
     数にたいする制限を定義し、この変数を越えるとEmacsはエラー(データに
     関するエラー‘"Variable binding depth exceeds max-specpdl-size"’)を
     シグナルします。

     このリミットは、もし超過したときにエラーが関連付けられている場合に
     は、誤って定義された関数による無限再起を避けるための1つの方法になり
     ます。ネストの深さにたいする他の制限としては、
     ‘max-lisp-eval-depth’があります。*note Eval: Definition of
     max-lisp-eval-depth.を参照してください。

     デフォルト値は1300です。Lispデバッガーのエントリーしたとき、もし残
     りが少ないときは、デバッガーを実行するための空きを作るために、値は
     増加されます。


File: elisp,  Node: Void Variables,  Next: Defining Variables,  Prev: Local Variables,  Up: Variables

11.4 When a Variable is “Void”
==============================

シンボルの値セル(*note Symbol Components::を参照してください)に値が割り
当てられていない場合、その変数はvoid(空)であると言います。

   Emacs Lispのデフォルトであるダイナミックスコープルール(*note Variable
Scoping::)の下では、値セルはその変数のカレント値(ローカルまたはグローバ
ル)を保持します。値が割り当てられていない値セルは、値セルに‘nil’をもつの
とは_異なる_ことに注意してください。シンボル‘nil’はLispオブジェクトであ
り、他のオブジェクトと同様に変数の値となることができます。‘nil’は値なの
です。変数がvoidの場合、その変数の評価を試みると、値をreturnするかわりに
、‘void-variable’エラーがシグナルされます。

   オプションであるレキシカルスコープルール(lexical scoping rule)の下で
は、値セル保持できるのは、その変数のグローバル値 — 任意のレキシカルバイ
ンディング構造の外側の値だけです。変数がレキシカルにバインドされている場
合、ローカル値はそのレキシカル環境により決定されます。したがって、これら
のシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つ
ことができます。

 -- Function: makunbound symbol
     この関数は、SYMBOLの値セルを空にして、その変数をvoidにします。この
     関数はSYMBOLをreturnします。

     SYMBOLがダイナミックなローカルバインディングを持つ場合、
     ‘makunbound’はカレントのバインディングをvoidにし、そのローカルバイ
     ンディングが効果を持つ限りvoidにします。その後、前にシャドーされた
     ローカル値(またはグローバル値)が再び有効になり、再び有効になった値
     がvoidでなければ、その変数はvoidでなくなります。

     いくつか例を示します(ダイナミックバインディングが有効だとします):

          (setq x 1)               ; グローバルバインディングに値をセットする。
               ⇒ 1
          (let ((x 2))             ; それをローカルにバインドする。
            (makunbound 'x)        ; ローカルバインディングをvoidにする。
            x)
          error→ Symbol's value as variable is void: x
          x                        ; グローバルバインディングは変更されない。
               ⇒ 1

          (let ((x 2))             ; ローカルにバインドする。
            (let ((x 3))           ; もう1度。
              (makunbound 'x)      ; 最内のローカルバインディングをvoidにする。
              x))                  ; それを参照すると、void。
          error→ Symbol's value as variable is void: x

          (let ((x 2))
            (let ((x 3))
              (makunbound 'x))     ; 内側のバインディングをvoidにしてから取り除く。
            x)                     ; 外側の‘let’バインディングが有効になる。
               ⇒ 2

 -- Function: boundp variable
     この関数はVARIABLE(シンボル)がvoidでなければ‘t’をreturnし、voidのと
     きは‘nil’をreturnします。

     いくつか例を示します(ダイナミックバインディングが有効だとします):

          (boundp 'abracadabra)          ; 最初はvoid。
               ⇒ nil
          (let ((abracadabra 5))         ; ローカルにバインドする。
            (boundp 'abracadabra))
               ⇒ t
          (boundp 'abracadabra)          ; グローバルではまだvoid。
               ⇒ nil
          (setq abracadabra 5)           ; グローバルで非voidにする。
               ⇒ 5
          (boundp 'abracadabra)
               ⇒ t


File: elisp,  Node: Defining Variables,  Next: Tips for Defining,  Prev: Void Variables,  Up: Variables

11.5 Defining Global Variables
==============================

“変数定義(variable definition)”とは、そのシンボルをグローバル変数として
使用する意図を表明する構成です。これには以下で説明するスペシャルフォーム
‘defvar’や‘defconst’が使用されます。

   変数宣言は3つの目的をもちます。1番目は、コードを読む人にたいして、そ
のシンボルが特定の方法(変数として)使用されることを_意図_したものだと知ら
せることです。2番目は、Lispシステムにたいして、オプションで初期値とドキ
ュメント文字列を与えて、これを知らせることです。3番目は、‘etags’のような
プログラミングツールにたいして、その変数が定義されている場所を見つけられ
るように、情報を提供することです。

   ‘defconst’と‘defvar’の違いは主に、人間の読み手に、値が変更されるかど
うかを知らせることにあります。Emacs Lispは実際、‘defconst’で定義された変
数の値の変更を妨げません。この2つのフォームの特筆すべき違いは、
‘defconst’は無条件で変数を初期化し、‘defvar’は変数が元々voidのときだけ初
期化することです。

   マスタマイズ可能な変数を定義する場合は、‘defcustom’を使用するべきです
(これはサブルーチンとして‘defvar’を呼び出します)。*note Variable
Definitions::を参照してください。

 -- Special Form: defvar symbol [value [doc-string]]
     このスペシャルフォームは、変数としてSYMBOLを定義します。SYMBOLは評
     価されないことに注意してください。シンボルは‘defvar’フォーム内に明
     示的に表記して定義される必要があります。この変数は“特別”だとマーク
     され、これは常にそれがダイナミックにバインドされることを意味します
     (*note Variable Scoping::を参照してください)。

     VALUEが指定されていてSYMBOLがvoid(たとえばこのシンボルがダイナミッ
     クにバインドされた値を持たないとき。*note Void Variables::を参照し
     てください)、VALUEが評価されて、その結果がSYMBOLにセットされます。
     しかしSYMBOLがvoidでな場合、VALUEは評価されず、SYMBOLの値は変更され
     ません。VALUEが省略された場合、いかなる場合もSYMBOLの値は変更されま
     せん。

     SYMBOLがカレントバッファー内でバッファーローカルなバインディングを
     もつ場合、‘defvar’はデフォルト値に作用します。デフォルト値はバッフ
     ァーローカルなバインディングではなく、バッファーにたいして独立して
     います。デフォルト値がvoidのときはデフォルト値をセットします。*note
     Buffer-Local Variables::を参照してください。

     すでにSYMBOLがレキシカルにバインドされている場合(たとえばレキシカル
     バインドが有効な状態で‘let’フォーム内に‘defvar’があるような場合)、
     ‘defvar’はダイナミックな値をセットします。バインディング構造を抜け
     るまで、レキシカルバインディングは効果をもちます。*note Variable
     Scoping::を参照してください。

     Emacs Lispモード(‘eval-defun’)でトップレベルの‘defvar’を評価すると
     き、‘eval-defun’の特別な機能は、その値がvoidであるかテストすること
     なく、その変数を無条件にセットします。

     引数DOC-STRINGが与えられた場合、それは変数にたいするドキュメント文
     字列を指定します(そのシンボルの‘variable-documentation’プロパティー
     に格納されます)。*note Documentation::を参照してください。

     以下にいくつか例を示します。これは‘foo’を定義しますが、初期化は行い
     ません:

          (defvar foo)
               ⇒ foo

     この例は‘bar’の値を‘23’に初期化して、ドキュメント文字列を与えます:

          (defvar bar 23
            "The normal weight of a bar.")
               ⇒ bar

     ‘defvar’フォームはSYMBOLをreturnしますが、通常これは値が問題になら
     ないファイル内のトップレベルで使用されます。

 -- Special Form: defconst symbol value [doc-string]
     このスペシャルフォームは、ある値としてSYMBOLを定義して、それを初期
     化します。これはコードを読む人に、SYMBOLがここで設定される標準的な
     グローバル値をもち、ユーザーや他のプログラムがそれを変更すべきでは
     ないことを知らせます。SYMBOLは評価されないことに注意してください。
     このシンボルは、‘defconst’内に明示的に記されなければなりません。

     ‘defvar’と同様、‘defconst’は、変数を“特別” — この変数が常にダイナミ
     ックにバインドされているという意味 — だとマークします(*note
     Variable Scoping::を参照してください)。加えて、これはその変数を危険
     であるとマークします(*note File Local Variables::を参照してください
     )。

     ‘defconst’は常にVALUEを評価して、その結果をSYMBOLの値にセットします
     。カレントバッファー内でSYMBOLがバッファーローカルなバインディング
     をもつ場合、‘defconst’はデフォルト値ではなく、バッファーローカルな
     値をセットします(しかし、‘defconst’で定義されたシンボルにたいしてバ
     ッファーローカルなバインディングを作るべきではありません)。

     ‘defconst’の使い方の例は、Emacsの‘float-pi’ — (たとえIndiana State
     Legislatureが何を試みようと)何者かにより変更されるべきではない、数
     学定数piにたいする定義です。しかし2番目の‘defconst’の例のように、こ
     れは単にアドバイス的なものです。

          (defconst float-pi 3.141592653589793 "The value of Pi.")
               ⇒ float-pi
          (setq float-pi 3)
               ⇒ float-pi
          float-pi
               ⇒ 3

   *警告:* 変数がローカルバインディングをもつとき(‘let’により作成された
、または関数の引数の場合)に、スペシャルフォーム‘defconst’または
‘defvar’を使用すると、これらのフォームはグローバルバインディングではなく
、ローカルバインディングをセットします。これは通常、あなたが望むことでは
ないはずです。これを防ぐには、これらのスペシャルフォームをファイル内のト
ップレベルで使用します。この場所は通常、何のローカルバインディングも効果
をもたないので、その変数にたいするローカルバインディングが作成される前に
ファイルがロードされることが確実だからです。


File: elisp,  Node: Tips for Defining,  Next: Accessing Variables,  Prev: Defining Variables,  Up: Variables

11.6 Tips for Defining Variables Robustly
=========================================

値が関数(または関数のリスト)であるような変数を定義するとき、変数の名前の
最後に‘-function’(または‘-functions’)を使います。

   他にも、変数名に関する慣習があります。以下はその完全なリストです:

‘...-hook’
     変数はノーマルフックです(*note Hooks::を参照してください)。

‘...-function’
     値は関数です。

‘...-functions’
     値は関数のリストです。

‘...-form’
     値はフォーム(式)です。

‘...-forms’
     値はフォーム(式)のリストです。

‘...-predicate’
     値は述語(predicate) — 1つの引数をとる関数 — で、引数が“正しい
     (good)”"場合は非‘nil’、“正しくない(bad)”場合は‘nil’をreturnします。

‘...-flag’
     ‘nil’か、そうでないかだけが意味をもつような値です。そのような変数は
     結局、やがては多くの値をもつことが多いので、この慣習を強く推奨はし
     ません。

‘...-program’
     値はプログラム名です。

‘...-command’
     値は完全なシェルコマンドです。

‘...-switches’
     値はコマンドにたいして指定するオプションです。

   変数を定義するときは、その変数を“安全(safe)”とマークすべきか、それと
も“危険(risky)”とマークすべきかを常に考慮してください。*note File Local
Variables::を参照してください。

   複雑な値を保持する変数(バインディングをもつkeymapなど)を定義、または
初期化するとき、以下のように値の計算をすべて‘defvar’の中に配置するのが最
良です:

     (defvar my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         map)
       DOCSTRING)

この方法にはいくつかの利点があります。1つ目は、ファールをロード中にユー
ザーが中断した場合、変数はまだ初期化されていないか、初期化されているかの
どちらかで、その中間ということはありません。まだ初期化されていない場合、
ファイルをリロードすれば正しく初期化されます。2つ目は、1度初期化された変
数は、ファイルをリロードしても変更されないことです。コンテンツの一部を変
更(たとえばキーのリバインド)するフックをユーザーが実行した場合などに、こ
れは重要です。3つ目は、‘C-M-x’で‘defvar’を評価すると、そのマップは完全に
再初期化されることです。

   ‘defvar’フォーム内に多すぎるコードを配置することには不利な点が1つあり
ます。ドキュメント文字列が変数の名前から離れた場所に配置されることです。
これを避ける安全な方法は以下の方法です:

     (defvar my-mode-map nil
       DOCSTRING)
     (unless my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         (setq my-mode-map map)))

これは初期化を‘defvar’の内側に配置した場合とまったく同じ利点をもちますが
、変数を再度初期化したい場合は、各フォームにたいして1回ずつ、2度
‘C-M-x’をタイプしなければならない点が異なります。


File: elisp,  Node: Accessing Variables,  Next: Setting Variables,  Prev: Tips for Defining,  Up: Variables

11.7 Accessing Variable Values
==============================

変数を参照する通常の方法は、それに名前をつけるシンボルを記述する方法です
。The usual way to reference a variable is to write the symbol which
names it.  *note Symbol Forms::を参照してください。

   時には、実行時にのみ決定される変数を参照したいときがあるかもしれませ
ん。そのような場合、プログラム中のテキストで、変数名を指定することはでき
ません。その値を抽出するために、‘symbol-value’を使うことができます。

 -- Function: symbol-value symbol
     この関数は、SYMBOLの値セルに格納された値をreturnします。これには、
     その変数の(ダイナミックな)カレント値が格納された場所です。その変数
     がローカルバインディングをもたない場合は、単にその変数のグローバル
     値になります。変数がvoidの場合、‘void-variable’はエラーをシグナルし
     ます。

     その変数がレキシカルにバインドされている場合、‘symbol-value’により
     報告される値は、その変数のレキシカル値と同じである必要はありません
     。レキシカル値はそのシンボルの値セルではなく、レキシカル環境により
     決定されます。*note Variable Scoping::を参照してください。

          (setq abracadabra 5)
               ⇒ 5
          (setq foo 9)
               ⇒ 9

          ;; ここでシンボル‘abracadabra’は
          ;;   値がテストされるシンボル。
          (let ((abracadabra 'foo))
            (symbol-value 'abracadabra))
               ⇒ foo

          ;; ここでは、‘abracadabra’の値、
          ;;   つまり‘foo’が、
          ;;   値をテストされるシンボル。
          (let ((abracadabra 'foo))
            (symbol-value abracadabra))
               ⇒ 9

          (symbol-value 'abracadabra)
               ⇒ 5


File: elisp,  Node: Setting Variables,  Next: Variable Scoping,  Prev: Accessing Variables,  Up: Variables

11.8 Setting Variable Values
============================

ある変数の値を変更する通常の方法は、スペシャルフォーム‘setq’を使用する方
法です。実行時に変数選択を計算する必要がある場合は、関数‘set’を使用しま
す。

 -- Special Form: setq [symbol form]...
     このスペシャルフォームは、変数の値を変更するための、もっとも一般的
     な方法です。SYMBOLにはそれぞれ、新しい値(対応するFORMが評価された結
     果)を与えられます。そのシンボルのカレントバインディングは変更されま
     す。

     ‘setq’はSYMBOLを評価せず、記述されたシンボルをセットします。この引
     数のことを、“自動的にクォートされた(automatically quoted)”と呼びま
     す。‘setq’の‘q’は、“quoted(クォートされた)”が由来です。

     ‘setq’フォームの値は、最後のFORMの値となります。

          (setq x (1+ 2))
               ⇒ 3
          x                   ; ここで‘x’はグローバル値をもつ。
               ⇒ 3
          (let ((x 5))
            (setq x 6)        ; ‘x’のローカルバインディングをセット。
            x)
               ⇒ 6
          x                   ; グローバル値は変更されない。
               ⇒ 3

     1番目のFORMが評価されてから1番目のSYMBOLがセットされ、次に2番目の
     FORMが評価されてからSYMBOLが評価されて、...となることに注意してくだ
     さい:

          (setq x 10          ; ここで、‘x’がセットされるのは
                y (1+ x))     ;   ‘y’の計算前であることに注目。
               ⇒ 11

 -- Function: set symbol value
     この関数は、SYMBOLの値セルにVALUEを配置します。これはスペシャルフォ
     ームではなく関数なので、シンボルにセットするために、SYMBOLに記述さ
     れた式は評価されます。return値はVALUEです。

     ダイナミックな変数バインドが有効な場合(デフォルト)、‘set’は自身の引
     数SYMBOLを評価しますが、‘setq’は評価しないという点を除き、‘set’は
     ‘setq’と同じ効果をもちます。しかし、変数がレキシカルバインドの場合
     、‘set’は変数の_ダイナミック_な値に影響し、‘setq’は変数のカレント値
     (レキシカル値)に影響します。*note Variable Scoping::を参照してくだ
     さい。

          (set one 1)
          error→ Symbol's value as variable is void: one
          (set 'one 1)
               ⇒ 1
          (set 'two 'one)
               ⇒ one
          (set two 2)         ; ‘two’は、シンボル‘one’に評価される。
               ⇒ 2
          one                 ; したがって‘one’がセットされる。
               ⇒ 2
          (let ((one 1))      ; ‘one’のこのバインディングがセットされるのであって
            (set 'one 3)      ;   グローバル値はセットされない。
            one)
               ⇒ 3
          one
               ⇒ 2

     SYMBOLが実際のシンボルでない場合、‘wrong-type-argument’エラーがシグ
     ナルされます。

          (set '(x y) 'z)
          error→ Wrong type argument: symbolp, (x y)


File: elisp,  Node: Variable Scoping,  Next: Buffer-Local Variables,  Prev: Setting Variables,  Up: Variables

11.9 Scoping Rules for Variable Bindings
========================================

ある変数にたいするローカルバインディングを作成するとき、そのバインディン
グはプログラムの限られた一部だけに効果をもちます(*note Local
Variables::)。このセクションでは、これが正確には何を意味するかについて説
明します。

   ローカルバインディングはそれぞれ、個別に“スコープ(scope: 範囲という意
味)”と“エクステント(extent: これも範囲を意味する)”をもちます。“スコープ
”は、そのバインディングにアクセスできるのが、テキストのソースコードの_ど
こ(where)_であるかを示します。“エクステント”は、プログラムの実行中に、そ
のバインディングが存在するのが_いつ(when)_であるかを示します。

   デフォルトでは、Emacsが作成したローカルバインディングは、“ダイナミッ
クバインディング(dynamic binding)”です。このようなバインディングは、“ダ
イナミックスコープ(dynamic scope)”をもち、それはプログラムの任意の範囲が
、その変数バインディングにアクセスするかもしれないことを意味します。これ
は“ダイナミックエクステント(dynamic extent)”ももちます。これはそのバイン
ディング構造(‘let’フォームのbodyなど)が実行される間だけ、そのバインディ
ングが存続することを意味します。

   Emacsはオプションで“レキシカルバインディング(lexical binding)”を作成
することができます。レキシカルバインディングは“レキシカルスコープ
(lexical scope)”をもち、これはその変数にたいする任意の参照が、バインディ
ング構造内にテキスト的に配置されなければならないことを意味します(1)。レ
キシカルバインディングは“不定エクステント(indefinite extent)”ももちます
。これは、ある状況下において、“クロージャー(closures)”と呼ばれるスペシャ
ルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続を
続けることを意味します。

   以降のサブセクションでは、ダイナミックバインディングとレキシカルバイ
ンディング、およびEmacs Lispプログラムでレキシカルバインディングを有効に
する方法について、より詳細に説明します。

* Menu:

* Dynamic Binding::          Emacs内でのローカル変数にたいするデフォルトのバインディング。
* Dynamic Binding Tips::     ダイナミックバインディングによる問題を回避する。
* Lexical Binding::          ローカル変数にたいする他の種類のバインディング。
* Using Lexical Binding::    レキシカルバインディングを有効にする方法。

   ---------- Footnotes ----------

   (1) これには、いくつか例外があります。たとえば、レキシカルバインディ
ングは、Lispデバッガーからもアクセスできます。


File: elisp,  Node: Dynamic Binding,  Next: Dynamic Binding Tips,  Up: Variable Scoping

11.9.1 Dynamic Binding
----------------------

デフォルトでは、Emacsにより作成されるローカル変数のバインディングは、ダ
イナミックバインディングです。ある変数がダイナミックにバインドされている
と、Lispプログラムの実行における任意のポイントでのカレントバインディング
は、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカ
ルバインディングか、そのようなローカルバインディングが存在しない場合はグ
ローバルバインディングになります。

   以下の例のように、ダイナミックバインディングはダイナミックスコープと
ダイナミック<エクステントをもちます:

     (defvar x -99)  ; ‘x’は初期値として−99を受け取る。

     (defun getx ()
       x)            ; この関数内では、‘x’は“自由”に使用される。

     (let ((x 1))    ; ‘x’はダイナミックにバインドされている。
       (getx))
          ⇒ 1

     ;; ‘let’フォームが終了した後、
     ;; ‘x’は前の値−99にリバートされる。

     (getx)
          ⇒ -99

関数‘getx’は‘x’を参照します。‘defun’構造自体の中に‘x’にたいするバインデ
ィングが存在しないと意味において、これは“自由”な参照です。‘x’が(ダイナミ
ックに)バインドされている‘let’フォーム内から‘getx’を呼び出すと、ローカル
値(つまり1)が取得されます。しかし、その後‘let’フォームの外側から‘getx’を
呼び出すと、グローバル値(つまり−99)が取得されます。

   以下は、‘setq’を使用してダイナミックに変数をバインドする、例をです:

     (defvar x -99)      ; ‘x’は初期値として−99を受け取る。

     (defun addx ()
       (setq x (1+ x)))  ; ‘x’に1追加して、新しい値をreturnする。

     (let ((x 1))
       (addx)
       (addx))
          ⇒ 3           ; ‘addx’を2回呼び出すと、‘x’に2回追加される。

     ;; ‘let’フォームが終了した後、
     ;; ‘x’は前の値−99にリバートされる。

     (addx)
          ⇒ -98

   Emacs Lispでは、ダイナミックバインディングは、シンプルな方法で実装さ
れています。それぞれのシンボルは、シンボルのカレントのダイナミック値(ま
たは値の不在)を指定する値セルをもちます。*note Symbol Components::を参照
してください。あるシンボルがダイナミックなローカル値を与えられたとき、
Emacsは値セルの内容(または値の不在)をスタックに記録し、新しいローカル値
を値セルに格納します。バインディング構造が実行を終えたとき、Emacsはスタ
ックから古い値をpopして、値セルにそれを置きます。


File: elisp,  Node: Dynamic Binding Tips,  Next: Lexical Binding,  Prev: Dynamic Binding,  Up: Variable Scoping

11.9.2 Proper Use of Dynamic Binding
------------------------------------

ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルス
コープ内で定義されていない変数を参照することを許す、強力な機能です。しか
し、無制限に使用した場合は、プログラムの理解しにくくしてしまうこともあり
ます。このテクニックを使用するために、2つの明解な方法があります:

   • ある変数がグローバルな定義をもたない場合は、ローカル変数としてバイ
     ンディング構造内だけ(その変数がバインドされる‘let’フォームのbodyな
     どの場所)でそれを使用します。プログラムでこの慣習に一貫してしたがえ
     ば、プログラム内の他の場所の同じ変数シンボルの任意の使用が、その変
     数の値に影響を与えたり、影響を受けることがなくなります。

   • それ以外では、‘defvar’、‘defconst’、‘defcustom’で変数を定義します。
     *note Defining Variables::を参照してください。この定義は通常、Emacs
     Lispファイル内のトップレベルにあるべきです。この定義には可能な限り
     、変数の意味と目的を説明するドキュメント文字列を含めるべきです。名
     前の衝突を避けるように、変数を命名することも行うべきです(*note
     Coding Conventions::を参照してください)。

     その後は、プログラム内のどこか別の場所で、それが何に影響するか確信
     をもって、変数をバインドすることができます。その変数にどこで出会っ
     ても、(たとえば、変数の定義がEmacsにロードされていれば、‘C-h v’コマ
     ンドを通じて)定義を参照するのが簡単になります。*note (emacs)Name
     Help::を参照してください。

     たとえば、‘case-fold-search’のようなカスタマイズ可能な変数にたいし
     てローカルバインディングを使用するのは一般的です:

          (defun search-for-abc ()
            "Search for the string \"abc\", ignoring case differences."
            (let ((case-fold-search nil))
              (re-search-forward "abc")))


File: elisp,  Node: Lexical Binding,  Next: Using Lexical Binding,  Prev: Dynamic Binding Tips,  Up: Variable Scoping

11.9.3 Lexical Binding
----------------------

Emacsのバージョン24.1から、オプションの機能としてレキシカルバインディン
グが導入されました。わたしたちは、この機能の重要さが、将来において重要に
なることを期待します。レキシカルバインディングは最適化の機会をより広げる
ので、この機能を使用するプログラムはおそらく、将来のEmacsバージョンで高
速に実行されるようになるでしょう。レキシカルバインディングは、わたしたち
がEmacsに将来追加したいと考える並列性(concurrency)とも互換をもっています
。

   レキシカルにバインドされた変数は“レキシカルスコープ(lexical scope)”を
もいます。 これは、その変数にたいする参照は、そのバインディング構造内に
テキスト的に配置されなければならないことを意味します。以下は例です (実際
にレキシカルバインディングを有功にする方法は、*note Using Lexical
Binding::を参照してください):

     (let ((x 1))    ; ‘x’はレキシカルにバインドされる。
       (+ x 3))
          ⇒ 4

     (defun getx ()
       x)            ; この関数内では、‘x’は“自由”に使用される。

     (let ((x 1))    ; ‘x’はレキシカルにバインドされる。
       (getx))
     error→ Symbol's value as variable is void: x

ここでは、‘x’はグローバル値をもちません。‘let’フォーム内でレキシカルにバ
インドされたとき、この変数は‘let’のテキスト境界内で使用できます。しかし
、この‘let’内から呼び出される‘getx’関数からは、‘getx’の関数定義が‘let’フ
ォームの外側にあるので、使用することが_できません_。

   レキシカルバインディングが機能する方法を説明します。各バインディング
構造は、その構造および構造のローカル値でバインドされるシンボルを指定する
ことにより、“レキシカル環境(lexical environment)”を定義します。Lispの評
価機能(Lisp evaluator)がある変数のカレント値を得たいときは、最初にレキシ
カル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が
格納されるシンボルの値セルを探します。

   (内部的には、レキシカル環境はシンボルと値がペアになったalistで、
alistの最後の要素はコンスセルではなく、シンボル‘t’です。そのような
alistは、フォームを評価するためのレキシカル環境を指定するために、
‘eval’関数の2番目の引数として渡すことができます。*note Eval::を参照して
ください。しかし、ほとんどのEmacs Lispプログラムは、この方法で直接レキシ
カル環境を使用するべきではありません。デバッガーのような特化されたプログ
ラムだけが使用すべきです。)

   レキシカルバインディングは、不定エクステント(indefinite extent)をもち
ます。バインディング構造が終了した後でも、そのレキシカル環境は“クロージ
ャー(closures)”と呼ばれるLispオブジェクト内に“保持”されます。クロージャ
ーは、レキシカルバインディングが有効な、名前つきまたは無名(anonymous)の
関数が作成されたときに作成されます。詳細は、*note Closures::を参照してく
ださい。

   クロージャーが関数として呼び出されたとき、その関数の定義内のレキシカ
ル変数にたいする任意の参照は、レキシカル環境を維持するために使用されます
。以下は例です:

     (defvar my-ticker nil)   ; クロージャーを格納するために
                              ; この変数を使用する。

     (let ((x 0))             ; ‘x’はレキシカルにバインドされる。
       (setq my-ticker (lambda ()
                         (setq x (1+ x)))))
         ⇒ (closure ((x . 0) t) ()
               (setq x (1+ x)))

     (funcall my-ticker)
         ⇒ 1

     (funcall my-ticker)
         ⇒ 2

     (funcall my-ticker)
         ⇒ 3

     x                        ; ‘x’はグローバル値をもたないことに注意。
     error→ Symbol's value as variable is void: x

‘let’バインディングは、内部に変数‘x’をもつレキシカル環境を定義し、これは
0にローカルにバインドされます。このバインディング構造内で、‘x’を1層化し
、増加された値をreturnするクロージャーを定義しています。このラムダ式は自
動的にクロージャーになり、たとえ‘let’構造を抜けた後でも、その内部ではレ
キシカル環境が存続します。クロージャーを評価するときは毎回、レキシカル環
境内の‘x’のバインディングが使用され、‘x’が増加されます。

   ‘symbol-value’、‘boundp’、‘set’のような関数は、変数のダイナミックバイ
ンディング(つまりそのシンボルの値セル)だけを取得(または変更)することに注
意してください。‘defun’(または‘defmacro’)のbody内のコードも、周囲のレキ
シカル変数は参照できません。

