This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Lexical Binding,  Next: Using Lexical Binding,  Prev: Dynamic Binding Tips,  Up: Variable Scoping

11.9.3 Lexical Binding
----------------------

Emacsのバージョン24.1から、オプションの機能としてレキシ
カルバインディングが導入されました。わたしたちは、この機
能の重要さが、将来において重要になることを期待します。レ
キシカルバインディングは最適化の機会をより広げるので、こ
の機能を使用するプログラムはおそらく、将来のEmacsバージ
ョンで高速に実行されるようになるでしょう。レキシカルバイ
ンディングは、わたしたちがEmacsに将来追加したいと考える
並列性(concurrency)とも互換をもっています。

   レキシカルにバインドされた変数は“レキシカルスコープ
(lexical scope)”をもいます。 これは、その変数にたいする
参照は、そのバインディング構造内にテキスト的に配置されな
ければならないことを意味します。以下は例です (実際にレキ
シカルバインディングを有功にする方法は、*note Using
Lexical Binding::を参照してください):

     (let ((x 1))    ; ‘x’はレキシカルにバインドされる。
       (+ x 3))
          ⇒ 4

     (defun getx ()
       x)            ; この関数内では、‘x’は“自由”に使用される。

     (let ((x 1))    ; ‘x’はレキシカルにバインドされる。
       (getx))
     error→ Symbol's value as variable is void: x

ここでは、‘x’はグローバル値をもちません。‘let’フォーム内
でレキシカルにバインドされたとき、この変数は‘let’のテキ
スト境界内で使用できます。しかし、この‘let’内から呼び出
される‘getx’関数からは、‘getx’の関数定義が‘let’フォーム
の外側にあるので、使用することが_できません_。

   レキシカルバインディングが機能する方法を説明します。
各バインディング構造は、その構造および構造のローカル値で
バインドされるシンボルを指定することにより、“レキシカル
環境(lexical environment)”を定義します。Lispの評価機能
(Lisp evaluator)がある変数のカレント値を得たいときは、最
初にレキシカル環境内を探します。そこで変数が指定されてい
なければ、ダイナミック値が格納されるシンボルの値セルを探
します。

   (内部的には、レキシカル環境はシンボルと値がペアになっ
たalistで、alistの最後の要素はコンスセルではなく、シンボ
ル‘t’です。そのようなalistは、フォームを評価するためのレ
キシカル環境を指定するために、‘eval’関数の2番目の引数と
して渡すことができます。*note Eval::を参照してください。
しかし、ほとんどのEmacs Lispプログラムは、この方法で直接
レキシカル環境を使用するべきではありません。デバッガーの
ような特化されたプログラムだけが使用すべきです。)

   レキシカルバインディングは、不定エクステント
(indefinite extent)をもちます。バインディング構造が終了
した後でも、そのレキシカル環境は“クロージャー
(closures)”と呼ばれるLispオブジェクト内に“保持”されます
。クロージャーは、レキシカルバインディングが有効な、名前
つきまたは無名(anonymous)の関数が作成されたときに作成さ
れます。詳細は、*note Closures::を参照してください。

   クロージャーが関数として呼び出されたとき、その関数の
定義内のレキシカル変数にたいする任意の参照は、レキシカル
環境を維持するために使用されます。以下は例です:

     (defvar my-ticker nil)   ; クロージャーを格納するために
                              ; この変数を使用する。

     (let ((x 0))             ; ‘x’はレキシカルにバインドされる。
       (setq my-ticker (lambda ()
                         (setq x (1+ x)))))
         ⇒ (closure ((x . 0) t) ()
               (setq x (1+ x)))

     (funcall my-ticker)
         ⇒ 1

     (funcall my-ticker)
         ⇒ 2

     (funcall my-ticker)
         ⇒ 3

     x                        ; ‘x’はグローバル値をもたないことに注意。
     error→ Symbol's value as variable is void: x

‘let’バインディングは、内部に変数‘x’をもつレキシカル環境
を定義し、これは0にローカルにバインドされます。このバイ
ンディング構造内で、‘x’を1層化し、増加された値をreturnす
るクロージャーを定義しています。このラムダ式は自動的にク
ロージャーになり、たとえ‘let’構造を抜けた後でも、その内
部ではレキシカル環境が存続します。クロージャーを評価する
ときは毎回、レキシカル環境内の‘x’のバインディングが使用
され、‘x’が増加されます。

   ‘symbol-value’、‘boundp’、‘set’のような関数は、変数の
ダイナミックバインディング(つまりそのシンボルの値セル)だ
けを取得(または変更)することに注意してください。
‘defun’(または‘defmacro’)のbody内のコードも、周囲のレキ
シカル変数は参照できません。


File: elisp,  Node: Using Lexical Binding,  Prev: Lexical Binding,  Up: Variable Scoping

11.9.4 Using Lexical Binding
----------------------------

Emacs Lispファイルをロードしたり、Lispバッファーを評価す
るとき、バッファーローカルな変数‘lexical-binding’が非
‘nil’の場合は、レキシカルバインディングが有効になります:

 -- Variable: lexical-binding
     このバッファーローカルな変数が非‘nil’の場合、Emacs
     Lispファイルおよびバッファーは、ダイナミックバイン
     ディングではなくレキシカルバインディングを使用して
     評価されます(しかし、特別な変数はダイナミックにバイ
     ンドされたままです。以下を参照してください)。
     ‘nil’の場合、すべてのローカル変数にたいしてダイナミ
     ックバインディングが使用されます。この変数は通常、
     ファイルローカル変数として、Emacs Lispファイル全体
     にたいしてセットされます(*note File Local
     Variables::を参照してください)。他のファイルローカ
     ル変数などとは異なり、ファイルの最初の行でセットさ
     れなければならないことに注意してください。

‘eval’呼び出しを使用して、Emacs Lispコードを直接評価する
とき、‘eval’のLEXICAL引数が非‘nil’の場合は、レキシカルバ
インディングが有効になります。*note Eval::を参照してくだ
さい。

   レキシカルバインディングが有効な場合でも、特定の変数
はダイナミックにバインドされたままです。これらは“スペシ
ャル変数(special variable)”と呼ばれます。‘defvar’、
‘defcustom’、‘defconst’で定義されたすべての変数は、スペ
シャル変数です(*note Defining Variables::を参照してくだ
さい)。その他のすべての変数はレキシカルバインディングの
対象になります。

 -- Function: special-variable-p symbol
     この関数は、SYMBOLがスペシャル変数(つまり変数が
     ‘defvar’、‘defcustom’、‘defconst’による定義をもつ
     )の場合は非‘nil’をreturnします。それ以外では、
     return値は‘nil’になります。

   関数内での通常の引数としてスペシャル変数を使用するこ
とは、推奨されません。レキシカルバインディングモードが有
効なときにこれを行うと、不定な動作が起こります(あるとき
はレキシカルバインディング、またあるときはダイナミックバ
インディングのように)。

   Emacs Lispプログラムをレキシカルバインディングに変換
するのは簡単です。最初にEmacs Lispソースファイルのヘッダ
ー行で‘lexical-binding’を‘t’して、ファイルローカル変数を
追加します(*note File Local Variables::を参照してくださ
い)。次に、意図せずレキシカルにバインドしてしまわないよ
うに、ダイナミックなバインドをもつ必要がある変数が変数定
義をもつことを、各変数ごとにチェックします。

   どの変数が変数定義をもつ必要があるか見つけるシンプル
な方法は、ソースファイルをバイトコンパイルすることです。
*note Byte Compilation::を参照してください。‘let’フォー
ムの外で非スペシャル変数が使用されている場合、バイトコン
パイラーは“free variable”にたいする参照または割り当てに
ついて警告するでしょう。非スペシャル変数がバインドされて
いるが、‘let’フォーム内で使用されていない場合、バイトコ
ンパイラーは“unused lexical variable”に関して警告するで
しょう。バイトコンパイラーは、スペシャル変数を関数の引数
として使用している場合も、問題を警告します。

   (使用されていない変数についての警告を抑制するためには
、単に変数名をアンダースコアーで開始します。そうすれば、
バイトコンパイラーはこれを、変数が使用されないことを示す
と解釈します。)


File: elisp,  Node: Buffer-Local Variables,  Next: File Local Variables,  Prev: Variable Scoping,  Up: Variables

11.10 Buffer-Local Variables
============================

グローバルおよびボーカルな変数バインディングは、1つの形
式、または別の形式で、ほとんどのプログラミング言語で見つ
けることができます。しかしEmacsは、1つのバッファーだけに
適用される“バッファーローカル(buffer-local)”なバインディ
ングの用に、普通にはない種類の変数バインディングもサポー
トします。ある変数にたいして異なるバッファーごとに別の亜
Q体をもつのは、重要なカスタマイズ方法です(変数は端末ごと
にローカルなバインディングをもつこともできます。*note
Multiple Terminals::を参照してください)。

* Menu:

* Intro to Buffer-Local::    イントロダクションと概念。
* Creating Buffer-Local::    バッファーローカルなバインディングの作成と削除。
* Default Value::            自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。


File: elisp,  Node: Intro to Buffer-Local,  Next: Creating Buffer-Local,  Up: Buffer-Local Variables

11.10.1 Introduction to Buffer-Local Variables
----------------------------------------------

バッファーローカル変数は、特定のバッファーに関連づけられ
た、バッファーローカルなバインディングをもちます。このバ
インディングは、そのバッファーがカレントのときに効果をも
ち、カレントでないときは効果がありません。バッファーロー
カルなバインディングが効力をもつときにその変数をセットし
た場合、そのバインディングは新しい値をもちますが、他のバ
インディングは変更されません。これは、バッファーローカル
なバインディングを作成したバッファーだけで変更が見えるこ
とを意味します。

   その変数にたいする特定のバッファーに関連づけられてい
ない通常のバインディングは、“デフォルトバインディング
(default binding)”と呼ばれます。ほとんどの場合、これはグ
ローバルバインディングです。

   変数は、あるバッファーではバッファーローカルなバイン
ディングをもつことができ、他のバッファーではもたないこと
ができます。デフォルトバインディングは、その変数にたいし
て自身のバインディングをもたない、すべてのバッファーで共
有されます(これには、新たに作成されたバッファーが含まれ
ます)。ある変数にたいしてバッファーローカルなバインディ
ングをもたないバッファーでその変数をセットすると、デフォ
ルトバインディングがセットされるので、それはデフォルトバ
インディングを参照するすべてのバッファーで新しい値を見る
ことができます。

   バッファーローカルなバインディングのもっとも一般的な
使用は、目はーモードがコマンドの動作を制御するために変数
を変更する場合です。たとえばCモードやLispモードは、空行
だけがパラグラフの区切りになるように、変数
‘paragraph-start’をセットします。これらのモードは、Cモー
ドやLispモードになるようなバッファー内でこの変数をバッフ
ァーローカルにすることによりこれを行い、その後そのモード
にたいして新しい値をセットします。*note Major Modes::を
参照してください。

   バッファーローカルなバインディングを作成する通常の方
法は、‘make-local-variable’による方法で、これは通常メジ
ャーモードが使用します。これはカレントバッファーだけに効
果があります。その他すべてのバッファー(まだ作成されてい
ないバッファーを含む)は、それらのバッファー自身が明示的
にバッファーローカルなバインディングを与えられるまで、デ
フォルト値の共有を続けます。

   変数を“自動的にバッファーローカルになる”ようにマーク
する、より強力な操作は、‘make-variable-buffer-local’を呼
び出すことにより行われます。これは、たとえその変数がまだ
作成されていなくても、変数をすべてのバッファーにたいして
ローカルにすると考えることができます。より正確には、変数
を自動的にセットすることにより、その変数がカレントバッフ
ァーにたいしてローカルでなくても、変数をローカルにする効
果があります。すべてのバッファーは最初は通常のようにデフ
ォルト値を共有しますが、この変数をセットすることによりカ
レントバッファーにたいしてバッファーローカルなバインディ
ングを作成します。新たな値はバッファーローカルなバインデ
ィングに格納され、デフォルトバインディングは変更されずに
残ります。これは、任意のバッファーで‘setq’によりデフォル
ト値を変更できないことを意味します。変更する唯一の方法は
、‘setq-default’だけです。

   *警告:* ある変数が1つ以上のバッファーでバッファーロー
カルなバインディングをもつとき、‘let’はそのとき効果をも
つ変数のバインディングをリバインドします。たとえばq、カ
レントバッファーがバッファーローカルな値をもつ場合、
‘let’は一時的にそれをリバインドします。効果をもつバッフ
ァーローカルなバインディングが存在しない場合、‘let’はデ
フォルト値をリバインドします。‘let’の内部で、別のバイン
ディングが効力をもつ別のバッファーをカレントバッファーに
すると、それ以上‘let’バインディングを参照できなくなりま
す。他のバッファーにいる間に‘let’を抜けると、(たとえそれ
が正しくても)バインディングの解消を見ることはできません
。以下にこれを示します:

     (setq foo 'g)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       ;; foo ⇒ 'temp  ; バッファー‘a’内でのletバインディング
       (set-buffer "b")
       ;; foo ⇒ 'g     ; fooは‘b’にたいしてローカルではないためグローバル値
       BODY...)
     foo ⇒ 'g        ; exitによりバッファー‘a’のローカル値が復元されるが、
                      ; バッファー‘b’では見ることができない
     (set-buffer "a") ; ローカル値が復元されたことを確認
     foo ⇒ 'a

BODY内の‘foo’にたいする参照は、バッファー‘b’のバッファー
ローカルなバインディングにアクセスすることに注意してくだ
さい。

   あるファイルがローカル変数の値をセットする場合、これ
らの変数はファイルをvisitするときバッファーローカルな値
になります。*note (emacs)File Variables::を参照してくだ
さい。

   バッファーローカル変数を、端末ローカル
(terminal-local)にすることはできません(*note Multiple
Terminals::を参照してください)。


File: elisp,  Node: Creating Buffer-Local,  Next: Default Value,  Prev: Intro to Buffer-Local,  Up: Buffer-Local Variables

11.10.2 Creating and Deleting Buffer-Local Bindings
---------------------------------------------------

 -- Command: make-local-variable variable
     この関数はカレントバッファー内で、VARIABLE(シンボル
     )にたいして、バッファーローカルなバインディングを作
     成します。他のバッファーは影響を受けません。
     returnされる値は、VARIABLEです。

     VARIABLEのバッファーローカルな値は最初、以前に
     VARIABLEがもっていた値と同じ値をもちます。
     VARIABLEがvoidのときは、voidのままです。

          ;; バッファー‘b1’で行う:
          (setq foo 5)                ; すべてのバッファーに影響する。
               ⇒ 5
          (make-local-variable 'foo)  ; ‘b1’内でローカルになった。
               ⇒ foo
          foo                         ; 値は変更されない。
               ⇒ 5
          (setq foo 6)                ; ‘b1’内で値を変更。
               ⇒ 6
          foo
               ⇒ 6

          ;; バッファー‘b2’では、値は変更されていない。
          (with-current-buffer "b2"
            foo)
               ⇒ 5

     変数を‘let’バインディングでバッファーローカルにして
     も、‘let’への出入り時の両方で、これを行うバッファー
     がカレントでない場合は、信頼性がありません。これは
     ‘let’がバインディングの種類を区別しないからです。
     ‘let’はバインディングを作成される変数だけを知るから
     です。

     変数が端末ローカル(*note Multiple Terminals::を参照
     してください)の場合、この関数はエラーをシグナルしま
     す。そのような変数は、バッファーローカルなバインデ
     ィングをもつことができません。

     *警告:* フック変数にたいして‘make-local-variable’を
     使用しないでください。フック変数は、‘add-hook’また
     は‘remove-hook’のLOCAL引数を使用した場合、必要に応
     じて自動的にバッファーローカルになります。

 -- Macro: setq-local variable value
     このマクロはカレントバッファー内でVARIABLEにたいし
     てバッファーローカルなバインディングを作成して、そ
     れにバッファーローカルな値VALUEを与えます。このマク
     ロは‘make-local-variable’に続けて‘setq’を呼び出すの
     と同じです。VARIABLEはクォートされていないシンボル
     です。

 -- Command: make-variable-buffer-local variable
     このコマンドは、VARIABLE(シンボル)が自動的にバッフ
     ァーローカルになるようにマークするので、それ以降に
     その変数へのセットを試みると、その時点でカレントの
     バッファーにローカルになります。しばしば混乱を招く
     ‘make-local-variable’とは異なり、これが取り消される
     ことはなく、すべてのバッファー内での変数の挙動に影
     響します。

     この機能に特有の欠点は、(‘let’またはその他のバイン
     ディング構造による)変数のバインディングが、その変数
     にたいするバッファーローカルなバインディングを作成
     しないことです。(‘set’または‘setq’による)変数のセッ
     トだけは、その変数がカレントバッファーで作成された
     ‘let’スタイルのバインディングをもたないので、ローカ
     ルなバインディングを作成します。

     VARIABLEがデフォルト値をもたない場合、このコマンド
     の呼び出しは‘nil’のデフォルト値を与えます。
     VARIABLEがすでにデフォルト値をもつ場合、その値は変
     更されずに残ります。それ以降にVARIABLEにたいして
     ‘makunbound’を呼び出すと、バッファーローカル値を
     voidにして、デフォルト値は影響を受けずに残ります。

     return値はVARIABLEです。

     *警告:* ユーザーオプション変数にたいしては、ユーザ
     ーは異なるバッファーにたいして異なるカスタマイズを
     望む_かもしれない_ので、
     ‘make-variable-buffer-local’を使うべきだと決め込む
     べきではありません。ユーザーは、望むなら任意の変数
     をローカルにできます。それらの選択の余地を残すほう
     がよいでしょう。

     ‘make-variable-buffer-local’を使用すべきときは、複
     数のバッファーが同じバインディングを共有しないこと
     が自明な場合です。たとえば、バッファーごとに個別な
     値をもつことに依存するLispプログラム内の内部プロセ
     スにたいして変数が使用されるときは、
     ‘make-variable-buffer-local’の使用が最善の解決策に
     なるかもしれません。

 -- Macro: defvar-local variable value &optional
          docstring
     このマクロはVARIABLEを、初期値VALUEおよび
     DOCSTRINGの変数として定義して、それを自動的にバッフ
     ァーローカルとマークします。これは‘defvar’の後につ
     づけて‘make-variable-buffer-local’を呼び出すのと同
     じです。VARIABLEはクォートされていないシンボルです
     。

 -- Function: local-variable-p variable &optional buffer
     これはVARIABLEがバッファーBUFFER(デフォルトはカレン
     トバッファー)内でバッファーローカルのときは‘t’、そ
     れ以外は‘nil’をreturnします。

 -- Function: local-variable-if-set-p variable &optional
          buffer
     これはVARIABLEがバッファーBUFFER内でバッファーロー
     カル値をもつか、自動的にバッファーローカルになる場
     合は、‘t’をreturnします。それ以外は‘nil’をreturnし
     ます。BUFFERが省略または‘nil’の場合のデフォルトは、
     カレントバッファーです。

 -- Function: buffer-local-value variable buffer
     この関数は、バッファーBUFFER内の、VARIABLE(シンボル
     )のバッファーローカルなバインディングをreturnします
     。VARIABLEがバッファーBUFFER内でバッファーローカル
     なバインディングをもたない場合は、かわりに
     VARIABLEのデフォルト値(*note Default Value::)を
     returnします。

 -- Function: buffer-local-variables &optional buffer
     この関数はバッファーBUFFER内のバッファーローカル変
     数を表すリストをreturnします(BUFFERが省略された場合
     はカレントバッファーが使用されます)。リストの各要素
     は通常、‘(SYM . VAL)’という形式をもちます。ここで
     SYMはバッファーローカル変数(シンボル)、VALはバッフ
     ァーローカル値です。しかしBUFFER内の、ある変数のバ
     ッファーローカルなバインディングがvoidのtきは、その
     変数に対応するリスト要素は単にSYMになります。

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; 最初はすべてのバッファー内でローカルなビルトイン変数:
          ⇒ ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; 次にビルトインでないバッファーローカル変数。
              ;; This one is buffer-local and void:
              foobar
              ;; これはバッファーローカルでvoidではない:
              (bind-me . 69))

     このリスト内のコンスセルのCDRに新たな値を格納しても
     、その変数のバッファーローカル値は変化_しない_こと
     に注意してください。

 -- Command: kill-local-variable variable
     この関数はカレントバッファー内のVARIABLE(シンボル
     )にたいするバッファーローカルなバインディング(もし
     あれば)を削除します。その結果として、このバッファー
     内でVARIABLEのデフォルトバインディングが可視になり
     ます。これは通常、VARIABLEの値を変更します。デフォ
     ルト値は削除されたバッファーローカル値とは異なるの
     が普通だからです。

     セットしたとき自動的にバッファーローカルになる変数
     のバッファーローカルなバインディングをkillした場合
     は、これによりカレントバッファーな意でデフォルト値
     が可視になります。しかし、変数を再度セットすると、
     その変数にたいするバッファーローカルなバインディン
     グが再作成されます。

     ‘kill-local-variable’はVARIABLEをreturnします。

     この関数はコマンドです。なぜなら、バッファーローカ
     ル変数のインタラクティブな作成が有用な場合があるよ
     うに、あるバッファーローカル変数のインタラクティブ
     なkillが有用な場合があるからです。

 -- Function: kill-all-local-variables
     この関数は、“permanent(永続的)”とマークされた変数、
     および‘permanent-local-hook’プロパティーに非‘nil’を
     もつローカルフック関数(*note Setting Hooks::)を除き
     、カレントバッファーのすべてのバッファーローカルな
     バインディングを解消します。結果として、そのバッフ
     ァーはほとんどの変数のデフォルト値を参照するように
     なります。

     この関数は、そのバッファーに関係のあるその他の特定
     の情報もリセットします。これはローカルキーマップ
     (local keymap)を‘nil’、構文テーブル(syntax table)を
     ‘(standard-syntax-table)’の値、大文字小文字テーブル
     (case table)を‘(standard-case-table)’、abbrevテーブ
     ル(abbrev table)を‘fundamental-mode-abbrev-table’の
     値にセットします。

     この関数が1番最初に行うのは、ノーマルフック
     ‘change-major-mode-hook’(以下参照)の実行です。

     各メジャーモードコマンドは、Fundamentalモードにスイ
     ッチする効果をもち、以前のメジャーモードのほとんど
     の効果を消去する、この関数を呼び出すことにより開始
     されます。この関数が処理を行うのを確実にするために
     、メジャーモードがセットする変数はpermanentとマーク
     すべきではありません。

     ‘kill-all-local-variables’ returns ‘nil’.

 -- Variable: change-major-mode-hook
     関数‘kill-all-local-variables’は、何か他のことを行
     う前に、まずこのノーマルフックを実行します。この関
     数はメジャーモードにたいして、ユーザーが他のメジャ
     ーモードにスイッチした場合に行われる、何か特別なこ
     とを準備する方法を与えます。この関数は、ユーザーが
     メジャーモードを変更した場合に忘れられるべき、バッ
     ファー固有のマイナーモードにたいしても有用です。

     最善の結果を得るために、この変数をバッファーローカ
     ルにすれば、処理が終了したときに消えるので、以降の
     メジャーモードに干渉しなくなります。*note Hooks::を
     参照してください。

   変数名(シンボル)が非‘nil’の‘permanent-local’プロパテ
ィーをもつ場合、バッファーローカル変数は“permanent(永続
的)”です。そのような変数は‘kill-all-local-variables’の影
響を受けず、したがってメジャーモードの変更によりそれらの
ローカルバインディングは作成されません。permanentなロー
カル変数は、ファイルの内容を編集する方法などより、どこか
ら読み込んだファイルか、あるいはどのように保存するかとい
ったことに関連するデータに適しています。


File: elisp,  Node: Default Value,  Prev: Creating Buffer-Local,  Up: Buffer-Local Variables

11.10.3 The Default Value of a Buffer-Local Variable
----------------------------------------------------

バッファーローカルなバインディングをもつ変数のグローバル
値も、“デフォルト値(default)”値と呼ばれます。なぜなら、
その変数にたいしてカレントバッファーも選択されたフレーム
もバインディングをもたない場合には、その値が常に効果をも
つからです。

   関数‘default-value’および‘setq-default’は、カレントバ
ッファーがバッファーローカルなバインディングをもつかどう
かに関わらず、その変数のデフォルト値にアクセスまたは変更
します。たとえば、ほとんどのバッファーにたいして、
‘paragraph-start’のデフォルトのセッティングを変更するた
めに、‘setq-default’を使用できます。そして、この変数にた
いするバッファーローカルな値をもつCモードやLispモードに
いるときでさえ、これは機能します。

   スペシャルフォーム‘defvar’および‘defconst’も、バッフ
ァーローカルな値ではなく、(もし変数にセットする場合は)デ
フォルト値をセットします。

 -- Function: default-value symbol
     この関数は、SYMBOLのデフォルト値をreturnします。こ
     れは、この変数にたいして独自の値をもたないバッファ
     ーやフレームから参照される値です。SYMBOLがバッファ
     ーローカルでない場合、これは‘symbol-value’(*note
     Accessing Variables::を参照してください)と同じです
     。

 -- Function: default-boundp symbol
     関数‘default-boundp’は、SYMBOLのデフォルト値が
     voidでないか報告します。‘(default-boundp 'foo)’が
     ‘nil’をreturnした場合、‘(default-value 'foo)’はエラ
     ーになります。

     ‘default-boundp’は‘default-value’んびたいして、
     ‘boundp’は‘symbol-value’にたいする述語です。

 -- Special Form: setq-default [symbol form]...
     このスペシャルフォームは、各SYMBOLに、対応する
     FORMを評価した結果を新たなデフォルト値として与えま
     す。これはSYMBOLを評価しませんが、FORMは評価します
     。‘setq-default’フォームの値は、最後のFORMの値です
     。

     カレントバッファーにたいしてSYMBOLがバッファーロー
     カルでなく、自動的にバッファーローカルにマークされ
     ない場合、‘setq-default’は‘setq’と同じ効果をもちま
     す。カレントバッファーにたいしてSYMBOLがバッファー
     ローカルな場合、これは他のバッファーから参照できる
     値を変更します(それらのバッファーがバッファーローカ
     ルな値をもたない限り)が、それはカレントバッファーか
     ら参照される値ではありません。

          ;; バッファー‘foo’で行う:
          (make-local-variable 'buffer-local)
               ⇒ buffer-local
          (setq buffer-local 'value-in-foo)
               ⇒ value-in-foo
          (setq-default buffer-local 'new-default)
               ⇒ new-default
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ new-default

          ;; (新しい)バッファー‘bar’で行う:
          buffer-local
               ⇒ new-default
          (default-value 'buffer-local)
               ⇒ new-default
          (setq buffer-local 'another-default)
               ⇒ another-default
          (default-value 'buffer-local)
               ⇒ another-default

          ;; バッファー‘foo’に戻って行う:
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ another-default

 -- Function: set-default symbol value
     この関数は‘setq-default’と似ていますが、SYMBOLは通
     常の引数として評価されます。

          (set-default (car '(a b c)) 23)
               ⇒ 23
          (default-value 'a)
               ⇒ 23


File: elisp,  Node: File Local Variables,  Next: Directory Local Variables,  Prev: Buffer-Local Variables,  Up: Variables

11.11 File Local Variables
==========================

ファイルにローカル変数の値を指定できます。そのファイルを
visitしているバッファー内で、これらの変数にたいしてバッ
ファーローカルなバインディングを作成するために、Emacsは
これらを使用します。ファイルローカル変数の基本的な情報に
ついては、*note Local Variables in Files: (emacs)File
Variables.を参照してください。このセクションはファイルロ
ーカル変数が処理される方法に影響する関数と変数を説明しま
す。

   ファイルローカル変数が勝手に関数や、後で呼び出される
Lisp式を指定できる場合、ファイルのvisitによりEmacsが乗っ
取られてしまうかもしれません。Emacsは、指定された値が安
全だと既知のファイルローカル変数だけを自動的にセットする
ことにより、この危険から保護します。これ以外のファイルロ
ーカル変数は、ユーザーが同意した場合のみセットされます。

   追加の安全策として、Emacsがファイルローカル変数を読み
込むとき、一時的に‘read-circle’が‘nil’にバインドされます
(*note Input Functions::を参照してください)。これは
Lispリーダー循環および共有されたLisp構造(*note Circular
Objects::を参照してください)を認識することを防ぎます。

 -- User Option: enable-local-variables
     この変数はファイルローカル変数を処理するかどうかを
     制御します。以下の値が利用できます:

     ‘t’(デフォルト)
          安全な変数をセットして、安全でない変数について
          は問い合わせます(1回)。
     ‘:safe’
          安全な変数だけをセットして、問い合わせはしませ
          ん。
     ‘:all’
          問い合わせをせずに、すべての変数をセットします
          。
     ‘nil’
          変数をセットしません。
     その他
          すべての変数にたいして問い合わせます(1回)。

 -- Variable: inhibit-local-variables-regexps
     これは正規表現のリストです。ファイルがこのリストの
     要素にマッチする名前をもつ場合、任意のファイルロー
     カル変数のフォームはスキャンされません。どんなとき
     にこれを使いたいかの例は、*Note Auto Major Mode::を
     参照してください。

 -- Function: hack-local-variables &optional mode-only
     この関数は、カレントバッファーの内容により指定され
     た任意のローカル変数として、必要に応じてバインドと
     評価を行います。変数‘enable-local-variables’は、こ
     こでも効果をもちます。しかし、この関数は‘-*-’行の、
     ‘mode:’ローカル変数を探しません。‘set-auto-mode’は
     これを行い、‘enable-local-variables’も考慮されます
     (*note Auto Major Mode::を参照してください)。

     この関数は、‘file-local-variables-alist’内に格納さ
     れたalistを調べて、各ローカル変数を順に適用すること
     により機能します。この関数は、変数に適用する前(また
     は後)に、‘before-hack-local-variables-hook’(または
     ‘hack-local-variables-hook’)を呼び出します。alistが
     非‘nil’の場合のみ、事前のフック(before-hook)を呼び
     出し、その他のフックは常に呼び出します。この関数は
     、そのバッファーがすでにもつメジャーモードと同じメ
     ジャーモードが指定された場合には、‘mode’要素を無視
     します。

     オプションの引数MODE-ONLYが非‘nil’の場合、この関数
     が行うのはメジャーモードを指定するシンボルを
     returnするのがすべてで、‘-*-’行またはローカル変数リ
     ストがメジャーモードを指定していればそのモード、そ
     れ以外は‘nil’をreturnします。この関数はモードや他の
     ファイルローカル変数をセットしません。

 -- Variable: file-local-variables-alist
     このバッファーローカルな変数は、ファイルローカル変
     数のセッティングのalistを保持します。alistの各要素
     は‘(VAR . VALUE)’という形式で、VARはローカル変数の
     シンボル、VALUEはその値です。Emacsがファイルを
     visitするとき、最初にすべてのファイルローカル変数を
     このalistに収集して、その後に変数1つずつに関数
     ‘hack-local-variables’を適用します。

 -- Variable: before-hack-local-variables-hook
     Emacsは、‘file-local-variables-alist’に格納されたフ
     ァイルローカル変数を適用する直前に、このフックを呼
     び出します。

 -- Variable: hack-local-variables-hook
     Emacsは、‘file-local-variables-alist’に格納されたフ
     ァイルローカル変数を適用し終えた直後に、このフック
     を呼び出します。

   ある変数にたいして‘safe-local-variable’プロパティーに
より、安全な値を指定できます。このプロパティーは引数を
1つとる関数です。与えられた値にたいして、その関数が非
‘nil’をreturnした場合、その値は安全です。一般的に目にす
るファイル変数の多くは、‘safe-local-variable’プロパティ
ーをもちます。これらのファイル変数には、‘fill-column’、
‘fill-prefix’、‘indent-tabs-mode’が含まれます。ブーリー
ン値の変数にたいしては、プロパティーの値に‘booleanp’を使
用します。

   ‘defcustom’を使用してユーザーオプションを定義するとき
、‘defcustom’に引数‘:safe FUNCTION’を追加することにより
、‘safe-local-variable’プロパティーをセットできます
(*note Variable Definitions::を参照してください)。

 -- User Option: safe-local-variable-values
     この変数は、ある変数の値が安全であることをマークす
     る、別の方法を提供します。これはコンスセル‘(VAR .
     VAL)’のリストで、VARは変数名、VALはその変数にたいし
     て安全な値です。

     Emacsが一連のファイルローカル変数にしたがうかどうか
     ユーザーに尋ねるとき、ユーザーはそれらの変数が安全
     だとマークすることができます。安全だとマークすると
     ‘safe-local-variable-values’にこれらの
     variable/valueペアーが追加され、ユーザーのカスタム
     ファイルに保存します。

 -- Function: safe-local-variable-p sym val
     この関数は、上記の条件に基づき、SYMに値VALを与えて
     も安全な場合は、非‘nil’をreturnします。

   いくつかの変数は“危険(risky)”だと判断されます。ある変
数が危険な場合、その変数が自動的に
‘safe-local-variable-values’に追加されることはありません
。ユーザーが‘safe-local-variable-values’を直接カスタマイ
ズすることにより、明示的に値を許さない限り、危険な変数を
セットする前にEmacsは常に確認を求めます。

   名前が非‘nil’の‘risky-local-variable’プロパティーをも
つ任意の変数は、危険だと判断されます。‘defcustom’を使用
してユーザーオプションを定義するとき、‘defcustom’に引数
‘:risky VALUE’を追加することにより、ユーザーオプションに
‘risky-local-variable’プロパティーをセットできます。それ
に加えて名前が‘-command’、‘-frame-alist’、‘-function’、
‘-functions’、‘-hook’、‘-hooks’、‘-form’、‘-forms’、
‘-map’、‘-map-alist’、‘-mode-alist’、‘-program’、
‘-predicate’で終わる任意の変数は、自動的に危険だと判断さ
れます。後に数字をともなう変数‘font-lock-keywords’および
‘font-lock-keywords’、さらに
‘font-lock-syntactic-keywords’も危険だと判断されます。

 -- Function: risky-local-variable-p sym
     この関数は、SYMが上記の条件にもとづき危険な変数の場
     合は、非非‘nil’をreturnします。

 -- Variable: ignored-local-variables
     この変数はファイルによりローカル値を与えられるべき
     ではない変数のリストを保持します。これらの変数に指
     定された任意の値は、完全に無視されます。

   ‘Eval:’“変数”も抜け道になる可能性があるので、Emacsは
通常、それを処理する前に確認を求めます。

 -- User Option: enable-local-eval
     この変数は‘-*-’行中、またはvisitされるファイル内の
     ローカル変数リストの、‘Eval:’にたいする処理を制御し
     ます。値‘t’は、無条件に実行することを意味します。
     ‘nil’は、それらを無視することを意味します。それ以外
     は、各ファイルにたいして何を行うか、ユーザーに確認
     を求めることを意味します。デフォルト値は、‘maybe’で
     す。

 -- User Option: safe-local-eval-forms
     この変数は、ファイルローカル変数リスト内の
     ‘Eval:’“変数”の中、評価しても安全な式のリストを保持
     します。

   その式が関数呼び出しで、その関数が
‘safe-local-eval-function’プロパティーをもつ場合、そのプ
ロパティー値はその式の評価が安全かどうかを決定します。プ
ロパティー値は、その式をテストするための述語
(predicate)、そのような述語のリスト(成功した述語があれば
安全)、または‘t’(引数が定数である限り常に安全)を指定でき
ます。

   テキストプロパティーは、それらの値に関数呼び出しを含
めることができるので、抜け道になる可能性があります。した
がって、Emacsはファイルローカル変数にたいして指定された
文字列値から、テキストプロパティーを取り除きます。


File: elisp,  Node: Directory Local Variables,  Next: Variable Aliases,  Prev: File Local Variables,  Up: Variables

11.12 Directory Local Variables
===============================

ディレクトリーは、そのディレクトリー内のすべてのファイル
に共通なローカル変数値を指定することができます。Emacsは
、そのディレクトリー内の任意のファイルをvisitしているバ
ッファー内で、それらの変数にたいするバッファーローカルな
バインディングを作成するために、これを使用します。これは
、そのディレクトリー内のファイルが何らかの“プロジェクト
”に属していて、同じローカル変数を共有するときなどに有用
です。

   ディレクトリーローカル変数を指定するために、2つの異な
る方法があります: 1つは特別なファイルにそれを記述する方
法、もう1つはそのディレクトリーに“プロジェクトクラス
(project class)”を定義する方法です。

 -- Constant: dir-locals-file
     この定数は、Emacsがディレクトリーローカル変数が見つ
     けることができる期待する、ファイルの名前です。ファ
     イル名は、‘.dir-locals.el’(1)です。ディレクトリー内
     でその名前をもつファイルにより、Emacsはディレクトリ
     ー内の任意のファイル、または任意のサブディレクトリ
     ー(オプションでサブディレクトリーを除外できます。以
     下を参照してください)にセッティングを適用します。独
     自に‘.dir-locals.el’をもつサブディレクトリーがある
     場合、Emacsはサブディレクトリーで見つかった1番深い
     ファイルのディレクトリーからディレクトリーツリーを
     上方に移動しながら、1番深いファイルのセッティングを
     使用します。このファイルは、ローカル変数をフォーマ
     ットされたリストとして指定します。詳細は、*note
     Per-directory Local Variables: (emacs)Directory
     Variables.を参照してください。

 -- Function: hack-dir-local-variables
     この関数は‘.dir-locals.el’ファイルを読み込み、その
     ディレクトリー内の任意のファイルをvisitしているバッ
     ファーにたいしてローカルな
     ‘file-local-variables-alist’内に、それらを適用する
     ことなくディレクトリーローカル変数を格納します。こ
     の関数はディレクトリーローカルなセッティングも
     ‘dir-locals-class-alist’(‘.dir-locals.el’ファイルが
     見つかったディレクトリーにたいする特別なクラスを定
     義する)内に格納します。この関数は、以下で説明するよ
     うに、‘dir-locals-set-class-variables’および
     ‘dir-locals-set-directory-class’を呼び出すことによ
     り機能します。

 -- Function: hack-dir-local-variables-non-file-buffer
     この関数はディレクトリーローカル変数を探して、即座
     にそれらをカレントバッファーに適用します。これは
     Diredバッファーのような、非ファイルバッファーをディ
     レクトリーローカル変数のセッティングにしたがわせる
     ために、モードコマンド呼び出しの中から呼び出される
     ことを意図したものです。非ファイルバッファーにたい
     しては、Emacsは‘default-directory’と、その親ディレ
     クトリーの中から、ディレクトリーローカル変数を探し
     ます。

 -- Function: dir-locals-set-class-variables class
          variables
     この関数は、CLASSという名前がつけられたシンボルにた
     いして、一連の変数セッティングを定義します。その後
     このクラスを1つ以上のディレクトリーに割り当てること
     ができ、するとEmacsはこれらの変数セッティングを、そ
     れらのディレクトリー内のすべてのファイルに適用しま
     す。VARIABLES内のリストは、2つの形式 — ‘(MAJOR-MODE
     . ALIST)’または‘(DIRECTORY . LIST)’ — のうち1つをも
     つことができます。1番目の形式では、そのファイルのバ
     ッファーがMAJOR-MODEを継承するモードに切り替わると
     きに、連想リストALIST内のすべての変数が適用されます
     。ALISTは、‘(NAME . VALUE)’という形式です。
     MAJOR-MODEにたいする特別な値‘nil’は、そのセッティン
     グが任意のモードに適用できることを意味します。
     ALIST内では、特別なNAMEとして、‘subdirs’を使用する
     ことができます。連想値が‘nil’の場合、alistは関連す
     るディレクトリー内のファイルだけに適用され、それら
     のサブディレクトリーには適用されません。

     VARIABLESの2番目の形式では、DIRECTORYがそのファイル
     のディレクトリーの最初のサブディレクトリーの場合、
     上記のルールにしたがって、LISTが再帰的に適用されま
     す。LISTは、この関数のVARIABLESで指定できる2つの形
     式のうち、1つを指定します。

 -- Function: dir-locals-set-directory-class directory
          class &optional mtime
     この関数は‘directory’およびサブディレクトリー内のす
     べてのファイルにCLASSを割り当てます。その後、
     CLASSにたいして指定されたすべての変数セッティングは
     、DIRECTORYおよびその子ディレクトリー内でvisitされ
     た任意のファイルに適用されます。CLASSは事前に
     ‘dir-locals-set-class-variables’で定義されていなけ
     ればなりません。

     Emacsは、‘.dir-locals.el’ファイルからディレクトリー
     変数をロードするとき、内部的にこの関数を使用します
     。その場合、オプションの引数MTIMEは、ファイルの修正
     日時(modification time。‘file-attributes’により
     returnされる)を保持します。Emacsは、記憶されたロー
     カル変数がまだ有効化チェックするために、この日時を
     使用します。ファイルを通じ手ではなく直接クラスを割
     り当てる場合、この引数は‘nil’になります。

 -- Variable: dir-locals-class-alist
     このalistはクラスシンボル(class symbol)と連想変数セ
     ッティング(associated variable settings)を保持しま
     す。これは‘dir-locals-set-class-variables’により更
     新されます。

 -- Variable: dir-locals-directory-cache
     このalistはディレクトリー名、それらに割り当てられた
     クラス名、およびこのエントリーに関連するディレクト
     リーローカル変数ファイルの修正日時を保持します。関
     数‘dir-locals-set-directory-class’は、このlistを更
     新します。

 -- Variable: enable-dir-local-variables
     ‘nil’の場合、ディレクトリーローカル変数は無視されま
     す。この変数は、ファイルローカル変数(*note File
     Local Variables::を参照してください)にしたがい、デ
     ィレクトリーローカル変数は無視したいモードにたいし
     て有用かもしれません。

   ---------- Footnotes ----------

   (1) MS-DOS版のEmacsは、DOSファイルシステムの制限によ
り、かわりに‘_dir-locals.el’という名前を使用します。


File: elisp,  Node: Variable Aliases,  Next: Variables with Restricted Values,  Prev: Directory Local Variables,  Up: Variables

11.13 Variable Aliases
======================

シノニムとして2つの変数を作成するのが有用なときがありま
す。2つの変数は常に同じ値をもち、、どちらか一方を変更す
ると、もう一方も変更されます。変数の名前を変更 — 古い名
前はよく考慮して選択されたものではなかった、あるいは変数
の意味が部分的に変更された等の理由で — するとき、互換性
のために新しい名前の_エイリアス(alias)_として古い名前を
維持するのが有用なときがあるかもしれません。
‘defvaralias’により、これを行うことができます。

 -- Function: defvaralias new-alias base-variable
          &optional docstring
     この関数はシンボルBASE-VARIABLEのエイリアスとして、
     シンボルNEW-ALIASを定義します。これはNEW-ALIASから
     値を取得すると、BASE-VARIABLEの値がreturnされ、
     NEW-ALIASの値を変更すると、BASE-VARIABLEの値が変更
     されることを意味します。エイリアスされた2つの変数名
     は、常に同じ値と同じバインディングを共有します。

     DOCSTRING引数が非‘nil’の場合、それはNEW-ALIASのドキ
     ュメント文字列を指定します。それ以外では、エイリア
     スは(もしあれば)BASE-VARIABLEと同じドキュメント文字
     列となります。ただし、それはBASE-VARIABLE自体がエイ
     リアスではない場合で、エイリアスの場合、NEW-ALIASは
     エイリアスチェーンの最後の変数のドキュメント文字列
     になります。

     この関数はBASE-VARIABLEをreturnします。

   変数のエイリアスは、変数にたいする古い名前を新しい名
前に置き換える、便利な方法です。
‘make-obsolete-variable’は古い名前を陳腐化(obsolete)して
いると宣言し。それが将来のある時点で削除されるかもしれな
いことを宣言します。

 -- Function: make-obsolete-variable obsolete-name
          current-name when &optional access-type
     この関数は、倍とコンパイラーに変数OBSOLETE-NAMEが陳
     腐化していると警告させます。CURRENT-NAMEがシンボル
     の場合、それはこの変数の新たな名前です。その後、
     OBSOLETE-NAMEのかわりにCURRENT-NAMEを使用するよう、
     警告メッセージを伝えます。CURRENT-NAMEが文字列の場
     合、これはメッセージで、置き換えられる変数はありま
     せん。WHENは、その変数が最初に陳腐化するのがいつか
     を示す文字列です(通常はバージョン番号文字列)。

     オプションの引数ACCESS-TYPEは、非‘nil’の場合は陳腐
     化の警告を引き起こすアクセスの種類を指定します。
     ‘get’または‘set’を指定できます。

   2つの変数シノニムを作成して、マクロ
‘define-obsolete-variable-alias’を使用することにより同時
に1つが陳腐化していると宣言できます。

 -- Macro: define-obsolete-variable-alias obsolete-name
          current-name &optional when docstring
     このマクロは変数OBSOLETE-NAMEが陳腐化しているとマー
     クして、それを変数CURRENT-NAMEにたいするエイリアス
     にします。これは以下と等価です:

          (defvaralias OBSOLETE-NAME CURRENT-NAME DOCSTRING)
          (make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN)

 -- Function: indirect-variable variable
     この関数は、VARIABLEのエイリアスチェーンの最後の変
     数をreturnします。VARIABLEがシンボルでない場合、ま
     たはVARIABLEがエイリアスとして定義されていない場合
     、この関数はVARIABLEをreturnします。

     この関数は、シンボルのチェーンがループしているとき
     は、‘cyclic-variable-indirection’エラーをシグナルし
     ます。

     (defvaralias 'foo 'bar)
     (indirect-variable 'foo)
          ⇒ bar
     (indirect-variable 'bar)
          ⇒ bar
     (setq bar 2)
     bar
          ⇒ 2
     foo
          ⇒ 2
     (setq foo 0)
     bar
          ⇒ 0
     foo
          ⇒ 0


File: elisp,  Node: Variables with Restricted Values,  Next: Generalized Variables,  Prev: Variable Aliases,  Up: Variables

11.14 Variables with Restricted Values
======================================

通常のLisp変数には、有効なLispオブジェクトである任意の値
を割り当てることができます。しかし、LispではなくCで定義
されたLisp変数もあります。これらの変数のほとんどは、
‘DEFVAR_LISP’を使用してCコードで定義されています。Lispで
定義された変数と同様、これらは任意の値をとることができま
す。しかし、いくつかの変数は‘DEFVAR_INT’や
‘DEFVAR_BOOL’を使用して定義されています。C実装の概要的な
議論は、*note Writing Emacs Primitives: Defining Lisp
variables in C.、特にタイプ‘syms_of_FILENAME’の関数の説
明を参照してください。

   タイプが‘DEFVAR_BOOL’の変数は、値に‘nil’か‘t’しかとる
ことができません。他の値の割り当てを試みると、‘t’はセッ
トされます:

     (let ((display-hourglass 5))
       display-hourglass)
          ⇒ t

 -- Variable: byte-boolean-vars
     この変数は、タイプ‘DEFVAR_BOOL’のすべての変数のリス
     トを保持します。

   タイプが‘DEFVAR_INT’の変数は、整数値だけをとることが
できます。他の値の割り当てを試みると、結果はエラーになり
ます:

     (setq undo-limit 1000.0)
     error→ Wrong type argument: integerp, 1000.0


File: elisp,  Node: Generalized Variables,  Prev: Variables with Restricted Values,  Up: Variables

11.15 Generalized Variables
===========================

“ジェネリック変数(generalized variable： 汎変数)”または
“place form”は、値が格納されるLispメモリー内の多くの場所
のうちの1つです。1番シンプルなplace formは、通常のLisp変
数です。しかし、リストのCARとCDR、配列の要素、シンボルの
プロパティー、その他多くのロケーション(location)も、
Lisp値が格納される場所です。

   ジェネリック変数は、C言語の“lvalues(左辺値)”と類似し
ています。C言語のlvalueでは、‘x = a[i]’で配列から要素を
取得し、同じ表記を使用して、‘a[i] = x’で要素を格納します
。‘a[i]’のような特定のフォームが、Cではlvalueになれるよ
うに、Lispでジェネリック変数になることができる一連のフォ
ームが存在します。

* Menu:

* Setting Generalized Variables::  ‘setf’マクロ。
* Adding Generalized Variables::  新たな‘setf’フォームの定義。


File: elisp,  Node: Setting Generalized Variables,  Next: Adding Generalized Variables,  Up: Generalized Variables

11.15.1 The ‘setf’ Macro
------------------------

‘setf’マクロは、ジェネリック変数を操作する、もっとも基本
的な方法です。‘setf’フォームは‘setq’と似ていますが、シン
ボルだけでなく、左辺の任意のplace formを受け入れます。た
とえば‘(setf (car a) b)’は‘a’のcarを‘b’にセットして、
‘(setcar a b)’と同じ操作を行いますが、すべてのplaceのタ
イプにセットおよびアクセスするために2つの別個の関数を覚
える必要はありません。

 -- Macro: setf [place form]...
     このマクロはFORMを評価して、それをPLACEに格納します
     。PLACEは有効なジェネリック変数フォームでなければな
     りません。複数のPLACE/FORMペアーがある場合、割り当
     ては‘setq’のときと同様です。‘setf’は最後のFORMの値
     をreturnします。

   以下のLispフォームはジェネリック変数として機能するの
で、‘setf’のPLACE引数にすることができます:

   • 変数を命名するシンボル。他の言い方をすると、‘(setf
     x y)’は完全に‘(setq x y)’と等しく、厳密に言うと
     ‘setq’自体は‘setf’が存在するので冗長です。これは純
     粋にスタイルと歴史的な理由によりますが、多くのプロ
     グラマーは依然として単純な変数へのセットには
     ‘setq’の方を好みます。マクロ‘(setf x y)’は、実際に
     は‘(setq x y)’に展開されるので、コンパイルされたコ
     ードでこれを使用することにパフォーマンス的な不利は
     ありません。

   • 以下の標準的なLisp関数の呼び出し:

          aref      cddr      symbol-function
          car       elt       symbol-plist
          caar      get       symbol-value
          cadr      gethash
          cdr       nth
          cdar      nthcdr

   • 以下のEmacs特有な関数の呼び出し:

          default-value                 process-get
          frame-parameter               process-sentinel
          terminal-parameter            window-buffer
          keymap-parent                 window-display-table
          match-data                    window-dedicated-p
          overlay-get                   window-hscroll
          overlay-start                 window-parameter
          overlay-end                   window-point
          process-buffer                window-start
          process-filter

どのように処理すれば良いか知られていないPLACEフォームを
渡した場合、‘setf’はエラーをシグナルします。

   ‘nthcdr’の場合、関数のリスト引数は、それ自体が有効な
PLACEフォームでなければならないことに注意してください。
たとえば、‘(setf (nthcdr 0 foo) 7)’は、‘foo’自体に7をセ
ットするでしょう。

   マクロ‘push’(*note List Variables::を参照してください
)、および‘pop’(*note List Elements::を参照してください
)は、リストだけでなくジェネリック変数を操作できます。
‘(pop PLACE)’は、PLACE内に格納されたリストの最初の要素を
削除してreturnします。これは‘(prog1 (car PLACE) (setf
PLACE (cdr PLACE)))’と類似していますが、すべてのサブフォ
ームを1度だけ評価します。‘(push X PLACE)’は、PLACE内に格
納されたリストの1番前に、Xを挿入します。これは‘(setf
PLACE (cons X PLACE))’と類似していますが、サブフォームの
評価を除きます。‘nthcdr’ placeへの‘push’および‘pop’は、
リスト内の任意の位置での挿入および削除に使用できることに
注意してください。

   ‘cl-lib’ライブラリーは、追加の‘setf’ placeを含む、ジ
ェネリック変数ニタイスルサマザマナ拡張を定義します。
*note (cl)Generalized Variables::を参照してください。


File: elisp,  Node: Adding Generalized Variables,  Prev: Setting Generalized Variables,  Up: Generalized Variables

11.15.2 Defining new ‘setf’ forms
---------------------------------

このセクションでは、‘setf’が操作できる新たなフォームを定
義する方法を説明します。

 -- Macro: gv-define-simple-setter name setter &optional
          fix-return
     このマクロは、単純なケースにたいして‘setf’メソッド
     を簡単に定義することを可能にします。NAMEは、関数、
     マクロ、スペシャルフォームの名前です。NAMEが、それ
     を更新するための対応するSETTER関数をもつときは、こ
     のマクロを使用できます(たとえば
     ‘(gv-define-simple-setter car setcar)’)。

     このマクロをフォーム以下の呼び出しを

          (setf (NAME ARGS...) VALUE)

     以下のように変換します。
          (SETTER ARGS... VALUE)

     ‘setf’のような呼び出しは、VALUEをreturnするようにド
     キュメントされます。これに問題はありません。たとえ
     ば‘car’と‘setcar’では、‘setcar’はそれがセットする値
     をreturnするからです。SETTER関数がVALUEをreturnしな
     い場合は、‘gv-define-simple-setter’のFIX-RETURN引数
     に、非‘nil’値を使用してください。これは以下のような
     ものに展開されます
          (let ((temp VALUE))
            (SETTER ARGS... temp)
            temp)
     これで正しい結果がreturnされることが保証されます。

 -- Macro: gv-define-setter name arglist &rest body
     このマクロは、上述のフォームより複雑な‘setf’展開を
     可能にします。たとえば、呼び出すべきシンプルな
     setter関数が存在しないときや、もしそれが存在しても
     place formとは異なる引数を要求する場合には、このフ
     ォームを使う必要があるかもしれません。

     このマクロは最初に‘setf’引数フォーム‘(VALUE
     ARGS...)’をARGLISTにバインドして、その後BODYを実行
     することにより、フォーム‘(setf (NAME ARGS...)
     VALUE)’を展開します。BODYは割り当てを行うLispフォー
     ムをreturnし、最後にセットされた値をreturnするべき
     です。以下はこのマクロの使用例です:

          (gv-define-setter caar (val x) `(setcar (car ,x) ,val))

   展開をさらに制御するには、マクロ
‘gv-define-expander’を参照してください。マクロ
‘gv-letplace’は、‘setf’のように処理を行うマクロを定義す
るのに有用です。詳細は、‘gv.el’のソースファイルを参照し
てください。

     Common Lispに関する注意: Common Lispは関数の
     ‘setf’、すなわち“‘setf’関数”の挙動を指定するための
     別の方法を定義します。‘setf’関数の名前はシンボルで
     はなく。リスト‘(setf NAME)’です。たとえば‘(defun
     (setf foo) ...)’は、‘setf’が‘foo’に適用されるときに
     使用される関数を定義します。Emacsはこれをサポートし
     ません。適切な展開が定義されていないフォームに
     ‘setf’を使用すると、コンパイル時にエラーとなります
     。Common Lispでは、関数‘(setf FUNC)’が後で定義され
     るので、エラーにはなりません。


File: elisp,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

12 Functions
************

Lispプログラムは主にLisp関数で構成されます。このチャプタ
ーは、関数とは何か、引数を受け取る方法、関数を定義する方
法を説明します。

* Menu:

* What Is a Function::       Lisp関数 vs. プリミティブ;
                               専門用語。
* Lambda Expressions::       関数がLispオブジェクトとして表現される方法。
* Function Names::           シンボルは関数を名づける役割を果たすことができる。
* Defining Functions::       関数定義のためのLisp式。
* Calling Functions::        既存の関数を使う方法。
* Mapping Functions::        リストの各要素などに関数を適用する。
* Anonymous Functions::      ラムダ式、それは無名の関数。
* Function Cells::           シンボルの関数定義へのアクセスとセット。
* Closures::                 レキシカル環境に囲まれた関数。
* Advising Functions::       関数の定義への追加。
* Obsolete Functions::       関数を陳腐と宣言する。
* Inline Functions::         コンパイラーによりインライン展開される関数。
* Declare Form::             関数についての補足的な情報の追加。
* Declaring Functions::      関数が定義されていることをコンパイラーに知らせる。
* Function Safety::          呼び出しても安全な関数なのか判断する。
* Related Topics::           関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。


File: elisp,  Node: What Is a Function,  Next: Lambda Expressions,  Up: Functions

12.1 What Is a Function?
========================

一般的な意味では、関数とは“引数(arguments)”と呼ばれる与
えられた入力値の計算を担うルールです。計算の結果は、その
関数の“値(value)”、または“return値(return value)”と呼ば
れます。計算は、変数の値やデータ構造の内容を変更する等の
副作用をもつこともできます。

   ほとんどのコンピューター言語では、関数はそれぞれ名前
をもちます。しかしLispでは、厳密な意味において、関数は名
前をもちません。関数はオブジェクトであり、関数の名前の役
割を果たすシンボルに関連づけることができますが(たとえば
‘car’)、それは_オプション_です。*note Function Names::を
参照してください。関数が名前を与えられたとき、通常はその
シンボルを“関数”として参照します(たとえば、関数‘car’のよ
うに参照します)。このマニュアルでは、関数名と関数オブジ
ェクト自身との間の区別は、通常は重要ではありませんが、そ
れが意味をもつような場合は注記します。

   “スペシャルフォーム(special form)”、“マクロ(macro)”と
呼ばれる、関数likeなオブジェクトがいくつかあり、それらも
引数を受け受け、計算を担います。しかし以下で説明するよう
に、Emacs Lispではこれらは関数とは考えられません。

   以下は関数および関数likeなオブジェクトにたいする、重
要な条件です:

“lambda expression”
     Lispで記述された関数(厳密には関数オブジェクト)です
     。これらについては、以降のセクションで説明します。
     *note Lambda Expressions::を参照してください。

“primitive”
     Lispから呼び出すことができますが、実際にはCで記述さ
     れています。プリミティブは、“ビルトイン関数
     (built-in functions)”や、“サブルーチン(subr)”といっ
     た呼ばれかたもします。それらの例には関数likeな
     ‘car’や‘append’が含まれます。加えて、すべてのスペシ
     ャルフォーム(以下参照)もプリミティブと考えられます
     。

     関数はLispの基礎となる部分(たとえば‘car’)であり、オ
     ペレーティングシステムのサービスにたいして値レベル
     のインターフェースを与え、高速に実行される必要があ
     るため、通常はプリミティブとして実装されています。
     Lispで定義された関数とは異なり、プリミティブの修正
     や追加には、Cソースの変更とEmacsのリコンパイルが必
     要です。*note Writing Emacs Primitives::を参照して
     ください。

“special form”
     プリミティブは関数と似ていますが、すべての引数が通
     常の方法で評価はされません。いくつかの引数だけが評
     価されるかもしれず、通常ではない順序で、複数回評価
     されるかもしれません。プリミティブの例には、‘if’、
     ‘and’、‘while’が含まれます。*note Special Forms::を
     参照してください。

“macro”
     あるLisp式を、オリジナルの式のかわりに評価される別
     の式に変換する、関数とは別のLispで定義された構造で
     す。マクロは、スペシャルフォームが行う一連のことを
     、Lispプログラマーが行うのを可能にします。*note
     Macros::を参照してください。

“command”
     ‘command-execute’プリミティブを通じて呼び出すことが
     できるオブジェクトで、通常はそのコマンドに“バインド
     ”されたキーシーケンスを、ユーザーがタイプすることに
     より呼び出されます。*note Interactive Call::を参照
     してください。コマンドは通常、関数です。その関数が
     Lispで記述されている場合は、関数の定義内の
     ‘interactive’フォームによりコマンドとなります(*note
     Defining Commands::を参照してください)。関数である
     コマンドは、他の関数と同様、Lisp式から呼び出すこと
     もできます。

     キーボードマクロ(文字列およびベクター)は関数ではあ
     りませんが、これらもコマンドです。*note Keyboard
     Macros::を参照してください。シンボルの関数セルにコ
     マンドが含まれている場合、わたしたちはそのシンボル
     をコマンドと言います(*note Symbol Components::を参
     照してください)。そのような“名前つきコマンド(named
     command)”は、‘M-x’で呼び出すことができます。

“closure”
     ラムダ式とよく似た関数オブジェクトですが、クロージ
     ャーはレキシカル変数バインディングの“環境”にも囲ま
     れています。*note Closures::を参照してください。

“byte-code function”
     バイトコンパイラーによりコンパイルされた関数です。
     *note Byte-Code Type::を参照してください。

“autoload object”
     実際の関数のプレースホルダーです。autoloadオブジェ
     クトが呼び出された場合、Emacsは実際の関数の定義を含
     むファイルをロードした後、実際の関数を呼び出します
     。*note Autoload::を参照してください。

   関数‘functionp’を使用して、あるオブジェクトが関数かど
うかテストできます:

 -- Function: functionp object
     この関数はOBJECTが任意の種類の関数(たとえば
     ‘funcall’に渡すことができる)の場合は、‘t’をreturnし
     ます。‘functionp’は関数を名づけるシンボルにたいして
     は‘t’、スペシャルフォームにたいしては‘nil’を
     returnすることに注意してください。

‘functionp’とは異なり、以下の3つの関数は、シンボルをそれ
の関数定義としては扱い_ません_。

 -- Function: subrp object
     この関数は、OBJECTがビルトイン関数(たとえばLispプリ
     ミティブ)の場合は、‘t’をreturnします。

          (subrp 'message)            ; ‘message’はシンボルであり、
               ⇒ nil                 ;   subrオブジェクトではない。
          (subrp (symbol-function 'message))
               ⇒ t

 -- Function: byte-code-function-p object
     この関数は、OBJECTがバイトコード関数の場合は、‘t’を
     returnします。たとえば:

          (byte-code-function-p (symbol-function 'next-line))
               ⇒ t

 -- Function: subr-arity subr
     この関数はプリミティブSUBRの引数リストについての情
     報を提供します。retrun値は、‘(MIN . MAX)’というペア
     ーです。MINは引数の最小数です。MAXは最大数、または
     引数‘&rest’を伴う関数にたいしてはシンボル‘many’、
     SUBRがスペシャルフォームの場合はシンボル
     ‘unevalled’です。


File: elisp,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

12.2 Lambda Expressions
=======================

ラムダ式(lambda expression)は、Lispで記述された関数オブ
ジェクトです。以下は例です:

     (lambda (x)
       "Xの双曲線コサインをreturnする。"
       (* 0.5 (+ (exp x) (exp (- x)))))

Emacs Lispでは、このようなリストは、関数オブジェクトに評
価される、有効な式です。

   ラムダ式自身は名前をもたない、“無名関数(anonymous
function)”です。ラムダ式をこの方法で使用できますが(*note
Anonymous Functions::を参照してください)、“名前付き関数
(named functions)”を作成するためにシンボルに関連付けられ
る方が一般的です(*note Function Names::)。これらの詳細に
触れる前に、以下のサブセクションではラムダ式の構成要素と
、それらが行うことについて説明します。

* Menu:

* Lambda Components::        ラムダ式のパーツ。
* Simple Lambda::            シンプルな例。
* Argument List::            引数リストの詳細と特別な機能。
* Function Documentation::   関数内にドキュメントを記述する方法。


File: elisp,  Node: Lambda Components,  Next: Simple Lambda,  Up: Lambda Expressions

12.2.1 Components of a Lambda Expression
----------------------------------------

ラムダ式は、以下のようなリストです:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

   ラムダ式の1番目の要素は常にシンボル‘lambda’です。これ
は、そのリストが関数を表すことを示します。‘lambda’で関数
定義を開始する理由は、他の目的のたまえの使用が意図された
他のリストが、意図せず関数として評価されないようにするた
めです。

   2番目の要素は、シンボル — 引数変数名のリストです。こ
れは“ラムダリスト(lambda list)”と呼ばれます。Lisp関数が
呼び出されたとき、引数値はラムダリスト内の変数と対応付け
されます。ラムダリストは、与えられた値にたいするローカル
バインディングが付与されます。*note Local Variables::を
参照してください。

   ドキュメント文字列(documentation string)はEmacs Lispの
ヘルプ機能にたいしてその、関数を説明する、関数定義に配さ
れたLisp文字列オブジェクトです。*note Function
Documentation::を参照してください。

   インタラクティブ宣言(interactive declaration)は、
‘(interactive CODE-STRING)’という形式のリストです。これ
は、この関数が対話的に使用された場合に引数を提供する方法
を宣言します。この宣言をもつ関数は、“コマンド
(command)”と呼ばれます。コマンドは‘M-x’を使用したり、キ
ーにバインドして呼び出すことができます。この方法で呼び出
されることを意図しない関数は、インタラクティブ宣言を持つ
べきではありません。インタラクティブ定義を記述する方法は
、*Note Defining Commands::を参照してください。

   残りの要素は、その関数の“body(本体)” — その関数が処理
を行うためのLispコード(Lispプログラマーは“評価される
Lispフォームのリスト”と言うでしょう)です。この関数から
returnされる値は、bodyの最後の要素によりreturnされる値で
す。


File: elisp,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

12.2.2 A Simple Lambda Expression Example
-----------------------------------------

以下の例を考えてみてください:

     (lambda (a b c) (+ a b c))

以下のように、‘funcall’に渡すことにより、この関数を呼び
出すことができます:

     (funcall (lambda (a b c) (+ a b c))
              1 2 3)

この呼び出しは、変数‘a’に1、‘b’に2、‘c’に3をバインドして
、ラムダ式のbodyを評価します。bodyの評価により、これら
3つの数が加算されて、6が結果として生成されます。したがっ
てこの関数呼び出しにより、6がreturnされます。

   以下のように、引数は他の関数の結果であってもよいこと
に注意してください:

     (funcall (lambda (a b c) (+ a b c))
              1 (* 2 3) (- 5 4))

これは引数‘1’、‘(* 2 3)’、‘(- 5 4)’を左から右に評価しま
す。その後、ラムダ式に引数1、6、1を適用して、値8が生成さ
れます。

   これらの例が示すように、ローカル変数を作成して、それ
らに値を与えるフォームとして、CARがラムダ式であるような
フォームを使用することができます。古い時代のLispでは、こ
の方法がローカル変数をバインドして初期化する唯一の方法で
した。しかし現在では、この目的にはフォーム‘let’を使用す
るほうが明解です(*note Local Variables::を参照してくださ
い)。ラムダ式は主に、他の関数の引数として渡される無名関
数(*note Anonymous Functions::を参照してください)として
、あるいは名前つき関数(*note Function Names::を参照して
ください)を生成するためにシンボルの関数定義に格納するた
めに使用されます。


File: elisp,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

12.2.3 Other Features of Argument Lists
---------------------------------------

シンプルなサンプル関数‘(lambda (a b c) (+ a b c))’は、
3つの引数変数を指定しているので、3つの引数で呼び出されな
ければなりません。引数を2つしか指定しなかったり4つ指定し
た場合は、‘wrong-number-of-arguments’エラーとなります。

   特定の引数を省略できる関数を記述できると便利なことも
あります。たとえば関数‘substring’は3つの引数 — 文字列、
開始インデックス、終了インデックス — を受け取りますが、
3つ目の引数を省略した場合、デフォルトでその文字列の
LENGTHとなります。関数‘list’や‘+’が行うように、特定の関
数にたいして不定個の引数を指定できると便利なときもありま
す。

   関数が呼び出されるとき省略されるかもしれないオプショ
ンの引数を指定するには、オプションの引数の前にキーワード
‘&optional’を含めるだけです。0個以上の追加引数のリストを
指定するには、最後の引数の前にキーワード‘&rest’を含めま
す。

   したがって、引数リストの完全な構文は以下のようになり
ます:

     (REQUIRED-VARS...
      [&optional OPTIONAL-VARS...]
      [&rest REST-VAR])

角カッコ(square bracket)は、‘&optional’と‘&rest’、および
それらに続く変数が省略できることを示します。

   この関数の呼び出しには、REQUIRED-VARSのそれぞれにたい
して、実際の引数が要求されます。0個以上のOPTIONAL-VARSに
たいして実際の引数があるかもしれませんが、ラムダ式が
‘&rest’を使用していなければ、その個数を超えて実際の引数
を記述することはできません。‘&rest’が記述されている場合
、追加で任意個の実際の引数があるかもしれません。

   optionaやrest変数にたいして実際の引数が省略された場合
、それらのデフォルトは常に‘nil’になります。関数にたいし
て引数に明示的に‘nil’が使用されたのか、引数が省略された
のかを区別することはできません。しかし関数のbodyが、
‘nil’を他の有意な値が省略されたと判断することは自由です
。これは‘substring’が行っていることです。‘substring’の
3つ目の引数が‘nil’の場合、それは文字列の長さを使用するこ
とを意味します。

     Common Lispに関する注意: Common Lispでは、オプショ
     ンの引数が省略されたときに使用するデフォルト値を指
     定できます。Emacs Lispは、引数が明示的に渡されたか
     を調べる、“supplied-p”変数はサポートしません。

   例えば、引数リストは以下のようになります:

     (a b &optional c d &rest e)

これは‘a’と‘b’は最初の2つの実引数となり、これらは必須で
す。さらに1つまたは2つの引数が指定された場合、それらは順
番に‘c’と‘d’にバインドされます。1つ目から4つ目の引数の後
の引数は、リストにまとめられて、‘e’にそのリストがバイン
ドされます。2つしか引数が指定されなかった場合、‘c’は
‘nil’になります。2つまたは3つの引数の場合、‘d’は‘nil’で
す。引数が4つ以下の場合、‘e’は‘nil’になります。

   オプションの引数の後ろに必須の引数を指定する方法はあ
りません — これは意味を成さないからです。なぜそうなるか
は、この例で‘c’がオプションで‘d’が必須な場合を考えてみて
ください。実際に3つの引数が与えられたとします。3番めの引
数は何を指定したのでしょうか? この引数はCなのでしょうか
、それともDに使用されるのでしょうか? 両方の場合が考えら
れます。同様に、‘&rest’引数の後に、さらに引数(必須または
オプション)をもつことも意味を成しません。

   以下に引数リストと、それを正しく呼び出す例をいくつか
示します:

     (funcall (lambda (n) (1+ n))        ; 1つの必須:
              1)                         ; これは正確に1つの引数を要求する。
          ⇒ 2
     (funcall (lambda (n &optional n1)   ; 1つは必須で、1つはオプション:
                (if n1 (+ n n1) (1+ n))) ; 1つまたは2つの引数。
              1 2)
          ⇒ 3
     (funcall (lambda (n &rest ns)       ; 1つは必須で、後は残り:
                (+ n (apply '+ ns)))     ; 1つ以上の引数。
              1 2 3 4 5)
          ⇒ 15


File: elisp,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

12.2.4 Documentation Strings of Functions
-----------------------------------------

ラムダ式は、ラムダリストの食後に、オプションで“ドキュメ
ント文字列(documentation string)”をもつことができます。
この文字列は、その関数の実行に影響を与えません。これはコ
メントの一種ですが、Lisp機構に内在するシステム化されたコ
メントであり。Emacsのヘルプ機能で使用できます。ドキュメ
ント文字列にアクセスする方法は、*note Documentation::を
参照してください。

   たとえその関数があなたのプログラム内だけで呼び出され
る関数だとしても、すべての関数にドキュメント文字列を与え
るのはよいアイデアです。ドキュメント文字列はコメントと似
ていますが、コメントより簡単にアクセスできます。

   ドキュメント文字列の1行目は、関数自体にもとづくもので
あるべきです。なぜなら‘apropos’は、最初の1行目だけを表示
するからです。ドキュメント文字列の1行目は、その関数の目
的を要約する、1つまたは2つの完全なセンテンスで構成される
べきです。

   ドキュメント文字列の開始は通常、ソースファイル内では
インデントされていますが、ドキュメント文字列の開始のダブ
ルクォート文字の前にインデントのスペースがあるので、イン
デントはドキュメント文字列の一部にはなりません。ドキュメ
ント文字列の残りの行がプログラムソース内で揃うようにイン
デントする人がいます。_これは、間違いです。_後続の行のイ
ンデントは文字列の内部にあります。これはソースコード内で
の見栄えはよくなりますが、ヘルプコマンドで表示したとき見
栄えが悪くなります。

   ドキュメント文字列がなぜオプションになるのか不思議に
思うかもしれません。なぜなら、ドキュメント文字列の後には
必須となる関数の構成要素であるbodyが続くからです。文字列
を評価するとその文字列自身がれつｒｎされるので、それが
body内の最後のフォームでない限りなんの効果もありません。
したがって、実際はbodyの1行目とドキュメント文字列で混乱
が生じることはありません。bodyの唯一のフォームが文字列の
場合、それはreturn値とドキュメントの両方の役目を果たしま
す。

   ドキュメント文字列の最後の行には、実際の関数引数とは
異なる呼び出し規約を指定できます。これは以下のようなテキ
ストを記述します

     \(fn ARGLIST)

ただし、このテキストの前に空行があり、テキスト自身が行頭
から記述されていて、ドキュメント文字列内でこのテキストの
後に改行が続かない場合です(‘\’はEmacsの移動コマンドが混
乱するのを避けるために使用されます)。この方法で指定され
た呼び出し規約は、ヘルプメッセージ内で関数の実引数から生
成される呼び出し例と同じ場所に表示されます。

   マクロ定義内に記述された引数は、ユーザーがマクロ呼び
出しの一部だと考える方法と合致しない場合がしばしばあるの
で、この機能はマクロ定義で特に有用です。


File: elisp,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

12.3 Naming a Function
======================

シンボルは関数の名前となることができます。これは、そのシ
ンボルの“関数セル(function cell”: *note Symbol
Components::を参照してください)が、関数オブジェクト(たと
えばラムダ式)を含むときに起こります。するとそのシンボル
自身が呼び出し可能な有効な関数、つまりそのシンボルの関数
セルの関数と等価になります。

   関数セルの内容は、そのシンボルの“関数定義(function
definition)”と呼ぶこともできます。そのシンボルのかわりに
、シンボルの関数定義を使う手続きのことを“シンボル関数イ
ンダイレクション(symbol function indirection)”と呼びます
。*note Function Indirection::を参照してください。与えら
れたシンボルに関数定義がない場合、シンボルの関数セルは
“void”と呼ばれ、それを関数として使用することはできません
。

   実際のところ、ほとんどすべての関数は名前をもち、その
名前により参照されます。ラムダ式を定義することにより名前
つきのLisp関数を作成、それを関数セル(*note Function
Cells::を参照してください)に置くことができます。しかし、
さらに一般的なのは‘defun’スペシャルフォーム(次のセクショ
ンで説明します)を使う方法です。 *note Defining
Functions::を参照してください。

   わたしたちは関数名を与えるのは、Lisp式内で関数を名前
で参照するのが便利だからです。また、名前つきの関数は簡単
に自分自身を —再帰的(recursive)に参照することができます
。さらに、プリミティブはテキスト的な名前だけで参照するこ
とができます。なぜならプリミティブ関数は入力構文(read
syntax)をもたないオブジェクトだからです(*note Primitive
Function Type::を参照してください)。

   関数は一意な名前をもつ必要はありません。与えられた関
数オブジェクトは、_通常_は1つのシンボルの関数セルだけに
存在しますが、これは単に慣習的なものです。‘fset’を使用し
て、関数を複数のシンボルに格納するのは簡単です。それらの
シンボルはそれぞれ、同じ関数にたいする有効な名前となりま
す。

   関数として使用されているシンボルを、変数としても利用
できることに注意してください。シンボルのこれら2つの利用
法は独立しており、競合はしません(これはSchemaのような他
のいくつかのLisp方言には当てはまりません)。


File: elisp,  Node: Defining Functions,  Next: Calling Functions,  Prev: Function Names,  Up: Functions

12.4 Defining Functions
=======================

わたしたちは通常、関数を最初に作成したときに名前を与えま
す。これは“関数の定義(defining a function)”と呼ばれ、
‘defun’マクロにより行われます。

 -- Macro: defun name args [doc] [declare] [interactive]
          body...
     ‘defun’は新たなLisp関数を定義する通常の方法です。こ
     れは、引数リストARGS、およびBODYにより与えられる
     bodyフォームとともに、シンボルNAMEを関数として定義
     します。NAMEとARGSを、クォートする必要はありません
     。

     DOCが与えられた場合、それはその関数のドキュメント文
     字列を指定する文字列であるべきです(*note Function
     Documentation::を参照してください)。DECLAREが与えら
     れた場合、それは関数のメタデータを指定する、
     ‘declare’フォームであるべきです(*note Declare
     Form::を参照してください)。INTERACTIVEが与えられた
     場合、それは関数が対話的に呼び出される方法を指定す
     る‘interactive’フォームであるべきです(*note
     Interactive Call::を参照してください)。

     ‘defun’のreturn値は定義されていません。

     以下にいくつか例を示します:

          (defun foo () 5)
          (foo)
               ⇒ 5

          (defun bar (a &optional b &rest c)
              (list a b c))
          (bar 1 2 3 4 5)
               ⇒ (1 2 (3 4 5))
          (bar 1)
               ⇒ (1 nil nil)
          (bar)
          error→ Wrong number of arguments.

          (defun capitalize-backwards ()
            "Upcase the last letter of the word at point."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

     意図せず既存の関数を再定義しないように、注意してく
     ださい。‘defun’は‘car’のようなプリミティブ関数でさ
     え、躊躇なく問い合わせもなしに再定義します。Emacsが
     がががこれを妨げることはありません。なぜなら関数の
     再定義は故意に行われることがあり、そのような意図し
     た再定義を、意図しない再定義と見分ける方法はないか
     らです。

 -- Function: defalias name definition &optional doc
     この関数は、定義DEFINITION(任意の有効なLisp関数)と
     ともに、シンボルNAMEを関数として定義します。この関
     数のreturn値は_未定義_です。

     DOCが非‘nil’の場合、それは関数NAMEのドキュメントに
     なります。それ以外は、DEFINITIONにより提供されるド
     キュメントが使用されます。

     内部的には、‘defalias’は通常、定義のセットに
     ‘fset’を使用します。しかしNAMEが
     ‘defalias-fset-function’プロパティーをもつ場合、
     ‘fset’を呼び出すかわりに、それに割り当てられた値が
     使用されます。

     ‘defalias’を使う正しい場所は、特定の関数名がまさに
     定義される場所 — 特にソースファイルがロードされると
     き明示的にその名前が出現する場所です。これは
     ‘defalias’が、‘defun’と同じように、どれが関数を定義
     するファイルなのか記録するからです(*note
     Unloading::を参照してください)。

     それとは対象的に、他の目的のために関数を操作するプ
     ログラムでは、そのような記録を保持しない‘fset’を使
     用するほうがよいでしょう。*note Function Cells::を
     参照してください。

   ‘defun’や‘defalias’で新たなプリミティブ関数を作成する
ことはできませんが、任意の関数定義を変更するのに使用する
ことができ、通常の定義がプリミティブである‘car’や
‘x-popup-menu’のような関数でさえ変更することができます。
しかし、これは危険なことです。たとえば、Lispの完全性を損
なうことなく、‘car’を再定義するのはほとんど不可能だから
です。それほど有名ではない‘x-popup-menu’のような関数の再
定義では、危険は減るものの、それでも期待したとおりに機能
しないかもしれません。Cコードにこのプリミティブの呼び出
しがある場合、それは直接そのプリミティブのC定義を呼び出
すので、シンボル定義を変更しても、それらに影響はありませ
ん。

   ‘defsubst’も参照してください。これは‘defun’のように関
数を定義して、それのインライン展開を処理するようLispコン
パイラーに指示します。*note Inline Functions::を参照して
ください。


File: elisp,  Node: Calling Functions,  Next: Mapping Functions,  Prev: Defining Functions,  Up: Functions

12.5 Calling Functions
======================

関数を定義しただけでは、半分しか終わっていません。関数は
それを“呼び出す(call)” — たとえば実行(run)するまでは、何
も行いません。関数のcallは、“invocation”としても知られて
います。

   関数を呼び出すもっとも一般的な方法は、リストの評価に
よる方法です。たとえば、リスト‘(concat "a" "b")’を評価す
ることにより、関数‘concat’が引数‘"a"’と‘"b"’で呼び出され
ます。評価については、*note Evaluation::を参照してくださ
い。

   プログラム内で式としてリストを記述するときは、プログ
ラム内にテキストで、どの関数を呼び出すか、いくつの引数を
与えるかを指定します。通常は、これが行いたいことです。ど
の関数を呼び出すかを、実行時に計算する必要がある場合もあ
ります。これを行うには、関数‘funcall’を使用します。実行
時にいくつの引数を渡すか決定する必要があるときは、
‘apply’を使用します。

 -- Function: funcall function &rest arguments
     ‘funcall’は、関数FUNCTIONを引数ARGUMENTSで呼び出し
     、FUNCTIONがreturnした値をreturnします。

     ‘funcall’は関数なので、FUNCTIONを含むすべての引数は
     、‘funcall’の呼び出し前に評価されます。これは、呼び
     出される関数を得るための任意の式を使用できることを
     意味します。これはまた、‘funcall’がARGUMENTSに記述
     した式ではなく、その値だけを見ることを意味します。
     これらの値はFUNCTION呼び出し中では、2回目は評価_さ
     れません_。‘funcall’の処理は、関数の通常の呼び出し
     手続きと似ており、すでに評価された引数は評価されま
     せん。

     引数FUNCTIONは、Lisp関数、またはプリミティブ関数で
     なければなりません。つまりスペシャルフォームやマク
     ロは、“評価されていない”引数式を与えられたときだけ
     意味があるので、指定することはできません。上述した
     ように、‘funcall’は最初に指定された評価前の引数を提
     供することはできません。

          (setq f 'list)
               ⇒ list
          (funcall f 'x 'y 'z)
               ⇒ (x y z)
          (funcall f 'x 'y '(z))
               ⇒ (x y (z))
          (funcall 'and t nil)
          error→ Invalid function: #<subr and>

     これらの例を、‘apply’の例と比較してみてください。

 -- Function: apply function &rest arguments
     ‘apply’は、関数FUNCTIONを引数ARGUMENTSで呼び出しま
     す。これは‘funcall’と同様ですが、1つ違いがあります
     。ARGUMENTSの最後はオブジェクトのリストです。これは
     1つのリストではなく、個別の引数としてFUNCTIONに渡さ
     れます。わたしたちはこれを、‘apply’がこのリストを
     “展開(spread)”(個々の要素が引数となるので)する、と
     言います。

     ‘apply’は、FUNCTIONを呼び出した結果をreturnします。
     ‘funcall’と同様、FUNCTIONはLisp関数かプリミティブ関
     数でなければなりません。つまりスペシャルフォームや
     マクロは、‘apply’では意味をもちません。

          (setq f 'list)
               ⇒ list
          (apply f 'x 'y 'z)
          error→ Wrong type argument: listp, z
          (apply '+ 1 2 '(3 4))
               ⇒ 10
          (apply '+ '(1 2 3 4))
               ⇒ 10

          (apply 'append '((a b c) nil (x y z) nil))
               ⇒ (a b c x y z)

     ‘apply’を使用した興味深い例は、*note Definition of
     mapcar::を参照してください。

   ある関数にたいして、その関数のある引数を特定の値に固
定し、他の引数は実際に呼びだされたときの値にできれば便利
なことがあります。関数のいくつかの引数を固定することは、
その関数の“部分適用(partial application)”と呼ばれます
(1)。結果は、残りの引数をとる新たな関数で、すべての引数
を合わせて元の関数を呼び出します。

   Emacs Lispで部分適用を行う方法を示します:

 -- Function: apply-partially func &rest args
     この関数は、新たな関数をreturnします。この新しい関
     数は、呼びだされたときにARGSと、呼び出し時に指定さ
     れた追加の引数から成る引数リストでFUNCを呼び出す関
     数です。FUNCにN個の引数を指定できる場合、‘M < N’個
     の引数で‘apply-partially’を呼び出すと、‘N - M’個の
     新たな関数を生成します。

     以下は、‘apply-partially’と他のビルトイン関数‘+’,を
     使用して、(もし存在しないなら)ビルトイン関数‘1+’を
     定義する例です:

          (defalias '1+ (apply-partially '+ 1)
            "Increment argument by one.")
          (1+ 10)
               ⇒ 11

   引数として関数をとったり、データ構造(特にフック変数や
プロパティーリスト)から関数を探す関数はLispでは一般的で
、それらは‘funcall’や‘apply’を使用してそれらの関数を呼び
出します。引数として関数をとる関数は、“ファンクショナル
(functional)”と呼ばれるときもあります。

   ファンクショナルを呼び出すとき、引数としてno-op関数
(何も行わない関数)を指定できると便利なときがあります。以
下に２つの異なるno-op関数を示します:

 -- Function: identity arg
     この関数はARGをreturnします。副作用はありません。

 -- Function: ignore &rest args
     この関数は任意の引数を無視して、‘nil’をreturnします
     。

   いくつかの関数はユーザーに可視な“コマンド”で、これら
は(通常はキーシーケンスを介して)対話的に呼び出すことがで
きます。そのようなコマンドは、‘call-interactively’関数を
使用することにより、対話的に呼びだされたときと同様に呼び
出すことができます。*note Interactive Call::を参照してく
ださい。

   ---------- Footnotes ----------

   (1) これは“カリー化(currying)”と関連しますが、異なる
機能です。カーリングは、複数の引数をとる関数を、関数チェ
ーンとして呼び出せるような、１つの引数を取る個々の関数に
変換するような方法です。


File: elisp,  Node: Mapping Functions,  Next: Anonymous Functions,  Prev: Calling Functions,  Up: Functions

12.6 Mapping Functions
======================

“マップ関数(mapping function)”は与えられた関数(スペシャ
ルフォームやマクロでは_ない_)を、リストや他のコレクショ
ンの各要素に適用します。Emacs Lispにはそのような関数がい
くつかあります。このセクションでは、リストにたいしてマッ
ピングを行う‘mapcar’、‘mapc’、‘mapconcat’を説明します。
obarray内のシンボルにたいしてマッピングを行う関数
‘mapatoms’は、*note Definition of mapatoms::を参照してく
ださい。ハッシュテーブル内のkey/value関係にたいしてマッ
ピングを行う関数‘maphash’は、*note Definition of
maphash::を参照してください。

   これらのマップ関数は、文字テーブル(char-table)には適
用されません。なぜなら文字テーブルは非常に広い範囲の疎な
配列だからです。疎な配列であるという性質に適う方法で文字
いテーブルにマッピングするには、関数‘map-char-table’を使
用します(*note Char-Tables::を参照してください)。

 -- Function: mapcar function sequence
     ‘mapcar’は、関数FUNCTIONをSEQUENCEの各要素にたいし
     て順番に適用し、その結果をリストでreturnします。

     引数SEQUENCEには、文字テーブルを除く任意の種類のシ
     ーケンス — つまりリスト、ベクター、ブールベクター、
     文字列を指定できます。結果は常にリストになります。
     結果の長さは、SEQUENCEの長さと同じです。たとえば:

          (mapcar 'car '((a b) (c d) (e f)))
               ⇒ (a c e)
          (mapcar '1+ [1 2 3])
               ⇒ (2 3 4)
          (mapcar 'string "abc")
               ⇒ ("a" "b" "c")

          ;; ‘my-hooks’内の各関数を呼び出す。
          (mapcar 'funcall my-hooks)

          (defun mapcar* (function &rest args)
            "Apply FUNCTION to successive cars of all ARGS.
          Return the list of results."
            ;; リストが消費されていなければ、
            (if (not (memq nil args))
                ;; CARに関数を適用する。
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; 残りの要素のための再帰。
                             (mapcar 'cdr args)))))

          (mapcar* 'cons '(a b c) '(1 2 3 4))
               ⇒ ((a . 1) (b . 2) (c . 3))

 -- Function: mapc function sequence
     ‘mapc’は‘mapcar’と似ていますが、FUNCTIONは副作用の
     ためだけに使用されます — つまりFUNCTIONがreturnする
     値は無視され、リストに収集されません。‘mapc’は常に
     SEQUENCEをreturnします。

 -- Function: mapconcat function sequence separator
     ‘mapconcat’は関数FUNCTIONをSEQUENCEの各要素に適用し
     ます。結果は結合された文字列になります。結果文字列
     の間に、‘mapconcat’は文字列SEPARATORを挿入します。
     SEPARATORには通常、スペースやカンマ、あるいはその他
     の適切な区切り文字が含まれます。

     引数FUNCTIONはははは、1つの引数を取り文字列を
     returnする関数でなければなりません。引数SEQUENCEに
     は、文字テーブルを除く、任意の種類のシーケンス — つ
     まりリスト、ベクター、ブールベクター、文字列を指定
     できます。

          (mapconcat 'symbol-name
                     '(The cat in the hat)
                     " ")
               ⇒ "The cat in the hat"

          (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                     "HAL-8000"
                     "")
               ⇒ "IBM.9111"


File: elisp,  Node: Anonymous Functions,  Next: Function Cells,  Prev: Mapping Functions,  Up: Functions

12.7 Anonymous Functions
========================

関数は通常、‘defun’により定義され、同時に名前が与えられ
ますが、明示的にラムダ式を使う — “無名関数(anonymous
function)”のほうが便利なときもあります。無名関数は、名前
つき関数が有効な場所なら、どこでも有効です。無名関数は変
数や関数の引数に割り当てられることがよくあります。たとえ
ば、ある関数をリストの各要素に適用する‘mapcar’の
FUNCTION引数に渡すかもしれません(*note Mapping
Functions::を参照してください)。現実的な例は、*note
describe-symbols example::を参照してください。

   無名関数として使用するためのラムダ式を定義するとき、
原則的にはリストを構築する任意の手法を使用できます。しか
し通常は、マクロ‘lambda’、スペシャルフォーム‘function’、
または入力構文‘#'’を使用するべきです。

 -- Macro: lambda args [doc] [interactive] body...
     このマクロは引数リストARGS、(もしあれば)ドキュメン
     ト文字列DOC、(もしあれば)インタラクティブ指定
     INTERACTIVE、およびBODYで与えられるbodyフォームをも
     つ無名関数をreturnします。

     実際にはこのマクロは‘lambda’フォームを“自己クォート
     (self-quoting)”します。つまりCARが‘lambda’であるよ
     うなフォームは、そのフォーム自身を得ます。

          (lambda (x) (* x x))
               ⇒ (lambda (x) (* x x))

     ‘lambda’フォームは別に、1つの効果をもちます。このマ
     クロは、‘function’(以下参照)をサブルーチンとして使
     用することにより、Emacs評価機能(Emacs evaluator)と
     バイトコンパイラーに、その引数が関数であることを告
     げます。

 -- Special Form: function function-object
     このスペシャルフォームは、評価を行わずに、
     FUNCTION-OBJECTをreturnします。この点では、
     ‘quote’(*note Quoting::を参照してください)と似てい
     ます。しかし‘quote’とは異なり、Emacs評価機能とバイ
     トコンパイラーに、これを関数として使用する意図を告
     げる役割をもちます。FUNCTION-OBJECTが有効なラムダ式
     と仮定すると、これは２つの効果をもちます:

        • そのコードがバイトコンパイルされているとき、
          FUNCTION-OBJECTはバイトコード関数オブジェクト
          にコンパイルされます(*note Byte Compilation::を
          参照してください)。

        • レキシカルバインドが有効な場合、
          FUNCTION-OBJECTはクロージャーに変換されます。
          *note Closures::を参照してください。

   入力構文‘#'’は、‘function’の使用の略記です。以下のフ
ォームは等価です:

     (lambda (x) (* x x))
     (function (lambda (x) (* x x)))
     #'(lambda (x) (* x x))

   以下の例では、3つ目の引数に関数をとる、
‘change-property’関数を定義し、その後の
‘change-property’で、無名関数を渡してこれを使用していま
す:

     (defun change-property (symbol prop function)
       (let ((value (get symbol prop)))
         (put symbol prop (funcall function value))))

     (defun double-property (symbol prop)
       (change-property symbol prop (lambda (x) (* 2 x))))

‘lambda’フォームをクォートしていないことに注意してくださ
い。

   上記のコードをコンパイルした場合は、無名関数もコンパ
イルされます。リストをクォートすることにより無名関数を構
築した場合、コンパイルはされません。

     (defun double-property (symbol prop)
       (change-property symbol prop '(lambda (x) (* 2 x))))

この場合、無名関数はコンパイルされたコード内のラムダ式に
保持されます。バイトコンパイラーは、‘change-property’が
関数としての使用を意図していることを知ることができないの
で、たとえこの関数が関数のように見えるとしても、このリス
トが関数であると決め込むことはできません。


File: elisp,  Node: Function Cells,  Next: Closures,  Prev: Anonymous Functions,  Up: Functions

12.8 Accessing Function Cell Contents
=====================================

あるシンボルの“関数定義(function definition)”とは、その
シンボルの関数セルに格納されたオブジェクトのことです。こ
こでは、シンボルの関数セルにアクセス、テスト、セットする
関数を説明します。

   *note Definition of indirect-function::の、関数
‘indirect-function’も参照してください。

 -- Function: symbol-function symbol
     これはSYMBOLの関数セル内のオブジェクトをreturnしま
     す。これは、returnされたオブジェクトが本物のの関数
     であるかチェックしません。

     関数セルがvoidの場合、return値は‘nil’です。関数セル
     がvoidのときと、‘nil’がセットされているときを区別す
     るには、‘fboundp’(以下参照)を使用します。

          (defun bar (n) (+ n 2))
          (symbol-function 'bar)
               ⇒ (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               ⇒ bar
          (symbol-function 'baz)
               ⇒ bar

   シンボルに何の関数定義も与えていない場合、そのシンボ
ルの関数セルは“void”だと言います。別の言い方をすると、そ
の関数セルは、どんなLispオブジェクトも保持しません。その
シンボルを関数として呼びだそうとすると、Emacsは
‘void-function’エラーをシグナルします。

   voidは、‘nil’やシンボル‘void’とは異なることに注意して
ください。シンボル‘nil’および‘void’はLispオブジェクトで
あり、他のオブジェクトと同様、関数セルに格納することがで
きます(これらのシンボルは‘defun’を使用して有効な関数に成
ることができます)。voidである関数セルは、どのようなオブ
ジェクトも含みません。

   ‘fboundp’を使用して、任意のシンボルの関数定義がvoidか
どうかテストすることができます。シンボルに関数定義を与え
た後は、‘fmakunbound’をつかえば、再びvoidにすることがで
きます。

 -- Function: fboundp symbol
     この関数は、そのシンボルが関数セルにオブジェクトを
     もっていれば‘t’、それ以外は‘nil’をreturnします。こ
     れは、そのオブジェクトが本物の関数であるかチェック
     しません。

 -- Function: fmakunbound symbol
     この関数はSYMBOLの関数セルをvoidにします。そのため
     、これ以降に関数セルにアクセスしようと試みると、
     ‘void-function’エラーが発生します。これはSYMBOLを
     returnします(*note Void Variables::の‘makunbound’も
     参照してください)。

          (defun foo (x) x)
          (foo 1)
               ⇒1
          (fmakunbound 'foo)
               ⇒ foo
          (foo 1)
          error→ Symbol's function definition is void: foo

 -- Function: fset symbol definition
     この関数はSYMBOLの関数セルに、DEFINITIONを格納しま
     す。結果はDEFINITIONです。DEFINITIONは通常、関数ま
     たは関数の名前であるべきですが、これはチェックされ
     ません。引数SYMBOLは、通常のどおり評価される引数で
     す。

     この関数は主に、関数を定義したり変更して構成を行う
     、‘defun’や‘advice-add’のようなものからサブルーチン
     として使用されます。シンボルにたいして、たとえばキ
     ーボードマクロ(*note Keyboard Macros::を参照してく
     ださい)のような、関数ではない関数定義与えるためにも
     使用することができます:

          ;; 名前つきのキーボードマクロを定義する。
          (fset 'kill-two-lines "\^u2\^k")
               ⇒ "\^u2\^k"

     関数にたいして別の名前を作成するために‘fset’を使い
     たい場合は、かわりに‘defalias’の使用を考慮してくだ
     さい。*note Definition of defalias::を参照してくだ
     さい。


File: elisp,  Node: Closures,  Next: Advising Functions,  Prev: Function Cells,  Up: Functions

12.9 Closures
=============

*note Variable Scoping::で説明したように、Emacsはオプシ
ョンで変数のレキシカルバインディングを有効にできます。レ
キシカルバインディングが有効な場合、あなたが(たとえば
‘defun’などで)作成した任意の名前つき関数、同様に
‘lambda’マクロ、‘function’スペシャルフォーム、‘#'’構文を
使用して作成した任意の無名関数(*note Anonymous
Functions::を参照してください)は、自動的に“クロージャー
(closure)”に変換されます。

   クロージャーとは、その関数が定ぎされたどときに存在し
たレキシカル環境の記録もあわせもつ関数です。クロージャー
が呼び出されたとき、定義内のレキシカル変数の参照には、そ
の保持されたレキシカル環境を使用されます。他のすべての点
では、クロージャーは通常の関数と同様に振る舞います。特に
、クロージャーは通常の関数と同じ方法で呼び出すことができ
ます。

   クロージャー使用する例は、*note Lexical Binding::を参
照してください。

   現在のところ、Emacs Lispのクロージャーオブジェクトは
、1つ目の要素にシンボル‘closure’をもつリストとして表現さ
れます。そのリストは2つ目の要素としてレキシカル環境を表
し、残りの要素で引数リストとbodyフォームを表します:

     ;; レキシカルバインディングが有効。
     (lambda (x) (* x x))
          ⇒ (closure (t) (x) (* x x))

しかし実際には、クロージャーの内部構造は、内部的な実装の
詳細と判断される残りのLisp界を“晒け出す”ものだと言えます
。この理由により、クロージャーオブジェクトの構造を直接調
べたり変更することは推奨しません。


File: elisp,  Node: Advising Functions,  Next: Obsolete Functions,  Prev: Closures,  Up: Functions

12.10 Advising Emacs Lisp Functions
===================================

他のライブラリーの関数定義を変更する必要があるとき、また
は‘FOO-function’oのようなフックやプロセスフィルター
(process filter)、または関数を値としてもつ任意の変数また
はオブジェクトを変更する必要があるときには、名前つきの関
数には‘fset’か‘defun’、フック変数には‘setq’、プロセスフ
ィルターには‘set-process-filter’のように、適切なセッター
関数(setter function)を使用することができます。しかし、
これらが以前の値を完全に破棄してしまうのが好ましくない場
合もあります。

   “アドバイス(advice)”機能により、“関数にアドバイス”す
ることにより、既存の関数定義に機能を追加できます。これは
関数全体を再定義するより明解な手法です。

   Emacsのアドバイスシステムは2つのプリミティブセットを
提供します。コアとなるセットは、変数やオブジェクトのフィ
ールドに保持された関数値にたいするものです(対応するプリ
ミティブは‘add-function’と‘remove-function’です)。もう
1つのセットは、名前つき関数の最上位のレイヤーとなるもの
です(主要なプリミティブは‘advice-add’と‘advice-remove’で
す)。

   たとえば、プロセスPROCのプロセスフィルターの呼び出し
をトレースするためには、以下を使用できます:

     (defun my-tracing-function (proc string)
       (message "Proc %S received %S" proc string))

     (add-function :before (process-filter PROC) #'my-tracing-function)

   これにより、そのプロセスの出力は、元のプロセスフィル
ターに渡される前に、‘my-tracing-function’に渡されるよう
になります。‘my-tracing-function’は元の関数と同じ引数を
受け取ります。これを行った場合、以下のようにしてトレース
を行わない振る舞いにリバートすることができます。

     (remove-function (process-filter PROC) #'my-tracing-function)

   同様に、‘display-buffer’という名前つきの関数の実行を
トレースしたい場合は、以下を使用できます:

     (defun his-tracing-function (orig-fun &rest args)
       (message "display-buffer called with args %S" args)
       (let ((res (apply orig-fun args)))
         (message "display-buffer returned %S" res)
         res))

     (advice-add 'display-buffer :around #'his-tracing-function)

   ここで、‘his-tracing-function’は元の関数のかわりに呼
び出され、元の関数(加えてその関数の引数)を引数として受け
取るので、必要な場合はそれを呼び出すことができます。出力
を確認し終えたら、以下のようにしてトレースしない振る舞い
にリバートできます:

     (advice-remove 'display-buffer #'his-tracing-function)

   上記の例で使用されている引数‘:before’と‘:around’は、
2つの関数が構成される方法を指定します(これを行うには多く
の方法があるからです)。追加された関数も、_アドバイス
(advice)_と呼ばれます。

* Menu:

* Core Advising Primitives::  アドバイスを扱うプリミティブ。
* Advising Named Functions::  名前つき関数のアドバイス。
* Advice combinators::       アドバイスを構成する方法。
* Porting old advices::      古いdefadviceを使用したコードの改良。


File: elisp,  Node: Core Advising Primitives,  Next: Advising Named Functions,  Up: Advising Functions

12.10.1 Primitives to manipulate advices
----------------------------------------

 -- Macro: add-function where place function &optional
          props
     このマクロはPLACE(*note Generalized Variables::を参
     照してください)に格納された関数に、アドバイス
     FUNCTIONを追加する手軽な方法です。

     WHEREは、既存の関数のどこに — たとえば元の関数の前
     、または後に — FUNCTIONが構成されるかを決定します。
     2つの関数を構成するために利用可能な方法のリストは、
     *note Advice combinators::を参照してください。

     (通常は名前が‘-function’で終わる)変数を変更するとき
     には、FUNCTIONがグローバルに使用されるか、あるいは
     カレントバッファーだけに使用されるか選ぶことができ
     ます。PLACEが単にシンボルの場合、FUNCTIONはPLACEの
     グローバル値に追加されます。PLACEが‘(local
     SYMBOL)’というフォームの場合、SYMBOLはその変数の名
     前をreturnする式なので、FUNCTIONはカレントバッファ
     ーだけに追加されます。最後に、レキシカル変数を変更
     したい場合には、‘(var VARIABLE)’を使用する必要があ
     るでしょう。

     ‘add-function’で追加されたすべての関数は、自動的に
     プロパティーPROPSの関連リストに加えることができます
     。現在のところ、特別な意味をもつのは2つのプロパティ
     ーだけです:

     ‘name’
          これはアドバイスの名前を与えます。この名前は、
          ‘remove-function’が取り除く関数を識別するのに
          使用できます。これは通常、FUNCTIONが無名関数の
          ときに使用されます。

     ‘depth’
          これは複数のアドバイスが与えられたときに、どの
          ようにアドバイスを順番づけるかを指定します。
          depthのデフォルト0です。depthが100のとき、この
          アドバイスは可能な限りの深さを保持すべきことを
          意味し、-100のときは最外のアドバイスに留めるこ
          とを意味します。同じdepthで2つのアドバイスが指
          定された場合、もっとも最近に追加されたアドバイ
          スが最外になります。

          ‘:before’アドバイスにたいしては、最外
          (outermost)になるということは、このアドバイス
          が他のアドバイスの前、つまり1番目に実行される
          ことを意味し、最内(innermost)とは元の関数が実
          行される直前、すなわちこのアドバイスと元の関数
          の間に実行されるアドバイスは存在しないことを意
          味します。同様に‘:after’アドバイスにたいしては
          、最内とは元の関数の直後、つまりこの元の関数と
          アドバイスの間に実行される他のアドバイスは存在
          せず、最外とは他のすべてのアドバイスが実行され
          た後にこのアドバイスが実行されることを意味しま
          す。‘:override’の最内アドバイスは、元の関数だ
          けをオーバーライドし、他のアドバイスは適用され
          ませんが、‘:override’の最外アドバイスは元の関
          数だけではなく。その他すべての適用済みのアドバ
          イスををオーバーライドします。

     FUNCTIONがインタラクティブでない場合、欠オグされた
     関数は、(もしあれば)元の関数のインタラクティブ指定
     (interactive spec)を継承します。それ以外は、結合さ
     れた関数はインタラクティブになり、FUNCTIONのインタ
     ラクティブ指定を使用します。1つ例外があります。
     FUNCTIONのインタラクティブ指定が、(式や文字列ではな
     い)関数の場合、元の関数のインタラクティブ指定を唯一
     の引数として、その関数を呼び出して、それが結合され
     た関数のインタラクティブ指定になります。引数として
     受け取ったインタラクティブ指定を解釈するためには、
     ‘advice-eval-interactive-spec’を使用します。

     注意: FUNCTIONのインタラクティブ指定は結合された関
     数に適用され、FUNCTIONではなく、結合された関数の呼
     び出し規約に従うべきです。多くの場合、これらは等し
     いので差異は生じませんが、FUNCTIONの‘:around’、
     ‘:filter-args’、‘filter-return’では、重要になります
     。

 -- Macro: remove-function place function
     このマクロはPLACEに格納された関数から、FUNCTIONを取
     り除きます。これは、‘add-function’を使用して、
     FUNCTIONがPLACEに追加されたときだけ機能します。

     FUNCTIONは、PLACEに追加された関数にたいして、ラムダ
     式にたいしても機能するように、‘equal’を使用して比較
     を試みます。これは追加でPLACEに追加された関数の
     ‘name’プロパティーも比較します。これは‘equal’を使用
     してラムダ式を比較するより信頼性があります。

 -- Function: advice-function-member-p advice
          function-def
     ADVICEがすでにFUNCTION-DEF内にある場合は、非‘nil’を
     returnします。上記の‘remove-function’と同様、実際の
     関数ADVICEのかわりに、アドバイス断片(piece of
     advice)の‘name’も使用できます。

 -- Function: advice-function-mapc f function-def
     FUNCTION-DEFに追加されたすべてのアドバイスに対して
     、関数Fを呼び出します。Fは2つの引数 — アドバイス関
     数と、それのプロパティーで呼びだされます。

 -- Function: advice-eval-interactive-spec spec
     そのような指定で関数がインタラクティブに呼び出され
     たように、インタラクティブ指定SPECを評価して、構築
     された引数のリストに対応するリストをreturnします。
     たとえば、‘(advice-eval-interactive-spec "r\nP")’は
     、リージョンの境界、カレントプレフィクス引数を含む
     、3つの要素からなるリストをreturnします。


File: elisp,  Node: Advising Named Functions,  Next: Advice combinators,  Prev: Core Advising Primitives,  Up: Advising Functions

12.10.2 Advising Named Functions
--------------------------------

アドバイスの一般的な使い方は、名前つき関数やマクロにたい
して使用する方法です。これは単に‘add-function’を使用して
以下のように行うことができます:

     (add-function :around (symbol-function 'FUN) #'his-tracing-function)

   しかし、かわりに‘advice-add’と‘advice-remove’を使うべ
きです。この別の関数セットは名前つき関数に適用されるアド
バイス断片を操作するためのもので、‘add-function’と比較し
て以下の追加機能があります。まず、これらはマクロおよびオ
ートロードされた関数を扱う方法を知っています。次に、
‘describe-function’にたいして、追加されたアドバイスと同
様に、元のドキュメント文字列を維持します。さらに、関数が
定義される前でも、アドバイスの追加と削除ができます。

   既存の関数を関数全体を再定義せずに、既存の呼び出しを
変更するために、‘advice-add’は有用になります。しかし、そ
の関数の既存の呼び出し元は、古い振る舞いを前提としている
かもしれず、アドバイスによりその振る舞いが変更されたとき
に正しく機能しないかもしれないので、これはソースのバグに
もなり得ます。アドバイスはデバッグを難しくする可能性もあ
ります。デバッグを行う人は、その関数がアドバイスにより変
更されたことに気づかなかったり、失念しているかもしれませ
ん。

   これらの理由により、他の方法で関数の振る舞いを変更で
きない場合のために、アドバイスの使用は控えるべきです。フ
ックを通じて同じことが行えるなら、フック(*note Hooks::を
参照してください)の使用が望ましい方法です。特定のキーが
行う何かを変更したいだけなら、新しいコマンドを記述して、
古いコマンドのキーバインドを新しいコマンドにリマップ
(*note Remapping Commands::を参照してください)するのが、
おそらくより良い方法です。特に、Emacs自身のソースファイ
ルは、Emacs内の関数をアドバイスするべきではありません(現
在のところこの慣習には数少ない例外がありますが、わたした
ちはこれを改善しようと思っています)。

   スペシャルフォーム(*note Special Forms::を参照してく
ださい)はアドバイスできませんが、マクロは関数と同じ方法
でアドバイスできます。もちろん、これはすでにマクロ展開さ
れたコードには影響しないため、マクロ展開前にアドバイスが
確実にインストールされる必要があります。

   プリミティブ(*note What Is a Function::を参照してくだ
さい)にアドバイスするのは可能ですが、2つの理由により通常
は行うべきでは_ありません_。1つ目の理由は、いくつかのプ
リミティブはアドバイスのメカニズム内で使用されているため
、それらにたいしてアドバイスを行うと無限再帰が発生するか
らです。2つ目の理由は、多くのプリミティブがCから直接呼び
出されていて、そのような呼び出しはアドバイスを無視するか
らです。したがって、プリミティブにたいしてアドバイスの使
用を控えることは、ある呼び出しはアドバイスにしたがい
(Lispコードから呼びだされたため)、他の呼び出しではアドバ
イスにしたがわない(Cコードから呼び出されたため)という混
乱した状況を解決します。

 -- Function: advice-add symbol where function &optional
          props
     名前つき関数SYMBOLに、アドバイスFUNCTIONを追加しま
     す。WHEREとPROPSは、‘add-function’(*note Core
     Advising Primitives::を参照してください)のときと同
     じ意味をもちます。

 -- Function: advice-remove symbol function
     名前つき関数SYMBOLからアドバイスFUNCTIONを取り除き
     ます。FUNCTIONにアドバイスの‘name’を指定することも
     できます。

 -- Function: advice-member-p function symbol
     名前つき関数SYMBOL内にすでにアドバイスFUNCTIONがあ
     る場合は、非‘nil’をreturnします。FUNCTIONにアドバイ
     スの‘name’を指定することもできます。

 -- Function: advice-mapc function symbol
     名前つき関数SYMBOLにすでに追加されたすべての関数に
     たいして、FUNCTIONを呼び出します。FUNCTIONは2つの引
     数、アドバイス関数と、そのプロパティーで呼び出され
     ます。


File: elisp,  Node: Advice combinators,  Next: Porting old advices,  Prev: Advising Named Functions,  Up: Advising Functions

12.10.3 Ways to compose advices
-------------------------------

以下は‘add-function’および‘advice-add’のWHERE引数に可能
な値で、そのアドバイスFUNCTIONと元の関数が構成されるべき
方法を指定します。

‘:before’
     古い関数の前にFUNCTIONを呼び出します。関数は両方と
     も同じ引数を受け取り、2つの関数の結合のreturn値は、
     古い関数のreturn値です。より正確に言うと、2つの関数
     の結合は、以下のように振る舞います:
          (lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
     ‘(add-function :before FUNVAR FUNCTION)’は、ノーマ
     ルフックにたいする‘(add-hook 'HOOKVAR FUNCTION)’の
     ような、1関数のフックと同等です。

‘:after’
     古い関数の後にFUNCTIONを呼び出します。関数は両方と
     も同じ引数を受け取り、2つの関数の結合のreturn値は、
     古い関数のreturn値です。より正確に言うと、2つの関数
     の結合は、以下のように振る舞います:
          (lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after FUNVAR FUNCTION)’は、ノーマル
     フックにたいする‘(add-hook 'HOOKVAR FUNCTION
     'append)’のような、1関数のフックと同等です。

‘:override’
     これは古い関数を新しい関数に完全に置き換えます。も
     ちろん、‘remove-function’を呼び出した後に、古い関数
     は復元されます。

‘:around’
     古い関数のかわりにFUNCTIONを呼び出しますが、古い関
     数はFUNCTIONの追加の引数になります。これはもっとも
     柔軟な結合です。たとえば、古い関数を異なる引数で呼
     び出したり、複数回呼び出したり、letバインディングで
     呼び出したり、あるときは古い関数に処理を委譲し、ま
     たあるときは完全にオーバーライドすることが可能にな
     ります。より正確に言うと、2つの関数の結合は、以下の
     ように振る舞います:
          (lambda (&rest r) (apply FUNCTION OLDFUN r))

‘:before-while’
     古い関数の前にFUNCTIONを呼び出し、FUNCTIONが‘nil’を
     returnした場合は古い関数を呼び出しません。関数は両
     方とも同じ引数を受け取り、2つの関数の結合のreturn値
     は、古い関数のreturn値です。より正確に言うと、2つの
     関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-while FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-failure’を通じてHOOKVARが
     実行されたときの‘(add-hook 'HOOKVAR FUNCTION)’のよ
     うな、1関数のフックと同等です。

‘:before-until’
     古い関数の前にFUNCTIONを呼び出し、FUNCTIONが‘nil’を
     returnした場合だけ古い関数を呼び出します。より正確
     に言うと、2つの関数の結合は、以下のように振る舞いま
     す:
          (lambda (&rest r) (or (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-until FUNVAR FUNCTION)’ は、
     ‘run-hook-with-args-until-success’を通じてHOOKVARが
     実行されたときの‘(add-hook 'HOOKVAR FUNCTION)’のよ
     うな、1関数のフックと同等です。

‘:after-while’
     古い関数が非‘nil’をreturnした場合だけ、古い関数の後
     にFUNCTIONを呼び出します。関数は両方とも同じ引数を
     受け取り、2つの関数の結合のreturn値は、FUNCTIONの
     return値です。より正確に言うと、2つの関数の結合は、
     以下のように振る舞います:
          (lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-while FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-failure’を通じてHOOKVARが
     実行されたときの‘(add-hook 'HOOKVAR FUNCTION
     'append)’のような、1関数のフックと同等です。

‘:after-until’
     古い関数が‘nil’をreturnした場合だけ、古い関数の後に
     FUNCTIONを呼び出します。より正確に言うと、2つの関数
     の結合は、以下のように振る舞います:
          (lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-until FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-success’を通じてHOOKVARが
     実行されたときの‘(add-hook 'HOOKVAR FUNCTION
     'append)’のような、1関数のフックと同等です。

‘:filter-args’
     最初にFUNCTIONを呼び出し、その結果(リスト)を新たな
     引数として古い関数に渡します。より正確に言うと、2つ
     の関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))

‘:filter-return’
     最初に古い関数を呼び出し、その結果をFUNCTIONに渡し
     ます。より正確に言うと、2つの関数の結合は、以下のよ
     うに振る舞います:
          (lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))


File: elisp,  Node: Porting old advices,  Prev: Advice combinators,  Up: Advising Functions

12.10.4 Adapting code using the old defadvice
---------------------------------------------

多くのコードは古い‘defadvice’メカニズムを使用しており、
これらの大半は‘advice-add’により陳腐化しました。
‘advice-add’の実装と意味は、とてもシンプルです。

   古いアドバイスは以下のようなものです:

     (defadvice previous-line (before next-line-at-end
                                      (&optional arg try-vscroll))
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   新しいアドバイスメカニズムを使用すれば、これを通常の
関数に変換できます:

     (defun previous-line--next-line-at-end (&optional arg try-vscroll)
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   これが実際の‘previous-line’を変更しないことは明確です
。古いアドバイスには、以下が必要です:
     (ad-activate 'previous-line)
   一方、新しいアドバイスメカニズムでは、以下が必要です:
     (advice-add 'previous-line :before #'previous-line--next-line-at-end)

   ‘ad-activate’はグローバルな効果をもつことに注意してく
ださい。これは、指定された関数にたいして、アドバイスのす
べての断片を有効にします。特定のアドバイスだけをアクティ
ブ、または非アクティブにしたい場合、‘ad-enable-advice’、
または‘ad-disable-advice’により、_有効_または_無効_にす
る必要があります。新しいメカニズムではこの区別はなくなり
ました。

   以下のようなaroundのアドバイスがあるとします:

     (defadvice foo (around foo-around)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         ad-do-it))
     (ad-activate 'foo)

   これは以下のように変換できます:

     (defun foo--foo-around (orig-fun &rest args)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         (apply orig-fun args)))
     (advice-add 'foo :around #'foo--foo-around)

   アドバイスの_クラス_について、新たな‘:before’は、古い
‘before’は完全に等価ではないことに注意してください。なぜ
なら古いアドバイス内では、(たとえば‘ad-set-arg’を使って
)その関数の引数を変更できそれは元の関数が参照する引数値
に影響します。しかし新しい‘:before’は、‘setq’を通じてア
ドバイス内の引数をし、その変更は元の関数からの参照に影響
しません。この振る舞いにもとづいて‘before’アドバイスを移
行するときは、代わりにそれを新たなアドバイス‘:around’ま
たは‘:filter-args’に変更する必要があるでしょう。

   同様に、古い‘after’アドバイスは、‘ad-return-value’を
変更することによりreturn値を変更できますが、新しい
‘:after’は変更できないので、そのような‘after’を移行する
ときは、かわりにそれらを新しいアドバイス‘:around’または
‘:filter-return’に変更する必要があるでしょう。


File: elisp,  Node: Obsolete Functions,  Next: Inline Functions,  Prev: Advising Functions,  Up: Functions

12.11 Declaring Functions Obsolete
==================================

名前つき関数を“陳腐化している(obsolete)”とマークすること
ができます。これは、その関数が将来のある時点で削除される
かもしれないことを意味します。陳腐化しているとマークされ
た関数を含むコードをバイトコンパイルしたとき、Ｅｍａｃｓ
は警告を発します。また、その関数のヘルプドキュメントは表
示されなくなります。他の点においては、陳腐化した関数は他
の任意の関数と同様に振る舞います。

   関数を陳腐化しているとマークするもっとも簡単な方法は
、その関数の‘defun’定義に‘(declare (obsolete ...))’を配
置することです。*note Declare Form::を参照してください。
かわりに、以下で説明している‘make-obsolete’関数を使うこ
ともできます。

   ‘make-obsolete’を使用して、マクロ(*note Macros::を参
照してください)を陳腐化しているとマークすることもできま
す。これは関数のときと同じ効果をもちます。関数またはマク
ロにたいするエイリアスも、陳腐化しているとマークできます
。これはエイリアス自身をマークし、名前解決される関数また
はマクロにたいしてではありません。

 -- Function: make-obsolete obsolete-name current-name
          &optional when
     この関数は、OBSOLETE-NAMEを陳腐化しているとマークし
     ます。OBSOLETE-NAMEには関数またはマクロを名前づける
     シンボル、、または関数やマクロにたいするエイリアス
     を指定します。

     CURRENT-NAMEがシンボルの場合は、OBSOLETE-NAMEのかわ
     りにCURRENT-NAMEの使用を促す警告メッセージになりま
     す。CURRENT-NAMEは、OBSOLETE-NAMEにたいするエイリア
     スである必要はありません。似たような機能をもつ、別
     の関数かもしれません。CURRENT-NAMEには、警告メッセ
     ージとなる文字列も指定できます。メッセージは小文字
     で始まりピリオドで終えるべきです。‘nil’も指定でき、
     この場合には警告メッセージに追加の詳細は提供されま
     せん。

     WHENが与えられた場合、それは最初にその関数が陳腐化
     する時期を示す文字列 — たとえば火付けやリリース番号
     を指定します。

 -- Macro: define-obsolete-function-alias obsolete-name
          current-name &optional when doc
     この便利なマクロは関数OBSOLETE-NAMEを陳腐化している
     とマークするとともに、それを関数CURRENT-NAMEのエイ
     リアスにします。これは以下と等価です:

          (defalias OBSOLETE-NAME CURRENT-NAME DOC)
          (make-obsolete OBSOLETE-NAME CURRENT-NAME WHEN)

   加えて、陳腐化した関数にたいする特定の呼び出し規約を
マークできます。

 -- Function: set-advertised-calling-convention function
          signature when
     この関数は、FUNCTIONを呼び出す正しい方法として、引
     数リストSIGNATUREを指定します。これにより、Emacs
     Lispプログラムが他の方法でFUNCTIONを呼び出している
     場合には、Emacsのバイトコンパイラーが警告を発します
     (それでもコードはバイトコンパイルされます)。WHENに
     は、その変数が最初に陳腐化するときを示す文字列(通常
     はバージョン番号)を指定します。

     たとえば、古いバージョンのEmacsでは、‘sit-for’には
     以下のように3つの引数を指定していました

            (sit-for seconds milliseconds nodisp)

     しかしこの方法による‘sit-for’の呼び出しは陳腐化して
     いると判断されます(*note Waiting::を参照してくださ
     い)。以下のように、古い呼び出し規約は推奨されません
     :

          (set-advertised-calling-convention
            'sit-for '(seconds &optional nodisp) "22.1")


File: elisp,  Node: Inline Functions,  Next: Declare Form,  Prev: Obsolete Functions,  Up: Functions

12.12 Inline Functions
======================

“インライン関数(inline function)”は関数と同様に機能しま
すが、1つ例外があります。その関数の呼び出しがバイトコン
パイルされると(*note Byte Compilation::を参照してくださ
い)、その関数の定義が呼び出し元に展開されます。インライ
ン関数を定義するには、‘defun’のかわりに‘defsubst’を使用
します。

 -- Macro: defsubst name args [doc] [declare]
          [interactive] body...
     このマクロはインライン関数を定義します。マクロの構
     文は‘defun’とまったく同じです(*note Defining
     Functions::を参照してください)。

   関数をインラインにすることにより、その関数の呼び出し
が高速になる場合があります。しかし欠点もあります。1つは
柔軟性の減少です。その関数の定義を変更した場合、すでにイ
ンライン化された呼び出しは、リコンパイルを行うまで古い定
義を使用します。

   もう1つの欠点は、大きな関数をインライン化することによ
り、コンパイルされたコードのファイル上およびメモリー上の
サイズが増大することです。スピード面でのインライン化の有
利性は小さい関数にたいして顕著なので、一般的に大きな関数
をインライン化するべきではありません。

   インライン関数は、デバッグ、トレース、アドバイス
(*note Advising Functions::を参照してください)に際してう
まく機能しません。デバッグの容易さと関数の再定義の柔軟さ
はEmacsの重要な機能なので、スピードがとても重要であり、
‘defun’の使用が実際に性能の面で問題となるのか検証するた
めにすでにコードをチューニングしたのでなければ、たとえそ
の関数が小さくてもインライン化するべきでは ありません。

   インライン関数が実行するのと同じコードに展開されるマ
クロ(*note Macros::を参照してください)を定義することは可
能です。しかし式内でのマクロの直接の使用には制限がありま
す — ‘apply’、‘mapcar’などでマクロを呼び出すことはできま
せん。通常の関数からマクロへの変換には、そのための余分な
作業が必要になります。通常の関数をインライン関数に変換す
るのは簡単です。‘defun’を‘defsubst’に置き換えるだけです
。インライン関数の引数はそれぞれ正確に1回評価されるので
、マクロのときのように、bodyで引数を何回使用するか心配す
る必要はありません。

   インライン関数を定義した後、そのインライン展開はマク
ロ同様、同じファイル内の後の部分で処理されます。


File: elisp,  Node: Declare Form,  Next: Declaring Functions,  Prev: Inline Functions,  Up: Functions

12.13 The ‘declare’ Form
========================

‘declare’(宣言)は特別なマクロで、関数やマクロに“メタ”プ
ロパティーを追加するために使用できます。たとえば陳腐化し
ているとマークしたり、Emacs Lispモード内の特別な<TAB>イ
ンデント規則を与えることができます。

 -- Macro: declare specs...
     このマクロは引数を無視して、‘nil’として評価され、実
     行時の効果はありません。しかし‘defun’または
     ‘defsubst’(*note Defining Functions::を参照してくだ
     さい)、または‘defmacro’マクロ(*note Defining
     Macros::を参照してください)の定義のDECLARE引数に
     ‘declare’フォームがある場合は、SPECSで指定されたプ
     ロパティーを関数またはマクロに追加します。これは
     ‘defun’、‘defsubst’、‘defmacro’により特別に処理され
     ます。

     SPECS内の各要素は‘(PROPERTY ARGS...)’というフォーム
     をもつべきです。また、クォートするべきではありませ
     ん。これらは、以下の効果をもちます:

     ‘(advertised-calling-convention SIGNATURE WHEN)’
          これは
          ‘set-advertised-calling-convention’(*note
          Obsolete Functions::を参照してください)の呼び
          出しと同じように振る舞います。SIGNATUREはその
          関数(またはマクロにたいする正しい引数リスト)で
          、WHENは古い引数リストが最初に陳腐化する時期を
          示す文字列を指定します。

     ‘(debug EDEBUG-FORM-SPEC)’
          これはマクロだけに有効です。Edebugでそのマクロ
          入ったときに、EDEBUG-FORM-SPECを使用します。
          *note Instrumenting Macro Calls::を参照してく
          ださい。

     ‘(doc-string N)’
          それ自身が関数、マクロ、または変数のようなエン
          ティティーを定義するために使用される関数やマク
          ロを定義するときに使用されます。これはN番目の
          引数を示し、もしあれば、それはドキュメント文字
          列です。

     ‘(indent INDENT-SPEC)’
          この関数(またはマクロ)にたいするインデント呼び
          出しは、INDENT-SPECにしたがいます。これは関数
          でも機能しますが、通常はマクロで使用されます。
          *note Indenting Macros::を参照してください。

     ‘(obsolete CURRENT-NAME WHEN)’
          ‘make-obsolete’(*note Obsolete Functions::を参
          照してください)と同様に、関数(またはマクロ)を
          陳腐化しているとマークします。CURRENT-NAMEには
          シンボル(かわりにこのシンボルを使うことをすす
          める警告メッセージになります)、文字列(警告メッ
          セージを指定します)、または‘nil’(警告メッセー
          ジには追加の詳細が含まれません)を指定します。
          WHENには、その関数(またはマクロ)が最初に陳腐化
          する時期を示す文字列を指定します。

     ‘(compiler-macro EXPANDER)’
          これは関数だけに使用でき、最適化関数
          (optimization function)としてEXPANDERを使用す
          るようコンパイラーに告げます。‘(FUNCTION
          ARGS...)’のようなその関数への呼び出しフォーム
          に出会うと、マクロ展開機能(macro expander)は
          ARGS...と同様のフォームでEXPANDERを呼び出しま
          す。EXPANDERはその関数呼び出しのかわりに使用す
          るための新しい式、または変更されていないフォー
          ム(その関数呼び出しを変更しないことを示す)のど
          ちらかをreturnすることができます。EXPANDERには
          シンボル、またはフォーム‘(lambda (ARG) BODY)’を
          指定できます。フォームの場合、ARGは元の関数呼
          び出し式を保持して、その関数の形式に適う引数を
          使用することにより、その関数にたいする(評価さ
          れていない)引数にアクセスできます。

     ‘(gv-expander EXPANDER)’
          EXPANDERが‘gv-define-expander’と同様、汎変数と
          してマクロ(または関数)にたいする呼び出しを処理
          する関数であることを宣言します。EXPANDERはシン
          ボル、またはフォーム‘(lambda (ARG) BODY)’を指
          定できます。フォームの場合、その関数は追加でそ
          のマクロ(または関数)にアクセスできます。

     ‘(gv-setter SETTER)’
          SETTERが、汎変数としてマクロ(または関数)にたい
          する呼び出しを処理する関数であることを宣言しま
          す。SETTERはシンボル、またはフォームを指定でき
          ます。シンボルの場合、そのシンボルは
          ‘gv-define-simple-setter’に渡されます。フォー
          ムの場合は‘(lambda (ARG) BODY)’という形式で、
          その関数は追加でマクロ(または関数)にアクセスで
          き、‘gv-define-setter’に渡されます。


File: elisp,  Node: Declaring Functions,  Next: Function Safety,  Prev: Declare Form,  Up: Functions

12.14 Telling the Compiler that a Function is Defined
=====================================================

あるファイルをバイトコンパイルするとき、コンパイラーが知
らない関数について警告が生成されるときがあります(*note
Compiler Errors::を参照してください)。実際に問題がある場
合もありますが、問題となっている関数がそのコードの実行時
にロードされる他のファイルで定義されている場合が通常です
。たとえば以前は、‘fortran.el’をバイトコンパイルすると、
以下のような警告が出ていました:

     In end of data:
     fortran.el:2152:1:Warning: the function `gud-find-c-expr' is not
         known to be defined.

   実際のところ、‘gud-find-c-expr’は、Fortranモードが使
用する‘gud-find-expr-function’のローカル値(GUDからのコー
ルバック)の中だけで使用されていて、呼びだされた場合は
GUD関数がロードされます。そのような警告が実際には問題を
示さないことを知っているときには、警告を抑制したほうがよ
いでしょう。そうすれば、実際に問題があることを示す新しい
警告の識別性が良くなります。‘declare-function’を使用して
、これを行うことができます。

   必要なのは、問題となっている関数を最初に使用する前に
‘declare-function’命令を追加するだけです:

     (declare-function gud-find-c-expr "gud.el" nil)

   これは‘gud-find-c-expr’が‘gud.el’(‘.el’は省略可)の中
で定義していることを告げます。コンパイラーは関数がそのフ
ァイルで実際に定義されているとみなし、チェックを行いませ
ん。

   3つ目の引数はオプションで、‘gud-find-c-expr’の引数リ
ストを指定します。この例では、引数はありません(‘nil’と値
を指定しないのは、異なります)。それ以外の場合は、‘(file
&optional overwrite)’のようになります。引数リストを指定
する必要はありませんが、指定すればコンパイラーはその呼び
出しが宣言と合致するかチェックできます。

 -- Macro: declare-function function file &optional
          arglist fileonly
     バイトコンパイラーにたいして、引数ARGLISTをとる
     FUNCTIONが定義されていて、その定義はFILEにあるとみ
     なすように告げます。FILEONLYが非‘nil’の場合は、
     FILEが存在することだけをチェックして、実際の
     FUNCTIONの定義はチェックしないことを意味します。

   これらの関数が‘declare-function’が告げる場所で実際に
宣言されているか検証するには、‘check-declare-file’を使用
して、1つのソースファイル中のすべての
‘declare-function’呼び出しをチェックするか、
‘check-declare-directory’を使用して、特定のディレクトリ
ー配下のすべてのファイルをチェックします。

   これらのコマンドは、‘locate-library’で使用する関数の
定義を含むべきファイルを探します。ファイルが見つからない
場合、これらのコマンドは‘declare-function’の呼び出しを含
むファイルをがあるディレクトリーからの相対ファイル名に、
定義ファイル名を展開します。

   ‘.c’や‘.m’で終わるファイル名を指定することにより、プ
リミティブ関数を指定することもできます。これが有用なのは
、特定のシステムだけで定義されるプリミティブを呼び出す場
合だけです。ほとんどのプリミティブは常に定義されているの
で、それらについて警告を受け取ることはありえないはずです
。

   あるファイルがオプションとして外部のパッケージの関数
を使う場合があります。‘declare-function’命令内のファイル
名のプレフィクスを‘ext:’にすると、そのファイルが見つかっ
た場合はチェックして、見つからない場合はエラーとせずにス
キップします。

   ‘check-declare’が理解しない関数定義もいくつか存在しま
す(たとえば‘defstruct’や、その他いくつかのマクロ)。その
ような場合、‘declare-function’のFILEONLY引数に、非
‘nil’を渡すことができます。これはファイルの存在だけをチ
ェックして、その関数の実際の定義はチェックしないことを意
味します。これを行う場合、引数リストを指定する必要はない
のですが、ARGLIST引数には‘t’をセットするべきだということ
に注意してください(なぜなら‘nil’は、引数リストが指定され
なかったという意味ではなく、空の引数リストを意味するから
です)。


File: elisp,  Node: Function Safety,  Next: Related Topics,  Prev: Declaring Functions,  Up: Functions

12.15 Determining whether a Function is Safe to Call
====================================================

SESのようないくつかのメジャーモードは、ユーザーファイル
内に格納された関数を呼び出します(*note (ses)Top::, for
more information on SESを参照してください)。 ユーザーフ
ァイルには素性があやふやな場合があります — 初対面の人か
ら受け取ったスプレッドシートかもしれず、会ったことのない
誰かから受け取ったeメールかもしれません。そのため、ユー
ザーファイルに格納されたソースコードの関数を呼び出すのは
、それが安全だと決定されるすまでは危険です。

 -- Function: unsafep form &optional unsafep-vars
     FORMが“安全(safe)”なLisp式の場合は‘nil’、危険な場合
     はなぜその式が危険かもしれないのか説明するリストを
     returnします。引数UNSAFEP-VARSは、この時点で一時的
     なバインドだと判っているシンボルのリストです。これ
     は主に内部的な再帰呼び出しで使用されます。カレント
     バッファーは暗黙の引数になり、これはバッファーロー
     カルなバインディングのリストを提供します。

   高速かつシンプルにするために、‘unsafep’は、とても軽量
な分析を行うので、実際には安全な多くのLisp式を拒絶します
。安全ではない式にたいして、‘unsafep’が‘nil’をreturnする
ケースは確認されていません。しかし“安全”なLisp式は
‘display’プロパティーと一緒に文字列をreturnでき、これは
その文字列がバッファーに挿入された後に実行される、割り当
てられたLisp式を含みます。割り当てられた式は、ウィルスか
もしれません。安全であるためには、バッファーへ挿入する前
に、ユーザーコードにより計算されたすべての文字列からプロ
パティーを削除しなければなりません。


File: elisp,  Node: Related Topics,  Prev: Function Safety,  Up: Functions

12.16 Other Topics Related to Functions
=======================================

以下のテーブルは、関数呼び出しと関数定義に関連したことを
行ういくつかの関数です。これらは別の場所で説明されている
ので、ここではクロスリファレンスを提供します。

‘apply’
     *note Calling Functions::を参照してください。

‘autoload’
     *note Autoload::を参照してください。

‘call-interactively’
     *note Interactive Call::を参照してください。

‘called-interactively-p’
     *note Distinguish Interactive::を参照してください。

‘commandp’
     *note Interactive Call::を参照してください。

‘documentation’
     *note Accessing Documentation::を参照してください。

‘eval’
     *note Eval::を参照してください。

‘funcall’
     *note Calling Functions::を参照してください。

‘function’
     *note Anonymous Functions::を参照してください。

‘ignore’
     *note Calling Functions::を参照してください。

‘indirect-function’
     *note Function Indirection::を参照してください。

‘interactive’
     *note Using Interactive::を参照してください。

‘interactive-p’
     *note Distinguish Interactive::を参照してください。

‘mapatoms’
     *note Creating Symbols::を参照してください。

‘mapcar’
     *note Mapping Functions::を参照してください。

‘map-char-table’
     *note Char-Tables::を参照してください。

‘mapconcat’
     *note Mapping Functions::を参照してください。

‘undefined’
     *note Functions for Key Lookup::を参照してください
     。


File: elisp,  Node: Macros,  Next: Customization,  Prev: Functions,  Up: Top

13 Macros
*********

“マクロ(macros)”は、新たな制御構造や、他の言語機能の定義
を可能にします。マクロは関数のように定義されますが、値の
計算方法を指定するかわりに、値を計算する別のLisp式を計算
する方法を指示します。わたしたちはこの式のことをマクロの
“展開形(expansion)”と呼んでいます。

   マクロは、関数が行うように引数の値を処理するのではな
く、引数のために未評価の式を処理することにより、これを行
うことができます。したがってマクロは、これらの引数式また
はその一部をを含む式を構築することができます。

   マクロを使用して通常の関数が行えることを行う場合、単
にそれが速度面の理由ならば、かわりにインライン関数の使用
を考慮してください。*note Inline Functions::を参照してく
ださい。

* Menu:

* Simple Macro::             基本的な例。
* Expansion::                いつ、なぜ、どのようにしてマクロが展開されるか。
* Compiling Macros::         コンパイラーによりマクロが展開される方法。
* Defining Macros::          マクロ定義を記述する方法。
* Problems with Macros::     マクロ引数を何回も評価しないこと。ユーザーの変数を隠さないこと。
* Indenting Macros::         マクロ呼び出しのインデント方法の指定。


File: elisp,  Node: Simple Macro,  Next: Expansion,  Up: Macros

13.1 A Simple Example of a Macro
================================

Cの‘++’演算子のように、変数の値をインクリメントするため
のLisp構造を定義したいとします。‘(inc x)’のように記述す
ると、‘(setq x (1+ x))’という効果を得たいとします。以下
はこれを行うマクロ定義です:

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

   これを‘(inc x)’のように呼び出すと、引数VARはシンボル
‘x’になります — 関数のときのように‘x’の_値_では_ありませ
ん_。このマクロのbodyはこれを展開の構築に使用して、展開
形は‘(setq x (1+ x))’になります。マクロが1度この展開形を
returnすると。Lispはそれを評価するので、‘x’はインクリメ
ントされます。

 -- Function: macrop object
     この術後は、その引数がマクロかどうかテストして、も
     しマクロなら‘t’、それ以外は‘nil’をreturnします。


File: elisp,  Node: Expansion,  Next: Compiling Macros,  Prev: Simple Macro,  Up: Macros

13.2 Expansion of a Macro Call
==============================

マクロ呼び出しは、関数の呼び出しと同じ外観をもち、マクロ
の名前で始まるリストで表されます。そのリストの残りの要素
は、マクロの引数になります。

   マクロ呼び出しの評価は、1つの重大な違いを除き、関数の
評価と同じように開始されます。重要な違いとは、そのマクロ
の引数はマクロ呼び出し内で実際の式として現れます。これら
の引数はマクロ定義に与えられる前には評価されません。対象
的に、関数の引数は、その関数の呼び出しリストの要素を評価
した結果です。

   こうして得た引数を使用して、Lispは関数呼び出しのよう
に、マクロ定義を呼び出します。マクロの引数変数はマクロ呼
び出しの引数値にバインドされるか、a ‘&rest’引数の場合は
引数地のリストになります。そして、そのマクロのbodyが実行
されて、関数bodyが行うように、マクロbodyの値をreturnsし
ます。

   マクロと関数の2つ目の重要な違いは、マクロのbodyから
returnされる値が、代替となるLisp式であることで、これはマ
クロの“展開(expansion)”としても知られます。Lispインター
プリターは、マクロから展開形が戻されると、すぐにその展開
形の評価を行います。

   展開形は通常の方法で評価されるので、もしかしたらその
展開形は他のマクロの呼び出しを含むかもしれません。一般的
ではありませんが、もしかすると同じマクロを呼び出すかもし
れません。

   EmacsはコンパイルされていないLispファイルをロードする
ときに、マクロの展開を試みることに注意してください。これ
は常に利用可能ではありませんが、もし可能なら、それ以降の
実行の速度を改善します。*note How Programs Do Loading::を
参照してください。

   ‘macroexpand’を呼び出すことにより、与えられたマクロ呼
び出しにたいする展開形を確認することができます。

 -- Function: macroexpand form &optional environment
     この関数は、それがマクロ呼び出しの場合は、FORMを展
     開します。結果が他のマクロ呼び出しの場合は、結果が
     マクロ呼び出しでなくなるまで、順番に展開を行います
     。これは‘macroexpand’からreturnされる値になります。
     FORMがマクロ呼び出しで開始されない場合、与えられた
     FORMをそのままreturnします。

     ‘macroexpand’は、(たとえいくつかのiマクロ定義がそれ
     を行っているとしても)FORMの部分式(subexpression)を
     調べないことに注意してください。たとえ部分式自身が
     マクロ呼び出しの場合でも、‘macroexpand’はそれらを展
     開しません。

     関数‘macroexpand’は、インライン関数の呼び出しを展開
     しません。なぜならインライン関数の呼び出しは、通常
     の関数呼び出しと比較して理解が難しい訳ではないので
     、通常はそれを行う必要がないからです。

     ENVIRONMENTが与えられた場合、それはそのとき定義され
     ているマクロをシャドーするマクロのalistを指定します
     。バイトコンパイルはこの機能を使用します。

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))

          (macroexpand '(inc r))
               ⇒ (setq r (1+ r))

          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))

          (macroexpand '(inc2 r s))
               ⇒ (progn (inc r) (inc s))  ; ここでは‘inc’は展開されない。

 -- Function: macroexpand-all form &optional environment
     ‘macroexpand-all’は‘macroexpand’と同様、マクロを展
     開しますが、ドップレベルだけではなく、FORM内のすべ
     てのマクロを探して展開します。展開されたマクロがな
     い場合、return値は、FORMと‘eq’になります。

     上記‘macroexpand’で使用した例を‘macroexpand-all’に
     用いると、‘macroexpand-all’が‘inc’に埋め込まれた呼
     び出しの展開を_行う_ことを確認できます:

          (macroexpand-all '(inc2 r s))
               ⇒ (progn (setq r (1+ r)) (setq s (1+ s)))


File: elisp,  Node: Compiling Macros,  Next: Defining Macros,  Prev: Expansion,  Up: Macros

13.3 Macros and Byte Compilation
================================

なぜわざわざマクロにたいする展開形を計算して、その後に展
開形を評価する手間をかけるのか、不思議に思うかもしれませ
ん。なぜマクロbodyは直接望ましい結果を生成しないのでしょ
うか? それはコンパイルする必要があるからです。

   コンパイルされるLispプログラム内にマクロ呼び出しがあ
るとき、Lispコンパイラーはインタープリターが行うようにマ
クロ定義を呼び出して、展開形を受け取ります。しかし展開形
を評価するかわりに、コンパイラーは展開形が直接プログラム
内にあるかのようにコンパイルを行います。結果として、コン
パイルされたコードはそのマクロにたいする値と副作用を生成
しますが、実行速度は完全にコンパイルされた行されたときと
同じになります。もしマクロbody自身が値と副作用を計算した
ら。このようには機能しません — コンパイル時に計算される
ことになり、それは有用ではありません。

   マクロ呼び出しのコンパイルが機能するためには、マクロ
を呼び出すコードがコンパイルされるとき、そのマクロが
Lisp内ですでに定義されていなければなりません。コンパイラ
ーには、これを行うのを助ける特別な機能があります。コンパ
イルされるファイルが‘defmacro’フォームを含む場合、そのフ
ァイルの残りの部分をコンパイルするために、そのマクロが一
時的に定義されます。

   ファイルをバイトコンパイルすると、ファイル内のトップ
レベルにある任意の‘require’呼び出しも実行されるので、そ
れらを定義しているファイルをrequireすることにより、コン
パイルの間、必要なマクロ定義が利用できることが確実になり
ます(*note Named Features::を参照してください)。誰かがコ
ンパイルされたプログラムを_実行_するときに、マクロ定義フ
ァイルのロードをしないようにするには、‘require’呼び出し
の周囲に‘eval-when-compile’を記述します(*note Eval
During Compile::を参照してください)。


File: elisp,  Node: Defining Macros,  Next: Problems with Macros,  Prev: Compiling Macros,  Up: Macros

13.4 Defining Macros
====================

Lispのマクロオブジェクトは、CARが‘macro’で、CDRが関数の
リストです。マクロの展開形は、マクロ呼び出しから、_評価
されていない_引数のリストに、(‘apply’を使って)関数を適用
することにより機能します。

   無名関数のように無名Lispマクロを使用することも可能で
すが、無名マクロを‘mapcar’のようなファンクショナルに渡す
ことに意味がないので、これが行われることはありません。実
際のところ、すべてのLispマクロは名前をもち、ほとんど常に
‘defmacro’マクロで定義されます。

 -- Macro: defmacro name args [doc] [declare] body...
     ‘defmacro’はシンボルNAME(クォートはしない)を、以下
     のようなマクロ押して定義します:

          (macro lambda ARGS . BODY)

     (このリストのCDRはラムダ式であることに注意してくだ
     さい。) このマクロオブジェクトは、NAMEの関数セルに
     格納されます。ARGSの意味は関数の場合と同じで、キー
     ワード‘&rest’および‘&optional’が使用されることもあ
     ります(*note Argument List::を参照してください)。
     NAMEとARGSはどちらも、クォートされるべきではありま
     せん。‘defmacro’のreturn値は未定義です。

     DOCが与えられた場合、それはマクロのドキュメント文字
     列を指定する文字列です。DECLAREが与えられた場合、そ
     れはマクロのメタデータを指定する‘declare’フォームで
     す(*note Declare Form::を参照してください)。マクロ
     を対話的に呼び出すことはできないので、インタラクテ
     ィブ宣言をもつことはできないことに注意してください
     。

   マクロが、定数部と非定数部の混合体から構築される巨大
なリスト構造を必要とする場合があります。これを簡単に行う
ためには、‘`’構文(*note Backquote::を参照してください)を
使用します。たとえば:

          (defmacro t-becomes-nil (variable)
            `(if (eq ,variable t)
                 (setq ,variable nil)))

          (t-becomes-nil foo)
               ≡ (if (eq foo t) (setq foo nil))

   マクロ定義のbodyには、そのマクロに関する追加のプロパ
ティーを指定する、‘declare’フォームを含めることができま
す。*note Declare Form::を参照してください。


File: elisp,  Node: Problems with Macros,  Next: Indenting Macros,  Prev: Defining Macros,  Up: Macros

13.5 Common Problems Using Macros
=================================

マクロ展開が、直感に反する結果となることがあり得ます。こ
のセクションでは、問題になりかねない重要な結果と、問題を
避けるためにしたがうべきルールをいくつか説明します。

* Menu:

* Wrong Time::               マクロ内ではなく展開形で作業を行う。
* Argument Evaluation::      展開形は各マクロ引数を1度評価するべきです。
* Surprising Local Vars::    展開形でのローカル変数バインディングには特別な注意が必要です。
* Eval During Expansion::    評価せずに展開形の中に配置してください。
* Repeated Expansion::       展開が行われる回数への依存を避ける。


File: elisp,  Node: Wrong Time,  Next: Argument Evaluation,  Up: Problems with Macros

13.5.1 Wrong Time
-----------------

マクロを記述する際のもっとも一般的な問題は、展開形の中で
はなく、マクロ展開中に、早まって実際に何らかの作業を行っ
てしまうことがあります。たとえば、実際のパッケージが以下
のマクロ定義をもつとします:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           (set-buffer-multibyte arg)))

   この誤ったマクロ定義は、解釈(interpret)されるときは正
常に機能しますが、コンパイル時に失敗します。このマクロ定
義はコンパイル時に‘set-buffer-multibyte’を呼び出してしま
いますが、それは間違っています。その後でコンパイルされた
パッケージを実行しても何も行いません。プログラマーが実際
に望むのは、以下の定義です:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           `(set-buffer-multibyte ,arg)))

このマクロは、もし適切なら‘set-buffer-multibyte’の呼び出
しに展開され、それはコンパイルされたプログラム実行時に実
行されるでしょう。


File: elisp,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros

13.5.2 Evaluating Macro Arguments Repeatedly
--------------------------------------------

マクロを定義する場合、展開形が実行されるときに引数が何回
評価されるか注意を払わなければなりません。以下の(繰り返
し処理を用意にする)マクロで、この問題を示してみましょう
。このマクロで“for”によるループ構造を記述できます。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (list 'let (list (list var init))
             (cons 'while
                   (cons (list '<= var final)
                         (append body (list (list 'inc var)))))))

     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ↦
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "\n%d %d" i square))
         (inc i)))

          ⊣1       1
          ⊣2       4
          ⊣3       9
     ⇒ nil

マクロ内の引数‘from’、‘to’、‘do’は、“構文糖(syntactic
sugar)”であり、完全に無視されます。このアイデアは、マク
ロ呼び出し中で(‘from’, ‘to’, and ‘do’のような)余計な単語
を、これらの位置に記述できるようにするというものです。

   以下は、バッククォートの使用により、より単純化された
等価の定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       `(let ((,var ,init))
          (while (<= ,var ,final)
            ,@body
            (inc ,var))))

   この定義のフォームは両方(バッククォートのあるものと、
ないもの)とも、各繰り返しにおいて毎回FINALが評価されると
いう欠点をもちます。FINALが定数のときには、問題はありま
せん。しかし、これがより複雑な、たとえば
‘(long-complex-calculation x)’のようなフォームの場合、実
効速度は顕著に低下し得ます。FINALが副作用をもつ場合には
、複数回実行すると、おそらく正しくなくなります。

   うまく設計されたマクロ定義は、繰り返し評価することが
そのマクロの意図された目的でない限り、引数を正確に1回評
価を行う展開形を生成することにより、この問題を避けるため
にステップを費やします。以下は‘for’マクロの正しい展開形
です:

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

   以下はこの展開形を生成するためのマクロ定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   残念なことに、この訂正により、以下のセクションで説明
する、別の問題が発生します。


File: elisp,  Node: Surprising Local Vars,  Next: Eval During Expansion,  Prev: Argument Evaluation,  Up: Problems with Macros

13.5.3 Local Variables in Macro Expansions
------------------------------------------

前のセクションでは、‘for’の定義を、展開形がマクロ引数を
正しい回数評価するように訂正しました:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   ‘for’の新しい定義には、新たな問題があります。この定義
は、ユーザーが意識していない、‘max’という名前のローカル
変数を導入しています。これは、以下の例で示すようなトラブ
ルを招きます:

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

‘for’のbodyの内部の‘max’への参照は、‘max’のユーサーバイ
ンディングの参照を意図したものですが、実際には‘for’によ
り作られたバインディングにアクセスします。

   これを修正する方法は、‘max’のかわりにinternされていな
い(uninterned)シンボルを使用することです(*note Creating
Symbols::を参照してください)。internされていないシンボル
は他のシンボルと同じようにバインドして参照することができ
ますが、‘for’により作成されるので、わたしたちはすでにユ
ーザーのプログラムに存在するはずがないことを知ることがで
きます。これはinternされていないので、プログラムの後続の
部分でそれを配置する方法はありません。これは‘for’により
配置された場所をのぞき、他の場所で配置されることはありま
せん。以下はこの方法で機能する‘for’の定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         `(let ((,var ,init)
                (,tempvar ,final))
            (while (<= ,var ,tempvar)
              ,@body
              (inc ,var)))))

作成されたinternされていないシンボルの名前は‘max’で、こ
れを通常のinternされたシンボル‘max’のかわりに、式内のそ
の位置に記述します。


File: elisp,  Node: Eval During Expansion,  Next: Repeated Expansion,  Prev: Surprising Local Vars,  Up: Problems with Macros

13.5.4 Evaluating Macro Arguments in Expansion
----------------------------------------------

マクロ定義自体が、‘eval’(*note Eval::を参照してください
)の呼び出しなどによりマクロ引数式を評価した場合には、別
の問題が発生します。その引数がユーザーの変数を参照する場
合、ユーザーがマクロ引数と同じな前で変数をしようとした場
合に問題となるでしょう。マクロのbodyないでは、マクロ引数
のバインディングは、その変数のもっともローカルなバインデ
ィングなので、そのフォーム内部の任意の参照は、それを参照
するように評価されます。以下は例です:

     (defmacro foo (a)
       (list 'setq (eval a) t))
     (setq x 'b)
     (foo x) ↦ (setq b t)
          ⇒ t                  ; ‘b’がセットされる。
     ;; but
     (setq a 'c)
     (foo a) ↦ (setq a t)
          ⇒ t                  ; しかし、これは‘c’ではなく‘a’がセットされる。


   ユーザーの変数の名前が‘a’か‘x’かということで、違いが
生じています。これは‘a’が、マクロの引数変数‘a’と競合して
いるからです。

   マクロ定義内での‘eval’の呼び出しにまつわる別の問題は
、それがおそらくコンパイル時にあなたが意図したことを行わ
ないだろうということです。バイトコンパイラーは、そのプロ
グラム自身の(あなたが‘eval’でアクセスしたいと望む)計算は
発生せず、ローカル変数バインディングも存在しないプログラ
ムのコンパイル時にマクロ定義を実行します。

   この問題を避けるためには、*マクロ展開形の計算では引数
式を評価しないでください*。かわりにその式をマクロ展開形
の中に置き換えれば、その値は展開形の実行の一部として計算
されます。これは、このチャプターの他の例が機能する方法で
す。


File: elisp,  Node: Repeated Expansion,  Prev: Eval During Expansion,  Up: Problems with Macros

13.5.5 How Many Times is the Macro Expanded?
--------------------------------------------

マクロ呼び出しは逐次解釈される関数で毎回マクロ呼び出しが
展開されるが、コンパイルされた関数では(コンパイル時に
)1回だけしか展開されないという事実にもとづく問題が、時折
発生します。そのマクロ定義が副作用をもつ場合、それらのマ
クロは、そのマクロが難解展開されたかにより、異なる動作を
とるでしょう。

   したがって、あなたが何をしているか本当に判っていない
のであれば、マクロ展開形の計算での副作用は避けるべきです
。

   避けることのできない特殊な副作用が1つあります。それは
Lispオブジェクトの構築です。ほとんどすべてのマクロ展開形
には、リストの構築が含まれます。リスト構築はほとんどのマ
クロの核心部分です。これは通常は安全です。用心しなければ
ならないケースが1つだけあります。それは構築するオブジェ
クトが、マクロ展開形の中でクォートされた定数の一部となる
ときです。

   そのマクロが1回だけ — コンパイル時 — しか展開されない
場合、そのオブジェクトの構築もコンパイル時の1回です。し
かし逐次実行では、そのマクロはマクロ呼び出しが実行される
たびに展開され、これは毎回新たなオブジェクトが構築される
ことを意味します。

   クリーンなLispコードのほとんどでは、この違いは問題に
なりません。しかし、マクロ定義によるオブジェクト構築の副
作用を処理する場合には、問題になるかもしれません。したが
って問題を避けるために、*マクロ定義によるオブジェクト構
築の副作用を避けてください*。以下は副作用により問題が起
こる例です:

     (defmacro empty-object ()
       (list 'quote (cons nil nil)))

     (defun initialize (condition)
       (let ((object (empty-object)))
         (if condition
             (setcar object condition))
         object))

‘initialize’が解釈された場合、‘initialize’が呼び出される
たびに、新しいリスト‘(nil)’が構築されます。したがって、
各呼び出しの間において、副作用は存続しません。しかし
‘initialize’がコンパイルされた場合、マクロ
‘empty-object’はコンパイル時に展開され、これは1つの“定数
”‘(nil)’を生成し、この定数は‘initialize’の毎回の呼び出し
で、再利用・変更されます。

   このような異常な状態を避ける1つの方法は、
‘empty-object’を、メモリー割り当て構造ではなく、一種の奇
妙な変数と考えることです。‘'(nil)’のような定数にたいして
‘setcar’を使うことはないでしょうから、当然
‘(empty-object)’にも使うことはないでしょう。


File: elisp,  Node: Indenting Macros,  Prev: Problems with Macros,  Up: Macros

13.6 Indenting Macros
=====================

マクロ定義では、マクロ呼び出しを<TAB>がどのようにインデ
ントすべきか指定するために、‘declare’フォーム(*note
Defining Macros::を参照してください)を使うことができます
。インデント指定は以下のように記述します:

     (declare (indent INDENT-SPEC))

以下は利用できるINDENT-SPECです:

‘nil’
     これはプロパティーを指定しない場合と同じ — 標準的な
     インデントパターンを使用します。
‘defun’
     この関数を‘def’構造 — 2番目の行が“body”の開始 — と
     同様に扱います。
整数: NUMBER
     関数の最初のNUMBER個の引数は“区別”され、残りは式の
     bodyと判断されます。その式の中の行は、最初の引数が
     区別されているかどうかにしたがってインデントされま
     す。引数がbodyの一部である場合、その行はこの式の先
     頭の 開きカッコ(open-parenthesis)よりも
     ‘lisp-body-indent’だけ多い列にインデントされます。
     引数が 区別されていて、1つ目または2つ目の引数である
     場合は、_2倍_余分にインデントされます。引数が区別さ
     れていて1つ目あるいは2つ目の引数でない場合、その行
     は標準パターンによってインデントされます。
シンボル: SYMBOL
     SYMBOLは関数名です。その関数はこの式のインデントを
     計算するために呼び出される関数です。この関数は2つの
     引数をとります:

     POS
          その行のインデントが開始される位置です。
     STATE
          その行の開始まで解析されたとき、
          ‘parse-partial-sexp’(インデントとネスト深さの
          計算のためのLispプリミティブ)によりreturnされ
          る値です。

     これは、数(その行のインデントの列数)、またはそのよ
     うな数がcarであるようなリストをreturnすべきです。数
     とリストの違いは、数の場合、同じネスト深さの後続の
     すべての行はこの数と同じインデントとなります。リス
     トの場合、後続の行は異なるインデントを呼び出すかも
     しれません。これは、‘C-M-q’によりインデントが計算さ
     れるときに違いがでます。値が数の場合、‘C-M-q’はリス
     トの終わりまでの後続の行のインデントを、再計算する
     必要はありません。


File: elisp,  Node: Customization,  Next: Loading,  Prev: Macros,  Up: Top

14 Customization Settings
*************************

Emacsのユーザーは、カスタマイズインターフェースにより、
Lispコードを記述することなく。変数とフェースをカスタマイ
ズできます。*note (emacs)Easy Customization::を参照して
ください。このチャプターでは、カスタマイズインターフェー
スを通じて、ユーザーとやりとりするための、“カスタマイズ
アイテム（customization items）”を定義する方法を説明しま
す。

   カスタマイズアイテムには、カスタマイズ可能変数
(customizable variable: ‘defcustom’マクロで定義される。
*note Variable Definitions::を参照してください)、 カスタ
マイズ可能フェース(customizable face: ‘defface’で定義さ
れる。*note Defining Faces::を参照してください)、および
関連するカスタマイズアイテムのグループのためのコンテナー
として働くカスタマイズグループ(customization group:
‘defgroup’で定義される。*note Group Definitions::を参照
してください) が含まれます。

* Menu:

* Common Keywords::          すべての種類のカスタマイズ宣言に共通なキーワード。
* Group Definitions::        カスタマイズグループ定義の記述。
* Variable Definitions::     ユーザーオプションの宣言。
* Customization Types::      ユーザーオプションの型指定。
* Applying Customizations::  カスタマイズセッティングを適用する関数。
* Custom Themes::            カスタムテーマの記述。


File: elisp,  Node: Common Keywords,  Next: Group Definitions,  Up: Customization

14.1 Common Item Keywords
=========================

以降のセクションで説明するカスタマイズ宣言(customization
declaration) — ‘defcustom’、‘defgroup’などはすべて、さま
ざまな情報を指定するためのキーワード引数(*note Constant
Variables::を参照してください)を受け取ります。このセクシ
ョンでは、カスタマイズ宣言のすべての種類に適用されるキー
ワードを説明します。

   ‘:tag’以外のすべてのキーワードは、与えられたアイテム
にたいして複数回使用できます。キーワードの使用はそれぞれ
独立した効果をもちます。‘:tag’は例外で、これはすべての与
えられたアイテムは1つの名前だけを表示できるからです。

‘:tag LABEL’
     LABELを使用すると、カスタマイズメニュー
     (customization menu)およびカスタマイズバッファー
     (customization buffer)のアイテムのラベルづけに、そ
     のアイテムの名前のかわりに指定された文字列を使用し
     ます。*混乱を招くので、そのアイテムの実際の名前と、
     大きく異なる名前は使用しないでください*。

‘:group GROUP’
     このカスタマイズアイテムを、グループGROUPに配します
     。‘defgroup’内で‘:group’を使用した場合、そのアイテ
     ムは新しいグループ(‘:group’のサブグループ)になりま
     す。

     このキーワードを複数回使用した場合、1つのアイテムを
     複数のグループに配すことができます。これらのグルー
     プのどれかを表示すると、このアイテムが表示されます
     。煩わしくなるので、多用しないでください。

‘:link LINK-DATA’
     このアイテムのドキュメント文字列の後に外部リンクを
     含めます。これは他のドキュメントを参照する、センテ
     ンスを含むボタンです。

     LINK-DATAに使用できる複数の候補があります:

     ‘(custom-manual INFO-NODE)’
          infoノードへのリンクです。INFO-NODEは、
          ‘"(emacs)Top"’のような、ノード名を示す文字列で
          す。このリンクはカスタマイズバッファーの
          ‘[Manual]’に表示され、INFO-NODEにたいしてビル
          トインのinfoリーダーを起動します。

     ‘(info-link INFO-NODE)’
          ‘custom-manual’と同様ですが、カスタマイズバッ
          ファーには、そのinfoノード名が表示されます。

     ‘(url-link URL)’
          ウェブページヘのリンクです。URLはURLを指定する
          文字列です。カスタマイズバッファーに表示される
          リンクは、‘browse-url-browser-function’で指定
          されたWWWブラウザーを呼び出します。

     ‘(emacs-commentary-link LIBRARY)’
          ライブラリーのコメントセクション(commentary
          section)へのリンクです。LIBRARYはライブラリー
          名を指定する文字列です。*note Library
          Headers::を参照してください。

     ‘(emacs-library-link LIBRARY)’
          Emacs Lispライブラリーファイルへのリンクです。
          LIBRARYはライブラリー名を指定する文字列です。

     ‘(file-link FILE)’
          ファイルへのリンクです。FILEは、ユーザーがこの
          リンクを呼び出したときに‘find-file’でvisitする
          ファイルの名前を指定する文字列です。

     ‘(function-link FUNCTION)’
          関数のドキュメントへのリンクです。FUNCTIONは、
          ユーザーがこのリンクを呼び出したときに
          ‘describe-function’で説明を表示する関数の名前
          を指定する文字列です。

     ‘(variable-link VARIABLE)’
          変数のドキュメントへのリンクです。VARIABLEは、
          ユーザーがこのリンクを呼び出したときに
          ‘describe-variable’で説明を表示する変数の名前
          を指定する文字列です。

     ‘(custom-group-link GROUP)’
          他のカスタマイズグループへのリンクです。このリ
          ンクを呼び出すことにより、GROUPにたいする新た
          なカスタマイズバッファーが作成されます。

     LINK-DATAの1つ目の要素の後に‘:tag NAME’を追加するこ
     とにより、カスタマイズバッファーで使用するテキスト
     を指定できます。たとえば‘(info-link :tag "foo"
     "(emacs)Top")’は、そのバッファーで‘foo’と表示される
     Emacs manualへのリンクを作成します。

     複数のリンクを追加するために、このキーワードを複数
     回使用することができます。

‘:load FILE’
     このカスタマイズアイテムを表示する前に、ファイル
     FILEをロードします(*note Loading::を参照してくださ
     い)。ロードは‘load’により行われ、そのファイルがまだ
     ロードされていないときだけロードします。

‘:require FEATURE’
     保存したカスタマイズが、このアイテム値をセットする
     とき、‘(require 'FEATURE)’が実行されます。FEATUREは
     シンボルです。

     ‘:require’を使用するもっとも一般的な理由は、ある変
     数がマイナーモードのような機能を有効にするとき、そ
     のモードを実装するコードがロードされていない場合に
     は、変数をセットするだけでは効果がないからです。

‘:version VERSION’
     このキーワードは、そのアイテムが最初に導入された
     EmacsバージョンVERSION、またはそのアイテムのデフォ
     ルト値がそのバージョンで変更されたことを指定します
     。値VERSIONは文字列でなければなりません。

‘:package-version '(PACKAGE . VERSION)’
     このキーワードは、そのアイテムが最初に導入された
     PACKAGEのバージョンVERSIONまたはアイテムの意味(また
     はデフォルト値)が変更されたバージョンを指定します。
     このキーワードは‘:version’より優先されます。

     PACKAGEにはそのパッケージの公式名をシンボルとして指
     定します(たとえば‘MH-E’)。VERSIONには文字列を指定し
     ます。パッケージPACKAGEがEmacsの一部としてリリース
     された場合、PACKAGEとVERSIONの値は、
     ‘customize-package-emacs-version-alist’の値に表示さ
     れるべきです。

   Emacsの一部として配布された‘:package-version’キーワー
ドを使用するパッケージは、
‘customize-package-emacs-version-alist’変数も更新しなけ
ればなりません。

 -- Variable: customize-package-emacs-version-alist
     このalistは、Emacsのバージョンにたいして、
     ‘:package-version’キーワード内でリストされたパッケ
     ージのバージョンへのマッピングを提供します:

          (PACKAGE (PVERSION . EVERSION)...)

     PACKAGE(シンボル)それぞれにたいして、パッケージバー
     ジョンPVERSIONを含む1つ以上の要素と、それに関連づけ
     られるEmacsバージョンEVERSIONが存在します。これらの
     バージョンは文字列です。たとえばMH-Eパッケージは、
     以下でalistを更新します:

          (add-to-list 'customize-package-emacs-version-alist
                       '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                              ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                              ("7.4" . "22.1") ("8.0" . "22.1")))

     PACKAGEの値は一意である必要があり、また
     ‘:package-version’キーワード内に現れるPACKAGEの値と
     マッチする必要があります。おそらくユーザーはエラー
     メッセージからこの値を見るので、MH-EやGnusのような
     パッケージの公式名を選択するのがよいでしょう。


File: elisp,  Node: Group Definitions,  Next: Variable Definitions,  Prev: Common Keywords,  Up: Customization

14.2 Defining Customization Groups
==================================

Emacs Lispパッケージはそれぞれ、1つのメインカスタマイズ
グループ(main customization group)をもち、それにはすべて
のオプション、フェイス、そのパッケージ内の他のグルーﾌﾟが
含まれるべきです。そのパッケージには少数のオプションとフ
ェイスしかない場合は、1つのグループだけを使用して、その
中にすべてを置きます。20以上のオプションやフェイスがある
場合には、それらをサブグループ内に構造化して、そのサブグ
ループをメインカスタマイズグループの下に配します。そのパ
ッケージ内の任意のオプションまたはフェイスを、サブグルー
プと並行してメイングループに配しても構いません。

   そのパッケージのメイングループ(または唯一のグループ
)は、1つ以上の標準カスタムグループ(standard
customization group)のメンバーであるべきです(これらの完
全なリストを表示するには、‘M-x customize’を使用します)。
それらの内から1つ以上(多すぎないこと)を選択して、
‘:group’を使用してあなたのグループをそれらに追加します。

   新しいカスタマイズグループは、‘defgroup’で宣言します
。

 -- Macro: defgroup group members doc [keyword value]...
     MEMBERSを含む、カスタマイズグループとして、GROUPを
     宣言します。シンボルGROUPはクォートしません。引数
     DOCは、そのグループにたいするドキュメント文字列を指
     定します。

     引数MEMBERSは、そのグループのメンバーとなるカスタマ
     イズアイテムの初期セットを指定するリストです。しか
     しほとんどの場合はMEMBERSを‘nil’にして、メンバーを
     定義するときに‘:group’キーワードを使用することによ
     り、そのグループのメンバーを指定します。

     MEMBERSを通じてグループのメンバーを指定したい場合、
     各要素は‘(NAME WIDGET)’という形式で指定するべきです
     。ここでNAMEはシンボル、WIDGETはそのシンボルを編集
     するウィジェット型(widget type)です。有用なウィジェ
     ットには、変数にたいする‘custom-variable’、フェイス
     にたいする‘custom-face’、グループにたいする
     ‘custom-group’があります。

     Emacsに新しいグループを導入するときは、‘defgroup’内
     で‘:version’キーワードを使用します。そうすればグル
     ープの個別のメンバーに対してそれを使用する必要がな
     くなります。

     一般的なキーワード(*note Common Keywords::を参照し
     てください)に加えて、‘defgroup’ないでは以下のキーワ
     ードも使用できます:

     ‘:prefix PREFIX’
          グループ内のアイテムの名前がPREFIXで始まり、カ
          スタマイズ変数
          ‘custom-unlispify-remove-prefixes’が非‘nil’の
          場合、そのアイテムのタグからPREFIXが省略されま
          す。グループは任意の数のプレフィクスをもつこと
          ができます。

 -- User Option: custom-unlispify-remove-prefixes
     この変数が非‘nil’の場合、グループの‘:prefix’キーワ
     ードで指定されたプレフィクスは、ユーザーがグループ
     をカスタマイズするときは常に、タグ名から省略されま
     す。

     デフォルト値は‘nil’、つまりプレフィクス省略
     (prefix-discarding)の機能は無効です。これは、オプシ
     ョンやフェイスの名前にたいしてプレフィクスを省略す
     るのは、混乱を招くことがあるからです。


File: elisp,  Node: Variable Definitions,  Next: Customization Types,  Prev: Group Definitions,  Up: Customization

14.3 Defining Customization Variables
=====================================

“カスタマイズ可能変数(customizable variable)”は“ユーザー
オプション(user option)”とも呼ばれ、これはCustomizeイン
ターフェースを通じてセットできるグローなるなLisp変数です
。‘defvar’(*note Defining Variables::を参照してください
)により定義される他のグローバル変数とは異なり、カスタマ
イズ可能変数は‘defcustom’マクロを使用して定義されます。
サブルーチンとして‘defvar’を呼び出すことに加え、
‘defcustom’はCustomizeインターフェースでその変数が表示さ
れる方法や、その変数がとることができる値などを明示します
。

 -- Macro: defcustom option standard doc [keyword
          value]...
     このマクロはユーザーオプション(またはカスタマイズ可
     能変数)としてOPTIONを宣言します。OPTIONはクォートす
     るべきではありません。

     引数STANDARDは、OPTIONの標準値を指定する式です。
     ‘defcustom’フォームの評価により、STANDARDが評価され
     ますが、その値にオプションをバインドする必要はあり
     ません。OPTIONがすでにデフォルト値をもつ場合、それ
     は変更されずに残ります。ユーザーがすでにOPTIONにた
     いするカスタマイズを保存している場合、ユーザーによ
     りカスタマイズされた値がデフォルト値としてインスト
     ールされます。それ以外は、STANDARDを評価した結果が
     デフォルト値としてインストールされます。

     ‘defvar’と同様、このマクロは‘option’をスペシャル変
     数 — 常にダイナミックにバインドされるべきことを意味
     する — としてマークします。OPTIONがすでにレキシカル
     バインドをもつ場合、そのレキシカルバインドはバイン
     ディング構造を抜けるまで効果をもちます。*note
     Variable Scoping::を参照してください。

     式STANDARDは別の様々な機会にも — カスタマイズ機能が
     OPTIONの標準値を知る必要があるときは常に — 評価され
     る可能性があります。そのため任意回数評価しても安全
     な式を使用するように気をつけてください。

     引数DOCは、その変数にたいするドキュメント文字列を指
     定します。

     ‘defcustom’が何も‘:group’を指定しない場合、同じファ
     イル内で‘defgroup’により最後に定義されたグループが
     使用されます。この方法では、ほとんどの‘defcustom’は
     明示的な‘:group’が必要なくなります。

     Emacs Lispモードで‘C-M-x’(‘eval-defun’)により
     ‘defcustom’フォームを評価するとき、‘eval-defun’の特
     別な機能は、変数の値がvoidかどうかテストせず、無条
     件に変数をセットする段取りをします(同じ機能は
     ‘defvar’にも適用されます。*note Defining
     Variables::を参照してください)。すでに定義された
     defcustomで‘eval-defun’を使用することにより、(もし
     あれば)‘:set’関数が呼び出されます(以下参照)。

     事前ロード( pre-loaded)されたEmacs Lispファイル
     (*note Building Emacs::を参照してください)に
     ‘defcustom’を配した場合、ダンプ時にインストールされ
     た標準値は正しくない — たとえば依存している他の変数
     は、まだ正しい値を割り当てられていない —　かもしれま
     せん。この場合、Emacs起動後に標準値を再評価するため
     に、以下で説明する‘custom-reevaluate-setting’を使用
     します。

   *note Common Keywords::にリストされたキーワードに加え
、このマクロには以下のキーワードを指定できます:

‘:type TYPE’
     このオプションのデータ型として、TYPEを使用します。
     これはどんな値が適正なのか、その値をどのように表示
     するかを指定します(*note Customization Types::を参
     照してください)。

‘:options VALUE-LIST’
     このオプションに使用する適正な値のリストを指定しま
     す。ユーザーが使用できる値はこれらの値に限定されま
     せんが、これらは便利な候補値を提示します。

     これは特定の型にたいしてだけ意味をもち、現在のとこ
     ろ‘hook’、‘plist’、‘alist’が含まれます。
     ‘:options’の使用法の説明は、個別の型の定義を参照し
     てください。

‘:set SETFUNCTION’
     Customizeインターフェースを使用してこのオプションの
     値を変更する方法として、SETFUNCTIONを指定します。関
     数SETFUNCTIONは2つの引数 — シンボル(オプション名)と
     新しい値 — をとり、このオプションにたいして正しく値
     を更新するために必要なことは何であれ行うべきです(こ
     れはおそらくLisp変数として単にオプションをセットす
     ることを意味しないでしょう)。望ましくは、この関数は
     引数の値を破壊的に変更するべきではありません。
     SETFUNCTIONのデフォルトは、‘set-default’です。

     このキーワードを指定した場合、その変数のドキュメン
     ト文字列には、手入力のLispコードで同じことを行う方
     法が記載されるべきです。

‘:get GETFUNCTION’
     このオプションの値を抽出する方法として、
     GETFUNCTIONを指定します。関数GETFUNCTIONは1つの引数
     (シンボル)をとり、カスタマイズがそのシンボル(シンボ
     ルのLisp値である必要はない)にたいする“カレント値”と
     してそれを使うべきかreturnするべきです。デフォルト
     は‘default-value’です。

     ‘:get’を正しく使用するためには、Customの機能を真に
     理解する必要があります。これは変数としてCustom内で
     扱われる値のためのものですが、実際にはLisp変数に格
     納されません。実際にLisp変数に格納されている値に
     GETFUNCTIONを指定するのは、ほとんどは誤りです。

‘:initialize FUNCTION’
     FUNCTIONは、‘defcustom’が評価されるときに変数を初期
     化するために使用される関数であるべきです。これは2つ
     の引数 — オプション名(シンボル)と値をとります。この
     方法での使用のために事前定義された関数がいくつかあ
     ります:

     ‘custom-initialize-set’
          変数の初期化に、その変数の‘:set’関数を使用しま
          すが、値がすでに非voidの場合、再処帰化を行いま
          せん。

     ‘custom-initialize-default’
          ‘custom-initialize-set’と同様ですが、その変数
          の‘:set’のかわりに、関数‘set-default’を使用し
          て変数をセットします。これは変数の‘:set’関数が
          マイナーモードを有効または無効にする場合の、通
          常の選択です。この選択により、変数の定義ではマ
          イナーモード関数を呼び出しませんが、変数をカス
          タマイズしたときはマイナーモード関数を呼び出し
          ます。

     ‘custom-initialize-reset’
          変数の初期化に、常に‘:set’関数を使用します。変
          数がすでに非voidの場合、(‘:get’メソッドで
          returnされる)カレント値を使用して‘:set’関数を
          呼び出して変数をリセットします。これはデフォル
          トの‘:initialize’関数です。

     ‘custom-initialize-changed’
          変数がすでにセットされている、またはカスタマイ
          ズされている場合は、変数の初期化のために
          ‘:set’関数を使用し、それ以外は単に
          ‘set-default’を使用します。

     ‘custom-initialize-safe-set’
     ‘custom-initialize-safe-default’
          これらのn関数は‘custom-initialize-set’、
          ‘custom-initialize-default’と同様に振る舞いま
          すが、エラーをcatchします。初期化中にエラーが
          発生した場合は、‘set-default’を使用して変数を
          ‘nil’にセットして、エラーをシグナルしません。

          これらの関数は事前ロードされたファイルで定義さ
          れたオプションのためのものです(requireされた変
          数または関数がまだ定義されていないため、
          STANDARD式はエラーをシグナルするかもしれない
          )。その値は通常、‘startup.el’で更新され、
          ‘defcustom’により計算された値は無視されます。
          startup後に、その値をunsetして、‘defcustom’を
          再評価すれば、エラーなしでSTANDARDは評価されま
          す。

‘:risky VALUE’
     その変数の‘risky-local-variable’プロパティーを
     VALUEにセットします(*note File Local Variables::を
     参照してください)。

‘:safe FUNCTION’
     その変数の‘safe-local-variable’プロパティーを、
     FUNCTIONにセットします(*note File Local
     Variables::を参照してください)。

‘:set-after VARIABLES’
     保存されたカスタマイズに合わせて変数をセッティング
     するときは、その前に変数VARIABLES確実にセット — つ
     まり、これら他のものが処理される後までセッティング
     を遅延 — してください。これら他の変数が意図された値
     をもっていない場合に、この変数のセッティングが正し
     く機能しないときは、‘:set-after’を使用してください
     。

   特定の機能を“オンに切り替える”オプションにたいしては
、‘:require’キーワードを指定すると便利です。これは、その
機能がまだロードされていないときは、そのオプションがセッ
トされるとEmacsがその機能をロードするようにします。*note
Common Keywords::を参照してください。以下はライブラリー
‘saveplace.el’の例です:

     (defcustom save-place nil
       "Non-nil means automatically save place in each file..."
       :type 'boolean
       :require 'saveplace
       :group 'save-place)

   あるカスタマイズアイテムが、‘:options’がサポートする
‘hook’や‘alist’のような型をもつ場合は、
‘custom-add-frequent-value’を呼び出すことにより、
‘defcustom’宣言の外部から、別途値を追加できます。たとえ
ば‘emacs-lisp-mode-hook’から呼び出されることを意図した関
数‘my-lisp-mode-initialization’を定義する場合は、
‘emacs-lisp-mode-hook’にたいする正当な値として、その定義
を編集することなく、その関数をリストに追加したいと思うか
もしれません。これは以下のようにして行うことができます:

     (custom-add-frequent-value 'emacs-lisp-mode-hook
        'my-lisp-mode-initialization)

 -- Function: custom-add-frequent-value symbol value
     カスタマイズオプションSYMBOLにたいして正当な値のリ
     ストにVALUEを追加します。

     追加による正確な効果は、SYMBOLのカスタマイズ型に依
     存します。

   内部的には、‘defcustom’は、標準値にたいする式を記録す
るためにシンボルプロパティー‘standard-value’を、カスタマ
イズバッファーでユーザーによりセットされたが保存されてい
ない値を記録するために‘saved-value’を使用します。*note
Symbol Properties::を参照してください。これらのプロパテ
ィーは、carがその値を評価する式であるようなリストです。

 -- Function: custom-reevaluate-setting symbol
     この関数は、‘defcustom’を通じて宣言されたユーザーオ
     プションSYMBOLの標準値を再評価します。変数がカスタ
     マイズされた場合、この関数はかわりに保存された値を
     再評価します。それからこの関数はユーザーオプション
     をその値に(もし定義されていればそのオプションの
     ‘:set’プロパティーを使用して)セットします。

     これは値が正しく計算される前に定義されたカスタマイ
     ズ可能オプションにたいして有用です。たとえば
     startupの間、Emacsは事前ロードされたEmacs Lispファ
     イルで定義されたユーザーオプションにたいしてこの関
     数を呼び出しますが、これらの初期値は実行時だけ利用
     可能な情報に依存します。

 -- Function: custom-variable-p arg
     この関数は、ARGがカスタマイズ可能変数の場合は、非
     ‘nil’をreturnします。カスタマイズ可能変数とは、
     ‘standard-value’か‘custom-autoload’プロパティーをも
     つ(通常は‘defcustom’で宣言されたことを意味する)変数
     、または別のカスタマイズ可能変数にたいするエイリア
     スのことです。


File: elisp,  Node: Customization Types,  Next: Applying Customizations,  Prev: Variable Definitions,  Up: Customization

14.4 Customization Types
========================

‘defcustom’でユーザーオプションを定義するときは、ユーザ
ーオプションの“カスタマイズ型(customization type)”を指定
しなければなりません。これは、(1)値が適正か、(2)編集のた
めにカスタマイズバッファーで値を表示する方法、を記述する
Lispオブジェクトです。

   カスタマイズ型は、‘defcustom’内の‘:type’キーワードで
指定します。‘:type’の引数は評価されますが、‘defcustom’が
実行されるとき1回だけ評価されるので、さまざまな値をとる
場合には有用でありません。通常はクォートされた定数を使用
します。たとえば:

     (defcustom diff-command "diff"
       "The command to use to run diff."
       :type '(string)
       :group 'diff)

   一般的に、カスタマイズ型は、最初の要素が以降のセクシ
ョンで定義されるカスタマイズ型の1つであるような、リスト
です。このシンボルの後にいくつかの引数があり、それはその
シンボルに依存します。型シンボルと引数の間には、オプショ
ンでkeyword-valueペアー(*note Type Keywords::を参照して
ください)を記述できます。

   いくつかの型シンボルは引数を使用しません。これらは“シ
ンプル型(simple types)”と呼ばれます。シンプル型にたいし
ては、keyword-valueペアーを使用しない場合は、型シンボル
の周囲のカッコ(parentheses)を省略できます。たとえばカス
タマイズ型として単に‘string’と記述すると、それは
‘(string)’と等価です。

   すべてのカスタマイズ型はウィジェットとして実装されま
す。詳細は、*note Introduction: (widget)Top.を参照してく
ださい。

* Menu:

* Simple Types::             シンプルなカスタマイズ型(sexp、integerなど)。
* Composite Types::          他の型やデータから新しい型を構築する。
* Splicing into Lists::      ‘:inline’で要素をリストに結合する。
* Type Keywords::            カスタマイズ型でのキーワード／引数ペアー
* Defining New Types::       型に名前をつける。


File: elisp,  Node: Simple Types,  Next: Composite Types,  Up: Customization Types

14.4.1 Simple Types
-------------------

このセクションでは、すべてのシンプルデータ型を説明します
。これらのカスタマイズ型のうちのいくつかにたいして、カス
タマイズウィジェットは‘C-M-i’または‘M-<TAB>’による、イン
ライン補完を提供します。

‘sexp’
     値はプリントおよび読み込むことができる任意のLispオ
     ブジェクトです。より特化した型の使用するために時間
     をとりたくない場合は、任意のオプションへのフォール
     バックとして‘sexp’を使用することができます。

‘integer’
     値は整数でなければなりません。

‘number’
     値は数(浮動小数点数または整数)でなければなりません
     。

‘float’
     値は浮動小数点数でなければなりません。

‘string’
     値は文字列でなければなりません。カスタマイズバッフ
     ァーはその文字列を区切り文字‘"’文字および‘\’クォー
     トなしで表示します。

‘regexp’
     ‘string’文字と同様ですが、その文字列は有効な正規表
     現でなければなりません。

‘character’
     値は文字コードでなければなりません。文字コードは実
     際には整数ですが、この型は数字を表示せずに、バッフ
     ァー内にその文字を挿入することにより値を表示します
     。

‘file’
     値はファイル名でなければなりません。ウィジェットは
     補完を提供します。

‘(file :must-match t)’
     値は既存のファイル名でなければなりません。ウィジェ
     ットは補完を提供します。

‘directory’
     値はディレクトリー名でなければなりません。ウィジェ
     ットは補完を提供します。

‘hook’
     値は関数のリストでなければなりません。このカスタマ
     イズ型はフック変数にたいして使用されます。フック内
     での使用を推奨される関数のリストを指定するために、
     フック変数の‘defcustom’内で‘:options’キーワードを使
     用できます。*note Variable Definitions::を参照して
     ください。

‘symbol’
     値はシンボルでなければなりません。これはカスタマイ
     ズバッファー内でシンボル名として表示されます。ウィ
     ジェットは補完を提供します。

‘function’
     値はラムダ式か関数名でなければなりません。ウィジェ
     ットは関数名にたいする補完を提供します。

‘variable’
     値は変数名でなければなりません。ウィジェットは補完
     を提供します。

‘face’
     値はフェイス名のシンボルでなければなりません。ウィ
     ジェットは補完を提供します。

‘boolean’
     値は真偽値 — ‘nil’か‘t’です。‘choice’と‘const’を合
     わせて使用(次のセクションを参照)することにより、値
     が‘nil’か‘t’でなければならず、それぞれの値に固有の
     意味に適合する説明テキストを指定することもできます
     。

‘key-sequence’
     値はキーシーケンスです。カスタマイズバッファーは、
     ‘kbd’関数と同じ構文うぃ使用して、キーシーケンスを表
     示します。*note Key Sequences::を参照してください。

‘coding-system’
     値はコーディングシステム名でなければならず、
     ‘M-<TAB>’で保管することができます。

‘color’
     値は有効なカラー名でなければなりません。ウィジェッ
     トはカラー名にたいする補完と、同様に‘*Colors*’バッ
     ファーに表示されるカラーサンプルとカラー名のリスト
     からカラー名を選択するボタンを提供します。


File: elisp,  Node: Composite Types,  Next: Splicing into Lists,  Prev: Simple Types,  Up: Customization Types

14.4.2 Composite Types
----------------------

適切なシンプル型がないときは、複合型(composite types)を
使うことができます。複合型は特定のデータによる他の型から
、新しい型を構築します。指定された型またはデータは、その
複合型の“引数(argument)”と呼ばれます。複合型は通常、以下
のようなものです:

     (CONSTRUCTOR ARGUMENTS...)

しかし、以下のように引数の前にkeyword-valueペアーを追加
することもできます。

     (CONSTRUCTOR {KEYWORD VALUE}... ARGUMENTS...)

   以下のテーブルに、はコンストラクター(constructor)と、
複合型を記述するためにそれらを使用する方法を示します:

‘(cons CAR-TYPE CDR-TYPE)’
     値はコンスセルでなければならず、CARはCAR-TYPE、
     CDRはCDR-TYPEに適合していなければなりません。たとえ
     ば、‘(cons string symbol)’は、‘("foo" . foo)’のよう
     な値にマッチするデータ型です。

     カスタマイズバッファーでは、CARとCDRは、それぞれ特
     定のデータ型に応じて、別々に表示・編集されます。

‘(list ELEMENT-TYPES...)’
     値は、ELEMENT-TYPESで与えられる要素と数が正確に一致
     するリストでなければならず、リストの各要素はそれぞ
     れ対応するELEMENT-TYPEに適合しなければなりません。

     たとえば、‘(list integer string function)’は、３つ
     の要素のリストを示し、１つ目の要素は整数、２つ目の
     要素は文字列、３つ目の要素は関数です。

     カスタマイズバッファーでは、各要素は、それぞれ特定
     のデータ型に応じて、別々に表示・編集されます。

‘(group ELEMENT-TYPES...)’
     これは‘list’と似ていますが、Customバッファー内での
     テキストのフォーマットが異なります。‘list’は各要素
     の値を、そのタグでラベルづけしますが、‘group’はそれ
     を行いません。

‘(vector ELEMENT-TYPES...)’
     これは‘list’と似ていますが、リストではなくベクター
     でなければなりません。各要素は‘list’の場合と同様に
     機能します。

‘(alist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     値はコンスセルのリストでなければならず、各セルの
     CARはカスタマイズ型KEY-TYPEのキーを表し、同じセルの
     CDRはカスタマイズ型VALUE-TYPEの値を表します。ユーザ
     ーはkey/valueペアーの追加や削除ができ、各ペアのキー
     と値の両方を編集することができます。

     省略された場合、KEY-TYPEとVALUE-TYPEのデフォルトは
     、‘sexp’です。

     ユーザーは指定されたkey-typeにマッチする任意のキー
     を追加できますが、‘:options’(*note Variable
     Definitions::を参照してください)で指定することによ
     り、あるキーを優先的に扱うことができます。指定され
     たキーは、(適切な値とともに)常にカスタマイズバッフ
     ァーに表示されます。また、alistにkey/valueを含める
     、除外する、または無効にするかを指定するチェックボ
     ックスも一緒に表示されます。ユーザーは‘:options’キ
     ーワード引数により指定された値は、変更できません。

     ‘:options’キーワードにたいする引数は、alist内の適切
     なキーにたいする仕様のリストであるべきです。これら
     は通常、単純なアトムであり、それらは自身をを意味し
     ます。たとえば:

          :options '("foo" "bar" "baz")

     これは、名前が‘"foo"’、‘"bar"’、‘"baz"’の、３つの
     “既知”のキーがあることを指定し、それらは常に最初に
     表示されます。

     たとえば‘"bar"’キーに対応する値を整数だけにするとい
     うように、特定のキーに対して値の型を制限したいとき
     があるかもしれません。これはリスト内でアトムのかわ
     りにリストを使用することにより、指定することができ
     ます。前述のように、１つ目の要素はそのキーを指定し
     、２つ目の要素は値の型を指定します。たとえば:

          :options '("foo" ("bar" integer) "baz")

     最後に、キーが表示される方法を変更したいときもある
     かもしれません。デフォルトでは、‘:options’キーワー
     ドで指定された特別なキーはユーザーが変更できないの
     で、キーは単に‘const’として表示されます。しかし、た
     とえばそれが関数バインディングをもつシンボルだと知
     っている場合は‘function-item’といったように、あるキ
     ーの表示のために、より特化した型を使用したいと思う
     かもしれません。これは、キーに対してシンボルを使う
     かわりに、カスタマイズ型指定を使用することにより、
     行うことができます。

          :options '("foo"
                     ((function-item some-function) integer)
                     "baz")

     多くのalistは、コンスセルのかわりに２要素のリストを
     使用します。たとえば、

          (defcustom cons-alist
            '(("foo" . 1) ("bar" . 2) ("baz" . 3))
            "Each element is a cons-cell (KEY . VALUE).")

     のかわりに以下を使用します

          (defcustom list-alist
            '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE).")

     リストはコンスセルの最上位に実装されているため、上
     記の‘list-alist’を、コンスセルのalist(value-typeが
     実際の値を含む１要素のリストであるような)として扱う
     ことができます。

          (defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE)."
            :type '(alist :value-type (group integer)))

     ‘list’のかわりに‘group’を使用するのは、その目的に適
     したフォーマットのためだけです。

     同様に、以下のようなトリックの類を用いることにより
     、より多くの値が各キー連づけられたalistを得ることが
     できます:

          (defcustom person-data '(("brian"  50 t)
                                   ("dorith" 55 nil)
                                   ("ken"    52 t))
            "Alist of basic info about people.
          Each element has the form (NAME AGE MALE-FLAG)."
            :type '(alist :value-type (group integer boolean)))

‘(plist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     このカスタマイズ型は‘alist’(上位参照)と似ていますが
     、(1)情報がプロパティーリスト(*note Property
     Lists::を参照してください)に格納され、(2)KEY-TYPEが
     省略された場合、デフォルトは‘sexp’ではなく、
     ‘symbol’になります。

‘(choice ALTERNATIVE-TYPES...)’
     値はALTERNATIVE-TYPESのうちの1つに適合しなければな
     りません。たとえば、‘(choice integer string)’では整
     数か文字列が許されます。

     カスタマイズバッファーでは、ユーザーはメニューを使
     用して候補を選択して、それらの候補にたいして通常の
     方法で値を編集できます。

     通常この選択からメニューの文字列が自動的に決定され
     ます。しかし候補の中に‘:tag’キーワードを含めること
     により、メニューにたいして異なる文字列を指定できま
     す。たとえば、空白の数を意味する整数と、その通りに
     使用したいテキストにたいする文字列の場合は、以下の
     ような方法でカスタマイズ型を記述したいかもしれませ
     ん

          (choice (integer :tag "Number of spaces")
                  (string :tag "Literal text"))

     この場合メニューは、‘Number of spaces’と‘Literal
     text’を提示します。

     ‘const’以外の‘nil’が有効な値ではない候補には、
     ‘:value’キーワードを使用して、有効なデフォルト値を
     指定するべきです。*note Type Keywords::を参照してく
     ださい。

     複数の候補によりいくつかの値が提供される場合、カス
     タマイズは適合する値をもつ最初の候補を選択します。
     これは常に、もっとも特有な型を最初に、もっとも一般
     的な型を最後にリストすべきことを意味します。以下は
     適切な使い方の例です:

          (choice (const :tag "Off" nil)
                  symbol (sexp :tag "Other"))

     この使い方では、特別な値‘nil’はその他のシンボルとは
     別に扱われ、シンボルは他のLisp式とは別に扱われます
     。

‘(radio ELEMENT-TYPES...)’
     これは‘choice’と似ていますが、選択はメニューではな
     く、‘ラジオボタン’で表示されます。これは該当する選
     択にたいしてドキュメントが表示できる利点があるので
     、関数定数(‘function-item’カスタマイズ型)の選択に適
     す場合があります。

‘(const VALUE)’
     値はVALUEでなければならず、他は許されません。

     ‘const’は主に‘choice’の中で使用されます。たとえば、
     ‘(choice integer (const nil))’では、整数か‘nil’が選
     択できます。

     ‘choice’の中では、‘:tag’とともに‘const’が使用される
     場合があります。たとえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (const :tag "Ask" foo))

     これは‘t’がyes、‘nil’がno、‘foo’が“ask”を意味するこ
     とを示します。

‘(other VALUE)’
     この候補は任意のLisp値にマッチできますが、ユーザー
     がこの候補を選択した場合は、値VALUEが選択されます。

     ‘other’は主に‘choice’の最後の要素に使用されます。た
     とえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (other :tag "Ask" foo))

     これは‘t’がyes、‘nil’がno、それ以外は“ask”を意味す
     ることを示します。ユーザーが候補メニューから‘Ask’を
     選択した場合は、値‘foo’が指定されます。しかし、その
     他の値(‘t’、‘nil’、‘foo’を除く)では、‘foo’と同様に
     ‘Ask’が表示されます。

‘(function-item FUNCTION)’
     ‘const’と同様ですが、値が関数のときに使用されます。
     これはドキュメント文字列も関数名と同じように表示し
     ます。ドキュメント文字列は、‘:doc’で指定した文字列
     か、FUNCTION自身のドキュメント文字列です。

‘(variable-item VARIABLE)’
     ‘const’と同様ですが、値が変数名のときに使用されます
     。これはドキュメント文字列も変数名と同じように表示
     します。ドキュメント文字列は、‘:doc’で指定した文字
     列か、VARIABLE自身のドキュメント文字列です。

‘(set TYPES...)’
     値はリストでなければならず、指定されたTYPESの1つに
     マッチしなければなりません。

     これはカスタマイズバッファーではチェックリストとし
     て表示されるので、TYPESはそれぞれ対応する要素を1つ
     、あるいは要素をもちません。同じ1つのTYPESにマッチ
     するような、異なる2つの要素を指定することはできませ
     ん。たとえば、‘(set integer symbol)’は、リスト内で
     1つの整数、および/または1つのシンボルが許され、複数
     の整数や複数のシンボルは許されません。結果として、
     ‘set’内で‘integer’のような特定的ではない型を使用す
     るのは稀です。

     以下のように、‘const’型は‘set’内のTYPESでよく使用さ
     れます:

          (set (const :bold) (const :italic))

     alist内で利用できる要素を示すために使用されることも
     あります:

          (set (cons :tag "Height" (const height) integer)
               (cons :tag "Width" (const width) integer))

     これによりユーザーにオプションでheightとwidthの値を
     指定させることができます。

‘(repeat ELEMENT-TYPE)’
     値はリストでなければならず、リストの各要素は型
     ELEMENT-TYPEに適合しなければなりません。カスタマイ
     ズバッファーでは要素のリストとして表示され、
     ‘[INS]’および‘[DEL]’ボタンにより、要素の追加や削除
     が行われます。

‘(restricted-sexp :match-alternatives CRITERIA)’
     これはもっとも汎用的な複合型の構築方法です。値は
     CRITERIAを満足する任意のLispオブジェクトです。
     CRITERIAはリストで、リストの各要素は以下のうちの1つ
     を満たす必要があります:

        • 述語 — つまり、副作用をもたず引数は1つ、その引
          数に応じて‘nil’か非‘nil’のどちらかをリターンす
          る関数。リスト内での述語の使用により、その述語
          が非‘nil’をリターンするようなオブジェクトが許
          されることを意味する。

        • クォートされた定数 — つまり、‘'OBJECT’。リスト
          内でこの要素は、OBJECT自身が容認される値である
          ことを示す。

     たとえば、

          (restricted-sexp :match-alternatives
                           (integerp 't 'nil))

     これは整数、‘t’、‘nil’を正当な値として受け入れます
     。

     カスタマイズバッファーは適切な値をそれらの入力構文
     ですべて表示し、ユーザーはこれらをテキストとして編
     集できます。

   以下は複合型でキーワード/値ペアーとして使用できるキー
ワードのテーブルです:

‘:tag TAG’
     TAGは、ユーザーとのコミュニケーションのために、その
     候補の名前として使用される。‘choice’内に出現する型
     にたいして有用。

‘:match-alternatives CRITERIA’
     CRITERIAは可能な値とのマッチに使用されます。
     ‘restricted-sexp’内でのみ有用です。

‘:args ARGUMENT-LIST’
     型構築の引数としてARGUMENT-LISTの要素を使用します。
     たとえば、‘(const :args (foo))’は‘(const foo)’と等
     価です。明示的に‘:args’とく記述する必要があるのは稀
     です。なぜなら、最後のキーワード/値ペアーの後に続く
     ものは何であれ、引数として認識されるからです。


File: elisp,  Node: Splicing into Lists,  Next: Type Keywords,  Prev: Composite Types,  Up: Customization Types

14.4.3 Splicing into Lists
--------------------------

‘:inline’機能により、可変個の要素を、カスタマイズ型の
‘list’や‘vector’の途中にスプライス(splice: 継ぎ足す)する
ことができます。‘list’や‘vector’記述を含む型にたいして
‘:inline t’を追加することによりこれを使用します。

   通常‘list’や‘vector’型の仕様は、単一の要素型を表しま
す。しかしエントリーが‘:inline t’を含む場合、マッチする
値は、その含まれたシーケンスに直接マージされます。たとえ
ば、エントリーが3要素のリストにマッチする場合、全体が3要
素のシーケンスになります。これはバッククォート構文(*note
Backquote::を参照)の‘,@’に類似しています。

   たとえば、最初の要素が‘baz’で、残りの引数は0個以上の
‘foo’か‘bar’でなければならないリストを指定する場合は、以
下のカスタマイズ型を使用します:

     (list (const baz) (set :inline t (const foo) (const bar)))

これは ‘(baz)’、‘(baz foo)’、‘(baz bar)’、‘(baz foo
bar)’のような値にマッチします。

   要素の型が‘choice’の場合は、‘choice’自身の中で
‘:inline’を使用せずに、‘choice’の候補(の一部)の中で使用
します。たとえば、最初がファイル名で開始され、その後にシ
ンボル‘t’か2つの文字列を続けなければならないリストにマッ
チさせるには、以下のカスタマイズ型を使用します:

     (list file
           (choice (const t)
                   (list :inline t string string)))

選択においてユーザーが選択肢の1つ目を選んだ場合、リスト
全体が2つの要素をもち、2つ目の要素は‘t’になります。ユー
ザーが2つ目の候補を選んだ場合、リスト全体が3つの要素をも
ち、2つ目と3つ目の要素は文字列でなければなりません。


File: elisp,  Node: Type Keywords,  Next: Defining New Types,  Prev: Splicing into Lists,  Up: Customization Types

14.4.4 Type Keywords
--------------------

カスタマイズ型内の型名シンボルの後にキーワード/引数ペア
ーを指定できます。以下は使用できるキーワードと、それらの
意味です:

‘:value DEFAULT’
     デフォルト値を提供する。

     その候補にたいして‘nil’が有効な値でない場合は、
     ‘:value’に有効なデフォルトを指定することが必須にな
     ります。

     ‘choice’の内部の候補として出現する型にたいしてこれ
     を使用する場合、ユーザーがカスタマイズバッファー内
     のメニューによりこの候補を選択したときに、使用する
     デフォルト値を最初に指定します。

     もちろんオプションの実際の値がこの候補に適合する場
     合は、DEFAULTではなく実際の値が表示されます。

‘:format FORMAT-STRING’
     この文字列は、その型に対応する値を説明するために、
     バッファーに挿入されます。FORMAT-STRING内では、以下
     の‘%’エスケープが利用できます:

     ‘%[BUTTON%]’
          ボタンとしてマークされたテキストBUTTONを表示す
          る。‘:action’属性は、ユーザーがそれを呼び出し
          たときに、そのボタンが何を行うか指定する。この
          属性の値は２つの引数 — ボタンが表示されるので
          ウィジェットとイベント — をとる関数。

          異なるアクションを行う2つの異なるボタンを指定
          する方法はない。

     ‘%{SAMPLE%}’
          ‘:sample-face’により指定された、スペシャルフェ
          イス内のSAMPLEを表示する。

     ‘%v’
          そのアイテムの値を代替えする。その値がどのよう
          に表示されるかはアイテムの種類と、(カスタマイ
          ズ型にたいしては)カスタマイズ型にに依存する。

     ‘%d’
          そのアイテムのドキュメント文字列を代替えする。

     ‘%h’
          ‘%d’と同様ふぁが、ドキュメント文字列が複数行の
          場合に、ドキュメント文字列全体か最初の行だけか
          を制御するボタンを追加する。

     ‘%t’
          その位置でタグに置き換える。‘:tag’キーワードで
          タグを指定する。

     ‘%%’
          リテラル‘%’を表示する。

‘:action ACTION’
     ユーザーがボタンをクリックした場合はACTIONを実行し
     ます。

‘:button-face FACE’
     ‘%[...%]’で表示されたボタンテキストにたいして、フェ
     イスFACE(フェイス名、またはフェイス名のリスト)を使
     用します。

‘:button-prefix PREFIX’
‘:button-suffix SUFFIX’
     これらはボタンの前、または後に表示されるテキストを
     指定します。以下が指定できます:

     ‘nil’
          テキストは挿入されない。

     文字列
          その文字列がリテラルに挿入される。

     シンボル
          そのシンボルの値が使用される。

‘:tag TAG’
     この型に対応する値(または値の一部)にたいするタグと
     してTAG(文字列)を使用する。

‘:doc DOC’
     この型に対応する値(または値の一部)にたいするドキュ
     メント文字列としてDOCを使用する。これが機能するため
     には、‘:format’にたいする値を指定し、その値にたいし
     て‘%d’か‘%h’を使用しなければならない。

     ある型にたいしてドキュメント文字列を指定するのは、
     ‘:choice’内の候補の型や、他の複合型の一部について情
     報を提供するのが通常の理由である。

‘:help-echo MOTION-DOC’
     ‘widget-forward’や‘widget-backward’でこのアイテムに
     移動したときに、エコーエリアに文字列MOTION-DOCを表
     示する。さらに、マウスの‘help-echo’文字列として
     MOTION-DOCが使用され、これは実際にはヘルプ文字列を
     生成するために評価される関数またはフォームかもしれ
     ない。もし関数の場合、これは1つの引数(そのウィジェ
     ット)で呼び出される。

‘:match FUNCTION’
     値がその型にマッチするか判断する方法を指定する。対
     応する値FUNCTIONは、2つの引数(ウィジェットと値)をと
     る関数で、値が適切なら非‘nil’をリターンすること。

‘:validate FUNCTION’
     入力にたいして検証を行う関数を指定する。FUNCTIONは
     引数としてウィジェットをとり、そのウィジェットのカ
     レント値がウィジェットにたいして有効なら‘nil’をリタ
     ーンすること。それ以外は無効なデータを含むウィジェ
     ットをリターンして、そのウィジェットの‘:error’プロ
     パティに、そのエラーを説明する文字列をセットするこ
     と。


File: elisp,  Node: Defining New Types,  Prev: Type Keywords,  Up: Customization Types

14.4.5 Defining New Types
-------------------------

前のセクションでは、‘defcustom’にたいして型の詳細な仕様
を作成する方法を説明しました。そのような型仕様に名前を与
えたい場合があるかもしれません。理解しやすいケースとして
は、多くのユーザーオプションに同じ型を使用する場合などで
す。各オプションにたいして仕様を繰り返すより、その型に名
前を与えて、‘defcustom’それぞれにその名前を使用すること
ができます。他にもユーザーオプションの値が再帰的なデータ
構造のケースがあります。あるデータ型がそれ自身を参照でき
るようにするためには、それが名前をもつ必要があります。

   カスタマイズ型はウィジェットとして実装されているめ、
新しいカスタマイズ型を定義するには、新たにウィジェット型
を定義します。ここではウィジェットインターフェイスの詳細
は説明しません。*note Introduction: (widget)Top.を参照し
てください。　かわりに、シンプルな例を用いて、カスタマイ
ズ型を新たに定義するのに必要となる、最小限の機能について
説明します。

     (define-widget 'binary-tree-of-string 'lazy
       "A binary tree made of cons-cells and strings."
       :offset 4
       :tag "Node"
       :type '(choice (string :tag "Leaf" :value "")
                      (cons :tag "Interior"
                            :value ("" . "")
                            binary-tree-of-string
                            binary-tree-of-string)))

     (defcustom foo-bar ""
       "Sample variable holding a binary tree of strings."
       :type 'binary-tree-of-string)

   新しいウィジェットを定義するための関数は、
‘define-widget’と呼ばれます。1つ目の引数は、新たなウィジ
ェット型にしたいシンボルです。2つ目の引数は既存のウィジ
ェットを表すシンボルで、新しいウィジェットではこの既存の
ウィジェットと異なる部分を定義することになります。新たな
カスタマイズ型を定義する目的にたいしては、‘lazy’ウィジェ
ットが最適です。なぜならこれは、‘defcustom’にたいするキ
ーワード引数と同じ構文、同じ名前でキーワード引数
‘:type’を受け取るからです。3つ目の引数は、新しいウィジェ
ットにたいするドキュメント文字列です。この文字列は、‘M-x
widget-browse <RET> binary-tree-of-string <RET>’コマンド
で参照することができるようになります。

   これらの必須の引数の後にキーワード引数が続きます。も
っとも重要なのは‘:type’で、これはこのウィジェットにマッ
チさせたいデータ型を表します。上記の例では
‘binary-tree-of-string’は文字列、またはcarとcdrが
‘binary-tree-of-string’であるようなコンスセルです。この
定義中でのウィジェット型への参照に注意してください。
‘:tag’属性はユーザーインターフェイスでウィジェット名とな
る文字列、‘:offset’引数はカスタマイズバッファーでのツリ
ー構造の外観で，子ノードと関連する親ノードの間に4つのス
ペースを確保します。

   ‘defcustom’は、通常のカスタマイズ型に使用される方法で
新しいウィジェットを表示します。

   ‘lazy’という名前の由来は、他のウィジェットの場合、そ
れらがバッファーでインスタンス化されるとき、他の合成され
たウィジェットが下位のウィジェットを内部形式に変換するか
らです。この変換は再帰的なので、下位のウィジェットは、
_それら自身_の下位ウィジェットへと変換されます。データ構
造自体が再帰的な場合、この変換は無限再帰(infinite
recursion)となります。‘lazy’ウィジェットは、‘:type’引数
を必要なときだけ変換することにより、この再帰を防ぎます。


File: elisp,  Node: Applying Customizations,  Next: Custom Themes,  Prev: Customization Types,  Up: Customization

14.5 Applying Customizations
============================

以下の関数には、変数とフェイスにたいして、そのユーザーの
カスタマイズ設定をインストールる役目があります。それらの
関数は、ユーザーがカスタマイズインターフェイスで‘Save
for future sessions’を呼び出したときに、次回のEmacs起動
時に評価されるように‘custom-set-variables’フォーム、およ
び/または‘custom-set-faces’フォームを がカスタムファイル
に書き込まれることによって効果をもちます。

 -- Function: custom-set-variables &rest args
     この関数はARGSにより指定された変数のカスタマイズを
     インストールします。ARGS内の引数はそれぞれ、以下の
     ようなフォームです

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     VARは変数名(シンボル)、EXPRESSIONはカスタマイズされ
     た値に評価される式です。

     この‘custom-set-variables’呼び出しより前にVARにたい
     して‘defcustom’フォームが評価された場合は、即座に
     EXPRESSIONが評価され、その変数の値にその結果がセッ
     トされます。それ以外は、その変数の‘saved-value’プロ
     パティにEXPRESSIONが格納され、これに関係する
     ‘defcustom’が呼び出されたとき(通常はその変数を定義
     するライブラリーがEmacsにロードされたとき)に評価さ
     れます。

     NOW、REQUEST、COMMENTエントリーは内部的な使用に限ら
     れており、省略されるかもしれません。NOWは、もし非
     ‘nil’の場合には、たとえその変数の‘defcustom’フォー
     ムが評価されていなくても、その変数の値がそのときセ
     ットされます。REQUESTは即座にロードされる機能のリス
     トです(*note Named Features::を参照)。COMMENTはその
     カスタマイズを説明する文字列です。

 -- Function: custom-set-faces &rest args
     この関数はARGSにより指定されたフェイスのカスタマイ
     ズをインストールします。ARGS内の引数はそれぞれ、以
     下のようなフォームです

          (FACE SPEC [NOW [COMMENT]])

     FACEはフェイス名(シンボル)、SPECはそのフェイスにた
     いするカスタマイズされたフェイス仕様です(*note
     Defining Faces::を参照)。

     NOW、REQUEST、COMMENTエントリーは内部的な使用に限ら
     れており、省略されるかもしれません。NOWは、もし非
     ‘nil’の場合には、たとえ‘defface’フォームが評価され
     ていなくても、そのフェイス仕様がそのときセットされ
     ます。COMMENTはそのカスタマイズを説明する文字列です
     。


File: elisp,  Node: Custom Themes,  Prev: Applying Customizations,  Up: Customization

14.6 Custom Themes
==================

“カスタムテーマ(Custom themes)”とはユニットとして有効ま
たは無効にできるセッティングのコレクションです。*note
(emacs)Custom Themes::を参照してくださいカスタムテーマは
それぞれEmacs Lispソースファイルにより定義され、それらは
このセクションで説明する慣習にしたがう必要があります。
(カスタムファイルを手で記述するかわりに、カスタマイズ風
のインターフェイスを使用して作成することもできます。
*note (emacs)Creating Custom Themes::を参照してください
。)

   カスタムファイルは‘FOO-theme.el’のように命名すべきで
す。ここでFOOはテーマの名前です。このファイルでの最初の
Lispフォームは‘deftheme’の呼び出しで、最後のフォームは
‘provide-theme’にすべきです。

 -- Macro: deftheme theme &optional doc
     このマクロはカスタムテーマの名前としてTHEME(シンボ
     ル)を宣言します。オプション引数DOCは、そのテーマを
     説明する文字列であるべきです。この文字列はユーザー
     が‘describe-theme’コマンドを呼び出したり、‘*Custom
     Themes*’バッファーで‘?’をタイプしたときに表示されま
     す。

     2つの特別なテーマ名は禁止されています(それらを使用
     するとエラーになります)。‘user’は、そのユーザーの直
     接的なカスタマイズ設定を格納するための“ダミー”のテ
     ーマです。そし‘changed’はカスタムシステムの外で行わ
     れた変更を格納するための“ダミー”のテーマです。

 -- Macro: provide-theme theme
     このマクロは完全に仕様が定められたテーマ名THEMEを宣
     言します。

   ‘deftheme’と‘provide-theme’の違いは、そのテーマセッテ
ィングを規定するLispフォーム(通常は
‘custom-theme-set-variables’の呼び出し、および/または
‘custom-theme-set-faces’の呼び出し)です。

 -- Function: custom-theme-set-variables theme &rest
          args
     この関数は、カスタムテーマTHEMEの変数のセッティング
     を規定します。THEMEはシンボルです。ARGS内の各引数は
     フォームのリストです。

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     ここでリストエントリーは‘custom-set-variables’のと
     きと同じ意味をもちます。*note Applying
     Customizations::を参照してください。

 -- Function: custom-theme-set-faces theme &rest args
     この関数は、カスタムテーマTHEMEのフェイスのセッティ
     ングを規定します。THEMEはシンボルです。ARGS内の各引
     数はフォームのリストです。

          (FACE SPEC [NOW [COMMENT]])

     ここでリストエントリーは‘custom-set-faces’のときと
     同じ意味をもちます。*note Applying
     Customizations::を参照してください。

   原則的に、テーマファイルは他のLispフォームを含むこと
もでき、それらはそのテーマがロードされるときに評価される
でしょうが、これは“悪いフォーム”です。悪意のあるコードを
含むテーマのロードを防ぐために、最初に非ビルトインテーマ
をロードする前に、Emacsはソースファイルを表示して、ユー
ザーにたいして確認を求めます。

   以下の関数は、テーマをプログラム的に有効または無効に
するのに有用です:

 -- Function: custom-theme-p theme
     この関数はTHEME(シンボル)がカスタムテーマの名前の場
     合(たとえば、そのテーマが有効かどうかにかかわらず、
     カスタムテーマがEmacsにロードされていれば)、非
     ‘nil’をリターンします。それ以外は‘nil’をリターンし
     ます。

 -- Variable: custom-known-themes
     この変数の値は、Emacsにロードされたテーマのリストで
     す。テーマはそれぞれ、Lispシンボル(テーマ名)により
     表されます。この変数のデフォルト値は、2つの“ダミー
     テーマ”を含みます: ‘(user changed)’。‘changed’テー
     マには、カスタムテーマが適用される前に行われたセッ
     ティング(たとえばカスタムの外部での変数のセット)が
     格納されています。‘user’テーマには、そのユーザーが
     カスタマイズして保存したセッティングが格納されてい
     ます。‘deftheme’マクロで宣言された任意の追加テーマ
     は、このリストの先頭に追加されます。

 -- Command: load-theme theme &optional no-confirm
          no-enable
     この関数はTHEMEという名前のカスタムテーマを、変数
     ‘custom-theme-load-path’で指定されたディレクトリー
     を探して、ソースファイルからロードします。*note
     (emacs)Custom Themes::を参照してください。また、そ
     のテーマの変数とフェイスのセッティングが効果を及ぼ
     すようにテーマを“enables”にします(オプション引数
     NO-ENABLEが非‘nil’でない場合)さらに、オプション引数
     NO-CONFIRMが非‘nil’でない場合は、そのテーマをロード
     する前にユーザーに確認を求めます。

 -- Command: enable-theme theme
     この関数はTHEMEという名前のカスタムテーマを有効にし
     ます。そのようなテーマがロードされていない場合は、
     エラーをシグナルします。

 -- Command: disable-theme theme
     この関数はTHEMEという名前のカスタムテーマを無効にし
     ます。テーマはロードされたまま残りので、続けて
     ‘enable-theme’を呼び出せばテーマは再び有効になりま
     す。


File: elisp,  Node: Loading,  Next: Byte Compilation,  Prev: Customization,  Up: Top

15 Loading
**********

Lispコードのファイルをロードすることは、その内容をLispオ
ブジェクト形式でLisp環境に取り込むことを意味します。
Emacsはファイルを探してオープンし、テキストを読み込んで
各フォームを評価してから、そのファイルをクローズします。
そのようなファイルは“Lispライブラリー(Lisp library)”とも
呼ばれます。

   ‘eval-buffer’関数がバッファー内のすべての式を評価する
のと同様に、load関数はファイル内のすべての式を評価します
。異なるのはEmacsバッファー内のテキストではなく、load関
数はディスク上で見つかったファイル内のテキストを読み込み
、評価することです。

   ロードされたファイルは、ソースコードかバイトコンパイ
ルされたコードとしてLisp式を含んでいなければなりません。
このファイル内の各フォームは、“トップレベルフォーム
(top-level form)”と呼ばれます。ロード可能なファイル内の
フォームにたいする特別なフォーマットはありません。ファイ
ル内のフォームはどれも、同じように直接バッファーにタイプ
され、そこで評価されるでしょう(実際、ほとんどのコードは
この方法でテストされます)。多くの場合、そのフォームは関
数定義と変数定義です。

   外部ライブラリーのオンデマンドローディングについては
、*note Dynamic Libraries::を参照してください。

* Menu:

* How Programs Do Loading::  ‘load’関数、その他。
* Load Suffixes::            ‘load’が試みられるサフィックスについての詳細。
* Library Search::           ロードするライブラリーの検索。
* Loading Non-ASCII::        Emacs
                               Lispファイル内の非ASCII文字。
* Autoload::                 オートロードのための関数のセットアップ。
* Repeated Loading::         ファイルを2度ロードする場合の配慮。
* Named Features::           まだロードされていないライブラリーのロード。
* Where Defined::            特定のシンボルがどのファイルで定義されているかの検索。
* Unloading::                ロードされたライブラリーを"unload"する方法。
* Hooks for Loading::        特定のライブラリーがロードされたとき実行されるコードの提供。


File: elisp,  Node: How Programs Do Loading,  Next: Load Suffixes,  Up: Loading

15.1 How Programs Do Loading
============================

Emacs Lispにはロードのためのインターフェイスがいくつかあ
ります。たとえば、‘autoload’はファイル内で定義された関数
にたいしてプレースホルダーとなるオブジェクトを作成します
。この関数はオートロードされる関数を呼び出すために、ファ
イルからその関数の実際の定義の取得を試みます(*note
Autoload::を参照)。‘require’は、ファイルがまだロードされ
ていない場合にファイルをロードします(*note Named
Features::を参照)。これらすべての関数は、処理を行うため
に最終的に‘load’を呼び出します。

 -- Function: load filename &optional missing-ok
          nomessage nosuffix must-suffix
     この関数はLispコードのファイルを見つけてオープンし
     、その中のすべてのフォームを評価して、そのファイル
     をクローズします。

     ファイルを見つけるために、まず‘load’は
     ‘FILENAME.elc’という名前、つまりFILENAMEに拡張子
     ‘.elc’を足した名前のファイルを探します。このような
     ファイルが存在したら、それをロードします。その名前
     のファイルが存在しない場合、‘load’は‘FILENAME.el’と
     いう名前のファイルを探します。このファイルが存在し
     たら、それをロードします。最後に、もしこれらの名前
     がどちらも見つからなかった場合、‘load’は何も付け足
     さないFILENAMEという名前のファイルを探して、それが
     存在したらロードします。(‘load’関数にFILENAMEを認識
     する賢さはありません。‘foo.el.el’のような正しくない
     名前のファイルの場合も、‘(load "foo.el")’の評価によ
     りそれを見つけてしまいます。)

     Auto Compressionモードが有効(残念ながらデフォルトで
     は有効ですが)の場合、‘load’は他のファイル名を試みる
     前に圧縮されたバージョンのファイル名を探すので、フ
     ァイルを見つけることができません。圧縮されたファイ
     ルが存在したら、それを解凍してロードします。
     ‘load’はファイル名に‘jka-compr-load-suffixes’内の各
     サフィックスを足して、圧縮されたバージョンを探しま
     す。この変数の値は、文字列のリストでなければなりま
     せん。標準的な値は‘(".gz")’です。

     オプション引数NOSUFFIXが非‘nil’の場合‘load’はサフィ
     ックス‘.elc’と‘.el’を試みません。この場合、ロードし
     たいファイルの正確な名前を指定しなければなりません
     。ただしAuto Compressionモードが有効な場合には、
     ‘load’は圧縮されたバージョンを探すために、
     ‘jka-compr-load-suffixes’を使用します。正確なファイ
     ル名の指定と、、NOSUFFIXにたいして‘t’を使用すること
     により、‘foo.el.el’のような名前のファイルにたいする
     ロードの試みを抑止できます。

     オプション引数MUST-SUFFIXが非‘nil’の場合、‘load’は
     ロードに使用されるファイルの名前に明示的にディレク
     トリー名が含まれていなければ、ファイル名が‘.el’か
     ‘.elc’で終わること(あるいは圧縮による拡張子が付加さ
     れているかもしれません)を要求します。

     オプション‘load-prefer-newer’が非‘nil’の場合、
     ‘load’はサフィックスを検索するとき、どのファイルで
     あっても(‘.elc’、‘.el’など)、もっとも最近変更された
     ファイルのバージョンを選択します。

     FILENAMEが‘foo’や‘baz/foo.bar’のような相対ファイル
     名の場合、‘load’は変数‘load-path’を使用してそのファ
     イルを探します。これは‘load-path’内にリストされた各
     ディレクトリーにFILENAMEを追加して、最初に見つかっ
     たら名前のマッチするファイルをロードします。デフォ
     ルトディレクトリーを意味する‘nil’が‘load-path’で措
     定されたときだけ、カレントデフォルトディレクトリー
     を試みます。‘load’は‘load-path’内の最初のディレクト
     リーで利用可能な3つのサフィックスすべてを試行してか
     ら、2つ目のディレクトリーで３つのサフィックスすべて
     を試行する、というようにファイルを探します。*note
     Library Search::を参照してください。

     最終的に見つかったファイル、およびEmacsがそのファイ
     ルを見つけたディレクトリーが何であれ、Emacsはそのフ
     ァイル名を変数‘load-file-name’の値にセットします。

     ‘foo.elc’が‘foo.el’より古いと警告された場合、それは
     ‘foo.el’のリコンパイルを考慮すべきことを意味します
     。*note Byte Compilation::を参照してください

     (コンパイルされていない)ソースファイルをロードした
     とき、Emacsがファイルをvisitしたときと同じように
     ‘load’は文字セットの変換を行います。*note Coding
     Systems::を参照してください。

     コンパイルされていないファイルをロードするとき、
     Emacsはそのファイルに含まれる任意のマクロ(*note
     Macros::を参照)を展開します。わたしたちはこれを
     “eagerマクロ展開(eager macro expansion)”と呼んでい
     ます。(関連するコードを実行するまで展開を延期するの
     ではなく)これを行うことにより、コンパイルされていな
     いコード実行のスピードが明らかに向上します。このマ
     クロ展開は、循環参照により行うことができないときも
     あります。これの一番簡単な例は、ロードしようとして
     いるファイルが他のファイルで定義されているマクロを
     参照しているが、そのファイルはロードしようとしてい
     るファイルを必要としている場合です。これは一般的に
     は無害です。Emacsは問題の詳細を与えるために警告
     (‘Eager macro-expansion skipped due to cycle...’)を
     プリントしますが、単にその時点ではマクロを展開せず
     に、そのファイルはロードされます。あなたはこの問題
     が発生しないように、コードをリストラクチャーしたい
     と思うかもしれません。コンパイル済みファイルでは、
     マクロ展開はコンパイル時に行われるので、ロード時の
     マクロ展開は行われません。*note Compiling Macros::を
     参照してください。

     NOMESSAGEが非‘nil’でない場合は、ロードの間、エコー
     エリアに‘Loading foo...’や‘Loading foo...done’のよ
     うなメッセージが表示されます。

     ファイルをロードする間のハンドルされないエラーは、
     ロードを終了させます。‘autoload’のためのロードの場
     合、ロードの間に定義された任意の関数定義は元に戻さ
     れます。

     ‘load’がロードするファイルを見つけられなかった場合
     、通常は(‘Cannot open load file FILENAME’のメッセー
     ジとともに)エラー‘file-error’がシグナルされます。し
     かしMISSING-OKが非‘nil’の場合、‘load’は単に‘nil’を
     リターンします。

     式の読み取りにたいして‘load’が‘read’のかわりに使用
     する関数を指定するために、変数
     ‘load-read-function’を使用できます。以下を参照して
     ください。

     ファイルが正常にロードされた場合、‘load’は‘t’をリタ
     ーンします。

 -- Command: load-file filename
     このコマンドは、ファイルFILENAMEをロードします。
     FILENAMEが相対ファイル名の場合は、カレントデフォル
     トディレクトリーとみなされます。このコマンドは、
     ‘load-path’を使用せず、サフィックスの追加もしません
     。しかし、(Auto Compressionモードが有効な場合は)圧
     縮されたバージョンの検索を行います。ロードするファ
     イル名を正確に指定したい場合は、このコマンドを使用
     してください。

 -- Command: load-library library
     このコマンドはLIBRARYという名前のライブラリーをロー
     ドします。このコマンドは、引数を読み取る方法がイン
     タラクティブであることを除き、‘load’と同じです。
     *note (emacs)Lisp Libraries::を参照してください。

 -- Variable: load-in-progress
     この変数は、Emacsがファイルをロード中のときは非
     ‘nil’、それ以外は‘nil’です。

 -- Variable: load-file-name
     このセクションの最初に説明した検索でEmacsがファイル
     を見つけて、そのファイルをロード中のとき、この変数
     の値はそのファイルの名前です。

 -- Variable: load-read-function
     この変数は、‘load’と‘eval-region’が式の読み取るため
     に、‘read’のかわりに使用する関数を指定します。指定
     する関数は‘read’と同様、引数が1つの関数です。

     通常、この変数の値は‘nil’で、これはそれらの関数が
     ‘read’を使用すべきことを意味します。

     この変数を使用するかわりに、別の新たな方法を使用す
     るほうが明確です。‘eval-region’のREAD-FUNCTION引数
     に、その関数を渡す方法です。*note Eval: Definition
     of eval-region.を参照してください。

   Emacsのビルドで‘load’がどのように使用されているかにつ
いての情報は、*note Building Emacs::を参照してください。


File: elisp,  Node: Load Suffixes,  Next: Library Search,  Prev: How Programs Do Loading,  Up: Loading

15.2 Load Suffixes
==================

ここでは、‘load’が試行するサフィックスについて、技術的な
詳細を説明します。

 -- Variable: load-suffixes
     これは(ソースまたはコンパイル済みの)Emacs Lispファ
     イルを示すサフィックスのリストです。空の文字列が含
     まれるべきではありません。‘load’は、指定されたファ
     イル名にLispファイルのサフィックスを追加するときに
     、これらのサフィックスを使用します。標準的な値は
     ‘(".elc" ".el")’で、これは前のセクションで説明した
     振る舞いとなります。

 -- Variable: load-file-rep-suffixes
     これは同じファイルにたいする異なる表現を示すサフィ
     ックスのリストです。このリストは空の文字列から開始
     されるべきです。‘load’はファイルを検索するときは、
     他のファイルを検索する前にこのリストのサフィックス
     を順番にファイル名に追加します。

     Auto Compressionモードを有効にすることにより
     ‘jka-compr-load-suffixes’のサフィックスがこのリスト
     に追加され、無効にすると再びリストから取り除かれま
     す。‘load-file-rep-suffixes’の標準的な値は、Auto
     Compressionモードが無効な場合は‘("")’です。
     ‘jka-compr-load-suffixes’の標準的な値が‘(".gz")’で
     あることを考慮すると、Auto Compressionモードが有効
     な場合の‘load-file-rep-suffixes’の標準的な値は‘(""
     ".gz")’です。

 -- Function: get-load-suffixes
     この関数は、MUST-SUFFIX引数が非‘nil’のときは、
     ‘load’が試みるべきすべてのサフィックスを順番にした
     がったリストでリターンします。この関数は
     ‘load-suffixes’と‘load-file-rep-suffixes’の両方を考
     慮に入れます。‘load-suffixes’、
     ‘jka-compr-load-suffixes’、
     ‘load-file-rep-suffixes’がすべて標準的な値の場合、
     この関数はAuto Compressionモードが有効なら‘(".elc"
     ".elc.gz" ".el" ".el.gz")’、無効なら‘(".elc"
     ".el")’をリターンします。

   まとめると、‘load’は通常まず‘(get-load-suffixes)’の値
のサフィックスを試み、つぎに‘load-file-rep-suffixes’を試
みます。NOSUFFIXが非‘nil’の場合は前者がスキップされ、
MUST-SUFFIXが非‘nil’の場合は後者がスキップされます。

 -- User Option: load-prefer-newer
     このオプションが非‘nil’の場合は、ファイルが見つかっ
     た最初のサフィックスで停止せずに、‘load’はすべての
     サフィックスをテストして、一番新しいファイルを使用
     します。


File: elisp,  Node: Library Search,  Next: Loading Non-ASCII,  Prev: Load Suffixes,  Up: Loading

15.3 Library Search
===================

EmacsがLispライブラリーをロードするときは、変数
‘load-path’.<により指定されるディレクトリー内のライブラ
リーを検索します。

 -- Variable: load-path
     この変数の値は、‘load’でファイルをロードするとき検
     索するディレクトリーのリストです。リストの各要素は
     文字列(ディレクトリー名でなければなりません)、また
     は‘nil’(カレントワーキングディレクトリーを意味しま
     す)です。

   Emacsは起動時にいくつかのステップにより‘load-path’の
値をセットアップします。最初に、Emacsがコンパイルされた
ときのデフォルトロケーションセット(default locations
set)を使用して、‘load-path’を初期化します。通常これは以
下のようなディレクトリーです

     "/usr/local/share/emacs/VERSION/lisp"

   (以下の例では、あなたがインストールしたEmacsのインス
トールプレフィクスに合うように‘/usr/local’を置き換えてく
ださい。)これらのディレクトリーには、Emacsとともにインス
トールされた、標準的なLispファイルが含まれます。Emacsが
これらを見つけられない場合は、正常に起動しないでしょう。

   Emacsをビルドしたディレクトリーから起動した場合 −−− つ
まり正式にインストールされた実行形式ではないEmacsを起動
した場合 —　、Emacsはビルドされたディレクトリーのソースの
‘lisp’ディレクトリーを使用して‘load-path’を初期化します
。ソースとは別のディレクトリーでEmacsをビルドした場合は
、ビルドしたディレクトリーの‘lisp’ディレクトリーも追加し
ます。(どちらの場合も、要素は絶対ファイル名になります。)

   ‘--no-site-lisp’オプションでEmacsを起動した場合を除き
、‘load-path’の先頭に2つのさらに‘site-lisp’を追加します
。これらはローカルにインストールされたLispファイで、通常
は:

     "/usr/local/share/emacs/VERSION/site-lisp"

と

     "/usr/local/share/emacs/site-lisp"

の形式です。1つ目は特定のバージョンのEmacsにたいしてロー
カルにインストールされたものです。2つ目はインストールさ
れたすべてのバージョンのEmacsが使用することを意図してロ
ーカルにインストールされたものです。(インストールされた
ものでないEmacsが実行された場合は、もし存在すればソース
ディレクトリーとビルドディレクトリーの‘site-lisp’ディレ
クトリーも追加します。これらのディレクトリーは通常、
‘site-lisp’ディレクトリーを含みません。)

   環境変数‘EMACSLOADPATH’がセットされている場合は、上述
の初期化プロセスが変更されます。Emacsは、この環境変数の
値にもとづいて‘load-path’を初期化します。

   ‘EMACSLOADPATH’の構文は、‘PATH’で使用される構文と同様
です。ディレクトリー名は‘:’(オペレーティングシステムによ
っては‘;’)で区切られます。 以下は、(‘sh’スタイルのシェル
から)‘EMACSLOADPATH’変数をセットする例です:

     export EMACSLOADPATH=/home/foo/.emacs.d/lisp:

   環境変数の値内の空の要素は、(上記例のような)末尾、先
頭、中間にあるかに関わらず、標準の初期化処理により決定さ
れる‘load-path’のデフォルト値に置き換えられます。そのよ
うな空要素が存在しない場合には、‘EMACSLOADPATH’により
‘load-path’全体が指定されます。空要素、または標準の
Lispファイルを含むディレクトリーへの明示的なパスのどちら
かを含めなければなりません。さもないとEmacsが関数を見つ
けられなくなります。(‘load-path’を変更する他の方法は、
Emacs起動時にコマンドラインオプション‘-L’を使用する方法
です。以下参照。)

   ‘load-path’内の各ディレクトリーにたいし、Emacsはその
ディレクトリーがファイル‘subdirs.el’を含むか確認し、もし
あればそれをロードします。‘subdirs.el’ファイルは、
‘load-path’のディレクトリーみたいして任意のサブディレク
トリーを追加するためのコードが含まれており、Emacsがビル
ド/インストールされたとき作成されます。サブディレクトリ
ーと複数階層下のレベルのサブディレクトリーの両方が、直接
追加されます。ただし、名前の最初が英数字でないディレクト
リー、名前が‘RCS’または‘CVS’のディレクトリー、名前が
‘.nosearch’というファイルを含むディレクトリーは除外され
ます。

   Emacsは次に、コマンドラインオプション‘-L’(*note
(emacs)Action Arguments::を参照)で指定したロードディレク
トリーを追加します。もしあれば、オプションパッケージ
(*note Packaging Basics::を参照)がインストールされた場所
も追加します。

   initファイル(*note Init File::を参照)で、
‘load-path’に1つ以上のディレクトリーを追加するコードを記
述するのは一般的に行なわれています。たとえば:

     (push "~/.emacs.d/lisp" load-path)

   Emacsのダンプには、‘load-path’の特別な値を使用します
。ダンプされたEmacsをカスタマイズするために
‘site-load.el’または‘site-init.el’を使用する場合、これら
のファイルが行った‘load-path’にたいする変更はすべて、ダ
ンプ後失われます。

 -- Command: locate-library library &optional nosuffix
          path interactive-call
     このコマンドは、ライブラリーLIBRARYの正確なファイル
     名を探します。‘load’と同じ方法でライブラリーを検索
     し、引数NOSUFFIXも‘load’の場合と同じ意味です。
     LIBRARYに指定する名前には、サフィックス‘.elc’または
     ‘.el’を追加しないでください。

     PATHが非‘nil’の場合は、‘load-path’のかわりにディレ
     クトリーのリストが使用されます。

     ‘locate-library’がプログラムから呼び出されたときは
     、ファイル名を文字列としてリターンします。ユーザー
     がインタラクティブに‘locate-library’を実行したとき
     は、引数INTERACTIVE-CALLが‘t’となり、これは
     ‘locate-library’にたいしてファイル名をエコーエリア
     に表示するよう指示します。

 -- Command: list-load-path-shadows &optional stringp
     このコマンドは、“シャドー(shadowed)”されたEmacs
     Lispファイルを表示します。シャドーされたファイルと
     は、‘load-path’のディレクトリーに存在するにも関わら
     ず、‘load-path’のディレクトリーリスト内で前の位置に
     ある他のディレクトリーに同じ名前のファイルが存在す
     るため、通常はロードされないファイルのことです。

     たとえば、以下のように‘load-path’がセットされていた
     とします

            ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")

     そして、両方のディレクトリーに‘foo.el’という名前の
     ファイルがあるとします。この場合、‘(require 'foo)’は
     決して2つ目のディレクトリーのファイルをロードしませ
     ん。このような状況は、Emacsがインストールされた方法
     に問題があることを示唆します。

     Lispから呼び出された場合、この関数はバッファー内に
     表示するかわりに、シャドーされたファイルリストのメ
     ッセージをプリントします。オプション引数‘stringp’が
     非‘nil’の場合は、かわりにシャドーされたファイルを文
     字列としてリターンします。


File: elisp,  Node: Loading Non-ASCII,  Next: Autoload,  Prev: Library Search,  Up: Loading

15.4 Loading Non-ASCII Characters
=================================

Emacs Lispプログラムが非ASCII文字の文字列定数を含むとき
、Emacsではそれらをユニバイト文字列またはマルチバイト文
字列のどちらかで表現される場合があります。どちらの表現が
使用されるかは、そのファイルがどのようにEmacsに読み込ま
れたかに依存します。マルチバイト表現へのデコーディングと
ともに読み込まれた場合、Lispプログラム内のテキストはマル
チバイトのテキストとなり、ファイル内の文字列定数はマルチ
バイト文字列になります。(たとえば)Latin-1文字を含むファ
イルをデコーディングなしで読み込んだ場合、そのプログラム
のテキストはユニバイトのテキストとなり、ファイル内の文字
列定数はユニバイト文字列になります。*note Coding
Systems::を参照してください。

   マルチバイト文字列がユニバイトバッファーに挿入される
ときは自動的にユニバイトに変換されるため、大部分のEmacs
Lispプログラムにおいて、マルチバイト文字列が非ASCII文字
列であるという事実を意識させないようにすべきです。しかし
これが行われことにより違いが生じる場合には、ローカル変数
セクションに‘coding: raw-text’と記述することにより、特定
のLispファイルを強制的にユニバイトとして解釈させることが
できます。この識別子により、そのファイルは無条件でユニバ
イトとして解釈されます。これは、‘?vLITERAL’で記述された
非ASCII文字にキーバインドするとき重要になります。

