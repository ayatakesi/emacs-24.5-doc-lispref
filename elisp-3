This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Using Lexical Binding,  Prev: Lexical Binding,  Up: Variable Scoping

11.9.4 Using Lexical Binding
----------------------------

Emacs Lispファイルをロードしたり、Lispバッファーを評価するとき、バッファ
ーローカルな変数‘lexical-binding’が非‘nil’の場合は、レキシカルバインディ
ングが有効になります:

 -- Variable: lexical-binding
     このバッファーローカルな変数が非‘nil’の場合、Emacs Lispファイルおよ
     びバッファーは、ダイナミックバインディングではなくレキシカルバイン
     ディングを使用して評価されます(しかし、特別な変数はダイナミックにバ
     インドされたままです。以下を参照してください)。‘nil’の場合、すべて
     のローカル変数にたいしてダイナミックバインディングが使用されます。
     この変数は通常、ファイルローカル変数として、Emacs Lispファイル全体
     にたいしてセットされます(*note File Local Variables::を参照してくだ
     さい)。他のファイルローカル変数などとは異なり、ファイルの最初の行で
     セットされなければならないことに注意してください。

‘eval’呼び出しを使用して、Emacs Lispコードを直接評価するとき、‘eval’の
LEXICAL引数が非‘nil’の場合は、レキシカルバインディングが有効になります。
*note Eval::を参照してください。

   レキシカルバインディングが有効な場合でも、特定の変数はダイナミックに
バインドされたままです。これらは“スペシャル変数(special variable)”と呼ば
れます。‘defvar’、‘defcustom’、‘defconst’で定義されたすべての変数は、ス
ペシャル変数です(*note Defining Variables::を参照してください)。その他の
すべての変数はレキシカルバインディングの対象になります。

 -- Function: special-variable-p symbol
     この関数は、SYMBOLがスペシャル変数(つまり変数が‘defvar’、
     ‘defcustom’、‘defconst’による定義をもつ)の場合は非‘nil’をreturnしま
     す。それ以外では、return値は‘nil’になります。

   関数内での通常の引数としてスペシャル変数を使用することは、推奨されま
せん。レキシカルバインディングモードが有効なときにこれを行うと、不定な動
作が起こります(あるときはレキシカルバインディング、またあるときはダイナ
ミックバインディングのように)。

   Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です
。最初にEmacs Lispソースファイルのヘッダー行で‘lexical-binding’を‘t’して
、ファイルローカル変数を追加します(*note File Local Variables::を参照し
てください)。次に、意図せずレキシカルにバインドしてしまわないように、ダ
イナミックなバインドをもつ必要がある変数が変数定義をもつことを、各変数ご
とにチェックします。

   どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソース
ファイルをバイトコンパイルすることです。*note Byte Compilation::を参照し
てください。‘let’フォームの外で非スペシャル変数が使用されている場合、バ
イトコンパイラーは“free variable”にたいする参照または割り当てについて警
告するでしょう。非スペシャル変数がバインドされているが、‘let’フォーム内
で使用されていない場合、バイトコンパイラーは“unused lexical variable”に
関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数
として使用している場合も、問題を警告します。

   (使用されていない変数についての警告を抑制するためには、単に変数名をア
ンダースコアーで開始します。そうすれば、バイトコンパイラーはこれを、変数
が使用されないことを示すと解釈します。)


File: elisp,  Node: Buffer-Local Variables,  Next: File Local Variables,  Prev: Variable Scoping,  Up: Variables

11.10 Buffer-Local Variables
============================

グローバルおよびボーカルな変数バインディングは、1つの形式、または別の形
式で、ほとんどのプログラミング言語で見つけることができます。しかし
Emacsは、1つのバッファーだけに適用される“バッファーローカル
(buffer-local)”なバインディングの用に、普通にはない種類の変数バインディ
ングもサポートします。ある変数にたいして異なるバッファーごとに別の亜Q体
をもつのは、重要なカスタマイズ方法です(変数は端末ごとにローカルなバイン
ディングをもつこともできます。*note Multiple Terminals::を参照してくださ
い)。

* Menu:

* Intro to Buffer-Local::    イントロダクションと概念。
* Creating Buffer-Local::    バッファーローカルなバインディングの作成と削除。
* Default Value::            自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。


File: elisp,  Node: Intro to Buffer-Local,  Next: Creating Buffer-Local,  Up: Buffer-Local Variables

11.10.1 Introduction to Buffer-Local Variables
----------------------------------------------

バッファーローカル変数は、特定のバッファーに関連づけられた、バッファーロ
ーカルなバインディングをもちます。このバインディングは、そのバッファーが
カレントのときに効果をもち、カレントでないときは効果がありません。バッフ
ァーローカルなバインディングが効力をもつときにその変数をセットした場合、
そのバインディングは新しい値をもちますが、他のバインディングは変更されま
せん。これは、バッファーローカルなバインディングを作成したバッファーだけ
で変更が見えることを意味します。

   その変数にたいする特定のバッファーに関連づけられていない通常のバイン
ディングは、“デフォルトバインディング(default binding)”と呼ばれます。ほ
とんどの場合、これはグローバルバインディングです。

   変数は、あるバッファーではバッファーローカルなバインディングをもつこ
とができ、他のバッファーではもたないことができます。デフォルトバインディ
ングは、その変数にたいして自身のバインディングをもたない、すべてのバッフ
ァーで共有されます(これには、新たに作成されたバッファーが含まれます)。あ
る変数にたいしてバッファーローカルなバインディングをもたないバッファーで
その変数をセットすると、デフォルトバインディングがセットされるので、それ
はデフォルトバインディングを参照するすべてのバッファーで新しい値を見るこ
とができます。

   バッファーローカルなバインディングのもっとも一般的な使用は、目はーモ
ードがコマンドの動作を制御するために変数を変更する場合です。たとえばCモ
ードやLispモードは、空行だけがパラグラフの区切りになるように、変数
‘paragraph-start’をセットします。これらのモードは、CモードやLispモードに
なるようなバッファー内でこの変数をバッファーローカルにすることによりこれ
を行い、その後そのモードにたいして新しい値をセットします。*note Major
Modes::を参照してください。

   バッファーローカルなバインディングを作成する通常の方法は、
‘make-local-variable’による方法で、これは通常メジャーモードが使用します
。これはカレントバッファーだけに効果があります。その他すべてのバッファー
(まだ作成されていないバッファーを含む)は、それらのバッファー自身が明示的
にバッファーローカルなバインディングを与えられるまで、デフォルト値の共有
を続けます。

   変数を“自動的にバッファーローカルになる”ようにマークする、より強力な
操作は、‘make-variable-buffer-local’を呼び出すことにより行われます。これ
は、たとえその変数がまだ作成されていなくても、変数をすべてのバッファーに
たいしてローカルにすると考えることができます。より正確には、変数を自動的
にセットすることにより、その変数がカレントバッファーにたいしてローカルで
なくても、変数をローカルにする効果があります。すべてのバッファーは最初は
通常のようにデフォルト値を共有しますが、この変数をセットすることによりカ
レントバッファーにたいしてバッファーローカルなバインディングを作成します
。新たな値はバッファーローカルなバインディングに格納され、デフォルトバイ
ンディングは変更されずに残ります。これは、任意のバッファーで‘setq’により
デフォルト値を変更できないことを意味します。変更する唯一の方法は、
‘setq-default’だけです。

   *警告:* ある変数が1つ以上のバッファーでバッファーローカルなバインディ
ングをもつとき、‘let’はそのとき効果をもつ変数のバインディングをリバイン
ドします。たとえばq、カレントバッファーがバッファーローカルな値をもつ場
合、‘let’は一時的にそれをリバインドします。効果をもつバッファーローカル
なバインディングが存在しない場合、‘let’はデフォルト値をリバインドします
。‘let’の内部で、別のバインディングが効力をもつ別のバッファーをカレント
バッファーにすると、それ以上‘let’バインディングを参照できなくなります。
他のバッファーにいる間に‘let’を抜けると、(たとえそれが正しくても)バイン
ディングの解消を見ることはできません。以下にこれを示します:

     (setq foo 'g)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       ;; foo ⇒ 'temp  ; バッファー‘a’内でのletバインディング
       (set-buffer "b")
       ;; foo ⇒ 'g     ; fooは‘b’にたいしてローカルではないためグローバル値
       BODY...)
     foo ⇒ 'g        ; exitによりバッファー‘a’のローカル値が復元されるが、
                      ; バッファー‘b’では見ることができない
     (set-buffer "a") ; ローカル値が復元されたことを確認
     foo ⇒ 'a

BODY内の‘foo’にたいする参照は、バッファー‘b’のバッファーローカルなバイン
ディングにアクセスすることに注意してください。

   あるファイルがローカル変数の値をセットする場合、これらの変数はファイ
ルをvisitするときバッファーローカルな値になります。*note (emacs)File
Variables::を参照してください。

   バッファーローカル変数を、端末ローカル(terminal-local)にすることはで
きません(*note Multiple Terminals::を参照してください)。


File: elisp,  Node: Creating Buffer-Local,  Next: Default Value,  Prev: Intro to Buffer-Local,  Up: Buffer-Local Variables

11.10.2 Creating and Deleting Buffer-Local Bindings
---------------------------------------------------

 -- Command: make-local-variable variable
     この関数はカレントバッファー内で、VARIABLE(シンボル)にたいして、バ
     ッファーローカルなバインディングを作成します。他のバッファーは影響
     を受けません。returnされる値は、VARIABLEです。

     VARIABLEのバッファーローカルな値は最初、以前にVARIABLEがもっていた
     値と同じ値をもちます。VARIABLEがvoidのときは、voidのままです。

          ;; バッファー‘b1’で行う:
          (setq foo 5)                ; すべてのバッファーに影響する。
               ⇒ 5
          (make-local-variable 'foo)  ; ‘b1’内でローカルになった。
               ⇒ foo
          foo                         ; 値は変更されない。
               ⇒ 5
          (setq foo 6)                ; ‘b1’内で値を変更。
               ⇒ 6
          foo
               ⇒ 6

          ;; バッファー‘b2’では、値は変更されていない。
          (with-current-buffer "b2"
            foo)
               ⇒ 5

     変数を‘let’バインディングでバッファーローカルにしても、‘let’への出
     入り時の両方で、これを行うバッファーがカレントでない場合は、信頼性
     がありません。これは‘let’がバインディングの種類を区別しないからです
     。‘let’はバインディングを作成される変数だけを知るからです。

     変数が端末ローカル(*note Multiple Terminals::を参照してください)の
     場合、この関数はエラーをシグナルします。そのような変数は、バッファ
     ーローカルなバインディングをもつことができません。

     *警告:* フック変数にたいして‘make-local-variable’を使用しないでくだ
     さい。フック変数は、‘add-hook’または‘remove-hook’のLOCAL引数を使用
     した場合、必要に応じて自動的にバッファーローカルになります。

 -- Macro: setq-local variable value
     このマクロはカレントバッファー内でVARIABLEにたいしてバッファーロー
     カルなバインディングを作成して、それにバッファーローカルな値VALUEを
     与えます。このマクロは‘make-local-variable’に続けて‘setq’を呼び出す
     のと同じです。VARIABLEはクォートされていないシンボルです。

 -- Command: make-variable-buffer-local variable
     このコマンドは、VARIABLE(シンボル)が自動的にバッファーローカルにな
     るようにマークするので、それ以降にその変数へのセットを試みると、そ
     の時点でカレントのバッファーにローカルになります。しばしば混乱を招
     く‘make-local-variable’とは異なり、これが取り消されることはなく、す
     べてのバッファー内での変数の挙動に影響します。

     この機能に特有の欠点は、(‘let’またはその他のバインディング構造によ
     る)変数のバインディングが、その変数にたいするバッファーローカルなバ
     インディングを作成しないことです。(‘set’または‘setq’による)変数のセ
     ットだけは、その変数がカレントバッファーで作成された‘let’スタイルの
     バインディングをもたないので、ローカルなバインディングを作成します
     。

     VARIABLEがデフォルト値をもたない場合、このコマンドの呼び出しは
     ‘nil’のデフォルト値を与えます。VARIABLEがすでにデフォルト値をもつ場
     合、その値は変更されずに残ります。それ以降にVARIABLEにたいして
     ‘makunbound’を呼び出すと、バッファーローカル値をvoidにして、デフォ
     ルト値は影響を受けずに残ります。

     return値はVARIABLEです。

     *警告:* ユーザーオプション変数にたいしては、ユーザーは異なるバッフ
     ァーにたいして異なるカスタマイズを望む_かもしれない_ので、
     ‘make-variable-buffer-local’を使うべきだと決め込むべきではありませ
     ん。ユーザーは、望むなら任意の変数をローカルにできます。それらの選
     択の余地を残すほうがよいでしょう。

     ‘make-variable-buffer-local’を使用すべきときは、複数のバッファーが
     同じバインディングを共有しないことが自明な場合です。たとえば、バッ
     ファーごとに個別な値をもつことに依存するLispプログラム内の内部プロ
     セスにたいして変数が使用されるときは、
     ‘make-variable-buffer-local’の使用が最善の解決策になるかもしれませ
     ん。

 -- Macro: defvar-local variable value &optional docstring
     このマクロはVARIABLEを、初期値VALUEおよびDOCSTRINGの変数として定義
     して、それを自動的にバッファーローカルとマークします。これは
     ‘defvar’の後につづけて‘make-variable-buffer-local’を呼び出すのと同
     じです。VARIABLEはクォートされていないシンボルです。

 -- Function: local-variable-p variable &optional buffer
     これはVARIABLEがバッファーBUFFER(デフォルトはカレントバッファー)内
     でバッファーローカルのときは‘t’、それ以外は‘nil’をreturnします。

 -- Function: local-variable-if-set-p variable &optional buffer
     これはVARIABLEがバッファーBUFFER内でバッファーローカル値をもつか、
     自動的にバッファーローカルになる場合は、‘t’をreturnします。それ以外
     は‘nil’をreturnします。BUFFERが省略または‘nil’の場合のデフォルトは
     、カレントバッファーです。

 -- Function: buffer-local-value variable buffer
     この関数は、バッファーBUFFER内の、VARIABLE(シンボル)のバッファーロ
     ーカルなバインディングをreturnします。VARIABLEがバッファーBUFFER内
     でバッファーローカルなバインディングをもたない場合は、かわりに
     VARIABLEのデフォルト値(*note Default Value::)をreturnします。

 -- Function: buffer-local-variables &optional buffer
     この関数はバッファーBUFFER内のバッファーローカル変数を表すリストを
     returnします(BUFFERが省略された場合はカレントバッファーが使用されま
     す)。リストの各要素は通常、‘(SYM . VAL)’という形式をもちます。ここ
     でSYMはバッファーローカル変数(シンボル)、VALはバッファーローカル値
     です。しかしBUFFER内の、ある変数のバッファーローカルなバインディン
     グがvoidのtきは、その変数に対応するリスト要素は単にSYMになります。

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; 最初はすべてのバッファー内でローカルなビルトイン変数:
          ⇒ ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; 次にビルトインでないバッファーローカル変数。
              ;; This one is buffer-local and void:
              foobar
              ;; これはバッファーローカルでvoidではない:
              (bind-me . 69))

     このリスト内のコンスセルのCDRに新たな値を格納しても、その変数のバッ
     ファーローカル値は変化_しない_ことに注意してください。

 -- Command: kill-local-variable variable
     この関数はカレントバッファー内のVARIABLE(シンボル)にたいするバッフ
     ァーローカルなバインディング(もしあれば)を削除します。その結果とし
     て、このバッファー内でVARIABLEのデフォルトバインディングが可視にな
     ります。これは通常、VARIABLEの値を変更します。デフォルト値は削除さ
     れたバッファーローカル値とは異なるのが普通だからです。

     セットしたとき自動的にバッファーローカルになる変数のバッファーロー
     カルなバインディングをkillした場合は、これによりカレントバッファー
     な意でデフォルト値が可視になります。しかし、変数を再度セットすると
     、その変数にたいするバッファーローカルなバインディングが再作成され
     ます。

     ‘kill-local-variable’はVARIABLEをreturnします。

     この関数はコマンドです。なぜなら、バッファーローカル変数のインタラ
     クティブな作成が有用な場合があるように、あるバッファーローカル変数
     のインタラクティブなkillが有用な場合があるからです。

 -- Function: kill-all-local-variables
     この関数は、“permanent(永続的)”とマークされた変数、および
     ‘permanent-local-hook’プロパティーに非‘nil’をもつローカルフック関数
     (*note Setting Hooks::)を除き、カレントバッファーのすべてのバッファ
     ーローカルなバインディングを解消します。結果として、そのバッファー
     はほとんどの変数のデフォルト値を参照するようになります。

     この関数は、そのバッファーに関係のあるその他の特定の情報もリセット
     します。これはローカルキーマップ(local keymap)を‘nil’、構文テーブル
     (syntax table)を‘(standard-syntax-table)’の値、大文字小文字テーブル
     (case table)を‘(standard-case-table)’、abbrevテーブル(abbrev
     table)を‘fundamental-mode-abbrev-table’の値にセットします。

     この関数が1番最初に行うのは、ノーマルフック
     ‘change-major-mode-hook’(以下参照)の実行です。

     各メジャーモードコマンドは、Fundamentalモードにスイッチする効果をも
     ち、以前のメジャーモードのほとんどの効果を消去する、この関数を呼び
     出すことにより開始されます。この関数が処理を行うのを確実にするため
     に、メジャーモードがセットする変数はpermanentとマークすべきではあり
     ません。

     ‘kill-all-local-variables’ returns ‘nil’.

 -- Variable: change-major-mode-hook
     関数‘kill-all-local-variables’は、何か他のことを行う前に、まずこの
     ノーマルフックを実行します。この関数はメジャーモードにたいして、ユ
     ーザーが他のメジャーモードにスイッチした場合に行われる、何か特別な
     ことを準備する方法を与えます。この関数は、ユーザーがメジャーモード
     を変更した場合に忘れられるべき、バッファー固有のマイナーモードにた
     いしても有用です。

     最善の結果を得るために、この変数をバッファーローカルにすれば、処理
     が終了したときに消えるので、以降のメジャーモードに干渉しなくなりま
     す。*note Hooks::を参照してください。

   変数名(シンボル)が非‘nil’の‘permanent-local’プロパティーをもつ場合、
バッファーローカル変数は“permanent(永続的)”です。そのような変数は
‘kill-all-local-variables’の影響を受けず、したがってメジャーモードの変更
によりそれらのローカルバインディングは作成されません。permanentなローカ
ル変数は、ファイルの内容を編集する方法などより、どこから読み込んだファイ
ルか、あるいはどのように保存するかといったことに関連するデータに適してい
ます。


File: elisp,  Node: Default Value,  Prev: Creating Buffer-Local,  Up: Buffer-Local Variables

11.10.3 The Default Value of a Buffer-Local Variable
----------------------------------------------------

バッファーローカルなバインディングをもつ変数のグローバル値も、“デフォル
ト値(default)”値と呼ばれます。なぜなら、その変数にたいしてカレントバッフ
ァーも選択されたフレームもバインディングをもたない場合には、その値が常に
効果をもつからです。

   関数‘default-value’および‘setq-default’は、カレントバッファーがバッフ
ァーローカルなバインディングをもつかどうかに関わらず、その変数のデフォル
ト値にアクセスまたは変更します。たとえば、ほとんどのバッファーにたいして
、‘paragraph-start’のデフォルトのセッティングを変更するために、
‘setq-default’を使用できます。そして、この変数にたいするバッファーローカ
ルな値をもつCモードやLispモードにいるときでさえ、これは機能します。

   スペシャルフォーム‘defvar’および‘defconst’も、バッファーローカルな値
ではなく、(もし変数にセットする場合は)デフォルト値をセットします。

 -- Function: default-value symbol
     この関数は、SYMBOLのデフォルト値をreturnします。これは、この変数に
     たいして独自の値をもたないバッファーやフレームから参照される値です
     。SYMBOLがバッファーローカルでない場合、これは‘symbol-value’(*note
     Accessing Variables::を参照してください)と同じです。

 -- Function: default-boundp symbol
     関数‘default-boundp’は、SYMBOLのデフォルト値がvoidでないか報告しま
     す。‘(default-boundp 'foo)’が‘nil’をreturnした場合、‘(default-value
     'foo)’はエラーになります。

     ‘default-boundp’は‘default-value’んびたいして、‘boundp’は
     ‘symbol-value’にたいする述語です。

 -- Special Form: setq-default [symbol form]...
     このスペシャルフォームは、各SYMBOLに、対応するFORMを評価した結果を
     新たなデフォルト値として与えます。これはSYMBOLを評価しませんが、
     FORMは評価します。‘setq-default’フォームの値は、最後のFORMの値です
     。

     カレントバッファーにたいしてSYMBOLがバッファーローカルでなく、自動
     的にバッファーローカルにマークされない場合、‘setq-default’は
     ‘setq’と同じ効果をもちます。カレントバッファーにたいしてSYMBOLがバ
     ッファーローカルな場合、これは他のバッファーから参照できる値を変更
     します(それらのバッファーがバッファーローカルな値をもたない限り)が
     、それはカレントバッファーから参照される値ではありません。

          ;; バッファー‘foo’で行う:
          (make-local-variable 'buffer-local)
               ⇒ buffer-local
          (setq buffer-local 'value-in-foo)
               ⇒ value-in-foo
          (setq-default buffer-local 'new-default)
               ⇒ new-default
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ new-default

          ;; (新しい)バッファー‘bar’で行う:
          buffer-local
               ⇒ new-default
          (default-value 'buffer-local)
               ⇒ new-default
          (setq buffer-local 'another-default)
               ⇒ another-default
          (default-value 'buffer-local)
               ⇒ another-default

          ;; バッファー‘foo’に戻って行う:
          buffer-local
               ⇒ value-in-foo
          (default-value 'buffer-local)
               ⇒ another-default

 -- Function: set-default symbol value
     この関数は‘setq-default’と似ていますが、SYMBOLは通常の引数として評
     価されます。

          (set-default (car '(a b c)) 23)
               ⇒ 23
          (default-value 'a)
               ⇒ 23


File: elisp,  Node: File Local Variables,  Next: Directory Local Variables,  Prev: Buffer-Local Variables,  Up: Variables

11.11 File Local Variables
==========================

ファイルにローカル変数の値を指定できます。そのファイルをvisitしているバ
ッファー内で、これらの変数にたいしてバッファーローカルなバインディングを
作成するために、Emacsはこれらを使用します。ファイルローカル変数の基本的
な情報については、*note Local Variables in Files: (emacs)File
Variables.を参照してください。このセクションはファイルローカル変数が処理
される方法に影響する関数と変数を説明します。

   ファイルローカル変数が勝手に関数や、後で呼び出されるLisp式を指定でき
る場合、ファイルのvisitによりEmacsが乗っ取られてしまうかもしれません。
Emacsは、指定された値が安全だと既知のファイルローカル変数だけを自動的に
セットすることにより、この危険から保護します。これ以外のファイルローカル
変数は、ユーザーが同意した場合のみセットされます。

   追加の安全策として、Emacsがファイルローカル変数を読み込むとき、一時的
に‘read-circle’が‘nil’にバインドされます(*note Input Functions::を参照し
てください)。これはLispリーダー循環および共有されたLisp構造(*note
Circular Objects::を参照してください)を認識することを防ぎます。

 -- User Option: enable-local-variables
     この変数はファイルローカル変数を処理するかどうかを制御します。以下
     の値が利用できます:

     ‘t’(デフォルト)
          安全な変数をセットして、安全でない変数については問い合わせます
          (1回)。
     ‘:safe’
          安全な変数だけをセットして、問い合わせはしません。
     ‘:all’
          問い合わせをせずに、すべての変数をセットします。
     ‘nil’
          変数をセットしません。
     その他
          すべての変数にたいして問い合わせます(1回)。

 -- Variable: inhibit-local-variables-regexps
     これは正規表現のリストです。ファイルがこのリストの要素にマッチする
     名前をもつ場合、任意のファイルローカル変数のフォームはスキャンされ
     ません。どんなときにこれを使いたいかの例は、*Note Auto Major
     Mode::を参照してください。

 -- Function: hack-local-variables &optional mode-only
     この関数は、カレントバッファーの内容により指定された任意のローカル
     変数として、必要に応じてバインドと評価を行います。変数
     ‘enable-local-variables’は、ここでも効果をもちます。しかし、この関
     数は‘-*-’行の、‘mode:’ローカル変数を探しません。‘set-auto-mode’はこ
     れを行い、‘enable-local-variables’も考慮されます(*note Auto Major
     Mode::を参照してください)。

     この関数は、‘file-local-variables-alist’内に格納されたalistを調べて
     、各ローカル変数を順に適用することにより機能します。この関数は、変
     数に適用する前(または後)に、‘before-hack-local-variables-hook’(また
     は‘hack-local-variables-hook’)を呼び出します。alistが非‘nil’の場合
     のみ、事前のフック(before-hook)を呼び出し、その他のフックは常に呼び
     出します。この関数は、そのバッファーがすでにもつメジャーモードと同
     じメジャーモードが指定された場合には、‘mode’要素を無視します。

     オプションの引数MODE-ONLYが非‘nil’の場合、この関数が行うのはメジャ
     ーモードを指定するシンボルをreturnするのがすべてで、‘-*-’行またはロ
     ーカル変数リストがメジャーモードを指定していればそのモード、それ以
     外は‘nil’をreturnします。この関数はモードや他のファイルローカル変数
     をセットしません。

 -- Variable: file-local-variables-alist
     このバッファーローカルな変数は、ファイルローカル変数のセッティング
     のalistを保持します。alistの各要素は‘(VAR . VALUE)’という形式で、
     VARはローカル変数のシンボル、VALUEはその値です。Emacsがファイルを
     visitするとき、最初にすべてのファイルローカル変数をこのalistに収集
     して、その後に変数1つずつに関数‘hack-local-variables’を適用します。

 -- Variable: before-hack-local-variables-hook
     Emacsは、‘file-local-variables-alist’に格納されたファイルローカル変
     数を適用する直前に、このフックを呼び出します。

 -- Variable: hack-local-variables-hook
     Emacsは、‘file-local-variables-alist’に格納されたファイルローカル変
     数を適用し終えた直後に、このフックを呼び出します。

   ある変数にたいして‘safe-local-variable’プロパティーにより、安全な値を
指定できます。このプロパティーは引数を1つとる関数です。与えられた値にた
いして、その関数が非‘nil’をreturnした場合、その値は安全です。一般的に目
にするファイル変数の多くは、‘safe-local-variable’プロパティーをもちます
。これらのファイル変数には、‘fill-column’、‘fill-prefix’、
‘indent-tabs-mode’が含まれます。ブーリーン値の変数にたいしては、プロパテ
ィーの値に‘booleanp’を使用します。

   ‘defcustom’を使用してユーザーオプションを定義するとき、‘defcustom’に
引数‘:safe FUNCTION’を追加することにより、‘safe-local-variable’プロパテ
ィーをセットできます(*note Variable Definitions::を参照してください)。

 -- User Option: safe-local-variable-values
     この変数は、ある変数の値が安全であることをマークする、別の方法を提
     供します。これはコンスセル‘(VAR . VAL)’のリストで、VARは変数名、
     VALはその変数にたいして安全な値です。

     Emacsが一連のファイルローカル変数にしたがうかどうかユーザーに尋ねる
     とき、ユーザーはそれらの変数が安全だとマークすることができます。安
     全だとマークすると‘safe-local-variable-values’にこれらの
     variable/valueペアーが追加され、ユーザーのカスタムファイルに保存し
     ます。

 -- Function: safe-local-variable-p sym val
     この関数は、上記の条件に基づき、SYMに値VALを与えても安全な場合は、
     非‘nil’をreturnします。

   いくつかの変数は“危険(risky)”だと判断されます。ある変数が危険な場合、
その変数が自動的に‘safe-local-variable-values’に追加されることはありませ
ん。ユーザーが‘safe-local-variable-values’を直接カスタマイズすることによ
り、明示的に値を許さない限り、危険な変数をセットする前にEmacsは常に確認
を求めます。

   名前が非‘nil’の‘risky-local-variable’プロパティーをもつ任意の変数は、
危険だと判断されます。‘defcustom’を使用してユーザーオプションを定義する
とき、‘defcustom’に引数‘:risky VALUE’を追加することにより、ユーザーオプ
ションに‘risky-local-variable’プロパティーをセットできます。それに加えて
名前が‘-command’、‘-frame-alist’、‘-function’、‘-functions’、‘-hook’、
‘-hooks’、‘-form’、‘-forms’、‘-map’、‘-map-alist’、‘-mode-alist’、
‘-program’、‘-predicate’で終わる任意の変数は、自動的に危険だと判断されま
す。後に数字をともなう変数‘font-lock-keywords’および
‘font-lock-keywords’、さらに‘font-lock-syntactic-keywords’も危険だと判断
されます。

 -- Function: risky-local-variable-p sym
     この関数は、SYMが上記の条件にもとづき危険な変数の場合は、非非
     ‘nil’をreturnします。

 -- Variable: ignored-local-variables
     この変数はファイルによりローカル値を与えられるべきではない変数のリ
     ストを保持します。これらの変数に指定された任意の値は、完全に無視さ
     れます。

   ‘Eval:’“変数”も抜け道になる可能性があるので、Emacsは通常、それを処理
する前に確認を求めます。

 -- User Option: enable-local-eval
     この変数は‘-*-’行中、またはvisitされるファイル内のローカル変数リス
     トの、‘Eval:’にたいする処理を制御します。値‘t’は、無条件に実行する
     ことを意味します。‘nil’は、それらを無視することを意味します。それ以
     外は、各ファイルにたいして何を行うか、ユーザーに確認を求めることを
     意味します。デフォルト値は、‘maybe’です。

 -- User Option: safe-local-eval-forms
     この変数は、ファイルローカル変数リスト内の‘Eval:’“変数”の中、評価し
     ても安全な式のリストを保持します。

   その式が関数呼び出しで、その関数が‘safe-local-eval-function’プロパテ
ィーをもつ場合、そのプロパティー値はその式の評価が安全かどうかを決定しま
す。プロパティー値は、その式をテストするための述語(predicate)、そのよう
な述語のリスト(成功した述語があれば安全)、または‘t’(引数が定数である限り
常に安全)を指定できます。

   テキストプロパティーは、それらの値に関数呼び出しを含めることができる
ので、抜け道になる可能性があります。したがって、Emacsはファイルローカル
変数にたいして指定された文字列値から、テキストプロパティーを取り除きます
。


File: elisp,  Node: Directory Local Variables,  Next: Variable Aliases,  Prev: File Local Variables,  Up: Variables

11.12 Directory Local Variables
===============================

ディレクトリーは、そのディレクトリー内のすべてのファイルに共通なローカル
変数値を指定することができます。Emacsは、そのディレクトリー内の任意のフ
ァイルをvisitしているバッファー内で、それらの変数にたいするバッファーロ
ーカルなバインディングを作成するために、これを使用します。これは、そのデ
ィレクトリー内のファイルが何らかの“プロジェクト”に属していて、同じローカ
ル変数を共有するときなどに有用です。

   ディレクトリーローカル変数を指定するために、2つの異なる方法があります
: 1つは特別なファイルにそれを記述する方法、もう1つはそのディレクトリーに
“プロジェクトクラス(project class)”を定義する方法です。

 -- Constant: dir-locals-file
     この定数は、Emacsがディレクトリーローカル変数が見つけることができる
     期待する、ファイルの名前です。ファイル名は、‘.dir-locals.el’(1)です
     。ディレクトリー内でその名前をもつファイルにより、Emacsはディレクト
     リー内の任意のファイル、または任意のサブディレクトリー(オプションで
     サブディレクトリーを除外できます。以下を参照してください)にセッティ
     ングを適用します。独自に‘.dir-locals.el’をもつサブディレクトリーが
     ある場合、Emacsはサブディレクトリーで見つかった1番深いファイルのデ
     ィレクトリーからディレクトリーツリーを上方に移動しながら、1番深いフ
     ァイルのセッティングを使用します。このファイルは、ローカル変数をフ
     ォーマットされたリストとして指定します。詳細は、*note Per-directory
     Local Variables: (emacs)Directory Variables.を参照してください。

 -- Function: hack-dir-local-variables
     この関数は‘.dir-locals.el’ファイルを読み込み、そのディレクトリー内
     の任意のファイルをvisitしているバッファーにたいしてローカルな
     ‘file-local-variables-alist’内に、それらを適用することなくディレク
     トリーローカル変数を格納します。この関数はディレクトリーローカルな
     セッティングも‘dir-locals-class-alist’(‘.dir-locals.el’ファイルが見
     つかったディレクトリーにたいする特別なクラスを定義する)内に格納しま
     す。この関数は、以下で説明するように、
     ‘dir-locals-set-class-variables’および
     ‘dir-locals-set-directory-class’を呼び出すことにより機能します。

 -- Function: hack-dir-local-variables-non-file-buffer
     この関数はディレクトリーローカル変数を探して、即座にそれらをカレン
     トバッファーに適用します。これはDiredバッファーのような、非ファイル
     バッファーをディレクトリーローカル変数のセッティングにしたがわせる
     ために、モードコマンド呼び出しの中から呼び出されることを意図したも
     のです。非ファイルバッファーにたいしては、Emacsは
     ‘default-directory’と、その親ディレクトリーの中から、ディレクトリー
     ローカル変数を探します。

 -- Function: dir-locals-set-class-variables class variables
     この関数は、CLASSという名前がつけられたシンボルにたいして、一連の変
     数セッティングを定義します。その後このクラスを1つ以上のディレクトリ
     ーに割り当てることができ、するとEmacsはこれらの変数セッティングを、
     それらのディレクトリー内のすべてのファイルに適用します。VARIABLES内
     のリストは、2つの形式 — ‘(MAJOR-MODE . ALIST)’または‘(DIRECTORY .
     LIST)’ — のうち1つをもつことができます。1番目の形式では、そのファイ
     ルのバッファーがMAJOR-MODEを継承するモードに切り替わるときに、連想
     リストALIST内のすべての変数が適用されます。ALISTは、‘(NAME .
     VALUE)’という形式です。MAJOR-MODEにたいする特別な値‘nil’は、そのセ
     ッティングが任意のモードに適用できることを意味します。ALIST内では、
     特別なNAMEとして、‘subdirs’を使用することができます。連想値が
     ‘nil’の場合、alistは関連するディレクトリー内のファイルだけに適用さ
     れ、それらのサブディレクトリーには適用されません。

     VARIABLESの2番目の形式では、DIRECTORYがそのファイルのディレクトリー
     の最初のサブディレクトリーの場合、上記のルールにしたがって、LISTが
     再帰的に適用されます。LISTは、この関数のVARIABLESで指定できる2つの
     形式のうち、1つを指定します。

 -- Function: dir-locals-set-directory-class directory class &optional
          mtime
     この関数は‘directory’およびサブディレクトリー内のすべてのファイルに
     CLASSを割り当てます。その後、CLASSにたいして指定されたすべての変数
     セッティングは、DIRECTORYおよびその子ディレクトリー内でvisitされた
     任意のファイルに適用されます。CLASSは事前に
     ‘dir-locals-set-class-variables’で定義されていなければなりません。

     Emacsは、‘.dir-locals.el’ファイルからディレクトリー変数をロードする
     とき、内部的にこの関数を使用します。その場合、オプションの引数
     MTIMEは、ファイルの修正日時(modification time。‘file-attributes’に
     よりreturnされる)を保持します。Emacsは、記憶されたローカル変数がま
     だ有効化チェックするために、この日時を使用します。ファイルを通じ手
     ではなく直接クラスを割り当てる場合、この引数は‘nil’になります。

 -- Variable: dir-locals-class-alist
     このalistはクラスシンボル(class symbol)と連想変数セッティング
     (associated variable settings)を保持します。これは
     ‘dir-locals-set-class-variables’により更新されます。

 -- Variable: dir-locals-directory-cache
     このalistはディレクトリー名、それらに割り当てられたクラス名、および
     このエントリーに関連するディレクトリーローカル変数ファイルの修正日
     時を保持します。関数‘dir-locals-set-directory-class’は、このlistを
     更新します。

 -- Variable: enable-dir-local-variables
     ‘nil’の場合、ディレクトリーローカル変数は無視されます。この変数は、
     ファイルローカル変数(*note File Local Variables::を参照してください
     )にしたがい、ディレクトリーローカル変数は無視したいモードにたいして
     有用かもしれません。

   ---------- Footnotes ----------

   (1) MS-DOS版のEmacsは、DOSファイルシステムの制限により、かわりに
‘_dir-locals.el’という名前を使用します。


File: elisp,  Node: Variable Aliases,  Next: Variables with Restricted Values,  Prev: Directory Local Variables,  Up: Variables

11.13 Variable Aliases
======================

シノニムとして2つの変数を作成するのが有用なときがあります。2つの変数は常
に同じ値をもち、、どちらか一方を変更すると、もう一方も変更されます。変数
の名前を変更 — 古い名前はよく考慮して選択されたものではなかった、あるい
は変数の意味が部分的に変更された等の理由で — するとき、互換性のために新
しい名前の_エイリアス(alias)_として古い名前を維持するのが有用なときがあ
るかもしれません。‘defvaralias’により、これを行うことができます。

 -- Function: defvaralias new-alias base-variable &optional docstring
     この関数はシンボルBASE-VARIABLEのエイリアスとして、シンボル
     NEW-ALIASを定義します。これはNEW-ALIASから値を取得すると、
     BASE-VARIABLEの値がreturnされ、NEW-ALIASの値を変更すると、
     BASE-VARIABLEの値が変更されることを意味します。エイリアスされた2つ
     の変数名は、常に同じ値と同じバインディングを共有します。

     DOCSTRING引数が非‘nil’の場合、それはNEW-ALIASのドキュメント文字列を
     指定します。それ以外では、エイリアスは(もしあれば)BASE-VARIABLEと同
     じドキュメント文字列となります。ただし、それはBASE-VARIABLE自体がエ
     イリアスではない場合で、エイリアスの場合、NEW-ALIASはエイリアスチェ
     ーンの最後の変数のドキュメント文字列になります。

     この関数はBASE-VARIABLEをreturnします。

   変数のエイリアスは、変数にたいする古い名前を新しい名前に置き換える、
便利な方法です。‘make-obsolete-variable’は古い名前を陳腐化(obsolete)して
いると宣言し。それが将来のある時点で削除されるかもしれないことを宣言しま
す。

 -- Function: make-obsolete-variable obsolete-name current-name when
          &optional access-type
     この関数は、倍とコンパイラーに変数OBSOLETE-NAMEが陳腐化していると警
     告させます。CURRENT-NAMEがシンボルの場合、それはこの変数の新たな名
     前です。その後、OBSOLETE-NAMEのかわりにCURRENT-NAMEを使用するよう、
     警告メッセージを伝えます。CURRENT-NAMEが文字列の場合、これはメッセ
     ージで、置き換えられる変数はありません。WHENは、その変数が最初に陳
     腐化するのがいつかを示す文字列です(通常はバージョン番号文字列)。

     オプションの引数ACCESS-TYPEは、非‘nil’の場合は陳腐化の警告を引き起
     こすアクセスの種類を指定します。‘get’または‘set’を指定できます。

   2つの変数シノニムを作成して、マクロ‘define-obsolete-variable-alias’を
使用することにより同時に1つが陳腐化していると宣言できます。

 -- Macro: define-obsolete-variable-alias obsolete-name current-name
          &optional when docstring
     このマクロは変数OBSOLETE-NAMEが陳腐化しているとマークして、それを変
     数CURRENT-NAMEにたいするエイリアスにします。これは以下と等価です:

          (defvaralias OBSOLETE-NAME CURRENT-NAME DOCSTRING)
          (make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN)

 -- Function: indirect-variable variable
     この関数は、VARIABLEのエイリアスチェーンの最後の変数をreturnします
     。VARIABLEがシンボルでない場合、またはVARIABLEがエイリアスとして定
     義されていない場合、この関数はVARIABLEをreturnします。

     この関数は、シンボルのチェーンがループしているときは、
     ‘cyclic-variable-indirection’エラーをシグナルします。

     (defvaralias 'foo 'bar)
     (indirect-variable 'foo)
          ⇒ bar
     (indirect-variable 'bar)
          ⇒ bar
     (setq bar 2)
     bar
          ⇒ 2
     foo
          ⇒ 2
     (setq foo 0)
     bar
          ⇒ 0
     foo
          ⇒ 0


File: elisp,  Node: Variables with Restricted Values,  Next: Generalized Variables,  Prev: Variable Aliases,  Up: Variables

11.14 Variables with Restricted Values
======================================

通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てること
ができます。しかし、LispではなくCで定義されたLisp変数もあります。これら
の変数のほとんどは、‘DEFVAR_LISP’を使用してCコードで定義されています。
Lispで定義された変数と同様、これらは任意の値をとることができます。しかし
、いくつかの変数は‘DEFVAR_INT’や‘DEFVAR_BOOL’を使用して定義されています
。C実装の概要的な議論は、*note Writing Emacs Primitives: Defining Lisp
variables in C.、特にタイプ‘syms_of_FILENAME’の関数の説明を参照してくだ
さい。

   タイプが‘DEFVAR_BOOL’の変数は、値に‘nil’か‘t’しかとることができません
。他の値の割り当てを試みると、‘t’はセットされます:

     (let ((display-hourglass 5))
       display-hourglass)
          ⇒ t

 -- Variable: byte-boolean-vars
     この変数は、タイプ‘DEFVAR_BOOL’のすべての変数のリストを保持します。

   タイプが‘DEFVAR_INT’の変数は、整数値だけをとることができます。他の値
の割り当てを試みると、結果はエラーになります:

     (setq undo-limit 1000.0)
     error→ Wrong type argument: integerp, 1000.0


File: elisp,  Node: Generalized Variables,  Prev: Variables with Restricted Values,  Up: Variables

11.15 Generalized Variables
===========================

“ジェネリック変数(generalized variable： 汎変数)”または“place form”は、
値が格納されるLispメモリー内の多くの場所のうちの1つです。1番シンプルな
place formは、通常のLisp変数です。しかし、リストのCARとCDR、配列の要素、
シンボルのプロパティー、その他多くのロケーション(location)も、Lisp値が格
納される場所です。

   ジェネリック変数は、C言語の“lvalues(左辺値)”と類似しています。C言語の
lvalueでは、‘x = a[i]’で配列から要素を取得し、同じ表記を使用して、‘a[i]
= x’で要素を格納します。‘a[i]’のような特定のフォームが、Cではlvalueにな
れるように、Lispでジェネリック変数になることができる一連のフォームが存在
します。

* Menu:

* Setting Generalized Variables::  ‘setf’マクロ。
* Adding Generalized Variables::  新たな‘setf’フォームの定義。


File: elisp,  Node: Setting Generalized Variables,  Next: Adding Generalized Variables,  Up: Generalized Variables

11.15.1 The ‘setf’ Macro
------------------------

‘setf’マクロは、ジェネリック変数を操作する、もっとも基本的な方法です。
‘setf’フォームは‘setq’と似ていますが、シンボルだけでなく、左辺の任意の
place formを受け入れます。たとえば‘(setf (car a) b)’は‘a’のcarを‘b’にセ
ットして、‘(setcar a b)’と同じ操作を行いますが、すべてのplaceのタイプに
セットおよびアクセスするために2つの別個の関数を覚える必要はありません。

 -- Macro: setf [place form]...
     このマクロはFORMを評価して、それをPLACEに格納します。PLACEは有効な
     ジェネリック変数フォームでなければなりません。複数のPLACE/FORMペア
     ーがある場合、割り当ては‘setq’のときと同様です。‘setf’は最後の
     FORMの値をreturnします。

   以下のLispフォームはジェネリック変数として機能するので、‘setf’の
PLACE引数にすることができます:

   • 変数を命名するシンボル。他の言い方をすると、‘(setf x y)’は完全に
     ‘(setq x y)’と等しく、厳密に言うと‘setq’自体は‘setf’が存在するので
     冗長です。これは純粋にスタイルと歴史的な理由によりますが、多くのプ
     ログラマーは依然として単純な変数へのセットには‘setq’の方を好みます
     。マクロ‘(setf x y)’は、実際には‘(setq x y)’に展開されるので、コン
     パイルされたコードでこれを使用することにパフォーマンス的な不利はあ
     りません。

   • 以下の標準的なLisp関数の呼び出し:

          aref      cddr      symbol-function
          car       elt       symbol-plist
          caar      get       symbol-value
          cadr      gethash
          cdr       nth
          cdar      nthcdr

   • 以下のEmacs特有な関数の呼び出し:

          default-value                 process-get
          frame-parameter               process-sentinel
          terminal-parameter            window-buffer
          keymap-parent                 window-display-table
          match-data                    window-dedicated-p
          overlay-get                   window-hscroll
          overlay-start                 window-parameter
          overlay-end                   window-point
          process-buffer                window-start
          process-filter

どのように処理すれば良いか知られていないPLACEフォームを渡した場合、
‘setf’はエラーをシグナルします。

   ‘nthcdr’の場合、関数のリスト引数は、それ自体が有効なPLACEフォームでな
ければならないことに注意してください。たとえば、‘(setf (nthcdr 0 foo)
7)’は、‘foo’自体に7をセットするでしょう。

   マクロ‘push’(*note List Variables::を参照してください)、および
‘pop’(*note List Elements::を参照してください)は、リストだけでなくジェネ
リック変数を操作できます。‘(pop PLACE)’は、PLACE内に格納されたリストの最
初の要素を削除してreturnします。これは‘(prog1 (car PLACE) (setf PLACE
(cdr PLACE)))’と類似していますが、すべてのサブフォームを1度だけ評価しま
す。‘(push X PLACE)’は、PLACE内に格納されたリストの1番前に、Xを挿入しま
す。これは‘(setf PLACE (cons X PLACE))’と類似していますが、サブフォーム
の評価を除きます。‘nthcdr’ placeへの‘push’および‘pop’は、リスト内の任意
の位置での挿入および削除に使用できることに注意してください。

   ‘cl-lib’ライブラリーは、追加の‘setf’ placeを含む、ジェネリック変数ニ
タイスルサマザマナ拡張を定義します。*note (cl)Generalized Variables::を
参照してください。


File: elisp,  Node: Adding Generalized Variables,  Prev: Setting Generalized Variables,  Up: Generalized Variables

11.15.2 Defining new ‘setf’ forms
---------------------------------

このセクションでは、‘setf’が操作できる新たなフォームを定義する方法を説明
します。

 -- Macro: gv-define-simple-setter name setter &optional fix-return
     このマクロは、単純なケースにたいして‘setf’メソッドを簡単に定義する
     ことを可能にします。NAMEは、関数、マクロ、スペシャルフォームの名前
     です。NAMEが、それを更新するための対応するSETTER関数をもつときは、
     このマクロを使用できます(たとえば‘(gv-define-simple-setter car
     setcar)’)。

     このマクロをフォーム以下の呼び出しを

          (setf (NAME ARGS...) VALUE)

     以下のように変換します。
          (SETTER ARGS... VALUE)

     ‘setf’のような呼び出しは、VALUEをreturnするようにドキュメントされま
     す。これに問題はありません。たとえば‘car’と‘setcar’では、‘setcar’は
     それがセットする値をreturnするからです。SETTER関数がVALUEをreturnし
     ない場合は、‘gv-define-simple-setter’のFIX-RETURN引数に、非‘nil’値
     を使用してください。これは以下のようなものに展開されます
          (let ((temp VALUE))
            (SETTER ARGS... temp)
            temp)
     これで正しい結果がreturnされることが保証されます。

 -- Macro: gv-define-setter name arglist &rest body
     このマクロは、上述のフォームより複雑な‘setf’展開を可能にします。た
     とえば、呼び出すべきシンプルなsetter関数が存在しないときや、もしそ
     れが存在してもplace formとは異なる引数を要求する場合には、このフォ
     ームを使う必要があるかもしれません。

     このマクロは最初に‘setf’引数フォーム‘(VALUE ARGS...)’をARGLISTにバ
     インドして、その後BODYを実行することにより、フォーム‘(setf (NAME
     ARGS...) VALUE)’を展開します。BODYは割り当てを行うLispフォームを
     returnし、最後にセットされた値をreturnするべきです。以下はこのマク
     ロの使用例です:

          (gv-define-setter caar (val x) `(setcar (car ,x) ,val))

   展開をさらに制御するには、マクロ‘gv-define-expander’を参照してくださ
い。マクロ‘gv-letplace’は、‘setf’のように処理を行うマクロを定義するのに
有用です。詳細は、‘gv.el’のソースファイルを参照してください。

     Common Lispに関する注意: Common Lispは関数の‘setf’、すなわち
     “‘setf’関数”の挙動を指定するための別の方法を定義します。‘setf’関数
     の名前はシンボルではなく。リスト‘(setf NAME)’です。たとえば‘(defun
     (setf foo) ...)’は、‘setf’が‘foo’に適用されるときに使用される関数を
     定義します。Emacsはこれをサポートしません。適切な展開が定義されてい
     ないフォームに‘setf’を使用すると、コンパイル時にエラーとなります。
     Common Lispでは、関数‘(setf FUNC)’が後で定義されるので、エラーには
     なりません。


File: elisp,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

12 Functions
************

Lispプログラムは主にLisp関数で構成されます。このチャプターは、関数とは何
か、引数を受け取る方法、関数を定義する方法を説明します。

* Menu:

* What Is a Function::       Lisp関数 vs. プリミティブ;
                               専門用語。
* Lambda Expressions::       関数がLispオブジェクトとして表現される方法。
* Function Names::           シンボルは関数を名づける役割を果たすことができる。
* Defining Functions::       関数定義のためのLisp式。
* Calling Functions::        既存の関数を使う方法。
* Mapping Functions::        リストの各要素などに関数を適用する。
* Anonymous Functions::      ラムダ式、それは無名の関数。
* Function Cells::           シンボルの関数定義へのアクセスとセット。
* Closures::                 レキシカル環境に囲まれた関数。
* Advising Functions::       関数の定義への追加。
* Obsolete Functions::       関数を陳腐と宣言する。
* Inline Functions::         コンパイラーによりインライン展開される関数。
* Declare Form::             関数についての補足的な情報の追加。
* Declaring Functions::      関数が定義されていることをコンパイラーに知らせる。
* Function Safety::          呼び出しても安全な関数なのか判断する。
* Related Topics::           関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。


File: elisp,  Node: What Is a Function,  Next: Lambda Expressions,  Up: Functions

12.1 What Is a Function?
========================

一般的な意味では、関数とは“引数(arguments)”と呼ばれる与えられた入力値の
計算を担うルールです。計算の結果は、その関数の“値(value)”、または
“return値(return value)”と呼ばれます。計算は、変数の値やデータ構造の内容
を変更する等の副作用をもつこともできます。

   ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しか
しLispでは、厳密な意味において、関数は名前をもちません。関数はオブジェク
トであり、関数の名前の役割を果たすシンボルに関連づけることができますが
(たとえば‘car’)、それは_オプション_です。*note Function Names::を参照し
てください。関数が名前を与えられたとき、通常はそのシンボルを“関数”として
参照します(たとえば、関数‘car’のように参照します)。このマニュアルでは、
関数名と関数オブジェクト自身との間の区別は、通常は重要ではありませんが、
それが意味をもつような場合は注記します。

   “スペシャルフォーム(special form)”、“マクロ(macro)”と呼ばれる、関数
likeなオブジェクトがいくつかあり、それらも引数を受け受け、計算を担います
。しかし以下で説明するように、Emacs Lispではこれらは関数とは考えられませ
ん。

   以下は関数および関数likeなオブジェクトにたいする、重要な条件です:

“lambda expression”
     Lispで記述された関数(厳密には関数オブジェクト)です。これらについて
     は、以降のセクションで説明します。 *note Lambda Expressions::を参照
     してください。

“primitive”
     Lispから呼び出すことができますが、実際にはCで記述されています。プリ
     ミティブは、“ビルトイン関数(built-in functions)”や、“サブルーチン
     (subr)”といった呼ばれかたもします。それらの例には関数likeな‘car’や
     ‘append’が含まれます。加えて、すべてのスペシャルフォーム(以下参照
     )もプリミティブと考えられます。

     関数はLispの基礎となる部分(たとえば‘car’)であり、オペレーティングシ
     ステムのサービスにたいして値レベルのインターフェースを与え、高速に
     実行される必要があるため、通常はプリミティブとして実装されています
     。Lispで定義された関数とは異なり、プリミティブの修正や追加には、Cソ
     ースの変更とEmacsのリコンパイルが必要です。*note Writing Emacs
     Primitives::を参照してください。

“special form”
     プリミティブは関数と似ていますが、すべての引数が通常の方法で評価は
     されません。いくつかの引数だけが評価されるかもしれず、通常ではない
     順序で、複数回評価されるかもしれません。プリミティブの例には、
     ‘if’、‘and’、‘while’が含まれます。*note Special Forms::を参照してく
     ださい。

“macro”
     あるLisp式を、オリジナルの式のかわりに評価される別の式に変換する、
     関数とは別のLispで定義された構造です。マクロは、スペシャルフォーム
     が行う一連のことを、Lispプログラマーが行うのを可能にします。*note
     Macros::を参照してください。

“command”
     ‘command-execute’プリミティブを通じて呼び出すことができるオブジェク
     トで、通常はそのコマンドに“バインド”されたキーシーケンスを、ユーザ
     ーがタイプすることにより呼び出されます。*note Interactive Call::を
     参照してください。コマンドは通常、関数です。その関数がLispで記述さ
     れている場合は、関数の定義内の‘interactive’フォームによりコマンドと
     なります(*note Defining Commands::を参照してください)。関数であるコ
     マンドは、他の関数と同様、Lisp式から呼び出すこともできます。

     キーボードマクロ(文字列およびベクター)は関数ではありませんが、これ
     らもコマンドです。*note Keyboard Macros::を参照してください。シンボ
     ルの関数セルにコマンドが含まれている場合、わたしたちはそのシンボル
     をコマンドと言います(*note Symbol Components::を参照してください)。
     そのような“名前つきコマンド(named command)”は、‘M-x’で呼び出すこと
     ができます。

“closure”
     ラムダ式とよく似た関数オブジェクトですが、クロージャーはレキシカル
     変数バインディングの“環境”にも囲まれています。*note Closures::を参
     照してください。

“byte-code function”
     バイトコンパイラーによりコンパイルされた関数です。*note Byte-Code
     Type::を参照してください。

“autoload object”
     実際の関数のプレースホルダーです。autoloadオブジェクトが呼び出され
     た場合、Emacsは実際の関数の定義を含むファイルをロードした後、実際の
     関数を呼び出します。*note Autoload::を参照してください。

   関数‘functionp’を使用して、あるオブジェクトが関数かどうかテストできま
す:

 -- Function: functionp object
     この関数はOBJECTが任意の種類の関数(たとえば‘funcall’に渡すことがで
     きる)の場合は、‘t’をreturnします。‘functionp’は関数を名づけるシンボ
     ルにたいしては‘t’、スペシャルフォームにたいしては‘nil’をreturnする
     ことに注意してください。

‘functionp’とは異なり、以下の3つの関数は、シンボルをそれの関数定義として
は扱い_ません_。

 -- Function: subrp object
     この関数は、OBJECTがビルトイン関数(たとえばLispプリミティブ)の場合
     は、‘t’をreturnします。

          (subrp 'message)            ; ‘message’はシンボルであり、
               ⇒ nil                 ;   subrオブジェクトではない。
          (subrp (symbol-function 'message))
               ⇒ t

 -- Function: byte-code-function-p object
     この関数は、OBJECTがバイトコード関数の場合は、‘t’をreturnします。た
     とえば:

          (byte-code-function-p (symbol-function 'next-line))
               ⇒ t

 -- Function: subr-arity subr
     この関数はプリミティブSUBRの引数リストについての情報を提供します。
     retrun値は、‘(MIN . MAX)’というペアーです。MINは引数の最小数です。
     MAXは最大数、または引数‘&rest’を伴う関数にたいしてはシンボル
     ‘many’、SUBRがスペシャルフォームの場合はシンボル‘unevalled’です。


File: elisp,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

12.2 Lambda Expressions
=======================

ラムダ式(lambda expression)は、Lispで記述された関数オブジェクトです。以
下は例です:

     (lambda (x)
       "Xの双曲線コサインをreturnする。"
       (* 0.5 (+ (exp x) (exp (- x)))))

Emacs Lispでは、このようなリストは、関数オブジェクトに評価される、有効な
式です。

   ラムダ式自身は名前をもたない、“無名関数(anonymous function)”です。ラ
ムダ式をこの方法で使用できますが(*note Anonymous Functions::を参照してく
ださい)、“名前付き関数(named functions)”を作成するためにシンボルに関連付
けられる方が一般的です(*note Function Names::)。これらの詳細に触れる前に
、以下のサブセクションではラムダ式の構成要素と、それらが行うことについて
説明します。

* Menu:

* Lambda Components::        ラムダ式のパーツ。
* Simple Lambda::            シンプルな例。
* Argument List::            引数リストの詳細と特別な機能。
* Function Documentation::   関数内にドキュメントを記述する方法。


File: elisp,  Node: Lambda Components,  Next: Simple Lambda,  Up: Lambda Expressions

12.2.1 Components of a Lambda Expression
----------------------------------------

ラムダ式は、以下のようなリストです:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

   ラムダ式の1番目の要素は常にシンボル‘lambda’です。これは、そのリストが
関数を表すことを示します。‘lambda’で関数定義を開始する理由は、他の目的の
たまえの使用が意図された他のリストが、意図せず関数として評価されないよう
にするためです。

   2番目の要素は、シンボル — 引数変数名のリストです。これは“ラムダリスト
(lambda list)”と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリ
スト内の変数と対応付けされます。ラムダリストは、与えられた値にたいするロ
ーカルバインディングが付与されます。*note Local Variables::を参照してく
ださい。

   ドキュメント文字列(documentation string)はEmacs Lispのヘルプ機能にた
いしてその、関数を説明する、関数定義に配されたLisp文字列オブジェクトです
。*note Function Documentation::を参照してください。

   インタラクティブ宣言(interactive declaration)は、‘(interactive
CODE-STRING)’という形式のリストです。これは、この関数が対話的に使用され
た場合に引数を提供する方法を宣言します。この宣言をもつ関数は、“コマンド
(command)”と呼ばれます。コマンドは‘M-x’を使用したり、キーにバインドして
呼び出すことができます。この方法で呼び出されることを意図しない関数は、イ
ンタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述す
る方法は、*Note Defining Commands::を参照してください。

   残りの要素は、その関数の“body(本体)” — その関数が処理を行うための
Lispコード(Lispプログラマーは“評価されるLispフォームのリスト”と言うでし
ょう)です。この関数からreturnされる値は、bodyの最後の要素によりreturnさ
れる値です。


File: elisp,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

12.2.2 A Simple Lambda Expression Example
-----------------------------------------

以下の例を考えてみてください:

     (lambda (a b c) (+ a b c))

以下のように、‘funcall’に渡すことにより、この関数を呼び出すことができま
す:

     (funcall (lambda (a b c) (+ a b c))
              1 2 3)

この呼び出しは、変数‘a’に1、‘b’に2、‘c’に3をバインドして、ラムダ式の
bodyを評価します。bodyの評価により、これら3つの数が加算されて、6が結果と
して生成されます。したがってこの関数呼び出しにより、6がreturnされます。

   以下のように、引数は他の関数の結果であってもよいことに注意してくださ
い:

     (funcall (lambda (a b c) (+ a b c))
              1 (* 2 3) (- 5 4))

これは引数‘1’、‘(* 2 3)’、‘(- 5 4)’を左から右に評価します。その後、ラム
ダ式に引数1、6、1を適用して、値8が生成されます。

   これらの例が示すように、ローカル変数を作成して、それらに値を与えるフ
ォームとして、CARがラムダ式であるようなフォームを使用することができます
。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一
の方法でした。しかし現在では、この目的にはフォーム‘let’を使用するほうが
明解です(*note Local Variables::を参照してください)。ラムダ式は主に、他
の関数の引数として渡される無名関数(*note Anonymous Functions::を参照して
ください)として、あるいは名前つき関数(*note Function Names::を参照してく
ださい)を生成するためにシンボルの関数定義に格納するために使用されます。


File: elisp,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

12.2.3 Other Features of Argument Lists
---------------------------------------

シンプルなサンプル関数‘(lambda (a b c) (+ a b c))’は、3つの引数変数を指
定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指
定しなかったり4つ指定した場合は、‘wrong-number-of-arguments’エラーとなり
ます。

   特定の引数を省略できる関数を記述できると便利なこともあります。たとえ
ば関数‘substring’は3つの引数 — 文字列、開始インデックス、終了インデック
ス — を受け取りますが、3つ目の引数を省略した場合、デフォルトでその文字列
のLENGTHとなります。関数‘list’や‘+’が行うように、特定の関数にたいして不
定個の引数を指定できると便利なときもあります。

   関数が呼び出されるとき省略されるかもしれないオプションの引数を指定す
るには、オプションの引数の前にキーワード‘&optional’を含めるだけです。0個
以上の追加引数のリストを指定するには、最後の引数の前にキーワード
‘&rest’を含めます。

   したがって、引数リストの完全な構文は以下のようになります:

     (REQUIRED-VARS...
      [&optional OPTIONAL-VARS...]
      [&rest REST-VAR])

角カッコ(square bracket)は、‘&optional’と‘&rest’、およびそれらに続く変数
が省略できることを示します。

   この関数の呼び出しには、REQUIRED-VARSのそれぞれにたいして、実際の引数
が要求されます。0個以上のOPTIONAL-VARSにたいして実際の引数があるかもしれ
ませんが、ラムダ式が‘&rest’を使用していなければ、その個数を超えて実際の
引数を記述することはできません。‘&rest’が記述されている場合、追加で任意
個の実際の引数があるかもしれません。

   optionaやrest変数にたいして実際の引数が省略された場合、それらのデフォ
ルトは常に‘nil’になります。関数にたいして引数に明示的に‘nil’が使用された
のか、引数が省略されたのかを区別することはできません。しかし関数のbodyが
、‘nil’を他の有意な値が省略されたと判断することは自由です。これは
‘substring’が行っていることです。‘substring’の3つ目の引数が‘nil’の場合、
それは文字列の長さを使用することを意味します。

     Common Lispに関する注意: Common Lispでは、オプションの引数が省略さ
     れたときに使用するデフォルト値を指定できます。Emacs Lispは、引数が
     明示的に渡されたかを調べる、“supplied-p”変数はサポートしません。

   例えば、引数リストは以下のようになります:

     (a b &optional c d &rest e)

これは‘a’と‘b’は最初の2つの実引数となり、これらは必須です。さらに1つまた
は2つの引数が指定された場合、それらは順番に‘c’と‘d’にバインドされます。
1つ目から4つ目の引数の後の引数は、リストにまとめられて、‘e’にそのリスト
がバインドされます。2つしか引数が指定されなかった場合、‘c’は‘nil’になり
ます。2つまたは3つの引数の場合、‘d’は‘nil’です。引数が4つ以下の場合、
‘e’は‘nil’になります。

   オプションの引数の後ろに必須の引数を指定する方法はありません — これは
意味を成さないからです。なぜそうなるかは、この例で‘c’がオプションで‘d’が
必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番
めの引数は何を指定したのでしょうか? この引数はCなのでしょうか、それとも
Dに使用されるのでしょうか? 両方の場合が考えられます。同様に、‘&rest’引数
の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。

   以下に引数リストと、それを正しく呼び出す例をいくつか示します:

     (funcall (lambda (n) (1+ n))        ; 1つの必須:
              1)                         ; これは正確に1つの引数を要求する。
          ⇒ 2
     (funcall (lambda (n &optional n1)   ; 1つは必須で、1つはオプション:
                (if n1 (+ n n1) (1+ n))) ; 1つまたは2つの引数。
              1 2)
          ⇒ 3
     (funcall (lambda (n &rest ns)       ; 1つは必須で、後は残り:
                (+ n (apply '+ ns)))     ; 1つ以上の引数。
              1 2 3 4 5)
          ⇒ 15


File: elisp,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

12.2.4 Documentation Strings of Functions
-----------------------------------------

ラムダ式は、ラムダリストの食後に、オプションで“ドキュメント文字列
(documentation string)”をもつことができます。この文字列は、その関数の実
行に影響を与えません。これはコメントの一種ですが、Lisp機構に内在するシス
テム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメン
ト文字列にアクセスする方法は、*note Documentation::を参照してください。

   たとえその関数があなたのプログラム内だけで呼び出される関数だとしても
、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメ
ント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。

   ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。な
ぜなら‘apropos’は、最初の1行目だけを表示するからです。ドキュメント文字列
の1行目は、その関数の目的を要約する、1つまたは2つの完全なセンテンスで構
成されるべきです。

   ドキュメント文字列の開始は通常、ソースファイル内ではインデントされて
いますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントの
スペースがあるので、インデントはドキュメント文字列の一部にはなりません。
ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントす
る人がいます。_これは、間違いです。_後続の行のインデントは文字列の内部に
あります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンド
で表示したとき見栄えが悪くなります。

   ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれませ
ん。なぜなら、ドキュメント文字列の後には必須となる関数の構成要素である
bodyが続くからです。文字列を評価するとその文字列自身がれつｒｎされるので
、それがbody内の最後のフォームでない限りなんの効果もありません。したがっ
て、実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません
。bodyの唯一のフォームが文字列の場合、それはreturn値とドキュメントの両方
の役目を果たします。

   ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規
約を指定できます。これは以下のようなテキストを記述します

     \(fn ARGLIST)

ただし、このテキストの前に空行があり、テキスト自身が行頭から記述されてい
て、ドキュメント文字列内でこのテキストの後に改行が続かない場合です(‘\’は
Emacsの移動コマンドが混乱するのを避けるために使用されます)。この方法で指
定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼
び出し例と同じ場所に表示されます。

   マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考
える方法と合致しない場合がしばしばあるので、この機能はマクロ定義で特に有
用です。


File: elisp,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

12.3 Naming a Function
======================

シンボルは関数の名前となることができます。これは、そのシンボルの“関数セ
ル(function cell”: *note Symbol Components::を参照してください)が、関数
オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル
自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価
になります。

   関数セルの内容は、そのシンボルの“関数定義(function definition)”と呼ぶ
こともできます。そのシンボルのかわりに、シンボルの関数定義を使う手続きの
ことを“シンボル関数インダイレクション(symbol function indirection)”と呼
びます。*note Function Indirection::を参照してください。与えられたシンボ
ルに関数定義がない場合、シンボルの関数セルは“void”と呼ばれ、それを関数と
して使用することはできません。

   実際のところ、ほとんどすべての関数は名前をもち、その名前により参照さ
れます。ラムダ式を定義することにより名前つきのLisp関数を作成、それを関数
セル(*note Function Cells::を参照してください)に置くことができます。しか
し、さらに一般的なのは‘defun’スペシャルフォーム(次のセクションで説明しま
す)を使う方法です。 *note Defining Functions::を参照してください。

   わたしたちは関数名を与えるのは、Lisp式内で関数を名前で参照するのが便
利だからです。また、名前つきの関数は簡単に自分自身を —再帰的
(recursive)に参照することができます。さらに、プリミティブはテキスト的な
名前だけで参照することができます。なぜならプリミティブ関数は入力構文
(read syntax)をもたないオブジェクトだからです(*note Primitive Function
Type::を参照してください)。

   関数は一意な名前をもつ必要はありません。与えられた関数オブジェクトは
、_通常_は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的な
ものです。‘fset’を使用して、関数を複数のシンボルに格納するのは簡単です。
それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。

   関数として使用されているシンボルを、変数としても利用できることに注意
してください。シンボルのこれら2つの利用法は独立しており、競合はしません
(これはSchemaのような他のいくつかのLisp方言には当てはまりません)。


File: elisp,  Node: Defining Functions,  Next: Calling Functions,  Prev: Function Names,  Up: Functions

12.4 Defining Functions
=======================

わたしたちは通常、関数を最初に作成したときに名前を与えます。これは“関数
の定義(defining a function)”と呼ばれ、‘defun’マクロにより行われます。

 -- Macro: defun name args [doc] [declare] [interactive] body...
     ‘defun’は新たなLisp関数を定義する通常の方法です。これは、引数リスト
     ARGS、およびBODYにより与えられるbodyフォームとともに、シンボル
     NAMEを関数として定義します。NAMEとARGSを、クォートする必要はありま
     せん。

     DOCが与えられた場合、それはその関数のドキュメント文字列を指定する文
     字列であるべきです(*note Function Documentation::を参照してください
     )。DECLAREが与えられた場合、それは関数のメタデータを指定する、
     ‘declare’フォームであるべきです(*note Declare Form::を参照してくだ
     さい)。INTERACTIVEが与えられた場合、それは関数が対話的に呼び出され
     る方法を指定する‘interactive’フォームであるべきです(*note
     Interactive Call::を参照してください)。

     ‘defun’のreturn値は定義されていません。

     以下にいくつか例を示します:

          (defun foo () 5)
          (foo)
               ⇒ 5

          (defun bar (a &optional b &rest c)
              (list a b c))
          (bar 1 2 3 4 5)
               ⇒ (1 2 (3 4 5))
          (bar 1)
               ⇒ (1 nil nil)
          (bar)
          error→ Wrong number of arguments.

          (defun capitalize-backwards ()
            "Upcase the last letter of the word at point."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

     意図せず既存の関数を再定義しないように、注意してください。‘defun’は
     ‘car’のようなプリミティブ関数でさえ、躊躇なく問い合わせもなしに再定
     義します。Emacsががががこれを妨げることはありません。なぜなら関数の
     再定義は故意に行われることがあり、そのような意図した再定義を、意図
     しない再定義と見分ける方法はないからです。

 -- Function: defalias name definition &optional doc
     この関数は、定義DEFINITION(任意の有効なLisp関数)とともに、シンボル
     NAMEを関数として定義します。この関数のreturn値は_未定義_です。

     DOCが非‘nil’の場合、それは関数NAMEのドキュメントになります。それ以
     外は、DEFINITIONにより提供されるドキュメントが使用されます。

     内部的には、‘defalias’は通常、定義のセットに‘fset’を使用します。し
     かしNAMEが‘defalias-fset-function’プロパティーをもつ場合、‘fset’を
     呼び出すかわりに、それに割り当てられた値が使用されます。

     ‘defalias’を使う正しい場所は、特定の関数名がまさに定義される場所 —
     特にソースファイルがロードされるとき明示的にその名前が出現する場所
     です。これは‘defalias’が、‘defun’と同じように、どれが関数を定義する
     ファイルなのか記録するからです(*note Unloading::を参照してください
     )。

     それとは対象的に、他の目的のために関数を操作するプログラムでは、そ
     のような記録を保持しない‘fset’を使用するほうがよいでしょう。*note
     Function Cells::を参照してください。

   ‘defun’や‘defalias’で新たなプリミティブ関数を作成することはできません
が、任意の関数定義を変更するのに使用することができ、通常の定義がプリミテ
ィブである‘car’や‘x-popup-menu’のような関数でさえ変更することができます
。しかし、これは危険なことです。たとえば、Lispの完全性を損なうことなく、
‘car’を再定義するのはほとんど不可能だからです。それほど有名ではない
‘x-popup-menu’のような関数の再定義では、危険は減るものの、それでも期待し
たとおりに機能しないかもしれません。Cコードにこのプリミティブの呼び出し
がある場合、それは直接そのプリミティブのC定義を呼び出すので、シンボル定
義を変更しても、それらに影響はありません。

   ‘defsubst’も参照してください。これは‘defun’のように関数を定義して、そ
れのインライン展開を処理するようLispコンパイラーに指示します。*note
Inline Functions::を参照してください。


File: elisp,  Node: Calling Functions,  Next: Mapping Functions,  Prev: Defining Functions,  Up: Functions

12.5 Calling Functions
======================

関数を定義しただけでは、半分しか終わっていません。関数はそれを“呼び出す
(call)” — たとえば実行(run)するまでは、何も行いません。関数のcallは、
“invocation”としても知られています。

   関数を呼び出すもっとも一般的な方法は、リストの評価による方法です。た
とえば、リスト‘(concat "a" "b")’を評価することにより、関数‘concat’が引数
‘"a"’と‘"b"’で呼び出されます。評価については、*note Evaluation::を参照し
てください。

   プログラム内で式としてリストを記述するときは、プログラム内にテキスト
で、どの関数を呼び出すか、いくつの引数を与えるかを指定します。通常は、こ
れが行いたいことです。どの関数を呼び出すかを、実行時に計算する必要がある
場合もあります。これを行うには、関数‘funcall’を使用します。実行時にいく
つの引数を渡すか決定する必要があるときは、‘apply’を使用します。

 -- Function: funcall function &rest arguments
     ‘funcall’は、関数FUNCTIONを引数ARGUMENTSで呼び出し、FUNCTIONが
     returnした値をreturnします。

     ‘funcall’は関数なので、FUNCTIONを含むすべての引数は、‘funcall’の呼
     び出し前に評価されます。これは、呼び出される関数を得るための任意の
     式を使用できることを意味します。これはまた、‘funcall’がARGUMENTSに
     記述した式ではなく、その値だけを見ることを意味します。これらの値は
     FUNCTION呼び出し中では、2回目は評価_されません_。‘funcall’の処理は
     、関数の通常の呼び出し手続きと似ており、すでに評価された引数は評価
     されません。

     引数FUNCTIONは、Lisp関数、またはプリミティブ関数でなければなりませ
     ん。つまりスペシャルフォームやマクロは、“評価されていない”引数式を
     与えられたときだけ意味があるので、指定することはできません。上述し
     たように、‘funcall’は最初に指定された評価前の引数を提供することはで
     きません。

          (setq f 'list)
               ⇒ list
          (funcall f 'x 'y 'z)
               ⇒ (x y z)
          (funcall f 'x 'y '(z))
               ⇒ (x y (z))
          (funcall 'and t nil)
          error→ Invalid function: #<subr and>

     これらの例を、‘apply’の例と比較してみてください。

 -- Function: apply function &rest arguments
     ‘apply’は、関数FUNCTIONを引数ARGUMENTSで呼び出します。これは
     ‘funcall’と同様ですが、1つ違いがあります。ARGUMENTSの最後はオブジェ
     クトのリストです。これは1つのリストではなく、個別の引数として
     FUNCTIONに渡されます。わたしたちはこれを、‘apply’がこのリストを“展
     開(spread)”(個々の要素が引数となるので)する、と言います。

     ‘apply’は、FUNCTIONを呼び出した結果をreturnします。‘funcall’と同様
     、FUNCTIONはLisp関数かプリミティブ関数でなければなりません。つまり
     スペシャルフォームやマクロは、‘apply’では意味をもちません。

          (setq f 'list)
               ⇒ list
          (apply f 'x 'y 'z)
          error→ Wrong type argument: listp, z
          (apply '+ 1 2 '(3 4))
               ⇒ 10
          (apply '+ '(1 2 3 4))
               ⇒ 10

          (apply 'append '((a b c) nil (x y z) nil))
               ⇒ (a b c x y z)

     ‘apply’を使用した興味深い例は、*note Definition of mapcar::を参照し
     てください。

   ある関数にたいして、その関数のある引数を特定の値に固定し、他の引数は
実際に呼びだされたときの値にできれば便利なことがあります。関数のいくつか
の引数を固定することは、その関数の“部分適用(partial application)”と呼ば
れます(1)。結果は、残りの引数をとる新たな関数で、すべての引数を合わせて
元の関数を呼び出します。

   Emacs Lispで部分適用を行う方法を示します:

 -- Function: apply-partially func &rest args
     この関数は、新たな関数をreturnします。この新しい関数は、呼びだされ
     たときにARGSと、呼び出し時に指定された追加の引数から成る引数リスト
     でFUNCを呼び出す関数です。FUNCにN個の引数を指定できる場合、
     ‘M < N’個の引数で‘apply-partially’を呼び出すと、‘N - M’個の新たな関
     数を生成します。

     以下は、‘apply-partially’と他のビルトイン関数‘+’,を使用して、(もし
     存在しないなら)ビルトイン関数‘1+’を定義する例です:

          (defalias '1+ (apply-partially '+ 1)
            "Increment argument by one.")
          (1+ 10)
               ⇒ 11

   引数として関数をとったり、データ構造(特にフック変数やプロパティーリス
ト)から関数を探す関数はLispでは一般的で、それらは‘funcall’や‘apply’を使
用してそれらの関数を呼び出します。引数として関数をとる関数は、“ファンク
ショナル(functional)”と呼ばれるときもあります。

   ファンクショナルを呼び出すとき、引数としてno-op関数(何も行わない関数
)を指定できると便利なときがあります。以下に２つの異なるno-op関数を示しま
す:

 -- Function: identity arg
     この関数はARGをreturnします。副作用はありません。

 -- Function: ignore &rest args
     この関数は任意の引数を無視して、‘nil’をreturnします。

   いくつかの関数はユーザーに可視な“コマンド”で、これらは(通常はキーシー
ケンスを介して)対話的に呼び出すことができます。そのようなコマンドは、
‘call-interactively’関数を使用することにより、対話的に呼びだされたときと
同様に呼び出すことができます。*note Interactive Call::を参照してください
。

   ---------- Footnotes ----------

   (1) これは“カリー化(currying)”と関連しますが、異なる機能です。カーリ
ングは、複数の引数をとる関数を、関数チェーンとして呼び出せるような、１つ
の引数を取る個々の関数に変換するような方法です。


File: elisp,  Node: Mapping Functions,  Next: Anonymous Functions,  Prev: Calling Functions,  Up: Functions

12.6 Mapping Functions
======================

“マップ関数(mapping function)”は与えられた関数(スペシャルフォームやマク
ロでは_ない_)を、リストや他のコレクションの各要素に適用します。Emacs
Lispにはそのような関数がいくつかあります。このセクションでは、リストにた
いしてマッピングを行う‘mapcar’、‘mapc’、‘mapconcat’を説明します。
obarray内のシンボルにたいしてマッピングを行う関数‘mapatoms’は、*note
Definition of mapatoms::を参照してください。ハッシュテーブル内の
key/value関係にたいしてマッピングを行う関数‘maphash’は、*note Definition
of maphash::を参照してください。

   これらのマップ関数は、文字テーブル(char-table)には適用されません。な
ぜなら文字テーブルは非常に広い範囲の疎な配列だからです。疎な配列であると
いう性質に適う方法で文字いテーブルにマッピングするには、関数
‘map-char-table’を使用します(*note Char-Tables::を参照してください)。

 -- Function: mapcar function sequence
     ‘mapcar’は、関数FUNCTIONをSEQUENCEの各要素にたいして順番に適用し、
     その結果をリストでreturnします。

     引数SEQUENCEには、文字テーブルを除く任意の種類のシーケンス — つまり
     リスト、ベクター、ブールベクター、文字列を指定できます。結果は常に
     リストになります。結果の長さは、SEQUENCEの長さと同じです。たとえば:

          (mapcar 'car '((a b) (c d) (e f)))
               ⇒ (a c e)
          (mapcar '1+ [1 2 3])
               ⇒ (2 3 4)
          (mapcar 'string "abc")
               ⇒ ("a" "b" "c")

          ;; ‘my-hooks’内の各関数を呼び出す。
          (mapcar 'funcall my-hooks)

          (defun mapcar* (function &rest args)
            "Apply FUNCTION to successive cars of all ARGS.
          Return the list of results."
            ;; リストが消費されていなければ、
            (if (not (memq nil args))
                ;; CARに関数を適用する。
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; 残りの要素のための再帰。
                             (mapcar 'cdr args)))))

          (mapcar* 'cons '(a b c) '(1 2 3 4))
               ⇒ ((a . 1) (b . 2) (c . 3))

 -- Function: mapc function sequence
     ‘mapc’は‘mapcar’と似ていますが、FUNCTIONは副作用のためだけに使用さ
     れます — つまりFUNCTIONがreturnする値は無視され、リストに収集されま
     せん。‘mapc’は常にSEQUENCEをreturnします。

 -- Function: mapconcat function sequence separator
     ‘mapconcat’は関数FUNCTIONをSEQUENCEの各要素に適用します。結果は結合
     された文字列になります。結果文字列の間に、‘mapconcat’は文字列
     SEPARATORを挿入します。SEPARATORには通常、スペースやカンマ、あるい
     はその他の適切な区切り文字が含まれます。

     引数FUNCTIONはははは、1つの引数を取り文字列をreturnする関数でなけれ
     ばなりません。引数SEQUENCEには、文字テーブルを除く、任意の種類のシ
     ーケンス — つまりリスト、ベクター、ブールベクター、文字列を指定でき
     ます。

          (mapconcat 'symbol-name
                     '(The cat in the hat)
                     " ")
               ⇒ "The cat in the hat"

          (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                     "HAL-8000"
                     "")
               ⇒ "IBM.9111"


File: elisp,  Node: Anonymous Functions,  Next: Function Cells,  Prev: Mapping Functions,  Up: Functions

12.7 Anonymous Functions
========================

関数は通常、‘defun’により定義され、同時に名前が与えられますが、明示的に
ラムダ式を使う — “無名関数(anonymous function)”のほうが便利なときもあり
ます。無名関数は、名前つき関数が有効な場所なら、どこでも有効です。無名関
数は変数や関数の引数に割り当てられることがよくあります。たとえば、ある関
数をリストの各要素に適用する‘mapcar’のFUNCTION引数に渡すかもしれません
(*note Mapping Functions::を参照してください)。現実的な例は、*note
describe-symbols example::を参照してください。

   無名関数として使用するためのラムダ式を定義するとき、原則的にはリスト
を構築する任意の手法を使用できます。しかし通常は、マクロ‘lambda’、スペシ
ャルフォーム‘function’、または入力構文‘#'’を使用するべきです。

 -- Macro: lambda args [doc] [interactive] body...
     このマクロは引数リストARGS、(もしあれば)ドキュメント文字列DOC、(も
     しあれば)インタラクティブ指定INTERACTIVE、およびBODYで与えられる
     bodyフォームをもつ無名関数をreturnします。

     実際にはこのマクロは‘lambda’フォームを“自己クォート
     (self-quoting)”します。つまりCARが‘lambda’であるようなフォームは、
     そのフォーム自身を得ます。

          (lambda (x) (* x x))
               ⇒ (lambda (x) (* x x))

     ‘lambda’フォームは別に、1つの効果をもちます。このマクロは、
     ‘function’(以下参照)をサブルーチンとして使用することにより、Emacs評
     価機能(Emacs evaluator)とバイトコンパイラーに、その引数が関数である
     ことを告げます。

 -- Special Form: function function-object
     このスペシャルフォームは、評価を行わずに、FUNCTION-OBJECTをreturnし
     ます。この点では、‘quote’(*note Quoting::を参照してください)と似て
     います。しかし‘quote’とは異なり、Emacs評価機能とバイトコンパイラー
     に、これを関数として使用する意図を告げる役割をもちます。
     FUNCTION-OBJECTが有効なラムダ式と仮定すると、これは２つの効果をもち
     ます:

        • そのコードがバイトコンパイルされているとき、FUNCTION-OBJECTは
          バイトコード関数オブジェクトにコンパイルされます(*note Byte
          Compilation::を参照してください)。

        • レキシカルバインドが有効な場合、FUNCTION-OBJECTはクロージャー
          に変換されます。*note Closures::を参照してください。

   入力構文‘#'’は、‘function’の使用の略記です。以下のフォームは等価です:

     (lambda (x) (* x x))
     (function (lambda (x) (* x x)))
     #'(lambda (x) (* x x))

   以下の例では、3つ目の引数に関数をとる、‘change-property’関数を定義し
、その後の‘change-property’で、無名関数を渡してこれを使用しています:

     (defun change-property (symbol prop function)
       (let ((value (get symbol prop)))
         (put symbol prop (funcall function value))))

     (defun double-property (symbol prop)
       (change-property symbol prop (lambda (x) (* 2 x))))

‘lambda’フォームをクォートしていないことに注意してください。

   上記のコードをコンパイルした場合は、無名関数もコンパイルされます。リ
ストをクォートすることにより無名関数を構築した場合、コンパイルはされませ
ん。

     (defun double-property (symbol prop)
       (change-property symbol prop '(lambda (x) (* 2 x))))

この場合、無名関数はコンパイルされたコード内のラムダ式に保持されます。バ
イトコンパイラーは、‘change-property’が関数としての使用を意図しているこ
とを知ることができないので、たとえこの関数が関数のように見えるとしても、
このリストが関数であると決め込むことはできません。


File: elisp,  Node: Function Cells,  Next: Closures,  Prev: Anonymous Functions,  Up: Functions

12.8 Accessing Function Cell Contents
=====================================

あるシンボルの“関数定義(function definition)”とは、そのシンボルの関数セ
ルに格納されたオブジェクトのことです。ここでは、シンボルの関数セルにアク
セス、テスト、セットする関数を説明します。

   *note Definition of indirect-function::の、関数‘indirect-function’も
参照してください。

 -- Function: symbol-function symbol
     これはSYMBOLの関数セル内のオブジェクトをreturnします。これは、
     returnされたオブジェクトが本物のの関数であるかチェックしません。

     関数セルがvoidの場合、return値は‘nil’です。関数セルがvoidのときと、
     ‘nil’がセットされているときを区別するには、‘fboundp’(以下参照)を使
     用します。

          (defun bar (n) (+ n 2))
          (symbol-function 'bar)
               ⇒ (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               ⇒ bar
          (symbol-function 'baz)
               ⇒ bar

   シンボルに何の関数定義も与えていない場合、そのシンボルの関数セルは
“void”だと言います。別の言い方をすると、その関数セルは、どんなLispオブジ
ェクトも保持しません。そのシンボルを関数として呼びだそうとすると、
Emacsは‘void-function’エラーをシグナルします。

   voidは、‘nil’やシンボル‘void’とは異なることに注意してください。シンボ
ル‘nil’および‘void’はLispオブジェクトであり、他のオブジェクトと同様、関
数セルに格納することができます(これらのシンボルは‘defun’を使用して有効な
関数に成ることができます)。voidである関数セルは、どのようなオブジェクト
も含みません。

   ‘fboundp’を使用して、任意のシンボルの関数定義がvoidかどうかテストする
ことができます。シンボルに関数定義を与えた後は、‘fmakunbound’をつかえば
、再びvoidにすることができます。

 -- Function: fboundp symbol
     この関数は、そのシンボルが関数セルにオブジェクトをもっていれば‘t’、
     それ以外は‘nil’をreturnします。これは、そのオブジェクトが本物の関数
     であるかチェックしません。

 -- Function: fmakunbound symbol
     この関数はSYMBOLの関数セルをvoidにします。そのため、これ以降に関数
     セルにアクセスしようと試みると、‘void-function’エラーが発生します。
     これはSYMBOLをreturnします(*note Void Variables::の‘makunbound’も参
     照してください)。

          (defun foo (x) x)
          (foo 1)
               ⇒1
          (fmakunbound 'foo)
               ⇒ foo
          (foo 1)
          error→ Symbol's function definition is void: foo

 -- Function: fset symbol definition
     この関数はSYMBOLの関数セルに、DEFINITIONを格納します。結果は
     DEFINITIONです。DEFINITIONは通常、関数または関数の名前であるべきで
     すが、これはチェックされません。引数SYMBOLは、通常のどおり評価され
     る引数です。

     この関数は主に、関数を定義したり変更して構成を行う、‘defun’や
     ‘advice-add’のようなものからサブルーチンとして使用されます。シンボ
     ルにたいして、たとえばキーボードマクロ(*note Keyboard Macros::を参
     照してください)のような、関数ではない関数定義与えるためにも使用する
     ことができます:

          ;; 名前つきのキーボードマクロを定義する。
          (fset 'kill-two-lines "\^u2\^k")
               ⇒ "\^u2\^k"

     関数にたいして別の名前を作成するために‘fset’を使いたい場合は、かわ
     りに‘defalias’の使用を考慮してください。*note Definition of
     defalias::を参照してください。


File: elisp,  Node: Closures,  Next: Advising Functions,  Prev: Function Cells,  Up: Functions

12.9 Closures
=============

*note Variable Scoping::で説明したように、Emacsはオプションで変数のレキ
シカルバインディングを有効にできます。レキシカルバインディングが有効な場
合、あなたが(たとえば‘defun’などで)作成した任意の名前つき関数、同様に
‘lambda’マクロ、‘function’スペシャルフォーム、‘#'’構文を使用して作成した
任意の無名関数(*note Anonymous Functions::を参照してください)は、自動的
に“クロージャー(closure)”に変換されます。

   クロージャーとは、その関数が定ぎされたどときに存在したレキシカル環境
の記録もあわせもつ関数です。クロージャーが呼び出されたとき、定義内のレキ
シカル変数の参照には、その保持されたレキシカル環境を使用されます。他のす
べての点では、クロージャーは通常の関数と同様に振る舞います。特に、クロー
ジャーは通常の関数と同じ方法で呼び出すことができます。

   クロージャー使用する例は、*note Lexical Binding::を参照してください。

   現在のところ、Emacs Lispのクロージャーオブジェクトは、1つ目の要素にシ
ンボル‘closure’をもつリストとして表現されます。そのリストは2つ目の要素と
してレキシカル環境を表し、残りの要素で引数リストとbodyフォームを表します
:

     ;; レキシカルバインディングが有効。
     (lambda (x) (* x x))
          ⇒ (closure (t) (x) (* x x))

しかし実際には、クロージャーの内部構造は、内部的な実装の詳細と判断される
残りのLisp界を“晒け出す”ものだと言えます。この理由により、クロージャーオ
ブジェクトの構造を直接調べたり変更することは推奨しません。


File: elisp,  Node: Advising Functions,  Next: Obsolete Functions,  Prev: Closures,  Up: Functions

12.10 Advising Emacs Lisp Functions
===================================

他のライブラリーの関数定義を変更する必要があるとき、または
‘FOO-function’oのようなフックやプロセスフィルター(process filter)、また
は関数を値としてもつ任意の変数またはオブジェクトを変更する必要があるとき
には、名前つきの関数には‘fset’か‘defun’、フック変数には‘setq’、プロセス
フィルターには‘set-process-filter’のように、適切なセッター関数(setter
function)を使用することができます。しかし、これらが以前の値を完全に破棄
してしまうのが好ましくない場合もあります。

   “アドバイス(advice)”機能により、“関数にアドバイス”することにより、既
存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手
法です。

   Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コア
となるセットは、変数やオブジェクトのフィールドに保持された関数値にたいす
るものです(対応するプリミティブは‘add-function’と‘remove-function’です
)。もう1つのセットは、名前つき関数の最上位のレイヤーとなるものです(主要
なプリミティブは‘advice-add’と‘advice-remove’です)。

   たとえば、プロセスPROCのプロセスフィルターの呼び出しをトレースするた
めには、以下を使用できます:

     (defun my-tracing-function (proc string)
       (message "Proc %S received %S" proc string))

     (add-function :before (process-filter PROC) #'my-tracing-function)

   これにより、そのプロセスの出力は、元のプロセスフィルターに渡される前
に、‘my-tracing-function’に渡されるようになります。
‘my-tracing-function’は元の関数と同じ引数を受け取ります。これを行った場
合、以下のようにしてトレースを行わない振る舞いにリバートすることができま
す。

     (remove-function (process-filter PROC) #'my-tracing-function)

   同様に、‘display-buffer’という名前つきの関数の実行をトレースしたい場
合は、以下を使用できます:

     (defun his-tracing-function (orig-fun &rest args)
       (message "display-buffer called with args %S" args)
       (let ((res (apply orig-fun args)))
         (message "display-buffer returned %S" res)
         res))

     (advice-add 'display-buffer :around #'his-tracing-function)

   ここで、‘his-tracing-function’は元の関数のかわりに呼び出され、元の関
数(加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び
出すことができます。出力を確認し終えたら、以下のようにしてトレースしない
振る舞いにリバートできます:

     (advice-remove 'display-buffer #'his-tracing-function)

   上記の例で使用されている引数‘:before’と‘:around’は、2つの関数が構成さ
れる方法を指定します(これを行うには多くの方法があるからです)。追加された
関数も、_アドバイス(advice)_と呼ばれます。

* Menu:

* Core Advising Primitives::  アドバイスを扱うプリミティブ。
* Advising Named Functions::  名前つき関数のアドバイス。
* Advice combinators::       アドバイスを構成する方法。
* Porting old advices::      古いdefadviceを使用したコードの改良。


File: elisp,  Node: Core Advising Primitives,  Next: Advising Named Functions,  Up: Advising Functions

12.10.1 Primitives to manipulate advices
----------------------------------------

 -- Macro: add-function where place function &optional props
     このマクロはPLACE(*note Generalized Variables::を参照してください
     )に格納された関数に、アドバイスFUNCTIONを追加する手軽な方法です。

     WHEREは、既存の関数のどこに — たとえば元の関数の前、または後に —
     FUNCTIONが構成されるかを決定します。2つの関数を構成するために利用可
     能な方法のリストは、*note Advice combinators::を参照してください。

     (通常は名前が‘-function’で終わる)変数を変更するときには、FUNCTIONが
     グローバルに使用されるか、あるいはカレントバッファーだけに使用され
     るか選ぶことができます。PLACEが単にシンボルの場合、FUNCTIONは
     PLACEのグローバル値に追加されます。PLACEが‘(local SYMBOL)’というフ
     ォームの場合、SYMBOLはその変数の名前をreturnする式なので、
     FUNCTIONはカレントバッファーだけに追加されます。最後に、レキシカル
     変数を変更したい場合には、‘(var VARIABLE)’を使用する必要があるでし
     ょう。

     ‘add-function’で追加されたすべての関数は、自動的にプロパティー
     PROPSの関連リストに加えることができます。現在のところ、特別な意味を
     もつのは2つのプロパティーだけです:

     ‘name’
          これはアドバイスの名前を与えます。この名前は、
          ‘remove-function’が取り除く関数を識別するのに使用できます。こ
          れは通常、FUNCTIONが無名関数のときに使用されます。

     ‘depth’
          これは複数のアドバイスが与えられたときに、どのようにアドバイス
          を順番づけるかを指定します。depthのデフォルト0です。depthが
          100のとき、このアドバイスは可能な限りの深さを保持すべきことを
          意味し、-100のときは最外のアドバイスに留めることを意味します。
          同じdepthで2つのアドバイスが指定された場合、もっとも最近に追加
          されたアドバイスが最外になります。

          ‘:before’アドバイスにたいしては、最外(outermost)になるというこ
          とは、このアドバイスが他のアドバイスの前、つまり1番目に実行さ
          れることを意味し、最内(innermost)とは元の関数が実行される直前
          、すなわちこのアドバイスと元の関数の間に実行されるアドバイスは
          存在しないことを意味します。同様に‘:after’アドバイスにたいして
          は、最内とは元の関数の直後、つまりこの元の関数とアドバイスの間
          に実行される他のアドバイスは存在せず、最外とは他のすべてのアド
          バイスが実行された後にこのアドバイスが実行されることを意味しま
          す。‘:override’の最内アドバイスは、元の関数だけをオーバーライ
          ドし、他のアドバイスは適用されませんが、‘:override’の最外アド
          バイスは元の関数だけではなく。その他すべての適用済みのアドバイ
          スををオーバーライドします。

     FUNCTIONがインタラクティブでない場合、欠オグされた関数は、(もしあれ
     ば)元の関数のインタラクティブ指定(interactive spec)を継承します。そ
     れ以外は、結合された関数はインタラクティブになり、FUNCTIONのインタ
     ラクティブ指定を使用します。1つ例外があります。FUNCTIONのインタラク
     ティブ指定が、(式や文字列ではない)関数の場合、元の関数のインタラク
     ティブ指定を唯一の引数として、その関数を呼び出して、それが結合され
     た関数のインタラクティブ指定になります。引数として受け取ったインタ
     ラクティブ指定を解釈するためには、‘advice-eval-interactive-spec’を
     使用します。

     注意: FUNCTIONのインタラクティブ指定は結合された関数に適用され、
     FUNCTIONではなく、結合された関数の呼び出し規約に従うべきです。多く
     の場合、これらは等しいので差異は生じませんが、FUNCTIONの‘:around’、
     ‘:filter-args’、‘filter-return’では、重要になります。

 -- Macro: remove-function place function
     このマクロはPLACEに格納された関数から、FUNCTIONを取り除きます。これ
     は、‘add-function’を使用して、FUNCTIONがPLACEに追加されたときだけ機
     能します。

     FUNCTIONは、PLACEに追加された関数にたいして、ラムダ式にたいしても機
     能するように、‘equal’を使用して比較を試みます。これは追加でPLACEに
     追加された関数の‘name’プロパティーも比較します。これは‘equal’を使用
     してラムダ式を比較するより信頼性があります。

 -- Function: advice-function-member-p advice function-def
     ADVICEがすでにFUNCTION-DEF内にある場合は、非‘nil’をreturnします。上
     記の‘remove-function’と同様、実際の関数ADVICEのかわりに、アドバイス
     断片(piece of advice)の‘name’も使用できます。

 -- Function: advice-function-mapc f function-def
     FUNCTION-DEFに追加されたすべてのアドバイスに対して、関数Fを呼び出し
     ます。Fは2つの引数 — アドバイス関数と、それのプロパティーで呼びださ
     れます。

 -- Function: advice-eval-interactive-spec spec
     そのような指定で関数がインタラクティブに呼び出されたように、インタ
     ラクティブ指定SPECを評価して、構築された引数のリストに対応するリス
     トをreturnします。たとえば、‘(advice-eval-interactive-spec
     "r\nP")’は、リージョンの境界、カレントプレフィクス引数を含む、3つの
     要素からなるリストをreturnします。


File: elisp,  Node: Advising Named Functions,  Next: Advice combinators,  Prev: Core Advising Primitives,  Up: Advising Functions

12.10.2 Advising Named Functions
--------------------------------

アドバイスの一般的な使い方は、名前つき関数やマクロにたいして使用する方法
です。これは単に‘add-function’を使用して以下のように行うことができます:

     (add-function :around (symbol-function 'FUN) #'his-tracing-function)

   しかし、かわりに‘advice-add’と‘advice-remove’を使うべきです。この別の
関数セットは名前つき関数に適用されるアドバイス断片を操作するためのもので
、‘add-function’と比較して以下の追加機能があります。まず、これらはマクロ
およびオートロードされた関数を扱う方法を知っています。次に、
‘describe-function’にたいして、追加されたアドバイスと同様に、元のドキュ
メント文字列を維持します。さらに、関数が定義される前でも、アドバイスの追
加と削除ができます。

   既存の関数を関数全体を再定義せずに、既存の呼び出しを変更するために、
‘advice-add’は有用になります。しかし、その関数の既存の呼び出し元は、古い
振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更さ
れたときに正しく機能しないかもしれないので、これはソースのバグにもなり得
ます。アドバイスはデバッグを難しくする可能性もあります。デバッグを行う人
は、その関数がアドバイスにより変更されたことに気づかなかったり、失念して
いるかもしれません。

   これらの理由により、他の方法で関数の振る舞いを変更できない場合のため
に、アドバイスの使用は控えるべきです。フックを通じて同じことが行えるなら
、フック(*note Hooks::を参照してください)の使用が望ましい方法です。特定
のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマ
ンドのキーバインドを新しいコマンドにリマップ(*note Remapping Commands::を
参照してください)するのが、おそらくより良い方法です。特に、Emacs自身のソ
ースファイルは、Emacs内の関数をアドバイスするべきではありません(現在のと
ころこの慣習には数少ない例外がありますが、わたしたちはこれを改善しようと
思っています)。

   スペシャルフォーム(*note Special Forms::を参照してください)はアドバイ
スできませんが、マクロは関数と同じ方法でアドバイスできます。もちろん、こ
れはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバ
イスが確実にインストールされる必要があります。

   プリミティブ(*note What Is a Function::を参照してください)にアドバイ
スするのは可能ですが、2つの理由により通常は行うべきでは_ありません_。1つ
目の理由は、いくつかのプリミティブはアドバイスのメカニズム内で使用されて
いるため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。
2つ目の理由は、多くのプリミティブがCから直接呼び出されていて、そのような
呼び出しはアドバイスを無視するからです。したがって、プリミティブにたいし
てアドバイスの使用を控えることは、ある呼び出しはアドバイスにしたがい
(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわな
い(Cコードから呼び出されたため)という混乱した状況を解決します。

 -- Function: advice-add symbol where function &optional props
     名前つき関数SYMBOLに、アドバイスFUNCTIONを追加します。WHEREと
     PROPSは、‘add-function’(*note Core Advising Primitives::を参照して
     ください)のときと同じ意味をもちます。

 -- Function: advice-remove symbol function
     名前つき関数SYMBOLからアドバイスFUNCTIONを取り除きます。FUNCTIONに
     アドバイスの‘name’を指定することもできます。

 -- Function: advice-member-p function symbol
     名前つき関数SYMBOL内にすでにアドバイスFUNCTIONがある場合は、非
     ‘nil’をreturnします。FUNCTIONにアドバイスの‘name’を指定することもで
     きます。

 -- Function: advice-mapc function symbol
     名前つき関数SYMBOLにすでに追加されたすべての関数にたいして、
     FUNCTIONを呼び出します。FUNCTIONは2つの引数、アドバイス関数と、その
     プロパティーで呼び出されます。


File: elisp,  Node: Advice combinators,  Next: Porting old advices,  Prev: Advising Named Functions,  Up: Advising Functions

12.10.3 Ways to compose advices
-------------------------------

以下は‘add-function’および‘advice-add’のWHERE引数に可能な値で、そのアド
バイスFUNCTIONと元の関数が構成されるべき方法を指定します。

‘:before’
     古い関数の前にFUNCTIONを呼び出します。関数は両方とも同じ引数を受け
     取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確
     に言うと、2つの関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
     ‘(add-function :before FUNVAR FUNCTION)’は、ノーマルフックにたいす
     る‘(add-hook 'HOOKVAR FUNCTION)’のような、1関数のフックと同等です。

‘:after’
     古い関数の後にFUNCTIONを呼び出します。関数は両方とも同じ引数を受け
     取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確
     に言うと、2つの関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after FUNVAR FUNCTION)’は、ノーマルフックにたいする
     ‘(add-hook 'HOOKVAR FUNCTION 'append)’のような、1関数のフックと同等
     です。

‘:override’
     これは古い関数を新しい関数に完全に置き換えます。もちろん、
     ‘remove-function’を呼び出した後に、古い関数は復元されます。

‘:around’
     古い関数のかわりにFUNCTIONを呼び出しますが、古い関数はFUNCTIONの追
     加の引数になります。これはもっとも柔軟な結合です。たとえば、古い関
     数を異なる引数で呼び出したり、複数回呼び出したり、letバインディング
     で呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完
     全にオーバーライドすることが可能になります。より正確に言うと、2つの
     関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (apply FUNCTION OLDFUN r))

‘:before-while’
     古い関数の前にFUNCTIONを呼び出し、FUNCTIONが‘nil’をreturnした場合は
     古い関数を呼び出しません。関数は両方とも同じ引数を受け取り、2つの関
     数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つ
     の関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-while FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-failure’を通じてHOOKVARが実行されたときの
     ‘(add-hook 'HOOKVAR FUNCTION)’のような、1関数のフックと同等です。

‘:before-until’
     古い関数の前にFUNCTIONを呼び出し、FUNCTIONが‘nil’をreturnした場合だ
     け古い関数を呼び出します。より正確に言うと、2つの関数の結合は、以下
     のように振る舞います:
          (lambda (&rest r) (or (apply FUNCTION r) (apply OLDFUN r)))
     ‘(add-function :before-until FUNVAR FUNCTION)’ は、
     ‘run-hook-with-args-until-success’を通じてHOOKVARが実行されたときの
     ‘(add-hook 'HOOKVAR FUNCTION)’のような、1関数のフックと同等です。

‘:after-while’
     古い関数が非‘nil’をreturnした場合だけ、古い関数の後にFUNCTIONを呼び
     出します。関数は両方とも同じ引数を受け取り、2つの関数の結合の
     return値は、FUNCTIONのreturn値です。より正確に言うと、2つの関数の結
     合は、以下のように振る舞います:
          (lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-while FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-failure’を通じてHOOKVARが実行されたときの
     ‘(add-hook 'HOOKVAR FUNCTION 'append)’のような、1関数のフックと同等
     です。

‘:after-until’
     古い関数が‘nil’をreturnした場合だけ、古い関数の後にFUNCTIONを呼び出
     します。より正確に言うと、2つの関数の結合は、以下のように振る舞いま
     す:
          (lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
     ‘(add-function :after-until FUNVAR FUNCTION)’は、
     ‘run-hook-with-args-until-success’を通じてHOOKVARが実行されたときの
     ‘(add-hook 'HOOKVAR FUNCTION 'append)’のような、1関数のフックと同等
     です。

‘:filter-args’
     最初にFUNCTIONを呼び出し、その結果(リスト)を新たな引数として古い関
     数に渡します。より正確に言うと、2つの関数の結合は、以下のように振る
     舞います:
          (lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))

‘:filter-return’
     最初に古い関数を呼び出し、その結果をFUNCTIONに渡します。より正確に
     言うと、2つの関数の結合は、以下のように振る舞います:
          (lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))


File: elisp,  Node: Porting old advices,  Prev: Advice combinators,  Up: Advising Functions

12.10.4 Adapting code using the old defadvice
---------------------------------------------

多くのコードは古い‘defadvice’メカニズムを使用しており、これらの大半は
‘advice-add’により陳腐化しました。‘advice-add’の実装と意味は、とてもシン
プルです。

   古いアドバイスは以下のようなものです:

     (defadvice previous-line (before next-line-at-end
                                      (&optional arg try-vscroll))
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できま
す:

     (defun previous-line--next-line-at-end (&optional arg try-vscroll)
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   これが実際の‘previous-line’を変更しないことは明確です。古いアドバイス
には、以下が必要です:
     (ad-activate 'previous-line)
   一方、新しいアドバイスメカニズムでは、以下が必要です:
     (advice-add 'previous-line :before #'previous-line--next-line-at-end)

   ‘ad-activate’はグローバルな効果をもつことに注意してください。これは、
指定された関数にたいして、アドバイスのすべての断片を有効にします。特定の
アドバイスだけをアクティブ、または非アクティブにしたい場合、
‘ad-enable-advice’、または‘ad-disable-advice’により、_有効_または_無効
_にする必要があります。新しいメカニズムではこの区別はなくなりました。

   以下のようなaroundのアドバイスがあるとします:

     (defadvice foo (around foo-around)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         ad-do-it))
     (ad-activate 'foo)

   これは以下のように変換できます:

     (defun foo--foo-around (orig-fun &rest args)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         (apply orig-fun args)))
     (advice-add 'foo :around #'foo--foo-around)

   アドバイスの_クラス_について、新たな‘:before’は、古い‘before’は完全に
等価ではないことに注意してください。なぜなら古いアドバイス内では、(たと
えば‘ad-set-arg’を使って)その関数の引数を変更できそれは元の関数が参照す
る引数値に影響します。しかし新しい‘:before’は、‘setq’を通じてアドバイス
内の引数をし、その変更は元の関数からの参照に影響しません。この振る舞いに
もとづいて‘before’アドバイスを移行するときは、代わりにそれを新たなアドバ
イス‘:around’または‘:filter-args’に変更する必要があるでしょう。

   同様に、古い‘after’アドバイスは、‘ad-return-value’を変更することによ
りreturn値を変更できますが、新しい‘:after’は変更できないので、そのような
‘after’を移行するときは、かわりにそれらを新しいアドバイス‘:around’または
‘:filter-return’に変更する必要があるでしょう。


File: elisp,  Node: Obsolete Functions,  Next: Inline Functions,  Prev: Advising Functions,  Up: Functions

12.11 Declaring Functions Obsolete
==================================

名前つき関数を“陳腐化している(obsolete)”とマークすることができます。これ
は、その関数が将来のある時点で削除されるかもしれないことを意味します。陳
腐化しているとマークされた関数を含むコードをバイトコンパイルしたとき、Ｅ
ｍａｃｓは警告を発します。また、その関数のヘルプドキュメントは表示されな
くなります。他の点においては、陳腐化した関数は他の任意の関数と同様に振る
舞います。

   関数を陳腐化しているとマークするもっとも簡単な方法は、その関数の
‘defun’定義に‘(declare (obsolete ...))’を配置することです。*note Declare
Form::を参照してください。かわりに、以下で説明している‘make-obsolete’関
数を使うこともできます。

   ‘make-obsolete’を使用して、マクロ(*note Macros::を参照してください)を
陳腐化しているとマークすることもできます。これは関数のときと同じ効果をも
ちます。関数またはマクロにたいするエイリアスも、陳腐化しているとマークで
きます。これはエイリアス自身をマークし、名前解決される関数またはマクロに
たいしてではありません。

 -- Function: make-obsolete obsolete-name current-name &optional when
     この関数は、OBSOLETE-NAMEを陳腐化しているとマークします。
     OBSOLETE-NAMEには関数またはマクロを名前づけるシンボル、、または関数
     やマクロにたいするエイリアスを指定します。

     CURRENT-NAMEがシンボルの場合は、OBSOLETE-NAMEのかわりに
     CURRENT-NAMEの使用を促す警告メッセージになります。CURRENT-NAMEは、
     OBSOLETE-NAMEにたいするエイリアスである必要はありません。似たような
     機能をもつ、別の関数かもしれません。CURRENT-NAMEには、警告メッセー
     ジとなる文字列も指定できます。メッセージは小文字で始まりピリオドで
     終えるべきです。‘nil’も指定でき、この場合には警告メッセージに追加の
     詳細は提供されません。

     WHENが与えられた場合、それは最初にその関数が陳腐化する時期を示す文
     字列 — たとえば火付けやリリース番号を指定します。

 -- Macro: define-obsolete-function-alias obsolete-name current-name
          &optional when doc
     この便利なマクロは関数OBSOLETE-NAMEを陳腐化しているとマークするとと
     もに、それを関数CURRENT-NAMEのエイリアスにします。これは以下と等価
     です:

          (defalias OBSOLETE-NAME CURRENT-NAME DOC)
          (make-obsolete OBSOLETE-NAME CURRENT-NAME WHEN)

   加えて、陳腐化した関数にたいする特定の呼び出し規約をマークできます。

 -- Function: set-advertised-calling-convention function signature when
     この関数は、FUNCTIONを呼び出す正しい方法として、引数リスト
     SIGNATUREを指定します。これにより、Emacs Lispプログラムが他の方法で
     FUNCTIONを呼び出している場合には、Emacsのバイトコンパイラーが警告を
     発します(それでもコードはバイトコンパイルされます)。WHENには、その
     変数が最初に陳腐化するときを示す文字列(通常はバージョン番号)を指定
     します。

     たとえば、古いバージョンのEmacsでは、‘sit-for’には以下のように3つの
     引数を指定していました

            (sit-for seconds milliseconds nodisp)

     しかしこの方法による‘sit-for’の呼び出しは陳腐化していると判断されま
     す(*note Waiting::を参照してください)。以下のように、古い呼び出し規
     約は推奨されません:

          (set-advertised-calling-convention
            'sit-for '(seconds &optional nodisp) "22.1")


File: elisp,  Node: Inline Functions,  Next: Declare Form,  Prev: Obsolete Functions,  Up: Functions

12.12 Inline Functions
======================

“インライン関数(inline function)”は関数と同様に機能しますが、1つ例外があ
ります。その関数の呼び出しがバイトコンパイルされると(*note Byte
Compilation::を参照してください)、その関数の定義が呼び出し元に展開されま
す。インライン関数を定義するには、‘defun’のかわりに‘defsubst’を使用しま
す。

 -- Macro: defsubst name args [doc] [declare] [interactive] body...
     このマクロはインライン関数を定義します。マクロの構文は‘defun’とまっ
     たく同じです(*note Defining Functions::を参照してください)。

   関数をインラインにすることにより、その関数の呼び出しが高速になる場合
があります。しかし欠点もあります。1つは柔軟性の減少です。その関数の定義
を変更した場合、すでにインライン化された呼び出しは、リコンパイルを行うま
で古い定義を使用します。

   もう1つの欠点は、大きな関数をインライン化することにより、コンパイルさ
れたコードのファイル上およびメモリー上のサイズが増大することです。スピー
ド面でのインライン化の有利性は小さい関数にたいして顕著なので、一般的に大
きな関数をインライン化するべきではありません。

   インライン関数は、デバッグ、トレース、アドバイス(*note Advising
Functions::を参照してください)に際してうまく機能しません。デバッグの容易
さと関数の再定義の柔軟さはEmacsの重要な機能なので、スピードがとても重要
であり、‘defun’の使用が実際に性能の面で問題となるのか検証するためにすで
にコードをチューニングしたのでなければ、たとえその関数が小さくてもインラ
イン化するべきでは ありません。

   インライン関数が実行するのと同じコードに展開されるマクロ(*note
Macros::を参照してください)を定義することは可能です。しかし式内でのマク
ロの直接の使用には制限があります — ‘apply’、‘mapcar’などでマクロを呼び出
すことはできません。通常の関数からマクロへの変換には、そのための余分な作
業が必要になります。通常の関数をインライン関数に変換するのは簡単です。
‘defun’を‘defsubst’に置き換えるだけです。インライン関数の引数はそれぞれ
正確に1回評価されるので、マクロのときのように、bodyで引数を何回使用する
か心配する必要はありません。

   インライン関数を定義した後、そのインライン展開はマクロ同様、同じファ
イル内の後の部分で処理されます。


File: elisp,  Node: Declare Form,  Next: Declaring Functions,  Prev: Inline Functions,  Up: Functions

12.13 The ‘declare’ Form
========================

‘declare’(宣言)は特別なマクロで、関数やマクロに“メタ”プロパティーを追加
するために使用できます。たとえば陳腐化しているとマークしたり、Emacs
Lispモード内の特別な<TAB>インデント規則を与えることができます。

 -- Macro: declare specs...
     このマクロは引数を無視して、‘nil’として評価され、実行時の効果はあり
     ません。しかし‘defun’または‘defsubst’(*note Defining Functions::を
     参照してください)、または‘defmacro’マクロ(*note Defining Macros::を
     参照してください)の定義のDECLARE引数に‘declare’フォームがある場合は
     、SPECSで指定されたプロパティーを関数またはマクロに追加します。これ
     は‘defun’、‘defsubst’、‘defmacro’により特別に処理されます。

     SPECS内の各要素は‘(PROPERTY ARGS...)’というフォームをもつべきです。
     また、クォートするべきではありません。これらは、以下の効果をもちま
     す:

     ‘(advertised-calling-convention SIGNATURE WHEN)’
          これは‘set-advertised-calling-convention’(*note Obsolete
          Functions::を参照してください)の呼び出しと同じように振る舞いま
          す。SIGNATUREはその関数(またはマクロにたいする正しい引数リスト
          )で、WHENは古い引数リストが最初に陳腐化する時期を示す文字列を
          指定します。

     ‘(debug EDEBUG-FORM-SPEC)’
          これはマクロだけに有効です。Edebugでそのマクロ入ったときに、
          EDEBUG-FORM-SPECを使用します。*note Instrumenting Macro
          Calls::を参照してください。

     ‘(doc-string N)’
          それ自身が関数、マクロ、または変数のようなエンティティーを定義
          するために使用される関数やマクロを定義するときに使用されます。
          これはN番目の引数を示し、もしあれば、それはドキュメント文字列
          です。

     ‘(indent INDENT-SPEC)’
          この関数(またはマクロ)にたいするインデント呼び出しは、
          INDENT-SPECにしたがいます。これは関数でも機能しますが、通常は
          マクロで使用されます。*note Indenting Macros::を参照してくださ
          い。

     ‘(obsolete CURRENT-NAME WHEN)’
          ‘make-obsolete’(*note Obsolete Functions::を参照してください
          )と同様に、関数(またはマクロ)を陳腐化しているとマークします。
          CURRENT-NAMEにはシンボル(かわりにこのシンボルを使うことをすす
          める警告メッセージになります)、文字列(警告メッセージを指定しま
          す)、または‘nil’(警告メッセージには追加の詳細が含まれません)を
          指定します。WHENには、その関数(またはマクロ)が最初に陳腐化する
          時期を示す文字列を指定します。

     ‘(compiler-macro EXPANDER)’
          これは関数だけに使用でき、最適化関数(optimization function)と
          してEXPANDERを使用するようコンパイラーに告げます。‘(FUNCTION
          ARGS...)’のようなその関数への呼び出しフォームに出会うと、マク
          ロ展開機能(macro expander)はARGS...と同様のフォームで
          EXPANDERを呼び出します。EXPANDERはその関数呼び出しのかわりに使
          用するための新しい式、または変更されていないフォーム(その関数
          呼び出しを変更しないことを示す)のどちらかをreturnすることがで
          きます。EXPANDERにはシンボル、またはフォーム‘(lambda (ARG)
          BODY)’を指定できます。フォームの場合、ARGは元の関数呼び出し式
          を保持して、その関数の形式に適う引数を使用することにより、その
          関数にたいする(評価されていない)引数にアクセスできます。

     ‘(gv-expander EXPANDER)’
          EXPANDERが‘gv-define-expander’と同様、汎変数としてマクロ(また
          は関数)にたいする呼び出しを処理する関数であることを宣言します
          。EXPANDERはシンボル、またはフォーム‘(lambda (ARG) BODY)’を指
          定できます。フォームの場合、その関数は追加でそのマクロ(または
          関数)にアクセスできます。

     ‘(gv-setter SETTER)’
          SETTERが、汎変数としてマクロ(または関数)にたいする呼び出しを処
          理する関数であることを宣言します。SETTERはシンボル、またはフォ
          ームを指定できます。シンボルの場合、そのシンボルは
          ‘gv-define-simple-setter’に渡されます。フォームの場合は
          ‘(lambda (ARG) BODY)’という形式で、その関数は追加でマクロ(また
          は関数)にアクセスでき、‘gv-define-setter’に渡されます。


File: elisp,  Node: Declaring Functions,  Next: Function Safety,  Prev: Declare Form,  Up: Functions

12.14 Telling the Compiler that a Function is Defined
=====================================================

あるファイルをバイトコンパイルするとき、コンパイラーが知らない関数につい
て警告が生成されるときがあります(*note Compiler Errors::を参照してくださ
い)。実際に問題がある場合もありますが、問題となっている関数がそのコード
の実行時にロードされる他のファイルで定義されている場合が通常です。たとえ
ば以前は、‘fortran.el’をバイトコンパイルすると、以下のような警告が出てい
ました:

     In end of data:
     fortran.el:2152:1:Warning: the function `gud-find-c-expr' is not
         known to be defined.

   実際のところ、‘gud-find-c-expr’は、Fortranモードが使用する
‘gud-find-expr-function’のローカル値(GUDからのコールバック)の中だけで使
用されていて、呼びだされた場合はGUD関数がロードされます。そのような警告
が実際には問題を示さないことを知っているときには、警告を抑制したほうがよ
いでしょう。そうすれば、実際に問題があることを示す新しい警告の識別性が良
くなります。‘declare-function’を使用して、これを行うことができます。

   必要なのは、問題となっている関数を最初に使用する前に
‘declare-function’命令を追加するだけです:

     (declare-function gud-find-c-expr "gud.el" nil)

   これは‘gud-find-c-expr’が‘gud.el’(‘.el’は省略可)の中で定義しているこ
とを告げます。コンパイラーは関数がそのファイルで実際に定義されているとみ
なし、チェックを行いません。

   3つ目の引数はオプションで、‘gud-find-c-expr’の引数リストを指定します
。この例では、引数はありません(‘nil’と値を指定しないのは、異なります)。
それ以外の場合は、‘(file &optional overwrite)’のようになります。引数リス
トを指定する必要はありませんが、指定すればコンパイラーはその呼び出しが宣
言と合致するかチェックできます。

 -- Macro: declare-function function file &optional arglist fileonly
     バイトコンパイラーにたいして、引数ARGLISTをとるFUNCTIONが定義されて
     いて、その定義はFILEにあるとみなすように告げます。FILEONLYが非
     ‘nil’の場合は、FILEが存在することだけをチェックして、実際の
     FUNCTIONの定義はチェックしないことを意味します。

   これらの関数が‘declare-function’が告げる場所で実際に宣言されているか
検証するには、‘check-declare-file’を使用して、1つのソースファイル中のす
べての‘declare-function’呼び出しをチェックするか、
‘check-declare-directory’を使用して、特定のディレクトリー配下のすべての
ファイルをチェックします。

   これらのコマンドは、‘locate-library’で使用する関数の定義を含むべきフ
ァイルを探します。ファイルが見つからない場合、これらのコマンドは
‘declare-function’の呼び出しを含むファイルをがあるディレクトリーからの相
対ファイル名に、定義ファイル名を展開します。

   ‘.c’や‘.m’で終わるファイル名を指定することにより、プリミティブ関数を
指定することもできます。これが有用なのは、特定のシステムだけで定義される
プリミティブを呼び出す場合だけです。ほとんどのプリミティブは常に定義され
ているので、それらについて警告を受け取ることはありえないはずです。

   あるファイルがオプションとして外部のパッケージの関数を使う場合があり
ます。‘declare-function’命令内のファイル名のプレフィクスを‘ext:’にすると
、そのファイルが見つかった場合はチェックして、見つからない場合はエラーと
せずにスキップします。

   ‘check-declare’が理解しない関数定義もいくつか存在します(たとえば
‘defstruct’や、その他いくつかのマクロ)。そのような場合、
‘declare-function’のFILEONLY引数に、非‘nil’を渡すことができます。これは
ファイルの存在だけをチェックして、その関数の実際の定義はチェックしないこ
とを意味します。これを行う場合、引数リストを指定する必要はないのですが、
ARGLIST引数には‘t’をセットするべきだということに注意してください(なぜな
ら‘nil’は、引数リストが指定されなかったという意味ではなく、空の引数リス
トを意味するからです)。


File: elisp,  Node: Function Safety,  Next: Related Topics,  Prev: Declaring Functions,  Up: Functions

12.15 Determining whether a Function is Safe to Call
====================================================

SESのようないくつかのメジャーモードは、ユーザーファイル内に格納された関
数を呼び出します(*note (ses)Top::, for more information on SESを参照して
ください)。 ユーザーファイルには素性があやふやな場合があります — 初対面
の人から受け取ったスプレッドシートかもしれず、会ったことのない誰かから受
け取ったeメールかもしれません。そのため、ユーザーファイルに格納されたソ
ースコードの関数を呼び出すのは、それが安全だと決定されるすまでは危険です
。

 -- Function: unsafep form &optional unsafep-vars
     FORMが“安全(safe)”なLisp式の場合は‘nil’、危険な場合はなぜその式が危
     険かもしれないのか説明するリストをreturnします。引数UNSAFEP-VARSは
     、この時点で一時的なバインドだと判っているシンボルのリストです。こ
     れは主に内部的な再帰呼び出しで使用されます。カレントバッファーは暗
     黙の引数になり、これはバッファーローカルなバインディングのリストを
     提供します。

   高速かつシンプルにするために、‘unsafep’は、とても軽量な分析を行うので
、実際には安全な多くのLisp式を拒絶します。安全ではない式にたいして、
‘unsafep’が‘nil’をreturnするケースは確認されていません。しかし“安全”な
Lisp式は‘display’プロパティーと一緒に文字列をreturnでき、これはその文字
列がバッファーに挿入された後に実行される、割り当てられたLisp式を含みます
。割り当てられた式は、ウィルスかもしれません。安全であるためには、バッフ
ァーへ挿入する前に、ユーザーコードにより計算されたすべての文字列からプロ
パティーを削除しなければなりません。


File: elisp,  Node: Related Topics,  Prev: Function Safety,  Up: Functions

12.16 Other Topics Related to Functions
=======================================

以下のテーブルは、関数呼び出しと関数定義に関連したことを行ういくつかの関
数です。これらは別の場所で説明されているので、ここではクロスリファレンス
を提供します。

‘apply’
     *note Calling Functions::を参照してください。

‘autoload’
     *note Autoload::を参照してください。

‘call-interactively’
     *note Interactive Call::を参照してください。

‘called-interactively-p’
     *note Distinguish Interactive::を参照してください。

‘commandp’
     *note Interactive Call::を参照してください。

‘documentation’
     *note Accessing Documentation::を参照してください。

‘eval’
     *note Eval::を参照してください。

‘funcall’
     *note Calling Functions::を参照してください。

‘function’
     *note Anonymous Functions::を参照してください。

‘ignore’
     *note Calling Functions::を参照してください。

‘indirect-function’
     *note Function Indirection::を参照してください。

‘interactive’
     *note Using Interactive::を参照してください。

‘interactive-p’
     *note Distinguish Interactive::を参照してください。

‘mapatoms’
     *note Creating Symbols::を参照してください。

‘mapcar’
     *note Mapping Functions::を参照してください。

‘map-char-table’
     *note Char-Tables::を参照してください。

‘mapconcat’
     *note Mapping Functions::を参照してください。

‘undefined’
     *note Functions for Key Lookup::を参照してください。


File: elisp,  Node: Macros,  Next: Customization,  Prev: Functions,  Up: Top

13 Macros
*********

“マクロ(macros)”は、新たな制御構造や、他の言語機能の定義を可能にします。
マクロは関数のように定義されますが、値の計算方法を指定するかわりに、値を
計算する別のLisp式を計算する方法を指示します。わたしたちはこの式のことを
マクロの“展開形(expansion)”と呼んでいます。

   マクロは、関数が行うように引数の値を処理するのではなく、引数のために
未評価の式を処理することにより、これを行うことができます。したがってマク
ロは、これらの引数式またはその一部をを含む式を構築することができます。

   マクロを使用して通常の関数が行えることを行う場合、単にそれが速度面の
理由ならば、かわりにインライン関数の使用を考慮してください。*note Inline
Functions::を参照してください。

* Menu:

* Simple Macro::             基本的な例。
* Expansion::                いつ、なぜ、どのようにしてマクロが展開されるか。
* Compiling Macros::         コンパイラーによりマクロが展開される方法。
* Defining Macros::          マクロ定義を記述する方法。
* Problems with Macros::     マクロ引数を何回も評価しないこと。ユーザーの変数を隠さないこと。
* Indenting Macros::         マクロ呼び出しのインデント方法の指定。


File: elisp,  Node: Simple Macro,  Next: Expansion,  Up: Macros

13.1 A Simple Example of a Macro
================================

Cの‘++’演算子のように、変数の値をインクリメントするためのLisp構造を定義
したいとします。‘(inc x)’のように記述すると、‘(setq x (1+ x))’という効果
を得たいとします。以下はこれを行うマクロ定義です:

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

   これを‘(inc x)’のように呼び出すと、引数VARはシンボル‘x’になります — 関
数のときのように‘x’の_値_では_ありません_。このマクロのbodyはこれを展開
の構築に使用して、展開形は‘(setq x (1+ x))’になります。マクロが1度この展
開形をreturnすると。Lispはそれを評価するので、‘x’はインクリメントされま
す。

 -- Function: macrop object
     この術後は、その引数がマクロかどうかテストして、もしマクロなら‘t’、
     それ以外は‘nil’をreturnします。


File: elisp,  Node: Expansion,  Next: Compiling Macros,  Prev: Simple Macro,  Up: Macros

13.2 Expansion of a Macro Call
==============================

マクロ呼び出しは、関数の呼び出しと同じ外観をもち、マクロの名前で始まるリ
ストで表されます。そのリストの残りの要素は、マクロの引数になります。

   マクロ呼び出しの評価は、1つの重大な違いを除き、関数の評価と同じように
開始されます。重要な違いとは、そのマクロの引数はマクロ呼び出し内で実際の
式として現れます。これらの引数はマクロ定義に与えられる前には評価されませ
ん。対象的に、関数の引数は、その関数の呼び出しリストの要素を評価した結果
です。

   こうして得た引数を使用して、Lispは関数呼び出しのように、マクロ定義を
呼び出します。マクロの引数変数はマクロ呼び出しの引数値にバインドされるか
、a ‘&rest’引数の場合は引数地のリストになります。そして、そのマクロの
bodyが実行されて、関数bodyが行うように、マクロbodyの値をreturnsします。

   マクロと関数の2つ目の重要な違いは、マクロのbodyからreturnされる値が、
代替となるLisp式であることで、これはマクロの“展開(expansion)”としても知
られます。Lispインタープリターは、マクロから展開形が戻されると、すぐにそ
の展開形の評価を行います。

   展開形は通常の方法で評価されるので、もしかしたらその展開形は他のマク
ロの呼び出しを含むかもしれません。一般的ではありませんが、もしかすると同
じマクロを呼び出すかもしれません。

   EmacsはコンパイルされていないLispファイルをロードするときに、マクロの
展開を試みることに注意してください。これは常に利用可能ではありませんが、
もし可能なら、それ以降の実行の速度を改善します。*note How Programs Do
Loading::を参照してください。

   ‘macroexpand’を呼び出すことにより、与えられたマクロ呼び出しにたいする
展開形を確認することができます。

 -- Function: macroexpand form &optional environment
     この関数は、それがマクロ呼び出しの場合は、FORMを展開します。結果が
     他のマクロ呼び出しの場合は、結果がマクロ呼び出しでなくなるまで、順
     番に展開を行います。これは‘macroexpand’からreturnされる値になります
     。FORMがマクロ呼び出しで開始されない場合、与えられたFORMをそのまま
     returnします。

     ‘macroexpand’は、(たとえいくつかのiマクロ定義がそれを行っているとし
     ても)FORMの部分式(subexpression)を調べないことに注意してください。
     たとえ部分式自身がマクロ呼び出しの場合でも、‘macroexpand’はそれらを
     展開しません。

     関数‘macroexpand’は、インライン関数の呼び出しを展開しません。なぜな
     らインライン関数の呼び出しは、通常の関数呼び出しと比較して理解が難
     しい訳ではないので、通常はそれを行う必要がないからです。

     ENVIRONMENTが与えられた場合、それはそのとき定義されているマクロをシ
     ャドーするマクロのalistを指定します。バイトコンパイルはこの機能を使
     用します。

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))

          (macroexpand '(inc r))
               ⇒ (setq r (1+ r))

          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))

          (macroexpand '(inc2 r s))
               ⇒ (progn (inc r) (inc s))  ; ここでは‘inc’は展開されない。

 -- Function: macroexpand-all form &optional environment
     ‘macroexpand-all’は‘macroexpand’と同様、マクロを展開しますが、ドッ
     プレベルだけではなく、FORM内のすべてのマクロを探して展開します。展
     開されたマクロがない場合、return値は、FORMと‘eq’になります。

     上記‘macroexpand’で使用した例を‘macroexpand-all’に用いると、
     ‘macroexpand-all’が‘inc’に埋め込まれた呼び出しの展開を_行う_ことを
     確認できます:

          (macroexpand-all '(inc2 r s))
               ⇒ (progn (setq r (1+ r)) (setq s (1+ s)))


File: elisp,  Node: Compiling Macros,  Next: Defining Macros,  Prev: Expansion,  Up: Macros

13.3 Macros and Byte Compilation
================================

なぜわざわざマクロにたいする展開形を計算して、その後に展開形を評価する手
間をかけるのか、不思議に思うかもしれません。なぜマクロbodyは直接望ましい
結果を生成しないのでしょうか? それはコンパイルする必要があるからです。

   コンパイルされるLispプログラム内にマクロ呼び出しがあるとき、Lispコン
パイラーはインタープリターが行うようにマクロ定義を呼び出して、展開形を受
け取ります。しかし展開形を評価するかわりに、コンパイラーは展開形が直接プ
ログラム内にあるかのようにコンパイルを行います。結果として、コンパイルさ
れたコードはそのマクロにたいする値と副作用を生成しますが、実行速度は完全
にコンパイルされた行されたときと同じになります。もしマクロbody自身が値と
副作用を計算したら。このようには機能しません — コンパイル時に計算される
ことになり、それは有用ではありません。

   マクロ呼び出しのコンパイルが機能するためには、マクロを呼び出すコード
がコンパイルされるとき、そのマクロがLisp内ですでに定義されていなければな
りません。コンパイラーには、これを行うのを助ける特別な機能があります。コ
ンパイルされるファイルが‘defmacro’フォームを含む場合、そのファイルの残り
の部分をコンパイルするために、そのマクロが一時的に定義されます。

   ファイルをバイトコンパイルすると、ファイル内のトップレベルにある任意
の‘require’呼び出しも実行されるので、それらを定義しているファイルを
requireすることにより、コンパイルの間、必要なマクロ定義が利用できること
が確実になります(*note Named Features::を参照してください)。誰かがコンパ
イルされたプログラムを_実行_するときに、マクロ定義ファイルのロードをしな
いようにするには、‘require’呼び出しの周囲に‘eval-when-compile’を記述しま
す(*note Eval During Compile::を参照してください)。


File: elisp,  Node: Defining Macros,  Next: Problems with Macros,  Prev: Compiling Macros,  Up: Macros

13.4 Defining Macros
====================

Lispのマクロオブジェクトは、CARが‘macro’で、CDRが関数のリストです。マク
ロの展開形は、マクロ呼び出しから、_評価されていない_引数のリストに、
(‘apply’を使って)関数を適用することにより機能します。

   無名関数のように無名Lispマクロを使用することも可能ですが、無名マクロ
を‘mapcar’のようなファンクショナルに渡すことに意味がないので、これが行わ
れることはありません。実際のところ、すべてのLispマクロは名前をもち、ほと
んど常に‘defmacro’マクロで定義されます。

 -- Macro: defmacro name args [doc] [declare] body...
     ‘defmacro’はシンボルNAME(クォートはしない)を、以下のようなマクロ押
     して定義します:

          (macro lambda ARGS . BODY)

     (このリストのCDRはラムダ式であることに注意してください。) このマク
     ロオブジェクトは、NAMEの関数セルに格納されます。ARGSの意味は関数の
     場合と同じで、キーワード‘&rest’および‘&optional’が使用されることも
     あります(*note Argument List::を参照してください)。NAMEとARGSはどち
     らも、クォートされるべきではありません。‘defmacro’のreturn値は未定
     義です。

     DOCが与えられた場合、それはマクロのドキュメント文字列を指定する文字
     列です。DECLAREが与えられた場合、それはマクロのメタデータを指定する
     ‘declare’フォームです(*note Declare Form::を参照してください)。マク
     ロを対話的に呼び出すことはできないので、インタラクティブ宣言をもつ
     ことはできないことに注意してください。

   マクロが、定数部と非定数部の混合体から構築される巨大なリスト構造を必
要とする場合があります。これを簡単に行うためには、‘`’構文(*note
Backquote::を参照してください)を使用します。たとえば:

          (defmacro t-becomes-nil (variable)
            `(if (eq ,variable t)
                 (setq ,variable nil)))

          (t-becomes-nil foo)
               ≡ (if (eq foo t) (setq foo nil))

   マクロ定義のbodyには、そのマクロに関する追加のプロパティーを指定する
、‘declare’フォームを含めることができます。*note Declare Form::を参照し
てください。


File: elisp,  Node: Problems with Macros,  Next: Indenting Macros,  Prev: Defining Macros,  Up: Macros

13.5 Common Problems Using Macros
=================================

マクロ展開が、直感に反する結果となることがあり得ます。このセクションでは
、問題になりかねない重要な結果と、問題を避けるためにしたがうべきルールを
いくつか説明します。

* Menu:

* Wrong Time::               マクロ内ではなく展開形で作業を行う。
* Argument Evaluation::      展開形は各マクロ引数を1度評価するべきです。
* Surprising Local Vars::    展開形でのローカル変数バインディングには特別な注意が必要です。
* Eval During Expansion::    評価せずに展開形の中に配置してください。
* Repeated Expansion::       展開が行われる回数への依存を避ける。


File: elisp,  Node: Wrong Time,  Next: Argument Evaluation,  Up: Problems with Macros

13.5.1 Wrong Time
-----------------

マクロを記述する際のもっとも一般的な問題は、展開形の中ではなく、マクロ展
開中に、早まって実際に何らかの作業を行ってしまうことがあります。たとえば
、実際のパッケージが以下のマクロ定義をもつとします:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           (set-buffer-multibyte arg)))

   この誤ったマクロ定義は、解釈(interpret)されるときは正常に機能しますが
、コンパイル時に失敗します。このマクロ定義はコンパイル時に
‘set-buffer-multibyte’を呼び出してしまいますが、それは間違っています。そ
の後でコンパイルされたパッケージを実行しても何も行いません。プログラマー
が実際に望むのは、以下の定義です:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           `(set-buffer-multibyte ,arg)))

このマクロは、もし適切なら‘set-buffer-multibyte’の呼び出しに展開され、そ
れはコンパイルされたプログラム実行時に実行されるでしょう。


File: elisp,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros

13.5.2 Evaluating Macro Arguments Repeatedly
--------------------------------------------

マクロを定義する場合、展開形が実行されるときに引数が何回評価されるか注意
を払わなければなりません。以下の(繰り返し処理を用意にする)マクロで、この
問題を示してみましょう。このマクロで“for”によるループ構造を記述できます
。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (list 'let (list (list var init))
             (cons 'while
                   (cons (list '<= var final)
                         (append body (list (list 'inc var)))))))

     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ↦
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "\n%d %d" i square))
         (inc i)))

          ⊣1       1
          ⊣2       4
          ⊣3       9
     ⇒ nil

マクロ内の引数‘from’、‘to’、‘do’は、“構文糖(syntactic sugar)”であり、完
全に無視されます。このアイデアは、マクロ呼び出し中で(‘from’, ‘to’, and
‘do’のような)余計な単語を、これらの位置に記述できるようにするというもの
です。

   以下は、バッククォートの使用により、より単純化された等価の定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       `(let ((,var ,init))
          (while (<= ,var ,final)
            ,@body
            (inc ,var))))

   この定義のフォームは両方(バッククォートのあるものと、ないもの)とも、
各繰り返しにおいて毎回FINALが評価されるという欠点をもちます。FINALが定数
のときには、問題はありません。しかし、これがより複雑な、たとえば
‘(long-complex-calculation x)’のようなフォームの場合、実効速度は顕著に低
下し得ます。FINALが副作用をもつ場合には、複数回実行すると、おそらく正し
くなくなります。

   うまく設計されたマクロ定義は、繰り返し評価することがそのマクロの意図
された目的でない限り、引数を正確に1回評価を行う展開形を生成することによ
り、この問題を避けるためにステップを費やします。以下は‘for’マクロの正し
い展開形です:

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

   以下はこの展開形を生成するためのマクロ定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   残念なことに、この訂正により、以下のセクションで説明する、別の問題が
発生します。


File: elisp,  Node: Surprising Local Vars,  Next: Eval During Expansion,  Prev: Argument Evaluation,  Up: Problems with Macros

13.5.3 Local Variables in Macro Expansions
------------------------------------------

前のセクションでは、‘for’の定義を、展開形がマクロ引数を正しい回数評価す
るように訂正しました:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   ‘for’の新しい定義には、新たな問題があります。この定義は、ユーザーが意
識していない、‘max’という名前のローカル変数を導入しています。これは、以
下の例で示すようなトラブルを招きます:

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

‘for’のbodyの内部の‘max’への参照は、‘max’のユーサーバインディングの参照
を意図したものですが、実際には‘for’により作られたバインディングにアクセ
スします。

   これを修正する方法は、‘max’のかわりにinternされていない(uninterned)シ
ンボルを使用することです(*note Creating Symbols::を参照してください)。
internされていないシンボルは他のシンボルと同じようにバインドして参照する
ことができますが、‘for’により作成されるので、わたしたちはすでにユーザー
のプログラムに存在するはずがないことを知ることができます。これはinternさ
れていないので、プログラムの後続の部分でそれを配置する方法はありません。
これは‘for’により配置された場所をのぞき、他の場所で配置されることはあり
ません。以下はこの方法で機能する‘for’の定義です:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         `(let ((,var ,init)
                (,tempvar ,final))
            (while (<= ,var ,tempvar)
              ,@body
              (inc ,var)))))

作成されたinternされていないシンボルの名前は‘max’で、これを通常の
internされたシンボル‘max’のかわりに、式内のその位置に記述します。


File: elisp,  Node: Eval During Expansion,  Next: Repeated Expansion,  Prev: Surprising Local Vars,  Up: Problems with Macros

13.5.4 Evaluating Macro Arguments in Expansion
----------------------------------------------

マクロ定義自体が、‘eval’(*note Eval::を参照してください)の呼び出しなどに
よりマクロ引数式を評価した場合には、別の問題が発生します。その引数がユー
ザーの変数を参照する場合、ユーザーがマクロ引数と同じな前で変数をしようと
した場合に問題となるでしょう。マクロのbodyないでは、マクロ引数のバインデ
ィングは、その変数のもっともローカルなバインディングなので、そのフォーム
内部の任意の参照は、それを参照するように評価されます。以下は例です:

     (defmacro foo (a)
       (list 'setq (eval a) t))
     (setq x 'b)
     (foo x) ↦ (setq b t)
          ⇒ t                  ; ‘b’がセットされる。
     ;; but
     (setq a 'c)
     (foo a) ↦ (setq a t)
          ⇒ t                  ; しかし、これは‘c’ではなく‘a’がセットされる。


   ユーザーの変数の名前が‘a’か‘x’かということで、違いが生じています。こ
れは‘a’が、マクロの引数変数‘a’と競合しているからです。

   マクロ定義内での‘eval’の呼び出しにまつわる別の問題は、それがおそらく
コンパイル時にあなたが意図したことを行わないだろうということです。バイト
コンパイラーは、そのプログラム自身の(あなたが‘eval’でアクセスしたいと望
む)計算は発生せず、ローカル変数バインディングも存在しないプログラムのコ
ンパイル時にマクロ定義を実行します。

   この問題を避けるためには、*マクロ展開形の計算では引数式を評価しないで
ください*。かわりにその式をマクロ展開形の中に置き換えれば、その値は展開
形の実行の一部として計算されます。これは、このチャプターの他の例が機能す
る方法です。


File: elisp,  Node: Repeated Expansion,  Prev: Eval During Expansion,  Up: Problems with Macros

13.5.5 How Many Times is the Macro Expanded?
--------------------------------------------

マクロ呼び出しは逐次解釈される関数で毎回マクロ呼び出しが展開されるが、コ
ンパイルされた関数では(コンパイル時に)1回だけしか展開されないという事実
にもとづく問題が、時折発生します。そのマクロ定義が副作用をもつ場合、それ
らのマクロは、そのマクロが難解展開されたかにより、異なる動作をとるでしょ
う。

   したがって、あなたが何をしているか本当に判っていないのであれば、マク
ロ展開形の計算での副作用は避けるべきです。

   避けることのできない特殊な副作用が1つあります。それはLispオブジェクト
の構築です。ほとんどすべてのマクロ展開形には、リストの構築が含まれます。
リスト構築はほとんどのマクロの核心部分です。これは通常は安全です。用心し
なければならないケースが1つだけあります。それは構築するオブジェクトが、
マクロ展開形の中でクォートされた定数の一部となるときです。

   そのマクロが1回だけ — コンパイル時 — しか展開されない場合、そのオブジ
ェクトの構築もコンパイル時の1回です。しかし逐次実行では、そのマクロはマ
クロ呼び出しが実行されるたびに展開され、これは毎回新たなオブジェクトが構
築されることを意味します。

   クリーンなLispコードのほとんどでは、この違いは問題になりません。しか
し、マクロ定義によるオブジェクト構築の副作用を処理する場合には、問題にな
るかもしれません。したがって問題を避けるために、*マクロ定義によるオブジ
ェクト構築の副作用を避けてください*。以下は副作用により問題が起こる例で
す:

     (defmacro empty-object ()
       (list 'quote (cons nil nil)))

     (defun initialize (condition)
       (let ((object (empty-object)))
         (if condition
             (setcar object condition))
         object))

‘initialize’が解釈された場合、‘initialize’が呼び出されるたびに、新しいリ
スト‘(nil)’が構築されます。したがって、各呼び出しの間において、副作用は
存続しません。しかし‘initialize’がコンパイルされた場合、マクロ
‘empty-object’はコンパイル時に展開され、これは1つの“定数”‘(nil)’を生成し
、この定数は‘initialize’の毎回の呼び出しで、再利用・変更されます。

   このような異常な状態を避ける1つの方法は、‘empty-object’を、メモリー割
り当て構造ではなく、一種の奇妙な変数と考えることです。‘'(nil)’のような定
数にたいして‘setcar’を使うことはないでしょうから、当然‘(empty-object)’に
も使うことはないでしょう。


File: elisp,  Node: Indenting Macros,  Prev: Problems with Macros,  Up: Macros

13.6 Indenting Macros
=====================

マクロ定義では、マクロ呼び出しを<TAB>がどのようにインデントすべきか指定
するために、‘declare’フォーム(*note Defining Macros::を参照してください
)を使うことができます。インデント指定は以下のように記述します:

     (declare (indent INDENT-SPEC))

以下は利用できるINDENT-SPECです:

‘nil’
     これはプロパティーを指定しない場合と同じ — 標準的なインデントパター
     ンを使用します。
‘defun’
     この関数を‘def’構造 — 2番目の行が“body”の開始 — と同様に扱います。
整数: NUMBER
     関数の最初のNUMBER個の引数は“区別”され、残りは式のbodyと判断されま
     す。その式の中の行は、最初の引数が区別されているかどうかにしたがっ
     てインデントされます。引数がbodyの一部である場合、その行はこの式の
     先頭の 開きカッコ(open-parenthesis)よりも‘lisp-body-indent’だけ多い
     列にインデントされます。引数が 区別されていて、1つ目または2つ目の引
     数である場合は、_2倍_余分にインデントされます。引数が区別されていて
     1つ目あるいは2つ目の引数でない場合、その行は標準パターンによってイ
     ンデントされます。
シンボル: SYMBOL
     SYMBOLは関数名です。その関数はこの式のインデントを計算するために呼
     び出される関数です。この関数は2つの引数をとります:

     POS
          その行のインデントが開始される位置です。
     STATE
          その行の開始まで解析されたとき、‘parse-partial-sexp’(インデン
          トとネスト深さの計算のためのLispプリミティブ)によりreturnされ
          る値です。

     これは、数(その行のインデントの列数)、またはそのような数がcarである
     ようなリストをreturnすべきです。数とリストの違いは、数の場合、同じ
     ネスト深さの後続のすべての行はこの数と同じインデントとなります。リ
     ストの場合、後続の行は異なるインデントを呼び出すかもしれません。こ
     れは、‘C-M-q’によりインデントが計算されるときに違いがでます。値が数
     の場合、‘C-M-q’はリストの終わりまでの後続の行のインデントを、再計算
     する必要はありません。


File: elisp,  Node: Customization,  Next: Loading,  Prev: Macros,  Up: Top

14 Customization Settings
*************************

Emacsのユーザーは、カスタマイズインターフェースにより、Lispコードを記述
することなく。変数とフェースをカスタマイズできます。*note (emacs)Easy
Customization::を参照してください。このチャプターでは、カスタマイズイン
ターフェースを通じて、ユーザーとやりとりするための、“カスタマイズアイテ
ム（customization items）”を定義する方法を説明します。

   カスタマイズアイテムには、カスタマイズ可能変数(customizable variable:
‘defcustom’マクロで定義される。*note Variable Definitions::を参照してく
ださい)、 カスタマイズ可能フェース(customizable face: ‘defface’で定義さ
れる。*note Defining Faces::を参照してください)、および関連するカスタマ
イズアイテムのグループのためのコンテナーとして働くカスタマイズグループ
(customization group: ‘defgroup’で定義される。*note Group Definitions::を
参照してください) が含まれます。

* Menu:

* Common Keywords::          すべての種類のカスタマイズ宣言に共通なキーワード。
* Group Definitions::        カスタマイズグループ定義の記述。
* Variable Definitions::     ユーザーオプションの宣言。
* Customization Types::      ユーザーオプションの型指定。
* Applying Customizations::  カスタマイズセッティングを適用する関数。
* Custom Themes::            カスタムテーマの記述。


File: elisp,  Node: Common Keywords,  Next: Group Definitions,  Up: Customization

14.1 Common Item Keywords
=========================

以降のセクションで説明するカスタマイズ宣言(customization declaration) —
‘defcustom’、‘defgroup’などはすべて、さまざまな情報を指定するためのキー
ワード引数(*note Constant Variables::を参照してください)を受け取ります。
このセクションでは、カスタマイズ宣言のすべての種類に適用されるキーワード
を説明します。

   ‘:tag’以外のすべてのキーワードは、与えられたアイテムにたいして複数回
使用できます。キーワードの使用はそれぞれ独立した効果をもちます。‘:tag’は
例外で、これはすべての与えられたアイテムは1つの名前だけを表示できるから
です。

‘:tag LABEL’
     LABELを使用すると、カスタマイズメニュー(customization menu)およびカ
     スタマイズバッファー(customization buffer)のアイテムのラベルづけに
     、そのアイテムの名前のかわりに指定された文字列を使用します。*混乱を
     招くので、そのアイテムの実際の名前と、大きく異なる名前は使用しない
     でください*。

‘:group GROUP’
     このカスタマイズアイテムを、グループGROUPに配します。‘defgroup’内で
     ‘:group’を使用した場合、そのアイテムは新しいグループ(‘:group’のサブ
     グループ)になります。

     このキーワードを複数回使用した場合、1つのアイテムを複数のグループに
     配すことができます。これらのグループのどれかを表示すると、このアイ
     テムが表示されます。煩わしくなるので、多用しないでください。

‘:link LINK-DATA’
     このアイテムのドキュメント文字列の後に外部リンクを含めます。これは
     他のドキュメントを参照する、センテンスを含むボタンです。

     LINK-DATAに使用できる複数の候補があります:

     ‘(custom-manual INFO-NODE)’
          infoノードへのリンクです。INFO-NODEは、‘"(emacs)Top"’のような
          、ノード名を示す文字列です。このリンクはカスタマイズバッファー
          の‘[Manual]’に表示され、INFO-NODEにたいしてビルトインのinfoリ
          ーダーを起動します。

     ‘(info-link INFO-NODE)’
          ‘custom-manual’と同様ですが、カスタマイズバッファーには、その
          infoノード名が表示されます。

     ‘(url-link URL)’
          ウェブページヘのリンクです。URLはURLを指定する文字列です。カス
          タマイズバッファーに表示されるリンクは、
          ‘browse-url-browser-function’で指定されたWWWブラウザーを呼び出
          します。

     ‘(emacs-commentary-link LIBRARY)’
          ライブラリーのコメントセクション(commentary section)へのリンク
          です。LIBRARYはライブラリー名を指定する文字列です。*note
          Library Headers::を参照してください。

     ‘(emacs-library-link LIBRARY)’
          Emacs Lispライブラリーファイルへのリンクです。LIBRARYはライブ
          ラリー名を指定する文字列です。

     ‘(file-link FILE)’
          ファイルへのリンクです。FILEは、ユーザーがこのリンクを呼び出し
          たときに‘find-file’でvisitするファイルの名前を指定する文字列で
          す。

     ‘(function-link FUNCTION)’
          関数のドキュメントへのリンクです。FUNCTIONは、ユーザーがこのリ
          ンクを呼び出したときに‘describe-function’で説明を表示する関数
          の名前を指定する文字列です。

     ‘(variable-link VARIABLE)’
          変数のドキュメントへのリンクです。VARIABLEは、ユーザーがこのリ
          ンクを呼び出したときに‘describe-variable’で説明を表示する変数
          の名前を指定する文字列です。

     ‘(custom-group-link GROUP)’
          他のカスタマイズグループへのリンクです。このリンクを呼び出すこ
          とにより、GROUPにたいする新たなカスタマイズバッファーが作成さ
          れます。

     LINK-DATAの1つ目の要素の後に‘:tag NAME’を追加することにより、カスタ
     マイズバッファーで使用するテキストを指定できます。たとえば
     ‘(info-link :tag "foo" "(emacs)Top")’は、そのバッファーで‘foo’と表
     示されるEmacs manualへのリンクを作成します。

     複数のリンクを追加するために、このキーワードを複数回使用することが
     できます。

‘:load FILE’
     このカスタマイズアイテムを表示する前に、ファイルFILEをロードします
     (*note Loading::を参照してください)。ロードは‘load’により行われ、そ
     のファイルがまだロードされていないときだけロードします。

‘:require FEATURE’
     保存したカスタマイズが、このアイテム値をセットするとき、‘(require
     'FEATURE)’が実行されます。FEATUREはシンボルです。

     ‘:require’を使用するもっとも一般的な理由は、ある変数がマイナーモー
     ドのような機能を有効にするとき、そのモードを実装するコードがロード
     されていない場合には、変数をセットするだけでは効果がないからです。

‘:version VERSION’
     このキーワードは、そのアイテムが最初に導入されたEmacsバージョン
     VERSION、またはそのアイテムのデフォルト値がそのバージョンで変更され
     たことを指定します。値VERSIONは文字列でなければなりません。

‘:package-version '(PACKAGE . VERSION)’
     このキーワードは、そのアイテムが最初に導入されたPACKAGEのバージョン
     VERSIONまたはアイテムの意味(またはデフォルト値)が変更されたバージョ
     ンを指定します。このキーワードは‘:version’より優先されます。

     PACKAGEにはそのパッケージの公式名をシンボルとして指定します(たとえ
     ば‘MH-E’)。VERSIONには文字列を指定します。パッケージPACKAGEが
     Emacsの一部としてリリースされた場合、PACKAGEとVERSIONの値は、
     ‘customize-package-emacs-version-alist’の値に表示されるべきです。

   Emacsの一部として配布された‘:package-version’キーワードを使用するパッ
ケージは、‘customize-package-emacs-version-alist’変数も更新しなければな
りません。

 -- Variable: customize-package-emacs-version-alist
     このalistは、Emacsのバージョンにたいして、‘:package-version’キーワ
     ード内でリストされたパッケージのバージョンへのマッピングを提供しま
     す:

          (PACKAGE (PVERSION . EVERSION)...)

     PACKAGE(シンボル)それぞれにたいして、パッケージバージョンPVERSIONを
     含む1つ以上の要素と、それに関連づけられるEmacsバージョンEVERSIONが
     存在します。これらのバージョンは文字列です。たとえばMH-Eパッケージ
     は、以下でalistを更新します:

          (add-to-list 'customize-package-emacs-version-alist
                       '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                              ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                              ("7.4" . "22.1") ("8.0" . "22.1")))

     PACKAGEの値は一意である必要があり、また‘:package-version’キーワード
     内に現れるPACKAGEの値とマッチする必要があります。おそらくユーザーは
     エラーメッセージからこの値を見るので、MH-EやGnusのようなパッケージ
     の公式名を選択するのがよいでしょう。


File: elisp,  Node: Group Definitions,  Next: Variable Definitions,  Prev: Common Keywords,  Up: Customization

14.2 Defining Customization Groups
==================================

Emacs Lispパッケージはそれぞれ、1つのメインカスタマイズグループ(main
customization group)をもち、それにはすべてのオプション、フェイス、そのパ
ッケージ内の他のグルーﾌﾟが含まれるべきです。そのパッケージには少数のオプ
ションとフェイスしかない場合は、1つのグループだけを使用して、その中にす
べてを置きます。20以上のオプションやフェイスがある場合には、それらをサブ
グループ内に構造化して、そのサブグループをメインカスタマイズグループの下
に配します。そのパッケージ内の任意のオプションまたはフェイスを、サブグル
ープと並行してメイングループに配しても構いません。

   そのパッケージのメイングループ(または唯一のグループ)は、1つ以上の標準
カスタムグループ(standard customization group)のメンバーであるべきです
(これらの完全なリストを表示するには、‘M-x customize’を使用します)。それ
らの内から1つ以上(多すぎないこと)を選択して、‘:group’を使用してあなたの
グループをそれらに追加します。

   新しいカスタマイズグループは、‘defgroup’で宣言します。

 -- Macro: defgroup group members doc [keyword value]...
     MEMBERSを含む、カスタマイズグループとして、GROUPを宣言します。シン
     ボルGROUPはクォートしません。引数DOCは、そのグループにたいするドキ
     ュメント文字列を指定します。

     引数MEMBERSは、そのグループのメンバーとなるカスタマイズアイテムの初
     期セットを指定するリストです。しかしほとんどの場合はMEMBERSを
     ‘nil’にして、メンバーを定義するときに‘:group’キーワードを使用するこ
     とにより、そのグループのメンバーを指定します。

     MEMBERSを通じてグループのメンバーを指定したい場合、各要素は‘(NAME
     WIDGET)’という形式で指定するべきです。ここでNAMEはシンボル、
     WIDGETはそのシンボルを編集するウィジェット型(widget type)です。有用
     なウィジェットには、変数にたいする‘custom-variable’、フェイスにたい
     する‘custom-face’、グループにたいする‘custom-group’があります。

     Emacsに新しいグループを導入するときは、‘defgroup’内で‘:version’キー
     ワードを使用します。そうすればグループの個別のメンバーに対してそれ
     を使用する必要がなくなります。

     一般的なキーワード(*note Common Keywords::を参照してください)に加え
     て、‘defgroup’ないでは以下のキーワードも使用できます:

     ‘:prefix PREFIX’
          グループ内のアイテムの名前がPREFIXで始まり、カスタマイズ変数
          ‘custom-unlispify-remove-prefixes’が非‘nil’の場合、そのアイテ
          ムのタグからPREFIXが省略されます。グループは任意の数のプレフィ
          クスをもつことができます。

 -- User Option: custom-unlispify-remove-prefixes
     この変数が非‘nil’の場合、グループの‘:prefix’キーワードで指定された
     プレフィクスは、ユーザーがグループをカスタマイズするときは常に、タ
     グ名から省略されます。

     デフォルト値は‘nil’、つまりプレフィクス省略(prefix-discarding)の機
     能は無効です。これは、オプションやフェイスの名前にたいしてプレフィ
     クスを省略するのは、混乱を招くことがあるからです。


File: elisp,  Node: Variable Definitions,  Next: Customization Types,  Prev: Group Definitions,  Up: Customization

14.3 Defining Customization Variables
=====================================

“カスタマイズ可能変数(customizable variable)”は“ユーザーオプション(user
option)”とも呼ばれ、これはCustomizeインターフェースを通じてセットできる
グローなるなLisp変数です。‘defvar’(*note Defining Variables::を参照して
ください)により定義される他のグローバル変数とは異なり、カスタマイズ可能
変数は‘defcustom’マクロを使用して定義されます。サブルーチンとして
‘defvar’を呼び出すことに加え、‘defcustom’はCustomizeインターフェースでそ
の変数が表示される方法や、その変数がとることができる値などを明示します。

 -- Macro: defcustom option standard doc [keyword value]...
     このマクロはユーザーオプション(またはカスタマイズ可能変数)として
     OPTIONを宣言します。OPTIONはクォートするべきではありません。

     引数STANDARDは、OPTIONの標準値を指定する式です。‘defcustom’フォーム
     の評価により、STANDARDが評価されますが、その値にオプションをバイン
     ドする必要はありません。OPTIONがすでにデフォルト値をもつ場合、それ
     は変更されずに残ります。ユーザーがすでにOPTIONにたいするカスタマイ
     ズを保存している場合、ユーザーによりカスタマイズされた値がデフォル
     ト値としてインストールされます。それ以外は、STANDARDを評価した結果
     がデフォルト値としてインストールされます。

     ‘defvar’と同様、このマクロは‘option’をスペシャル変数 — 常にダイナミ
     ックにバインドされるべきことを意味する — としてマークします。
     OPTIONがすでにレキシカルバインドをもつ場合、そのレキシカルバインド
     はバインディング構造を抜けるまで効果をもちます。*note Variable
     Scoping::を参照してください。

     式STANDARDは別の様々な機会にも — カスタマイズ機能がOPTIONの標準値を
     知る必要があるときは常に — 評価される可能性があります。そのため任意
     回数評価しても安全な式を使用するように気をつけてください。

     引数DOCは、その変数にたいするドキュメント文字列を指定します。

     ‘defcustom’が何も‘:group’を指定しない場合、同じファイル内で
     ‘defgroup’により最後に定義されたグループが使用されます。この方法で
     は、ほとんどの‘defcustom’は明示的な‘:group’が必要なくなります。

     Emacs Lispモードで‘C-M-x’(‘eval-defun’)により‘defcustom’フォームを
     評価するとき、‘eval-defun’の特別な機能は、変数の値がvoidかどうかテ
     ストせず、無条件に変数をセットする段取りをします(同じ機能は
     ‘defvar’にも適用されます。*note Defining Variables::を参照してくだ
     さい)。すでに定義されたdefcustomで‘eval-defun’を使用することにより
     、(もしあれば)‘:set’関数が呼び出されます(以下参照)。

     事前ロード( pre-loaded)されたEmacs Lispファイル(*note Building
     Emacs::を参照してください)に‘defcustom’を配した場合、ダンプ時にイン
     ストールされた標準値は正しくない — たとえば依存している他の変数は、
     まだ正しい値を割り当てられていない —　かもしれません。この場合、
     Emacs起動後に標準値を再評価するために、以下で説明する
     ‘custom-reevaluate-setting’を使用します。

   *note Common Keywords::にリストされたキーワードに加え、このマクロには
以下のキーワードを指定できます:

‘:type TYPE’
     このオプションのデータ型として、TYPEを使用します。これはどんな値が
     適正なのか、その値をどのように表示するかを指定します(*note
     Customization Types::を参照してください)。

‘:options VALUE-LIST’
     このオプションに使用する適正な値のリストを指定します。ユーザーが使
     用できる値はこれらの値に限定されませんが、これらは便利な候補値を提
     示します。

     これは特定の型にたいしてだけ意味をもち、現在のところ‘hook’、
     ‘plist’、‘alist’が含まれます。‘:options’の使用法の説明は、個別の型
     の定義を参照してください。

‘:set SETFUNCTION’
     Customizeインターフェースを使用してこのオプションの値を変更する方法
     として、SETFUNCTIONを指定します。関数SETFUNCTIONは2つの引数 — シン
     ボル(オプション名)と新しい値 — をとり、このオプションにたいして正し
     く値を更新するために必要なことは何であれ行うべきです(これはおそらく
     Lisp変数として単にオプションをセットすることを意味しないでしょう)。
     望ましくは、この関数は引数の値を破壊的に変更するべきではありません
     。SETFUNCTIONのデフォルトは、‘set-default’です。

     このキーワードを指定した場合、その変数のドキュメント文字列には、手
     入力のLispコードで同じことを行う方法が記載されるべきです。

‘:get GETFUNCTION’
     このオプションの値を抽出する方法として、GETFUNCTIONを指定します。関
     数GETFUNCTIONは1つの引数(シンボル)をとり、カスタマイズがそのシンボ
     ル(シンボルのLisp値である必要はない)にたいする“カレント値”としてそ
     れを使うべきかreturnするべきです。デフォルトは‘default-value’です。

     ‘:get’を正しく使用するためには、Customの機能を真に理解する必要があ
     ります。これは変数としてCustom内で扱われる値のためのものですが、実
     際にはLisp変数に格納されません。実際にLisp変数に格納されている値に
     GETFUNCTIONを指定するのは、ほとんどは誤りです。

‘:initialize FUNCTION’
     FUNCTIONは、‘defcustom’が評価されるときに変数を初期化するために使用
     される関数であるべきです。これは2つの引数 — オプション名(シンボル
     )と値をとります。この方法での使用のために事前定義された関数がいくつ
     かあります:

     ‘custom-initialize-set’
          変数の初期化に、その変数の‘:set’関数を使用しますが、値がすでに
          非voidの場合、再処帰化を行いません。

     ‘custom-initialize-default’
          ‘custom-initialize-set’と同様ですが、その変数の‘:set’のかわり
          に、関数‘set-default’を使用して変数をセットします。これは変数
          の‘:set’関数がマイナーモードを有効または無効にする場合の、通常
          の選択です。この選択により、変数の定義ではマイナーモード関数を
          呼び出しませんが、変数をカスタマイズしたときはマイナーモード関
          数を呼び出します。

     ‘custom-initialize-reset’
          変数の初期化に、常に‘:set’関数を使用します。変数がすでに非
          voidの場合、(‘:get’メソッドでreturnされる)カレント値を使用して
          ‘:set’関数を呼び出して変数をリセットします。これはデフォルトの
          ‘:initialize’関数です。

     ‘custom-initialize-changed’
          変数がすでにセットされている、またはカスタマイズされている場合
          は、変数の初期化のために‘:set’関数を使用し、それ以外は単に
          ‘set-default’を使用します。

     ‘custom-initialize-safe-set’
     ‘custom-initialize-safe-default’
          これらのn関数は‘custom-initialize-set’、
          ‘custom-initialize-default’と同様に振る舞いますが、エラーを
          catchします。初期化中にエラーが発生した場合は、‘set-default’を
          使用して変数を‘nil’にセットして、エラーをシグナルしません。

          これらの関数は事前ロードされたファイルで定義されたオプションの
          ためのものです(requireされた変数または関数がまだ定義されていな
          いため、STANDARD式はエラーをシグナルするかもしれない)。その値
          は通常、‘startup.el’で更新され、‘defcustom’により計算された値
          は無視されます。startup後に、その値をunsetして、‘defcustom’を
          再評価すれば、エラーなしでSTANDARDは評価されます。

‘:risky VALUE’
     その変数の‘risky-local-variable’プロパティーをVALUEにセットします
     (*note File Local Variables::を参照してください)。

‘:safe FUNCTION’
     その変数の‘safe-local-variable’プロパティーを、FUNCTIONにセットしま
     す(*note File Local Variables::を参照してください)。

‘:set-after VARIABLES’
     保存されたカスタマイズに合わせて変数をセッティングするときは、その
     前に変数VARIABLES確実にセット — つまり、これら他のものが処理される
     後までセッティングを遅延 — してください。これら他の変数が意図された
     値をもっていない場合に、この変数のセッティングが正しく機能しないと
     きは、‘:set-after’を使用してください。

   特定の機能を“オンに切り替える”オプションにたいしては、‘:require’キー
ワードを指定すると便利です。これは、その機能がまだロードされていないとき
は、そのオプションがセットされるとEmacsがその機能をロードするようにしま
す。*note Common Keywords::を参照してください。以下はライブラリー
‘saveplace.el’の例です:

     (defcustom save-place nil
       "Non-nil means automatically save place in each file..."
       :type 'boolean
       :require 'saveplace
       :group 'save-place)

   あるカスタマイズアイテムが、‘:options’がサポートする‘hook’や‘alist’の
ような型をもつ場合は、‘custom-add-frequent-value’を呼び出すことにより、
‘defcustom’宣言の外部から、別途値を追加できます。たとえば
‘emacs-lisp-mode-hook’から呼び出されることを意図した関数
‘my-lisp-mode-initialization’を定義する場合は、‘emacs-lisp-mode-hook’に
たいする正当な値として、その定義を編集することなく、その関数をリストに追
加したいと思うかもしれません。これは以下のようにして行うことができます:

     (custom-add-frequent-value 'emacs-lisp-mode-hook
        'my-lisp-mode-initialization)

 -- Function: custom-add-frequent-value symbol value
     カスタマイズオプションSYMBOLにたいして正当な値のリストにVALUEを追加
     します。

     追加による正確な効果は、SYMBOLのカスタマイズ型に依存します。

   内部的には、‘defcustom’は、標準値にたいする式を記録するためにシンボル
プロパティー‘standard-value’を、カスタマイズバッファーでユーザーによりセ
ットされたが保存されていない値を記録するために‘saved-value’を使用します
。*note Symbol Properties::を参照してください。これらのプロパティーは、
carがその値を評価する式であるようなリストです。

 -- Function: custom-reevaluate-setting symbol
     この関数は、‘defcustom’を通じて宣言されたユーザーオプションSYMBOLの
     標準値を再評価します。変数がカスタマイズされた場合、この関数はかわ
     りに保存された値を再評価します。それからこの関数はユーザーオプショ
     ンをその値に(もし定義されていればそのオプションの‘:set’プロパティー
     を使用して)セットします。

     これは値が正しく計算される前に定義されたカスタマイズ可能オプション
     にたいして有用です。たとえばstartupの間、Emacsは事前ロードされた
     Emacs Lispファイルで定義されたユーザーオプションにたいしてこの関数
     を呼び出しますが、これらの初期値は実行時だけ利用可能な情報に依存し
     ます。

 -- Function: custom-variable-p arg
     この関数は、ARGがカスタマイズ可能変数の場合は、非‘nil’をreturnしま
     す。カスタマイズ可能変数とは、‘standard-value’か‘custom-autoload’プ
     ロパティーをもつ(通常は‘defcustom’で宣言されたことを意味する)変数、
     または別のカスタマイズ可能変数にたいするエイリアスのことです。


File: elisp,  Node: Customization Types,  Next: Applying Customizations,  Prev: Variable Definitions,  Up: Customization

14.4 Customization Types
========================

‘defcustom’でユーザーオプションを定義するときは、ユーザーオプションの“カ
スタマイズ型(customization type)”を指定しなければなりません。これは、
(1)値が適正か、(2)編集のためにカスタマイズバッファーで値を表示する方法、
を記述するLispオブジェクトです。

   カスタマイズ型は、‘defcustom’内の‘:type’キーワードで指定します。
‘:type’の引数は評価されますが、‘defcustom’が実行されるとき1回だけ評価さ
れるので、さまざまな値をとる場合には有用でありません。通常はクォートされ
た定数を使用します。たとえば:

     (defcustom diff-command "diff"
       "The command to use to run diff."
       :type '(string)
       :group 'diff)

   一般的に、カスタマイズ型は、最初の要素が以降のセクションで定義される
カスタマイズ型の1つであるような、リストです。このシンボルの後にいくつか
の引数があり、それはそのシンボルに依存します。型シンボルと引数の間には、
オプションでkeyword-valueペアー(*note Type Keywords::を参照してください
)を記述できます。

   いくつかの型シンボルは引数を使用しません。これらは“シンプル型(simple
types)”と呼ばれます。シンプル型にたいしては、keyword-valueペアーを使用し
ない場合は、型シンボルの周囲のカッコ(parentheses)を省略できます。たとえ
ばカスタマイズ型として単に‘string’と記述すると、それは‘(string)’と等価で
す。

   すべてのカスタマイズ型はウィジェットとして実装されます。詳細は、*note
Introduction: (widget)Top.を参照してください。

* Menu:

* Simple Types::             シンプルなカスタマイズ型(sexp、integerなど)。
* Composite Types::          他の型やデータから新しい型を構築する。
* Splicing into Lists::      ‘:inline’で要素をリストに結合する。
* Type Keywords::            カスタマイズ型でのキーワード／引数ペアー
* Defining New Types::       型に名前をつける。


File: elisp,  Node: Simple Types,  Next: Composite Types,  Up: Customization Types

14.4.1 Simple Types
-------------------

このセクションでは、すべてのシンプルデータ型を説明します。これらのカスタ
マイズ型のうちのいくつかにたいして、カスタマイズウィジェットは‘C-M-i’ま
たは‘M-<TAB>’による、インライン補完を提供します。

‘sexp’
     値はプリントおよび読み込むことができる任意のLispオブジェクトです。
     より特化した型の使用するために時間をとりたくない場合は、任意のオプ
     ションへのフォールバックとして‘sexp’を使用することができます。

‘integer’
     値は整数でなければなりません。

‘number’
     値は数(浮動小数点数または整数)でなければなりません。

‘float’
     値は浮動小数点数でなければなりません。

‘string’
     値は文字列でなければなりません。カスタマイズバッファーはその文字列
     を区切り文字‘"’文字および‘\’クォートなしで表示します。

‘regexp’
     ‘string’文字と同様ですが、その文字列は有効な正規表現でなければなり
     ません。

‘character’
     値は文字コードでなければなりません。文字コードは実際には整数ですが
     、この型は数字を表示せずに、バッファー内にその文字を挿入することに
     より値を表示します。

‘file’
     値はファイル名でなければなりません。ウィジェットは補完を提供します
     。

‘(file :must-match t)’
     値は既存のファイル名でなければなりません。ウィジェットは補完を提供
     します。

‘directory’
     値はディレクトリー名でなければなりません。ウィジェットは補完を提供
     します。

‘hook’
     値は関数のリストでなければなりません。このカスタマイズ型はフック変
     数にたいして使用されます。フック内での使用を推奨される関数のリスト
     を指定するために、フック変数の‘defcustom’内で‘:options’キーワードを
     使用できます。*note Variable Definitions::を参照してください。

‘symbol’
     値はシンボルでなければなりません。これはカスタマイズバッファー内で
     シンボル名として表示されます。ウィジェットは補完を提供します。

‘function’
     値はラムダ式か関数名でなければなりません。ウィジェットは関数名にた
     いする補完を提供します。

‘variable’
     値は変数名でなければなりません。ウィジェットは補完を提供します。

‘face’
     値はフェイス名のシンボルでなければなりません。ウィジェットは補完を
     提供します。

‘boolean’
     値は真偽値 — ‘nil’か‘t’です。‘choice’と‘const’を合わせて使用(次のセ
     クションを参照)することにより、値が‘nil’か‘t’でなければならず、それ
     ぞれの値に固有の意味に適合する説明テキストを指定することもできます
     。

‘key-sequence’
     値はキーシーケンスです。カスタマイズバッファーは、‘kbd’関数と同じ構
     文うぃ使用して、キーシーケンスを表示します。*note Key Sequences::を
     参照してください。

‘coding-system’
     値はコーディングシステム名でなければならず、‘M-<TAB>’で保管すること
     ができます。

‘color’
     値は有効なカラー名でなければなりません。ウィジェットはカラー名にた
     いする補完と、同様に‘*Colors*’バッファーに表示されるカラーサンプル
     とカラー名のリストからカラー名を選択するボタンを提供します。


File: elisp,  Node: Composite Types,  Next: Splicing into Lists,  Prev: Simple Types,  Up: Customization Types

14.4.2 Composite Types
----------------------

適切なシンプル型がないときは、複合型(composite types)を使うことができま
す。複合型は特定のデータによる他の型から、新しい型を構築します。指定され
た型またはデータは、その複合型の“引数(argument)”と呼ばれます。複合型は通
常、以下のようなものです:

     (CONSTRUCTOR ARGUMENTS...)

しかし、以下のように引数の前にkeyword-valueペアーを追加することもできま
す。

     (CONSTRUCTOR {KEYWORD VALUE}... ARGUMENTS...)

   以下のテーブルに、はコンストラクター(constructor)と、複合型を記述する
ためにそれらを使用する方法を示します:

‘(cons CAR-TYPE CDR-TYPE)’
     値はコンスセルでなければならず、CARはCAR-TYPE、CDRはCDR-TYPEに適合
     していなければなりません。たとえば、‘(cons string symbol)’は、
     ‘("foo" . foo)’のような値にマッチするデータ型です。

     カスタマイズバッファーでは、CARとCDRは、それぞれ特定のデータ型に応
     じて、別々に表示・編集されます。

‘(list ELEMENT-TYPES...)’
     値は、ELEMENT-TYPESで与えられる要素と数が正確に一致するリストでなけ
     ればならず、リストの各要素はそれぞれ対応するELEMENT-TYPEに適合しな
     ければなりません。

     たとえば、‘(list integer string function)’は、３つの要素のリストを
     示し、１つ目の要素は整数、２つ目の要素は文字列、３つ目の要素は関数
     です。

     カスタマイズバッファーでは、各要素は、それぞれ特定のデータ型に応じ
     て、別々に表示・編集されます。

‘(group ELEMENT-TYPES...)’
     これは‘list’と似ていますが、Customバッファー内でのテキストのフォー
     マットが異なります。‘list’は各要素の値を、そのタグでラベルづけしま
     すが、‘group’はそれを行いません。

‘(vector ELEMENT-TYPES...)’
     これは‘list’と似ていますが、リストではなくベクターでなければなりま
     せん。各要素は‘list’の場合と同様に機能します。

‘(alist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     値はコンスセルのリストでなければならず、各セルのCARはカスタマイズ型
     KEY-TYPEのキーを表し、同じセルのCDRはカスタマイズ型VALUE-TYPEの値を
     表します。ユーザーはkey/valueペアーの追加や削除ができ、各ペアのキー
     と値の両方を編集することができます。

     省略された場合、KEY-TYPEとVALUE-TYPEのデフォルトは、‘sexp’です。

     ユーザーは指定されたkey-typeにマッチする任意のキーを追加できますが
     、‘:options’(*note Variable Definitions::を参照してください)で指定
     することにより、あるキーを優先的に扱うことができます。指定されたキ
     ーは、(適切な値とともに)常にカスタマイズバッファーに表示されます。
     また、alistにkey/valueを含める、除外する、または無効にするかを指定
     するチェックボックスも一緒に表示されます。ユーザーは‘:options’キー
     ワード引数により指定された値は、変更できません。

     ‘:options’キーワードにたいする引数は、alist内の適切なキーにたいする
     仕様のリストであるべきです。これらは通常、単純なアトムであり、それ
     らは自身をを意味します。たとえば:

          :options '("foo" "bar" "baz")

     これは、名前が‘"foo"’、‘"bar"’、‘"baz"’の、３つの“既知”のキーがある
     ことを指定し、それらは常に最初に表示されます。

     たとえば‘"bar"’キーに対応する値を整数だけにするというように、特定の
     キーに対して値の型を制限したいときがあるかもしれません。これはリス
     ト内でアトムのかわりにリストを使用することにより、指定することがで
     きます。前述のように、１つ目の要素はそのキーを指定し、２つ目の要素
     は値の型を指定します。たとえば:

          :options '("foo" ("bar" integer) "baz")

     最後に、キーが表示される方法を変更したいときもあるかもしれません。
     デフォルトでは、‘:options’キーワードで指定された特別なキーはユーザ
     ーが変更できないので、キーは単に‘const’として表示されます。しかし、
     たとえばそれが関数バインディングをもつシンボルだと知っている場合は
     ‘function-item’といったように、あるキーの表示のために、より特化した
     型を使用したいと思うかもしれません。これは、キーに対してシンボルを
     使うかわりに、カスタマイズ型指定を使用することにより、行うことがで
     きます。

          :options '("foo"
                     ((function-item some-function) integer)
                     "baz")

     多くのalistは、コンスセルのかわりに２要素のリストを使用します。たと
     えば、

          (defcustom cons-alist
            '(("foo" . 1) ("bar" . 2) ("baz" . 3))
            "Each element is a cons-cell (KEY . VALUE).")

     のかわりに以下を使用します

          (defcustom list-alist
            '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE).")

     リストはコンスセルの最上位に実装されているため、上記の
     ‘list-alist’を、コンスセルのalist(value-typeが実際の値を含む１要素
     のリストであるような)として扱うことができます。

          (defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE)."
            :type '(alist :value-type (group integer)))

     ‘list’のかわりに‘group’を使用するのは、その目的に適したフォーマット
     のためだけです。

     同様に、以下のようなトリックの類を用いることにより、より多くの値が
     各キー連づけられたalistを得ることができます:

          (defcustom person-data '(("brian"  50 t)
                                   ("dorith" 55 nil)
                                   ("ken"    52 t))
            "Alist of basic info about people.
          Each element has the form (NAME AGE MALE-FLAG)."
            :type '(alist :value-type (group integer boolean)))

‘(plist :key-type KEY-TYPE :value-type VALUE-TYPE)’
     このカスタマイズ型は‘alist’(上位参照)と似ていますが、(1)情報がプロ
     パティーリスト(*note Property Lists::を参照してください)に格納され
     、(2)KEY-TYPEが省略された場合、デフォルトは‘sexp’ではなく、
     ‘symbol’になります。

‘(choice ALTERNATIVE-TYPES...)’
     値はALTERNATIVE-TYPESのうちの1つに適合しなければなりません。たとえ
     ば、‘(choice integer string)’では整数か文字列が許されます。

     カスタマイズバッファーでは、ユーザーはメニューを使用して候補を選択
     して、それらの候補にたいして通常の方法で値を編集できます。

     通常この選択からメニューの文字列が自動的に決定されます。しかし候補
     の中に‘:tag’キーワードを含めることにより、メニューにたいして異なる
     文字列を指定できます。たとえば、空白の数を意味する整数と、その通り
     に使用したいテキストにたいする文字列の場合は、以下のような方法でカ
     スタマイズ型を記述したいかもしれません

          (choice (integer :tag "Number of spaces")
                  (string :tag "Literal text"))

     この場合メニューは、‘Number of spaces’と‘Literal text’を提示します
     。

     ‘const’以外の‘nil’が有効な値ではない候補には、‘:value’キーワードを
     使用して、有効なデフォルト値を指定するべきです。*note Type
     Keywords::を参照してください。

     複数の候補によりいくつかの値が提供される場合、カスタマイズは適合す
     る値をもつ最初の候補を選択します。これは常に、もっとも特有な型を最
     初に、もっとも一般的な型を最後にリストすべきことを意味します。以下
     は適切な使い方の例です:

          (choice (const :tag "Off" nil)
                  symbol (sexp :tag "Other"))

     この使い方では、特別な値‘nil’はその他のシンボルとは別に扱われ、シン
     ボルは他のLisp式とは別に扱われます。

‘(radio ELEMENT-TYPES...)’
     これは‘choice’と似ていますが、選択はメニューではなく、‘ラジオボタン
     ’で表示されます。これは該当する選択にたいしてドキュメントが表示でき
     る利点があるので、関数定数(‘function-item’カスタマイズ型)の選択に適
     す場合があります。

‘(const VALUE)’
     値はVALUEでなければならず、他は許されません。

     ‘const’は主に‘choice’の中で使用されます。たとえば、‘(choice integer
     (const nil))’では、整数か‘nil’が選択できます。

     ‘choice’の中では、‘:tag’とともに‘const’が使用される場合があります。
     たとえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (const :tag "Ask" foo))

     これは‘t’がyes、‘nil’がno、‘foo’が“ask”を意味することを示します。

‘(other VALUE)’
     この候補は任意のLisp値にマッチできますが、ユーザーがこの候補を選択
     した場合は、値VALUEが選択されます。

     ‘other’は主に‘choice’の最後の要素に使用されます。たとえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (other :tag "Ask" foo))

     これは‘t’がyes、‘nil’がno、それ以外は“ask”を意味することを示します
     。ユーザーが候補メニューから‘Ask’を選択した場合は、値‘foo’が指定さ
     れます。しかし、その他の値(‘t’、‘nil’、‘foo’を除く)では、‘foo’と同
     様に‘Ask’が表示されます。

‘(function-item FUNCTION)’
     ‘const’と同様ですが、値が関数のときに使用されます。これはドキュメン
     ト文字列も関数名と同じように表示します。ドキュメント文字列は、
     ‘:doc’で指定した文字列か、FUNCTION自身のドキュメント文字列です。

‘(variable-item VARIABLE)’
     ‘const’と同様ですが、値が変数名のときに使用されます。これはドキュメ
     ント文字列も変数名と同じように表示します。ドキュメント文字列は、
     ‘:doc’で指定した文字列か、VARIABLE自身のドキュメント文字列です。

‘(set TYPES...)’
     値はリストでなければならず、指定されたTYPESの1つにマッチしなければ
     なりません。

     これはカスタマイズバッファーではチェックリストとして表示されるので
     、TYPESはそれぞれ対応する要素を1つ、あるいは要素をもちません。同じ
     1つのTYPESにマッチするような、異なる2つの要素を指定することはできま
     せん。たとえば、‘(set integer symbol)’は、リスト内で1つの整数、およ
     び/または1つのシンボルが許され、複数の整数や複数のシンボルは許され
     ません。結果として、‘set’内で‘integer’のような特定的ではない型を使
     用するのは稀です。

     以下のように、‘const’型は‘set’内のTYPESでよく使用されます:

          (set (const :bold) (const :italic))

     alist内で利用できる要素を示すために使用されることもあります:

          (set (cons :tag "Height" (const height) integer)
               (cons :tag "Width" (const width) integer))

     これによりユーザーにオプションでheightとwidthの値を指定させることが
     できます。

‘(repeat ELEMENT-TYPE)’
     値はリストでなければならず、リストの各要素は型ELEMENT-TYPEに適合し
     なければなりません。カスタマイズバッファーでは要素のリストとして表
     示され、‘[INS]’および‘[DEL]’ボタンにより、要素の追加や削除が行われ
     ます。

‘(restricted-sexp :match-alternatives CRITERIA)’
     これはもっとも汎用的な複合型の構築方法です。値はCRITERIAを満足する
     任意のLispオブジェクトです。CRITERIAはリストで、リストの各要素は以
     下のうちの1つを満たす必要があります:

        • 述語 — つまり、副作用をもたず引数は1つ、その引数に応じて
          ‘nil’か非‘nil’のどちらかをリターンする関数。リスト内での述語の
          使用により、その述語が非‘nil’をリターンするようなオブジェクト
          が許されることを意味する。

        • クォートされた定数 — つまり、‘'OBJECT’。リスト内でこの要素は、
          OBJECT自身が容認される値であることを示す。

     たとえば、

          (restricted-sexp :match-alternatives
                           (integerp 't 'nil))

     これは整数、‘t’、‘nil’を正当な値として受け入れます。

     カスタマイズバッファーは適切な値をそれらの入力構文ですべて表示し、
     ユーザーはこれらをテキストとして編集できます。

   以下は複合型でキーワード/値ペアーとして使用できるキーワードのテーブル
です:

‘:tag TAG’
     TAGは、ユーザーとのコミュニケーションのために、その候補の名前として
     使用される。‘choice’内に出現する型にたいして有用。

‘:match-alternatives CRITERIA’
     CRITERIAは可能な値とのマッチに使用されます。‘restricted-sexp’内での
     み有用です。

‘:args ARGUMENT-LIST’
     型構築の引数としてARGUMENT-LISTの要素を使用します。たとえば、
     ‘(const :args (foo))’は‘(const foo)’と等価です。明示的に‘:args’とく
     記述する必要があるのは稀です。なぜなら、最後のキーワード/値ペアーの
     後に続くものは何であれ、引数として認識されるからです。


File: elisp,  Node: Splicing into Lists,  Next: Type Keywords,  Prev: Composite Types,  Up: Customization Types

14.4.3 Splicing into Lists
--------------------------

‘:inline’機能により、可変個の要素を、カスタマイズ型の‘list’や‘vector’の
途中にスプライス(splice: 継ぎ足す)することができます。‘list’や‘vector’記
述を含む型にたいして‘:inline t’を追加することによりこれを使用します。

   通常‘list’や‘vector’型の仕様は、単一の要素型を表します。しかしエント
リーが‘:inline t’を含む場合、マッチする値は、その含まれたシーケンスに直
接マージされます。たとえば、エントリーが3要素のリストにマッチする場合、
全体が3要素のシーケンスになります。これはバッククォート構文(*note
Backquote::を参照)の‘,@’に類似しています。

   たとえば、最初の要素が‘baz’で、残りの引数は0個以上の‘foo’か‘bar’でな
ければならないリストを指定する場合は、以下のカスタマイズ型を使用します:

     (list (const baz) (set :inline t (const foo) (const bar)))

これは ‘(baz)’、‘(baz foo)’、‘(baz bar)’、‘(baz foo bar)’のような値にマ
ッチします。

   要素の型が‘choice’の場合は、‘choice’自身の中で‘:inline’を使用せずに、
‘choice’の候補(の一部)の中で使用します。たとえば、最初がファイル名で開始
され、その後にシンボル‘t’か2つの文字列を続けなければならないリストにマッ
チさせるには、以下のカスタマイズ型を使用します:

     (list file
           (choice (const t)
                   (list :inline t string string)))

選択においてユーザーが選択肢の1つ目を選んだ場合、リスト全体が2つの要素を
もち、2つ目の要素は‘t’になります。ユーザーが2つ目の候補を選んだ場合、リ
スト全体が3つの要素をもち、2つ目と3つ目の要素は文字列でなければなりませ
ん。


File: elisp,  Node: Type Keywords,  Next: Defining New Types,  Prev: Splicing into Lists,  Up: Customization Types

14.4.4 Type Keywords
--------------------

カスタマイズ型内の型名シンボルの後にキーワード/引数ペアーを指定できます
。以下は使用できるキーワードと、それらの意味です:

‘:value DEFAULT’
     デフォルト値を提供する。

     その候補にたいして‘nil’が有効な値でない場合は、‘:value’に有効なデフ
     ォルトを指定することが必須になります。

     ‘choice’の内部の候補として出現する型にたいしてこれを使用する場合、
     ユーザーがカスタマイズバッファー内のメニューによりこの候補を選択し
     たときに、使用するデフォルト値を最初に指定します。

     もちろんオプションの実際の値がこの候補に適合する場合は、DEFAULTでは
     なく実際の値が表示されます。

‘:format FORMAT-STRING’
     この文字列は、その型に対応する値を説明するために、バッファーに挿入
     されます。FORMAT-STRING内では、以下の‘%’エスケープが利用できます:

     ‘%[BUTTON%]’
          ボタンとしてマークされたテキストBUTTONを表示する。‘:action’属
          性は、ユーザーがそれを呼び出したときに、そのボタンが何を行うか
          指定する。この属性の値は２つの引数 — ボタンが表示されるのでウ
          ィジェットとイベント — をとる関数。

          異なるアクションを行う2つの異なるボタンを指定する方法はない。

     ‘%{SAMPLE%}’
          ‘:sample-face’により指定された、スペシャルフェイス内のSAMPLEを
          表示する。

     ‘%v’
          そのアイテムの値を代替えする。その値がどのように表示されるかは
          アイテムの種類と、(カスタマイズ型にたいしては)カスタマイズ型に
          に依存する。

     ‘%d’
          そのアイテムのドキュメント文字列を代替えする。

     ‘%h’
          ‘%d’と同様ふぁが、ドキュメント文字列が複数行の場合に、ドキュメ
          ント文字列全体か最初の行だけかを制御するボタンを追加する。

     ‘%t’
          その位置でタグに置き換える。‘:tag’キーワードでタグを指定する。

     ‘%%’
          リテラル‘%’を表示する。

‘:action ACTION’
     ユーザーがボタンをクリックした場合はACTIONを実行します。

‘:button-face FACE’
     ‘%[...%]’で表示されたボタンテキストにたいして、フェイスFACE(フェイ
     ス名、またはフェイス名のリスト)を使用します。

‘:button-prefix PREFIX’
‘:button-suffix SUFFIX’
     これらはボタンの前、または後に表示されるテキストを指定します。以下
     が指定できます:

     ‘nil’
          テキストは挿入されない。

     文字列
          その文字列がリテラルに挿入される。

     シンボル
          そのシンボルの値が使用される。

‘:tag TAG’
     この型に対応する値(または値の一部)にたいするタグとしてTAG(文字列)を
     使用する。

‘:doc DOC’
     この型に対応する値(または値の一部)にたいするドキュメント文字列とし
     てDOCを使用する。これが機能するためには、‘:format’にたいする値を指
     定し、その値にたいして‘%d’か‘%h’を使用しなければならない。

     ある型にたいしてドキュメント文字列を指定するのは、‘:choice’内の候補
     の型や、他の複合型の一部について情報を提供するのが通常の理由である
     。

‘:help-echo MOTION-DOC’
     ‘widget-forward’や‘widget-backward’でこのアイテムに移動したときに、
     エコーエリアに文字列MOTION-DOCを表示する。さらに、マウスの
     ‘help-echo’文字列としてMOTION-DOCが使用され、これは実際にはヘルプ文
     字列を生成するために評価される関数またはフォームかもしれない。もし
     関数の場合、これは1つの引数(そのウィジェット)で呼び出される。

‘:match FUNCTION’
     値がその型にマッチするか判断する方法を指定する。対応する値
     FUNCTIONは、2つの引数(ウィジェットと値)をとる関数で、値が適切なら非
     ‘nil’をリターンすること。

‘:validate FUNCTION’
     入力にたいして検証を行う関数を指定する。FUNCTIONは引数としてウィジ
     ェットをとり、そのウィジェットのカレント値がウィジェットにたいして
     有効なら‘nil’をリターンすること。それ以外は無効なデータを含むウィジ
     ェットをリターンして、そのウィジェットの‘:error’プロパティに、その
     エラーを説明する文字列をセットすること。


File: elisp,  Node: Defining New Types,  Prev: Type Keywords,  Up: Customization Types

14.4.5 Defining New Types
-------------------------

前のセクションでは、‘defcustom’にたいして型の詳細な仕様を作成する方法を
説明しました。そのような型仕様に名前を与えたい場合があるかもしれません。
理解しやすいケースとしては、多くのユーザーオプションに同じ型を使用する場
合などです。各オプションにたいして仕様を繰り返すより、その型に名前を与え
て、‘defcustom’それぞれにその名前を使用することができます。他にもユーザ
ーオプションの値が再帰的なデータ構造のケースがあります。あるデータ型がそ
れ自身を参照できるようにするためには、それが名前をもつ必要があります。

   カスタマイズ型はウィジェットとして実装されているめ、新しいカスタマイ
ズ型を定義するには、新たにウィジェット型を定義します。ここではウィジェッ
トインターフェイスの詳細は説明しません。*note Introduction:
(widget)Top.を参照してください。　かわりに、シンプルな例を用いて、カスタ
マイズ型を新たに定義するのに必要となる、最小限の機能について説明します。

     (define-widget 'binary-tree-of-string 'lazy
       "A binary tree made of cons-cells and strings."
       :offset 4
       :tag "Node"
       :type '(choice (string :tag "Leaf" :value "")
                      (cons :tag "Interior"
                            :value ("" . "")
                            binary-tree-of-string
                            binary-tree-of-string)))

     (defcustom foo-bar ""
       "Sample variable holding a binary tree of strings."
       :type 'binary-tree-of-string)

   新しいウィジェットを定義するための関数は、‘define-widget’と呼ばれます
。1つ目の引数は、新たなウィジェット型にしたいシンボルです。2つ目の引数は
既存のウィジェットを表すシンボルで、新しいウィジェットではこの既存のウィ
ジェットと異なる部分を定義することになります。新たなカスタマイズ型を定義
する目的にたいしては、‘lazy’ウィジェットが最適です。なぜならこれは、
‘defcustom’にたいするキーワード引数と同じ構文、同じ名前でキーワード引数
‘:type’を受け取るからです。3つ目の引数は、新しいウィジェットにたいするド
キュメント文字列です。この文字列は、‘M-x widget-browse <RET>
binary-tree-of-string <RET>’コマンドで参照することができるようになります
。

   これらの必須の引数の後にキーワード引数が続きます。もっとも重要なのは
‘:type’で、これはこのウィジェットにマッチさせたいデータ型を表します。上
記の例では‘binary-tree-of-string’は文字列、またはcarとcdrが
‘binary-tree-of-string’であるようなコンスセルです。この定義中でのウィジ
ェット型への参照に注意してください。‘:tag’属性はユーザーインターフェイス
でウィジェット名となる文字列、‘:offset’引数はカスタマイズバッファーでの
ツリー構造の外観で，子ノードと関連する親ノードの間に4つのスペースを確保
します。

   ‘defcustom’は、通常のカスタマイズ型に使用される方法で新しいウィジェッ
トを表示します。

   ‘lazy’という名前の由来は、他のウィジェットの場合、それらがバッファー
でインスタンス化されるとき、他の合成されたウィジェットが下位のウィジェッ
トを内部形式に変換するからです。この変換は再帰的なので、下位のウィジェッ
トは、_それら自身_の下位ウィジェットへと変換されます。データ構造自体が再
帰的な場合、この変換は無限再帰(infinite recursion)となります。‘lazy’ウィ
ジェットは、‘:type’引数を必要なときだけ変換することにより、この再帰を防
ぎます。


File: elisp,  Node: Applying Customizations,  Next: Custom Themes,  Prev: Customization Types,  Up: Customization

14.5 Applying Customizations
============================

以下の関数には、変数とフェイスにたいして、そのユーザーのカスタマイズ設定
をインストールる役目があります。それらの関数は、ユーザーがカスタマイズイ
ンターフェイスで‘Save for future sessions’を呼び出したときに、次回の
Emacs起動時に評価されるように‘custom-set-variables’フォーム、および/また
は‘custom-set-faces’フォームを がカスタムファイルに書き込まれることによ
って効果をもちます。

 -- Function: custom-set-variables &rest args
     この関数はARGSにより指定された変数のカスタマイズをインストールしま
     す。ARGS内の引数はそれぞれ、以下のようなフォームです

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     VARは変数名(シンボル)、EXPRESSIONはカスタマイズされた値に評価される
     式です。

     この‘custom-set-variables’呼び出しより前にVARにたいして
     ‘defcustom’フォームが評価された場合は、即座にEXPRESSIONが評価され、
     その変数の値にその結果がセットされます。それ以外は、その変数の
     ‘saved-value’プロパティにEXPRESSIONが格納され、これに関係する
     ‘defcustom’が呼び出されたとき(通常はその変数を定義するライブラリー
     がEmacsにロードされたとき)に評価されます。

     NOW、REQUEST、COMMENTエントリーは内部的な使用に限られており、省略さ
     れるかもしれません。NOWは、もし非‘nil’の場合には、たとえその変数の
     ‘defcustom’フォームが評価されていなくても、その変数の値がそのときセ
     ットされます。REQUESTは即座にロードされる機能のリストです(*note
     Named Features::を参照)。COMMENTはそのカスタマイズを説明する文字列
     です。

 -- Function: custom-set-faces &rest args
     この関数はARGSにより指定されたフェイスのカスタマイズをインストール
     します。ARGS内の引数はそれぞれ、以下のようなフォームです

          (FACE SPEC [NOW [COMMENT]])

     FACEはフェイス名(シンボル)、SPECはそのフェイスにたいするカスタマイ
     ズされたフェイス仕様です(*note Defining Faces::を参照)。

     NOW、REQUEST、COMMENTエントリーは内部的な使用に限られており、省略さ
     れるかもしれません。NOWは、もし非‘nil’の場合には、たとえ‘defface’フ
     ォームが評価されていなくても、そのフェイス仕様がそのときセットされ
     ます。COMMENTはそのカスタマイズを説明する文字列です。


File: elisp,  Node: Custom Themes,  Prev: Applying Customizations,  Up: Customization

14.6 Custom Themes
==================

“カスタムテーマ(Custom themes)”とはユニットとして有効または無効にできる
セッティングのコレクションです。*note (emacs)Custom Themes::を参照してく
ださいカスタムテーマはそれぞれEmacs Lispソースファイルにより定義され、そ
れらはこのセクションで説明する慣習にしたがう必要があります。(カスタムフ
ァイルを手で記述するかわりに、カスタマイズ風のインターフェイスを使用して
作成することもできます。*note (emacs)Creating Custom Themes::を参照して
ください。)

   カスタムファイルは‘FOO-theme.el’のように命名すべきです。ここでFOOはテ
ーマの名前です。このファイルでの最初のLispフォームは‘deftheme’の呼び出し
で、最後のフォームは‘provide-theme’にすべきです。

 -- Macro: deftheme theme &optional doc
     このマクロはカスタムテーマの名前としてTHEME(シンボル)を宣言します。
     オプション引数DOCは、そのテーマを説明する文字列であるべきです。この
     文字列はユーザーが‘describe-theme’コマンドを呼び出したり、‘*Custom
     Themes*’バッファーで‘?’をタイプしたときに表示されます。

     2つの特別なテーマ名は禁止されています(それらを使用するとエラーにな
     ります)。‘user’は、そのユーザーの直接的なカスタマイズ設定を格納する
     ための“ダミー”のテーマです。そし‘changed’はカスタムシステムの外で行
     われた変更を格納するための“ダミー”のテーマです。

 -- Macro: provide-theme theme
     このマクロは完全に仕様が定められたテーマ名THEMEを宣言します。

   ‘deftheme’と‘provide-theme’の違いは、そのテーマセッティングを規定する
Lispフォーム(通常は‘custom-theme-set-variables’の呼び出し、および/または
‘custom-theme-set-faces’の呼び出し)です。

 -- Function: custom-theme-set-variables theme &rest args
     この関数は、カスタムテーマTHEMEの変数のセッティングを規定します。
     THEMEはシンボルです。ARGS内の各引数はフォームのリストです。

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     ここでリストエントリーは‘custom-set-variables’のときと同じ意味をも
     ちます。*note Applying Customizations::を参照してください。

 -- Function: custom-theme-set-faces theme &rest args
     この関数は、カスタムテーマTHEMEのフェイスのセッティングを規定します
     。THEMEはシンボルです。ARGS内の各引数はフォームのリストです。

          (FACE SPEC [NOW [COMMENT]])

     ここでリストエントリーは‘custom-set-faces’のときと同じ意味をもちま
     す。*note Applying Customizations::を参照してください。

   原則的に、テーマファイルは他のLispフォームを含むこともでき、それらは
そのテーマがロードされるときに評価されるでしょうが、これは“悪いフォーム
”です。悪意のあるコードを含むテーマのロードを防ぐために、最初に非ビルト
インテーマをロードする前に、Emacsはソースファイルを表示して、ユーザーに
たいして確認を求めます。

   以下の関数は、テーマをプログラム的に有効または無効にするのに有用です:

 -- Function: custom-theme-p theme
     この関数はTHEME(シンボル)がカスタムテーマの名前の場合(たとえば、そ
     のテーマが有効かどうかにかかわらず、カスタムテーマがEmacsにロードさ
     れていれば)、非‘nil’をリターンします。それ以外は‘nil’をリターンしま
     す。

 -- Variable: custom-known-themes
     この変数の値は、Emacsにロードされたテーマのリストです。テーマはそれ
     ぞれ、Lispシンボル(テーマ名)により表されます。この変数のデフォルト
     値は、2つの“ダミーテーマ”を含みます: ‘(user changed)’。‘changed’テ
     ーマには、カスタムテーマが適用される前に行われたセッティング(たとえ
     ばカスタムの外部での変数のセット)が格納されています。‘user’テーマに
     は、そのユーザーがカスタマイズして保存したセッティングが格納されて
     います。‘deftheme’マクロで宣言された任意の追加テーマは、このリスト
     の先頭に追加されます。

 -- Command: load-theme theme &optional no-confirm no-enable
     この関数はTHEMEという名前のカスタムテーマを、変数
     ‘custom-theme-load-path’で指定されたディレクトリーを探して、ソース
     ファイルからロードします。*note (emacs)Custom Themes::を参照してく
     ださい。また、そのテーマの変数とフェイスのセッティングが効果を及ぼ
     すようにテーマを“enables”にします(オプション引数NO-ENABLEが非
     ‘nil’でない場合)さらに、オプション引数NO-CONFIRMが非‘nil’でない場合
     は、そのテーマをロードする前にユーザーに確認を求めます。

 -- Command: enable-theme theme
     この関数はTHEMEという名前のカスタムテーマを有効にします。そのような
     テーマがロードされていない場合は、エラーをシグナルします。

 -- Command: disable-theme theme
     この関数はTHEMEという名前のカスタムテーマを無効にします。テーマはロ
     ードされたまま残りので、続けて‘enable-theme’を呼び出せばテーマは再
     び有効になります。


File: elisp,  Node: Loading,  Next: Byte Compilation,  Prev: Customization,  Up: Top

15 Loading
**********

Lispコードのファイルをロードすることは、その内容をLispオブジェクト形式で
Lisp環境に取り込むことを意味します。Emacsはファイルを探してオープンし、
テキストを読み込んで各フォームを評価してから、そのファイルをクローズしま
す。そのようなファイルは“Lispライブラリー(Lisp library)”とも呼ばれます。

   ‘eval-buffer’関数がバッファー内のすべての式を評価するのと同様に、
load関数はファイル内のすべての式を評価します。異なるのはEmacsバッファー
内のテキストではなく、load関数はディスク上で見つかったファイル内のテキス
トを読み込み、評価することです。

   ロードされたファイルは、ソースコードかバイトコンパイルされたコードと
してLisp式を含んでいなければなりません。このファイル内の各フォームは、
“トップレベルフォーム(top-level form)”と呼ばれます。ロード可能なファイル
内のフォームにたいする特別なフォーマットはありません。ファイル内のフォー
ムはどれも、同じように直接バッファーにタイプされ、そこで評価されるでしょ
う(実際、ほとんどのコードはこの方法でテストされます)。多くの場合、そのフ
ォームは関数定義と変数定義です。

   外部ライブラリーのオンデマンドローディングについては、*note Dynamic
Libraries::を参照してください。

* Menu:

* How Programs Do Loading::  ‘load’関数、その他。
* Load Suffixes::            ‘load’が試みられるサフィックスについての詳細。
* Library Search::           ロードするライブラリーの検索。
* Loading Non-ASCII::        Emacs
                               Lispファイル内の非ASCII文字。
* Autoload::                 オートロードのための関数のセットアップ。
* Repeated Loading::         ファイルを2度ロードする場合の配慮。
* Named Features::           まだロードされていないライブラリーのロード。
* Where Defined::            特定のシンボルがどのファイルで定義されているかの検索。
* Unloading::                ロードされたライブラリーを"unload"する方法。
* Hooks for Loading::        特定のライブラリーがロードされたとき実行されるコードの提供。


File: elisp,  Node: How Programs Do Loading,  Next: Load Suffixes,  Up: Loading

15.1 How Programs Do Loading
============================

Emacs Lispにはロードのためのインターフェイスがいくつかあります。たとえば
、‘autoload’はファイル内で定義された関数にたいしてプレースホルダーとなる
オブジェクトを作成します。この関数はオートロードされる関数を呼び出すため
に、ファイルからその関数の実際の定義の取得を試みます(*note Autoload::を
参照)。‘require’は、ファイルがまだロードされていない場合にファイルをロー
ドします(*note Named Features::を参照)。これらすべての関数は、処理を行う
ために最終的に‘load’を呼び出します。

 -- Function: load filename &optional missing-ok nomessage nosuffix
          must-suffix
     この関数はLispコードのファイルを見つけてオープンし、その中のすべて
     のフォームを評価して、そのファイルをクローズします。

     ファイルを見つけるために、まず‘load’は‘FILENAME.elc’という名前、つ
     まりFILENAMEに拡張子‘.elc’を足した名前のファイルを探します。このよ
     うなファイルが存在したら、それをロードします。その名前のファイルが
     存在しない場合、‘load’は‘FILENAME.el’という名前のファイルを探します
     。このファイルが存在したら、それをロードします。最後に、もしこれら
     の名前がどちらも見つからなかった場合、‘load’は何も付け足さない
     FILENAMEという名前のファイルを探して、それが存在したらロードします
     。(‘load’関数にFILENAMEを認識する賢さはありません。‘foo.el.el’のよ
     うな正しくない名前のファイルの場合も、‘(load "foo.el")’の評価により
     それを見つけてしまいます。)

     Auto Compressionモードが有効(残念ながらデフォルトでは有効ですが)の
     場合、‘load’は他のファイル名を試みる前に圧縮されたバージョンのファ
     イル名を探すので、ファイルを見つけることができません。圧縮されたフ
     ァイルが存在したら、それを解凍してロードします。‘load’はファイル名
     に‘jka-compr-load-suffixes’内の各サフィックスを足して、圧縮されたバ
     ージョンを探します。この変数の値は、文字列のリストでなければなりま
     せん。標準的な値は‘(".gz")’です。

     オプション引数NOSUFFIXが非‘nil’の場合‘load’はサフィックス‘.elc’と
     ‘.el’を試みません。この場合、ロードしたいファイルの正確な名前を指定
     しなければなりません。ただしAuto Compressionモードが有効な場合には
     、‘load’は圧縮されたバージョンを探すために、
     ‘jka-compr-load-suffixes’を使用します。正確なファイル名の指定と、、
     NOSUFFIXにたいして‘t’を使用することにより、‘foo.el.el’のような名前
     のファイルにたいするロードの試みを抑止できます。

     オプション引数MUST-SUFFIXが非‘nil’の場合、‘load’はロードに使用され
     るファイルの名前に明示的にディレクトリー名が含まれていなければ、フ
     ァイル名が‘.el’か‘.elc’で終わること(あるいは圧縮による拡張子が付加
     されているかもしれません)を要求します。

     オプション‘load-prefer-newer’が非‘nil’の場合、‘load’はサフィックス
     を検索するとき、どのファイルであっても(‘.elc’、‘.el’など)、もっとも
     最近変更されたファイルのバージョンを選択します。

     FILENAMEが‘foo’や‘baz/foo.bar’のような相対ファイル名の場合、
     ‘load’は変数‘load-path’を使用してそのファイルを探します。これは
     ‘load-path’内にリストされた各ディレクトリーにFILENAMEを追加して、最
     初に見つかったら名前のマッチするファイルをロードします。デフォルト
     ディレクトリーを意味する‘nil’が‘load-path’で措定されたときだけ、カ
     レントデフォルトディレクトリーを試みます。‘load’は‘load-path’内の最
     初のディレクトリーで利用可能な3つのサフィックスすべてを試行してから
     、2つ目のディレクトリーで３つのサフィックスすべてを試行する、という
     ようにファイルを探します。*note Library Search::を参照してください
     。

     最終的に見つかったファイル、およびEmacsがそのファイルを見つけたディ
     レクトリーが何であれ、Emacsはそのファイル名を変数‘load-file-name’の
     値にセットします。

     ‘foo.elc’が‘foo.el’より古いと警告された場合、それは‘foo.el’のリコン
     パイルを考慮すべきことを意味します。*note Byte Compilation::を参照
     してください

     (コンパイルされていない)ソースファイルをロードしたとき、Emacsがファ
     イルをvisitしたときと同じように‘load’は文字セットの変換を行います。
     *note Coding Systems::を参照してください。

     コンパイルされていないファイルをロードするとき、Emacsはそのファイル
     に含まれる任意のマクロ(*note Macros::を参照)を展開します。わたした
     ちはこれを“eagerマクロ展開(eager macro expansion)”と呼んでいます。
     (関連するコードを実行するまで展開を延期するのではなく)これを行うこ
     とにより、コンパイルされていないコード実行のスピードが明らかに向上
     します。このマクロ展開は、循環参照により行うことができないときもあ
     ります。これの一番簡単な例は、ロードしようとしているファイルが他の
     ファイルで定義されているマクロを参照しているが、そのファイルはロー
     ドしようとしているファイルを必要としている場合です。これは一般的に
     は無害です。Emacsは問題の詳細を与えるために警告(‘Eager
     macro-expansion skipped due to cycle...’)をプリントしますが、単にそ
     の時点ではマクロを展開せずに、そのファイルはロードされます。あなた
     はこの問題が発生しないように、コードをリストラクチャーしたいと思う
     かもしれません。コンパイル済みファイルでは、マクロ展開はコンパイル
     時に行われるので、ロード時のマクロ展開は行われません。*note
     Compiling Macros::を参照してください。

     NOMESSAGEが非‘nil’でない場合は、ロードの間、エコーエリアに‘Loading
     foo...’や‘Loading foo...done’のようなメッセージが表示されます。

     ファイルをロードする間のハンドルされないエラーは、ロードを終了させ
     ます。‘autoload’のためのロードの場合、ロードの間に定義された任意の
     関数定義は元に戻されます。

     ‘load’がロードするファイルを見つけられなかった場合、通常は(‘Cannot
     open load file FILENAME’のメッセージとともに)エラー‘file-error’がシ
     グナルされます。しかしMISSING-OKが非‘nil’の場合、‘load’は単に
     ‘nil’をリターンします。

     式の読み取りにたいして‘load’が‘read’のかわりに使用する関数を指定す
     るために、変数‘load-read-function’を使用できます。以下を参照してく
     ださい。

     ファイルが正常にロードされた場合、‘load’は‘t’をリターンします。

 -- Command: load-file filename
     このコマンドは、ファイルFILENAMEをロードします。FILENAMEが相対ファ
     イル名の場合は、カレントデフォルトディレクトリーとみなされます。こ
     のコマンドは、‘load-path’を使用せず、サフィックスの追加もしません。
     しかし、(Auto Compressionモードが有効な場合は)圧縮されたバージョン
     の検索を行います。ロードするファイル名を正確に指定したい場合は、こ
     のコマンドを使用してください。

 -- Command: load-library library
     このコマンドはLIBRARYという名前のライブラリーをロードします。このコ
     マンドは、引数を読み取る方法がインタラクティブであることを除き、
     ‘load’と同じです。*note (emacs)Lisp Libraries::を参照してください。

 -- Variable: load-in-progress
     この変数は、Emacsがファイルをロード中のときは非‘nil’、それ以外は
     ‘nil’です。

 -- Variable: load-file-name
     このセクションの最初に説明した検索でEmacsがファイルを見つけて、その
     ファイルをロード中のとき、この変数の値はそのファイルの名前です。

 -- Variable: load-read-function
     この変数は、‘load’と‘eval-region’が式の読み取るために、‘read’のかわ
     りに使用する関数を指定します。指定する関数は‘read’と同様、引数が1つ
     の関数です。

     通常、この変数の値は‘nil’で、これはそれらの関数が‘read’を使用すべき
     ことを意味します。

     この変数を使用するかわりに、別の新たな方法を使用するほうが明確です
     。‘eval-region’のREAD-FUNCTION引数に、その関数を渡す方法です。*note
     Eval: Definition of eval-region.を参照してください。

   Emacsのビルドで‘load’がどのように使用されているかについての情報は、
*note Building Emacs::を参照してください。


File: elisp,  Node: Load Suffixes,  Next: Library Search,  Prev: How Programs Do Loading,  Up: Loading

15.2 Load Suffixes
==================

ここでは、‘load’が試行するサフィックスについて、技術的な詳細を説明します
。

 -- Variable: load-suffixes
     これは(ソースまたはコンパイル済みの)Emacs Lispファイルを示すサフィ
     ックスのリストです。空の文字列が含まれるべきではありません。
     ‘load’は、指定されたファイル名にLispファイルのサフィックスを追加す
     るときに、これらのサフィックスを使用します。標準的な値は‘(".elc"
     ".el")’で、これは前のセクションで説明した振る舞いとなります。

 -- Variable: load-file-rep-suffixes
     これは同じファイルにたいする異なる表現を示すサフィックスのリストで
     す。このリストは空の文字列から開始されるべきです。‘load’はファイル
     を検索するときは、他のファイルを検索する前にこのリストのサフィック
     スを順番にファイル名に追加します。

     Auto Compressionモードを有効にすることにより
     ‘jka-compr-load-suffixes’のサフィックスがこのリストに追加され、無効
     にすると再びリストから取り除かれます。‘load-file-rep-suffixes’の標
     準的な値は、Auto Compressionモードが無効な場合は‘("")’です。
     ‘jka-compr-load-suffixes’の標準的な値が‘(".gz")’であることを考慮す
     ると、Auto Compressionモードが有効な場合の
     ‘load-file-rep-suffixes’の標準的な値は‘("" ".gz")’です。

 -- Function: get-load-suffixes
     この関数は、MUST-SUFFIX引数が非‘nil’のときは、‘load’が試みるべきす
     べてのサフィックスを順番にしたがったリストでリターンします。この関
     数は‘load-suffixes’と‘load-file-rep-suffixes’の両方を考慮に入れます
     。‘load-suffixes’、‘jka-compr-load-suffixes’、
     ‘load-file-rep-suffixes’がすべて標準的な値の場合、この関数はAuto
     Compressionモードが有効なら‘(".elc" ".elc.gz" ".el" ".el.gz")’、無
     効なら‘(".elc" ".el")’をリターンします。

   まとめると、‘load’は通常まず‘(get-load-suffixes)’の値のサフィックスを
試み、つぎに‘load-file-rep-suffixes’を試みます。NOSUFFIXが非‘nil’の場合
は前者がスキップされ、MUST-SUFFIXが非‘nil’の場合は後者がスキップされます
。

 -- User Option: load-prefer-newer
     このオプションが非‘nil’の場合は、ファイルが見つかった最初のサフィッ
     クスで停止せずに、‘load’はすべてのサフィックスをテストして、一番新
     しいファイルを使用します。


File: elisp,  Node: Library Search,  Next: Loading Non-ASCII,  Prev: Load Suffixes,  Up: Loading

15.3 Library Search
===================

EmacsがLispライブラリーをロードするときは、変数‘load-path’.<により指定さ
れるディレクトリー内のライブラリーを検索します。

 -- Variable: load-path
     この変数の値は、‘load’でファイルをロードするとき検索するディレクト
     リーのリストです。リストの各要素は文字列(ディレクトリー名でなければ
     なりません)、または‘nil’(カレントワーキングディレクトリーを意味しま
     す)です。

   Emacsは起動時にいくつかのステップにより‘load-path’の値をセットアップ
します。最初に、Emacsがコンパイルされたときのデフォルトロケーションセッ
ト(default locations set)を使用して、‘load-path’を初期化します。通常これ
は以下のようなディレクトリーです

     "/usr/local/share/emacs/VERSION/lisp"

   (以下の例では、あなたがインストールしたEmacsのインストールプレフィク
スに合うように‘/usr/local’を置き換えてください。)これらのディレクトリー
には、Emacsとともにインストールされた、標準的なLispファイルが含まれます
。Emacsがこれらを見つけられない場合は、正常に起動しないでしょう。

   Emacsをビルドしたディレクトリーから起動した場合 −−− つまり正式にイン
ストールされた実行形式ではないEmacsを起動した場合 —　、Emacsはビルドされ
たディレクトリーのソースの‘lisp’ディレクトリーを使用して‘load-path’を初
期化します。ソースとは別のディレクトリーでEmacsをビルドした場合は、ビル
ドしたディレクトリーの‘lisp’ディレクトリーも追加します。(どちらの場合も
、要素は絶対ファイル名になります。)

   ‘--no-site-lisp’オプションでEmacsを起動した場合を除き、‘load-path’の
先頭に2つのさらに‘site-lisp’を追加します。これらはローカルにインストール
されたLispファイで、通常は:

     "/usr/local/share/emacs/VERSION/site-lisp"

と

     "/usr/local/share/emacs/site-lisp"

の形式です。1つ目は特定のバージョンのEmacsにたいしてローカルにインストー
ルされたものです。2つ目はインストールされたすべてのバージョンのEmacsが使
用することを意図してローカルにインストールされたものです。(インストール
されたものでないEmacsが実行された場合は、もし存在すればソースディレクト
リーとビルドディレクトリーの‘site-lisp’ディレクトリーも追加します。これ
らのディレクトリーは通常、‘site-lisp’ディレクトリーを含みません。)

   環境変数‘EMACSLOADPATH’がセットされている場合は、上述の初期化プロセス
が変更されます。Emacsは、この環境変数の値にもとづいて‘load-path’を初期化
します。

   ‘EMACSLOADPATH’の構文は、‘PATH’で使用される構文と同様です。ディレクト
リー名は‘:’(オペレーティングシステムによっては‘;’)で区切られます。 以下
は、(‘sh’スタイルのシェルから)‘EMACSLOADPATH’変数をセットする例です:

     export EMACSLOADPATH=/home/foo/.emacs.d/lisp:

   環境変数の値内の空の要素は、(上記例のような)末尾、先頭、中間にあるか
に関わらず、標準の初期化処理により決定される‘load-path’のデフォルト値に
置き換えられます。そのような空要素が存在しない場合には、
‘EMACSLOADPATH’により‘load-path’全体が指定されます。空要素、または標準の
Lispファイルを含むディレクトリーへの明示的なパスのどちらかを含めなければ
なりません。さもないとEmacsが関数を見つけられなくなります。
(‘load-path’を変更する他の方法は、Emacs起動時にコマンドラインオプション
‘-L’を使用する方法です。以下参照。)

   ‘load-path’内の各ディレクトリーにたいし、Emacsはそのディレクトリーが
ファイル‘subdirs.el’を含むか確認し、もしあればそれをロードします。
‘subdirs.el’ファイルは、‘load-path’のディレクトリーみたいして任意のサブ
ディレクトリーを追加するためのコードが含まれており、Emacsがビルド/インス
トールされたとき作成されます。サブディレクトリーと複数階層下のレベルのサ
ブディレクトリーの両方が、直接追加されます。ただし、名前の最初が英数字で
ないディレクトリー、名前が‘RCS’または‘CVS’のディレクトリー、名前が
‘.nosearch’というファイルを含むディレクトリーは除外されます。

   Emacsは次に、コマンドラインオプション‘-L’(*note (emacs)Action
Arguments::を参照)で指定したロードディレクトリーを追加します。もしあれば
、オプションパッケージ(*note Packaging Basics::を参照)がインストールされ
た場所も追加します。

   initファイル(*note Init File::を参照)で、‘load-path’に1つ以上のディレ
クトリーを追加するコードを記述するのは一般的に行なわれています。たとえば
:

     (push "~/.emacs.d/lisp" load-path)

   Emacsのダンプには、‘load-path’の特別な値を使用します。ダンプされた
Emacsをカスタマイズするために‘site-load.el’または‘site-init.el’を使用す
る場合、これらのファイルが行った‘load-path’にたいする変更はすべて、ダン
プ後失われます。

 -- Command: locate-library library &optional nosuffix path
          interactive-call
     このコマンドは、ライブラリーLIBRARYの正確なファイル名を探します。
     ‘load’と同じ方法でライブラリーを検索し、引数NOSUFFIXも‘load’の場合
     と同じ意味です。LIBRARYに指定する名前には、サフィックス‘.elc’または
     ‘.el’を追加しないでください。

     PATHが非‘nil’の場合は、‘load-path’のかわりにディレクトリーのリスト
     が使用されます。

     ‘locate-library’がプログラムから呼び出されたときは、ファイル名を文
     字列としてリターンします。ユーザーがインタラクティブに
     ‘locate-library’を実行したときは、引数INTERACTIVE-CALLが‘t’となり、
     これは‘locate-library’にたいしてファイル名をエコーエリアに表示する
     よう指示します。

 -- Command: list-load-path-shadows &optional stringp
     このコマンドは、“シャドー(shadowed)”されたEmacs Lispファイルを表示
     します。シャドーされたファイルとは、‘load-path’のディレクトリーに存
     在するにも関わらず、‘load-path’のディレクトリーリスト内で前の位置に
     ある他のディレクトリーに同じ名前のファイルが存在するため、通常はロ
     ードされないファイルのことです。

     たとえば、以下のように‘load-path’がセットされていたとします

            ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")

     そして、両方のディレクトリーに‘foo.el’という名前のファイルがあると
     します。この場合、‘(require 'foo)’は決して2つ目のディレクトリーのフ
     ァイルをロードしません。このような状況は、Emacsがインストールされた
     方法に問題があることを示唆します。

     Lispから呼び出された場合、この関数はバッファー内に表示するかわりに
     、シャドーされたファイルリストのメッセージをプリントします。オプシ
     ョン引数‘stringp’が非‘nil’の場合は、かわりにシャドーされたファイル
     を文字列としてリターンします。


File: elisp,  Node: Loading Non-ASCII,  Next: Autoload,  Prev: Library Search,  Up: Loading

15.4 Loading Non-ASCII Characters
=================================

Emacs Lispプログラムが非ASCII文字の文字列定数を含むとき、Emacsではそれら
をユニバイト文字列またはマルチバイト文字列のどちらかで表現される場合があ
ります。どちらの表現が使用されるかは、そのファイルがどのようにEmacsに読
み込まれたかに依存します。マルチバイト表現へのデコーディングとともに読み
込まれた場合、Lispプログラム内のテキストはマルチバイトのテキストとなり、
ファイル内の文字列定数はマルチバイト文字列になります。(たとえば
)Latin-1文字を含むファイルをデコーディングなしで読み込んだ場合、そのプロ
グラムのテキストはユニバイトのテキストとなり、ファイル内の文字列定数はユ
ニバイト文字列になります。*note Coding Systems::を参照してください。

   マルチバイト文字列がユニバイトバッファーに挿入されるときは自動的にユ
ニバイトに変換されるため、大部分のEmacs Lispプログラムにおいて、マルチバ
イト文字列が非ASCII文字列であるという事実を意識させないようにすべきです
。しかしこれが行われことにより違いが生じる場合には、ローカル変数セクショ
ンに‘coding: raw-text’と記述することにより、特定のLispファイルを強制的に
ユニバイトとして解釈させることができます。この識別子により、そのファイル
は無条件でユニバイトとして解釈されます。これは、‘?vLITERAL’で記述された
非ASCII文字にキーバインドするとき重要になります。


File: elisp,  Node: Autoload,  Next: Repeated Loading,  Prev: Loading Non-ASCII,  Up: Loading

15.5 Autoload
=============

“オートロード(autoload: 自動ロード)”の機能により、定義されているファイル
をロードすることなく、関数やマクロの存在を登録できます。関数の最初の呼び
出しで、実際の定義およびその他の関連するコードをインストールするために適
切なライブラリーを自動的にロードし、すべてがすでにロードされていたかのよ
うに、実際の定義を実行します。関数やマクロのドキュメントを参照することに
よっても、オートロードが発生します(*note Documentation Basics::を参照)。

   オートロードされた関数をセットアップするには、2つの方法があります。そ
れは‘autoload’を呼び出す方法と、ソースの実際の定義の前に、特別な“マジッ
ク”コメントを記述する方法です。‘autoload’はオートロードのための低レベル
のプリミティブです。任意のLispプログラムが、任意のときに‘autoload’を呼び
出すことができます。Emacsととみにインストールされるパッケージにとって、
マジックコメントは関数をオートロードできるようににするための一番便利な方
法です。コメント自身は何も行いませんが、コマンド
‘update-file-autoloads’にたいするガイドを努めます。このコマンドは
‘autoload’の呼び出しを構築し、Emacsビルド時に実行されるようアレンジしま
す。

 -- Function: autoload function filename &optional docstring interactive
          type
     この関数は、FILENAMEから自動的にロードされるように、FUNCTIONという
     名前の関数(またはマクロ)を定義します。文字列FILENAMEのは、
     FUNCTIONの実際の定義を取得するファイルを指定します。

     FILENAMEがディレクトリー名とサフィックス‘.el’と‘.elc’のどちらも含ま
     ない場合、この関数はこれらの強制的にサフィックスを追加します。つま
     りサフィックスが追加されないただのFILENAMEという名前のファイルはロ
     ードされません。(変数‘load-suffixes’により要求される正確なサフィッ
     クスが指定されます。)

     引数DOCSTRINGは、その関数のドキュメント文字列です。‘autoload’の呼び
     出しでドキュメント文字列を指定することにより、その関数の実際の定義
     をロードせずにドキュメントを見ることが可能になります。この引数の値
     は通常、関数定義のドキュメント文字列と等しくあるべきです。もし等し
     くない場合は、その関数のドキュメント文字列がロード時に有効になりま
     す。

     INTERACTIVEが非‘nil’の場合、その関数はインタラクティブに呼び出すこ
     とが可能になります。これにより、FUNCTIONの実際の定義をロードせずに
     、‘M-x’による補完が機能するようになります。。ここでは、完全なインタ
     ラクティブ指定は与えられません。完全な指定はユーザーが実際に
     FUNCTIONを呼び出すまで必要ありません。実際にユーザーが呼び出したと
     きに、実際の定義がロードされます。

     普通の関数と同様、マクロおよびキーマップをオートロードできます。
     FUNCTIONが実際にはマクロの場合はTYPEに‘macro’を指定し、キーマップの
     場合にはTYPEに‘keymap’を指定します。Emacsのさまざまな部分は、実際の
     定義をロードせずに、これらの情報を知る必要があるのです。

     オートロードされたキーマップは、あるプレフィクスキーがシンボル
     FUNCTIONにバインドされているときにキーを探す間に、自動的にロードさ
     れます。そのキーマップにたいする他の類のアクセスでは、オートロード
     は発生しません。特に、Lispプログラムが変数の値からそのキーマップを
     取得して‘define-key’を呼び出した場合には、たとえその変数の名前がシ
     ンボルFUNCTIONと同じであっても、オートロードは起こりません。

     FUNCTIONが非voidのオートロードされたオブジェクトではない関数定義を
     もつ場合、その関数は何も行わず‘nil’をリターンします。それ以外は、オ
     ートロードされたオブジェクト(*note Autoload Type::を参照)を作成して
     、それをFUNCTIONにたいする関数定義として格納します。オートロードさ
     れたオブジェクトは、以下の形式をもちます:

          (autoload FILENAME DOCSTRING INTERACTIVE TYPE)

     たとえば、

          (symbol-function 'run-prolog)
               ⇒ (autoload "prolog" 169681 t nil)

     このような場合、‘"prolog"’はロードするファイルの名前、169681は
     ‘emacs/etc/DOC’ファイル(*note Documentation Basics::を参照)内のドキ
     ュメント文字列への参照で、‘t’はその関数がインタラクティブであり、
     ‘nil’はそれがマクロやキーマップでないことを意味します。

 -- Function: autoloadp object
     この関数は、OBJECTがオートロードされたオブジェクトの場合、非‘nil’を
     リターンします。たとえば、‘run-prolog’がオートロードされたオブジェ
     クトかチェックするには、以下を評価します

          (autoloadp (symbol-function 'run-prolog))

   オートロードされたファイルは、通常は他の定義を含み、1つ以上の機能を必
要あるいは提供するかもしれません。(内容の評価でのエラーにより)そのファイ
ルが完全にロードされていない場合、そのロードの間に行われた関数定義や
‘provide’の呼び出しはアンドゥされます。これは、このファイルからオートロ
ードされる関数にたいして再度呼び出しを試みたときに、そのファイルを確実に
再ロードさせるためです。このようにしないと、そのファイル内のいくつかの関
数はアボートしたロードにより定義されていて、それらはロードされなかった修
正後のファイルで提供される正しいサブルーチンを欠くため、正しく機能しない
からです。

   オートロードされたファイルが意図したLisp関数、またはマクロの定義に失
敗した場合には、データ‘"Autoloading failed to define function
FUNCTION-NAME"’とともにエラーがシグナルされます。

   オートロードのマジックコメント(“autoload cookie”とも呼ばれる)は、オー
トロード可能なソースファイル内の実際の定義の直前にある、
‘;;;###autoload’だけの行から構成されます。コマンド‘M-x
update-file-autoloads’は、対応する‘autoload’呼び出しを‘loaddefs.el’内に
書き込みます。(autoload cookieとなる文字列と、‘update-file-autoloads’に
より生成されるファイルの名前は、上述のデフォルトから変更可能です。以下を
参照。) Emacsのビルドでは‘loaddefs.el’をロードするために‘autoload’を呼び
出します。‘M-x update-directory-autoloads’は、より強力です。このコマンド
はカレントディレクトリー内のすべてのファイルにたいするオートロードを更新
します。

   このマジックコメントは、任意の種類のフォームを、‘loaddefs.el’内にコピ
ーできます。このマジックコメントに続くフォームは、そのままコピーされます
。しかしオートロード機能が特別に処理するフォームの場合は_除外_されます
(たとえば‘autoload’内への変換)。以下は、そのままコピーされないフォームで
す:

関数、または関数のようなオブジェクトにたいする定義:
     ‘defun’と‘defmacro’。‘cl-defun’と‘cl-defmacro’(*note (cl)Argument
     Lists::を参照)、および‘define-overloadable-function’
     (‘mode-local.el’内のコメントを参照)も該当

メジャーモードおよびマイナーモードにたいする定義:
     ‘define-minor-mode’、‘define-globalized-minor-mode’、
     ‘define-generic-mode’、‘define-derived-mode’、
     ‘easy-mmode-define-minor-mode’、‘easy-mmode-define-global-mode’、
     ‘define-compilation-mode’、‘define-global-minor-mode’。

その他のタイプの定義:
     ‘defcustom’、‘defgroup’、‘defclass’ (*note EIEIO: (eieio)Top.を参照
     )、および‘define-skeleton’ (‘skeleton.el’内のコメントを参照)。

   ビルド時に、そのファイル自身をロードするときにフォームを_実行しないよ
うに_、マジックコメントを使用することもできます。これを行なうには、マジ
ックコメントと同じ行にフォームを記述します。これはコメントなので、ソース
ファイルをロードするとき何も行いません。ただし‘M-x
update-file-autoloads’は、Emacsビルド時に実行されたものは、‘M-x
update-file-autoloads’にコピーします。

   以下は、マジックコメントによるオートロードのために‘doctor’を準備する
例です:

     ;;;###autoload
     (defun doctor ()
       "Switch to *doctor* buffer and start giving psychotherapy."
       (interactive)
       (switch-to-buffer "*doctor*")
       (doctor-mode))

これにより、以下が‘loaddefs.el’内に書き込まれます:

     (autoload (quote doctor) "doctor" "\
     Switch to *doctor* buffer and start giving psychotherapy.

     \(fn)" t nil)

ダブルクォートの直後のバックスラッシュまたは改行は、‘loaddefs.el’のよう
なプリロードされた未コンパイルだけに使用される慣習です。これは、
‘make-docfile’にたいして、ドキュメント文字列を‘etc/DOC’ファイルに配する
よう指示します。*note Building Emacs::を参照してください。また、
‘lib-src/make-docfile.c’内のコメントも参照してください。ドキュメント文字
列の使い方(usage part)の中の‘(fn)’は、種々のヘルプ関数(*note Help
Functions::を参照)が表示するとき、その関数の名前に置き換えられます。

   関数定義手法として既知ではなく、認められてもいないような、通常とは異
なるマクロにより関数定義を記述した場合、通常のオートロードのマジックコメ
ントの使用により、定義全体が‘loaddefs.el’内にコピーされるでしょう。これ
は期待した動作ではありません。かわりに以下を記述することにより、意図した
‘autoload’呼び出しを‘loaddefs.el’内に配することができます。

     ;;;###autoload (autoload 'foo "myfile")
     (mydefunmacro foo
       ...)

   autoload cookieとして、デフォルト以外の文字列を使用して、デフォルトの
‘loaddefs.el’とは異なるファイル内に、対応するオートロード呼び出しを記述
できます。これを制御するために、Emacsは2つの変数を提供します:

 -- Variable: generate-autoload-cookie
     この変数の値は、Lispコメントの文法に準じた文字列です。‘M-x
     update-file-autoloads’は、そのcookieの後のLispフォームを、cookieが
     生成したオートロードファイル内にコピーします。この変数のデフォルト
     値は、‘";;;###autoload"’です。

 -- Variable: generated-autoload-file
     この変数の値は、オートロード呼び出しが書き込まれるEmacs Lispファイ
     ルを命名します。デフォルト値は‘loaddefs.el’ですが、(たとえば‘.el’フ
     ァイル内のセクション“Local Variables”))をオーバーライドできます。オ
     ートロードファイルは、フォームフィード文字で開始される終端を含んで
     いると仮定されます。

   以下の関数は、オートロードオブジェクトにより指定されたライブラリーを
明示的にロードするために使用されるかもしれません:

 -- Function: autoload-do-load autoload &optional name macro-only
     この関数はオートロードオブジェクトAUTOLOADにより指定されたロードを
     処理します。オプション引数NAMEに非‘nil’を指定する場合は、関数値が
     AUTOLOADとなるシンボルを指定します。この場合、この関数のリターン値
     は、そのシンボルの新しい関数値になります。オプション引数
     MACRO-ONLYの値が‘macro’の場合、この関数は関数ではなくマクロのロード
     だけを有効にします。

