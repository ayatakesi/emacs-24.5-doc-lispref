This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Autoload,  Next: Repeated Loading,  Prev: Loading Non-ASCII,  Up: Loading

15.5 Autoload
=============

“オートロード(autoload: 自動ロード)”の機能により、定義さ
れているファイルをロードすることなく、関数やマクロの存在
を登録できます。関数の最初の呼び出しで、実際の定義および
その他の関連するコードをインストールするために適切なライ
ブラリーを自動的にロードし、すべてがすでにロードされてい
たかのように、実際の定義を実行します。関数やマクロのドキ
ュメントを参照することによっても、オートロードが発生しま
す(*note Documentation Basics::を参照)。

   オートロードされた関数をセットアップするには、2つの方
法があります。それは‘autoload’を呼び出す方法と、ソースの
実際の定義の前に、特別な“マジック”コメントを記述する方法
です。‘autoload’はオートロードのための低レベルのプリミテ
ィブです。任意のLispプログラムが、任意のときに
‘autoload’を呼び出すことができます。Emacsととみにインス
トールされるパッケージにとって、マジックコメントは関数を
オートロードできるようににするための一番便利な方法です。
コメント自身は何も行いませんが、コマンド
‘update-file-autoloads’にたいするガイドを努めます。この
コマンドは‘autoload’の呼び出しを構築し、Emacsビルド時に
実行されるようアレンジします。

 -- Function: autoload function filename &optional
          docstring interactive type
     この関数は、FILENAMEから自動的にロードされるように
     、FUNCTIONという名前の関数(またはマクロ)を定義しま
     す。文字列FILENAMEのは、FUNCTIONの実際の定義を取得
     するファイルを指定します。

     FILENAMEがディレクトリー名とサフィックス‘.el’と
     ‘.elc’のどちらも含まない場合、この関数はこれらの強
     制的にサフィックスを追加します。つまりサフィックス
     が追加されないただのFILENAMEという名前のファイルは
     ロードされません。(変数‘load-suffixes’により要求さ
     れる正確なサフィックスが指定されます。)

     引数DOCSTRINGは、その関数のドキュメント文字列です。
     ‘autoload’の呼び出しでドキュメント文字列を指定する
     ことにより、その関数の実際の定義をロードせずにドキ
     ュメントを見ることが可能になります。この引数の値は
     通常、関数定義のドキュメント文字列と等しくあるべき
     です。もし等しくない場合は、その関数のドキュメント
     文字列がロード時に有効になります。

     INTERACTIVEが非‘nil’の場合、その関数はインタラクテ
     ィブに呼び出すことが可能になります。これにより、
     FUNCTIONの実際の定義をロードせずに、‘M-x’による補完
     が機能するようになります。。ここでは、完全なインタ
     ラクティブ指定は与えられません。完全な指定はユーザ
     ーが実際にFUNCTIONを呼び出すまで必要ありません。実
     際にユーザーが呼び出したときに、実際の定義がロード
     されます。

     普通の関数と同様、マクロおよびキーマップをオートロ
     ードできます。FUNCTIONが実際にはマクロの場合は
     TYPEに‘macro’を指定し、キーマップの場合にはTYPEに
     ‘keymap’を指定します。Emacsのさまざまな部分は、実際
     の定義をロードせずに、これらの情報を知る必要がある
     のです。

     オートロードされたキーマップは、あるプレフィクスキ
     ーがシンボルFUNCTIONにバインドされているときにキー
     を探す間に、自動的にロードされます。そのキーマップ
     にたいする他の類のアクセスでは、オートロードは発生
     しません。特に、Lispプログラムが変数の値からそのキ
     ーマップを取得して‘define-key’を呼び出した場合には
     、たとえその変数の名前がシンボルFUNCTIONと同じであ
     っても、オートロードは起こりません。

     FUNCTIONが非voidのオートロードされたオブジェクトで
     はない関数定義をもつ場合、その関数は何も行わず
     ‘nil’をリターンします。それ以外は、オートロードされ
     たオブジェクト(*note Autoload Type::を参照)を作成し
     て、それをFUNCTIONにたいする関数定義として格納しま
     す。オートロードされたオブジェクトは、以下の形式を
     もちます:

          (autoload FILENAME DOCSTRING INTERACTIVE TYPE)

     たとえば、

          (symbol-function 'run-prolog)
               ⇒ (autoload "prolog" 169681 t nil)

     このような場合、‘"prolog"’はロードするファイルの名
     前、169681は‘emacs/etc/DOC’ファイル(*note
     Documentation Basics::を参照)内のドキュメント文字列
     への参照で、‘t’はその関数がインタラクティブであり、
     ‘nil’はそれがマクロやキーマップでないことを意味しま
     す。

 -- Function: autoloadp object
     この関数は、OBJECTがオートロードされたオブジェクト
     の場合、非‘nil’をリターンします。たとえば、
     ‘run-prolog’がオートロードされたオブジェクトかチェ
     ックするには、以下を評価します

          (autoloadp (symbol-function 'run-prolog))

   オートロードされたファイルは、通常は他の定義を含み、
1つ以上の機能を必要あるいは提供するかもしれません。(内容
の評価でのエラーにより)そのファイルが完全にロードされて
いない場合、そのロードの間に行われた関数定義や
‘provide’の呼び出しはアンドゥされます。これは、このファ
イルからオートロードされる関数にたいして再度呼び出しを試
みたときに、そのファイルを確実に再ロードさせるためです。
このようにしないと、そのファイル内のいくつかの関数はアボ
ートしたロードにより定義されていて、それらはロードされな
かった修正後のファイルで提供される正しいサブルーチンを欠
くため、正しく機能しないからです。

   オートロードされたファイルが意図したLisp関数、または
マクロの定義に失敗した場合には、データ‘"Autoloading
failed to define function FUNCTION-NAME"’とともにエラー
がシグナルされます。

   オートロードのマジックコメント(“autoload cookie”とも
呼ばれる)は、オートロード可能なソースファイル内の実際の
定義の直前にある、‘;;;###autoload’だけの行から構成されま
す。コマンド‘M-x update-file-autoloads’は、対応する
‘autoload’呼び出しを‘loaddefs.el’内に書き込みます。
(autoload cookieとなる文字列と、
‘update-file-autoloads’により生成されるファイルの名前は
、上述のデフォルトから変更可能です。以下を参照。) Emacsの
ビルドでは‘loaddefs.el’をロードするために‘autoload’を呼
び出します。‘M-x update-directory-autoloads’は、より強力
です。このコマンドはカレントディレクトリー内のすべてのフ
ァイルにたいするオートロードを更新します。

   このマジックコメントは、任意の種類のフォームを、
‘loaddefs.el’内にコピーできます。このマジックコメントに
続くフォームは、そのままコピーされます。しかしオートロー
ド機能が特別に処理するフォームの場合は_除外_されます(た
とえば‘autoload’内への変換)。以下は、そのままコピーされ
ないフォームです:

関数、または関数のようなオブジェクトにたいする定義:
     ‘defun’と‘defmacro’。‘cl-defun’と
     ‘cl-defmacro’(*note (cl)Argument Lists::を参照)、お
     よび‘define-overloadable-function’
     (‘mode-local.el’内のコメントを参照)も該当

メジャーモードおよびマイナーモードにたいする定義:
     ‘define-minor-mode’、
     ‘define-globalized-minor-mode’、
     ‘define-generic-mode’、‘define-derived-mode’、
     ‘easy-mmode-define-minor-mode’、
     ‘easy-mmode-define-global-mode’、
     ‘define-compilation-mode’、
     ‘define-global-minor-mode’。

その他のタイプの定義:
     ‘defcustom’、‘defgroup’、‘defclass’ (*note EIEIO:
     (eieio)Top.を参照)、および‘define-skeleton’
     (‘skeleton.el’内のコメントを参照)。

   ビルド時に、そのファイル自身をロードするときにフォー
ムを_実行しないように_、マジックコメントを使用することも
できます。これを行なうには、マジックコメントと同じ行にフ
ォームを記述します。これはコメントなので、ソースファイル
をロードするとき何も行いません。ただし‘M-x
update-file-autoloads’は、Emacsビルド時に実行されたもの
は、‘M-x update-file-autoloads’にコピーします。

   以下は、マジックコメントによるオートロードのために
‘doctor’を準備する例です:

     ;;;###autoload
     (defun doctor ()
       "Switch to *doctor* buffer and start giving psychotherapy."
       (interactive)
       (switch-to-buffer "*doctor*")
       (doctor-mode))

これにより、以下が‘loaddefs.el’内に書き込まれます:

     (autoload (quote doctor) "doctor" "\
     Switch to *doctor* buffer and start giving psychotherapy.

     \(fn)" t nil)

ダブルクォートの直後のバックスラッシュまたは改行は、
‘loaddefs.el’のようなプリロードされた未コンパイルだけに
使用される慣習です。これは、‘make-docfile’にたいして、ド
キュメント文字列を‘etc/DOC’ファイルに配するよう指示しま
す。*note Building Emacs::を参照してください。また、
‘lib-src/make-docfile.c’内のコメントも参照してください。
ドキュメント文字列の使い方(usage part)の中の‘(fn)’は、種
々のヘルプ関数(*note Help Functions::を参照)が表示すると
き、その関数の名前に置き換えられます。

   関数定義手法として既知ではなく、認められてもいないよ
うな、通常とは異なるマクロにより関数定義を記述した場合、
通常のオートロードのマジックコメントの使用により、定義全
体が‘loaddefs.el’内にコピーされるでしょう。これは期待し
た動作ではありません。かわりに以下を記述することにより、
意図した‘autoload’呼び出しを‘loaddefs.el’内に配すること
ができます。

     ;;;###autoload (autoload 'foo "myfile")
     (mydefunmacro foo
       ...)

   autoload cookieとして、デフォルト以外の文字列を使用し
て、デフォルトの‘loaddefs.el’とは異なるファイル内に、対
応するオートロード呼び出しを記述できます。これを制御する
ために、Emacsは2つの変数を提供します:

 -- Variable: generate-autoload-cookie
     この変数の値は、Lispコメントの文法に準じた文字列で
     す。‘M-x update-file-autoloads’は、そのcookieの後の
     Lispフォームを、cookieが生成したオートロードファイ
     ル内にコピーします。この変数のデフォルト値は、
     ‘";;;###autoload"’です。

 -- Variable: generated-autoload-file
     この変数の値は、オートロード呼び出しが書き込まれる
     Emacs Lispファイルを命名します。デフォルト値は
     ‘loaddefs.el’ですが、(たとえば‘.el’ファイル内のセク
     ション“Local Variables”))をオーバーライドできます。
     オートロードファイルは、フォームフィード文字で開始
     される終端を含んでいると仮定されます。

   以下の関数は、オートロードオブジェクトにより指定され
たライブラリーを明示的にロードするために使用されるかもし
れません:

 -- Function: autoload-do-load autoload &optional name
          macro-only
     この関数はオートロードオブジェクトAUTOLOADにより指
     定されたロードを処理します。オプション引数NAMEに非
     ‘nil’を指定する場合は、関数値がAUTOLOADとなるシンボ
     ルを指定します。この場合、この関数のリターン値は、
     そのシンボルの新しい関数値になります。オプション引
     数MACRO-ONLYの値が‘macro’の場合、この関数は関数では
     なくマクロのロードだけを有効にします。


File: elisp,  Node: Repeated Loading,  Next: Named Features,  Prev: Autoload,  Up: Loading

15.6 Repeated Loading
=====================

1つのEmacsセッション内で、ファイルを複数回ロードできます
。たとえば、バッファーで関数定義を編集して再インストール
した後に、元のバージョンに戻したいときがあるかもしれませ
ん。これは、元のファイルをリロードすることにより行なうこ
とができます。

   ファイルをロードまたはリロードするとき、‘load’および
‘load-library’関数は未コンパイルのファイルではなく、バイ
トコンパイルされた同名のファイルを自動的にロードすること
に留意してください。ファイルを再記述して保存後に再インス
トールする場合には、新しいバージョンをバイトコンパイルす
る必要があります。さもないと、Emacsは新しいソースではな
く、古いバイトコンパイルされたファイルをロードしてしまう
でしょう! その場合には、ファイルロード時に表示されるメッ
セージに、そのファイルのリコンパイルを促す‘(compiled;
note, source is newer)’というメッセージが含まれます。

   Lispライブラリーファイル内にフォームを記述するときは
、そのファイルが複数回ロードされるかもしれないことに留意
してください。たとえば、そのライブラリーをリロードすると
きには、各変数が最初期化されるべきかどうか考慮してくださ
い。。変数がすでに初期化されている場合、‘defvar’はその変
数の値を変更しません(*note Defining Variables::を参照)。

   alistに要素を追加するもっともシンプルな方法は、以下の
ようなものでしょう:

     (push '(leif-mode " Leif") minor-mode-alist)

しかし、これはそのライブラリーがリロードされた場合は、複
数の要素を追加してしまうでしょう。この問題を避けるには、
‘add-to-list’(*note List Variables::を参照)を使用します:

     (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   時には、ライブラリーが既にロード済みか、明示的にテス
トしたいときがあるでしょう。そのライブラリーが
‘provide’を使用して名前付きフィーチャ(named feature)を提
供する場合は、‘featurep’を使用して前に‘provide’が実行さ
れているかテストすることができます。かわりに、以下のよう
にすることもできます:

     (defvar foo-was-loaded nil)

     (unless foo-was-loaded
       EXECUTE-FIRST-TIME-ONLY
       (setq foo-was-loaded t))



File: elisp,  Node: Named Features,  Next: Where Defined,  Prev: Repeated Loading,  Up: Loading

15.7 Features
=============

‘provide’と‘require’は、‘autoload’にかわるファイルを自動
的にロードする関数です。これらは名前付きの“フィーチャ
(feature: 機能)”という面で機能します。オートロードは特定
の関数の呼び出しをトリガーにしますが、フィーチャーは最初
は他のプログラムが名前により問い合わせたときにロードされ
ます。

   フィーチャ名とは、関数、変数などのコレクションを表す
シンボルです。これらを定義するファイルは、そのフィーチャ
を“プロバイド(provide: 提供)”すべきです。これらのフィー
チャを使用する他のプログラムは、その機能を“リクワイア
(require: 要求)”することにより、それらが定義されているか
確認できるでしょう。これは、定義がまだロードされていなけ
れば、定義ファイルをロードします。

   フィーチャをリクワイアするには、フィーチャ名を引数と
して‘require’を呼び出します。‘require’は、意図する機能が
すでにプロバイドされているか確認するために、グローバル変
数‘features’を調べます。もしプロバイドされていなければ、
適切なファイルからそのフィーチャをロードします。このファ
イルは、そのフィーチャを‘features’に追加するために、トッ
プレベルで‘provide’を呼び出すべきです。これに失敗すると
、‘require’はエラーをシグナルします。

   たとえば、‘idlwave.el’内の
‘idlwave-complete-filename’にたいする定義には、以下のコ
ードが含まれます:

     (defun idlwave-complete-filename ()
       "Use the comint stuff to complete a file name."
        (require 'comint)
        (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
               (comint-completion-addsuffix nil)
               ...)
            (comint-dynamic-complete-filename)))

式‘(require 'comint)’は、‘comint.el’がまだロードされてい
なければ、‘comint-dynamic-complete-filename’が確実に定義
されるように、そのファイルをロードします。フィーチャは通
常、それらを提供するファイルにしたがって命名されるため、
‘require’にファイル名を与える必要はありません。
(‘require’命令文が‘let’のボディーの外側にあるのが重要な
ことに注意してください。変数がletバインドされているライ
ブラリーをロードすることにより、意図せぬ結果、つまり
letをexitした後にその変数がアンバインドされます。)

   ‘comint.el’には以下のトップレベル式が含まれます:

     (provide 'comint)

これは‘comint’はグローバルなリスト‘features’に追加するの
で、‘(require 'comint)’は今後何も行う必要がないことを知
ることができます。

   ファイルのトップレベル‘require’が使用されたときは、そ
れをロードしたときと同様、そのファイルをバイトコンパイル
(*note Byte Compilation::を参照)したときにも効果が表れま
す。これはリクワイアされたパッケージがマクロを含み、バイ
トコンパイラーがそれを知らなければならない場合です。これ
は‘require’によりロードされるファイルで定義される関数と
変数にたいするバイトコンパイラーの警告も無効にします。

   バイトコンパイルの間にトップレベルの‘require’が評価さ
れるとしても、‘provide’呼び出しは評価されません。したが
って、以下の例のように‘provide’の後に同じ機能にたいする
‘require’を含めることにより、バイトコンパイル前に定義し
ているファイルを確実にロードできます。

     (provide 'my-feature)  ; バイトコンパイラーには無視され、
                            ;   ‘load’には評価される。
     (require 'my-feature)  ; バイトコンパイラーにより評価される。

コンパイラーは‘provide’を無視して、その後に対象のファイ
ルをロードすることにより‘require’が処理されます。ファイ
ルのロードは‘provide’呼び出しを実行するので、後続の
‘require’はファイルがロードされているときは何も行いませ
ん。

 -- Function: provide feature &optional subfeatures
     この関数は、カレントEmacsセッションにFEATUREがロー
     ドされた、あるいはロードされつつあることをアナウン
     スします。これは、FEATUREに関連する機能が他のLispプ
     ログラムから利用可能できる、あるいは利用可能になる
     ことを意味します。

     ‘provide’を呼び出すことによる直接的な効果は、まだ
     FEATUREがFEATURES内に存在しない場合はリストの先頭に
     追加して、それを必要としている‘eval-after-load’コー
     ドを呼び出します(*note Hooks for Loading::を参照)。
     引数FEATUREはシンボルでなければなりません。
     ‘provide’はFEATUREをリターンします。

     SUBFEATURESが与えられた場合、それはFEATUREの当該バ
     ージョンによりプロバイドされる特定のサブフィーチャ
     のセットを示すシンボルのリストであるべきです。
     ‘featurep’を使用して、サブフィーチャの存在をテスト
     できます。あるパッケージの、ロードされるか、あるい
     はそのバージョンに存在するか不明なさまざまな部分や
     機能に名前を与えて使いやすくするには、そのパッケー
     ジが複雑すぎるときにサブフィーチャを使用するという
     のがサブフィーチャというアイデアです。例としては、
     *note Network Feature Testing::を参照してください。

          features
               ⇒ (bar bish)

          (provide 'foo)
               ⇒ foo
          features
               ⇒ (foo bar bish)

     オートロードによりあるファイルがロードされて、その
     内容の評価エラーによりストップいたとき、そのロード
     の間に発生した関数定義や‘provide’呼び出しはアンドゥ
     されます。*note Autoload::を参照してください。

 -- Function: require feature &optional filename noerror
     この関数はカレントEmacsセッションにおいて、
     FEATUREが存在するかどうかを、(‘(featurep FEATURE)’を
     使用して。以下を参照)をチェックします。引数
     FEATUREはシンボルでなければなりません。

     そのフィーチャが存在しない場合、‘require’は‘load’に
     よりFILENAMEをロードします。FILENAMEが与えられなか
     った場合は、シンボルFEATUREの名前がロードするファイ
     ル名のベースとして使用されます。しかしこの場合、
     ‘require’はFEATUREを探すためにサフィックス‘.el’およ
     び‘.elc’の追加を強制します(圧縮ファイルのサフィック
     スに拡張されるかもしれません)。名前がただの
     FEATUREというファイルは使用されません。(変数
     ‘load-suffixes’は要求されるLispサフィックスを正確に
     指定します。)

     NOERRORが非‘nil’の場合は、ファイルの実際のロードに
     おけるエラーを抑止します。この場合、そのファイルの
     ロードが失敗すると、‘require’は‘nil’をリターンしま
     す。通常では、‘require’はFEATUREをリターンします。

     ファイルのロードは成功したがFEATUREをプロバイドして
     いない場合、‘require’は‘Required feature FEATURE
     was not provided’のようにエラーをシグナルします。

 -- Function: featurep feature &optional subfeature
     この関数は、カレントEmacsセッションFEATUREがプロバ
     イドされている場合(たとえばFEATURE‘features’のメン
     バーの場合)は‘t’をリターンします。SUBFEATUREが非
     ‘nil’の場合、この関数はサブフィーチャも同様にプロバ
     イドされているとき(たとえばSUBFEATUREがシンボル
     FEATUREのプロパティ‘subfeature’のメンバーのとき)だ
     け‘t’をリターンします。

 -- Variable: features
     この変数の値はシンボルのリストで、このシンボルはカ
     レントEmacsセッションにロードされたフィーチャです。
     シンボルはそれぞれ‘provide’を呼び出すことにより、こ
     のリストにputされたものです。リスト‘features’内の要
     素の順番に意味はありません。


File: elisp,  Node: Where Defined,  Next: Unloading,  Prev: Named Features,  Up: Loading

15.8 Which File Defined a Certain Symbol
========================================

 -- Function: symbol-file symbol &optional type
     この関数は、SYMBOLを定義しているファイルの名前をリ
     ターンします。TYPEが‘nil’の場合は、どのようなタイプ
     の定義も受け入れられます。TYPEが‘defun’の場合は関数
     定義、‘defvar’は変数定義、‘defface’はフェイス定義だ
     けを指定します。

     値は通常、絶対ファイル名です。定義がどのファイルに
     も関係しないときは、‘nil’になることもあります。
     SYMBOLがオートロード関数を指定する場合、値が拡張子
     なしの相対ファイル名になることもあります。

   ‘symbol-file’は変数‘load-history’.<の値にもとづいてい
ます。

 -- Variable: load-history
     この変数の値は、ロードされたライブラリーファイルの
     名前を、それらが定義する関数と変数の名前、およびそ
     れらがプロバイドまたはリクワイアするフィーチャに関
     連付けるalistです。

     このalist内の各要素は、1つのロード済みライブラリー
     (スタートアップ時にプリロードされたライブラリーを含
     む)を記述します。要素はCARがライブラリーの絶対ファ
     イル名(文字列)のリストです。残りのリスト要素は、以
     下の形式です:

     ‘VAR’
          シンボルVARが変数として定義された。
     ‘(defun . FUN)’
          関数FUNが定義された。
     ‘(t . FUN)’
          関数FUNは、このライブラリーがそれを関数として
          再定義する前はオートロードとして定義されていた
          。後続の要素は常に‘(defun . FUN)’で、これは
          FUNを関数として定義する。
     ‘(autoload . FUN)’
          関数FUNはオートロードとして定義された。
     ‘(defface . FACE)’
          フェイスFACEが定義された。
     ‘(require . FEATURE)’
          フィーチャFEATUREがリクワイアされた。
     ‘(provide . FEATURE)’
          フィーチャFEATUREがプロバイドされた。

     ‘load-history’の値には、CARが‘nil’の要素が1つ含まれ
     るかもしれません。この要素は、ファイルをvisitしてい
     ないバッファーでの‘eval-buffer’で作成された定義を記
     述します。

   コマンド‘eval-region’は‘load-history’を更新しますが、
要素を置き換えずに、visitされているファイルの要素にたい
して定義されたシンボルを追加します。*note Eval::を参照し
てください。


File: elisp,  Node: Unloading,  Next: Hooks for Loading,  Prev: Where Defined,  Up: Loading

15.9 Unloading
==============

他のLispオブジェクト用にメモリーを回収するために、ライブ
ラリーによりロードされた関数や変数を破棄することができま
す。これを行うには、関数‘unload-feature’を使用します:

 -- Command: unload-feature feature &optional force
     このコマンドはフィーチャFEATUREをプロバイドしていた
     ライブラリーをアンロードします。そのライブラリー内
     の‘defun’、‘defalias’、‘defsubst’、‘defmacro’、
     ‘defconst’、‘defvar’、‘defcustom’により定義されたす
     べての関数、マクロ、変数は未定義になります。その後
     、それらのシンボルにたいして事前に関連付けられてい
     たオートロードをリストアします。(ロードはシンボルの
     ‘autoload’プロパティにこれらを保存しています。)

     以前の定義をリストアする前に、特定のフックからその
     ライブラリー内の関数を取り除くために、
     ‘unload-feature’は‘remove-hook’を実行します。これら
     のフックには、名前が‘-hook’(または廃止されたサフィ
     ックス‘-hooks’)で終わる変数、加えて
     ‘unload-feature-special-hooks’、同様に
     ‘auto-mode-alist’にリストされた変数も含まれます。こ
     れは、重要なフックがすでに定義されていない関数を参
     照をすることにより、Emacsの機能が停止することを防ぐ
     ためです。

     標準的なアンロードアクティビティは、そのライブラリ
     ー内の関数のELPプロファイリングを取り消し、そのライ
     ブラリーによりプロバイドされたフィーチャを取り消し
     、そのライブラリーで定義された変数に保持されたタイ
     マーも取り消します。

     これらの基準が機能不全を防ぐのに十分でない場合、ラ
     イブラリーは‘FEATURE-unload-function’という名前の明
     示的なアンローダーを定義できます。そのシンボルが関
     数として定義された場合、‘unload-feature’は何かを行
     う前にまず引数なしでそれを呼び出します。これはライ
     ブラリーをアンロードしるために適切なすべてのことを
     行うことができます。これが‘nil’をリターンした場合、
     ‘unload-feature’は通常のアンロードアクションを処理
     します。それ以外は、アンロード処理は完了したとみな
     します。

     ‘unload-feature’は通常、他のライブラリーが依存する
     ライブラリーのアンロードを拒絶します。(ライブラリー
     Bにたいする‘require’がライブラリーAに含まれる場合、
     AはBに依存します。)オプション引数FORCEが非‘nil’の場
     合、依存関係は無視され、どのようなライブラリーもア
     ンロードできます。

   ‘unload-feature’関数はLispで記述されており、その動作
は変数‘load-history’にもとづきます。

 -- Variable: unload-feature-special-hooks
     この変数には、ライブラリー内で定義された関数を取り
     除くために、ライブラリーをアンロードする前にスキャ
     ンされるフックのリストが保持されています。


File: elisp,  Node: Hooks for Loading,  Prev: Unloading,  Up: Loading

15.10 Hooks for Loading
=======================

変数‘after-load-functions’を使用することにより、Emacsが
ライブラリーをロードするたびにコードを実行させることがで
きます:

 -- Variable: after-load-functions
     このアブノーマルフック(abnormal hook)は、ファイルを
     ロードした後に実行されます。フック内の各関数は1つの
     引数(ロードされたファイルの絶対ファイル名)で呼び出
     されます。

   _特定_のライブラリーがロードされた後にコードを実行し
たい場合は、マクロ‘with-eval-after-load’を使用します:

 -- Macro: with-eval-after-load library body...
     このマクロはLIBRARYがロードされるたびに、ファイル
     LIBRARYのロードの最後でBODYが評価されるよう準備しま
     す。LIBRARYがすでにロード済みの場合は、即座にBODYを
     評価します。

     ファイル名LIBRARYにディレクトリーや拡張子を与える必
     要はありません。通常は以下のようにファイル名だけを
     与えます:

          (with-eval-after-load "edebug" (def-edebug-spec c-point t))

     どのファイルが評価をトリガーできるか制限するには、
     ディレクトリーか拡張子、またはしの両方をLIBRARYに含
     めます。実際のファイル名(たとえばすべてのシンボリッ
     クリンク名は除外される)が、与えられた名前すべてにマ
     ッチするファイルだけが、マッチします。以下の例では
     、どこかのディレクトリー‘..../foo/bar’にある
     ‘my_inst.elc’や‘my_inst.elc.gz’は評価をトリガーしま
     すが、‘my_inst.el’は異なります。:

          (with-eval-after-load "foo/bar/my_inst.elc" ...)

     LIBRARYはフィーチャ(たとえばシンボル)でもよく、その
     場合‘(provide LIBRARY)’を呼び出す任意のファイルの最
     後にBODYが評価されます。

     BODY内のエラーはロードをアンドゥしませんが、BODYの
     残りの実行を妨げます。

   上手く設計されたLispプログラムは通常、
‘eval-after-load’を使用するべきではありません。(外部から
の使用を意図した)他のライブラリーで定義された変数を調べ
たりセットする必要がある場合、それは即座に行うことができ
ます −−− そのライブラリーがロードされるのを待つ必要はあ
りません。そのライブラリーで定義された関数を呼び出す必要
がある場合は、そのライブラリーをロードすべきで、それには
‘require’(*note Named Features::を参照)が適しています。


File: elisp,  Node: Byte Compilation,  Next: Debugging,  Prev: Loading,  Up: Top

16 Byte Compilation
*******************

Emacs Lispには、Lispで記述された関数を、より効率的に実行
できる“バイトコード(byte-code)”と呼ばれる特別な表現に翻
訳する“コンパイラー(compiler)”があります。コンパイラーは
Lispの関数定義をバイトコードに置き換えます。バイトコード
関数が呼び出されたとき、その定義は“バイトコードインター
プリター(byte-code interpreter)”により評価されます。

   バイトコンパイルされたコードは、(本当のコンパイル済み
コードのように)そのマシンのハードウェアにより直接実行さ
れるのではなく、バイトコンパイラーにより評価されるため、
バイトコードはリコンパイルしなくてもマシン間での完全な可
搬性を有します。しかし、本当にコンパイルされたコードほど
高速ではありません。

   一般的に、任意のバージョンのEmacsはそれ以前のバージョ
ンのEmacsにより生成されたバイトコンパイル済みコードを実
行できますが、逆は成り立ちません。

   あるLispファイルを常にコンパイルせずに実行したい場合
は、以下のように‘no-byte-compile’にバインドするファイル
ローカル変数を配します:

     ;; -*-no-byte-compile: t; -*-

* Menu:

* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル;
                               バイトコードの読み方。


File: elisp,  Node: Speed of Byte-Code,  Next: Compilation Functions,  Up: Byte Compilation

16.1 Performance of Byte-Compiled Code
======================================

バイトコンパイルされた関数はCで記述されたプリミティブ関
数ほど効率的ではありませんがLispで記述されたバージョンよ
りは高速に実行されます。以下は例です:

     (defun silly-loop (n)
       "Return the time, in seconds, to run N iterations of a loop."
       (let ((t1 (float-time)))
         (while (> (setq n (1- n)) 0))
         (- (float-time) t1)))
     ⇒ silly-loop

     (silly-loop 50000000)
     ⇒ 10.235304117202759

     (byte-compile 'silly-loop)
     ⇒ [コンパイルされたコードは表示されない]

     (silly-loop 50000000)
     ⇒ 3.705854892730713

   この例では、インタープリターによる実行には10秒を要し
ますが、バイトコンパイルされたコードは4秒未満です。これ
は典型的な結果例ですが、実際の結果はさまざまでしょう。


File: elisp,  Node: Compilation Functions,  Next: Docs and Compilation,  Prev: Speed of Byte-Code,  Up: Byte Compilation

16.2 Byte-Compilation Functions
===============================

‘byte-compile’により、関数やマクロを個別にバイトコンパイ
ルできます。‘byte-compile-file’でファイル全体、
‘byte-recompile-directory’または‘batch-byte-compile’で複
数ファイルをコンパイルできます。

   バイトコンパイラーが警告、および/またはエラーメッセー
ジを生成することもあります(詳細は*note Compiler
Errors::を参照)。これらのメッセージはCompilationモードが
使用する‘*Compile-Log*’と呼ばれるバッファーに記録されま
す。*note (emacs)Compilation Mode::を参照してください。

   バイトコンパイルを意図したファイル内にマクロ呼び出し
を記述する際は、注意が必要です。マクロ呼び出しはコンパイ
ル時に展開されるので、そのマクロはEmacsにロードされる必
要があります(さもないとバイトコンパイラーは正しく処理し
ないでしょう)。これを処理する通常の方法は、必要なマクロ
定義を含むファイルを‘require’フォームで指定することです
。バイトコンパイラーは通常、コンパイルするコードを評価し
ませんが、‘require’フォームは指定されたライブラリーをロ
ードすることにより特別に扱われます。誰かがコンパイルされ
たプログラムを_実行_する際に、マクロ定義ファイルのロード
を回避するには、‘require’呼び出しの周囲に
‘eval-when-compile’を記述します(*note Eval During
Compile::を参照)。詳細は*note Compiling Macros::を参照し
てください。

   インライン(‘defsubst’)の関数は、これほど面倒ではあり
ません。定義が判明する前にそのような関数呼び出しをコンパ
イルした場合でも、その呼び出しは低速になるだけで、正しく
機能するでしょう。

 -- Function: byte-compile symbol
     この関数はSYMBOLの関数定義をバイトコンパイルして、
     以前の定義をコンパイルされた定義に置き換えます。
     SYMBOLの関数定義は、その関数にたいする実際のコード
     でなければなりません。‘byte-compile’はインダイレク
     ト関数を処理しません。リターン値は、SYMBOLのコンパ
     イルされた定義であるバイトコード関数ブジェクトです
     (*note Byte-Code Objects::を参照)。

          (defun factorial (integer)
            "INTEGERの階乗を計算する。"
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
          ⇒ factorial

          (byte-compile 'factorial)
          ⇒
          #[(integer)
            "^H\301U\203^H^@\301\207\302^H\303^HS!\"\207"
            [integer 1 * factorial]
            4 "Compute factorial of INTEGER."]

     SYMBOLの定義がバイトコード関数オブジェクトの場合、
     ‘byte-compile’は何も行わず‘nil’をリターンします。そ
     のシンボルの関数セル内の(コンパイルされていない)オ
     リジナルのコードはすでにバイトコンパイルされたコー
     ドに置き換えられているので、“シンボルの定義の再コン
     パイル”はしません。

     ‘byte-compile’の引数として‘lambda’式も指定できます
     。この場合、関数は対応するコンパイル済みコードをリ
     ターンしますが、それはどこにも格納されません。

 -- Command: compile-defun &optional arg
     このコマンドはポイントを含むdefunを読み取りそれをコ
     ンパイルして、結果を評価します。実際に関数定義であ
     るようなdefunでこれを使用した場合は、その関数のコン
     パイル済みバージョンをインストールする効果がありま
     す。

     ‘compile-defun’は通常、評価した結果をエコーエリアに
     表示しますが、ARGが非‘nil’の場合は、そのフォームを
     コンパイルした後にカレントバッファーに結果を挿入し
     ます。

 -- Command: byte-compile-file filename &optional load
     この関数はFILENAMEという名前のLispコードファイルを
     、バイトコードのファイルにコンパイルします。出力と
     なるファイルの名前は、サフィックス‘.el’を‘.elc’に変
     更することにより作成されます。FILENAMEが‘.el’で終了
     しない場合は、‘.elc’をFILENAMEの最後に付け足します
     。

     コンパイルは入力ファイルから1つのフォームを逐次読み
     取ることにより機能します。フォームが関数またはマク
     ロの場合は、コンパイル済みの関数またはマクロが書き
     込まれます。それ以外のフォームはまとめられて、まと
     められたものごとにコンパイルされ、そのファイルが読
     まれたとき実行されるようにコンパイルされたコードが
     書き込まれます。入力ファイルを読み取る際、すべての
     コメントは無視されます。

     このコマンドはエラーのないときは‘t’、それ以外は
     ‘nil’をリターンします。インタラクティブに呼び出され
     たときは、ファイル名の入力をもとめます。

     LOADが非‘nil’の場合、このコマンドはコンパイルした後
     にコンパイルされたファイルをロードします。インタラ
     クティブに呼び出された場合、LOADはプレフィクス引数
     です。

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el

          (byte-compile-file "~/emacs/push.el")
               ⇒ t

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
          -rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc

 -- Command: byte-recompile-directory directory
          &optional flag force
     このコマンドは、DIRECTORY(またはそのサブディレクト
     リー)内の、リコンパイルを要するすべての‘.el’ファイ
     ルをリコンパイルします。‘.elc’ファイルが存在し、そ
     れが‘.el’より古いファイルは、リコンパイルが必要です
     。

     ‘.el’ファイルに対応する‘.elc’ファイルが存在しない場
     合、何を行うかをFLAGで指定します。‘nil’の場合、この
     コマンドはこれらのファイルを無視します。FLAGが0のと
     きは、それらをコンパイルします。‘nil’と0以外の場合
     は、それらのファイルをコンパイルするかユーザーに尋
     ね、同様にそれぞれのサブディレクトリーについても尋
     ねます。

     インタラクティブに呼び出された場合、
     ‘byte-recompile-directory’はDIRECTORYの入力を求め、
     FLAGはプレフィクス引数になります。

     FORCEが非‘nil’の場合、このコマンドは‘.elc’ファイル
     のあるすべての‘.el’ファイルをリコンパイルします。

     リターン値は不定です。

 -- Function: batch-byte-compile &optional noforce
     この関数は、コマンドラインで指定されたファイルにた
     いして、‘byte-compile-file’を実行します。この関数は
     処理が完了するとEmacsをkillするので、Emacsのバッチ
     実行だけで使用しなければなりません。1つのファイルで
     エラーが発生しても、それにより後続のファイルにたい
     する処理が妨げられることはありませんが、そのファイ
     ルにたいする出力ファイルは生成されず、Emacsプロセス
     は0以外のステータスコードで終了します。

     NOFORCEが非‘nil’の場合、この関数は最新の‘.elc’ファ
     イルがあるファイルをリコンパイルしません。

          $ emacs -batch -f batch-byte-compile *.el


File: elisp,  Node: Docs and Compilation,  Next: Dynamic Loading,  Prev: Compilation Functions,  Up: Byte Compilation

16.3 Documentation Strings and Compilation
==========================================

Emacsがバイトコンパイルされたファイルから関数や変数をロ
ードする際、通常はメモリー内にそれらのドキュメント文字列
をロードしません。それぞれのドキュメント文字列は、必要な
ときだけバイトコンパイルされたファイルから“ダイナミック
(dynamic: 動的)”にロードされます。ドキュメント文字列の処
理をスキップすることにより、メモリーが節約され、ロードが
高速になります。

   この機能には欠点があります。コンパイル済みのファイル
を削除、移動、または(新しいバージョンのコンパイル等で)変
更した場合、Emacsは前にロードされた関数や変数のドキュメ
ント文字列にアクセスできなくなるでしょう。このような問題
は通常、あなた自身がEmacsをビルドした場合に、そのLispフ
ァイルを編集、および/またはリコンパイルしたときだけ発生
します。この問題は、リコンパイル後にそれぞれのファイルを
リロードするだけで解決します。

   バイトコンパイルされたファイルからのドキュメント文字
列のダイナミックロードは、バイトコンパイルされたファイル
ごとに、コンパイル時に決定されます。これはオプション
‘byte-compile-dynamic-docstrings’により、無効にできます
。

 -- User Option: byte-compile-dynamic-docstrings
     これが非‘nil’の場合、バイトコンパイラーはドキュメン
     ト文字列をダイナミックロードするようセットアップし
     たコンパイル済みファイルを生成します。

     特定のファイルでダイナミックロード機能を無効にする
     には、以下のようにヘッダー行(*note Local Variables
     in Files: (emacs)File Variables.を参照)で、このオプ
     ションに‘nil’をセットします。

          -*-byte-compile-dynamic-docstrings: nil;-*-

     これは主に、あるファイルを変更しようとしていて、そ
     のファイルをすでにロード済みのEmacsセッションがファ
     イルを変更した際にも正しく機能し続けることを望む場
     合に有用です。

   内部的には、ドキュメント文字列のダイナミックロードは
、特殊なLispリーダー構成‘#@COUNT’とともにコンパイル済み
ファイルに書き込むことにより達成されます。この構成は、次
のCOUNT文字をスキップします。さらに‘#$’構成も使用され、
これは“このファイルの名前(文字列)”を意味します。これらの
構成をLispソースファイル内で使用しないでください。これら
は人間がファイルを読む際に明確であるようデザインされてい
ません。


File: elisp,  Node: Dynamic Loading,  Next: Eval During Compile,  Prev: Docs and Compilation,  Up: Byte Compilation

16.4 Dynamic Loading of Individual Functions
============================================

ファイルをコンパイルするとき、オプションで“ダイナミック
関数ロード(dynamic function loading)”機能(“laxyロード
(lazy loading)とも呼ばれる”)を有効にできます。ダイナミッ
ク関数ロードでは、ファイルのロードでファイル内の関数定義
は完全には読み込まれません。かわりに、各関数定義にはその
ファイルを参照するプレースホルダーが含まれます。それぞれ
関数が最初に呼び出されるときに、そのプレースホルダーを置
き換えるために、ファイルから完全な定義が読み込まれます。

   ダイナミック関数ロードの利点は、ファイルのロードがよ
り高速になることです。ユーザーが呼び出せる関数を多く含む
ファイルにとって、それらの関数のうち1つを使用したら、お
そらく残りの関数も使用するというのでなければ、これは利点
です。多くのキーボードコマンドを提供する特化したモードは
、このパターンの使い方をする場合があります。ユーザーはそ
のモードを呼び出すかもしれませんが、使用するのはそのモー
ドが提供するコマンドのわずか一部です。

   ダイナミックロード機能には、いくつか不利な点がありま
す:

   • ロード後にコンパイル済みファイルを削除や移動した場
     合、Emacsはまだロードされていない残りの関数定義をロ
     ードできなくなる。

   • (新しいバージョンのコンパイル等で)コンパイル済みフ
     ァイルを変更した場合、まだロードされていない関数の
     ロードを試みると、通常は無意味な結果となる。

   このような問題は、通常の状況でインストールされた
Emacsファイルでは決して発生しません。しかし、あなたが変
更したLispファイルでは発生し得ます。それぞれのファイルを
リコンパイルしたらすぐに、新たなコンパイル済みファイルを
リロードするのが、これらの問題を回避する一番簡単な方法で
す。

   コンパイル時に変数‘byte-compile-dynamic’が非‘nil’の場
合、バイトコンパイラーはダイナミック関数ロード機能を使用
します。ダイナミックロードが望ましいのは特定のファイルに
たいしてだけなので、この変数をグローバルにセットしないで
ください。そのかわりに、特定のソースファイルのファイルロ
ーカル変数で、この機能を有効にしてください。たとえば、ソ
ースファイルの最初の行に以下のテキストを記述することによ
り、これを行うことができます:

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     これが非‘nil’の場合、バイトコンパイラーはダイナミッ
     ク関数ロードのためにセットアップされたコンパイル済
     みファイルを生成します。

 -- Function: fetch-bytecode function
     FUNCTIONがバイトコード関数オブジェクトの場合、それ
     がまだ完全にロードされていなければ、バイトコンパイ
     ル済みのファイルからのFUNCTIONのバイトコードのロー
     ドを完了させます。それ以外は、何も行いません。この
     関数は、常にFUNCTIONをリターンします。


File: elisp,  Node: Eval During Compile,  Next: Compiler Errors,  Prev: Dynamic Loading,  Up: Byte Compilation

16.5 Evaluation During Compilation
==================================

これらの機能により、プログラムのコンパイル中に評価される
コードを記述できます。

 -- Special Form: eval-and-compile body...
     このフォームは、それを含むコードがコンパイルされる
     とき、および(コンパイルされているかいないかに関わら
     ず)実行されるときの両方で、BODYが評価されるようにマ
     ークします。

     BODYを別のファイルに配し、そのファイルを‘require’で
     参照すれば、同様の結果が得られます。これはBODYが大
     きいとき望ましい方法です。事実上、‘require’は自動的
     に‘eval-and-compile’され、そのパッケージはコンパイ
     ル時と実行時の両方でロードされます。

     ‘autoload’も実際は‘eval-and-compile’されます。これ
     はコンパイル時に認識されるので、そのような関数の使
     用により警告“not known to be defined”は生成されませ
     ん。

     ほとんどの‘eval-and-compile’の使用は、完全に妥当で
     あると言えます。

     あるマクロがマクロの結果を構築するためのヘルパー関
     数をもち、そのマクロがそのパッケージにたいしてロー
     カルと外部の両方で使用される場合には、コンパイル時
     と後の実行時にそのヘルパー関数を取得するために、
     ‘eval-and-compile’を使用すべきです。

     関数がプログラム的に(‘fset’で)定義されている場合に
     は、それがコンパイル時、同様に実行時に行われるよう
     に使用でき、それらの関数への呼び出しはチェックされ
     ます(“not known to be defined”の警告は抑えられます
     )。

 -- Special Form: eval-when-compile body...
     このフォームは、BODYがコンパイル時に評価され、コン
     パイルされたプログラムがロードされるときは評価され
     ないようにマークします。コンパイラーによる評価の結
     果は、コンパイル済みのプログラム内の定数となります
     。ソースファイルをコンパイルではなくロードした場合
     、BODYは通常どおり評価されます。

     生成するために何らかの計算が必要な定数がある場合、
     ‘eval-when-compile’はコンパイル時にそれを行なうこと
     ができます。たとえば、

          (defvar my-regexp
            (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))

     他のパッケージを使用しているが、そのパッケージのマ
     クロ(バイトコンパイラーはそれらを展開します)だけが
     必要な場合、それらを実行せずにコンパイル用にロード
     させるために‘eval-when-compile’を使用できます。たと
     えば、

          (eval-when-compile
            (require 'my-macro-package))

     これらの事項は、マクロおよび‘defsubst’関数がローカ
     ルに定義され、そのファイル内だけで使用されることを
     要求します。これらは、そのファイルのコンパイルに必
     要ですが、コンパイル済みファイルの実行には、ほとん
     どの場合必要ありません。たとえば、

          (eval-when-compile
            (unless (fboundp 'some-new-thing)
              (defmacro 'some-new-thing ()
                (compatibility code))))

     これは大抵他のバージョンのEmacsとの互換性にたいする
     保証だけのためのコードにたいして有用です。

     *Common Lispに関する注意:* トップレベルでは、
     ‘eval-when-compile’はCommon Lispのイディオム
     ‘(eval-when (compile eval) ...)’に類似しています。
     トップレベル以外では、Common Lispのリーダーマクロ
     ‘#.’(ただし解釈時を除く)が、‘eval-when-compile’と近
     いことを行います。


File: elisp,  Node: Compiler Errors,  Next: Byte-Code Objects,  Prev: Eval During Compile,  Up: Byte Compilation

16.6 Compiler Errors
====================

バイトコンパイルのエラーメッセージと警告メッセージは、
‘*Compile-Log*’という名前のバッファーにプリントされます
。これらのメッセージには、問題となる箇所を示すファイル名
と行番号が含まれます。これらのメッセージにたいして、コン
パイラー出力を操作する通常のEmacsコマンドが使用できます
。

   あるエラーがプログラムのシンタックスに由来する場合、
バイトコンパイラーはエラーの正確な位置の取得に際し混乱す
るかもしれません。バッファー‘ *Compiler Input*’.にスイッ
チするのは、これを調べ1つの方法です。(このバッファー名は
スペースで始まるので、Buffer Menuに表示されません。)この
バッファーにはコンパイルされたプログラムと、バイトコンパ
イラーが読み取れた箇所からポイントがどれほど離れているか
が含まれ、エラーの原因はその近傍にあるかもしれません。シ
ンタックスエラーを見つけるヒントについては、*note Syntax
Errors::を参照してください。

   定義されていない関数や変数の使用は、バイトコンパイラ
ーにより報告される警告のタイプとしては一般的です。そのよ
うな警告では、定義されていない関数や変数を使用した位置で
はなく、そのファイルの最後の行の行番号が報告されるので、
それを見つけるには手作業で検索しなければなりません。

   定義のない関数や変数の警告が間違いだと確信できる場合
には、警告を抑制する方法がいくつかあります:

   • 関数FUNCへの特定の呼び出しにたいする警告は、それを
     条件式で‘fboundp’によるテストを行なうことで抑制でき
     ます:

          (if (fboundp 'FUNC) ...(FUNC ...)...)

     FUNCへの呼び出しは‘if’文のTHEN-FORM内になければなら
     ず、FUNCは‘fboundp’呼び出し内でクォートされていなけ
     ればなりません。(この機能は‘cond’でも同様に機能しま
     す。)

   • 同じように、変数VARIABLEの特定の使用についの警告を
     、条件式内の‘boundp’テストで抑制できます:

          (if (boundp 'VARIABLE) ...VARIABLE...)

     VARIABLEへの参照は‘if’文のTHEN-FORM内になければなら
     ず、VARIABLEは‘boundp’呼び出し内でクォートされてい
     なければなりません。

   • コンパイラーに関数が‘declare-function’を使用して定
     義されていると告げることができます。*note Declaring
     Functions::を参照してください。

   • 同じように、その変数が初期値なしの‘defvar’を使用し
     て定義されているとコンパイラーに告げることができま
     す。(これはその変数を特別な変数としてマークすること
     に注意してください。*note Defining Variables::を参
     照してください。

   ‘with-no-warnings’構成を使用して特定の式にたいするコ
ンパイラーのすべての任意の警告を抑制することもできます:

 -- Special Form: with-no-warnings body...
     実行時には〜これは‘(progn BODY...)’と等価ですが、コ
     ンパイラーはBODYの中で起こるいかなる事項にたいして
     も警告を発しません。

     わたしたちは、あなたが抑制したいと意図する警告以外
     の警告を失わないようにするために、可能な限り小さい
     コード断片にたいしてこの構成を使用することを推奨し
     ます。

   変数‘byte-compile-warnings’をセットすることにより、コ
ンパイラーの警告をより詳細に制御できます。詳細は、変数の
ドキュメント文字列を参照してください。


File: elisp,  Node: Byte-Code Objects,  Next: Disassembly,  Prev: Compiler Errors,  Up: Byte Compilation

16.7 Byte-Code Function Objects
===============================

バイトコンパイルされた関数は、特別なデータ型、“バイトコ
ード関数オブジェクト(byte-code function objects)”をもち
ます。関数呼び出しとしてそのようなオブジェクトが出現した
とき、Emacsはそのバイトコードを実行するために、常にバイ
トコードインタープリターを使用します。

   内部的には、バイトコード関数オブジェクトはベクターに
よく似ています。バイトコード関数オブジェクトの要素には、
‘aref’を通じてアクセスできます。バイトコード関数オブジェ
クトのプリント表現(printed representation)はベクターに似
ていて、開き‘[’の前に‘#’が追加されます。バイト関数オブジ
ェクトは少なくとも4つの要素をもたねばならず、要素数に上
限はありません。しかし通常使用されるのは、最初の6要素で
す。これらは:

ARGLIST
     シンボル引数のリスト。

BYTE-CODE
     バイトコード命令を含む文字列。

CONSTANTS
     バイトコードにより参照されるLispオブジェクトのベク
     ター。関数名と変数名に使用されるシンボルが含まれる
     。

STACKSIZE
     この関数が要するスタックの最大サイズ。

DOCSTRING
     (もしあれば)ドキュメント文字列。それ以外は‘nil’。ド
     キュメント文字列がファイルに格納されている場合、値
     は数字かリストかもしれない。本当のドキュメント文字
     列の取得には、関数‘documentation’を使用する(*note
     Accessing Documentation::を参照)。

INTERACTIVE
     (もしあれば)インタラクティブ仕様。文字列かLisp式。
     インタラクティブでない関数では‘nil’。

   以下は、バイトコード関数オブジェクトのプリント表現の
例です。これはコマンド‘backward-sexp’の定義です。

     #[(&optional arg)
       "^H\204^F^@\301^P\302^H[!\207"
       [arg 1 forward-sexp]
       2
       254435
       "^p"]

   バイトコードオブジェクトを作成する原始的な方法は、
‘make-byte-code’です:

 -- Function: make-byte-code &rest elements
     この関数はELEMENTSを要素とするバイトコードオブジェ
     クトを構築して、リターンします。

   あなた自身が要素を収集してバイトコード関数を構築しな
いでください。それらが矛盾する場合、その関数の呼び出しに
よりEmacsがクラッシュするかもしれません。これらのオブジ
ェクトの作成は、常にバイトコンパイラーにまかせてください
。バイトコンパイラーは、要素を矛盾なく構築します(願わく
ば)。


File: elisp,  Node: Disassembly,  Prev: Byte-Code Objects,  Up: Byte Compilation

16.8 Disassembled Byte-Code
===========================

人はバイトコードを記述しません。それはバイトコンパイラー
の仕事です。しかし、好奇心を満たすために、わたしたちはデ
ィスアセンブラを提供しています。ディスアセンブラは、バイ
トコードを人間が読めるフォームに変換します。

   バイトコードインタープリターは、シンプルなスタックマ
シンとして実装されています。これは値を自身のスタックに
pushして、計算で使用するためにそれらをpopして取り出し、
おの結果を再びそのスタックにpushして戻します。バイトコー
ド関数がリターンするときは、スタックから値をpopして取り
出し、その関数の値としてリターンします。

   それに加えてスタックとバイトコード関数は、値を変数と
スタックの間で転送することにより、普通のLisp変数を使用し
たり、バインドおよびセットすることができます。

 -- Command: disassemble object &optional buffer-or-name
     このコマンドは、OBJECTにたいするディスアセンブルさ
     れたコードを表示します。インタラクティブに使用した
     場合、またはBUFFER-OR-NAMEが‘nil’か省略された場合は
     、‘*Disassemble*’という名前のバッファーに出力します
     。BUFFER-OR-NAMEが非‘nil’の場合は、バッファーもしく
     は既存のバッファーの名前でなければなりません。その
     場合は、そのバッファーのポイント位置に出力され、ポ
     イントは出力の前に残りされます。

     引数OBJECTには関数名、ラムダ式(*note Lambda
     Expressions::を参照)、またはバイトコードオブジェク
     ト(*note Byte-Code Objects::を参照)を指定できます。
     ラムダ式の場合、‘disassemble’はそれをコンパイルして
     から、そのコンパイル済みコードをディスアセンブルし
     ます。

   以下に‘disassemble’関数を使用した例を2つ示します。バ
イトコードとLispソースを関連付ける助けとなるように、説明
的なコメントを追加してあります。これらのコメントは、
‘disassemble’の出力にはありません。

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          ⇒ factorial

     (factorial 4)
          ⇒ 24

     (disassemble 'factorial)
          ⊣ byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   varref   integer      ; ‘integer’の値を取得して
                               ;   それをスタック上にpushする。
     1   constant 1            ; スタック上に1をpushする。
     2   eqlsign               ; 2つの値をスタックからpopして取り出し、
                               ;   それらを比較して結果をスタック上にpushする。
     3   goto-if-nil 1         ; スタックのトップをpopしてテストする。
                               ;   ‘nil’なら1へ、それ以外はcontinue。
     6   constant 1            ; スタックのトップに1をpushする。
     7   return                ; スタックのトップの要素をリターンする。
     8:1 varref   integer      ; ‘integer’の値をスタック上にpushする。
     9   constant factorial    ; ‘factorial’をスタック上にpushする。
     10  varref   integer      ; ‘integer’の値をスタック上にpushする。
     11  sub1                  ; ‘integer’をpopして値をデクリメントする。
                               ;   スタック上に新しい値をpushする。
     12  call     1            ; スタックの最初(トップ)の要素を引数として
                               ;   関数‘factorial’を呼び出す。
                               ;   リターン値をスタック上にpushする。
     13 mult                   ; スタックのトップ2要素をpopして取り出し乗じ
                               ;   結果をスタック上にpushする。
     14 return                 ; スタックのトップ要素をリターンする。

   ‘silly-loop’は幾分複雑です:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
          ⇒ silly-loop

     (disassemble 'silly-loop)
          ⊣ byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; ‘current-time-string’を
                                       ;   スタック上のトップにpushする。
     1   call     0            ; 引数なしで‘current-time-string’を呼び出し
                               ;   結果をスタック上にpushする。
     2   varbind  t1           ; スタックをpopして‘t1’にpopされた値をバインドする。
     3:1 varref   n            ; 環境から‘n’の値を取得して
                               ;   その値をスタック上にpushする。
     4   sub1                  ; スタックのトップから1を減ずる。
     5   dup                   ; スタックのトップを複製する。
                               ;   たとえばスタックのトップをコピーしてスタック上にpushする。
     6   varset   n            ; スタックのトップをpopして
                               ;   ‘n’をその値にバインドする。

     ;; (要はシーケンス‘dup varset’はpopせずに
     ;;  スタックのトップを‘n’の値にコピーする。)

     7   constant 0            ; スタック上に0をpushする。
     8   gtr                   ; スタックのトップ2値をpopして取り出し
                               ;   Nが0より大かテストし
                               ;   結果をスタック上にpushする。
     9   goto-if-not-nil 1     ; ‘n’ > 0なら1へ
                               ;   (これはwhile-loopを継続する)
                               ;   それ以外はcontinue。
     12  varref   t1           ; ‘t1’の値をスタック上にpushする。
     13  constant current-time-string  ; ‘current-time-string’を
                                       ;   スタックのトップにpushする。
     14  call     0            ; 再度‘current-time-string’を呼び出す。
     15  unbind   1            ; ローカル環境の‘t1’をアンバインドする。
     16  list2                 ; スタックのトップ2要素をpopして取り出し
                               ;   それらのリストを作りスタック上にpushする。
     17  return                ; スタックのトップの値をリターンする。


File: elisp,  Node: Debugging,  Next: Read and Print,  Prev: Byte Compilation,  Up: Top

17 Debugging Lisp Programs
**************************

Emacs Lispプログラム内の問題を見つけて詳細に調べる方法が
、いくつかあります。

   • プログラム実行中に問題が発生した場合は、Lisp評価機
     能をサスペンドするためにビルトインのEmacs Lispデバ
     ッガを使用して、評価機能の内部状態の調査および/また
     は変更を行なうことができます。

   • Emacs Lispにたいするソースレベルデバッガの、
     Edebugを使用できます。

   • 文法的な問題によりLispがプログラムを読むことさえで
     きない場合は、Lisp編集コマンドを使用して該当箇所を
     見つけることができます。

   • バイトコンパイラーがプログラムをコンパイルするとき
     、コンパイラーにより生成されるエラーメッセージと警
     告メッセージを調べることができます。*note Compiler
     Errors::を参照してください。

   • Testcoverパッケージを使用してプログラムのテストカバ
     レッジを行なえます。

   • ERTパッケージを使用して、プログラムにたいするリグレ
     ッションテストを記述できます。*note the ERT manual:
     (ert)Top.を参照してください。

   • プログラムをプロファイルして、プログラムをより効果
     的にするためのヒントを取得できます。

   入出力の問題をデバックする便利なその他のツールに、ド
リブルファイル(dribble file: *note Terminal Input::を参
照)と、‘open-termscript’関数(*note Terminal Output::)が
あります。

* Menu:

* Debugger::                 Emacs
                               Lisp評価機能にたいするデバッガ。
* Edebug::                   Emacs Lispソースレベルデバッガ。
* Syntax Errors::            シンタックスエラーを見つける方法。
* Test Coverage::            プログラムのすべての分岐を確実にテストする。
* Profiling::                あなたのコードが使用するリソースの計測。


File: elisp,  Node: Debugger,  Next: Edebug,  Up: Debugging

17.1 The Lisp Debugger
======================

普通の“Lispデバッガ”は、フォーム評価のサスペンド機能を提
供します。評価がサスペンド(一般的には“break”の状態として
知られる)されている間、実行時スタックを調べたり、ローカ
ル変数やグローバル変数の値を調べたり変更することができま
す。breakは再帰編集(recursive edit)なので、Emacsの通常の
編集機能が利用可能です。デバッガにエンターするようにプロ
グラムを実行することさえ可能です。*note Recursive
Editing::を参照してください。

* Menu:

* Error Debugging::          エラー発生時にデバッガにエンターする。
* Infinite Loops::           exitしないプログラムの停止デバッグ。
* Function Debugging::       特定の関数が呼び出されたときにデバッガにエンターする。
* Explicit Debug::           プログラム内の特定箇所でデバッガにエンターする。
* Using Debugger::           デバッガが行なうこと:
                               そこで何を目にするか。
* Debugger Commands::        デバッガで使用するコマンド。
* Invoking the Debugger::    関数‘debug’の呼び出し方。
* Internals of Debugger::    デバッガのサブルーチン、およびグローバル変数。


File: elisp,  Node: Error Debugging,  Next: Infinite Loops,  Up: Debugger

17.1.1 Entering the Debugger on an Error
----------------------------------------

デバッガに入る一番重要なタイミングは、Lispエラーが発生し
たときです。デバッガでは、エラーの直接原因を調査できます
。

   しかしデバッガへのエンターは、エラーによる通常の結末
ではありません。多くのコマンドは不適切に呼び出されたとき
にLispエラーをシグナルするので、通常の編集の間にこれが発
生するたびデバッガにエンターするのは、とても不便でしょう
。したがって、エラーの際にデバッガにエンターしたい場合は
、変数‘debug-on-error’に非‘nil’をセットします。(コマンド
‘toggle-debug-on-error’は、これを簡単に行う方法を提供し
ます。)

 -- User Option: debug-on-error
     この変数はエラーがシグナルされ、それがハンドルされ
     ていないときに、デバッガが呼び出されるかどうかを決
     定します。‘debug-on-error’が‘t’の場合は、
     ‘debug-ignored-errors’(以下を参照)にリストされてい
     るエラーを除く、すべての種類のエラーがデバッガを呼
     び出します。‘nil’の場合は、デバッガを呼び出しません
     。

     値にはエラー条件(*note Signaling Errors::を参照)の
     リストも指定できます。その場合、このリスト内のエラ
     ー条件だけにより、デバッガが呼び出されます
     (‘debug-ignored-errors’にもリストされているエラー条
     件は除外されます)。たとえば、‘debug-on-error’をリス
     ト‘(void-variable)’にセットした場合には、値をもたな
     い変数に関するエラーにたいしてだけデバッガが呼び出
     されます。

     ‘eval-expression-debug-on-error’がこの変数をオーバ
     ーライドする場合がいくつかあることに注意してくださ
     い(以下を参照)。

     この変数が非‘nil’のとき、Emacsはプロセスフィルター
     関数と番兵(sentinel)の周囲にエラーハンドラーを作成
     しません。したがって、これらの関数内でのエラーは、
     デバッガを呼び出します。*note Processes::を参照して
     ください。

 -- User Option: debug-ignored-errors
     この変数は、‘debug-on-error’の値に関わらず、デバッ
     ガにエンターすべきでないエラーを指定します。変数の
     値はエラー条件のシンボル、および/または正規表現のリ
     ストです。エラーがこれら条件シンボルのいずれか、ま
     たはエラーメッセージが正規表現のいずれかにマッチす
     る場合、そのエラーはデバッガにエンターしません。

     この変数の通常の値には‘user-error’と、同様に編集中
     にしばしば発生するがLispプログラムのバグによるもの
     はほとんどない、いくつかのエラーが含まれます。しか
     し、“ほとんどない”は“絶対ない”ではありません。あな
     たのプログラムがこのリストにマッチするエラーにより
     機能しない場合は、そのエラーをデバッグするために、
     このリストの変更を試みるのもよいでしょう。通常は
     ‘debug-ignored-errors’を‘nil’にセットしておくのが、
     もっとも簡単な方法です。

 -- User Option: eval-expression-debug-on-error
     この変数が非‘nil’値(デフォルト)の場合は、コマンド
     ‘eval-expression’の実行により、一時的に
     ‘debug-on-error’が‘t’がバインドされます。*note
     Evaluating Emacs-Lisp Expressions: (emacs)Lisp
     Eval.を参照してください。

     ‘eval-expression-debug-on-error’が‘nil’の場合は、
     ‘eval-expression’の間も‘debug-on-error’の値は変更さ
     れません。

 -- Variable: debug-on-signal
     ‘condition-case’によりキャッチされたエラーは通常、
     決してデバッガを呼び出しません。‘condition-case’は
     、デバッガがそのエラーをハンドルする前に、エラーを
     ハンドルする機会を得ます。

     ‘debug-on-signal’を非‘nil’値に変更した場合は、
     ‘condition-case’の存在如何に関わらず、すべてのエラ
     ーにおいてデバッガが最初に機会を得ます。(デバッガを
     呼び出すためには、依然としてそのエラーが
     ‘debug-on-error’と‘debug-ignored-errors’で指定され
     た条件を満たさなければなりません。)

     *警告:* この変数を非‘nil’にセットすると、芳しくない
     効果があるかもしれません。Emacsのさまざまな部分で処
     理の通常の過程としてエラーがキャッチされており、そ
     のエラーが発生したことに気づかないことさえあるかも
     しれません。‘condition-case’でラップされたコードを
     デバッグする必要がある場合は、
     ‘condition-case-unless-debug’(*note Handling
     Errors::を参照)の使用を考慮してください。

 -- User Option: debug-on-event
     ‘debug-on-event’をスペシャルイベント(*note Special
     Events::を参照)にセットした場合は、Emacsは
     ‘special-event-map’をバイパスして、このイベントを受
     け取ると即座にデバッガへのエンターを試みます。現在
     のところサポートされる値は、シグナル‘SIGUSR1’および
     ‘SIGUSR2’に対応する値だけです(これがデフォルトです
     )。これは‘inhibit-quit’がセットされていて、それ以外
     はEmacsが応答しない場合に有用かもしれません。

 -- Variable: debug-on-message
     ‘debug-on-message’に正規表現をセットした場合には、
     それにマッチするメッセージがエコーエリアに表示され
     ると、Emacsはデバッガにエンターします。たとえば、こ
     れは特定のメッセージの原因を探すのに有用かもしれま
     せん。

   initファイルロード中に発生したエラーをデバッグするに
は、オプション‘--debug-init’を使用します。これはinitファ
イルロードの間に‘debug-on-error’を‘t’にバインドして、通
常はinitファイル内のエラーをキャッチする
‘condition-case’をバイパスします。


File: elisp,  Node: Infinite Loops,  Next: Function Debugging,  Prev: Error Debugging,  Up: Debugger

17.1.2 Debugging Infinite Loops
-------------------------------

プログラムが無限にループしてリターンできないとき、最初の
問題はそのループをいかに停止するかです。ほとんどのオペレ
ーティングシステムでは、(“quit”させる)‘C-g’でこれを行う
ことができます。*note Quitting::を参照してください。

   普通のquitでは、なぜそのプログラムがループしたかにつ
いての情報は与えられません。変数‘debug-on-quit’に非
‘nil’をセットすることにより、より多くの情報を得ることが
できます。無限ループの途中でデバッガを実行すれば、デバッ
ガからステップコマンドで先へ進むことができます。ループ全
体をステップで追えば、問題を解決するために十分な情報が得
られるでしょう。

   ‘C-g’によるquitはエラーとは判断されないので、‘C-g’の
ハンドルに‘debug-on-error’は効果がありません。同じように
、‘debug-on-quit’はエラーにたいして効果がありません。

 -- User Option: debug-on-quit
     この変数は、‘quit’がシグナルされ、それがハンドルさ
     れていないときに、デバッガを呼び出すかどうかを決定
     します。‘debug-on-quit’が非‘nil’の場合は、quit(つま
     り‘C-g’をタイプ)したときは常にデバッガが呼び出され
     ます。‘debug-on-quit’が‘nil’(デフォルト)の場合は、
     quitしてもデバッガは呼び出されません。


File: elisp,  Node: Function Debugging,  Next: Explicit Debug,  Prev: Infinite Loops,  Up: Debugger

17.1.3 Entering the Debugger on a Function Call
-----------------------------------------------

プログラムの途中で発生する問題を調べるための有用なテクニ
ックの1つは、特定の関数が呼び出されたときデバッガにエン
ターする方法です。問題が発生した関数にこれを行い、その関
数をステップで追ったり、問題箇所の少し手前の関数呼び出し
でこれを行い、その関数をステップオーバーしてその後をステ
ップで追うことができます。

 -- Command: debug-on-entry function-name
     この関数は、FUNCTION-NAMEが呼び出されるたびにデバッ
     ガの呼び出しを要求します。

     Lispコードで定義された任意の関数およびマクロは、イ
     ンタープリターに解釈されたコードかコンパイル済みの
     コードかに関わらず、エントリーにbreakをセットできま
     す。その関数がコマンドの場合は、Lispから呼び出され
     たときと、インタラクティブに呼び出されたとき、デバ
     ッガにエンターします。(たとえばCで記述された)プリミ
     ティブ関数にも、この方法で‘debug-on-entry’をセット
     できますが、そのプリミティブがLispコードから呼び出
     されたときだけ効果があります。‘debug-on-entry’はス
     ペシャルフォームにはセットできません。

     ‘debug-on-entry’がインタラクティブに呼び出されたと
     きは、ミニバッファーでFUNCTION-NAMEの入力を求めます
     。その関数がすでにエントリーでデバッガを呼び出すよ
     うにセットアップされていた場合、‘debug-on-entry’は
     何も行いません。‘debug-on-entry’は常に
     FUNCTION-NAMEをリターンします。

     以下は、この関数の使い方を説明するための例です:

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               ⇒ fact
          (debug-on-entry 'fact)
               ⇒ fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Debugger entered--entering a function:
          * fact(3)
            eval((fact 3))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ------ Buffer: *Backtrace* ------


 -- Command: cancel-debug-on-entry &optional
          function-name
     この関数はFUNCTION-NAMEにたいする‘debug-on-entry’の
     効果をアンドゥします。インタラクティブに呼び出され
     たときは、ミニバッファーでFUNCTION-NAMEの入力を求め
     ます。FUNCTION-NAMEが省略された、あるいは‘nil’の場
     合は、すべての関数にたいするbreak-on-entryをキャン
     セルします。エントリー時にbreakするようセットアップ
     されていない関数に‘cancel-debug-on-entry’を呼び出し
     たときは、何も行いません。


File: elisp,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Function Debugging,  Up: Debugger

17.1.4 Explicit Entry to the Debugger
-------------------------------------

プログラム内の特定箇所に式‘(debug)’を記述することにより
、その箇所でデバッガが呼び出されるようにできます。これを
行うにはソースファイルをvisitして、適切な箇所にテキスト
‘(debug)’を挿入し、‘C-M-x’(Lispモードでの‘eval-defun’に
たいするキーバインド)をタイプします。*警告:* 一時的なデ
バッグ目的のためにこれを行なう場合は、ファイルを保存する
前に確実にアンドゥしてください!

   ‘(debug)’を挿入する箇所は、追加フォームが評価されるこ
とができ、その値を無視することができる箇所でなければなり
ません。(‘(debug)’の値が無視されない場合が、プログラムの
実行が変更されてしまうでしょう!) 一般的にもっとも適した
箇所は、‘progn’または暗黙的な‘progn’(*note Sequencing::を
参照)の内部です。

   デバッグ命令を配したいソースコード中の正確な箇所がわ
からないが、特定のメッセージが表示されたときにバックトレ
ースを表示したい場合は、意図するメッセージにマッチする正
規表現を‘debug-on-message’にセットできます。


File: elisp,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

17.1.5 Using the Debugger
-------------------------

デバッガにエンターすると、その前に選択されていたウィンド
ウを1つのウィンドウに表示し、他のウィンドウに
‘*Backtrace*’という名前のバッファーを表示します。
backtraceバッファーには、現在実行されているLisp関数の各
レベルが1行ずつ含まれます。このバッファーの先頭は、デバ
ッガが呼び出された理由を説明するメッセージ(デバッガがエ
ラーにより呼び出された場合はエラーメッセージや関連するデ
ータなど)です。

   backtraceバッファーは読み取り専用で、文字キーにデバッ
ガコマンドが定義されたDebuggerモードという特別なメジャー
モードを使用します。通常のEmacs編集コマンドが利用できま
す。したがって、エラー時に編集されていたバッファーを調べ
るためにウィンドウを切り替えたり、バッファーを切り替えや
ファイルのvisit、その他一連の編集処理を行なうことができ
ます。しかしデバッガは再帰編集レベル(*note Recursive
Editing::を参照)にあり、編集が終わったらそれは
backtraceバッファーに戻って、(‘q’コマンドで)デバッガを
exitできます。デバッガをexitすることにより、再帰編集を抜
け出し、backtraceバッファーはバリー(bury: 覆い隠す)され
ます。(変数‘debugger-bury-or-killw’をセットすることによ
り、backtraceバッファーで‘q’コマンドが何を行うかをカスタ
マイズできます。たとえば、バッファーをバリーせずにkillし
たい場合は、この変数を‘kill’にセットします。他の値につい
ては、変数のドキュメントを調べてください。)

   デバッガにエンターしたとき、
‘eval-expression-debug-on-error’に一致するように変数
‘debug-on-error’が一時的にセットされます。変数
‘eval-expression-debug-on-error’が非‘nil’の場合、
‘debug-on-error’は一時的に‘t’にセットされます。これは、
デバッグセッション行っている間にさらにエラーが発生すると
、(デフォルトでは)他のbacktraceがトリガーされることを意
味します。これが望ましくない場合は、
‘debugger-mode-hook’内で
‘eval-expression-debug-on-error’を‘nil’にセットするか、
‘debug-on-error’を‘nil’にセットすることができます。

   backtraceバッファーは、実行されている関数と、その関数
の引数の値を示します。しのフレームを示す行にポイントを移
動して、スタックフレームを指定することもできます。(スタ
ックフレームとは、Lispインタープリターがある関数への特定
の呼び出しを記録する場所のことです。) 行ポイントがオンの
フレームが、“カレントフレーム(current frame)”となります
。デバッガコマンドのいくつかは、カレントフレームを処理し
ます。ある行がスター(star)で始まる場合は、そのフレームを
exitすることにより再びデバッガが呼び出されることを意味し
ます。これは関数のリターン値を調べるとき有用です。

   関数名にアンダーラインが引かれている場合は、デバッガ
がその関数のソースコードも位置を知っていることを意味しま
す。その名前をマウスでクリックするか、そこに移動して
<RET>をタイプして、ソースコードをvisitできます。

   デバッガはデバッガ自身のスタックフレーム数を想定する
ため、バイトコンパイルされて実行されなければなりません。
デバッガがインタープリターに解釈されて実行されているとき
、これらの想定は正しくなくなります。


File: elisp,  Node: Debugger Commands,  Next: Invoking the Debugger,  Prev: Using Debugger,  Up: Debugger

17.1.6 Debugger Commands
------------------------

(Debuggerモードの)debuggerバッファーでは、通常のEmacsコ
マンドに加えて、特別なコマンドが提供されます。デバッガで
もっとも重要な使い方をするのは、制御フローを見ることがで
きるコードをステップ実行するコマンドです。デバッガはイン
タープリターにより解釈された制御構造のステップ実行はでき
ますが、バイトコンパイル済みの関数ではできません。バイト
コンパイル済み関数をステップ実行したい場合は、同じ関数の
解釈された定義に置き換えてください。(これを行なうには、
その関数のソースをvisitして、関数の定義で‘C-M-x’とタイプ
してください。) プリミティブ関数のステップ実行にLispデバ
ッガは使用できません。

   以下はDebuggerモードのコマンドのリストです:

‘c’
     デバッガをexitして、実行を継続する。これはあたかも
     デバッガにエンターしなかったかのように(デバッガ内で
     行った変数値やデータ構造の変更などの副作用は除外さ
     れる)、プログラムの実行を再開する。

‘d’
     実行を継続するが、次にLisp関数が何か呼び出されたと
     きはデバッガにエンターする。これにより、ある式の下
     位の式をステップ実行して、下位の式が計算する値や、
     行うことを確認できる。

     デバッガにエンターした関数呼び出しにたいして、この
     方法で作成されたスタックフレームには自動的にフラグ
     がつくので、そのフレームをexitすると再びデバッガが
     呼び出されます。このフラグは、‘u’コマンドを使用して
     キャンセルできます。

‘b’
     カレントフレームにフラグをつけるので、そのフレーム
     をexitするときデバッガにエンターする。この方法でフ
     ラグがつけられたフレームは、backtraceバッファーでス
     ターのマークがつく。

‘u’
     カレントフレームをexitしたとき、デバッガにエンター
     してはならない。これは、そのフレームの‘b’コマンドを
     キャンセルする。目に見える効果としては、backtraceバ
     ッファーの行からスターが削除される。

‘j’
     ‘b’と同じようにカレントフレームにフラグをつける。そ
     の後、‘c’のように実行を継続するが、
     ‘debug-on-entry’によりセットアップされたすべての関
     数にたいするbreak-on-entryを一時的に無効にする。

‘e’
     ミニバッファーのLisp式を読み取り、(関連する
     lexical環境が適切なら)評価して、エコーエリアに値を
     プリントする。デバッガは特定の重要な変数とバッファ
     ーを処理の一部としてを変更する。‘e’は一時的にデバッ
     ガの外部からそれらの値をリストアするので、それらを
     調べて変更できる。これによりデバッガはより透過的に
     なる。対照的に、デバッガ内で‘M-:’は特別なことを行わ
     ず、デバッガ内での変数の値を表示する。

‘R’
     ‘e’と同様だが、バッファー‘*Debugger-record*’内の評
     価の結果も保存する。

‘q’
     デバッグされているプログラムを終了し、Emacsコマンド
     実行のトップレベルにリターンする。

     ‘C-g’によりデバッガにエンターしたが、実際はデバッグ
     ではなくquitしたいときは、‘q’コマンドを使用する。

‘r’
     デバッガから値をリターンする。ミニバッファーで式を
     読み取り、それを評価することにより、値が計算される
     。

     ‘d’コマンドは、(‘b’によるリクエスト、または‘d’によ
     るそのフレームへのエンターによる)Lisp呼び出しフレー
     ムからのexitでデバッガが呼び出されたときに有用です
     。‘r’コマンドで指定された値は、そのフレームの値とし
     て使用されます。これは、‘debug’を呼び出して、そのリ
     ターン値を使用するときも有用です。それ以外は、‘r’は
     ‘c’と同じ効果をもｙい、指定されたリターン値は問題に
     なりません。

     エラーによりデバッガにエンターしたときは、‘r’コマン
     ドは使用できません。

‘l’
     呼び出されたときにデバッガを呼び出す関数をリストし
     ます。これは、‘debug-on-entry’によりエントリー時に
     breakするようセットされた関数のリストです。

‘v’
     カレントスタックフレームのローカル変数の表示を切り
     替えます。


File: elisp,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

17.1.7 Invoking the Debugger
----------------------------

以下では、デバッガを呼び出すために使用される関数
‘debug’の完全な詳細を説明します。

 -- Command: debug &rest debugger-args
     この関数は、デバッガにエンターします。この関数は
     ‘*Backtrace*’(デバッガへの2回目以降の再帰エントリー
     では‘*Backtrace*<2>、...’)という名前のバッファーに
     バッファーを切り替えて、Lisp関数呼び出しについての
     情報を書き込みます。それから再帰編集にエンターして
     、Debuggerモードでbacktraceバッファーを表示します。

     Debuggerモードのコマンド‘c’、‘d’、‘j’、‘r’は再帰編
     集をexitします。その後、‘debug’は以前のバッファーに
     戻って、‘debug’を呼び出したものが何であれ、そこにリ
     ターンします。これは関数‘debug’が呼び出し元にリター
     ン可能な唯一の方法です。

     DEBUGGER-ARGSを使用すると、‘debug’は‘*Backtrace*’の
     最上部に残りの引数を表示するもで、ユーザーがそれら
     を確認できます。以下で説明する場合を除き、これは、
     これらの引数を使用する_唯一_の方法です。

     しかし‘debug’への1つ目の引数にたいする値は、特別な
     意味をもちます。(これらの値は通常、‘debug’を呼び出
     すプログラマーではなく、Emacs内部でのみ使用されます
     。) 以下はこれら特別な値のテーブルです:

     ‘lambda’
          1つ目の引数ga‘lambda’の場合、それは
          ‘debug-on-next-call’が非‘nil’のときに関数にエ
          ントリーしたことにより‘debug’が呼び出されたこ
          とを意味する。デバッガはバッファーのトップのテ
          キスト行に‘Debugger entered--entering a
          function:’と表示する。

     ‘debug’
          1つ目の引数が‘debug’の場合、それはエントリー時
          にデバッグされるようにセットされた関数にエント
          リーしたことにより‘debug’が呼び出されたことを
          意味する。デバッガは‘lambda’のときと同様、
          ‘Debugger entered--entering a function:’を表示
          します。これはその関数のスタックフレームもマー
          クするので、exit時にデバッガが呼び出される。

     ‘t’
          1つ目の引数が‘t’の場合、それは
          ‘debug-on-next-call’が非‘nil’のときに関数呼び
          出しの評価により‘debug’が呼び出されたことを示
          す。デバッガはバッファーのトップの行に
          ‘Debugger entered--beginning evaluation of
          function call form:’と表示する。

     ‘exit’
          1つ目の引数が‘exit’のときは、exit時にデバッガ
          を呼び出すよう以前にマークされたスタックフレー
          ムをexitしたことを示す。この場合は、‘debug’に
          与えられた2つ目の引数が、そのフレームからリタ
          ーンされた値になる。デバッガはバッファーのトッ
          プの行に‘Debugger entered--returning value:’と
          リターンされた値を表示する。

     ‘error’
          1つ目の引数が‘error’のときは、ハンドルされてい
          ないエラーまたは‘quit’がシグナルされてデバッガ
          にエンターした場合で、デバッガは‘Debugger
          entered--Lisp error:’とその後にシグナルされた
          エラーおよび‘signal’への引数を表示して、それを
          示す。たとえば、

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Debugger entered--Lisp error: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          エラーがシグナルされた場合はおそらく、変数
          ‘debug-on-error’は非‘nil’で、‘quit’がシグナル
          された場合はおそらく、変数‘debug-on-quit’は非
          ‘nil’である。

     ‘nil’
          明示的にデバッガにエンターしたいときは、
          DEBUGGER-ARGSの1つ目の引数に‘nil’を使用する。
          残りのDEBUGGER-ARGSは、バッファーのトップの行
          にプリントされる。メッセージ — たとえば
          ‘debug’が呼び出された条件を思い出すためのリマ
          インダー — の表示にこの機能を使用できる。


File: elisp,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

17.1.8 Internals of the Debugger
--------------------------------

このセクションでは、デバッガ内部で使用される関数と変数に
ついて説明します。

 -- Variable: debugger
     この関数の値は、デバッガを呼び出す関数呼び出しです
     。値には任意個の引数をとる関数、より具体的には関数
     の名前でなければなりません。この関数は何らかのデバ
     ッガを呼び出すべきです。この変数のデフォルト値は
     ‘debug’です。

     関数にたいしてLispが渡す1つ目の引数は、その関数がな
     ぜ呼び出されたかを示します。引数の慣習は、
     ‘debug’(*note Invoking the Debugger::)に詳解されて
     います。

 -- Command: backtrace
     この関数は現在アクティブなLisp関数呼び出しのトレー
     スをプリントします。この関数は‘debug’が
     ‘*Backtrace*’バッファーに書き込む内容を得るために使
     用されます。どの関数呼び出しがアクティブか判断する
     ためにスタックにアクセスしなければならないので、こ
     の関数はCで記述されています。リターン値は、常に
     ‘nil’です。

     以下の例では、Lisp式で明示的に‘backtrace’を呼び出し
     ています。これはストリーム‘standard-output’(この場
     合はバッファー‘backtrace-output’)にbacktraceをプリ
     ントします。

     backtraceの各行は、1つの関数呼び出しを表します。関
     数の引数が既知の場合は行に値が表示され、まだ計算中
     の場合は行にその旨が示されます。スペシャルフォーム
     の引数は無視されます。

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               ⇒ (testing nil)

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval((with-output-to-temp-buffer ...))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- Variable: debug-on-next-call
     この変数が非‘nil’の場合、それは次の‘eval’、
     ‘apply’、‘funcall’の前にデバッガを呼び出すよう指定
     します。デバッガへのエンターにより、
     ‘debug-on-next-call’は‘nil’にセットされます。

     デバッガの‘d’コマンドは、この変数をセットすることに
     より機能します。

 -- Function: backtrace-debug level flag
     この関数は、そのスタックフレームのLEVEL下位のスタッ
     クフレームのdebug-on-exitフラグにFLAGに応じた値をセ
     ットします。FLAGが非‘nil’の場合は、後にそのフレーム
     をexitするときデバッガにエンターします。そのフレー
     ムを通じた非ローカルexitでも、デバッガにエンターし
     ます。

     この関数は、デバッガだけに使用されます。

 -- Variable: command-debug-status
     この変数はカレントのインタラクティブコマンドのデバ
     ッグ状態を記録します。コマンドがインタラクティブに
     呼び出されるたびに、この変数は‘nil’にバインドされま
     す。デバッガは、同じコマンドが呼び出されたときのデ
     バッガ呼び出しに情報を残すために、この変数をセット
     できます。

     普通のグローバル変数ではなくこの変数を使用する利点
     は、そのデータが後続のコマンド呼び出しに決して引き
     継がれないことです。

 -- Function: backtrace-frame frame-number
     関数‘backtrace-frame’は、Lispデバッガ内での使用を意
     図しています。これは、FRAME-NUMBERレベル下位のスタ
     ックフレームで、何の評価が行われているかに関する情
     報をリターンします。

     そのフレームがまだ引数を評価していない場合、または
     そのフレームがスペシャルフォームの場合、値は‘(nil
     FUNCTION ARG-FORMS...)’です。

     そのフレームが引数を評価して関数をすでに呼び出した
     場合、リターン値は‘(t FUNCTION ARG-VALUES...)’です
     。

     リターン値のFUNCTIONは何であれ評価されたリストの
     CARとして提供されます。マクロ呼び出しの場合は
     ‘lambda’式になります。その関数に‘&rest’引数がある場
     合は、リストARG-VALUESの末尾に表されます。

     FRAME-NUMBERが範囲外の場合、‘backtrace-frame’は
     ‘nil’をリターンします。


File: elisp,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

17.2 Edebug
===========

EdebugはEmacs Lispプログラムにたいするソースレベルデバッ
ガです。これにより、以下のことができます:

   • 式の前や後でストップして、評価をステップで実行する
     。

   • 条件付き、または無条件のbreakpointのセット。

   • 指定された条件がtrueのときにストップする(グローバル
     breakpoint)。

   • ストップポイントごとに停止したり、breakpointごとに
     簡単に停止して、低速または高速にトレースを行う。

   • Edebug外部であるかのように、式の結果を表示し、式を
     評価する。

   • 式のリストを自動的に再評価して、Edebugがディスプレ
     イを更新するたびにそれらの結果を表示する。

   • 関数呼び出しとリターンのトレース情報を出力する。

   • エラー発生時にストップする。

   • Edebug自身のフレームを除外してbacktraceを表示する。

   • マクロおよびフォームの定義で引数の評価を指定する。

   • 初歩的なカバレッジテストと頻度数の取得。

   以下の初めの3つのセクションは、使用を開始するために
Edebugについて十分説明します。

* Menu:

* Using Edebug::             Edebug使用のための手引き。
* Instrumenting::            Edebugでデバッグするために、コードをインストルメント(計装)しなければならないe
* Modes: Edebug Execution Modes.  多かれ少なかれ、ストップする実行モード。
* Jumping::                  特定の位置にジャンプするコマンド。
* Misc: Edebug Misc.         さまざまなコマンド。
* Breaks::                   プログラムをストップさせるbreakpointのセット。
* Trapping Errors::          Edebugでのエラーのトラップ。
* Views: Edebug Views.       Edebugの内側と外側のビュー。
* Eval: Edebug Eval.         Edebugでの式の評価。
* Eval List::                Edebugにエンターするたびに値が表示される式。
* Printing in Edebug::       プリントのカスタマイズ。
* Trace Buffer::             バッファー内で採れを生成する方法。
* Coverage Testing::         評価をカバレッジテストする方法。
* The Outside Context::      Edebugが保存およびリストアするデータ。
* Edebug and Macros::        マクロ呼び出しをハンドルする方法の指定。
* Options: Edebug Options.   Edebugをカスタマイズするオプション変数。


File: elisp,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

17.2.1 Using Edebug
-------------------

EdebugでLispプログラムをデバッグするには、最初にデバッグ
したいLispコードを“インストルメント(instrument: 計装)”し
なければなりません。これを行なうもっともシンプルな方法は
、関数またはマクロの定義に移動して、‘C-u C-M-x’(プレフィ
クス引数を指定した‘eval-defun’)を行います。コードをイン
ストルメントする他の手段については、*note
Instrumenting::を参照してください。

   一度関数をインストルメントすると、その関数にたいする
任意の呼び出しにより、Edebugがアクティブになります。
Edebugがアクティブになると、どのEdebug実行モードを選択し
たかに依存して、その関数をステップ実行できるように実行が
ストップされるか、ディスプレイを更新してデバッグコマンド
にたいするチェックの間、実行が継続されます。デフォルトの
実行モードstepで、これは実行をストップします。*note
Edebug Execution Modes::を参照してください。

   Edebugでは通常、デバッグしているLispコードをEmacsバッ
ファーで閲覧します。これを“ソースコードバッファー(source
code buffer)”と呼び、バッファーは一時的に読み取り専用に
なります。

   左フリンジの矢印は、その関数で実行されている行を示し
ます。最初ポイントはその関数の実行されている行にあります
が、ポイントを移動するとこれは真ではなくなります。

   以下は、‘fac’の定義(以下を参照)をインストルメントして
‘(fac 3)’を実行した場合に通常目にするものです。ポイント
は、‘if’の前の開きカッコにあります。

     (defun fac (n)
     =>★(if (< 0 n)
           (* n (fac (1- n)))
         1))

   関数内でEdebugが実行をストップできる位置のことを、“ス
トップポイント(stop points)”と呼びます。ストップポイント
は、リストであるような部分式の前後、および変数参照の後で
も発生します。以下は、関数‘fac’内のストップポイントをピ
リオドで示したものです:

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac .(1- n.).).).
         1).)

   Emacs Lispモードのコマンドに加えて、ソースコードバッ
ファーでは、Edebugのスペシャルコマンドが利用できます。た
とえば、Edebugコマンド<SPC>で次のストップポイントまで実
行することができます。‘fac’にエントリーした後に一度
‘fac’とタイプした場合は、以下のように表示されるでしょう:

     (defun fac (n)
     =>(if ★(< 0 n)
           (* n (fac (1- n)))
         1))

   式の後でEdebugが実行をストップしたときは、エコーエリ
アにその式の値が表示されます。

   他にも頻繁に使用されるコマンドとして、ストップポイン
トにbreakpointをセットする‘b’、breakpointに達するまで実
行する‘g’、Edebugをexitしてトップレベルのコマンドループ
にリターンする‘q’があります。また、‘?’とタイプするとすべ
てのEdebugコマンドがリストされます。


File: elisp,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

17.2.2 Instrumenting for Edebug
-------------------------------

LispコードのデバッグにEdebugを使用するためには、最初にそ
のコードを“インストルメント(instrument: 計装)”しなければ
なりません。コードをインストルメントすると、適切な位置で
Edebugを呼び出すために追加コードが挿入されます。

   関数定義でプレフィクス引数とともにコマンド‘C-M-x’
(‘eval-defun’)を呼び出すと、それを評価する前にその定義を
インストルメントします。(ソースコード自体は変更しません
。) 変数‘edebug-all-defs’が非‘nil’の場合は、プレフィクス
引数の意味を反転します。この場合、‘C-M-x’はプレフィクス
引数が_なければ_その定義をインストルメントします。
‘edebug-all-defs’のデフォルト値は‘nil’です。コマンド‘M-x
edebug-all-defs’は、変数‘edebug-all-defs’の値を切り替え
ます。

   ‘edebug-all-defs’が非‘nil’の場合は‘eval-region’、
‘eval-current-buffer’、‘eval-buffer’も、それらが評価する
定義をインストルメントします。同様に、
‘edebug-all-forms’は、‘eval-region’が(非定義フォームさえ
含む）_あらゆる_フォームをインストルメントすべきかを制御
します。これはミニバッファー内でのロードや評価には適用さ
れません。コマンド‘M-x edebug-all-forms’は、このオプショ
ンを切り替えます。

   他にもコマンド‘M-x edebug-eval-top-level-form’が利用
可能で、これは‘edebug-all-defs’や‘edebug-all-forms’の値
に関わらず、トップレベルの任意のフォームをインストルメン
トします。‘edebug-defun’は‘edebug-eval-top-level-form’の
エイリアスです。

   Edebugがアクティブのの間、コマンド
‘I’(‘edebug-instrument-callee’)は、ポイント後のリストフ
ォームに呼び出される関数およびマクロ定義がまだインストル
メントされていなければ、それらをインストルメントします。
これは、そのファイルのソースの場所をEdebugが知っている場
合だけ可能です。この理由によりEdebugロード後は、たとえ評
価する定義をインストルメントしない場合でも、
‘eval-region’は評価するすべての定義の位置を記録します。
インストルメント済み関数呼び出しにステップインする‘i’コ
マンド(*note Jumping::を参照)も参照してください。

   Edebugはすべての標準スペシャルフォーム、式引数をもつ
‘interactive’フォーム、無名ラムダ式、およびその他の定義
フォームのインストルメント方法を知っています。しかし、
Edebugはユーザー定義マクロが引数にたいして何を行うかを判
断できないので、Edebug仕様を使用してその情報を与えなけれ
ばなりません。詳細は*note Edebug and Macros::を参照して
ください。

   Edebugがセッション内で最初にコードをインストルメント
しようとするときは、フック‘edebug-setup-hook’を実行して
から、それに‘nil’をセットします。使おうとしているパッケ
ージに結びつけてEdebug仕様をロードするためにこれを使用で
きますが、それはEdebugを使用するときだけ機能します。

   定義からインストルメントを削除するには、単にインスト
ルメントを行わない方法でその定義を再評価するだけです。フ
ォームを絶対にインストルメントせずに評価するには、2つの
方法があります。それはファイルからの‘load’による評価と、
ミニバッファーからの‘eval-expression’(‘M-:’)による評価で
す。

   Edebugがインストルメント中にシンタックスエラー(syntax
error: 構文エラー)を検知した場合は、間違ったコードの箇所
にポイントを残して‘invalid-read-syntax’エラーをシグナル
します。

   Edebug内で利用可能な他の評価関数については、*note
Edebug Eval::を参照してください。


File: elisp,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

17.2.3 Edebug Execution Modes
-----------------------------

Edebugは、デバッグするプログラムの実行にたいして、いくつ
かの実行モードをサポートします。これらの実行モードを、
“Edebug実行モード(Edebug execution modes)”と呼びます。こ
れらをメジャーモードやマイナーモードと混同しないでくださ
い。カレントのEdebug実行モードは、プログラムをストップす
る前にEdebugがどれだけ実行を継続するか — たとえばストッ
プポイントごとにストップ、あるいは次のbreakpointまで継続
など — と、ストップする前にEdebugがどれだけ進捗を表示す
るかを決定します。

   Edebug実行モードは通常、ある特定のモードでプログラム
を継続させるコマンドをタイプすることにより指定します。以
下は、それらのコマンドのテーブルです。プログラムの実行を
再開‘S’以外は、少なくともある長さの間だけ実行を継続しま
す。

‘S’
     Stop(ストップ): これ以上プログラムを実行しないで、
     Edebugのコマンドを待つ(‘edebug-stop’)。

‘<SPC>’
     Step(ステップ): 次のストップポイントでストップする
     (‘edebug-step-mode’)。

‘n’
     Next(次へ): 式の後にある次のストップポイントでスト
     ップする(‘edebug-next-mode’)。*note Jumping::の
     ‘edebug-forward-sexp’も参照。

‘t’
     Trace(トレース): Edebugのストップポイントごとに
     pause(通常は1秒)する(‘edebug-trace-mode’)。

‘T’
     Rapid trace(高速でトレース):ストップポイントごとに
     表示を更新するが、実際にpauseはしない
     (‘edebug-Trace-fast-mode’)。

‘g’
     Go(進む): 次のbreakpointまで実行する
     (‘edebug-go-mode’)。*note Breakpoints::を参照。

‘c’
     Continue(継続): breakpointごとにpauseしてから継続す
     る(‘edebug-continue-mode’)。

‘C’
     Rapid continue(高速で継続): ポイントを各
     breakpointへ移動するが、pauseしない
     (‘edebug-Continue-fast-mode’)。

‘G’
     Go non-stop(ストップせず進む): breakpointを無視する
     (‘edebug-Go-nonstop-mode’)。まだ‘S’、またはその他の
     編集コマンドでプログラムをストップするのは可能。

   一般的に、上記リストの最初のほうにある実行モードは後
のほうの実行モードに比べて、プログラムをより低速に実行、
またはすぐにストップさせます。

   実行中、またはトレース中は、任意のEdebugコマンドをタ
イプすることにより、実行をインタラプト(interrupt: 中断、
割り込み)できます。Edebugは次のストップポイントでプログ
ラムをストップしてから、タイプされたコマンドを実行します
。たとえば、実行中に‘t’をタイプすると、次のストップポイ
ントでトレースモードに切り替えます。‘S’を使用すれば、他
に何も行わずに実行をストップできます。

   関数でたまたま読み取り入力が発生した場合には、実行の
インタラプトを意図してタイプされた文字は、かわりにその関
数により読み取られます。そのプログラムが入力を欲するタイ
ミングに注意を払うことで、そのような意図せぬ結果を避ける
ことができます。

   このセクションのコマンドを含むキーボードマクロは、完
全には機能しません。プログラムを再開するためにEdebugから
exitすると、キーボードマクロの追跡記録は失われます。これ
を処理するのは、簡単ではありません。またEdebug外部でキー
ボードマクロを定義または実行しても、Edebug内部のコマンド
に影響しません。通常これは利点です。*note Edebug
Options::内の‘edebug-continue-kbd-macro’オプションも参照
してください。

   新たなEdebugレベルにエンターしたとき、初期の実行モー
ドは変数‘edebug-initial-mode’の値により与えられます
(*note Edebug Options::を参照)。デフォルトでこれはstepモ
ードを指定します。たとえば１つのコマンドからインストルメ
ント済みの関数が複数回呼び出された場合は、同じEdebugレベ
ルに再エンターするかもしれないことに注意してください。

 -- User Option: edebug-sit-for-seconds
     このオプションは、traceモードおよびcontinueモードで
     実行ステップの間を何秒待つか指定します。デフォルト
     は1秒です。


File: elisp,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

17.2.4 Jumping
--------------

このセクションで説明するコマンドは、指定された場所に達す
るまで実行を続けます。‘i’を除くすべてのコマンドは、スト
ップ場所を確立するために一時的なbreakpointを作成してから
、goモードにスイッチします。意図されたストップポイントの
前にある他のストップポイントに達した場合も、実行はストッ
プします。breakpointの詳細は、*note Breakpoints::を参照
してください。

   これらのコマンドは、非ローカルexitの場合はプログラム
のストップを期待する一時的なbreakpointをバイパスできるの
で、期待どおり機能しないかもしれません。

‘h’
     ポイントがある場所の近くのストップポイントへ実行を
     進める(‘edebug-goto-here’)。

‘f’
     プログラムの式を1つ分実行する
     (‘edebug-forward-sexp’)。

‘o’
     sexpを含む終端までプログラムを実行する
     (‘edebug-step-out’)。

‘i’
     ポイントの後のフォームから呼び出された関数またはマ
     クロにステップインする(‘edebug-step-in’)。

   ‘h’コマンドは一時的なbreakpointを使用して、ポイントの
カレント位置、またはその後のストップポイントまで処理を進
めます。

   ‘f’コマンドは式を1つ飛び越してプログラムを実家します
。より正確には、‘forward-sexp’により到達できる位置に一時
的なbreakpointをセットしてからgoモードで実行するので、プ
ログラムはそのbreakpointでストップすることになります。

   プレフィクス引数Nとともに使用した場合は、ポイントから
N個のsexp(s-expression: S式)を超えた場所に一時的な
breakpointをセットします。ポイントを含むリストがNより少
ない要素で終わるような場合は、ストップ箇所はポイントが含
まれる式の後になります。

   ‘forward-sexp’が見つける位置と、プログラムを実際にス
トップさせたい位置なのかチェックしなければなりません。た
とえば‘cond’内では、これは正しくないかもしれません。

   ‘f’コマンドは柔軟性を与えるために、‘forward-sexp’をス
トップポイントではなく、ポイント位置から開始します。_カ
レントのストップポイント_から1つの式を実行したい場合は、
まずそこにポイントを移動するために‘w’(‘edebug-where’)を
タイプして、それから‘f’をタイプしてください。

   ‘o’コマンドは、式の“外側”で実行を継続します。これは、
ポイントを含む式の最後に一時的なbreakpointを配します。ポ
イントを含むsexpが関数定義の場合、‘o’はその定義内の最後
のsexpの直前まで実行を継続します。もし定義内の最後の
sexpの直前にポイントがある場合は、その関数からリターンし
てからストップします。他の言い方をすると、このコマンドは
最後のsexpの後にポイントがない場合は、カレントで実行中の
関数からexitしません。

   ‘i’コマンドは、ポイントの後のリストフォームに呼び出さ
れた関数、またはマクロにステップインします。そのフォーム
は、評価されようとしているもの1つである必要はないことに
注意してください。しかし、そのフォームが評価されようとし
ている関数呼び出しの場合は、引数が何も評価されないうちに
このコマンドを使用しないと、遅すぎることを覚えておいてく
ださい。

   ‘i’コマンドは、ステップインしようとしている関数または
マクロがまだインストルメントされていない場合は、それらを
インストルメントします。これは便利かもしれませんが、それ
らを明示的に非インストルメントしない場合、その関数または
マクロはインストルメントされたままになることを覚えておい
てください。


File: elisp,  Node: Edebug Misc,  Next: Breaks,  Prev: Jumping,  Up: Edebug

17.2.5 Miscellaneous Edebug Commands
------------------------------------

ここでは、その他のEdebugコマンドを説明します。

‘?’
     Edebugのヘルプメッセージを表示する(‘edebug-help’)。

‘C-]’
     1レベルを中断して以前のコマンドレベルへ戻る
     (‘abort-recursive-edit’)。

‘q’
     エディターのトップレベルのコマンドループにリターン
     する(‘top-level’)。これは、すべてのレベルのEdebugア
     クティビティを含む、すべての再帰編集レベルをexitす
     る。しかし、フォーム‘unwind-protect’または
     ‘condition-case’で保護されたインストルメント済みの
     コードはデバッグを再開するかもしれない。

‘Q’
     ‘q’と同様だが、保護されたコードでもストップしない
     (‘edebug-top-level-nonstop’)。

‘r’
     エコーエリアに、もっとも最近の既知のコマンドを再表
     示する(‘edebug-previous-result’)。

‘d’
     backtraceを表示するが、明確であるようにEdebug自身の
     関数は除外される(‘edebug-backtrace’)。

     Edebugのbacktraceバッファーでは、標準デバッガ内のよ
     うにバッガコマンドは使用できない。

     実行を継続したとき、backtraceバッファーは自動的に
     killされる。

   Edebugから再帰的にEdebugをアクティブにするコマンドを
呼び出すことができます。Edebugがアクティブなときは常に、
‘q’によトップレベルの終了、または‘C-]’による再帰編集1レ
ベルの中断ができます。‘d’により、すべての未解決な評価の
backtraceを表示できます。


File: elisp,  Node: Breaks,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

17.2.6 Breaks
-------------

Edebugのstepモードは、次のストップポイントに達したときに
、実行をストップします。一度開始されたEdebugの実行をスト
ップするには、他に3つの方法があります。それは
breakpoint、グローバルbreak条件、およびソース
breakpointです。

* Menu:

* Breakpoints::              ストップポイントのbreakpoint。
* Global Break Condition::   イベントによるbreak。
* Source Breakpoints::       ソースコードに埋め込まれたbreakpoint。


File: elisp,  Node: Breakpoints,  Next: Global Break Condition,  Up: Breaks

17.2.6.1 Edebug Breakpoints
...........................

Edebugを使用しているときは、テスト中のプログラム内に
“breakpoint”を指定できます。breakpointとは、実行がストッ
プされる場所のことです。*note Using Edebug::で定義されて
いる任意のストップポイントに、breakpointをセットできます
。breakpointをセットおよび解除において影響を受けるストッ
プポイントは、ソースコードバッファー内でポイント位置、ま
たはポイント位置の後の最初のストップポイントです。以下は
Edebugのbreakpoint用のコマンドです:

‘b’
     ポイント位置、またはポイント位置の後のストップポイ
     ントに、breakpointをセットする
     (‘edebug-set-breakpoint’)。プレフィクス引数を使用し
     た場合、それは一時的なbreakpointになり、プログラム
     が最初にそこで停止したとき解除される。

‘u’
     (もしあれば)ポイント位置、またはポイント位置の後の
     ストップポイントにあるbreakpointを解除(unset)する
     (‘edebug-unset-breakpoint’)。

‘x CONDITION <RET>’
     CONDITIONを評価して非‘nil’値になる場合だけプログラ
     ムをストップする、条件付きbreakpointをセットする
     (‘edebug-set-conditional-breakpoint’)。プレフィクス
     引数を指定した場合は、一時的なbreakpointになる。

‘B’
     カレント定義内の、次のbreakpointにポイントを移動す
     る(‘edebug-next-breakpoint’)。

   Edebug内では、‘b’でbreakpointをセットして、‘u’でそれ
を解除できます。最初に望ましいストップポイントにポイント
を移動してから、そこにbreakpointをセットまたは解除するた
めに‘b’または‘u’をタイプしますbreakpointがない場所で
breakpointを解除しても、影響はありません。

   ある定義を再評価、または再インストルメントすると、以
前のbreakpointはすべて削除されます。

   “条件付きbreakpoint(conditional breakpoint)”は、プロ
グラムがそこに達するたびに条件をテストします。条件を評価
した結果エラーが発生した場合、エラーは無視され結果は
‘nil’になります。条件付きbreakpointをセットするには‘x’を
使用して、ミニバッファーで条件式を指定します。以前にセッ
トされた条件付きbreakpointがあるストップポイントに条件付
きbreakpointをセットすると、以前の条件式がミニバッファー
に配されるので、それを編集できます。

   プレフィクス引数を指定してbreakpointをセットするコマ
ンドを使用することにより、“一時的”な条件付きbreakpoint、
および無条件のbreakpointを作成できます。一時的な
breakpointによりプログラムがストップしたとき、その
breakpointは自動的に解除されます。

   Go-nonstopモードを除き、Edebugは常にbreakpointでスト
ップ、またはpauseします。Go-nonstopモードでは、
breakpointは完全に無視されます。

   breakpointがどこにあるか探すには、‘B’コマンドを使用し
ます。このコマンドは同じ関数内から、ポイント以降にある次
のbreakpoint(ポイント以降にbreakpointが存在しない場合は
最初のbreakpoint)にポイントを移動します。このコマンドは
実行を継続せず、単にバッファー内のポイントを移動します。


File: elisp,  Node: Global Break Condition,  Next: Source Breakpoints,  Prev: Breakpoints,  Up: Breaks

17.2.6.2 Global Break Condition
...............................

“グローバルbreak条件(global break condition)”は指定され
た条件が満たされたとき、それがどこで発生したかによらず、
実行をストップします。Edebugは、すべてのストップポイント
でグローバルbreak条件を評価します。これが非‘nil’値に評価
された場合は、あたかもそのストップポイントにbreakpointが
あったかのように、実行をストップまたはpauseします(実行モ
ードによる)。条件の評価でエラーを取得した場合は、実行を
ストップしません。

   条件式は‘edebug-global-break-condition’に格納されます
。Edebugがアクティブなときにソースバッファーから‘X’コマ
ンドを使用するか、Edebugがロードされている間は任意のバッ
ファーから任意のタイミングで‘C-x X
X’(‘edebug-set-global-break-condition’)を使用することに
より新たな式を指定できます。

   グローバルbreak条件は、コード内のどこでイベントが発生
したかを見つけるもっともシンプルな方法ですが、コードの実
行は遅くなります。そのため、使用しないときは条件を
‘nil’にリセットするべきです。


File: elisp,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breaks

17.2.6.3 Source Breakpoints
...........................

定義内のすべてのbreakpointは、それをインストルメントする
たびに失われます。breakpointが失われないようにしたい場合
は、ソースコード内で単に関数‘edebug’を呼び出す“ソース
breakpoint(source breakpoint)”を記述できます。もちろん、
そのような呼び出しを条件付きすることにもできます。たとえ
ば‘fac’関数内に以下のような行を1行目に挿入して、引数が
0になったときストップさせることができます:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   ‘fac’の定義がインストルメントされて呼び出されたとき、
‘edebug’呼び出しはbreakpointとして振る舞います。実行モー
ドに応じて、Edebugはそこでストップまたはpauseします。

   ‘edebug’が呼び出されたときにインストルメント済みのコ
ードが実行されていなければ、この関数は‘debug’を呼び出し
ます。


File: elisp,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breaks,  Up: Edebug

17.2.7 Trapping Errors
----------------------

エラーがシグナルされて、それが‘condition-case’でハンドル
されていないとき、Emacsは通常エラーメッセージを表示しま
す。Edebugがアクティブでインストルメント済みのコードを実
行中は、ハンドルされていないエラーには通常Edebugが対応し
ます。オプション‘edebug-on-error’および
‘edebug-on-quit’で、これをカスタマイズできます。*note
Edebug Options::を参照してください。

   Edebugがエラーに対応するときは、エラー発生箇所の前に
ある最後のストップポイントを表示します。この場所はインス
トルメントされていない関数の呼び出しで、その関数内で実際
にエラーが発生したのかもしれません。バインドされていない
変数に関するエラーの場合は、最後の既知のストップポイント
は、その不正な変数参照から遠く離れた場所かもしれません。
そのような場合は、完全なbacktraceを表示したいと思うでし
ょう(*note Edebug Misc::を参照)。

   Edebugがアクティブの間に‘debug-on-error’、または
‘debug-on-quit’を変更した場合、それらの変更はEdebugが非
アクティブになったとき失われます。さらに、Edebugの再帰編
集の間、これらの変数はEdebugの外部でもっていた値にバイン
ドされます。


File: elisp,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

17.2.8 Edebug Views
-------------------

これらのEdebugコマンドは、Edebugにエントリーする前のバッ
ファーの外観と、ウィンドウの状態を調べるコマンドです。外
部のウィンドウ構成は、ウィンドウのコレクションとその内容
であり、これらは実際にEdebugの外部にあります。

‘v’
     外部のウィンドウ構成ビューに切り替える
     (‘edebug-view-outside’)。Edebugにリターンするには、
     ‘C-x X w’をタイプする。

‘p’
     一時的に外部のカレントバッファーを表示し、ポイント
     もその外部の位置になる(‘edebug-bounce-point’)。
     Edebugにリターンする前に、1秒pauseする。プレフィク
     ス引数Nを指定すると、かわりにN秒pauseする。

‘w’
     ソースコードバッファー内のカレントストップポイント
     にポイントを戻す(‘edebug-where’)。

     このコマンドを同じバッファーを表示する異なるウィン
     ドウで使用した場合には、そのウィンドウは将来カレン
     ト定義を表示するために代用される。

‘W’
     Edebugが外部のウィンドウ構成を保存、およびリストア
     するかどうかを切り替える
     (‘edebug-toggle-save-windows’)。

     プレフィクス引数を指定すると、‘W’は選択されたウィン
     ドウの保存とリストアだけを切り替える。ソースコード
     バッファーを表示していないウィンドウを指定するには
     、グローバルキーマップから‘C-x X W’を使用しなければ
     ならない。

   ‘v’、または単に‘p’でカレントバッファーにポイントを反
跳させれば、たとえ通常は表示されないウィンドウでも、外部
のウィンドウ構成を調べることができます。

   ポイントを移動した後に、ストップポイントに戻りたいと
きがあるかもしれません。これは、ソースコードバッファーか
ら‘w’で行うことができます。どのバッファーにいても、‘C-x
X w’を使用すれば、ソースコードバッファー内のストップポイ
ントに戻ることができます。

   保存を_オフ_にするために‘W’を使用するたびに、Edebugは
外部のウィンドウ構成を忘れます。そのため、たとえ保存を
_オン_に戻しても、(プログラムを実行することにより)次に
Edebugをexitしたとき、カレントウィンドウ構成は変更されな
いまま残ります。しかし、十分な数のウィンドウをオープンし
ていない場合は、‘*edebug*’と‘*edebug-trace*’の再表示が、
あなたが見たいバッファーと競合するかもしれません。


File: elisp,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

17.2.9 Evaluation
-----------------

Edebug内では、まるでEdebugが実行されていないかのように、
式を評価できます。式の評価とプリントに際して、Edebugが不
可視になるよう試みます。。副作用をもつ式の評価は、
Edebugが明示的に保存とリストアを行うデータへの変更を除き
、期待したとおり機能するでしょう。このプロセスの詳細は、
*note The Outside Context::を参照してください。

‘e EXP <RET>’
     Edebugのコンテキスト外で、式EXPを評価する
     (‘edebug-eval-expression’)。つまり、Edebugはその式
     への干渉を最小限にしようと努める。

‘M-: EXP <RET>’
     Edebug自身のコンテキスト内で、式EXPを評価する
     (‘eval-expression’)。

‘C-x C-e’
     Edebugのコンテキスト外で、ポイントの前の式を評価す
     る(‘edebug-eval-last-sexp’)。

   Edebugは、‘cl.el’内の構文(‘lexical-let’、‘macrolet’、
‘symbol-macrolet’)により作成された、レキシカル
(lexical)にバインドされたシンボルへの参照を含む式の評価
をサポートします。


File: elisp,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

17.2.10 Evaluation List Buffer
------------------------------

式をインタラクティブに評価するために、‘*edebug*’と呼ばれ
る“評価リストバッファー(evaluation list buffer)”を使用で
きます。Edebugがディスプレイを更新するたびに自動的に評価
される、式の“評価リスト(evaluation list)”もセットアップ
できます。

‘E’
     評価リストバッファー‘*edebug*’に切り替える
     (‘edebug-visit-eval-list’)。

   ‘*edebug*’バッファーでは、以下の特別なコマンドと同様
に、Lisp Interactionモード(*note (emacs)Lisp
Interaction::)のコマンドも使用できます。

‘C-j’
     ポイントの前の式をコンテキスト外で評価して、その値
     をバッファーに挿入する
     (‘edebug-eval-print-last-sexp’)。

‘C-x C-e’
     Edebugのコンテキスト外で、ポイントの前の式を評価す
     る(‘edebug-eval-last-sexp’)。

‘C-c C-u’
     バッファー内のコンテンツから、新たに評価リストを構
     築する(‘edebug-update-eval-list’)。

‘C-c C-d’
     ポイントのある評価リストグループを削除する
     (‘edebug-delete-eval-item’)。

‘C-c C-w’
     ソースコードバッファーに切り替えてカレントストップ
     ポイントに戻る(‘edebug-where’)。

   評価リストウィンドウ内では、‘*scratch*’にいるときと同
様に、‘C-j’や‘C-x C-e’で式を評価できますが、それらは
Edebugのコンテキスト外で評価されます。

   インタラクティブに入力した式(とその結果)は、実行を継
続すると失われます。しかし、実行がストップされるたびに評
価されるように、式から構成される“評価リスト”をセットアッ
プできます。

   これを行なうには、評価リストバッファー内で1つ以上の
“評価リストグループ(evaluation list group)”を記述します
。評価リストグループは、1つ以上のLisp式から構成されます
。グループはコメント行で区切られます。

   コマンド‘C-c C-u’(‘edebug-update-eval-list’)は、バッ
ファーをスキャンして各グループの最初の式を使用して、評価
リストを再構築します。(これはグループの2つ目の式は以前に
計算、表示されている値だという発想からです。)

   Edebugにエントリーするたびに、評価リストの各式(および
式の後に式のカレント値)をバッファーに挿入して再表示しま
す。これはコメント行も挿入するため、各式はそのグループの
一員となります。したがって、バッファーのテキストを変更せ
ずに‘C-c C-u’とタイプした場合、評価リストは実際には変更
されません。

   評価リストからの評価の間にエラーが発生した場合、それ
が式の結果であるかのようにエラーメッセージが文字列で表示
されます。したがって、カレントで無効な変数を使用する式に
より、デバッグが中断されることはありません。

   以下は、いくつかの式を評価リストウィンドウに追加した
とき、どのように見えるかの例です:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   グループを削除するには、グループ内にポイントを移動し
て‘C-c C-d’をタイプするか、単にグループのテキストを削除
して‘C-c C-u’で評価リストを更新します。評価リストに新た
な式を追加するには、適切な箇所にその式を挿入し、新たなコ
メント行を挿入してから‘C-c C-u’をタイプします。コメント
行にダッシュを挿入する必要はありません — 内容は関係ない
のです。

   ‘*edebug*’を選択した後に、‘C-c C-w’でソースコードバッ
ファーにリターンできます。‘*edebug*’は実行を継続したとき
killされ、次回必要なとき再作成されます。


File: elisp,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

17.2.11 Printing in Edebug
--------------------------

プログラム内の式が循環リスト構造(circular list
structure)を含む値を生成する場合は、Edebugがそれをプリン
トしようとしたときエラーとなるかもしれません。

   循環構造への対処の1つに、‘print-length’および
‘print-level’にプリントの切り詰めをセットする方法があり
ます。Edebugは、変数‘edebug-print-length’および
‘edebug-print-level’の値(非‘nil’値をもつ場合)を、これら
の変数にバインドします。*note Output Variables::を参照し
てください。

 -- User Option: edebug-print-length
     非‘nil’の場合は、結果をプリントするときEdebugは
     ‘print-length’をこの値にバインドする。デフォルト値
     は‘50’。

 -- User Option: edebug-print-level
     非‘nil’の場合は、結果をプリントするときEdebugは
     ‘print-level’をこの値にバインドする。デフォルト値は
     ‘50’。

   ‘print-circle’を非‘nil’値にバインドして、循環構造や要
素を共有する構造を、より参考になる情報をプリントすること
もできます。

   以下は循環構造を作成するコードの例です:

     (setq a '(x y))
     (setcar a a)

カスタムプリントはこれを、‘Result: #1=(#1# y)’のようにプ
リントします。‘#1=’という表記はその後の構造をラベル‘1’と
ラベル付けし、‘#1#’表記はその前にラベル付けされた構造を
参照しています。この表記は、リストやベクターの任意の共有
要素に使用されます。

 -- User Option: edebug-print-circle
     非‘nil’の場合は、結果をプリントするときEdebugは
     ‘print-circle’をこの値にバインドする。デフォルト値
     は‘t’。

   他にプログラムもカスタムプリントを使用できます。詳細
は‘cust-print.el’を参照してください。


File: elisp,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

17.2.12 Trace Buffer
--------------------

Edebugは実行トレースを‘*edebug-trace*’という名前のバッフ
ァーに格納して記録できます。実行トレースとは関数呼び出し
よリターンのログのことで、関数名と引数、および値が確認で
きます。トレースレコードを有効にするには、
‘edebug-trace’を非‘nil’値にセットしてください。

   トレースバッファーの作成は、実行モードのトレースの使
用(*note Edebug Execution Modes::を参照)と同じではありま
せん。

   トレースレコードが有効なときは、関数へのエントリーと
exitのたびに、トレースバッファーに行が追加されます。関数
エントリーレコードは‘::::{’、および関数名と引数の値によ
り構成されます。関数exitレコードは‘::::}’、および関数名
と関数の結果により構成されます。

   ‘:’の数は、関数エントリーの再帰レベルを表します。トレ
ースバッファーでは、関数呼び出しの開始と終了の検索に
‘{’と‘}’を使用できます。

   関数‘edebug-print-trace-before’および
‘edebug-print-trace-after’を再定義することにより、関数エ
ントリーと関数exitのトレースレコードをカスタマイズできま
す。

 -- Macro: edebug-tracing string body...
     このマクロはBODYフォーム実行活動にたいする、追加の
     トレース情報をリクエストする。引数STRINGは、トレー
     スバッファーに配す‘{’または‘}’の後のテキストを指定
     する。すべての引数は評価され、‘edebug-tracing’は
     BODY内の最後のフォームの値をリターンする。

 -- Function: edebug-trace format-string &rest
          format-args
     この関数は、トレースバッファーにテキストを挿入する
     。テキストは、‘(apply 'format FORMAT-STRING
     FORMAT-ARGS)’により計算される。エントリー間の区切り
     として改行も付け加える。

   ‘edebug-tracing’および‘edebug-trace’は、たとえ
Edebugが非アクティブでも、呼び出されたときは常にトレース
バッファーに行を挿入します。トレースバッファーへのテキス
トの追加により、挿入された最後の行が見えるようにウィンド
ウもスクロールします。


File: elisp,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

17.2.13 Coverage Testing
------------------------

Edebugは基本的なカバレッジテスト(coverage test)と実行頻
度(execution frequency)の表示を提供します。

   カバレッジテストは、すべての式の結果と以前の結果を比
較することにより機能します。プログラム内のフォームがそれ
ぞれ、カレントEmacsセッション内でカバレッジテストを開始
して以降に、2つの異なる値をリターンした場合、それらのフ
ォームは“カバー”されたと判断します。したがって、プログラ
ムにカバレッジテストを行なうには、そのプログラムをさまざ
まなコンディション下で実行して、プログラムが正しく振る舞
うかに注目します。異なるコンディション下で十分にテストし
て、すべてのフォームが異なる2つの値をリターンしたとき、
Edebugはそのことを告げるでしょう。

   カバレッジテストにより実行速度が低下するので、
‘edebug-test-coverage’が非‘nil’のときだけカバレッジテス
トが行なわれます。頻度計数(frequency count)は、たとえ実
行モードがGo-nonstopでも、カバレッジテストが有効か無効か
に関わらず、すべての式にたいして処理されます。

   定義にたいするカバレッジ情報と頻度数の両方を表示する
には、‘C-x X =’(‘edebug-display-freq-count’)を使用する。
単に‘=’(‘edebug-temp-display-freq-count’)とすると、他の
キーをタイプするまでの間だけ、同様な情報を一時的に表示す
る。

 -- Command: edebug-display-freq-count
     このコマンドは、カレント定義の各行の頻度数を表示す
     る。

     このコマンドは、コードの各行の下にコメント行として
     頻度数を挿入する。1回の‘undo’コマンドで、すべての挿
     入をアンドゥできる。頻度数は式の前の‘(’、または式の
     後の‘)’、または変数の最後の文字の下に表示される。表
     示をシンプルにするために、同一行にたいして式の以前
     頻度数と頻度数が同じ場合は表示しない。

     ある式にたいする頻度数の後に文字‘=’がある場合、それ
     はその式が評価されるたびに毎回同じ値をリターンして
     いることを表す。他の言い方をすると、カバレッジテス
     トの目的からは、その式はまだ“カバー”されていないと
     いうことである。

     ある定義にたいして頻度数とカバレッジデータを明確に
     するには、単に‘eval-defun’で再インストルメントすれ
     ばよい。

   たとえば、ソースのbreakpointで‘(fac 5)’を評価した後、
‘edebug-test-coverage’を‘t’にセットすると、breakpointに
達したときの頻度データは以下のようになります:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      = =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   コメント行は、‘fac’が6回呼び出されたことを表していま
す。最初の‘if’命令は毎回同じ結果を5回リターンしています
。同じ結果という意味では、2つ目の‘if’の条件にも当てはま
ります。‘fac’の再帰呼び出しは、結局リターンしません。


File: elisp,  Node: The Outside Context,  Next: Edebug and Macros,  Prev: Coverage Testing,  Up: Edebug

17.2.14 The Outside Context
---------------------------

Edebugはデバッグ中のプログラムにたいして透過的であろうと
努めますが、完全には達成されません。Edebugは、‘e’や評価
リストバッファーで式を評価するときも、一時的に外部のコン
テキストをリストアして、透明化を試みます。このセクション
ではEdebugがリストアするコンテキストと、Edebugがいかにし
て完全に透過的になるのに失敗するかを正確に説明します。

* Menu:

* Checking Whether to Stop::  何を行うかをEdebugが決定するタイミング。
* Edebug Display Update::    Edebugがディスプレイを更新するタイミング。
* Edebug Recursive Edit::    Edebugが実行をストップするタイミング。


File: elisp,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

17.2.14.1 Checking Whether to Stop
..................................

Edebugにエンターするときは常に特定のデータの保存とリスト
アを行なう必要があり、それはトレース情報を作成するか、あ
るいはプログラムを停止するかを決定する前に行なう必要があ
ります。

   • ‘max-lisp-eval-depth’および‘max-specpdl-size’は、
     Edebugがスタック与える影響の低減効果を高める。しか
     しそれでも、Edebug使用時にスタック空間を使い切って
     しまうことはあり得る。

   • キーボードマクロの実行状態は保存およびリストアされ
     る。Edebugがアクティブの間、
     ‘edebug-continue-kbd-macro’が‘nil’の場合は、
     ‘executing-kbd-macro’が‘nil’にバインドされる。


File: elisp,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

17.2.14.2 Edebug Display Update
...............................

(たとえばtraceモードなどで)Edebugが何かを表示する必要が
あるときは、Edebugの“外部”からカレントウィンドウ構成
(*note Window Configurations::を参照)を保存します。
Edebugをexitするときに、以前のウィンドウ構成がリストアさ
れます。

   Emacsは、pause時だけ再表示を行います。通常は実行を継
続したときに、そのプログラムはbreakpointまたはステップ実
行後にEdebugに再エンターし、その間にpauseや入力の読み取
りはありません。そのような場合、Emacsが“外部”の構成を再
表示する機会は決してありません。結果として、ユーザーが目
にするウィンドウ構成は、前回Edebugが中断なしでアクティブ
だったときのウィンドウ構成と同じになります。

   何かを表示するためにEdebugにエントリーすることにより
、(たとえこれらのうちのいくつかは、エラーやquitがシグナ
ルされたときは、故意にリストアしないデータだとしても)以
下のデータも保存およびリストアされます。

   • どれがカレントバッファーか、そしてカレントバッファ
     ー内のポイントとマークの位置が、保存およびリストア
     される。

   • ‘edebug-save-windows’が非‘nil’の場合は、外部のウィ
     ンドウ構成が保存およびリストアされる(*note Edebug
     Options::を参照)。

     エラーやquitではウィンドウ構成はリストアされないが
     、‘save-excursion’がアクティブな場合は、たとえエラ
     ーやquitのとき外部の選択されたウィンドウが再選択_さ
     れる_。‘edebug-save-windows’の値がリストの場合は、
     それにリストされたウィンドウだけが保存およびリスト
     アされる。

     しかし、ソースコードバッファーのウィンドウの開始位
     置と水平スクロールはリストアされないので、表示は
     Edebug内で整合性が保たれたままとなる。

   • ‘edebug-save-displayed-buffer-points’が非‘nil’の場
     合、表示されているそれぞれのバッファー内のポイント
     値は、保存およびリストアされる。

   • 変数‘overlay-arrow-position’と
     ‘overlay-arrow-string’は保存およびリストアされるの
     で、同じバッファー内の他の場所の再帰編集から、安全
     にEdebugを呼び出せる。

   • ‘cursor-in-echo-area’は‘nil’にローカルにバインドさ
     れるので、カーソルはそのウィンドウ内に現れる。


File: elisp,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

17.2.14.3 Edebug Recursive Edit
...............................

Edebugにエンターしてユーザーのコマンドが実際に読み取られ
るとき、Edebugは以下の追加データを保存(そして後でリスト
ア)します:

   • カレントマッチデータ。*note Match Data::を参照。

   • 変数‘last-command’、‘this-command’、
     ‘last-command-event’、‘last-input-event’、
     ‘last-event-frame’、‘last-nonmenu-event’、
     ‘track-mouse’。Edebug内のコマンドは、Edebug外部のこ
     れらの変数に影響をあたえない。

     Edebug内でのコマンド実行は、‘this-command-keys’によ
     りリターンされるキーシーケンスを変更でき、Lispから
     そのキーシーケンスをリセットする方法はない。

     Edebugは‘unread-command-events’の値の保存およびリス
     トアができない。この変数が重要な値をもつときに
     Edebugにエンターすると、デバッグ中のプログラムの実
     行に干渉する可能性がある。

   • Edebug内で実行された複雑なコマンドは、変数
     ‘command-history’に追加される。これが稀に実行に影響
     を与える。

   • Edebug内では、再帰深さがEdebug外部の再帰深さより1つ
     深くなる。これは自動的に更新される評価リストウィン
     ドウでは異なる。

   • ‘standard-output’と‘standard-input’は
     ‘recursive-edit’により‘nil’にバインドされるが、
     Edebugは評価の間それらを一時的にリストアする。

   • キーボードマクロ定義の状態は、保存およびリストアさ
     れる。Edebugがアクティブの間、
     ‘defining-kbd-macro’は‘edebug-continue-kbd-macro’に
     バインドされる。


File: elisp,  Node: Edebug and Macros,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

17.2.15 Edebug and Macros
-------------------------

Edebugが正しくマクロを呼び出す式をインストルメントするに
は、いくつかの特定な配慮が必要になります。このサブセクシ
ョンでは、その詳細を説明します。

* Menu:

* Instrumenting Macro Calls::  基本的な問題点。
* Specification List::       式の複雑なパターンを指定する方法。
* Backtracking::             マッチに失敗したときEdebugが行なうこと。
* Specification Examples::   Edebug仕様を理解するために。


File: elisp,  Node: Instrumenting Macro Calls,  Next: Specification List,  Up: Edebug and Macros

17.2.15.1 Instrumenting Macro Calls
...................................

EdebugがLispマクロを呼び出す式をインストルメントするとき
は、正しくインストルメントを行なうために、そのマクロに関
して追加の情報が必要になります。これは、マクロ呼び出しの
どの部分式(subexpression)が評価されるフォームなのか推測
する方法がないからです。(評価はマクロのbodyで明示的に発
生するかもしれないし、展開結果が評価されるとき、または任
意のタイミングで行われるかもしれません。)

   したがって、Edebugが処理するかもしれないすべてのマク
ロにたいして、そのマクロの呼び出しフォーマットを説明する
ための、Edebug仕様(Edebug specification)を定義しなければ
なりません。これを行なうには、マクロ定義に‘debug’宣言を
追加します。以下はマクロ例‘for’(*note Argument
Evaluation::を参照)にたいする簡単な仕様の例です。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (declare (debug (symbolp "from" form "to" form "do" &rest form)))
       ...)

   このEdebug仕様は、マクロ呼び出しのどの部分が評価され
るフォームなのかを示しています。単純なマクロにたいする
Edebug仕様は、そのマクロ定義の正式な引数リストに非常に類
似している場合がありますが、Edebug仕様はマクロ引数に比べ
より汎的です。‘declare’フォームの詳細は、*note Defining
Macros::を参照してください。

   コードをインストルメントするときEdebugに仕様が確実に
解るよう注意してください。マクロ定義を含む他のファイルを
要求するために‘eval-when-compile’を使用するファイルから
関数をインストルメントする場合は、そのファイルを明示的に
ロードする必要があるかもしれません。

   ‘def-edebug-spec’によりマクロ定義から個々のマクロにた
いしてEdebug仕様を定義することもできます。Lispで記述され
たマクロ定義にたいしては‘debug’宣言を追加するほうが好ま
しく、その方が便利でもありますが、‘def-edebug-spec’では
Cで実装されたスペシャルフォームにたいしてEdebug仕様を定
義することが可能になります。

 -- Macro: def-edebug-spec macro specification
     マクロMACRO呼び出しのどの式が評価される式かを指定す
     る。SPECIFICATIONはEdebug仕様である。どちらの引数も
     評価されない。

     引数MACROは単なるマクロ名ではない、任意の実シンボル
     を指定できる。

   以下はSPECIFICATIONに指定できるシンボルと、引数を処理
する方法のテーブルです。

‘t’
     すべての引数は評価のためにインストルメントされる。

‘0’
     引数はインストルメントされない。

シンボル
     そのシンボルは、かわりに使用されるEdebug仕様をもた
     なければならない。このインダイレクションは、他の種
     類の仕様が見つかるまで繰り返される。これにより、他
     のマクロの仕様を継承できる。

リスト
     リストの要素はフォーム呼び出しの引数の型を記述する
     。仕様リストに指定できる要素については、以降のセク
     ションを参照。

   マクロがEdebug仕様をもたない場合は、‘debug’宣言および
‘def-edebug-spec’呼び出しのどちらを通じても、変数
‘edebug-eval-macro-args’が効果を発揮する。

 -- User Option: edebug-eval-macro-args
     これは、Edebugが明示的なEdebug仕様をもたないマクロ
     引数を扱う方法を制御する。‘nil’(デフォルト)の場合、
     引数は評価のためにインストルメントされない。それ以
     外は、すべての引数がインストルメントされる。


File: elisp,  Node: Specification List,  Next: Backtracking,  Prev: Instrumenting Macro Calls,  Up: Edebug and Macros

17.2.15.2 Specification List
............................

あるマクロ呼び出しにおいて、いくつかの引数は評価されるが
、それ以外の引数は評価されないような場合には、Edebug仕様
のために“仕様リスト(specification list)”が要求されます。
仕様リスト内のいくつかの要素は1つ以上の引数にマッチしま
づが、それ以外の要素は以降に続くすべての引数の処理を変更
します。後者は“仕様キーワード(specification keywords)”と
呼ばれ、(‘&optional’のように)‘&’で始まるシンボルです。

   仕様リストは、それ自身がリストであるような引数にマッ
チする部分リスト(sublist)、またはグループ化に使用される
ベクターを含むかもしれません。したがって部分式とグループ
は、仕様リストをレベル階層に細分化します。仕様キーワード
は、部分式やグループを含むものの残りに適用されます。

   仕様リストに選択肢や繰り返しが含まれる場合は、実際の
マクロの呼び出しにたいしてマッチさせるためにバックトラッ
クが要求されるかもしれません。詳細は、*note
Backtracking::を参照してください。

   Edebug仕様は、バランスのとれたカッコで括られた部分式
へのマッチ、フォームの再帰処理、インダイレクト仕様を通じ
た再帰などの、正規表現によるマッチングと、コンテキストに
依存しない文法構成を提供します。

   以下は仕様リストに使用できる要素と、その意味について
のテーブルです(使用例は*note Specification Examples::を
参照):

‘sexp’
     評価れない単一のLispオブジェクト。インストルメント
     されない。

‘form’
     評価される単一のLispオブジェクト。インストルメント
     される。

‘place’
     汎変数(generalized variable)。*note Generalized
     Variables::を参照。

‘body’
     ‘&rest form’の省略形。以下の‘&rest’を参照。

‘function-form’
     関数フォーム。クォートされた関数シンボル、クォート
     されたラムダ式、または(関数シンボルかラムダ式に評価
     される)フォームのうちのどれか。これはラムダ式の
     bodyをいずれかの方法でインストルメントするため、
     ‘function’よりも‘quote’でクォートされたラムダ式の引
     数にたいし有用。

‘lambda-expr’
     クォートされないラムダ式。

‘&optional’
     仕様リスト内の後続の要素はオプション。マッチしない
     要素が出現すると、Edebugはこのレベルのマッチングを
     停止する。

     後続が非オプションの要素であるような数個の要素をオ
     プションにするだけなら、‘[&optional SPECS...]’を使
     用する。複数の要素すべてのマッチ、または非マッチを
     指定するには、‘&optional [SPECS...]’を使用する。
     ‘defun’の例を参照。

‘&rest’
     仕様リスト内の後続のすべての要素は、0回以上繰り返さ
     れる。しかし、最後の繰り返しでは、仕様リスト内のす
     べての要素にたいするマッチングの前に式が終了しても
     問題はない。

     数個の要素を繰り返すには、‘[&rest SPECS...]’を使用
     する。各繰り返しにおいいてすべてマッチしなければな
     らない複数要素を指定するには、‘&rest [SPECS...]’を
     使用する。

‘&or’
     仕様リスト内の後続の各要素は選択肢。選択肢の1つがマ
     ッチしなければならず、マッチしない場合‘&or’仕様は失
     敗する。

     ‘&or’に続く各リスト要素は、単一の選択肢。複数のリス
     ト要素を単一の選択肢にグループ化するには、それらを
     ‘[...]’で括る。

‘&not’
     後続の各要素は、‘&or’が使用されたときのように選択肢
     にマッチするが、要素がマッチした場合に失敗する。ど
     れもマッチする要素がない場合は何もマッチされないが
     、‘&not’仕様は成功する。

‘&define’
     フォーム定義にたいする仕様であることを示す。フォー
     ム定義自体はインストルメントされない(つまりEdebugは
     フォーム定義の前後でストップしない)が、フォーム内部
     は通常はインストルメントされるであろう。‘&define’キ
     ーワードはリスト仕様の最初の要素であること。

‘nil’
     カレント引数レベルでマッチさせる引数が存在しない場
     合は成功し、それ以外は失敗する。部分リスト仕様とバ
     ッククォートの例を参照。

‘gate’
     引数はマッチされないがgateを通じたバックトラックは
     、このレベルの使用の残りをマッチングする間は無効に
     される。これは主に、特定の構文エラーメッセージを一
     般的にするために使用される。詳細は*note
     Backtracking::、および‘let’の例も参照。

‘OTHER-SYMBOL’
     仕様リスト内のその他の要素は、述語(predicate)かイン
     ダイレクト仕様(indirect specification)である。

     シンボルがEdebug仕様をもつ場合、“インダイレクト仕様
     (indirect specification)”はシンボル位置に使用される
     リスト仕様か、引数を処理するための関数のどちらかで
     ある。この仕様はマクロにたいする‘def-edebug-spec’の
     ように定義される。‘defun’の例を参照。

     それ以外の場合、シンボルは述語(predicate)である。述
     語は引数とともに呼び出され、述語が‘nil’をリターンし
     た場合、その仕様は失敗して引数はインストルメントさ
     れない。

     適切な述語としては‘symbolp’、‘integerp’、
     ‘stringp’、‘vectorp’、‘atom’が含まれる。

‘[ELEMENTS...]’
     要素のベクターは、要素を単一の“グループ仕様(group
     specification)”にグループ化する。このグループ仕様は
     、ベクター自体に何も行わない。

‘"STRING"’
     引数はSTRINGという名前のシンボルである。この仕様は
     、SYMBOLの名前がSTRINGであるクォートされたシンボル
     ‘'SYMBOL’と等価だが、文字列形式のほうが好ましい。

‘(vector ELEMENTS...)’
     引数は、要素が仕様内のELEMENTSにマッチするベクター
     である。バッククォートの例を参照。

‘(ELEMENTS...)’
     他のリストは“部分リスト仕様(sublist
     specification)”であり、引数は要素が仕様のELEMENTSに
     マッチするリストでなければならない。

     部分リスト仕様はドットリスト(dotted list)かもしれず
     、その場合対応するリスト引数はドットリストである。
     かわりに、ドットリスト仕様の最後のCDRが、(グループ
     化やインダイレクト仕様による)他の部分リスト仕様かも
     しれない(たとえば要素が非ドットリストにマッチする
     ‘(spec . [(more specs...)])’))。これはバッククォー
     トの例のような再帰仕様に有用。このような再帰を終了
     させるには、上述の‘nil’仕様も参照。

     ‘(specs . nil)’のように記述された部分リスト仕様は
     ‘(specs)’、‘(specs . (sublist-elements...))’は
     ‘(specs sublist-elements...)’と等価であることに注意
     。

   以下は‘&define’の後だけに出現する追加仕様のリストです
。‘defun’の例を参照してください。

‘name’
     引数(シンボル)は定義フォームの名前。

     定義フォームは名前フィールドをもつ必要はなく、複数
     の名前フィールドをもつかもしれない。

‘:name’
     この構成は引数に実際のマッチは行わない。‘:name’の後
     の要素はシンボルであり、その定義の追加の名前要素と
     して使用される。定義名に一意で静的な要素を加えるた
     めに、これを使用できる。複数回使用されるかもしれな
     い。

‘arg’
     引数(シンボル)は定義フォームの引数の名前である。し
     かし、lambda-listキーワード(‘&’で始まるシンボル)は
     許されない。

‘lambda-list’
     これはラムダリスト(ラムダ式の引数リスト)にマッチす
     る。

‘def-body’
     引数は定義内のコードのbodyである。これは上述の
     ‘body’と似ているが、定義のbodyはその定義に関連する
     情報を照会する別のEdebug呼び出しでインストルメント
     されていなければならない。定義内のより高位レベルの
     フォームリストには、‘def-body’を使用する。

‘def-form’
     引数は、定義内のもっとも高位レベルの単一フォームで
     ある。これは‘def-body’と似ているが、フォームリスト
     ではなく単一フォームのマッチに使用される。特別なケ
     ースとして、‘def-form’はフォームが実行されるときト
     レース情報を出力しないことも意味する。
     ‘interactive’の例を参照。


File: elisp,  Node: Backtracking,  Next: Specification Examples,  Prev: Specification List,  Up: Edebug and Macros

17.2.15.3 Backtracking in Specifications
........................................

あるポイント位置で仕様がマッチに失敗しても、構文エラーが
シグナルされるとは限りません。そのかわり“バックトラック
(backtracking)”が開始されます。バックトラックは、すべて
の選択肢をマッチングするまで行なわれます。最終的に引数リ
ストのすべての要素は仕様内の要素のいずれかとマッチしなけ
ればならず、仕様内の必須要素は引数のいずれかとマッチしな
ければなりません。

   構文エラーが検出されてもその時点では報告されず、より
高位レベルの選択肢のマッチングが終わった後、実際のエラー
箇所から離れたポイント位置でエラーが報告されるかもしれま
せん。しかしエラー発生時にバックトラックが無効なら、エラ
ーは即座に報告されるでしょう。ある状況においては、バック
トラックも自動的に再有効化されることに注意してください。
‘&optional’、‘&rest’、‘&or’により新たな選択肢が設定され
たとき、または部分リスト、グループ、インダイレクト仕様が
開始されたときは、バックトラックが自動的に有効になります
。バックトラックを有効、または無効にした場合の影響は、現
在処理中のレベルの残り要素と、低位レベルに限定されます。

   何らかのフォーム仕様(すなわち‘form’、‘body’、
‘def-form’、‘def-body’)をマッチングする間、バックトラッ
クは無効になっています。これらの仕様は任意のフォームにマ
ッチするので、何らかのエラーが発生するとしたらそれは高位
レベルではなく、そのフォーム自体の内部でなければなりませ
ん。

   バックトラックはクォートされたシンボルや文字列仕様と
のマッチに成功した後にも無効になります。なぜなら通常これ
は構成が認識されたことを示すからです。しかし、同じシンボ
ルで始まる一連の選択肢構成がある場合は、たとえば‘["foo"
&or [first case] [second case] ...]’のように、通常は選択
肢の外部にそのシンボルをファクタリングすることにより、こ
の制約に対処できます。

   ほとんどのニーズは、バックトラックを自動的に無効にす
る、これら2つの方法で満足させることができますが、
‘gate’仕様を使用して明示的にバックトラックを無効にするほ
うが便利なときもあります。これは、高位に適用可能な選択肢
が存在しないことが分かっている場合に有用です。‘let’仕様
の例を参照してください。


File: elisp,  Node: Specification Examples,  Prev: Backtracking,  Up: Edebug and Macros

17.2.15.4 Specification Examples
................................

以下で提供する例から学ぶことにより、Edebug仕様の理解が容
易になるかもしれません。

   スペシャルフォーム‘let’は、バインディングとbodyのシー
ケンスをもちます。各バインディングはそシンボル、またはシ
ンボルとオプションの部分リストです。以下の仕様では、部分
リストを見つけたらバックトラックを抑止するために、部分リ
スト内の‘gate’があることに注目してください。

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebugは‘defun’および関連する引数リスト、
‘interactive’仕様にたいして以下の仕様を使用します。式の
引数はその関数bodyの外部で実際に評価されるので、
interactiveフォームは特別に処理する必要があります。
(‘defmacro’にたいする仕様は‘defun’にたいする仕様と非常に
似ていますが、‘declare’命令文が許されます。)

     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; ドキュメント文字列が与えられた場合はマッチする。
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: ‘def-form’

   以下のバッククォートにたいする仕様は、ドットリストに
マッチさせる方法と、‘nil’を使用して再帰を終了させる方法
を説明するための例です。また、ベクターのコンポーネントを
マッチさせる方法も示しています。(Edebugにより定義される
実際の仕様は少し異なり、ドットリストについては失敗するか
もしれない非常に深い再帰を引き起こすためサポートしていま
せん。)

     (def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: elisp,  Node: Edebug Options,  Prev: Edebug and Macros,  Up: Edebug

17.2.16 Edebug Options
----------------------

以下のオプションは、Edebugの動作に影響を与えます:

 -- User Option: edebug-setup-hook
     Edebugが使用される前に呼び出される関数。この関数は
     毎回新たな値をセットする。Edebugこれらの関数を一度
     呼び出したら、その後‘edebug-setup-hook’‘nil’にリセ
     ットする。使用するパッケージに関係するEdebug仕様を
     ロードするために使用ｄきるが、それはEdebugを使用す
     るときだけである。*note Instrumenting::を参照。

 -- User Option: edebug-all-defs
     これが非‘nil’の場合は‘defun’や‘defmacro’のような定
     義フォームの普通に評価すると、Edebug用にインストル
     メントされる。これは‘eval-defun’、‘eval-region’、
     ‘eval-buffer’、and ‘eval-current-buffer’に適用され
     る。

     このオプションの切り替えには、コマンド‘M-x
     edebug-all-defs’を使用する。*note Instrumenting::を
     参照。

 -- User Option: edebug-all-forms
     これが非‘nil’の場合‘eval-defun’、‘eval-region’、
     ‘eval-buffer’、‘eval-current-buffer’は、たとえフォ
     ームが何も定義していなくても、すべてのフォームをイ
     ンストルメントする。これはロードとミニバッファー内
     の評価には適用されない。

     このオプションの切り替えには、コマンド‘M-x
     edebug-all-forms’を使用する。*note Instrumenting::を
     参照。

 -- User Option: edebug-save-windows
     これが非‘nil’の場合、Edebugはウィンドウ構成の保存と
     リストアを行なう。これにはある程度時間がかかるので
     、ウィンドウ構成に何が起こってもプログラムに関係し
     ない場合は、この変数を‘nil’にセットしたほうがよい。

     値がリストの場合は、リストされたウィンドウだけが保
     存およびリストアされる。

     Edebug内では、この変数をインタラクティブに変更する
     ために‘W’コマンドを使用できる。*note Edebug Display
     Update::を参照。

 -- User Option: edebug-save-displayed-buffer-points
     これが非‘nil’の場合、Edebugは表示されているすべての
     バッファー内のポイントを保存およびリストアする。

     選択されていないウィンドウ内に表示されているバッフ
     ァーのポイントを変更するコードをデバッグしている場
     合は、他のバッファーのポイントを保存およびリストア
     する必要がある。その後にEdebugまたはユーザーがその
     ウィンドウを選択した場合は、そのバッファー内のポイ
     ントは、そのウィンドウのポイント値に移動される。

     すべてのバッファー内のポイントの保存とリストアは、
     それぞれのウィンドウを2回選択する必要があり高価な処
     理のため、必要なときだけ有効にする。*note Edebug
     Display Update::を参照。

 -- User Option: edebug-initial-mode
     この変数が非‘nil’の場合、Edebugが最初にアクティブに
     なったときの、Edebugの最初の実行モードを指定する。
     指定できる値は‘step’、‘next’、‘go’、‘Go-nonstop’、
     ‘trace’、‘Trace-fast’、‘continue’、
     ‘Continue-fast’。

     デフォルト値は‘step’。*note Edebug Execution
     Modes::を参照。

 -- User Option: edebug-trace
     これが非‘nil’の場合が、各関数のエントリーとexitをト
     レースする。トレース出力は、関数のエントリーと
     exitを行ごとに、再帰レベルにしたがって
     ‘*edebug-trace*’という名前のバッファーに表示される
     。

     *note Trace Buffer::の‘edebug-tracing’も参照のこと
     。

 -- User Option: edebug-test-coverage
     非‘nil’の場合、Edebugはデバッグされるすべての式のカ
     バレッジをテストする。*note Coverage Testing::を参
     照。

 -- User Option: edebug-continue-kbd-macro
     非‘nil’の場合は、Edebug外で実行されている任意のキー
     ボードマクロの定義または実行を継続する。これはデバ
     ッグされないので、慎重に使用すること。*note Edebug
     Execution Modes::を参照。

 -- User Option: edebug-unwrap-results
     非‘nil’の場合、Edebugは式の結果を表示するときに、そ
     の式自体のインストルメント結果の削除を試みる。マク
     ロをデバッグするときは、式の結果自体がインストルメ
     ントされた式になるということに関連する。実際的な例
     ではないが、サンプル例の関数‘fac’がインストルメント
     されたとき、そのフォームのマクロを考えてみるとよい
     。

          (defmacro test () "Edebug example."
            (if (symbol-function 'fac)
                ...))

     ‘test’マクロをインストルメントしてステップ実行する
     と、デフォルトでは‘symbol-function’呼び出しは多数の
     ‘edebug-after’フォームと‘edebug-before’フォームをも
     つことになり、それにより“実際の”結果の確認が難しく
     なり得る。‘edebug-unwrap-results’が非‘nil’の場合、
     Edebugは結果からこれらのフォームの削除を試みる。

 -- User Option: edebug-on-error
     ‘debug-on-error’の以前が‘nil’の場合、Edebugは
     ‘debug-on-error’をこの値にバインドする。*note
     Trapping Errors::を参照。

 -- User Option: edebug-on-quit
     ‘debug-on-quit’の以前の値が‘nil’の場合、Edebugは
     ‘debug-on-quit’にこの値をバインドする。*note
     Trapping Errors::を参照。

   Edebugがアクティブな間に‘edebug-on-error’または
‘edebug-on-quit’の値を変更した場合は、_次回_に新たなコマ
ンドを通じてEdebugが呼び出されるまで、これらの値は使用さ
れない。

 -- User Option: edebug-global-break-condition
     非‘nil’の場合、値はすべてのステップポイントでテスト
     される式である。式の結果が‘nil’の場合は、breakする
     。エラーは無視される。*note Global Break
     Condition::を参照。


File: elisp,  Node: Syntax Errors,  Next: Test Coverage,  Prev: Edebug,  Up: Debugging

17.3 Debugging Invalid Lisp Syntax
==================================

Lispリーダーは無効な構文(invalid syntax)について報告はし
ますが、実際の問題箇所は報告しません。たとえば、ある式を
評価中のエラー“End of file during parsing(パース中にファ
イル終端に達した)”は、開カッコまたは開角カッコ(open
parenthese or open square bracket)が多いことを示していま
す。Lispリーダーはこの不一致をファイル終端で検出しました
が、本来閉カッコがあるべき箇所を解決することはできません
。同様に、“Invalid read syntax: ")"(無効なread構文
:)")"”は開カッコの欠落を示していますが、欠落しているカッ
コが属すべき場所は告げません。ならば、どうやって変更すべ
き箇所を探せばよいのでしょうか?

   問題が単なるカッコの不一致でない場合の便利なテクニッ
クは、各defunの先頭で‘C-M-e’とタイプして、そのdefunの最
後と思われる箇所に移動するか確認する方法です。もし移動し
なければ、問題はそのdefunの内部にあります。

   マッチしないカッコがLispにおいてもっとも一般的な構文
エラーなので、これらのケースにたいしてさらにアドバイスす
ることができます。(Show Parenモードを有効にしてコードに
ポイントを移動するだけで、カッコの不一致を探しやすくなる
でしょう。)

* Menu:

* Excess Open::              誤った開カッコと閉カッコを探す方法。
* Excess Close::             誤った閉カッコと開カッコを探す方法。


File: elisp,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

17.3.1 Excess Open Parentheses
------------------------------

カッコがマッチしないdefunを探すのが、最初のステップです
。過剰な開カッコが存在する場合は、ファイルの終端に移動し
て‘C-u C-M-u’とタイプします。これにより、カッコがマッチ
しない最初のdefunの先頭に移動するでしょう。

   何が間違っているのか正確に判断するのが次のステップで
す。これを確実に行なうには、そのプログラムを詳しく調べる
以外に方法はありませんが、カッコがあるべき箇所を探すのに
、既存のインデントが手掛かりになることが多々あります。
‘C-M-q’で再インデントして何が移動されるか確認するのが、
この手掛かりを使用するもっとも簡単な方法です。*しかし、
行うのはちょっと待ってください!* まず続きを読んでからに
しましょう。

   これを行なう前に、defunに十分な閉カッコがあるか確認し
ます。十分な閉カッコがない場合、‘C-M-q’がエラーとなるか
、そのdefunからファイル終端までの残りすべてが再インデン
トされます。その場合はdefunの最後に移動して、そこに閉カ
ッコを挿入します。そのdefunのカッコの釣り合いがとれるま
では、defunの最後に移動するのに‘C-M-e’は使用できません
(失敗するでしょう)。

   これでdefunの先頭に移動して‘C-M-q’とタイプすることが
できます。通常は、一定のポイントからその関数の最後までの
すべての行が、右へとシフトされるでしょう。これはおそらく
そのポイント付近で閉カッコが欠落しているか、不要な開カッ
コがあります。(しかし、これを真実と仮定せず、コードを詳
しく調べてください。) 不一致箇所が見つけたら、元のインデ
ントはおそらく意図されたカッコに適しているはずなので、
‘C-_’で‘C-M-q’をアンドゥしてください。

   問題をfixできたと思った後に、再度‘C-M-q’を使用します
。実際に元のインデントが意図したカッコのネストに適合して
いて、足りないカッコを追加していたら、‘C-M-q’は何も変更
しないはずです。


File: elisp,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

17.3.2 Excess Close Parentheses
-------------------------------

過剰な閉カッコへの対処は、まずファイルの先頭に移動してか
ら、カッコのマッチしないdefunを探すために‘C-u -1 C-M-u’を
タイプします。

   それから、そのdefunの先頭で‘C-M-f’をタイプして、実際
にマッチする閉カッコを探します。これにより、そのdefunの
終端より幾分手前の箇所に移動するでしょう。その付近に間違
った閉カッコが見つかるでしょう。

   そのポイントに問題が見つからない場合には、そのdefunの
先頭で‘C-M-q’をタイプするのが次のステップです。ある行範
囲はおそらく左へシフトするでしょう。その場合、欠落してい
る開カッコまたは間違った閉カッコは、おそらくそれらの行の
1行目の近くにあるでしょう。 (しかし、これを真実と仮定せ
ず、コードを詳しく調べてください。)不一致箇所が見つけた
ら、元のインデントはおそらく意図されたカッコに適している
はずなので、‘C-_’で‘C-M-q’をアンドゥしてください。

   問題をfixできたと思った後に、再度‘C-M-q’を使用します
。実際に元のインデントが意図したカッコのネストに適合して
いて、足りないカッコを追加していたら、‘C-M-q’は何も変更
しないはずです。


File: elisp,  Node: Test Coverage,  Next: Profiling,  Prev: Syntax Errors,  Up: Debugging

17.4 Test Coverage
==================

‘testcover’ライブラリーをロードして、コマンド‘M-x
testcover-start <RET> FILE <RET>’でコードをインストルメ
ントすることにより、Lispコードのファイルにたいしてカバレ
ッジテストを行なうことができます。コードを1回以上呼び出
すことにより、テストが行なわれます。コマンド‘M-x
testcover-mark-all’を使用すれば、カバレッジが不十分な箇
所が色付きでハイライト表示されます。コマンド‘M-x
testcover-next-mark’は、次のハイライトされた箇所へポイン
トを前方に移動します。

   通常、赤くハイライトされた箇所はそのフォームが完全に
評価されたことが一度もないことを示し、茶色でハイライトさ
れた箇所は常に同じ値に評価された(その結果にたいして少し
しかテストされていない)ことを意味します。しかし、
‘error’のように完全に評価するのが不可能なフォームにたい
しては、赤いハイライトはスキップされます。‘(setq x 14)’の
ように、常に同じ値に評価されることが期待されるフォームに
たいしては、茶色のハイライトスキップされます。

   難しいケースでは、テストカバレッジツールにアドバイス
を与えるために、コードにdo-nothingマクロを追加することが
できます。

 -- Macro: 1value form
     FORMを評価してその値をリターンするが、テストカバレ
     ッジにたいしてFORMが常に同じ値だという情報を与える
     。

 -- Macro: noreturn form
     FORMを評価し、FORMが決してリターンしないという情報
     をカバレッジテストに与える。もしリターンした場合は
     、run-timeエラーとなる。

   Edebugにもカバレッジテスト機能があります(*note
Coverage Testing::を参照)。これらの機能は部分的に重複し
ており、組み合わせることで明確になるでしょう。


File: elisp,  Node: Profiling,  Prev: Test Coverage,  Up: Debugging

17.5 Profiling
==============

プログラムは正常に機能しているものの、より高速にまたは効
率的に実行させたい場合にまず行うべきは、そのプログラムが
リソースをどのように使用するか知るために、コードを“プロ
ファイル(profile)”することです。ある特定の関数の実行が、
実行時間のうち無視できない割り合いを占めるようなら、その
部分を最適化する方法を探すことを開始できます。

   Emacsには、このためのビルトインサポートがあります。プ
ロファイリングを開始するには、‘M-x profiler-start’をタイ
プします。プロファイルはプロセッサー使用(processor
usage)、メモリー使用(memory usage)、またはその両方を選択
できます。何らかの処理を行った後に‘M-x profiler-report’と
タイプすると、プロファイルに選択した各リソースが
summaryバッファーに表示されます。reportバッファーの名前
には、そのレポートが生成された時刻が含まれるので、前の結
果を消去せずに後で他のレポートを生成できます。プロファイ
リングが終了したら、‘M-x profiler-stop’とタイプしてくだ
さい(プロファイリングに関連したオーバーヘッドが少しある
からです)。

   profiler reportバッファーでは、各行に呼び出された関数
と、その後にプロファイリングが開始されてから使用したリソ
ース(プロセッサーまたはメモリー)の絶対時間とパーセンテー
ジ時間が表示されます。左側にシンボル‘+’のある行では
<RET>をタイプして行を展開して、高位レベルの関数に呼び出
された関数を確認できます。もう一度<RET>をタイプすると、
元の状態へと行が折り畳まれます。

   ‘j’または‘mouse-2’を押下すると、関数の定義にジャンプ
します。‘d’を押下すると、関数のドキュメントを閲覧できま
す。‘C-x C-w’を使用して、プロファイルをファイルに保存で
きます。‘=’を使用すれば、2つのプロファイルを比較すること
ができます。

   ‘elp’ライブラリーは、別のアプローチを提案します。使い
方は‘elp.el’を参照してください。

   ‘benchmark’ライブラリーを使用して、Emacs Lispフォーム
のスピードwpy個別にチェックできます。‘benchmark.el’内の
関数‘benchmark-run’、および‘benchmark-run-compiled’を参
照してください。

   ‘configure’のオプションに‘--enable-profiling’を使用し
てビルドすることにより、EmacsをCコードのレベルでプロファ
イルすることができます。こうしてビルドされたEmacsは、
Emacsをexitするときに‘gprof’ユーティリティを使用して検証
できるファイル‘gmon.out’を生成します。この機能は主に
Emacsのデバッグに有用です。このEmacsは、実行状態から上述
の‘M-x profiler-...’コマンドによりLispレベルで実際にスト
ップします。


File: elisp,  Node: Read and Print,  Next: Minibuffers,  Prev: Debugging,  Up: Top

18 Reading and Printing Lisp Objects
************************************

“プリント(print)”および“読み取り(read)”は、Lispオブジェ
クトからテキスト形式への変換、またはその逆の変換を行なう
操作です。これらは*note Lisp Data Types::で説明したプリ
ント表現(printed representation)と入力構文(read syntax)を
使用します。

   このチャプターでは、読み取りおよびプリントのための
Lisp関数について説明します。このチャプターではさらに“ス
トリーム(stream)”についても説明します。ストリームとは、
(読み取りにおいては)テキストがどこから取得されるか、(プ
リントにおいては)テキストをどこに出力するかを指定します
。

* Menu:

* Streams Intro::            ストリーム、読み取り、プリントの概観。
* Input Streams::            入力ストリームとして使用できる、さまざまなデータ型。
* Input Functions::          テキストからLispオブジェクトを読み取る関数。
* Output Streams::           出力ストリームとして使用できる、さまざまなデータ型。
* Output Functions::         テキストとしてLispオブジェクトをプリントする関数。
* Output Variables::         プリント関数が何を行うか制御する変数。


File: elisp,  Node: Streams Intro,  Next: Input Streams,  Up: Read and Print

18.1 Introduction to Reading and Printing
=========================================

Lispオブジェクトの“読み取り”とは、テキスト形式のLisp式を
パース(parse: 構文解析)して、対応するLispオブジェクトを
生成することを意味します。これは、LLispプログラムが
LispコードファイルからLispに取得される方法でもあります。
わたしたちは、そのテキストをそのオブジェクトの“入力構文
(read syntax)”と呼んでいます。たとえばテキスト‘(a . 5)’は
、CARが‘a’でCDRが数字の5であるようなコンスセルにたいする
入力構文です。

   Lispオブジェクトの“プリント”とは、あるオブジェクトを
そのオブジェクトの“プリント表現(printed representation)”
(*note Printed Representation::を参照)に変換することによ
り、そのオブジェクトを表すテキストを生成することを意味し
ます。上述のコンスセルをプリントすると、テキスト‘(a .
5)’が生成されます。

   読み取りとプリントは、概ね逆の処理といえます。あるテ
キスト断片を読み取った結果生成されたオブジェクトをプリン
トすると、多くの場合は同じテキストが生成され、あるオブジ
ェクトをプリントした結果のテキストを読み取ると、通常は同
じようなオブジェクトが生成されます。たとえばシンボル
‘foo’をプリントするとテキスト‘foo’が生成され、そのテキス
トを読み取るとシンボル‘foo’がリターンされます。要素が
‘a’と‘b’のリストをプリントするとテキスト‘(a b)’が生成さ
れ、そのテキストを読み取ると、(同じリストではないが)要素
が‘a’と‘b’のリストが生成されます。

   しかし、これら2つの処理は互いにまったく逆の処理という
わけではありません。３つの例外があります:

   • プリントは読み取ることが不可能なテキストを生成でき
     る。たとえば、バッファー、フレーム、サブプロセス、
     マーカーは‘#’で始まるテキストとしてプリントされる。
     このテキストの読み取りを試行すると、エラーとなる。
     これらのデータ型を読み取る方法は存在しない。

   • 1つのオブジェクトが、複数のテキスト的な表現をもつこ
     とができる。たとえば‘1’と‘01’は同じ整数を表し、‘(a
     b)’と‘(a . (b))’は同じリストを表す。読み取りは複数
     の候補を受容するかもしれないが、プリントはそのうち
     のただ1つを選択しなければならない。

   • あるオブジェクトの読み取りシーケンスの中間の特定ポ
     イントに、読み取り結果に影響を与えないコメントを置
     くことができる。


File: elisp,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Read and Print

18.2 Input Streams
==================

テキストを読み取るLisp関数の大部分は、引数として“入力ス
トリーム(input stream)”をとります。入力ストリームは、読
み取られるテキストの文字をどこから、どのように取得するか
を指定します。以下は可能な入力ストリーム型です:

BUFFER
     入力文字はBUFFERのポイントの後の文字から直接読み取
     られる。文字の読み取りとともに、ポイントが進む。

MARKER
     入力文字はMARKERのあるバッファーの、マーカーの後の
     文字から直接読み取られる。文字の読み取りとともに、
     マーカーが進む。ストリームがマーカーのときは、バッ
     ファー内のポイント値に影響はない。

STRING
     入力文字はSTRINGの最初の文字から必要な文字数分が取
     得される。

FUNCTION
     入力文字はFUNCTIONから生成され、その関数は2種類の呼
     び出しをサポートしなければならない:

        • 引数なしで呼び出されたときは、次の文字をリター
          ンする。

        • 1つの引数(常に文字)で呼び出されたとき、
          FUNCTIONは引数を保存して、次の呼び出しでリター
          ンするよう用意する。これは文字の“読み戻し
          (unreading)”と呼ばれ、Lispリーダーが1文字多く
          読みとったとき、それを“読みとったところに戻し
          たい”ときに発生する。この場合には、FUNCTIONの
          リターン値と同じこと。

‘t’
     ‘t’は、その入力がミニバッファーから読み取られるスト
     リームであることを意味する。実際にはミニバッファー
     が1回呼び出されて、ユーザーから与えられたテキストが
     、その後に入力ストリームとして使用される文字列とな
     る。Emacsがbatchモードで実行されている場合は、ミニ
     バッファーのかわりに標準入力が使用される。たとえば
     、
          (message "%s" (read t))
     このような場合は標準入力からLisp式が読み取られて、
     結果は標準出力にプリントされるだろう。

‘nil’
     入力ストリームとして‘nil’が与えられた場合は、かわり
     に‘standard-input’の値が使用されることを意味する。
     この値は“デフォルトの入力ストリーム(default input
     stream)”であり、非‘nil’の入力ストリームでなければな
     らない。

SYMBOL
     入力ストリームとしてのシンボルは、(もしあれば)その
     シンボルの関数定義と等価である。

   以下の例では、バッファーストリームから読み込み、読み
取りの前後におけるポイント位置を示しています:

     ---------- Buffer: foo ----------
     This★ is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          ⇒ is
     (read (get-buffer "foo"))
          ⇒ the

     ---------- Buffer: foo ----------
     This is the★ contents of foo.
     ---------- Buffer: foo ----------

最初の読み取りではスペースがスキップされていることに注意
してください。読み取りにおいては、意味のあるテキストに先
行する、任意のサイズの空白文字がスキップされます。

   以下は、マーカーストリームからの読み取りの例で、最初
は表示されているバッファーの先頭にマーカーが配します。読
み取られた値はシンボル‘This’です。


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          ⇒ #<marker at 1 in foo>
     (read m)
          ⇒ This
     m
          ⇒ #<marker at 5 in foo>   ;; 最初のスペースの前。

   以下では、文字列のコンテンツから読み取っています:

     (read "(When in) the course")
          ⇒ (When in)

   以下はミニバッファーから読み取る例です。プロンプトは
、‘Lisp expression: ’です。(このプロンプトはストリーム
‘t’から読み取る際は常に使用されます。) ユーザーの入力は
プロンプトの後に表示されます。

     (read t)
          ⇒ 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   最後は、‘useless-stream’という名前の関数ストリームか
ら読み取る例です。ストリームを使用する前に、変数
‘useless-list’を文字のリストに初期化しています。その後は
、リスト内の次の文字を取得するため、または文字をリストの
先頭に追加することにより読み戻すために、関数
‘useless-stream’を呼び出します。

     (setq useless-list (append "XY()" nil))
          ⇒ (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          ⇒ useless-stream

このストリームを使って、以下のように読み取ります:

     (read 'useless-stream)
          ⇒ XY

     useless-list
          ⇒ (40 41)

開カッコと閉カッコがリスト内に残ることに注意してください
。Lispリーダーは開カッコに出会うと、それを入力の終わりと
判断して、読み戻します。次にこのポイント位置からこのスト
リームを読み取ると、‘()’が読み取られて‘nil’がリターンさ
れます。


File: elisp,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Read and Print

18.3 Input Functions
====================

このセクションでは、読み取りに関係のあるLisp関数と変数に
ついて説明します。

   以下の関数で、STREAMは入力ストリーム(前のセクションを
参照)を意味します。STREAMが‘nil’、または省略された場合の
デフォルト値は‘standard-input’です。

   読み取りにおいて終端されていないリスト、ベクター、文
字列に遭遇した場合は、‘end-of-file’がシグナルされます。

 -- Function: read &optional stream
     この関数はSTREAMからテキスト表現されたLisp式を1つ読
     み取り、Lispオブジェクトとしてリターンする。これは
     基本的なLisp入力関数である。

 -- Function: read-from-string string &optional start
          end
     この関数はSTRING内のテキストから、最初のテキスト表
     現されたLisp式を読み取る。リターン値はCARがその式で
     、CDRが次に読み取られるその文字列内の残りの文字(読
     み取られていない最初の文字)の位置を与える整数である
     ようなコンスセルである。

     STARTが与えられた場合は、文字列内のインデックス
     START(最初の文字はインデックス0)から読み取りが開始
     される。ENDを指定した場合は、残りの文字列が存在しな
     いかのごとく、そのインデックスの直前で読み取りがス
     トップされる。

     たとえば:

          (read-from-string "(setq x 55) (setq y 5)")
               ⇒ ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               ⇒ ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               ⇒ ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               ⇒ (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               ⇒ (11 . 8)

 -- Variable: standard-input
     この変数はデフォルト入力ストリーム(引数STREAMが
     ‘nil’のとき‘read’が使用するストリーム)を保持する。
     デフォルトは‘t’で、これはミニバッファーを使用するこ
     とを意味する。

 -- Variable: read-circle
     非‘nil’の場合、この変数は循環構造(circular
     structure)および共有構造(shared structures)の読み取
     りを有効にする。*note Circular Objects::を参照。デ
     フォルト値は‘t’。


File: elisp,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Read and Print

18.4 Output Streams
===================

出力ストリームは、プリントにより生成された文字に何を行う
かを指定します。ほとんどのプリント関数は、オプション引数
として出力ストリームを受け入れます。以下は利用できる出力
ストリーム型です:

BUFFER
     出力文字は、BUFFERのポイント位置に挿入される。文字
     が挿入された分、ポイントが進む。

MARKER
     出力文字は、MARKERのあるバッファーのマーカー位置に
     挿入される。文字が挿入された分、マーカー位置が進む
     。ストリームがマーカーのときは、そのバッファー内の
     ポイント位置にプリントは影響せず、この種のプリント
     でポイントは移動しない(マーカー位置がポイント位置、
     またはポイント位置より前の場合は除外される。通常は
     テキストの周囲にポイントが進む)。

FUNCTION
     出力文字は、文字を格納する役目をもつFUNCTIONに渡さ
     れる。この関数は１つの文字を引数に、出力される文字
     の回数呼び出され、その文字を格納したい場所に格納す
     る役目をもつ。

‘t’
     出力文字はエコーエリアに表示される。

‘nil’
     出力ストリームに‘nil’が指定された場合は、かわりに
     ‘standard-output’の値が使用されることを意味する。こ
     の値は“デフォルトの出力ストリーム(default output
     stream)”であり、非‘nil’でなければならない。

SYMBOL
     出力ストリームとしてのシンボルは、(もしあれば)その
     シンボルの関数定義と等価である。

   有効な出力ストリームの多くは、入力ストリームとしても
有効です。したがって入力ストリームと出力ストリームの違い
は、Lispオブジェクトの型ではなく、どのようにLispオブジェ
クトを使うかという点です。

   以下はバッファーを出力ストリームとして使用する例です
。ポイントは最初は‘the’の中の‘h’の直前にあります。そして
最後も、同じ‘h’の直前に配されます。

     ---------- Buffer: foo ----------
     This is t★he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          ⇒ "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     ★he contents of foo.
     ---------- Buffer: foo ----------

   次はマーカーを出力ストリームとして使用する例です。マ
ーカーは最初、バッファー‘foo’内の単語‘the’の中の‘t’と
‘h’の間にあります。最後には、挿入されたテキストによりマ
ーカーが進み、同じ‘h’の前に留まります。通常の方法で見ら
れるようなポイント位置への影響がないことに注意してくださ
い。

     ---------- Buffer: foo ----------
     This is the ★output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          ⇒ #<marker at 10 in foo>

     (print "More output for foo." m)
          ⇒ "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he ★output
     ---------- Buffer: foo ----------

     m
          ⇒ #<marker at 34 in foo>

   以下はエコーエリアに出力を表示する例です:

     (print "Echo Area output" t)
          ⇒ "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   最後は関数を出力ストリームとして使用する例です。関数
‘eat-output’は与えられたそれぞれの文字を‘last-output’の
先頭にconsします(*note Building Lists::を参照)。最後には
、リストには出力されたすべての文字が逆順で含まれます。

     (setq last-output nil)
          ⇒ nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          ⇒ eat-output

     (print "This is the output" 'eat-output)
          ⇒ "This is the output"

     last-output
          ⇒ (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)

このリストを逆転すれば、正しい順序で出力することができま
す:

     (concat (nreverse last-output))
          ⇒ "
     \"This is the output\"
     "

‘concat’を呼び出してリストを文字列に変換すれば、内容をよ
り明解に確認できます。


File: elisp,  Node: Output Functions,  Next: Output Variables,  Prev: Output Streams,  Up: Read and Print

18.5 Output Functions
=====================

このセクションでは、オブジェクトをオブジェクトのプリント
表現に変換してLispオブジェクトをプリントするLisp関数を説
明します。

   Emacsプリント関数には、正しく読み取れるように必要なと
き出力にクォート文字を追加するものがあります。使用される
クォート文字は‘"’と‘\’です。これらは文字列をシンボルと区
別するとともに、文字列およびシンボル内の区切り文字が読み
取り時に区切り文字として扱われることを防ぎます。完全な詳
細は*note Printed Representation::を参照してください。ク
ォートするかしないかは、プリント関数の選択により指定でき
ます。

   そのテキストがLispに読み戻す場合、同様にLispプログラ
マーにLispオブジェクトを明解に説明するのが目的の場合は、
曖昧さを避けるためにクォート文字をプリントするべきです。
しかし、プログラマー以外の人間にたいして出力の見栄えを良
くするのが目的なら、通常はクォートなしでプリントしたほう
がよいでしょう。

   Lispオブジェクトは自己参照ができます。通常の方法で自
己参照オブジェクトをプリントするにはテキストが無限に必要
で、その試みにより無限再帰が発生する恐れがあります。
Emacsはそのような再帰を検知して、すでにプリントされたオ
ブジェクトを再帰的にプリントするかわりに、‘#LEVEL’をプリ
ントします。たとえば以下は、カレントのプリント処理におい
て、レベル0のオブジェクトを再帰的に参照することを示して
います:

     (setq foo (list nil))
          ⇒ (nil)
     (setcar foo foo)
          ⇒ (#0)

   以下の関数では、STREAMは出力ストリームを意味します。
(出力ストリームの説明は、前のセクションを参照してくださ
い。) STREAMが‘nil’、または省略された場合のデフォルトは
、‘standard-output’の値になります。

 -- Function: print object &optional stream
     ‘print’関数は、プリントを行うための便利な方法である
     。この関数はOBJECTの前後に改行を付与して、OBJECTの
     プリント表現をSTREAMにプリントする。クォート文字が
     使用される。‘print’はOBJECTをリターンする。たとえば
     :

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               ⊣
               ⊣ The\ cat\ in
               ⊣
               ⊣ "the hat"
               ⊣
               ⊣ " came back"
               ⇒ " came back"

 -- Function: prin1 object &optional stream
     この関数はOBJECTのプリント表現をSTREAMに出力する。
     この関数は‘print’のように出力を分割するための改行を
     プリントしないが、‘print’のようにクォート文字を使用
     する。OBJECTをリターンする。

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               ⊣ The\ cat\ in"the hat"" came back"
               ⇒ " came back"

 -- Function: princ object &optional stream
     この関数はOBJECTのプリント表現をSTREAMに出力する。
     OBJECTをリターンする。

     この関数は‘read’ではなく人間が読める出力を生成する
     ことを意図しているので、クォート文字を挿入せず、文
     字列のコンテンツの前後にダブルクォート文字を配さな
     い。呼び出しの間に間隔を何も出力しない。

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               ⊣ The cat in the "hat"
               ⇒ " in the \"hat\""

 -- Function: terpri &optional stream
     この関数はSTREAMに改行を出力する。名前の由来は、
     “terminate print”である。

 -- Function: write-char character &optional stream
     この関数はCHARACTERをSTREAMに出力する。CHARACTERを
     リターンする。

 -- Function: prin1-to-string object &optional noescape
     この関数は、同じ引数で‘prin1’がプリントするテキスト
     を含む文字列をリターンする。

          (prin1-to-string 'foo)
               ⇒ "foo"
          (prin1-to-string (mark-marker))
               ⇒ "#<marker at 2773 in strings.texi>"

     NOESCAPEが非‘nil’の場合は、出力中のクォート文字の使
     用を抑制する。(この引数は、Emacsバージョン19以降で
     サポートされた。)

          (prin1-to-string "foo")
               ⇒ "\"foo\""
          (prin1-to-string "foo" t)
               ⇒ "foo"

     Lispオブジェクトのプリント表現を文字列として取得す
     る別の手段については、*note Formatting Strings::の
     ‘format’を参照のこと。

 -- Macro: with-output-to-string body...
     このマクロは出力を文字列に送るよう
     ‘standard-output’をセットアップして、フォームBODYを
     実行する。その文字列がリターンされる。

     たとえばカレントバッファー名が‘foo’の場合、

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     は‘"The buffer is foo"’をリターンする。

 -- Function: pp object &optional stream
     この関数は‘prin1’と同じようにOBJECTをSTREAMに出力す
     るが、より“優雅(pretty)”な方法でこれを行う。すなわ
     ち、この関数は人間がより読みやすいようにオブジェク
     トのインデントとパディングを行う。


File: elisp,  Node: Output Variables,  Prev: Output Functions,  Up: Read and Print

18.6 Variables Affecting Output
===============================

 -- Variable: standard-output
     この変数の値はデフォルト出力ストリーム(STREAM引数が
     ‘nil’のときプリント関数が使用するストリーム)である
     。デフォルトは‘t’で、エコーエリアに表示することを意
     味する。

 -- Variable: print-quoted
     これが非‘nil’の場合は、省略されたリーダー構文(たと
     えば‘(quote foo)’を‘'foo’、‘(function foo)’を
     ‘#'foo’のように)を使用してクォートされたフォームを
     プリントすることを意味する。

 -- Variable: print-escape-newlines
     この変数が非‘nil’の場合、文字列内の改行は‘\n’、改ペ
     ージは‘\f’でプリントされる。これらの文字は、通常は
     実際の改行および改ページとしてプリントされる。

     この変数はクォートつきのプリントを行うプリント関数
     ‘prin1’および‘print’に影響を与える。‘princ’に影響は
     ない。以下は‘prin1’を使用した場合の例である:

          (prin1 "a\nb")
               ⊣ "a
               ⊣ b"
               ⇒ "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               ⊣ "a\nb"
               ⇒ "a
          b"

     2つ目の式では、‘prin1’を呼び出す間は
     ‘print-escape-newlines’のローカルバインドが効果をも
     つが、結果をプリントするときには効果がない。

 -- Variable: print-escape-nonascii
     この変数が非‘nil’の場合、クォートつきでプリントする
     プリント関数‘prin1’および‘print’は、文字列内のユニ
     バイトの非ASCII文字を無条件でバックスラッシュシーケ
     ンスとしてプリントする。

     これらの関数は、出力ストリームがマルチバイトバッフ
     ァー、あるいはマーカーがマルチバイトバッファーをポ
     イントするときは、この変数の値に関わらずユニバイト
     非ASCII文字にたいしてバックスラッシュシーケンスを使
     用する。

 -- Variable: print-escape-multibyte
     この変数が非‘nil’の場合、クォートつきでプリントする
     プリント関数‘prin1’および‘print’は、文字列内のマル
     チバイトの非ASCII文字を無条件でバックスラッシュシー
     ケンスとしてプリントする。

     これらの関数は、出力ストリームがユニバイトバッファ
     ー、あるいはマーカーがユニバイトバッファーをポイン
     トするときは、この変数の値に関わらずマルチバイト非
     ASCII文字にたいしてバックスラッシュシーケンスを使用
     する。

 -- Variable: print-length
     この変数の値は任意のリスト、ベクター、ブールベクタ
     ーをプリントする際の最大要素数である。プリントされ
     るオブジェクトがこれより多くの要素をもつ場合は、省
     略記号(“...”)で省略される。

     値が‘nil’(デフォルト)の場合は、無制限である。

          (setq print-length 2)
               ⇒ 2
          (print '(1 2 3 4 5))
               ⊣ (1 2 ...)
               ⇒ (1 2 ...)

 -- Variable: print-level
     この変数の値はプリント時の丸カッコ(parentheses:
     “()”)と角カッコ(brackets: “[]"’)のネスト最大深さで
     ある。この制限を超える任意のリストまたはベクターは
     省略記号(“...”)で省略される。値‘nil’(デフォルト)は
     無制限を意味する。

 -- User Option: eval-expression-print-length
 -- User Option: eval-expression-print-level
     これらは‘eval-expression’により使用される
     ‘print-length’および‘print-level’の値であり、したが
     って間接的に多くのインタラクティブな評価コマンドに
     より使用される(*note Evaluating Emacs-Lisp
     Expressions: (emacs)Lisp Eval.を参照)。

   以下の変数は循環構造および共有構造の検出と報告に使用
されます:

 -- Variable: print-circle
     非‘nil’の場合、この変数はプリント時の循環構造と共有
     構造の検出を有効にする。*note Circular Objects::を
     参照のこと。

 -- Variable: print-gensym
     非‘nil’の場合、この変数はプリント時のインターンされ
     ていないシンボル(*note Creating Symbols::を参照)の
     検出を有効にする。これが有効な場合、インターンされ
     ていないシンボルはプレフィックス‘#:’とともにプリン
     トされる。このプレフィックスは、Lispリーダーにたい
     してインターンされていないシンボルを生成するよう告
     げる。

 -- Variable: print-continuous-numbering
     非‘nil’の場合は、複数のプリント呼び出しを通じて通番
     が振られることを意味する。これは‘#N=’ラベルおよび
     ‘#M#’参照にたいしてプリントされる数字に影響する。こ
     の変数を‘setq’でセットしてはならない。‘let’を使用し
     て一時的に‘t’にバインドするべきである。これを行う場
     合は、‘print-number-table’も‘nil’にバインドするべき
     である。

 -- Variable: print-number-table
     この変数は‘print-circle’機能を実装するために、プリ
     ント処理で内部的に使用されるベクターを保持する。
     ‘print-continuous-numbering’をバインドするときにこ
     の変数を‘nil’にバインドする以外は、この変数を使用す
     るべきではない。

 -- Variable: float-output-format
     この変数は浮動小数点数をプリントする方法を指定する
     。デフォルトは‘nil’で、これは情報を失わずにその数値
     を表せるもっとも短い出力を使用することを意味する。

     出力フォーマットをより精密に制御するために、この変
     数に文字列をセットできる。この文字列にはCの
     ‘sprintf’関数で使用される‘%’指定子をセットする。こ
     の変数で使用することのできる制限についての詳細は、
     この変数のドキュメント文字列を参照のこと。


File: elisp,  Node: Minibuffers,  Next: Command Loop,  Prev: Read and Print,  Up: Top

19 Minibuffers
**************

“ミニバッファー(minibuffer)”とは、単一の数プレフィックス
引数より複雑な引数を読み取るためにEmacsコマンドが使用す
る、特別なバッファーのことです。これらの引数にはファイル
名、バッファー名、(‘M-x’での)コマンド名が含まれます。ミ
ニバッファーはフレームの最下行、エコーエリア(*note The
Echo Area::を参照)と同じ場所に表示されますが、引数を読み
取るときだけ使用されます。

* Menu:

* Intro to Minibuffers::     ミニバッファーに関する基本的な情報。
* Text from Minibuffer::     そのままのテキスト文字列を読み取る方法。
* Object from Minibuffer::   Lispオブジェクトや式を読み取る方法。
* Minibuffer History::       ユーザーが再利用できるように以前のミニバッファー入力は記録される。
* Initial Input::            ミニバッファーにたいして初期内容を指定する。
* Completion::               補完の呼び出しとカスタマイズ方法。
* Yes-or-No Queries::        問いにたいし単純な答えを求める。
* Multiple Queries::         一連の似たような問いに答える。
* Reading a Password::       端末からパスワードを読み取る。
* Minibuffer Commands::      ミニバッファー内でキーバインドとして使用されるコマンド。
* Minibuffer Windows::       特殊なミニバッファーウィンドウを処理する。
* Minibuffer Contents::      どのようなコマンドがミニバッファーのテキストにアクセスするか。
* Recursive Mini::           ミニバッファーへの再帰的なエントリーが許容されるかどうか。
* Minibuffer Misc::          カスタマイズ用のさまざまなフックや変数。


File: elisp,  Node: Intro to Minibuffers,  Next: Text from Minibuffer,  Up: Minibuffers

19.1 Introduction to Minibuffers
================================

ほとんどの点において、ミニバッファーは普通のEmacsバッフ
ァーです。編集コマンドのようなバッファーにたいするほとん
どの操作は、ミニバッファーでも機能します。しかし、バッフ
ァーを管理する操作の多くは、ミニバッファーに適用できませ
ん。ミニバッファーは常に‘ *Minibuf-NUMBER*’という形式の
名前をもち、変更することはできません。ミニバッファーはミ
ニバッファー用の特殊なウィンドウだけに表示されます。これ
らのウィンドウは常にフレーム最下に表示されます。(フレー
ムにミニバッファーウィンドウがないときや、ミニバッファー
ウィンドウだけをもつ特殊なフレームもあります。)*note
Minibuffers and Frames::を参照してください。

   ミニバッファー内のテキストは常に“プロンプト文字列
(prompt string)”で始まります。これはミニバッファーを使用
しているプログラムが、ユーザーにたいしてどのような種類の
入力が求められているか告げるために指定するテキストです。
このテキストは意図せずに変更してしまわないように、読み取
り専用としてマークされます。このテキストは
‘beginning-of-line’、‘forward-word’、
‘forward-sentence’、‘forward-paragraph’を含む特定の移動
用関数が、プロンプトと実際のテキストの境界でストップする
ように、フィールド(*note Fields::を参照)としてもマークさ
れています。

   ミニバッファーのウィンドウは、通常は1行です。ミニバッ
ファーのコンテンツがより多くのスペースを要求する場合は、
自動的に拡張されます。ミニバッファーのウィンドウがアクテ
ィブな間は、ウィンドウのサイズ変更コマンドで一時的にウィ
ンドウのサイズを変更できます。サイズの変更は、ミニバッフ
ァーをexitしたとき、通常のサイズにリバートされます。ミニ
バッファーがアクティブでないときはフレーム内の他のウィン
ドウでウィンドウのサイズ変更コマンドを使用するか、マウス
でモードラインをドラッグして、ミニバッファーのサイズを永
続的に変更できます。(現実装では、これが機能するには
‘resize-mini-windows’が‘nil’でなければなりません。) フレ
ームがミニバッファーだけを含む場合は、そのフレームのサイ
ズを変更してミニバッファーのサイズを変更できます。

   ミニバッファーの使用により入力イベントが読み取られ、
‘this-command’や‘last-command’のような変数の値が変更され
ます(*note Command Loop Info::を参照)。プログラムにそれ
らを変更させたくない場合は、ミニバッファーを使用するコー
ドの前後でそれらをバインドするべきです。

   ある状況下では、アクティブなミニバッファーが存在する
ときでもコマンドがミニバッファーを使用できます。そのよう
なミニバッファーは“再帰ミニバッファー(recursive
minibuffer)”と呼ばれます。この場合、最初のミニバッファー
は‘ *Minibuf-1*’という名前になります。再帰ミニバッファー
はミニバッファー名の最後の数字を増加させて命名されます。
(名前はスペースで始まるので、通常のバッファーリストには
表示されません。) 再帰ミニバッファーが複数ある場合は、最
内の(もっとも最近にエンターされた)ミニバッファーがアクテ
ィブなミニバッファーになります。このバッファーが、通常で
はミニバッファーと呼ばれるバッファーです。変数
‘enable-recursive-minibuffers’、またはコマンドシンボルの
その名前のプロパティをセットすることにより再帰ミニバッフ
ァーを許可、または禁止できます(*note Recursive Mini::を
参照)。

   他のバッファーと同様、ミニバッファーは特別なキーバイ
ンドを指定するためにローカルキーマップ(*note Keymaps::を
参照)を使用します。ミニバッファーを呼び出す関数も、処理
を行うためにローカルマップをセットアップします。補完なし
のミニバッファーローカルマップについては、*note Text
from Minibuffer::を参照してください。補完つきのミニバッ
ファーローカルマップについては、*note Completion
Commands::を参照してください。

   ミニバッファーが非アクティブのときのメジャーモードは
‘minibuffer-inactive-mode’で、キーマップは
‘minibuffer-inactive-mode-map’です。これらは、実際にはミ
ニバッファーが別フレームにある場合だけ、便利です。*note
Minibuffers and Frames::を参照してください。

   Emacsがバッチモードで実行されている場合、ミニバッファ
ーからの読み取りリクエストは、実装にはEmacs開始時に提供
された標準入力記述子から行を読み取ります。これは基本的な
入力だけをサポートします。特別なミニバッファーの機能(ヒ
ストリー、補完、パスワードのマスクなど)は、バッチモード
では利用できません。


File: elisp,  Node: Text from Minibuffer,  Next: Object from Minibuffer,  Prev: Intro to Minibuffers,  Up: Minibuffers

19.2 Reading Text Strings with the Minibuffer
=============================================

ミニバッファー入力にたいする基本的なプリミティブは
‘read-from-minibuffer’で、これは文字列とLispオブジェクト
の両方からテキスト表現されたフォームを読み取ることができ
ます。関数‘read-regexp’は、特別な種類の文字列である正規
表現式(*note Regular Expressions::を参照)の読み取りに使
用されます。コマンドや変数、ファイル名などの読み取りに特
化した関数もあります(*note Completion::を参照)。

   ほとんどの場合では、Lisp関数の途中でミニバッファー入
力関数を呼び出すべきではありません。かわりに
‘interactive’指定されたコマンドの引数読み取りの一部とし
て、すべてのミニバッファー入力を行います。*note Defining
Commands::を参照してください。

 -- Function: read-from-minibuffer prompt &optional
          initial keymap read history default
          inherit-input-method
     この関数は、ミニバッファーから入力を取得するもっと
     も一般的な手段である。デフォルトでは、任意のテキス
     トを受け入れて、それを文字列としてリターンする。し
     かし、READが非‘nil’の場合は、テキストをLispオブジェ
     クトに変換するために‘read’を使用する(*note Input
     Functions::を参照)。

     この関数が最初に行うのは、ミニバッファーをアクティ
     ブにして、プロンプトにPROMPT(文字列でなければならな
     い)を用いてミニバッファーを表示することである。その
     後に、ユーザーはミニバッファーでテキストを編集でき
     る。

     ミニバッファーをexitするためにユーザーがコマンドを
     タイプするとき、‘read-from-minibuffer’はミニバッフ
     ァー内のテキストからリターン値を構築する。通常はそ
     のテキストを含む文字列がリターンされる。しかし、
     READが非‘nil’の場合、‘read-from-minibuffer’はテキス
     トを読み込んで結果を未評価のLispオブジェクトでリタ
     ーンする。(読み取りについての詳細は、*Note Input
     Functions::を参照のこと。)

     引数DEFAULTは、ヒストリーコマンドを通じて利用できる
     デフォルト値を指定する。値には文字列、文字列リスト
     、または‘nil’を指定する。文字列または文字列リストは
     、ユーザーが‘M-n’で利用可能な“未来のヒストリー
     (future history)”になります。

     READが非‘nil’の場合は、ユーザーの入力が空のときの
     ‘read’の入力としても、DEFAULTが使用される。
     DEFAULTが文字列リストの!は、最初の文字列が入力とし
     て使用される。DEFAULTが‘nil’の場合、空の入力は
     ‘end-of-file’エラーとなる。しかし通常(READが
     ‘nil’)の場合には、ユーザーの入力が空のとき
     ‘read-from-minibuffer’はDEFAULTを無視して、空文字列
     ‘""’をリターンする。この点において、この関数はこの
     チャプターの他のどのミニバッファー入力関数とも異な
     る。

     KEYMAPが非‘nil’の場合、そのキーマップはミニバッファ
     ー内で使用されるローカルキーマップとなる。KEYMAPが
     省略、または‘nil’の場合は、‘minibuffer-local-map’の
     値がキーマップとして使用される。キーマップの指定は
     、補完のようなさまざまなアプリケーションにたいして
     ミニバッファーをカスタマイズする、もっとも重要な方
     法である。

     引数HISTORYは、入力の保存やミニバッファー内で使用さ
     れるヒストリーコマンドが使用するヒストリーリスト変
     数を指定する。デフォルトは‘minibuffer-history’であ
     る。同様に、オプションでヒストリーリスト内の開始位
     置を指定できる。*note Minibuffer History::を参照の
     こと。

     変数‘minibuffer-allow-text-properties’が非‘nil’の場
     合には、リターンされる文字列にはミニバッファーでの
     すべてのテキストプロパティが含まれる。それ以外では
     、値がリターンされるときすべてのテキストプロパティ
     が取り除かれる。

     引数INHERIT-INPUT-METHODが非‘nil’の場合には、ミニバ
     ッファーにエンターする前にカレントだったバッファー
     が何であれ、カレントのインプットメソッド(*note
     Input Methods::を参照)、および
     ‘enable-multibyte-characters’のセッティング(*note
     Text Representations::を参照)が継承される。

     ほとんどの場合、INITIALの使用は推奨されない。非
     ‘nil’値の使用は、HISTORYにたいするコンスセル指定と
     組み合わせる場合のみ推奨する。*note Initial
     Input::を参照のこと。

 -- Function: read-string prompt &optional initial
          history default inherit-input-method
     この関数はミニバッファーから文字列を読み取り、それ
     をリターンする。引数PROMPT、INITIAL、HISTORY、
     INHERIT-INPUT-METHODは‘read-from-minibuffer’で使用
     する場合と同様。使用されるキーマップは
     ‘minibuffer-local-map’である。

     オプション引数DEFAULTは‘read-from-minibuffer’の場合
     と同様に使用されるが、ユーザーの入力が空の場合にリ
     ターンするデフォルト値も指定する。
     ‘read-from-minibuffer’の場合と同様、値は文字列、文
     字列リスト、または‘nil’(空文字列と等価)である。
     DEFAULTが文字列のときは、その文字列がデフォルト値に
     なる。文字列リストのときは、最初の文字列がデフォル
     ト値になる。(これらの文字列はすべて“未来のミニバッ
     ファーヒストリー(future minibuffer history)”として
     ユーザーが利用可能)。

     この関数は‘read-from-minibuffer’を呼び出すことによ
     り機能する。

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ≡
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (and (equal value "") DEFAULT)
                (if (consp DEFAULT) (car DEFAULT) DEFAULT)
              value))

 -- Function: read-regexp prompt &optional defaults
          history
     この関数はミニバッファーから文字列として正規表現を
     読み取り、それをリターンする。ミニバッファーのプロ
     ンプト文字列PROMPTが‘:’(とその後にオプションの空白
     文字)で終端されていない場合、この関数はデフォルトの
     リターン値(空文字列でない場合。以下参照)の前に‘: ’を
     付加する。

     オプション引数DEFAULTSは、入力が空の場合にリターン
     するデフォルト値を制御する。値は文字列、‘nil’(空文
     字列と等価)、文字列リスト、シンボルのうちのどれか。

     DEFAULTSがシンボルの場合、‘read-regexp’は変数
     ‘read-regexp-defaults-function’(以下参照)の値を調べ
     て非‘nil’のときは、DEFAULTSよりそちらを優先的に使用
     する。この場合、値は以下のいずれか:

        − ‘regexp-history-last’。これは適切なミニバッフ
          ァーヒストリーリスト(以下参照)の最初の要素を使
          用することを意味する。

        − 引数なしの関数。リターン値(‘nil’、文字列、文字
          列リストのいずれか)がDEFAULTSの値となる。

     これで、‘read-regexp’がDEFAULTSを処理した結果はリス
     トに確定する(値が‘nil’または文字列の場合は1要素のリ
     ストに変換する)。このリストにたいし、
     ‘read-regexp’は、以下のような入力として有用な候補を
     いくつか追加する:

        − ポイント位置の単語またはシンボル。
        − インクリメンタル検索で最後に使用されたregexp。
        − インクリメンタル検索で最後に使用された文字列。
        − 問い合わせつき置換コマンドで最後に使用された文
          字列またはパターン。

     これで関数は、ユーザー入力を取得するために
     ‘read-from-minibuffer’に渡す正規表現のリストを得た
     。リストの最初の要素は入力が空の場合のデフォルト値
     である。リストのすべての要素は“未来のミニバッファー
     ヒストリーリスト(future minibuffer history list)”
     (*note future list: (emacs)Minibuffer History.を参
     照)としてユーザーが利用可能になる。

     オプション引数HISTORYが非‘nil’の場合、それは使用す
     るミニバッファーヒストリーリストを指定するシンボル
     である(*note Minibuffer History::を参照)。これが省
     略、または‘nil’の場合、ヒストリーリストのデフォルト
     は‘regexp-history’となる。

 -- Variable: read-regexp-defaults-function
     関数‘read-regexp’は、デフォルトの正規表現リストを決
     定するために、この変数の値を使用するかもしれない。
     非‘nil’の場合、この変数は以下のいずれかである:

        − シンボル‘regexp-history-last’。

        − ‘nil’、文字列、文字列リストのいずれかをリター
          ンする引数なしの関数。

     これらの変数の使い方についての詳細は、上述の
     ‘read-regexp’を参照のこと。

 -- Variable: minibuffer-allow-text-properties
     この変数が‘nil’の場合、‘read-from-minibuffer’および
     ‘read-string’はミニバッファー入力をリターンする前に
     、すべてのテキストプロパティを取り除く。しかし
     ‘read-no-blanks-input’(以下参照)、同様に補完つきで
     ミニバッファー入力を行う‘read-minibuffer’およびそれ
     に関連する関数(*note Reading Lisp Objects With the
     Minibuffer: Object from Minibuffer.を参照)は、この
     変数の値に関わらず、無条件でテキストプロパティを破
     棄する。

 -- Variable: minibuffer-local-map
     これはミニバッファーからの読み取りにたいするデフォ
     ルトローカルキーマップである。デフォルトでは以下の
     バインディングをもつ:

     ‘C-j’
          ‘exit-minibuffer’

     <RET>
          ‘exit-minibuffer’

     ‘C-g’
          ‘abort-recursive-edit’

     ‘M-n’
     <DOWN>
          ‘next-history-element’

     ‘M-p’
     <UP>
          ‘previous-history-element’

     ‘M-s’
          ‘next-matching-history-element’

     ‘M-r’
          ‘previous-matching-history-element’

 -- Function: read-no-blanks-input prompt &optional
          initial inherit-input-method
     この関数はミニバッファーから文字列を読み取るが、入
     力の一部として空白文字を認めず、かわりに空白文字は
     入力を終端させる。引数PROMPT、INITIAL、
     INHERIT-INPUT-METHODは‘read-from-minibuffer’で使用
     するときと同様。

     これは関数‘read-from-minibuffer’の簡略化されたイン
     ターフェイスであり、キーマップ
     ‘minibuffer-local-ns-map’の値をKEYMAP引数として、
     ‘read-from-minibuffer’関数に渡す。キーマップ
     ‘minibuffer-local-ns-map’は‘C-q’をリバインドしない
     ので、クォートすることにより文字列内にスペースを挿
     入することが_可能である_。

     ‘minibuffer-allow-text-properties’の値に関わらず、
     この関数はテキストプロパティを破棄する。

          (read-no-blanks-input PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map))

 -- Variable: minibuffer-local-ns-map
     このビルトイン変数は関数‘read-no-blanks-input’内で
     ミニバッファーローカルキーマップとして使用されるキ
     ーマップである。デフォルトでは、
     ‘minibuffer-local-map’のバインディングに加えて、以
     下のバインディングが有効になる:

     <SPC>
          ‘exit-minibuffer’

     <TAB>
          ‘exit-minibuffer’

     ‘?’
          ‘self-insert-and-exit’


File: elisp,  Node: Object from Minibuffer,  Next: Minibuffer History,  Prev: Text from Minibuffer,  Up: Minibuffers

19.3 Reading Lisp Objects with the Minibuffer
=============================================

このセクションでは、ミニバッファーでLispオブジェクトを読
み取る関数を説明します。

 -- Function: read-minibuffer prompt &optional initial
     この関数はミニバッファーを使用してLispオブジェクト
     をよみ、それを評価せずにリターンする。引数PROMPTと
     INITIALは、‘read-from-minibuffer’のときと同様に使用
     する。

     これは‘read-from-minibuffer’関数にたいする簡略化さ
     れたインターフェイスである。

          (read-minibuffer PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL nil t))

     以下の例では、初期入力として文字列‘"(testing)"’を与
     えている:

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; 以下はミニバッファーでの表示::

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)★
          ---------- Buffer: Minibuffer ----------

     ユーザーは<RET>をタイプして初期入力をデフォルトとし
     て利用したり、入力を編集することができる。

 -- Function: eval-minibuffer prompt &optional initial
     この関数はミニバッファーを使用してLisp式を読み取り
     、それを評価して結果をリターンする。引数PROMPTと
     INITIALの使い方は、‘read-from-minibuffer’と同様。

     この関数は、‘read-minibuffer’の呼び出し結果を単に評
     価する:

          (eval-minibuffer PROMPT INITIAL)
          ≡
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command prompt form
     この関数はミニバッファーでLisp式を読み取り、それを
     評価して結果をリターンする。このコマンドと
     ‘eval-minibuffer’の違いは、このコマンドでは初期値と
     してのFORMはオプションではなく、テキストの文字列で
     はないプリント表現に変換されたLispオブジェクトとし
     て扱われることである。これは‘prin1’でプリントされる
     ので、文字列の場合はテキスト初期値内にダブルクォー
     ト文字(‘"’)が含まれる。*note Output Functions::を参
     照のこと。

     以下の例では、すでに有効なフォームであるようなテキ
     スト初期値として式をユーザーに提案している:

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; 前の式を評価した後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)★
          ---------- Buffer: Minibuffer ----------

     すぐに<RET> をタイプするとミニバッファーをexitして
     式を評価するので、1単語分ポイントは前進する。


File: elisp,  Node: Minibuffer History,  Next: Initial Input,  Prev: Object from Minibuffer,  Up: Minibuffers

19.4 Minibuffer History
=======================

“ミニバッファーヒストリーリスト(minibuffer history
list)”は以前のミニバッファー入力を記録するので、それらを
手軽に再利用できます。ミニバッファーヒストリーリストは、
(以前に入力された)文字列のリストで、もっとも最近の文字列
が先頭になります。

   多数のミニバッファーが個別に存在し、異なる入力の種類
に使用されます。それぞれのミニバッファー使用にたいして正
しいヒストリーリストを指定するのは、Lispプログラマーの役
目です。

   ミニバッファーヒストリーリストは、
‘read-from-minibuffer’および‘completing-read’のオプショ
ン引数HISTORYに指定します。以下が利用できる値です:

VARIABLE
     ヒストリーリストとしてVARIABLE(シンボル)を使用する
     。

(VARIABLE . STARTPOS)
     ヒストリーリストとしてVARIABLE(シンボル)を使用し、
     ヒストリー位置の初期値をSTARTPOS(負の整数)とみなす
     。

     STARTPOSに0を指定するのは、単にシンボルVARIABLEだけ
     を指定するのと等価である。
     ‘previous-history-element’はミニバッファー内のヒス
     トリーリストの最新の要素を表示するだろう。 正の
     STARTPOSを指定した場合、ミニバッファーヒストリー関
     数は‘(elt VARIABLE(1- STARTPOS))’がミニバッファー内
     でカレントで表示されているヒストリー要素であるかの
     ように振る舞う。

     一貫性を保つため、ミニバッファー入力関数のINITIAL引
     数(*note Initial Input::を参照)使用して、ミニバッフ
     ァーの初期内容となるヒストリー要素も指定すべきであ
     る。

   HISTORYを指定しない場合は、デフォルトのヒストリーリス
ト‘minibuffer-history’が使用されます。他の標準的なヒスト
リーリストについては、以下を参照してください。最初に使用
する前に‘nil’に初期化するだけで、独自のヒストリーリスト
を作成することもできます。

   ‘read-from-minibuffer’と‘completing-read’は、どちらも
新たな要素を自動的にヒストリーリストに追加して、ユーザー
がそのリストのアイテムを再使用するためのコマンドを提供し
ます。ヒストリーリストを使用するためにプログラムが行う必
要があるのは、リストの初期化と、使用するときに入力関数に
リストの名前を渡すだけです。しかし、ミニバッファー入力関
数がリストを使用していないときに、手動でリストを変更して
も問題はありません。

   新たな要素をヒストリーリストに追加するEmacs関数は、リ
ストが長くなりすぎたときに古い要素の削除も行うことができ
ます。変数‘history-length’は、ほとんどのヒストリーリスト
の最大長を指定する変数です。特定のヒストリーリストにたい
して異なる最大長を指定するには、そのヒストリーリストシン
ボルの‘history-length’プロパティにその最大長をセットしま
す。変数‘history-delete-duplicates’には、ヒストリー内の
重複を削除するかどうかを指定します。

 -- Function: add-to-history history-var newelt
          &optional maxelt keep-all
     この関数はNEWELTが空文字列でなければ、それを新たな
     要素として変数HISTORY-VARに格納されたヒストリーリス
     トに追加して、更新されたヒストリーリストをリターン
     する。これはMAXELTまたは‘history-length’がが非
     ‘nil’の場合は、リストの長さをその変数の値に制限する
     (以下参照)。MAXELTに指定できる値の意味は、
     ‘history-length’の値と同様。

     ‘add-to-history’は通常、
     ‘history-delete-duplicates’が非‘nil’ならば、ヒスト
     リーリスト内の重複メンバーを削除する。しかし、
     KEEP-ALLが非‘nil’の場合、それは重複を削除しないこと
     を意味し、たとえNEWELTが空でもリストに追加する。

 -- Variable: history-add-new-input
     この変数の値が‘nil’の場合、ミニバッファーから読み取
     りを行う標準的な関数は、ヒストリーリストに新たな要
     素を追加しない。これにより、Lispプログラムが
     ‘add-to-history’を使用して明示的に入力ヒストリーを
     管理することになる。デフォルト値は‘t’。

 -- User Option: history-length
     この変数の値は、最大長を独自に指定しないすべてのヒ
     ストリーリストの最大長を指定する。値が‘t’の場合は、
     最大長がない(古い要素を削除しない)ことを意味する。
     ヒストリーリスト変数のシンボルの‘history-length’プ
     ロパティが非‘nil’の場合には、その特定のヒストリーリ
     ストにたいする最大長として、そのプロパティ値がこの
     変数をオーバーライドする。

 -- User Option: history-delete-duplicates
     この変数の値が‘t’の場合、それは新たなヒストリー要素
     の追加時に、以前からある等しい要素が削除されること
     を意味する。

   以下は、標準的なミニバッファーヒストリーリスト変数で
す:

 -- Variable: minibuffer-history
     ミニバッファーヒストリー入力にたいするデフォルトの
     ヒストリーリスト。

 -- Variable: query-replace-history
     ‘query-replace’の引数(および他のコマンドの同様の引
     数)にたいするヒストリーリスト。

 -- Variable: file-name-history
     ファイル名引数にたいするヒストリーリスト。

 -- Variable: buffer-name-history
     バッファー名引数にたいするヒストリーリスト。

 -- Variable: regexp-history
     正規表現引数にたいするヒストリーリスト。

 -- Variable: extended-command-history
     拡張コマンド名引数にたいするヒストリーリスト。

 -- Variable: shell-command-history
     シェルコマンド引数にたいするヒストリーリスト。

 -- Variable: read-expression-history
     評価されるためのLisp式引数にたいするヒストリーリス
     ト。

 -- Variable: face-name-history
     フェイス引数にたいするヒストリーリスト。


File: elisp,  Node: Initial Input,  Next: Completion,  Prev: Minibuffer History,  Up: Minibuffers

19.5 Initial Input
==================

ミニバッファー入力にたいする関数のいくつかには、
INITIALと呼ばれる引数があります。これは通常のように空の
状態で開始されるのではなく、特定のテキストとともにミニバ
ッファーが開始されることを指定しますが、ほとんどの場合に
おいて推奨されない機能です。

   INITIALが文字列の場合、ミニバッファーはその文字列のテ
キストを含む状態で開始され、ユーザーがそのテキストの編集
を開始するとき、ポイントはテキストの終端にあります。ユー
ザーがミニバッファーをexitするために単に<RET>をタイプし
た場合には、この入力文字列の初期値をリターン値だと判断し
ます。

   *INITIALにたいして非‘nil’値の使用には反対します。*な
ぜなら初期入力は強要的なインターフェイスだからです。ユー
ザーにたいして有用なデフォルト入力を提案するためには、ヒ
ストリーリストやデフォルト値の提供のほうが、より便利です
。

   しかしINITIAL引数にたいして文字列を指定すべき状況が
1つだけあります。それは、HISTORY引数にコンスセルを指定し
たときです。*note Minibuffer History::を参照してください
。

   INITIALは‘(STRING . POSITION)’という形式をとることも
できます。これはSTRINGをミニバッファーに挿入するが、その
文字列のテキスト中のPOSITIONにポイントを配するという意味
です。

   歴史的な経緯により、POSITIONは異なる関数において実装
が統一されていません。‘completing-read’ではPOSITIONの値
は0基準です。つまり、値0は文字列の先頭で、1は最初の文字
の次、...を意味します。しかし‘read-minibuffer’、およびこ
の引数をサポートする補完を行わない他のミニバッファー入力
関数では、1は文字列の先頭、2は最初の文字の次、...を意味
します。

   INITIALの値としてのコンスセルの使用は、推奨されません
。


File: elisp,  Node: Completion,  Next: Yes-or-No Queries,  Prev: Initial Input,  Up: Minibuffers

19.6 Completion
===============

“補完(complete, ompletion)”は省略された形式から始まる名
前の残りを充填する機能です。補完はユーザー入力と有効な名
前リストを比較して、ユーザーが何をタイプしたかで名前をど
の程度一意に判定できるか判断することにより機能します。た
とえば‘C-x b’(‘switch-to-buffer’)とタイプしてから、スイ
ッチしたいバッファー名の最初の数文字をタイプして、その後
に<TAB>(‘minibuffer-complete’)をタイプすると、Emacsはそ
の名前を可能な限り展開します。

   標準的なEmacsコマンドはシンボル、ファイル、バッファー
、プロセスの名前にたいして補完を提案します。このセクショ
ンの関数により、他の種類の名前にたいしても補完を実装でき
ます。

   ‘try-completion’関数は補完にたいする基本的なプリミテ
ィブです。これは初期文字列にたいして文字列セットをマッチ
して、最長と判定された補完をリターンします。

   関数‘completing-read’は、補完にたいする高レベルなイン
ターフェイスを提供します。‘completing-read’の呼び出しに
より、有効な名前リストの判定方法が指定されます。その後に
この関数は補完にたいして有用ないくつかのコマンドにキーバ
インドするローカルキーマップとともに、ミニバッファーをア
クティブ化します。その他の関数は、特定の種類の名前を補完
つきで読み取る、簡便なインターフェイスを提供します。

* Menu:

* Basic Completion::         文字列を補完する低レベル関数。
* Minibuffer Completion::    補完つきでミニバッファーを呼び出す。
* Completion Commands::      補完を行うミニバッファーコマンド。
* High-Level Completion::    特別なケースに有用な補完(バッファー名や変数名などの読み取り)。
* Reading File Names::       ファイル名やシェルコマンドの読み取りに補完を使用する。
* Completion Variables::     補完の挙動を制御する変数。
* Programmed Completion::    独自の補完関数を記述する。
* Completion in Buffers::    通常バッファー内でのテキスト補完。


File: elisp,  Node: Basic Completion,  Next: Minibuffer Completion,  Up: Completion

19.6.1 Basic Completion Functions
---------------------------------

以下の補完関数は、その関数自身ではミニバッファーでなにも
行いません。ここでは、ミニバッファーを使用する高レベルの
補完機能と並べて、これらの関数について説明します。

 -- Function: try-completion string collection &optional
          predicate
     この関数はCOLLECTION内のSTRINGに利用可能なすべての
     補完の、共通する最長部分文字列をリターンする。

     COLLECTIONは“補完テーブル(completion table)”と呼ば
     れる。値は文字列リスト、コンスセル、obarray、ハッシ
     ュテーブル、または補完関数でなければならない。

     ‘try-completion’は補完テーブルにより指定された許容
     できる補完それぞれにたいして、STRINGと比較を行う。
     許容できる補完マッチが存在しない場合は、‘nil’をリタ
     ーンする。マッチする補完が1つだけで、それが完全一致
     ならば‘t’をリターンする。それ以外は、すべてのマッチ
     可能な補完に共通する最長の初期シーケンス(longest
     initial sequence)をリターンする。

     COLLECTIONがリストの場合、許容できる補完
     (permissible completions)はそのリストの要素により指
     定される。リストの要素は文字列、またはCARが文字列ま
     たは(‘symbol-name’により文字列に変換される)シンボル
     であるようなコンスセルである。リストに他の型の要素
     が含まれる場合は無視される。

     COLLECTIONがobarray(*note Creating Symbols::を参照
     )の場合、そのobarray内のすべてのシンボル名が許容で
     きる補完セットを形成する。

     COLLECTIONがハッシュテーブルの場合には、文字列のキ
     ーが利用可能な補完(possible completions)になる。他
     のキーは無視される。

     COLLECTIONとして関数を使用することもできる。この場
     合、この関数だけが補完を処理する役目を担う。つまり
     ‘try-completion’は、この関数が何をリターンしようと
     も、それをリターンする。この関数はSTRING、
     PREDICATE、‘nil’の3つの引数で呼び出される(3つ目の引
     数は同じ関数を‘all-completions’でも使用して、どちら
     の場合でも適切なことを行うためである)。*note
     Programmed Completion::を参照のこと。

     引数PREDICATEが非‘nil’の場合、COLLECTIONがハッシュ
     テーブルなら1引数、それ以外は2引数の関数でなければ
     ならない。これは利用可能なマッチのテストに使用され
     、マッチはPREDICATEが非‘nil’をリターンしたときだけ
     受け入れられる。PREDICATEに与えられる引数は文字列、
     alistのコンスセル(CARが文字列)、またはobarrayのシン
     ボル(シンボル名では_ない_)のうちのどれか。
     COLLECTIONがハッシュテーブルの場合、PREDICATEは文字
     列キー(string key)と関連値(associated value)の2引数
     で呼び出される。

     加えて使いやすいように、補完は
     ‘completion-regexp-list’内のすべての正規表現にもマ
     ッチしなければならない。(COLLECTIONが関数の場合は、
     その関数自身が‘completion-regexp-list’を処理する必
     要がある。)

     以下の例の1つ目では、文字列‘foo’がalistのうち3つの
     CARとマッチされている。すべてのマッチは文字
     ‘fooba’で始まるので、それが結果となる。2つ目の例で
     は、可能なマッチは1つだけで、しかも完全一致なのでリ
     ターン値は‘t’になる。

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               ⇒ "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               ⇒ t

     以下の例では、文字‘forw’で始まるシンボルが多数あり
     、それらはすべて単語‘forward’で始まる。ほとんどのシ
     ンボルはその後に‘-’が続くが、すべてではないので
     ‘forward’までしか補完できない。

          (try-completion "forw" obarray)
               ⇒ "forward"

     最後に、以下の例では述語‘test’に渡される利用可能な
     マッチは3つのうち2つだけである(文字列‘foobaz’は短す
     ぎる)。これらは両方とも文字列‘foobar’で始まる。

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ "foobar"

 -- Function: all-completions string collection
          &optional predicate
     この関数は、STRINGの利用可能な補完すべてのリストを
     リターンする。この関数の引数は‘try-completion’の引
     数と同じであり、‘try-completion’が行うのと同じ方法
     で‘completion-regexp-list’を使用する。

     COLLECTIONか関数の場合はSTRING、PREDICATE、‘t’の3つ
     の引数で呼び出される。この場合、その関数がリターン
     するのが何であれ、‘all-completions’はそれをリターン
     する。*note Programmed Completion::を参照のこと。

     以下の例は、‘try-completion’の例の関数‘test’を使用
     している。

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ ("foobar1" "foobar2")

 -- Function: test-completion string collection
          &optional predicate
     この関数は、STRINGがCOLLECTIONおよびPREDICATEで指定
     された有効な補完候補の場合は、‘nil’をリターンする。
     引数は‘try-completion’の引数と同じ。たとえば、
     COLLECTIONが文字列リストの場合は、STRINGがリスト内
     に存在し、かつPREDICATEを満足すればtrueとなる。

     この関数は‘try-completion’が行うのと同じ方法で、
     ‘completion-regexp-list’を使用する。

     PREDICATEが非‘nil’で、COLLECTIONが同じ文字列を複数
     含む場合には、‘completion-ignore-case’にしたがって
     ‘compare-strings’で判定して、それらすべてをリターン
     するか、もしくは何もリターンしない。それ以外では、
     ‘test-completion’のリターン値は基本的に予測不可能で
     ある。

     COLLECTIONが関数の場合はSTRING、PREDICATE、
     ‘lambda’の3つの引数で呼び出される。それが何をリター
     ンするにせよ、‘test-completion’はそれをリターンする
     。

 -- Function: completion-boundaries string collection
          predicate suffix
     この関数はポイントの前のテキストがSTRING、ポイント
     の後がSUFFIXと仮定して、COLLECTIONが扱うフィールド
     の境界(boundary)をリターンする。

     補完は通常、文字列(string)全体に作用するので、すべ
     ての普通のコレクション(collection)にたいして、この
     関数は常に‘(0 . (length SUFFIX))’をリターンするだろ
     う。しかしファイルにたいする補完などのより複雑な補
     完は、1回に1フィールド行われる。たとえば、たとえ
     ‘"/usr/share/doc"’が存在しても、‘"/usr/sh"’の補完に
     ‘"/usr/share/"’は含まれるが、‘"/usr/share/doc"’は含
     まれないだろう。また、‘"/usr/sh"’にたいする
     ‘all-completions’に‘"/usr/share/"’は含まれず、
     ‘"share/"’だけが含まれるだろう。STRINGが
     ‘"/usr/sh"’、SUFFIXが‘"e/doc"’の場合、
     ‘completion-boundaries’は‘(5 . 1)’をリターンするだ
     ろう。これは、COLLECTIONが‘"/usr/"’の後ろにあり
     ‘"/doc"’の前にある領域に関する補完情報だけをリター
     ンするであろうことを告げている。

   補完alistを変数に格納した場合は、変数の
‘risky-local-variable’プロパティに非‘nil’をセットして、
その変数が“risky(危険)”だとマークすべきである。*note
File Local Variables::を参照のこと。

 -- Variable: completion-ignore-case
     この変数の値が非‘nil’の場合、補完での大文字小文字の
     違いは意味をもたない。‘read-file-name’では、この変
     数は‘read-file-name-completion-ignore-case’(*note
     Reading File Names::を参照)にオーバーライドされる。
     ‘read-buffer’では、この変数は
     ‘read-buffer-completion-ignore-case’(*note
     High-Level Completion::を参照)にオーバーライドされ
     る。

 -- Variable: completion-regexp-list
     これは正規表現のリストである。補完関数はこのリスト
     内のすべての正規表現にマッチした場合のみ許容できる
     補完と判断する。‘case-fold-search’(*note Searching
     and Case::を参照)では‘completion-ignore-case’の値に
     バインドされる。

 -- Macro: lazy-completion-table var fun
     この変数は変数VARを補完のためのcollectionとして
     lazy(lazy: 力のない、だらけさせる、のろのろした、怠
     惰な、不精な、眠気を誘う)な方法で初期化する。ここで
     lazyとは、collection内の実際のコンテンツを必要にな
     るまで計算しないという意味。このマクロはVARに格納す
     る値の生成に使用する。VARを使用して最初に補完を行っ
     たとき、真の値が実際に計算される。これは引数なしで
     FUNを呼び出すことにより行われる。FUNがリターンする
     値は、VARの永続的な値となる。

     以下は例である:

          (defvar foo (lazy-completion-table foo make-my-alist))

   既存の補完テーブルを受け取り変更したバージョンをリタ
ーンする関数が、いくつかあります。
‘completion-table-case-fold’は大文字小文字を区別しない、
case-insensitiveなテーブルをリターンします。
‘completion-table-in-turn’と‘completion-table-merge’は、
複数の入力テーブルを、異なる方法で組み合わせます。
‘completion-table-subvert’はテーブルを異なる初期プレフィ
ックス(initial prefix)で変更します。
‘completion-table-with-quoting’はクォートされたテキスト
の処理に適したテーブルをリターンします。
‘completion-table-with-predicate’は述語関数(predicate
function)によりフィルターします。
‘completion-table-with-terminator’は終端文字列
(terminating string)を追加します。


File: elisp,  Node: Minibuffer Completion,  Next: Completion Commands,  Prev: Basic Completion,  Up: Completion

19.6.2 Completion and the Minibuffer
------------------------------------

このセクションでは、補完つきでミニバッファーから読み取る
ための、基本的なインターフェイスを説明します。

 -- Function: completing-read prompt collection
          &optional predicate require-match initial
          history default inherit-input-method
     この関数は、補完の提供によりユーザーを支援して、ミ
     ニバッファーから文字列を読み取る。PROMPT(文字列でな
     ければならない)のプロンプトとともに、ミニバッファー
     をアクティブ化する。

     実際の補完は、補完テーブルCOLLECTIONと補完述語
     PREDICATEを関数‘try-completion’(*note Basic
     Completion::を参照)に渡すことにより行われる。これは
     補完の使用されるローカルキーマップに特定のコマンド
     をバインドしたとき発生する。これらのコマンドのいく
     つかは、‘test-completion’も呼び出す。したがって、
     PREDICATEが非‘nil’の場合は、COLLECTIONと
     ‘completion-ignore-case’が矛盾しないようにすべきで
     ある。*note Definition of test-completion::を参照の
     こと。

     オプション引数REQUIRE-MATCHの値は、ユーザーがミニバ
     ッファーをexitする方法を決定する。

        • ‘nil’の場合、通常のミニバッファーexitコマンド
          は、ミニバッファーの入力と無関係に機能する。

        • ‘t’の場合は、入力がCOLLECTIONの要素に補完され
          るまで、通常のミニバッファーexitコマンドは機能
          しない。

        • ‘confirm’の場合、どのような入力でもユーザーは
          exitできるが、入力が‘confirm’の要素に補完され
          ていなければ、確認を求められる。

        • ‘confirm-after-completion’の場合、どのような入
          力でもユーザーはexitできるが、前のコマンドが補
          完コマンド(たとえば
          ‘minibuffer-confirm-exit-commands’の中のコマン
          ドの1つの場合)で、入力の結果がCOLLECTIONの要素
          でない場合は、確認を求められる。*note
          Completion Commands::を参照のこと。

        • REQUIRE-MATCHにたいする他の値は‘t’と同じふぁが
          、exitコマンドは補完処理中はexitしない。

     しかし、REQUIRE-MATCHの値に関わらず、空の入力は常に
     許される。この場合、‘completing-read’はDEFAULTがリ
     ストなら最初の要素、DEFAULTが‘nil’なら‘""’、または
     DEFAULTをリターンする。文字列およびDEFAULT内の文字
     列は、ヒストリーコマンドを通じてユーザーが利用でき
     る。

     関数‘completing-read’はREQUIRE-MATCHが‘nil’の場合は
     キーマップとして‘minibuffer-local-completion-map’を
     、REQUIRE-MATCHが非‘nil’の場合は
     ‘minibuffer-local-must-match-map’を使用する。*note
     Completion Commands::を参照のこと。

     引数HISTORYは入力の保存とミニバッファーヒストリーコ
     マンドに、どのヒストリーリスト変数を使用するか指定
     する。デフォルトは‘minibuffer-history’。*note
     Minibuffer History::を参照のこと。

     INITIALは、ほとんどの場合推奨されない。HISTORYにた
     いするコンスセル指定と組み合わせた場合のみ、非
     ‘nil’値の使用を推奨する。*note Initial Input::を参
     照のこと。デフォルト入力にたいしては、かわりに
     DEFAULTを使用する。

     引数INHERIT-INPUT-METHODが非‘nil’の場合には、ミニバ
     ッファーにエンターする前にカレントだったバッファー
     が何であれ、カレントのインプットメソッド(*note
     Input Methods::を参照)、および
     ‘enable-multibyte-characters’のセッティング(*note
     Text Representations::を参照)が継承される。

     変数‘completion-ignore-case’が非‘nil’の場合、利用可
     能なマッチにたいして入力を比較するときの補完は、大
     文字小文字を区別しない。*note Basic Completion::を
     参照のこと。このモードでの操作では、PREDICATEも大文
     字小文字を区別してはならない(さもないと驚くべき結果
     となるであろう)。

     以下は‘completing-read’を使用した例である:

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; 前の式を評価後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo★
          ---------- Buffer: Minibuffer ----------

     その後ユーザーが‘<DEL> <DEL> b <RET>’をタイプすると
     、‘completing-read’は‘barfoo’をリターンする。

     ‘completing-read’関数は、実際に補完を行うコマンドの
     情報を渡すために、変数をバインドする。これらの変数
     は、以降のセクションで説明する。

 -- Variable: completing-read-function
     この変数の値は関数でなければならず、補完つきの読み
     取りを実際に行うために‘completing-read’から呼び出さ
     れる。この関数は‘completing-read’と同じ引数を受け入
     れる。他の関数のバインドして、通常の
     ‘completing-read’の振る舞いを完全にオーバーライドす
     ることができる。


File: elisp,  Node: Completion Commands,  Next: High-Level Completion,  Prev: Minibuffer Completion,  Up: Completion

19.6.3 Minibuffer Commands that Do Completion
---------------------------------------------

このセクションでは、補完のためにミニバッファーで使用され
るキーマップ、コマンド、ユーザーオプションを説明します。

 -- Variable: minibuffer-completion-table
     この変数の値は、ミニバッファー内の補完に使用される
     補完テーブルである。これは‘completing-read’が
     ‘try-completion’に渡す補完テーブルを含むグローバル
     変数である。‘minibuffer-complete-word’のような、ミ
     ニバッファー補完コマンドにより使用される。

 -- Variable: minibuffer-completion-predicate
     この変数の値は‘completing-read’が‘try-completion’に
     渡す述語(predicate)である。この変数は、他のミニバッ
     ファー補完関数でも使用される。

 -- Variable: minibuffer-completion-confirm
     この変数はミニバッファーをexitする前に、Emacsが確認
     を求めるかどうかを決定する。‘completing-read’はこの
     変数をバインドして、exitする前に関数
     ‘minibuffer-complete-and-exit’がこの値をチェックす
     る。値が‘nil’の場合は、確認は求められない。値が
     ‘confirm’の場合、入力が有効な補完候補でなくてもユー
     ザーはexitするかもしれないが、Emacsは確認を求めない
     。値が‘confirm-after-completion’の場合、入力が有効
     な補完候補でなくてもユーザーはexitするかもしれない
     が、ユーザーが‘minibuffer-confirm-exit-commands’内
     の任意の補完コマンドの直後に入力を確定した場合、
     Emacsは確認を求める。

 -- Variable: minibuffer-confirm-exit-commands
     この変数には、‘completing-read’の引数
     REQUIRE-MATCHが‘confirm-after-completion’の場合は、
     ミニバッファーをexitする前にEmacsが確認を求めるよう
     にさせるコマンドのリストが保持されている。このリス
     トないのコマンドを呼び出した直後にユーザーがミニバ
     ッファーのexitを試みると、Emacsは確認を求める。

 -- Command: minibuffer-complete-word
     この関数は、ただ1つの単語からミニバッファーを補完す
     る。たとえミニバッファーのコンテンツが1つの補完しか
     もたない場合でも、‘minibuffer-complete-word’はその
     単語に属さない最初の文字を超えた追加はしない。*note
     Syntax Tables::を参照のこと。

 -- Command: minibuffer-complete
     この関数は、可能な限りミニバッファーのコンテンツを
     補完する。

 -- Command: minibuffer-complete-and-exit
     この関数はミニバッファーのコンテンツを補完して、確
     認が要求されない場合(たとえば
     ‘minibuffer-completion-confirm’が‘nil’のとき)は
     exitする。確認が_要求される_場合には、このコマンド
     を即座に繰り返すことにより確認が行われないようにす
     る。このコマンドは2回連続で実行された場合は確認なし
     で機能するようにプログラムされている。

 -- Command: minibuffer-completion-help
     この関数は、カレントのミニバッファーのコンテンツで
     利用可能な補完のリストを作成する。これは
     ‘all-completions’の引数COLLECTIONに変数
     ‘minibuffer-completion-table’の値を、引数
     PREDICATEに‘minibuffer-completion-predicate’の値を
     使用して呼び出すことにより機能する。補完リストは、
     ‘*Completions*’と呼ばれるバッファーのテキストとして
     表示される。

 -- Function: display-completion-list completions
     この関数は‘standard-output’内のストリーム(通常はバ
     ッファー)にCOMPLETIONSを表示する(ストリームについて
     の詳細は、*note Read and Print::を参照)。引数
     COMPLETIONSは通常、‘all-completions’がリターンする
     補完リストそのものだが、それである必要はない。要素
     はシンボルか文字列で、どちらも単にプリントされる。
     文字列2つのリストでもよく、2つの文字列が結合された
     かのようにプリントされる。この場合、1つ目の文字列は
     実際の補完で、2つ目の文字列は注釈の役目を負う。

     この関数は‘minibuffer-completion-help’により呼び出
     される。一般的には、以下のように
     ‘with-output-to-temp-buffer’とともに使用される。

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     この変数が非‘nil’の場合には、次の文字が一意でないた
     めに決定できず補完が完了しないときは常に、補完コマ
     ンドは利用可能な補完リストを自動的に表示する。

 -- Variable: minibuffer-local-completion-map
     ‘completing-read’の値は、補完の1つが完全に一致する
     ことを要求されないときにローカルキーマップとして使
     用される。デフォルトでは、このキーマップは以下のバ
     インディングを作成する:

     ‘?’
          ‘minibuffer-completion-help’

     <SPC>
          ‘minibuffer-complete-word’

     <TAB>
          ‘minibuffer-complete’

     親キーマップとして‘minibuffer-local-map’を使用する
     (*note Definition of minibuffer-local-map::を参照
     )。

 -- Variable: minibuffer-local-must-match-map
     ‘completing-read’は、補完の1つの完全な一致が要求さ
     れないときのローカルキーマップとして、この値を使用
     する。したがって‘exit-minibuffer’にキーがバインドさ
     れていなければ、無条件にミニバッファーをexitする。
     デフォルトでは、このキーマップは以下のバインディン
     グを作成する:

     ‘C-j’
          ‘minibuffer-complete-and-exit’

     <RET>
          ‘minibuffer-complete-and-exit’

     親キーマップは‘minibuffer-local-completion-map’を使
     用する。

 -- Variable: minibuffer-local-filename-completion-map
     これは単に<SPC>を非バインドするsparseキーマップ
     (sparse: 疎、希薄、まばら)を作成する。これはファイ
     ル名にスペースを含めることができるからである。関数
     ‘read-file-name’は、このキーマップと
     ‘minibuffer-local-completion-map’か
     ‘minibuffer-local-must-match-map’のいずれかを組み合
     わせる。


File: elisp,  Node: High-Level Completion,  Next: Reading File Names,  Prev: Completion Commands,  Up: Completion

19.6.4 High-Level Completion Functions
--------------------------------------

このセクションでは、特定の種類の名前を補完つきで読み取る
便利な高レベル関数を説明します。

   ほとんどの場合、Lisp関数の中盤でこれらの関数を呼び出
すべきではありません。可能なときは、‘interactive’指定の
内部で呼び出し、ミニバッファーのすべての入力をコマンドの
引数読み取りの一部にします。*note Defining Commands::を
参照してください。

 -- Function: read-buffer prompt &optional default
          require-match
     この関数はバッファーの名前を読み取り、それを文字列
     でリターンする。引数DEFAULTは、ミニバッファーが空の
     状態でユーザーがexitした場合にリターンされるデフォ
     ルト名として使用される。非‘nil’の場合は文字列、文字
     列リスト、またはバッファーを指定する。リストの場合
     は、リストの先頭の要素がデフォルト値になる。デフォ
     ルト値はプロンプトに示されるが、初期入力としてミニ
     バッファーには挿入されない。

     引数PROMPTは、コロンかスペースで終わる文字列である
     。DEFAULTが非‘nil’の場合、この関数はデフォルト値つ
     きでミニバッファーから読み取る際の慣習にしたがい、
     コロンの前のPROMPTの中にこれを挿入する。

     オプション引数REQUIRE-MATCHは、‘completing-read’の
     ときと同じ。*note Minibuffer Completion::を参照のこ
     と。

     以下の例で、ユーザーが‘minibuffer.t’とエンターして
     から、<RET>をタイプする。引数REQUIRE-MATCHは‘t’であ
     り、与えられた入力で始まるバッファー名は
     ‘minibuffer.texi’だけなので、その名前が値となる。

          (read-buffer "Buffer name: " "foo" t)
          ;; 前の式を評価した後、
          ;;   空のミニバッファーに
          ;;   以下のプロンプトが表示される:

          ---------- Buffer: Minibuffer ----------
          Buffer name (default foo): ★
          ---------- Buffer: Minibuffer ----------

          ;; ユーザーが‘minibuffer.t <RET>’とタイプする。
               ⇒ "minibuffer.texi"

 -- User Option: read-buffer-function
     この変数が非‘nil’の場合は、バッファー名を読み取る関
     数である。‘read-buffer’は通常行うことを行うかわりに
     、‘read-buffer’と同じ引数でその関数を呼び出す。

 -- User Option: read-buffer-completion-ignore-case
     この変数が非non-‘nil’の場合は、補完の処理において
     ‘read-buffer’は大文字小文字を無視する。

 -- Function: read-command prompt &optional default
     この関数はコマンドの名前を読み取り、Lispシンボルと
     してそれをリターンする。引数PROMPTは、
     ‘read-from-minibuffer’で使用される場合と同じ。それ
     が何であれ‘commandp’が‘t’をリターンすればコマンドで
     あり、コマンド名とは‘commandp’が‘t’をリターンするシ
     ンボルだということを思い出してほしい。*note
     Interactive Call::を参照のこと。

     引数DEFAULTは、ユーザーがnull入力をエンターした場合
     に何をリターンするか指定する。シンボル、文字列、文
     字列リストを指定できる。文字列の場合、
     ‘read-command’はリターンする前にそれをinternする。
     リストの場合、‘read-command’はリストの最初の要素を
     internする。DEFAULTが‘nil’の場合は、デフォルトが指
     定されなかったことを意味する。その場合もしユーザー
     がnull入力をエンターすると、リターン値は‘(intern
     "")’、つまり名前が空文字列のシンボルとなる。

          (read-command "Command name? ")

          ;; 前の式を評価した後に、
          ;;   空のミニバッファーに以下のプロンプトが表示される:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     ユーザーが‘forward-c <RET>’とタイプした場合、この関
     数は‘forward-char’をリターンする。

     ‘read-command’関数は、‘completing-read’の簡略化され
     たインターフェイスである。実在するLisp変数のセット
     を補完するために変数‘obarray’を、コマンド名だけを受
     け入れるために述語‘commandp’を使用する。

          (read-command PROMPT)
          ≡
          (intern (completing-read PROMPT obarray
                                   'commandp t nil))

 -- Function: read-variable prompt &optional default
     この変数はカスタマイズ可能な変数の名前を読み取り、
     それをシンボルとしてリターンする。引数の形式は
     ‘read-command’の引数と同じ。この関数は、
     ‘commandp’のかわりに‘custom-variable-p’を述語に使用
     する点を除き、‘read-command’と同様に振る舞う。

 -- Command: read-color &optional prompt convert
          allow-empty display
     この関数はカラー指定(カラー名、または‘#RRRGGGBBB’の
     ような形式のRGB16進値)の文字列を読み取る。これはプ
     ロンプトにPROMPT(デフォルトは‘"Color (name or #RGB
     triplet):"’)を表示して、カラー名にたいする補完を提
     供する(16進RGB値は補完しない)。標準的なカラー名に加
     えて、補完候補にはポイント位置のフォアグラウンドカ
     ラーとバックグラウンドカラーが含まれる。

     Valid RGB values are described in *note Color
     Names::.

     この関数のリターン値は、ミニバッファー内でユーザー
     がタイプした文字列である。しかし、インタラクティブ
     に呼び出されたとき、またはオプション引数CONVERTが非
     ‘nil’の場合は、入力されたカラー名のかわりに、それに
     対応するRGB値文字列をリターンする。この関数は、入力
     に有効なカラー指定を求める。ALLOW-EMPTYが非‘nil’で
     ユーザーがnull入力をエンターした場合は、空のカラー
     名が許される。

     インタラクティブに呼び出されたとき、またはDISPLAYが
     非‘nil’の場合には、エコーエリアにもリターン値が表示
     される。

   *note User-Chosen Coding Systems::の関数
‘read-coding-system’と‘read-non-nil-coding-system’、およ
び*note Input Methods::の‘read-input-method-name’も参照
のこと。

