This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Repeated Loading,  Next: Named Features,  Prev: Autoload,  Up: Loading

15.6 Repeated Loading
=====================

1つのEmacsセッション内で、ファイルを複数回ロードできます。たとえば、バッ
ファーで関数定義を編集して再インストールした後に、元のバージョンに戻した
いときがあるかもしれません。これは、元のファイルをリロードすることにより
行なうことができます。

   ファイルをロードまたはリロードするとき、‘load’および‘load-library’関
数は未コンパイルのファイルではなく、バイトコンパイルされた同名のファイル
を自動的にロードすることに留意してください。ファイルを再記述して保存後に
再インストールする場合には、新しいバージョンをバイトコンパイルする必要が
あります。さもないと、Emacsは新しいソースではなく、古いバイトコンパイル
されたファイルをロードしてしまうでしょう! その場合には、ファイルロード時
に表示されるメッセージに、そのファイルのリコンパイルを促す‘(compiled;
note, source is newer)’というメッセージが含まれます。

   Lispライブラリーファイル内にフォームを記述するときは、そのファイルが
複数回ロードされるかもしれないことに留意してください。たとえば、そのライ
ブラリーをリロードするときには、各変数が最初期化されるべきかどうか考慮し
てください。。変数がすでに初期化されている場合、‘defvar’はその変数の値を
変更しません(*note Defining Variables::を参照)。

   alistに要素を追加するもっともシンプルな方法は、以下のようなものでしょ
う:

     (push '(leif-mode " Leif") minor-mode-alist)

しかし、これはそのライブラリーがリロードされた場合は、複数の要素を追加し
てしまうでしょう。この問題を避けるには、‘add-to-list’(*note List
Variables::を参照)を使用します:

     (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   時には、ライブラリーが既にロード済みか、明示的にテストしたいときがあ
るでしょう。そのライブラリーが‘provide’を使用して名前付きフィーチャ
(named feature)を提供する場合は、‘featurep’を使用して前に‘provide’が実行
されているかテストすることができます。かわりに、以下のようにすることもで
きます:

     (defvar foo-was-loaded nil)

     (unless foo-was-loaded
       EXECUTE-FIRST-TIME-ONLY
       (setq foo-was-loaded t))



File: elisp,  Node: Named Features,  Next: Where Defined,  Prev: Repeated Loading,  Up: Loading

15.7 Features
=============

‘provide’と‘require’は、‘autoload’にかわるファイルを自動的にロードする関
数です。これらは名前付きの“フィーチャ(feature: 機能)”という面で機能しま
す。オートロードは特定の関数の呼び出しをトリガーにしますが、フィーチャー
は最初は他のプログラムが名前により問い合わせたときにロードされます。

   フィーチャ名とは、関数、変数などのコレクションを表すシンボルです。こ
れらを定義するファイルは、そのフィーチャを“プロバイド(provide: 提供)”す
べきです。これらのフィーチャを使用する他のプログラムは、その機能を“リク
ワイア(require: 要求)”することにより、それらが定義されているか確認できる
でしょう。これは、定義がまだロードされていなければ、定義ファイルをロード
します。

   フィーチャをリクワイアするには、フィーチャ名を引数として‘require’を呼
び出します。‘require’は、意図する機能がすでにプロバイドされているか確認
するために、グローバル変数‘features’を調べます。もしプロバイドされていな
ければ、適切なファイルからそのフィーチャをロードします。このファイルは、
そのフィーチャを‘features’に追加するために、トップレベルで‘provide’を呼
び出すべきです。これに失敗すると、‘require’はエラーをシグナルします。

   たとえば、‘idlwave.el’内の‘idlwave-complete-filename’にたいする定義に
は、以下のコードが含まれます:

     (defun idlwave-complete-filename ()
       "Use the comint stuff to complete a file name."
        (require 'comint)
        (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
               (comint-completion-addsuffix nil)
               ...)
            (comint-dynamic-complete-filename)))

式‘(require 'comint)’は、‘comint.el’がまだロードされていなければ、
‘comint-dynamic-complete-filename’が確実に定義されるように、そのファイル
をロードします。フィーチャは通常、それらを提供するファイルにしたがって命
名されるため、‘require’にファイル名を与える必要はありません。
(‘require’命令文が‘let’のボディーの外側にあるのが重要なことに注意してく
ださい。変数がletバインドされているライブラリーをロードすることにより、
意図せぬ結果、つまりletをexitした後にその変数がアンバインドされます。)

   ‘comint.el’には以下のトップレベル式が含まれます:

     (provide 'comint)

これは‘comint’はグローバルなリスト‘features’に追加するので、‘(require
'comint)’は今後何も行う必要がないことを知ることができます。

   ファイルのトップレベル‘require’が使用されたときは、それをロードしたと
きと同様、そのファイルをバイトコンパイル(*note Byte Compilation::を参照
)したときにも効果が表れます。これはリクワイアされたパッケージがマクロを
含み、バイトコンパイラーがそれを知らなければならない場合です。これは
‘require’によりロードされるファイルで定義される関数と変数にたいするバイ
トコンパイラーの警告も無効にします。

   バイトコンパイルの間にトップレベルの‘require’が評価されるとしても、
‘provide’呼び出しは評価されません。したがって、以下の例のように
‘provide’の後に同じ機能にたいする‘require’を含めることにより、バイトコン
パイル前に定義しているファイルを確実にロードできます。

     (provide 'my-feature)  ; バイトコンパイラーには無視され、
                            ;   ‘load’には評価される。
     (require 'my-feature)  ; バイトコンパイラーにより評価される。

コンパイラーは‘provide’を無視して、その後に対象のファイルをロードするこ
とにより‘require’が処理されます。ファイルのロードは‘provide’呼び出しを実
行するので、後続の‘require’はファイルがロードされているときは何も行いま
せん。

 -- Function: provide feature &optional subfeatures
     この関数は、カレントEmacsセッションにFEATUREがロードされた、あるい
     はロードされつつあることをアナウンスします。これは、FEATUREに関連す
     る機能が他のLispプログラムから利用可能できる、あるいは利用可能にな
     ることを意味します。

     ‘provide’を呼び出すことによる直接的な効果は、まだFEATUREが
     FEATURES内に存在しない場合はリストの先頭に追加して、それを必要とし
     ている‘eval-after-load’コードを呼び出します(*note Hooks for
     Loading::を参照)。引数FEATUREはシンボルでなければなりません。
     ‘provide’はFEATUREをリターンします。

     SUBFEATURESが与えられた場合、それはFEATUREの当該バージョンによりプ
     ロバイドされる特定のサブフィーチャのセットを示すシンボルのリストで
     あるべきです。‘featurep’を使用して、サブフィーチャの存在をテストで
     きます。あるパッケージの、ロードされるか、あるいはそのバージョンに
     存在するか不明なさまざまな部分や機能に名前を与えて使いやすくするに
     は、そのパッケージが複雑すぎるときにサブフィーチャを使用するという
     のがサブフィーチャというアイデアです。例としては、*note Network
     Feature Testing::を参照してください。

          features
               ⇒ (bar bish)

          (provide 'foo)
               ⇒ foo
          features
               ⇒ (foo bar bish)

     オートロードによりあるファイルがロードされて、その内容の評価エラー
     によりストップいたとき、そのロードの間に発生した関数定義や
     ‘provide’呼び出しはアンドゥされます。*note Autoload::を参照してくだ
     さい。

 -- Function: require feature &optional filename noerror
     この関数はカレントEmacsセッションにおいて、FEATUREが存在するかどう
     かを、(‘(featurep FEATURE)’を使用して。以下を参照)をチェックします
     。引数FEATUREはシンボルでなければなりません。

     そのフィーチャが存在しない場合、‘require’は‘load’によりFILENAMEをロ
     ードします。FILENAMEが与えられなかった場合は、シンボルFEATUREの名前
     がロードするファイル名のベースとして使用されます。しかしこの場合、
     ‘require’はFEATUREを探すためにサフィックス‘.el’および‘.elc’の追加を
     強制します(圧縮ファイルのサフィックスに拡張されるかもしれません)。
     名前がただのFEATUREというファイルは使用されません。(変数
     ‘load-suffixes’は要求されるLispサフィックスを正確に指定します。)

     NOERRORが非‘nil’の場合は、ファイルの実際のロードにおけるエラーを抑
     止します。この場合、そのファイルのロードが失敗すると、‘require’は
     ‘nil’をリターンします。通常では、‘require’はFEATUREをリターンします
     。

     ファイルのロードは成功したがFEATUREをプロバイドしていない場合、
     ‘require’は‘Required feature FEATURE was not provided’のようにエラ
     ーをシグナルします。

 -- Function: featurep feature &optional subfeature
     この関数は、カレントEmacsセッションFEATUREがプロバイドされている場
     合(たとえばFEATURE‘features’のメンバーの場合)は‘t’をリターンします
     。SUBFEATUREが非‘nil’の場合、この関数はサブフィーチャも同様にプロバ
     イドされているとき(たとえばSUBFEATUREがシンボルFEATUREのプロパティ
     ‘subfeature’のメンバーのとき)だけ‘t’をリターンします。

 -- Variable: features
     この変数の値はシンボルのリストで、このシンボルはカレントEmacsセッシ
     ョンにロードされたフィーチャです。シンボルはそれぞれ‘provide’を呼び
     出すことにより、このリストにputされたものです。リスト‘features’内の
     要素の順番に意味はありません。


File: elisp,  Node: Where Defined,  Next: Unloading,  Prev: Named Features,  Up: Loading

15.8 Which File Defined a Certain Symbol
========================================

 -- Function: symbol-file symbol &optional type
     この関数は、SYMBOLを定義しているファイルの名前をリターンします。
     TYPEが‘nil’の場合は、どのようなタイプの定義も受け入れられます。
     TYPEが‘defun’の場合は関数定義、‘defvar’は変数定義、‘defface’はフェ
     イス定義だけを指定します。

     値は通常、絶対ファイル名です。定義がどのファイルにも関係しないとき
     は、‘nil’になることもあります。SYMBOLがオートロード関数を指定する場
     合、値が拡張子なしの相対ファイル名になることもあります。

   ‘symbol-file’は変数‘load-history’.<の値にもとづいています。

 -- Variable: load-history
     この変数の値は、ロードされたライブラリーファイルの名前を、それらが
     定義する関数と変数の名前、およびそれらがプロバイドまたはリクワイア
     するフィーチャに関連付けるalistです。

     このalist内の各要素は、1つのロード済みライブラリー(スタートアップ時
     にプリロードされたライブラリーを含む)を記述します。要素はCARがライ
     ブラリーの絶対ファイル名(文字列)のリストです。残りのリスト要素は、
     以下の形式です:

     ‘VAR’
          シンボルVARが変数として定義された。
     ‘(defun . FUN)’
          関数FUNが定義された。
     ‘(t . FUN)’
          関数FUNは、このライブラリーがそれを関数として再定義する前はオ
          ートロードとして定義されていた。後続の要素は常に‘(defun .
          FUN)’で、これはFUNを関数として定義する。
     ‘(autoload . FUN)’
          関数FUNはオートロードとして定義された。
     ‘(defface . FACE)’
          フェイスFACEが定義された。
     ‘(require . FEATURE)’
          フィーチャFEATUREがリクワイアされた。
     ‘(provide . FEATURE)’
          フィーチャFEATUREがプロバイドされた。

     ‘load-history’の値には、CARが‘nil’の要素が1つ含まれるかもしれません
     。この要素は、ファイルをvisitしていないバッファーでの
     ‘eval-buffer’で作成された定義を記述します。

   コマンド‘eval-region’は‘load-history’を更新しますが、要素を置き換えず
に、visitされているファイルの要素にたいして定義されたシンボルを追加しま
す。*note Eval::を参照してください。


File: elisp,  Node: Unloading,  Next: Hooks for Loading,  Prev: Where Defined,  Up: Loading

15.9 Unloading
==============

他のLispオブジェクト用にメモリーを回収するために、ライブラリーによりロー
ドされた関数や変数を破棄することができます。これを行うには、関数
‘unload-feature’を使用します:

 -- Command: unload-feature feature &optional force
     このコマンドはフィーチャFEATUREをプロバイドしていたライブラリーをア
     ンロードします。そのライブラリー内の‘defun’、‘defalias’、
     ‘defsubst’、‘defmacro’、‘defconst’、‘defvar’、‘defcustom’により定義
     されたすべての関数、マクロ、変数は未定義になります。その後、それら
     のシンボルにたいして事前に関連付けられていたオートロードをリストア
     します。(ロードはシンボルの‘autoload’プロパティにこれらを保存してい
     ます。)

     以前の定義をリストアする前に、特定のフックからそのライブラリー内の
     関数を取り除くために、‘unload-feature’は‘remove-hook’を実行します。
     これらのフックには、名前が‘-hook’(または廃止されたサフィックス
     ‘-hooks’)で終わる変数、加えて‘unload-feature-special-hooks’、同様に
     ‘auto-mode-alist’にリストされた変数も含まれます。これは、重要なフッ
     クがすでに定義されていない関数を参照をすることにより、Emacsの機能が
     停止することを防ぐためです。

     標準的なアンロードアクティビティは、そのライブラリー内の関数のELPプ
     ロファイリングを取り消し、そのライブラリーによりプロバイドされたフ
     ィーチャを取り消し、そのライブラリーで定義された変数に保持されたタ
     イマーも取り消します。

     これらの基準が機能不全を防ぐのに十分でない場合、ライブラリーは
     ‘FEATURE-unload-function’という名前の明示的なアンローダーを定義でき
     ます。そのシンボルが関数として定義された場合、‘unload-feature’は何
     かを行う前にまず引数なしでそれを呼び出します。これはライブラリーを
     アンロードしるために適切なすべてのことを行うことができます。これが
     ‘nil’をリターンした場合、‘unload-feature’は通常のアンロードアクショ
     ンを処理します。それ以外は、アンロード処理は完了したとみなします。

     ‘unload-feature’は通常、他のライブラリーが依存するライブラリーのア
     ンロードを拒絶します。(ライブラリーBにたいする‘require’がライブラリ
     ーAに含まれる場合、AはBに依存します。)オプション引数FORCEが非
     ‘nil’の場合、依存関係は無視され、どのようなライブラリーもアンロード
     できます。

   ‘unload-feature’関数はLispで記述されており、その動作は変数
‘load-history’にもとづきます。

 -- Variable: unload-feature-special-hooks
     この変数には、ライブラリー内で定義された関数を取り除くために、ライ
     ブラリーをアンロードする前にスキャンされるフックのリストが保持され
     ています。


File: elisp,  Node: Hooks for Loading,  Prev: Unloading,  Up: Loading

15.10 Hooks for Loading
=======================

変数‘after-load-functions’を使用することにより、Emacsがライブラリーをロ
ードするたびにコードを実行させることができます:

 -- Variable: after-load-functions
     このアブノーマルフック(abnormal hook)は、ファイルをロードした後に実
     行されます。フック内の各関数は1つの引数(ロードされたファイルの絶対
     ファイル名)で呼び出されます。

   _特定_のライブラリーがロードされた後にコードを実行したい場合は、マク
ロ‘with-eval-after-load’を使用します:

 -- Macro: with-eval-after-load library body...
     このマクロはLIBRARYがロードされるたびに、ファイルLIBRARYのロードの
     最後でBODYが評価されるよう準備します。LIBRARYがすでにロード済みの場
     合は、即座にBODYを評価します。

     ファイル名LIBRARYにディレクトリーや拡張子を与える必要はありません。
     通常は以下のようにファイル名だけを与えます:

          (with-eval-after-load "edebug" (def-edebug-spec c-point t))

     どのファイルが評価をトリガーできるか制限するには、ディレクトリーか
     拡張子、またはしの両方をLIBRARYに含めます。実際のファイル名(たとえ
     ばすべてのシンボリックリンク名は除外される)が、与えられた名前すべて
     にマッチするファイルだけが、マッチします。以下の例では、どこかのデ
     ィレクトリー‘..../foo/bar’にある‘my_inst.elc’や‘my_inst.elc.gz’は評
     価をトリガーしますが、‘my_inst.el’は異なります。:

          (with-eval-after-load "foo/bar/my_inst.elc" ...)

     LIBRARYはフィーチャ(たとえばシンボル)でもよく、その場合‘(provide
     LIBRARY)’を呼び出す任意のファイルの最後にBODYが評価されます。

     BODY内のエラーはロードをアンドゥしませんが、BODYの残りの実行を妨げ
     ます。

   上手く設計されたLispプログラムは通常、‘eval-after-load’を使用するべき
ではありません。(外部からの使用を意図した)他のライブラリーで定義された変
数を調べたりセットする必要がある場合、それは即座に行うことができます −−−
そのライブラリーがロードされるのを待つ必要はありません。そのライブラリー
で定義された関数を呼び出す必要がある場合は、そのライブラリーをロードすべ
きで、それには‘require’(*note Named Features::を参照)が適しています。


File: elisp,  Node: Byte Compilation,  Next: Debugging,  Prev: Loading,  Up: Top

16 Byte Compilation
*******************

Emacs Lispには、Lispで記述された関数を、より効率的に実行できる“バイトコ
ード(byte-code)”と呼ばれる特別な表現に翻訳する“コンパイラー(compiler)”が
あります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイ
トコード関数が呼び出されたとき、その定義は“バイトコードインタープリター
(byte-code interpreter)”により評価されます。

   バイトコンパイルされたコードは、(本当のコンパイル済みコードのように
)そのマシンのハードウェアにより直接実行されるのではなく、バイトコンパイ
ラーにより評価されるため、バイトコードはリコンパイルしなくてもマシン間で
の完全な可搬性を有します。しかし、本当にコンパイルされたコードほど高速で
はありません。

   一般的に、任意のバージョンのEmacsはそれ以前のバージョンのEmacsにより
生成されたバイトコンパイル済みコードを実行できますが、逆は成り立ちません
。

   あるLispファイルを常にコンパイルせずに実行したい場合は、以下のように
‘no-byte-compile’にバインドするファイルローカル変数を配します:

     ;; -*-no-byte-compile: t; -*-

* Menu:

* Speed of Byte-Code::       バイトコンパイルによるスピードアップ例。
* Compilation Functions::    バイトコンパイル関数。
* Docs and Compilation::     ドキュメント文字列のダイナミックロード。
* Dynamic Loading::          個々の関数のダイナミックロード。
* Eval During Compile::      コンパイル時に評価されるコード。
* Compiler Errors::          コンパイラーのエラーメッセージの扱い。
* Byte-Code Objects::        バイトコンパイル済み関数に使用されるデータ型。
* Disassembly::              バイトコードの逆アセンブル;
                               バイトコードの読み方。


File: elisp,  Node: Speed of Byte-Code,  Next: Compilation Functions,  Up: Byte Compilation

16.1 Performance of Byte-Compiled Code
======================================

バイトコンパイルされた関数はCで記述されたプリミティブ関数ほど効率的では
ありませんがLispで記述されたバージョンよりは高速に実行されます。以下は例
です:

     (defun silly-loop (n)
       "Return the time, in seconds, to run N iterations of a loop."
       (let ((t1 (float-time)))
         (while (> (setq n (1- n)) 0))
         (- (float-time) t1)))
     ⇒ silly-loop

     (silly-loop 50000000)
     ⇒ 10.235304117202759

     (byte-compile 'silly-loop)
     ⇒ [コンパイルされたコードは表示されない]

     (silly-loop 50000000)
     ⇒ 3.705854892730713

   この例では、インタープリターによる実行には10秒を要しますが、バイトコ
ンパイルされたコードは4秒未満です。これは典型的な結果例ですが、実際の結
果はさまざまでしょう。


File: elisp,  Node: Compilation Functions,  Next: Docs and Compilation,  Prev: Speed of Byte-Code,  Up: Byte Compilation

16.2 Byte-Compilation Functions
===============================

‘byte-compile’により、関数やマクロを個別にバイトコンパイルできます。
‘byte-compile-file’でファイル全体、‘byte-recompile-directory’または
‘batch-byte-compile’で複数ファイルをコンパイルできます。

   バイトコンパイラーが警告、および/またはエラーメッセージを生成すること
もあります(詳細は*note Compiler Errors::を参照)。これらのメッセージは
Compilationモードが使用する‘*Compile-Log*’と呼ばれるバッファーに記録され
ます。*note (emacs)Compilation Mode::を参照してください。

   バイトコンパイルを意図したファイル内にマクロ呼び出しを記述する際は、
注意が必要です。マクロ呼び出しはコンパイル時に展開されるので、そのマクロ
はEmacsにロードされる必要があります(さもないとバイトコンパイラーは正しく
処理しないでしょう)。これを処理する通常の方法は、必要なマクロ定義を含む
ファイルを‘require’フォームで指定することです。バイトコンパイラーは通常
、コンパイルするコードを評価しませんが、‘require’フォームは指定されたラ
イブラリーをロードすることにより特別に扱われます。誰かがコンパイルされた
プログラムを_実行_する際に、マクロ定義ファイルのロードを回避するには、
‘require’呼び出しの周囲に‘eval-when-compile’を記述します(*note Eval
During Compile::を参照)。詳細は*note Compiling Macros::を参照してくださ
い。

   インライン(‘defsubst’)の関数は、これほど面倒ではありません。定義が判
明する前にそのような関数呼び出しをコンパイルした場合でも、その呼び出しは
低速になるだけで、正しく機能するでしょう。

 -- Function: byte-compile symbol
     この関数はSYMBOLの関数定義をバイトコンパイルして、以前の定義をコン
     パイルされた定義に置き換えます。SYMBOLの関数定義は、その関数にたい
     する実際のコードでなければなりません。‘byte-compile’はインダイレク
     ト関数を処理しません。リターン値は、SYMBOLのコンパイルされた定義で
     あるバイトコード関数ブジェクトです(*note Byte-Code Objects::を参照
     )。

          (defun factorial (integer)
            "INTEGERの階乗を計算する。"
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
          ⇒ factorial

          (byte-compile 'factorial)
          ⇒
          #[(integer)
            "^H\301U\203^H^@\301\207\302^H\303^HS!\"\207"
            [integer 1 * factorial]
            4 "Compute factorial of INTEGER."]

     SYMBOLの定義がバイトコード関数オブジェクトの場合、‘byte-compile’は
     何も行わず‘nil’をリターンします。そのシンボルの関数セル内の(コンパ
     イルされていない)オリジナルのコードはすでにバイトコンパイルされたコ
     ードに置き換えられているので、“シンボルの定義の再コンパイル”はしま
     せん。

     ‘byte-compile’の引数として‘lambda’式も指定できます。この場合、関数
     は対応するコンパイル済みコードをリターンしますが、それはどこにも格
     納されません。

 -- Command: compile-defun &optional arg
     このコマンドはポイントを含むdefunを読み取りそれをコンパイルして、結
     果を評価します。実際に関数定義であるようなdefunでこれを使用した場合
     は、その関数のコンパイル済みバージョンをインストールする効果があり
     ます。

     ‘compile-defun’は通常、評価した結果をエコーエリアに表示しますが、
     ARGが非‘nil’の場合は、そのフォームをコンパイルした後にカレントバッ
     ファーに結果を挿入します。

 -- Command: byte-compile-file filename &optional load
     この関数はFILENAMEという名前のLispコードファイルを、バイトコードの
     ファイルにコンパイルします。出力となるファイルの名前は、サフィック
     ス‘.el’を‘.elc’に変更することにより作成されます。FILENAMEが‘.el’で
     終了しない場合は、‘.elc’をFILENAMEの最後に付け足します。

     コンパイルは入力ファイルから1つのフォームを逐次読み取ることにより機
     能します。フォームが関数またはマクロの場合は、コンパイル済みの関数
     またはマクロが書き込まれます。それ以外のフォームはまとめられて、ま
     とめられたものごとにコンパイルされ、そのファイルが読まれたとき実行
     されるようにコンパイルされたコードが書き込まれます。入力ファイルを
     読み取る際、すべてのコメントは無視されます。

     このコマンドはエラーのないときは‘t’、それ以外は‘nil’をリターンしま
     す。インタラクティブに呼び出されたときは、ファイル名の入力をもとめ
     ます。

     LOADが非‘nil’の場合、このコマンドはコンパイルした後にコンパイルされ
     たファイルをロードします。インタラクティブに呼び出された場合、
     LOADはプレフィクス引数です。

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el

          (byte-compile-file "~/emacs/push.el")
               ⇒ t

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
          -rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc

 -- Command: byte-recompile-directory directory &optional flag force
     このコマンドは、DIRECTORY(またはそのサブディレクトリー)内の、リコン
     パイルを要するすべての‘.el’ファイルをリコンパイルします。‘.elc’ファ
     イルが存在し、それが‘.el’より古いファイルは、リコンパイルが必要です
     。

     ‘.el’ファイルに対応する‘.elc’ファイルが存在しない場合、何を行うかを
     FLAGで指定します。‘nil’の場合、このコマンドはこれらのファイルを無視
     します。FLAGが0のときは、それらをコンパイルします。‘nil’と0以外の場
     合は、それらのファイルをコンパイルするかユーザーに尋ね、同様にそれ
     ぞれのサブディレクトリーについても尋ねます。

     インタラクティブに呼び出された場合、‘byte-recompile-directory’は
     DIRECTORYの入力を求め、FLAGはプレフィクス引数になります。

     FORCEが非‘nil’の場合、このコマンドは‘.elc’ファイルのあるすべての
     ‘.el’ファイルをリコンパイルします。

     リターン値は不定です。

 -- Function: batch-byte-compile &optional noforce
     この関数は、コマンドラインで指定されたファイルにたいして、
     ‘byte-compile-file’を実行します。この関数は処理が完了するとEmacsを
     killするので、Emacsのバッチ実行だけで使用しなければなりません。1つ
     のファイルでエラーが発生しても、それにより後続のファイルにたいする
     処理が妨げられることはありませんが、そのファイルにたいする出力ファ
     イルは生成されず、Emacsプロセスは0以外のステータスコードで終了しま
     す。

     NOFORCEが非‘nil’の場合、この関数は最新の‘.elc’ファイルがあるファイ
     ルをリコンパイルしません。

          $ emacs -batch -f batch-byte-compile *.el


File: elisp,  Node: Docs and Compilation,  Next: Dynamic Loading,  Prev: Compilation Functions,  Up: Byte Compilation

16.3 Documentation Strings and Compilation
==========================================

Emacsがバイトコンパイルされたファイルから関数や変数をロードする際、通常
はメモリー内にそれらのドキュメント文字列をロードしません。それぞれのドキ
ュメント文字列は、必要なときだけバイトコンパイルされたファイルから“ダイ
ナミック(dynamic: 動的)”にロードされます。ドキュメント文字列の処理をスキ
ップすることにより、メモリーが節約され、ロードが高速になります。

   この機能には欠点があります。コンパイル済みのファイルを削除、移動、ま
たは(新しいバージョンのコンパイル等で)変更した場合、Emacsは前にロードさ
れた関数や変数のドキュメント文字列にアクセスできなくなるでしょう。このよ
うな問題は通常、あなた自身がEmacsをビルドした場合に、そのLispファイルを
編集、および/またはリコンパイルしたときだけ発生します。この問題は、リコ
ンパイル後にそれぞれのファイルをリロードするだけで解決します。

   バイトコンパイルされたファイルからのドキュメント文字列のダイナミック
ロードは、バイトコンパイルされたファイルごとに、コンパイル時に決定されま
す。これはオプション‘byte-compile-dynamic-docstrings’により、無効にでき
ます。

 -- User Option: byte-compile-dynamic-docstrings
     これが非‘nil’の場合、バイトコンパイラーはドキュメント文字列をダイナ
     ミックロードするようセットアップしたコンパイル済みファイルを生成し
     ます。

     特定のファイルでダイナミックロード機能を無効にするには、以下のよう
     にヘッダー行(*note Local Variables in Files: (emacs)File
     Variables.を参照)で、このオプションに‘nil’をセットします。

          -*-byte-compile-dynamic-docstrings: nil;-*-

     これは主に、あるファイルを変更しようとしていて、そのファイルをすで
     にロード済みのEmacsセッションがファイルを変更した際にも正しく機能し
     続けることを望む場合に有用です。

   内部的には、ドキュメント文字列のダイナミックロードは、特殊なLispリー
ダー構成‘#@COUNT’とともにコンパイル済みファイルに書き込むことにより達成
されます。この構成は、次のCOUNT文字をスキップします。さらに‘#$’構成も使
用され、これは“このファイルの名前(文字列)”を意味します。これらの構成を
Lispソースファイル内で使用しないでください。これらは人間がファイルを読む
際に明確であるようデザインされていません。


File: elisp,  Node: Dynamic Loading,  Next: Eval During Compile,  Prev: Docs and Compilation,  Up: Byte Compilation

16.4 Dynamic Loading of Individual Functions
============================================

ファイルをコンパイルするとき、オプションで“ダイナミック関数ロード
(dynamic function loading)”機能(“laxyロード(lazy loading)とも呼ばれる
”)を有効にできます。ダイナミック関数ロードでは、ファイルのロードでファイ
ル内の関数定義は完全には読み込まれません。かわりに、各関数定義にはそのフ
ァイルを参照するプレースホルダーが含まれます。それぞれ関数が最初に呼び出
されるときに、そのプレースホルダーを置き換えるために、ファイルから完全な
定義が読み込まれます。

   ダイナミック関数ロードの利点は、ファイルのロードがより高速になること
です。ユーザーが呼び出せる関数を多く含むファイルにとって、それらの関数の
うち1つを使用したら、おそらく残りの関数も使用するというのでなければ、こ
れは利点です。多くのキーボードコマンドを提供する特化したモードは、このパ
ターンの使い方をする場合があります。ユーザーはそのモードを呼び出すかもし
れませんが、使用するのはそのモードが提供するコマンドのわずか一部です。

   ダイナミックロード機能には、いくつか不利な点があります:

   • ロード後にコンパイル済みファイルを削除や移動した場合、Emacsはまだロ
     ードされていない残りの関数定義をロードできなくなる。

   • (新しいバージョンのコンパイル等で)コンパイル済みファイルを変更した
     場合、まだロードされていない関数のロードを試みると、通常は無意味な
     結果となる。

   このような問題は、通常の状況でインストールされたEmacsファイルでは決し
て発生しません。しかし、あなたが変更したLispファイルでは発生し得ます。そ
れぞれのファイルをリコンパイルしたらすぐに、新たなコンパイル済みファイル
をリロードするのが、これらの問題を回避する一番簡単な方法です。

   コンパイル時に変数‘byte-compile-dynamic’が非‘nil’の場合、バイトコンパ
イラーはダイナミック関数ロード機能を使用します。ダイナミックロードが望ま
しいのは特定のファイルにたいしてだけなので、この変数をグローバルにセット
しないでください。そのかわりに、特定のソースファイルのファイルローカル変
数で、この機能を有効にしてください。たとえば、ソースファイルの最初の行に
以下のテキストを記述することにより、これを行うことができます:

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     これが非‘nil’の場合、バイトコンパイラーはダイナミック関数ロードのた
     めにセットアップされたコンパイル済みファイルを生成します。

 -- Function: fetch-bytecode function
     FUNCTIONがバイトコード関数オブジェクトの場合、それがまだ完全にロー
     ドされていなければ、バイトコンパイル済みのファイルからのFUNCTIONの
     バイトコードのロードを完了させます。それ以外は、何も行いません。こ
     の関数は、常にFUNCTIONをリターンします。


File: elisp,  Node: Eval During Compile,  Next: Compiler Errors,  Prev: Dynamic Loading,  Up: Byte Compilation

16.5 Evaluation During Compilation
==================================

これらの機能により、プログラムのコンパイル中に評価されるコードを記述でき
ます。

 -- Special Form: eval-and-compile body...
     このフォームは、それを含むコードがコンパイルされるとき、および(コン
     パイルされているかいないかに関わらず)実行されるときの両方で、BODYが
     評価されるようにマークします。

     BODYを別のファイルに配し、そのファイルを‘require’で参照すれば、同様
     の結果が得られます。これはBODYが大きいとき望ましい方法です。事実上
     、‘require’は自動的に‘eval-and-compile’され、そのパッケージはコンパ
     イル時と実行時の両方でロードされます。

     ‘autoload’も実際は‘eval-and-compile’されます。これはコンパイル時に
     認識されるので、そのような関数の使用により警告“not known to be
     defined”は生成されません。

     ほとんどの‘eval-and-compile’の使用は、完全に妥当であると言えます。

     あるマクロがマクロの結果を構築するためのヘルパー関数をもち、そのマ
     クロがそのパッケージにたいしてローカルと外部の両方で使用される場合
     には、コンパイル時と後の実行時にそのヘルパー関数を取得するために、
     ‘eval-and-compile’を使用すべきです。

     関数がプログラム的に(‘fset’で)定義されている場合には、それがコンパ
     イル時、同様に実行時に行われるように使用でき、それらの関数への呼び
     出しはチェックされます(“not known to be defined”の警告は抑えられま
     す)。

 -- Special Form: eval-when-compile body...
     このフォームは、BODYがコンパイル時に評価され、コンパイルされたプロ
     グラムがロードされるときは評価されないようにマークします。コンパイ
     ラーによる評価の結果は、コンパイル済みのプログラム内の定数となりま
     す。ソースファイルをコンパイルではなくロードした場合、BODYは通常ど
     おり評価されます。

     生成するために何らかの計算が必要な定数がある場合、
     ‘eval-when-compile’はコンパイル時にそれを行なうことができます。たと
     えば、

          (defvar my-regexp
            (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))

     他のパッケージを使用しているが、そのパッケージのマクロ(バイトコンパ
     イラーはそれらを展開します)だけが必要な場合、それらを実行せずにコン
     パイル用にロードさせるために‘eval-when-compile’を使用できます。たと
     えば、

          (eval-when-compile
            (require 'my-macro-package))

     これらの事項は、マクロおよび‘defsubst’関数がローカルに定義され、そ
     のファイル内だけで使用されることを要求します。これらは、そのファイ
     ルのコンパイルに必要ですが、コンパイル済みファイルの実行には、ほと
     んどの場合必要ありません。たとえば、

          (eval-when-compile
            (unless (fboundp 'some-new-thing)
              (defmacro 'some-new-thing ()
                (compatibility code))))

     これは大抵他のバージョンのEmacsとの互換性にたいする保証だけのための
     コードにたいして有用です。

     *Common Lispに関する注意:* トップレベルでは、‘eval-when-compile’は
     Common Lispのイディオム‘(eval-when (compile eval) ...)’に類似してい
     ます。トップレベル以外では、Common Lispのリーダーマクロ‘#.’(ただし
     解釈時を除く)が、‘eval-when-compile’と近いことを行います。


File: elisp,  Node: Compiler Errors,  Next: Byte-Code Objects,  Prev: Eval During Compile,  Up: Byte Compilation

16.6 Compiler Errors
====================

バイトコンパイルのエラーメッセージと警告メッセージは、‘*Compile-Log*’と
いう名前のバッファーにプリントされます。これらのメッセージには、問題とな
る箇所を示すファイル名と行番号が含まれます。これらのメッセージにたいして
、コンパイラー出力を操作する通常のEmacsコマンドが使用できます。

   あるエラーがプログラムのシンタックスに由来する場合、バイトコンパイラ
ーはエラーの正確な位置の取得に際し混乱するかもしれません。バッファー
‘ *Compiler Input*’.にスイッチするのは、これを調べ1つの方法です。(このバ
ッファー名はスペースで始まるので、Buffer Menuに表示されません。)このバッ
ファーにはコンパイルされたプログラムと、バイトコンパイラーが読み取れた箇
所からポイントがどれほど離れているかが含まれ、エラーの原因はその近傍にあ
るかもしれません。シンタックスエラーを見つけるヒントについては、*note
Syntax Errors::を参照してください。

   定義されていない関数や変数の使用は、バイトコンパイラーにより報告され
る警告のタイプとしては一般的です。そのような警告では、定義されていない関
数や変数を使用した位置ではなく、そのファイルの最後の行の行番号が報告され
るので、それを見つけるには手作業で検索しなければなりません。

   定義のない関数や変数の警告が間違いだと確信できる場合には、警告を抑制
する方法がいくつかあります:

   • 関数FUNCへの特定の呼び出しにたいする警告は、それを条件式で
     ‘fboundp’によるテストを行なうことで抑制できます:

          (if (fboundp 'FUNC) ...(FUNC ...)...)

     FUNCへの呼び出しは‘if’文のTHEN-FORM内になければならず、FUNCは
     ‘fboundp’呼び出し内でクォートされていなければなりません。(この機能
     は‘cond’でも同様に機能します。)

   • 同じように、変数VARIABLEの特定の使用についの警告を、条件式内の
     ‘boundp’テストで抑制できます:

          (if (boundp 'VARIABLE) ...VARIABLE...)

     VARIABLEへの参照は‘if’文のTHEN-FORM内になければならず、VARIABLEは
     ‘boundp’呼び出し内でクォートされていなければなりません。

   • コンパイラーに関数が‘declare-function’を使用して定義されていると告
     げることができます。*note Declaring Functions::を参照してください。

   • 同じように、その変数が初期値なしの‘defvar’を使用して定義されている
     とコンパイラーに告げることができます。(これはその変数を特別な変数と
     してマークすることに注意してください。*note Defining Variables::を
     参照してください。

   ‘with-no-warnings’構成を使用して特定の式にたいするコンパイラーのすべ
ての任意の警告を抑制することもできます:

 -- Special Form: with-no-warnings body...
     実行時には〜これは‘(progn BODY...)’と等価ですが、コンパイラーは
     BODYの中で起こるいかなる事項にたいしても警告を発しません。

     わたしたちは、あなたが抑制したいと意図する警告以外の警告を失わない
     ようにするために、可能な限り小さいコード断片にたいしてこの構成を使
     用することを推奨します。

   変数‘byte-compile-warnings’をセットすることにより、コンパイラーの警告
をより詳細に制御できます。詳細は、変数のドキュメント文字列を参照してくだ
さい。


File: elisp,  Node: Byte-Code Objects,  Next: Disassembly,  Prev: Compiler Errors,  Up: Byte Compilation

16.7 Byte-Code Function Objects
===============================

バイトコンパイルされた関数は、特別なデータ型、“バイトコード関数オブジェ
クト(byte-code function objects)”をもちます。関数呼び出しとしてそのよう
なオブジェクトが出現したとき、Emacsはそのバイトコードを実行するために、
常にバイトコードインタープリターを使用します。

   内部的には、バイトコード関数オブジェクトはベクターによく似ています。
バイトコード関数オブジェクトの要素には、‘aref’を通じてアクセスできます。
バイトコード関数オブジェクトのプリント表現(printed representation)はベク
ターに似ていて、開き‘[’の前に‘#’が追加されます。バイト関数オブジェクトは
少なくとも4つの要素をもたねばならず、要素数に上限はありません。しかし通
常使用されるのは、最初の6要素です。これらは:

ARGLIST
     シンボル引数のリスト。

BYTE-CODE
     バイトコード命令を含む文字列。

CONSTANTS
     バイトコードにより参照されるLispオブジェクトのベクター。関数名と変
     数名に使用されるシンボルが含まれる。

STACKSIZE
     この関数が要するスタックの最大サイズ。

DOCSTRING
     (もしあれば)ドキュメント文字列。それ以外は‘nil’。ドキュメント文字列
     がファイルに格納されている場合、値は数字かリストかもしれない。本当
     のドキュメント文字列の取得には、関数‘documentation’を使用する(*note
     Accessing Documentation::を参照)。

INTERACTIVE
     (もしあれば)インタラクティブ仕様。文字列かLisp式。インタラクティブ
     でない関数では‘nil’。

   以下は、バイトコード関数オブジェクトのプリント表現の例です。これはコ
マンド‘backward-sexp’の定義です。

     #[(&optional arg)
       "^H\204^F^@\301^P\302^H[!\207"
       [arg 1 forward-sexp]
       2
       254435
       "^p"]

   バイトコードオブジェクトを作成する原始的な方法は、‘make-byte-code’で
す:

 -- Function: make-byte-code &rest elements
     この関数はELEMENTSを要素とするバイトコードオブジェクトを構築して、
     リターンします。

   あなた自身が要素を収集してバイトコード関数を構築しないでください。そ
れらが矛盾する場合、その関数の呼び出しによりEmacsがクラッシュするかもし
れません。これらのオブジェクトの作成は、常にバイトコンパイラーにまかせて
ください。バイトコンパイラーは、要素を矛盾なく構築します(願わくば)。


File: elisp,  Node: Disassembly,  Prev: Byte-Code Objects,  Up: Byte Compilation

16.8 Disassembled Byte-Code
===========================

人はバイトコードを記述しません。それはバイトコンパイラーの仕事です。しか
し、好奇心を満たすために、わたしたちはディスアセンブラを提供しています。
ディスアセンブラは、バイトコードを人間が読めるフォームに変換します。

   バイトコードインタープリターは、シンプルなスタックマシンとして実装さ
れています。これは値を自身のスタックにpushして、計算で使用するためにそれ
らをpopして取り出し、おの結果を再びそのスタックにpushして戻します。バイ
トコード関数がリターンするときは、スタックから値をpopして取り出し、その
関数の値としてリターンします。

   それに加えてスタックとバイトコード関数は、値を変数とスタックの間で転
送することにより、普通のLisp変数を使用したり、バインドおよびセットするこ
とができます。

 -- Command: disassemble object &optional buffer-or-name
     このコマンドは、OBJECTにたいするディスアセンブルされたコードを表示
     します。インタラクティブに使用した場合、またはBUFFER-OR-NAMEが
     ‘nil’か省略された場合は、‘*Disassemble*’という名前のバッファーに出
     力します。BUFFER-OR-NAMEが非‘nil’の場合は、バッファーもしくは既存の
     バッファーの名前でなければなりません。その場合は、そのバッファーの
     ポイント位置に出力され、ポイントは出力の前に残りされます。

     引数OBJECTには関数名、ラムダ式(*note Lambda Expressions::を参照)、
     またはバイトコードオブジェクト(*note Byte-Code Objects::を参照)を指
     定できます。ラムダ式の場合、‘disassemble’はそれをコンパイルしてから
     、そのコンパイル済みコードをディスアセンブルします。

   以下に‘disassemble’関数を使用した例を2つ示します。バイトコードと
Lispソースを関連付ける助けとなるように、説明的なコメントを追加してありま
す。これらのコメントは、‘disassemble’の出力にはありません。

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          ⇒ factorial

     (factorial 4)
          ⇒ 24

     (disassemble 'factorial)
          ⊣ byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   varref   integer      ; ‘integer’の値を取得して
                               ;   それをスタック上にpushする。
     1   constant 1            ; スタック上に1をpushする。
     2   eqlsign               ; 2つの値をスタックからpopして取り出し、
                               ;   それらを比較して結果をスタック上にpushする。
     3   goto-if-nil 1         ; スタックのトップをpopしてテストする。
                               ;   ‘nil’なら1へ、それ以外はcontinue。
     6   constant 1            ; スタックのトップに1をpushする。
     7   return                ; スタックのトップの要素をリターンする。
     8:1 varref   integer      ; ‘integer’の値をスタック上にpushする。
     9   constant factorial    ; ‘factorial’をスタック上にpushする。
     10  varref   integer      ; ‘integer’の値をスタック上にpushする。
     11  sub1                  ; ‘integer’をpopして値をデクリメントする。
                               ;   スタック上に新しい値をpushする。
     12  call     1            ; スタックの最初(トップ)の要素を引数として
                               ;   関数‘factorial’を呼び出す。
                               ;   リターン値をスタック上にpushする。
     13 mult                   ; スタックのトップ2要素をpopして取り出し乗じ
                               ;   結果をスタック上にpushする。
     14 return                 ; スタックのトップ要素をリターンする。

   ‘silly-loop’は幾分複雑です:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
          ⇒ silly-loop

     (disassemble 'silly-loop)
          ⊣ byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; ‘current-time-string’を
                                       ;   スタック上のトップにpushする。
     1   call     0            ; 引数なしで‘current-time-string’を呼び出し
                               ;   結果をスタック上にpushする。
     2   varbind  t1           ; スタックをpopして‘t1’にpopされた値をバインドする。
     3:1 varref   n            ; 環境から‘n’の値を取得して
                               ;   その値をスタック上にpushする。
     4   sub1                  ; スタックのトップから1を減ずる。
     5   dup                   ; スタックのトップを複製する。
                               ;   たとえばスタックのトップをコピーしてスタック上にpushする。
     6   varset   n            ; スタックのトップをpopして
                               ;   ‘n’をその値にバインドする。

     ;; (要はシーケンス‘dup varset’はpopせずに
     ;;  スタックのトップを‘n’の値にコピーする。)

     7   constant 0            ; スタック上に0をpushする。
     8   gtr                   ; スタックのトップ2値をpopして取り出し
                               ;   Nが0より大かテストし
                               ;   結果をスタック上にpushする。
     9   goto-if-not-nil 1     ; ‘n’ > 0なら1へ
                               ;   (これはwhile-loopを継続する)
                               ;   それ以外はcontinue。
     12  varref   t1           ; ‘t1’の値をスタック上にpushする。
     13  constant current-time-string  ; ‘current-time-string’を
                                       ;   スタックのトップにpushする。
     14  call     0            ; 再度‘current-time-string’を呼び出す。
     15  unbind   1            ; ローカル環境の‘t1’をアンバインドする。
     16  list2                 ; スタックのトップ2要素をpopして取り出し
                               ;   それらのリストを作りスタック上にpushする。
     17  return                ; スタックのトップの値をリターンする。


File: elisp,  Node: Debugging,  Next: Read and Print,  Prev: Byte Compilation,  Up: Top

17 Debugging Lisp Programs
**************************

Emacs Lispプログラム内の問題を見つけて詳細に調べる方法が、いくつかありま
す。

   • プログラム実行中に問題が発生した場合は、Lisp評価機能をサスペンドす
     るためにビルトインのEmacs Lispデバッガを使用して、評価機能の内部状
     態の調査および/または変更を行なうことができます。

   • Emacs Lispにたいするソースレベルデバッガの、Edebugを使用できます。

   • 文法的な問題によりLispがプログラムを読むことさえできない場合は、
     Lisp編集コマンドを使用して該当箇所を見つけることができます。

   • バイトコンパイラーがプログラムをコンパイルするとき、コンパイラーに
     より生成されるエラーメッセージと警告メッセージを調べることができま
     す。*note Compiler Errors::を参照してください。

   • Testcoverパッケージを使用してプログラムのテストカバレッジを行なえま
     す。

   • ERTパッケージを使用して、プログラムにたいするリグレッションテストを
     記述できます。*note the ERT manual: (ert)Top.を参照してください。

   • プログラムをプロファイルして、プログラムをより効果的にするためのヒ
     ントを取得できます。

   入出力の問題をデバックする便利なその他のツールに、ドリブルファイル
(dribble file: *note Terminal Input::を参照)と、‘open-termscript’関数
(*note Terminal Output::)があります。

* Menu:

* Debugger::                 Emacs
                               Lisp評価機能にたいするデバッガ。
* Edebug::                   Emacs Lispソースレベルデバッガ。
* Syntax Errors::            シンタックスエラーを見つける方法。
* Test Coverage::            プログラムのすべての分岐を確実にテストする。
* Profiling::                あなたのコードが使用するリソースの計測。


File: elisp,  Node: Debugger,  Next: Edebug,  Up: Debugging

17.1 The Lisp Debugger
======================

普通の“Lispデバッガ”は、フォーム評価のサスペンド機能を提供します。評価が
サスペンド(一般的には“break”の状態として知られる)されている間、実行時ス
タックを調べたり、ローカル変数やグローバル変数の値を調べたり変更すること
ができます。breakは再帰編集(recursive edit)なので、Emacsの通常の編集機能
が利用可能です。デバッガにエンターするようにプログラムを実行することさえ
可能です。*note Recursive Editing::を参照してください。

* Menu:

* Error Debugging::          エラー発生時にデバッガにエンターする。
* Infinite Loops::           exitしないプログラムの停止デバッグ。
* Function Debugging::       特定の関数が呼び出されたときにデバッガにエンターする。
* Explicit Debug::           プログラム内の特定箇所でデバッガにエンターする。
* Using Debugger::           デバッガが行なうこと:
                               そこで何を目にするか。
* Debugger Commands::        デバッガで使用するコマンド。
* Invoking the Debugger::    関数‘debug’の呼び出し方。
* Internals of Debugger::    デバッガのサブルーチン、およびグローバル変数。


File: elisp,  Node: Error Debugging,  Next: Infinite Loops,  Up: Debugger

17.1.1 Entering the Debugger on an Error
----------------------------------------

デバッガに入る一番重要なタイミングは、Lispエラーが発生したときです。デバ
ッガでは、エラーの直接原因を調査できます。

   しかしデバッガへのエンターは、エラーによる通常の結末ではありません。
多くのコマンドは不適切に呼び出されたときにLispエラーをシグナルするので、
通常の編集の間にこれが発生するたびデバッガにエンターするのは、とても不便
でしょう。したがって、エラーの際にデバッガにエンターしたい場合は、変数
‘debug-on-error’に非‘nil’をセットします。(コマンド
‘toggle-debug-on-error’は、これを簡単に行う方法を提供します。)

 -- User Option: debug-on-error
     この変数はエラーがシグナルされ、それがハンドルされていないときに、
     デバッガが呼び出されるかどうかを決定します。‘debug-on-error’が‘t’の
     場合は、‘debug-ignored-errors’(以下を参照)にリストされているエラー
     を除く、すべての種類のエラーがデバッガを呼び出します。‘nil’の場合は
     、デバッガを呼び出しません。

     値にはエラー条件(*note Signaling Errors::を参照)のリストも指定でき
     ます。その場合、このリスト内のエラー条件だけにより、デバッガが呼び
     出されます(‘debug-ignored-errors’にもリストされているエラー条件は除
     外されます)。たとえば、‘debug-on-error’をリスト‘(void-variable)’に
     セットした場合には、値をもたない変数に関するエラーにたいしてだけデ
     バッガが呼び出されます。

     ‘eval-expression-debug-on-error’がこの変数をオーバーライドする場合
     がいくつかあることに注意してください(以下を参照)。

     この変数が非‘nil’のとき、Emacsはプロセスフィルター関数と番兵
     (sentinel)の周囲にエラーハンドラーを作成しません。したがって、これ
     らの関数内でのエラーは、デバッガを呼び出します。*note Processes::を
     参照してください。

 -- User Option: debug-ignored-errors
     この変数は、‘debug-on-error’の値に関わらず、デバッガにエンターすべ
     きでないエラーを指定します。変数の値はエラー条件のシンボル、および
     /または正規表現のリストです。エラーがこれら条件シンボルのいずれか、
     またはエラーメッセージが正規表現のいずれかにマッチする場合、そのエ
     ラーはデバッガにエンターしません。

     この変数の通常の値には‘user-error’と、同様に編集中にしばしば発生す
     るがLispプログラムのバグによるものはほとんどない、いくつかのエラー
     が含まれます。しかし、“ほとんどない”は“絶対ない”ではありません。あ
     なたのプログラムがこのリストにマッチするエラーにより機能しない場合
     は、そのエラーをデバッグするために、このリストの変更を試みるのもよ
     いでしょう。通常は‘debug-ignored-errors’を‘nil’にセットしておくのが
     、もっとも簡単な方法です。

 -- User Option: eval-expression-debug-on-error
     この変数が非‘nil’値(デフォルト)の場合は、コマンド
     ‘eval-expression’の実行により、一時的に‘debug-on-error’が‘t’がバイ
     ンドされます。*note Evaluating Emacs-Lisp Expressions: (emacs)Lisp
     Eval.を参照してください。

     ‘eval-expression-debug-on-error’が‘nil’の場合は、
     ‘eval-expression’の間も‘debug-on-error’の値は変更されません。

 -- Variable: debug-on-signal
     ‘condition-case’によりキャッチされたエラーは通常、決してデバッガを
     呼び出しません。‘condition-case’は、デバッガがそのエラーをハンドル
     する前に、エラーをハンドルする機会を得ます。

     ‘debug-on-signal’を非‘nil’値に変更した場合は、‘condition-case’の存
     在如何に関わらず、すべてのエラーにおいてデバッガが最初に機会を得ま
     す。(デバッガを呼び出すためには、依然としてそのエラーが
     ‘debug-on-error’と‘debug-ignored-errors’で指定された条件を満たさな
     ければなりません。)

     *警告:* この変数を非‘nil’にセットすると、芳しくない効果があるかもし
     れません。Emacsのさまざまな部分で処理の通常の過程としてエラーがキャ
     ッチされており、そのエラーが発生したことに気づかないことさえあるか
     もしれません。‘condition-case’でラップされたコードをデバッグする必
     要がある場合は、‘condition-case-unless-debug’(*note Handling
     Errors::を参照)の使用を考慮してください。

 -- User Option: debug-on-event
     ‘debug-on-event’をスペシャルイベント(*note Special Events::を参照
     )にセットした場合は、Emacsは‘special-event-map’をバイパスして、この
     イベントを受け取ると即座にデバッガへのエンターを試みます。現在のと
     ころサポートされる値は、シグナル‘SIGUSR1’および‘SIGUSR2’に対応する
     値だけです(これがデフォルトです)。これは‘inhibit-quit’がセットされ
     ていて、それ以外はEmacsが応答しない場合に有用かもしれません。

 -- Variable: debug-on-message
     ‘debug-on-message’に正規表現をセットした場合には、それにマッチする
     メッセージがエコーエリアに表示されると、Emacsはデバッガにエンターし
     ます。たとえば、これは特定のメッセージの原因を探すのに有用かもしれ
     ません。

   initファイルロード中に発生したエラーをデバッグするには、オプション
‘--debug-init’を使用します。これはinitファイルロードの間に
‘debug-on-error’を‘t’にバインドして、通常はinitファイル内のエラーをキャ
ッチする‘condition-case’をバイパスします。


File: elisp,  Node: Infinite Loops,  Next: Function Debugging,  Prev: Error Debugging,  Up: Debugger

17.1.2 Debugging Infinite Loops
-------------------------------

プログラムが無限にループしてリターンできないとき、最初の問題はそのループ
をいかに停止するかです。ほとんどのオペレーティングシステムでは、
(“quit”させる)‘C-g’でこれを行うことができます。*note Quitting::を参照し
てください。

   普通のquitでは、なぜそのプログラムがループしたかについての情報は与え
られません。変数‘debug-on-quit’に非‘nil’をセットすることにより、より多く
の情報を得ることができます。無限ループの途中でデバッガを実行すれば、デバ
ッガからステップコマンドで先へ進むことができます。ループ全体をステップで
追えば、問題を解決するために十分な情報が得られるでしょう。

   ‘C-g’によるquitはエラーとは判断されないので、‘C-g’のハンドルに
‘debug-on-error’は効果がありません。同じように、‘debug-on-quit’はエラー
にたいして効果がありません。

 -- User Option: debug-on-quit
     この変数は、‘quit’がシグナルされ、それがハンドルされていないときに
     、デバッガを呼び出すかどうかを決定します。‘debug-on-quit’が非
     ‘nil’の場合は、quit(つまり‘C-g’をタイプ)したときは常にデバッガが呼
     び出されます。‘debug-on-quit’が‘nil’(デフォルト)の場合は、quitして
     もデバッガは呼び出されません。


File: elisp,  Node: Function Debugging,  Next: Explicit Debug,  Prev: Infinite Loops,  Up: Debugger

17.1.3 Entering the Debugger on a Function Call
-----------------------------------------------

プログラムの途中で発生する問題を調べるための有用なテクニックの1つは、特
定の関数が呼び出されたときデバッガにエンターする方法です。問題が発生した
関数にこれを行い、その関数をステップで追ったり、問題箇所の少し手前の関数
呼び出しでこれを行い、その関数をステップオーバーしてその後をステップで追
うことができます。

 -- Command: debug-on-entry function-name
     この関数は、FUNCTION-NAMEが呼び出されるたびにデバッガの呼び出しを要
     求します。

     Lispコードで定義された任意の関数およびマクロは、インタープリターに
     解釈されたコードかコンパイル済みのコードかに関わらず、エントリーに
     breakをセットできます。その関数がコマンドの場合は、Lispから呼び出さ
     れたときと、インタラクティブに呼び出されたとき、デバッガにエンター
     します。(たとえばCで記述された)プリミティブ関数にも、この方法で
     ‘debug-on-entry’をセットできますが、そのプリミティブがLispコードか
     ら呼び出されたときだけ効果があります。‘debug-on-entry’はスペシャル
     フォームにはセットできません。

     ‘debug-on-entry’がインタラクティブに呼び出されたときは、ミニバッフ
     ァーでFUNCTION-NAMEの入力を求めます。その関数がすでにエントリーでデ
     バッガを呼び出すようにセットアップされていた場合、
     ‘debug-on-entry’は何も行いません。‘debug-on-entry’は常に
     FUNCTION-NAMEをリターンします。

     以下は、この関数の使い方を説明するための例です:

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               ⇒ fact
          (debug-on-entry 'fact)
               ⇒ fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Debugger entered--entering a function:
          * fact(3)
            eval((fact 3))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ------ Buffer: *Backtrace* ------


 -- Command: cancel-debug-on-entry &optional function-name
     この関数はFUNCTION-NAMEにたいする‘debug-on-entry’の効果をアンドゥし
     ます。インタラクティブに呼び出されたときは、ミニバッファーで
     FUNCTION-NAMEの入力を求めます。FUNCTION-NAMEが省略された、あるいは
     ‘nil’の場合は、すべての関数にたいするbreak-on-entryをキャンセルしま
     す。エントリー時にbreakするようセットアップされていない関数に
     ‘cancel-debug-on-entry’を呼び出したときは、何も行いません。


File: elisp,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Function Debugging,  Up: Debugger

17.1.4 Explicit Entry to the Debugger
-------------------------------------

プログラム内の特定箇所に式‘(debug)’を記述することにより、その箇所でデバ
ッガが呼び出されるようにできます。これを行うにはソースファイルをvisitし
て、適切な箇所にテキスト‘(debug)’を挿入し、‘C-M-x’(Lispモードでの
‘eval-defun’にたいするキーバインド)をタイプします。*警告:* 一時的なデバ
ッグ目的のためにこれを行なう場合は、ファイルを保存する前に確実にアンドゥ
してください!

   ‘(debug)’を挿入する箇所は、追加フォームが評価されることができ、その値
を無視することができる箇所でなければなりません。(‘(debug)’の値が無視され
ない場合が、プログラムの実行が変更されてしまうでしょう!) 一般的にもっと
も適した箇所は、‘progn’または暗黙的な‘progn’(*note Sequencing::を参照)の
内部です。

   デバッグ命令を配したいソースコード中の正確な箇所がわからないが、特定
のメッセージが表示されたときにバックトレースを表示したい場合は、意図する
メッセージにマッチする正規表現を‘debug-on-message’にセットできます。


File: elisp,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

17.1.5 Using the Debugger
-------------------------

デバッガにエンターすると、その前に選択されていたウィンドウを1つのウィン
ドウに表示し、他のウィンドウに‘*Backtrace*’という名前のバッファーを表示
します。backtraceバッファーには、現在実行されているLisp関数の各レベルが
1行ずつ含まれます。このバッファーの先頭は、デバッガが呼び出された理由を
説明するメッセージ(デバッガがエラーにより呼び出された場合はエラーメッセ
ージや関連するデータなど)です。

   backtraceバッファーは読み取り専用で、文字キーにデバッガコマンドが定義
されたDebuggerモードという特別なメジャーモードを使用します。通常の
Emacs編集コマンドが利用できます。したがって、エラー時に編集されていたバ
ッファーを調べるためにウィンドウを切り替えたり、バッファーを切り替えやフ
ァイルのvisit、その他一連の編集処理を行なうことができます。しかしデバッ
ガは再帰編集レベル(*note Recursive Editing::を参照)にあり、編集が終わっ
たらそれはbacktraceバッファーに戻って、(‘q’コマンドで)デバッガをexitでき
ます。デバッガをexitすることにより、再帰編集を抜け出し、backtraceバッフ
ァーはバリー(bury: 覆い隠す)されます。(変数‘debugger-bury-or-killw’をセ
ットすることにより、backtraceバッファーで‘q’コマンドが何を行うかをカスタ
マイズできます。たとえば、バッファーをバリーせずにkillしたい場合は、この
変数を‘kill’にセットします。他の値については、変数のドキュメントを調べて
ください。)

   デバッガにエンターしたとき、‘eval-expression-debug-on-error’に一致す
るように変数‘debug-on-error’が一時的にセットされます。変数
‘eval-expression-debug-on-error’が非‘nil’の場合、‘debug-on-error’は一時
的に‘t’にセットされます。これは、デバッグセッション行っている間にさらに
エラーが発生すると、(デフォルトでは)他のbacktraceがトリガーされることを
意味します。これが望ましくない場合は、‘debugger-mode-hook’内で
‘eval-expression-debug-on-error’を‘nil’にセットするか、
‘debug-on-error’を‘nil’にセットすることができます。

   backtraceバッファーは、実行されている関数と、その関数の引数の値を示し
ます。しのフレームを示す行にポイントを移動して、スタックフレームを指定す
ることもできます。(スタックフレームとは、Lispインタープリターがある関数
への特定の呼び出しを記録する場所のことです。) 行ポイントがオンのフレーム
が、“カレントフレーム(current frame)”となります。デバッガコマンドのいく
つかは、カレントフレームを処理します。ある行がスター(star)で始まる場合は
、そのフレームをexitすることにより再びデバッガが呼び出されることを意味し
ます。これは関数のリターン値を調べるとき有用です。

   関数名にアンダーラインが引かれている場合は、デバッガがその関数のソー
スコードも位置を知っていることを意味します。その名前をマウスでクリックす
るか、そこに移動して<RET>をタイプして、ソースコードをvisitできます。

   デバッガはデバッガ自身のスタックフレーム数を想定するため、バイトコン
パイルされて実行されなければなりません。デバッガがインタープリターに解釈
されて実行されているとき、これらの想定は正しくなくなります。


File: elisp,  Node: Debugger Commands,  Next: Invoking the Debugger,  Prev: Using Debugger,  Up: Debugger

17.1.6 Debugger Commands
------------------------

(Debuggerモードの)debuggerバッファーでは、通常のEmacsコマンドに加えて、
特別なコマンドが提供されます。デバッガでもっとも重要な使い方をするのは、
制御フローを見ることができるコードをステップ実行するコマンドです。デバッ
ガはインタープリターにより解釈された制御構造のステップ実行はできますが、
バイトコンパイル済みの関数ではできません。バイトコンパイル済み関数をステ
ップ実行したい場合は、同じ関数の解釈された定義に置き換えてください。(こ
れを行なうには、その関数のソースをvisitして、関数の定義で‘C-M-x’とタイプ
してください。) プリミティブ関数のステップ実行にLispデバッガは使用できま
せん。

   以下はDebuggerモードのコマンドのリストです:

‘c’
     デバッガをexitして、実行を継続する。これはあたかもデバッガにエンタ
     ーしなかったかのように(デバッガ内で行った変数値やデータ構造の変更な
     どの副作用は除外される)、プログラムの実行を再開する。

‘d’
     実行を継続するが、次にLisp関数が何か呼び出されたときはデバッガにエ
     ンターする。これにより、ある式の下位の式をステップ実行して、下位の
     式が計算する値や、行うことを確認できる。

     デバッガにエンターした関数呼び出しにたいして、この方法で作成された
     スタックフレームには自動的にフラグがつくので、そのフレームをexitす
     ると再びデバッガが呼び出されます。このフラグは、‘u’コマンドを使用し
     てキャンセルできます。

‘b’
     カレントフレームにフラグをつけるので、そのフレームをexitするときデ
     バッガにエンターする。この方法でフラグがつけられたフレームは、
     backtraceバッファーでスターのマークがつく。

‘u’
     カレントフレームをexitしたとき、デバッガにエンターしてはならない。
     これは、そのフレームの‘b’コマンドをキャンセルする。目に見える効果と
     しては、backtraceバッファーの行からスターが削除される。

‘j’
     ‘b’と同じようにカレントフレームにフラグをつける。その後、‘c’のよう
     に実行を継続するが、‘debug-on-entry’によりセットアップされたすべて
     の関数にたいするbreak-on-entryを一時的に無効にする。

‘e’
     ミニバッファーのLisp式を読み取り、(関連するlexical環境が適切なら)評
     価して、エコーエリアに値をプリントする。デバッガは特定の重要な変数
     とバッファーを処理の一部としてを変更する。‘e’は一時的にデバッガの外
     部からそれらの値をリストアするので、それらを調べて変更できる。これ
     によりデバッガはより透過的になる。対照的に、デバッガ内で‘M-:’は特別
     なことを行わず、デバッガ内での変数の値を表示する。

‘R’
     ‘e’と同様だが、バッファー‘*Debugger-record*’内の評価の結果も保存す
     る。

‘q’
     デバッグされているプログラムを終了し、Emacsコマンド実行のトップレベ
     ルにリターンする。

     ‘C-g’によりデバッガにエンターしたが、実際はデバッグではなくquitした
     いときは、‘q’コマンドを使用する。

‘r’
     デバッガから値をリターンする。ミニバッファーで式を読み取り、それを
     評価することにより、値が計算される。

     ‘d’コマンドは、(‘b’によるリクエスト、または‘d’によるそのフレームへ
     のエンターによる)Lisp呼び出しフレームからのexitでデバッガが呼び出さ
     れたときに有用です。‘r’コマンドで指定された値は、そのフレームの値と
     して使用されます。これは、‘debug’を呼び出して、そのリターン値を使用
     するときも有用です。それ以外は、‘r’は‘c’と同じ効果をもｙい、指定さ
     れたリターン値は問題になりません。

     エラーによりデバッガにエンターしたときは、‘r’コマンドは使用できませ
     ん。

‘l’
     呼び出されたときにデバッガを呼び出す関数をリストします。これは、
     ‘debug-on-entry’によりエントリー時にbreakするようセットされた関数の
     リストです。

‘v’
     カレントスタックフレームのローカル変数の表示を切り替えます。


File: elisp,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

17.1.7 Invoking the Debugger
----------------------------

以下では、デバッガを呼び出すために使用される関数‘debug’の完全な詳細を説
明します。

 -- Command: debug &rest debugger-args
     この関数は、デバッガにエンターします。この関数は‘*Backtrace*’(デバ
     ッガへの2回目以降の再帰エントリーでは‘*Backtrace*<2>、...’)という名
     前のバッファーにバッファーを切り替えて、Lisp関数呼び出しについての
     情報を書き込みます。それから再帰編集にエンターして、Debuggerモード
     でbacktraceバッファーを表示します。

     Debuggerモードのコマンド‘c’、‘d’、‘j’、‘r’は再帰編集をexitします。
     その後、‘debug’は以前のバッファーに戻って、‘debug’を呼び出したもの
     が何であれ、そこにリターンします。これは関数‘debug’が呼び出し元にリ
     ターン可能な唯一の方法です。

     DEBUGGER-ARGSを使用すると、‘debug’は‘*Backtrace*’の最上部に残りの引
     数を表示するもで、ユーザーがそれらを確認できます。以下で説明する場
     合を除き、これは、これらの引数を使用する_唯一_の方法です。

     しかし‘debug’への1つ目の引数にたいする値は、特別な意味をもちます。
     (これらの値は通常、‘debug’を呼び出すプログラマーではなく、Emacs内部
     でのみ使用されます。) 以下はこれら特別な値のテーブルです:

     ‘lambda’
          1つ目の引数ga‘lambda’の場合、それは‘debug-on-next-call’が非
          ‘nil’のときに関数にエントリーしたことにより‘debug’が呼び出され
          たことを意味する。デバッガはバッファーのトップのテキスト行に
          ‘Debugger entered--entering a function:’と表示する。

     ‘debug’
          1つ目の引数が‘debug’の場合、それはエントリー時にデバッグされる
          ようにセットされた関数にエントリーしたことにより‘debug’が呼び
          出されたことを意味する。デバッガは‘lambda’のときと同様、
          ‘Debugger entered--entering a function:’を表示します。これはそ
          の関数のスタックフレームもマークするので、exit時にデバッガが呼
          び出される。

     ‘t’
          1つ目の引数が‘t’の場合、それは‘debug-on-next-call’が非‘nil’の
          ときに関数呼び出しの評価により‘debug’が呼び出されたことを示す
          。デバッガはバッファーのトップの行に‘Debugger
          entered--beginning evaluation of function call form:’と表示す
          る。

     ‘exit’
          1つ目の引数が‘exit’のときは、exit時にデバッガを呼び出すよう以
          前にマークされたスタックフレームをexitしたことを示す。この場合
          は、‘debug’に与えられた2つ目の引数が、そのフレームからリターン
          された値になる。デバッガはバッファーのトップの行に‘Debugger
          entered--returning value:’とリターンされた値を表示する。

     ‘error’
          1つ目の引数が‘error’のときは、ハンドルされていないエラーまたは
          ‘quit’がシグナルされてデバッガにエンターした場合で、デバッガは
          ‘Debugger entered--Lisp error:’とその後にシグナルされたエラー
          および‘signal’への引数を表示して、それを示す。たとえば、

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Debugger entered--Lisp error: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          エラーがシグナルされた場合はおそらく、変数‘debug-on-error’は非
          ‘nil’で、‘quit’がシグナルされた場合はおそらく、変数
          ‘debug-on-quit’は非‘nil’である。

     ‘nil’
          明示的にデバッガにエンターしたいときは、DEBUGGER-ARGSの1つ目の
          引数に‘nil’を使用する。残りのDEBUGGER-ARGSは、バッファーのトッ
          プの行にプリントされる。メッセージ — たとえば‘debug’が呼び出さ
          れた条件を思い出すためのリマインダー — の表示にこの機能を使用
          できる。


File: elisp,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

17.1.8 Internals of the Debugger
--------------------------------

このセクションでは、デバッガ内部で使用される関数と変数について説明します
。

 -- Variable: debugger
     この関数の値は、デバッガを呼び出す関数呼び出しです。値には任意個の
     引数をとる関数、より具体的には関数の名前でなければなりません。この
     関数は何らかのデバッガを呼び出すべきです。この変数のデフォルト値は
     ‘debug’です。

     関数にたいしてLispが渡す1つ目の引数は、その関数がなぜ呼び出されたか
     を示します。引数の慣習は、‘debug’(*note Invoking the Debugger::)に
     詳解されています。

 -- Command: backtrace
     この関数は現在アクティブなLisp関数呼び出しのトレースをプリントしま
     す。この関数は‘debug’が‘*Backtrace*’バッファーに書き込む内容を得る
     ために使用されます。どの関数呼び出しがアクティブか判断するためにス
     タックにアクセスしなければならないので、この関数はCで記述されていま
     す。リターン値は、常に‘nil’です。

     以下の例では、Lisp式で明示的に‘backtrace’を呼び出しています。これは
     ストリーム‘standard-output’(この場合はバッファー
     ‘backtrace-output’)にbacktraceをプリントします。

     backtraceの各行は、1つの関数呼び出しを表します。関数の引数が既知の
     場合は行に値が表示され、まだ計算中の場合は行にその旨が示されます。
     スペシャルフォームの引数は無視されます。

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               ⇒ (testing nil)

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval((with-output-to-temp-buffer ...))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- Variable: debug-on-next-call
     この変数が非‘nil’の場合、それは次の‘eval’、‘apply’、‘funcall’の前に
     デバッガを呼び出すよう指定します。デバッガへのエンターにより、
     ‘debug-on-next-call’は‘nil’にセットされます。

     デバッガの‘d’コマンドは、この変数をセットすることにより機能します。

 -- Function: backtrace-debug level flag
     この関数は、そのスタックフレームのLEVEL下位のスタックフレームの
     debug-on-exitフラグにFLAGに応じた値をセットします。FLAGが非‘nil’の
     場合は、後にそのフレームをexitするときデバッガにエンターします。そ
     のフレームを通じた非ローカルexitでも、デバッガにエンターします。

     この関数は、デバッガだけに使用されます。

 -- Variable: command-debug-status
     この変数はカレントのインタラクティブコマンドのデバッグ状態を記録し
     ます。コマンドがインタラクティブに呼び出されるたびに、この変数は
     ‘nil’にバインドされます。デバッガは、同じコマンドが呼び出されたとき
     のデバッガ呼び出しに情報を残すために、この変数をセットできます。

     普通のグローバル変数ではなくこの変数を使用する利点は、そのデータが
     後続のコマンド呼び出しに決して引き継がれないことです。

 -- Function: backtrace-frame frame-number
     関数‘backtrace-frame’は、Lispデバッガ内での使用を意図しています。こ
     れは、FRAME-NUMBERレベル下位のスタックフレームで、何の評価が行われ
     ているかに関する情報をリターンします。

     そのフレームがまだ引数を評価していない場合、またはそのフレームがス
     ペシャルフォームの場合、値は‘(nil FUNCTION ARG-FORMS...)’です。

     そのフレームが引数を評価して関数をすでに呼び出した場合、リターン値
     は‘(t FUNCTION ARG-VALUES...)’です。

     リターン値のFUNCTIONは何であれ評価されたリストのCARとして提供されま
     す。マクロ呼び出しの場合は‘lambda’式になります。その関数に‘&rest’引
     数がある場合は、リストARG-VALUESの末尾に表されます。

     FRAME-NUMBERが範囲外の場合、‘backtrace-frame’は‘nil’をリターンしま
     す。


File: elisp,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

17.2 Edebug
===========

EdebugはEmacs Lispプログラムにたいするソースレベルデバッガです。これによ
り、以下のことができます:

   • 式の前や後でストップして、評価をステップで実行する。

   • 条件付き、または無条件のbreakpointのセット。

   • 指定された条件がtrueのときにストップする(グローバルbreakpoint)。

   • ストップポイントごとに停止したり、breakpointごとに簡単に停止して、
     低速または高速にトレースを行う。

   • Edebug外部であるかのように、式の結果を表示し、式を評価する。

   • 式のリストを自動的に再評価して、Edebugがディスプレイを更新するたび
     にそれらの結果を表示する。

   • 関数呼び出しとリターンのトレース情報を出力する。

   • エラー発生時にストップする。

   • Edebug自身のフレームを除外してbacktraceを表示する。

   • マクロおよびフォームの定義で引数の評価を指定する。

   • 初歩的なカバレッジテストと頻度数の取得。

   以下の初めの3つのセクションは、使用を開始するためにEdebugについて十分
説明します。

* Menu:

* Using Edebug::             Edebug使用のための手引き。
* Instrumenting::            Edebugでデバッグするために、コードをインストルメント(計装)しなければならないe
* Modes: Edebug Execution Modes.  多かれ少なかれ、ストップする実行モード。
* Jumping::                  特定の位置にジャンプするコマンド。
* Misc: Edebug Misc.         さまざまなコマンド。
* Breaks::                   プログラムをストップさせるbreakpointのセット。
* Trapping Errors::          Edebugでのエラーのトラップ。
* Views: Edebug Views.       Edebugの内側と外側のビュー。
* Eval: Edebug Eval.         Edebugでの式の評価。
* Eval List::                Edebugにエンターするたびに値が表示される式。
* Printing in Edebug::       プリントのカスタマイズ。
* Trace Buffer::             バッファー内で採れを生成する方法。
* Coverage Testing::         評価をカバレッジテストする方法。
* The Outside Context::      Edebugが保存およびリストアするデータ。
* Edebug and Macros::        マクロ呼び出しをハンドルする方法の指定。
* Options: Edebug Options.   Edebugをカスタマイズするオプション変数。


File: elisp,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

17.2.1 Using Edebug
-------------------

EdebugでLispプログラムをデバッグするには、最初にデバッグしたいLispコード
を“インストルメント(instrument: 計装)”しなければなりません。これを行なう
もっともシンプルな方法は、関数またはマクロの定義に移動して、‘C-u
C-M-x’(プレフィクス引数を指定した‘eval-defun’)を行います。コードをインス
トルメントする他の手段については、*note Instrumenting::を参照してくださ
い。

   一度関数をインストルメントすると、その関数にたいする任意の呼び出しに
より、Edebugがアクティブになります。Edebugがアクティブになると、どの
Edebug実行モードを選択したかに依存して、その関数をステップ実行できるよう
に実行がストップされるか、ディスプレイを更新してデバッグコマンドにたいす
るチェックの間、実行が継続されます。デフォルトの実行モードstepで、これは
実行をストップします。*note Edebug Execution Modes::を参照してください。

   Edebugでは通常、デバッグしているLispコードをEmacsバッファーで閲覧しま
す。これを“ソースコードバッファー(source code buffer)”と呼び、バッファー
は一時的に読み取り専用になります。

   左フリンジの矢印は、その関数で実行されている行を示します。最初ポイン
トはその関数の実行されている行にありますが、ポイントを移動するとこれは真
ではなくなります。

   以下は、‘fac’の定義(以下を参照)をインストルメントして‘(fac 3)’を実行
した場合に通常目にするものです。ポイントは、‘if’の前の開きカッコにありま
す。

     (defun fac (n)
     =>★(if (< 0 n)
           (* n (fac (1- n)))
         1))

   関数内でEdebugが実行をストップできる位置のことを、“ストップポイント
(stop points)”と呼びます。ストップポイントは、リストであるような部分式の
前後、および変数参照の後でも発生します。以下は、関数‘fac’内のストップポ
イントをピリオドで示したものです:

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac .(1- n.).).).
         1).)

   Emacs Lispモードのコマンドに加えて、ソースコードバッファーでは、
Edebugのスペシャルコマンドが利用できます。たとえば、Edebugコマンド
<SPC>で次のストップポイントまで実行することができます。‘fac’にエントリー
した後に一度‘fac’とタイプした場合は、以下のように表示されるでしょう:

     (defun fac (n)
     =>(if ★(< 0 n)
           (* n (fac (1- n)))
         1))

   式の後でEdebugが実行をストップしたときは、エコーエリアにその式の値が
表示されます。

   他にも頻繁に使用されるコマンドとして、ストップポイントにbreakpointを
セットする‘b’、breakpointに達するまで実行する‘g’、Edebugをexitしてトップ
レベルのコマンドループにリターンする‘q’があります。また、‘?’とタイプする
とすべてのEdebugコマンドがリストされます。


File: elisp,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

17.2.2 Instrumenting for Edebug
-------------------------------

LispコードのデバッグにEdebugを使用するためには、最初にそのコードを“イン
ストルメント(instrument: 計装)”しなければなりません。コードをインストル
メントすると、適切な位置でEdebugを呼び出すために追加コードが挿入されます
。

   関数定義でプレフィクス引数とともにコマンド‘C-M-x’ (‘eval-defun’)を呼
び出すと、それを評価する前にその定義をインストルメントします。(ソースコ
ード自体は変更しません。) 変数‘edebug-all-defs’が非‘nil’の場合は、プレフ
ィクス引数の意味を反転します。この場合、‘C-M-x’はプレフィクス引数が_なけ
れば_その定義をインストルメントします。‘edebug-all-defs’のデフォルト値は
‘nil’です。コマンド‘M-x edebug-all-defs’は、変数‘edebug-all-defs’の値を
切り替えます。

   ‘edebug-all-defs’が非‘nil’の場合は‘eval-region’、
‘eval-current-buffer’、‘eval-buffer’も、それらが評価する定義をインストル
メントします。同様に、‘edebug-all-forms’は、‘eval-region’が(非定義フォー
ムさえ含む）_あらゆる_フォームをインストルメントすべきかを制御します。こ
れはミニバッファー内でのロードや評価には適用されません。コマンド‘M-x
edebug-all-forms’は、このオプションを切り替えます。

   他にもコマンド‘M-x edebug-eval-top-level-form’が利用可能で、これは
‘edebug-all-defs’や‘edebug-all-forms’の値に関わらず、トップレベルの任意
のフォームをインストルメントします。‘edebug-defun’は
‘edebug-eval-top-level-form’のエイリアスです。

   Edebugがアクティブのの間、コマンド‘I’(‘edebug-instrument-callee’)は、
ポイント後のリストフォームに呼び出される関数およびマクロ定義がまだインス
トルメントされていなければ、それらをインストルメントします。これは、その
ファイルのソースの場所をEdebugが知っている場合だけ可能です。この理由によ
りEdebugロード後は、たとえ評価する定義をインストルメントしない場合でも、
‘eval-region’は評価するすべての定義の位置を記録します。インストルメント
済み関数呼び出しにステップインする‘i’コマンド(*note Jumping::を参照)も参
照してください。

   Edebugはすべての標準スペシャルフォーム、式引数をもつ‘interactive’フォ
ーム、無名ラムダ式、およびその他の定義フォームのインストルメント方法を知
っています。しかし、Edebugはユーザー定義マクロが引数にたいして何を行うか
を判断できないので、Edebug仕様を使用してその情報を与えなければなりません
。詳細は*note Edebug and Macros::を参照してください。

   Edebugがセッション内で最初にコードをインストルメントしようとするとき
は、フック‘edebug-setup-hook’を実行してから、それに‘nil’をセットします。
使おうとしているパッケージに結びつけてEdebug仕様をロードするためにこれを
使用できますが、それはEdebugを使用するときだけ機能します。

   定義からインストルメントを削除するには、単にインストルメントを行わな
い方法でその定義を再評価するだけです。フォームを絶対にインストルメントせ
ずに評価するには、2つの方法があります。それはファイルからの‘load’による
評価と、ミニバッファーからの‘eval-expression’(‘M-:’)による評価です。

   Edebugがインストルメント中にシンタックスエラー(syntax error: 構文エラ
ー)を検知した場合は、間違ったコードの箇所にポイントを残して
‘invalid-read-syntax’エラーをシグナルします。

   Edebug内で利用可能な他の評価関数については、*note Edebug Eval::を参照
してください。


File: elisp,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

17.2.3 Edebug Execution Modes
-----------------------------

Edebugは、デバッグするプログラムの実行にたいして、いくつかの実行モードを
サポートします。これらの実行モードを、“Edebug実行モード(Edebug execution
modes)”と呼びます。これらをメジャーモードやマイナーモードと混同しないで
ください。カレントのEdebug実行モードは、プログラムをストップする前に
Edebugがどれだけ実行を継続するか — たとえばストップポイントごとにストッ
プ、あるいは次のbreakpointまで継続など — と、ストップする前にEdebugがど
れだけ進捗を表示するかを決定します。

   Edebug実行モードは通常、ある特定のモードでプログラムを継続させるコマ
ンドをタイプすることにより指定します。以下は、それらのコマンドのテーブル
です。プログラムの実行を再開‘S’以外は、少なくともある長さの間だけ実行を
継続します。

‘S’
     Stop(ストップ): これ以上プログラムを実行しないで、Edebugのコマンド
     を待つ(‘edebug-stop’)。

‘<SPC>’
     Step(ステップ): 次のストップポイントでストップする
     (‘edebug-step-mode’)。

‘n’
     Next(次へ): 式の後にある次のストップポイントでストップする
     (‘edebug-next-mode’)。*note Jumping::の‘edebug-forward-sexp’も参照
     。

‘t’
     Trace(トレース): Edebugのストップポイントごとにpause(通常は1秒)する
     (‘edebug-trace-mode’)。

‘T’
     Rapid trace(高速でトレース):ストップポイントごとに表示を更新するが
     、実際にpauseはしない(‘edebug-Trace-fast-mode’)。

‘g’
     Go(進む): 次のbreakpointまで実行する(‘edebug-go-mode’)。*note
     Breakpoints::を参照。

‘c’
     Continue(継続): breakpointごとにpauseしてから継続する
     (‘edebug-continue-mode’)。

‘C’
     Rapid continue(高速で継続): ポイントを各breakpointへ移動するが、
     pauseしない(‘edebug-Continue-fast-mode’)。

‘G’
     Go non-stop(ストップせず進む): breakpointを無視する
     (‘edebug-Go-nonstop-mode’)。まだ‘S’、またはその他の編集コマンドでプ
     ログラムをストップするのは可能。

   一般的に、上記リストの最初のほうにある実行モードは後のほうの実行モー
ドに比べて、プログラムをより低速に実行、またはすぐにストップさせます。

   実行中、またはトレース中は、任意のEdebugコマンドをタイプすることによ
り、実行をインタラプト(interrupt: 中断、割り込み)できます。Edebugは次の
ストップポイントでプログラムをストップしてから、タイプされたコマンドを実
行します。たとえば、実行中に‘t’をタイプすると、次のストップポイントでト
レースモードに切り替えます。‘S’を使用すれば、他に何も行わずに実行をスト
ップできます。

   関数でたまたま読み取り入力が発生した場合には、実行のインタラプトを意
図してタイプされた文字は、かわりにその関数により読み取られます。そのプロ
グラムが入力を欲するタイミングに注意を払うことで、そのような意図せぬ結果
を避けることができます。

   このセクションのコマンドを含むキーボードマクロは、完全には機能しませ
ん。プログラムを再開するためにEdebugからexitすると、キーボードマクロの追
跡記録は失われます。これを処理するのは、簡単ではありません。またEdebug外
部でキーボードマクロを定義または実行しても、Edebug内部のコマンドに影響し
ません。通常これは利点です。*note Edebug Options::内の
‘edebug-continue-kbd-macro’オプションも参照してください。

   新たなEdebugレベルにエンターしたとき、初期の実行モードは変数
‘edebug-initial-mode’の値により与えられます(*note Edebug Options::を参照
)。デフォルトでこれはstepモードを指定します。たとえば１つのコマンドから
インストルメント済みの関数が複数回呼び出された場合は、同じEdebugレベルに
再エンターするかもしれないことに注意してください。

 -- User Option: edebug-sit-for-seconds
     このオプションは、traceモードおよびcontinueモードで実行ステップの間
     を何秒待つか指定します。デフォルトは1秒です。


File: elisp,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

17.2.4 Jumping
--------------

このセクションで説明するコマンドは、指定された場所に達するまで実行を続け
ます。‘i’を除くすべてのコマンドは、ストップ場所を確立するために一時的な
breakpointを作成してから、goモードにスイッチします。意図されたストップポ
イントの前にある他のストップポイントに達した場合も、実行はストップします
。breakpointの詳細は、*note Breakpoints::を参照してください。

   これらのコマンドは、非ローカルexitの場合はプログラムのストップを期待
する一時的なbreakpointをバイパスできるので、期待どおり機能しないかもしれ
ません。

‘h’
     ポイントがある場所の近くのストップポイントへ実行を進める
     (‘edebug-goto-here’)。

‘f’
     プログラムの式を1つ分実行する(‘edebug-forward-sexp’)。

‘o’
     sexpを含む終端までプログラムを実行する(‘edebug-step-out’)。

‘i’
     ポイントの後のフォームから呼び出された関数またはマクロにステップイ
     ンする(‘edebug-step-in’)。

   ‘h’コマンドは一時的なbreakpointを使用して、ポイントのカレント位置、ま
たはその後のストップポイントまで処理を進めます。

   ‘f’コマンドは式を1つ飛び越してプログラムを実家します。より正確には、
‘forward-sexp’により到達できる位置に一時的なbreakpointをセットしてから
goモードで実行するので、プログラムはそのbreakpointでストップすることにな
ります。

   プレフィクス引数Nとともに使用した場合は、ポイントからN個の
sexp(s-expression: S式)を超えた場所に一時的なbreakpointをセットします。
ポイントを含むリストがNより少ない要素で終わるような場合は、ストップ箇所
はポイントが含まれる式の後になります。

   ‘forward-sexp’が見つける位置と、プログラムを実際にストップさせたい位
置なのかチェックしなければなりません。たとえば‘cond’内では、これは正しく
ないかもしれません。

   ‘f’コマンドは柔軟性を与えるために、‘forward-sexp’をストップポイントで
はなく、ポイント位置から開始します。_カレントのストップポイント_から1つ
の式を実行したい場合は、まずそこにポイントを移動するために
‘w’(‘edebug-where’)をタイプして、それから‘f’をタイプしてください。

   ‘o’コマンドは、式の“外側”で実行を継続します。これは、ポイントを含む式
の最後に一時的なbreakpointを配します。ポイントを含むsexpが関数定義の場合
、‘o’はその定義内の最後のsexpの直前まで実行を継続します。もし定義内の最
後のsexpの直前にポイントがある場合は、その関数からリターンしてからストッ
プします。他の言い方をすると、このコマンドは最後のsexpの後にポイントがな
い場合は、カレントで実行中の関数からexitしません。

   ‘i’コマンドは、ポイントの後のリストフォームに呼び出された関数、または
マクロにステップインします。そのフォームは、評価されようとしているもの
1つである必要はないことに注意してください。しかし、そのフォームが評価さ
れようとしている関数呼び出しの場合は、引数が何も評価されないうちにこのコ
マンドを使用しないと、遅すぎることを覚えておいてください。

   ‘i’コマンドは、ステップインしようとしている関数またはマクロがまだイン
ストルメントされていない場合は、それらをインストルメントします。これは便
利かもしれませんが、それらを明示的に非インストルメントしない場合、その関
数またはマクロはインストルメントされたままになることを覚えておいてくださ
い。


File: elisp,  Node: Edebug Misc,  Next: Breaks,  Prev: Jumping,  Up: Edebug

17.2.5 Miscellaneous Edebug Commands
------------------------------------

ここでは、その他のEdebugコマンドを説明します。

‘?’
     Edebugのヘルプメッセージを表示する(‘edebug-help’)。

‘C-]’
     1レベルを中断して以前のコマンドレベルへ戻る
     (‘abort-recursive-edit’)。

‘q’
     エディターのトップレベルのコマンドループにリターンする
     (‘top-level’)。これは、すべてのレベルのEdebugアクティビティを含む、
     すべての再帰編集レベルをexitする。しかし、フォーム
     ‘unwind-protect’または‘condition-case’で保護されたインストルメント
     済みのコードはデバッグを再開するかもしれない。

‘Q’
     ‘q’と同様だが、保護されたコードでもストップしない
     (‘edebug-top-level-nonstop’)。

‘r’
     エコーエリアに、もっとも最近の既知のコマンドを再表示する
     (‘edebug-previous-result’)。

‘d’
     backtraceを表示するが、明確であるようにEdebug自身の関数は除外される
     (‘edebug-backtrace’)。

     Edebugのbacktraceバッファーでは、標準デバッガ内のようにバッガコマン
     ドは使用できない。

     実行を継続したとき、backtraceバッファーは自動的にkillされる。

   Edebugから再帰的にEdebugをアクティブにするコマンドを呼び出すことがで
きます。Edebugがアクティブなときは常に、‘q’によトップレベルの終了、また
は‘C-]’による再帰編集1レベルの中断ができます。‘d’により、すべての未解決
な評価のbacktraceを表示できます。


File: elisp,  Node: Breaks,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

17.2.6 Breaks
-------------

Edebugのstepモードは、次のストップポイントに達したときに、実行をストップ
します。一度開始されたEdebugの実行をストップするには、他に3つの方法があ
ります。それはbreakpoint、グローバルbreak条件、およびソースbreakpointで
す。

* Menu:

* Breakpoints::              ストップポイントのbreakpoint。
* Global Break Condition::   イベントによるbreak。
* Source Breakpoints::       ソースコードに埋め込まれたbreakpoint。


File: elisp,  Node: Breakpoints,  Next: Global Break Condition,  Up: Breaks

17.2.6.1 Edebug Breakpoints
...........................

Edebugを使用しているときは、テスト中のプログラム内に“breakpoint”を指定で
きます。breakpointとは、実行がストップされる場所のことです。*note Using
Edebug::で定義されている任意のストップポイントに、breakpointをセットでき
ます。breakpointをセットおよび解除において影響を受けるストップポイントは
、ソースコードバッファー内でポイント位置、またはポイント位置の後の最初の
ストップポイントです。以下はEdebugのbreakpoint用のコマンドです:

‘b’
     ポイント位置、またはポイント位置の後のストップポイントに、
     breakpointをセットする(‘edebug-set-breakpoint’)。プレフィクス引数を
     使用した場合、それは一時的なbreakpointになり、プログラムが最初にそ
     こで停止したとき解除される。

‘u’
     (もしあれば)ポイント位置、またはポイント位置の後のストップポイント
     にあるbreakpointを解除(unset)する(‘edebug-unset-breakpoint’)。

‘x CONDITION <RET>’
     CONDITIONを評価して非‘nil’値になる場合だけプログラムをストップする
     、条件付きbreakpointをセットする
     (‘edebug-set-conditional-breakpoint’)。プレフィクス引数を指定した場
     合は、一時的なbreakpointになる。

‘B’
     カレント定義内の、次のbreakpointにポイントを移動する
     (‘edebug-next-breakpoint’)。

   Edebug内では、‘b’でbreakpointをセットして、‘u’でそれを解除できます。
最初に望ましいストップポイントにポイントを移動してから、そこに
breakpointをセットまたは解除するために‘b’または‘u’をタイプします
breakpointがない場所でbreakpointを解除しても、影響はありません。

   ある定義を再評価、または再インストルメントすると、以前のbreakpointは
すべて削除されます。

   “条件付きbreakpoint(conditional breakpoint)”は、プログラムがそこに達
するたびに条件をテストします。条件を評価した結果エラーが発生した場合、エ
ラーは無視され結果は‘nil’になります。条件付きbreakpointをセットするには
‘x’を使用して、ミニバッファーで条件式を指定します。以前にセットされた条
件付きbreakpointがあるストップポイントに条件付きbreakpointをセットすると
、以前の条件式がミニバッファーに配されるので、それを編集できます。

   プレフィクス引数を指定してbreakpointをセットするコマンドを使用するこ
とにより、“一時的”な条件付きbreakpoint、および無条件のbreakpointを作成で
きます。一時的なbreakpointによりプログラムがストップしたとき、その
breakpointは自動的に解除されます。

   Go-nonstopモードを除き、Edebugは常にbreakpointでストップ、または
pauseします。Go-nonstopモードでは、breakpointは完全に無視されます。

   breakpointがどこにあるか探すには、‘B’コマンドを使用します。このコマン
ドは同じ関数内から、ポイント以降にある次のbreakpoint(ポイント以降に
breakpointが存在しない場合は最初のbreakpoint)にポイントを移動します。こ
のコマンドは実行を継続せず、単にバッファー内のポイントを移動します。


File: elisp,  Node: Global Break Condition,  Next: Source Breakpoints,  Prev: Breakpoints,  Up: Breaks

17.2.6.2 Global Break Condition
...............................

“グローバルbreak条件(global break condition)”は指定された条件が満たされ
たとき、それがどこで発生したかによらず、実行をストップします。Edebugは、
すべてのストップポイントでグローバルbreak条件を評価します。これが非
‘nil’値に評価された場合は、あたかもそのストップポイントにbreakpointがあ
ったかのように、実行をストップまたはpauseします(実行モードによる)。条件
の評価でエラーを取得した場合は、実行をストップしません。

   条件式は‘edebug-global-break-condition’に格納されます。Edebugがアクテ
ィブなときにソースバッファーから‘X’コマンドを使用するか、Edebugがロード
されている間は任意のバッファーから任意のタイミングで‘C-x X
X’(‘edebug-set-global-break-condition’)を使用することにより新たな式を指
定できます。

   グローバルbreak条件は、コード内のどこでイベントが発生したかを見つける
もっともシンプルな方法ですが、コードの実行は遅くなります。そのため、使用
しないときは条件を‘nil’にリセットするべきです。


File: elisp,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breaks

17.2.6.3 Source Breakpoints
...........................

定義内のすべてのbreakpointは、それをインストルメントするたびに失われます
。breakpointが失われないようにしたい場合は、ソースコード内で単に関数
‘edebug’を呼び出す“ソースbreakpoint(source breakpoint)”を記述できます。
もちろん、そのような呼び出しを条件付きすることにもできます。たとえば
‘fac’関数内に以下のような行を1行目に挿入して、引数が0になったときストッ
プさせることができます:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   ‘fac’の定義がインストルメントされて呼び出されたとき、‘edebug’呼び出し
はbreakpointとして振る舞います。実行モードに応じて、Edebugはそこでストッ
プまたはpauseします。

   ‘edebug’が呼び出されたときにインストルメント済みのコードが実行されて
いなければ、この関数は‘debug’を呼び出します。


File: elisp,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breaks,  Up: Edebug

17.2.7 Trapping Errors
----------------------

エラーがシグナルされて、それが‘condition-case’でハンドルされていないとき
、Emacsは通常エラーメッセージを表示します。Edebugがアクティブでインスト
ルメント済みのコードを実行中は、ハンドルされていないエラーには通常
Edebugが対応します。オプション‘edebug-on-error’および‘edebug-on-quit’で
、これをカスタマイズできます。*note Edebug Options::を参照してください。

   Edebugがエラーに対応するときは、エラー発生箇所の前にある最後のストッ
プポイントを表示します。この場所はインストルメントされていない関数の呼び
出しで、その関数内で実際にエラーが発生したのかもしれません。バインドされ
ていない変数に関するエラーの場合は、最後の既知のストップポイントは、その
不正な変数参照から遠く離れた場所かもしれません。そのような場合は、完全な
backtraceを表示したいと思うでしょう(*note Edebug Misc::を参照)。

   Edebugがアクティブの間に‘debug-on-error’、または‘debug-on-quit’を変更
した場合、それらの変更はEdebugが非アクティブになったとき失われます。さら
に、Edebugの再帰編集の間、これらの変数はEdebugの外部でもっていた値にバイ
ンドされます。


File: elisp,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

17.2.8 Edebug Views
-------------------

これらのEdebugコマンドは、Edebugにエントリーする前のバッファーの外観と、
ウィンドウの状態を調べるコマンドです。外部のウィンドウ構成は、ウィンドウ
のコレクションとその内容であり、これらは実際にEdebugの外部にあります。

‘v’
     外部のウィンドウ構成ビューに切り替える(‘edebug-view-outside’)。
     Edebugにリターンするには、‘C-x X w’をタイプする。

‘p’
     一時的に外部のカレントバッファーを表示し、ポイントもその外部の位置
     になる(‘edebug-bounce-point’)。Edebugにリターンする前に、1秒pauseす
     る。プレフィクス引数Nを指定すると、かわりにN秒pauseする。

‘w’
     ソースコードバッファー内のカレントストップポイントにポイントを戻す
     (‘edebug-where’)。

     このコマンドを同じバッファーを表示する異なるウィンドウで使用した場
     合には、そのウィンドウは将来カレント定義を表示するために代用される
     。

‘W’
     Edebugが外部のウィンドウ構成を保存、およびリストアするかどうかを切
     り替える(‘edebug-toggle-save-windows’)。

     プレフィクス引数を指定すると、‘W’は選択されたウィンドウの保存とリス
     トアだけを切り替える。ソースコードバッファーを表示していないウィン
     ドウを指定するには、グローバルキーマップから‘C-x X W’を使用しなけれ
     ばならない。

   ‘v’、または単に‘p’でカレントバッファーにポイントを反跳させれば、たと
え通常は表示されないウィンドウでも、外部のウィンドウ構成を調べることがで
きます。

   ポイントを移動した後に、ストップポイントに戻りたいときがあるかもしれ
ません。これは、ソースコードバッファーから‘w’で行うことができます。どの
バッファーにいても、‘C-x X w’を使用すれば、ソースコードバッファー内のス
トップポイントに戻ることができます。

   保存を_オフ_にするために‘W’を使用するたびに、Edebugは外部のウィンドウ
構成を忘れます。そのため、たとえ保存を_オン_に戻しても、(プログラムを実
行することにより)次にEdebugをexitしたとき、カレントウィンドウ構成は変更
されないまま残ります。しかし、十分な数のウィンドウをオープンしていない場
合は、‘*edebug*’と‘*edebug-trace*’の再表示が、あなたが見たいバッファーと
競合するかもしれません。


File: elisp,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

17.2.9 Evaluation
-----------------

Edebug内では、まるでEdebugが実行されていないかのように、式を評価できます
。式の評価とプリントに際して、Edebugが不可視になるよう試みます。。副作用
をもつ式の評価は、Edebugが明示的に保存とリストアを行うデータへの変更を除
き、期待したとおり機能するでしょう。このプロセスの詳細は、*note The
Outside Context::を参照してください。

‘e EXP <RET>’
     Edebugのコンテキスト外で、式EXPを評価する
     (‘edebug-eval-expression’)。つまり、Edebugはその式への干渉を最小限
     にしようと努める。

‘M-: EXP <RET>’
     Edebug自身のコンテキスト内で、式EXPを評価する(‘eval-expression’)。

‘C-x C-e’
     Edebugのコンテキスト外で、ポイントの前の式を評価する
     (‘edebug-eval-last-sexp’)。

   Edebugは、‘cl.el’内の構文(‘lexical-let’、‘macrolet’、
‘symbol-macrolet’)により作成された、レキシカル(lexical)にバインドされた
シンボルへの参照を含む式の評価をサポートします。


File: elisp,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

17.2.10 Evaluation List Buffer
------------------------------

式をインタラクティブに評価するために、‘*edebug*’と呼ばれる“評価リストバ
ッファー(evaluation list buffer)”を使用できます。Edebugがディスプレイを
更新するたびに自動的に評価される、式の“評価リスト(evaluation list)”もセ
ットアップできます。

‘E’
     評価リストバッファー‘*edebug*’に切り替える
     (‘edebug-visit-eval-list’)。

   ‘*edebug*’バッファーでは、以下の特別なコマンドと同様に、Lisp
Interactionモード(*note (emacs)Lisp Interaction::)のコマンドも使用できま
す。

‘C-j’
     ポイントの前の式をコンテキスト外で評価して、その値をバッファーに挿
     入する(‘edebug-eval-print-last-sexp’)。

‘C-x C-e’
     Edebugのコンテキスト外で、ポイントの前の式を評価する
     (‘edebug-eval-last-sexp’)。

‘C-c C-u’
     バッファー内のコンテンツから、新たに評価リストを構築する
     (‘edebug-update-eval-list’)。

‘C-c C-d’
     ポイントのある評価リストグループを削除する
     (‘edebug-delete-eval-item’)。

‘C-c C-w’
     ソースコードバッファーに切り替えてカレントストップポイントに戻る
     (‘edebug-where’)。

   評価リストウィンドウ内では、‘*scratch*’にいるときと同様に、‘C-j’や
‘C-x C-e’で式を評価できますが、それらはEdebugのコンテキスト外で評価され
ます。

   インタラクティブに入力した式(とその結果)は、実行を継続すると失われま
す。しかし、実行がストップされるたびに評価されるように、式から構成される
“評価リスト”をセットアップできます。

   これを行なうには、評価リストバッファー内で1つ以上の“評価リストグルー
プ(evaluation list group)”を記述します。評価リストグループは、1つ以上の
Lisp式から構成されます。グループはコメント行で区切られます。

   コマンド‘C-c C-u’(‘edebug-update-eval-list’)は、バッファーをスキャン
して各グループの最初の式を使用して、評価リストを再構築します。(これはグ
ループの2つ目の式は以前に計算、表示されている値だという発想からです。)

   Edebugにエントリーするたびに、評価リストの各式(および式の後に式のカレ
ント値)をバッファーに挿入して再表示します。これはコメント行も挿入するた
め、各式はそのグループの一員となります。したがって、バッファーのテキスト
を変更せずに‘C-c C-u’とタイプした場合、評価リストは実際には変更されませ
ん。

   評価リストからの評価の間にエラーが発生した場合、それが式の結果である
かのようにエラーメッセージが文字列で表示されます。したがって、カレントで
無効な変数を使用する式により、デバッグが中断されることはありません。

   以下は、いくつかの式を評価リストウィンドウに追加したとき、どのように
見えるかの例です:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   グループを削除するには、グループ内にポイントを移動して‘C-c C-d’をタイ
プするか、単にグループのテキストを削除して‘C-c C-u’で評価リストを更新し
ます。評価リストに新たな式を追加するには、適切な箇所にその式を挿入し、新
たなコメント行を挿入してから‘C-c C-u’をタイプします。コメント行にダッシ
ュを挿入する必要はありません — 内容は関係ないのです。

   ‘*edebug*’を選択した後に、‘C-c C-w’でソースコードバッファーにリターン
できます。‘*edebug*’は実行を継続したときkillされ、次回必要なとき再作成さ
れます。


File: elisp,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

17.2.11 Printing in Edebug
--------------------------

プログラム内の式が循環リスト構造(circular list structure)を含む値を生成
する場合は、Edebugがそれをプリントしようとしたときエラーとなるかもしれま
せん。

   循環構造への対処の1つに、‘print-length’および‘print-level’にプリント
の切り詰めをセットする方法があります。Edebugは、変数
‘edebug-print-length’および‘edebug-print-level’の値(非‘nil’値をもつ場合
)を、これらの変数にバインドします。*note Output Variables::を参照してく
ださい。

 -- User Option: edebug-print-length
     非‘nil’の場合は、結果をプリントするときEdebugは‘print-length’をこの
     値にバインドする。デフォルト値は‘50’。

 -- User Option: edebug-print-level
     非‘nil’の場合は、結果をプリントするときEdebugは‘print-level’をこの
     値にバインドする。デフォルト値は‘50’。

   ‘print-circle’を非‘nil’値にバインドして、循環構造や要素を共有する構造
を、より参考になる情報をプリントすることもできます。

   以下は循環構造を作成するコードの例です:

     (setq a '(x y))
     (setcar a a)

カスタムプリントはこれを、‘Result: #1=(#1# y)’のようにプリントします。
‘#1=’という表記はその後の構造をラベル‘1’とラベル付けし、‘#1#’表記はその
前にラベル付けされた構造を参照しています。この表記は、リストやベクターの
任意の共有要素に使用されます。

 -- User Option: edebug-print-circle
     非‘nil’の場合は、結果をプリントするときEdebugは‘print-circle’をこの
     値にバインドする。デフォルト値は‘t’。

   他にプログラムもカスタムプリントを使用できます。詳細は
‘cust-print.el’を参照してください。


File: elisp,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

17.2.12 Trace Buffer
--------------------

Edebugは実行トレースを‘*edebug-trace*’という名前のバッファーに格納して記
録できます。実行トレースとは関数呼び出しよリターンのログのことで、関数名
と引数、および値が確認できます。トレースレコードを有効にするには、
‘edebug-trace’を非‘nil’値にセットしてください。

   トレースバッファーの作成は、実行モードのトレースの使用(*note Edebug
Execution Modes::を参照)と同じではありません。

   トレースレコードが有効なときは、関数へのエントリーとexitのたびに、ト
レースバッファーに行が追加されます。関数エントリーレコードは‘::::{’、お
よび関数名と引数の値により構成されます。関数exitレコードは‘::::}’、およ
び関数名と関数の結果により構成されます。

   ‘:’の数は、関数エントリーの再帰レベルを表します。トレースバッファーで
は、関数呼び出しの開始と終了の検索に‘{’と‘}’を使用できます。

   関数‘edebug-print-trace-before’および‘edebug-print-trace-after’を再定
義することにより、関数エントリーと関数exitのトレースレコードをカスタマイ
ズできます。

 -- Macro: edebug-tracing string body...
     このマクロはBODYフォーム実行活動にたいする、追加のトレース情報をリ
     クエストする。引数STRINGは、トレースバッファーに配す‘{’または‘}’の
     後のテキストを指定する。すべての引数は評価され、‘edebug-tracing’は
     BODY内の最後のフォームの値をリターンする。

 -- Function: edebug-trace format-string &rest format-args
     この関数は、トレースバッファーにテキストを挿入する。テキストは、
     ‘(apply 'format FORMAT-STRING FORMAT-ARGS)’により計算される。エント
     リー間の区切りとして改行も付け加える。

   ‘edebug-tracing’および‘edebug-trace’は、たとえEdebugが非アクティブで
も、呼び出されたときは常にトレースバッファーに行を挿入します。トレースバ
ッファーへのテキストの追加により、挿入された最後の行が見えるようにウィン
ドウもスクロールします。


File: elisp,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

17.2.13 Coverage Testing
------------------------

Edebugは基本的なカバレッジテスト(coverage test)と実行頻度(execution
frequency)の表示を提供します。

   カバレッジテストは、すべての式の結果と以前の結果を比較することにより
機能します。プログラム内のフォームがそれぞれ、カレントEmacsセッション内
でカバレッジテストを開始して以降に、2つの異なる値をリターンした場合、そ
れらのフォームは“カバー”されたと判断します。したがって、プログラムにカバ
レッジテストを行なうには、そのプログラムをさまざまなコンディション下で実
行して、プログラムが正しく振る舞うかに注目します。異なるコンディション下
で十分にテストして、すべてのフォームが異なる2つの値をリターンしたとき、
Edebugはそのことを告げるでしょう。

   カバレッジテストにより実行速度が低下するので、
‘edebug-test-coverage’が非‘nil’のときだけカバレッジテストが行なわれます
。頻度計数(frequency count)は、たとえ実行モードがGo-nonstopでも、カバレ
ッジテストが有効か無効かに関わらず、すべての式にたいして処理されます。

   定義にたいするカバレッジ情報と頻度数の両方を表示するには、‘C-x X
=’(‘edebug-display-freq-count’)を使用する。単に
‘=’(‘edebug-temp-display-freq-count’)とすると、他のキーをタイプするまで
の間だけ、同様な情報を一時的に表示する。

 -- Command: edebug-display-freq-count
     このコマンドは、カレント定義の各行の頻度数を表示する。

     このコマンドは、コードの各行の下にコメント行として頻度数を挿入する
     。1回の‘undo’コマンドで、すべての挿入をアンドゥできる。頻度数は式の
     前の‘(’、または式の後の‘)’、または変数の最後の文字の下に表示される
     。表示をシンプルにするために、同一行にたいして式の以前頻度数と頻度
     数が同じ場合は表示しない。

     ある式にたいする頻度数の後に文字‘=’がある場合、それはその式が評価さ
     れるたびに毎回同じ値をリターンしていることを表す。他の言い方をする
     と、カバレッジテストの目的からは、その式はまだ“カバー”されていない
     ということである。

     ある定義にたいして頻度数とカバレッジデータを明確にするには、単に
     ‘eval-defun’で再インストルメントすればよい。

   たとえば、ソースのbreakpointで‘(fac 5)’を評価した後、
‘edebug-test-coverage’を‘t’にセットすると、breakpointに達したときの頻度
データは以下のようになります:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      = =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   コメント行は、‘fac’が6回呼び出されたことを表しています。最初の‘if’命
令は毎回同じ結果を5回リターンしています。同じ結果という意味では、2つ目の
‘if’の条件にも当てはまります。‘fac’の再帰呼び出しは、結局リターンしませ
ん。


File: elisp,  Node: The Outside Context,  Next: Edebug and Macros,  Prev: Coverage Testing,  Up: Edebug

17.2.14 The Outside Context
---------------------------

Edebugはデバッグ中のプログラムにたいして透過的であろうと努めますが、完全
には達成されません。Edebugは、‘e’や評価リストバッファーで式を評価すると
きも、一時的に外部のコンテキストをリストアして、透明化を試みます。このセ
クションではEdebugがリストアするコンテキストと、Edebugがいかにして完全に
透過的になるのに失敗するかを正確に説明します。

* Menu:

* Checking Whether to Stop::  何を行うかをEdebugが決定するタイミング。
* Edebug Display Update::    Edebugがディスプレイを更新するタイミング。
* Edebug Recursive Edit::    Edebugが実行をストップするタイミング。


File: elisp,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

17.2.14.1 Checking Whether to Stop
..................................

Edebugにエンターするときは常に特定のデータの保存とリストアを行なう必要が
あり、それはトレース情報を作成するか、あるいはプログラムを停止するかを決
定する前に行なう必要があります。

   • ‘max-lisp-eval-depth’および‘max-specpdl-size’は、Edebugがスタック与
     える影響の低減効果を高める。しかしそれでも、Edebug使用時にスタック
     空間を使い切ってしまうことはあり得る。

   • キーボードマクロの実行状態は保存およびリストアされる。Edebugがアク
     ティブの間、‘edebug-continue-kbd-macro’が‘nil’の場合は、
     ‘executing-kbd-macro’が‘nil’にバインドされる。


File: elisp,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

17.2.14.2 Edebug Display Update
...............................

(たとえばtraceモードなどで)Edebugが何かを表示する必要があるときは、
Edebugの“外部”からカレントウィンドウ構成(*note Window Configurations::を
参照)を保存します。Edebugをexitするときに、以前のウィンドウ構成がリスト
アされます。

   Emacsは、pause時だけ再表示を行います。通常は実行を継続したときに、そ
のプログラムはbreakpointまたはステップ実行後にEdebugに再エンターし、その
間にpauseや入力の読み取りはありません。そのような場合、Emacsが“外部”の構
成を再表示する機会は決してありません。結果として、ユーザーが目にするウィ
ンドウ構成は、前回Edebugが中断なしでアクティブだったときのウィンドウ構成
と同じになります。

   何かを表示するためにEdebugにエントリーすることにより、(たとえこれらの
うちのいくつかは、エラーやquitがシグナルされたときは、故意にリストアしな
いデータだとしても)以下のデータも保存およびリストアされます。

   • どれがカレントバッファーか、そしてカレントバッファー内のポイントと
     マークの位置が、保存およびリストアされる。

   • ‘edebug-save-windows’が非‘nil’の場合は、外部のウィンドウ構成が保存
     およびリストアされる(*note Edebug Options::を参照)。

     エラーやquitではウィンドウ構成はリストアされないが、
     ‘save-excursion’がアクティブな場合は、たとえエラーやquitのとき外部
     の選択されたウィンドウが再選択_される_。‘edebug-save-windows’の値が
     リストの場合は、それにリストされたウィンドウだけが保存およびリスト
     アされる。

     しかし、ソースコードバッファーのウィンドウの開始位置と水平スクロー
     ルはリストアされないので、表示はEdebug内で整合性が保たれたままとな
     る。

   • ‘edebug-save-displayed-buffer-points’が非‘nil’の場合、表示されてい
     るそれぞれのバッファー内のポイント値は、保存およびリストアされる。

   • 変数‘overlay-arrow-position’と‘overlay-arrow-string’は保存およびリ
     ストアされるので、同じバッファー内の他の場所の再帰編集から、安全に
     Edebugを呼び出せる。

   • ‘cursor-in-echo-area’は‘nil’にローカルにバインドされるので、カーソ
     ルはそのウィンドウ内に現れる。


File: elisp,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

17.2.14.3 Edebug Recursive Edit
...............................

Edebugにエンターしてユーザーのコマンドが実際に読み取られるとき、Edebugは
以下の追加データを保存(そして後でリストア)します:

   • カレントマッチデータ。*note Match Data::を参照。

   • 変数‘last-command’、‘this-command’、‘last-command-event’、
     ‘last-input-event’、‘last-event-frame’、‘last-nonmenu-event’、
     ‘track-mouse’。Edebug内のコマンドは、Edebug外部のこれらの変数に影響
     をあたえない。

     Edebug内でのコマンド実行は、‘this-command-keys’によりリターンされる
     キーシーケンスを変更でき、Lispからそのキーシーケンスをリセットする
     方法はない。

     Edebugは‘unread-command-events’の値の保存およびリストアができない。
     この変数が重要な値をもつときにEdebugにエンターすると、デバッグ中の
     プログラムの実行に干渉する可能性がある。

   • Edebug内で実行された複雑なコマンドは、変数‘command-history’に追加さ
     れる。これが稀に実行に影響を与える。

   • Edebug内では、再帰深さがEdebug外部の再帰深さより1つ深くなる。これは
     自動的に更新される評価リストウィンドウでは異なる。

   • ‘standard-output’と‘standard-input’は‘recursive-edit’により‘nil’に
     バインドされるが、Edebugは評価の間それらを一時的にリストアする。

   • キーボードマクロ定義の状態は、保存およびリストアされる。Edebugがア
     クティブの間、‘defining-kbd-macro’は‘edebug-continue-kbd-macro’にバ
     インドされる。


File: elisp,  Node: Edebug and Macros,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

17.2.15 Edebug and Macros
-------------------------

Edebugが正しくマクロを呼び出す式をインストルメントするには、いくつかの特
定な配慮が必要になります。このサブセクションでは、その詳細を説明します。

* Menu:

* Instrumenting Macro Calls::  基本的な問題点。
* Specification List::       式の複雑なパターンを指定する方法。
* Backtracking::             マッチに失敗したときEdebugが行なうこと。
* Specification Examples::   Edebug仕様を理解するために。


File: elisp,  Node: Instrumenting Macro Calls,  Next: Specification List,  Up: Edebug and Macros

17.2.15.1 Instrumenting Macro Calls
...................................

EdebugがLispマクロを呼び出す式をインストルメントするときは、正しくインス
トルメントを行なうために、そのマクロに関して追加の情報が必要になります。
これは、マクロ呼び出しのどの部分式(subexpression)が評価されるフォームな
のか推測する方法がないからです。(評価はマクロのbodyで明示的に発生するか
もしれないし、展開結果が評価されるとき、または任意のタイミングで行われる
かもしれません。)

   したがって、Edebugが処理するかもしれないすべてのマクロにたいして、そ
のマクロの呼び出しフォーマットを説明するための、Edebug仕様(Edebug
specification)を定義しなければなりません。これを行なうには、マクロ定義に
‘debug’宣言を追加します。以下はマクロ例‘for’(*note Argument
Evaluation::を参照)にたいする簡単な仕様の例です。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (declare (debug (symbolp "from" form "to" form "do" &rest form)))
       ...)

   このEdebug仕様は、マクロ呼び出しのどの部分が評価されるフォームなのか
を示しています。単純なマクロにたいするEdebug仕様は、そのマクロ定義の正式
な引数リストに非常に類似している場合がありますが、Edebug仕様はマクロ引数
に比べより汎的です。‘declare’フォームの詳細は、*note Defining Macros::を
参照してください。

   コードをインストルメントするときEdebugに仕様が確実に解るよう注意して
ください。マクロ定義を含む他のファイルを要求するために
‘eval-when-compile’を使用するファイルから関数をインストルメントする場合
は、そのファイルを明示的にロードする必要があるかもしれません。

   ‘def-edebug-spec’によりマクロ定義から個々のマクロにたいしてEdebug仕様
を定義することもできます。Lispで記述されたマクロ定義にたいしては
‘debug’宣言を追加するほうが好ましく、その方が便利でもありますが、
‘def-edebug-spec’ではCで実装されたスペシャルフォームにたいしてEdebug仕様
を定義することが可能になります。

 -- Macro: def-edebug-spec macro specification
     マクロMACRO呼び出しのどの式が評価される式かを指定する。
     SPECIFICATIONはEdebug仕様である。どちらの引数も評価されない。

     引数MACROは単なるマクロ名ではない、任意の実シンボルを指定できる。

   以下はSPECIFICATIONに指定できるシンボルと、引数を処理する方法のテーブ
ルです。

‘t’
     すべての引数は評価のためにインストルメントされる。

‘0’
     引数はインストルメントされない。

シンボル
     そのシンボルは、かわりに使用されるEdebug仕様をもたなければならない
     。このインダイレクションは、他の種類の仕様が見つかるまで繰り返され
     る。これにより、他のマクロの仕様を継承できる。

リスト
     リストの要素はフォーム呼び出しの引数の型を記述する。仕様リストに指
     定できる要素については、以降のセクションを参照。

   マクロがEdebug仕様をもたない場合は、‘debug’宣言および
‘def-edebug-spec’呼び出しのどちらを通じても、変数
‘edebug-eval-macro-args’が効果を発揮する。

 -- User Option: edebug-eval-macro-args
     これは、Edebugが明示的なEdebug仕様をもたないマクロ引数を扱う方法を
     制御する。‘nil’(デフォルト)の場合、引数は評価のためにインストルメン
     トされない。それ以外は、すべての引数がインストルメントされる。


File: elisp,  Node: Specification List,  Next: Backtracking,  Prev: Instrumenting Macro Calls,  Up: Edebug and Macros

17.2.15.2 Specification List
............................

あるマクロ呼び出しにおいて、いくつかの引数は評価されるが、それ以外の引数
は評価されないような場合には、Edebug仕様のために“仕様リスト
(specification list)”が要求されます。仕様リスト内のいくつかの要素は1つ以
上の引数にマッチしまづが、それ以外の要素は以降に続くすべての引数の処理を
変更します。後者は“仕様キーワード(specification keywords)”と呼ばれ、
(‘&optional’のように)‘&’で始まるシンボルです。

   仕様リストは、それ自身がリストであるような引数にマッチする部分リスト
(sublist)、またはグループ化に使用されるベクターを含むかもしれません。し
たがって部分式とグループは、仕様リストをレベル階層に細分化します。仕様キ
ーワードは、部分式やグループを含むものの残りに適用されます。

   仕様リストに選択肢や繰り返しが含まれる場合は、実際のマクロの呼び出し
にたいしてマッチさせるためにバックトラックが要求されるかもしれません。詳
細は、*note Backtracking::を参照してください。

   Edebug仕様は、バランスのとれたカッコで括られた部分式へのマッチ、フォ
ームの再帰処理、インダイレクト仕様を通じた再帰などの、正規表現によるマッ
チングと、コンテキストに依存しない文法構成を提供します。

   以下は仕様リストに使用できる要素と、その意味についてのテーブルです(使
用例は*note Specification Examples::を参照):

‘sexp’
     評価れない単一のLispオブジェクト。インストルメントされない。

‘form’
     評価される単一のLispオブジェクト。インストルメントされる。

‘place’
     汎変数(generalized variable)。*note Generalized Variables::を参照。

‘body’
     ‘&rest form’の省略形。以下の‘&rest’を参照。

‘function-form’
     関数フォーム。クォートされた関数シンボル、クォートされたラムダ式、
     または(関数シンボルかラムダ式に評価される)フォームのうちのどれか。
     これはラムダ式のbodyをいずれかの方法でインストルメントするため、
     ‘function’よりも‘quote’でクォートされたラムダ式の引数にたいし有用。

‘lambda-expr’
     クォートされないラムダ式。

‘&optional’
     仕様リスト内の後続の要素はオプション。マッチしない要素が出現すると
     、Edebugはこのレベルのマッチングを停止する。

     後続が非オプションの要素であるような数個の要素をオプションにするだ
     けなら、‘[&optional SPECS...]’を使用する。複数の要素すべてのマッチ
     、または非マッチを指定するには、‘&optional [SPECS...]’を使用する。
     ‘defun’の例を参照。

‘&rest’
     仕様リスト内の後続のすべての要素は、0回以上繰り返される。しかし、最
     後の繰り返しでは、仕様リスト内のすべての要素にたいするマッチングの
     前に式が終了しても問題はない。

     数個の要素を繰り返すには、‘[&rest SPECS...]’を使用する。各繰り返し
     においいてすべてマッチしなければならない複数要素を指定するには、
     ‘&rest [SPECS...]’を使用する。

‘&or’
     仕様リスト内の後続の各要素は選択肢。選択肢の1つがマッチしなければな
     らず、マッチしない場合‘&or’仕様は失敗する。

     ‘&or’に続く各リスト要素は、単一の選択肢。複数のリスト要素を単一の選
     択肢にグループ化するには、それらを‘[...]’で括る。

‘&not’
     後続の各要素は、‘&or’が使用されたときのように選択肢にマッチするが、
     要素がマッチした場合に失敗する。どれもマッチする要素がない場合は何
     もマッチされないが、‘&not’仕様は成功する。

‘&define’
     フォーム定義にたいする仕様であることを示す。フォーム定義自体はイン
     ストルメントされない(つまりEdebugはフォーム定義の前後でストップしな
     い)が、フォーム内部は通常はインストルメントされるであろう。
     ‘&define’キーワードはリスト仕様の最初の要素であること。

‘nil’
     カレント引数レベルでマッチさせる引数が存在しない場合は成功し、それ
     以外は失敗する。部分リスト仕様とバッククォートの例を参照。

‘gate’
     引数はマッチされないがgateを通じたバックトラックは、このレベルの使
     用の残りをマッチングする間は無効にされる。これは主に、特定の構文エ
     ラーメッセージを一般的にするために使用される。詳細は*note
     Backtracking::、および‘let’の例も参照。

‘OTHER-SYMBOL’
     仕様リスト内のその他の要素は、述語(predicate)かインダイレクト仕様
     (indirect specification)である。

     シンボルがEdebug仕様をもつ場合、“インダイレクト仕様(indirect
     specification)”はシンボル位置に使用されるリスト仕様か、引数を処理す
     るための関数のどちらかである。この仕様はマクロにたいする
     ‘def-edebug-spec’のように定義される。‘defun’の例を参照。

     それ以外の場合、シンボルは述語(predicate)である。述語は引数とともに
     呼び出され、述語が‘nil’をリターンした場合、その仕様は失敗して引数は
     インストルメントされない。

     適切な述語としては‘symbolp’、‘integerp’、‘stringp’、‘vectorp’、
     ‘atom’が含まれる。

‘[ELEMENTS...]’
     要素のベクターは、要素を単一の“グループ仕様(group specification)”に
     グループ化する。このグループ仕様は、ベクター自体に何も行わない。

‘"STRING"’
     引数はSTRINGという名前のシンボルである。この仕様は、SYMBOLの名前が
     STRINGであるクォートされたシンボル‘'SYMBOL’と等価だが、文字列形式の
     ほうが好ましい。

‘(vector ELEMENTS...)’
     引数は、要素が仕様内のELEMENTSにマッチするベクターである。バックク
     ォートの例を参照。

‘(ELEMENTS...)’
     他のリストは“部分リスト仕様(sublist specification)”であり、引数は要
     素が仕様のELEMENTSにマッチするリストでなければならない。

     部分リスト仕様はドットリスト(dotted list)かもしれず、その場合対応す
     るリスト引数はドットリストである。かわりに、ドットリスト仕様の最後
     のCDRが、(グループ化やインダイレクト仕様による)他の部分リスト仕様か
     もしれない(たとえば要素が非ドットリストにマッチする‘(spec . [(more
     specs...)])’))。これはバッククォートの例のような再帰仕様に有用。こ
     のような再帰を終了させるには、上述の‘nil’仕様も参照。

     ‘(specs . nil)’のように記述された部分リスト仕様は‘(specs)’、‘(specs
     . (sublist-elements...))’は‘(specs sublist-elements...)’と等価であ
     ることに注意。

   以下は‘&define’の後だけに出現する追加仕様のリストです。‘defun’の例を
参照してください。

‘name’
     引数(シンボル)は定義フォームの名前。

     定義フォームは名前フィールドをもつ必要はなく、複数の名前フィールド
     をもつかもしれない。

‘:name’
     この構成は引数に実際のマッチは行わない。‘:name’の後の要素はシンボル
     であり、その定義の追加の名前要素として使用される。定義名に一意で静
     的な要素を加えるために、これを使用できる。複数回使用されるかもしれ
     ない。

‘arg’
     引数(シンボル)は定義フォームの引数の名前である。しかし、
     lambda-listキーワード(‘&’で始まるシンボル)は許されない。

‘lambda-list’
     これはラムダリスト(ラムダ式の引数リスト)にマッチする。

‘def-body’
     引数は定義内のコードのbodyである。これは上述の‘body’と似ているが、
     定義のbodyはその定義に関連する情報を照会する別のEdebug呼び出しでイ
     ンストルメントされていなければならない。定義内のより高位レベルのフ
     ォームリストには、‘def-body’を使用する。

‘def-form’
     引数は、定義内のもっとも高位レベルの単一フォームである。これは
     ‘def-body’と似ているが、フォームリストではなく単一フォームのマッチ
     に使用される。特別なケースとして、‘def-form’はフォームが実行される
     ときトレース情報を出力しないことも意味する。‘interactive’の例を参照
     。


File: elisp,  Node: Backtracking,  Next: Specification Examples,  Prev: Specification List,  Up: Edebug and Macros

17.2.15.3 Backtracking in Specifications
........................................

あるポイント位置で仕様がマッチに失敗しても、構文エラーがシグナルされると
は限りません。そのかわり“バックトラック(backtracking)”が開始されます。バ
ックトラックは、すべての選択肢をマッチングするまで行なわれます。最終的に
引数リストのすべての要素は仕様内の要素のいずれかとマッチしなければならず
、仕様内の必須要素は引数のいずれかとマッチしなければなりません。

   構文エラーが検出されてもその時点では報告されず、より高位レベルの選択
肢のマッチングが終わった後、実際のエラー箇所から離れたポイント位置でエラ
ーが報告されるかもしれません。しかしエラー発生時にバックトラックが無効な
ら、エラーは即座に報告されるでしょう。ある状況においては、バックトラック
も自動的に再有効化されることに注意してください。‘&optional’、‘&rest’、
‘&or’により新たな選択肢が設定されたとき、または部分リスト、グループ、イ
ンダイレクト仕様が開始されたときは、バックトラックが自動的に有効になりま
す。バックトラックを有効、または無効にした場合の影響は、現在処理中のレベ
ルの残り要素と、低位レベルに限定されます。

   何らかのフォーム仕様(すなわち‘form’、‘body’、‘def-form’、
‘def-body’)をマッチングする間、バックトラックは無効になっています。これ
らの仕様は任意のフォームにマッチするので、何らかのエラーが発生するとした
らそれは高位レベルではなく、そのフォーム自体の内部でなければなりません。

   バックトラックはクォートされたシンボルや文字列仕様とのマッチに成功し
た後にも無効になります。なぜなら通常これは構成が認識されたことを示すから
です。しかし、同じシンボルで始まる一連の選択肢構成がある場合は、たとえば
‘["foo" &or [first case] [second case] ...]’のように、通常は選択肢の外部
にそのシンボルをファクタリングすることにより、この制約に対処できます。

   ほとんどのニーズは、バックトラックを自動的に無効にする、これら2つの方
法で満足させることができますが、‘gate’仕様を使用して明示的にバックトラッ
クを無効にするほうが便利なときもあります。これは、高位に適用可能な選択肢
が存在しないことが分かっている場合に有用です。‘let’仕様の例を参照してく
ださい。


File: elisp,  Node: Specification Examples,  Prev: Backtracking,  Up: Edebug and Macros

17.2.15.4 Specification Examples
................................

以下で提供する例から学ぶことにより、Edebug仕様の理解が容易になるかもしれ
ません。

   スペシャルフォーム‘let’は、バインディングとbodyのシーケンスをもちます
。各バインディングはそシンボル、またはシンボルとオプションの部分リストで
す。以下の仕様では、部分リストを見つけたらバックトラックを抑止するために
、部分リスト内の‘gate’があることに注目してください。

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebugは‘defun’および関連する引数リスト、‘interactive’仕様にたいして
以下の仕様を使用します。式の引数はその関数bodyの外部で実際に評価されるの
で、interactiveフォームは特別に処理する必要があります。(‘defmacro’にたい
する仕様は‘defun’にたいする仕様と非常に似ていますが、‘declare’命令文が許
されます。)

     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; ドキュメント文字列が与えられた場合はマッチする。
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: ‘def-form’

   以下のバッククォートにたいする仕様は、ドットリストにマッチさせる方法
と、‘nil’を使用して再帰を終了させる方法を説明するための例です。また、ベ
クターのコンポーネントをマッチさせる方法も示しています。(Edebugにより定
義される実際の仕様は少し異なり、ドットリストについては失敗するかもしれな
い非常に深い再帰を引き起こすためサポートしていません。)

     (def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: elisp,  Node: Edebug Options,  Prev: Edebug and Macros,  Up: Edebug

17.2.16 Edebug Options
----------------------

以下のオプションは、Edebugの動作に影響を与えます:

 -- User Option: edebug-setup-hook
     Edebugが使用される前に呼び出される関数。この関数は毎回新たな値をセ
     ットする。Edebugこれらの関数を一度呼び出したら、その後
     ‘edebug-setup-hook’‘nil’にリセットする。使用するパッケージに関係す
     るEdebug仕様をロードするために使用ｄきるが、それはEdebugを使用する
     ときだけである。*note Instrumenting::を参照。

 -- User Option: edebug-all-defs
     これが非‘nil’の場合は‘defun’や‘defmacro’のような定義フォームの普通
     に評価すると、Edebug用にインストルメントされる。これは
     ‘eval-defun’、‘eval-region’、‘eval-buffer’、and
     ‘eval-current-buffer’に適用される。

     このオプションの切り替えには、コマンド‘M-x edebug-all-defs’を使用す
     る。*note Instrumenting::を参照。

 -- User Option: edebug-all-forms
     これが非‘nil’の場合‘eval-defun’、‘eval-region’、‘eval-buffer’、
     ‘eval-current-buffer’は、たとえフォームが何も定義していなくても、す
     べてのフォームをインストルメントする。これはロードとミニバッファー
     内の評価には適用されない。

     このオプションの切り替えには、コマンド‘M-x edebug-all-forms’を使用
     する。*note Instrumenting::を参照。

 -- User Option: edebug-save-windows
     これが非‘nil’の場合、Edebugはウィンドウ構成の保存とリストアを行なう
     。これにはある程度時間がかかるので、ウィンドウ構成に何が起こっても
     プログラムに関係しない場合は、この変数を‘nil’にセットしたほうがよい
     。

     値がリストの場合は、リストされたウィンドウだけが保存およびリストア
     される。

     Edebug内では、この変数をインタラクティブに変更するために‘W’コマンド
     を使用できる。*note Edebug Display Update::を参照。

 -- User Option: edebug-save-displayed-buffer-points
     これが非‘nil’の場合、Edebugは表示されているすべてのバッファー内のポ
     イントを保存およびリストアする。

     選択されていないウィンドウ内に表示されているバッファーのポイントを
     変更するコードをデバッグしている場合は、他のバッファーのポイントを
     保存およびリストアする必要がある。その後にEdebugまたはユーザーがそ
     のウィンドウを選択した場合は、そのバッファー内のポイントは、そのウ
     ィンドウのポイント値に移動される。

     すべてのバッファー内のポイントの保存とリストアは、それぞれのウィン
     ドウを2回選択する必要があり高価な処理のため、必要なときだけ有効にす
     る。*note Edebug Display Update::を参照。

 -- User Option: edebug-initial-mode
     この変数が非‘nil’の場合、Edebugが最初にアクティブになったときの、
     Edebugの最初の実行モードを指定する。指定できる値は‘step’、‘next’、
     ‘go’、‘Go-nonstop’、‘trace’、‘Trace-fast’、‘continue’、
     ‘Continue-fast’。

     デフォルト値は‘step’。*note Edebug Execution Modes::を参照。

 -- User Option: edebug-trace
     これが非‘nil’の場合が、各関数のエントリーとexitをトレースする。トレ
     ース出力は、関数のエントリーとexitを行ごとに、再帰レベルにしたがっ
     て‘*edebug-trace*’という名前のバッファーに表示される。

     *note Trace Buffer::の‘edebug-tracing’も参照のこと。

 -- User Option: edebug-test-coverage
     非‘nil’の場合、Edebugはデバッグされるすべての式のカバレッジをテスト
     する。*note Coverage Testing::を参照。

 -- User Option: edebug-continue-kbd-macro
     非‘nil’の場合は、Edebug外で実行されている任意のキーボードマクロの定
     義または実行を継続する。これはデバッグされないので、慎重に使用する
     こと。*note Edebug Execution Modes::を参照。

 -- User Option: edebug-unwrap-results
     非‘nil’の場合、Edebugは式の結果を表示するときに、その式自体のインス
     トルメント結果の削除を試みる。マクロをデバッグするときは、式の結果
     自体がインストルメントされた式になるということに関連する。実際的な
     例ではないが、サンプル例の関数‘fac’がインストルメントされたとき、そ
     のフォームのマクロを考えてみるとよい。

          (defmacro test () "Edebug example."
            (if (symbol-function 'fac)
                ...))

     ‘test’マクロをインストルメントしてステップ実行すると、デフォルトで
     は‘symbol-function’呼び出しは多数の‘edebug-after’フォームと
     ‘edebug-before’フォームをもつことになり、それにより“実際の”結果の確
     認が難しくなり得る。‘edebug-unwrap-results’が非‘nil’の場合、
     Edebugは結果からこれらのフォームの削除を試みる。

 -- User Option: edebug-on-error
     ‘debug-on-error’の以前が‘nil’の場合、Edebugは‘debug-on-error’をこの
     値にバインドする。*note Trapping Errors::を参照。

 -- User Option: edebug-on-quit
     ‘debug-on-quit’の以前の値が‘nil’の場合、Edebugは‘debug-on-quit’にこ
     の値をバインドする。*note Trapping Errors::を参照。

   Edebugがアクティブな間に‘edebug-on-error’または‘edebug-on-quit’の値を
変更した場合は、_次回_に新たなコマンドを通じてEdebugが呼び出されるまで、
これらの値は使用されない。

 -- User Option: edebug-global-break-condition
     非‘nil’の場合、値はすべてのステップポイントでテストされる式である。
     式の結果が‘nil’の場合は、breakする。エラーは無視される。*note
     Global Break Condition::を参照。


File: elisp,  Node: Syntax Errors,  Next: Test Coverage,  Prev: Edebug,  Up: Debugging

17.3 Debugging Invalid Lisp Syntax
==================================

Lispリーダーは無効な構文(invalid syntax)について報告はしますが、実際の問
題箇所は報告しません。たとえば、ある式を評価中のエラー“End of file
during parsing(パース中にファイル終端に達した)”は、開カッコまたは開角カ
ッコ(open parenthese or open square bracket)が多いことを示しています。
Lispリーダーはこの不一致をファイル終端で検出しましたが、本来閉カッコがあ
るべき箇所を解決することはできません。同様に、“Invalid read syntax:
")"(無効なread構文:)")"”は開カッコの欠落を示していますが、欠落しているカ
ッコが属すべき場所は告げません。ならば、どうやって変更すべき箇所を探せば
よいのでしょうか?

   問題が単なるカッコの不一致でない場合の便利なテクニックは、各defunの先
頭で‘C-M-e’とタイプして、そのdefunの最後と思われる箇所に移動するか確認す
る方法です。もし移動しなければ、問題はそのdefunの内部にあります。

   マッチしないカッコがLispにおいてもっとも一般的な構文エラーなので、こ
れらのケースにたいしてさらにアドバイスすることができます。(Show Parenモ
ードを有効にしてコードにポイントを移動するだけで、カッコの不一致を探しや
すくなるでしょう。)

* Menu:

* Excess Open::              誤った開カッコと閉カッコを探す方法。
* Excess Close::             誤った閉カッコと開カッコを探す方法。


File: elisp,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

17.3.1 Excess Open Parentheses
------------------------------

カッコがマッチしないdefunを探すのが、最初のステップです。過剰な開カッコ
が存在する場合は、ファイルの終端に移動して‘C-u C-M-u’とタイプします。こ
れにより、カッコがマッチしない最初のdefunの先頭に移動するでしょう。

   何が間違っているのか正確に判断するのが次のステップです。これを確実に
行なうには、そのプログラムを詳しく調べる以外に方法はありませんが、カッコ
があるべき箇所を探すのに、既存のインデントが手掛かりになることが多々あり
ます。‘C-M-q’で再インデントして何が移動されるか確認するのが、この手掛か
りを使用するもっとも簡単な方法です。*しかし、行うのはちょっと待ってくだ
さい!* まず続きを読んでからにしましょう。

   これを行なう前に、defunに十分な閉カッコがあるか確認します。十分な閉カ
ッコがない場合、‘C-M-q’がエラーとなるか、そのdefunからファイル終端までの
残りすべてが再インデントされます。その場合はdefunの最後に移動して、そこ
に閉カッコを挿入します。そのdefunのカッコの釣り合いがとれるまでは、
defunの最後に移動するのに‘C-M-e’は使用できません(失敗するでしょう)。

   これでdefunの先頭に移動して‘C-M-q’とタイプすることができます。通常は
、一定のポイントからその関数の最後までのすべての行が、右へとシフトされる
でしょう。これはおそらくそのポイント付近で閉カッコが欠落しているか、不要
な開カッコがあります。(しかし、これを真実と仮定せず、コードを詳しく調べ
てください。) 不一致箇所が見つけたら、元のインデントはおそらく意図された
カッコに適しているはずなので、‘C-_’で‘C-M-q’をアンドゥしてください。

   問題をfixできたと思った後に、再度‘C-M-q’を使用します。実際に元のイン
デントが意図したカッコのネストに適合していて、足りないカッコを追加してい
たら、‘C-M-q’は何も変更しないはずです。


File: elisp,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

17.3.2 Excess Close Parentheses
-------------------------------

過剰な閉カッコへの対処は、まずファイルの先頭に移動してから、カッコのマッ
チしないdefunを探すために‘C-u -1 C-M-u’をタイプします。

   それから、そのdefunの先頭で‘C-M-f’をタイプして、実際にマッチする閉カ
ッコを探します。これにより、そのdefunの終端より幾分手前の箇所に移動する
でしょう。その付近に間違った閉カッコが見つかるでしょう。

   そのポイントに問題が見つからない場合には、そのdefunの先頭で‘C-M-q’を
タイプするのが次のステップです。ある行範囲はおそらく左へシフトするでしょ
う。その場合、欠落している開カッコまたは間違った閉カッコは、おそらくそれ
らの行の1行目の近くにあるでしょう。 (しかし、これを真実と仮定せず、コー
ドを詳しく調べてください。)不一致箇所が見つけたら、元のインデントはおそ
らく意図されたカッコに適しているはずなので、‘C-_’で‘C-M-q’をアンドゥして
ください。

   問題をfixできたと思った後に、再度‘C-M-q’を使用します。実際に元のイン
デントが意図したカッコのネストに適合していて、足りないカッコを追加してい
たら、‘C-M-q’は何も変更しないはずです。


File: elisp,  Node: Test Coverage,  Next: Profiling,  Prev: Syntax Errors,  Up: Debugging

17.4 Test Coverage
==================

‘testcover’ライブラリーをロードして、コマンド‘M-x testcover-start <RET>
FILE <RET>’でコードをインストルメントすることにより、Lispコードのファイ
ルにたいしてカバレッジテストを行なうことができます。コードを1回以上呼び
出すことにより、テストが行なわれます。コマンド‘M-x testcover-mark-all’を
使用すれば、カバレッジが不十分な箇所が色付きでハイライト表示されます。コ
マンド‘M-x testcover-next-mark’は、次のハイライトされた箇所へポイントを
前方に移動します。

   通常、赤くハイライトされた箇所はそのフォームが完全に評価されたことが
一度もないことを示し、茶色でハイライトされた箇所は常に同じ値に評価された
(その結果にたいして少ししかテストされていない)ことを意味します。しかし、
‘error’のように完全に評価するのが不可能なフォームにたいしては、赤いハイ
ライトはスキップされます。‘(setq x 14)’のように、常に同じ値に評価される
ことが期待されるフォームにたいしては、茶色のハイライトスキップされます。

   難しいケースでは、テストカバレッジツールにアドバイスを与えるために、
コードにdo-nothingマクロを追加することができます。

 -- Macro: 1value form
     FORMを評価してその値をリターンするが、テストカバレッジにたいして
     FORMが常に同じ値だという情報を与える。

 -- Macro: noreturn form
     FORMを評価し、FORMが決してリターンしないという情報をカバレッジテス
     トに与える。もしリターンした場合は、run-timeエラーとなる。

   Edebugにもカバレッジテスト機能があります(*note Coverage Testing::を参
照)。これらの機能は部分的に重複しており、組み合わせることで明確になるで
しょう。


File: elisp,  Node: Profiling,  Prev: Test Coverage,  Up: Debugging

17.5 Profiling
==============

プログラムは正常に機能しているものの、より高速にまたは効率的に実行させた
い場合にまず行うべきは、そのプログラムがリソースをどのように使用するか知
るために、コードを“プロファイル(profile)”することです。ある特定の関数の
実行が、実行時間のうち無視できない割り合いを占めるようなら、その部分を最
適化する方法を探すことを開始できます。

   Emacsには、このためのビルトインサポートがあります。プロファイリングを
開始するには、‘M-x profiler-start’をタイプします。プロファイルはプロセッ
サー使用(processor usage)、メモリー使用(memory usage)、またはその両方を
選択できます。何らかの処理を行った後に‘M-x profiler-report’とタイプする
と、プロファイルに選択した各リソースがsummaryバッファーに表示されます。
reportバッファーの名前には、そのレポートが生成された時刻が含まれるので、
前の結果を消去せずに後で他のレポートを生成できます。プロファイリングが終
了したら、‘M-x profiler-stop’とタイプしてください(プロファイリングに関連
したオーバーヘッドが少しあるからです)。

   profiler reportバッファーでは、各行に呼び出された関数と、その後にプロ
ファイリングが開始されてから使用したリソース(プロセッサーまたはメモリー
)の絶対時間とパーセンテージ時間が表示されます。左側にシンボル‘+’のある行
では<RET>をタイプして行を展開して、高位レベルの関数に呼び出された関数を
確認できます。もう一度<RET>をタイプすると、元の状態へと行が折り畳まれま
す。

   ‘j’または‘mouse-2’を押下すると、関数の定義にジャンプします。‘d’を押下
すると、関数のドキュメントを閲覧できます。‘C-x C-w’を使用して、プロファ
イルをファイルに保存できます。‘=’を使用すれば、2つのプロファイルを比較す
ることができます。

   ‘elp’ライブラリーは、別のアプローチを提案します。使い方は‘elp.el’を参
照してください。

   ‘benchmark’ライブラリーを使用して、Emacs Lispフォームのスピードwpy個
別にチェックできます。‘benchmark.el’内の関数‘benchmark-run’、および
‘benchmark-run-compiled’を参照してください。

   ‘configure’のオプションに‘--enable-profiling’を使用してビルドすること
により、EmacsをCコードのレベルでプロファイルすることができます。こうして
ビルドされたEmacsは、Emacsをexitするときに‘gprof’ユーティリティを使用し
て検証できるファイル‘gmon.out’を生成します。この機能は主にEmacsのデバッ
グに有用です。このEmacsは、実行状態から上述の‘M-x profiler-...’コマンド
によりLispレベルで実際にストップします。


File: elisp,  Node: Read and Print,  Next: Minibuffers,  Prev: Debugging,  Up: Top

18 Reading and Printing Lisp Objects
************************************

“プリント(print)”および“読み取り(read)”は、Lispオブジェクトからテキスト
形式への変換、またはその逆の変換を行なう操作です。これらは*note Lisp
Data Types::で説明したプリント表現(printed representation)と入力構文
(read syntax)を使用します。

   このチャプターでは、読み取りおよびプリントのためのLisp関数について説
明します。このチャプターではさらに“ストリーム(stream)”についても説明しま
す。ストリームとは、(読み取りにおいては)テキストがどこから取得されるか、
(プリントにおいては)テキストをどこに出力するかを指定します。

* Menu:

* Streams Intro::            ストリーム、読み取り、プリントの概観。
* Input Streams::            入力ストリームとして使用できる、さまざまなデータ型。
* Input Functions::          テキストからLispオブジェクトを読み取る関数。
* Output Streams::           出力ストリームとして使用できる、さまざまなデータ型。
* Output Functions::         テキストとしてLispオブジェクトをプリントする関数。
* Output Variables::         プリント関数が何を行うか制御する変数。


File: elisp,  Node: Streams Intro,  Next: Input Streams,  Up: Read and Print

18.1 Introduction to Reading and Printing
=========================================

Lispオブジェクトの“読み取り”とは、テキスト形式のLisp式をパース(parse: 構
文解析)して、対応するLispオブジェクトを生成することを意味します。これは
、LLispプログラムがLispコードファイルからLispに取得される方法でもありま
す。わたしたちは、そのテキストをそのオブジェクトの“入力構文(read
syntax)”と呼んでいます。たとえばテキスト‘(a . 5)’は、CARが‘a’でCDRが数字
の5であるようなコンスセルにたいする入力構文です。

   Lispオブジェクトの“プリント”とは、あるオブジェクトをそのオブジェクト
の“プリント表現(printed representation)” (*note Printed
Representation::を参照)に変換することにより、そのオブジェクトを表すテキ
ストを生成することを意味します。上述のコンスセルをプリントすると、テキス
ト‘(a . 5)’が生成されます。

   読み取りとプリントは、概ね逆の処理といえます。あるテキスト断片を読み
取った結果生成されたオブジェクトをプリントすると、多くの場合は同じテキス
トが生成され、あるオブジェクトをプリントした結果のテキストを読み取ると、
通常は同じようなオブジェクトが生成されます。たとえばシンボル‘foo’をプリ
ントするとテキスト‘foo’が生成され、そのテキストを読み取るとシンボル
‘foo’がリターンされます。要素が‘a’と‘b’のリストをプリントするとテキスト
‘(a b)’が生成され、そのテキストを読み取ると、(同じリストではないが)要素
が‘a’と‘b’のリストが生成されます。

   しかし、これら2つの処理は互いにまったく逆の処理というわけではありませ
ん。３つの例外があります:

   • プリントは読み取ることが不可能なテキストを生成できる。たとえば、バ
     ッファー、フレーム、サブプロセス、マーカーは‘#’で始まるテキストとし
     てプリントされる。このテキストの読み取りを試行すると、エラーとなる
     。これらのデータ型を読み取る方法は存在しない。

   • 1つのオブジェクトが、複数のテキスト的な表現をもつことができる。たと
     えば‘1’と‘01’は同じ整数を表し、‘(a b)’と‘(a . (b))’は同じリストを表
     す。読み取りは複数の候補を受容するかもしれないが、プリントはそのう
     ちのただ1つを選択しなければならない。

   • あるオブジェクトの読み取りシーケンスの中間の特定ポイントに、読み取
     り結果に影響を与えないコメントを置くことができる。


File: elisp,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Read and Print

18.2 Input Streams
==================

テキストを読み取るLisp関数の大部分は、引数として“入力ストリーム(input
stream)”をとります。入力ストリームは、読み取られるテキストの文字をどこか
ら、どのように取得するかを指定します。以下は可能な入力ストリーム型です:

BUFFER
     入力文字はBUFFERのポイントの後の文字から直接読み取られる。文字の読
     み取りとともに、ポイントが進む。

MARKER
     入力文字はMARKERのあるバッファーの、マーカーの後の文字から直接読み
     取られる。文字の読み取りとともに、マーカーが進む。ストリームがマー
     カーのときは、バッファー内のポイント値に影響はない。

STRING
     入力文字はSTRINGの最初の文字から必要な文字数分が取得される。

FUNCTION
     入力文字はFUNCTIONから生成され、その関数は2種類の呼び出しをサポート
     しなければならない:

        • 引数なしで呼び出されたときは、次の文字をリターンする。

        • 1つの引数(常に文字)で呼び出されたとき、FUNCTIONは引数を保存し
          て、次の呼び出しでリターンするよう用意する。これは文字の“読み
          戻し(unreading)”と呼ばれ、Lispリーダーが1文字多く読みとったと
          き、それを“読みとったところに戻したい”ときに発生する。この場合
          には、FUNCTIONのリターン値と同じこと。

‘t’
     ‘t’は、その入力がミニバッファーから読み取られるストリームであること
     を意味する。実際にはミニバッファーが1回呼び出されて、ユーザーから与
     えられたテキストが、その後に入力ストリームとして使用される文字列と
     なる。Emacsがbatchモードで実行されている場合は、ミニバッファーのか
     わりに標準入力が使用される。たとえば、
          (message "%s" (read t))
     このような場合は標準入力からLisp式が読み取られて、結果は標準出力に
     プリントされるだろう。

‘nil’
     入力ストリームとして‘nil’が与えられた場合は、かわりに
     ‘standard-input’の値が使用されることを意味する。この値は“デフォルト
     の入力ストリーム(default input stream)”であり、非‘nil’の入力ストリ
     ームでなければならない。

SYMBOL
     入力ストリームとしてのシンボルは、(もしあれば)そのシンボルの関数定
     義と等価である。

   以下の例では、バッファーストリームから読み込み、読み取りの前後におけ
るポイント位置を示しています:

     ---------- Buffer: foo ----------
     This★ is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          ⇒ is
     (read (get-buffer "foo"))
          ⇒ the

     ---------- Buffer: foo ----------
     This is the★ contents of foo.
     ---------- Buffer: foo ----------

最初の読み取りではスペースがスキップされていることに注意してください。読
み取りにおいては、意味のあるテキストに先行する、任意のサイズの空白文字が
スキップされます。

   以下は、マーカーストリームからの読み取りの例で、最初は表示されている
バッファーの先頭にマーカーが配します。読み取られた値はシンボル‘This’です
。


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          ⇒ #<marker at 1 in foo>
     (read m)
          ⇒ This
     m
          ⇒ #<marker at 5 in foo>   ;; 最初のスペースの前。

   以下では、文字列のコンテンツから読み取っています:

     (read "(When in) the course")
          ⇒ (When in)

   以下はミニバッファーから読み取る例です。プロンプトは、
‘Lisp expression: ’です。(このプロンプトはストリーム‘t’から読み取る際は
常に使用されます。) ユーザーの入力はプロンプトの後に表示されます。

     (read t)
          ⇒ 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   最後は、‘useless-stream’という名前の関数ストリームから読み取る例です
。ストリームを使用する前に、変数‘useless-list’を文字のリストに初期化して
います。その後は、リスト内の次の文字を取得するため、または文字をリストの
先頭に追加することにより読み戻すために、関数‘useless-stream’を呼び出しま
す。

     (setq useless-list (append "XY()" nil))
          ⇒ (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          ⇒ useless-stream

このストリームを使って、以下のように読み取ります:

     (read 'useless-stream)
          ⇒ XY

     useless-list
          ⇒ (40 41)

開カッコと閉カッコがリスト内に残ることに注意してください。Lispリーダーは
開カッコに出会うと、それを入力の終わりと判断して、読み戻します。次にこの
ポイント位置からこのストリームを読み取ると、‘()’が読み取られて‘nil’がリ
ターンされます。


File: elisp,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Read and Print

18.3 Input Functions
====================

このセクションでは、読み取りに関係のあるLisp関数と変数について説明します
。

   以下の関数で、STREAMは入力ストリーム(前のセクションを参照)を意味しま
す。STREAMが‘nil’、または省略された場合のデフォルト値は
‘standard-input’です。

   読み取りにおいて終端されていないリスト、ベクター、文字列に遭遇した場
合は、‘end-of-file’がシグナルされます。

 -- Function: read &optional stream
     この関数はSTREAMからテキスト表現されたLisp式を1つ読み取り、Lispオブ
     ジェクトとしてリターンする。これは基本的なLisp入力関数である。

 -- Function: read-from-string string &optional start end
     この関数はSTRING内のテキストから、最初のテキスト表現されたLisp式を
     読み取る。リターン値はCARがその式で、CDRが次に読み取られるその文字
     列内の残りの文字(読み取られていない最初の文字)の位置を与える整数で
     あるようなコンスセルである。

     STARTが与えられた場合は、文字列内のインデックスSTART(最初の文字はイ
     ンデックス0)から読み取りが開始される。ENDを指定した場合は、残りの文
     字列が存在しないかのごとく、そのインデックスの直前で読み取りがスト
     ップされる。

     たとえば:

          (read-from-string "(setq x 55) (setq y 5)")
               ⇒ ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               ⇒ ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               ⇒ ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               ⇒ (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               ⇒ (11 . 8)

 -- Variable: standard-input
     この変数はデフォルト入力ストリーム(引数STREAMが‘nil’のとき‘read’が
     使用するストリーム)を保持する。デフォルトは‘t’で、これはミニバッフ
     ァーを使用することを意味する。

 -- Variable: read-circle
     非‘nil’の場合、この変数は循環構造(circular structure)および共有構造
     (shared structures)の読み取りを有効にする。*note Circular
     Objects::を参照。デフォルト値は‘t’。


File: elisp,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Read and Print

18.4 Output Streams
===================

出力ストリームは、プリントにより生成された文字に何を行うかを指定します。
ほとんどのプリント関数は、オプション引数として出力ストリームを受け入れま
す。以下は利用できる出力ストリーム型です:

BUFFER
     出力文字は、BUFFERのポイント位置に挿入される。文字が挿入された分、
     ポイントが進む。

MARKER
     出力文字は、MARKERのあるバッファーのマーカー位置に挿入される。文字
     が挿入された分、マーカー位置が進む。ストリームがマーカーのときは、
     そのバッファー内のポイント位置にプリントは影響せず、この種のプリン
     トでポイントは移動しない(マーカー位置がポイント位置、またはポイント
     位置より前の場合は除外される。通常はテキストの周囲にポイントが進む
     )。

FUNCTION
     出力文字は、文字を格納する役目をもつFUNCTIONに渡される。この関数は
     １つの文字を引数に、出力される文字の回数呼び出され、その文字を格納
     したい場所に格納する役目をもつ。

‘t’
     出力文字はエコーエリアに表示される。

‘nil’
     出力ストリームに‘nil’が指定された場合は、かわりに
     ‘standard-output’の値が使用されることを意味する。この値は“デフォル
     トの出力ストリーム(default output stream)”であり、非‘nil’でなければ
     ならない。

SYMBOL
     出力ストリームとしてのシンボルは、(もしあれば)そのシンボルの関数定
     義と等価である。

   有効な出力ストリームの多くは、入力ストリームとしても有効です。したが
って入力ストリームと出力ストリームの違いは、Lispオブジェクトの型ではなく
、どのようにLispオブジェクトを使うかという点です。

   以下はバッファーを出力ストリームとして使用する例です。ポイントは最初
は‘the’の中の‘h’の直前にあります。そして最後も、同じ‘h’の直前に配されま
す。

     ---------- Buffer: foo ----------
     This is t★he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          ⇒ "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     ★he contents of foo.
     ---------- Buffer: foo ----------

   次はマーカーを出力ストリームとして使用する例です。マーカーは最初、バ
ッファー‘foo’内の単語‘the’の中の‘t’と‘h’の間にあります。最後には、挿入さ
れたテキストによりマーカーが進み、同じ‘h’の前に留まります。通常の方法で
見られるようなポイント位置への影響がないことに注意してください。

     ---------- Buffer: foo ----------
     This is the ★output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          ⇒ #<marker at 10 in foo>

     (print "More output for foo." m)
          ⇒ "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he ★output
     ---------- Buffer: foo ----------

     m
          ⇒ #<marker at 34 in foo>

   以下はエコーエリアに出力を表示する例です:

     (print "Echo Area output" t)
          ⇒ "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   最後は関数を出力ストリームとして使用する例です。関数‘eat-output’は与
えられたそれぞれの文字を‘last-output’の先頭にconsします(*note Building
Lists::を参照)。最後には、リストには出力されたすべての文字が逆順で含まれ
ます。

     (setq last-output nil)
          ⇒ nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          ⇒ eat-output

     (print "This is the output" 'eat-output)
          ⇒ "This is the output"

     last-output
          ⇒ (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)

このリストを逆転すれば、正しい順序で出力することができます:

     (concat (nreverse last-output))
          ⇒ "
     \"This is the output\"
     "

‘concat’を呼び出してリストを文字列に変換すれば、内容をより明解に確認でき
ます。


File: elisp,  Node: Output Functions,  Next: Output Variables,  Prev: Output Streams,  Up: Read and Print

18.5 Output Functions
=====================

このセクションでは、オブジェクトをオブジェクトのプリント表現に変換して
LispオブジェクトをプリントするLisp関数を説明します。

   Emacsプリント関数には、正しく読み取れるように必要なとき出力にクォート
文字を追加するものがあります。使用されるクォート文字は‘"’と‘\’です。これ
らは文字列をシンボルと区別するとともに、文字列およびシンボル内の区切り文
字が読み取り時に区切り文字として扱われることを防ぎます。完全な詳細は
*note Printed Representation::を参照してください。クォートするかしないか
は、プリント関数の選択により指定できます。

   そのテキストがLispに読み戻す場合、同様にLispプログラマーにLispオブジ
ェクトを明解に説明するのが目的の場合は、曖昧さを避けるためにクォート文字
をプリントするべきです。しかし、プログラマー以外の人間にたいして出力の見
栄えを良くするのが目的なら、通常はクォートなしでプリントしたほうがよいで
しょう。

   Lispオブジェクトは自己参照ができます。通常の方法で自己参照オブジェク
トをプリントするにはテキストが無限に必要で、その試みにより無限再帰が発生
する恐れがあります。Emacsはそのような再帰を検知して、すでにプリントされ
たオブジェクトを再帰的にプリントするかわりに、‘#LEVEL’をプリントします。
たとえば以下は、カレントのプリント処理において、レベル0のオブジェクトを
再帰的に参照することを示しています:

     (setq foo (list nil))
          ⇒ (nil)
     (setcar foo foo)
          ⇒ (#0)

   以下の関数では、STREAMは出力ストリームを意味します。(出力ストリームの
説明は、前のセクションを参照してください。) STREAMが‘nil’、または省略さ
れた場合のデフォルトは、‘standard-output’の値になります。

 -- Function: print object &optional stream
     ‘print’関数は、プリントを行うための便利な方法である。この関数は
     OBJECTの前後に改行を付与して、OBJECTのプリント表現をSTREAMにプリン
     トする。クォート文字が使用される。‘print’はOBJECTをリターンする。た
     とえば:

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               ⊣
               ⊣ The\ cat\ in
               ⊣
               ⊣ "the hat"
               ⊣
               ⊣ " came back"
               ⇒ " came back"

 -- Function: prin1 object &optional stream
     この関数はOBJECTのプリント表現をSTREAMに出力する。この関数は
     ‘print’のように出力を分割するための改行をプリントしないが、
     ‘print’のようにクォート文字を使用する。OBJECTをリターンする。

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               ⊣ The\ cat\ in"the hat"" came back"
               ⇒ " came back"

 -- Function: princ object &optional stream
     この関数はOBJECTのプリント表現をSTREAMに出力する。OBJECTをリターン
     する。

     この関数は‘read’ではなく人間が読める出力を生成することを意図してい
     るので、クォート文字を挿入せず、文字列のコンテンツの前後にダブルク
     ォート文字を配さない。呼び出しの間に間隔を何も出力しない。

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               ⊣ The cat in the "hat"
               ⇒ " in the \"hat\""

 -- Function: terpri &optional stream
     この関数はSTREAMに改行を出力する。名前の由来は、“terminate print”で
     ある。

 -- Function: write-char character &optional stream
     この関数はCHARACTERをSTREAMに出力する。CHARACTERをリターンする。

 -- Function: prin1-to-string object &optional noescape
     この関数は、同じ引数で‘prin1’がプリントするテキストを含む文字列をリ
     ターンする。

          (prin1-to-string 'foo)
               ⇒ "foo"
          (prin1-to-string (mark-marker))
               ⇒ "#<marker at 2773 in strings.texi>"

     NOESCAPEが非‘nil’の場合は、出力中のクォート文字の使用を抑制する。
     (この引数は、Emacsバージョン19以降でサポートされた。)

          (prin1-to-string "foo")
               ⇒ "\"foo\""
          (prin1-to-string "foo" t)
               ⇒ "foo"

     Lispオブジェクトのプリント表現を文字列として取得する別の手段につい
     ては、*note Formatting Strings::の‘format’を参照のこと。

 -- Macro: with-output-to-string body...
     このマクロは出力を文字列に送るよう‘standard-output’をセットアップし
     て、フォームBODYを実行する。その文字列がリターンされる。

     たとえばカレントバッファー名が‘foo’の場合、

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     は‘"The buffer is foo"’をリターンする。

 -- Function: pp object &optional stream
     この関数は‘prin1’と同じようにOBJECTをSTREAMに出力するが、より“優雅
     (pretty)”な方法でこれを行う。すなわち、この関数は人間がより読みやす
     いようにオブジェクトのインデントとパディングを行う。


File: elisp,  Node: Output Variables,  Prev: Output Functions,  Up: Read and Print

18.6 Variables Affecting Output
===============================

 -- Variable: standard-output
     この変数の値はデフォルト出力ストリーム(STREAM引数が‘nil’のときプリ
     ント関数が使用するストリーム)である。デフォルトは‘t’で、エコーエリ
     アに表示することを意味する。

 -- Variable: print-quoted
     これが非‘nil’の場合は、省略されたリーダー構文(たとえば‘(quote
     foo)’を‘'foo’、‘(function foo)’を‘#'foo’のように)を使用してクォート
     されたフォームをプリントすることを意味する。

 -- Variable: print-escape-newlines
     この変数が非‘nil’の場合、文字列内の改行は‘\n’、改ページは‘\f’でプリ
     ントされる。これらの文字は、通常は実際の改行および改ページとしてプ
     リントされる。

     この変数はクォートつきのプリントを行うプリント関数‘prin1’および
     ‘print’に影響を与える。‘princ’に影響はない。以下は‘prin1’を使用した
     場合の例である:

          (prin1 "a\nb")
               ⊣ "a
               ⊣ b"
               ⇒ "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               ⊣ "a\nb"
               ⇒ "a
          b"

     2つ目の式では、‘prin1’を呼び出す間は‘print-escape-newlines’のローカ
     ルバインドが効果をもつが、結果をプリントするときには効果がない。

 -- Variable: print-escape-nonascii
     この変数が非‘nil’の場合、クォートつきでプリントするプリント関数
     ‘prin1’および‘print’は、文字列内のユニバイトの非ASCII文字を無条件で
     バックスラッシュシーケンスとしてプリントする。

     これらの関数は、出力ストリームがマルチバイトバッファー、あるいはマ
     ーカーがマルチバイトバッファーをポイントするときは、この変数の値に
     関わらずユニバイト非ASCII文字にたいしてバックスラッシュシーケンスを
     使用する。

 -- Variable: print-escape-multibyte
     この変数が非‘nil’の場合、クォートつきでプリントするプリント関数
     ‘prin1’および‘print’は、文字列内のマルチバイトの非ASCII文字を無条件
     でバックスラッシュシーケンスとしてプリントする。

     これらの関数は、出力ストリームがユニバイトバッファー、あるいはマー
     カーがユニバイトバッファーをポイントするときは、この変数の値に関わ
     らずマルチバイト非ASCII文字にたいしてバックスラッシュシーケンスを使
     用する。

 -- Variable: print-length
     この変数の値は任意のリスト、ベクター、ブールベクターをプリントする
     際の最大要素数である。プリントされるオブジェクトがこれより多くの要
     素をもつ場合は、省略記号(“...”)で省略される。

     値が‘nil’(デフォルト)の場合は、無制限である。

          (setq print-length 2)
               ⇒ 2
          (print '(1 2 3 4 5))
               ⊣ (1 2 ...)
               ⇒ (1 2 ...)

 -- Variable: print-level
     この変数の値はプリント時の丸カッコ(parentheses: “()”)と角カッコ
     (brackets: “[]"’)のネスト最大深さである。この制限を超える任意のリス
     トまたはベクターは省略記号(“...”)で省略される。値‘nil’(デフォルト
     )は無制限を意味する。

 -- User Option: eval-expression-print-length
 -- User Option: eval-expression-print-level
     これらは‘eval-expression’により使用される‘print-length’および
     ‘print-level’の値であり、したがって間接的に多くのインタラクティブな
     評価コマンドにより使用される(*note Evaluating Emacs-Lisp
     Expressions: (emacs)Lisp Eval.を参照)。

   以下の変数は循環構造および共有構造の検出と報告に使用されます:

 -- Variable: print-circle
     非‘nil’の場合、この変数はプリント時の循環構造と共有構造の検出を有効
     にする。*note Circular Objects::を参照のこと。

 -- Variable: print-gensym
     非‘nil’の場合、この変数はプリント時のインターンされていないシンボル
     (*note Creating Symbols::を参照)の検出を有効にする。これが有効な場
     合、インターンされていないシンボルはプレフィックス‘#:’とともにプリ
     ントされる。このプレフィックスは、Lispリーダーにたいしてインターン
     されていないシンボルを生成するよう告げる。

 -- Variable: print-continuous-numbering
     非‘nil’の場合は、複数のプリント呼び出しを通じて通番が振られることを
     意味する。これは‘#N=’ラベルおよび‘#M#’参照にたいしてプリントされる
     数字に影響する。この変数を‘setq’でセットしてはならない。‘let’を使用
     して一時的に‘t’にバインドするべきである。これを行う場合は、
     ‘print-number-table’も‘nil’にバインドするべきである。

 -- Variable: print-number-table
     この変数は‘print-circle’機能を実装するために、プリント処理で内部的
     に使用されるベクターを保持する。‘print-continuous-numbering’をバイ
     ンドするときにこの変数を‘nil’にバインドする以外は、この変数を使用す
     るべきではない。

 -- Variable: float-output-format
     この変数は浮動小数点数をプリントする方法を指定する。デフォルトは
     ‘nil’で、これは情報を失わずにその数値を表せるもっとも短い出力を使用
     することを意味する。

     出力フォーマットをより精密に制御するために、この変数に文字列をセッ
     トできる。この文字列にはCの‘sprintf’関数で使用される‘%’指定子をセッ
     トする。この変数で使用することのできる制限についての詳細は、この変
     数のドキュメント文字列を参照のこと。


File: elisp,  Node: Minibuffers,  Next: Command Loop,  Prev: Read and Print,  Up: Top

19 Minibuffers
**************

“ミニバッファー(minibuffer)”とは、単一の数プレフィックス引数より複雑な引
数を読み取るためにEmacsコマンドが使用する、特別なバッファーのことです。
これらの引数にはファイル名、バッファー名、(‘M-x’での)コマンド名が含まれ
ます。ミニバッファーはフレームの最下行、エコーエリア(*note The Echo
Area::を参照)と同じ場所に表示されますが、引数を読み取るときだけ使用され
ます。

* Menu:

* Intro to Minibuffers::     ミニバッファーに関する基本的な情報。
* Text from Minibuffer::     そのままのテキスト文字列を読み取る方法。
* Object from Minibuffer::   Lispオブジェクトや式を読み取る方法。
* Minibuffer History::       ユーザーが再利用できるように以前のミニバッファー入力は記録される。
* Initial Input::            ミニバッファーにたいして初期内容を指定する。
* Completion::               補完の呼び出しとカスタマイズ方法。
* Yes-or-No Queries::        問いにたいし単純な答えを求める。
* Multiple Queries::         一連の似たような問いに答える。
* Reading a Password::       端末からパスワードを読み取る。
* Minibuffer Commands::      ミニバッファー内でキーバインドとして使用されるコマンド。
* Minibuffer Windows::       特殊なミニバッファーウィンドウを処理する。
* Minibuffer Contents::      どのようなコマンドがミニバッファーのテキストにアクセスするか。
* Recursive Mini::           ミニバッファーへの再帰的なエントリーが許容されるかどうか。
* Minibuffer Misc::          カスタマイズ用のさまざまなフックや変数。


File: elisp,  Node: Intro to Minibuffers,  Next: Text from Minibuffer,  Up: Minibuffers

19.1 Introduction to Minibuffers
================================

ほとんどの点において、ミニバッファーは普通のEmacsバッファーです。編集コ
マンドのようなバッファーにたいするほとんどの操作は、ミニバッファーでも機
能します。しかし、バッファーを管理する操作の多くは、ミニバッファーに適用
できません。ミニバッファーは常に‘ *Minibuf-NUMBER*’という形式の名前をも
ち、変更することはできません。ミニバッファーはミニバッファー用の特殊なウ
ィンドウだけに表示されます。これらのウィンドウは常にフレーム最下に表示さ
れます。(フレームにミニバッファーウィンドウがないときや、ミニバッファー
ウィンドウだけをもつ特殊なフレームもあります。)*note Minibuffers and
Frames::を参照してください。

   ミニバッファー内のテキストは常に“プロンプト文字列(prompt string)”で始
まります。これはミニバッファーを使用しているプログラムが、ユーザーにたい
してどのような種類の入力が求められているか告げるために指定するテキストで
す。このテキストは意図せずに変更してしまわないように、読み取り専用として
マークされます。このテキストは‘beginning-of-line’、‘forward-word’、
‘forward-sentence’、‘forward-paragraph’を含む特定の移動用関数が、プロン
プトと実際のテキストの境界でストップするように、フィールド(*note
Fields::を参照)としてもマークされています。

   ミニバッファーのウィンドウは、通常は1行です。ミニバッファーのコンテン
ツがより多くのスペースを要求する場合は、自動的に拡張されます。ミニバッフ
ァーのウィンドウがアクティブな間は、ウィンドウのサイズ変更コマンドで一時
的にウィンドウのサイズを変更できます。サイズの変更は、ミニバッファーを
exitしたとき、通常のサイズにリバートされます。ミニバッファーがアクティブ
でないときはフレーム内の他のウィンドウでウィンドウのサイズ変更コマンドを
使用するか、マウスでモードラインをドラッグして、ミニバッファーのサイズを
永続的に変更できます。(現実装では、これが機能するには
‘resize-mini-windows’が‘nil’でなければなりません。) フレームがミニバッフ
ァーだけを含む場合は、そのフレームのサイズを変更してミニバッファーのサイ
ズを変更できます。

   ミニバッファーの使用により入力イベントが読み取られ、‘this-command’や
‘last-command’のような変数の値が変更されます(*note Command Loop Info::を
参照)。プログラムにそれらを変更させたくない場合は、ミニバッファーを使用
するコードの前後でそれらをバインドするべきです。

   ある状況下では、アクティブなミニバッファーが存在するときでもコマンド
がミニバッファーを使用できます。そのようなミニバッファーは“再帰ミニバッ
ファー(recursive minibuffer)”と呼ばれます。この場合、最初のミニバッファ
ーは‘ *Minibuf-1*’という名前になります。再帰ミニバッファーはミニバッファ
ー名の最後の数字を増加させて命名されます。(名前はスペースで始まるので、
通常のバッファーリストには表示されません。) 再帰ミニバッファーが複数ある
場合は、最内の(もっとも最近にエンターされた)ミニバッファーがアクティブな
ミニバッファーになります。このバッファーが、通常ではミニバッファーと呼ば
れるバッファーです。変数‘enable-recursive-minibuffers’、またはコマンドシ
ンボルのその名前のプロパティをセットすることにより再帰ミニバッファーを許
可、または禁止できます(*note Recursive Mini::を参照)。

   他のバッファーと同様、ミニバッファーは特別なキーバインドを指定するた
めにローカルキーマップ(*note Keymaps::を参照)を使用します。ミニバッファ
ーを呼び出す関数も、処理を行うためにローカルマップをセットアップします。
補完なしのミニバッファーローカルマップについては、*note Text from
Minibuffer::を参照してください。補完つきのミニバッファーローカルマップに
ついては、*note Completion Commands::を参照してください。

   ミニバッファーが非アクティブのときのメジャーモードは
‘minibuffer-inactive-mode’で、キーマップは
‘minibuffer-inactive-mode-map’です。これらは、実際にはミニバッファーが別
フレームにある場合だけ、便利です。*note Minibuffers and Frames::を参照し
てください。

   Emacsがバッチモードで実行されている場合、ミニバッファーからの読み取り
リクエストは、実装にはEmacs開始時に提供された標準入力記述子から行を読み
取ります。これは基本的な入力だけをサポートします。特別なミニバッファーの
機能(ヒストリー、補完、パスワードのマスクなど)は、バッチモードでは利用で
きません。


File: elisp,  Node: Text from Minibuffer,  Next: Object from Minibuffer,  Prev: Intro to Minibuffers,  Up: Minibuffers

19.2 Reading Text Strings with the Minibuffer
=============================================

ミニバッファー入力にたいする基本的なプリミティブは
‘read-from-minibuffer’で、これは文字列とLispオブジェクトの両方からテキス
ト表現されたフォームを読み取ることができます。関数‘read-regexp’は、特別
な種類の文字列である正規表現式(*note Regular Expressions::を参照)の読み
取りに使用されます。コマンドや変数、ファイル名などの読み取りに特化した関
数もあります(*note Completion::を参照)。

   ほとんどの場合では、Lisp関数の途中でミニバッファー入力関数を呼び出す
べきではありません。かわりに‘interactive’指定されたコマンドの引数読み取
りの一部として、すべてのミニバッファー入力を行います。*note Defining
Commands::を参照してください。

 -- Function: read-from-minibuffer prompt &optional initial keymap read
          history default inherit-input-method
     この関数は、ミニバッファーから入力を取得するもっとも一般的な手段で
     ある。デフォルトでは、任意のテキストを受け入れて、それを文字列とし
     てリターンする。しかし、READが非‘nil’の場合は、テキストをLispオブジ
     ェクトに変換するために‘read’を使用する(*note Input Functions::を参
     照)。

     この関数が最初に行うのは、ミニバッファーをアクティブにして、プロン
     プトにPROMPT(文字列でなければならない)を用いてミニバッファーを表示
     することである。その後に、ユーザーはミニバッファーでテキストを編集
     できる。

     ミニバッファーをexitするためにユーザーがコマンドをタイプするとき、
     ‘read-from-minibuffer’はミニバッファー内のテキストからリターン値を
     構築する。通常はそのテキストを含む文字列がリターンされる。しかし、
     READが非‘nil’の場合、‘read-from-minibuffer’はテキストを読み込んで結
     果を未評価のLispオブジェクトでリターンする。(読み取りについての詳細
     は、*Note Input Functions::を参照のこと。)

     引数DEFAULTは、ヒストリーコマンドを通じて利用できるデフォルト値を指
     定する。値には文字列、文字列リスト、または‘nil’を指定する。文字列ま
     たは文字列リストは、ユーザーが‘M-n’で利用可能な“未来のヒストリー
     (future history)”になります。

     READが非‘nil’の場合は、ユーザーの入力が空のときの‘read’の入力として
     も、DEFAULTが使用される。DEFAULTが文字列リストの!は、最初の文字列が
     入力として使用される。DEFAULTが‘nil’の場合、空の入力は
     ‘end-of-file’エラーとなる。しかし通常(READが‘nil’)の場合には、ユー
     ザーの入力が空のとき‘read-from-minibuffer’はDEFAULTを無視して、空文
     字列‘""’をリターンする。この点において、この関数はこのチャプターの
     他のどのミニバッファー入力関数とも異なる。

     KEYMAPが非‘nil’の場合、そのキーマップはミニバッファー内で使用される
     ローカルキーマップとなる。KEYMAPが省略、または‘nil’の場合は、
     ‘minibuffer-local-map’の値がキーマップとして使用される。キーマップ
     の指定は、補完のようなさまざまなアプリケーションにたいしてミニバッ
     ファーをカスタマイズする、もっとも重要な方法である。

     引数HISTORYは、入力の保存やミニバッファー内で使用されるヒストリーコ
     マンドが使用するヒストリーリスト変数を指定する。デフォルトは
     ‘minibuffer-history’である。同様に、オプションでヒストリーリスト内
     の開始位置を指定できる。*note Minibuffer History::を参照のこと。

     変数‘minibuffer-allow-text-properties’が非‘nil’の場合には、リターン
     される文字列にはミニバッファーでのすべてのテキストプロパティが含ま
     れる。それ以外では、値がリターンされるときすべてのテキストプロパテ
     ィが取り除かれる。

     引数INHERIT-INPUT-METHODが非‘nil’の場合には、ミニバッファーにエンタ
     ーする前にカレントだったバッファーが何であれ、カレントのインプット
     メソッド(*note Input Methods::を参照)、および
     ‘enable-multibyte-characters’のセッティング(*note Text
     Representations::を参照)が継承される。

     ほとんどの場合、INITIALの使用は推奨されない。非‘nil’値の使用は、
     HISTORYにたいするコンスセル指定と組み合わせる場合のみ推奨する。
     *note Initial Input::を参照のこと。

 -- Function: read-string prompt &optional initial history default
          inherit-input-method
     この関数はミニバッファーから文字列を読み取り、それをリターンする。
     引数PROMPT、INITIAL、HISTORY、INHERIT-INPUT-METHODは
     ‘read-from-minibuffer’で使用する場合と同様。使用されるキーマップは
     ‘minibuffer-local-map’である。

     オプション引数DEFAULTは‘read-from-minibuffer’の場合と同様に使用され
     るが、ユーザーの入力が空の場合にリターンするデフォルト値も指定する
     。‘read-from-minibuffer’の場合と同様、値は文字列、文字列リスト、ま
     たは‘nil’(空文字列と等価)である。DEFAULTが文字列のときは、その文字
     列がデフォルト値になる。文字列リストのときは、最初の文字列がデフォ
     ルト値になる。(これらの文字列はすべて“未来のミニバッファーヒストリ
     ー(future minibuffer history)”としてユーザーが利用可能)。

     この関数は‘read-from-minibuffer’を呼び出すことにより機能する。

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ≡
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (and (equal value "") DEFAULT)
                (if (consp DEFAULT) (car DEFAULT) DEFAULT)
              value))

 -- Function: read-regexp prompt &optional defaults history
     この関数はミニバッファーから文字列として正規表現を読み取り、それを
     リターンする。ミニバッファーのプロンプト文字列PROMPTが‘:’(とその後
     にオプションの空白文字)で終端されていない場合、この関数はデフォルト
     のリターン値(空文字列でない場合。以下参照)の前に‘: ’を付加する。

     オプション引数DEFAULTSは、入力が空の場合にリターンするデフォルト値
     を制御する。値は文字列、‘nil’(空文字列と等価)、文字列リスト、シンボ
     ルのうちのどれか。

     DEFAULTSがシンボルの場合、‘read-regexp’は変数
     ‘read-regexp-defaults-function’(以下参照)の値を調べて非‘nil’のとき
     は、DEFAULTSよりそちらを優先的に使用する。この場合、値は以下のいず
     れか:

        − ‘regexp-history-last’。これは適切なミニバッファーヒストリーリ
          スト(以下参照)の最初の要素を使用することを意味する。

        − 引数なしの関数。リターン値(‘nil’、文字列、文字列リストのいずれ
          か)がDEFAULTSの値となる。

     これで、‘read-regexp’がDEFAULTSを処理した結果はリストに確定する(値
     が‘nil’または文字列の場合は1要素のリストに変換する)。このリストにた
     いし、‘read-regexp’は、以下のような入力として有用な候補をいくつか追
     加する:

        − ポイント位置の単語またはシンボル。
        − インクリメンタル検索で最後に使用されたregexp。
        − インクリメンタル検索で最後に使用された文字列。
        − 問い合わせつき置換コマンドで最後に使用された文字列またはパター
          ン。

     これで関数は、ユーザー入力を取得するために‘read-from-minibuffer’に
     渡す正規表現のリストを得た。リストの最初の要素は入力が空の場合のデ
     フォルト値である。リストのすべての要素は“未来のミニバッファーヒスト
     リーリスト(future minibuffer history list)” (*note future list:
     (emacs)Minibuffer History.を参照)としてユーザーが利用可能になる。

     オプション引数HISTORYが非‘nil’の場合、それは使用するミニバッファー
     ヒストリーリストを指定するシンボルである(*note Minibuffer
     History::を参照)。これが省略、または‘nil’の場合、ヒストリーリストの
     デフォルトは‘regexp-history’となる。

 -- Variable: read-regexp-defaults-function
     関数‘read-regexp’は、デフォルトの正規表現リストを決定するために、こ
     の変数の値を使用するかもしれない。非‘nil’の場合、この変数は以下のい
     ずれかである:

        − シンボル‘regexp-history-last’。

        − ‘nil’、文字列、文字列リストのいずれかをリターンする引数なしの
          関数。

     これらの変数の使い方についての詳細は、上述の‘read-regexp’を参照のこ
     と。

 -- Variable: minibuffer-allow-text-properties
     この変数が‘nil’の場合、‘read-from-minibuffer’および‘read-string’は
     ミニバッファー入力をリターンする前に、すべてのテキストプロパティを
     取り除く。しかし‘read-no-blanks-input’(以下参照)、同様に補完つきで
     ミニバッファー入力を行う‘read-minibuffer’およびそれに関連する関数
     (*note Reading Lisp Objects With the Minibuffer: Object from
     Minibuffer.を参照)は、この変数の値に関わらず、無条件でテキストプロ
     パティを破棄する。

 -- Variable: minibuffer-local-map
     これはミニバッファーからの読み取りにたいするデフォルトローカルキー
     マップである。デフォルトでは以下のバインディングをもつ:

     ‘C-j’
          ‘exit-minibuffer’

     <RET>
          ‘exit-minibuffer’

     ‘C-g’
          ‘abort-recursive-edit’

     ‘M-n’
     <DOWN>
          ‘next-history-element’

     ‘M-p’
     <UP>
          ‘previous-history-element’

     ‘M-s’
          ‘next-matching-history-element’

     ‘M-r’
          ‘previous-matching-history-element’

 -- Function: read-no-blanks-input prompt &optional initial
          inherit-input-method
     この関数はミニバッファーから文字列を読み取るが、入力の一部として空
     白文字を認めず、かわりに空白文字は入力を終端させる。引数PROMPT、
     INITIAL、INHERIT-INPUT-METHODは‘read-from-minibuffer’で使用するとき
     と同様。

     これは関数‘read-from-minibuffer’の簡略化されたインターフェイスであ
     り、キーマップ‘minibuffer-local-ns-map’の値をKEYMAP引数として、
     ‘read-from-minibuffer’関数に渡す。キーマップ
     ‘minibuffer-local-ns-map’は‘C-q’をリバインドしないので、クォートす
     ることにより文字列内にスペースを挿入することが_可能である_。

     ‘minibuffer-allow-text-properties’の値に関わらず、この関数はテキス
     トプロパティを破棄する。

          (read-no-blanks-input PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map))

 -- Variable: minibuffer-local-ns-map
     このビルトイン変数は関数‘read-no-blanks-input’内でミニバッファーロ
     ーカルキーマップとして使用されるキーマップである。デフォルトでは、
     ‘minibuffer-local-map’のバインディングに加えて、以下のバインディン
     グが有効になる:

     <SPC>
          ‘exit-minibuffer’

     <TAB>
          ‘exit-minibuffer’

     ‘?’
          ‘self-insert-and-exit’


File: elisp,  Node: Object from Minibuffer,  Next: Minibuffer History,  Prev: Text from Minibuffer,  Up: Minibuffers

19.3 Reading Lisp Objects with the Minibuffer
=============================================

このセクションでは、ミニバッファーでLispオブジェクトを読み取る関数を説明
します。

 -- Function: read-minibuffer prompt &optional initial
     この関数はミニバッファーを使用してLispオブジェクトをよみ、それを評
     価せずにリターンする。引数PROMPTとINITIALは、
     ‘read-from-minibuffer’のときと同様に使用する。

     これは‘read-from-minibuffer’関数にたいする簡略化されたインターフェ
     イスである。

          (read-minibuffer PROMPT INITIAL)
          ≡
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL nil t))

     以下の例では、初期入力として文字列‘"(testing)"’を与えている:

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; 以下はミニバッファーでの表示::

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)★
          ---------- Buffer: Minibuffer ----------

     ユーザーは<RET>をタイプして初期入力をデフォルトとして利用したり、入
     力を編集することができる。

 -- Function: eval-minibuffer prompt &optional initial
     この関数はミニバッファーを使用してLisp式を読み取り、それを評価して
     結果をリターンする。引数PROMPTとINITIALの使い方は、
     ‘read-from-minibuffer’と同様。

     この関数は、‘read-minibuffer’の呼び出し結果を単に評価する:

          (eval-minibuffer PROMPT INITIAL)
          ≡
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command prompt form
     この関数はミニバッファーでLisp式を読み取り、それを評価して結果をリ
     ターンする。このコマンドと‘eval-minibuffer’の違いは、このコマンドで
     は初期値としてのFORMはオプションではなく、テキストの文字列ではない
     プリント表現に変換されたLispオブジェクトとして扱われることである。
     これは‘prin1’でプリントされるので、文字列の場合はテキスト初期値内に
     ダブルクォート文字(‘"’)が含まれる。*note Output Functions::を参照の
     こと。

     以下の例では、すでに有効なフォームであるようなテキスト初期値として
     式をユーザーに提案している:

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; 前の式を評価した後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)★
          ---------- Buffer: Minibuffer ----------

     すぐに<RET> をタイプするとミニバッファーをexitして式を評価するので
     、1単語分ポイントは前進する。


File: elisp,  Node: Minibuffer History,  Next: Initial Input,  Prev: Object from Minibuffer,  Up: Minibuffers

19.4 Minibuffer History
=======================

“ミニバッファーヒストリーリスト(minibuffer history list)”は以前のミニバ
ッファー入力を記録するので、それらを手軽に再利用できます。ミニバッファー
ヒストリーリストは、(以前に入力された)文字列のリストで、もっとも最近の文
字列が先頭になります。

   多数のミニバッファーが個別に存在し、異なる入力の種類に使用されます。
それぞれのミニバッファー使用にたいして正しいヒストリーリストを指定するの
は、Lispプログラマーの役目です。

   ミニバッファーヒストリーリストは、‘read-from-minibuffer’および
‘completing-read’のオプション引数HISTORYに指定します。以下が利用できる値
です:

VARIABLE
     ヒストリーリストとしてVARIABLE(シンボル)を使用する。

(VARIABLE . STARTPOS)
     ヒストリーリストとしてVARIABLE(シンボル)を使用し、ヒストリー位置の
     初期値をSTARTPOS(負の整数)とみなす。

     STARTPOSに0を指定するのは、単にシンボルVARIABLEだけを指定するのと等
     価である。‘previous-history-element’はミニバッファー内のヒストリー
     リストの最新の要素を表示するだろう。 正のSTARTPOSを指定した場合、ミ
     ニバッファーヒストリー関数は‘(elt VARIABLE(1- STARTPOS))’がミニバッ
     ファー内でカレントで表示されているヒストリー要素であるかのように振
     る舞う。

     一貫性を保つため、ミニバッファー入力関数のINITIAL引数(*note Initial
     Input::を参照)使用して、ミニバッファーの初期内容となるヒストリー要
     素も指定すべきである。

   HISTORYを指定しない場合は、デフォルトのヒストリーリスト
‘minibuffer-history’が使用されます。他の標準的なヒストリーリストについて
は、以下を参照してください。最初に使用する前に‘nil’に初期化するだけで、
独自のヒストリーリストを作成することもできます。

   ‘read-from-minibuffer’と‘completing-read’は、どちらも新たな要素を自動
的にヒストリーリストに追加して、ユーザーがそのリストのアイテムを再使用す
るためのコマンドを提供します。ヒストリーリストを使用するためにプログラム
が行う必要があるのは、リストの初期化と、使用するときに入力関数にリストの
名前を渡すだけです。しかし、ミニバッファー入力関数がリストを使用していな
いときに、手動でリストを変更しても問題はありません。

   新たな要素をヒストリーリストに追加するEmacs関数は、リストが長くなりす
ぎたときに古い要素の削除も行うことができます。変数‘history-length’は、ほ
とんどのヒストリーリストの最大長を指定する変数です。特定のヒストリーリス
トにたいして異なる最大長を指定するには、そのヒストリーリストシンボルの
‘history-length’プロパティにその最大長をセットします。変数
‘history-delete-duplicates’には、ヒストリー内の重複を削除するかどうかを
指定します。

 -- Function: add-to-history history-var newelt &optional maxelt
          keep-all
     この関数はNEWELTが空文字列でなければ、それを新たな要素として変数
     HISTORY-VARに格納されたヒストリーリストに追加して、更新されたヒスト
     リーリストをリターンする。これはMAXELTまたは‘history-length’がが非
     ‘nil’の場合は、リストの長さをその変数の値に制限する(以下参照)。
     MAXELTに指定できる値の意味は、‘history-length’の値と同様。

     ‘add-to-history’は通常、‘history-delete-duplicates’が非‘nil’ならば
     、ヒストリーリスト内の重複メンバーを削除する。しかし、KEEP-ALLが非
     ‘nil’の場合、それは重複を削除しないことを意味し、たとえNEWELTが空で
     もリストに追加する。

 -- Variable: history-add-new-input
     この変数の値が‘nil’の場合、ミニバッファーから読み取りを行う標準的な
     関数は、ヒストリーリストに新たな要素を追加しない。これにより、
     Lispプログラムが‘add-to-history’を使用して明示的に入力ヒストリーを
     管理することになる。デフォルト値は‘t’。

 -- User Option: history-length
     この変数の値は、最大長を独自に指定しないすべてのヒストリーリストの
     最大長を指定する。値が‘t’の場合は、最大長がない(古い要素を削除しな
     い)ことを意味する。ヒストリーリスト変数のシンボルの
     ‘history-length’プロパティが非‘nil’の場合には、その特定のヒストリー
     リストにたいする最大長として、そのプロパティ値がこの変数をオーバー
     ライドする。

 -- User Option: history-delete-duplicates
     この変数の値が‘t’の場合、それは新たなヒストリー要素の追加時に、以前
     からある等しい要素が削除されることを意味する。

   以下は、標準的なミニバッファーヒストリーリスト変数です:

 -- Variable: minibuffer-history
     ミニバッファーヒストリー入力にたいするデフォルトのヒストリーリスト
     。

 -- Variable: query-replace-history
     ‘query-replace’の引数(および他のコマンドの同様の引数)にたいするヒス
     トリーリスト。

 -- Variable: file-name-history
     ファイル名引数にたいするヒストリーリスト。

 -- Variable: buffer-name-history
     バッファー名引数にたいするヒストリーリスト。

 -- Variable: regexp-history
     正規表現引数にたいするヒストリーリスト。

 -- Variable: extended-command-history
     拡張コマンド名引数にたいするヒストリーリスト。

 -- Variable: shell-command-history
     シェルコマンド引数にたいするヒストリーリスト。

 -- Variable: read-expression-history
     評価されるためのLisp式引数にたいするヒストリーリスト。

 -- Variable: face-name-history
     フェイス引数にたいするヒストリーリスト。


File: elisp,  Node: Initial Input,  Next: Completion,  Prev: Minibuffer History,  Up: Minibuffers

19.5 Initial Input
==================

ミニバッファー入力にたいする関数のいくつかには、INITIALと呼ばれる引数が
あります。これは通常のように空の状態で開始されるのではなく、特定のテキス
トとともにミニバッファーが開始されることを指定しますが、ほとんどの場合に
おいて推奨されない機能です。

   INITIALが文字列の場合、ミニバッファーはその文字列のテキストを含む状態
で開始され、ユーザーがそのテキストの編集を開始するとき、ポイントはテキス
トの終端にあります。ユーザーがミニバッファーをexitするために単に<RET>を
タイプした場合には、この入力文字列の初期値をリターン値だと判断します。

   *INITIALにたいして非‘nil’値の使用には反対します。*なぜなら初期入力は
強要的なインターフェイスだからです。ユーザーにたいして有用なデフォルト入
力を提案するためには、ヒストリーリストやデフォルト値の提供のほうが、より
便利です。

   しかしINITIAL引数にたいして文字列を指定すべき状況が1つだけあります。
それは、HISTORY引数にコンスセルを指定したときです。*note Minibuffer
History::を参照してください。

   INITIALは‘(STRING . POSITION)’という形式をとることもできます。これは
STRINGをミニバッファーに挿入するが、その文字列のテキスト中のPOSITIONにポ
イントを配するという意味です。

   歴史的な経緯により、POSITIONは異なる関数において実装が統一されていま
せん。‘completing-read’ではPOSITIONの値は0基準です。つまり、値0は文字列
の先頭で、1は最初の文字の次、...を意味します。しかし‘read-minibuffer’、
およびこの引数をサポートする補完を行わない他のミニバッファー入力関数では
、1は文字列の先頭、2は最初の文字の次、...を意味します。

   INITIALの値としてのコンスセルの使用は、推奨されません。


File: elisp,  Node: Completion,  Next: Yes-or-No Queries,  Prev: Initial Input,  Up: Minibuffers

19.6 Completion
===============

“補完(complete, ompletion)”は省略された形式から始まる名前の残りを充填す
る機能です。補完はユーザー入力と有効な名前リストを比較して、ユーザーが何
をタイプしたかで名前をどの程度一意に判定できるか判断することにより機能し
ます。たとえば‘C-x b’(‘switch-to-buffer’)とタイプしてから、スイッチした
いバッファー名の最初の数文字をタイプして、その後に
<TAB>(‘minibuffer-complete’)をタイプすると、Emacsはその名前を可能な限り
展開します。

   標準的なEmacsコマンドはシンボル、ファイル、バッファー、プロセスの名前
にたいして補完を提案します。このセクションの関数により、他の種類の名前に
たいしても補完を実装できます。

   ‘try-completion’関数は補完にたいする基本的なプリミティブです。これは
初期文字列にたいして文字列セットをマッチして、最長と判定された補完をリタ
ーンします。

   関数‘completing-read’は、補完にたいする高レベルなインターフェイスを提
供します。‘completing-read’の呼び出しにより、有効な名前リストの判定方法
が指定されます。その後にこの関数は補完にたいして有用ないくつかのコマンド
にキーバインドするローカルキーマップとともに、ミニバッファーをアクティブ
化します。その他の関数は、特定の種類の名前を補完つきで読み取る、簡便なイ
ンターフェイスを提供します。

* Menu:

* Basic Completion::         文字列を補完する低レベル関数。
* Minibuffer Completion::    補完つきでミニバッファーを呼び出す。
* Completion Commands::      補完を行うミニバッファーコマンド。
* High-Level Completion::    特別なケースに有用な補完(バッファー名や変数名などの読み取り)。
* Reading File Names::       ファイル名やシェルコマンドの読み取りに補完を使用する。
* Completion Variables::     補完の挙動を制御する変数。
* Programmed Completion::    独自の補完関数を記述する。
* Completion in Buffers::    通常バッファー内でのテキスト補完。


File: elisp,  Node: Basic Completion,  Next: Minibuffer Completion,  Up: Completion

19.6.1 Basic Completion Functions
---------------------------------

以下の補完関数は、その関数自身ではミニバッファーでなにも行いません。ここ
では、ミニバッファーを使用する高レベルの補完機能と並べて、これらの関数に
ついて説明します。

 -- Function: try-completion string collection &optional predicate
     この関数はCOLLECTION内のSTRINGに利用可能なすべての補完の、共通する
     最長部分文字列をリターンする。

     COLLECTIONは“補完テーブル(completion table)”と呼ばれる。値は文字列
     リスト、コンスセル、obarray、ハッシュテーブル、または補完関数でなけ
     ればならない。

     ‘try-completion’は補完テーブルにより指定された許容できる補完それぞ
     れにたいして、STRINGと比較を行う。許容できる補完マッチが存在しない
     場合は、‘nil’をリターンする。マッチする補完が1つだけで、それが完全
     一致ならば‘t’をリターンする。それ以外は、すべてのマッチ可能な補完に
     共通する最長の初期シーケンス(longest initial sequence)をリターンす
     る。

     COLLECTIONがリストの場合、許容できる補完(permissible completions)は
     そのリストの要素により指定される。リストの要素は文字列、またはCARが
     文字列または(‘symbol-name’により文字列に変換される)シンボルであるよ
     うなコンスセルである。リストに他の型の要素が含まれる場合は無視され
     る。

     COLLECTIONがobarray(*note Creating Symbols::を参照)の場合、その
     obarray内のすべてのシンボル名が許容できる補完セットを形成する。

     COLLECTIONがハッシュテーブルの場合には、文字列のキーが利用可能な補
     完(possible completions)になる。他のキーは無視される。

     COLLECTIONとして関数を使用することもできる。この場合、この関数だけ
     が補完を処理する役目を担う。つまり‘try-completion’は、この関数が何
     をリターンしようとも、それをリターンする。この関数はSTRING、
     PREDICATE、‘nil’の3つの引数で呼び出される(3つ目の引数は同じ関数を
     ‘all-completions’でも使用して、どちらの場合でも適切なことを行うため
     である)。*note Programmed Completion::を参照のこと。

     引数PREDICATEが非‘nil’の場合、COLLECTIONがハッシュテーブルなら1引数
     、それ以外は2引数の関数でなければならない。これは利用可能なマッチの
     テストに使用され、マッチはPREDICATEが非‘nil’をリターンしたときだけ
     受け入れられる。PREDICATEに与えられる引数は文字列、alistのコンスセ
     ル(CARが文字列)、またはobarrayのシンボル(シンボル名では_ない_)のう
     ちのどれか。COLLECTIONがハッシュテーブルの場合、PREDICATEは文字列キ
     ー(string key)と関連値(associated value)の2引数で呼び出される。

     加えて使いやすいように、補完は‘completion-regexp-list’内のすべての
     正規表現にもマッチしなければならない。(COLLECTIONが関数の場合は、そ
     の関数自身が‘completion-regexp-list’を処理する必要がある。)

     以下の例の1つ目では、文字列‘foo’がalistのうち3つのCARとマッチされて
     いる。すべてのマッチは文字‘fooba’で始まるので、それが結果となる。
     2つ目の例では、可能なマッチは1つだけで、しかも完全一致なのでリター
     ン値は‘t’になる。

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               ⇒ "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               ⇒ t

     以下の例では、文字‘forw’で始まるシンボルが多数あり、それらはすべて
     単語‘forward’で始まる。ほとんどのシンボルはその後に‘-’が続くが、す
     べてではないので‘forward’までしか補完できない。

          (try-completion "forw" obarray)
               ⇒ "forward"

     最後に、以下の例では述語‘test’に渡される利用可能なマッチは3つのうち
     2つだけである(文字列‘foobaz’は短すぎる)。これらは両方とも文字列
     ‘foobar’で始まる。

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ "foobar"

 -- Function: all-completions string collection &optional predicate
     この関数は、STRINGの利用可能な補完すべてのリストをリターンする。こ
     の関数の引数は‘try-completion’の引数と同じであり、
     ‘try-completion’が行うのと同じ方法で‘completion-regexp-list’を使用
     する。

     COLLECTIONか関数の場合はSTRING、PREDICATE、‘t’の3つの引数で呼び出さ
     れる。この場合、その関数がリターンするのが何であれ、
     ‘all-completions’はそれをリターンする。*note Programmed
     Completion::を参照のこと。

     以下の例は、‘try-completion’の例の関数‘test’を使用している。

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ ("foobar1" "foobar2")

 -- Function: test-completion string collection &optional predicate
     この関数は、STRINGがCOLLECTIONおよびPREDICATEで指定された有効な補完
     候補の場合は、‘nil’をリターンする。引数は‘try-completion’の引数と同
     じ。たとえば、COLLECTIONが文字列リストの場合は、STRINGがリスト内に
     存在し、かつPREDICATEを満足すればtrueとなる。

     この関数は‘try-completion’が行うのと同じ方法で、
     ‘completion-regexp-list’を使用する。

     PREDICATEが非‘nil’で、COLLECTIONが同じ文字列を複数含む場合には、
     ‘completion-ignore-case’にしたがって‘compare-strings’で判定して、そ
     れらすべてをリターンするか、もしくは何もリターンしない。それ以外で
     は、‘test-completion’のリターン値は基本的に予測不可能である。

     COLLECTIONが関数の場合はSTRING、PREDICATE、‘lambda’の3つの引数で呼
     び出される。それが何をリターンするにせよ、‘test-completion’はそれを
     リターンする。

 -- Function: completion-boundaries string collection predicate suffix
     この関数はポイントの前のテキストがSTRING、ポイントの後がSUFFIXと仮
     定して、COLLECTIONが扱うフィールドの境界(boundary)をリターンする。

     補完は通常、文字列(string)全体に作用するので、すべての普通のコレク
     ション(collection)にたいして、この関数は常に‘(0 . (length
     SUFFIX))’をリターンするだろう。しかしファイルにたいする補完などのよ
     り複雑な補完は、1回に1フィールド行われる。たとえば、たとえ
     ‘"/usr/share/doc"’が存在しても、‘"/usr/sh"’の補完に
     ‘"/usr/share/"’は含まれるが、‘"/usr/share/doc"’は含まれないだろう。
     また、‘"/usr/sh"’にたいする‘all-completions’に‘"/usr/share/"’は含ま
     れず、‘"share/"’だけが含まれるだろう。STRINGが‘"/usr/sh"’、SUFFIXが
     ‘"e/doc"’の場合、‘completion-boundaries’は‘(5 . 1)’をリターンするだ
     ろう。これは、COLLECTIONが‘"/usr/"’の後ろにあり‘"/doc"’の前にある領
     域に関する補完情報だけをリターンするであろうことを告げている。

   補完alistを変数に格納した場合は、変数の‘risky-local-variable’プロパテ
ィに非‘nil’をセットして、その変数が“risky(危険)”だとマークすべきである。
*note File Local Variables::を参照のこと。

 -- Variable: completion-ignore-case
     この変数の値が非‘nil’の場合、補完での大文字小文字の違いは意味をもた
     ない。‘read-file-name’では、この変数は
     ‘read-file-name-completion-ignore-case’(*note Reading File Names::を
     参照)にオーバーライドされる。‘read-buffer’では、この変数は
     ‘read-buffer-completion-ignore-case’(*note High-Level Completion::を
     参照)にオーバーライドされる。

 -- Variable: completion-regexp-list
     これは正規表現のリストである。補完関数はこのリスト内のすべての正規
     表現にマッチした場合のみ許容できる補完と判断する。
     ‘case-fold-search’(*note Searching and Case::を参照)では
     ‘completion-ignore-case’の値にバインドされる。

 -- Macro: lazy-completion-table var fun
     この変数は変数VARを補完のためのcollectionとしてlazy(lazy: 力のない
     、だらけさせる、のろのろした、怠惰な、不精な、眠気を誘う)な方法で初
     期化する。ここでlazyとは、collection内の実際のコンテンツを必要にな
     るまで計算しないという意味。このマクロはVARに格納する値の生成に使用
     する。VARを使用して最初に補完を行ったとき、真の値が実際に計算される
     。これは引数なしでFUNを呼び出すことにより行われる。FUNがリターンす
     る値は、VARの永続的な値となる。

     以下は例である:

          (defvar foo (lazy-completion-table foo make-my-alist))

   既存の補完テーブルを受け取り変更したバージョンをリターンする関数が、
いくつかあります。‘completion-table-case-fold’は大文字小文字を区別しない
、case-insensitiveなテーブルをリターンします。
‘completion-table-in-turn’と‘completion-table-merge’は、複数の入力テーブ
ルを、異なる方法で組み合わせます。‘completion-table-subvert’はテーブルを
異なる初期プレフィックス(initial prefix)で変更します。
‘completion-table-with-quoting’はクォートされたテキストの処理に適したテ
ーブルをリターンします。‘completion-table-with-predicate’は述語関数
(predicate function)によりフィルターします。
‘completion-table-with-terminator’は終端文字列(terminating string)を追加
します。


File: elisp,  Node: Minibuffer Completion,  Next: Completion Commands,  Prev: Basic Completion,  Up: Completion

19.6.2 Completion and the Minibuffer
------------------------------------

このセクションでは、補完つきでミニバッファーから読み取るための、基本的な
インターフェイスを説明します。

 -- Function: completing-read prompt collection &optional predicate
          require-match initial history default inherit-input-method
     この関数は、補完の提供によりユーザーを支援して、ミニバッファーから
     文字列を読み取る。PROMPT(文字列でなければならない)のプロンプトとと
     もに、ミニバッファーをアクティブ化する。

     実際の補完は、補完テーブルCOLLECTIONと補完述語PREDICATEを関数
     ‘try-completion’(*note Basic Completion::を参照)に渡すことにより行
     われる。これは補完の使用されるローカルキーマップに特定のコマンドを
     バインドしたとき発生する。これらのコマンドのいくつかは、
     ‘test-completion’も呼び出す。したがって、PREDICATEが非‘nil’の場合は
     、COLLECTIONと‘completion-ignore-case’が矛盾しないようにすべきであ
     る。*note Definition of test-completion::を参照のこと。

     オプション引数REQUIRE-MATCHの値は、ユーザーがミニバッファーをexitす
     る方法を決定する。

        • ‘nil’の場合、通常のミニバッファーexitコマンドは、ミニバッファ
          ーの入力と無関係に機能する。

        • ‘t’の場合は、入力がCOLLECTIONの要素に補完されるまで、通常のミ
          ニバッファーexitコマンドは機能しない。

        • ‘confirm’の場合、どのような入力でもユーザーはexitできるが、入
          力が‘confirm’の要素に補完されていなければ、確認を求められる。

        • ‘confirm-after-completion’の場合、どのような入力でもユーザーは
          exitできるが、前のコマンドが補完コマンド(たとえば
          ‘minibuffer-confirm-exit-commands’の中のコマンドの1つの場合)で
          、入力の結果がCOLLECTIONの要素でない場合は、確認を求められる。
          *note Completion Commands::を参照のこと。

        • REQUIRE-MATCHにたいする他の値は‘t’と同じふぁが、exitコマンドは
          補完処理中はexitしない。

     しかし、REQUIRE-MATCHの値に関わらず、空の入力は常に許される。この場
     合、‘completing-read’はDEFAULTがリストなら最初の要素、DEFAULTが
     ‘nil’なら‘""’、またはDEFAULTをリターンする。文字列およびDEFAULT内の
     文字列は、ヒストリーコマンドを通じてユーザーが利用できる。

     関数‘completing-read’はREQUIRE-MATCHが‘nil’の場合はキーマップとして
     ‘minibuffer-local-completion-map’を、REQUIRE-MATCHが非‘nil’の場合は
     ‘minibuffer-local-must-match-map’を使用する。*note Completion
     Commands::を参照のこと。

     引数HISTORYは入力の保存とミニバッファーヒストリーコマンドに、どのヒ
     ストリーリスト変数を使用するか指定する。デフォルトは
     ‘minibuffer-history’。*note Minibuffer History::を参照のこと。

     INITIALは、ほとんどの場合推奨されない。HISTORYにたいするコンスセル
     指定と組み合わせた場合のみ、非‘nil’値の使用を推奨する。*note
     Initial Input::を参照のこと。デフォルト入力にたいしては、かわりに
     DEFAULTを使用する。

     引数INHERIT-INPUT-METHODが非‘nil’の場合には、ミニバッファーにエンタ
     ーする前にカレントだったバッファーが何であれ、カレントのインプット
     メソッド(*note Input Methods::を参照)、および
     ‘enable-multibyte-characters’のセッティング(*note Text
     Representations::を参照)が継承される。

     変数‘completion-ignore-case’が非‘nil’の場合、利用可能なマッチにたい
     して入力を比較するときの補完は、大文字小文字を区別しない。*note
     Basic Completion::を参照のこと。このモードでの操作では、PREDICATEも
     大文字小文字を区別してはならない(さもないと驚くべき結果となるであろ
     う)。

     以下は‘completing-read’を使用した例である:

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; 前の式を評価後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo★
          ---------- Buffer: Minibuffer ----------

     その後ユーザーが‘<DEL> <DEL> b <RET>’をタイプすると、
     ‘completing-read’は‘barfoo’をリターンする。

     ‘completing-read’関数は、実際に補完を行うコマンドの情報を渡すために
     、変数をバインドする。これらの変数は、以降のセクションで説明する。

 -- Variable: completing-read-function
     この変数の値は関数でなければならず、補完つきの読み取りを実際に行う
     ために‘completing-read’から呼び出される。この関数は
     ‘completing-read’と同じ引数を受け入れる。他の関数のバインドして、通
     常の‘completing-read’の振る舞いを完全にオーバーライドすることができ
     る。


File: elisp,  Node: Completion Commands,  Next: High-Level Completion,  Prev: Minibuffer Completion,  Up: Completion

19.6.3 Minibuffer Commands that Do Completion
---------------------------------------------

このセクションでは、補完のためにミニバッファーで使用されるキーマップ、コ
マンド、ユーザーオプションを説明します。

 -- Variable: minibuffer-completion-table
     この変数の値は、ミニバッファー内の補完に使用される補完テーブルであ
     る。これは‘completing-read’が‘try-completion’に渡す補完テーブルを含
     むグローバル変数である。‘minibuffer-complete-word’のような、ミニバ
     ッファー補完コマンドにより使用される。

 -- Variable: minibuffer-completion-predicate
     この変数の値は‘completing-read’が‘try-completion’に渡す述語
     (predicate)である。この変数は、他のミニバッファー補完関数でも使用さ
     れる。

 -- Variable: minibuffer-completion-confirm
     この変数はミニバッファーをexitする前に、Emacsが確認を求めるかどうか
     を決定する。‘completing-read’はこの変数をバインドして、exitする前に
     関数‘minibuffer-complete-and-exit’がこの値をチェックする。値が
     ‘nil’の場合は、確認は求められない。値が‘confirm’の場合、入力が有効
     な補完候補でなくてもユーザーはexitするかもしれないが、Emacsは確認を
     求めない。値が‘confirm-after-completion’の場合、入力が有効な補完候
     補でなくてもユーザーはexitするかもしれないが、ユーザーが
     ‘minibuffer-confirm-exit-commands’内の任意の補完コマンドの直後に入
     力を確定した場合、Emacsは確認を求める。

 -- Variable: minibuffer-confirm-exit-commands
     この変数には、‘completing-read’の引数REQUIRE-MATCHが
     ‘confirm-after-completion’の場合は、ミニバッファーをexitする前に
     Emacsが確認を求めるようにさせるコマンドのリストが保持されている。こ
     のリストないのコマンドを呼び出した直後にユーザーがミニバッファーの
     exitを試みると、Emacsは確認を求める。

 -- Command: minibuffer-complete-word
     この関数は、ただ1つの単語からミニバッファーを補完する。たとえミニバ
     ッファーのコンテンツが1つの補完しかもたない場合でも、
     ‘minibuffer-complete-word’はその単語に属さない最初の文字を超えた追
     加はしない。*note Syntax Tables::を参照のこと。

 -- Command: minibuffer-complete
     この関数は、可能な限りミニバッファーのコンテンツを補完する。

 -- Command: minibuffer-complete-and-exit
     この関数はミニバッファーのコンテンツを補完して、確認が要求されない
     場合(たとえば‘minibuffer-completion-confirm’が‘nil’のとき)はexitす
     る。確認が_要求される_場合には、このコマンドを即座に繰り返すことに
     より確認が行われないようにする。このコマンドは2回連続で実行された場
     合は確認なしで機能するようにプログラムされている。

 -- Command: minibuffer-completion-help
     この関数は、カレントのミニバッファーのコンテンツで利用可能な補完の
     リストを作成する。これは‘all-completions’の引数COLLECTIONに変数
     ‘minibuffer-completion-table’の値を、引数PREDICATEに
     ‘minibuffer-completion-predicate’の値を使用して呼び出すことにより機
     能する。補完リストは、‘*Completions*’と呼ばれるバッファーのテキスト
     として表示される。

 -- Function: display-completion-list completions
     この関数は‘standard-output’内のストリーム(通常はバッファー)に
     COMPLETIONSを表示する(ストリームについての詳細は、*note Read and
     Print::を参照)。引数COMPLETIONSは通常、‘all-completions’がリターン
     する補完リストそのものだが、それである必要はない。要素はシンボルか
     文字列で、どちらも単にプリントされる。文字列2つのリストでもよく、
     2つの文字列が結合されたかのようにプリントされる。この場合、1つ目の
     文字列は実際の補完で、2つ目の文字列は注釈の役目を負う。

     この関数は‘minibuffer-completion-help’により呼び出される。一般的に
     は、以下のように‘with-output-to-temp-buffer’とともに使用される。

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     この変数が非‘nil’の場合には、次の文字が一意でないために決定できず補
     完が完了しないときは常に、補完コマンドは利用可能な補完リストを自動
     的に表示する。

 -- Variable: minibuffer-local-completion-map
     ‘completing-read’の値は、補完の1つが完全に一致することを要求されな
     いときにローカルキーマップとして使用される。デフォルトでは、このキ
     ーマップは以下のバインディングを作成する:

     ‘?’
          ‘minibuffer-completion-help’

     <SPC>
          ‘minibuffer-complete-word’

     <TAB>
          ‘minibuffer-complete’

     親キーマップとして‘minibuffer-local-map’を使用する(*note Definition
     of minibuffer-local-map::を参照)。

 -- Variable: minibuffer-local-must-match-map
     ‘completing-read’は、補完の1つの完全な一致が要求されないときのロー
     カルキーマップとして、この値を使用する。したがって
     ‘exit-minibuffer’にキーがバインドされていなければ、無条件にミニバッ
     ファーをexitする。デフォルトでは、このキーマップは以下のバインディ
     ングを作成する:

     ‘C-j’
          ‘minibuffer-complete-and-exit’

     <RET>
          ‘minibuffer-complete-and-exit’

     親キーマップは‘minibuffer-local-completion-map’を使用する。

 -- Variable: minibuffer-local-filename-completion-map
     これは単に<SPC>を非バインドするsparseキーマップ(sparse: 疎、希薄、
     まばら)を作成する。これはファイル名にスペースを含めることができるか
     らである。関数‘read-file-name’は、このキーマップと
     ‘minibuffer-local-completion-map’か
     ‘minibuffer-local-must-match-map’のいずれかを組み合わせる。


File: elisp,  Node: High-Level Completion,  Next: Reading File Names,  Prev: Completion Commands,  Up: Completion

19.6.4 High-Level Completion Functions
--------------------------------------

このセクションでは、特定の種類の名前を補完つきで読み取る便利な高レベル関
数を説明します。

   ほとんどの場合、Lisp関数の中盤でこれらの関数を呼び出すべきではありま
せん。可能なときは、‘interactive’指定の内部で呼び出し、ミニバッファーの
すべての入力をコマンドの引数読み取りの一部にします。*note Defining
Commands::を参照してください。

 -- Function: read-buffer prompt &optional default require-match
     この関数はバッファーの名前を読み取り、それを文字列でリターンする。
     引数DEFAULTは、ミニバッファーが空の状態でユーザーがexitした場合にリ
     ターンされるデフォルト名として使用される。非‘nil’の場合は文字列、文
     字列リスト、またはバッファーを指定する。リストの場合は、リストの先
     頭の要素がデフォルト値になる。デフォルト値はプロンプトに示されるが
     、初期入力としてミニバッファーには挿入されない。

     引数PROMPTは、コロンかスペースで終わる文字列である。DEFAULTが非
     ‘nil’の場合、この関数はデフォルト値つきでミニバッファーから読み取る
     際の慣習にしたがい、コロンの前のPROMPTの中にこれを挿入する。

     オプション引数REQUIRE-MATCHは、‘completing-read’のときと同じ。*note
     Minibuffer Completion::を参照のこと。

     以下の例で、ユーザーが‘minibuffer.t’とエンターしてから、<RET>をタイ
     プする。引数REQUIRE-MATCHは‘t’であり、与えられた入力で始まるバッフ
     ァー名は‘minibuffer.texi’だけなので、その名前が値となる。

          (read-buffer "Buffer name: " "foo" t)
          ;; 前の式を評価した後、
          ;;   空のミニバッファーに
          ;;   以下のプロンプトが表示される:

          ---------- Buffer: Minibuffer ----------
          Buffer name (default foo): ★
          ---------- Buffer: Minibuffer ----------

          ;; ユーザーが‘minibuffer.t <RET>’とタイプする。
               ⇒ "minibuffer.texi"

 -- User Option: read-buffer-function
     この変数が非‘nil’の場合は、バッファー名を読み取る関数である。
     ‘read-buffer’は通常行うことを行うかわりに、‘read-buffer’と同じ引数
     でその関数を呼び出す。

 -- User Option: read-buffer-completion-ignore-case
     この変数が非non-‘nil’の場合は、補完の処理において‘read-buffer’は大
     文字小文字を無視する。

 -- Function: read-command prompt &optional default
     この関数はコマンドの名前を読み取り、Lispシンボルとしてそれをリター
     ンする。引数PROMPTは、‘read-from-minibuffer’で使用される場合と同じ
     。それが何であれ‘commandp’が‘t’をリターンすればコマンドであり、コマ
     ンド名とは‘commandp’が‘t’をリターンするシンボルだということを思い出
     してほしい。*note Interactive Call::を参照のこと。

     引数DEFAULTは、ユーザーがnull入力をエンターした場合に何をリターンす
     るか指定する。シンボル、文字列、文字列リストを指定できる。文字列の
     場合、‘read-command’はリターンする前にそれをinternする。リストの場
     合、‘read-command’はリストの最初の要素をinternする。DEFAULTが
     ‘nil’の場合は、デフォルトが指定されなかったことを意味する。その場合
     もしユーザーがnull入力をエンターすると、リターン値は‘(intern "")’、
     つまり名前が空文字列のシンボルとなる。

          (read-command "Command name? ")

          ;; 前の式を評価した後に、
          ;;   空のミニバッファーに以下のプロンプトが表示される:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     ユーザーが‘forward-c <RET>’とタイプした場合、この関数は
     ‘forward-char’をリターンする。

     ‘read-command’関数は、‘completing-read’の簡略化されたインターフェイ
     スである。実在するLisp変数のセットを補完するために変数‘obarray’を、
     コマンド名だけを受け入れるために述語‘commandp’を使用する。

          (read-command PROMPT)
          ≡
          (intern (completing-read PROMPT obarray
                                   'commandp t nil))

 -- Function: read-variable prompt &optional default
     この変数はカスタマイズ可能な変数の名前を読み取り、それをシンボルと
     してリターンする。引数の形式は‘read-command’の引数と同じ。この関数
     は、‘commandp’のかわりに‘custom-variable-p’を述語に使用する点を除き
     、‘read-command’と同様に振る舞う。

 -- Command: read-color &optional prompt convert allow-empty display
     この関数はカラー指定(カラー名、または‘#RRRGGGBBB’のような形式の
     RGB16進値)の文字列を読み取る。これはプロンプトにPROMPT(デフォルトは
     ‘"Color (name or #RGB triplet):"’)を表示して、カラー名にたいする補
     完を提供する(16進RGB値は補完しない)。標準的なカラー名に加えて、補完
     候補にはポイント位置のフォアグラウンドカラーとバックグラウンドカラ
     ーが含まれる。

     Valid RGB values are described in *note Color Names::.

     この関数のリターン値は、ミニバッファー内でユーザーがタイプした文字
     列である。しかし、インタラクティブに呼び出されたとき、またはオプシ
     ョン引数CONVERTが非‘nil’の場合は、入力されたカラー名のかわりに、そ
     れに対応するRGB値文字列をリターンする。この関数は、入力に有効なカラ
     ー指定を求める。ALLOW-EMPTYが非‘nil’でユーザーがnull入力をエンター
     した場合は、空のカラー名が許される。

     インタラクティブに呼び出されたとき、またはDISPLAYが非‘nil’の場合に
     は、エコーエリアにもリターン値が表示される。

   *note User-Chosen Coding Systems::の関数‘read-coding-system’と
‘read-non-nil-coding-system’、および*note Input Methods::の
‘read-input-method-name’も参照のこと。


File: elisp,  Node: Reading File Names,  Next: Completion Variables,  Prev: High-Level Completion,  Up: Completion

19.6.5 Reading File Names
-------------------------

高レベル補完関数‘read-file-name’、‘read-directory-name’、
‘read-shell-command’はそれぞれ、ファイル名、ディレクトリー名、シェルコマ
ンドを読み取るようデザインされています。これらはデフォルトディレクトリー
の自動挿入を含む特別な機能を提供します。

 -- Function: read-file-name prompt &optional directory default
          require-match initial predicate
     この関数はプロンプトPROMPTとともに補完つきでファイル名を読み取る。

     例外として以下のすべてが真ならば、この関数はミニバッファーのかわり
     にグラフィカルなファイルダイアログを使用してファイル名を読み取る:

       1. マウスコマンドを通じて呼び出された。

       2. グラフィカルなディスプレイ上の選択されたフレームがこの種のダイ
          アログをサポートする。

       3. 変数‘use-dialog-box’が非‘nil’の場合。*note Dialog Boxes:
          (emacs)Dialog Boxes.を参照のこと。

       4. DIRECTORY引数(以下参照)がリモートファイルを指定しない。*note
          Remote Files: (emacs)Remote Files.を参照のこと。

     グラフィカルなファイルダイアログを使用したときの正確な振る舞いは、
     プラットホームに依存する。ここでは単にミニバッファーを使用したとき
     の振る舞いを記す。

     ‘read-file-name’はリターンするファイル名を自動的に展開しない。絶対
     ファイル名が必要ならば、自分で‘expand-file-name’を呼び出さなければ
     ならない。

     オプション引数REQUIRE-MATCHは、‘completing-read’のときと同じ。*note
     Minibuffer Completion::を参照のこと。

     引数DIRECTORYは、相対ファイル名の補完に使用するディレクトリーを指定
     する。値は絶対ディレクトリー名。変数‘insert-default-directory’が非
     ‘nil’の場合は、初期入力としてミニバッファーにDIRECTORYも挿入される
     。デフォルトはカレントバッファーの‘default-directory’の値。

     INITIALを指定した場合、それはミニバッファーに挿入する初期ファイル名
     になる(DIRECTORYが挿入された場合はその後に挿入される)。この場合、ポ
     イントはINITIALの先頭に配される。INITIALのデフォルト値は‘nil’(ファ
     イル名を挿入しない)。INITIALが何を行うか確認するには、ファイルを
     visitしているバッファーで‘C-x C-v’を試すとよい。*注意: ほとんどの場
     合、*INITIALよりもDEFAULTの使用を推奨する。

     DEFAULTが非‘nil’の場合、ユーザーが最初に‘read-file-name’が挿入した
     ものと同じ、空以外のコンテンツを残してミニバッファーをexitすると、
     この関数はDEFAULTをリターンする。‘insert-default-directory’が非
     ‘nil’の場合はそれがデフォルトとなるので、ミニバッファーの初期コンテ
     ンツは常に空以外になる。REQUIRE-MATCHの値に関わらず、DEFAULTの有効
     性はチェックされない。とはいえREQUIRE-MATCHが非‘nil’の場合、ミニバ
     ッファーの初期コンテンツは有効なファイル名(またはディレクトリー名
     )であるべきだろう。それが有効でない場合、ユーザーがそれを編集せずに
     exitすると‘read-file-name’は補完を試み、DEFAULTはリターンされない。
     DEFAULTはヒストリーコマンドからも利用できる。

     DEFAULTが‘nil’の場合、‘read-file-name’はその場所に代用するデフォル
     トを探そうと試みる。この代用デフォルトは、明示的にDEFAULTにそれが指
     定されたかのように、DEFAULTとまったく同じ方法で扱われる。DEFAULTが
     ‘nil’でもINITIALが非‘nil’の場合、デフォルトはDIRECTORYとINITIALから
     得られる絶対ファイル名になる。DEFAULTとINITIALの両方が‘nil’で、その
     バッファーがファイルをvisitしているバッファーの場合、
     ‘read-file-name’はそのファイルの絶対ファイル名をデフォルトとして使
     用する。バッファーがファイルをvisitしていなければ、デフォルトは存在
     しない。この場合、ユーザーが編集せずに<RET>をタイプすると、
     ‘read-file-name’は前にミニバッファーに挿入されたコンテンツを単にリ
     ターンする。

     空のミニバッファー内でユーザーが<RET>をタイプした場合、この関数は
     REQUIRE-MATCHの値に関わらず、空の文字列をリターンする。たとえばユー
     ザーが‘M-x set-visited-file-name’を使用して、カレントバッファーをフ
     ァイルをvisitしていないことにするのに、この方法を使用している。

     PREDICATEが非‘nil’の場合、それは補完候補として許容できるファイル名
     を決定する、1引数の関数である。PREDICATEが関数名にたいして非‘nil’を
     リターンすれば、それはファイル名として許容できる値である。

     以下は‘read-file-name’を使用した例である:

          (read-file-name "The file is ")

          ;; 前の式を評価した後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/★
          ---------- Buffer: Minibuffer ----------

     ‘manual <TAB>’をタイプすると以下がリターンされる:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi★
          ---------- Buffer: Minibuffer ----------

     ここでユーザーが<RET>をタイプすると、‘read-file-name’は文字列
     ‘"/gp/gnu/elisp/manual.texi"’をファイル名としてリターンする。

 -- Variable: read-file-name-function
     非‘nil’の場合は、‘read-file-name’と同じ引数を受け取る関数である。
     ‘read-file-name’が呼び出されたとき、‘read-file-name’は通常の処理を
     行なうかわりに、与えられた引数でこの関数を呼び出す。

 -- User Option: read-file-name-completion-ignore-case
     この変数が非‘nil’の場合、‘read-file-name’は補完を行なう際に大文字小
     文字を無視する。

 -- Function: read-directory-name prompt &optional directory default
          require-match initial
     この関数は‘read-file-name’と似ているが、補完候補としてディレクトリ
     ーだけを許す。

     DEFAULTが‘nil’でINITIALが非‘nil’の場合、‘read-directory-name’は
     DIRECTORY(DIRECTORYが‘nil’ならカレントバッファーのデフォルトディレ
     クトリー)とINITIALを組み合わせて代替えのデフォルトを構築する。
     DEFAULTとINITIALの両方が‘nil’の場合、この関数はDIRECTORY、
     DIRECTORYも‘nil’の場合はカレントバッファーのデフォルトディレクトリ
     ーを代替えのデフォルトとして使用する。

 -- User Option: insert-default-directory
     この変数は‘read-file-name’により使用されるため、ファイル名を読み取
     るほとんどのコマンドにより、間接的に使用される。(これらのコマンドに
     はコマンドのインタラクティブフォームに‘f’や‘F’のコードレター(code
     letter))をふくむすべてのコマンドが含まれる。*note Code Characters
     for interactive: Interactive Codes.を参照のこと。)この変数の値は、
     (もしあれば)デフォルトディレクトリー名をミニバッファー内に配して
     ‘read-file-name’を開始するかどうかを制御する。変数の値が‘nil’の場合
     、‘read-file-name’はミニバッファーに初期入力を何も配さない(ただし
     INITIAL引数で初期入力を指定しない場合)。この場合、依然としてデフォ
     ルトディレクトリーが相対ファイル名の補完に使用されるが、表示はされ
     ない。

     この変数が‘nil’でミニバッファーの初期コンテンツが空の場合、ユーザー
     はデフォルト値にアクセスするために次のヒストリー要素を明示的にフェ
     ッチする必要があるだろう。この変数が非‘nil’ならミニバッファーの初期
     コンテンツは常に空以外となり、ミニバッファーで編集をおこなわず即座
     に<RET>をタイプすることにより、常にデフォルト値を要求できる(上記参
     照)。

     たとえば:

          ;; デフォルトディレクトリーとともにミニバッファーが開始。
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/★
          ---------- Buffer: Minibuffer ----------

          ;; ミニバッファーはプロンプトだけで空。
          ;;   appears on its line.
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ★
          ---------- Buffer: Minibuffer ----------

 -- Function: read-shell-command prompt &optional initial history &rest
          args
     この関数は、プロンプトPROMPTと優れた補完を提供して、ミニバッファー
     からのシェルコマンドを読み取る。これはコマンド名にたいして適切な候
     補を使用してコマンドの最初の単語を補完する。コマンドの残りの単語は
     ファイル名として補完する。

     この関数はミニバッファー入力にたいするキーマップとして
     ‘minibuffer-local-shell-command-map’を使用する。HISTORY引数は使用す
     るヒストリーリストを指定する。省略、または‘nil’の場合のデフォルトは
     ‘shell-command-history’(*note shell-command-history: Minibuffer
     History.を参照)。オプション引数INITIALはミニバッファーの初期コンテ
     ンツを指定する(*note Initial Input::を参照)。もしあれば、残りの
     ARGSは‘read-from-minibuffer’内のDEFAULTおよびINHERIT-INPUT-METHODと
     して使用される(*note Text from Minibuffer::を参照)。

 -- Variable: minibuffer-local-shell-command-map
     このキーマップは‘read-shell-command’により、コマンドおよびシェルコ
     マンドの一部となるファイル名の補完のために使用される。これは親キー
     マップとして‘minibuffer-local-map’を使用し、<TAB>を
     ‘completion-at-point’にバインドする。

