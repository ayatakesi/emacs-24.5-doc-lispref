This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Completion Variables,  Next: Programmed Completion,  Prev: Reading File Names,  Up: Completion

19.6.6 Completion Variables
---------------------------

補完のデフォルト動作を変更するために使用される変数がいくつかあります。

 -- User Option: completion-styles
     この変数の値は、補完を行うために使用される補完スタイル(シンボル)で
     ある。“補完スタイル(completion style)”とは、補完を生成するためのル
     ールセットのこと。このリストにあるシンボルはそれぞれ、
     ‘completion-styles-alist’内に対応するエントリーをもたなければならな
     い。

 -- Variable: completion-styles-alist
     この変数には補完スタイルのリストが格納される。リスト内の各要素は以
     下の形式をもつ

          (STYLE TRY-COMPLETION ALL-COMPLETIONS DOC)

     ここでSTYLEは補完スタイルの名前(シンボル)であり、そのスタイルを参照
     するために変数‘completion-styles’内で使用されるかもしれない。
     TRY-COMPLETIONは補完を行なう関数で、ALL-COMPLETIONS補完をリストする
     関数、DOC補完スタイルを説明する文字列である。

     関数TRY-COMPLETIONおよびALL-COMPLETIONSはSTRING、COLLECTION、
     PREDICATE、POINTの4つの引数をとる。引数STRING、COLLECTION、
     PREDICATEの意味は‘try-completion’(*note Basic Completion::を参照)の
     ときと同様。引数POINTはSTRING内のポイント位置。各関数は自身の処理を
     行った場合は非‘nil’を、行わなかった場合(たとえば補完スタイルに一致
     するようにSTRINGを行う方法がない場合)は‘nil’をリターンする。

     ユーザーが‘minibuffer-complete’(*note Completion Commands::を参照
     )のような補完コマンドを呼び出すと、Emacsは‘completion-styles’に最初
     にリストされたスタイルを探して、そのスタイルのTRY-COMPLETION関数を
     呼び出す。この関数が‘nil’をリターンした場合、Emacsは次にリストされ
     た補完スタイルに移動してそのスタイルのTRY-COMPLETION関数を呼び出す
     といったように、TRY-COMPLETION関数の1つが補完の処理に成功して非
     ‘nil’値をリターンするまで順次これを行なう。同様の手順は
     ALL-COMPLETIONS関数を通じて、補完のリストにも行われる。

     利用できる補完スタイルについては*note (emacs)Completion Styles::を
     参照のこと。

 -- User Option: completion-category-overrides
     この変数は特別な補完スタイルと、特定の種類のテキスト補完時に使用す
     るその他の補完動作を指定する。この変数の値は‘(CATEGORY . ALIST)’と
     いう形式の要素をもつalistである。CATEGORYは何が補完されるかを記述す
     るシンボルで、現在のところカテゴリーに‘buffer’、‘file’、
     ‘unicode-name’が定義されているが、これに特化した補完関数(*note
     Programmed Completion::を参照)を通じて他のカテゴリーを定義できる。
     ALISTは、そのカテゴリーにたいして補完がどのように振る舞うべきかを記
     述する連想リスト。以下のalistのキーがサポートされる:

     ‘styles’
          値は補完スタイル(シンボル)のリスト。

     ‘cycle’
          値はそのカテゴリーにたいする‘completion-cycle-threshold’(*note
          (emacs)Completion Options::を参照)の値。

     将来、さらにalistエントリーが定義されるかもしれない。

 -- Variable: completion-extra-properties
     この変数はカレント補完コマンドの特別なプロパティの指定に使用される
     。この変数は補完に特化したコマンドによりletバインドされることを意図
     している。値はプロパティ/値ペアーのリスト。以下のプロパティがサポー
     トされる:

     ‘:annotation-function’
          値は補完バッファー内に注釈(annotation)を加える関数。この関数は
          引数completionを1つ受け取り‘nil’、または補完の隣に表示する文字
          列をリターンしなければならない。

     ‘:exit-function’
          値は補完を行った後に実行する関数。この関数は2つの引数STRINGと
          STATUSを受け取る。STRINGは補完されたフィールドのテキストで、
          STATUSは行われた操作の種類を示す。操作の種類は、テキストの補完
          が完了したなら‘finished’、それ以上補完できないが補完が完了して
          いなければ‘sole’、有効な補完だがさらに補完できるときは
          ‘exact’となる。


File: elisp,  Node: Programmed Completion,  Next: Completion in Buffers,  Prev: Completion Variables,  Up: Completion

19.6.7 Programmed Completion
----------------------------

意図した利用可能な補完のすべてを含むalistまたはobarrayを前もって作成する
のが不可能または不便なことがあります。このような場合は、与えられた文字列
にたいする補完を計算する独自の関数を提供できます。これは“プログラム補完
(programmed completion)”と呼ばれます。Emacsは数あるケースの中でも特に、
ファイル名の補完(*note File Name Completion::を参照)でプログラム補完を使
用しています。

   この機能を使用するためには、関数を‘completing-read’のCOLLECTION引数に
渡します。関数‘completing-read’はその補完関数が‘try-completion’、
‘all-completions’などの基本的な補完関数に渡されて、その関数がすべてを行
えるよう取り計らいます。

   補完関数は3つの引数を受け取ります:

   • 補完される文字列。

   • 利用可能なマッチをフィルターする述語関数。もしなければ‘nil’。関数は
     利用可能なマッチにたいしてこの述語(predicate)を呼び出し、述語が
     ‘nil’をリターンした場合はそのマッチを無視する。

   • 実行する補完操作のタイプを指定するフラグ。以下の4つの値のうち1つを
     指定する:

     ‘nil’
          ‘try-completion’を指定する。関数は指定された文字が一意かつ完全
          一致の場合は、‘t’をリターンする。マッチが複数の場合、すべての
          マッチに共通する部分文字列をリターンする(文字列が補完候補の1つ
          に完全一致するが、より長い他の候補にもマッチする場合、リターン
          値はその文字列)。マッチがなければ‘nil’をリターンする。

     ‘t’
          ‘all-completions’を指定する。関数は指定された文字列の利用可能
          なすべての補完のリストをリターンする。

     ‘lambda’
          ‘test-completion’を指定する。関数は指定された文字列がいくつか
          の補完候補に完全一致する場合は‘t’、それ以外は‘nil’をリターンす
          る。

     ‘(boundaries . SUFFIX)’
          ‘completion-boundaries’を指定する。関数は‘(boundaries START .
          END)’をリターンする。ここでSTARTは指定された文字列内の境界の開
          始位置、ENDはSUFFIX内の境界の終了位置。

     ‘metadata’
          カレント補完の状態に関する情報の要求を指定する。リターン値は
          ‘(metadata . ALIST)’の形式をもち、ALISTは以下で説明する要素を
          もつ連想配列。

     フラグに他の値が指定された場合、補完関数は‘nil’をリターンする。

   以下は‘metadata’フラグ引数への応答として補完関数がリターンするかもし
れない、metadataエントリーのリストです:

‘category’
     値は補完関数が補完を試みているテキストの種類を説明するシンボル。シ
     ンボルが‘completion-category-overrides’内のキーの1つにマッチする場
     合、通常の補完動作はオーバーライドされる。*note Completion
     Variables::を参照のこと。

‘annotation-function’
     値は補完に“注釈(annotation)”を付ける関数。この関数は1つの引数
     STRINGをとり、これは利用可能な補完である。リターン値は文字列で、
     ‘*Completions*’バッファー内の補完STRINGの後に表示される。

‘display-sort-function’
     値は補完をソートする関数。関数は1つの引数をとる。これは補完文字列の
     リストで、ソートされた補完文字列リストがリターンされる。その入力の
     リストは破壊的に変更することが許される。

‘cycle-sort-function’
     値は‘completion-cycle-threshold’が非‘nil’で、ユーザーが補完候補を巡
     回するときに補完をソートする関数。引数のリストとリターン値は
     ‘display-sort-function’と同様。

 -- Function: completion-table-dynamic function
     この関数はプログラム補完関数として動作する関数を記述する便利な方法
     である。引数FUNCTIONは1つの引数(文字列)をとる関数であり、その文字列
     の利用可能な補完のalistをリターンする。‘completion-table-dynamic’は
     、FUNCTIONとプログラム補完関数のインターフェイス変換器と考えること
     ができる。

 -- Function: completion-table-with-cache function &optional ignore-case
     これは前回の引数/結果ペアーを保存する‘completion-table-dynamic’にた
     いするラッパーである。これは同じ引数にたいする複数回の検査に必要な
     のは、1回のFUNCTION呼び出しだけであることを意味する。これは外部プロ
     セス呼び出しなど、処理が低速のとき有用かもしれない。


File: elisp,  Node: Completion in Buffers,  Prev: Programmed Completion,  Up: Completion

19.6.8 Completion in Ordinary Buffers
-------------------------------------

補完は通常はミニバッファー内で行われますが、補完機能は通常のEmacsバッフ
ァー内のテキストにも使用できます。多くのメジャーモードで、コマンド
‘C-M-i’または‘M-<TAB>’によりバッファー内補完が行われ、それらは
‘completion-at-point’にバインドされています。*note (emacs)Symbol
Completion::を参照してください。このコマンドはアブノーマルフック変数
‘completion-at-point-functions’を使用します:

 -- Variable: completion-at-point-functions
     このアブノーマルフックの値は関数のリストである。これらの関数はポイ
     ント位置のテキストの補完にたいする補完テーブルの計算に使用される。
     これはメジャーモードにより、モード特有な補完テーブル(*note Major
     Mode Conventions::を参照)の提供に使用できる。

     コマンド‘completion-at-point’が実行されると、引数なしでリスト内の関
     数が1つずつ呼び出される。それぞれの関数は、ポイント位置のテキストに
     たいして補完テーブルを生成できない場合は‘nil’をリターンする。生成で
     きた場合は、以下の形式のリストをリターンする

          (START END COLLECTION . PROPS)

     ここでSTARTとENDは補完する(ポイントを取り囲む)テキストの区切りであ
     る。COLLECTIONはそのテキストを補完する補完テーブルであり、
     ‘try-completion’(*note Basic Completion::を参照)の2つ目の引数として
     渡すのに適した形式である。補完候補は‘completion-styles’(*note
     Completion Variables::を参照)で定義された補完スタイルを通じ、この補
     完テーブルを通常の方法で使用して生成されるだろう。PROPSは追加の情報
     のためのプロパティリストである。‘completion-extra-properties’内のす
     べてのプロパティ(*note Completion Variables::を参照)と、以下の追加
     のプロパティが認識される:

     ‘:predicate’
          値は補完候補が満足する必要がある述語。

     ‘:exclusive’
          値が‘no’の場合は、もし補完テーブルがポイント位置のテキストのマ
          ッチに失敗したなら、補完の失敗を報告するかわりに
          ‘completion-at-point’は‘completion-at-point-functions’内の次の
          関数へ移動する。

     ‘completion-at-point-functions’内の関数も関数をリターンするかもしれ
     ない。その場合は引数なしでリターンされた関数が呼び出され、その関数
     が補完処理の全責任を負う。この方法は推奨されない。これは
     ‘completion-at-point’を使用する古いコードの救済を意図したもののだか
     らである。

     非‘nil’値を最初にリターンした‘completion-at-point-functions’内の関
     数が、‘completion-at-point’により使用される。残りの関数は呼び出され
     ない。これの例外は上述の‘:exclusive’指定があるときである。

   以下の関数は、Emacsバッファー内の任意に拡張されたテキストにたいして便
利な補完方法を提供します:

 -- Function: completion-in-region start end collection &optional
          predicate
     この関数はCOLLECTIONを使用して、カレントバッファー内の位置STARTと
     ENDの間のテキストを補完する。引数COLLECTIONは‘try-completion’(*note
     Basic Completion::を参照)のときと同じ意味をもつ。

     この関数は補完テキストを直接カレントバッファーに挿入する。
     ‘completing-read’(*note Minibuffer Completion::を参照)とは異なり、
     ミニバッファーをアクティブにしない。

     この関数が機能するためには、ポイントがSTARTとENDの間になければなら
     ない。


File: elisp,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

19.7 Yes-or-No Queries
======================

このセクションでは、ユーザーにyes-or-noの確認を求める関数を説明します。
関数‘y-or-n-p’は1文字での応答に使用できます。この関数は不注意による誤っ
た答えが深刻な結果を招かない場合に有用です。‘yes-or-no-p’は3文字から4文
字の答えを要求するので、より重大な問に適しています。

   3つの関数はどれも、マウスを使用して呼び出されたコマンド、より正確には
‘last-nonmenu-event’(*note Command Loop Info::を参照)が‘nil’かリストの場
合は、問いに答えるためにダイアログボックスまたはポップアップメニューを使
用します。それ以外の場合はキーボード入力を使用します。呼び出しの周囲で
‘last-nonmenu-event’に適切な値をバインドすることにより、マウスまたはキー
ボードの使用を強制できます。

   厳密に言うと、‘yes-or-no-p’はミニバッファーを使用し、‘y-or-n-p’は使用
しませんが、これらのコマンドは一緒に説明したほうがよいでしょう。

 -- Function: y-or-n-p prompt
     この関数はユーザーに答えを尋ねて、ミニバッファーに入力を求める。ユ
     ーザーが‘y’をタイプしたら‘t’、‘n’をタイプしたら‘nil’をリターンする
     。この関数はyesの意味で<SPC>、noの意味で<DEL>も受け入れる。“quit”の
     意味として‘C-g’と同様に‘C-]’も受け入れる。これは問いがミニバッファ
     ーのような外見をもち、ミニバッファーを抜けるためにユーザーが‘C-]’の
     使用を試みるかもしれないという理由による。応答は1文字であり、問いを
     終了させるための<RET>は必要ない。大文字と小文字は等価である。

     “答えを尋ねる”とはエコーエリアにPROMPTと、その後に文字列
     ‘(y or n) ’をプリントすることを意味する。期待される答え(‘y’、‘n’、
     ‘<SPC>’、‘<DEL>’、もしくは質問を終了するその他のキー)以外が入力され
     た場合、この関数は‘Please answer y or n.’と応答し、繰り返し答えの入
     力を要求する。

     この関数は答えの編集を許さないため、実際にミニバッファーは使用しな
     い。実際に使用するのはミニバッファーと同じスクリーンスペースを使用
     するエコーエリア(*note The Echo Area::を参照)である。問いが答えられ
     るまで、カーソルはエコーエリアに移動する。

     答えとその意味は、たとえ‘y’と‘n’であっても固定されたものではなく、
     キーマップ‘query-replace-map’により指定される(*note Search and
     Replace::を参照)。特にユーザーが‘recenter’、‘scroll-up’、
     ‘scroll-down’、‘scroll-other-window’、‘scroll-other-window-down’(そ
     れぞれ‘query-replace-map’内で‘C-l’、‘C-v’、‘M-v’、‘C-M-v’、
     ‘C-M-S-v’にバインドされている)のような特殊な応答をエンターした場合
     、この関数はは指定されたウィンドウの再センタリングやスクロール操作
     を処理してから再度答えを求める。

     例ではエコーエリアのメッセージを連続する行で示しているが、スクリー
     ン上に実際に表示されるのは1回に1行だけである。

 -- Function: y-or-n-p-with-timeout prompt seconds default
     ‘y-or-n-p’と同様だが、ユーザーがSECONDS秒以内に答えないと、この関数
     は待つのをやめてDEFAULTをリターンする。これはタイマーをセットアップ
     することにより機能する。引数SECONDSは数字である。

 -- Function: yes-or-no-p prompt
     この関数は質問して、ミニバッファーに答えの入力を求める。これはユー
     ザーが‘yes’をエンターすると‘t’を、‘no’をエンターすると‘nil’をリター
     ンする。ユーザーは応答を終えるために<RET>をタイプしなければならない
     。大文字と小文字は等価である。

     ‘yes-or-no-p’はエコーエリアにPROMPTとその後に‘(yes or no) ’を表示す
     ることにより開始される。ユーザーは期待される応答の1つをタイプしなけ
     ればならない。それ以外の答えだと、この関数は‘Please answer yes or
     no.’と応答して約2秒待った後に要求を繰り返す。

     ‘yes-or-no-p’は‘y-or-n-p’より多くの作業をユーザーに要求し、より重大
     な決定に適している。

     以下は例である:

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; 前の式を評価した後、
          ;;   空のミニバッファーに
          ;;   以下のプロンプトが表示される:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     ユーザーが最初に‘y <RET>’とタイプした場合、これは無効である。なぜな
     らこの関数は‘yes’という単語全体を要求しているので、以下のプロンプト
     を説明のために一時停止して表示する。

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------


File: elisp,  Node: Multiple Queries,  Next: Reading a Password,  Prev: Yes-or-No Queries,  Up: Minibuffers

19.8 Asking Multiple Y-or-N Questions
=====================================

同じような連続する質問と答えがある場合、たとえば各バッファーにたいして順
に“Do you want to save this buffer”と確認を求めるような場合は、個別に質
問するより‘map-y-or-n-p’を使用して質問のコレクションを尋ねるべきです。こ
れはユーザーにたいして、質問全体にたいして1回で答えられるような便利な機
能を提供します。

 -- Function: map-y-or-n-p prompter actor list &optional help
          action-alist no-cursor-in-echo-area
     この関数はユーザーに一連の質問をし、それぞれの質問にたいしてエコー
     エリア内の1文字の答えを読み取る。

     値LISTは質問をするオブジェクトを指定する。これはリスト、オブジェク
     ト、または生成関数(generator function)のいずれかである。関数の場合
     は引数なしで、次に質問するオブジェクト、または質問の中止を意味する
     ‘nil’のいずれかをリターンする。

     引数PROMPTERは各質問について問い合わせ方法を指定する。PROMPTERが文
     字列の場合、質問テキストは以下のようになる:

          (format PROMPTER OBJECT)

     ここでOBJECTは、(LISTから得られる)質問する次のオブジェクトである。

     文字列でない場合、PROMPTERは1つの引数(質問する次のオブジェクト)をと
     る関数で、質問テキストをリターンする。値が文字列の場合は、ユーザー
     問うための質問。関数は‘t’(ユーザーに尋ねずこのオブジェクトを処理す
     る)、または‘nil’(ユーザーに尋ねずこのオブジェクトを無視する)をリタ
     ーンすることもできる。

     引数ACTORは、ユーザーが与えた答えにたいし、どのように処理するかを指
     定する。これは引数が1つの関数で、ユーザーがyesと答えたオブジェクト
     を引数に呼び出される。引数は常にLISTから取得したオブジェクトである
     。

     引数HELPが与えられた場合は、以下の形式のリストである:

          (SINGULAR PLURAL ACTION)

     SINGULARはそのオブジェクトが概念的に何に作用するかを説明する単数形
     の名詞を含む文字列、PLURALはそれに対応する複数形の名詞、ACTIONは
     ACTORが何を行うかを説明する他動詞である。

     HELPを指定しない場合のデフォルトは、‘("object" "objects" "act
     on")’。

     質問のたびに、ユーザーはそのオブジェクトを処理するには‘y’、‘Y’また
     は<SPC>を、そのオブジェクトをスキップするには‘n’、‘N’、または
     <DEL>を、以降のすべてのオブジェクトを処理するには‘!’を、exit(以降の
     すべてのオブジェクトをスキップ)するには<ESC>か‘q’を、カレントオブジ
     ェクトを処理した後にexitするには‘.’(ピリオド)を、ヘルプを入手するに
     は‘C-h’をエンターする。これらは‘query-replace’が受け入れるのと同じ
     答えである。キーマップ‘query-replace-map’は‘map-y-or-n-p’にたいする
     それらの意味を定義し、‘query-replace’にたいしても同様に定義する。
     *note Search and Replace::を参照のこと。

     ACTION-ALISTを使用して、利用できる追加の答えとそれらが何を意味する
     かを指定できる。これは要素が‘(CHAR FUNCTION HELP)’という形式の
     alistで、それぞれの要素が追加の答えを1つ定義する。要素の内容は
     CHARが文字(答え)、FUNCTIONが引数が1つ(LISTから取得するオブジェクト
     )の関数、HELPが文字列である。

     ユーザーの応答がCHARの場合、‘map-y-or-n-p’はFUNCTIONを呼び出す。こ
     れが非‘nil’をリターンした場合には、そのオブジェクトが“処理された”と
     判断して、‘map-y-or-n-p’はLIST内の次のオブジェクトに進む。‘nil’をリ
     ターンした場合は、同じオブジェクトにたいして質問を繰り返す。

     確認を求める間は通常、‘map-y-or-n-p’は‘cursor-in-echo-area’をバイン
     ドする。しかしNO-CURSOR-IN-ECHO-AREAが非‘nil’の場合はバインドしない
     。

     マウスを使用して呼び出されたコマンドから‘map-y-or-n-p’が呼び出され
     た場合(より正確には‘last-nonmenu-event’は非‘nil’かリストの場合。
     *note Command Loop Info::を参照)は、確認を求めるためにダイアログボ
     ックスかポップアップメニューが使用される。この場合、キーボード入力
     やエコーエリアは使用されない。呼び出しの前後で
     ‘last-nonmenu-event’を適切な値にバインドして、入力マウスあるいはキ
     ーボードの入力を強制できる。

     ‘map-y-or-n-p’のリターン値は、処理したオブジェクトの数である。


File: elisp,  Node: Reading a Password,  Next: Minibuffer Commands,  Prev: Multiple Queries,  Up: Minibuffers

19.9 Reading a Password
=======================

他のプログラムに渡すためのパスワードを読み取るために、関数
‘read-passwd’を使用できます。

 -- Function: read-passwd prompt &optional confirm default
     この関数はプロンプトPROMPTを表示してパスワードを読み取る。これはユ
     ーザーがタイプしたパスワードのかわりに、パスワード内の各文字を‘.’に
     かえてエコーする(バッチモードでは入力は隠されないことに注意)。)

     オプション引数CONFIRMが非‘nil’の場合にはパスワードを2回読み取ること
     で、それらが同じものであることを強制する。同じでない場合は、2回の入
     力が同じになるまで、ユーザーはパスワードを繰り返しタイプする必要が
     ある。

     オプション引数DEFAULTは、ユーザーが空入力をエンターした場合のデフォ
     ルトパスワードである。DEFAULTが‘nil’の場合、‘read-passwd’はnull文字
     列をリターンする。


File: elisp,  Node: Minibuffer Commands,  Next: Minibuffer Windows,  Prev: Reading a Password,  Up: Minibuffers

19.10 Minibuffer Commands
=========================

このセクションではミニバッファー内で使用するコマンドを説明します。

 -- Command: exit-minibuffer
     このコマンドはアクティブなミニバッファーをexitする。これは通常、ミ
     ニバッファー内のローカルキーマップのキーにバインドされる。

 -- Command: self-insert-and-exit
     このコマンドはキーボードでタイプされた最後の文字を挿入した後にアク
     ティブなミニバッファーをexitする。*note Command Loop Info::)を参照
     のこと。

 -- Command: previous-history-element n
     このコマンドは、N個前(古い)のヒストリー要素の値でミニバッファー内の
     コンテンツを置換する。

 -- Command: next-history-element n
     このコマンドは、N個先(新しい)のヒストリー要素の値でミニバッファー内
     のコンテンツを置換する。

 -- Command: previous-matching-history-element pattern n
     このコマンドはPATTERN(正規表現)にマッチするN個前(古い)のヒストリー
     要素でミニバッファー内のコンテンツを置換する。

 -- Command: next-matching-history-element pattern n
     このコマンドはPATTERN(正規表現)にマッチするN個先(新しい)のヒストリ
     ー要素でミニバッファー内のコンテンツを置換する。

 -- Command: previous-complete-history-element n
     このコマンドはミニバッファー内のポイントの前のカレントコンテンツを
     、N個前(古い)ヒストリー要素の値で置換する。

 -- Command: next-complete-history-element n
     このコマンドはミニバッファー内のポイントの前のカレントコンテンツを
     、N個先(新しい)ヒストリー要素の値で置換する。


File: elisp,  Node: Minibuffer Windows,  Next: Minibuffer Contents,  Prev: Minibuffer Commands,  Up: Minibuffers

19.11 Minibuffer Windows
========================

以下の関数はミニバッファーウィンドウをアクセスにして選択して、それがアク
ティブかどうかテストします。

 -- Function: active-minibuffer-window
     この関数はカレントでアクティブなミニバッファーウィンドウ、アクティ
     ブなウィンドウがない場合は‘nil’をリターンする。

 -- Function: minibuffer-window &optional frame
     この関数はフレームFRAMEにたいして使用されるミニバッファーウィンドウ
     をリターンする。FRAMEが‘nil’の場合はカレントフレームを意味する。フ
     レームに使用されるミニバッファーウィンドウは、そのフレームの一部で
     ある必要はないことに注意。自身のミニバッファーをもたないフレームは
     、必然的に他のフレームのミニバッファーウィンドウを使用する。

 -- Function: set-minibuffer-window window
     この関数はミニバッファーウィンドウとしてWINDOWを使用するよう指定す
     る。 This function specifies as the minibuffer window to use. これ
     は通常のミニバッファーコマンドを呼び出さずにミニバッファーにテキス
     トを入力する場合、そのミニバッファーがどこに表示されるかに影響を及
     ぼす。通常のミニバッファー入力関数はすべてカレントフレームに対応す
     るミニバッファーを選択して開始されるので、影響はない。

 -- Function: window-minibuffer-p &optional window
     この関数はWINDOWがミニバッファーウィンドウなら‘nil’をリターンする。
     WINDOWのデフォルトは選択されたウィンドウである。

   ‘(minibuffer-window)’の結果を比較して、与えられたウィンドウがミニバッ
ファーかどうか判断するのは正しくない。なぜなら複数のフレームがある場合、
ミニバッファーウィンドウも複数あり得るからである。

 -- Function: minibuffer-window-active-p window
     この関数はWINDOWがカレントでアクティブなミニバッファーウィンドウの
     場合は、非‘nil’をリターンする。


File: elisp,  Node: Minibuffer Contents,  Next: Recursive Mini,  Prev: Minibuffer Windows,  Up: Minibuffers

19.12 Minibuffer Contents
=========================

以下の関数はミニバッファーのプロンプトとコンテンツにアクセスします。

 -- Function: minibuffer-prompt
     この関数はカレントでアクティブなミニバッファーのプロンプト文字列を
     リターンする。アクティブなミニバッファーがない場合は、‘nil’をリター
     ンする。

 -- Function: minibuffer-prompt-end
     この関数は、ミニバッファーがカレントの場合はミニバッファープロンプ
     トの終端のカレント位置をリターンする。それ以外はバッファーの有効な
     最小位置をリターンする。

 -- Function: minibuffer-prompt-width
     この関数はミニバッファーがカレントの場合は、ミニバッファープロンプ
     トのカレントの表示幅をリターンする。それ以外は0をリターンする。

 -- Function: minibuffer-contents
     この関数はミニバッファーがカレントの場合は、ミニバッファーの編集可
     能なコンテンツ(つまりプロンプト以外のすべて)を文字列でリターンする
     。それ以外は、カレントバッファーのコンテンツ全体をリターンする。

 -- Function: minibuffer-contents-no-properties
     これは‘minibuffer-contents’と同様だが、テキストプロパティをコピーせ
     ず文字だけをリターンする。*note Text Properties::を参照のこと。

 -- Function: delete-minibuffer-contents
     この関数はミニバッファーがカレントの場合は、ミニバッファーの編集可
     能なコンテンツ(つまりプロンプト以外のすべて)を削除する。それ以外は
     、カレントバッファー全体を削除する。


File: elisp,  Node: Recursive Mini,  Next: Minibuffer Misc,  Prev: Minibuffer Contents,  Up: Minibuffers

19.13 Recursive Minibuffers
===========================

以下の関数および変数は再帰ミニバッファーを処理します(*note Recursive
Editing::を参照):

 -- Function: minibuffer-depth
     この関数はアクティブなミニバッファーのカレント深さを正の整数でリタ
     ーンする。アクティブなミニバッファーが存在しない場合は0をリターンす
     る。

 -- User Option: enable-recursive-minibuffers
     この変数が非‘nil’の場合は、ミニバッファーウィンドウがアクティブでも
     、(‘find-file’のような)ミニバッファーを使用するコマンドを呼び出すこ
     とができる。このような呼び出しは、新たなミニバッファーにたいして再
     帰編集レベル(recursive editing level)を生成する。内側レベルの編集の
     間、外側レベルのミニバッファーは非表示になる。

     この変数が‘nil’の場合、ミニバッファーウィンドウがアクティブなときは
     、たとえ他のウィンドウに切り替えても、ミニバッファーコマンドの呼び
     出しはできない。

   コマンド名が非‘nil’のプロパティ‘enable-recursive-minibuffers’をもつ場
合は、たとえミニバッファーから呼び出された場合でも、そのコマンドは引数の
読み取りにミニバッファーを使用できる。コマンドのinteractive宣言内で
‘enable-recursive-minibuffers’を‘t’にしても、これを行うことができる
(*note Using Interactive::を参照)。ミニバッファーコマンド
‘next-matching-history-element’(ミニバッファー内では通常‘M-s’)は後者を行
う。


File: elisp,  Node: Minibuffer Misc,  Prev: Recursive Mini,  Up: Minibuffers

19.14 Minibuffer Miscellany
===========================

 -- Function: minibufferp &optional buffer-or-name
     この関数はBUFFER-OR-NAMEがミニバッファーの場合は非‘nil’をリターンす
     る。BUFFER-OR-NAMEが省略された場合はカレントバッファーをテストする
     。

 -- Variable: minibuffer-setup-hook
     これはミニバッファーがエンターされたときは常に実行されるノーマルフ
     ックである。*note Hooks::を参照のこと。

 -- Variable: minibuffer-exit-hook
     これはミニバッファーがexitされたときは常に実行されるノーマルフック
     である。

 -- Variable: minibuffer-help-form
     この変数のカレント値はミニバッファー内で‘help-form’をローカルにリバ
     インドするために使用される(*note Help Functions::を参照)。

 -- Variable: minibuffer-scroll-window
     この変数の値が非‘nil’の場合、それはウィンドウオブジェクトである。ミ
     ニバッファー内で関数‘scroll-other-window’が呼び出されたときは、この
     ウィンドウをスクロールする。

 -- Function: minibuffer-selected-window
     この関数はミニバッファーがエンターされたときに選択されていたウィン
     ドウをリターンする。選択されたウィンドウがミニバッファー以外のとき
     は、‘nil’をリターンする。

 -- User Option: max-mini-window-height
     この変数はミニバッファーウィンドウのリサイズにたいする最大高さを指
     定する。浮動小数点数の場合は、フレーム高さにたいする割り合いを指定
     する。整数の場合は行数を指定する。

 -- Function: minibuffer-message string &rest args
     この関数は数秒、あるいは次の入力イベントが到着するまで、ミニバッフ
     ァーテキストの最後に一時的にSTRINGを表示する。変数
     ‘minibuffer-message-timeout’は入力がない場合に待機する秒数を指定す
     る(デフォルトは2)。ARGSが非‘nil’の場合、実際のメッセージは
     ‘format’にSTRINGとARGSを渡して作成される。*Note Formatting
     Strings::を参照のこと。

 -- Command: minibuffer-inactive-mode
     これはインタラクティブなミニバッファー内で使用されるメジャーモード
     である。キーマップ‘minibuffer-inactive-mode-map’を使用する。ミニバ
     ッファーが別のフレームにある場合は有用かもしれない。*note
     Minibuffers and Frames::を参照のこと。


File: elisp,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

20 Command Loop
***************

Emacsを実行すると、ほぼ即座に“エディターコマンドループ(editor command
loop)”にエンターします。このループはキーシーケンスを読み取り、それらの定
義を実行して、結果を表示します。このチャプターでは、これらが行われる方法
と、Lispプログラムがこれらを行えるようにするサブルーチンを説明します。

* Menu:

* Command Overview::         コマンドループがコマンドを読み取る方法。
* Defining Commands::        関数が引数を読み取る方法を指定する。
* Interactive Call::         引数を読み取るようにコマンドを呼び出す。
* Distinguish Interactive::  インタラクティブな呼び出しとコマンドを区別する。
* Command Loop Info::        検証用にコマンドループによりセットされる変数。
* Adjusting Point::          コマンドの後にポイント位置を調整する。
* Input Events::             入力を読み取るとき、入力がどのように見えるか。
* Reading Input::            キーボードやマウスからの入力イベントを読み取る方法。
* Special Events::           即座かつ個別に処理されるイベント。
* Waiting::                  ユーザー入力または経過時間の待機。
* Quitting::                 ‘C-g’が機能する方法。quitをcatchまたは延期する方法。
* Prefix Command Arguments::  コマンドがプレフィクス引数が機能するようにセットするための方法。
* Recursive Editing::        再帰編集へのエンター、なぜ通常は再帰編集を行うべきでないのか。
* Disabling Commands::       コマンドループが無効なコマンドを扱う方法。
* Command History::          コマンドヒストリーがセットアップされる方法と、どのようにアクセスされるか。
* Keyboard Macros::          キーボードマクロが実装される方法。


File: elisp,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

20.1 Command Loop Overview
==========================

コマンドループが最初に行わなければならないのはキーシーケンスの読み取りで
す。キーシーケンスほコマンドに変換される入力イベントのシーケンスです。こ
れは関数‘read-key-sequence’を呼び出すことにより行われます。Lispプログラ
ムもこの関数を呼び出すことができます(*note Key Sequence Input::を参照)。
これらはより低レベルの‘read-key’や‘read-event’(*note Reading One
Event::)で入力を読み取ったり、‘discard-input’(*note Event Input Misc::を
参照)で保留中の入力を無視することもできます。

   キーシーケンスはカレントでアクティブなキーマップを通じてコマンドに変
換されます。これが行われる方法については、*Note Key Lookup::を参照してく
ださい。結果はキーボードマクロかインタラクティブに呼び出し可能な関数にな
ります。キーが‘M-x’の場合は、他のコマンドの名前を読み取り、それを呼び出
します。これはコマンド‘execute-extended-command’(*note Interactive
Call::を参照)により行われます。

   コマンドの実行に先立ち、Emacsはアンドゥ境界(undo boundary)を作成する
ために‘undo-boundary’を実行します。*note Maintaining Undo::を参照してく
ださい。

   コマンドを実行するために、Emacsはまず‘command-execute’を呼び出してコ
マンドの引数を読み取ります(*note Interactive Call::を参照)。Lispで記述さ
れたコマンドについては、‘interactive’指定で引数を読み取る方法を指定しま
す。これはプレフィクス引数(*note Prefix Command Arguments::を参照)を使用
したり、ミニバッファー内(*note Minibuffers::を参照)で確認を求めて読み取
りを行うかもしれません。たとえば、コマンド‘find-file’には‘interactive’指
定があり、これはミニバッファーを使用してファイル名を読み取ることを指定し
ます。‘find-file’の関数bodyはミニバッファーを使用しないので、Lispコード
から関数として‘find-file’を呼び出す場合は通常のLisp関数引数としてファイ
ル名を文字列で与えなければなりません。

   コマンドがキーボードマクロ(文字列やベクター)の場合、Emacsは
‘execute-kbd-macro’を使用してそれを実行します(*note Keyboard Macros::を
参照)。

 -- Variable: pre-command-hook
     このノーマルフックはコマンドを実行する前に、エディターコマンドルー
     プにより実行される。その際、‘this-command’ には実行しようとするコマ
     ンドが含まれ、‘last-command’には前のコマンドが記述される。*note
     Command Loop Info::を参照のこと。

 -- Variable: post-command-hook
     このノーマルフックはコマンドを実行した後(quitやエラーにより早期に終
     了させられたコマンドを含む)に、エディターコマンドループにより実行さ
     れる。その際、‘this-command’は正に実行されたコマンドを参照し、
     ‘last-command’は前に実行されたコマンドを参照する。

     このフックはEmacsが最初にコマンドループにエンターしたときにも実行さ
     れる(その時点では‘this-command’と‘last-command’はどちらも‘nil’)。

   ‘pre-command-hook’および‘post-command-hook’の実行中、quitは抑制されま
す。これらのフックのどれか1つを実行中にエラーが発生した場合、そのエラー
はフックの実行を終了させません。そのかわりにエラーは黙殺され、エラーが発
生した関数はそのフックから取り除かれます。

   Emacsサーバー(*note (emacs)Emacs Server::を参照)に届くリクエストは、
キーボードコマンドが行うのと同じように、これらの2つのフックを実行します
。


File: elisp,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

20.2 Defining Commands
======================

スペシャルフォーム‘interactive’はLisp関数をコマンドに変えます。
‘interactive’フォームは関数ボディーのトップレベルに置かなければならず、
通常はボディー内の最初のフォームとして記述されます。これはラムダ式(*note
Lambda Expressions::を参照)と‘defun’(*note Defining Functions::を参照)の
両方を受け入れます。このフォームは、その関数が実際に実行される間は何も行
いません。このフォームの存在はフラグとしての役割りをもち、Emacsコマンド
ループにたいしてその関数がインタラクティブに呼び出せることを告げます。
‘interactive’フォームの引数は、インタラクティブな呼び出しが引数を読み取
る方法を指定します。

   ‘interactive’フォームのかわりに、関数シンボルの‘interactive-form’プロ
パティで指定されることもあります。このプロパティが非‘nil’値の場合、関数
ボディー内の‘interactive’フォームより優先されます。この機能はほとんど使
用されません。

   インタラクティブに呼び出されることだけを意図していて、決してLispから
直接呼び出されない関数が時折あります。この場合は、その関数の
‘interactive-only’プロパティに非‘nil’を与えます。これにより、そのコマン
ドがLispから呼び出された場合に、バイトコンパイラーが警告を発します。この
プロパティの値には、文字列、‘t’、または任意のシンボルを指定できます。文
字列の場合、それはバイトコンパイラーによる警告内で直接使用されます(最初
は大文字でなくピリオドで終端される文字列。たとえば“use ... instead.”)。
シンボルの場合、それはLispコード内で使用されるかわりの関数です。

* Menu:

* Using Interactive::        ‘interactive’にたいする一般的なルール。
* Interactive Codes::        さまざまな方法で引数を読み取る標準的な文字のコード。
* Interactive Examples::     インタラクティブ引数を読み取る方法の例。
* Generic Commands::         コマンド候補からの選択。


File: elisp,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

20.2.1 Using ‘interactive’
--------------------------

このセクションでは、Lisp関数をインタラクティブに呼び出し可能なコマンドに
する‘interactive’フォームの記述方法と、コマンドの‘interactive’フォームの
検証方法について説明します。

 -- Special Form: interactive arg-descriptor
     このスペシャルフォームは関数がコマンドであり、したがって(‘M-x’を通
     じて、またはそのコマンドにバインドされたキーシーケンスのエンターす
     ることにより)インタラクティブに呼び出されるかもしれないことを宣言す
     る。引数ARG-DESCRIPTORは、そのコマンドがインタラクティブに呼び出さ
     れたときに引数を計算する方法を宣言する。

     コマンドは他の関数と同じようにLisp関数から呼び出されるかもしれない
     が、その場合呼び出し側は引数を提供し、ARG-DESCRIPTORは効果をもたな
     い。

     ‘interactive’フォームは関数ボディー内のトップレベルに置くか、関数シ
     ンボルの‘interactive-form’プロパティ((*note Symbol Properties::)を
     参照)になければならない。これはコマンドループが関数を呼び出す前に
     interactiveフォームを調べることにより効果をもつ(*note Interactive
     Call::を参照)。一度関数が呼び出されると関数ボディー内のすべてのフォ
     ームが実行される。このときボディー内に‘interactive’フォームが出現し
     ても、そのフォームは引数の評価さえされず、単に‘nil’をリターンする。

     慣例により、‘interactive’フォームは関数ボディー内の最初のトップレベ
     ルフォームとするべきである。‘interactive’フォームがシンボルの
     ‘interactive-form’プロパティと関数ボディーの両方に存在する場合は、
     前者が優先される。‘interactive-form’フォームは既存の関数に
     interactiveフォームを追加したり、その関数を再定義することなく引数を
     インタラクティブに処理する方法を変更するために使用できる。

   引数ARG-DESCRIPTORには3つの可能性があります:

   • 省略、または‘nil’の場合、コマンドは引数なしで呼び出される。コマンド
     が1つ以上の引数を要求する場合は、すぐにエラーとなる。

   • 文字列の場合、その文字列の内容は改行で区切られた要素シーケンスであ
     り、1つの要素が1つの引数に対応する(1)。各要素はコード文字(*note
     Interactive Codes::を参照)と、オプションでその後のプロンプト(ある文
     字はコード文字として使用され、コード文字としては無視されるものもあ
     る)により構成される。以下は例である:

          (interactive "P\nbFrobnicate buffer: ")

     コード文字‘P’はそのコマンドの1つ目の引数をrawコマンドプレフィクス
     (*note Prefix Command Arguments::を参照)にセットする。‘bFrobnicate
     buffer: ’は、ユーザーに‘Frobnicate buffer: ’のプロンプトを示して既
     存のバッファーの名前の入力を促し、これは2つ目かつ最後の引数になる。

     プロンプト文字列には、プロンプト内の前の引数(1つ目の引数から始まる
     )の値を含めるために‘%’を使用できる。これは‘format’(*note Formatting
     Strings::を参照)を使用して行われる。たとえば、以下は既存のバッファ
     ーの名前を読み取り、その後にそのバッファーに与える新たな名前を読み
     取る例である:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     文字列の先頭‘*’がある場合、そのバッファーが読み取り専用の場合にエラ
     ーがシグナルされる。

     文字列の先頭が‘@’で、そのコマンドの呼び出しに使用されたキーシーケン
     スに何らかのマウスイベントが含まれる場合は、そのコマンドを実行する
     前に、それらのうち最初のイベントに結びつくウィンドウが選択される。

     文字列の先頭が‘^’で、そのコマンドが“シフト転換
     (shift-translation)”を通じて呼び出された場合は、そのコマンドを実行
     する前に、マークをセットして一時的にリージョンをアクティブにするか
     、すでにアクティブなリージョンを拡張する。コマンドがシフト転換なし
     で呼び出されて、リージョンが一時的にアクティブな場合は、コマンドを
     実行する前に、そのリージョンを非アクティブにする。シフト転換は
     ‘shift-select-mode’により、ユーザーレベルで制御される。*note
     (emacs)Shift Selection::を参照のこと。

     ‘*’、‘@’、‘^’はともに使用でき、その場合は順序に意味はない。実際の引
     数の読み取りは残りのプロンプト文字列(‘*’、‘@’、‘^’以外の最初の文字
     以降)により制御される。

   • 文字列ではないLisp式の場合は、そのコマンドに渡す引数リストを取得す
     るために評価されるフォームである。このフォームは通常、ユーザーから
     入力を読み取るためにさまざまな関数を呼び出し、それにはほとんどの場
     合はミニバッファー(*note Minibuffers::を参照)を通じてか、キーボード
     から直接読み取りを行う(*note Reading Input::を参照)。

     引数値としてポイントやマークを提供するのも一般的だが、何かを行い_か
     つ_(ミニバッファー使用の有無に関わらず)入力を読み取る場合は、読み取
     りの前にポイント値またはマーク値の整数を確実に取得しておくこと。カ
     レントバッファーはサブプロセスの出力を受信するかもしれず、コマンド
     が入力を待つ間にサブプロセス出力が到着した場合、ポイントおよびマー
     クの再配置が起こり得る。

     以下は行っては_いけない_例である:

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     これにたいし、以下はキーボード入力を読み取った後にポイントとマーク
     を調べることにより、上記の問題を避ける例である:

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

     *警告:* 引数値にはプリントや読み取りが不可能なデータ型を含めるべき
     ではない。いくつかの機能は後続のセッションに読み込ませるために
     ‘command-history’をファイルに保存する。コマンドの引数に‘#<...>’構文
     を使用してプリントされるデータ型が含まれる場合、それらの機能は動作
     しないだろう。

     しかしこれには少数の例外がある。‘(point)’、‘(mark)’、
     ‘(region-beginning)’、‘(region-end)’などの一連の式に限定して使用す
     るのに問題はない。なぜならEmacsはこれらを特別に認識して、コマンドヒ
     ストリー内に(値ではなく)その式を配すからである。記述した式がこれら
     の例外に含まれるかどうか確認するには、コマンドを実行した後に‘(car
     command-history)’を調べればよい。

 -- Function: interactive-form function
     この関数はFUNCTIONの‘interactive’フォームをリターンする。FUNCTIONが
     インタラクティブに呼び出し可能な関数(*note Interactive Call::を参照
     )の場合、値はそのコマンドの引数を計算する方法を指定する
     ‘interactive’フォーム(‘(interactive SPEC)’)である。それ以外では値は
     ‘nil’である。FUNCTIONがシンボルの場合は、そのシンボルの関数定義が使
     用される。

   ---------- Footnotes ----------

   (1) いくつかの要素は実際に2つの引数を提供します。


File: elisp,  Node: Interactive Codes,  Next: Interactive Examples,  Prev: Using Interactive,  Up: Defining Commands

20.2.2 Code Characters for ‘interactive’
----------------------------------------

ここで説明されているコード文字には、以下で定義されるいくつかのキーワード
が含まれています:

Completion
     補完を提供する。<TAB>、<SPC>、<RET>は‘completing-read’(*note
     Completion::を参照)を使用して引数を読み取り、名前の補完を行う。
     ‘?’で利用可能な補完リストを表示する。

Existing
     既存オブジェクトの名前を要求する。無効な名前は受け付けられない。カ
     レント入力が有効でない場合、ミニバッファーをexitするコマンドは
     exitしない。

Default
     ユーザーがテキストを何もエンターしなかった場合は、ある種のデフォル
     ト値が使用される。デフォルトはコード文字に依存する。

No I/O
     このコード文字は入力を読み取らずに引数を計算する。したがってプロン
     プト文字列を使用せず、与えられたプロンプト文字列は無視される。

     たとえこのコード文字がプロンプト文字列を使用しなくても、これが文字
     列内で最後のコード文字でない場合は、その後に改行を付けなければなら
     ない。

Prompt
     コード文字の直後にプロンプトが続く。プロンプトの終端は文字列の終端
     、または改行。

Special
     このコード文字はインタラクティブ文字列の先頭にあるときのみ意味があ
     り、プロンプトおよび改行を要求しない。単一の独立した文字である。

   以下は‘interactive’とともに使用されるコード文字です:

‘*’
     カレントバッファーが読み取り専用の場合はエラーをシグナルする。
     [Special]

‘@’
     このコマンドを呼び出したキーシーケンス内の最初のマウスイベントに関
     連するウィンドウを選択する。[Special]

‘^’
     シフト転換を通じてコマンドが呼び出された場合はコマンドを実行する前
     に、マークをセットして一時的にリージョンをアクティブにするか、すで
     にリージョンがアクティブな場合はリージョンを拡張する。シフト転換を
     通じずにコマンドが呼び出され、リージョンが一時的にアクティブな場合
     は、コマンドを実行する前にそのリージョンを非アクティブにする。
     [Special]

‘a’
     関数名(たとえば‘fboundp’を満足するシンボル)。[Existing]、
     [Completion]、[Prompt]

‘b’
     既存バッファーの名前。 The name of an existing buffer. デフォルトで
     はカレントバッファー(*note Buffers::を参照)の名前を使用する。
     [Existing]、[Completion]、[Default]、[Prompt]

‘B’
     バッファー名。そのバッファーが存在する必要はない。デフォルトではカ
     レントバッファーではなくもっとも最近使用されたバッファーの名前を使
     用する。[Completion]、[Default]、[Prompt]

‘c’
     文字。カーソルはエコーエリアに移動しない。[Prompt]

‘C’
     コマンド名(たとえば‘commandp’を満足するシンボル)。[Existing]、
     [Completion]、[Prompt]

‘d’
     ポイント位置の整数(*note Point::を参照)。[No I/O]

‘D’
     ディレクトリー名。デフォルトはカレントバッファーのカレントのデフォ
     ルトディレクトリー‘default-directory’(*note File Name Expansion::を
     参照)。[Existing]、[Completion]、[Default]、[Prompt]

‘e’
     そのコマンドを呼び出したキーシーケンス内の1つ目、または2つ目の非キ
     ーボードイベント。より正確には、‘e’はリストとしてイベントを取得する
     ので、リスト内のデータを調べることができる。*note Input Events::を
     参照のこと。[No I/O]

     ‘e’はマウスイベント、および特別なシステムイベント(*note Misc
     Events::を参照)にたいして使用する。コマンドが受け取るイベントリスト
     は、そのイベントに依存する。*note Input Events::ではそれぞれのイベ
     ントのリスト形式を、対応するサブセクションでそれぞれ説明しているの
     で、参照のこと。

     1つのコマンドのinteractive仕様の中で、‘e’を複数回使用できる。そのコ
     マンドを呼び出したキーシーケンスがイベントN(リスト)をもつ場合は、
     ‘e’のN番目がそのイベントを提供する。関数キーやASCII文字のようなリス
     ト以外のイベントは、‘e’に関連するイベントとしてカウントされない。

‘f’
     既存ファイルのファイル名(*note File Names::を参照)。デフォルトのデ
     ィレクトリーは‘default-directory’。[Existing]、[Completion]、
     [Default]、[Prompt]

‘F’
     ファイル名。ファイルが存在している必要はない。[Completion]、
     [Default]、[Prompt]

‘G’
     ファイル名。ファイルが存在している必要はない。ユーザーがディレクト
     リー名だけをエンターした場合、値はそのディレクトリー名となり、その
     ディレクトリー名にファイル名は追加されない。[Completion]、
     [Default]、[Prompt]

‘i’
     無関係な引数。このコード文字は引数値として常に‘nil’を与える。[No
     I/O]

‘k’
     キーシーケンス(*note Key Sequences::を参照)。これはカレントキーマッ
     プ内でコマンド(または未定義のコマンド)が見つかるまで、イベントを読
     み取り続ける。キーシーケンス引数は文字列、またはベクターで表される
     。カーソルはエコーエリアに移動しない。[Prompt]

     ‘k’が(マウスの)down-eventで終わるキーシーケンスを読み取った場合は、
     後続の(マウスの)up-eventも読み取り、それを捨てる。コード文字‘U’によ
     り、up-eventへのアクセスを得ることができる。

     この種の入力は、‘describe-key’や‘global-set-key’のようなコマンドに
     より使用される。

‘K’
     キーシーケンス。その定義は変更されることを意図している。これは‘k’と
     同じように機能するが、キーシーケンス内の最後の入力イベントにたいし
     て、通常(必要なら)使用される未定義キーから定義済みキーへの変換を抑
     制する。

‘m’
     マーク位置の整数。[No I/O]

‘M’
     任意のテキスト。ミニバッファー内でカレントバッファーの入力メソッド
     (*note (emacs)Input Methods::を参照)を使用して読み取りを行い、それ
     を文字列でリターンする。[Prompt]

‘n’
     数字。ミニバッファーで読み取られる。入力が数字でない場合、ユーザー
     は再試行する必要がある。‘n’は決してプレフィクス引数を使用しない。
     [Prompt]

‘N’
     数引数(numeric prefix argument)。ただしプレフィクス引数がない場合は
     、‘n’のように数字を読み取る。値は常に数字。*note Prefix Command
     Arguments::を参照のこと。[Prompt]

‘p’
     数引数()これは小文字の‘p’であることに注意)。[No I/O]

‘P’
     rawプレフィクス引数(これは大文字の‘P’であることに注意)。[No I/O]

‘r’
     2つの数引数(ポイントとマーク)。小さいほうが先。これは1つではなく連
     続する2つの引数を指定する唯一のコード文字である。[No I/O]

‘s’
     任意のテキスト。ミニバッファー内で読み取りを行い文字列としてリター
     ンする(*note Text from Minibuffer::を参照)。‘C-j’か<RET>で入力を終
     端する(これらの文字を入力に含めるために‘C-q’が使用されるかもしれな
     い)。[Prompt]

‘S’
     インターン済みのシンボル。名前はミニバッファー内で読み取られる。
     ‘C-j’か<RET>で入力を終端する。ここでは、その他の通常はシンボルを終
     端する文字(たとえば空白文字、丸カッコ、角カッコ)では終端されない。
     [Prompt]

‘U’
     キーシーケンス、または‘nil’。‘k’(または‘K’)が読み取った後に、(もし
     あれば)捨てられる(マウスの)up-eventを取得するために、引数‘k’(または
     ‘K’)の後で使用され得る。捨てられたup-eventが存在しない場合、‘U’は引
     数として‘nil’を提供する。[No I/O]

‘v’
     ユーザーオプションとして宣言された変数(たとえば述語
     ‘custom-variable-p’を満足する)。これは‘read-variable’を使用して変数
     を読み取る。*note Definition of read-variable::を参照のこと。
     [Existing]、[Completion]、[Prompt]

‘x’
     Lispオブジェクト。そのオブジェクトの入力構文により指定され、‘C-j’か
     <RET>で終端される。オブジェクトは評価されない。*note Object from
     Minibuffer::を参照のこと。[Prompt]

‘X’
     Lispフォームの値。‘X’は‘x’のように読み取りを行いフォームを評価して
     、その値がコマンドの引数になる。[Prompt]

‘z’
     コーディングシステム名(シンボル)。ユーザーがnull入力をエンターした
     場合、引数値は‘nil’になる。*note Coding Systems::を参照のこと。
     [Completion]、[Existing]、[Prompt]

‘Z’
     コマンドにプレフィクス引数がある場合はコーディングシステム名。プレ
     フィクス引数がない場合、‘Z’は引数値として‘nil’を提供する。
     [Completion]、[Existing]、[Prompt]


File: elisp,  Node: Interactive Examples,  Next: Generic Commands,  Prev: Interactive Codes,  Up: Defining Commands

20.2.3 Examples of Using ‘interactive’
--------------------------------------

以下に‘interactive’の例をいくつか挙げます:

     (defun foo1 ()              ; ‘foo1’は1つの引数をとり
         (interactive)           ;   単に2単語分前に移動する。
         (forward-word 2))
          ⇒ foo1

     (defun foo2 (n)             ; ‘foo2’は引数を1つとる
         (interactive "^p")      ;   引数は数引数
                                 ; ‘shift-select-mode’では、
                                 ;   リージョンをアクティブにするか、拡張する
         (forward-word (* 2 n)))
          ⇒ foo2

     (defun foo3 (n)             ; ‘foo3’は引数を1つとる
         (interactive "nCount:") ;   引数はミニバッファーで読み取られる
         (forward-word (* 2 n)))
          ⇒ foo3

     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          ⇒ three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          ⇒ nil


File: elisp,  Node: Generic Commands,  Prev: Interactive Examples,  Up: Defining Commands

20.2.4 Select among Command Alternatives
----------------------------------------

マクロ‘define-alternatives’は“ジェネリックコマンド(generic command)”を定
義するために使用できます。これらはユーザーの選択により複数の候補から選択
可能なinteractive関数の実装です。

 -- Macro: define-alternatives command &rest customizations
     新たなコマンドCOMMAND(シンボル)を定義する。

     最初にユーザーが‘M-x COMMAND <RET>’を実行したとき、Emacsはコマンド
     が使用する実際のフォームにたいして確認を求め、その選択をカスタム変
     数として記録する。プレフィクス引数を使用すると、候補選択のプロセス
     を繰り返す。

     変数‘COMMAND-alternatives’には、COMMANDの実装候補がalistで含まれる
     。この変数がセットされるまで、‘define-alternatives’は効果をもたない
     。

     CUSTOMIZATIONSが非‘nil’の場合は、‘defcustom’キーワード(典型的には
     ‘:group’および‘:version’)と、‘COMMAND-alternatives’の宣言に追加する
     値により構成される候補である。


File: elisp,  Node: Interactive Call,  Next: Distinguish Interactive,  Prev: Defining Commands,  Up: Command Loop

20.3 Interactive Call
=====================

コマンドループはキーシーケンスをコマンドに翻訳した後、関数
‘command-execute’を使用してその関数を呼び出します。そのコマンドが関数の
場合、‘command-execute’は引数を読み取りコマンドを呼び出す
‘call-interactively’を呼び出します。自分でこれらの関数を呼び出すこともで
きます。

   このコンテキストにおいて用語“command”はインタラクティブにコール可能な
関数(または関数likeなオブジェクト)やキーボードマクロを指すことに注意して
ください。つまりコマンドを呼び出すキーシーケンスのことではありません
(*note Keymaps::を参照)。

 -- Function: commandp object &optional for-call-interactively
     この関数はOBJECTがコマンドの場合は‘t’、それ以外は‘nil’をリターンす
     る。

     コマンドには文字列とベクター(キーボードマクロとして扱われる)、トッ
     プレベル‘interactive’フォーム(*note Using Interactive::を参照)を含
     むラムダ式、そのようなラムダ式から作成されたバイトコンパイル関数オ
     ブジェクト、interactiveとして宣言(‘autoload’の4つ目の引数が非
     ‘nil’)されたautoloadオブジェクト、およびいくつかのプリミティブ関数
     が含まれる。‘interactive-form’プロパティが非‘nil’のシンボル、および
     関数定義が‘commandp’を満足するシンボルもコマンドとされる。

     FOR-CALL-INTERACTIVELYが非‘nil’の場合は、‘call-interactively’が呼び
     出すことができるオブジェクトにたいしてのみ‘commandp’は‘t’をリターン
     する。したがってキーボードマクロは該当しなくなる。

     ‘commandp’を使用する現実的な例は、*note Accessing Documentation::内
     の‘documentation’を参照のこと。

 -- Function: call-interactively command &optional record-flag keys
     この関数はinteractive呼び出し仕様にしたがって引数を取得し、インタラ
     クティブに呼び出し可能な関数COMMANDを呼び出す。これはCOMMANDがリタ
     ーンするものが何であれ、それをリターンする。

     たとえば、もし以下の署名をもつ関数がある場合:

          (defun foo (begin end)
            (interactive "r")
            ...)

     以下を行うと

          (call-interactively 'foo)

     これはリージョン(‘point’と‘mark’)を引数として‘foo’を呼び出すだろう
     。

     COMMANDが関数でない、またはインタラクティブに呼び出せない(コマンド
     でない)場合は、エラーをシグナルする。たとえコマンドだとしても、キー
     ボードマクロ(文字列かベクター)は、関数ではないので、許されないこと
     に注意。COMMANDがシンボルの場合、‘call-interactively’はそれの関数定
     義を使用する。

     RECORD-FLAGが非‘nil’の場合は、このコマンドとコマンドの引数は無条件
     にリスト‘command-history’に追加される。それ以外では、引数の読み取り
     にミニバッファーを使用した場合のみコマンドが追加される。*note
     Command History::を参照のこと。

     引数KEYSが与えられた場合、それはコマンドを呼び出すためにどのイベン
     トを使用するかコマンドが問い合わせた場合に与えるべき、イベントシー
     ケンスを指定するベクターである。KEYSが‘nil’、または省略された場合の
     デフォルトは、‘this-command-keys-vector’のリターン値である。*note
     Definition of this-command-keys-vector::を参照のこと。

 -- Function: command-execute command &optional record-flag keys special
     この関数はCOMMANDを実行する。引数COMMANDは述語‘commandp’を満足しな
     ければならない。つまりインタラクティブに呼び出し可能な関数かキーボ
     ードマクロでなければならない。

     COMMANDが文字列かベクターの場合は、‘execute-kbd-macro’により実行さ
     れる。関数はRECORD-FLAGおよびKEYS引数とともに‘call-interactively’に
     渡される(上記参照)。

     COMMANDがシンボルの場合、その位置にシンボルの関数定義が使用される。
     ‘autoload’定義のあるシンボルは、インタラクティブに呼び出し可能な関
     数お意味するよう宣言されている場合は、コマンドとして判断される。そ
     のような宣言は、指定されたライブラリーのロードと、シンボル定義の再
     チェックにより処理される。

     引数SPECIALが与えられた場合、それはプレフィクス引数を無視して、それ
     をクリアーしないという意味である。これはスペシャルイベント(*note
     Special Events::を参照)を実行する場合に使用される。

 -- Command: execute-extended-command prefix-argument
     この関数は‘completing-read’(*note Completion::を参照)を使用して、ミ
     ニバッファーからコマンド名を読み取る。その後、指定されたコマンドを
     呼び出すために‘command-execute’を使用する。そのコマンドがリターンす
     るのが何であれ、それが‘execute-extended-command’の値となる。

     そのコマンドがプレフィクス引数を求める場合は、PREFIX-ARGUMENTのの値
     を受け取る。‘execute-extended-command’がインタラクティブに呼び出さ
     れた場合は、カレントのrawプレフィクス引数がPREFIX-ARGUMENTに使用さ
     れ、それが何であれ実行するコマンドに渡される。

     通常、‘execute-extended-command’は‘M-x’の定義なので、プロンプトとし
     て文字列‘M-x ’を使用する(‘execute-extended-command’を呼び出したイベ
     ントからプロンプトを受け取るほうが良いのだろうが、実装は骨が折れる
     )。プレフィクス引数の値の説明が、もしあれば、それもプロンプトの一部
     となる。

          (execute-extended-command 3)
          ---------- Buffer: Minibuffer ----------
          3 M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               ⇒ t


File: elisp,  Node: Distinguish Interactive,  Next: Command Loop Info,  Prev: Interactive Call,  Up: Command Loop

20.4 Distinguish Interactive Calls
==================================

interactive呼び出しのときは、コマンドが(エコーエリア内の情報メッセージな
どのような)視覚的な追加フィードバックを表示すべきときがあります。これを
行うためには、3つの方法があります。その関数が‘call-interactively’を使用
して呼び出されたかどうかテストするには、オプション引数‘print-message’を
与えるとともに、interactive呼び出しで非‘nil’となるように‘interactive’仕
様を使うのが推奨される方法です。以下は例です:

     (defun foo (&optional print-message)
       (interactive "p")
       (when print-message
         (message "foo")))

数プレフィクス引数は決して‘nil’にならないので、わたしたちは‘"p"’を使用し
ます。この方法で定義された関数は、キーボードマクロから呼び出されたときに
メッセージを表示します。

   追加引数による上記の手法は、呼び出し側に“この呼び出しをinteractiveと
して扱うように”伝えることができるので、通常は最善です。しかし、
‘called-interactively-p’.をテストすることにより、これを行うこともできま
す。

 -- Function: called-interactively-p kind
     この関数は、呼び出された関数が‘call-interactively’を使用して呼び出
     された場合は‘t’をリターンする。

     引数KINDはシンボル‘interactive’かシンボル‘any’のどちらかである。こ
     れが‘interactive’の場合、‘called-interactively-p’はユーザーから直接
     呼び出しが行われたとき — たとえば関数呼び出しにバインドされたキーシ
     ーケンスをユーザーがタイプした場合がそれに該当するが、ユーザーがそ
     の関数を呼び出すキーボードマクロ(*note Keyboard Macros::を参照)を実
     行中した場合は_該当しない_ — だけ‘t’をリターンするKINDが‘any’の場合
     、‘called-interactively-p’はキーボードマクロを含む任意の種類の
     interactive呼び出しにたいして‘t’をリターンする。

     疑わしい場合は‘any’を使用すること。‘interactive’の使用が正しいと解
     っているのは、関数が実行中に役に立つメッセージを表示するかどうか判
     断が必要な場合だけである。

     Lisp評価(または‘apply’や‘funcall’))を通じて呼び出された、または場合
     、関数は決してインタラクティブに呼び出されたとは判断されない。

以下は‘called-interactively-p’を使用する例である:

     (defun foo ()
       (interactive)
       (when (called-interactively-p 'any)
         (message "Interactive!")
         'foo-called-interactively))

     ;; ‘M-x foo’とタイプする
          ⊣ Interactive!

     (foo)
          ⇒ nil

以下は‘called-interactively-p’の直接呼び出しと間接呼び出しを比較した例で
ある。

     (defun bar ()
       (interactive)
       (message "%s" (list (foo) (called-interactively-p 'any))))

     ;; ‘M-x bar’とタイプする
          ⊣ (nil t)


File: elisp,  Node: Command Loop Info,  Next: Adjusting Point,  Prev: Distinguish Interactive,  Up: Command Loop

20.5 Information from the Command Loop
======================================

エディターコマンドループは、自分自身と実行するコマンドのために、いくつか
のLisp変数にステータス記録を保持します。‘this-command’および
‘last-command’以外は、一般的にこれらの変数をLispプログラム内で変更するの
は、良いアイデアではありません。

 -- Variable: last-command
     この変数は、コマンドループにより実行された以前のコマンド(前にカレン
     トだったコマンド)の名前を記録する。値は通常、関数定義をもつシンボル
     だが、その保証はない。

     コマンドがコマンドループからリターンするとき、‘this-command’から値
     がコピーされる。ただしそのコマンドが、後続のコマンドにたいしてプレ
     フィクス引数を指定されたときを除く。

     この変数は常にカレント端末にたいしてローカルであり、バッファーロー
     カルにできない。*note Multiple Terminals::を参照のこと。

 -- Variable: real-last-command
     この変数はEmacsにより‘last-command’と同様にセットアップされるが、
     Lispプログラムから決して変更されない。

 -- Variable: last-repeatable-command
     この変数は、入力イベントと一部としではなく、もっとも最近実行された
     コマンドを格納する。これはコマンド‘repeat’が再実行を試みるコマンド
     である。*note (emacs)Repeating::を参照のこと。

 -- Variable: this-command
     この変数は、コマンドループにより現在実行中のコマンドの名前を記録す
     る。‘last-command’と同様、通常は関数定義をもつシンボルである。

     コマンドループはコマンドを実行する直前にこの変数をセットして、(その
     コマンドが後続のコマンドのプレフィクス引数を指定しない場合)そのコマ
     ンドが終了したときに、その値を‘last-command’内にコピーする。

     いくつかのコマンドは、次に実行されるコマンドが何であれ、それにたい
     するフラグとして、実行中の間この変数をセットする。特にテキストを
     killする関数は‘this-command’を‘kill-region’にセットするので、直後に
     実行された任意のkillコマンドは、killしたテキストを前にkillされたテ
     キストに追加すべきことが解かるだろう。

   特定のコマンドにおいて、エラーが発生した場合に前のコマンドとして認識
されたくない場合は、これを防ぐようにそのコマンドをコーディングしなければ
ならない。これを行う1つの方法は、以下のようにコマンドの最初で
‘this-command’に‘t’をセットして、最後に‘this-command’に正しい値をセット
する方法である:

     (defun foo (args...)
       (interactive ...)
       (let ((old-this-command this-command))
         (setq this-command t)
         ... 処理を行う ...
         (setq this-command old-this-command)))

エラーの場合、‘let’は古い値をリストアするので、わたしたちは‘let’で
‘this-command’をバインドしない。この場合における‘let’の機能は、わたした
ちが避けたいと思っていることを正確に行ってしまうだろう。

 -- Variable: this-original-command
     コマンドのリマップ(*note Remapping Commands::を参照)が発生したとき
     を除き、これは‘this-command’と同じ値をもつ。リマップが発生した場合
     、‘this-command’は実際に実行されたコマンド、
     ‘this-original-command’は実行を指定されたが他のコマンドにリマップさ
     れたコマンドを与える。

 -- Function: this-command-keys
     この関数は、現在のコマンドを呼び出したキーシーケンスと、加えてその
     コマンドにたいするプレフィクス引数を生成した前のコマンドを含む文字
     列またはベクターをリターンする。‘read-event’を使用するコマンドによ
     り、タイムアウトせずに読み取られた任意のイベントは最後に加えられる
     。

     しかし、そのコマンドが‘read-key-sequence’を呼び出していた場合は、最
     後に読み取られたキーシーケンスをリターンする。*note Key Sequence
     Input::を参照のこと。シーケンス内のすべてのイベントが文字列として適
     当な文字の場合は、文字列が値になる。*note Input Events::を参照のこ
     と。

          (this-command-keys)
          ;; これを評価するために‘C-u C-x C-e’を使用すると、
               ⇒ "^U^X^E"

 -- Function: this-command-keys-vector
     ‘this-command-keys’と同様だが、常にベクターでイベントをリターンする
     ので、入力イベントを文字列内に格納する複雑さを処理する必要がない
     (*note Strings of Events::を参照)。

 -- Function: clear-this-command-keys &optional keep-record
     この関数は、‘this-command-keys’がリターンするイベントテーブルを空に
     する。KEEP-RECORDが‘nil’の場合は、その後に関数‘recent-keys’(*note
     Recording Input::)がリターンするレコードも空にする。これは特定のケ
     ースにおいて、パスワードを読み取った後、次のコマンドの一部として不
     用意にパスワードがエコーされるのを防ぐために有用である。

 -- Variable: last-nonmenu-event
     この変数はキーシーケンス(マウスメニューからのイベントは勘定しない
     )の一部として読み取られた最後の入力イベントを保持する。

     この変数の1つの使い方は、‘x-popup-menu’にたいしてどこにメニューをポ
     ップアップすべきか告げる場合である。これは内部的に‘y-or-n-p’(*note
     Yes-or-No Queries::を参照)にも使用されている。

 -- Variable: last-command-event
     この変数には、コマンドの一部としてコマンドループに読み取られた、最
     後の入力イベントがセットされる。この変数は主に、
     ‘self-insert-command’内でどの文字が挿入されたか判断するために使用さ
     れている。

          last-command-event
          ;; これを評価するために‘C-u C-x C-e’を使用すると、
               ⇒ 5

     ‘C-e’のASCIIコードの5が値になる。

 -- Variable: last-event-frame
     この変数は、最後の入力イベントが送られたフレームを記録する。これは
     通常、そのイベントが生成されたときに選択されていたフレームだが、そ
     のフレームの入力が他のフレームにリダイレクトされていた場合は、その
     リダイレクトされていたフレームが値となる。*note Input Focus::を参照
     のこと。

     最後のイベントがキーボードマクロ由来の場合、値は‘macro’になる。


File: elisp,  Node: Adjusting Point,  Next: Input Events,  Prev: Command Loop Info,  Up: Command Loop

20.6 Adjusting Point After Commands
===================================

プロパティ‘display’や‘composition’をｍつテキストや、非表示のテキストシー
ケンスの中間でポイント値を表示するのは、簡単ではありません。したがって、
コマンドが終了した後にコマンドループにリターンするとき、そのようなシーケ
ンス中にポイントがある場合、コマンドループは通常ポイントをそのようなシー
ケンスの端に移動します。

   変数‘disable-point-adjustment’をセットすることにより、コマンドはこの
機能を抑制できます:

 -- Variable: disable-point-adjustment
     この変数が非‘nil’の場合は、コマンドがコマンドループにリターンすると
     き、コマンドループはこれらのテキストプロパティをチェックせず、これ
     らのプロパティをもつシーケンスの外にポイントを移動しない。

     コマンドループはそれぞれのコマンドを実行する前にこの変数を‘nil’にセ
     ットするので、あるコマンドがこれをセットしても、効果が適用されるの
     はそのコマンドにたいしてだけである。

 -- Variable: global-disable-point-adjustment
     この変数を非‘nil’にセットした場合、これらのシーケンス外にポイントを
     移動する機能は、完全にオフになる。


File: elisp,  Node: Input Events,  Next: Reading Input,  Prev: Adjusting Point,  Up: Command Loop

20.7 Input Events
=================

Emacsコマンドループは“入力イベント(input events)”のシーケンスを読み取り
ます。入力イベントとは、キーボードやマウスのアクティビティ、または
Emacsに送られるシステムイベントを表します。キーボードアクティビティにた
いするイベントは文字、またはシンボルです。それ以外のイベントは、常にリス
トになります。このセクションでは、入力イベントの表現と意味について詳細を
説明します。

 -- Function: eventp object
     この関数は、OBJECTが入力イベント、またはイベント型の場合は、非
     ‘nil’をリターンする。

     イベント、またはイベント型として任意のシンボルが使用されるかもしれ
     ないことに注意。‘eventp’は、あるシンボルがLispコードによりイベント
     として使用されることを意図しているか否か区別できない。そのかわりに
     、カレントEmacsセッション内で、そのシンボルが入力として読み取られた
     イベント内で実際に使用されているか否かを区別する。シンボルがまだそ
     のように使用されていない場合、‘eventp’は‘nil’をリターンする。

* Menu:

* Keyboard Events::          通常の文字 —
                               自身にシンボルされるキー。
* Function Keys::            ファンクションキー —
                               名前をもつがシンボルではない。
* Mouse Events::             マウスイベントの概観。
* Click Events::             マウスボタンのプッシュとリリース。
* Drag Events::              ボタンをリリースする前のマウス移動。
* Button-Down Events::       ボタンがプッシュされて、まだリリースされていない状態。
* Repeat Events::            ダブル、トリプルのクリック(またはドラッグ、ダウン)
* Motion Events::            ボタンを押さずに、マウスだけを移動する。
* Focus Events::             フレーム間のマウス移動。
* Misc Events::              システムが生成可能なその他のイベント。
* Event Examples::           マウスイベントの例。
* Classifying Events::       イベントシンボル内の修飾キーを見つける。イベント型。
* Accessing Mouse::          マウスイベントから情報抽出する関数。
* Accessing Scroll::         スクロールバーイベントから情報取得する関数。
* Strings of Events::        文字列内にキーボード文字イベントを配すための特別な配慮。


File: elisp,  Node: Keyboard Events,  Next: Function Keys,  Up: Input Events

20.7.1 Keyboard Events
----------------------

キーボードから取得できる入力には2つの種類があります。それは通常のキーと
ファンクションキーです。通常のキーは文字に対応し、それらが生成するイベン
トはLisp内では文字で表現されます。文字イベントのイベント型は文字自身(整
数)です。*note Classifying Events::を参照してください。

   入力文字イベントは0から524287までの“基本コード(basic code)”に加えて、
以下の“修飾ビット(modifier bits)”の一部、またはすべてにより構成されます:

meta
     文字コードのビット 2**27 はメタキーが押下された状態で文字がタイプさ
     れたことを示す。

control
     文字コードのビット 2**26 は非ASCIIコントロール文字を示す。

     ‘C-a’のような非ASCIIコントロール文字は、自身が特別な基本コードをも
     つため、それらを示すためにEmacsは特別なビットを必要としない。つまり
     ‘C-a’のコードは単なる1である。

     しかし、‘%’のような非ASCIIとコントロールを組み合わせてタイプした場
     合、取得される数値は‘%’に 2**26 を加えた値となる(端末が非ASCIIコン
     トロール文字をサポートすると仮定する)。

shift
     文字コードのビット 2**25 はシフトキーが押下された状態でASCIIコント
     ロール文字がタイプされたことを示す。

     アルファベット文字にたいしては、基本コード自身が大文字か小文字かを
     示す。数字と句読点文字にたいしてシフトキーは、異なる基本コードをも
     つ完全に違う文字を選択する。可能な限りASCII文字として保つために、
     Emacsはこれらの文字にたいしてビット 2**25 を使用しない。

     しかし、ASCIIは‘C-A’と‘C-a’を区別する方法を提供しないので、Emacsは
     ‘C-A’にたいしてビット 2**25 を使用し、‘C-a’には使用しない。

hyper
     文字コードのビット 2**24 はハイパーキーが押下された状態で文字がタイ
     プされたことを示す。

super
     文字コードのビット 2**23 はスーパーキーが押下された状態で文字がタイ
     プされたことを示す。

alt
     文字コードのビット 2**22 はアルトキーが押下された状態で文字がタイプ
     されたことを示す(ほとんどのキーボードで<Alt>とラベルされたキーは、
     実際にはアルトキーではなくメタキーとして扱われる)。

   プログラム内での特定のビット数値の記述は避けるのが最善の方法です。文
字の修飾ビットをテストするためには、関数‘event-modifiers’(*note
Classifying Events::を参照)を使用してください。キーバインディングを作成
するときは、修飾ビットつきの文字にたいする読み取り構文を使用できます
(‘\C-’、‘\M-’、...など)。‘define-key’でのキーバインディング作成では、文
字を指定するために‘(control hyper ?x)’のようなリストを使用できます(*note
Changing Key Bindings::を参照)。関数‘event-convert-list’は、そのようなリ
ストをイベント型に変換します(*note Classifying Events::を参照)。


File: elisp,  Node: Function Keys,  Next: Mouse Events,  Prev: Keyboard Events,  Up: Input Events

20.7.2 Function Keys
--------------------

ほとんどのキーボードには“ファンクションキー(function keys)”があります。
これは名前、または文字以外のシンボルをもつキーです。Emacs Lispではファン
クションキーはシンボルとして表現されます。そのシンボル名はファンクション
キーのラベルの小文字です。たとえば<F1>とラベルされたキーを押下すると、シ
ンボル‘f1’で表される入力イベントが生成されます。

   ファンクションキーのイベント型は、イベントシンボルそれ自身です。*note
Classifying Events::を参照してください。

   ファンクションキーにたいするシンボルネーミングの慣習には、以下のよう
な特別なケースがいくつかあります:

‘backspace’、‘tab’、‘newline’、‘return’、‘delete’
     これらのキーは、ほとんどのキーボードにおいて特別にキーをもつ、一般
     的なASCIIコントロール文字に対応する。

     ASCIIでは‘C-i’と<TAB>は同じ文字である。端末がこれらを区別できる場合
     、Emacsは前者を整数の9、後者をシンボル‘tab’で表現することにより、
     Lispプログラムにこれらの違いを伝える。

     ほとんどの場合、これら2つを区別するのは役に立たない。そのため
     ‘local-function-key-map’(*note Translation Keymaps::を参照)は
     ‘tab’を9にマップするようセットアップされている。したがって文字コー
     ド9(文字‘C-i’)へのキーバインディングは‘tab’にも適用される。このグル
     ープ内の他のシンボルも同様である。関数‘read-char’が、これらのイベン
     トを文字に変換する場合も同様である。

     ASCIIでは、<BS>は実際は‘C-h’である。しかし‘backspace’は文字コード
     8(<BS>)ではなく、文字コード127(<DEL>)に変換される。ほとんどのユーザ
     ーにとって、これは好ましいだろう。

‘left’、‘up’、‘right’、‘down’
     矢印カーソルキー
‘kp-add’、‘kp-decimal’、‘kp-divide’、...
     キーパッドキー(標準的なキーボードにおいては右側にある)。
‘kp-0’、‘kp-1’、...
     キーパッド数字キー。
‘kp-f1’、‘kp-f2’、‘kp-f3’、‘kp-f4’
     キーパッドPFキー。
‘kp-home’、‘kp-left’、‘kp-up’、‘kp-right’、‘kp-down’
     キーパッド矢印キー。Emacsは通常これらを非キーパッドのキー‘home’、
     ‘left’、...に変換する。
‘kp-prior’、‘kp-next’、‘kp-end’、‘kp-begin’、‘kp-insert’、‘kp-delete’
     通常は他の箇所にあるキーと重複するキーパッド追加キー。Emacsは通常こ
     れらを同じような名前の非キーパッドキーに変換する。

   ファンクションキーにたいしても修飾キー<ALT>、<CTRL>、<HYPER>、
<META>、<SHIFT>、<SUPER>を使用できます。シンボル名のプレフィクスとしてこ
れらを表します:

‘A-’
     アルト修飾。
‘C-’
     コントロール修飾。
‘H-’
     ハイパー修飾。
‘M-’
     メタ修飾。
‘S-’
     シフト修飾。
‘s-’
     スーパー修飾。

   したがって、<META>を押下した場合の<F3>キーにたいするシンボルは
‘M-f3’になります。複雑のプレフィクスを使用する場合は、アルファベット順に
記述することを推奨します。とはいえ、キーバインディングが修飾されたファン
クションキーを探す際、引数の順序は関係ありません。


File: elisp,  Node: Mouse Events,  Next: Click Events,  Prev: Function Keys,  Up: Input Events

20.7.3 Mouse Events
-------------------

Emacsは4つの種類のマウスイベントをサポートします。それはクリックイベント
、ドラッグイベント、ボタンダウンイベント、モーションイベントです。すべて
のマウスイベントはリストで表現されます。このリストのCARはイベント型です
。イベント型はどのマウスボタンが関与するのか、それにたいしてどの修飾キー
が使用されたかを示します。イベント型によりダブル、あるいはトリプルでボタ
ンが押されたかを区別することもできます(*note Repeat Events::を参照)。残
りのリスト要素は、位置と時間の情報を提供します。

   キーの照合においては、イベント型だけが問題になります。2つのイベントが
同じコマンドを実行するためには、同じイベント型が必要です。実行されるコマ
ンドはinteractiveのコード‘e’を使用して、これらのイベントの完全な値にアク
セスできます。*note Interactive Codes::を参照してください。

   マウスイベントで開始されたキーシーケンスはカレントバッファーではなく
、マウスのあったウィンドウ内のバッファーのキーマップを使用して読み取られ
ます。これはウィンドウ内でクリックすることによりそのウィンドウやそのウィ
ンドウのバッファーが選択されることを意味しません。つまり、それは完全にそ
のキーシーケンスのコマンドバインディングの制御下にあるのです。


File: elisp,  Node: Click Events,  Next: Drag Events,  Prev: Mouse Events,  Up: Input Events

20.7.4 Click Events
-------------------

ユーザーが同じ場所でマウスボタンを押してからリリース(release: 離す)する
と、“click”イベントが生成されます。すべてのマウスクリックイベントは同じ
フォーマットを共有します:

     (EVENT-TYPE POSITION CLICK-COUNT)

EVENT-TYPE
     これはマウスボタンが使用されたことを示す。これはシンボル‘mouse-1’、
     ‘mouse-2’、...のうちのどれかで、マウスボタンは左から右に番号が付さ
     れる。

     ファンクションキーにたいして行うのと同様にアルト、コントロール、ハ
     イパー、メタ、シフト、スーパーの修飾にたいしてプレフィクス‘A-’、
     ‘C-’、‘H-’、‘M-’、‘S-’、‘s-’も使用できる。

     このシンボルは、イベントのイベント型の役割りももつ。イベントのキー
     バインディングはこれらの型により示される。したがって、‘mouse-1’にた
     いするキーバインディングが存在する場合、そのバインディングは
     EVENT-TYPEが‘mouse-1’であるようなすべてのイベントに適用されるだろう
     。

POSITION
     これはマウスクリックがどこで発生したかを表す“マウス位置リスト(mouse
     position list)”である。詳細は以下を参照のこと。

CLICK-COUNT
     これは同じマウスボタンを素早く繰り返し押下したときの回数である。
     *note Repeat Events::を参照のこと。

   クリックイベントのPOSITIONスロット内にあるマウス位置リストの内容にア
クセスするためには、一般的には*note Accessing Mouse::にドキュメントされ
ている関数を使用するべきです。このリストの明示的なフォーマットは、どこで
クリックが発生したかに依存します。テキストエリア、モードライン、ヘッダー
ライン、フリンジ、マージンエリアでのクリックにたいして、マウス位置リスト
は以下のフォーマットをもちます

     (WINDOW POS-OR-AREA (X . Y) TIMESTAMP
      OBJECT TEXT-POS (COL . ROW)
      IMAGE (DX . DY) (WIDTH . HEIGHT))

以下はこれらのリスト要素がもつ意味です:

WINDOW
     クリックが発生したウィンドウ。

POS-OR-AREA
     テキストエリア内でクリックされた文字のバッファー位置。またはテキス
     トエリア外がクリックされた場合は、クリックが発生したウィンドウエリ
     ア。これはシンボル‘mode-line’、‘header-line’、‘vertical-line’、
     ‘left-margin’、‘right-margin’、‘left-fringe’、‘right-fringe’のどれ
     か。

     特別な場合の1つとして、POS-OR-AREAが単なるシンボルではなく、(上記シ
     ンボルのいずれか1つの)シンボルを含むリストの場合がある。これは
     Emacsにより登録されたイベントにたいする、イマジナリープレフィクスキ
     ー(imaginary prefix key)の後に発生する。*note Key Sequence Input::を
     参照のこと。

X, Y
     クリックの相対ピクセル座標(relative pixel coordinates)。あるウィン
     ドウのテキストエリア内でのクリックにたいする座標原点‘(0 . 0)’は、テ
     キストエリアの左上隅となる。*note Window Sizes::を参照のこと。モー
     ドラインまたはヘッダーライン内でのクリックにたいする座標原点は、そ
     のウィンドウ自身の左上隅となる。フリンジ、マージン、垂直ボーダー
     (vertical border)では、Xな有意なデータをもたない。フリンジ、マージ
     ンでは、Yはヘッダーラインの最下端からの相対位置である。すべてのケー
     スにおいてXおよびY座標は右方向および下方向で増加する。

TIMESTAMP
     そのイベントが発生した時刻を、システム依存の初期時刻(initial time)か
     らの経過ミリ秒で表す整数。

OBJECT
     クリック位置に文字列タイプのテキストプロパティが存在しない場合は
     ‘nil’、存在する場合は(STRING .  STRING-POS)形式のコンスセル:

     STRING
          クリックされた文字列。すべてのテキストプロパティを含む。

     STRING-POS
          クリックが発生した文字列内の位置。

TEXT-POS
     マージンエリアまたはフリンジにたいするクリックでは、そのウィンドウ
     内の対応する行内の最初の可視な文字のバッファー位置となる。他のイベ
     ントにたいしては、そのウィンドウ内のカレントバッファーの位置となる
     。

COL, ROW
     これらはX、Yの位置にあるグリフ(gliph)の、実際の行と列の座標数値であ
     る。行Xがその行の実際のテキストの最後の列を超える場合、COLはデフォ
     ルトの文字幅をもつ仮想的な追加列数を加えた値が報告される。そのウィ
     ンドウがヘッダーラインをもつ場合、行0はヘッダーラインとなり、ヘッダ
     ーラインをもたない場合はテキストエリアの上端ラインが行0となる。ウィ
     ンドウのテキストエリアのクリックにたいしては、テキストエリアの左端
     列が列0となり、モードラインまたはヘッダーラインのクリックにたいして
     はそのラインの左端が列0となる。フリンジまたは垂直ボーダーのクリック
     にたいしては、これらは有意なデータをもたない。マージンのクリックに
     たいしては、COLはマージンエリアの左端、ROWはマージンエリアの上端か
     ら測られる。

IMAGE
     これはクリックが発生した場所のイメージオブジェクトである。クリック
     された場所にイメージが存在しない場合は‘nil’、イメージがクリックされ
     た場合は‘find-image’によりリターンされるイメージオブジェクトである
     。

DX, DY
     これらはOBJECTの左上隅‘(0 . 0)’からの相対的ピクセル座標である。
     OBJECTが‘nil’の場合は、クリックされた文字グリフの左上隅からの相対座
     標である。

WIDTH, HEIGHT
     これらはOBJECTのピクセル幅とピクセル高さであり、OBJECTが‘nil’の場合
     はクリックされた文字グリフのピクセル幅とピクセル高さである。

   スクロールバーへのクリックにたいして、POSITIONは以下の形式をもちます:

     (WINDOW AREA (PORTION . WHOLE) TIMESTAMP PART)

WINDOW
     スクロールバーがクリックされたウィンドウ。

AREA
     これはシンボル‘vertical-scroll-bar’である。

PORTION
     スクロールバーの上端からクリック位置までのピクセル数。GTK+を含むい
     くつかのツールキットでは、Emacsがこれらのデータを抽出できないので、
     値は常に‘0’となる。

WHOLE
     スクロールバーの全長のピクセル数。GTK+を含むいくつかのツールキット
     では、Emacsがこれらのデータを抽出できないので、値は常に‘0’となる。

TIMESTAMP
     イベントが発生したミリ秒時刻。GTK+を含むいくつかのツールキットでは
     、Emacsがこれらのデータを抽出できないので、値は常に‘0’となる。

PART
     クリックが発生したスクロールバー部分。これはシンボル‘handle’(スクロ
     ールバーのハンドル)、‘above-handle’(ハンドルの上側エリア)、
     ‘below-handle’(ハンドルの下側エリア)、‘up’(スクロールバー端の上矢印
     )、‘down’(スクロールバー端の下矢印)のいずれかである。


File: elisp,  Node: Drag Events,  Next: Button-Down Events,  Prev: Click Events,  Up: Input Events

20.7.5 Drag Events
------------------

Emacsでは、特別なことをしなくてもドラッグイベントを取得できます。“ドラッ
グイベント(drag event)”は、ユーザーがマウスボタンを押下して、ボタンをリ
リースする前に、マウスを異なる文字位置に移動すると毎回発生します。すべて
のマウスイベントと同じように、ドラッグイベントはLispではリストで表現され
ます。このリストは以下のように、開始マウス位置と最終位置ぼ両方を記録しま
す:

     (EVENT-TYPE
      (WINDOW1 START-POSITION)
      (WINDOW2 END-POSITION))

   ドラッグイベントにたいしては、シンボルEVENT-TYPEの名前に、プレフィク
ス‘drag-’が含まれます。たとえば、ボタン2を押下したままマウスをドラッグす
ると、‘drag-mouse-2’イベントが生成されます。このイベントの2つ目と3つ目の
要素は、マウス位置リスト(*note Click Events::を参照)としてドラッグの開始
と終了の位置を与えます。任意のマウスイベントの2つ目の要素には、同じ方法
でアクセスできます。しかし、ドラッグイベントは最初に選択されていたフレー
ムの境界外で終了するかもしれません。この場合、3つ目の要素の位置リストに
、ウィンドウのかわりにそのフレームが含まれます。

   ‘drag-’プレフィクスは、その後に‘C-’や‘M-’のような修飾キープレフィクス
が続きます。

   ‘read-key-sequence’がキーバインディングをもたず、対応するクリックイベ
ントにキーバインディングがあるようなドラッグイベントを受け取った場合、こ
の関数はそのドラッグイベントをドラッグ開始位置でのクリックイベントに変更
します。これは、もし望まなければクリックイベントとドラッグイベントを区別
する必要がないことを意味します。


File: elisp,  Node: Button-Down Events,  Next: Repeat Events,  Prev: Drag Events,  Up: Input Events

20.7.6 Button-Down Events
-------------------------

クリックイベントとドラッグイベントは、ユーザーがマウスボタンをリリースし
たときに発生します。ボタンがリリースされるまでクリックとドラッグを区別す
ることはできないので、リリース前にイベントが発生することはありません。

   ボタンが押下されたらすぐに何か処理したい場合は、“ボタンダウン
(button-down)”イベントを処理する必要があります(1)。これらはEVENT-TYPEの
シンボル名に‘down-’が含まれることを除き、クリックイベントとまったく同じ
ようなリストにより表現されます。‘down-’プレフィクスの後には、‘C-’や
‘M-’のような修飾キープレフィクスが続きます。

   関数‘read-key-sequence’は、コマンドバインディングをもたないボタンダウ
ンイベントを無視します。したがって、Emacsコマンドループもこれらを無視し
ます。これは、ボタンダウンイベントで何かしたい場合以外は、ボタンダウンイ
ベントの定義について心配する必要がないことを意味します。ボタンダウンイベ
ントを定義する通常の理由は、ボタンがリリースされるまで(モーションイベン
トを読み取ることにより)マウスモーションを追跡できるからです。*note
Motion Events::を参照してください。

   ---------- Footnotes ----------

   (1) ボタンダウン(button-down)はドラッグ(drag)の保守的なアンチテーゼで
す(訳注: 原文は“Button-down is the conservative antithesis of drag.”。ボ
タンダウンを着るような人種と麻薬を対比させたジョークのような気がしますが
、すいません、よく分からないので直訳します)。


File: elisp,  Node: Repeat Events,  Next: Motion Events,  Prev: Button-Down Events,  Up: Input Events

20.7.7 Repeat Events
--------------------

マウスを移動せずに同じマウスボタンを素早く2回以上連続して押下すると、
Emacsは2回目とそれ以降の押下にたいして、特別な“リピート(repeat)”マウスイ
ベントを生成します。

   もっとも一般的なリピートイベントは、“ダブルクリック(double-click)”イ
ベントです。Emacsはボタンを2回クリックしたときに、ダブルクリックイベント
を生成します。このイベントは、(すべてのクリックイベントが通常そうである
ように)ボタンをリリースしたときに発生します。

   ダブルクリックイベントのイベント型には、プレフィクス‘double-’が含まれ
ます。したがって、<meta>を押しながら2つ目のマウスボタンをダブルクリック
すると、Lispプログラムには‘M-double-mouse-2’が渡されます。ダブルクリック
イベントがバインディングをもたない場合、対応する通常のクリックイベントの
バインディングが実行に使用されます。したがって、実際に望んでいなければダ
ブルクリック機能に注意を払う必要はありません。

   ユーザーがダブルクリックを行うとき、Emacsはまず通常のクリックイベント
を生成し、その後ダブルクリックイベントを生成します。したがって、ダブルク
リックイベントのコマンドバインディングは、すでにシングルクリックイベント
が実行された想定でデザインしなければなりません。つまりシングルクリックの
結果から開始して、ダブルクリックの望むべき結果を生成しなければならないの
です。

   これはダブルクリックの意味合いが、シングルクリックの意味合いの何らか
にもとづいて“構築”される場合は便利です。これはダブルクリックにたいするユ
ーザーインターフェイスにおける推奨されるデザインプラクティスです。

   ボタンをクリックした後もう一度ボタンを押下して、そのままマウス一般的
を開始した場合、最終的にボタンをリリースしたとき“ダブルドラッグ
(double-drag)”イベントが取得されます。このイベント型には単なる‘drag’のか
わりに‘double-drag’が含まれます。ダブルドラッグイベントがバインディング
をもたない場合、それがあたかも通常のドラッグイベントだったかのように
Emacsはかわりのバインディングを探します。

   ダブルクリックまたはダブルドラッグイベントの前に、Emacsはユーザーが
2回目にボタンを押したタイミングで“ダブルダウン(double-down)”イベントを生
成します。このイベント型には、単なる‘down’のかわりに‘double-down’が含ま
れます。ダブルダウンイベントがバインディングをもたない場合、それがあたか
も通常のボタンダウンイベントだったかのようにEmacsはかわりのバインディン
グを探します。どちらの方法でもバインディングが見つからなかった場合、ダブ
ルダウンイベントは無視されます。

   要約すると、ボタンをクリックしてすぐにまた押したとき、Emacsは1回目の
クリックにたいしてダウンイベントとクリックイベントを生成し、2回目に再度
ボタンを押したときにダブルダウンイベント、そして最後にダブルクリックまた
はダブルドラッグイベントを生成します。

   ボタンを2回クリックした後もう一度押したとき、それらすべてが素早く連続
で行われた場合、Emacsは“トリプルダウン(triple-down)”イベントと、その後続
の“トリプルクリック(triple-click)”または“トリプルドラッグ
(triple-drag)”イベントを生成します。これらイベントのイベント型には、
‘double’のかわりに‘triple’が含まれます。トリプルイベントがバインディング
をもたない場合、Emacsは対応するダブルイベントに使用されるであろうバイン
ディングを使用します。

   ボタンを3回以上クリックした後、再度ボタンを押した場合、3回を超える押
下にたいするイベントはすべてトリプルイベントになります。Emacsはクワドル
ープル(quadruple: 4連)、クインティプル(quintuple: 5連)、...等のイベント
にたいして個別のイベント型をもちません。しかし、ボタンが何回押下されたか
を正確に見つけるために、イベントリストを調べることができます。

 -- Function: event-click-count event
     この関数はEVENTを誘因した連続したボタン押下の回数をリターンする。
     EVENTがダブルダウン、ダブルクリック、ダブルドラッグの場合、値は2で
     ある。EVENTがトリプルイベントの場合、値は3以上になる。EVENTが(リピ
     ートイベントではない)通常のマウスイベントの場合、値は1である。

 -- User Option: double-click-fuzz
     リピートイベントを生成するためには、ほぼ同じスクリーン位置で連続で
     マウスボタンを押下しなければならない。‘double-click-fuzz’の値は、ダ
     ブルクリックを生成するために連続する2回のクリック間で、マウスが移動
     (水平および垂直)するかもしれない最大ピクセル数を指定する。

     この変数はドラッグとみなされるマウスモーションの閾値でもある。

 -- User Option: double-click-time
     リピートイベントを生成するためには、連続するボタン押下のミリ秒間隔
     が、‘double-click-time’の値より小さくなければならない。
     ‘double-click-time’を‘nil’にセットすると、複数回クリック検知が完全
     に無効になる。‘t’にセットすると、時間制限が取り除かれる。その場合、
     Emacsは位置だけで複数回クリックを検知する。


File: elisp,  Node: Motion Events,  Next: Focus Events,  Prev: Repeat Events,  Up: Input Events

20.7.8 Motion Events
--------------------

Emacsは、ボタンアクティビティが何もないマウスのモーション(motion: 動き
)を記述する“マウスモーション(mouse motion)”イベントを生成するときがあり
ます。マウスモーションイベントは、以下のようなリストにより表現されます:

     (mouse-movement POSITION)

POSITIONは、マウスカーソルのカレント位置を指定するマウス位置リスト(*note
Click Events::)です。ドラッグイベントの終了位置のように、この位置リスト
は最初に選択されていた境界外の位置を表すかもしれず、その場合はそのフレー
ム内のその位置のウィンドウが含まれる。

   スペシャルフォーム‘track-mouse’は、ボタン内でのモーションイベントの生
成を有効にします。‘track-mouse’フォームの外側では、Emacsはマウスの単なる
モーションにたいするイベントは生成せず、これらのイベントは発生しません。
*note Mouse Tracking::を参照してください。


File: elisp,  Node: Focus Events,  Next: Misc Events,  Prev: Motion Events,  Up: Input Events

20.7.9 Focus Events
-------------------

ウィンドウシステムは、ユーザーにたいしてどのウィンドウがキーボード入力を
受け取るか制御するための、一般的な方法を提供します。このウィンドウ選択は
“フォーカス(focus)”と呼ばれます。Emacsのフレームを切り替えるためにユーザ
ーが何かを行うと、それは“フォーカスイベント(focus event)”を生成します。
フォーカスイベントの通常の定義はグローバルキーマップ内にあり、ユーザーが
期待するようにEmacsで新たなフレームを選択するためのものです。*Note Input
Focus::を参照してください。

   フォーカスイベントは、以下のようにLispのリストで表現されます:

     (switch-frame NEW-FRAME)

ここでNEW-FRAMEは切り替え先のフレームです。

   Xウィンドウマネージャーには、あるウィンドウにマウスを移動するだけで、
そこにフォーカスされるようにセットアップするものがいくつかあります。通常
は、他の種類の入力が到着するまで、Lispプログラムがフォーカスの変更を知る
必要はありません。Emacsはユーザーが新たなフレーム内で実際にキーボードの
キーをタイプするかマウスボタンを押下したときしか、フォーカスイベントを生
成しません。つまりフレーム間でマウスを移動させても、フォーカスイベントは
生成されません。

   キーシーケンスの途中におけるフォーカスイベントは、そのシーケンスを誤
ったものにするかもしれません。そのため、Emacsは決してキーシーケンスの途
中でフォーカスイベントを生成しません。ユーザーがキーシーケンスの途中(つ
まりプレフィクス引数の後)でフォーカスを変更した場合、複数イベントキーシ
ーケンスの前か後にフォーカスイベントが到着するように、Emacsはフォーカス
イベントを記録しておきます。


File: elisp,  Node: Misc Events,  Next: Event Examples,  Prev: Focus Events,  Up: Input Events

20.7.10 Miscellaneous System Events
-----------------------------------

他にもシステム内での出来事を表現するイベント型が少数あります。

‘(delete-frame (FRAME))’
     このイベントの種類は、ユーザーがウィンドウマネージャーに特定のウィ
     ンドウを削除するコマンドを与えたことを示し、Emacsのフレームにたいし
     て発生する。

     ‘フレーム削除(delete-frame)’イベントの標準的な定義は、FRAMEを削除す
     る。

‘(iconify-frame (FRAME))’
     このイベントの種類は、ウィンドウマネージャーを使用してユーザーが
     FRAMEをアイコン化したことを示す。標準的な定義は‘ignore’である。これ
     は、そのフレームがすでにアイコン化されているので、Emacsが行う必要の
     ことは何もないからである。このイベント型の目的は、望むならこのよう
     なイベントの追跡を可能にしておくためである。

‘(make-frame-visible (FRAME))’
     このイベントの種類は、ウィンドウマネージャーを使用してユーザーが
     FRAMEを非アイコン化したことを示す。標準的な定義は‘ignore’である。こ
     れは、そのフレームがすでに可視化されているので、Emacsが行う必要のこ
     とは何もないからである。

‘(wheel-up POSITION)’
‘(wheel-down POSITION)’
     この種類のイベントは、マウスホイールを移動したことにより発生する。
     POSITION要素は、そのイベント発生時のマウスカーソル位置を指定するマ
     ウス位置リスト(*note Click Events::を参照)である。

     この種類のイベントは、ある種のシステムでのみ発生する。いくつかのシ
     ステムでは、かわりに‘mouse-4’と‘mouse-5’が使用される。可搬性のある
     コードとするためには、マウスホイールにたいしてどのイベント型が期待
     されるかを決定するために‘mwheel.el’内で定義されている変数
     ‘mouse-wheel-up-event’および‘mouse-wheel-down-event’を使用する。

‘(drag-n-drop POSITION FILES)’
     この種類のイベントは、Emacs外部アプリケーション内でファイルグループ
     が選択され、それがEmacsフレーム内にドラッグアンドドロップされたとき
     に発生する。

     要素POSITIONは、そのイベント位置を記述しマウスクリックイベントで使
     用されるフォーマット(*note Click Events::を参照)と同じである。要素
     FILESはドラッグアンドドロップされたファイル名のリストである。通常は
     、それらのファイルをvisitすることにより、このイベントは処理される。

     この種類のイベントは、現在のところある種のシステムでのみ生成される
     。

‘help-echo’
     この種類のイベントは、テキストプロパティ‘help-echo’をもつバッファー
     テキスト部分上にマウスポインターが移動したときに生成される。生成さ
     れるイベントは以下の形式をもつ:

          (help-echo FRAME HELP WINDOW OBJECT POS)

     イベントパラメーターの正確な意味と、ヘルプテキストを表示するために
     これらのパラメーターを使用する方法は、*note Text help-echo::で説明
     されているか

‘sigusr1’
‘sigusr2’
     これらのイベントは、Emacsプロセスがシグナル‘SIGUSR1’および
     ‘SIGUSR2’を受け取ったときに生成される。シグナルは追加情報を運搬しな
     いので、追加データは含まれない。これらのシグナルはデバッグに有用で
     ある(*note Error Debugging::を参照)。

     ユーザーシグナルをcatchするためには、‘special-event-map’(*note
     Active Keymaps::を参照)内で対応するイベントにバインドする。そのコマ
     ンドは引数なしで呼び出され、‘last-input-event’内の特定のシグナルイ
     ベントが利用できる。たとえば:

          (defun sigusr-handler ()
            (interactive)
            (message "Caught signal %S" last-input-event))

          (define-key special-event-map [sigusr1] 'sigusr-handler)

     シグナルハンドラーをテストするために、自身でEmacsにシグナルを送信で
     きる:

          (signal-process (emacs-pid) 'sigusr1)

‘language-change’
     この種類のイベントは、MS-Windows上で入力言語が変更されたときに生成
     される。これは通常、キーボードキーが異なる言語の文字でEmacsに送られ
     ることを意味する。生成されるイベントは、以下の形式をもつ:

          (language-change FRAME CODEPAGE LANGUAGE-ID)

     ここでFRAMEは言語が変更されたときカレントだったフレームであり、
     CODEPAGEは新たなコードページ番号(codepage number)、LANGUAGE-IDは新
     たな入力言語の数値IDである。CODEPAGEに対応するコーディングシステム
     (*note Coding Systems::を参照)は、‘cpCODEPAGE’または
     ‘windows-CODEPAGE’である。LANGUAGE-IDを文字列に変更する(たとえば
     ‘set-language-environment’のようなさまざまな言語依存機能にたいしこ
     れを使用する)には、以下のように‘w32-get-locale-info’関数を使用する:

          ;; 英語にたいする"ENU"のような言語の省略形を取得する
          (w32-get-locale-info language-id)
          ;; "English (United States)"のような
          ;; その言語の完全な英語名を取得する
          (w32-get-locale-info language-id 4097)
          ;; その言語の完全なローカライズ名を取得する
          (w32-get-locale-info language-id t)

   キーシーケンスの途中、つまりプレフィクスキーの後にこれらのイベントの
1つが到着した場合、複数イベントキー内ではなくその前または後にそのイベン
トが到着するように、Emacsはそのイベントを記録する。


File: elisp,  Node: Event Examples,  Next: Classifying Events,  Prev: Misc Events,  Up: Input Events

20.7.11 Event Examples
----------------------

ユーザーが同じ場所でマウス左ボタンを押して離した場合、それは以下のような
イベントシーケンスを生成します:

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

   コントロールキーを押したままユーザーがマウス第2ボタンを押してマウスを
ある行から次の行へドラッグした場合、以下のような2つのイベントが生成され
ます:

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

   メタキーとシフトキーを押したままユーザーがそのウィンドウのモードライ
ン上でマウス第2ボタンを押して他ウィンドウへマウスをドラッグした場合、以
下のようなイベントのペアーが生成されます:

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))

   全画面表示されていないフレームに入力フォーカスがあり、ユーザーがマウ
スをそのフレームのスコープ外へマウスを移動した場合、スペシャルフォーム
‘track-mouse’内では以下のようなイベントが生成されます:

     (mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))

   SIGUSR1シグナルを処理するためにはインタラクティブ関数を定義して、それ
を‘signal usr1’イベントシーケンスにバインドします:

     (defun usr1-handler ()
       (interactive)
       (message "Got USR1 signal"))
     (global-set-key [signal usr1] 'usr1-handler)


File: elisp,  Node: Classifying Events,  Next: Accessing Mouse,  Prev: Event Examples,  Up: Input Events

20.7.12 Classifying Events
--------------------------

すべてのイベントは“イベント型(event type)”をもちます。イベント型はキーバ
インディング目的でイベントをクラス分けします。キーボードイベントにたいす
るイベント型はイベント値と等しく、したがって文字のイベント型は文字、ファ
ンクションキーシンボルのイベント型はそのシンボル自身です。リストであるよ
うなイベントのイベント型は、そのリストのCAR内のシンボルです。したがって
、イベント型は常にシンボルか文字です。

   同じ型の２つのイベントはキーバインディングに関する限り同じです。した
がって、それらは常に同じコマンドを実行します。これらが同じことを行う必要
があるという意味ではありませんが、イベント全体を調べてから何を行うか決定
するコマンドもいくつかあります。、たとえば、バッファー内でどこに作用する
か決定するためにマウスイベントの場所を使用するコマンドもいくつかあります
。

   広範なイベントのクラス分けが役に立つときもあります。たとえば、他の修
飾キーやマウスボタンが使用されたかとは無関係に、<META>キーとともに呼び出
されたイベントを尋ねたいと思うかもしれません。

   関数‘event-modifiers’は‘event-basic-type’は、そのような情報を手軽に取
得するために提供されています。

 -- Function: event-modifiers event
     この関数は、EVENTがもつ修飾子のリストをリターンする。この修飾子はシ
     ンボルであり‘shift’、‘control’、‘meta’、‘alt’、‘hyper’、‘super’が含
     まれる。さらにマウスイベントシンボルの修飾子リストには常に‘click’、
     ‘drag’、‘down’のいずれか1つが含まれる。ダブルイベントまたはトリプル
     イベントには‘double’または‘triple’も含まれる。

     引数EVENTはイベントオブジェクト全体、または単なるイベント型かもしれ
     ない。EVENTがカレントEmacsセッション内で入力として読み取られたイベ
     ント内で決して使用されないシンボルの場合は、実際にEVENTが変更された
     ときでも、‘event-modifiers’は‘nil’をリターンできる。

     いくつか例を挙げる:

          (event-modifiers ?a)
               ⇒ nil
          (event-modifiers ?A)
               ⇒ (shift)
          (event-modifiers ?\C-a)
               ⇒ (control)
          (event-modifiers ?\C-%)
               ⇒ (control)
          (event-modifiers ?\C-\S-a)
               ⇒ (control shift)
          (event-modifiers 'f5)
               ⇒ nil
          (event-modifiers 's-f5)
               ⇒ (super)
          (event-modifiers 'M-S-f5)
               ⇒ (meta shift)
          (event-modifiers 'mouse-1)
               ⇒ (click)
          (event-modifiers 'down-mouse-1)
               ⇒ (down)

     クリックイベントにたいする修飾リストは明示的に‘click’を含むが、イベ
     ントシンボル名自身は‘click’を含まない。

 -- Function: event-basic-type event
     この関数はEVENTを記述するキー、またはマウスボタンをリターンする。
     EVENT引数は‘event-modifiers’の場合と同様。たとえば:

          (event-basic-type ?a)
               ⇒ 97
          (event-basic-type ?A)
               ⇒ 97
          (event-basic-type ?\C-a)
               ⇒ 97
          (event-basic-type ?\C-\S-a)
               ⇒ 97
          (event-basic-type 'f5)
               ⇒ f5
          (event-basic-type 's-f5)
               ⇒ f5
          (event-basic-type 'M-S-f5)
               ⇒ f5
          (event-basic-type 'down-mouse-1)
               ⇒ mouse-1

 -- Function: mouse-movement-p object
     OBJECTがマウス移動イベントの場合、この関数は非‘nil’をリターンする。

 -- Function: event-convert-list list
     この関数は修飾子名リストと基本イベント型(basic event type)を、それ
     らすべてを指定するイベント型に変換する。基本イベント型はそのリスト
     の最後の要素でなければならない。たとえば、

          (event-convert-list '(control ?a))
               ⇒ 1
          (event-convert-list '(control meta ?a))
               ⇒ -134217727
          (event-convert-list '(control super f1))
               ⇒ C-s-f1


File: elisp,  Node: Accessing Mouse,  Next: Accessing Scroll,  Prev: Classifying Events,  Up: Input Events

20.7.13 Accessing Mouse Events
------------------------------

このセクションではマウスボタンやモーションイベント内のデータアクセスに役
に立つ関数を説明します。同じ関数を使用してキーボードイベントデータにもア
クセスできますが、キーボードイベントに不適切なデータ要素は0または‘nil’に
なります。

   以下の2つの関数は、マウスイベントの位置を指定するマウス位置リスト
(*note Click Events::)をリターンします。

 -- Function: event-start event
     これはEVENTの開始位置をリターンする。

     EVENTがクリックイベントまたはボタンダウンイベントの場合、この関数は
     そのイベントの位置をリターンする。EVENTがドラッグイベントの場合は、
     そのドラッグの開始位置をリターンする。

 -- Function: event-end event
     これはEVENTの終了位置をリターンする。

     EVENTがドラッグイベントの場合、この関数はユーザーがマウスボタンをリ
     リースした位置をリターンする。EVENTがクリックイベントまたはボタンダ
     ウンイベントの場合、値はそのイベント固有の開始位置となる。

 -- Function: posnp object
     この関数はOBJECTが(*note Click Events::に記述されたいずれかのフォー
     マットの)マウス位置リストの場合は非‘nil’、それ以外では‘nil’をリター
     ンする。

   以下の関数は、引数にマウス位置リストをとり、そのリストのさまざまな部
分をリターンします:

 -- Function: posn-window position
     POSITIONがあったウィンドウをリターンする。POSITIONが最初イベントが
     あったフレーム外の位置を表す場合は、かわりにそのフレームをリターン
     する。

 -- Function: posn-area position
     POSITION内に記録されたウィンドウエリアをリターンする。そのウィンド
     ウのテキストエリアでイベントが発生したときは‘nil’、それ以外ではイベ
     ントがどこで発生したかを識別するシンボルをリターンする。

 -- Function: posn-point position
     POSITION内のバッファー位置をリターンする。ウィンドウのテキストエリ
     ア、マージンエリア、フリンジでイベントが発生したときは、バッファー
     位置を識別する整数値、それ以外では値は未定義である。

 -- Function: posn-x-y position
     POSITION内のピクセル単位のxy座標を、コンスセル‘(X . Y)’でリターンす
     る。これらは‘posn-window’により与えられるウィンドウにたいする相対座
     標である。

     以下は、あるウィンドウのテキストエリア内のウィンドウ相対座標をフレ
     ーム相対座標に変換する方法を示す例である:

          (defun frame-relative-coordinates (position)
            "POSITIONのフレーム相対座標をリターンする。
          POSITIONはウィンドウのテキストエリアにあるものとする。"
            (let* ((x-y (posn-x-y position))
                   (window (posn-window position))
                   (edges (window-inside-pixel-edges window)))
              (cons (+ (car x-y) (car edges))
                    (+ (cdr x-y) (cadr edges)))))

 -- Function: posn-col-row position
     この関数は、POSITION内のバッファー位置にたいして推定される列と行を
     含むコンスセル‘(COL . ROW)’をリターンする。リターン値は、POSITIONに
     たいするXとYの値より計算され、そのフレームのデフォルト文字幅とデフ
     ォルト行高(行間スペースを含む)の単位で与えられる(そのため、実際の文
     字サイズが非デフォルト値の場合には、実際の行と列は、これらの計算さ
     れた値とは異なるかもしれない)。

     ROWは、そのテキストエリアの上端から数えられることに注意すること。
     POSITIONにより与えられるウィンドウがヘッダーライン(*note Header
     Lines::)をもつ場合、そのヘッダーラインはROWの数に_含まない_。

 -- Function: posn-actual-col-row position
     POSITION内の実際の行と列を、コンスセル‘(COL . ROW)’でリターンする。
     値はPOSITION与えられるウィンドウの実際の行と列である。*note Click
     Events::を参照のこと。POSITIONが実際のポジション値を含まない場合、
     この関数は‘nil’をリターンする。この場合、おおよその値を取得するため
     に‘posn-col-row’を使用できる。

     この関数は、タブ文字やイメージによるビジュアル列数のように、ディス
     プレイ上の文字のビジュアル幅を意味しない。標準的な文字単位の座標が
     必要ｎ場合は、かわりに‘posn-col-row’を使用すること。

 -- Function: posn-string position
     POSITION内の文字列オブジェクトをを‘nil’、またはコンスセル‘(STRING .
     STRING-POS)’でリターンする。

 -- Function: posn-image position
     POSITION内のイメージオブジェクトを‘nil’、または‘(image ...)’でリタ
     ーンする。

 -- Function: posn-object position
     POSITION内のイメージオブジェクト、または文字列オブジェクトを‘nil’、
     イメージ‘(image ...)’、またはコンスセル‘(STRING . STRING-POS)’でリ
     ターンする。

 -- Function: posn-object-x-y position
     POSITION内のオブジェクトの左上隅からのピクセル単位のxy座標を、コン
     スセル‘(DX . DY)’でリターンする。POSITIONがバッファーテキストの場合
     は、その位置にもっとも近いバッファーテキストの相対位置をリターンす
     る。

 -- Function: posn-object-width-height position
     POSITION内のオブジェクトのピクセル幅とピクセル高さを、コンスセル
     ‘(WIDTH . HEIGHT)’でリターンする。POSITIONがバッファー位置の場合は
     、その位置の文字のサイズをリターンする。

 -- Function: posn-timestamp position
     POSITION内のタイムスタンプをリターンする。これはミリ秒で表されたイ
     ベント発生時刻である。

   以下の関数は与えられた特定のバッファー、またはスクリーン位置により与
えられる位置リストを計算します。上述の関数で、この位置リスト内のデータに
アクセスできます。

 -- Function: posn-at-point &optional pos window
     この関数は位置POS in WINDOWにたいする位置リストをリターンする。
     POSのデフォルトはWINDOW内のポイントであり、WINDOWのデフォルトは選択
     されたウィンドウである。

     WINDOW内でPOSが不可視の場合、‘posn-at-point’は‘nil’をリターンする。

 -- Function: posn-at-x-y x y &optional frame-or-window whole
     この関数は、指定されたフレームまたはウィンドウFRAME-OR-WINDOW(デフ
     ォルトは選択されたウィンドウ)内のピクセル座標XとYに対応する位置情報
     をリターンする。XとYは、使用されたフレームまたはウィンドウにたいす
     る相対座標である。WHOLEが‘nil’の場合、座標はウィンドウのテキストエ
     リアにたいする相対座標であり、それ以外ではスクロールバー、マージン
     、フリンジを含むウィンドウエリア全体にたいする相対座標である。


File: elisp,  Node: Accessing Scroll,  Next: Strings of Events,  Prev: Accessing Mouse,  Up: Input Events

20.7.14 Accessing Scroll Bar Events
-----------------------------------

以下の関数は、スクロールバーイベントの解析に役立ちます。

 -- Function: scroll-bar-event-ratio event
     この関数はスクロールバーで発生したスクロールバーイベントの位置の垂
     直位置割り合いをリターンする。値は位置の割り合いを表す2つの整数を含
     むコンスセル‘(PORTION . WHOLE)’である。

 -- Function: scroll-bar-scale ratio total
     この関数は、(実質的には)RATIOにTOTALを乗じて、結果を整数に丸める。
     引数RATIOは数字ではなく、‘scroll-bar-event-ratio’によりリターンされ
     る典型的な値ペアー‘(NUM . DENOM)’である。

     この関数はスクロールバー位置をバッファー位置にスケーリングするのに
     便利である。以下のようにこれを行う:

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     スクロールバーイベントは、xy座標ペアーのかわりに割り合いを構成する
     2つの整数をもつことを思い出してほしい。


File: elisp,  Node: Strings of Events,  Prev: Accessing Scroll,  Up: Input Events

20.7.15 Putting Keyboard Events in Strings
------------------------------------------

文字列が使用される場所のほとんどにおいて、わたしたちはテキスト文字を含む
もの、つまりバッファーやファイル内で見出すのと同種のものとして、文字列を
概念化します。Lispプログラムはときおり、キーボード文字、たとえばキーシー
ケンスやキーボードマクロ定義かもしれないキーボード文字を概念的に含む文字
列を使用します。しかし文字列内へのキーボード文字の格納は、歴史的な互換性
の理由により複雑な問題であり、常に可能なわけではありません。

   新たに記述するプログラムでは文字列内にキーボードイベントを格納しない
ことにより、これらの複雑さを扱うことを避けるよう推奨します。以下はこれを
行う方法です:

   • ‘lookup-key’および‘define-key’の引数として使用するのでなければ、キ
     ーシーケンスにたいして文字列のかわりにベクターを使用する。たとえば
     、‘read-key-sequence’のかわりに‘read-key-sequence-vector’、
     ‘this-command-keys’のかわりに‘this-command-keys-vector’を使用できる
     。

   • メタ文字を含むキーシーケンス定数を記述する際は、たとえそれを直接
     ‘define-key’に渡す場合でもベクターを使用する。

   • 文字列かもしれないキーシーケンスの内容を調べる必要があるときは、そ
     れをリストに変換するために最初に‘listify-key-sequence’(*note Event
     Input Misc::を参照)を使用する。

   複雑さはキーボード入力に含まれるかもしれない修飾ビットに起因します。
メタ修飾以外の修飾ビットは文字列に含めることができず、メタ文字も特別な場
合だけ許されます。

   GNU Emacsの初期のバージョンでは、メタ文字を128から255のコードで表して
いました。その頃は基本文字コードの範囲は0から127だったので、すべてのキー
ボード文字を文字列内に適合させることができました。Lispプログラムの多くは
、特に‘define-key’やその種の関数の引数として文字列定数内にメタ文字を意味
する‘\M-’を使用し、キーシーケンスとイベントシーケンスは常に文字列として
表現されていました。

   127を超えるより大きい基本文字コードと追加の修飾ビットにたいするサポー
トを加えたとき、わたしたちはメタ文字の表現を変更する必要がありました。現
在では文字のメタ修飾を表すフラグは 2**27 であり、そのような値は文字列内
に含めることができません。

   プログラムで文字列定数内の‘\M-’をサポートするために、文字列内に特定の
メタ文字を含めるための特別なルールがあります。以下は入力文字シーケンスと
して文字列を解釈するためのルールです:

   • キーボード文字の値の範囲が0から127の場合は、文字列を変更せずに含め
     ることができる。

   • これらの文字のコード 2**27 から 2**27+127, までの範囲のメタ修飾され
     た変種も文字列に含めることができるが、それらの数値を変更しなければ
     ならない。値が128から255の範囲となるように、ビット 2**7 のかわりに
     ビット 2**27 をセットしなければならない。ユニバイト文字列だけがこれ
     らの文字を含むことができる。

   • 265を超える非ASCII文字はマルチバイト文字に含めることができる。

   • その他のキーボード文字イベントは文字列に適合させられない。これには
     128から255の範囲のキーボードイベントが含まれる。

   キーボード入力文字の文字列定数を構築する‘read-key-sequence’のような関
数は、イベントが文字列内に適合しないときは文字列のかわりにベクターを構築
するというルールにしたがいます。

   文字列内で入力構文‘\M-’を使用すると、それは128から255の範囲のコード、
つまり対応するキーボードイベントを文字列内に配すために変更するとき取得さ
れるのと同じコードが生成されます。したがって文字列内のメタイベントは、そ
れが文字列内にどのように配置されたかと無関係に一貫して機能します。

   しかし、ほとんどのプログラムはこのセクションの冒頭の推奨にしたがって
、これらの問題を避けるほうがよいでしょう。


File: elisp,  Node: Reading Input,  Next: Special Events,  Prev: Input Events,  Up: Command Loop

20.8 Reading Input
==================

エディターコマンドループはキーシーケンスの読み取りに関数
‘read-key-sequence’を使用し、この関数は‘read-event’を使用します。イベン
ト入力にたいしてこれらの関数、およびその他の関数がLisp関数から利用できま
す。*note Temporary Displays::の‘momentary-string-display’、および*note
Waiting::の‘sit-for’も参照してください。端末の入力モードの制御、および端
末入力のデバッグに関する関数と変数については、*note Terminal Input::を参
照してください。

   高レベル入力機能については*note Minibuffers::を参照してください。

* Menu:

* Key Sequence Input::       キーシーケンスを読み取る方法。
* Reading One Event::        イベントを1つだけ読み取る方法。
* Event Mod::                Emacsが読み取られたイベントを変更する方法。
* Invoking the Input Method::  入力メソッドを使用するイベントを読み取る方法。
* Quoted Character Input::   文字の指定をユーザーに問い合わせる。
* Event Input Misc::         入力イベントの最読み取りや破棄の方法。


File: elisp,  Node: Key Sequence Input,  Next: Reading One Event,  Up: Reading Input

20.8.1 Key Sequence Input
-------------------------

コマンドループは‘read-key-sequence’を呼び出すことにより、キーシーケンス
の入力を一度に読み取ります。Lisp関数もこの関数を呼び出すことができます。
たとえば‘describe-key’はキーを説明するためにこの関数を使用します。

 -- Function: read-key-sequence prompt &optional continue-echo
          dont-downcase-last switch-frame-ok command-loop
     この関数はキーシーケンスを読み取り、それを文字列またはベクターでリ
     ターンする。この関数は完全なキーシーケンスに蓄積されるまで、つまり
     カレントでアクティブなキーマップを使用してプレフィクスなしでコマン
     ドを指定するのに十分なキーシーケンスとなるまでイベントの読み取りを
     継続する(マウスイベントで始まるキーシーケンスは、カレントバッファー
     ではなくマウスのあったウィンドウ内のバッファーのキーマップを使用し
     て読み取られることを思い出してほしい)。

     イベントがすべて文字で、それらがすべて文字列に適合する場合、
     ‘read-key-sequence’は文字列をリターンする(*note Strings of
     Events::を参照)。それ以外の場合は文字、シンボル、リストなどすべての
     種類のイベントを保持できるベクターをリターンする。文字列またはベク
     ターの要素は、キーシーケンス内のイベントである。

     キーシーケンスのo読み取りには、そのイベントを変換するさまざまな方法
     が含まれる。*note Translation Keymaps::を参照のこと。

     引数PROMPTはプロンプトとしてエコーエリアに表示される文字列か、プロ
     ンプトを表示しない‘nil’である。引数CONTINUE-ECHOが非‘nil’の場合、そ
     れは前のキーの継続としてそのキーをエコーすることを意味する。

     通常、元となる大文字のイベントが未定義で、それと等価な小文字イベン
     トが定義されている場合、大文字のイベントは小文字のイベントに変換さ
     れる。引数DONT-DOWNCASE-LASTが非‘nil’の場合、それは最後のイベントを
     小文字に変換しないことを意味する。これはキーシーケンスを定義すると
     きに適している。

     引数SWITCH-FRAME-OKが非‘nil’の場合は、たとえ何かをタイプする前にユ
     ーザーがフレームを切り替えたとしても、この関数が‘switch-frame’を処
     理すべきでないことを意味する。キーシーケンスの途中でユーザーがフレ
     ームを切り替えた場合、またはシーケンスの最初だがSWITCH-FRAME-OKが
     ‘nil’のときにフレームを切り替えた場合、そのイベントはカレントキーシ
     ーケンスの後に延期される。

     引数COMMAND-LOOPが非‘nil’の場合は、そのキーシーケンスがコマンドを逐
     次読み取る何かによりa読み取られることを意味する。呼び出し側が1つの
     キーシーケンスだけを読み取る場合は、‘nil’を指定すべきである。

     以下の例では、Emacsはエコーエリアにプロンプト‘?’を表示して、その後
     ユーザーが‘C-x C-f’をタイプしている。

          (read-key-sequence "?")

          ---------- Echo Area ----------
          ?C-x C-f
          ---------- Echo Area ----------

               ⇒ "^X^F"

     関数‘read-key-sequence’はquitを抑制する。この関数による読み取りの間
     にタイプされた‘C-g’は他の文字と同じように機能し、‘quit-flag’をaセッ
     トしない。*note Quitting::を参照のこと。

 -- Function: read-key-sequence-vector prompt &optional continue-echo
          dont-downcase-last switch-frame-ok command-loop
     これは‘read-key-sequence’と同様だが、キーシーケンスを常にベクターで
     リターンし、文字列では決してリターンしない点が異なる。*note Strings
     of Events::を参照のこと。

   入力文字が大文字(またはシフト修飾をもつ)で、キーバインディングをもた
ないが、等価な小文字はキーバインディングをもつ場合、
‘read-key-sequence’はその文字を小文字に変換します。‘lookup-key’はこの方
法による大文字小文字変換を行わないことに注意してください。

   入力を読み取った結果が“シフト変換(shift-translation)”されていたような
場合、Emacsは変数‘this-command-keys-shift-translated’に非‘nil’値をセット
します。シフト変換されたキーにより呼びだされたときは挙動を変更する必要が
あるLispプログラムは、この変数を調べることができます。たとえば、関数
‘handle-shift-selection’はリージョンをアクティブ、または非アクティブにす
るか判断するためにこの変数の値を調べます(*note handle-shift-selection:
The Mark.を参照)。

   この関数‘read-key-sequence’も、マウスイベントのいくつかを変換します。
これはバインドされていないドラッグイベントをクリックイベントに変換し、バ
インドされていないボタンダウンイベントを完全に破棄します。さらにフォーカ
スイベントとさまざまなウィンドウイベントの再配置も行うため、これらのイベ
ントはキーシーケンス中に他のイベントとともに決して出現しません。

   モードラインやスクロールバーのようなウィンドウの特別な箇所でマウスイ
ベントが発生したとき、そのイベント型は特別なことは何も示さず、マウスボタ
ンと修飾キーの組み合わせを通常表すのと同じシンボルになります。ウィンドウ
の箇所についての情報はイベント内の別のどこか、すなわち座標に保持されてい
ます。しかし‘read-key-sequence’はこの情報を仮想的な“プレフィクスキー”に
変換します。これらはすべてシンボルであり‘header-line’、
‘horizontal-scroll-bar’、‘menu-bar’、‘mode-line’、‘vertical-line’、
‘vertical-scroll-bar’です。これらの仮想的なプレフィクスキーを使用してキ
ーシーケンスを定義することにより、ウィンドウの特別な部分でのカウスクリッ
クにたいして意味を定義できます。

   たとえば、‘read-key-sequence’を呼び出した後にそのウィンドウのモードラ
インをマウスでクリックすると、以下のように2つのマウスイベントが取得され
ます:

     (read-key-sequence "Click on the mode line: ")
          ⇒ [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]

 -- Variable: num-input-keys
     この変数の値は、そのEmacsセッション内で処理されたキーシーケンスの数
     である。これには端末からのキーシーケンスと、実行されるキーボードマ
     クロにより読み取られたキーシーケンスが含まれる。


File: elisp,  Node: Reading One Event,  Next: Event Mod,  Prev: Key Sequence Input,  Up: Reading Input

20.8.2 Reading One Event
------------------------

‘read-event’,‘read-char’、‘read-char-exclusive’は、コマンド入力にたいす
るもっとも低レベルの関数です。

 -- Function: read-event &optional prompt inherit-input-method seconds
     この関数はコマンド入力の次のイベントを読み取り、リターンする。必要
     ならイベントが利用可能になるまで待機する。

     リターンされるイベントはユーザーから直接のイベントかもしれないし、
     またはキーボードマクロからのイベントかもしれない。イベントはキーボ
     ードの入力コーディングシステム(*note Terminal I/O Encoding::を参照
     )により復号されない。

     オプション引数PROMPTが非‘nil’の場合、それはエコーエリアにプロンプト
     として表示される文字列である。‘nil’の場合、‘read-event’は入力待ちを
     示すメッセージを何も表示せず、エコーを行うことによりプロンプトの代
     用とする。エコーで表示されるのはカレントコマンドに至ったイベントや
     読み取られたイベントの説明である。*note The Echo Area::を参照のこと
     。

     INHERIT-INPUT-METHODが非‘nil’の場合、(もしあれば)非ASCII文字の入力
     を可能にするためにカレントの入力メソッドが採用される。それ以外では
     、このイベントの読み取りにたいして入力メソッドの処理が無効になる。

     ‘cursor-in-echo-area’が非‘nil’の場合、‘read-event’はカーソルを一時
     的にエコーエリアの、そこに表示されているメッセージの終端に移動する
     。それ以外では、‘read-event’はカーソルを移動しない。

     SECONDSが非‘nil’の場合、それは入力を待つ最大秒数を指定する数値であ
     る。その時間内に入力が何も到着しない場合、‘read-event’は待機を終え
     て‘nil’をリターンする。浮動小数点数SECONDSは待機する秒の分数を意味
     する。いくつかのシステムではサポートされるのは整数の秒数だけであり
     、そのようなシステムではSECONDSは切り捨てられる。SECONDSが‘nil’の場
     合、‘read-event’は入力が到着するのに必要なだけ待機する。

     SECONDSが‘nil’の場合、ユーザー入力が到着するのを待つ間、Emacsはアイ
     ドル状態にあるとみなされる。この期間中にアイドルタイマー —
     ‘run-with-idle-timer’(*note Idle Timers::を参照) — を実行できる。し
     かしSECONDSが非‘nil’の場合には、非アイドル状態は変更されずに残る。
     ‘read-event’が呼び出されたときEmacsが非アイドルだった場合、
     ‘read-event’の処理を通じて非アイドルのままとなる。Emacsがアイドルだ
     った場合(これはアイドルタイマー内部からその呼び出しが行われた場合に
     起こり得る)は、アイドルのままとまる。

     ‘read-event’がヘルプ文字として定義されたイベントを取得した場合、あ
     る状況においては‘read-event’がリターンせずに直接イベントを処理する
     ことがある。*note Help Functions::を参照のこと。その他の“スペシャル
     イベント(special events)”(*note Special Events::を参照)と呼ばれる特
     定のイベントも‘read-event’で直接処理される。

     以下は‘read-event’を呼び出してから右矢印キーを押下したとき何が起こ
     るかの例である:

          (read-event)
               ⇒ right

 -- Function: read-char &optional prompt inherit-input-method seconds
     この関数はコマンド入力の文字を読み取り、それをリターンする。ユーザ
     ーが文字以外(たとえばマウスクリックやファンクションキー)のイベント
     を生成した場合、‘read-char’はエラーをシグナルする。引数は
     ‘read-event’と同じように機能する。

     1つ目の例では、ユーザーは文字‘1’(ASCIIコード49)をタイプしている。
     2つ目の例では、‘eval-expression’を使用してミニバッファーから
     ‘read-char’を呼び出すキーボード定義を示している。‘read-char’は、キ
     ーボードマクロの直後の文字‘1’を読み取る。その後、
     ‘eval-expression’はリターン値をエコーエリアに表示する。

          (read-char)
               ⇒ 49

          ;; ‘M-:’を使用して以下を評価するものとする
          (symbol-function 'foo)
               ⇒ "^[:(read-char)^M1"
          (execute-kbd-macro 'foo)
               ⊣ 49
               ⇒ nil

 -- Function: read-char-exclusive &optional prompt inherit-input-method
          seconds
     この関数はコマンド入力の文字を読み取り、それをリターンする。ユーザ
     ーが文字以外のイベントを生成した場合、‘read-char-exclusive’はそれを
     無視して文字を取得するまで他のイベントを読み取る。引数は
     ‘read-event’と同じように機能する。

   上記でquitを抑制する関数はありません。

 -- Variable: num-nonmacro-input-events
     この変数は端末から受信した入力イベント(キーボードマクロにより生成さ
     れたイベントは勘定されない)の総数を保持する。

   ‘read-key-sequence’と異なり、関数‘read-event’、‘read-char’、
‘read-char-exclusive’は*note Translation Keymaps::で説明した変換を行わな
いことを強調しておきます。単一キー読み取りでこれらの変換を行いたい場合は
、関数‘read-key’を使用してください。

 -- Function: read-key &optional prompt
     この関数は1つのキーを読み取る。これは‘read-key-sequence’と
     ‘read-event’の間の“中間的”な関数である。‘read-key-sequence’と異なる
     のは、キーシーケンスではなく単一キーを読み取ることである。
     ‘read-event’と異なるのは、rawイベントをリターンせずに
     ‘input-decode-map’、‘local-function-key-map’、
     ‘key-translation-map’(*note Translation Keymaps::を参照)に合わせて
     復号と変換を行うことである。

     引数PROMPTはプロンプトとしてエコーエリアに表示する文字列で、‘nil’は
     プロンプトを表示しないことを意味する。

 -- Function: read-char-choice prompt chars &optional inhibit-quit
     この関数は1つの文字を読み取りリターンするために‘read-key’を使用する
     。これはCHARS(許容される文字のリスト)のメンバー以外の入力を無視する
     。オプションで、有効な入力を待つ間のquitイベントも無視する。
     ‘read-char-choice’呼び出しの間に‘help-form’(*note Help Functions::を
     参照)を非‘nil’値にバインドした場合、‘help-char’の押下により
     ‘help-form’が評価され結果が表示される。その後、有効な入力文字、また
     はキーボードquitの待機を継続する。


File: elisp,  Node: Event Mod,  Next: Invoking the Input Method,  Prev: Reading One Event,  Up: Reading Input

20.8.3 Modifying and Translating Input Events
---------------------------------------------

Emacsは‘extra-keyboard-modifiers’に合わせて読み取ったすべてのイベントを
変更して、‘read-event’からリターンする前に、(もし適切なら
)‘keyboard-translate-table’を通じてそれを変換します。

 -- Variable: extra-keyboard-modifiers
     この変数は、Lispプログラムにキーボード上の修飾キーを“押下”させる。
     値は文字である。文字の修飾子だけが対象となる。ユーザーがキーボード
     のキーを押下するたびに、その修飾キーがすでに押下されたかのように処
     理される。たとえば、‘extra-keyboard-modifiers’を‘?\C-\M-a’にバイン
     ドした場合、このバインディングのスコープ内にある間、すべてのキーボ
     ード入力文字はコントロール修飾とメタ修飾を適用されるだろう。文字
     ‘?\C-@’は0と等価なので、この目的にたいしてはコントロール文字として
     勘定されないが、修飾無しの文字として扱われる。したがって
     ‘extra-keyboard-modifiers’を0にセットすることにより、すべての修飾を
     キャンセルできる。

     ウィンドウシステムを利用する場合は、この方法によりプログラムが任意
     の修飾キーを“押下”できる。それ以外は<CTL>と<META>のキーだけを仮想的
     に押下できる。

     この変数は実際にキーボード由来のイベントだけに適用され、マウスイベ
     ントやその他のイベントには効果がないことに注意されたい。

 -- Variable: keyboard-translate-table
     この端末ローカルな変数はキーボード文字にたいする変換テーブルである
     。これによりコマンドバインディングを変更することなく、キーボード上
     のキーを再配置できる。値は通常、文字テーブル、または‘nil’ある(文字
     列かベクターも指定できるが、時代遅れとされている)

     ‘keyboard-translate-table’が文字テーブル(*note Char-Tables::を参照
     )の場合、キーボードから読み取られたそれぞれの文字はその文字テーブル
     を調べる。非‘nil’の値が見つかった場合は、実際の入力文字のかわりにそ
     れを使用する。

     この変換は文字が端末から読み取られた後、最初に発生することに注意さ
     れたい。‘recent-keys’のような記録保持機能や文字を記録するdribbleフ
     ァイルは、この変換の後に処理される。

     さらに、この変換は入力メソッド(*note Input Methods::を参照)に文字を
     提供する前に行われることにも注意されたい。入力メソッド処理の後に文
     字を変換したい場合は、‘translation-table-for-input’(*note
     Translation of Characters::を参照)を使用すること。

 -- Function: keyboard-translate from to
     この関数は文字コードFROMを文字コードTOに変換するために、
     ‘keyboard-translate-table’を変更する。 必要な場合は、キーボード変換
     テーブルを作成する。

   以下は‘C-x’でカット、‘C-’でコピー、‘C-v’でペーストを処理するように
‘keyboard-translate-table’を使用する例です:

     (keyboard-translate ?\C-x 'control-x)
     (keyboard-translate ?\C-c 'control-c)
     (keyboard-translate ?\C-v 'control-v)
     (global-set-key [control-x] 'kill-region)
     (global-set-key [control-c] 'kill-ring-save)
     (global-set-key [control-v] 'yank)

拡張ASCII入力をサポートするグラフィカルな端末上では、シフトキーとともに
タイプすることにより、標準的なEmacsにおける意味をこれらの文字から依然と
して取得することが可能です。これはキーボード変換が関与する文字とは異なり
ますが、それらは通常と同じ意味をもちます。

   ‘read-key-sequence’のレベルでイベントシーケンスを変換するメカニズムに
ついては、*note Translation Keymaps::を参照してください。


File: elisp,  Node: Invoking the Input Method,  Next: Quoted Character Input,  Prev: Event Mod,  Up: Reading Input

20.8.4 Invoking the Input Method
--------------------------------

イベント読み取り関数は、もしあればカレント入力メソッドを呼び出します
(*note Input Methods::を参照)。‘input-method-function’の値が非‘nil’の場
合、関数を指定します。‘read-event’が修飾ビットのないプリント文字(<SPC>を
含む)を読み取ったときは、その文字を引数としてその関数を呼び出します。

 -- Variable: input-method-function
     これが非‘nil’の場合、その値はカレントの入力メソッド関数を指定する。

     *警告:* この変数は‘let’でバインドしてはならない。この変数はしばしば
     バッファーローカルであり、入力の前後(これは正にあなたがバインド_す
     るであろう_タイミングである)でバインドした場合、Emacsが待機中に非同
     期にバッファーを切り替えると誤ったバッファーに値がリストアされるだ
     ろう。

   入力メソッド関数は、入力として使用されるイベントのリストをリターンす
るべきです(このリストが‘nil’の場合、それは入力がないことを意味するので、
‘read-event’他のイベントを待機する)。これらのイベントは
‘unread-command-events’(*note Event Input Misc::を参照)内のイベントの前
に処理されます。入力メソッドによりリターンされるイベントは、たとえそれら
が修飾ビットのないプリント文字であっても、再度入力メソッドに渡されること
はありません。

   入力メソッド関数が‘read-event’または‘read-key-sequence’を呼び出した場
合は、再帰を防ぐために最初に‘input-method-function’を‘nil’にバインドする
べきです。

   キーシーケンスの2つ目および後続のイベントを読み取るときは、入力メソッ
ド関数は呼び出されません。したがって、それらの文字は入力メソッドの処理対
象ではありません。入力メソッド関数は‘overriding-local-map’と
‘overriding-terminal-local-map’の値をテストするべきです。これらの変数の
いずれかが非‘nil’の場合、入力メソッドは引数をリストにputして、それ以上の
処理を行わずにそのリストをリターンするべきです。


File: elisp,  Node: Quoted Character Input,  Next: Event Input Misc,  Prev: Invoking the Input Method,  Up: Reading Input

20.8.5 Quoted Character Input
-----------------------------

ユーザーが手軽にコントロール文字やメタ文字。リテラルや8進文字コードを指
定できるように、文字の指定をもとめることができます。コマンド
‘quoted-insert’この関数を使用します。

 -- Function: read-quoted-char &optional prompt
     この関数は‘read-char’同様だが、最初に読み取った文字が8進数 (0–7)の
     場合は任意の個数の8進数(8進数以外の文字を見つけた時点でストップする
     )を読み取り、その文字コードにより表される文字をリターンする。8進シ
     ーケンスを終端させた文字が<RET>の場合、それは無視される。他の終端文
     字は、この関数がリターンした後に入力として使用される。

     最初の文字の読み取り時はquitは抑制されるので、ユーザーはは‘C-g’を入
     力できる。*note Quitting::を参照のこと。

     PROMPTが与えられた場合、それはユーザーへのプロンプトに使用する文字
     列を指定する。プロンプト文字列は、その後の1つの‘-’とともに常にエコ
     ーエリアに表示される。

     以下の例では、ユーザーは8進数の177(10進数の127)をタイプしている。

          (read-quoted-char "What character")

          ---------- Echo Area ----------
          What character 1 7 7-
          ---------- Echo Area ----------

               ⇒ 127


File: elisp,  Node: Event Input Misc,  Prev: Quoted Character Input,  Up: Reading Input

20.8.6 Miscellaneous Event Input Features
-----------------------------------------

このセクションでは、イベントを使い切ることなく“先読み”する方法、および入
力の保留や保留の破棄の方法について説明します。*note Reading a
Password::の関数‘read-passwd’も参照してください。

 -- Variable: unread-command-events
     この変数はコマンド入力として読み取り待機中のイベントのリストを保持
     する。イベントはこのリスト内の出現順に使用され、使用されるごとにリ
     ストから取り除かれる。

     ある関数がイベントを読み取ってそれを使用するかどうか決定する場合が
     いくつかあるので、この変数が必要になる。この変数にイベントを格納す
     ると、コマンドループおよにコマンド入力を読み取る関数により、イベン
     トは通常のように処理される。

     たとえば、数引数を実装する関数は、任意の個数の数字を読み取る。数字
     イベントが見つからないとき、関数はそのイベントを読み戻す(unread)の
     で、そのイベントはコマンドループにより通常通り読み取られることがで
     きる。同様に、インクリメンタル検索は、検索において特別な意味をもた
     ないイベントを読み戻すために、この機能を使用する。なぜなら、それら
     のイベントは検索をexitして、通常どおり実行されるべきだからである。

     ‘unread-command-events’にイベントを置くためにキーシーケンスからイベ
     ントを抽出するには、‘listify-key-sequence’(以下参照)を使用するのが
     簡単で信頼のおける方法である。

     もっとも最近読み戻したイベントが最初に再読み取りされるように、この
     リストの先頭にイベントを追加するのが通常である。

     通常このリストから読み取ったイベントは、そのイベントが最初に読み取
     られたときにすでに一度追加されたときのように、カレントコマンドのキ
     ーシーケンスに(たとえば‘this-command-keys’にリターンされたとみのよ
     うに)追加される。フォーム‘(t . EVENT)’の要素は、カレントコマンドの
     キーシーケンスにEVENTを強制的に追加する。

 -- Function: listify-key-sequence key
     この関数は文字列またはベクターのKEYを、‘unread-command-events’置く
     ことができる個別のイベントのリストに変換する。

 -- Function: input-pending-p &optional check-timers
     この関数は、コマンド入力がカレントで読み取り可能かどうか判断する。
     入力が利用可能なら即座に‘t’を、それ以外は‘nil’をリターンする。非常
     に稀だが、入力が利用できないときに‘t’

     オプション引数CHECK-TIMERSが非‘nil’の場合、Emacsは順部位ができたら
     任意のタイマーを実行する。*note Timers::を参照のこと。

 -- Variable: last-input-event
     この変数は最後に読み取られた端末入力イベントがコマンドの一部なのか
     、それともLispプログラムによる明示的なものなのかを記録する。

     以下の例では、文字‘1’(ASCIIコード49)をLispプログラムが読み取ってい
     る。‘C-e’(‘C-x C-e’は式を評価するコマンドとする)が
     ‘last-command-event’に値として残っている間は、それが
     ‘last-input-event’の値となる。

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               ⊣ 49
               ⊣ 5
               ⇒ 49

 -- Macro: while-no-input body...
     この構成はBODYフォームを実行して、入力が何も到着しない場合だけ最後
     のフォームの値をリターンする。BODYフォームを実行する間に何らかの入
     力が到着した場合は、それらの入力をする(quitのように機能する)。
     ‘while-no-input’フォームは実際のquitによりabortした場合は‘nil’、入
     力の到着によりabortした場合は‘t’をリターンする。

     BODYの一部で‘inhibit-quit’を非‘nil’にバインドした場合、その部分の間
     に到着した入力は、その部分が終わるまでabortしない。

     両方のabort条件をBODYにより計算されたすべての可能な値で区別できるよ
     うにしたい場合は、以下のようにコードを記述する:

          (while-no-input
            (list
              (progn . BODY)))

 -- Function: discard-input
     この関数は端末入力バッファーの内容を破棄して定義処理中かもしれない
     キーボードマクロをキャンセルする。この関数は‘nil’をリターンする。

     以下の例では、フォームの評価開始直後にユーザーが数字か文字をタイプ
     するかもしれない。‘sleep-for’がスリープを終えた後、
     ‘discard-input’はスリープ中にタイプされた文字を破棄する。

          (progn (sleep-for 2)
                 (discard-input))
               ⇒ nil


File: elisp,  Node: Special Events,  Next: Waiting,  Prev: Reading Input,  Up: Command Loop

20.9 Special Events
===================

特定の“スペシャルイベント(special event)”は、読み取られると即座に非常に
低レベルで処理されます。‘read-event’関数はそれらのイベントを自身で処理し
て、それらを決してリターンしません。かわりに、スペシャルイベント以外の最
初のイベントを待ち、それをリターンします。

   スペシャルイベントはエコーされず、決してキーシーケンスにグループ化さ
れず、‘last-command-event’や‘(this-command-keys)’の値として出現すること
もありません。スペシャルイベントは数引数を破棄し、
‘unread-command-events’による読み戻しができず、キーボードマクロ内に出現
することもないでしょうし、キーボードマクロ定義中にキーボードマクロに記録
されることもありません。

   しかし、スペシャルイベントは読み取られた直後に‘last-input-event’内に
出現するので、これがイベント定義にたいして実際のイベントを探す方法になり
ます。

   イベント型‘iconify-frame’、‘make-frame-visible’、‘delete-frame’、
‘drag-n-drop’、‘language-change’、および‘sigusr1’ようなユーザーシグナル
は通常この方法により処理されます。何がスペシャルイベントで、スペシャルイ
ベントをどのように処理するかを定義するキーマップは、変数
‘special-event-map’(*note Active Keymaps::を参照)の中にあります。


File: elisp,  Node: Waiting,  Next: Quitting,  Prev: Special Events,  Up: Command Loop

20.10 Waiting for Elapsed Time or Input
=======================================

待機関数(wait function)は特定の時間が経過するか、入力があるまで待機する
ようにデザインされています。たとえば、計算の途中でユーザーがディスプレイ
を閲覧できるように一時停止したいときがあるかもしれません。‘sit-for’は一
時停止して画面を更新、‘sleep-for’は画面を更新せずに一時停止して、入力が
到着したら即座にリターンします。

 -- Function: sit-for seconds &optional nodisp
     この関数は、(ユーザーからの保留中入力がない場合は)再描画を行ってか
     ら、SECONDS秒、または入力が利用可能になるまで待機する。‘sit-for’の
     通常の目的は、ディスプレイしたテキストをユーザーが読み取る時間を与
     えるためである。入力が何も到着せず(*note Event Input Misc::を参照
     )、時間をフルに待機した場合は‘t’、それ以外は‘nil’が値となる。

     引数SECONDSは整数である必要はない。浮動小数点数の場合、‘sit-for’は
     秒の少数点数を待機する。整数の秒だけをサポートするいくつかのシステ
     ムでは、SECONDSは切り捨てられる。

     保留中の入力が存在しない場合、式‘(sit-for 0)’は遅延なしに再描画をリ
     クエストする‘(redisplay)’と等価である。*note Forcing Redisplay::を
     参照のこと。

     NODISPが非‘nil’の場合‘sit-for’は再描画を行わないが、それでも入力が
     利用可能になると(またはタイムアウト時間が経過すると)即座にリターン
     する。

     バッチモード(*note Batch Mode::を参照)では、たとえ標準入力ディスク
     リプタからの入力でも割り込みできまい。これは以下で説明する
     ‘sleep-for’でも同じである。

     ‘(sit-for SECONDS MILLISEC NODISP)’のように、3つの引数で‘sit-for’を
     呼び出すことも可能だが時代遅れだと考えられている。

 -- Function: sleep-for seconds &optional millisec
     この関数は表示を更新せず、単にSECONDS秒間一時停止する。これは利用可
     能な入力に注意を払わない。この関数は‘nil’をリターンする。

     引数SECONDSは整数である必要はない。浮動小数点数の場合、
     ‘sleep-for’は秒の少数点数を待機する。整数の秒だけをサポートするいく
     つかのシステムでは、SECONDSは切り捨てられる。

     オプション引数MILLISECはミリ秒単位で追加の待機期間を指定する。これ
     はSECONDSで指定された期間に追加される。システムが小数点の秒数をサポ
     ートしない場合、非0のMILLISECを指定するとエラーとなる。

     遅延を保証したい場合は‘sleep-for’を使用する。

   現在時刻を取得する関数については、*note Time of Day::を参照してくださ
い。


File: elisp,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Waiting,  Up: Command Loop

20.11 Quitting
==============

Lisp関数を実行中に‘C-g’をタイプすると、Emacsが何を行っていてもEmacsを
“quit(中止、終了)”させます。これはアクティブなコマンドループの再内に制御
がリターンすることを意味します。

   コマンドループがキーボード入力待機中に‘C-g’をタイプしてもquitはしませ
ん。これは通常の入力文字として機能します。もっともシンプルなケースでは、
通常‘C-g’はquitの効果をもつ‘keyboard-quit’を実行するので、区別できません
しかしプレフィクスキーの後の‘C-g’は、未定義のキー組み合わせになります。
これはプレフィクスキーやプレフィクスキーも同様にキャンセルする効果をもち
ます。

   ミニバッファー内では、‘C-g’は異なる定義をもち、それはミニバッファーを
abort(失敗、中止、中断)します。これは実際にはミニバッファーをexitして
quitします(単にquitするのは_ミニバッファー内_のコマンドループにリターン
するだろう)。‘C-g’がなぜコマンドリーダーが入力読み取り時に直接quitしない
かという理由は、ミニバッファー内で‘C-g’の意味をこの方法により再定義可能
にするためです。プレフィクスキーの後の‘C-g’はミニバッファー内で再定義さ
れておらず、プレフィクスキーおよびプレフィクス引数のキャンセルという通常
の効果をもちます。もし‘C-g’ｇヴぁ常に直接quitするなら、これは不可能でし
ょう。

   ‘C-g’が直接quitを行うときは、変数‘quit-flag’を‘t’にセットすることによ
りそれを行います。Emacsは適切なときにこの変数をチェックして、‘nil’でない
場合はquitします。どのような方法でも、‘quit-flag’を非‘nil’にセットすると
quitが発生します。

   Cコードのレベルでは、どこでもquitを発生させることはできず、
‘quit-flag’をチェックする特別な場所でのみquitが発生します。この理由は、
他の場所でquitすると、Emacsの内部状態が矛盾が生じるかもしれないからです
。安全な場所までquitが遅延されるので、quitがEmacsをクラッシュさせること
がなくなります。

   ‘read-key-sequence’や‘read-quoted-char’のような特定の関数は、たとえ入
力を待機中でもquitを抑制します。quitするかわりに、‘C-g’は要求された入力
として処理されます。‘read-key-sequence’の場合、これはコマンドループ内で
の‘C-g’の特別な振る舞いを引き起こすのに役立ちます。‘read-quoted-char’の
場合、これは‘C-g’をクォートするのに‘C-q’を使用できるようにします。

   変数‘inhibit-quit’を非‘nil’値にバインドすることにより、Lisp関数の一部
でquitを抑止できます。その場合は、‘quit-flag’を‘t’にセットされていても、
‘C-g’の通常の結果であるquitは抑止されます。‘let’フォームの最後でこのバイ
ンディングがunwindされるなどして、結果として‘inhibit-quit’は再び‘nil’に
なります。このとき‘quit-flag’が‘nil’の場合には、即座に要求されたquitが発
生します。この挙動は、プログラム中の“クリティカルセクション”内でquitが発
生しないことを確実にしたいときに理想的です。

   (‘read-quoted-char’のような)いくつかの関数では、quitを起こさない特別
な方法で‘C-g’が処理されます。これは‘inhibit-quit’を‘t’にバインドして入力
を読み取り、再び‘inhibit-quit’が‘nil’になる前に‘quit-flag’を‘nil’にセッ
トすることにより行われます。以下は、これを行う方法を示すための
‘read-quoted-char’の抜粋です。この例は入力の最初の文字の後で通常のquitを
許す方法も示しています。

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((message-log-max nil) done (first t) (code 0) char)
         (while (not done)
           (let ((inhibit-quit first)
                 ...)
             (and prompt (message "%s-" prompt))
             (setq char (read-event))
             (if inhibit-quit (setq quit-flag nil)))
           ... 変数‘code’をセット ...)
         code))

 -- Variable: quit-flag
     この変数が非‘nil’で‘inhibit-quit’が‘nil’の場合、macsは即座にquitす
     る。‘C-g’をタイプすると、通常は‘inhibit-quit’とは無関係に
     ‘quit-flag’を非‘nil’にセットする。

 -- Variable: inhibit-quit
     この変数は、‘quit-flag’が非‘nil’にセットされているときEmacsがquitす
     るかどうかを決定する。‘inhibit-quit’が非‘nil’の場合、‘quit-flag’は
     特に効果がない。

 -- Macro: with-local-quit body...
     このマクロはBODYを順番に実行するが、たとえこの構成の外部で
     ‘inhibit-quit’が非‘nil’でも、少なくともローカルにBODY内でのquitを許
     す。このマクロはquitによりexitした場合は‘nil’、それ以外はBODY内の最
     後のフォームの値をリターンする。

     ‘inhibit-quit’が‘nil’の場合‘with-local-quit’へのエントリーでBODYだ
     けが実行され、‘quit-flag’をセットすることにより通常のquitが発生する
     。しかし通常のquitが遅延されるように‘inhibit-quit’が非‘nil’にセット
     されている場合、非‘nil’の‘quit-flag’は特別な種類のローカルquitを引
     き起こす。これはBODYの実行を終了して、‘quit-flag’を非‘nil’のままで
     ‘with-local-quit’ボディーをexitするので、許され次第(通常の)他の
     quitが発生する。BODYの先頭ですでに‘quit-flag’が非‘nil’の場合、即座
     にローカルquitが発生して結局ボディーは実行されない。

     このマクロは主にタイマー、プロセスフィルター、プロセスセンチネル、
     ‘pre-command-hook’、‘post-command-hook’、および‘inhibit-quit’が通常
     は‘t’にバイドされている場所で役に立つ。

 -- Command: keyboard-quit
     この関数は‘(signal 'quit nil)’により‘quit’条件をシグナルする。これ
     はquitが行うことと同じである(*note Errors::の‘signal’を参照)。

   quitに使用する‘C-g’以外の文字を指定できます。*note Input Modes::内の
関数‘set-input-mode’を参照してください。


File: elisp,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

20.12 Prefix Command Arguments
==============================

ほとんどのEmacsコマンドは“プレフィクス引数(prefix argument)”を使用できま
す。プレフィクス引数はコマンド自身の前に数字を指定するものです(プレフィ
クス引数とプレフィクスキーを混同しないように)。プレフィクス引数は常に値
により表され、‘nil’のときはカレントでプレフィクス引数が存在しないことを
意味します。すべてのコマンドはプレフィクス引数を使用するか、あるいは無視
します。

   プレフィクス引数には2つの表現があります。それは“raw(生の、加工してい
ない、原料のままの、未加工の)”と“数字(numeric)”です。エディターコマンド
ループは内部的にraw表現を使用し、Lisp変数もその情報を格納するのにこれを
使用しますが、コマンドはどちらかの表現を要求できます。

   以下は利用できるrawプレフィクス引数の値です:

   • ‘nil’はプレフィクス引数がないことを意味する。これの数値的な値は1だ
     が、多くのコマンドは‘nil’と整数1を区別する。

   • 整数はそれ自身を意味する。

   • 整数の要素を1つもつリスト。プレフィクス引数のこの形式は、1つまたは
     数字無しの連続する‘C-u’の結果である。数値的な値はリスト内の整数だが
     、そのようなリストと単独の整数を区別するコマンドがいくつかある。

   • シンボル‘-’。これは後に数字をともなわない‘M--’か‘C-u -’がタイプされ
     たことを示す。数値的に等価な値は−1だが、整数の−1をシンボルの‘-’を区
     別するコマンドがいくつかある。

   以下の関数をさまざまなプレフィクスで呼び出して、これらの可能なプレフ
ィクスを説明しましょう:

     (defun display-prefix (arg)
       "rawプレフィクス引数の値を表示する。"
       (interactive "P")
       (message "%s" arg))

以下はさまざまなrawプレフィクス引数で‘display-prefix’を呼び出した結果で
す:

             M-x display-prefix  ⊣ nil

     C-u     M-x display-prefix  ⊣ (4)

     C-u C-u M-x display-prefix  ⊣ (16)

     C-u 3   M-x display-prefix  ⊣ 3

     M-3     M-x display-prefix  ⊣ 3      ; (‘C-u 3’と同じ)

     C-u -   M-x display-prefix  ⊣ -

     M--     M-x display-prefix  ⊣ -      ; (‘C-u -’と同じ)

     C-u - 7 M-x display-prefix  ⊣ -7

     M-- 7   M-x display-prefix  ⊣ -7     ; (‘C-u -7’と同じ)

   Emacsにはプレフィクス引数を格納するための2つの変数‘prefix-arg’と
‘current-prefix-arg’があります。他のコマンドにたいしてプレフィクス引数を
セットアップする‘universal-argument’のようなコマンドは、プレフィクス引数
を‘prefix-arg’内に格納します。対照的に‘current-prefix-arg’はカレントコマ
ンドにプレフィクス引数を引き渡すので、これらの変数をセットしても将来のコ
マンドにたいするプレフィクス引数に効果はありません。

   コマンドは通常は‘interactive’内で、プレフィクス引数にたいしてrawと数
値のどちらの表現を使用するかを指定します(*note Using Interactive::を参照
)。そのかわりに関数は変数‘current-prefix-arg’内のプレフィクス引数の値を
直接調べるかもしれませんが、これは明確さで劣ります。

 -- Function: prefix-numeric-value arg
     この関数はARGの有効なrawプレフィクス引数の数値的な意味をリターンす
     る。引数はシンボル、数字、またはリストかもしれない。これが‘nil’の場
     合は、値1がリターンsare,‘-’の場合は−1がリターンされる。これが数字の
     場合は、その数字がリターンされる。リスト(数字であるべき)の場合は、
     そのリストのCARがリターンされる。

 -- Variable: current-prefix-arg
     この変数は_カレント_のコマンドにたいするrawプレフィクス引数を保持す
     る。コマンドはこの変数を直接調べるかもしれないが、この変数にたいす
     るアクセスには通常は‘(interactive "P")’を使用する。

 -- Variable: prefix-arg
     この変数の値は_次_の編集コマンドにたいするrawプレフィクス引数である
     。後続のコマンドにたいしてプレフィクス引数を指定する
     ‘universal-argument’のようなコマンドは、この変数をセットすることに
     より機能する。

 -- Variable: last-prefix-arg
     rawプレフィクス引数の値は、前のコマンドにより使用された値である。

   以下のコマンドは、後続のコマンドにたいしてプレフィクス引数をセットア
ップするために存在します。これらを他の用途で呼び出さないでください。

 -- Command: universal-argument
     このコマンドは入力を読み取り。後続のコマンドにたいするプレフィクス
     引数を指定する。何をしているかわかっているのでなければ、このコマン
     ドを自分で呼び出してはならない。

 -- Command: digit-argument arg
     このコマンドは、後続のコマンドにたいしてプレフィクス引数を追加する
     。引数ARGはこのコマンドの前のrawプレフィクス引数であり、これはプレ
     フィクス引数を更新するために使用される。何をしているかわかっている
     のでなければ、このコマンドを自分で呼び出してはならない。

 -- Command: negative-argument arg
     このコマンドは、次のコマンドにたいして数引数を追加する。引数ARGはこ
     のコマンドの前のrawプレフィクス引数であり、この値に負の符号が付され
     て新しいプレフィクス引数を構築する。何をしているかわかっているので
     なければ、このコマンドを自分で呼び出してはならない。


File: elisp,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

20.13 Recursive Editing
=======================

Emacsスタートアップ時に、自動的にEmacsコマンドループにエンターします。こ
のトップレベルのコマンドループ呼び出しは決してexitせず、Emacs実行中は実
行を続けます。Lispプログラムもコマンドループを呼び出せます。これは複数の
コマンドループを活性化するため、これを“再帰編集(recursive editing)”と呼
んでいます。再帰編集レベルは、呼び出したコマンドが何であれそれをサスペン
ドして、そのコマンドを再開する前にユーザーが任意の編集を行うことを可能に
する効果をもちます。

   再帰編集の間に利用可能なコマンドは、トップレベルの編集ループ内で利用
できるコマンドと同じであり、キーマップ内で定義されます。数少ない特別なコ
マンドだけが再帰編集レベルをexitし、他のコマンドは再帰編集レベルが終了し
たときに再帰編集レベルからリターンします(exitするための特別なコマンドは
常に利用できますが、再帰編集が行われていないときは何も行いません)。

   再帰コマンドループを含むすべてのコマンドループは、コマンドループから
実行されたコマンド内のエラーによりそのループをexitしないように、汎用エラ
ーハンドラーをセットアップします。

   ミニバッファー入力は、特殊な再帰編集です。これは、ミニバッファーとミ
ニバッファーウィンドウの表示を有効にするなどの欠点をもちますが、それはあ
なたが思うより少ないでしょう。ミニバッファー内では特定のキーの振る舞いが
異なりますが、これははミニバッファーのローカルマップによるものです。ウィ
ンドウを切り替えれば、通常のEmacsコマンドを使用できます。

   再帰編集レベルを呼び出すには、関数を‘recursive-edit’を呼び出します。
この関数はコマンドループを含んでいます。さらに‘exit’をthrowすることによ
り再帰編集レベルのexitを可能にする、タグ‘exit’をともなう‘catch’呼び出し
も含んでいます(*note Catch and Throw::を参照)。‘t’以外の値をthrowした場
合、‘recursive-edit’は通常それを呼び出した関数にリターンします。コマンド
‘C-M-c’(‘exit-recursive-edit’)がこれを行います。値‘t’をthrowすることによ
り‘recursive-edit’がquitされるので、1レベル上位のコマンドループに制御が
リターンされます。これは“abort”と呼ばれ、‘C-]’(‘abort-recursive-edit’)が
これを行います。

   ほとんどのアプリケーションはミニバッファー使用の一部として使用する場
合を除き、再帰編集を使用するべきではありません。カレントバッファーのメジ
ャーモードから、特殊なメジャーモードに一時的に変更する場合に、そのモード
に戻るコマンドをもつ必要があるときは、通常は再帰編集のほうが便利です
(Rmailの‘e’コマンドはこのテクニックを使用している)。またはユーザーが新た
なバッファーの特殊なモードで、異なるテキストを“再帰的”に編集・作成・選択
できるようにしたい場合が該当します。このモードでは処理を完了させるコマン
ドを定義して、前のバッファーに戻ります(Rmailの‘m’コマンドはこれを使用し
ている)。

   再帰編集はデバッグに便利です。一種のブレークポイントとして関数定義内
に‘debug’を挿入して、関数がそこに達したときにその箇所を調べることができ
ます。‘debug’は再帰編集を呼び出しますが、デバッガのその他の機能も提供し
ます。

   ‘query-replace’内で‘C-r’をタイプしたときや‘C-x q’(‘kbd-macro-query’)を
使用したときも、再帰編集レベルが使用されます。

 -- Command: recursive-edit
     この関数はエディターコマンドループを呼び出す。これはユーザーに編集
     を開始させるために、Emacsの初期化により自動的に呼び出されるLispプロ
     グラムから呼び出されたときは、再帰編集レベルにエンターする。

     カレントバッファーが選択されたウィンドウのバッファーと異なる場合、
     ‘recursive-edit’はカレントバッファーの保存とリストアを行う。それ以
     外では、バッファーを切り替えた場合には、‘recursive-edit’がリターン
     した後その切り替えたバッファーがカレントになる。

     以下の例では、関数‘simple-rec’が最初にポイントを1単語分進めてからメ
     ッセージをエコーエリアにプリントして再帰編集にエンターする。その後
     ユーザーは望む編集を行い、‘C-M-c’をタイプすれば再帰編集をexitして、
     ‘simple-rec’の実行を継続できる。

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               ⇒ simple-rec
          (simple-rec)
               ⇒ nil

 -- Command: exit-recursive-edit
     この関数は最内の再帰編集(ミニバッファー入力を含む)からexitする。関
     数の実質的な定義は‘(throw 'exit nil)’である。

 -- Command: abort-recursive-edit
     この関数は、再帰編集をexitした後に‘quit’をシグナルすることにより、
     最内の再帰編集(ミニバッファー入力を含む)を要求したコマンドをabortす
     る。関数の実質的な定義は‘(throw 'exit t)’である。*note Quitting::を
     参照のこと。

 -- Command: top-level
     この関数はすべての再帰編集レベルをexitする。これはすべての計算を直
     接抜け出してメインのコマンドループに戻り、値をリターンしない。

 -- Function: recursion-depth
     この関数は再帰編集のカレントの深さをリターンする。アクティブな再帰
     編集が存在しない場合は、0をリターンする。


File: elisp,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

20.14 Disabling Commands
========================

“コマンドを無効化(disabling a command)”とは、それを実行可能にする前にユ
ーザーによる確認を要求するようにコマンドをマークすることです。無効化は初
めてのユーザーを混乱させるかもしれないコマンドにたいして、アクシデントに
よりそのコマンドが使用されるのを防ぐために使用されます。

   コマンド無効化の低レベルにおけるメカニズムは、そのコマンドにたいする
Lispシンボルの‘disabled’プロパティに非‘nil’をputすることです。これらのプ
ロパティは、通常はユーザーのinitファイル(*note Init File::を参照)で以下
のようなLisp式によりセットアップされます:

     (put 'upcase-region 'disabled t)

いくつかのコマンドにたいしては、これらのプロパティがデフォルトで与えられ
ています(これらを削除したい場合はinitファイルで削除できる)。

   ‘disabled’プロパティの値が文字列の場合、そのコマンドが無効化されてい
ることを告げるメッセージにその文字列が含まれます。たとえば:

     (put 'delete-region 'disabled
          "この方法で削除されたテキストはyankで戻せない!\n")

   無効化されたコマンドをインタラクティブに呼び出したときに何が起こるか
の詳細は、*Note (emacs)Disabling::を参照してください。コマンドの無効化は
、それをLispプログラムから関数として呼び出したときは効果がありません。

 -- Command: enable-command command
     その時点より、特別な確認なしでCOMMAND(シンボル)が実行されることを許
     す。さらにユーザーのinitファイル(*note Init File::を参照)も修正する
     ので、将来のセッションにもこれが適用される。

 -- Command: disable-command command
     その時点より、COMMAND(シンボル)の実行に特別な確認を要求する。さらに
     ユーザーのinitファイル(*note Init File::を参照)も修正するので、将来
     のセッションにもこれが適用される。

 -- Variable: disabled-command-function
     この変数の値は関数であること。ユーザーが無効化されたコマンドを呼び
     出したときは、無効化されたコマンドのかわりにその関数が呼び出される
     。そのコマンドを実行するためにユーザーが何のキーをタイプしたかを判
     断するために‘this-command-keys’を使用して、そのコマンド自体を探すこ
     とができる。

     値が‘nil’の場合もあり得る。その場合は、たとえ無効化されたコマンドで
     も、すべてのコマンドが通常に機能する。

     デフォルトでは、値はユーザーに処理を行うか尋ねる関数である。


File: elisp,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

20.15 Command History
=====================

コマンドループは複雑なコマンドを手軽に繰り返せるように、実行された複雑な
コマンドのヒストリー(history: 履歴)を保持します。“複雑なコマンド(complex
command)とは、ミニバッファーを使用してinteractive引数を読み取るコマンド
です。”これには‘M-x’コマンド、‘M-:’コマンド、および‘interactive’指定によ
りミニバッファーから引数を読み取る任意のコマンドが含まれます。コマンド自
身の実行の間に明示的にミニバッファーを使用するものは、複雑なコマンドとは
判断されません。

 -- Variable: command-history
     この変数の値は最近実行された複雑なコマンドのリストであり、それぞれ
     が評価されるべきフォームとして表現される。このリストは編集セッショ
     ンの間、すべての複雑なコマンドを蓄積するが、最大サイズ(*note
     Minibuffer History::を参照)に達したときは、もっとも古い要素が削除さ
     れて、新たな要素が追加される。

          command-history
          ⇒ ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

   実際には、このヒストリーリストはミニバッファーヒストリーの特殊ケース
であり、それは要素が文字列ではなく式であることです。

   以前のコマンドを編集したり再呼び出しするためのコマンドがいくつかあり
ます。コマンド‘repeat-complex-command’および‘list-command-history’は、ユ
ーザーマニュアルで説明されています(*note (emacs)Repetition::を参照)。ミ
ニバッファー内では、通常のミニバッファーヒストリーコマンドが理由できます
。


File: elisp,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

20.16 Keyboard Macros
=====================

“キーボードマクロ(keyboard macro)”は、コマンドとして考えることが可能な、
入力イベントの記録されたシーケンスであり、キー定義により作成されます。キ
ーボードマクロのLisp表現は、イベントを含む文字列またはベクターです。キー
ボードマクロとLispマクロ(*note Macros::を参照)を混同しないでください。

 -- Function: execute-kbd-macro kbdmacro &optional count loopfunc
     この関数は、イベントシーケンスとしてKBDMACROを実行する。KBDMACROが
     文字列かベクターの場合、たとえそれがユーザーによる入力であっても、
     その中のイベントは忠実に実行される。シーケンスは、単一のキーシーケ
     ンスであることを_要求されない_。キーボードマクロ定義は、通常は複数
     のキーシーケンスを結合して構成される。

     KBDMACROがシンボルの場合、そのシンボルの関数定義はKBDMACROの箇所に
     使用される。それが別のシンボルの場合は、このプロセスを繰り返す。最
     終的に結果は文字列かベクターになる。結果がシンボル、文字列、ベクタ
     ーでない場合は、エラーがシグナルされる。

     引数COUNTは繰り返すカウントであり、KBDMACROがその回数実行される。
     COUNTが省略、または‘nil’の場合は1回実行される。0の場合、KBDMACROは
     エラーに出会うか検索が失敗するまで、何度も実行される。

     LOOPFUNCが非‘nil’の場合、それはマクロの繰り返しごとに呼び出される、
     引数なしの関数である。LOOPFUNCが‘nil’をリターンすると、マクロの実行
     が停止する。

     ‘execute-kbd-macro’の使用例は、*note Reading One Event::を参照のこ
     と。

 -- Variable: executing-kbd-macro
     この変数は、カレントで実行中のキーボードマクロを定義する文字列かベ
     クターである。‘nil’の場合、カレントで実行中のマクロは存在しない。マ
     クロの実行により実行されたときに異なる振る舞いをするように、コマン
     ドはこの変数をテストできる。この変数を自分でセットしてはならない。

 -- Variable: defining-kbd-macro
     この変数は、キーボードマクロの定義中のときだけ非‘nil’である。マクロ
     定義中の間は異なる振る舞いをするように、コマンドはこの変数をテスト
     できる。既存のマクロ定義に追加する間、値は‘append’になる。コマンド
     ‘start-kbd-macro’、‘kmacro-start-macro’、‘end-kbd-macro’は、この変
     数をセットする。この変数を自分でセットしてはならない。

     この変数は常にカレント端末にたいしてローカルであり、バッファーロー
     カルにできない。*note Multiple Terminals::を参照のこと。

 -- Variable: last-kbd-macro
     この変数は、もっとも最近定義されたキーボードマクロの定義である。値
     は文字列、ベクター、または‘nil’である。

     この変数は常にカレント端末にたいしてローカルであり、バッファーロー
     カルにできない。*note Multiple Terminals::を参照のこと。

 -- Variable: kbd-macro-termination-hook
     これはキーボードマクロが終了したときに実行されるノーマルフックであ
     り、何がキーボードマクロを終了させたか(マクロの最後に達したのか、あ
     るいはエラーにより最後に達する前に終了したのか)は問わない。


File: elisp,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

21 Keymaps
**********

入力イベントのコマンドバインディングは、“キーマップ(keymap)”と呼ばれるデ
ータ構造に記録されます。キーマップ内の各エントリーは個別のイベント型(他
のキーマップ、またはコマンド)に関連づけ(または“バインド”)されます。イベ
ント型がキーマップにバインドされる場合、そのキーマップは次の入力イベント
を調べるために使用されます。これはコマンドが見つかるまで継続されます。こ
のプロセス全体を“キールックアップ(key lookup: キー照合)”と呼びます。

* Menu:

* Key Sequences::            Lispオブジェクトとしてのキーシーケンス。
* Keymap Basics::            キーマップの基本概念。
* Format of Keymaps::        キーマップはLispオブジェクトとしてどのように見えるか。
* Creating Keymaps::         キーマップを作成、コピーする関数。
* Inheritance and Keymaps::  キーマップが他のキーマップのバインディングを継承する方法。
* Prefix Keys::              キーマップの定義としてキーを定義する。
* Active Keymaps::           Emacsがアクティブなキーマップでキーバインディングを探す方法。
* Searching Keymaps::        アクティブなマップ検索のLisp処理概要。
* Controlling Active Maps::  各バッファーは標準(グローバル)のバインディングをオーバーライドするためのキーマップをもつ。マイナーモードもそれらをオーバーライドできる。
* Key Lookup::               1つのキーマップから、あるキーのバインディングを探す。
* Functions for Key Lookup::  キールックアップを要求する方法。
* Changing Key Bindings::    キーマップ内でのキーの再定義。
* Remapping Commands::       キーマップはあるコマンドを他のコマンドに変換できる。
* Translation Keymaps::      イベントシーケンスを変換するキーマップ。
* Key Binding Commands::     キーの再定義にたいするインタラクティブなインターフェイス。
* Scanning Keymaps::         ヘルプをプリントするためにすべてのキーマップを走査する。
* Menu Keymaps::             キーマップとしてキーマップを定義する。


File: elisp,  Node: Key Sequences,  Next: Keymap Basics,  Up: Keymaps

21.1 Key Sequences
==================

“キーシーケンス(key sequence)”、短くは“キー(key)”とは、1つの単位を形成す
る1つ以上の入力イベントのシーケンスです。入力イベントには文字、ファンク
ションキー、マウスアクション、または‘iconify-frame’のようなEmacs外部のシ
ステムイベントが含まれます(*note Input Events::を参照)。キーシーケンスに
たいするEmacs Lispの表現は文字列かベクターです。特に明記しない限り、引数
としてキーシーケンスを受け取るEmacs Lisp関数は両方の表現を処理することが
できます。

   文字列表現では、たとえば、‘"a"’は‘a’、‘"2"’は‘2’を表すといったように
、英数字はその文字自身を意味します。コントロール文字イベントは部分文字列
‘"\C-"’、メタ文字は‘"\M-"’によりプレフィクスされます。たとえば‘"\C-x"’は
キー‘C-x’を表します。それらに加えて、<TAB>、<RET>、<ESC>、<DEL>などのイ
ベントはそれぞれ‘"\t"’、‘"\r"’、‘"\e"’、‘"\d"’で表されます。複雑なキーシ
ーケンスの文字列表現は、イベント成分の文字列表現を結合したものです。した
がって‘"\C-xl"’はキーシーケンス‘C-x l’を表します。

   キーシーケンスにはファンクションキー、マウスボタンイベント、システム
イベント、または‘C-=’や‘H-a’のような文字列で表現できない非ASCII文字が含
まれます。これらはベクターとして表現される必要があります。

   ベクター表現ではベクターの各要素は1つの入力イベントをイベントのLisp形
式で表します。*note Input Events::を参照してください。たとえば、ベクター
‘[?\C-x ?l]’はキーシーケンス‘C-x l’を表します。

   キーシーケンスを文字列やベクターによる表現で記述する例は、*note
(emacs)Init Rebinding::を参照してください。

 -- Function: kbd keyseq-text
     この関数はテキストKEYSEQ-TEXT(文字列定数)をキーシーケンス(文字列か
     ベクターの定数)に変換する。KEYSEQ-TEXTの内容は‘C-x C-k
     <RET>’(‘kmacro-edit-macro’) コマンドにより呼び出されたバッファー内
     と同じ構文を使用するべきであ特にファンクションキーの名前は‘<...>’で
     囲まなければならない。*note (emacs)Edit Keyboard Macro::を参照のこ
     と。

          (kbd "C-x") ⇒ "\C-x"
          (kbd "C-x C-f") ⇒ "\C-x\C-f"
          (kbd "C-x 4 C-f") ⇒ "\C-x4\C-f"
          (kbd "X") ⇒ "X"
          (kbd "RET") ⇒ "\^M"
          (kbd "C-c SPC") ⇒ "\C-c "
          (kbd "<f1> SPC") ⇒ [f1 32]
          (kbd "C-M-<down>") ⇒ [C-M-down]


File: elisp,  Node: Keymap Basics,  Next: Format of Keymaps,  Prev: Key Sequences,  Up: Keymaps

21.2 Keymap Basics
==================

キーマップは、さまざまなキーシーケンスにたいして“キーバインディング(key
binding)”を指定するLispデータ構造です。

   1つのキーマップが、個々のイベントにたいする定義を直接指定します。 A
single keymap directly specifies definitions for individual events. 単一
のイベントでキーシーケンスが構成されるとき、そのキーシーケンスのキーマッ
プ内でのバインディングは、そのイベントにたいするそのキーマップの定義です
。それより長いキーシーケンスのバインディングは対話的プロセスにより見つけ
出されます。まず、最初のイベント(これ自身がキーマップでなければならない
)の定義を探します。次にそのキーマップ内で2つ目のイベントを探すといったよ
うに、そのキーシーケンス内のすべてのイベントが処理されるまで、これを続け
ます。

   あるキーシーケンスのバインディングがキーマップであるような場合、わた
したちはそのキーシーケンスを“プレフィクスキー(prefix key)”と呼び、それ以
外の場合は(それ以上イベントを追加できないので)“コンプリートキー(complete
keyl”と呼んでいます。バインディングが‘nil’の場合、わたしたちはそのキーを
“未定義(undefined)”と呼びます。‘C-c’、‘C-x’、‘C-x 4’などはプレフィクスキ
ーの例です。‘X’、<RET>、‘C-x 4 C-f’などは定義されたコンプリートキーの例
です。‘C-x C-g’や‘C-c 3’などは未定義なコンプリートキーの例です。詳細は
*note Prefix Keys::を参照してください。

   キーシーケンスのバインディングを見つけ出すルールは、(最後のイベントの
前までに見つかる)中間的なバインディングがすべてキーマップであると仮定し
ます。もしそうでなければ、そのイベントシーケンスは単位を形成せず、実際の
単一キーシーケンスではありません。他の言い方をすると、任意の有効なキーシ
ーケンスから1つ以上のイベントを取り除くと、常にプレフィクスキーにならな
ければなりません。たとえば‘C-f C-n’はキーシーケンスではありません。
‘C-f’はプレフィクスキーではないので、‘C-f’で始まるこれより長いシーケンス
は、キーシーケンスであり得ないのです。

   利用可能な複数イベントキーシーケンスのセットは、プレフィクスキーにた
いするバインディングに依存します。したがって、これはキーマップが異なれば
異なるかもしれず、バインディングが変更されたとき変更されるかもしれません
。しかし、単一イベントキーシーケンスは適格性において任意のプレフィクスキ
ーに依存しないので、常に単一のキーシーケンスです。

   常に複数のプライマリーキーマップ(primary keymap: 主キーマップ)がアク
ティブであり、これらはキーバインディングを見つけるために使用されます。す
べてのバッファーで共有される“グローバルキーマップ(global map)”というキー
マップが存在します。“ローカルキーマップ(local keymap)”は通常、特定のメジ
ャーモードに関連します。そして0個以上の“マイナーモードキーマップ(minor
mode keymap)”はカレントで有効なマイナーモードに属します(すべてのマイナー
モードがキーマップをもつわけでなない)。ローカルキーマップは、対応するグ
ローバルバインディングをshadow(優先される)します。マイナーモードキーマッ
プは、ローカルキーマップとグローバルキーマップの両方をshadowします。詳細
は、*note Active Keymaps::を参照してください。


File: elisp,  Node: Format of Keymaps,  Next: Creating Keymaps,  Prev: Keymap Basics,  Up: Keymaps

21.3 Format of Keymaps
======================

キーマップはそれぞれ、CARがシンボル‘keymap’であるようなリストです。この
リストの残りの要素は、そのキーマップのキーバインディングを定義します。関
数定義がキーマップであるようなシンボルもキーマップです。あるオブジェクト
がキーマップかどうかテストするには、関数‘keymapp’(以下参照)を使用してく
ださい。

   キーマップを開始するシンボル‘keymap’の後には、いくつかの種類の要素が
出現します:

‘(TYPE . BINDING)’
     これは型TYPEのイベントにたいする1つのバインディングを指定する。通常
     のバインディングはそれぞれ、常に文字かシンボルであるような特定の“イ
     ベント型(event type)”のイベントに適用される。*note Classifying
     Events::を参照のこと。この種のバインディングでは、BINDINGはコマンド
     である。

‘(TYPE ITEM-NAME . BINDING)’
     これは、メニュー内でITEM-NAMEとして表示されるシンプルなメニューアイ
     テムでもあるようなバインディングを指定する。*note Simple Menu
     Items::を参照のこと。

‘(TYPE ITEM-NAME HELP-STRING . BINDING)’
     これは、ヘルプ文字列HELP-STRINGのシンプルなメニューアイテムである。

‘(TYPE menu-item . DETAILS)’
     これは、拡張されたメニューアイテムでもあるようなバインディングを指
     定する。これは他の機能も使用できる。*note Extended Menu Items::を参
     照のこと。

‘(t . BINDING)’
     これは“デフォルトキーバインディング(default key binding)”を指定する
     。キーマップの他の要素でバインドされないイベントは、バインディング
     としてBINDINGが与えられる。デフォルトバインディングにより、利用可能
     なすべてのイベント型を列挙することなくバインドできる。デフォルトバ
     インディングをもつキーマップは、明示的に‘nil’にバインドされるイベン
     ト(以下参照)を除き、より低い優先度にあるすべてのキーマップをマスク
     する。

‘CHAR-TABLE’
     キーマップのある要素が文字テーブル(char-table)の場合、それは修飾ビ
     ットなしのすべての文字イベントにたいするバインディングを保持すると
     みなされる。 If an element of a keymap is a it counts as holding
     bindings for all character events with no modifier bits (*note
     modifier bits::): 要素Nは、コードNの文字にたいするバインディングで
     ある。これは多量のバインディングを記録するための、コンパクトな方法
     である。そのような文字テーブルのキーマップは、“fullキーマップ(full
     keymap: 完全なキーマップ)”と呼ばれる。それにたいし他のキーマップは
     “sparseキーマップ(sparse keymaps: 疎なキーマップ)”と呼ばれる。

‘STRING’
     キーにたいするバインディングを指定する要素は別として、キーマップは
     要素として文字列ももつことができる。これは“overallプロンプト文字列
     (overall prompt string: 全般的なプロンプト文字列)”と呼ばれ、メニュ
     ーとしてキーマップを使用することを可能にする。*note Defining
     Menus::を参照のこと。

‘(keymap ...)’
     キーマップのある要素それ自身がキーマップの場合、それは外側のキーマ
     ップ内でこれが内側のキーマップとしてinline指定されているかのように
     みなされる。これは‘make-composed-keymap’内で行なわれるような多重継
     承にたいして使用される。

   バインディングが‘nil’の場合、それは定義の構成要素ではありませんが、デ
フォルトバインディングや親キーマップ内のバインディングに優先されます。一
方、‘nil’のバインディングは、より低い優先度のキーマップを_オーバーライド
しません_したがって、ローカルマップで‘nil’のバインディングが与えられた場
合、Emacsはグローバルマップのバインディングを使用します。

   キーマップはメタ文字にたいするバインディングを直接記録しません。かわ
りに、メタ文字は１文字目が<ESC>(または何であれ‘meta-prefix-char’のカレン
ト値)の、2文字のキーシーケンスをルックアップするものとみなされます。した
がって、キー‘M-a’は内部的に‘<ESC> a’で表され、そのグローバルバインディン
グは、‘esc-map’内の‘a’にたいするスロットで見つけることができます(*note
Prefix Keys::を参照)。

   この変換は文字にたいしてのみ適用され、ファンクションキーや他の入力イ
ベントには適用されないので、‘M-<end>’は‘<ESC> <end>’と何も関係ありません
。

   以下に例としてLispモードにたいするローカルキーマップ(sparseキーマップ
)を挙げます。以下では<DEL>、‘C-c C-z’、‘C-M-q’、‘C-M-x’にたいするバイン
ディングを定義しています(実際の値はメニューバインディングも含みますが、
簡潔にするためここでは省略しています)。

     lisp-mode-map
     ⇒
     (keymap
      (3 keymap
         ;; C-c C-z
         (26 . run-lisp))
      (27 keymap
          ;; ‘C-M-x’は‘<ESC> C-x’として扱われる
          (24 . lisp-send-defun))
      ;; この部分は‘lisp-mode-shared-map’から継承
      keymap
      ;; <DEL>
      (127 . backward-delete-char-untabify)
      (27 keymap
          ;; ‘C-M-q’は‘<ESC> C-q’として扱われる
          (17 . indent-sexp)))

 -- Function: keymapp object
     この関数は、OBJECTがキーマップなら‘t’、それ以外は‘nil’をリターンす
     る。より正確には、この関数はリストにたいしてそのCARが‘keymap’か、あ
     るいはシンボルにたいしてその関数定義が‘keymapp’かをテストする。

          (keymapp '(keymap))
              ⇒ t
          (fset 'foo '(keymap))
          (keymapp 'foo)
              ⇒ t
          (keymapp (current-global-map))
              ⇒ t


File: elisp,  Node: Creating Keymaps,  Next: Inheritance and Keymaps,  Prev: Format of Keymaps,  Up: Keymaps

21.4 Creating Keymaps
=====================

以下はキーマップを作成する関数です。

 -- Function: make-sparse-keymap &optional prompt
     この関数はエントリーをもたない新たなsparseキーマップを作成して、そ
     れをリターンする(sparseキーマップは、あなたが通常望む類のキーマップ
     のこと)。‘make-keymap’とは異なり、新たなキーマップは文字テーブルを
     含まず、何のイベントもバインドしない。

          (make-sparse-keymap)
              ⇒ (keymap)

     PROMPTを指定した場合、それはキーマップにたいするoverallプロンプト文
     字列になる。これはメニューキーマップ(*note Defining Menus::を参照
     )にたいしてのみ指定すべきである。overallプロンプト文字列をともなう
     キーマップがアクティブな場合は、次の入力イベントのルックアップにた
     いしてマウスメニューとキーボードメニューを常に提示する。これはコマ
     ンドループにたいして毎回キーボードメニューを提示するので、overallプ
     ロンプト文字列をメインマップ、メジャーモードマップ、マイナーモード
     マップに指定しないこと。

 -- Function: make-keymap &optional prompt
     この関数は、新たなfullキーマップを作成して、それをリターンする。こ
     のキーマップは修飾されないすべての文字にたいするスロットをもつ文字
     テーブル(*note Char-Tables::を参照)を含む。この新たなキーマップは、
     初期状態ではすべての文字、およびその他の種類のイベントが‘nil’にバイ
     ンドされている。引数PROMPTは、‘make-sparse-keymap’のようにプロンプ
     ト文字列を指定する。

          (make-keymap)
              ⇒ (keymap #^[nil nil keymap nil nil nil ...])

     fullキーマップは、多くのスロットを保持するときはsparseキーマップよ
     り効果的であり、少ししかスロットを保持しないときはsparseキーマップ
     のほうが適している。

 -- Function: copy-keymap keymap
     この関数は、KEYMAPのコピーをリターンする。KEYMAP内でバインディング
     として直接出現するすべてのキーマップも、すべてのレベルまで再帰的に
     コピーされる。しかし、ある文字の定義が関数定義にキーマップをもつ関
     数のときは、再帰的なコピーは行われず、新たにコピーされたキーマップ
     には同じシンボルがコピーされる。

          (setq map (copy-keymap (current-local-map)))
          ⇒ (keymap
               ;; (これはメタ文字を実装する)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))

          (eq map (current-local-map))
              ⇒ nil
          (equal map (current-local-map))
              ⇒ t


File: elisp,  Node: Inheritance and Keymaps,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

21.5 Inheritance and Keymaps
============================

キーマップは、他のキーマップを継承することができ、この継承元のキーマップ
を“親キーマップ(parent keymap)”と呼びます。そのようなキーマップは、以下
のようなキーマップです:

     (keymap ELEMENTS... . PARENT-KEYMAP)

これの効果は、このキーマップがキールックアップ時にPARENT-KEYMAPのすべて
のバインディングを継承するが、それらにバインディングを追加したり、
ELEMENTSでオーバーライドできるということです。

   ‘define-key’や他のキーバインディング関数を使用してPARENT-KEYMAP内のバ
インディングを変更した場合、変更されたバインディングはELEMENTSで作られた
バインディングにshadowされない限り、継承されたキーマップ内で可視になりま
す。逆は真ではありません。‘define-key’を使用して継承されたキーマップ内の
バインディングを変更した場合、これらの変更はELEMENTS内に記録されますが、
PARENT-KEYMAPに影響はありません。

   親キーマップからキーマップを構築するには、‘set-keymap-parent’を使用す
るのが正しい方法です。親キーマップから直接キーマップを構築するコードがあ
る場合は、かわりに‘set-keymap-parent’を使用するようにプログラムを変更し
てください。

 -- Function: keymap-parent keymap
     これは、KEYMAPの親キーマップをリターンする。KEYMAPに親キーマップが
     ない場合、‘keymap-parent’は‘nil’をリターンする。

 -- Function: set-keymap-parent keymap parent
     これはKEYMAPの親キーマップをPARENTにセットして、PARENTをリターンす
     る。PARENTが‘nil’の場合、この関数はKEYMAPに親キーマップを与えない。

     KEYMAPがサブマップ(プレフィクスキーにたいするバインディング)をもつ
     場合は、それらも新たな親キーマップを受け取り、それらのプレフィクス
     キーにたいしてPARENTが何を指定するかが反映される。

   以下は‘text-mode-map’から継承してキーマップを作成する方法を示す例です
:

     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map text-mode-map)
       map)

   非sparseキーマップも親キーマップをもつことができますが、便利とは言え
ません。非sparseキーマップは、修飾ビットをもたないすべての数値文字コード
にたいするバインディングとして、たとえそれが‘nil’であっても常に何かを指
定するので、これらの文字のバインディングが親キーマップから継承されること
は決してないのです。

   複数のマップからキーマップを継承したいときがあるかもしれません。これ
にたいしては、関数‘make-composed-keymap’が使用できます。

 -- Function: make-composed-keymap maps &optional parent
     この関数は、既存のキーマップから構成される新たなキーマップをリター
     ンする。また、オプションで親キーマップPARENTから継承する。MAPSには
     単一のキーマップ、または複数のキーマップのリストを指定できる。リタ
     ーンされた新たなマップ内でキーをルックアップするとき、EmacsはMAPS内
     のキーマップを順に検索してからPARENT内を検索する。この検索は最初の
     マッチで停止される。MAPSのどれか1つのキーマップ内の‘nil’バインディ
     ングは、PARENT内の任意のバインディングをオーバーライドするが、
     MAPSにないキーマップの非‘nil’バインディングはオーバーライドしない。

For example, here is how Emacs sets the parent of 【FIXME】たとえば、以
下は‘button-buffer-map’と‘special-mode-map’の両方を継承する
‘help-mode-map’のようなキーマップの親キーマップをEmacsがセットする方法で
す:

     (defvar help-mode-map
       (let ((map (make-sparse-keymap)))
         (set-keymap-parent map
           (make-composed-keymap button-buffer-map special-mode-map))
         ... map) ... )


File: elisp,  Node: Prefix Keys,  Next: Active Keymaps,  Prev: Inheritance and Keymaps,  Up: Keymaps

21.6 Prefix Keys
================

“プレフィクスキー(prefix key)”とは、バインディングがキーマップであるよう
なキーシーケンスです。このキーマップは、プレフィクスキーを拡張するキーシ
ーケンスが何を行うか定義します。たとえば、‘C-x’はプレフィクスキーであり
、これはキーマップを使用し、そのキーマップは変数‘ctl-x-map’にも格納され
ています。このキーマップは‘C-x’で始まるキーシーケンスにたいするバインデ
ィングを定義します。

   標準的なEmacsのプレフィクスキーのいくつかは、Lisp変数でも見い出すこと
ができるキーマップを使用していますl:

   • ‘esc-map’は、プレフィクスキー<ESC>にたいするグローバルキーマップで
     ある。したがって、すべてのメタ文字にたいする定義は、このキーマップ
     で見つけることができる。このマップは、‘ESC-prefix’の関数定義でもあ
     る。

   • ‘help-map’は、プレフィクスキー‘C-h’にたいするグローバルキーマップで
     ある。

   • ‘mode-specific-map’は、プレフィクスキー‘C-c’にたいするグローバルキ
     ーマップである。このマップは実際にはモード特有(mode-specific)ではな
     くグローバルであるが、このプレフィクスキーは主にモード特有なバイン
     ディングに使用されるので、‘C-h b’(‘display-bindings’)の出力内の
     ‘C-c’に関する情報で、この名前は有意義な情報を提供する。

   • ‘ctl-x-map’は、プレフィクスキー‘C-x’にたいして使用されるグローバル
     キーマップである。このマップは、シンボル‘Control-X-prefix’の関数セ
     ルを通して見つけることができる。

   • ‘mule-keymap’は、プレフィクスキー‘C-x <RET>’ にたいして使用されるグ
     ローバルキーマップである。

   • ‘ctl-x-4-map’は、プレフィクスキー‘C-x 4’にたいして使用されるグロー
     バルキーマップである。

   • ‘ctl-x-5-map’は、プレフィクスキー‘C-x 5’にたいして使用されるグロー
     バルキーマップである。

   • ‘2C-mode-map’は、プレフィクスキー‘C-x 6’にたいして使用されるグロー
     バルキーマップである。

   • ‘vc-prefix-map’は、プレフィクスキー‘C-x v’にたいして使用されるグロ
     ーバルキーマップである。

   • ‘goto-map’は、プレフィクスキー‘M-g’にたいして使用されるグローバルキ
     ーマップである。

   • ‘search-map’は、プレフィクスキー‘M-s’にたいして使用されるグローバル
     キーマップである。

   • ‘facemenu-keymap’は、プレフィクスキー‘M-o’にたいして使用されるグロ
     ーバルキーマップである。

   • Emacsの他のプレフィクスキーには‘C-x @’、‘C-x a i’、‘C-x <ESC>’、
     ‘<ESC> <ESC>’がある。これらは、特別な名前をもたないキーマップを使用
     する。

   プレフィクスキーのキーマップバインディングは、プレフィクスキーに続く
イベントをルックアップするために使用されます。(これは、関数定義がキーマ
ップであるようなシンボルかもしれません。効果は同じですが、シンボルはプレ
フィクスキーにたいする名前の役割を果たします。) したがって、‘C-x’のバイ
ンディングはシンボル‘Control-X-prefix’であり、このシンボルの関数セルが
‘C-x’コマンドにたいするキーマップを保持します(‘ctl-x-map’の値も同じキー
マップです)。

   プレフィクスキー定義は、任意のアクティブなキーマップ内に置くことがで
きます。プレフィクスキーとしての‘C-c’、‘C-x’、‘C-h’、<ESC>の定義はグロー
バルマップ内にもあるので、これらのプレフィクスキーは常に使用できます。メ
ジャーモードとマイナーモードは、ローカルマップやマイナーモードのマップ内
にプレフィクスキー定義を置くことにより、キーをプレフィクスキーとして再定
義できます。 *note Active Keymaps::を参照してください。

   あるキーが複数のアクティブなマップ内でプレフィクスキーとして定義され
ている場合、それぞれの定義がマージされて効果をもちます。まずマイナーモー
ドキーマップ内で定義されたコマンド、次にローカルマップのプレフィクス定義
されたコマンド、そしてグローバルマップのコマンドが続きます。

   以下の例では、ローカルキーマップ内で‘C-p’を‘C-x’と等価なプレフィクス
キーにしています。すると、‘C-p C-f’にたいするバインディングは、‘C-x
C-f’と同様に関数‘find-file’になります。キーシーケンス‘C-p 6’は、すべての
アクティブなキーマップで見つけることができません。

     (use-local-map (make-sparse-keymap))
         ⇒ nil
     (local-set-key "\C-p" ctl-x-map)
         ⇒ nil
     (key-binding "\C-p\C-f")
         ⇒ find-file

     (key-binding "\C-p6")
         ⇒ nil

 -- Function: define-prefix-command symbol &optional mapvar prompt
     この関数は、プレフィクスキーのバインディングとして使用するために、
     SYMBOLを用意する。これはsparseキーマップを作成して、それをSYMBOLの
     関数定義として格納する。その後はSYMBOLにキーシーケンスをバインディ
     ングすると、そのキーシーケンスはプレフィクスキーになるだろう。リタ
     ーン値は‘symbol’である。

     この関数は、値がそのキーマップであるような変数としてもSYMBOLをセッ
     トする。しかしMAPVARが非‘nil’の場合は、かわりにMAPVARを変数としてセ
     ットする。

     PROMPTが非‘nil’の場合、これはそのキーマップにたいするoverallプロン
     プト文字列になる。プロンプト文字列はメニューキーマップにたいして与
     えられるべきである(*note Defining Menus::を参照)。


File: elisp,  Node: Active Keymaps,  Next: Searching Keymaps,  Prev: Prefix Keys,  Up: Keymaps

21.7 Active Keymaps
===================

Emacsは多くのキーマップを含んでいますが、常にいくつかのキーマップだけが
“アクティブ”です。Emacsがユーザー入力を受け取ったとき、それは入力イベン
トに変換されて(*note Translation Keymaps::を参照)、アクティブなキーマッ
プ内でキーバインディングが照合されます。

   アクティブなキーマップは通常、(1) ‘keymap’プロパティにより指定される
キーマップ、(2) 有効なマイナーモードのキーマップ、(3) カレントバッファー
のローカルキーマップ、(4) グローバルキーマップの順です。Emacsは入力キー
シーケンスそれぞれにたいして、これらすべてのキーマップ内を検索します。

   これらの“通常”のキーマップのうち最優先されるのは、もしあればポイント
位置の‘keymap’テキストにより指定されるキーマップ、またはoverallプロパテ
ィです。(マウス入力イベントにたいしては、Emacsはポイント位置のかわりにイ
ベント位置を使用する。 *note Searching Keymaps::を参照のこと。)

   次に優先されるのは、有効なマイナーモードにより指定されるキーマップで
す。もしあれば、これらのキーマップは変数‘emulation-mode-map-alists’、
‘minor-mode-overriding-map-alist’、‘minor-mode-map-alist’により指定され
ます。*note Controlling Active Maps::を参照してください。

   次に優先されるのは、バッファーの“ローカルキーマップ(local keymap)”で
、これにはそのバッファー特有なキーバインディングが含まれます。ミニバッフ
ァーもローカルキーマップをもちます(*note Intro to Minibuffers::を参照)。
ポイント位置に‘local-map’テキスト、またはoverlayプロパティがある場合、そ
れはバッファーのデフォルトローカルキーマップのかわりに使用するローカルキ
ーマップを指定します。

   ローカルキーマップは通常はそのバッファーのメジャーモードによりセット
されます。同じメジャーモードをもつすべてのバッファーは、同じローカルキー
マップを共有します。したがって、あるバッファーでローカルキーマップを変更
するために‘local-set-key’(*note Key Binding Commands::を参照)を呼び出し
た場合、それは同じメジャーモードをもつ他のバッファーのローカルキーマップ
にも影響を与えます。

   最後は、‘C-f’のようなカレントバッファーとは関係なく定義されるキーバイ
ンディングを含む、“グローバルキーマップ(global keymap)”です。kこのキーマ
ップは常にアクティブであり、変数‘global-map’にバインドされています。

   これら“通常”のキーマップとは別に、Emacsはプログラムが他のキーマップを
アクティブにするための特別な手段を提供します。1つ目は、グローバルキーマ
ップ以外の通常アクティブなキーマップを置き換えるキーマップを指定する変数
‘overriding-local-map’です。2つ目は、他の_すべて_のキーマップより優先さ
れるキーマップを指定する、端末ローカル変数
‘overriding-terminal-local-map’です。この端末ローカル変数は通常、
modal(訳注: 他のキーマップを選択できない状態)かつ一時的なキーバインディ
ングに使用されます(ここの変数にたいして関数‘set-transient-map’は便利なイ
ンターフェイスを提供する)。詳細は、*note Controlling Active Maps::を参照
のこと。

   これらを使用するのがキーマップをアクティブにする唯一の方法ではありま
せん。キーマップは、‘read-key-sequence’によるイベントの変換のような、他
の用途にも使用されます。*note Translation Keymaps::を参照してください。

   いくつかの標準的なキーマップのリストは、*note Standard Keymaps::を参
照してください。

 -- Function: current-active-maps &optional olp position
     これは、カレントの状況下でコマンドループによりキーシーケンスをルッ
     クアップするために使用される、アクティブなキーマップのリストをリタ
     ーンする。これは通常、‘overriding-local-map’と
     ‘overriding-terminal-local-map’を無視するが、OLPが非‘nil’の場合には
     、それらのキーマップにも注意を払う。オプションでPOSITIONに
     ‘event-start’によりリターンされるイベント位置、またはバッファー位置
     を指定でき、‘key-binding’で説明されているようにキーマップを変更する
     かもしれない。

 -- Function: key-binding key &optional accept-defaults no-remap
          position
     この関数は、カレントのアクティブキーマップでKEYにたいするバインディ
     ングをリターンする。そのキーマップ内でKEYが未定義の場合、結果は
     ‘nil’になる。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(*note Functions for Key
     Lookup::を参照)のようにデフォルトバインディングをチェックするかを制
     御する。

     コマンドがリマップ(remap: 再マップ。*note Remapping Commands::を参
     照)されたとき、‘key-binding’は通常、実際に実行されるであろうリマッ
     プされたコマンドをリターンするように、コマンドのリマップを行う。し
     かし、NO-REMAPが非‘nil’の場合、‘key-binding’はリマップを無視して、
     KEYにたいして直接指定されたバインディングをリターンする。

     KEYがマウスイベント(もしかしたらプレフィクスイベントが先行するかも
     しれない)で始まる場合、照合されるマップはそのイベントの位置を元に決
     定される。それ以外では、それらのマップはポイント値に基づき決定され
     る。しかし、POSITIONを指定することにより、これらをオーバーライドで
     きる。POSITIONが非‘nil’の場合、それはバッファー位置か
     ‘event-start’の値のようなイベント位置のいずれかである。その場合、照
     合されるマップはPOSITIONに基づき決定される。

     KEYが文字列とベクターのいずれでもない場合、Emacsはエラーをシグナル
     する。

          (key-binding "\C-x\C-f")
              ⇒ find-file


File: elisp,  Node: Searching Keymaps,  Next: Controlling Active Maps,  Prev: Active Keymaps,  Up: Keymaps

21.8 Searching the Active Keymaps
=================================

以下は、macsがアクティブなキーマップを検索する方法を示す、Lisp処理概要で
す:

     (or (if overriding-terminal-local-map
             (FIND-IN overriding-terminal-local-map))
         (if overriding-local-map
             (FIND-IN overriding-local-map)
           (or (FIND-IN (get-char-property (point) 'keymap))
               (FIND-IN-ANY emulation-mode-map-alists)
               (FIND-IN-ANY minor-mode-overriding-map-alist)
               (FIND-IN-ANY minor-mode-map-alist)
               (if (get-text-property (point) 'local-map)
                   (FIND-IN (get-char-property (point) 'local-map))
                 (FIND-IN (current-local-map)))))
         (FIND-IN (current-global-map)))

ここで、FIND-INとFIND-IN-ANYはそれぞれ、1つのキーマップとキーマップの
alistを検索する仮の関数です。関数‘set-transient-map’が
‘overriding-terminal-local-map’(*note Controlling Active Maps::を参照)を
セットすることにより機能する点に注意してください。

   上記の処理概要では、キーシーケンスがマウスイベント(*note Mouse
Events::を参照)で始まる場合、ポイント位置のかわりにそのイベント位置、カ
レントバッファーのかわりにそのイベントのバッファーが使用されます。これは
特に、プロパティ‘keymap’および‘local-map’をルックアップする方法に影響を
与えます。‘display’、‘before-string’、‘after-string’プロパティ(*note
Special Properties::を参照)が埋め込まれていて、‘keymap’または
‘local-map’プロパティが非‘nil’の文字列上でマウスイベントが発生した場合、
それは基調となるバッファーテキストの対応するプロパティをオーバーライドし
ます(バッファーテキストにより指定されたプロパティは無視される)。

   アクティブなキーマップの1つでキーバインディングが見つかり、そのバイン
ディングがコマンドの場合、検索は終了し、そのコマンドが実行されます。しか
し、そのバインディングが値をもつ変数、または文字列の場合、Emacsは入力キ
ーシーケンスをその変数の値、または文字列で置き換えて、アクティブなキーマ
ップの検索を再開します。 *note Key Lookup::を参照してください。

   最終的に見つかったコマンドもリマップされるかもしれません。*note
Remapping Commands::を参照してください。


File: elisp,  Node: Controlling Active Maps,  Next: Key Lookup,  Prev: Searching Keymaps,  Up: Keymaps

21.9 Controlling the Active Keymaps
===================================

 -- Variable: global-map
     この変数は、Emacsキーボード入力をコマンドにマップするデフォルトのグ
     ローバルキーマップを含む。通常は、このキーマップがグローバルキーマ
     ップである。デフォルトグローバルキーマップは、
     ‘self-insert-command’をすべてのプリント文字にバインドするfullキーマ
     ップである。

     これはグローバルキーマップ内のバインディングを変更する通常の手段だ
     が、この変数に開始時のキーマップ以外の値を割り当てるべきではない。

 -- Function: current-global-map
     この関数は、カレントのグローバルキーマップをリターンする。デフォル
     トグローバルキーマップとカレントグローバルキーマップのいずれも変更
     していない場合は、‘global-map’と同じ値になる。リターン値はコピーで
     はなく参照である。これに‘define-key’などの関数を使用すると、グロー
     バルバインディングが変更されるだろう。

          (current-global-map)
          ⇒ (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 -- Function: current-local-map
     この関数はカレントバッファーのローカルキーマップをリターンする。ロ
     ーカルキーマップがない場合は‘nil’をリターンする。以下の例では、
     (Lisp Interactionモードを使用する)‘*scratch*’バッファーにたいするキ
     ーマップは、<ESC>(ASCIIコード27)にたいするエントリーが別のsparseキ
     ーマップであるようなsparseキーマップである。

          (current-local-map)
          ⇒ (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

   ‘current-local-map’はローカルキーマップのコピーではなく参照をリターン
する。これに‘define-key’などの関数を使用すると、ローカルバインディングが
変更されるだろう。

 -- Function: current-minor-mode-maps
     この関数は、カレントで有効なメジャーモードのキーマップリストをリタ
     ーンする。

 -- Function: use-global-map keymap
     この関数は、KEYMAPを新たなカレントグローバルキーマップにする。これ
     は‘nil’をリターンする。

     グローバルキーマップの変更は、異例である。

 -- Function: use-local-map keymap
     この関数は、KEYMAPをカレントバッファーの新たなローカルキーマップに
     する。KEYMAPが‘nil’の場合、そのバッファーはローカルキーマップをもた
     ない。‘use-local-map’は‘nil’をリターンする。ほとんどのメジャーモー
     ドコマンドは、この関数を使用する。

 -- Variable: minor-mode-map-alist
     この変数は、アクティブかどうかに関わらず、特定の変数の値にたいする
     キーマップを示すalistである。要素は、以下のようになる:

          (VARIABLE . KEYMAP)

     キーマップKEYMAPは、 VARIABLEが非‘nil’値をもつときはアクティブであ
     る。通常、VARIABLEはメジャーモードを有効、または無効にする変数であ
     る。*note Keymaps and Minor Modes::を参照のこと。

     ‘minor-mode-map-alist’の要素が、‘minor-mode-alist’の要素と異なる構
     造をもつことに注意されたい。マップは要素のCDRでなければならず、そう
     でなければ2つ目の要素にマップリストは用いられないだろう。CDRはキー
     マップ(リスト)、または関数定義がキーマップであるようなシンボルであ
     る。

     1つ以上のマイナーモードキーマップがアクティブなとき、
     ‘minor-mode-map-alist’内で前のキーマップが優先される。しかし、互い
     が干渉しないようにマイナーモードをデザインすべきである。これを正し
     く行えば、順序は問題にならない。

     マイナーモードについての詳細な情報は、*note Keymaps and Minor
     Modes::を参照のこと。‘minor-mode-key-binding’(*note Functions for
     Key Lookup::を参照)も確認されたい。

 -- Variable: minor-mode-overriding-map-alist
     この変数は、メジャーモードによる特定のマイナーモードにたいするキー
     バインディングのオーバーライドを可能にする。このalistの要素は、
     ‘minor-mode-map-alist’の要素のように、‘(VARIABLE . KEYMAP)’のような
     形式である。

     ある変数が‘minor-mode-overriding-map-alist’の要素として出現する場合
     、その要素により指定されるマップは、‘minor-mode-map-alist’内の同じ
     変数にたいして指定される任意のマップを完全に置き換える。

     すべてのバッファーにおいて、‘minor-mode-overriding-map-alist’は自動
     的にバッファーローカルである。

 -- Variable: overriding-local-map
     この変数が非‘nil’の場合は、バッファーのローカルキーマップ、テキスト
     プロパティまたはoverlayによるキーマップ、マイナーモードキーマップの
     かわりに使用されるするキーマップを保持する。このキーマップが指定さ
     れた場合、カレントグローバルキーマップ以外のアクティブだった他のす
     べてのマップがオーバーライドされる。

 -- Variable: overriding-terminal-local-map
     この変数が非‘nil’の場合は、‘overriding-local-map’、バッファーのロー
     カルキーマップ、テキストプロパティまたはoverlayによるキーマップ、お
     よびすべてのマイナーモードキーマップのかわりに使用されるキーマップ
     を保持する。

     この変数は、カレント端末にたいして常にローカルであり、バッファーロ
     ーカルにできない。*note Multiple Terminals::を参照のこと。これはイ
     ンクリメンタル検索モードの実装に使用される。

 -- Variable: overriding-local-map-menu-flag
     この変数が非‘nil’の場合は、‘overriding-local-map’または
     ‘overriding-terminal-local-map’の値がメニューバーの表示に影響し得る
     。デフォルト値は‘nil’なので、これらのマップ変数なメニューバーに影響
     をもたない。

     これら2つのマップ変数は、たとえこれらの変数がメニューバー表示に影響
     し得るを与えない場合でも、メニューバーを使用してエンターされたキー
     シーケンスの実行には影響を与えることに注意されたい。したがって、も
     しメニューバーキーシーケンスが到着したら、そのキーシーケンスをルッ
     クアップ・実行する前に変数をクリアーすべきである。この変数を使用す
     るモードは通常、何らかの方法でこれを行っている。これらのモードは通
     常“読み戻し(unread)”とexitにより処理されないイベントに応答する。

 -- Variable: special-event-map
     この変数は、スペシャルイベントにたいするキーマップを保持する。ある
     イベント型がこのキーマップ内でバインディングをもつ場合、それはスペ
     シャルであり、そのイベントにたいするバインディングは‘read-event’に
     より直接実行される。*note Special Events::を参照のこと。

 -- Variable: emulation-mode-map-alists
     この変数は、エミュレーションモードにたいして使用するキーマップ
     alistのリストを保持する。この変数は、複数マイナーモードキーマップを
     使用するモードとパッケージを意図している。リストの各要素は
     ‘minor-mode-map-alist’と同じフォーマットと意味をもつキーマップ
     alistか、そのようなalist形式の変数バインディングをもつシンボルであ
     る。それぞれのalist内の“アクティブ”なキーマップは、
     ‘minor-mode-map-alist’と‘minor-mode-overriding-map-alist’の前に使用
     される。

 -- Function: set-transient-map keymap &optional keep
     この関数は“一時的(transient)”なキーマップとしてKEYMAPを追加する。一
     時的なキーマップは1つ以上の後続するキーにたいして、他のキーマップよ
     り優先される。

     通常、KEYMAPは直後のキーをルックアップするために、1回だけ使用される
     。しかし、オプション引数PREDが‘t’の場合、そのマップはユーザーが
     KEYMAP内で定義されたキーをタイプするまでアクのままとなる。KEYMAP内
     にないキーをユーザーがタイプしたとき、一時的キーマップは非アクティ
     ブとなり、そのキーにたいして通常のキールックアップが継続される。

     PREDには関数も指定できる。。この場合、KEYMAPがアクティブの間は、各
     コマンドの実行に優先して、その関数が引数なしで呼び出される。
     KEYMAPがアクティブの間、関数は非‘nil’をリターンすべきである。

     この関数は、他のすべてのアクティブなキーマップに優先される変数
     ‘overriding-terminal-local-map’にたいして、‘keymap’を追加、または削
     除することにより機能する(*note Searching Keymaps::を参照)。


File: elisp,  Node: Key Lookup,  Next: Functions for Key Lookup,  Prev: Controlling Active Maps,  Up: Keymaps

21.10 Key Lookup
================

“キールックアップ(key lookup: キー照合)”とは、与えられたキーマップからキ
ーシーケンスのバインディングを見つけ出すことです。そのバインディングの使
用や実行は、キールックアップの一部ではありません。

   キールックアップは、キーシーケンス内の各イベントのイベント型だけを使
用し、そのイベントの残りは無視します。実際のところ、キールックアップに使
用されるキーシーケンスは、マウスイベントをイベント全体(リスト)のかわりに
イベント型のみ(シンボル)を用いるでしょう。*note Input Events::を参照して
ください。そのような“キーシーケンス”は、‘command-execute’による実行には
不十分ですが、キーのルックアップやリバインドには十分です。

   キーシーケンスが複数イベントから構成されるとき、キールックアップはイ
ベントを順に処理します。最初のイベントのバインディングが見つかったとき、
それはキーマップでなければなりません。そのキーマップ内で2つ目のイベント
を見つけ出し、そのキーシーケンス内のすべてのイベントが消費されるまで、こ
のプロセスを続けます(故に、最後のイベントにたいして見つかったイベントは
キーマップかどうかわからない)。したがって、キールックアッププロセスは、
キーマップ内で単一イベントを見つけ出す、よりシンプルなプロセスで定義され
ます。これが行なわれる方法は、キーマップ内でそのイベントに関連するオブジ
ェクトの型に依存します。

   キーマップ内のイベント型ルックアップによる値発見を説明するために、“キ
ーマップエントリー(keymap entry)”という用語を導入しましょう。(これにはメ
ニューアイテムにたいするキーマップ内のアイテム文字列や、他の余計な要素は
含まれません。なぜなら、‘lookup-key’や他のキーマップルックアップ関数が、
リターン値にそれらを含まないからです。) 任意のLispオブジェクトがキーマッ
プエントリーとしてキーマップに格納されるかもしれませんが、すべてがキール
ックアップに意味をもつわけではありません。以下のテーブルは、キーマップエ
ントリーで重要な型です:

‘nil’
     ‘nil’は、それまでにルックアップに使用されたイベントが、未定義キーを
     形成することを意味する。最終的にキーマップがイベント型を調べるのに
     失敗して、デフォルトバインディングも存在しないときは、そのイベント
     型のバインディングが‘nil’であるのと同じである。

COMMAND
     それまでにルックアップに使用されたイベントがコンプリートキーを形成
     し、そのバインディングはCOMMANDである。*note What Is a Function::を
     参照のこと。

ARRAY
     array(文字列かベクター)は、キーボードマクロである。それまでにルック
     アップに使用されたイベントはコンプリートキーを形成し、そのバインデ
     ィングはarrayである。詳細は*note Keyboard Macros::を参照のこと。

KEYMAP
     それまでにルックアップに使用されたイベントはプレフィクスキーを形成
     する。そのキーシーケンスの次のイベントは、KEYMAP内でルックアップさ
     れる。

LIST
     listの意味は、そのリストが何を含んでいるかに依存する:

        • LISTのCARがシンボル‘keymap’の場合、そのリストはキーマップであ
          り、キーマップとして扱われる(上記参照)。

        • LISTのCARが‘lambda’の場合、そのリストはラムダ式である。これは
          関数とみなされ、そのように扱われる(上記参照)。キーバインディン
          グとして正しく実行されるために、この関数はコマンドでなければな
          らず、‘interactive’指定をもたなければならない。*note Defining
          Commands::を参照のこと。

        • LISTのCARがキーマップでCDRがイベント型の場合、これは“インダイ
          レクトエントリー(indirect entry: 間接エントリー)”である:

               (OTHERMAP . OTHERTYPE)

          キールックアップはインダイレクトエントリーに遭遇したときは、か
          わりにOTHERMAP内でOTHERTYPEのバインディングをルックアップして
          、それを使用する。

          この機能により、あるキーを他のキーにたいするalistとして定義す
          ることが可能になる。たとえば、CARが‘esc-map’と呼ばれるキーマッ
          プで、CDRが32(<SPC>のコード)の場合は、“それが何であろうと
          ‘Meta-<SPC>’のグローバルバインディングを使用する”ことを意味す
          る。

SYMBOL
     SYMBOLの関数定義がSYMBOLのかわりに使用される。もし関数定義もシンボ
     ルの場合は、任意の回数このプロセスが繰り返される。これは最終的にキ
     ーマップであるようなオブジェクト、コマンド、またはキーボードマクロ
     に行き着くはずである。それがキーマップかコマンドの場合はリストも許
     されるが、シンボルを通じて見つけ出された場合、インダイレクトエント
     リーは理解されない。

     キーマップおよびキーボードマクロ(文字列かベクター)は有効な関数では
     ないので、関数定義にキーマップ、文字列、ベクターをもつシンボルは、
     関数としては無効であることに注意されたい。しかし、キーバインディン
     グとしては有効である。その定義がキーボードマクロの場合、そのシンボ
     ルは‘command-execute’(*note Interactive Call::を参照)の引数としても
     有効である。

     シンボル‘undefined’は特記するに値する。これはそのキーを未定義として
     扱うことを意味する。厳密に言うと、そのキーは定義されているが、その
     バインディングがコマンド‘undefined’なのである。しかし、このコマンド
     は未定義キーにたいして自動的に行われるのと同じことを行う。これは
     (‘ding’を呼び出して)bellを鳴らすが、エラーはシグナルしない。

     ‘undefined’は、グローバルキーバインディングをオーバーライドして、そ
     のキーをローカルに“未定義”にするために使用される。‘nil’にローカルに
     バインドしても、グローバルバインディングをオーバーライドしないであ
     ろうから、これを行うのに失敗するだろう。

ANYTHING ELSE
     オブジェクトの他の型が見つかった場合、それまでにルックアップで使用
     されたイベントはコンプリートキーを形成し、そのオブジェクトがバイン
     ディングになるが、そのバインディングはコマンドとして実行不可能であ
     る。

   要約すると、キーマップエントリーはキーマップ、コマンド、キーボードマ
クロ、あるいはそれらに導出されるシンボル、インダイレクトエントリー、ある
いは‘nil’のいずれかです。


File: elisp,  Node: Functions for Key Lookup,  Next: Changing Key Bindings,  Prev: Key Lookup,  Up: Keymaps

21.11 Functions for Key Lookup
==============================

以下は、キールックアップに関連する関数および変数です。

 -- Function: lookup-key keymap key &optional accept-defaults
     この関数は、KEYMAP内のKEYの定義をリターンする。このチャプターで説明
     されている、キーをルックアップする他のすべての関数が‘lookup-key’を
     使用する。以下は例である:

          (lookup-key (current-global-map) "\C-x\C-f")
              ⇒ find-file
          (lookup-key (current-global-map) (kbd "C-x C-f"))
              ⇒ find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              ⇒ 2

     文字列、またはベクターのKEYが、KEYMAP内で指定されるプレフィクスキー
     として有効なキーシーケンスでない場合、それは最後に余計なイベントを
     もつ、単一のキーシーケンスに適合しない、“長過ぎる”キーのはずである
     。その場合のリターン値は数となり、この数はコンプリートキーを構成す
     るKEYの前にあるイベントの数である。

     ACCEPT-DEFAULTSが非‘nil’の場合、‘lookup-key’はKEY内の特定のイベント
     にたいするバインディングと同様に、デフォルトバインディングも考慮す
     る。それ以外では、‘lookup-key’は特定のKEYのシーケンスにたいするバイ
     ンディングだけを報告し、明示的に指定したとき以外はデフォルトバイン
     ディングを無視する。(これを行うには、KEYの要素として‘t’を与える。
     *note Format of Keymaps::を参照のこと。)

     KEYがメタ文字(ファンクションキーではない)を含む場合その文字は暗黙に
     ‘meta-prefix-char’の値と対応する非メタ文字からなる、2文字シーケンス
     に置き換えられる。したがって、以下に1つ目の例は、2つ目の例に変換さ
     れて処理される。

          (lookup-key (current-global-map) "\M-f")
              ⇒ forward-word
          (lookup-key (current-global-map) "\ef")
              ⇒ forward-word

     ‘read-key-sequence’とは異なり、この関数は指定されたイベントの情報を
     破棄する変更(*note Key Sequence Input::を参照)を行わない。特に、こ
     の関数はアルファベット文字を小文字に変更せず、ドラッグイベントをク
     リックイベントに変更しない。

 -- Command: undefined
     キーを未定義にするために、キーマップ内で使用される。これは‘ding’を
     呼び出すが、エラーを起こさない。

 -- Function: local-key-binding key &optional accept-defaults
     この関数は、カレントのローカルキーマップ内の、KEYにたいするバインデ
     ィングをリターンする。カレントのローカルキーマップ内で未定義の場合
     は、‘nil’をリターンする。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じように、デフォルトバ
     インディングのチェックを制御する。

 -- Function: global-key-binding key &optional accept-defaults
     この関数は、カレントのグローバルキーマップ内で、コマンドKEYにたいす
     るバインディングをリターンする。カレントのグローバルキーマップ内で
     未定義の場合は、‘nil’をリターンする。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じように、デフォルトバ
     インディングのチェックを制御する。

 -- Function: minor-mode-key-binding key &optional accept-defaults
     この関数は、アクティブなマイナーモードのKEYのバインディングを、リス
     トでリターンする。より正確には、この関数は‘(MODENAME . BINDING)’の
     とうなペアーのalistをリターンする。ここでMODENAMEなそのマイナーモー
     ドを有効にする変数、BINDINGはそのモードでのKEYのバインディングであ
     る。KEYがマイナーモードバインディングをみたない場合、値は‘nil’であ
     る。

     最初に見つかったバインディングがプレフィクス定義(キーマップ、または
     キーマップとして定義されたシンボル)でない場合は、他のマイナーモード
     由来のすべての後続するバインディングは、完全にshadowされるため省略
     される。同様に、このリストはプレフィクスバインディングに後続する非
     プレフィクスバインディングは省略される。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じように、デフォルトバ
     インディングのチェックを制御する。

 -- User Option: meta-prefix-char
     この変数はメタ/プレフィクス文字コードである。これはメタ文字をキーマ
     ップ内でルックアップできるように、2文字シーケンスに変換する。有用な
     結果を得るために、値はプレフィクスイベント(*note Prefix Keys::を参
     照)であること。デフォルト値は27で、これは<ESC>にたいするASCIIコード
     である。

     ‘meta-prefix-char’の値が27であるような限り、キールックアップは通常
     ‘backward-word’コマンドとして定義される‘M-b’を、‘<ESC> b’に変換する
     。しかし、‘meta-prefix-char’を24(‘C-x’のコード)にセットした場合、
     Emacsは‘M-b’を‘C-x b’に変換するだろうが、これの標準のバインディング
     は‘switch-to-buffer’コマンドである。以下に何が起こるかを示す(実際に
     これを行ってはならない!):

          meta-prefix-char                    ; デフォルト値
               ⇒ 27
          (key-binding "\M-b")
               ⇒ backward-word
          ?\C-x                               ; 文字.の
               ⇒ 24                          ; プリント表現
          (setq meta-prefix-char 24)
               ⇒ 24
          (key-binding "\M-b")
               ⇒ switch-to-buffer            ; 今や‘M-b’をタイプすると
                                              ;   ‘C-x b’をタイプしたようになる

          (setq meta-prefix-char 27)          ; 混乱を避ける!
               ⇒ 27                          ; デフォルト値をリストア!

     この単一イベントから２イベントへの変換は文字にたいしてのみ発生し、
     他の種類の入力イベントには発生しない。したがって、ファンクションキ
     ー‘M-<F1>’は‘<ESC> <F1>’に変換されない。


File: elisp,  Node: Changing Key Bindings,  Next: Remapping Commands,  Prev: Functions for Key Lookup,  Up: Keymaps

21.12 Changing Key Bindings
===========================

キーのリバインド(rebind: 再バインド、再束縛)は、キーマップ内でそのキーの
バインディングエントリーを変更することにより行います。グローバルキーマッ
プ内のバインディングを変更した場合、その変更は(たとえローカルバインディ
ングによりグローバルバインディングをshadowしているバッファーでは直接影響
しないとしても)すべてのバッファーに影響します。カレントバッファーのロー
カルマップを変更した場合は、通常は同じメジャーモードを使用するすべてのバ
ッファーに影響します。関数‘global-set-key’および‘local-set-key’は、これ
らの操作のための使いやすいインターフェイスです(*note Key Binding
Commands::を参照)。より汎用的な関数‘define-key’を使用することもできます
。その場合は、変更するマップを明示的に指定しなければなりません。

   Lispプログラムでリバインドするキーシーケンスを選択するときは、さまざ
まなキーの使用についてのEmacsの慣習にしたがうようお願いします(*note Key
Binding Conventions::を参照)。

   リバインドするキーシーケンスの記述では、コントロール文字とメタ文字に
たいして、特別なエスケープシーケンスを使用すると良いでしょう(*note
String Type::を参照)。構文‘\C-’は後続する文字がコントロール文字でること
を意味し、‘\M-’は後続する文字がメタ文字であることを意味します。したがっ
て、文字列‘"\M-x"’は1つの‘M-x’、‘"\C-f"’は1つの‘C-f’、‘"\M-\C-x"’および
‘"\C-\M-x"’は1つの‘C-M-x’として読み取られます。ベクター内でも、このエス
ケープシーケンス、および文字列では使用できない他のエスケープシーケンスを
使用できます。1例は‘[?\C-\H-x home]’です。*note Character Type::を参照し
てください。

   キー定義、およびルックアップ関数は、ベクターであるようなキーシーケン
ス内のイベント型にたいして、別の構文を受け入れます。修飾名に基本イベント
(文字かファンクションキー名)を付加したものを含むリストを使用できます。た
とえば、‘(control ?a)’は‘?\C-a’、‘(hyper control left)’は‘C-H-left’と等
価です。このようなリストの利点の1つは、コンパイル済みファイル内に修飾ビ
ットの正確な数値コードが出現しないことです。

   以下の関数は、KEYMAPがキーマップでない場合、およびKEYがキーシーケンス
を表す文字列やベクターでない場合はエラーをシグナルします。リストであるよ
うなイベントにたいする略記として、イベント型(シンボル)を使用できます。
‘kbd’関数(*note Key Sequences::を参照)は、キーシーケンスを指定するための
便利な方法です。

 -- Function: define-key keymap key binding
     この関数は、KEYMAP内でKEYにたいするバインディングをセットする(KEYが
     長さ2以上のイベントの場合、その変更は実際はKEYMAPから辿られる他のキ
     ーマップで行なわれる)。引数BINDINGには任意のLispオブジェクトを指定
     できるが、意味があるのは特定のオブジェクトだけである(意味のある型の
     リストは、*note Key Lookup::を参照のこと)。‘define-key’のリターン値
     はBINDINGである。

     KEYが‘[t]’の場合、これはKEYMAP内でデフォルトバインディングをセット
     する。イベントが自身のバインディングをもたないとき、そのキーマップ
     内にデフォルトバインディングが存在するなら、Emacsコマンドループはそ
     れを使用する。

     KEYのすべてのプレフィクスは、プレフィクスキー(キーマップにバインド
     される)、または未定義でなけらばならず、それ以外はエラーがシグナルさ
     れる。KEYのいくつかのプレフィクスが未定義の場合は、‘define-key’はそ
     れをプレフィクスキーとして定義するので、残りのKEYは指定されたように
     定義できる。

     前にKEYMAP内でKEYにたいするバインディングが存在しなかった場合は、新
     たなバインディングがKEYMAPの先頭に追加される。キーマップ内のバイン
     ディングの順序はキーボード入力にたいし影響を与えないが、メニューキ
     ーマップにたいしては問題となる(*note Menu Keymaps::を参照)。

   以下は、sparseキーマップを作成して、その中にバインディングをいくつか
作成する例である:

     (setq map (make-sparse-keymap))
         ⇒ (keymap)
     (define-key map "\C-f" 'forward-char)
         ⇒ forward-char
     map
         ⇒ (keymap (6 . forward-char))

     ;; ‘C-x’にたいしsparseサブマップを作成し、
     ;; その中で‘f’をバインドする
     (define-key map (kbd "C-x f") 'forward-word)
         ⇒ forward-word
     map
     ⇒ (keymap
         (24 keymap                ; C-x
             (102 . forward-word)) ;      f
         (6 . forward-char))       ; C-f

     ;; ‘C-p’を‘ctl-x-map’にバインド
     (define-key map (kbd "C-p") ctl-x-map)
     ;; ctl-x-map
     ⇒ [nil ... find-file ... backward-kill-sentence]

     ;; ‘ctl-x-map’内で‘C-f’を‘foo’にバインド
     (define-key map (kbd "C-p C-f") 'foo)
     ⇒ 'foo
     map
     ⇒ (keymap     ; ‘ctl-x-map’内の‘foo’に注目
         (16 keymap [nil ... foo ... backward-kill-sentence])
         (24 keymap
             (102 . forward-word))
         (6 . forward-char))

‘C-p C-f’にたいする新たなバインディングの格納は、実際には‘ctl-x-map’内の
エントリーを変更することにより機能し、これはデフォルトグローバルマップ内
の‘C-p C-f’と‘C-x C-f’の両方のバインディングを変更する効果をもつことに注
意されたい。

   関数‘substitute-key-definition’は、キーマップから特定のバインディング
をもつキーをスキャンして、それらを異なるバインディングにリバインドする。
より明快で、多くの場合は同じ結果を生成できる他の機能として、あるコマンド
から別のコマンドへのリマップがあります(*note Remapping Commands::を参照
)。

 -- Function: substitute-key-definition olddef newdef keymap &optional
          oldmap
     この関数は、KEYMAP内でOLDDEFにバインドされるすべてのキーについて、
     OLDDEFをNEWDEFに置き換える。別の言い方をすると、OLDDEFが出現する箇
     所すべてをNEWDEFに置き換える。この関数は‘nil’をリターンする。

     たとえば、以下をEmacsの標準バインディングで行うと、‘C-x C-f’を再定
     義する:

          (substitute-key-definition
           'find-file 'find-file-read-only (current-global-map))

     OLDMAPが非‘nil’の場合は、どのキーをリバインドするかをOLDMAP内のバイ
     ンディングが決定するよう、‘substitute-key-definition’の動作を変更す
     る。リバインディングは依然としてOLDMAPではなく、KEYMAPで発生する。
     したがって、他のマップ内のバインディングの制御下で、マップを変更す
     ることができる。たとえば、

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     これは、標準的な削除コマンドにグローバルにバインドされたキーにたい
     して、‘my-map’内の特別な削除コマンドを設定する。

     以下は、キーマップの置き換え(substitution)の前後を示す例である:

          (setq map '(keymap
                      (?1 . olddef-1)
                      (?2 . olddef-2)
                      (?3 . olddef-1)))
          ⇒ (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          ⇒ nil
          map
          ⇒ (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 -- Function: suppress-keymap keymap &optional nodigits
     この関数は、‘self-insert-command’をコマンド‘undefined’にリマップ
     (*note Remapping Commands::を参照)することにより、fullキーマップの
     コンテンツを変更する。これは、すべてのプリント文字を未定義にする効
     果をもすので、通常のテキスト挿入は不可能になる。‘suppress-keymap’は
     ‘nil’をリターンする。

     NODIGITSが‘nil’の場合、‘suppress-keymap’は数字が‘digit-argument’、
     ‘-’が‘negative-argument’を実行するように定義する。それ以外は、残り
     のプリント文字と同じように、それらの文字も未定義にする。

     ‘suppress-keymap’関数は、‘yank’や‘quoted-insert’のようなコマンドを
     抑制(suppress)しないので、バッファーの変更は可能である。バッファー
     の変更を防ぐには、バッファーを読み取り専用(read-only)にする(*note
     Read Only Buffers::を参照)。

     この関数はKEYMAPを変更するので、通常は新たに作成したキーマップにた
     いして使用するだろう。するだろう。他の目的のために使用されている既
     存のキーマップに操作を行うと、恐らくトラブルの原因となる。たとえば
     、‘global-map’の抑制は、Emacsの使用をほとんど不可能に

     この関数は、テキストの挿入が望ましくないメジャーモードの、ローカル
     キーマップ初期科に使用され得る。しかし、そのようなモードは通常は
     ‘special-mode’(*note Basic Major Modes::を参照)から継承される。この
     場合、そのモードのキーマップは既に抑制済みの‘special-mode-map’から
     自動的に受け継がれる。以下に‘special-mode-map’が定義される方法を示
     す:

          (defvar special-mode-map
            (let ((map (make-sparse-keymap)))
              (suppress-keymap map)
              (define-key map "q" 'quit-window)
              ...
              map))

