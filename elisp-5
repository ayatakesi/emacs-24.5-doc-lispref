This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Reading File Names,  Next: Completion Variables,  Prev: High-Level Completion,  Up: Completion

19.6.5 Reading File Names
-------------------------

高レベル補完関数‘read-file-name’、
‘read-directory-name’、‘read-shell-command’はそれぞれ、
ファイル名、ディレクトリー名、シェルコマンドを読み取るよ
うデザインされています。これらはデフォルトディレクトリー
の自動挿入を含む特別な機能を提供します。

 -- Function: read-file-name prompt &optional directory
          default require-match initial predicate
     この関数はプロンプトPROMPTとともに補完つきでファイ
     ル名を読み取る。

     例外として以下のすべてが真ならば、この関数はミニバ
     ッファーのかわりにグラフィカルなファイルダイアログ
     を使用してファイル名を読み取る:

       1. マウスコマンドを通じて呼び出された。

       2. グラフィカルなディスプレイ上の選択されたフレー
          ムがこの種のダイアログをサポートする。

       3. 変数‘use-dialog-box’が非‘nil’の場合。*note
          Dialog Boxes: (emacs)Dialog Boxes.を参照のこと
          。

       4. DIRECTORY引数(以下参照)がリモートファイルを指
          定しない。*note Remote Files: (emacs)Remote
          Files.を参照のこと。

     グラフィカルなファイルダイアログを使用したときの正
     確な振る舞いは、プラットホームに依存する。ここでは
     単にミニバッファーを使用したときの振る舞いを記す。

     ‘read-file-name’はリターンするファイル名を自動的に
     展開しない。絶対ファイル名が必要ならば、自分で
     ‘expand-file-name’を呼び出さなければならない。

     オプション引数REQUIRE-MATCHは、‘completing-read’の
     ときと同じ。*note Minibuffer Completion::を参照のこ
     と。

     引数DIRECTORYは、相対ファイル名の補完に使用するディ
     レクトリーを指定する。値は絶対ディレクトリー名。変
     数‘insert-default-directory’が非‘nil’の場合は、初期
     入力としてミニバッファーにDIRECTORYも挿入される。デ
     フォルトはカレントバッファーの‘default-directory’の
     値。

     INITIALを指定した場合、それはミニバッファーに挿入す
     る初期ファイル名になる(DIRECTORYが挿入された場合は
     その後に挿入される)。この場合、ポイントはINITIALの
     先頭に配される。INITIALのデフォルト値は‘nil’(ファイ
     ル名を挿入しない)。INITIALが何を行うか確認するには
     、ファイルをvisitしているバッファーで‘C-x C-v’を試
     すとよい。*注意: ほとんどの場合、*INITIALよりも
     DEFAULTの使用を推奨する。

     DEFAULTが非‘nil’の場合、ユーザーが最初に
     ‘read-file-name’が挿入したものと同じ、空以外のコン
     テンツを残してミニバッファーをexitすると、この関数
     はDEFAULTをリターンする。
     ‘insert-default-directory’が非‘nil’の場合はそれがデ
     フォルトとなるので、ミニバッファーの初期コンテンツ
     は常に空以外になる。REQUIRE-MATCHの値に関わらず、
     DEFAULTの有効性はチェックされない。とはいえ
     REQUIRE-MATCHが非‘nil’の場合、ミニバッファーの初期
     コンテンツは有効なファイル名(またはディレクトリー名
     )であるべきだろう。それが有効でない場合、ユーザーが
     それを編集せずにexitすると‘read-file-name’は補完を
     試み、DEFAULTはリターンされない。DEFAULTはヒストリ
     ーコマンドからも利用できる。

     DEFAULTが‘nil’の場合、‘read-file-name’はその場所に
     代用するデフォルトを探そうと試みる。この代用デフォ
     ルトは、明示的にDEFAULTにそれが指定されたかのように
     、DEFAULTとまったく同じ方法で扱われる。DEFAULTが
     ‘nil’でもINITIALが非‘nil’の場合、デフォルトは
     DIRECTORYとINITIALから得られる絶対ファイル名になる
     。DEFAULTとINITIALの両方が‘nil’で、そのバッファーが
     ファイルをvisitしているバッファーの場合、
     ‘read-file-name’はそのファイルの絶対ファイル名をデ
     フォルトとして使用する。バッファーがファイルを
     visitしていなければ、デフォルトは存在しない。この場
     合、ユーザーが編集せずに<RET>をタイプすると、
     ‘read-file-name’は前にミニバッファーに挿入されたコ
     ンテンツを単にリターンする。

     空のミニバッファー内でユーザーが<RET>をタイプした場
     合、この関数はREQUIRE-MATCHの値に関わらず、空の文字
     列をリターンする。たとえばユーザーが‘M-x
     set-visited-file-name’を使用して、カレントバッファ
     ーをファイルをvisitしていないことにするのに、この方
     法を使用している。

     PREDICATEが非‘nil’の場合、それは補完候補として許容
     できるファイル名を決定する、1引数の関数である。
     PREDICATEが関数名にたいして非‘nil’をリターンすれば
     、それはファイル名として許容できる値である。

     以下は‘read-file-name’を使用した例である:

          (read-file-name "The file is ")

          ;; 前の式を評価した後に、
          ;;   ミニバッファーに以下が表示される。:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/★
          ---------- Buffer: Minibuffer ----------

     ‘manual <TAB>’をタイプすると以下がリターンされる:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi★
          ---------- Buffer: Minibuffer ----------

     ここでユーザーが<RET>をタイプすると、
     ‘read-file-name’は文字列
     ‘"/gp/gnu/elisp/manual.texi"’をファイル名としてリタ
     ーンする。

 -- Variable: read-file-name-function
     非‘nil’の場合は、‘read-file-name’と同じ引数を受け取
     る関数である。‘read-file-name’が呼び出されたとき、
     ‘read-file-name’は通常の処理を行なうかわりに、与え
     られた引数でこの関数を呼び出す。

 -- User Option: read-file-name-completion-ignore-case
     この変数が非‘nil’の場合、‘read-file-name’は補完を行
     なう際に大文字小文字を無視する。

 -- Function: read-directory-name prompt &optional
          directory default require-match initial
     この関数は‘read-file-name’と似ているが、補完候補と
     してディレクトリーだけを許す。

     DEFAULTが‘nil’でINITIALが非‘nil’の場合、
     ‘read-directory-name’はDIRECTORY(DIRECTORYが‘nil’な
     らカレントバッファーのデフォルトディレクトリー)と
     INITIALを組み合わせて代替えのデフォルトを構築する。
     DEFAULTとINITIALの両方が‘nil’の場合、この関数は
     DIRECTORY、DIRECTORYも‘nil’の場合はカレントバッファ
     ーのデフォルトディレクトリーを代替えのデフォルトと
     して使用する。

 -- User Option: insert-default-directory
     この変数は‘read-file-name’により使用されるため、フ
     ァイル名を読み取るほとんどのコマンドにより、間接的
     に使用される。(これらのコマンドにはコマンドのインタ
     ラクティブフォームに‘f’や‘F’のコードレター(code
     letter))をふくむすべてのコマンドが含まれる。*note
     Code Characters for interactive: Interactive
     Codes.を参照のこと。)この変数の値は、(もしあれば)デ
     フォルトディレクトリー名をミニバッファー内に配して
     ‘read-file-name’を開始するかどうかを制御する。変数
     の値が‘nil’の場合、‘read-file-name’はミニバッファー
     に初期入力を何も配さない(ただしINITIAL引数で初期入
     力を指定しない場合)。この場合、依然としてデフォルト
     ディレクトリーが相対ファイル名の補完に使用されるが
     、表示はされない。

     この変数が‘nil’でミニバッファーの初期コンテンツが空
     の場合、ユーザーはデフォルト値にアクセスするために
     次のヒストリー要素を明示的にフェッチする必要がある
     だろう。この変数が非‘nil’ならミニバッファーの初期コ
     ンテンツは常に空以外となり、ミニバッファーで編集を
     おこなわず即座に<RET>をタイプすることにより、常にデ
     フォルト値を要求できる(上記参照)。

     たとえば:

          ;; デフォルトディレクトリーとともにミニバッファーが開始。
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/★
          ---------- Buffer: Minibuffer ----------

          ;; ミニバッファーはプロンプトだけで空。
          ;;   appears on its line.
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ★
          ---------- Buffer: Minibuffer ----------

 -- Function: read-shell-command prompt &optional
          initial history &rest args
     この関数は、プロンプトPROMPTと優れた補完を提供して
     、ミニバッファーからのシェルコマンドを読み取る。こ
     れはコマンド名にたいして適切な候補を使用してコマン
     ドの最初の単語を補完する。コマンドの残りの単語はフ
     ァイル名として補完する。

     この関数はミニバッファー入力にたいするキーマップと
     して‘minibuffer-local-shell-command-map’を使用する
     。HISTORY引数は使用するヒストリーリストを指定する。
     省略、または‘nil’の場合のデフォルトは
     ‘shell-command-history’(*note
     shell-command-history: Minibuffer History.を参照)。
     オプション引数INITIALはミニバッファーの初期コンテン
     ツを指定する(*note Initial Input::を参照)。もしあれ
     ば、残りのARGSは‘read-from-minibuffer’内のDEFAULTお
     よびINHERIT-INPUT-METHODとして使用される(*note Text
     from Minibuffer::を参照)。

 -- Variable: minibuffer-local-shell-command-map
     このキーマップは‘read-shell-command’により、コマン
     ドおよびシェルコマンドの一部となるファイル名の補完
     のために使用される。これは親キーマップとして
     ‘minibuffer-local-map’を使用し、<TAB>を
     ‘completion-at-point’にバインドする。


File: elisp,  Node: Completion Variables,  Next: Programmed Completion,  Prev: Reading File Names,  Up: Completion

19.6.6 Completion Variables
---------------------------

補完のデフォルト動作を変更するために使用される変数がいく
つかあります。

 -- User Option: completion-styles
     この変数の値は、補完を行うために使用される補完スタ
     イル(シンボル)である。“補完スタイル(completion
     style)”とは、補完を生成するためのルールセットのこと
     。このリストにあるシンボルはそれぞれ、
     ‘completion-styles-alist’内に対応するエントリーをも
     たなければならない。

 -- Variable: completion-styles-alist
     この変数には補完スタイルのリストが格納される。リス
     ト内の各要素は以下の形式をもつ

          (STYLE TRY-COMPLETION ALL-COMPLETIONS DOC)

     ここでSTYLEは補完スタイルの名前(シンボル)であり、そ
     のスタイルを参照するために変数‘completion-styles’内
     で使用されるかもしれない。TRY-COMPLETIONは補完を行
     なう関数で、ALL-COMPLETIONS補完をリストする関数、
     DOC補完スタイルを説明する文字列である。

     関数TRY-COMPLETIONおよびALL-COMPLETIONSはSTRING、
     COLLECTION、PREDICATE、POINTの4つの引数をとる。引数
     STRING、COLLECTION、PREDICATEの意味は
     ‘try-completion’(*note Basic Completion::を参照)の
     ときと同様。引数POINTはSTRING内のポイント位置。各関
     数は自身の処理を行った場合は非‘nil’を、行わなかった
     場合(たとえば補完スタイルに一致するようにSTRINGを行
     う方法がない場合)は‘nil’をリターンする。

     ユーザーが‘minibuffer-complete’(*note Completion
     Commands::を参照)のような補完コマンドを呼び出すと、
     Emacsは‘completion-styles’に最初にリストされたスタ
     イルを探して、そのスタイルのTRY-COMPLETION関数を呼
     び出す。この関数が‘nil’をリターンした場合、Emacsは
     次にリストされた補完スタイルに移動してそのスタイル
     のTRY-COMPLETION関数を呼び出すといったように、
     TRY-COMPLETION関数の1つが補完の処理に成功して非
     ‘nil’値をリターンするまで順次これを行なう。同様の手
     順はALL-COMPLETIONS関数を通じて、補完のリストにも行
     われる。

     利用できる補完スタイルについては*note
     (emacs)Completion Styles::を参照のこと。

 -- User Option: completion-category-overrides
     この変数は特別な補完スタイルと、特定の種類のテキス
     ト補完時に使用するその他の補完動作を指定する。この
     変数の値は‘(CATEGORY . ALIST)’という形式の要素をも
     つalistである。CATEGORYは何が補完されるかを記述する
     シンボルで、現在のところカテゴリーに‘buffer’、
     ‘file’、‘unicode-name’が定義されているが、これに特
     化した補完関数(*note Programmed Completion::を参照
     )を通じて他のカテゴリーを定義できる。ALISTは、その
     カテゴリーにたいして補完がどのように振る舞うべきか
     を記述する連想リスト。以下のalistのキーがサポートさ
     れる:

     ‘styles’
          値は補完スタイル(シンボル)のリスト。

     ‘cycle’
          値はそのカテゴリーにたいする
          ‘completion-cycle-threshold’(*note
          (emacs)Completion Options::を参照)の値。

     将来、さらにalistエントリーが定義されるかもしれない
     。

 -- Variable: completion-extra-properties
     この変数はカレント補完コマンドの特別なプロパティの
     指定に使用される。この変数は補完に特化したコマンド
     によりletバインドされることを意図している。値はプロ
     パティ/値ペアーのリスト。以下のプロパティがサポート
     される:

     ‘:annotation-function’
          値は補完バッファー内に注釈(annotation)を加える
          関数。この関数は引数completionを1つ受け取り
          ‘nil’、または補完の隣に表示する文字列をリター
          ンしなければならない。

     ‘:exit-function’
          値は補完を行った後に実行する関数。この関数は
          2つの引数STRINGとSTATUSを受け取る。STRINGは補
          完されたフィールドのテキストで、STATUSは行われ
          た操作の種類を示す。操作の種類は、テキストの補
          完が完了したなら‘finished’、それ以上補完できな
          いが補完が完了していなければ‘sole’、有効な補完
          だがさらに補完できるときは‘exact’となる。


File: elisp,  Node: Programmed Completion,  Next: Completion in Buffers,  Prev: Completion Variables,  Up: Completion

19.6.7 Programmed Completion
----------------------------

意図した利用可能な補完のすべてを含むalistまたはobarrayを
前もって作成するのが不可能または不便なことがあります。こ
のような場合は、与えられた文字列にたいする補完を計算する
独自の関数を提供できます。これは“プログラム補完
(programmed completion)”と呼ばれます。Emacsは数あるケー
スの中でも特に、ファイル名の補完(*note File Name
Completion::を参照)でプログラム補完を使用しています。

   この機能を使用するためには、関数を‘completing-read’の
COLLECTION引数に渡します。関数‘completing-read’はその補
完関数が‘try-completion’、‘all-completions’などの基本的
な補完関数に渡されて、その関数がすべてを行えるよう取り計
らいます。

   補完関数は3つの引数を受け取ります:

   • 補完される文字列。

   • 利用可能なマッチをフィルターする述語関数。もしなけ
     れば‘nil’。関数は利用可能なマッチにたいしてこの述語
     (predicate)を呼び出し、述語が‘nil’をリターンした場
     合はそのマッチを無視する。

   • 実行する補完操作のタイプを指定するフラグ。以下の4つ
     の値のうち1つを指定する:

     ‘nil’
          ‘try-completion’を指定する。関数は指定された文
          字が一意かつ完全一致の場合は、‘t’をリターンす
          る。マッチが複数の場合、すべてのマッチに共通す
          る部分文字列をリターンする(文字列が補完候補の
          1つに完全一致するが、より長い他の候補にもマッ
          チする場合、リターン値はその文字列)。マッチが
          なければ‘nil’をリターンする。

     ‘t’
          ‘all-completions’を指定する。関数は指定された
          文字列の利用可能なすべての補完のリストをリター
          ンする。

     ‘lambda’
          ‘test-completion’を指定する。関数は指定された
          文字列がいくつかの補完候補に完全一致する場合は
          ‘t’、それ以外は‘nil’をリターンする。

     ‘(boundaries . SUFFIX)’
          ‘completion-boundaries’を指定する。関数は
          ‘(boundaries START . END)’をリターンする。ここ
          でSTARTは指定された文字列内の境界の開始位置、
          ENDはSUFFIX内の境界の終了位置。

     ‘metadata’
          カレント補完の状態に関する情報の要求を指定する
          。リターン値は‘(metadata . ALIST)’の形式をもち
          、ALISTは以下で説明する要素をもつ連想配列。

     フラグに他の値が指定された場合、補完関数は‘nil’をリ
     ターンする。

   以下は‘metadata’フラグ引数への応答として補完関数がリ
ターンするかもしれない、metadataエントリーのリストです:

‘category’
     値は補完関数が補完を試みているテキストの種類を説明
     するシンボル。シンボルが
     ‘completion-category-overrides’内のキーの1つにマッ
     チする場合、通常の補完動作はオーバーライドされる。
     *note Completion Variables::を参照のこと。

‘annotation-function’
     値は補完に“注釈(annotation)”を付ける関数。この関数
     は1つの引数STRINGをとり、これは利用可能な補完である
     。リターン値は文字列で、‘*Completions*’バッファー内
     の補完STRINGの後に表示される。

‘display-sort-function’
     値は補完をソートする関数。関数は1つの引数をとる。こ
     れは補完文字列のリストで、ソートされた補完文字列リ
     ストがリターンされる。その入力のリストは破壊的に変
     更することが許される。

‘cycle-sort-function’
     値は‘completion-cycle-threshold’が非‘nil’で、ユーザ
     ーが補完候補を巡回するときに補完をソートする関数。
     引数のリストとリターン値は‘display-sort-function’と
     同様。

 -- Function: completion-table-dynamic function
     この関数はプログラム補完関数として動作する関数を記
     述する便利な方法である。引数FUNCTIONは1つの引数(文
     字列)をとる関数であり、その文字列の利用可能な補完の
     alistをリターンする。‘completion-table-dynamic’は、
     FUNCTIONとプログラム補完関数のインターフェイス変換
     器と考えることができる。

 -- Function: completion-table-with-cache function
          &optional ignore-case
     これは前回の引数/結果ペアーを保存する
     ‘completion-table-dynamic’にたいするラッパーである
     。これは同じ引数にたいする複数回の検査に必要なのは
     、1回のFUNCTION呼び出しだけであることを意味する。こ
     れは外部プロセス呼び出しなど、処理が低速のとき有用
     かもしれない。


File: elisp,  Node: Completion in Buffers,  Prev: Programmed Completion,  Up: Completion

19.6.8 Completion in Ordinary Buffers
-------------------------------------

補完は通常はミニバッファー内で行われますが、補完機能は通
常のEmacsバッファー内のテキストにも使用できます。多くの
メジャーモードで、コマンド‘C-M-i’または‘M-<TAB>’によりバ
ッファー内補完が行われ、それらは‘completion-at-point’に
バインドされています。*note (emacs)Symbol Completion::を
参照してください。このコマンドはアブノーマルフック変数
‘completion-at-point-functions’を使用します:

 -- Variable: completion-at-point-functions
     このアブノーマルフックの値は関数のリストである。こ
     れらの関数はポイント位置のテキストの補完にたいする
     補完テーブルの計算に使用される。これはメジャーモー
     ドにより、モード特有な補完テーブル(*note Major Mode
     Conventions::を参照)の提供に使用できる。

     コマンド‘completion-at-point’が実行されると、引数な
     しでリスト内の関数が1つずつ呼び出される。それぞれの
     関数は、ポイント位置のテキストにたいして補完テーブ
     ルを生成できない場合は‘nil’をリターンする。生成でき
     た場合は、以下の形式のリストをリターンする

          (START END COLLECTION . PROPS)

     ここでSTARTとENDは補完する(ポイントを取り囲む)テキ
     ストの区切りである。COLLECTIONはそのテキストを補完
     する補完テーブルであり、‘try-completion’(*note
     Basic Completion::を参照)の2つ目の引数として渡すの
     に適した形式である。補完候補は
     ‘completion-styles’(*note Completion Variables::を
     参照)で定義された補完スタイルを通じ、この補完テーブ
     ルを通常の方法で使用して生成されるだろう。PROPSは追
     加の情報のためのプロパティリストである。
     ‘completion-extra-properties’内のすべてのプロパティ
     (*note Completion Variables::を参照)と、以下の追加
     のプロパティが認識される:

     ‘:predicate’
          値は補完候補が満足する必要がある述語。

     ‘:exclusive’
          値が‘no’の場合は、もし補完テーブルがポイント位
          置のテキストのマッチに失敗したなら、補完の失敗
          を報告するかわりに‘completion-at-point’は
          ‘completion-at-point-functions’内の次の関数へ
          移動する。

     ‘completion-at-point-functions’内の関数も関数をリタ
     ーンするかもしれない。その場合は引数なしでリターン
     された関数が呼び出され、その関数が補完処理の全責任
     を負う。この方法は推奨されない。これは
     ‘completion-at-point’を使用する古いコードの救済を意
     図したもののだからである。

     非‘nil’値を最初にリターンした
     ‘completion-at-point-functions’内の関数が、
     ‘completion-at-point’により使用される。残りの関数は
     呼び出されない。これの例外は上述の‘:exclusive’指定
     があるときである。

   以下の関数は、Emacsバッファー内の任意に拡張されたテキ
ストにたいして便利な補完方法を提供します:

 -- Function: completion-in-region start end collection
          &optional predicate
     この関数はCOLLECTIONを使用して、カレントバッファー
     内の位置STARTとENDの間のテキストを補完する。引数
     COLLECTIONは‘try-completion’(*note Basic
     Completion::を参照)のときと同じ意味をもつ。

     この関数は補完テキストを直接カレントバッファーに挿
     入する。‘completing-read’(*note Minibuffer
     Completion::を参照)とは異なり、ミニバッファーをアク
     ティブにしない。

     この関数が機能するためには、ポイントがSTARTとENDの
     間になければならない。


File: elisp,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

19.7 Yes-or-No Queries
======================

このセクションでは、ユーザーにyes-or-noの確認を求める関
数を説明します。関数‘y-or-n-p’は1文字での応答に使用でき
ます。この関数は不注意による誤った答えが深刻な結果を招か
ない場合に有用です。‘yes-or-no-p’は3文字から4文字の答え
を要求するので、より重大な問に適しています。

   3つの関数はどれも、マウスを使用して呼び出されたコマン
ド、より正確には‘last-nonmenu-event’(*note Command Loop
Info::を参照)が‘nil’かリストの場合は、問いに答えるために
ダイアログボックスまたはポップアップメニューを使用します
。それ以外の場合はキーボード入力を使用します。呼び出しの
周囲で‘last-nonmenu-event’に適切な値をバインドすることに
より、マウスまたはキーボードの使用を強制できます。

   厳密に言うと、‘yes-or-no-p’はミニバッファーを使用し、
‘y-or-n-p’は使用しませんが、これらのコマンドは一緒に説明
したほうがよいでしょう。

 -- Function: y-or-n-p prompt
     この関数はユーザーに答えを尋ねて、ミニバッファーに
     入力を求める。ユーザーが‘y’をタイプしたら‘t’、‘n’を
     タイプしたら‘nil’をリターンする。この関数はyesの意
     味で<SPC>、noの意味で<DEL>も受け入れる。“quit”の意
     味として‘C-g’と同様に‘C-]’も受け入れる。これは問い
     がミニバッファーのような外見をもち、ミニバッファー
     を抜けるためにユーザーが‘C-]’の使用を試みるかもしれ
     ないという理由による。応答は1文字であり、問いを終了
     させるための<RET>は必要ない。大文字と小文字は等価で
     ある。

     “答えを尋ねる”とはエコーエリアにPROMPTと、その後に
     文字列‘(y or n) ’をプリントすることを意味する。期待
     される答え(‘y’、‘n’、‘<SPC>’、‘<DEL>’、もしくは質問
     を終了するその他のキー)以外が入力された場合、この関
     数は‘Please answer y or n.’と応答し、繰り返し答えの
     入力を要求する。

     この関数は答えの編集を許さないため、実際にミニバッ
     ファーは使用しない。実際に使用するのはミニバッファ
     ーと同じスクリーンスペースを使用するエコーエリア
     (*note The Echo Area::を参照)である。問いが答えられ
     るまで、カーソルはエコーエリアに移動する。

     答えとその意味は、たとえ‘y’と‘n’であっても固定され
     たものではなく、キーマップ‘query-replace-map’により
     指定される(*note Search and Replace::を参照)。特に
     ユーザーが‘recenter’、‘scroll-up’、‘scroll-down’、
     ‘scroll-other-window’、
     ‘scroll-other-window-down’(それぞれ
     ‘query-replace-map’内で‘C-l’、‘C-v’、‘M-v’、
     ‘C-M-v’、‘C-M-S-v’にバインドされている)のような特殊
     な応答をエンターした場合、この関数はは指定されたウ
     ィンドウの再センタリングやスクロール操作を処理して
     から再度答えを求める。

     例ではエコーエリアのメッセージを連続する行で示して
     いるが、スクリーン上に実際に表示されるのは1回に1行
     だけである。

 -- Function: y-or-n-p-with-timeout prompt seconds
          default
     ‘y-or-n-p’と同様だが、ユーザーがSECONDS秒以内に答え
     ないと、この関数は待つのをやめてDEFAULTをリターンす
     る。これはタイマーをセットアップすることにより機能
     する。引数SECONDSは数字である。

 -- Function: yes-or-no-p prompt
     この関数は質問して、ミニバッファーに答えの入力を求
     める。これはユーザーが‘yes’をエンターすると‘t’を、
     ‘no’をエンターすると‘nil’をリターンする。ユーザーは
     応答を終えるために<RET>をタイプしなければならない。
     大文字と小文字は等価である。

     ‘yes-or-no-p’はエコーエリアにPROMPTとその後に
     ‘(yes or no) ’を表示することにより開始される。ユー
     ザーは期待される応答の1つをタイプしなければならない
     。それ以外の答えだと、この関数は‘Please answer yes
     or no.’と応答して約2秒待った後に要求を繰り返す。

     ‘yes-or-no-p’は‘y-or-n-p’より多くの作業をユーザーに
     要求し、より重大な決定に適している。

     以下は例である:

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; 前の式を評価した後、
          ;;   空のミニバッファーに
          ;;   以下のプロンプトが表示される:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     ユーザーが最初に‘y <RET>’とタイプした場合、これは無
     効である。なぜならこの関数は‘yes’という単語全体を要
     求しているので、以下のプロンプトを説明のために一時
     停止して表示する。

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------


File: elisp,  Node: Multiple Queries,  Next: Reading a Password,  Prev: Yes-or-No Queries,  Up: Minibuffers

19.8 Asking Multiple Y-or-N Questions
=====================================

同じような連続する質問と答えがある場合、たとえば各バッフ
ァーにたいして順に“Do you want to save this buffer”と確
認を求めるような場合は、個別に質問するより
‘map-y-or-n-p’を使用して質問のコレクションを尋ねるべきで
す。これはユーザーにたいして、質問全体にたいして1回で答
えられるような便利な機能を提供します。

 -- Function: map-y-or-n-p prompter actor list &optional
          help action-alist no-cursor-in-echo-area
     この関数はユーザーに一連の質問をし、それぞれの質問
     にたいしてエコーエリア内の1文字の答えを読み取る。

     値LISTは質問をするオブジェクトを指定する。これはリ
     スト、オブジェクト、または生成関数(generator
     function)のいずれかである。関数の場合は引数なしで、
     次に質問するオブジェクト、または質問の中止を意味す
     る‘nil’のいずれかをリターンする。

     引数PROMPTERは各質問について問い合わせ方法を指定す
     る。PROMPTERが文字列の場合、質問テキストは以下のよ
     うになる:

          (format PROMPTER OBJECT)

     ここでOBJECTは、(LISTから得られる)質問する次のオブ
     ジェクトである。

     文字列でない場合、PROMPTERは1つの引数(質問する次の
     オブジェクト)をとる関数で、質問テキストをリターンす
     る。値が文字列の場合は、ユーザー問うための質問。関
     数は‘t’(ユーザーに尋ねずこのオブジェクトを処理する
     )、または‘nil’(ユーザーに尋ねずこのオブジェクトを無
     視する)をリターンすることもできる。

     引数ACTORは、ユーザーが与えた答えにたいし、どのよう
     に処理するかを指定する。これは引数が1つの関数で、ユ
     ーザーがyesと答えたオブジェクトを引数に呼び出される
     。引数は常にLISTから取得したオブジェクトである。

     引数HELPが与えられた場合は、以下の形式のリストであ
     る:

          (SINGULAR PLURAL ACTION)

     SINGULARはそのオブジェクトが概念的に何に作用するか
     を説明する単数形の名詞を含む文字列、PLURALはそれに
     対応する複数形の名詞、ACTIONはACTORが何を行うかを説
     明する他動詞である。

     HELPを指定しない場合のデフォルトは、‘("object"
     "objects" "act on")’。

     質問のたびに、ユーザーはそのオブジェクトを処理する
     には‘y’、‘Y’または<SPC>を、そのオブジェクトをスキッ
     プするには‘n’、‘N’、または<DEL>を、以降のすべてのオ
     ブジェクトを処理するには‘!’を、exit(以降のすべての
     オブジェクトをスキップ)するには<ESC>か‘q’を、カレン
     トオブジェクトを処理した後にexitするには‘.’(ピリオ
     ド)を、ヘルプを入手するには‘C-h’をエンターする。こ
     れらは‘query-replace’が受け入れるのと同じ答えである
     。キーマップ‘query-replace-map’は‘map-y-or-n-p’にた
     いするそれらの意味を定義し、‘query-replace’にたいし
     ても同様に定義する。*note Search and Replace::を参
     照のこと。

     ACTION-ALISTを使用して、利用できる追加の答えとそれ
     らが何を意味するかを指定できる。これは要素が‘(CHAR
     FUNCTION HELP)’という形式のalistで、それぞれの要素
     が追加の答えを1つ定義する。要素の内容はCHARが文字
     (答え)、FUNCTIONが引数が1つ(LISTから取得するオブジ
     ェクト)の関数、HELPが文字列である。

     ユーザーの応答がCHARの場合、‘map-y-or-n-p’は
     FUNCTIONを呼び出す。これが非‘nil’をリターンした場合
     には、そのオブジェクトが“処理された”と判断して、
     ‘map-y-or-n-p’はLIST内の次のオブジェクトに進む。
     ‘nil’をリターンした場合は、同じオブジェクトにたいし
     て質問を繰り返す。

     確認を求める間は通常、‘map-y-or-n-p’は
     ‘cursor-in-echo-area’をバインドする。しかし
     NO-CURSOR-IN-ECHO-AREAが非‘nil’の場合はバインドしな
     い。

     マウスを使用して呼び出されたコマンドから
     ‘map-y-or-n-p’が呼び出された場合(より正確には
     ‘last-nonmenu-event’は非‘nil’かリストの場合。*note
     Command Loop Info::を参照)は、確認を求めるためにダ
     イアログボックスかポップアップメニューが使用される
     。この場合、キーボード入力やエコーエリアは使用され
     ない。呼び出しの前後で‘last-nonmenu-event’を適切な
     値にバインドして、入力マウスあるいはキーボードの入
     力を強制できる。

     ‘map-y-or-n-p’のリターン値は、処理したオブジェクト
     の数である。


File: elisp,  Node: Reading a Password,  Next: Minibuffer Commands,  Prev: Multiple Queries,  Up: Minibuffers

19.9 Reading a Password
=======================

他のプログラムに渡すためのパスワードを読み取るために、関
数‘read-passwd’を使用できます。

 -- Function: read-passwd prompt &optional confirm
          default
     この関数はプロンプトPROMPTを表示してパスワードを読
     み取る。これはユーザーがタイプしたパスワードのかわ
     りに、パスワード内の各文字を‘.’にかえてエコーする
     (バッチモードでは入力は隠されないことに注意)。)

     オプション引数CONFIRMが非‘nil’の場合にはパスワード
     を2回読み取ることで、それらが同じものであることを強
     制する。同じでない場合は、2回の入力が同じになるまで
     、ユーザーはパスワードを繰り返しタイプする必要があ
     る。

     オプション引数DEFAULTは、ユーザーが空入力をエンター
     した場合のデフォルトパスワードである。DEFAULTが
     ‘nil’の場合、‘read-passwd’はnull文字列をリターンす
     る。


File: elisp,  Node: Minibuffer Commands,  Next: Minibuffer Windows,  Prev: Reading a Password,  Up: Minibuffers

19.10 Minibuffer Commands
=========================

このセクションではミニバッファー内で使用するコマンドを説
明します。

 -- Command: exit-minibuffer
     このコマンドはアクティブなミニバッファーをexitする
     。これは通常、ミニバッファー内のローカルキーマップ
     のキーにバインドされる。

 -- Command: self-insert-and-exit
     このコマンドはキーボードでタイプされた最後の文字を
     挿入した後にアクティブなミニバッファーをexitする。
     *note Command Loop Info::)を参照のこと。

 -- Command: previous-history-element n
     このコマンドは、N個前(古い)のヒストリー要素の値でミ
     ニバッファー内のコンテンツを置換する。

 -- Command: next-history-element n
     このコマンドは、N個先(新しい)のヒストリー要素の値で
     ミニバッファー内のコンテンツを置換する。

 -- Command: previous-matching-history-element pattern n
     このコマンドはPATTERN(正規表現)にマッチするN個前(古
     い)のヒストリー要素でミニバッファー内のコンテンツを
     置換する。

 -- Command: next-matching-history-element pattern n
     このコマンドはPATTERN(正規表現)にマッチするN個先(新
     しい)のヒストリー要素でミニバッファー内のコンテンツ
     を置換する。

 -- Command: previous-complete-history-element n
     このコマンドはミニバッファー内のポイントの前のカレ
     ントコンテンツを、N個前(古い)ヒストリー要素の値で置
     換する。

 -- Command: next-complete-history-element n
     このコマンドはミニバッファー内のポイントの前のカレ
     ントコンテンツを、N個先(新しい)ヒストリー要素の値で
     置換する。


File: elisp,  Node: Minibuffer Windows,  Next: Minibuffer Contents,  Prev: Minibuffer Commands,  Up: Minibuffers

19.11 Minibuffer Windows
========================

以下の関数はミニバッファーウィンドウをアクセスにして選択
して、それがアクティブかどうかテストします。

 -- Function: active-minibuffer-window
     この関数はカレントでアクティブなミニバッファーウィ
     ンドウ、アクティブなウィンドウがない場合は‘nil’をリ
     ターンする。

 -- Function: minibuffer-window &optional frame
     この関数はフレームFRAMEにたいして使用されるミニバッ
     ファーウィンドウをリターンする。FRAMEが‘nil’の場合
     はカレントフレームを意味する。フレームに使用される
     ミニバッファーウィンドウは、そのフレームの一部であ
     る必要はないことに注意。自身のミニバッファーをもた
     ないフレームは、必然的に他のフレームのミニバッファ
     ーウィンドウを使用する。

 -- Function: set-minibuffer-window window
     この関数はミニバッファーウィンドウとしてWINDOWを使
     用するよう指定する。 This function specifies as the
     minibuffer window to use. これは通常のミニバッファ
     ーコマンドを呼び出さずにミニバッファーにテキストを
     入力する場合、そのミニバッファーがどこに表示される
     かに影響を及ぼす。通常のミニバッファー入力関数はす
     べてカレントフレームに対応するミニバッファーを選択
     して開始されるので、影響はない。

 -- Function: window-minibuffer-p &optional window
     この関数はWINDOWがミニバッファーウィンドウなら
     ‘nil’をリターンする。WINDOWのデフォルトは選択された
     ウィンドウである。

   ‘(minibuffer-window)’の結果を比較して、与えられたウィ
ンドウがミニバッファーかどうか判断するのは正しくない。な
ぜなら複数のフレームがある場合、ミニバッファーウィンドウ
も複数あり得るからである。

 -- Function: minibuffer-window-active-p window
     この関数はWINDOWがカレントでアクティブなミニバッフ
     ァーウィンドウの場合は、非‘nil’をリターンする。


File: elisp,  Node: Minibuffer Contents,  Next: Recursive Mini,  Prev: Minibuffer Windows,  Up: Minibuffers

19.12 Minibuffer Contents
=========================

以下の関数はミニバッファーのプロンプトとコンテンツにアク
セスします。

 -- Function: minibuffer-prompt
     この関数はカレントでアクティブなミニバッファーのプ
     ロンプト文字列をリターンする。アクティブなミニバッ
     ファーがない場合は、‘nil’をリターンする。

 -- Function: minibuffer-prompt-end
     この関数は、ミニバッファーがカレントの場合はミニバ
     ッファープロンプトの終端のカレント位置をリターンす
     る。それ以外はバッファーの有効な最小位置をリターン
     する。

 -- Function: minibuffer-prompt-width
     この関数はミニバッファーがカレントの場合は、ミニバ
     ッファープロンプトのカレントの表示幅をリターンする
     。それ以外は0をリターンする。

 -- Function: minibuffer-contents
     この関数はミニバッファーがカレントの場合は、ミニバ
     ッファーの編集可能なコンテンツ(つまりプロンプト以外
     のすべて)を文字列でリターンする。それ以外は、カレン
     トバッファーのコンテンツ全体をリターンする。

 -- Function: minibuffer-contents-no-properties
     これは‘minibuffer-contents’と同様だが、テキストプロ
     パティをコピーせず文字だけをリターンする。*note
     Text Properties::を参照のこと。

 -- Function: delete-minibuffer-contents
     この関数はミニバッファーがカレントの場合は、ミニバ
     ッファーの編集可能なコンテンツ(つまりプロンプト以外
     のすべて)を削除する。それ以外は、カレントバッファー
     全体を削除する。


File: elisp,  Node: Recursive Mini,  Next: Minibuffer Misc,  Prev: Minibuffer Contents,  Up: Minibuffers

19.13 Recursive Minibuffers
===========================

以下の関数および変数は再帰ミニバッファーを処理します
(*note Recursive Editing::を参照):

 -- Function: minibuffer-depth
     この関数はアクティブなミニバッファーのカレント深さ
     を正の整数でリターンする。アクティブなミニバッファ
     ーが存在しない場合は0をリターンする。

 -- User Option: enable-recursive-minibuffers
     この変数が非‘nil’の場合は、ミニバッファーウィンドウ
     がアクティブでも、(‘find-file’のような)ミニバッファ
     ーを使用するコマンドを呼び出すことができる。このよ
     うな呼び出しは、新たなミニバッファーにたいして再帰
     編集レベル(recursive editing level)を生成する。内側
     レベルの編集の間、外側レベルのミニバッファーは非表
     示になる。

     この変数が‘nil’の場合、ミニバッファーウィンドウがア
     クティブなときは、たとえ他のウィンドウに切り替えて
     も、ミニバッファーコマンドの呼び出しはできない。

   コマンド名が非‘nil’のプロパティ
‘enable-recursive-minibuffers’をもつ場合は、たとえミニバ
ッファーから呼び出された場合でも、そのコマンドは引数の読
み取りにミニバッファーを使用できる。コマンドの
interactive宣言内で‘enable-recursive-minibuffers’を‘t’に
しても、これを行うことができる(*note Using
Interactive::を参照)。ミニバッファーコマンド
‘next-matching-history-element’(ミニバッファー内では通常
‘M-s’)は後者を行う。


File: elisp,  Node: Minibuffer Misc,  Prev: Recursive Mini,  Up: Minibuffers

19.14 Minibuffer Miscellany
===========================

 -- Function: minibufferp &optional buffer-or-name
     この関数はBUFFER-OR-NAMEがミニバッファーの場合は非
     ‘nil’をリターンする。BUFFER-OR-NAMEが省略された場合
     はカレントバッファーをテストする。

 -- Variable: minibuffer-setup-hook
     これはミニバッファーがエンターされたときは常に実行
     されるノーマルフックである。*note Hooks::を参照のこ
     と。

 -- Variable: minibuffer-exit-hook
     これはミニバッファーがexitされたときは常に実行され
     るノーマルフックである。

 -- Variable: minibuffer-help-form
     この変数のカレント値はミニバッファー内で
     ‘help-form’をローカルにリバインドするために使用され
     る(*note Help Functions::を参照)。

 -- Variable: minibuffer-scroll-window
     この変数の値が非‘nil’の場合、それはウィンドウオブジ
     ェクトである。ミニバッファー内で関数
     ‘scroll-other-window’が呼び出されたときは、このウィ
     ンドウをスクロールする。

 -- Function: minibuffer-selected-window
     この関数はミニバッファーがエンターされたときに選択
     されていたウィンドウをリターンする。選択されたウィ
     ンドウがミニバッファー以外のときは、‘nil’をリターン
     する。

 -- User Option: max-mini-window-height
     この変数はミニバッファーウィンドウのリサイズにたい
     する最大高さを指定する。浮動小数点数の場合は、フレ
     ーム高さにたいする割り合いを指定する。整数の場合は
     行数を指定する。

 -- Function: minibuffer-message string &rest args
     この関数は数秒、あるいは次の入力イベントが到着する
     まで、ミニバッファーテキストの最後に一時的に
     STRINGを表示する。変数
     ‘minibuffer-message-timeout’は入力がない場合に待機
     する秒数を指定する(デフォルトは2)。ARGSが非‘nil’の
     場合、実際のメッセージは‘format’にSTRINGとARGSを渡
     して作成される。*Note Formatting Strings::を参照の
     こと。

 -- Command: minibuffer-inactive-mode
     これはインタラクティブなミニバッファー内で使用され
     るメジャーモードである。キーマップ
     ‘minibuffer-inactive-mode-map’を使用する。ミニバッ
     ファーが別のフレームにある場合は有用かもしれない。
     *note Minibuffers and Frames::を参照のこと。


File: elisp,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

20 Command Loop
***************

Emacsを実行すると、ほぼ即座に“エディターコマンドループ
(editor command loop)”にエンターします。このループはキー
シーケンスを読み取り、それらの定義を実行して、結果を表示
します。このチャプターでは、これらが行われる方法と、
Lispプログラムがこれらを行えるようにするサブルーチンを説
明します。

* Menu:

* Command Overview::         コマンドループがコマンドを読み取る方法。
* Defining Commands::        関数が引数を読み取る方法を指定する。
* Interactive Call::         引数を読み取るようにコマンドを呼び出す。
* Distinguish Interactive::  インタラクティブな呼び出しとコマンドを区別する。
* Command Loop Info::        検証用にコマンドループによりセットされる変数。
* Adjusting Point::          コマンドの後にポイント位置を調整する。
* Input Events::             入力を読み取るとき、入力がどのように見えるか。
* Reading Input::            キーボードやマウスからの入力イベントを読み取る方法。
* Special Events::           即座かつ個別に処理されるイベント。
* Waiting::                  ユーザー入力または経過時間の待機。
* Quitting::                 ‘C-g’が機能する方法。quitをcatchまたは延期する方法。
* Prefix Command Arguments::  コマンドがプレフィクス引数が機能するようにセットするための方法。
* Recursive Editing::        再帰編集へのエンター、なぜ通常は再帰編集を行うべきでないのか。
* Disabling Commands::       コマンドループが無効なコマンドを扱う方法。
* Command History::          コマンドヒストリーがセットアップされる方法と、どのようにアクセスされるか。
* Keyboard Macros::          キーボードマクロが実装される方法。


File: elisp,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

20.1 Command Loop Overview
==========================

コマンドループが最初に行わなければならないのはキーシーケ
ンスの読み取りです。キーシーケンスほコマンドに変換される
入力イベントのシーケンスです。これは関数
‘read-key-sequence’を呼び出すことにより行われます。
Lispプログラムもこの関数を呼び出すことができます(*note
Key Sequence Input::を参照)。これらはより低レベルの
‘read-key’や‘read-event’(*note Reading One Event::)で入
力を読み取ったり、‘discard-input’(*note Event Input
Misc::を参照)で保留中の入力を無視することもできます。

   キーシーケンスはカレントでアクティブなキーマップを通
じてコマンドに変換されます。これが行われる方法については
、*Note Key Lookup::を参照してください。結果はキーボード
マクロかインタラクティブに呼び出し可能な関数になります。
キーが‘M-x’の場合は、他のコマンドの名前を読み取り、それ
を呼び出します。これはコマンド
‘execute-extended-command’(*note Interactive Call::を参
照)により行われます。

   コマンドの実行に先立ち、Emacsはアンドゥ境界(undo
boundary)を作成するために‘undo-boundary’を実行します。
*note Maintaining Undo::を参照してください。

   コマンドを実行するために、Emacsはまず
‘command-execute’を呼び出してコマンドの引数を読み取りま
す(*note Interactive Call::を参照)。Lispで記述されたコマ
ンドについては、‘interactive’指定で引数を読み取る方法を
指定します。これはプレフィクス引数(*note Prefix Command
Arguments::を参照)を使用したり、ミニバッファー内(*note
Minibuffers::を参照)で確認を求めて読み取りを行うかもしれ
ません。たとえば、コマンド‘find-file’には‘interactive’指
定があり、これはミニバッファーを使用してファイル名を読み
取ることを指定します。‘find-file’の関数bodyはミニバッフ
ァーを使用しないので、Lispコードから関数として
‘find-file’を呼び出す場合は通常のLisp関数引数としてファ
イル名を文字列で与えなければなりません。

   コマンドがキーボードマクロ(文字列やベクター)の場合、
Emacsは‘execute-kbd-macro’を使用してそれを実行します
(*note Keyboard Macros::を参照)。

 -- Variable: pre-command-hook
     このノーマルフックはコマンドを実行する前に、エディ
     ターコマンドループにより実行される。その際、
     ‘this-command’ には実行しようとするコマンドが含まれ
     、‘last-command’には前のコマンドが記述される。*note
     Command Loop Info::を参照のこと。

 -- Variable: post-command-hook
     このノーマルフックはコマンドを実行した後(quitやエラ
     ーにより早期に終了させられたコマンドを含む)に、エデ
     ィターコマンドループにより実行される。その際、
     ‘this-command’は正に実行されたコマンドを参照し、
     ‘last-command’は前に実行されたコマンドを参照する。

     このフックはEmacsが最初にコマンドループにエンターし
     たときにも実行される(その時点では‘this-command’と
     ‘last-command’はどちらも‘nil’)。

   ‘pre-command-hook’および‘post-command-hook’の実行中、
quitは抑制されます。これらのフックのどれか1つを実行中に
エラーが発生した場合、そのエラーはフックの実行を終了させ
ません。そのかわりにエラーは黙殺され、エラーが発生した関
数はそのフックから取り除かれます。

   Emacsサーバー(*note (emacs)Emacs Server::を参照)に届
くリクエストは、キーボードコマンドが行うのと同じように、
これらの2つのフックを実行します。


File: elisp,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

20.2 Defining Commands
======================

スペシャルフォーム‘interactive’はLisp関数をコマンドに変
えます。‘interactive’フォームは関数ボディーのトップレベ
ルに置かなければならず、通常はボディー内の最初のフォーム
として記述されます。これはラムダ式(*note Lambda
Expressions::を参照)と‘defun’(*note Defining
Functions::を参照)の両方を受け入れます。このフォームは、
その関数が実際に実行される間は何も行いません。このフォー
ムの存在はフラグとしての役割りをもち、Emacsコマンドルー
プにたいしてその関数がインタラクティブに呼び出せることを
告げます。‘interactive’フォームの引数は、インタラクティ
ブな呼び出しが引数を読み取る方法を指定します。

   ‘interactive’フォームのかわりに、関数シンボルの
‘interactive-form’プロパティで指定されることもあります。
このプロパティが非‘nil’値の場合、関数ボディー内の
‘interactive’フォームより優先されます。この機能はほとん
ど使用されません。

   インタラクティブに呼び出されることだけを意図していて
、決してLispから直接呼び出されない関数が時折あります。こ
の場合は、その関数の‘interactive-only’プロパティに非
‘nil’を与えます。これにより、そのコマンドがLispから呼び
出された場合に、バイトコンパイラーが警告を発します。この
プロパティの値には、文字列、‘t’、または任意のシンボルを
指定できます。文字列の場合、それはバイトコンパイラーによ
る警告内で直接使用されます(最初は大文字でなくピリオドで
終端される文字列。たとえば“use ... instead.”)。シンボル
の場合、それはLispコード内で使用されるかわりの関数です。

* Menu:

* Using Interactive::        ‘interactive’にたいする一般的なルール。
* Interactive Codes::        さまざまな方法で引数を読み取る標準的な文字のコード。
* Interactive Examples::     インタラクティブ引数を読み取る方法の例。
* Generic Commands::         コマンド候補からの選択。


File: elisp,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

20.2.1 Using ‘interactive’
--------------------------

このセクションでは、Lisp関数をインタラクティブに呼び出し
可能なコマンドにする‘interactive’フォームの記述方法と、
コマンドの‘interactive’フォームの検証方法について説明し
ます。

 -- Special Form: interactive arg-descriptor
     このスペシャルフォームは関数がコマンドであり、した
     がって(‘M-x’を通じて、またはそのコマンドにバインド
     されたキーシーケンスのエンターすることにより)インタ
     ラクティブに呼び出されるかもしれないことを宣言する
     。引数ARG-DESCRIPTORは、そのコマンドがインタラクテ
     ィブに呼び出されたときに引数を計算する方法を宣言す
     る。

     コマンドは他の関数と同じようにLisp関数から呼び出さ
     れるかもしれないが、その場合呼び出し側は引数を提供
     し、ARG-DESCRIPTORは効果をもたない。

     ‘interactive’フォームは関数ボディー内のトップレベル
     に置くか、関数シンボルの‘interactive-form’プロパテ
     ィ((*note Symbol Properties::)を参照)になければなら
     ない。これはコマンドループが関数を呼び出す前に
     interactiveフォームを調べることにより効果をもつ
     (*note Interactive Call::を参照)。一度関数が呼び出
     されると関数ボディー内のすべてのフォームが実行され
     る。このときボディー内に‘interactive’フォームが出現
     しても、そのフォームは引数の評価さえされず、単に
     ‘nil’をリターンする。

     慣例により、‘interactive’フォームは関数ボディー内の
     最初のトップレベルフォームとするべきである。
     ‘interactive’フォームがシンボルの
     ‘interactive-form’プロパティと関数ボディーの両方に
     存在する場合は、前者が優先される。
     ‘interactive-form’フォームは既存の関数に
     interactiveフォームを追加したり、その関数を再定義す
     ることなく引数をインタラクティブに処理する方法を変
     更するために使用できる。

   引数ARG-DESCRIPTORには3つの可能性があります:

   • 省略、または‘nil’の場合、コマンドは引数なしで呼び出
     される。コマンドが1つ以上の引数を要求する場合は、す
     ぐにエラーとなる。

   • 文字列の場合、その文字列の内容は改行で区切られた要
     素シーケンスであり、1つの要素が1つの引数に対応する
     (1)。各要素はコード文字(*note Interactive Codes::を
     参照)と、オプションでその後のプロンプト(ある文字は
     コード文字として使用され、コード文字としては無視さ
     れるものもある)により構成される。以下は例である:

          (interactive "P\nbFrobnicate buffer: ")

     コード文字‘P’はそのコマンドの1つ目の引数をrawコマン
     ドプレフィクス(*note Prefix Command Arguments::を参
     照)にセットする。‘bFrobnicate buffer: ’は、ユーザー
     に‘Frobnicate buffer: ’のプロンプトを示して既存のバ
     ッファーの名前の入力を促し、これは2つ目かつ最後の引
     数になる。

     プロンプト文字列には、プロンプト内の前の引数(1つ目
     の引数から始まる)の値を含めるために‘%’を使用できる
     。これは‘format’(*note Formatting Strings::を参照
     )を使用して行われる。たとえば、以下は既存のバッファ
     ーの名前を読み取り、その後にそのバッファーに与える
     新たな名前を読み取る例である:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     文字列の先頭‘*’がある場合、そのバッファーが読み取り
     専用の場合にエラーがシグナルされる。

     文字列の先頭が‘@’で、そのコマンドの呼び出しに使用さ
     れたキーシーケンスに何らかのマウスイベントが含まれ
     る場合は、そのコマンドを実行する前に、それらのうち
     最初のイベントに結びつくウィンドウが選択される。

     文字列の先頭が‘^’で、そのコマンドが“シフト転換
     (shift-translation)”を通じて呼び出された場合は、そ
     のコマンドを実行する前に、マークをセットして一時的
     にリージョンをアクティブにするか、すでにアクティブ
     なリージョンを拡張する。コマンドがシフト転換なしで
     呼び出されて、リージョンが一時的にアクティブな場合
     は、コマンドを実行する前に、そのリージョンを非アク
     ティブにする。シフト転換は‘shift-select-mode’により
     、ユーザーレベルで制御される。*note (emacs)Shift
     Selection::を参照のこと。

     ‘*’、‘@’、‘^’はともに使用でき、その場合は順序に意味
     はない。実際の引数の読み取りは残りのプロンプト文字
     列(‘*’、‘@’、‘^’以外の最初の文字以降)により制御され
     る。

   • 文字列ではないLisp式の場合は、そのコマンドに渡す引
     数リストを取得するために評価されるフォームである。
     このフォームは通常、ユーザーから入力を読み取るため
     にさまざまな関数を呼び出し、それにはほとんどの場合
     はミニバッファー(*note Minibuffers::を参照)を通じて
     か、キーボードから直接読み取りを行う(*note Reading
     Input::を参照)。

     引数値としてポイントやマークを提供するのも一般的だ
     が、何かを行い_かつ_(ミニバッファー使用の有無に関わ
     らず)入力を読み取る場合は、読み取りの前にポイント値
     またはマーク値の整数を確実に取得しておくこと。カレ
     ントバッファーはサブプロセスの出力を受信するかもし
     れず、コマンドが入力を待つ間にサブプロセス出力が到
     着した場合、ポイントおよびマークの再配置が起こり得
     る。

     以下は行っては_いけない_例である:

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     これにたいし、以下はキーボード入力を読み取った後に
     ポイントとマークを調べることにより、上記の問題を避
     ける例である:

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

     *警告:* 引数値にはプリントや読み取りが不可能なデー
     タ型を含めるべきではない。いくつかの機能は後続のセ
     ッションに読み込ませるために‘command-history’をファ
     イルに保存する。コマンドの引数に‘#<...>’構文を使用
     してプリントされるデータ型が含まれる場合、それらの
     機能は動作しないだろう。

     しかしこれには少数の例外がある。‘(point)’、
     ‘(mark)’、‘(region-beginning)’、‘(region-end)’など
     の一連の式に限定して使用するのに問題はない。なぜな
     らEmacsはこれらを特別に認識して、コマンドヒストリー
     内に(値ではなく)その式を配すからである。記述した式
     がこれらの例外に含まれるかどうか確認するには、コマ
     ンドを実行した後に‘(car command-history)’を調べれば
     よい。

 -- Function: interactive-form function
     この関数はFUNCTIONの‘interactive’フォームをリターン
     する。FUNCTIONがインタラクティブに呼び出し可能な関
     数(*note Interactive Call::を参照)の場合、値はその
     コマンドの引数を計算する方法を指定する
     ‘interactive’フォーム(‘(interactive SPEC)’)である。
     それ以外では値は‘nil’である。FUNCTIONがシンボルの場
     合は、そのシンボルの関数定義が使用される。

   ---------- Footnotes ----------

   (1) いくつかの要素は実際に2つの引数を提供します。


File: elisp,  Node: Interactive Codes,  Next: Interactive Examples,  Prev: Using Interactive,  Up: Defining Commands

20.2.2 Code Characters for ‘interactive’
----------------------------------------

ここで説明されているコード文字には、以下で定義されるいく
つかのキーワードが含まれています:

Completion
     補完を提供する。<TAB>、<SPC>、<RET>は
     ‘completing-read’(*note Completion::を参照)を使用し
     て引数を読み取り、名前の補完を行う。‘?’で利用可能な
     補完リストを表示する。

Existing
     既存オブジェクトの名前を要求する。無効な名前は受け
     付けられない。カレント入力が有効でない場合、ミニバ
     ッファーをexitするコマンドはexitしない。

Default
     ユーザーがテキストを何もエンターしなかった場合は、
     ある種のデフォルト値が使用される。デフォルトはコー
     ド文字に依存する。

No I/O
     このコード文字は入力を読み取らずに引数を計算する。
     したがってプロンプト文字列を使用せず、与えられたプ
     ロンプト文字列は無視される。

     たとえこのコード文字がプロンプト文字列を使用しなく
     ても、これが文字列内で最後のコード文字でない場合は
     、その後に改行を付けなければならない。

Prompt
     コード文字の直後にプロンプトが続く。プロンプトの終
     端は文字列の終端、または改行。

Special
     このコード文字はインタラクティブ文字列の先頭にある
     ときのみ意味があり、プロンプトおよび改行を要求しな
     い。単一の独立した文字である。

   以下は‘interactive’とともに使用されるコード文字です:

‘*’
     カレントバッファーが読み取り専用の場合はエラーをシ
     グナルする。[Special]

‘@’
     このコマンドを呼び出したキーシーケンス内の最初のマ
     ウスイベントに関連するウィンドウを選択する。
     [Special]

‘^’
     シフト転換を通じてコマンドが呼び出された場合はコマ
     ンドを実行する前に、マークをセットして一時的にリー
     ジョンをアクティブにするか、すでにリージョンがアク
     ティブな場合はリージョンを拡張する。シフト転換を通
     じずにコマンドが呼び出され、リージョンが一時的にア
     クティブな場合は、コマンドを実行する前にそのリージ
     ョンを非アクティブにする。[Special]

‘a’
     関数名(たとえば‘fboundp’を満足するシンボル)。
     [Existing]、[Completion]、[Prompt]

‘b’
     既存バッファーの名前。 The name of an existing
     buffer. デフォルトではカレントバッファー(*note
     Buffers::を参照)の名前を使用する。[Existing]、
     [Completion]、[Default]、[Prompt]

‘B’
     バッファー名。そのバッファーが存在する必要はない。
     デフォルトではカレントバッファーではなくもっとも最
     近使用されたバッファーの名前を使用する。
     [Completion]、[Default]、[Prompt]

‘c’
     文字。カーソルはエコーエリアに移動しない。[Prompt]

‘C’
     コマンド名(たとえば‘commandp’を満足するシンボル)。
     [Existing]、[Completion]、[Prompt]

‘d’
     ポイント位置の整数(*note Point::を参照)。[No I/O]

‘D’
     ディレクトリー名。デフォルトはカレントバッファーの
     カレントのデフォルトディレクトリー
     ‘default-directory’(*note File Name Expansion::を参
     照)。[Existing]、[Completion]、[Default]、[Prompt]

‘e’
     そのコマンドを呼び出したキーシーケンス内の1つ目、ま
     たは2つ目の非キーボードイベント。より正確には、
     ‘e’はリストとしてイベントを取得するので、リスト内の
     データを調べることができる。*note Input Events::を
     参照のこと。[No I/O]

     ‘e’はマウスイベント、および特別なシステムイベント
     (*note Misc Events::を参照)にたいして使用する。コマ
     ンドが受け取るイベントリストは、そのイベントに依存
     する。*note Input Events::ではそれぞれのイベントの
     リスト形式を、対応するサブセクションでそれぞれ説明
     しているので、参照のこと。

     1つのコマンドのinteractive仕様の中で、‘e’を複数回使
     用できる。そのコマンドを呼び出したキーシーケンスが
     イベントN(リスト)をもつ場合は、‘e’のN番目がそのイベ
     ントを提供する。関数キーやASCII文字のようなリスト以
     外のイベントは、‘e’に関連するイベントとしてカウント
     されない。

‘f’
     既存ファイルのファイル名(*note File Names::を参照
     )。デフォルトのディレクトリーは
     ‘default-directory’。[Existing]、[Completion]、
     [Default]、[Prompt]

‘F’
     ファイル名。ファイルが存在している必要はない。
     [Completion]、[Default]、[Prompt]

‘G’
     ファイル名。ファイルが存在している必要はない。ユー
     ザーがディレクトリー名だけをエンターした場合、値は
     そのディレクトリー名となり、そのディレクトリー名に
     ファイル名は追加されない。[Completion]、[Default]、
     [Prompt]

‘i’
     無関係な引数。このコード文字は引数値として常に
     ‘nil’を与える。[No I/O]

‘k’
     キーシーケンス(*note Key Sequences::を参照)。これは
     カレントキーマップ内でコマンド(または未定義のコマン
     ド)が見つかるまで、イベントを読み取り続ける。キーシ
     ーケンス引数は文字列、またはベクターで表される。カ
     ーソルはエコーエリアに移動しない。[Prompt]

     ‘k’が(マウスの)down-eventで終わるキーシーケンスを読
     み取った場合は、後続の(マウスの)up-eventも読み取り
     、それを捨てる。コード文字‘U’により、up-eventへのア
     クセスを得ることができる。

     この種の入力は、‘describe-key’や‘global-set-key’の
     ようなコマンドにより使用される。

‘K’
     キーシーケンス。その定義は変更されることを意図して
     いる。これは‘k’と同じように機能するが、キーシーケン
     ス内の最後の入力イベントにたいして、通常(必要なら
     )使用される未定義キーから定義済みキーへの変換を抑制
     する。

‘m’
     マーク位置の整数。[No I/O]

‘M’
     任意のテキスト。ミニバッファー内でカレントバッファ
     ーの入力メソッド(*note (emacs)Input Methods::を参照
     )を使用して読み取りを行い、それを文字列でリターンす
     る。[Prompt]

‘n’
     数字。ミニバッファーで読み取られる。入力が数字でな
     い場合、ユーザーは再試行する必要がある。‘n’は決して
     プレフィクス引数を使用しない。[Prompt]

‘N’
     数引数(numeric prefix argument)。ただしプレフィクス
     引数がない場合は、‘n’のように数字を読み取る。値は常
     に数字。*note Prefix Command Arguments::を参照のこ
     と。[Prompt]

‘p’
     数引数()これは小文字の‘p’であることに注意)。[No
     I/O]

‘P’
     rawプレフィクス引数(これは大文字の‘P’であることに注
     意)。[No I/O]

‘r’
     2つの数引数(ポイントとマーク)。小さいほうが先。これ
     は1つではなく連続する2つの引数を指定する唯一のコー
     ド文字である。[No I/O]

‘s’
     任意のテキスト。ミニバッファー内で読み取りを行い文
     字列としてリターンする(*note Text from
     Minibuffer::を参照)。‘C-j’か<RET>で入力を終端する
     (これらの文字を入力に含めるために‘C-q’が使用される
     かもしれない)。[Prompt]

‘S’
     インターン済みのシンボル。名前はミニバッファー内で
     読み取られる。‘C-j’か<RET>で入力を終端する。ここで
     は、その他の通常はシンボルを終端する文字(たとえば空
     白文字、丸カッコ、角カッコ)では終端されない。
     [Prompt]

‘U’
     キーシーケンス、または‘nil’。‘k’(または‘K’)が読み取
     った後に、(もしあれば)捨てられる(マウスの
     )up-eventを取得するために、引数‘k’(または‘K’)の後で
     使用され得る。捨てられたup-eventが存在しない場合、
     ‘U’は引数として‘nil’を提供する。[No I/O]

‘v’
     ユーザーオプションとして宣言された変数(たとえば述語
     ‘custom-variable-p’を満足する)。これは
     ‘read-variable’を使用して変数を読み取る。*note
     Definition of read-variable::を参照のこと。
     [Existing]、[Completion]、[Prompt]

‘x’
     Lispオブジェクト。そのオブジェクトの入力構文により
     指定され、‘C-j’か<RET>で終端される。オブジェクトは
     評価されない。*note Object from Minibuffer::を参照
     のこと。[Prompt]

‘X’
     Lispフォームの値。‘X’は‘x’のように読み取りを行いフ
     ォームを評価して、その値がコマンドの引数になる。
     [Prompt]

‘z’
     コーディングシステム名(シンボル)。ユーザーがnull入
     力をエンターした場合、引数値は‘nil’になる。*note
     Coding Systems::を参照のこと。[Completion]、
     [Existing]、[Prompt]

‘Z’
     コマンドにプレフィクス引数がある場合はコーディング
     システム名。プレフィクス引数がない場合、‘Z’は引数値
     として‘nil’を提供する。[Completion]、[Existing]、
     [Prompt]


File: elisp,  Node: Interactive Examples,  Next: Generic Commands,  Prev: Interactive Codes,  Up: Defining Commands

20.2.3 Examples of Using ‘interactive’
--------------------------------------

以下に‘interactive’の例をいくつか挙げます:

     (defun foo1 ()              ; ‘foo1’は1つの引数をとり
         (interactive)           ;   単に2単語分前に移動する。
         (forward-word 2))
          ⇒ foo1

     (defun foo2 (n)             ; ‘foo2’は引数を1つとる
         (interactive "^p")      ;   引数は数引数
                                 ; ‘shift-select-mode’では、
                                 ;   リージョンをアクティブにするか、拡張する
         (forward-word (* 2 n)))
          ⇒ foo2

     (defun foo3 (n)             ; ‘foo3’は引数を1つとる
         (interactive "nCount:") ;   引数はミニバッファーで読み取られる
         (forward-word (* 2 n)))
          ⇒ foo3

     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          ⇒ three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          ⇒ nil


File: elisp,  Node: Generic Commands,  Prev: Interactive Examples,  Up: Defining Commands

20.2.4 Select among Command Alternatives
----------------------------------------

マクロ‘define-alternatives’は“ジェネリックコマンド
(generic command)”を定義するために使用できます。これらは
ユーザーの選択により複数の候補から選択可能な
interactive関数の実装です。

 -- Macro: define-alternatives command &rest
          customizations
     新たなコマンドCOMMAND(シンボル)を定義する。

     最初にユーザーが‘M-x COMMAND <RET>’を実行したとき、
     Emacsはコマンドが使用する実際のフォームにたいして確
     認を求め、その選択をカスタム変数として記録する。プ
     レフィクス引数を使用すると、候補選択のプロセスを繰
     り返す。

     変数‘COMMAND-alternatives’には、COMMANDの実装候補が
     alistで含まれる。この変数がセットされるまで、
     ‘define-alternatives’は効果をもたない。

     CUSTOMIZATIONSが非‘nil’の場合は、‘defcustom’キーワ
     ード(典型的には‘:group’および‘:version’)と、
     ‘COMMAND-alternatives’の宣言に追加する値により構成
     される候補である。


File: elisp,  Node: Interactive Call,  Next: Distinguish Interactive,  Prev: Defining Commands,  Up: Command Loop

20.3 Interactive Call
=====================

コマンドループはキーシーケンスをコマンドに翻訳した後、関
数‘command-execute’を使用してその関数を呼び出します。そ
のコマンドが関数の場合、‘command-execute’は引数を読み取
りコマンドを呼び出す‘call-interactively’を呼び出します。
自分でこれらの関数を呼び出すこともできます。

   このコンテキストにおいて用語“command”はインタラクティ
ブにコール可能な関数(または関数likeなオブジェクト)やキー
ボードマクロを指すことに注意してください。つまりコマンド
を呼び出すキーシーケンスのことではありません(*note
Keymaps::を参照)。

 -- Function: commandp object &optional
          for-call-interactively
     この関数はOBJECTがコマンドの場合は‘t’、それ以外は
     ‘nil’をリターンする。

     コマンドには文字列とベクター(キーボードマクロとして
     扱われる)、トップレベル‘interactive’フォーム(*note
     Using Interactive::を参照)を含むラムダ式、そのよう
     なラムダ式から作成されたバイトコンパイル関数オブジ
     ェクト、interactiveとして宣言(‘autoload’の4つ目の引
     数が非‘nil’)されたautoloadオブジェクト、およびいく
     つかのプリミティブ関数が含まれる。
     ‘interactive-form’プロパティが非‘nil’のシンボル、お
     よび関数定義が‘commandp’を満足するシンボルもコマン
     ドとされる。

     FOR-CALL-INTERACTIVELYが非‘nil’の場合は、
     ‘call-interactively’が呼び出すことができるオブジェ
     クトにたいしてのみ‘commandp’は‘t’をリターンする。し
     たがってキーボードマクロは該当しなくなる。

     ‘commandp’を使用する現実的な例は、*note Accessing
     Documentation::内の‘documentation’を参照のこと。

 -- Function: call-interactively command &optional
          record-flag keys
     この関数はinteractive呼び出し仕様にしたがって引数を
     取得し、インタラクティブに呼び出し可能な関数
     COMMANDを呼び出す。これはCOMMANDがリターンするもの
     が何であれ、それをリターンする。

     たとえば、もし以下の署名をもつ関数がある場合:

          (defun foo (begin end)
            (interactive "r")
            ...)

     以下を行うと

          (call-interactively 'foo)

     これはリージョン(‘point’と‘mark’)を引数として
     ‘foo’を呼び出すだろう。

     COMMANDが関数でない、またはインタラクティブに呼び出
     せない(コマンドでない)場合は、エラーをシグナルする
     。たとえコマンドだとしても、キーボードマクロ(文字列
     かベクター)は、関数ではないので、許されないことに注
     意。COMMANDがシンボルの場合、‘call-interactively’は
     それの関数定義を使用する。

     RECORD-FLAGが非‘nil’の場合は、このコマンドとコマン
     ドの引数は無条件にリスト‘command-history’に追加され
     る。それ以外では、引数の読み取りにミニバッファーを
     使用した場合のみコマンドが追加される。*note Command
     History::を参照のこと。

     引数KEYSが与えられた場合、それはコマンドを呼び出す
     ためにどのイベントを使用するかコマンドが問い合わせ
     た場合に与えるべき、イベントシーケンスを指定するベ
     クターである。KEYSが‘nil’、または省略された場合のデ
     フォルトは、‘this-command-keys-vector’のリターン値
     である。*note Definition of
     this-command-keys-vector::を参照のこと。

 -- Function: command-execute command &optional
          record-flag keys special
     この関数はCOMMANDを実行する。引数COMMANDは述語
     ‘commandp’を満足しなければならない。つまりインタラ
     クティブに呼び出し可能な関数かキーボードマクロでな
     ければならない。

     COMMANDが文字列かベクターの場合は、
     ‘execute-kbd-macro’により実行される。関数は
     RECORD-FLAGおよびKEYS引数とともに
     ‘call-interactively’に渡される(上記参照)。

     COMMANDがシンボルの場合、その位置にシンボルの関数定
     義が使用される。‘autoload’定義のあるシンボルは、イ
     ンタラクティブに呼び出し可能な関数お意味するよう宣
     言されている場合は、コマンドとして判断される。その
     ような宣言は、指定されたライブラリーのロードと、シ
     ンボル定義の再チェックにより処理される。

     引数SPECIALが与えられた場合、それはプレフィクス引数
     を無視して、それをクリアーしないという意味である。
     これはスペシャルイベント(*note Special Events::を参
     照)を実行する場合に使用される。

 -- Command: execute-extended-command prefix-argument
     この関数は‘completing-read’(*note Completion::を参
     照)を使用して、ミニバッファーからコマンド名を読み取
     る。その後、指定されたコマンドを呼び出すために
     ‘command-execute’を使用する。そのコマンドがリターン
     するのが何であれ、それが
     ‘execute-extended-command’の値となる。

     そのコマンドがプレフィクス引数を求める場合は、
     PREFIX-ARGUMENTのの値を受け取る。
     ‘execute-extended-command’がインタラクティブに呼び
     出された場合は、カレントのrawプレフィクス引数が
     PREFIX-ARGUMENTに使用され、それが何であれ実行するコ
     マンドに渡される。

     通常、‘execute-extended-command’は‘M-x’の定義なので
     、プロンプトとして文字列‘M-x ’を使用する
     (‘execute-extended-command’を呼び出したイベントから
     プロンプトを受け取るほうが良いのだろうが、実装は骨
     が折れる)。プレフィクス引数の値の説明が、もしあれば
     、それもプロンプトの一部となる。

          (execute-extended-command 3)
          ---------- Buffer: Minibuffer ----------
          3 M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               ⇒ t


File: elisp,  Node: Distinguish Interactive,  Next: Command Loop Info,  Prev: Interactive Call,  Up: Command Loop

20.4 Distinguish Interactive Calls
==================================

interactive呼び出しのときは、コマンドが(エコーエリア内の
情報メッセージなどのような)視覚的な追加フィードバックを
表示すべきときがあります。これを行うためには、3つの方法
があります。その関数が‘call-interactively’を使用して呼び
出されたかどうかテストするには、オプション引数
‘print-message’を与えるとともに、interactive呼び出しで非
‘nil’となるように‘interactive’仕様を使うのが推奨される方
法です。以下は例です:

     (defun foo (&optional print-message)
       (interactive "p")
       (when print-message
         (message "foo")))

数プレフィクス引数は決して‘nil’にならないので、わたした
ちは‘"p"’を使用します。この方法で定義された関数は、キー
ボードマクロから呼び出されたときにメッセージを表示します
。

   追加引数による上記の手法は、呼び出し側に“この呼び出し
をinteractiveとして扱うように”伝えることができるので、通
常は最善です。しかし、‘called-interactively-p’.をテスト
することにより、これを行うこともできます。

 -- Function: called-interactively-p kind
     この関数は、呼び出された関数が
     ‘call-interactively’を使用して呼び出された場合は
     ‘t’をリターンする。

     引数KINDはシンボル‘interactive’かシンボル‘any’のど
     ちらかである。これが‘interactive’の場合、
     ‘called-interactively-p’はユーザーから直接呼び出し
     が行われたとき — たとえば関数呼び出しにバインドされ
     たキーシーケンスをユーザーがタイプした場合がそれに
     該当するが、ユーザーがその関数を呼び出すキーボード
     マクロ(*note Keyboard Macros::を参照)を実行中した場
     合は_該当しない_ — だけ‘t’をリターンするKINDが
     ‘any’の場合、‘called-interactively-p’はキーボードマ
     クロを含む任意の種類のinteractive呼び出しにたいして
     ‘t’をリターンする。

     疑わしい場合は‘any’を使用すること。‘interactive’の
     使用が正しいと解っているのは、関数が実行中に役に立
     つメッセージを表示するかどうか判断が必要な場合だけ
     である。

     Lisp評価(または‘apply’や‘funcall’))を通じて呼び出さ
     れた、または場合、関数は決してインタラクティブに呼
     び出されたとは判断されない。

以下は‘called-interactively-p’を使用する例である:

     (defun foo ()
       (interactive)
       (when (called-interactively-p 'any)
         (message "Interactive!")
         'foo-called-interactively))

     ;; ‘M-x foo’とタイプする
          ⊣ Interactive!

     (foo)
          ⇒ nil

以下は‘called-interactively-p’の直接呼び出しと間接呼び出
しを比較した例である。

     (defun bar ()
       (interactive)
       (message "%s" (list (foo) (called-interactively-p 'any))))

     ;; ‘M-x bar’とタイプする
          ⊣ (nil t)


File: elisp,  Node: Command Loop Info,  Next: Adjusting Point,  Prev: Distinguish Interactive,  Up: Command Loop

20.5 Information from the Command Loop
======================================

エディターコマンドループは、自分自身と実行するコマンドの
ために、いくつかのLisp変数にステータス記録を保持します。
‘this-command’および‘last-command’以外は、一般的にこれら
の変数をLispプログラム内で変更するのは、良いアイデアでは
ありません。

 -- Variable: last-command
     この変数は、コマンドループにより実行された以前のコ
     マンド(前にカレントだったコマンド)の名前を記録する
     。値は通常、関数定義をもつシンボルだが、その保証は
     ない。

     コマンドがコマンドループからリターンするとき、
     ‘this-command’から値がコピーされる。ただしそのコマ
     ンドが、後続のコマンドにたいしてプレフィクス引数を
     指定されたときを除く。

     この変数は常にカレント端末にたいしてローカルであり
     、バッファーローカルにできない。*note Multiple
     Terminals::を参照のこと。

 -- Variable: real-last-command
     この変数はEmacsにより‘last-command’と同様にセットア
     ップされるが、Lispプログラムから決して変更されない
     。

 -- Variable: last-repeatable-command
     この変数は、入力イベントと一部としではなく、もっと
     も最近実行されたコマンドを格納する。これはコマンド
     ‘repeat’が再実行を試みるコマンドである。*note
     (emacs)Repeating::を参照のこと。

 -- Variable: this-command
     この変数は、コマンドループにより現在実行中のコマン
     ドの名前を記録する。‘last-command’と同様、通常は関
     数定義をもつシンボルである。

     コマンドループはコマンドを実行する直前にこの変数を
     セットして、(そのコマンドが後続のコマンドのプレフィ
     クス引数を指定しない場合)そのコマンドが終了したとき
     に、その値を‘last-command’内にコピーする。

     いくつかのコマンドは、次に実行されるコマンドが何で
     あれ、それにたいするフラグとして、実行中の間この変
     数をセットする。特にテキストをkillする関数は
     ‘this-command’を‘kill-region’にセットするので、直後
     に実行された任意のkillコマンドは、killしたテキスト
     を前にkillされたテキストに追加すべきことが解かるだ
     ろう。

   特定のコマンドにおいて、エラーが発生した場合に前のコ
マンドとして認識されたくない場合は、これを防ぐようにその
コマンドをコーディングしなければならない。これを行う1つ
の方法は、以下のようにコマンドの最初で‘this-command’に
‘t’をセットして、最後に‘this-command’に正しい値をセット
する方法である:

     (defun foo (args...)
       (interactive ...)
       (let ((old-this-command this-command))
         (setq this-command t)
         ... 処理を行う ...
         (setq this-command old-this-command)))

エラーの場合、‘let’は古い値をリストアするので、わたした
ちは‘let’で‘this-command’をバインドしない。この場合にお
ける‘let’の機能は、わたしたちが避けたいと思っていること
を正確に行ってしまうだろう。

 -- Variable: this-original-command
     コマンドのリマップ(*note Remapping Commands::を参照
     )が発生したときを除き、これは‘this-command’と同じ値
     をもつ。リマップが発生した場合、‘this-command’は実
     際に実行されたコマンド、‘this-original-command’は実
     行を指定されたが他のコマンドにリマップされたコマン
     ドを与える。

 -- Function: this-command-keys
     この関数は、現在のコマンドを呼び出したキーシーケン
     スと、加えてそのコマンドにたいするプレフィクス引数
     を生成した前のコマンドを含む文字列またはベクターを
     リターンする。‘read-event’を使用するコマンドにより
     、タイムアウトせずに読み取られた任意のイベントは最
     後に加えられる。

     しかし、そのコマンドが‘read-key-sequence’を呼び出し
     ていた場合は、最後に読み取られたキーシーケンスをリ
     ターンする。*note Key Sequence Input::を参照のこと
     。シーケンス内のすべてのイベントが文字列として適当
     な文字の場合は、文字列が値になる。*note Input
     Events::を参照のこと。

          (this-command-keys)
          ;; これを評価するために‘C-u C-x C-e’を使用すると、
               ⇒ "^U^X^E"

 -- Function: this-command-keys-vector
     ‘this-command-keys’と同様だが、常にベクターでイベン
     トをリターンするので、入力イベントを文字列内に格納
     する複雑さを処理する必要がない(*note Strings of
     Events::を参照)。

 -- Function: clear-this-command-keys &optional
          keep-record
     この関数は、‘this-command-keys’がリターンするイベン
     トテーブルを空にする。KEEP-RECORDが‘nil’の場合は、
     その後に関数‘recent-keys’(*note Recording Input::)が
     リターンするレコードも空にする。これは特定のケース
     において、パスワードを読み取った後、次のコマンドの
     一部として不用意にパスワードがエコーされるのを防ぐ
     ために有用である。

 -- Variable: last-nonmenu-event
     この変数はキーシーケンス(マウスメニューからのイベン
     トは勘定しない)の一部として読み取られた最後の入力イ
     ベントを保持する。

     この変数の1つの使い方は、‘x-popup-menu’にたいしてど
     こにメニューをポップアップすべきか告げる場合である
     。これは内部的に‘y-or-n-p’(*note Yes-or-No
     Queries::を参照)にも使用されている。

 -- Variable: last-command-event
     この変数には、コマンドの一部としてコマンドループに
     読み取られた、最後の入力イベントがセットされる。こ
     の変数は主に、‘self-insert-command’内でどの文字が挿
     入されたか判断するために使用されている。

          last-command-event
          ;; これを評価するために‘C-u C-x C-e’を使用すると、
               ⇒ 5

     ‘C-e’のASCIIコードの5が値になる。

 -- Variable: last-event-frame
     この変数は、最後の入力イベントが送られたフレームを
     記録する。これは通常、そのイベントが生成されたとき
     に選択されていたフレームだが、そのフレームの入力が
     他のフレームにリダイレクトされていた場合は、そのリ
     ダイレクトされていたフレームが値となる。*note Input
     Focus::を参照のこと。

     最後のイベントがキーボードマクロ由来の場合、値は
     ‘macro’になる。


File: elisp,  Node: Adjusting Point,  Next: Input Events,  Prev: Command Loop Info,  Up: Command Loop

20.6 Adjusting Point After Commands
===================================

プロパティ‘display’や‘composition’をｍつテキストや、非表
示のテキストシーケンスの中間でポイント値を表示するのは、
簡単ではありません。したがって、コマンドが終了した後にコ
マンドループにリターンするとき、そのようなシーケンス中に
ポイントがある場合、コマンドループは通常ポイントをそのよ
うなシーケンスの端に移動します。

   変数‘disable-point-adjustment’をセットすることにより
、コマンドはこの機能を抑制できます:

 -- Variable: disable-point-adjustment
     この変数が非‘nil’の場合は、コマンドがコマンドループ
     にリターンするとき、コマンドループはこれらのテキス
     トプロパティをチェックせず、これらのプロパティをも
     つシーケンスの外にポイントを移動しない。

     コマンドループはそれぞれのコマンドを実行する前にこ
     の変数を‘nil’にセットするので、あるコマンドがこれを
     セットしても、効果が適用されるのはそのコマンドにた
     いしてだけである。

 -- Variable: global-disable-point-adjustment
     この変数を非‘nil’にセットした場合、これらのシーケン
     ス外にポイントを移動する機能は、完全にオフになる。


File: elisp,  Node: Input Events,  Next: Reading Input,  Prev: Adjusting Point,  Up: Command Loop

20.7 Input Events
=================

Emacsコマンドループは“入力イベント(input events)”のシー
ケンスを読み取ります。入力イベントとは、キーボードやマウ
スのアクティビティ、またはEmacsに送られるシステムイベン
トを表します。キーボードアクティビティにたいするイベント
は文字、またはシンボルです。それ以外のイベントは、常にリ
ストになります。このセクションでは、入力イベントの表現と
意味について詳細を説明します。

 -- Function: eventp object
     この関数は、OBJECTが入力イベント、またはイベント型
     の場合は、非‘nil’をリターンする。

     イベント、またはイベント型として任意のシンボルが使
     用されるかもしれないことに注意。‘eventp’は、あるシ
     ンボルがLispコードによりイベントとして使用されるこ
     とを意図しているか否か区別できない。そのかわりに、
     カレントEmacsセッション内で、そのシンボルが入力とし
     て読み取られたイベント内で実際に使用されているか否
     かを区別する。シンボルがまだそのように使用されてい
     ない場合、‘eventp’は‘nil’をリターンする。

* Menu:

* Keyboard Events::          通常の文字 —
                               自身にシンボルされるキー。
* Function Keys::            ファンクションキー —
                               名前をもつがシンボルではない。
* Mouse Events::             マウスイベントの概観。
* Click Events::             マウスボタンのプッシュとリリース。
* Drag Events::              ボタンをリリースする前のマウス移動。
* Button-Down Events::       ボタンがプッシュされて、まだリリースされていない状態。
* Repeat Events::            ダブル、トリプルのクリック(またはドラッグ、ダウン)
* Motion Events::            ボタンを押さずに、マウスだけを移動する。
* Focus Events::             フレーム間のマウス移動。
* Misc Events::              システムが生成可能なその他のイベント。
* Event Examples::           マウスイベントの例。
* Classifying Events::       イベントシンボル内の修飾キーを見つける。イベント型。
* Accessing Mouse::          マウスイベントから情報抽出する関数。
* Accessing Scroll::         スクロールバーイベントから情報取得する関数。
* Strings of Events::        文字列内にキーボード文字イベントを配すための特別な配慮。


File: elisp,  Node: Keyboard Events,  Next: Function Keys,  Up: Input Events

20.7.1 Keyboard Events
----------------------

キーボードから取得できる入力には2つの種類があります。そ
れは通常のキーとファンクションキーです。通常のキーは文字
に対応し、それらが生成するイベントはLisp内では文字で表現
されます。文字イベントのイベント型は文字自身(整数)です。
*note Classifying Events::を参照してください。

   入力文字イベントは0から524287までの“基本コード(basic
code)”に加えて、以下の“修飾ビット(modifier bits)”の一部
、またはすべてにより構成されます:

meta
     文字コードのビット 2**27 はメタキーが押下された状態
     で文字がタイプされたことを示す。

control
     文字コードのビット 2**26 は非ASCIIコントロール文字
     を示す。

     ‘C-a’のような非ASCIIコントロール文字は、自身が特別
     な基本コードをもつため、それらを示すためにEmacsは特
     別なビットを必要としない。つまり‘C-a’のコードは単な
     る1である。

     しかし、‘%’のような非ASCIIとコントロールを組み合わ
     せてタイプした場合、取得される数値は‘%’に 2**26 を
     加えた値となる(端末が非ASCIIコントロール文字をサポ
     ートすると仮定する)。

shift
     文字コードのビット 2**25 はシフトキーが押下された状
     態でASCIIコントロール文字がタイプされたことを示す。

     アルファベット文字にたいしては、基本コード自身が大
     文字か小文字かを示す。数字と句読点文字にたいしてシ
     フトキーは、異なる基本コードをもつ完全に違う文字を
     選択する。可能な限りASCII文字として保つために、
     Emacsはこれらの文字にたいしてビット 2**25 を使用し
     ない。

     しかし、ASCIIは‘C-A’と‘C-a’を区別する方法を提供しな
     いので、Emacsは‘C-A’にたいしてビット 2**25 を使用し
     、‘C-a’には使用しない。

hyper
     文字コードのビット 2**24 はハイパーキーが押下された
     状態で文字がタイプされたことを示す。

super
     文字コードのビット 2**23 はスーパーキーが押下された
     状態で文字がタイプされたことを示す。

alt
     文字コードのビット 2**22 はアルトキーが押下された状
     態で文字がタイプされたことを示す(ほとんどのキーボー
     ドで<Alt>とラベルされたキーは、実際にはアルトキーで
     はなくメタキーとして扱われる)。

   プログラム内での特定のビット数値の記述は避けるのが最
善の方法です。文字の修飾ビットをテストするためには、関数
‘event-modifiers’(*note Classifying Events::を参照)を使
用してください。キーバインディングを作成するときは、修飾
ビットつきの文字にたいする読み取り構文を使用できます
(‘\C-’、‘\M-’、...など)。‘define-key’でのキーバインディ
ング作成では、文字を指定するために‘(control hyper ?x)’の
ようなリストを使用できます(*note Changing Key
Bindings::を参照)。関数‘event-convert-list’は、そのよう
なリストをイベント型に変換します(*note Classifying
Events::を参照)。


File: elisp,  Node: Function Keys,  Next: Mouse Events,  Prev: Keyboard Events,  Up: Input Events

20.7.2 Function Keys
--------------------

ほとんどのキーボードには“ファンクションキー(function
keys)”があります。これは名前、または文字以外のシンボルを
もつキーです。Emacs Lispではファンクションキーはシンボル
として表現されます。そのシンボル名はファンクションキーの
ラベルの小文字です。たとえば<F1>とラベルされたキーを押下
すると、シンボル‘f1’で表される入力イベントが生成されます
。

   ファンクションキーのイベント型は、イベントシンボルそ
れ自身です。*note Classifying Events::を参照してください
。

   ファンクションキーにたいするシンボルネーミングの慣習
には、以下のような特別なケースがいくつかあります:

‘backspace’、‘tab’、‘newline’、‘return’、‘delete’
     これらのキーは、ほとんどのキーボードにおいて特別に
     キーをもつ、一般的なASCIIコントロール文字に対応する
     。

     ASCIIでは‘C-i’と<TAB>は同じ文字である。端末がこれら
     を区別できる場合、Emacsは前者を整数の9、後者をシン
     ボル‘tab’で表現することにより、Lispプログラムにこれ
     らの違いを伝える。

     ほとんどの場合、これら2つを区別するのは役に立たない
     。そのため‘local-function-key-map’(*note
     Translation Keymaps::を参照)は‘tab’を9にマップする
     ようセットアップされている。したがって文字コード
     9(文字‘C-i’)へのキーバインディングは‘tab’にも適用さ
     れる。このグループ内の他のシンボルも同様である。関
     数‘read-char’が、これらのイベントを文字に変換する場
     合も同様である。

     ASCIIでは、<BS>は実際は‘C-h’である。しかし
     ‘backspace’は文字コード8(<BS>)ではなく、文字コード
     127(<DEL>)に変換される。ほとんどのユーザーにとって
     、これは好ましいだろう。

‘left’、‘up’、‘right’、‘down’
     矢印カーソルキー
‘kp-add’、‘kp-decimal’、‘kp-divide’、...
     キーパッドキー(標準的なキーボードにおいては右側にあ
     る)。
‘kp-0’、‘kp-1’、...
     キーパッド数字キー。
‘kp-f1’、‘kp-f2’、‘kp-f3’、‘kp-f4’
     キーパッドPFキー。
‘kp-home’、‘kp-left’、‘kp-up’、‘kp-right’、‘kp-down’
     キーパッド矢印キー。Emacsは通常これらを非キーパッド
     のキー‘home’、‘left’、...に変換する。
‘kp-prior’、‘kp-next’、‘kp-end’、‘kp-begin’、‘kp-insert’、‘kp-delete’
     通常は他の箇所にあるキーと重複するキーパッド追加キ
     ー。Emacsは通常これらを同じような名前の非キーパッド
     キーに変換する。

   ファンクションキーにたいしても修飾キー<ALT>、<CTRL>、
<HYPER>、<META>、<SHIFT>、<SUPER>を使用できます。シンボ
ル名のプレフィクスとしてこれらを表します:

‘A-’
     アルト修飾。
‘C-’
     コントロール修飾。
‘H-’
     ハイパー修飾。
‘M-’
     メタ修飾。
‘S-’
     シフト修飾。
‘s-’
     スーパー修飾。

   したがって、<META>を押下した場合の<F3>キーにたいする
シンボルは‘M-f3’になります。複雑のプレフィクスを使用する
場合は、アルファベット順に記述することを推奨します。とは
いえ、キーバインディングが修飾されたファンクションキーを
探す際、引数の順序は関係ありません。


File: elisp,  Node: Mouse Events,  Next: Click Events,  Prev: Function Keys,  Up: Input Events

20.7.3 Mouse Events
-------------------

Emacsは4つの種類のマウスイベントをサポートします。それは
クリックイベント、ドラッグイベント、ボタンダウンイベント
、モーションイベントです。すべてのマウスイベントはリスト
で表現されます。このリストのCARはイベント型です。イベン
ト型はどのマウスボタンが関与するのか、それにたいしてどの
修飾キーが使用されたかを示します。イベント型によりダブル
、あるいはトリプルでボタンが押されたかを区別することもで
きます(*note Repeat Events::を参照)。残りのリスト要素は
、位置と時間の情報を提供します。

   キーの照合においては、イベント型だけが問題になります
。2つのイベントが同じコマンドを実行するためには、同じイ
ベント型が必要です。実行されるコマンドはinteractiveのコ
ード‘e’を使用して、これらのイベントの完全な値にアクセス
できます。*note Interactive Codes::を参照してください。

   マウスイベントで開始されたキーシーケンスはカレントバ
ッファーではなく、マウスのあったウィンドウ内のバッファー
のキーマップを使用して読み取られます。これはウィンドウ内
でクリックすることによりそのウィンドウやそのウィンドウの
バッファーが選択されることを意味しません。つまり、それは
完全にそのキーシーケンスのコマンドバインディングの制御下
にあるのです。


File: elisp,  Node: Click Events,  Next: Drag Events,  Prev: Mouse Events,  Up: Input Events

20.7.4 Click Events
-------------------

ユーザーが同じ場所でマウスボタンを押してからリリース
(release: 離す)すると、“click”イベントが生成されます。す
べてのマウスクリックイベントは同じフォーマットを共有しま
す:

     (EVENT-TYPE POSITION CLICK-COUNT)

EVENT-TYPE
     これはマウスボタンが使用されたことを示す。これはシ
     ンボル‘mouse-1’、‘mouse-2’、...のうちのどれかで、マ
     ウスボタンは左から右に番号が付される。

     ファンクションキーにたいして行うのと同様にアルト、
     コントロール、ハイパー、メタ、シフト、スーパーの修
     飾にたいしてプレフィクス‘A-’、‘C-’、‘H-’、‘M-’、
     ‘S-’、‘s-’も使用できる。

     このシンボルは、イベントのイベント型の役割りももつ
     。イベントのキーバインディングはこれらの型により示
     される。したがって、‘mouse-1’にたいするキーバインデ
     ィングが存在する場合、そのバインディングは
     EVENT-TYPEが‘mouse-1’であるようなすべてのイベントに
     適用されるだろう。

POSITION
     これはマウスクリックがどこで発生したかを表す“マウス
     位置リスト(mouse position list)”である。詳細は以下
     を参照のこと。

CLICK-COUNT
     これは同じマウスボタンを素早く繰り返し押下したとき
     の回数である。*note Repeat Events::を参照のこと。

   クリックイベントのPOSITIONスロット内にあるマウス位置
リストの内容にアクセスするためには、一般的には*note
Accessing Mouse::にドキュメントされている関数を使用する
べきです。このリストの明示的なフォーマットは、どこでクリ
ックが発生したかに依存します。テキストエリア、モードライ
ン、ヘッダーライン、フリンジ、マージンエリアでのクリック
にたいして、マウス位置リストは以下のフォーマットをもちま
す

     (WINDOW POS-OR-AREA (X . Y) TIMESTAMP
      OBJECT TEXT-POS (COL . ROW)
      IMAGE (DX . DY) (WIDTH . HEIGHT))

以下はこれらのリスト要素がもつ意味です:

WINDOW
     クリックが発生したウィンドウ。

POS-OR-AREA
     テキストエリア内でクリックされた文字のバッファー位
     置。またはテキストエリア外がクリックされた場合は、
     クリックが発生したウィンドウエリア。これはシンボル
     ‘mode-line’、‘header-line’、‘vertical-line’、
     ‘left-margin’、‘right-margin’、‘left-fringe’、
     ‘right-fringe’のどれか。

     特別な場合の1つとして、POS-OR-AREAが単なるシンボル
     ではなく、(上記シンボルのいずれか1つの)シンボルを含
     むリストの場合がある。これはEmacsにより登録されたイ
     ベントにたいする、イマジナリープレフィクスキー
     (imaginary prefix key)の後に発生する。*note Key
     Sequence Input::を参照のこと。

X, Y
     クリックの相対ピクセル座標(relative pixel
     coordinates)。あるウィンドウのテキストエリア内での
     クリックにたいする座標原点‘(0 . 0)’は、テキストエリ
     アの左上隅となる。*note Window Sizes::を参照のこと
     。モードラインまたはヘッダーライン内でのクリックに
     たいする座標原点は、そのウィンドウ自身の左上隅とな
     る。フリンジ、マージン、垂直ボーダー(vertical
     border)では、Xな有意なデータをもたない。フリンジ、
     マージンでは、Yはヘッダーラインの最下端からの相対位
     置である。すべてのケースにおいてXおよびY座標は右方
     向および下方向で増加する。

TIMESTAMP
     そのイベントが発生した時刻を、システム依存の初期時
     刻(initial time)からの経過ミリ秒で表す整数。

OBJECT
     クリック位置に文字列タイプのテキストプロパティが存
     在しない場合は‘nil’、存在する場合は(STRING .
     STRING-POS)形式のコンスセル:

     STRING
          クリックされた文字列。すべてのテキストプロパテ
          ィを含む。

     STRING-POS
          クリックが発生した文字列内の位置。

TEXT-POS
     マージンエリアまたはフリンジにたいするクリックでは
     、そのウィンドウ内の対応する行内の最初の可視な文字
     のバッファー位置となる。他のイベントにたいしては、
     そのウィンドウ内のカレントバッファーの位置となる。

COL, ROW
     これらはX、Yの位置にあるグリフ(gliph)の、実際の行と
     列の座標数値である。行Xがその行の実際のテキストの最
     後の列を超える場合、COLはデフォルトの文字幅をもつ仮
     想的な追加列数を加えた値が報告される。そのウィンド
     ウがヘッダーラインをもつ場合、行0はヘッダーラインと
     なり、ヘッダーラインをもたない場合はテキストエリア
     の上端ラインが行0となる。ウィンドウのテキストエリア
     のクリックにたいしては、テキストエリアの左端列が列
     0となり、モードラインまたはヘッダーラインのクリック
     にたいしてはそのラインの左端が列0となる。フリンジま
     たは垂直ボーダーのクリックにたいしては、これらは有
     意なデータをもたない。マージンのクリックにたいして
     は、COLはマージンエリアの左端、ROWはマージンエリア
     の上端から測られる。

IMAGE
     これはクリックが発生した場所のイメージオブジェクト
     である。クリックされた場所にイメージが存在しない場
     合は‘nil’、イメージがクリックされた場合は
     ‘find-image’によりリターンされるイメージオブジェク
     トである。

DX, DY
     これらはOBJECTの左上隅‘(0 . 0)’からの相対的ピクセル
     座標である。OBJECTが‘nil’の場合は、クリックされた文
     字グリフの左上隅からの相対座標である。

WIDTH, HEIGHT
     これらはOBJECTのピクセル幅とピクセル高さであり、
     OBJECTが‘nil’の場合はクリックされた文字グリフのピク
     セル幅とピクセル高さである。

   スクロールバーへのクリックにたいして、POSITIONは以下
の形式をもちます:

     (WINDOW AREA (PORTION . WHOLE) TIMESTAMP PART)

WINDOW
     スクロールバーがクリックされたウィンドウ。

AREA
     これはシンボル‘vertical-scroll-bar’である。

PORTION
     スクロールバーの上端からクリック位置までのピクセル
     数。GTK+を含むいくつかのツールキットでは、Emacsがこ
     れらのデータを抽出できないので、値は常に‘0’となる。

WHOLE
     スクロールバーの全長のピクセル数。GTK+を含むいくつ
     かのツールキットでは、Emacsがこれらのデータを抽出で
     きないので、値は常に‘0’となる。

TIMESTAMP
     イベントが発生したミリ秒時刻。GTK+を含むいくつかの
     ツールキットでは、Emacsがこれらのデータを抽出できな
     いので、値は常に‘0’となる。

PART
     クリックが発生したスクロールバー部分。これはシンボ
     ル‘handle’(スクロールバーのハンドル)、
     ‘above-handle’(ハンドルの上側エリア)、
     ‘below-handle’(ハンドルの下側エリア)、‘up’(スクロー
     ルバー端の上矢印)、‘down’(スクロールバー端の下矢印
     )のいずれかである。


File: elisp,  Node: Drag Events,  Next: Button-Down Events,  Prev: Click Events,  Up: Input Events

20.7.5 Drag Events
------------------

Emacsでは、特別なことをしなくてもドラッグイベントを取得
できます。“ドラッグイベント(drag event)”は、ユーザーがマ
ウスボタンを押下して、ボタンをリリースする前に、マウスを
異なる文字位置に移動すると毎回発生します。すべてのマウス
イベントと同じように、ドラッグイベントはLispではリストで
表現されます。このリストは以下のように、開始マウス位置と
最終位置ぼ両方を記録します:

     (EVENT-TYPE
      (WINDOW1 START-POSITION)
      (WINDOW2 END-POSITION))

   ドラッグイベントにたいしては、シンボルEVENT-TYPEの名
前に、プレフィクス‘drag-’が含まれます。たとえば、ボタン
2を押下したままマウスをドラッグすると、‘drag-mouse-2’イ
ベントが生成されます。このイベントの2つ目と3つ目の要素は
、マウス位置リスト(*note Click Events::を参照)としてドラ
ッグの開始と終了の位置を与えます。任意のマウスイベントの
2つ目の要素には、同じ方法でアクセスできます。しかし、ド
ラッグイベントは最初に選択されていたフレームの境界外で終
了するかもしれません。この場合、3つ目の要素の位置リスト
に、ウィンドウのかわりにそのフレームが含まれます。

   ‘drag-’プレフィクスは、その後に‘C-’や‘M-’のような修飾
キープレフィクスが続きます。

   ‘read-key-sequence’がキーバインディングをもたず、対応
するクリックイベントにキーバインディングがあるようなドラ
ッグイベントを受け取った場合、この関数はそのドラッグイベ
ントをドラッグ開始位置でのクリックイベントに変更します。
これは、もし望まなければクリックイベントとドラッグイベン
トを区別する必要がないことを意味します。


File: elisp,  Node: Button-Down Events,  Next: Repeat Events,  Prev: Drag Events,  Up: Input Events

20.7.6 Button-Down Events
-------------------------

クリックイベントとドラッグイベントは、ユーザーがマウスボ
タンをリリースしたときに発生します。ボタンがリリースされ
るまでクリックとドラッグを区別することはできないので、リ
リース前にイベントが発生することはありません。

   ボタンが押下されたらすぐに何か処理したい場合は、“ボタ
ンダウン(button-down)”イベントを処理する必要があります
(1)。これらはEVENT-TYPEのシンボル名に‘down-’が含まれるこ
とを除き、クリックイベントとまったく同じようなリストによ
り表現されます。‘down-’プレフィクスの後には、‘C-’や
‘M-’のような修飾キープレフィクスが続きます。

   関数‘read-key-sequence’は、コマンドバインディングをも
たないボタンダウンイベントを無視します。したがって、
Emacsコマンドループもこれらを無視します。これは、ボタン
ダウンイベントで何かしたい場合以外は、ボタンダウンイベン
トの定義について心配する必要がないことを意味します。ボタ
ンダウンイベントを定義する通常の理由は、ボタンがリリース
されるまで(モーションイベントを読み取ることにより)マウス
モーションを追跡できるからです。*note Motion Events::を
参照してください。

   ---------- Footnotes ----------

   (1) ボタンダウン(button-down)はドラッグ(drag)の保守的
なアンチテーゼです(訳注: 原文は“Button-down is the
conservative antithesis of drag.”。ボタンダウンを着るよ
うな人種と麻薬を対比させたジョークのような気がしますが、
すいません、よく分からないので直訳します)。


File: elisp,  Node: Repeat Events,  Next: Motion Events,  Prev: Button-Down Events,  Up: Input Events

20.7.7 Repeat Events
--------------------

マウスを移動せずに同じマウスボタンを素早く2回以上連続し
て押下すると、Emacsは2回目とそれ以降の押下にたいして、特
別な“リピート(repeat)”マウスイベントを生成します。

   もっとも一般的なリピートイベントは、“ダブルクリック
(double-click)”イベントです。Emacsはボタンを2回クリック
したときに、ダブルクリックイベントを生成します。このイベ
ントは、(すべてのクリックイベントが通常そうであるように
)ボタンをリリースしたときに発生します。

   ダブルクリックイベントのイベント型には、プレフィクス
‘double-’が含まれます。したがって、<meta>を押しながら2つ
目のマウスボタンをダブルクリックすると、Lispプログラムに
は‘M-double-mouse-2’が渡されます。ダブルクリックイベント
がバインディングをもたない場合、対応する通常のクリックイ
ベントのバインディングが実行に使用されます。したがって、
実際に望んでいなければダブルクリック機能に注意を払う必要
はありません。

   ユーザーがダブルクリックを行うとき、Emacsはまず通常の
クリックイベントを生成し、その後ダブルクリックイベントを
生成します。したがって、ダブルクリックイベントのコマンド
バインディングは、すでにシングルクリックイベントが実行さ
れた想定でデザインしなければなりません。つまりシングルク
リックの結果から開始して、ダブルクリックの望むべき結果を
生成しなければならないのです。

   これはダブルクリックの意味合いが、シングルクリックの
意味合いの何らかにもとづいて“構築”される場合は便利です。
これはダブルクリックにたいするユーザーインターフェイスに
おける推奨されるデザインプラクティスです。

   ボタンをクリックした後もう一度ボタンを押下して、その
ままマウス一般的を開始した場合、最終的にボタンをリリース
したとき“ダブルドラッグ(double-drag)”イベントが取得され
ます。このイベント型には単なる‘drag’のかわりに
‘double-drag’が含まれます。ダブルドラッグイベントがバイ
ンディングをもたない場合、それがあたかも通常のドラッグイ
ベントだったかのようにEmacsはかわりのバインディングを探
します。

   ダブルクリックまたはダブルドラッグイベントの前に、
Emacsはユーザーが2回目にボタンを押したタイミングで“ダブ
ルダウン(double-down)”イベントを生成します。このイベント
型には、単なる‘down’のかわりに‘double-down’が含まれます
。ダブルダウンイベントがバインディングをもたない場合、そ
れがあたかも通常のボタンダウンイベントだったかのように
Emacsはかわりのバインディングを探します。どちらの方法で
もバインディングが見つからなかった場合、ダブルダウンイベ
ントは無視されます。

   要約すると、ボタンをクリックしてすぐにまた押したとき
、Emacsは1回目のクリックにたいしてダウンイベントとクリッ
クイベントを生成し、2回目に再度ボタンを押したときにダブ
ルダウンイベント、そして最後にダブルクリックまたはダブル
ドラッグイベントを生成します。

   ボタンを2回クリックした後もう一度押したとき、それらす
べてが素早く連続で行われた場合、Emacsは“トリプルダウン
(triple-down)”イベントと、その後続の“トリプルクリック
(triple-click)”または“トリプルドラッグ(triple-drag)”イベ
ントを生成します。これらイベントのイベント型には、
‘double’のかわりに‘triple’が含まれます。トリプルイベント
がバインディングをもたない場合、Emacsは対応するダブルイ
ベントに使用されるであろうバインディングを使用します。

   ボタンを3回以上クリックした後、再度ボタンを押した場合
、3回を超える押下にたいするイベントはすべてトリプルイベ
ントになります。Emacsはクワドループル(quadruple: 4連)、
クインティプル(quintuple: 5連)、...等のイベントにたいし
て個別のイベント型をもちません。しかし、ボタンが何回押下
されたかを正確に見つけるために、イベントリストを調べるこ
とができます。

 -- Function: event-click-count event
     この関数はEVENTを誘因した連続したボタン押下の回数を
     リターンする。EVENTがダブルダウン、ダブルクリック、
     ダブルドラッグの場合、値は2である。EVENTがトリプル
     イベントの場合、値は3以上になる。EVENTが(リピートイ
     ベントではない)通常のマウスイベントの場合、値は1で
     ある。

 -- User Option: double-click-fuzz
     リピートイベントを生成するためには、ほぼ同じスクリ
     ーン位置で連続でマウスボタンを押下しなければならな
     い。‘double-click-fuzz’の値は、ダブルクリックを生成
     するために連続する2回のクリック間で、マウスが移動
     (水平および垂直)するかもしれない最大ピクセル数を指
     定する。

     この変数はドラッグとみなされるマウスモーションの閾
     値でもある。

 -- User Option: double-click-time
     リピートイベントを生成するためには、連続するボタン
     押下のミリ秒間隔が、‘double-click-time’の値より小さ
     くなければならない。‘double-click-time’を‘nil’にセ
     ットすると、複数回クリック検知が完全に無効になる。
     ‘t’にセットすると、時間制限が取り除かれる。その場合
     、Emacsは位置だけで複数回クリックを検知する。


File: elisp,  Node: Motion Events,  Next: Focus Events,  Prev: Repeat Events,  Up: Input Events

20.7.8 Motion Events
--------------------

Emacsは、ボタンアクティビティが何もないマウスのモーショ
ン(motion: 動き)を記述する“マウスモーション(mouse
motion)”イベントを生成するときがあります。マウスモーショ
ンイベントは、以下のようなリストにより表現されます:

     (mouse-movement POSITION)

POSITIONは、マウスカーソルのカレント位置を指定するマウス
位置リスト(*note Click Events::)です。ドラッグイベントの
終了位置のように、この位置リストは最初に選択されていた境
界外の位置を表すかもしれず、その場合はそのフレーム内のそ
の位置のウィンドウが含まれる。

   スペシャルフォーム‘track-mouse’は、ボタン内でのモーシ
ョンイベントの生成を有効にします。‘track-mouse’フォーム
の外側では、Emacsはマウスの単なるモーションにたいするイ
ベントは生成せず、これらのイベントは発生しません。*note
Mouse Tracking::を参照してください。


File: elisp,  Node: Focus Events,  Next: Misc Events,  Prev: Motion Events,  Up: Input Events

20.7.9 Focus Events
-------------------

ウィンドウシステムは、ユーザーにたいしてどのウィンドウが
キーボード入力を受け取るか制御するための、一般的な方法を
提供します。このウィンドウ選択は“フォーカス(focus)”と呼
ばれます。Emacsのフレームを切り替えるためにユーザーが何
かを行うと、それは“フォーカスイベント(focus event)”を生
成します。フォーカスイベントの通常の定義はグローバルキー
マップ内にあり、ユーザーが期待するようにEmacsで新たなフ
レームを選択するためのものです。*Note Input Focus::を参
照してください。

   フォーカスイベントは、以下のようにLispのリストで表現
されます:

     (switch-frame NEW-FRAME)

ここでNEW-FRAMEは切り替え先のフレームです。

   Xウィンドウマネージャーには、あるウィンドウにマウスを
移動するだけで、そこにフォーカスされるようにセットアップ
するものがいくつかあります。通常は、他の種類の入力が到着
するまで、Lispプログラムがフォーカスの変更を知る必要はあ
りません。Emacsはユーザーが新たなフレーム内で実際にキー
ボードのキーをタイプするかマウスボタンを押下したときしか
、フォーカスイベントを生成しません。つまりフレーム間でマ
ウスを移動させても、フォーカスイベントは生成されません。

   キーシーケンスの途中におけるフォーカスイベントは、そ
のシーケンスを誤ったものにするかもしれません。そのため、
Emacsは決してキーシーケンスの途中でフォーカスイベントを
生成しません。ユーザーがキーシーケンスの途中(つまりプレ
フィクス引数の後)でフォーカスを変更した場合、複数イベン
トキーシーケンスの前か後にフォーカスイベントが到着するよ
うに、Emacsはフォーカスイベントを記録しておきます。


File: elisp,  Node: Misc Events,  Next: Event Examples,  Prev: Focus Events,  Up: Input Events

20.7.10 Miscellaneous System Events
-----------------------------------

他にもシステム内での出来事を表現するイベント型が少数あり
ます。

‘(delete-frame (FRAME))’
     このイベントの種類は、ユーザーがウィンドウマネージ
     ャーに特定のウィンドウを削除するコマンドを与えたこ
     とを示し、Emacsのフレームにたいして発生する。

     ‘フレーム削除(delete-frame)’イベントの標準的な定義
     は、FRAMEを削除する。

‘(iconify-frame (FRAME))’
     このイベントの種類は、ウィンドウマネージャーを使用
     してユーザーがFRAMEをアイコン化したことを示す。標準
     的な定義は‘ignore’である。これは、そのフレームがす
     でにアイコン化されているので、Emacsが行う必要のこと
     は何もないからである。このイベント型の目的は、望む
     ならこのようなイベントの追跡を可能にしておくためで
     ある。

‘(make-frame-visible (FRAME))’
     このイベントの種類は、ウィンドウマネージャーを使用
     してユーザーがFRAMEを非アイコン化したことを示す。標
     準的な定義は‘ignore’である。これは、そのフレームが
     すでに可視化されているので、Emacsが行う必要のことは
     何もないからである。

‘(wheel-up POSITION)’
‘(wheel-down POSITION)’
     この種類のイベントは、マウスホイールを移動したこと
     により発生する。POSITION要素は、そのイベント発生時
     のマウスカーソル位置を指定するマウス位置リスト
     (*note Click Events::を参照)である。

     この種類のイベントは、ある種のシステムでのみ発生す
     る。いくつかのシステムでは、かわりに‘mouse-4’と
     ‘mouse-5’が使用される。可搬性のあるコードとするため
     には、マウスホイールにたいしてどのイベント型が期待
     されるかを決定するために‘mwheel.el’内で定義されてい
     る変数‘mouse-wheel-up-event’および
     ‘mouse-wheel-down-event’を使用する。

‘(drag-n-drop POSITION FILES)’
     この種類のイベントは、Emacs外部アプリケーション内で
     ファイルグループが選択され、それがEmacsフレーム内に
     ドラッグアンドドロップされたときに発生する。

     要素POSITIONは、そのイベント位置を記述しマウスクリ
     ックイベントで使用されるフォーマット(*note Click
     Events::を参照)と同じである。要素FILESはドラッグア
     ンドドロップされたファイル名のリストである。通常は
     、それらのファイルをvisitすることにより、このイベン
     トは処理される。

     この種類のイベントは、現在のところある種のシステム
     でのみ生成される。

‘help-echo’
     この種類のイベントは、テキストプロパティ
     ‘help-echo’をもつバッファーテキスト部分上にマウスポ
     インターが移動したときに生成される。生成されるイベ
     ントは以下の形式をもつ:

          (help-echo FRAME HELP WINDOW OBJECT POS)

     イベントパラメーターの正確な意味と、ヘルプテキスト
     を表示するためにこれらのパラメーターを使用する方法
     は、*note Text help-echo::で説明されているか

‘sigusr1’
‘sigusr2’
     これらのイベントは、Emacsプロセスがシグナル
     ‘SIGUSR1’および‘SIGUSR2’を受け取ったときに生成され
     る。シグナルは追加情報を運搬しないので、追加データ
     は含まれない。これらのシグナルはデバッグに有用であ
     る(*note Error Debugging::を参照)。

     ユーザーシグナルをcatchするためには、
     ‘special-event-map’(*note Active Keymaps::を参照)内
     で対応するイベントにバインドする。そのコマンドは引
     数なしで呼び出され、‘last-input-event’内の特定のシ
     グナルイベントが利用できる。たとえば:

          (defun sigusr-handler ()
            (interactive)
            (message "Caught signal %S" last-input-event))

          (define-key special-event-map [sigusr1] 'sigusr-handler)

     シグナルハンドラーをテストするために、自身でEmacsに
     シグナルを送信できる:

          (signal-process (emacs-pid) 'sigusr1)

‘language-change’
     この種類のイベントは、MS-Windows上で入力言語が変更
     されたときに生成される。これは通常、キーボードキー
     が異なる言語の文字でEmacsに送られることを意味する。
     生成されるイベントは、以下の形式をもつ:

          (language-change FRAME CODEPAGE LANGUAGE-ID)

     ここでFRAMEは言語が変更されたときカレントだったフレ
     ームであり、CODEPAGEは新たなコードページ番号
     (codepage number)、LANGUAGE-IDは新たな入力言語の数
     値IDである。CODEPAGEに対応するコーディングシステム
     (*note Coding Systems::を参照)は、‘cpCODEPAGE’また
     は‘windows-CODEPAGE’である。LANGUAGE-IDを文字列に変
     更する(たとえば‘set-language-environment’のようなさ
     まざまな言語依存機能にたいしこれを使用する)には、以
     下のように‘w32-get-locale-info’関数を使用する:

          ;; 英語にたいする"ENU"のような言語の省略形を取得する
          (w32-get-locale-info language-id)
          ;; "English (United States)"のような
          ;; その言語の完全な英語名を取得する
          (w32-get-locale-info language-id 4097)
          ;; その言語の完全なローカライズ名を取得する
          (w32-get-locale-info language-id t)

   キーシーケンスの途中、つまりプレフィクスキーの後にこ
れらのイベントの1つが到着した場合、複数イベントキー内で
はなくその前または後にそのイベントが到着するように、
Emacsはそのイベントを記録する。


File: elisp,  Node: Event Examples,  Next: Classifying Events,  Prev: Misc Events,  Up: Input Events

20.7.11 Event Examples
----------------------

ユーザーが同じ場所でマウス左ボタンを押して離した場合、そ
れは以下のようなイベントシーケンスを生成します:

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

   コントロールキーを押したままユーザーがマウス第2ボタン
を押してマウスをある行から次の行へドラッグした場合、以下
のような2つのイベントが生成されます:

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

   メタキーとシフトキーを押したままユーザーがそのウィン
ドウのモードライン上でマウス第2ボタンを押して他ウィンド
ウへマウスをドラッグした場合、以下のようなイベントのペア
ーが生成されます:

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))

   全画面表示されていないフレームに入力フォーカスがあり
、ユーザーがマウスをそのフレームのスコープ外へマウスを移
動した場合、スペシャルフォーム‘track-mouse’内では以下の
ようなイベントが生成されます:

     (mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))

   SIGUSR1シグナルを処理するためにはインタラクティブ関数
を定義して、それを‘signal usr1’イベントシーケンスにバイ
ンドします:

     (defun usr1-handler ()
       (interactive)
       (message "Got USR1 signal"))
     (global-set-key [signal usr1] 'usr1-handler)


File: elisp,  Node: Classifying Events,  Next: Accessing Mouse,  Prev: Event Examples,  Up: Input Events

20.7.12 Classifying Events
--------------------------

すべてのイベントは“イベント型(event type)”をもちます。イ
ベント型はキーバインディング目的でイベントをクラス分けし
ます。キーボードイベントにたいするイベント型はイベント値
と等しく、したがって文字のイベント型は文字、ファンクショ
ンキーシンボルのイベント型はそのシンボル自身です。リスト
であるようなイベントのイベント型は、そのリストのCAR内の
シンボルです。したがって、イベント型は常にシンボルか文字
です。

   同じ型の２つのイベントはキーバインディングに関する限
り同じです。したがって、それらは常に同じコマンドを実行し
ます。これらが同じことを行う必要があるという意味ではあり
ませんが、イベント全体を調べてから何を行うか決定するコマ
ンドもいくつかあります。、たとえば、バッファー内でどこに
作用するか決定するためにマウスイベントの場所を使用するコ
マンドもいくつかあります。

   広範なイベントのクラス分けが役に立つときもあります。
たとえば、他の修飾キーやマウスボタンが使用されたかとは無
関係に、<META>キーとともに呼び出されたイベントを尋ねたい
と思うかもしれません。

   関数‘event-modifiers’は‘event-basic-type’は、そのよう
な情報を手軽に取得するために提供されています。

 -- Function: event-modifiers event
     この関数は、EVENTがもつ修飾子のリストをリターンする
     。この修飾子はシンボルであり‘shift’、‘control’、
     ‘meta’、‘alt’、‘hyper’、‘super’が含まれる。さらにマ
     ウスイベントシンボルの修飾子リストには常に‘click’、
     ‘drag’、‘down’のいずれか1つが含まれる。ダブルイベン
     トまたはトリプルイベントには‘double’または
     ‘triple’も含まれる。

     引数EVENTはイベントオブジェクト全体、または単なるイ
     ベント型かもしれない。EVENTがカレントEmacsセッショ
     ン内で入力として読み取られたイベント内で決して使用
     されないシンボルの場合は、実際にEVENTが変更されたと
     きでも、‘event-modifiers’は‘nil’をリターンできる。

     いくつか例を挙げる:

          (event-modifiers ?a)
               ⇒ nil
          (event-modifiers ?A)
               ⇒ (shift)
          (event-modifiers ?\C-a)
               ⇒ (control)
          (event-modifiers ?\C-%)
               ⇒ (control)
          (event-modifiers ?\C-\S-a)
               ⇒ (control shift)
          (event-modifiers 'f5)
               ⇒ nil
          (event-modifiers 's-f5)
               ⇒ (super)
          (event-modifiers 'M-S-f5)
               ⇒ (meta shift)
          (event-modifiers 'mouse-1)
               ⇒ (click)
          (event-modifiers 'down-mouse-1)
               ⇒ (down)

     クリックイベントにたいする修飾リストは明示的に
     ‘click’を含むが、イベントシンボル名自身は‘click’を
     含まない。

 -- Function: event-basic-type event
     この関数はEVENTを記述するキー、またはマウスボタンを
     リターンする。EVENT引数は‘event-modifiers’の場合と
     同様。たとえば:

          (event-basic-type ?a)
               ⇒ 97
          (event-basic-type ?A)
               ⇒ 97
          (event-basic-type ?\C-a)
               ⇒ 97
          (event-basic-type ?\C-\S-a)
               ⇒ 97
          (event-basic-type 'f5)
               ⇒ f5
          (event-basic-type 's-f5)
               ⇒ f5
          (event-basic-type 'M-S-f5)
               ⇒ f5
          (event-basic-type 'down-mouse-1)
               ⇒ mouse-1

 -- Function: mouse-movement-p object
     OBJECTがマウス移動イベントの場合、この関数は非
     ‘nil’をリターンする。

 -- Function: event-convert-list list
     この関数は修飾子名リストと基本イベント型(basic
     event type)を、それらすべてを指定するイベント型に変
     換する。基本イベント型はそのリストの最後の要素でな
     ければならない。たとえば、

          (event-convert-list '(control ?a))
               ⇒ 1
          (event-convert-list '(control meta ?a))
               ⇒ -134217727
          (event-convert-list '(control super f1))
               ⇒ C-s-f1


File: elisp,  Node: Accessing Mouse,  Next: Accessing Scroll,  Prev: Classifying Events,  Up: Input Events

20.7.13 Accessing Mouse Events
------------------------------

このセクションではマウスボタンやモーションイベント内のデ
ータアクセスに役に立つ関数を説明します。同じ関数を使用し
てキーボードイベントデータにもアクセスできますが、キーボ
ードイベントに不適切なデータ要素は0または‘nil’になります
。

   以下の2つの関数は、マウスイベントの位置を指定するマウ
ス位置リスト(*note Click Events::)をリターンします。

 -- Function: event-start event
     これはEVENTの開始位置をリターンする。

     EVENTがクリックイベントまたはボタンダウンイベントの
     場合、この関数はそのイベントの位置をリターンする。
     EVENTがドラッグイベントの場合は、そのドラッグの開始
     位置をリターンする。

 -- Function: event-end event
     これはEVENTの終了位置をリターンする。

     EVENTがドラッグイベントの場合、この関数はユーザーが
     マウスボタンをリリースした位置をリターンする。
     EVENTがクリックイベントまたはボタンダウンイベントの
     場合、値はそのイベント固有の開始位置となる。

 -- Function: posnp object
     この関数はOBJECTが(*note Click Events::に記述された
     いずれかのフォーマットの)マウス位置リストの場合は非
     ‘nil’、それ以外では‘nil’をリターンする。

   以下の関数は、引数にマウス位置リストをとり、そのリス
トのさまざまな部分をリターンします:

 -- Function: posn-window position
     POSITIONがあったウィンドウをリターンする。
     POSITIONが最初イベントがあったフレーム外の位置を表
     す場合は、かわりにそのフレームをリターンする。

 -- Function: posn-area position
     POSITION内に記録されたウィンドウエリアをリターンす
     る。そのウィンドウのテキストエリアでイベントが発生
     したときは‘nil’、それ以外ではイベントがどこで発生し
     たかを識別するシンボルをリターンする。

 -- Function: posn-point position
     POSITION内のバッファー位置をリターンする。ウィンド
     ウのテキストエリア、マージンエリア、フリンジでイベ
     ントが発生したときは、バッファー位置を識別する整数
     値、それ以外では値は未定義である。

 -- Function: posn-x-y position
     POSITION内のピクセル単位のxy座標を、コンスセル‘(X .
     Y)’でリターンする。これらは‘posn-window’により与え
     られるウィンドウにたいする相対座標である。

     以下は、あるウィンドウのテキストエリア内のウィンド
     ウ相対座標をフレーム相対座標に変換する方法を示す例
     である:

          (defun frame-relative-coordinates (position)
            "POSITIONのフレーム相対座標をリターンする。
          POSITIONはウィンドウのテキストエリアにあるものとする。"
            (let* ((x-y (posn-x-y position))
                   (window (posn-window position))
                   (edges (window-inside-pixel-edges window)))
              (cons (+ (car x-y) (car edges))
                    (+ (cdr x-y) (cadr edges)))))

 -- Function: posn-col-row position
     この関数は、POSITION内のバッファー位置にたいして推
     定される列と行を含むコンスセル‘(COL . ROW)’をリター
     ンする。リターン値は、POSITIONにたいするXとYの値よ
     り計算され、そのフレームのデフォルト文字幅とデフォ
     ルト行高(行間スペースを含む)の単位で与えられる(その
     ため、実際の文字サイズが非デフォルト値の場合には、
     実際の行と列は、これらの計算された値とは異なるかも
     しれない)。

     ROWは、そのテキストエリアの上端から数えられることに
     注意すること。POSITIONにより与えられるウィンドウが
     ヘッダーライン(*note Header Lines::)をもつ場合、そ
     のヘッダーラインはROWの数に_含まない_。

 -- Function: posn-actual-col-row position
     POSITION内の実際の行と列を、コンスセル‘(COL .
     ROW)’でリターンする。値はPOSITION与えられるウィンド
     ウの実際の行と列である。*note Click Events::を参照
     のこと。POSITIONが実際のポジション値を含まない場合
     、この関数は‘nil’をリターンする。この場合、おおよそ
     の値を取得するために‘posn-col-row’を使用できる。

     この関数は、タブ文字やイメージによるビジュアル列数
     のように、ディスプレイ上の文字のビジュアル幅を意味
     しない。標準的な文字単位の座標が必要ｎ場合は、かわ
     りに‘posn-col-row’を使用すること。

 -- Function: posn-string position
     POSITION内の文字列オブジェクトをを‘nil’、またはコン
     スセル‘(STRING . STRING-POS)’でリターンする。

 -- Function: posn-image position
     POSITION内のイメージオブジェクトを‘nil’、または
     ‘(image ...)’でリターンする。

 -- Function: posn-object position
     POSITION内のイメージオブジェクト、または文字列オブ
     ジェクトを‘nil’、イメージ‘(image ...)’、またはコン
     スセル‘(STRING . STRING-POS)’でリターンする。

 -- Function: posn-object-x-y position
     POSITION内のオブジェクトの左上隅からのピクセル単位
     のxy座標を、コンスセル‘(DX . DY)’でリターンする。
     POSITIONがバッファーテキストの場合は、その位置にも
     っとも近いバッファーテキストの相対位置をリターンす
     る。

 -- Function: posn-object-width-height position
     POSITION内のオブジェクトのピクセル幅とピクセル高さ
     を、コンスセル‘(WIDTH . HEIGHT)’でリターンする。
     POSITIONがバッファー位置の場合は、その位置の文字の
     サイズをリターンする。

 -- Function: posn-timestamp position
     POSITION内のタイムスタンプをリターンする。これはミ
     リ秒で表されたイベント発生時刻である。

   以下の関数は与えられた特定のバッファー、またはスクリ
ーン位置により与えられる位置リストを計算します。上述の関
数で、この位置リスト内のデータにアクセスできます。

 -- Function: posn-at-point &optional pos window
     この関数は位置POS in WINDOWにたいする位置リストをリ
     ターンする。POSのデフォルトはWINDOW内のポイントであ
     り、WINDOWのデフォルトは選択されたウィンドウである
     。

     WINDOW内でPOSが不可視の場合、‘posn-at-point’は
     ‘nil’をリターンする。

 -- Function: posn-at-x-y x y &optional frame-or-window
          whole
     この関数は、指定されたフレームまたはウィンドウ
     FRAME-OR-WINDOW(デフォルトは選択されたウィンドウ)内
     のピクセル座標XとYに対応する位置情報をリターンする
     。XとYは、使用されたフレームまたはウィンドウにたい
     する相対座標である。WHOLEが‘nil’の場合、座標はウィ
     ンドウのテキストエリアにたいする相対座標であり、そ
     れ以外ではスクロールバー、マージン、フリンジを含む
     ウィンドウエリア全体にたいする相対座標である。


File: elisp,  Node: Accessing Scroll,  Next: Strings of Events,  Prev: Accessing Mouse,  Up: Input Events

20.7.14 Accessing Scroll Bar Events
-----------------------------------

以下の関数は、スクロールバーイベントの解析に役立ちます。

 -- Function: scroll-bar-event-ratio event
     この関数はスクロールバーで発生したスクロールバーイ
     ベントの位置の垂直位置割り合いをリターンする。値は
     位置の割り合いを表す2つの整数を含むコンスセル
     ‘(PORTION . WHOLE)’である。

 -- Function: scroll-bar-scale ratio total
     この関数は、(実質的には)RATIOにTOTALを乗じて、結果
     を整数に丸める。引数RATIOは数字ではなく、
     ‘scroll-bar-event-ratio’によりリターンされる典型的
     な値ペアー‘(NUM . DENOM)’である。

     この関数はスクロールバー位置をバッファー位置にスケ
     ーリングするのに便利である。以下のようにこれを行う:

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     スクロールバーイベントは、xy座標ペアーのかわりに割
     り合いを構成する2つの整数をもつことを思い出してほし
     い。


File: elisp,  Node: Strings of Events,  Prev: Accessing Scroll,  Up: Input Events

20.7.15 Putting Keyboard Events in Strings
------------------------------------------

文字列が使用される場所のほとんどにおいて、わたしたちはテ
キスト文字を含むもの、つまりバッファーやファイル内で見出
すのと同種のものとして、文字列を概念化します。Lispプログ
ラムはときおり、キーボード文字、たとえばキーシーケンスや
キーボードマクロ定義かもしれないキーボード文字を概念的に
含む文字列を使用します。しかし文字列内へのキーボード文字
の格納は、歴史的な互換性の理由により複雑な問題であり、常
に可能なわけではありません。

   新たに記述するプログラムでは文字列内にキーボードイベ
ントを格納しないことにより、これらの複雑さを扱うことを避
けるよう推奨します。以下はこれを行う方法です:

   • ‘lookup-key’および‘define-key’の引数として使用する
     のでなければ、キーシーケンスにたいして文字列のかわ
     りにベクターを使用する。たとえば、
     ‘read-key-sequence’のかわりに
     ‘read-key-sequence-vector’、‘this-command-keys’のか
     わりに‘this-command-keys-vector’を使用できる。

   • メタ文字を含むキーシーケンス定数を記述する際は、た
     とえそれを直接‘define-key’に渡す場合でもベクターを
     使用する。

   • 文字列かもしれないキーシーケンスの内容を調べる必要
     があるときは、それをリストに変換するために最初に
     ‘listify-key-sequence’(*note Event Input Misc::を参
     照)を使用する。

   複雑さはキーボード入力に含まれるかもしれない修飾ビッ
トに起因します。メタ修飾以外の修飾ビットは文字列に含める
ことができず、メタ文字も特別な場合だけ許されます。

   GNU Emacsの初期のバージョンでは、メタ文字を128から
255のコードで表していました。その頃は基本文字コードの範
囲は0から127だったので、すべてのキーボード文字を文字列内
に適合させることができました。Lispプログラムの多くは、特
に‘define-key’やその種の関数の引数として文字列定数内にメ
タ文字を意味する‘\M-’を使用し、キーシーケンスとイベント
シーケンスは常に文字列として表現されていました。

   127を超えるより大きい基本文字コードと追加の修飾ビット
にたいするサポートを加えたとき、わたしたちはメタ文字の表
現を変更する必要がありました。現在では文字のメタ修飾を表
すフラグは 2**27 であり、そのような値は文字列内に含める
ことができません。

   プログラムで文字列定数内の‘\M-’をサポートするために、
文字列内に特定のメタ文字を含めるための特別なルールがあり
ます。以下は入力文字シーケンスとして文字列を解釈するため
のルールです:

   • キーボード文字の値の範囲が0から127の場合は、文字列
     を変更せずに含めることができる。

   • これらの文字のコード 2**27 から 2**27+127, までの範
     囲のメタ修飾された変種も文字列に含めることができる
     が、それらの数値を変更しなければならない。値が128か
     ら255の範囲となるように、ビット 2**7 のかわりにビッ
     ト 2**27 をセットしなければならない。ユニバイト文字
     列だけがこれらの文字を含むことができる。

   • 265を超える非ASCII文字はマルチバイト文字に含めるこ
     とができる。

   • その他のキーボード文字イベントは文字列に適合させら
     れない。これには128から255の範囲のキーボードイベン
     トが含まれる。

   キーボード入力文字の文字列定数を構築する
‘read-key-sequence’のような関数は、イベントが文字列内に
適合しないときは文字列のかわりにベクターを構築するという
ルールにしたがいます。

   文字列内で入力構文‘\M-’を使用すると、それは128から
255の範囲のコード、つまり対応するキーボードイベントを文
字列内に配すために変更するとき取得されるのと同じコードが
生成されます。したがって文字列内のメタイベントは、それが
文字列内にどのように配置されたかと無関係に一貫して機能し
ます。

   しかし、ほとんどのプログラムはこのセクションの冒頭の
推奨にしたがって、これらの問題を避けるほうがよいでしょう
。


File: elisp,  Node: Reading Input,  Next: Special Events,  Prev: Input Events,  Up: Command Loop

20.8 Reading Input
==================

エディターコマンドループはキーシーケンスの読み取りに関数
‘read-key-sequence’を使用し、この関数は‘read-event’を使
用します。イベント入力にたいしてこれらの関数、およびその
他の関数がLisp関数から利用できます。*note Temporary
Displays::の‘momentary-string-display’、および*note
Waiting::の‘sit-for’も参照してください。端末の入力モード
の制御、および端末入力のデバッグに関する関数と変数につい
ては、*note Terminal Input::を参照してください。

   高レベル入力機能については*note Minibuffers::を参照し
てください。

* Menu:

* Key Sequence Input::       キーシーケンスを読み取る方法。
* Reading One Event::        イベントを1つだけ読み取る方法。
* Event Mod::                Emacsが読み取られたイベントを変更する方法。
* Invoking the Input Method::  入力メソッドを使用するイベントを読み取る方法。
* Quoted Character Input::   文字の指定をユーザーに問い合わせる。
* Event Input Misc::         入力イベントの最読み取りや破棄の方法。


File: elisp,  Node: Key Sequence Input,  Next: Reading One Event,  Up: Reading Input

20.8.1 Key Sequence Input
-------------------------

コマンドループは‘read-key-sequence’を呼び出すことにより
、キーシーケンスの入力を一度に読み取ります。Lisp関数もこ
の関数を呼び出すことができます。たとえば‘describe-key’は
キーを説明するためにこの関数を使用します。

 -- Function: read-key-sequence prompt &optional
          continue-echo dont-downcase-last
          switch-frame-ok command-loop
     この関数はキーシーケンスを読み取り、それを文字列ま
     たはベクターでリターンする。この関数は完全なキーシ
     ーケンスに蓄積されるまで、つまりカレントでアクティ
     ブなキーマップを使用してプレフィクスなしでコマンド
     を指定するのに十分なキーシーケンスとなるまでイベン
     トの読み取りを継続する(マウスイベントで始まるキーシ
     ーケンスは、カレントバッファーではなくマウスのあっ
     たウィンドウ内のバッファーのキーマップを使用して読
     み取られることを思い出してほしい)。

     イベントがすべて文字で、それらがすべて文字列に適合
     する場合、‘read-key-sequence’は文字列をリターンする
     (*note Strings of Events::を参照)。それ以外の場合は
     文字、シンボル、リストなどすべての種類のイベントを
     保持できるベクターをリターンする。文字列またはベク
     ターの要素は、キーシーケンス内のイベントである。

     キーシーケンスのo読み取りには、そのイベントを変換す
     るさまざまな方法が含まれる。*note Translation
     Keymaps::を参照のこと。

     引数PROMPTはプロンプトとしてエコーエリアに表示され
     る文字列か、プロンプトを表示しない‘nil’である。引数
     CONTINUE-ECHOが非‘nil’の場合、それは前のキーの継続
     としてそのキーをエコーすることを意味する。

     通常、元となる大文字のイベントが未定義で、それと等
     価な小文字イベントが定義されている場合、大文字のイ
     ベントは小文字のイベントに変換される。引数
     DONT-DOWNCASE-LASTが非‘nil’の場合、それは最後のイベ
     ントを小文字に変換しないことを意味する。これはキー
     シーケンスを定義するときに適している。

     引数SWITCH-FRAME-OKが非‘nil’の場合は、たとえ何かを
     タイプする前にユーザーがフレームを切り替えたとして
     も、この関数が‘switch-frame’を処理すべきでないこと
     を意味する。キーシーケンスの途中でユーザーがフレー
     ムを切り替えた場合、またはシーケンスの最初だが
     SWITCH-FRAME-OKが‘nil’のときにフレームを切り替えた
     場合、そのイベントはカレントキーシーケンスの後に延
     期される。

     引数COMMAND-LOOPが非‘nil’の場合は、そのキーシーケン
     スがコマンドを逐次読み取る何かによりa読み取られるこ
     とを意味する。呼び出し側が1つのキーシーケンスだけを
     読み取る場合は、‘nil’を指定すべきである。

     以下の例では、Emacsはエコーエリアにプロンプト‘?’を
     表示して、その後ユーザーが‘C-x C-f’をタイプしている
     。

          (read-key-sequence "?")

          ---------- Echo Area ----------
          ?C-x C-f
          ---------- Echo Area ----------

               ⇒ "^X^F"

     関数‘read-key-sequence’はquitを抑制する。この関数に
     よる読み取りの間にタイプされた‘C-g’は他の文字と同じ
     ように機能し、‘quit-flag’をaセットしない。*note
     Quitting::を参照のこと。

 -- Function: read-key-sequence-vector prompt &optional
          continue-echo dont-downcase-last
          switch-frame-ok command-loop
     これは‘read-key-sequence’と同様だが、キーシーケンス
     を常にベクターでリターンし、文字列では決してリター
     ンしない点が異なる。*note Strings of Events::を参照
     のこと。

   入力文字が大文字(またはシフト修飾をもつ)で、キーバイ
ンディングをもたないが、等価な小文字はキーバインディング
をもつ場合、‘read-key-sequence’はその文字を小文字に変換
します。‘lookup-key’はこの方法による大文字小文字変換を行
わないことに注意してください。

   入力を読み取った結果が“シフト変換
(shift-translation)”されていたような場合、Emacsは変数
‘this-command-keys-shift-translated’に非‘nil’値をセット
します。シフト変換されたキーにより呼びだされたときは挙動
を変更する必要があるLispプログラムは、この変数を調べるこ
とができます。たとえば、関数‘handle-shift-selection’はリ
ージョンをアクティブ、または非アクティブにするか判断する
ためにこの変数の値を調べます(*note
handle-shift-selection: The Mark.を参照)。

   この関数‘read-key-sequence’も、マウスイベントのいくつ
かを変換します。これはバインドされていないドラッグイベン
トをクリックイベントに変換し、バインドされていないボタン
ダウンイベントを完全に破棄します。さらにフォーカスイベン
トとさまざまなウィンドウイベントの再配置も行うため、これ
らのイベントはキーシーケンス中に他のイベントとともに決し
て出現しません。

   モードラインやスクロールバーのようなウィンドウの特別
な箇所でマウスイベントが発生したとき、そのイベント型は特
別なことは何も示さず、マウスボタンと修飾キーの組み合わせ
を通常表すのと同じシンボルになります。ウィンドウの箇所に
ついての情報はイベント内の別のどこか、すなわち座標に保持
されています。しかし‘read-key-sequence’はこの情報を仮想
的な“プレフィクスキー”に変換します。これらはすべてシンボ
ルであり‘header-line’、‘horizontal-scroll-bar’、
‘menu-bar’、‘mode-line’、‘vertical-line’、
‘vertical-scroll-bar’です。これらの仮想的なプレフィクス
キーを使用してキーシーケンスを定義することにより、ウィン
ドウの特別な部分でのカウスクリックにたいして意味を定義で
きます。

   たとえば、‘read-key-sequence’を呼び出した後にそのウィ
ンドウのモードラインをマウスでクリックすると、以下のよう
に2つのマウスイベントが取得されます:

     (read-key-sequence "Click on the mode line: ")
          ⇒ [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]

 -- Variable: num-input-keys
     この変数の値は、そのEmacsセッション内で処理されたキ
     ーシーケンスの数である。これには端末からのキーシー
     ケンスと、実行されるキーボードマクロにより読み取ら
     れたキーシーケンスが含まれる。


File: elisp,  Node: Reading One Event,  Next: Event Mod,  Prev: Key Sequence Input,  Up: Reading Input

20.8.2 Reading One Event
------------------------

‘read-event’,‘read-char’、‘read-char-exclusive’は、コマ
ンド入力にたいするもっとも低レベルの関数です。

 -- Function: read-event &optional prompt
          inherit-input-method seconds
     この関数はコマンド入力の次のイベントを読み取り、リ
     ターンする。必要ならイベントが利用可能になるまで待
     機する。

     リターンされるイベントはユーザーから直接のイベント
     かもしれないし、またはキーボードマクロからのイベン
     トかもしれない。イベントはキーボードの入力コーディ
     ングシステム(*note Terminal I/O Encoding::を参照)に
     より復号されない。

     オプション引数PROMPTが非‘nil’の場合、それはエコーエ
     リアにプロンプトとして表示される文字列である。
     ‘nil’の場合、‘read-event’は入力待ちを示すメッセージ
     を何も表示せず、エコーを行うことによりプロンプトの
     代用とする。エコーで表示されるのはカレントコマンド
     に至ったイベントや読み取られたイベントの説明である
     。*note The Echo Area::を参照のこと。

     INHERIT-INPUT-METHODが非‘nil’の場合、(もしあれば)非
     ASCII文字の入力を可能にするためにカレントの入力メソ
     ッドが採用される。それ以外では、このイベントの読み
     取りにたいして入力メソッドの処理が無効になる。

     ‘cursor-in-echo-area’が非‘nil’の場合、
     ‘read-event’はカーソルを一時的にエコーエリアの、そ
     こに表示されているメッセージの終端に移動する。それ
     以外では、‘read-event’はカーソルを移動しない。

     SECONDSが非‘nil’の場合、それは入力を待つ最大秒数を
     指定する数値である。その時間内に入力が何も到着しな
     い場合、‘read-event’は待機を終えて‘nil’をリターンす
     る。浮動小数点数SECONDSは待機する秒の分数を意味する
     。いくつかのシステムではサポートされるのは整数の秒
     数だけであり、そのようなシステムではSECONDSは切り捨
     てられる。SECONDSが‘nil’の場合、‘read-event’は入力
     が到着するのに必要なだけ待機する。

     SECONDSが‘nil’の場合、ユーザー入力が到着するのを待
     つ間、Emacsはアイドル状態にあるとみなされる。この期
     間中にアイドルタイマー —
     ‘run-with-idle-timer’(*note Idle Timers::を参照) —
     を実行できる。しかしSECONDSが非‘nil’の場合には、非
     アイドル状態は変更されずに残る。‘read-event’が呼び
     出されたときEmacsが非アイドルだった場合、
     ‘read-event’の処理を通じて非アイドルのままとなる。
     Emacsがアイドルだった場合(これはアイドルタイマー内
     部からその呼び出しが行われた場合に起こり得る)は、ア
     イドルのままとまる。

     ‘read-event’がヘルプ文字として定義されたイベントを
     取得した場合、ある状況においては‘read-event’がリタ
     ーンせずに直接イベントを処理することがある。*note
     Help Functions::を参照のこと。その他の“スペシャルイ
     ベント(special events)”(*note Special Events::を参
     照)と呼ばれる特定のイベントも‘read-event’で直接処理
     される。

     以下は‘read-event’を呼び出してから右矢印キーを押下
     したとき何が起こるかの例である:

          (read-event)
               ⇒ right

 -- Function: read-char &optional prompt
          inherit-input-method seconds
     この関数はコマンド入力の文字を読み取り、それをリタ
     ーンする。ユーザーが文字以外(たとえばマウスクリック
     やファンクションキー)のイベントを生成した場合、
     ‘read-char’はエラーをシグナルする。引数は
     ‘read-event’と同じように機能する。

     1つ目の例では、ユーザーは文字‘1’(ASCIIコード49)をタ
     イプしている。2つ目の例では、‘eval-expression’を使
     用してミニバッファーから‘read-char’を呼び出すキーボ
     ード定義を示している。‘read-char’は、キーボードマク
     ロの直後の文字‘1’を読み取る。その後、
     ‘eval-expression’はリターン値をエコーエリアに表示す
     る。

          (read-char)
               ⇒ 49

          ;; ‘M-:’を使用して以下を評価するものとする
          (symbol-function 'foo)
               ⇒ "^[:(read-char)^M1"
          (execute-kbd-macro 'foo)
               ⊣ 49
               ⇒ nil

 -- Function: read-char-exclusive &optional prompt
          inherit-input-method seconds
     この関数はコマンド入力の文字を読み取り、それをリタ
     ーンする。ユーザーが文字以外のイベントを生成した場
     合、‘read-char-exclusive’はそれを無視して文字を取得
     するまで他のイベントを読み取る。引数は
     ‘read-event’と同じように機能する。

   上記でquitを抑制する関数はありません。

 -- Variable: num-nonmacro-input-events
     この変数は端末から受信した入力イベント(キーボードマ
     クロにより生成されたイベントは勘定されない)の総数を
     保持する。

   ‘read-key-sequence’と異なり、関数‘read-event’、
‘read-char’、‘read-char-exclusive’は*note Translation
Keymaps::で説明した変換を行わないことを強調しておきます
。単一キー読み取りでこれらの変換を行いたい場合は、関数
‘read-key’を使用してください。

 -- Function: read-key &optional prompt
     この関数は1つのキーを読み取る。これは
     ‘read-key-sequence’と‘read-event’の間の“中間的”な関
     数である。‘read-key-sequence’と異なるのは、キーシー
     ケンスではなく単一キーを読み取ることである。
     ‘read-event’と異なるのは、rawイベントをリターンせず
     に‘input-decode-map’、‘local-function-key-map’、
     ‘key-translation-map’(*note Translation Keymaps::を
     参照)に合わせて復号と変換を行うことである。

     引数PROMPTはプロンプトとしてエコーエリアに表示する
     文字列で、‘nil’はプロンプトを表示しないことを意味す
     る。

 -- Function: read-char-choice prompt chars &optional
          inhibit-quit
     この関数は1つの文字を読み取りリターンするために
     ‘read-key’を使用する。これはCHARS(許容される文字の
     リスト)のメンバー以外の入力を無視する。オプションで
     、有効な入力を待つ間のquitイベントも無視する。
     ‘read-char-choice’呼び出しの間に‘help-form’(*note
     Help Functions::を参照)を非‘nil’値にバインドした場
     合、‘help-char’の押下により‘help-form’が評価され結
     果が表示される。その後、有効な入力文字、またはキー
     ボードquitの待機を継続する。


File: elisp,  Node: Event Mod,  Next: Invoking the Input Method,  Prev: Reading One Event,  Up: Reading Input

20.8.3 Modifying and Translating Input Events
---------------------------------------------

Emacsは‘extra-keyboard-modifiers’に合わせて読み取ったす
べてのイベントを変更して、‘read-event’からリターンする前
に、(もし適切なら)‘keyboard-translate-table’を通じてそれ
を変換します。

 -- Variable: extra-keyboard-modifiers
     この変数は、Lispプログラムにキーボード上の修飾キー
     を“押下”させる。値は文字である。文字の修飾子だけが
     対象となる。ユーザーがキーボードのキーを押下するた
     びに、その修飾キーがすでに押下されたかのように処理
     される。たとえば、‘extra-keyboard-modifiers’を
     ‘?\C-\M-a’にバインドした場合、このバインディングの
     スコープ内にある間、すべてのキーボード入力文字はコ
     ントロール修飾とメタ修飾を適用されるだろう。文字
     ‘?\C-@’は0と等価なので、この目的にたいしてはコント
     ロール文字として勘定されないが、修飾無しの文字とし
     て扱われる。したがって‘extra-keyboard-modifiers’を
     0にセットすることにより、すべての修飾をキャンセルで
     きる。

     ウィンドウシステムを利用する場合は、この方法により
     プログラムが任意の修飾キーを“押下”できる。それ以外
     は<CTL>と<META>のキーだけを仮想的に押下できる。

     この変数は実際にキーボード由来のイベントだけに適用
     され、マウスイベントやその他のイベントには効果がな
     いことに注意されたい。

 -- Variable: keyboard-translate-table
     この端末ローカルな変数はキーボード文字にたいする変
     換テーブルである。これによりコマンドバインディング
     を変更することなく、キーボード上のキーを再配置でき
     る。値は通常、文字テーブル、または‘nil’ある(文字列
     かベクターも指定できるが、時代遅れとされている)

     ‘keyboard-translate-table’が文字テーブル(*note
     Char-Tables::を参照)の場合、キーボードから読み取ら
     れたそれぞれの文字はその文字テーブルを調べる。非
     ‘nil’の値が見つかった場合は、実際の入力文字のかわり
     にそれを使用する。

     この変換は文字が端末から読み取られた後、最初に発生
     することに注意されたい。‘recent-keys’のような記録保
     持機能や文字を記録するdribbleファイルは、この変換の
     後に処理される。

     さらに、この変換は入力メソッド(*note Input
     Methods::を参照)に文字を提供する前に行われることに
     も注意されたい。入力メソッド処理の後に文字を変換し
     たい場合は、‘translation-table-for-input’(*note
     Translation of Characters::を参照)を使用すること。

 -- Function: keyboard-translate from to
     この関数は文字コードFROMを文字コードTOに変換するた
     めに、‘keyboard-translate-table’を変更する。 必要な
     場合は、キーボード変換テーブルを作成する。

   以下は‘C-x’でカット、‘C-’でコピー、‘C-v’でペーストを
処理するように‘keyboard-translate-table’を使用する例です
:

     (keyboard-translate ?\C-x 'control-x)
     (keyboard-translate ?\C-c 'control-c)
     (keyboard-translate ?\C-v 'control-v)
     (global-set-key [control-x] 'kill-region)
     (global-set-key [control-c] 'kill-ring-save)
     (global-set-key [control-v] 'yank)

拡張ASCII入力をサポートするグラフィカルな端末上では、シ
フトキーとともにタイプすることにより、標準的なEmacsにお
ける意味をこれらの文字から依然として取得することが可能で
す。これはキーボード変換が関与する文字とは異なりますが、
それらは通常と同じ意味をもちます。

   ‘read-key-sequence’のレベルでイベントシーケンスを変換
するメカニズムについては、*note Translation Keymaps::を
参照してください。


File: elisp,  Node: Invoking the Input Method,  Next: Quoted Character Input,  Prev: Event Mod,  Up: Reading Input

20.8.4 Invoking the Input Method
--------------------------------

イベント読み取り関数は、もしあればカレント入力メソッドを
呼び出します(*note Input Methods::を参照)。
‘input-method-function’の値が非‘nil’の場合、関数を指定し
ます。‘read-event’が修飾ビットのないプリント文字(<SPC>を
含む)を読み取ったときは、その文字を引数としてその関数を
呼び出します。

 -- Variable: input-method-function
     これが非‘nil’の場合、その値はカレントの入力メソッド
     関数を指定する。

     *警告:* この変数は‘let’でバインドしてはならない。こ
     の変数はしばしばバッファーローカルであり、入力の前
     後(これは正にあなたがバインド_するであろう_タイミン
     グである)でバインドした場合、Emacsが待機中に非同期
     にバッファーを切り替えると誤ったバッファーに値がリ
     ストアされるだろう。

   入力メソッド関数は、入力として使用されるイベントのリ
ストをリターンするべきです(このリストが‘nil’の場合、それ
は入力がないことを意味するので、‘read-event’他のイベント
を待機する)。これらのイベントは
‘unread-command-events’(*note Event Input Misc::を参照
)内のイベントの前に処理されます。入力メソッドによりリタ
ーンされるイベントは、たとえそれらが修飾ビットのないプリ
ント文字であっても、再度入力メソッドに渡されることはあり
ません。

   入力メソッド関数が‘read-event’または
‘read-key-sequence’を呼び出した場合は、再帰を防ぐために
最初に‘input-method-function’を‘nil’にバインドするべきで
す。

   キーシーケンスの2つ目および後続のイベントを読み取ると
きは、入力メソッド関数は呼び出されません。したがって、そ
れらの文字は入力メソッドの処理対象ではありません。入力メ
ソッド関数は‘overriding-local-map’と
‘overriding-terminal-local-map’の値をテストするべきです
。これらの変数のいずれかが非‘nil’の場合、入力メソッドは
引数をリストにputして、それ以上の処理を行わずにそのリス
トをリターンするべきです。


File: elisp,  Node: Quoted Character Input,  Next: Event Input Misc,  Prev: Invoking the Input Method,  Up: Reading Input

20.8.5 Quoted Character Input
-----------------------------

ユーザーが手軽にコントロール文字やメタ文字。リテラルや
8進文字コードを指定できるように、文字の指定をもとめるこ
とができます。コマンド‘quoted-insert’この関数を使用しま
す。

 -- Function: read-quoted-char &optional prompt
     この関数は‘read-char’同様だが、最初に読み取った文字
     が8進数 (0–7)の場合は任意の個数の8進数(8進数以外の
     文字を見つけた時点でストップする)を読み取り、その文
     字コードにより表される文字をリターンする。8進シーケ
     ンスを終端させた文字が<RET>の場合、それは無視される
     。他の終端文字は、この関数がリターンした後に入力と
     して使用される。

     最初の文字の読み取り時はquitは抑制されるので、ユー
     ザーはは‘C-g’を入力できる。*note Quitting::を参照の
     こと。

     PROMPTが与えられた場合、それはユーザーへのプロンプ
     トに使用する文字列を指定する。プロンプト文字列は、
     その後の1つの‘-’とともに常にエコーエリアに表示され
     る。

     以下の例では、ユーザーは8進数の177(10進数の127)をタ
     イプしている。

          (read-quoted-char "What character")

          ---------- Echo Area ----------
          What character 1 7 7-
          ---------- Echo Area ----------

               ⇒ 127


File: elisp,  Node: Event Input Misc,  Prev: Quoted Character Input,  Up: Reading Input

20.8.6 Miscellaneous Event Input Features
-----------------------------------------

このセクションでは、イベントを使い切ることなく“先読み”す
る方法、および入力の保留や保留の破棄の方法について説明し
ます。*note Reading a Password::の関数‘read-passwd’も参
照してください。

 -- Variable: unread-command-events
     この変数はコマンド入力として読み取り待機中のイベン
     トのリストを保持する。イベントはこのリスト内の出現
     順に使用され、使用されるごとにリストから取り除かれ
     る。

     ある関数がイベントを読み取ってそれを使用するかどう
     か決定する場合がいくつかあるので、この変数が必要に
     なる。この変数にイベントを格納すると、コマンドルー
     プおよにコマンド入力を読み取る関数により、イベント
     は通常のように処理される。

     たとえば、数引数を実装する関数は、任意の個数の数字
     を読み取る。数字イベントが見つからないとき、関数は
     そのイベントを読み戻す(unread)ので、そのイベントは
     コマンドループにより通常通り読み取られることができ
     る。同様に、インクリメンタル検索は、検索において特
     別な意味をもたないイベントを読み戻すために、この機
     能を使用する。なぜなら、それらのイベントは検索を
     exitして、通常どおり実行されるべきだからである。

     ‘unread-command-events’にイベントを置くためにキーシ
     ーケンスからイベントを抽出するには、
     ‘listify-key-sequence’(以下参照)を使用するのが簡単
     で信頼のおける方法である。

     もっとも最近読み戻したイベントが最初に再読み取りさ
     れるように、このリストの先頭にイベントを追加するの
     が通常である。

     通常このリストから読み取ったイベントは、そのイベン
     トが最初に読み取られたときにすでに一度追加されたと
     きのように、カレントコマンドのキーシーケンスに(たと
     えば‘this-command-keys’にリターンされたとみのように
     )追加される。フォーム‘(t . EVENT)’の要素は、カレン
     トコマンドのキーシーケンスにEVENTを強制的に追加する
     。

 -- Function: listify-key-sequence key
     この関数は文字列またはベクターのKEYを、
     ‘unread-command-events’置くことができる個別のイベン
     トのリストに変換する。

 -- Function: input-pending-p &optional check-timers
     この関数は、コマンド入力がカレントで読み取り可能か
     どうか判断する。入力が利用可能なら即座に‘t’を、それ
     以外は‘nil’をリターンする。非常に稀だが、入力が利用
     できないときに‘t’

     オプション引数CHECK-TIMERSが非‘nil’の場合、Emacsは
     順部位ができたら任意のタイマーを実行する。*note
     Timers::を参照のこと。

 -- Variable: last-input-event
     この変数は最後に読み取られた端末入力イベントがコマ
     ンドの一部なのか、それともLispプログラムによる明示
     的なものなのかを記録する。

     以下の例では、文字‘1’(ASCIIコード49)をLispプログラ
     ムが読み取っている。‘C-e’(‘C-x C-e’は式を評価するコ
     マンドとする)が‘last-command-event’に値として残って
     いる間は、それが‘last-input-event’の値となる。

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               ⊣ 49
               ⊣ 5
               ⇒ 49

 -- Macro: while-no-input body...
     この構成はBODYフォームを実行して、入力が何も到着し
     ない場合だけ最後のフォームの値をリターンする。
     BODYフォームを実行する間に何らかの入力が到着した場
     合は、それらの入力をする(quitのように機能する)。
     ‘while-no-input’フォームは実際のquitによりabortした
     場合は‘nil’、入力の到着によりabortした場合は‘t’をリ
     ターンする。

     BODYの一部で‘inhibit-quit’を非‘nil’にバインドした場
     合、その部分の間に到着した入力は、その部分が終わる
     までabortしない。

     両方のabort条件をBODYにより計算されたすべての可能な
     値で区別できるようにしたい場合は、以下のようにコー
     ドを記述する:

          (while-no-input
            (list
              (progn . BODY)))

 -- Function: discard-input
     この関数は端末入力バッファーの内容を破棄して定義処
     理中かもしれないキーボードマクロをキャンセルする。
     この関数は‘nil’をリターンする。

     以下の例では、フォームの評価開始直後にユーザーが数
     字か文字をタイプするかもしれない。‘sleep-for’がスリ
     ープを終えた後、‘discard-input’はスリープ中にタイプ
     された文字を破棄する。

          (progn (sleep-for 2)
                 (discard-input))
               ⇒ nil


File: elisp,  Node: Special Events,  Next: Waiting,  Prev: Reading Input,  Up: Command Loop

20.9 Special Events
===================

特定の“スペシャルイベント(special event)”は、読み取られ
ると即座に非常に低レベルで処理されます。‘read-event’関数
はそれらのイベントを自身で処理して、それらを決してリター
ンしません。かわりに、スペシャルイベント以外の最初のイベ
ントを待ち、それをリターンします。

   スペシャルイベントはエコーされず、決してキーシーケン
スにグループ化されず、‘last-command-event’や
‘(this-command-keys)’の値として出現することもありません
。スペシャルイベントは数引数を破棄し、
‘unread-command-events’による読み戻しができず、キーボー
ドマクロ内に出現することもないでしょうし、キーボードマク
ロ定義中にキーボードマクロに記録されることもありません。

   しかし、スペシャルイベントは読み取られた直後に
‘last-input-event’内に出現するので、これがイベント定義に
たいして実際のイベントを探す方法になります。

   イベント型‘iconify-frame’、‘make-frame-visible’、
‘delete-frame’、‘drag-n-drop’、‘language-change’、および
‘sigusr1’ようなユーザーシグナルは通常この方法により処理
されます。何がスペシャルイベントで、スペシャルイベントを
どのように処理するかを定義するキーマップは、変数
‘special-event-map’(*note Active Keymaps::を参照)の中に
あります。


File: elisp,  Node: Waiting,  Next: Quitting,  Prev: Special Events,  Up: Command Loop

20.10 Waiting for Elapsed Time or Input
=======================================

待機関数(wait function)は特定の時間が経過するか、入力が
あるまで待機するようにデザインされています。たとえば、計
算の途中でユーザーがディスプレイを閲覧できるように一時停
止したいときがあるかもしれません。‘sit-for’は一時停止し
て画面を更新、‘sleep-for’は画面を更新せずに一時停止して
、入力が到着したら即座にリターンします。

 -- Function: sit-for seconds &optional nodisp
     この関数は、(ユーザーからの保留中入力がない場合は
     )再描画を行ってから、SECONDS秒、または入力が利用可
     能になるまで待機する。‘sit-for’の通常の目的は、ディ
     スプレイしたテキストをユーザーが読み取る時間を与え
     るためである。入力が何も到着せず(*note Event Input
     Misc::を参照)、時間をフルに待機した場合は‘t’、それ
     以外は‘nil’が値となる。

     引数SECONDSは整数である必要はない。浮動小数点数の場
     合、‘sit-for’は秒の少数点数を待機する。整数の秒だけ
     をサポートするいくつかのシステムでは、SECONDSは切り
     捨てられる。

     保留中の入力が存在しない場合、式‘(sit-for 0)’は遅延
     なしに再描画をリクエストする‘(redisplay)’と等価であ
     る。*note Forcing Redisplay::を参照のこと。

     NODISPが非‘nil’の場合‘sit-for’は再描画を行わないが
     、それでも入力が利用可能になると(またはタイムアウト
     時間が経過すると)即座にリターンする。

     バッチモード(*note Batch Mode::を参照)では、たとえ
     標準入力ディスクリプタからの入力でも割り込みできま
     い。これは以下で説明する‘sleep-for’でも同じである。

     ‘(sit-for SECONDS MILLISEC NODISP)’のように、3つの
     引数で‘sit-for’を呼び出すことも可能だが時代遅れだと
     考えられている。

 -- Function: sleep-for seconds &optional millisec
     この関数は表示を更新せず、単にSECONDS秒間一時停止す
     る。これは利用可能な入力に注意を払わない。この関数
     は‘nil’をリターンする。

     引数SECONDSは整数である必要はない。浮動小数点数の場
     合、‘sleep-for’は秒の少数点数を待機する。整数の秒だ
     けをサポートするいくつかのシステムでは、SECONDSは切
     り捨てられる。

     オプション引数MILLISECはミリ秒単位で追加の待機期間
     を指定する。これはSECONDSで指定された期間に追加され
     る。システムが小数点の秒数をサポートしない場合、非
     0のMILLISECを指定するとエラーとなる。

     遅延を保証したい場合は‘sleep-for’を使用する。

   現在時刻を取得する関数については、*note Time of
Day::を参照してください。


File: elisp,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Waiting,  Up: Command Loop

20.11 Quitting
==============

Lisp関数を実行中に‘C-g’をタイプすると、Emacsが何を行って
いてもEmacsを“quit(中止、終了)”させます。これはアクティ
ブなコマンドループの再内に制御がリターンすることを意味し
ます。

   コマンドループがキーボード入力待機中に‘C-g’をタイプし
てもquitはしません。これは通常の入力文字として機能します
。もっともシンプルなケースでは、通常‘C-g’はquitの効果を
もつ‘keyboard-quit’を実行するので、区別できませんしかし
プレフィクスキーの後の‘C-g’は、未定義のキー組み合わせに
なります。これはプレフィクスキーやプレフィクスキーも同様
にキャンセルする効果をもちます。

   ミニバッファー内では、‘C-g’は異なる定義をもち、それは
ミニバッファーをabort(失敗、中止、中断)します。これは実
際にはミニバッファーをexitしてquitします(単にquitするの
は_ミニバッファー内_のコマンドループにリターンするだろう
)。‘C-g’がなぜコマンドリーダーが入力読み取り時に直接
quitしないかという理由は、ミニバッファー内で‘C-g’の意味
をこの方法により再定義可能にするためです。プレフィクスキ
ーの後の‘C-g’はミニバッファー内で再定義されておらず、プ
レフィクスキーおよびプレフィクス引数のキャンセルという通
常の効果をもちます。もし‘C-g’ｇヴぁ常に直接quitするなら
、これは不可能でしょう。

   ‘C-g’が直接quitを行うときは、変数‘quit-flag’を‘t’にセ
ットすることによりそれを行います。Emacsは適切なときにこ
の変数をチェックして、‘nil’でない場合はquitします。どの
ような方法でも、‘quit-flag’を非‘nil’にセットするとquitが
発生します。

   Cコードのレベルでは、どこでもquitを発生させることはで
きず、‘quit-flag’をチェックする特別な場所でのみquitが発
生します。この理由は、他の場所でquitすると、Emacsの内部
状態が矛盾が生じるかもしれないからです。安全な場所まで
quitが遅延されるので、quitがEmacsをクラッシュさせること
がなくなります。

   ‘read-key-sequence’や‘read-quoted-char’のような特定の
関数は、たとえ入力を待機中でもquitを抑制します。quitする
かわりに、‘C-g’は要求された入力として処理されます。
‘read-key-sequence’の場合、これはコマンドループ内での
‘C-g’の特別な振る舞いを引き起こすのに役立ちます。
‘read-quoted-char’の場合、これは‘C-g’をクォートするのに
‘C-q’を使用できるようにします。

   変数‘inhibit-quit’を非‘nil’値にバインドすることにより
、Lisp関数の一部でquitを抑止できます。その場合は、
‘quit-flag’を‘t’にセットされていても、‘C-g’の通常の結果
であるquitは抑止されます。‘let’フォームの最後でこのバイ
ンディングがunwindされるなどして、結果として
‘inhibit-quit’は再び‘nil’になります。このとき
‘quit-flag’が‘nil’の場合には、即座に要求されたquitが発生
します。この挙動は、プログラム中の“クリティカルセクショ
ン”内でquitが発生しないことを確実にしたいときに理想的で
す。

   (‘read-quoted-char’のような)いくつかの関数では、
quitを起こさない特別な方法で‘C-g’が処理されます。これは
‘inhibit-quit’を‘t’にバインドして入力を読み取り、再び
‘inhibit-quit’が‘nil’になる前に‘quit-flag’を‘nil’にセッ
トすることにより行われます。以下は、これを行う方法を示す
ための‘read-quoted-char’の抜粋です。この例は入力の最初の
文字の後で通常のquitを許す方法も示しています。

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((message-log-max nil) done (first t) (code 0) char)
         (while (not done)
           (let ((inhibit-quit first)
                 ...)
             (and prompt (message "%s-" prompt))
             (setq char (read-event))
             (if inhibit-quit (setq quit-flag nil)))
           ... 変数‘code’をセット ...)
         code))

 -- Variable: quit-flag
     この変数が非‘nil’で‘inhibit-quit’が‘nil’の場合、
     macsは即座にquitする。‘C-g’をタイプすると、通常は
     ‘inhibit-quit’とは無関係に‘quit-flag’を非‘nil’にセ
     ットする。

 -- Variable: inhibit-quit
     この変数は、‘quit-flag’が非‘nil’にセットされている
     ときEmacsがquitするかどうかを決定する。
     ‘inhibit-quit’が非‘nil’の場合、‘quit-flag’は特に効
     果がない。

 -- Macro: with-local-quit body...
     このマクロはBODYを順番に実行するが、たとえこの構成
     の外部で‘inhibit-quit’が非‘nil’でも、少なくともロー
     カルにBODY内でのquitを許す。このマクロはquitにより
     exitした場合は‘nil’、それ以外はBODY内の最後のフォー
     ムの値をリターンする。

     ‘inhibit-quit’が‘nil’の場合‘with-local-quit’へのエ
     ントリーでBODYだけが実行され、‘quit-flag’をセットす
     ることにより通常のquitが発生する。しかし通常の
     quitが遅延されるように‘inhibit-quit’が非‘nil’にセッ
     トされている場合、非‘nil’の‘quit-flag’は特別な種類
     のローカルquitを引き起こす。これはBODYの実行を終了
     して、‘quit-flag’を非‘nil’のままで
     ‘with-local-quit’ボディーをexitするので、許され次第
     (通常の)他のquitが発生する。BODYの先頭ですでに
     ‘quit-flag’が非‘nil’の場合、即座にローカルquitが発
     生して結局ボディーは実行されない。

     このマクロは主にタイマー、プロセスフィルター、プロ
     セスセンチネル、‘pre-command-hook’、
     ‘post-command-hook’、および‘inhibit-quit’が通常は
     ‘t’にバイドされている場所で役に立つ。

 -- Command: keyboard-quit
     この関数は‘(signal 'quit nil)’により‘quit’条件をシ
     グナルする。これはquitが行うことと同じである(*note
     Errors::の‘signal’を参照)。

   quitに使用する‘C-g’以外の文字を指定できます。*note
Input Modes::内の関数‘set-input-mode’を参照してください
。


File: elisp,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

20.12 Prefix Command Arguments
==============================

ほとんどのEmacsコマンドは“プレフィクス引数(prefix
argument)”を使用できます。プレフィクス引数はコマンド自身
の前に数字を指定するものです(プレフィクス引数とプレフィ
クスキーを混同しないように)。プレフィクス引数は常に値に
より表され、‘nil’のときはカレントでプレフィクス引数が存
在しないことを意味します。すべてのコマンドはプレフィクス
引数を使用するか、あるいは無視します。

   プレフィクス引数には2つの表現があります。それは
“raw(生の、加工していない、原料のままの、未加工の)”と“数
字(numeric)”です。エディターコマンドループは内部的に
raw表現を使用し、Lisp変数もその情報を格納するのにこれを
使用しますが、コマンドはどちらかの表現を要求できます。

   以下は利用できるrawプレフィクス引数の値です:

   • ‘nil’はプレフィクス引数がないことを意味する。これの
     数値的な値は1だが、多くのコマンドは‘nil’と整数1を区
     別する。

   • 整数はそれ自身を意味する。

   • 整数の要素を1つもつリスト。プレフィクス引数のこの形
     式は、1つまたは数字無しの連続する‘C-u’の結果である
     。数値的な値はリスト内の整数だが、そのようなリスト
     と単独の整数を区別するコマンドがいくつかある。

   • シンボル‘-’。これは後に数字をともなわない‘M--’か
     ‘C-u -’がタイプされたことを示す。数値的に等価な値は
     −1だが、整数の−1をシンボルの‘-’を区別するコマンドが
     いくつかある。

   以下の関数をさまざまなプレフィクスで呼び出して、これ
らの可能なプレフィクスを説明しましょう:

     (defun display-prefix (arg)
       "rawプレフィクス引数の値を表示する。"
       (interactive "P")
       (message "%s" arg))

以下はさまざまなrawプレフィクス引数で‘display-prefix’を
呼び出した結果です:

             M-x display-prefix  ⊣ nil

     C-u     M-x display-prefix  ⊣ (4)

     C-u C-u M-x display-prefix  ⊣ (16)

     C-u 3   M-x display-prefix  ⊣ 3

     M-3     M-x display-prefix  ⊣ 3      ; (‘C-u 3’と同じ)

     C-u -   M-x display-prefix  ⊣ -

     M--     M-x display-prefix  ⊣ -      ; (‘C-u -’と同じ)

     C-u - 7 M-x display-prefix  ⊣ -7

     M-- 7   M-x display-prefix  ⊣ -7     ; (‘C-u -7’と同じ)

   Emacsにはプレフィクス引数を格納するための2つの変数
‘prefix-arg’と‘current-prefix-arg’があります。他のコマン
ドにたいしてプレフィクス引数をセットアップする
‘universal-argument’のようなコマンドは、プレフィクス引数
を‘prefix-arg’内に格納します。対照的に
‘current-prefix-arg’はカレントコマンドにプレフィクス引数
を引き渡すので、これらの変数をセットしても将来のコマンド
にたいするプレフィクス引数に効果はありません。

   コマンドは通常は‘interactive’内で、プレフィクス引数に
たいしてrawと数値のどちらの表現を使用するかを指定します
(*note Using Interactive::を参照)。そのかわりに関数は変
数‘current-prefix-arg’内のプレフィクス引数の値を直接調べ
るかもしれませんが、これは明確さで劣ります。

 -- Function: prefix-numeric-value arg
     この関数はARGの有効なrawプレフィクス引数の数値的な
     意味をリターンする。引数はシンボル、数字、またはリ
     ストかもしれない。これが‘nil’の場合は、値1がリター
     ンsare,‘-’の場合は−1がリターンされる。これが数字の
     場合は、その数字がリターンされる。リスト(数字である
     べき)の場合は、そのリストのCARがリターンされる。

 -- Variable: current-prefix-arg
     この変数は_カレント_のコマンドにたいするrawプレフィ
     クス引数を保持する。コマンドはこの変数を直接調べる
     かもしれないが、この変数にたいするアクセスには通常
     は‘(interactive "P")’を使用する。

 -- Variable: prefix-arg
     この変数の値は_次_の編集コマンドにたいするrawプレフ
     ィクス引数である。後続のコマンドにたいしてプレフィ
     クス引数を指定する‘universal-argument’のようなコマ
     ンドは、この変数をセットすることにより機能する。

 -- Variable: last-prefix-arg
     rawプレフィクス引数の値は、前のコマンドにより使用さ
     れた値である。

   以下のコマンドは、後続のコマンドにたいしてプレフィク
ス引数をセットアップするために存在します。これらを他の用
途で呼び出さないでください。

 -- Command: universal-argument
     このコマンドは入力を読み取り。後続のコマンドにたい
     するプレフィクス引数を指定する。何をしているかわか
     っているのでなければ、このコマンドを自分で呼び出し
     てはならない。

 -- Command: digit-argument arg
     このコマンドは、後続のコマンドにたいしてプレフィク
     ス引数を追加する。引数ARGはこのコマンドの前のrawプ
     レフィクス引数であり、これはプレフィクス引数を更新
     するために使用される。何をしているかわかっているの
     でなければ、このコマンドを自分で呼び出してはならな
     い。

 -- Command: negative-argument arg
     このコマンドは、次のコマンドにたいして数引数を追加
     する。引数ARGはこのコマンドの前のrawプレフィクス引
     数であり、この値に負の符号が付されて新しいプレフィ
     クス引数を構築する。何をしているかわかっているので
     なければ、このコマンドを自分で呼び出してはならない
     。


File: elisp,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

20.13 Recursive Editing
=======================

Emacsスタートアップ時に、自動的にEmacsコマンドループにエ
ンターします。このトップレベルのコマンドループ呼び出しは
決してexitせず、Emacs実行中は実行を続けます。Lispプログ
ラムもコマンドループを呼び出せます。これは複数のコマンド
ループを活性化するため、これを“再帰編集(recursive
editing)”と呼んでいます。再帰編集レベルは、呼び出したコ
マンドが何であれそれをサスペンドして、そのコマンドを再開
する前にユーザーが任意の編集を行うことを可能にする効果を
もちます。

   再帰編集の間に利用可能なコマンドは、トップレベルの編
集ループ内で利用できるコマンドと同じであり、キーマップ内
で定義されます。数少ない特別なコマンドだけが再帰編集レベ
ルをexitし、他のコマンドは再帰編集レベルが終了したときに
再帰編集レベルからリターンします(exitするための特別なコ
マンドは常に利用できますが、再帰編集が行われていないとき
は何も行いません)。

   再帰コマンドループを含むすべてのコマンドループは、コ
マンドループから実行されたコマンド内のエラーによりそのル
ープをexitしないように、汎用エラーハンドラーをセットアッ
プします。

   ミニバッファー入力は、特殊な再帰編集です。これは、ミ
ニバッファーとミニバッファーウィンドウの表示を有効にする
などの欠点をもちますが、それはあなたが思うより少ないでし
ょう。ミニバッファー内では特定のキーの振る舞いが異なりま
すが、これははミニバッファーのローカルマップによるもので
す。ウィンドウを切り替えれば、通常のEmacsコマンドを使用
できます。

   再帰編集レベルを呼び出すには、関数を
‘recursive-edit’を呼び出します。この関数はコマンドループ
を含んでいます。さらに‘exit’をthrowすることにより再帰編
集レベルのexitを可能にする、タグ‘exit’をともなう
‘catch’呼び出しも含んでいます(*note Catch and Throw::を
参照)。‘t’以外の値をthrowした場合、‘recursive-edit’は通
常それを呼び出した関数にリターンします。コマンド
‘C-M-c’(‘exit-recursive-edit’)がこれを行います。値‘t’を
throwすることにより‘recursive-edit’がquitされるので、1レ
ベル上位のコマンドループに制御がリターンされます。これは
“abort”と呼ばれ、‘C-]’(‘abort-recursive-edit’)がこれを行
います。

   ほとんどのアプリケーションはミニバッファー使用の一部
として使用する場合を除き、再帰編集を使用するべきではあり
ません。カレントバッファーのメジャーモードから、特殊なメ
ジャーモードに一時的に変更する場合に、そのモードに戻るコ
マンドをもつ必要があるときは、通常は再帰編集のほうが便利
です(Rmailの‘e’コマンドはこのテクニックを使用している)。
またはユーザーが新たなバッファーの特殊なモードで、異なる
テキストを“再帰的”に編集・作成・選択できるようにしたい場
合が該当します。このモードでは処理を完了させるコマンドを
定義して、前のバッファーに戻ります(Rmailの‘m’コマンドは
これを使用している)。

   再帰編集はデバッグに便利です。一種のブレークポイント
として関数定義内に‘debug’を挿入して、関数がそこに達した
ときにその箇所を調べることができます。‘debug’は再帰編集
を呼び出しますが、デバッガのその他の機能も提供します。

   ‘query-replace’内で‘C-r’をタイプしたときや‘C-x
q’(‘kbd-macro-query’)を使用したときも、再帰編集レベルが
使用されます。

 -- Command: recursive-edit
     この関数はエディターコマンドループを呼び出す。これ
     はユーザーに編集を開始させるために、Emacsの初期化に
     より自動的に呼び出されるLispプログラムから呼び出さ
     れたときは、再帰編集レベルにエンターする。

     カレントバッファーが選択されたウィンドウのバッファ
     ーと異なる場合、‘recursive-edit’はカレントバッファ
     ーの保存とリストアを行う。それ以外では、バッファー
     を切り替えた場合には、‘recursive-edit’がリターンし
     た後その切り替えたバッファーがカレントになる。

     以下の例では、関数‘simple-rec’が最初にポイントを1単
     語分進めてからメッセージをエコーエリアにプリントし
     て再帰編集にエンターする。その後ユーザーは望む編集
     を行い、‘C-M-c’をタイプすれば再帰編集をexitして、
     ‘simple-rec’の実行を継続できる。

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               ⇒ simple-rec
          (simple-rec)
               ⇒ nil

 -- Command: exit-recursive-edit
     この関数は最内の再帰編集(ミニバッファー入力を含む
     )からexitする。関数の実質的な定義は‘(throw 'exit
     nil)’である。

 -- Command: abort-recursive-edit
     この関数は、再帰編集をexitした後に‘quit’をシグナル
     することにより、最内の再帰編集(ミニバッファー入力を
     含む)を要求したコマンドをabortする。関数の実質的な
     定義は‘(throw 'exit t)’である。*note Quitting::を参
     照のこと。

 -- Command: top-level
     この関数はすべての再帰編集レベルをexitする。これは
     すべての計算を直接抜け出してメインのコマンドループ
     に戻り、値をリターンしない。

 -- Function: recursion-depth
     この関数は再帰編集のカレントの深さをリターンする。
     アクティブな再帰編集が存在しない場合は、0をリターン
     する。


File: elisp,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

20.14 Disabling Commands
========================

“コマンドを無効化(disabling a command)”とは、それを実行
可能にする前にユーザーによる確認を要求するようにコマンド
をマークすることです。無効化は初めてのユーザーを混乱させ
るかもしれないコマンドにたいして、アクシデントによりその
コマンドが使用されるのを防ぐために使用されます。

   コマンド無効化の低レベルにおけるメカニズムは、そのコ
マンドにたいするLispシンボルの‘disabled’プロパティに非
‘nil’をputすることです。これらのプロパティは、通常はユー
ザーのinitファイル(*note Init File::を参照)で以下のよう
なLisp式によりセットアップされます:

     (put 'upcase-region 'disabled t)

いくつかのコマンドにたいしては、これらのプロパティがデフ
ォルトで与えられています(これらを削除したい場合はinitフ
ァイルで削除できる)。

   ‘disabled’プロパティの値が文字列の場合、そのコマンド
が無効化されていることを告げるメッセージにその文字列が含
まれます。たとえば:

     (put 'delete-region 'disabled
          "この方法で削除されたテキストはyankで戻せない!\n")

   無効化されたコマンドをインタラクティブに呼び出したと
きに何が起こるかの詳細は、*Note (emacs)Disabling::を参照
してください。コマンドの無効化は、それをLispプログラムか
ら関数として呼び出したときは効果がありません。

 -- Command: enable-command command
     その時点より、特別な確認なしでCOMMAND(シンボル)が実
     行されることを許す。さらにユーザーのinitファイル
     (*note Init File::を参照)も修正するので、将来のセッ
     ションにもこれが適用される。

 -- Command: disable-command command
     その時点より、COMMAND(シンボル)の実行に特別な確認を
     要求する。さらにユーザーのinitファイル(*note Init
     File::を参照)も修正するので、将来のセッションにもこ
     れが適用される。

 -- Variable: disabled-command-function
     この変数の値は関数であること。ユーザーが無効化され
     たコマンドを呼び出したときは、無効化されたコマンド
     のかわりにその関数が呼び出される。そのコマンドを実
     行するためにユーザーが何のキーをタイプしたかを判断
     するために‘this-command-keys’を使用して、そのコマン
     ド自体を探すことができる。

     値が‘nil’の場合もあり得る。その場合は、たとえ無効化
     されたコマンドでも、すべてのコマンドが通常に機能す
     る。

     デフォルトでは、値はユーザーに処理を行うか尋ねる関
     数である。


File: elisp,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

20.15 Command History
=====================

コマンドループは複雑なコマンドを手軽に繰り返せるように、
実行された複雑なコマンドのヒストリー(history: 履歴)を保
持します。“複雑なコマンド(complex command)とは、ミニバッ
ファーを使用してinteractive引数を読み取るコマンドです。
”これには‘M-x’コマンド、‘M-:’コマンド、および
‘interactive’指定によりミニバッファーから引数を読み取る
任意のコマンドが含まれます。コマンド自身の実行の間に明示
的にミニバッファーを使用するものは、複雑なコマンドとは判
断されません。

 -- Variable: command-history
     この変数の値は最近実行された複雑なコマンドのリスト
     であり、それぞれが評価されるべきフォームとして表現
     される。このリストは編集セッションの間、すべての複
     雑なコマンドを蓄積するが、最大サイズ(*note
     Minibuffer History::を参照)に達したときは、もっとも
     古い要素が削除されて、新たな要素が追加される。

          command-history
          ⇒ ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

   実際には、このヒストリーリストはミニバッファーヒスト
リーの特殊ケースであり、それは要素が文字列ではなく式であ
ることです。

   以前のコマンドを編集したり再呼び出しするためのコマン
ドがいくつかあります。コマンド‘repeat-complex-command’お
よび‘list-command-history’は、ユーザーマニュアルで説明さ
れています(*note (emacs)Repetition::を参照)。ミニバッフ
ァー内では、通常のミニバッファーヒストリーコマンドが理由
できます。


File: elisp,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

20.16 Keyboard Macros
=====================

“キーボードマクロ(keyboard macro)”は、コマンドとして考え
ることが可能な、入力イベントの記録されたシーケンスであり
、キー定義により作成されます。キーボードマクロのLisp表現
は、イベントを含む文字列またはベクターです。キーボードマ
クロとLispマクロ(*note Macros::を参照)を混同しないでくだ
さい。

 -- Function: execute-kbd-macro kbdmacro &optional count
          loopfunc
     この関数は、イベントシーケンスとしてKBDMACROを実行
     する。KBDMACROが文字列かベクターの場合、たとえそれ
     がユーザーによる入力であっても、その中のイベントは
     忠実に実行される。シーケンスは、単一のキーシーケン
     スであることを_要求されない_。キーボードマクロ定義
     は、通常は複数のキーシーケンスを結合して構成される
     。

     KBDMACROがシンボルの場合、そのシンボルの関数定義は
     KBDMACROの箇所に使用される。それが別のシンボルの場
     合は、このプロセスを繰り返す。最終的に結果は文字列
     かベクターになる。結果がシンボル、文字列、ベクター
     でない場合は、エラーがシグナルされる。

     引数COUNTは繰り返すカウントであり、KBDMACROがその回
     数実行される。COUNTが省略、または‘nil’の場合は1回実
     行される。0の場合、KBDMACROはエラーに出会うか検索が
     失敗するまで、何度も実行される。

     LOOPFUNCが非‘nil’の場合、それはマクロの繰り返しごと
     に呼び出される、引数なしの関数である。LOOPFUNCが
     ‘nil’をリターンすると、マクロの実行が停止する。

     ‘execute-kbd-macro’の使用例は、*note Reading One
     Event::を参照のこと。

 -- Variable: executing-kbd-macro
     この変数は、カレントで実行中のキーボードマクロを定
     義する文字列かベクターである。‘nil’の場合、カレント
     で実行中のマクロは存在しない。マクロの実行により実
     行されたときに異なる振る舞いをするように、コマンド
     はこの変数をテストできる。この変数を自分でセットし
     てはならない。

 -- Variable: defining-kbd-macro
     この変数は、キーボードマクロの定義中のときだけ非
     ‘nil’である。マクロ定義中の間は異なる振る舞いをする
     ように、コマンドはこの変数をテストできる。既存のマ
     クロ定義に追加する間、値は‘append’になる。コマンド
     ‘start-kbd-macro’、‘kmacro-start-macro’、
     ‘end-kbd-macro’は、この変数をセットする。この変数を
     自分でセットしてはならない。

     この変数は常にカレント端末にたいしてローカルであり
     、バッファーローカルにできない。*note Multiple
     Terminals::を参照のこと。

 -- Variable: last-kbd-macro
     この変数は、もっとも最近定義されたキーボードマクロ
     の定義である。値は文字列、ベクター、または‘nil’であ
     る。

     この変数は常にカレント端末にたいしてローカルであり
     、バッファーローカルにできない。*note Multiple
     Terminals::を参照のこと。

 -- Variable: kbd-macro-termination-hook
     これはキーボードマクロが終了したときに実行されるノ
     ーマルフックであり、何がキーボードマクロを終了させ
     たか(マクロの最後に達したのか、あるいはエラーにより
     最後に達する前に終了したのか)は問わない。


File: elisp,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

21 Keymaps
**********

入力イベントのコマンドバインディングは、“キーマップ
(keymap)”と呼ばれるデータ構造に記録されます。キーマップ
内の各エントリーは個別のイベント型(他のキーマップ、また
はコマンド)に関連づけ(または“バインド”)されます。イベン
ト型がキーマップにバインドされる場合、そのキーマップは次
の入力イベントを調べるために使用されます。これはコマンド
が見つかるまで継続されます。このプロセス全体を“キールッ
クアップ(key lookup: キー照合)”と呼びます。

* Menu:

* Key Sequences::            Lispオブジェクトとしてのキーシーケンス。
* Keymap Basics::            キーマップの基本概念。
* Format of Keymaps::        キーマップはLispオブジェクトとしてどのように見えるか。
* Creating Keymaps::         キーマップを作成、コピーする関数。
* Inheritance and Keymaps::  キーマップが他のキーマップのバインディングを継承する方法。
* Prefix Keys::              キーマップの定義としてキーを定義する。
* Active Keymaps::           Emacsがアクティブなキーマップでキーバインディングを探す方法。
* Searching Keymaps::        アクティブなマップ検索のLisp処理概要。
* Controlling Active Maps::  各バッファーは標準(グローバル)のバインディングをオーバーライドするためのキーマップをもつ。マイナーモードもそれらをオーバーライドできる。
* Key Lookup::               1つのキーマップから、あるキーのバインディングを探す。
* Functions for Key Lookup::  キールックアップを要求する方法。
* Changing Key Bindings::    キーマップ内でのキーの再定義。
* Remapping Commands::       キーマップはあるコマンドを他のコマンドに変換できる。
* Translation Keymaps::      イベントシーケンスを変換するキーマップ。
* Key Binding Commands::     キーの再定義にたいするインタラクティブなインターフェイス。
* Scanning Keymaps::         ヘルプをプリントするためにすべてのキーマップを走査する。
* Menu Keymaps::             キーマップとしてキーマップを定義する。


File: elisp,  Node: Key Sequences,  Next: Keymap Basics,  Up: Keymaps

21.1 Key Sequences
==================

“キーシーケンス(key sequence)”、短くは“キー(key)”とは、
1つの単位を形成する1つ以上の入力イベントのシーケンスです
。入力イベントには文字、ファンクションキー、マウスアクシ
ョン、または‘iconify-frame’のようなEmacs外部のシステムイ
ベントが含まれます(*note Input Events::を参照)。キーシー
ケンスにたいするEmacs Lispの表現は文字列かベクターです。
特に明記しない限り、引数としてキーシーケンスを受け取る
Emacs Lisp関数は両方の表現を処理することができます。

   文字列表現では、たとえば、‘"a"’は‘a’、‘"2"’は‘2’を表
すといったように、英数字はその文字自身を意味します。コン
トロール文字イベントは部分文字列‘"\C-"’、メタ文字は
‘"\M-"’によりプレフィクスされます。たとえば‘"\C-x"’はキ
ー‘C-x’を表します。それらに加えて、<TAB>、<RET>、<ESC>、
<DEL>などのイベントはそれぞれ‘"\t"’、‘"\r"’、‘"\e"’、
‘"\d"’で表されます。複雑なキーシーケンスの文字列表現は、
イベント成分の文字列表現を結合したものです。したがって
‘"\C-xl"’はキーシーケンス‘C-x l’を表します。

   キーシーケンスにはファンクションキー、マウスボタンイ
ベント、システムイベント、または‘C-=’や‘H-a’のような文字
列で表現できない非ASCII文字が含まれます。これらはベクタ
ーとして表現される必要があります。

   ベクター表現ではベクターの各要素は1つの入力イベントを
イベントのLisp形式で表します。*note Input Events::を参照
してください。たとえば、ベクター‘[?\C-x ?l]’はキーシーケ
ンス‘C-x l’を表します。

   キーシーケンスを文字列やベクターによる表現で記述する
例は、*note (emacs)Init Rebinding::を参照してください。

 -- Function: kbd keyseq-text
     この関数はテキストKEYSEQ-TEXT(文字列定数)をキーシー
     ケンス(文字列かベクターの定数)に変換する。
     KEYSEQ-TEXTの内容は‘C-x C-k
     <RET>’(‘kmacro-edit-macro’) コマンドにより呼び出さ
     れたバッファー内と同じ構文を使用するべきであ特にフ
     ァンクションキーの名前は‘<...>’で囲まなければならな
     い。*note (emacs)Edit Keyboard Macro::を参照のこと
     。

          (kbd "C-x") ⇒ "\C-x"
          (kbd "C-x C-f") ⇒ "\C-x\C-f"
          (kbd "C-x 4 C-f") ⇒ "\C-x4\C-f"
          (kbd "X") ⇒ "X"
          (kbd "RET") ⇒ "\^M"
          (kbd "C-c SPC") ⇒ "\C-c "
          (kbd "<f1> SPC") ⇒ [f1 32]
          (kbd "C-M-<down>") ⇒ [C-M-down]


File: elisp,  Node: Keymap Basics,  Next: Format of Keymaps,  Prev: Key Sequences,  Up: Keymaps

21.2 Keymap Basics
==================

キーマップは、さまざまなキーシーケンスにたいして“キーバ
インディング(key binding)”を指定するLispデータ構造です。

   1つのキーマップが、個々のイベントにたいする定義を直接
指定します。 A single keymap directly specifies
definitions for individual events. 単一のイベントでキー
シーケンスが構成されるとき、そのキーシーケンスのキーマッ
プ内でのバインディングは、そのイベントにたいするそのキー
マップの定義です。それより長いキーシーケンスのバインディ
ングは対話的プロセスにより見つけ出されます。まず、最初の
イベント(これ自身がキーマップでなければならない)の定義を
探します。次にそのキーマップ内で2つ目のイベントを探すと
いったように、そのキーシーケンス内のすべてのイベントが処
理されるまで、これを続けます。

   あるキーシーケンスのバインディングがキーマップである
ような場合、わたしたちはそのキーシーケンスを“プレフィク
スキー(prefix key)”と呼び、それ以外の場合は(それ以上イベ
ントを追加できないので)“コンプリートキー(complete keyl”と
呼んでいます。バインディングが‘nil’の場合、わたしたちは
そのキーを“未定義(undefined)”と呼びます。‘C-c’、‘C-x’、
‘C-x 4’などはプレフィクスキーの例です。‘X’、<RET>、‘C-x
4 C-f’などは定義されたコンプリートキーの例です。‘C-x
C-g’や‘C-c 3’などは未定義なコンプリートキーの例です。詳
細は*note Prefix Keys::を参照してください。

   キーシーケンスのバインディングを見つけ出すルールは、
(最後のイベントの前までに見つかる)中間的なバインディング
がすべてキーマップであると仮定します。もしそうでなければ
、そのイベントシーケンスは単位を形成せず、実際の単一キー
シーケンスではありません。他の言い方をすると、任意の有効
なキーシーケンスから1つ以上のイベントを取り除くと、常に
プレフィクスキーにならなければなりません。たとえば‘C-f
C-n’はキーシーケンスではありません。‘C-f’はプレフィクス
キーではないので、‘C-f’で始まるこれより長いシーケンスは
、キーシーケンスであり得ないのです。

   利用可能な複数イベントキーシーケンスのセットは、プレ
フィクスキーにたいするバインディングに依存します。したが
って、これはキーマップが異なれば異なるかもしれず、バイン
ディングが変更されたとき変更されるかもしれません。しかし
、単一イベントキーシーケンスは適格性において任意のプレフ
ィクスキーに依存しないので、常に単一のキーシーケンスです
。

   常に複数のプライマリーキーマップ(primary keymap: 主キ
ーマップ)がアクティブであり、これらはキーバインディング
を見つけるために使用されます。すべてのバッファーで共有さ
れる“グローバルキーマップ(global map)”というキーマップが
存在します。“ローカルキーマップ(local keymap)”は通常、特
定のメジャーモードに関連します。そして0個以上の“マイナー
モードキーマップ(minor mode keymap)”はカレントで有効なマ
イナーモードに属します(すべてのマイナーモードがキーマッ
プをもつわけでなない)。ローカルキーマップは、対応するグ
ローバルバインディングをshadow(優先される)します。マイナ
ーモードキーマップは、ローカルキーマップとグローバルキー
マップの両方をshadowします。詳細は、*note Active
Keymaps::を参照してください。


File: elisp,  Node: Format of Keymaps,  Next: Creating Keymaps,  Prev: Keymap Basics,  Up: Keymaps

21.3 Format of Keymaps
======================

キーマップはそれぞれ、CARがシンボル‘keymap’であるような
リストです。このリストの残りの要素は、そのキーマップのキ
ーバインディングを定義します。関数定義がキーマップである
ようなシンボルもキーマップです。あるオブジェクトがキーマ
ップかどうかテストするには、関数‘keymapp’(以下参照)を使
用してください。

   キーマップを開始するシンボル‘keymap’の後には、いくつ
かの種類の要素が出現します:

‘(TYPE . BINDING)’
     これは型TYPEのイベントにたいする1つのバインディング
     を指定する。通常のバインディングはそれぞれ、常に文
     字かシンボルであるような特定の“イベント型(event
     type)”のイベントに適用される。*note Classifying
     Events::を参照のこと。この種のバインディングでは、
     BINDINGはコマンドである。

‘(TYPE ITEM-NAME . BINDING)’
     これは、メニュー内でITEM-NAMEとして表示されるシンプ
     ルなメニューアイテムでもあるようなバインディングを
     指定する。*note Simple Menu Items::を参照のこと。

‘(TYPE ITEM-NAME HELP-STRING . BINDING)’
     これは、ヘルプ文字列HELP-STRINGのシンプルなメニュー
     アイテムである。

‘(TYPE menu-item . DETAILS)’
     これは、拡張されたメニューアイテムでもあるようなバ
     インディングを指定する。これは他の機能も使用できる
     。*note Extended Menu Items::を参照のこと。

‘(t . BINDING)’
     これは“デフォルトキーバインディング(default key
     binding)”を指定する。キーマップの他の要素でバインド
     されないイベントは、バインディングとしてBINDINGが与
     えられる。デフォルトバインディングにより、利用可能
     なすべてのイベント型を列挙することなくバインドでき
     る。デフォルトバインディングをもつキーマップは、明
     示的に‘nil’にバインドされるイベント(以下参照)を除き
     、より低い優先度にあるすべてのキーマップをマスクす
     る。

‘CHAR-TABLE’
     キーマップのある要素が文字テーブル(char-table)の場
     合、それは修飾ビットなしのすべての文字イベントにた
     いするバインディングを保持するとみなされる。 If an
     element of a keymap is a it counts as holding
     bindings for all character events with no modifier
     bits (*note modifier bits::): 要素Nは、コードNの文
     字にたいするバインディングである。これは多量のバイ
     ンディングを記録するための、コンパクトな方法である
     。そのような文字テーブルのキーマップは、“fullキーマ
     ップ(full keymap: 完全なキーマップ)”と呼ばれる。そ
     れにたいし他のキーマップは“sparseキーマップ(sparse
     keymaps: 疎なキーマップ)”と呼ばれる。

‘STRING’
     キーにたいするバインディングを指定する要素は別とし
     て、キーマップは要素として文字列ももつことができる
     。これは“overallプロンプト文字列(overall prompt
     string: 全般的なプロンプト文字列)”と呼ばれ、メニュ
     ーとしてキーマップを使用することを可能にする。*note
     Defining Menus::を参照のこと。

‘(keymap ...)’
     キーマップのある要素それ自身がキーマップの場合、そ
     れは外側のキーマップ内でこれが内側のキーマップとし
     てinline指定されているかのようにみなされる。これは
     ‘make-composed-keymap’内で行なわれるような多重継承
     にたいして使用される。

   バインディングが‘nil’の場合、それは定義の構成要素では
ありませんが、デフォルトバインディングや親キーマップ内の
バインディングに優先されます。一方、‘nil’のバインディン
グは、より低い優先度のキーマップを_オーバーライドしませ
ん_したがって、ローカルマップで‘nil’のバインディングが与
えられた場合、Emacsはグローバルマップのバインディングを
使用します。

   キーマップはメタ文字にたいするバインディングを直接記
録しません。かわりに、メタ文字は１文字目が<ESC>(または何
であれ‘meta-prefix-char’のカレント値)の、2文字のキーシー
ケンスをルックアップするものとみなされます。したがって、
キー‘M-a’は内部的に‘<ESC> a’で表され、そのグローバルバイ
ンディングは、‘esc-map’内の‘a’にたいするスロットで見つけ
ることができます(*note Prefix Keys::を参照)。

   この変換は文字にたいしてのみ適用され、ファンクション
キーや他の入力イベントには適用されないので、‘M-<end>’は
‘<ESC> <end>’と何も関係ありません。

   以下に例としてLispモードにたいするローカルキーマップ
(sparseキーマップ)を挙げます。以下では<DEL>、‘C-c C-z’、
‘C-M-q’、‘C-M-x’にたいするバインディングを定義しています
(実際の値はメニューバインディングも含みますが、簡潔にす
るためここでは省略しています)。

     lisp-mode-map
     ⇒
     (keymap
      (3 keymap
         ;; C-c C-z
         (26 . run-lisp))
      (27 keymap
          ;; ‘C-M-x’は‘<ESC> C-x’として扱われる
          (24 . lisp-send-defun))
      ;; この部分は‘lisp-mode-shared-map’から継承
      keymap
      ;; <DEL>
      (127 . backward-delete-char-untabify)
      (27 keymap
          ;; ‘C-M-q’は‘<ESC> C-q’として扱われる
          (17 . indent-sexp)))

 -- Function: keymapp object
     この関数は、OBJECTがキーマップなら‘t’、それ以外は
     ‘nil’をリターンする。より正確には、この関数はリスト
     にたいしてそのCARが‘keymap’か、あるいはシンボルにた
     いしてその関数定義が‘keymapp’かをテストする。

          (keymapp '(keymap))
              ⇒ t
          (fset 'foo '(keymap))
          (keymapp 'foo)
              ⇒ t
          (keymapp (current-global-map))
              ⇒ t


File: elisp,  Node: Creating Keymaps,  Next: Inheritance and Keymaps,  Prev: Format of Keymaps,  Up: Keymaps

21.4 Creating Keymaps
=====================

以下はキーマップを作成する関数です。

 -- Function: make-sparse-keymap &optional prompt
     この関数はエントリーをもたない新たなsparseキーマッ
     プを作成して、それをリターンする(sparseキーマップは
     、あなたが通常望む類のキーマップのこと)。
     ‘make-keymap’とは異なり、新たなキーマップは文字テー
     ブルを含まず、何のイベントもバインドしない。

          (make-sparse-keymap)
              ⇒ (keymap)

     PROMPTを指定した場合、それはキーマップにたいする
     overallプロンプト文字列になる。これはメニューキーマ
     ップ(*note Defining Menus::を参照)にたいしてのみ指
     定すべきである。overallプロンプト文字列をともなうキ
     ーマップがアクティブな場合は、次の入力イベントのル
     ックアップにたいしてマウスメニューとキーボードメニ
     ューを常に提示する。これはコマンドループにたいして
     毎回キーボードメニューを提示するので、overallプロン
     プト文字列をメインマップ、メジャーモードマップ、マ
     イナーモードマップに指定しないこと。

 -- Function: make-keymap &optional prompt
     この関数は、新たなfullキーマップを作成して、それを
     リターンする。このキーマップは修飾されないすべての
     文字にたいするスロットをもつ文字テーブル(*note
     Char-Tables::を参照)を含む。この新たなキーマップは
     、初期状態ではすべての文字、およびその他の種類のイ
     ベントが‘nil’にバインドされている。引数PROMPTは、
     ‘make-sparse-keymap’のようにプロンプト文字列を指定
     する。

          (make-keymap)
              ⇒ (keymap #^[nil nil keymap nil nil nil ...])

     fullキーマップは、多くのスロットを保持するときは
     sparseキーマップより効果的であり、少ししかスロット
     を保持しないときはsparseキーマップのほうが適してい
     る。

 -- Function: copy-keymap keymap
     この関数は、KEYMAPのコピーをリターンする。KEYMAP内
     でバインディングとして直接出現するすべてのキーマッ
     プも、すべてのレベルまで再帰的にコピーされる。しか
     し、ある文字の定義が関数定義にキーマップをもつ関数
     のときは、再帰的なコピーは行われず、新たにコピーさ
     れたキーマップには同じシンボルがコピーされる。

          (setq map (copy-keymap (current-local-map)))
          ⇒ (keymap
               ;; (これはメタ文字を実装する)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))

          (eq map (current-local-map))
              ⇒ nil
          (equal map (current-local-map))
              ⇒ t


File: elisp,  Node: Inheritance and Keymaps,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

21.5 Inheritance and Keymaps
============================

キーマップは、他のキーマップを継承することができ、この継
承元のキーマップを“親キーマップ(parent keymap)”と呼びま
す。そのようなキーマップは、以下のようなキーマップです:

     (keymap ELEMENTS... . PARENT-KEYMAP)

これの効果は、このキーマップがキールックアップ時に
PARENT-KEYMAPのすべてのバインディングを継承するが、それ
らにバインディングを追加したり、ELEMENTSでオーバーライド
できるということです。

   ‘define-key’や他のキーバインディング関数を使用して
PARENT-KEYMAP内のバインディングを変更した場合、変更され
たバインディングはELEMENTSで作られたバインディングに
shadowされない限り、継承されたキーマップ内で可視になりま
す。逆は真ではありません。‘define-key’を使用して継承され
たキーマップ内のバインディングを変更した場合、これらの変
更はELEMENTS内に記録されますが、PARENT-KEYMAPに影響はあ
りません。

   親キーマップからキーマップを構築するには、
‘set-keymap-parent’を使用するのが正しい方法です。親キー
マップから直接キーマップを構築するコードがある場合は、か
わりに‘set-keymap-parent’を使用するようにプログラムを変
更してください。

 -- Function: keymap-parent keymap
     これは、KEYMAPの親キーマップをリターンする。
     KEYMAPに親キーマップがない場合、‘keymap-parent’は
     ‘nil’をリターンする。

 -- Function: set-keymap-parent keymap parent
     これはKEYMAPの親キーマップをPARENTにセットして、
     PARENTをリターンする。PARENTが‘nil’の場合、この関数
     はKEYMAPに親キーマップを与えない。

     KEYMAPがサブマップ(プレフィクスキーにたいするバイン
     ディング)をもつ場合は、それらも新たな親キーマップを
     受け取り、それらのプレフィクスキーにたいして
     PARENTが何を指定するかが反映される。

   以下は‘text-mode-map’から継承してキーマップを作成する
方法を示す例です:

     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map text-mode-map)
       map)

   非sparseキーマップも親キーマップをもつことができます
が、便利とは言えません。非sparseキーマップは、修飾ビット
をもたないすべての数値文字コードにたいするバインディング
として、たとえそれが‘nil’であっても常に何かを指定するの
で、これらの文字のバインディングが親キーマップから継承さ
れることは決してないのです。

   複数のマップからキーマップを継承したいときがあるかも
しれません。これにたいしては、関数
‘make-composed-keymap’が使用できます。

 -- Function: make-composed-keymap maps &optional parent
     この関数は、既存のキーマップから構成される新たなキ
     ーマップをリターンする。また、オプションで親キーマ
     ップPARENTから継承する。MAPSには単一のキーマップ、
     または複数のキーマップのリストを指定できる。リター
     ンされた新たなマップ内でキーをルックアップするとき
     、EmacsはMAPS内のキーマップを順に検索してから
     PARENT内を検索する。この検索は最初のマッチで停止さ
     れる。MAPSのどれか1つのキーマップ内の‘nil’バインデ
     ィングは、PARENT内の任意のバインディングをオーバー
     ライドするが、MAPSにないキーマップの非‘nil’バインデ
     ィングはオーバーライドしない。

For example, here is how Emacs sets the parent of 【
FIXME】たとえば、以下は‘button-buffer-map’と
‘special-mode-map’の両方を継承する‘help-mode-map’のよう
なキーマップの親キーマップをEmacsがセットする方法です:

     (defvar help-mode-map
       (let ((map (make-sparse-keymap)))
         (set-keymap-parent map
           (make-composed-keymap button-buffer-map special-mode-map))
         ... map) ... )


File: elisp,  Node: Prefix Keys,  Next: Active Keymaps,  Prev: Inheritance and Keymaps,  Up: Keymaps

21.6 Prefix Keys
================

“プレフィクスキー(prefix key)”とは、バインディングがキー
マップであるようなキーシーケンスです。このキーマップは、
プレフィクスキーを拡張するキーシーケンスが何を行うか定義
します。たとえば、‘C-x’はプレフィクスキーであり、これは
キーマップを使用し、そのキーマップは変数‘ctl-x-map’にも
格納されています。このキーマップは‘C-x’で始まるキーシー
ケンスにたいするバインディングを定義します。

   標準的なEmacsのプレフィクスキーのいくつかは、Lisp変数
でも見い出すことができるキーマップを使用していますl:

   • ‘esc-map’は、プレフィクスキー<ESC>にたいするグロー
     バルキーマップである。したがって、すべてのメタ文字
     にたいする定義は、このキーマップで見つけることがで
     きる。このマップは、‘ESC-prefix’の関数定義でもある
     。

   • ‘help-map’は、プレフィクスキー‘C-h’にたいするグロー
     バルキーマップである。

   • ‘mode-specific-map’は、プレフィクスキー‘C-c’にたい
     するグローバルキーマップである。このマップは実際に
     はモード特有(mode-specific)ではなくグローバルである
     が、このプレフィクスキーは主にモード特有なバインデ
     ィングに使用されるので、‘C-h
     b’(‘display-bindings’)の出力内の‘C-c’に関する情報で
     、この名前は有意義な情報を提供する。

   • ‘ctl-x-map’は、プレフィクスキー‘C-x’にたいして使用
     されるグローバルキーマップである。このマップは、シ
     ンボル‘Control-X-prefix’の関数セルを通して見つける
     ことができる。

   • ‘mule-keymap’は、プレフィクスキー‘C-x <RET>’ にたい
     して使用されるグローバルキーマップである。

   • ‘ctl-x-4-map’は、プレフィクスキー‘C-x 4’にたいして
     使用されるグローバルキーマップである。

   • ‘ctl-x-5-map’は、プレフィクスキー‘C-x 5’にたいして
     使用されるグローバルキーマップである。

   • ‘2C-mode-map’は、プレフィクスキー‘C-x 6’にたいして
     使用されるグローバルキーマップである。

   • ‘vc-prefix-map’は、プレフィクスキー‘C-x v’にたいし
     て使用されるグローバルキーマップである。

   • ‘goto-map’は、プレフィクスキー‘M-g’にたいして使用さ
     れるグローバルキーマップである。

   • ‘search-map’は、プレフィクスキー‘M-s’にたいして使用
     されるグローバルキーマップである。

   • ‘facemenu-keymap’は、プレフィクスキー‘M-o’にたいし
     て使用されるグローバルキーマップである。

   • Emacsの他のプレフィクスキーには‘C-x @’、‘C-x a i’、
     ‘C-x <ESC>’、‘<ESC> <ESC>’がある。これらは、特別な
     名前をもたないキーマップを使用する。

   プレフィクスキーのキーマップバインディングは、プレフ
ィクスキーに続くイベントをルックアップするために使用され
ます。(これは、関数定義がキーマップであるようなシンボル
かもしれません。効果は同じですが、シンボルはプレフィクス
キーにたいする名前の役割を果たします。) したがって、
‘C-x’のバインディングはシンボル‘Control-X-prefix’であり
、このシンボルの関数セルが‘C-x’コマンドにたいするキーマ
ップを保持します(‘ctl-x-map’の値も同じキーマップです)。

   プレフィクスキー定義は、任意のアクティブなキーマップ
内に置くことができます。プレフィクスキーとしての‘C-c’、
‘C-x’、‘C-h’、<ESC>の定義はグローバルマップ内にもあるの
で、これらのプレフィクスキーは常に使用できます。メジャー
モードとマイナーモードは、ローカルマップやマイナーモード
のマップ内にプレフィクスキー定義を置くことにより、キーを
プレフィクスキーとして再定義できます。 *note Active
Keymaps::を参照してください。

   あるキーが複数のアクティブなマップ内でプレフィクスキ
ーとして定義されている場合、それぞれの定義がマージされて
効果をもちます。まずマイナーモードキーマップ内で定義され
たコマンド、次にローカルマップのプレフィクス定義されたコ
マンド、そしてグローバルマップのコマンドが続きます。

   以下の例では、ローカルキーマップ内で‘C-p’を‘C-x’と等
価なプレフィクスキーにしています。すると、‘C-p C-f’にた
いするバインディングは、‘C-x C-f’と同様に関数
‘find-file’になります。キーシーケンス‘C-p 6’は、すべての
アクティブなキーマップで見つけることができません。

     (use-local-map (make-sparse-keymap))
         ⇒ nil
     (local-set-key "\C-p" ctl-x-map)
         ⇒ nil
     (key-binding "\C-p\C-f")
         ⇒ find-file

     (key-binding "\C-p6")
         ⇒ nil

 -- Function: define-prefix-command symbol &optional
          mapvar prompt
     この関数は、プレフィクスキーのバインディングとして
     使用するために、SYMBOLを用意する。これはsparseキー
     マップを作成して、それをSYMBOLの関数定義として格納
     する。その後はSYMBOLにキーシーケンスをバインディン
     グすると、そのキーシーケンスはプレフィクスキーにな
     るだろう。リターン値は‘symbol’である。

     この関数は、値がそのキーマップであるような変数とし
     てもSYMBOLをセットする。しかしMAPVARが非‘nil’の場合
     は、かわりにMAPVARを変数としてセットする。

     PROMPTが非‘nil’の場合、これはそのキーマップにたいす
     るoverallプロンプト文字列になる。プロンプト文字列は
     メニューキーマップにたいして与えられるべきである
     (*note Defining Menus::を参照)。


File: elisp,  Node: Active Keymaps,  Next: Searching Keymaps,  Prev: Prefix Keys,  Up: Keymaps

21.7 Active Keymaps
===================

Emacsは多くのキーマップを含んでいますが、常にいくつかの
キーマップだけが“アクティブ”です。Emacsがユーザー入力を
受け取ったとき、それは入力イベントに変換されて(*note
Translation Keymaps::を参照)、アクティブなキーマップ内で
キーバインディングが照合されます。

   アクティブなキーマップは通常、(1) ‘keymap’プロパティ
により指定されるキーマップ、(2) 有効なマイナーモードのキ
ーマップ、(3) カレントバッファーのローカルキーマップ、
(4) グローバルキーマップの順です。Emacsは入力キーシーケ
ンスそれぞれにたいして、これらすべてのキーマップ内を検索
します。

   これらの“通常”のキーマップのうち最優先されるのは、も
しあればポイント位置の‘keymap’テキストにより指定されるキ
ーマップ、またはoverallプロパティです。(マウス入力イベン
トにたいしては、Emacsはポイント位置のかわりにイベント位
置を使用する。 *note Searching Keymaps::を参照のこと。)

   次に優先されるのは、有効なマイナーモードにより指定さ
れるキーマップです。もしあれば、これらのキーマップは変数
‘emulation-mode-map-alists’、
‘minor-mode-overriding-map-alist’、
‘minor-mode-map-alist’により指定されます。*note
Controlling Active Maps::を参照してください。

   次に優先されるのは、バッファーの“ローカルキーマップ
(local keymap)”で、これにはそのバッファー特有なキーバイ
ンディングが含まれます。ミニバッファーもローカルキーマッ
プをもちます(*note Intro to Minibuffers::を参照)。ポイン
ト位置に‘local-map’テキスト、またはoverlayプロパティがあ
る場合、それはバッファーのデフォルトローカルキーマップの
かわりに使用するローカルキーマップを指定します。

   ローカルキーマップは通常はそのバッファーのメジャーモ
ードによりセットされます。同じメジャーモードをもつすべて
のバッファーは、同じローカルキーマップを共有します。した
がって、あるバッファーでローカルキーマップを変更するため
に‘local-set-key’(*note Key Binding Commands::を参照)を
呼び出した場合、それは同じメジャーモードをもつ他のバッフ
ァーのローカルキーマップにも影響を与えます。

   最後は、‘C-f’のようなカレントバッファーとは関係なく定
義されるキーバインディングを含む、“グローバルキーマップ
(global keymap)”です。kこのキーマップは常にアクティブで
あり、変数‘global-map’にバインドされています。

   これら“通常”のキーマップとは別に、Emacsはプログラムが
他のキーマップをアクティブにするための特別な手段を提供し
ます。1つ目は、グローバルキーマップ以外の通常アクティブ
なキーマップを置き換えるキーマップを指定する変数
‘overriding-local-map’です。2つ目は、他の_すべて_のキー
マップより優先されるキーマップを指定する、端末ローカル変
数‘overriding-terminal-local-map’です。この端末ローカル
変数は通常、modal(訳注: 他のキーマップを選択できない状態
)かつ一時的なキーバインディングに使用されます(ここの変数
にたいして関数‘set-transient-map’は便利なインターフェイ
スを提供する)。詳細は、*note Controlling Active Maps::を
参照のこと。

   これらを使用するのがキーマップをアクティブにする唯一
の方法ではありません。キーマップは、
‘read-key-sequence’によるイベントの変換のような、他の用
途にも使用されます。*note Translation Keymaps::を参照し
てください。

   いくつかの標準的なキーマップのリストは、*note
Standard Keymaps::を参照してください。

 -- Function: current-active-maps &optional olp position
     これは、カレントの状況下でコマンドループによりキー
     シーケンスをルックアップするために使用される、アク
     ティブなキーマップのリストをリターンする。これは通
     常、‘overriding-local-map’と
     ‘overriding-terminal-local-map’を無視するが、OLPが
     非‘nil’の場合には、それらのキーマップにも注意を払う
     。オプションでPOSITIONに‘event-start’によりリターン
     されるイベント位置、またはバッファー位置を指定でき
     、‘key-binding’で説明されているようにキーマップを変
     更するかもしれない。

 -- Function: key-binding key &optional accept-defaults
          no-remap position
     この関数は、カレントのアクティブキーマップでKEYにた
     いするバインディングをリターンする。そのキーマップ
     内でKEYが未定義の場合、結果は‘nil’になる。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(*note Functions
     for Key Lookup::を参照)のようにデフォルトバインディ
     ングをチェックするかを制御する。

     コマンドがリマップ(remap: 再マップ。*note Remapping
     Commands::を参照)されたとき、‘key-binding’は通常、
     実際に実行されるであろうリマップされたコマンドをリ
     ターンするように、コマンドのリマップを行う。しかし
     、NO-REMAPが非‘nil’の場合、‘key-binding’はリマップ
     を無視して、KEYにたいして直接指定されたバインディン
     グをリターンする。

     KEYがマウスイベント(もしかしたらプレフィクスイベン
     トが先行するかもしれない)で始まる場合、照合されるマ
     ップはそのイベントの位置を元に決定される。それ以外
     では、それらのマップはポイント値に基づき決定される
     。しかし、POSITIONを指定することにより、これらをオ
     ーバーライドできる。POSITIONが非‘nil’の場合、それは
     バッファー位置か‘event-start’の値のようなイベント位
     置のいずれかである。その場合、照合されるマップは
     POSITIONに基づき決定される。

     KEYが文字列とベクターのいずれでもない場合、Emacsは
     エラーをシグナルする。

          (key-binding "\C-x\C-f")
              ⇒ find-file


File: elisp,  Node: Searching Keymaps,  Next: Controlling Active Maps,  Prev: Active Keymaps,  Up: Keymaps

21.8 Searching the Active Keymaps
=================================

以下は、macsがアクティブなキーマップを検索する方法を示す
、Lisp処理概要です:

     (or (if overriding-terminal-local-map
             (FIND-IN overriding-terminal-local-map))
         (if overriding-local-map
             (FIND-IN overriding-local-map)
           (or (FIND-IN (get-char-property (point) 'keymap))
               (FIND-IN-ANY emulation-mode-map-alists)
               (FIND-IN-ANY minor-mode-overriding-map-alist)
               (FIND-IN-ANY minor-mode-map-alist)
               (if (get-text-property (point) 'local-map)
                   (FIND-IN (get-char-property (point) 'local-map))
                 (FIND-IN (current-local-map)))))
         (FIND-IN (current-global-map)))

ここで、FIND-INとFIND-IN-ANYはそれぞれ、1つのキーマップ
とキーマップのalistを検索する仮の関数です。関数
‘set-transient-map’が
‘overriding-terminal-local-map’(*note Controlling Active
Maps::を参照)をセットすることにより機能する点に注意して
ください。

   上記の処理概要では、キーシーケンスがマウスイベント
(*note Mouse Events::を参照)で始まる場合、ポイント位置の
かわりにそのイベント位置、カレントバッファーのかわりにそ
のイベントのバッファーが使用されます。これは特に、プロパ
ティ‘keymap’および‘local-map’をルックアップする方法に影
響を与えます。‘display’、‘before-string’、
‘after-string’プロパティ(*note Special Properties::を参
照)が埋め込まれていて、‘keymap’または‘local-map’プロパテ
ィが非‘nil’の文字列上でマウスイベントが発生した場合、そ
れは基調となるバッファーテキストの対応するプロパティをオ
ーバーライドします(バッファーテキストにより指定されたプ
ロパティは無視される)。

   アクティブなキーマップの1つでキーバインディングが見つ
かり、そのバインディングがコマンドの場合、検索は終了し、
そのコマンドが実行されます。しかし、そのバインディングが
値をもつ変数、または文字列の場合、Emacsは入力キーシーケ
ンスをその変数の値、または文字列で置き換えて、アクティブ
なキーマップの検索を再開します。 *note Key Lookup::を参
照してください。

   最終的に見つかったコマンドもリマップされるかもしれま
せん。*note Remapping Commands::を参照してください。


File: elisp,  Node: Controlling Active Maps,  Next: Key Lookup,  Prev: Searching Keymaps,  Up: Keymaps

21.9 Controlling the Active Keymaps
===================================

 -- Variable: global-map
     この変数は、Emacsキーボード入力をコマンドにマップす
     るデフォルトのグローバルキーマップを含む。通常は、
     このキーマップがグローバルキーマップである。デフォ
     ルトグローバルキーマップは、‘self-insert-command’を
     すべてのプリント文字にバインドするfullキーマップで
     ある。

     これはグローバルキーマップ内のバインディングを変更
     する通常の手段だが、この変数に開始時のキーマップ以
     外の値を割り当てるべきではない。

 -- Function: current-global-map
     この関数は、カレントのグローバルキーマップをリター
     ンする。デフォルトグローバルキーマップとカレントグ
     ローバルキーマップのいずれも変更していない場合は、
     ‘global-map’と同じ値になる。リターン値はコピーでは
     なく参照である。これに‘define-key’などの関数を使用
     すると、グローバルバインディングが変更されるだろう
     。

          (current-global-map)
          ⇒ (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 -- Function: current-local-map
     この関数はカレントバッファーのローカルキーマップを
     リターンする。ローカルキーマップがない場合は‘nil’を
     リターンする。以下の例では、(Lisp Interactionモード
     を使用する)‘*scratch*’バッファーにたいするキーマッ
     プは、<ESC>(ASCIIコード27)にたいするエントリーが別
     のsparseキーマップであるようなsparseキーマップであ
     る。

          (current-local-map)
          ⇒ (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

   ‘current-local-map’はローカルキーマップのコピーではな
く参照をリターンする。これに‘define-key’などの関数を使用
すると、ローカルバインディングが変更されるだろう。

 -- Function: current-minor-mode-maps
     この関数は、カレントで有効なメジャーモードのキーマ
     ップリストをリターンする。

 -- Function: use-global-map keymap
     この関数は、KEYMAPを新たなカレントグローバルキーマ
     ップにする。これは‘nil’をリターンする。

     グローバルキーマップの変更は、異例である。

 -- Function: use-local-map keymap
     この関数は、KEYMAPをカレントバッファーの新たなロー
     カルキーマップにする。KEYMAPが‘nil’の場合、そのバッ
     ファーはローカルキーマップをもたない。
     ‘use-local-map’は‘nil’をリターンする。ほとんどのメ
     ジャーモードコマンドは、この関数を使用する。

 -- Variable: minor-mode-map-alist
     この変数は、アクティブかどうかに関わらず、特定の変
     数の値にたいするキーマップを示すalistである。要素は
     、以下のようになる:

          (VARIABLE . KEYMAP)

     キーマップKEYMAPは、 VARIABLEが非‘nil’値をもつとき
     はアクティブである。通常、VARIABLEはメジャーモード
     を有効、または無効にする変数である。*note Keymaps
     and Minor Modes::を参照のこと。

     ‘minor-mode-map-alist’の要素が、
     ‘minor-mode-alist’の要素と異なる構造をもつことに注
     意されたい。マップは要素のCDRでなければならず、そう
     でなければ2つ目の要素にマップリストは用いられないだ
     ろう。CDRはキーマップ(リスト)、または関数定義がキー
     マップであるようなシンボルである。

     1つ以上のマイナーモードキーマップがアクティブなとき
     、‘minor-mode-map-alist’内で前のキーマップが優先さ
     れる。しかし、互いが干渉しないようにマイナーモード
     をデザインすべきである。これを正しく行えば、順序は
     問題にならない。

     マイナーモードについての詳細な情報は、*note Keymaps
     and Minor Modes::を参照のこと。
     ‘minor-mode-key-binding’(*note Functions for Key
     Lookup::を参照)も確認されたい。

 -- Variable: minor-mode-overriding-map-alist
     この変数は、メジャーモードによる特定のマイナーモー
     ドにたいするキーバインディングのオーバーライドを可
     能にする。このalistの要素は、
     ‘minor-mode-map-alist’の要素のように、‘(VARIABLE .
     KEYMAP)’のような形式である。

     ある変数が‘minor-mode-overriding-map-alist’の要素と
     して出現する場合、その要素により指定されるマップは
     、‘minor-mode-map-alist’内の同じ変数にたいして指定
     される任意のマップを完全に置き換える。

     すべてのバッファーにおいて、
     ‘minor-mode-overriding-map-alist’は自動的にバッファ
     ーローカルである。

 -- Variable: overriding-local-map
     この変数が非‘nil’の場合は、バッファーのローカルキー
     マップ、テキストプロパティまたはoverlayによるキーマ
     ップ、マイナーモードキーマップのかわりに使用される
     するキーマップを保持する。このキーマップが指定され
     た場合、カレントグローバルキーマップ以外のアクティ
     ブだった他のすべてのマップがオーバーライドされる。

 -- Variable: overriding-terminal-local-map
     この変数が非‘nil’の場合は、‘overriding-local-map’、
     バッファーのローカルキーマップ、テキストプロパティ
     またはoverlayによるキーマップ、およびすべてのマイナ
     ーモードキーマップのかわりに使用されるキーマップを
     保持する。

     この変数は、カレント端末にたいして常にローカルであ
     り、バッファーローカルにできない。*note Multiple
     Terminals::を参照のこと。これはインクリメンタル検索
     モードの実装に使用される。

 -- Variable: overriding-local-map-menu-flag
     この変数が非‘nil’の場合は、‘overriding-local-map’ま
     たは‘overriding-terminal-local-map’の値がメニューバ
     ーの表示に影響し得る。デフォルト値は‘nil’なので、こ
     れらのマップ変数なメニューバーに影響をもたない。

     これら2つのマップ変数は、たとえこれらの変数がメニュ
     ーバー表示に影響し得るを与えない場合でも、メニュー
     バーを使用してエンターされたキーシーケンスの実行に
     は影響を与えることに注意されたい。したがって、もし
     メニューバーキーシーケンスが到着したら、そのキーシ
     ーケンスをルックアップ・実行する前に変数をクリアー
     すべきである。この変数を使用するモードは通常、何ら
     かの方法でこれを行っている。これらのモードは通常“読
     み戻し(unread)”とexitにより処理されないイベントに応
     答する。

 -- Variable: special-event-map
     この変数は、スペシャルイベントにたいするキーマップ
     を保持する。あるイベント型がこのキーマップ内でバイ
     ンディングをもつ場合、それはスペシャルであり、その
     イベントにたいするバインディングは‘read-event’によ
     り直接実行される。*note Special Events::を参照のこ
     と。

 -- Variable: emulation-mode-map-alists
     この変数は、エミュレーションモードにたいして使用す
     るキーマップalistのリストを保持する。この変数は、複
     数マイナーモードキーマップを使用するモードとパッケ
     ージを意図している。リストの各要素は
     ‘minor-mode-map-alist’と同じフォーマットと意味をも
     つキーマップalistか、そのようなalist形式の変数バイ
     ンディングをもつシンボルである。それぞれのalist内の
     “アクティブ”なキーマップは、
     ‘minor-mode-map-alist’と
     ‘minor-mode-overriding-map-alist’の前に使用される。

 -- Function: set-transient-map keymap &optional keep
     この関数は“一時的(transient)”なキーマップとして
     KEYMAPを追加する。一時的なキーマップは1つ以上の後続
     するキーにたいして、他のキーマップより優先される。

     通常、KEYMAPは直後のキーをルックアップするために、
     1回だけ使用される。しかし、オプション引数PREDが
     ‘t’の場合、そのマップはユーザーがKEYMAP内で定義され
     たキーをタイプするまでアクのままとなる。KEYMAP内に
     ないキーをユーザーがタイプしたとき、一時的キーマッ
     プは非アクティブとなり、そのキーにたいして通常のキ
     ールックアップが継続される。

     PREDには関数も指定できる。。この場合、KEYMAPがアク
     ティブの間は、各コマンドの実行に優先して、その関数
     が引数なしで呼び出される。KEYMAPがアクティブの間、
     関数は非‘nil’をリターンすべきである。

     この関数は、他のすべてのアクティブなキーマップに優
     先される変数‘overriding-terminal-local-map’にたいし
     て、‘keymap’を追加、または削除することにより機能す
     る(*note Searching Keymaps::を参照)。


File: elisp,  Node: Key Lookup,  Next: Functions for Key Lookup,  Prev: Controlling Active Maps,  Up: Keymaps

21.10 Key Lookup
================

“キールックアップ(key lookup: キー照合)”とは、与えられた
キーマップからキーシーケンスのバインディングを見つけ出す
ことです。そのバインディングの使用や実行は、キールックア
ップの一部ではありません。

   キールックアップは、キーシーケンス内の各イベントのイ
ベント型だけを使用し、そのイベントの残りは無視します。実
際のところ、キールックアップに使用されるキーシーケンスは
、マウスイベントをイベント全体(リスト)のかわりにイベント
型のみ(シンボル)を用いるでしょう。*note Input Events::を
参照してください。そのような“キーシーケンス”は、
‘command-execute’による実行には不十分ですが、キーのルッ
クアップやリバインドには十分です。

   キーシーケンスが複数イベントから構成されるとき、キー
ルックアップはイベントを順に処理します。最初のイベントの
バインディングが見つかったとき、それはキーマップでなけれ
ばなりません。そのキーマップ内で2つ目のイベントを見つけ
出し、そのキーシーケンス内のすべてのイベントが消費される
まで、このプロセスを続けます(故に、最後のイベントにたい
して見つかったイベントはキーマップかどうかわからない)。
したがって、キールックアッププロセスは、キーマップ内で単
一イベントを見つけ出す、よりシンプルなプロセスで定義され
ます。これが行なわれる方法は、キーマップ内でそのイベント
に関連するオブジェクトの型に依存します。

   キーマップ内のイベント型ルックアップによる値発見を説
明するために、“キーマップエントリー(keymap entry)”という
用語を導入しましょう。(これにはメニューアイテムにたいす
るキーマップ内のアイテム文字列や、他の余計な要素は含まれ
ません。なぜなら、‘lookup-key’や他のキーマップルックアッ
プ関数が、リターン値にそれらを含まないからです。) 任意の
Lispオブジェクトがキーマップエントリーとしてキーマップに
格納されるかもしれませんが、すべてがキールックアップに意
味をもつわけではありません。以下のテーブルは、キーマップ
エントリーで重要な型です:

‘nil’
     ‘nil’は、それまでにルックアップに使用されたイベント
     が、未定義キーを形成することを意味する。最終的にキ
     ーマップがイベント型を調べるのに失敗して、デフォル
     トバインディングも存在しないときは、そのイベント型
     のバインディングが‘nil’であるのと同じである。

COMMAND
     それまでにルックアップに使用されたイベントがコンプ
     リートキーを形成し、そのバインディングはCOMMANDであ
     る。*note What Is a Function::を参照のこと。

ARRAY
     array(文字列かベクター)は、キーボードマクロである。
     それまでにルックアップに使用されたイベントはコンプ
     リートキーを形成し、そのバインディングはarrayである
     。詳細は*note Keyboard Macros::を参照のこと。

KEYMAP
     それまでにルックアップに使用されたイベントはプレフ
     ィクスキーを形成する。そのキーシーケンスの次のイベ
     ントは、KEYMAP内でルックアップされる。

LIST
     listの意味は、そのリストが何を含んでいるかに依存す
     る:

        • LISTのCARがシンボル‘keymap’の場合、そのリスト
          はキーマップであり、キーマップとして扱われる
          (上記参照)。

        • LISTのCARが‘lambda’の場合、そのリストはラムダ
          式である。これは関数とみなされ、そのように扱わ
          れる(上記参照)。キーバインディングとして正しく
          実行されるために、この関数はコマンドでなければ
          ならず、‘interactive’指定をもたなければならな
          い。*note Defining Commands::を参照のこと。

        • LISTのCARがキーマップでCDRがイベント型の場合、
          これは“インダイレクトエントリー(indirect
          entry: 間接エントリー)”である:

               (OTHERMAP . OTHERTYPE)

          キールックアップはインダイレクトエントリーに遭
          遇したときは、かわりにOTHERMAP内でOTHERTYPEの
          バインディングをルックアップして、それを使用す
          る。

          この機能により、あるキーを他のキーにたいする
          alistとして定義することが可能になる。たとえば
          、CARが‘esc-map’と呼ばれるキーマップで、CDRが
          32(<SPC>のコード)の場合は、“それが何であろうと
          ‘Meta-<SPC>’のグローバルバインディングを使用す
          る”ことを意味する。

SYMBOL
     SYMBOLの関数定義がSYMBOLのかわりに使用される。もし
     関数定義もシンボルの場合は、任意の回数このプロセス
     が繰り返される。これは最終的にキーマップであるよう
     なオブジェクト、コマンド、またはキーボードマクロに
     行き着くはずである。それがキーマップかコマンドの場
     合はリストも許されるが、シンボルを通じて見つけ出さ
     れた場合、インダイレクトエントリーは理解されない。

     キーマップおよびキーボードマクロ(文字列かベクター
     )は有効な関数ではないので、関数定義にキーマップ、文
     字列、ベクターをもつシンボルは、関数としては無効で
     あることに注意されたい。しかし、キーバインディング
     としては有効である。その定義がキーボードマクロの場
     合、そのシンボルは‘command-execute’(*note
     Interactive Call::を参照)の引数としても有効である。

     シンボル‘undefined’は特記するに値する。これはそのキ
     ーを未定義として扱うことを意味する。厳密に言うと、
     そのキーは定義されているが、そのバインディングがコ
     マンド‘undefined’なのである。しかし、このコマンドは
     未定義キーにたいして自動的に行われるのと同じことを
     行う。これは(‘ding’を呼び出して)bellを鳴らすが、エ
     ラーはシグナルしない。

     ‘undefined’は、グローバルキーバインディングをオーバ
     ーライドして、そのキーをローカルに“未定義”にするた
     めに使用される。‘nil’にローカルにバインドしても、グ
     ローバルバインディングをオーバーライドしないであろ
     うから、これを行うのに失敗するだろう。

ANYTHING ELSE
     オブジェクトの他の型が見つかった場合、それまでにル
     ックアップで使用されたイベントはコンプリートキーを
     形成し、そのオブジェクトがバインディングになるが、
     そのバインディングはコマンドとして実行不可能である
     。

   要約すると、キーマップエントリーはキーマップ、コマン
ド、キーボードマクロ、あるいはそれらに導出されるシンボル
、インダイレクトエントリー、あるいは‘nil’のいずれかです
。


File: elisp,  Node: Functions for Key Lookup,  Next: Changing Key Bindings,  Prev: Key Lookup,  Up: Keymaps

21.11 Functions for Key Lookup
==============================

以下は、キールックアップに関連する関数および変数です。

 -- Function: lookup-key keymap key &optional
          accept-defaults
     この関数は、KEYMAP内のKEYの定義をリターンする。この
     チャプターで説明されている、キーをルックアップする
     他のすべての関数が‘lookup-key’を使用する。以下は例
     である:

          (lookup-key (current-global-map) "\C-x\C-f")
              ⇒ find-file
          (lookup-key (current-global-map) (kbd "C-x C-f"))
              ⇒ find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              ⇒ 2

     文字列、またはベクターのKEYが、KEYMAP内で指定される
     プレフィクスキーとして有効なキーシーケンスでない場
     合、それは最後に余計なイベントをもつ、単一のキーシ
     ーケンスに適合しない、“長過ぎる”キーのはずである。
     その場合のリターン値は数となり、この数はコンプリー
     トキーを構成するKEYの前にあるイベントの数である。

     ACCEPT-DEFAULTSが非‘nil’の場合、‘lookup-key’はKEY内
     の特定のイベントにたいするバインディングと同様に、
     デフォルトバインディングも考慮する。それ以外では、
     ‘lookup-key’は特定のKEYのシーケンスにたいするバイン
     ディングだけを報告し、明示的に指定したとき以外はデ
     フォルトバインディングを無視する。(これを行うには、
     KEYの要素として‘t’を与える。*note Format of
     Keymaps::を参照のこと。)

     KEYがメタ文字(ファンクションキーではない)を含む場合
     その文字は暗黙に‘meta-prefix-char’の値と対応する非
     メタ文字からなる、2文字シーケンスに置き換えられる。
     したがって、以下に1つ目の例は、2つ目の例に変換され
     て処理される。

          (lookup-key (current-global-map) "\M-f")
              ⇒ forward-word
          (lookup-key (current-global-map) "\ef")
              ⇒ forward-word

     ‘read-key-sequence’とは異なり、この関数は指定された
     イベントの情報を破棄する変更(*note Key Sequence
     Input::を参照)を行わない。特に、この関数はアルファ
     ベット文字を小文字に変更せず、ドラッグイベントをク
     リックイベントに変更しない。

 -- Command: undefined
     キーを未定義にするために、キーマップ内で使用される
     。これは‘ding’を呼び出すが、エラーを起こさない。

 -- Function: local-key-binding key &optional
          accept-defaults
     この関数は、カレントのローカルキーマップ内の、KEYに
     たいするバインディングをリターンする。カレントのロ
     ーカルキーマップ内で未定義の場合は、‘nil’をリターン
     する。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じよう
     に、デフォルトバインディングのチェックを制御する。

 -- Function: global-key-binding key &optional
          accept-defaults
     この関数は、カレントのグローバルキーマップ内で、コ
     マンドKEYにたいするバインディングをリターンする。カ
     レントのグローバルキーマップ内で未定義の場合は、
     ‘nil’をリターンする。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じよう
     に、デフォルトバインディングのチェックを制御する。

 -- Function: minor-mode-key-binding key &optional
          accept-defaults
     この関数は、アクティブなマイナーモードのKEYのバイン
     ディングを、リストでリターンする。より正確には、こ
     の関数は‘(MODENAME . BINDING)’のとうなペアーの
     alistをリターンする。ここでMODENAMEなそのマイナーモ
     ードを有効にする変数、BINDINGはそのモードでのKEYの
     バインディングである。KEYがマイナーモードバインディ
     ングをみたない場合、値は‘nil’である。

     最初に見つかったバインディングがプレフィクス定義(キ
     ーマップ、またはキーマップとして定義されたシンボル
     )でない場合は、他のマイナーモード由来のすべての後続
     するバインディングは、完全にshadowされるため省略さ
     れる。同様に、このリストはプレフィクスバインディン
     グに後続する非プレフィクスバインディングは省略され
     る。

     引数ACCEPT-DEFAULTSは、‘lookup-key’(上記)と同じよう
     に、デフォルトバインディングのチェックを制御する。

 -- User Option: meta-prefix-char
     この変数はメタ/プレフィクス文字コードである。これは
     メタ文字をキーマップ内でルックアップできるように、
     2文字シーケンスに変換する。有用な結果を得るために、
     値はプレフィクスイベント(*note Prefix Keys::を参照
     )であること。デフォルト値は27で、これは<ESC>にたい
     するASCIIコードである。

     ‘meta-prefix-char’の値が27であるような限り、キール
     ックアップは通常‘backward-word’コマンドとして定義さ
     れる‘M-b’を、‘<ESC> b’に変換する。しかし、
     ‘meta-prefix-char’を24(‘C-x’のコード)にセットした場
     合、Emacsは‘M-b’を‘C-x b’に変換するだろうが、これの
     標準のバインディングは‘switch-to-buffer’コマンドで
     ある。以下に何が起こるかを示す(実際にこれを行っては
     ならない!):

          meta-prefix-char                    ; デフォルト値
               ⇒ 27
          (key-binding "\M-b")
               ⇒ backward-word
          ?\C-x                               ; 文字.の
               ⇒ 24                          ; プリント表現
          (setq meta-prefix-char 24)
               ⇒ 24
          (key-binding "\M-b")
               ⇒ switch-to-buffer            ; 今や‘M-b’をタイプすると
                                              ;   ‘C-x b’をタイプしたようになる

          (setq meta-prefix-char 27)          ; 混乱を避ける!
               ⇒ 27                          ; デフォルト値をリストア!

     この単一イベントから２イベントへの変換は文字にたい
     してのみ発生し、他の種類の入力イベントには発生しな
     い。したがって、ファンクションキー‘M-<F1>’は‘<ESC>
     <F1>’に変換されない。

