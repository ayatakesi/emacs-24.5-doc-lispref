This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Remapping Commands,  Next: Translation Keymaps,  Prev: Changing Key Bindings,  Up: Keymaps

21.13 Remapping Commands
========================

あるコマンドから他のコマンドへの“リマップ(remap)”には、特別な種類のキー
バインディングが使用できます。この機能を使用するためには、ダミーイベント
‘remap’で始まり、その後にリマップしたいコマンド名が続くようなキーシーケ
ンスにたいするキーバインディングを作成します。そして、そのバインディング
にたいしては、新たな定義(通常はコマンド名だが、キーバインディングにたい
して有効な他の任意の定義を指定可能)を指定します。

   たとえば、Myモードというモードが、‘kill-line’のかわりに呼び出される
‘my-kill-line’という特別なコマンドを提供するとします。これを設定するには
、このモードのキーマップに以下のようなリマッピングが含まれるはずです:

     (define-key my-mode-map [remap kill-line] 'my-kill-line)

その後は、‘my-mode-map’がアクティブなときは常に、ユーザーが
‘C-k’(‘kill-line’についてデフォルトのグローバルキーシーケンス)をタイプす
ると、Emacsはかわりに‘my-kill-line’を実行するでしょう。

   リマップはアクティブなキーマップでのみ行なわれることに注意してくださ
い。たとえば、‘ctl-x-map’のようなプレフィクスキーマップ内にリマッピング
を置いても、そのようなキーマップはそれ自体がアクティブでないので、通常は
効果がありません。それに加えて、リマップは1レベルを通じてのみ機能します
。以下の例では、

     (define-key my-mode-map [remap kill-line] 'my-kill-line)
     (define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)

これは‘kill-line’を‘my-other-kill-line’にリマップ_しません_。かわりに、
通常のキーバインディングが‘kill-line’を指定する場合は、それが
‘my-kill-line’にリマップされます。通常のバインディングが‘my-kill-line’を
指定した場合は、‘my-other-kill-line’にリマップされます。

   コマンドのリマップをアンドゥするには、以下のようにそれを‘nil’にリマッ
プします：

     (define-key my-mode-map [remap kill-line] nil)

 -- Function: command-remapping command &optional position keymaps
     この関数は、カレントアクティブキーマップにより与えられる、
     COMMAND(シンボル)にたいするリマッピングをリターンする。COMMANDがリ
     マップされていない(これは普通の状況である)、またはシンボル以外の場
     合、この関数は‘nil’をリターンする。‘position’は、‘key-binding’の場
     合と同様、使用するキーマップを決定するために、オプションバッファー
     位置、またはイベント位置をオプションで指定できる。

     オプション引数‘keymaps’が非‘nil’の場合、それは検索するキーマップの
     リストを指定する。この引数は、‘position’が非‘nil’の場合は無視される
     。


File: elisp,  Node: Translation Keymaps,  Next: Key Binding Commands,  Prev: Remapping Commands,  Up: Keymaps

21.14 Keymaps for Translating Sequences of Events
=================================================

‘read-key-sequence’関数がキーシーケンス(*note Key Sequence Input::を参照
)を読み取るときは、特定のイベントシーケンスを他のものに変換(translate)す
るために、“変換キーマップ(translation keymaps)”を使用します。
‘input-decode-map’、‘local-function-key-map’、‘key-translation-map’(優先
順)は変換キーマップです。

   変換キーマップは、他のキーマップと同じ構造をもちますが、使われ方は異
なります。変換キーマップは、キーシーケンスを読み取るときに、コンプリート
キーシーケンスにたいするバインディングではなく、キーシーケンスに行う変換
を指定します。キーシーケンスが読み取られると、それらのキーシーケンスは変
換キーマップにたいしてチェックされます。ある変換キーマップがKをベクター
Vに“バインド”する場合、キーシーケンス内の_どこか_にサブシーケンスとして
Kが出現すると、それはVないのでイベントに置き換えられます。

   たとえば、キーパッドキー<PF1>が押下されたとき、VT100端末は‘<ESC> O
P’を送信します。そのような端末では、Emacsはそのイベントシーケンスを単一
イベント‘pf1’に変換しなければなりません。これは、‘input-decode-map’内で
‘<ESC> O P’を‘[pf1]’に“バインド”することにより行われます。したがって、そ
の端末上で‘C-c <PF1>’をタイプしたとき、端末は文字シーケンス‘C-c <ESC> O
P’を発行し、‘read-key-sequence’がそれを‘C-c <PF1>’に変換してベクター
‘[?\C-c pf1]’としてリターンします。

   変換キーマップは、(‘keyboard-coding-system’で指定された入力コーディン
グシステムを通じて)Emacsがキーボード入力をデコードした直後だけ効果をもち
ます。*note Terminal I/O Encoding::を参照してください。

 -- Variable: input-decode-map
     この変数は、通常の文字端末上のファンクションキーから送信された文字
     シーケンスを記述するキーマップを保持する。

     ‘input-decode-map’の値は、通常はその端末のTerminfoかTermcapのエント
     リーに応じて、自動的にセットアップされるが、Lispの端末仕様ファイル
     の助けが必要なときもある。Emacsには、多くの一般的な端末の端末仕様フ
     ァイルが同梱されている。これらのファイルの主な目的は、Termcapや
     Terminfoから推定できないエントリーを‘input-decode-map’内に作成する
     ことである。*note Terminal-Specific::を参照のこと。

 -- Variable: local-function-key-map
     この変数は、‘input-decode-map’と同じようにキーマップを保持するが、
     通常優先される解釈候補(alternative interpretation)に変換されるべき
     キーシーケンスを記述するキーマップを保持する。このキーマップは
     ‘input-decode-map’の後、‘key-translation-map’の前に適用される。

     ‘local-function-key-map’内のエントリーは、マイナーモード、ローカル
     キーマップ、グローバルキーマップによるバインディングと衝突する場合
     は無視される。つまり、元のキーシーケンスが他にバインディングをもた
     ない場合だけ、リマッピングが適用される。

     ‘local-function-key-map’が‘function-key-map’を継承するが、
     ‘function-key-map’を直接使用すべきではない。

 -- Variable: key-translation-map
     この変数は、入力イベントを他のイベントに変換するために、
     ‘input-decode-map’と同じように使用される、別のキーマップを保持する
     。‘input-decode-map’との違いは、‘local-function-key-map’の前ではな
     く、後に機能する点である。このキーマップは、
     ‘local-function-key-map’による変換結果を受け取る。

     ‘input-decode-map’と同様、ただし‘local-function-key-map’とは異なり
     、このキーマップは入力キーシーケンスが通常のバインディングをもつか
     どうかかに関わらず適用される。しかし、このキーマップによりキーバイ
     ンディングがオーバーライドされても、‘key-translation-map’では実際の
     キーバインディングが効果をもち得ることに注意されたい。確かに、実際
     のキーバインディングは‘local-function-key-map’をオーバーライドし、
     したがって‘key-translation-map’が受け取るキーシーケンスは変更される
     だろう。明確にするためには、このような類の状況は避けたほうがよい。

     ‘key-translation-map’は、通常は‘self-insert-command’にバインディン
     グされるような通常文字を含めて、ユーザーがある文字を他の文字にマッ
     プすることを意図している。

   キーシーケンスのかわりにキーの“変換”として関数を使用することにより、
シンプルなエイリアスより多くのことに‘input-decode-map’、
‘local-function-key-map’、‘key-translation-map’を使用できます。その場合
、この関数はそのキーの変換を計算するために呼び出されます。

   キー変換関数は、引数を1つ受け取ります。この引数は
‘read-key-sequence’内で指定されるプロンプトです。キーシーケンスがエディ
ターコマンドループに読み取られる場合は、‘nil’です。ほとんどの場合、プロ
ンプト値は無視できます。

   関数が自身で入力を読み取る場合、その関数は後続のイベントを変更する効
果をもつことができます。たとえば、以下は‘C-c h’をハイパー文字に後続する
文字とするために定義する方法の例です:

     (defun hyperify (prompt)
       (let ((e (read-event)))
         (vector (if (numberp e)
                     (logior (lsh 1 24) e)
                   (if (memq 'hyper (event-modifiers e))
                       e
                     (add-event-modifier "H-" e))))))

     (defun add-event-modifier (string e)
       (let ((symbol (if (symbolp e) e (car e))))
         (setq symbol (intern (concat string
                                      (symbol-name symbol))))
         (if (symbolp e)
             symbol
           (cons symbol (cdr e)))))

     (define-key local-function-key-map "\C-ch" 'hyperify)

21.14.1 Interaction with normal keymaps
---------------------------------------

そのキーシーケンスがコマンドにバインドされたとき、またはさらにイベントを
追加してもコマンドにバインドされるシーケンスにすることができないと
Emacsが判断したときに、キーシーケンスの終わりが検出されます。

   これは、元のキーシーケンスがバインディングをもつかどうかに関わらず、
‘input-decode-map’および‘key-translation-map’を適用するとき、そのような
バインディングが変換の開始を妨げることを意味します。たとえば、前述の
VT100の例に戻って、グローバルマップに‘C-c <ESC>’を追加してみましょう。す
ると、ユーザーが‘C-c <PF1>’をタイプしたとき、Emacsは‘C-c <ESC> O P’を
‘C-c <PF1>’に変換するのに失敗するでしょう。これは、Emacsが‘C-x <ESC>’の
直後に読み取りを停止して、‘O P’は読み取られずに残るからです。この場合、
ユーザーが実際に‘C-c <ESC>’をタイプした場合、ユーザーが実際に‘<ESC>’を押
下したのか、あるいは‘<PF1>’を押下したのか判断するために、Emacsが待つべき
ではないのです。

   この理由により、キーシーケンスの終わりがキー変換のプレフィクスである
ようなキーシーケンスをコマンドにバインドするのは、避けたほうがよいでしょ
う。そのような問題を起こす主なサフィックス、およびプレフィクスは
‘<ESC>’、‘M-O’(実際は‘<ESC> O’)、‘M-[’(実際は‘<ESC> [’)です。


File: elisp,  Node: Key Binding Commands,  Next: Scanning Keymaps,  Prev: Translation Keymaps,  Up: Keymaps

21.15 Commands for Binding Keys
===============================

このセクションでは、キーバインディングを変更するための便利な対話的インタ
ーフェイスを説明します。これらは‘define-key’を呼び出すことにより機能しま
す。

   ユーザーはinitファイルにたいしてシンプルなカスタマイズを行うとき、し
ばしば‘global-set-key’を使用します。たとえば、

     (global-set-key (kbd "C-x C-\\") 'next-line)

または

     (global-set-key [?\C-x ?\C-\\] 'next-line)

または

     (global-set-key [(control ?x) (control ?\\)] 'next-line)

は、次の行に移動するように‘C-x C-\’を再定義します。

     (global-set-key [M-mouse-1] 'mouse-set-point)

は、メタキーを押してマウスの第一ボタン(左ボタン)をクリックすると、クリッ
クした箇所にポイントをセットするように再定義します。

   バインドするキーのLisp指定に非ASCII文字のテキストを使用するときは、注
意してください。マルチバイトとして読み取られたテキストがある場合には、
Lispファイル内でマルチバイトテキストが読み取られるときのように(*note
Loading Non-ASCII::)、マルチバイトとしてキーをタイプしなければなりません
。たとえば、

     (global-set-key "ö" 'my-function) ; bind o-umlaut

または

     (global-set-key ?ö 'my-function) ; bind o-umlaut

をLatin-1のマルチバイト環境で使用した場合、これらのコマンドはLatin-1端末
より送信されたバイトコード246(‘M-v’)ではなく、コード246のマルチバイト文
字に実際にバインドされます。このバインディングを使用するためには、適切な
入力メソッド(*note Input Methods: (emacs)Input Methods.を参照)を使用して
、キーボードをデコードする方法をEmacsに教える必要があります。

 -- Command: global-set-key key binding
     この関数は、カレントグローバルマップ内で、KEYのバインディングを
     BINDINGにセットする。

          (global-set-key KEY BINDING)
          ≡
          (define-key (current-global-map) KEY BINDING)

 -- Command: global-unset-key key
     この関数は、カレントグローバルマップから、KEYのバインディングを削除
     する。

     プレフィクスとしてKEYを使用する、長いキーの定義の準備に使用するのも
     、この関数の1つの使い方である。KEYが非プレフィクスのようなバインデ
     ィングをもつ場合、この使い方は許されないだろう。たとえば、

          (global-unset-key "\C-l")
              ⇒ nil
          (global-set-key "\C-l\C-l" 'redraw-display)
              ⇒ nil

     この関数は、以下のように‘define-key’を使用するのと等しい:

          (global-unset-key KEY)
          ≡
          (define-key (current-global-map) KEY nil)

 -- Command: local-set-key key binding
     この関数は、カレントローカルキーマップ内のKEYのバインディングを、
     BINDINGにセットする。

          (local-set-key KEY BINDING)
          ≡
          (define-key (current-local-map) KEY BINDING)

 -- Command: local-unset-key key
     この関数は、カレントローカルキーマップから、KEYのバインディングを削
     除する。

          (local-unset-key KEY)
          ≡
          (define-key (current-local-map) KEY nil)


File: elisp,  Node: Scanning Keymaps,  Next: Menu Keymaps,  Prev: Key Binding Commands,  Up: Keymaps

21.16 Scanning Keymaps
======================

このセクションでは、すべてのカレントキーマップをスキャンして、ヘルプ情報
をプリントするために使用される関数を説明します。

 -- Function: accessible-keymaps keymap &optional prefix
     この関数は、(0個以上のプレフィクスキーを通じて)KEYMAPから到達可能な
     、すべてのキーマップのリストをリターンする。リターン値は‘(KEY .
     MAP)’のような形式の要素をもつ連想配列(alist)である。ここで、KEYは
     KEYMAP内での定義がMAPであるようなプレフィクスキーである。

     alistの要素は、KEYの長さにたいして昇順にソートされている。1つ目の要
     素は、常に‘([] . KEYMAP)’である。これは、指定されたキーマップがイベ
     ントなしのプレフィクスにより、自分自身からアクセス可能だからである
     。

     PREFIXが与えられた場合、それはプレフィクスキーシーケンスである。そ
     の場合には、PREFIXで始まるプレフィクスキーをもつサブマップだけが
     ‘accessible-keymaps’に含まれる。これらの要素の意味は、
     ‘(accessible-keymaps)’の値の場合と同様であり、いくつかの要素が省略
     されている点だけが異なる。

     以下の例では、リターンされるalistにより、‘^[’と表示されるキー
     <ESC>がプレフィクスキーであり、その定義がsparseキーマップ‘(keymap
     (83 . center-paragraph) (115 . foo))’であること示される。

          (accessible-keymaps (current-local-map))
          ⇒(([] keymap
                (27 keymap   ; 以降<ESC>にたいするこのキーマップが繰り返されることに注意
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))

             ("^[" keymap
              (83 . center-paragraph)
              (115 . foo)))

     また以下の例では、‘C-h’は‘(keymap (118 . describe-variable)...)’で
     始まるsparseキーマップを使用するプレフィクスキーである。他のプレフ
     ィクス‘C-x 4’は、変数‘ctl-x-4-map’の値でもあるキーマップを使用する
     。イベント‘mode-line’は、ウィンドウの特別な箇所でのマウスイベントに
     たいするプレフィクスとして使用される、いくつかのダミーイベントのう
     ちの1つである。

          (accessible-keymaps (current-global-map))
          ⇒ (([] keymap [set-mark-command beginning-of-line ...
                             delete-backward-char])
              ("^H" keymap (118 . describe-variable) ...
               (8 . help-for-help))
              ("^X" keymap [x-flush-mouse-queue ...
               backward-kill-sentence])
              ("^[" keymap [mark-sexp backward-sexp ...
               backward-kill-word])
              ("^X4" keymap (15 . display-buffer) ...)
              ([mode-line] keymap
               (S-mouse-2 . mouse-split-window-horizontally) ...))

     これらは実際に目にするであろうキーマップのすべてではない。

 -- Function: map-keymap function keymap
     関数‘map-keymap’は、KEYMAP内のバインディングそれぞれにたいして1回
     FUNCTIONを呼び出す。呼び出す際の引数はイベント型と、そのバインディ
     ングの値の2つである。KEYMAPに親キーマップがある場合は、その親キーマ
     ップのバインディングも含まれる。これは再帰的に機能する。つまり、そ
     の親キーマップ自身が親キーマップをもつ場合は、それのバインディング
     も含まれる、といった具合である。

     これは、キーマップ内のすべてのバインディングを検証する、もっとも明
     快な方法である。

 -- Function: where-is-internal command &optional keymap firstonly
          noindirect no-remap
     この関数は、‘where-is’コマンド(*note Help: (emacs)Help.を参照)によ
     り使用されるサブルーチンである。これは、キーマップのセット内で
     COMMANDにバインドされる、(任意の長さの)キーシーケンスすべてのリスト
     をリターンする。

     引数COMMANDには、任意のオブジェクトを指定できる。このオブジェクトは
     、すべてのキーマップエントリーにたいし、‘eq’を使用して比較される。

     KEYMAPが‘nil’の場合、‘overriding-local-map’の値とは無関係に
     (‘overriding-local-map’の値が‘nil’であると装い)、カレントアクティブ
     キーマップをマップとして使用する。KEYMAPがキーマップの場合は、
     KEYMAPとグローバルキーマップが検索されるマップとなる。KEYMAPがキー
     マップのリストの場合は、それらのキーマップだけが検索される。

     KEYMAPにたいする式としては、通常は‘overriding-local-map’を使用する
     のが最善である。その場合、‘where-is-internal’は正にアクティブなキー
     マップを検索する。グローバルマップだけを検索するには、KEYMAPの値に
     ‘(keymap)’(空のキーマップ)を渡せばよい。

     FIRSTONLYが‘non-ascii’の場合、値はすべての可能なキーシーケンスのリ
     ストではなく、最初に見つかったキーシーケンスを表す単一のベクターと
     なる。FIRSTONLYが‘t’の場合、値は最初のキーシーケンスだが、全体が
     ASCII文字(またはメタ修飾されたASCII文字)で構成されるキーシーケンス
     が、他のすべてのキーシーケンスに優先され、リターン値がメニューバイ
     ンディングになることは決してない。

     NOINDIRECTが非‘nil’の場合、‘where-is-internal’はインダイレクトキー
     マップ(indirect keymap: 間接キーマップ)のバインディングを追跡しない
     。これにより、インダイレクト定義自体にたいして検索が可能になる。

     5つ目の引数NO-REMAPは、この関数がコマンドリマッピング(*note
     Remapping Commands::を参照)を扱う方法を決定する。興味深いケースが
     2つある:

     コマンドOTHER-COMMANDがCOMMANDにリマップされる場合:
          NO-REMAPが‘nil’の場合は、OTHER-COMMANDにたいするバインディング
          を探して、COMMANDにたいするバインディングであるかのようにそれ
          らを扱う。NO-REMAPが非‘nil’の場合は、それらのバインディングを
          探すかわりに、利用可能なキーシーケンスリストに、ベクター
          ‘[remap OTHER-COMMAND]’を含める。

     If COMMAND is remapped to OTHER-COMMAND:
          NO-REMAPが‘nil’の場合は、COMMANDではなくOTHER-COMMANDにたいす
          るバインディングをリターンする。NO-REMAPが非‘nil’の場合は、リ
          マップされていることを無視して、COMMANDにたいするバインディン
          グをリターンする。

 -- Command: describe-bindings &optional prefix buffer-or-name
     この関数は、すべてのカレントキーバインディングのリストを作成して、
     ‘*Help*’という名前のバッファーにそれを表示する。テキストはモードご
     とにグループ化され、順番はマイナーモード、メジャーモード、グローバ
     ルバインディングの順である。

     PREFIXが非‘nil’の場合、それはプレフィクスキーである。その場合、リス
     トに含まれるのはPREFIXで始まるキーだけになる。

     複数の連続するASCIIコードが同じ定義をもつとき、それらは
     ‘FIRSTCHAR..LASTCHAR’のようにまとめて表示される。この場合、それがど
     の文字に該当するかを理解するためには、そのASCIIコードを知っている必
     要がある。たとえば、デフォルトグローバルマップでは、文字‘<SPC> ..
     ~’は1行で記述される。<SPC>はASCIIの32，‘~’はASCIIの126で、その間の
     すべての文字には、通常のプリント文字(アルファベット文字、数字、句読
     点など)が含まれる。これらの文字はすべて、‘self-insert-command’にバ
     インドされる。

     BUFFER-OR-NAMEが非‘nil’の場合、それはバッファー、またはバッファー名
     である。その場合、‘describe-bindings’はカレントバッファーのかわりに
     、そのバッファーのバインディングをリストする。


File: elisp,  Node: Menu Keymaps,  Prev: Scanning Keymaps,  Up: Keymaps

21.17 Menu Keymaps
==================

キーマップは、キーボードキーやマウスボタンにたいするバインディング定義と
同様に、メニューとして操作することができます。メニューは、通常はマウスに
より操作されますが、キーボードでも機能させことができます。次の入力イベン
トにたいしてメニューキーマップがアクティブな場合は、キーボードメニュー機
能がアクティブになります。

* Menu:

* Defining Menus::           メニューを定義するキーマップを作成する方法。
* Mouse Menus::              ユーザーがマウスでメニューを操作する方法。
* Keyboard Menus::           ユーザーがキーボードでメニューを操作する方法。
* Menu Example::             シンプルなメニューの作成。
* Menu Bar::                 メニューバーのカスタマイズ方法。
* Tool Bar::                 イメージ行のツールバー。
* Modifying Menus::          メニューへ新たなアイテムを追加する方法。
* Easy Menu::                メニュー作成のための便利なマクロ。


File: elisp,  Node: Defining Menus,  Next: Mouse Menus,  Up: Menu Keymaps

21.17.1 Defining Menus
----------------------

キーマップが“overallプロンプト文字列(overall prompt string)”をもつ場合、
そのキーマップはメニューとして動作します。overallプロンプト文字列とは、
キーマップの要素として表される文字列です(*note Format of Keymaps::を参照
)。この文字列には、メニューコマンドの目的を記述します。Emacsは、(もしあ
れば)メニュー表示に使用されるツールキットに応じ、メニュータイトルとして
overallメニュー文字列を表示します(1)。キーボードメニューもoverallプロン
プト文字列を表示します。

   プロンプト文字列をもつキーマップを構築するもっとも簡単な方法は、
‘make-keymap’、‘make-sparse-keymap’(*note Creating Keymaps::を参照)、
‘define-prefix-command’(*note Definition of define-prefix-command::を参
照)を呼び出すときに引数で文字列を指定する方法です。キーマップをメニュー
として操作したくない場合は、これらの関数にたいしてプロンプト文字列を指定
しないでください。

 -- Function: keymap-prompt keymap
     この関数は、KEYMAPのoverallプロンプト文字列を、もしなければ‘nil’を
     リターンする。

   メニューのアイテムは、そのキーマップ内のバインディングです。各バイン
ディングはイベント型と定義を関連付けますが、イベント型はメニューの外見に
何の意味ももちません(通常は、イベント型としてキーボードが生成できない擬
似イベントのシンボルをメニューアイテムのバインディングに使用する)。メニ
ュー全体は、これらのイベントにたいするキーマップ内のバインディングから生
成されます。

   メニュー内のアイテムの順序は、キーマップ内のバインディングの順序と同
じです。‘define-key’は新たなバインディングを先頭に置くので、メニューアイ
テムの順序が重要な場合は、メニューの最後から先頭へメニューアイテムを定義
する必要があります。既存のメニューにアイテムを追加するときは、
‘define-key-after’を使用してメニュー内の位置を指定できます(*note
Modifying Menus::を参照)。

* Menu:

* Simple Menu Items::        単純なメニューのキーバインディング。
* Extended Menu Items::      複雑なメニューアイテムの定義。
* Menu Separators::          メニューに水平ラインを描画する。
* Alias Menu Items::         メニューアイテムにコマンドエイリアスを使用する。

   ---------- Footnotes ----------

   (1) これはテキスト端末ののような、ツールキットを使用しないメニューに
たいして要求されます。


File: elisp,  Node: Simple Menu Items,  Next: Extended Menu Items,  Up: Defining Menus

21.17.1.1 Simple Menu Items
...........................

メニューアイテムを定義する単純(かつ初歩的)な方法は、何らかのイベント型
(何のイベント型かは問題にならない)を以下のようにバインドすることです:

     (ITEM-STRING . REAL-BINDING)

CARのITEM-STRINGは、メニュー内で表示される文字列です。これは短いほうがよ
く、1から3の単語が望ましいでしょう。この文字列は、対応するコマンドの動作
を説明します。すべてのグラフィカルツールキットが非ASCIIテキストを表示で
きる訳ではないことに注意してください(キーボードメニューとGTK+ツールキッ
トの大部分では機能するだろう)。

   以下のように、ヘルプ文字列と呼ばれる2つ目の文字列を与えることもできま
す:

     (ITEM-STRING HELP . REAL-BINDING)

HELPは、マウスがそのアイテム上にあるときに、‘help-echo’テキストプロパテ
ィ(*note Help display::を参照)と同じ方法で表示される“help-echo”文字列を
指定します。

   ‘define-key’に関する限り、ITEM-STRINGとHELP-STRINGは、そのイベントの
バインディングの一部です。しかし、‘lookup-key’は単にREAL-BINDINGだけをリ
ターンし、そのキーの実行にはREAL-BINDINGだけが使用されます。

   REAL-BINDINGが‘nil’の場合、メニューにITEM-STRINGは表示されまづが、選
択できなくなります。

   REAL-BINDINGがシンボルで、‘menu-enable’プロパティが非‘nil’の場合、そ
のプロパティはメニューアイテムが有効か無効かを制御する式です。メニュー表
示にキーマップが使用されるたびに、Emacsはその式を評価して、式の値が非
‘nil’の場合だけ、そのメニューのメニューアイテムを有効にします。メニュー
アイテム無効なとき、そのアイテムは“fuzzy”形式で表示され、選択できなくな
ります。

   メニューバーはメニューを調べる際に、どのアイテムが有効なのか再計算し
ません。これは、Xツールキットが事前にメニュー全体を要求するからです。メ
ニューバーの再計算を強制するには、‘force-mode-line-update’を呼び出してく
ださい(*note Mode Line Format::を参照)。


File: elisp,  Node: Extended Menu Items,  Next: Menu Separators,  Prev: Simple Menu Items,  Up: Defining Menus

21.17.1.2 Extended Menu Items
.............................

メニューアイテムの拡張フォーマットは、単純なフォーマットに比べて、より柔
軟かつ明快です。拡張フォーマットでは、メニューアイテムにバインドのイベン
ト型に、シンボル‘menu-item’で始まるシンボルのリストを指定します。選択で
きない文字列にたいしては、以下のようなバインディングになります:

     (menu-item ITEM-NAME)

2つ以上のダッシュで始まる文字列は、リストのセパレーターを指定します。
*note Menu Separators::を参照してください。

   選択可能な実際のメニューアイテムを定義するには、以下のような拡張フォ
ーマットでバインドします:

     (menu-item ITEM-NAME REAL-BINDING
         . ITEM-PROPERTY-LIST)

ここで、ITEM-NAMEはメニューアイテム文字列を評価する式です。つまり、文字
列は底数である必要はありません。3つ目の引数REAL-BINDINGは、実行するコマ
ンドです。リストの最後の要素ITEM-PROPERTY-LISTは、プロパティリストの形式
をもつ、その他の情報を含みます。

   以下は、サポートされるプロパティのテーブルです:

‘:enable FORM’
     FORMの評価結果は、そのアイテムを有効にするかどうかを決定する(非
     ‘nil’の場合は有効)。アイテムが無効な場合は、実際にクリックできない
     。

‘:visible FORM’
     FORMの評価結果は、そのアイテムを実際にメニューに表示するかどうかを
     決定する(非‘nil’の場合は表示)。アイテムが非表示の場合は、そのアイテ
     ムが定義されていないかのようにメニューが表示される。

‘:help HELP’
     このプロパティHELPの値は、そのアイテム上にマウスがある間表示する
     “help-echo”文字列を指定する。この文字列は、‘help-echo’テキストプロ
     パティ(*note Help display::を参照)と同じ方法で表示される。これは、
     テキストやoverlayにたいする‘help-echo’プロパティと異なり、文字列定
     数でなければならないことに注意されたい。

‘:button (TYPE . SELECTED)’
     このプロパティは、ラジオボタンおよびトグルボタンを定義する手段を提
     供する。CARのTYPEは、‘:toggle’か‘:radio’のいずれかを指定する。CDRの
     SELECTEDはフォームで、評価結果によりそのボタンがカレントで選択され
     ているかどうかを指定する。

     “トグル(toggle)”は、SELECTEDの値に応じて“on”か“off”のいずれかがラベ
     ルされるメニューアイテムである。コマンド自身は、SELECTEDが‘nil’なら
     ‘t’に、‘t’なら‘nil’にSELECTEDを切り替える(toggle)こと。以下は、
     ‘debug-on-error’フラグが定義されているときに、メニューアイテムをト
     グルする方法の例である:

          (menu-item "Debug on Error" toggle-debug-on-error
                     :button (:toggle
                              . (and (boundp 'debug-on-error)
                                     debug-on-error)))

     これは、‘toggle-debug-on-error’が変数‘debug-on-error’をトグルするコ
     マンドとして定義されていることにより機能する。

     “ラジオボタン”とは、メニューアイテムのグループであり、常にただ1つの
     メニューアイテムだけが“選択される(selected)”。そのためには、どのメ
     ニューアイテムが選択されているかを示す変数が存在する必要がある。グ
     ループ内の各ラジオボタンにたいするSELECTEDフォームは、そのボタンを
     選択するために、その変数が正しい値をもつかどうかをチェックする。そ
     して、ボタンのクリックにより変数をセットして、クリックされたボタン
     が選択される。

‘:key-sequence KEY-SEQUENCE’
     このプロパティは、そのメニューアイテムにより呼び出されるのと同じコ
     マンドにバインドされるかもしれないキーシーケンスを指定する。正しい
     キーシーケンスを指定した場合は、メニュー表示の準備がより高速になる
     。

     間違ったキーシーケンスを指定した場合は、何の効果もない。Emacsは、メ
     ニュー内のKEY-SEQUENCEを表示する前に、実際にそのKEY-SEQUENCEがその
     メニューアイテムと等価なのか検証する。

‘:key-sequence nil’
     このプロパティは、そのメニューアイテムには等価なキーバインディング
     が通常は存在しないことを示す。このプロパティを使用することにより、
     Emacsはそのメニューアイテムにたいして等価なキーボード入力をキーマッ
     プから検索する必要がなくなるので、メニュー表示の準備時間が短縮され
     る。

     しかし、ユーザーがそのアイテムの定義をキーシーケンスにリバインドし
     た場合、Emacsは‘:keys’プロパティを無視して、結局は等価なキーボード
     入力を見つけ出す。

‘:keys STRING’
     このプロパティは、そのメニューにたいする等価なキーボード入力として
     表示される文字列STRINGを指定する。STRING内では、ドキュメント構成
     ‘\\[...]’を使用できる。

‘:filter FILTER-FN’
     このプロパティは、メニューアイテムを直接計算する手段を提供する。こ
     のプロパティの値FILTER-FNは、引数が1つの関数で、呼び出し時の引数は
     REAL-BINDINGである。この関数は、かわりに使用するバインディングをリ
     ターンするべきである。

     Emacsは、メニューデータ構造を再表示、または操作する任意のタイミング
     でこの関数を呼び出し得るので、いつ呼び出されても安全なように関数を
     記述すべきである。


File: elisp,  Node: Menu Separators,  Next: Alias Menu Items,  Prev: Extended Menu Items,  Up: Defining Menus

21.17.1.3 Menu Separators
.........................

メニューセパレーターは、テキストを表示するかわりに、水平ラインでメニュー
をサブパーツに分割する、メニューアイテムの一種です。メニューキーマップ内
で、セパレーターは以下のように見えます:

     (menu-item SEPARATOR-TYPE)

ここで、SEPARATOR-TYPEは2つ以上のダッシュで始まる文字列です。

   もっとも単純なケースでは、ダッシュだけでSEPARATOR-TYPEが構成されます
。これはデフォルトのセパレーターを指定します(互換性のため、‘""’と‘-’もセ
パレーターとみなされる)。

   SEPARATOR-TYPEにたいする他の特定の値は、異なるスタイルのセパレーター
を指定します。以下はそれらのテーブルです:

‘"--no-line"’
‘"--space"’
     実際のラインではない、余分な垂直スペース。

‘"--single-line"’
     メニューのforegroundカラーの一重ライン。

‘"--double-line"’
     メニューのforegroundカラーの二重ライン。

‘"--single-dashed-line"’
     メニューのforegroundカラーの一重ダッシュライン。

‘"--double-dashed-line"’
     メニューのforegroundカラーの二重ダッシュライン。

‘"--shadow-etched-in"’
     3Dの窪んだ外観(3D sunken appearance)をもつ一重ライン。これはダッシ
     ュだけで構成されるセパレーターに使用されるデフォルトである。

‘"--shadow-etched-out"’
     3Dの浮き上がった外観(3D raised appearance)をもつ一重ライン。

‘"--shadow-etched-in-dash"’
     3Dの窪んだ外観(3D sunken appearance)をもつ一重ダッシュライン。

‘"--shadow-etched-out-dash"’
     3Dの浮き上がった外観(3D raised appearance)をもつ一重ダッシュライン
     。

‘"--shadow-double-etched-in"’
     3Dの窪んだ外観をもつ二重ライン。

‘"--shadow-double-etched-out"’
     3Dの浮き上がった外観をもつ二重ライン。

‘"--shadow-double-etched-in-dash"’
     3Dの窪んだ外観をもつ二重ダッシュライン。

‘"--shadow-double-etched-out-dash"’
     3Dの浮き上がった外観をもつ二重ダッシュライン。

   2連ダッシュの後にコロンを追加して、1連ダッシュの後の単語の先頭の文字
を大文字にすることにより、別のスタイルで名前を与えることもできます。つま
り、‘"--:singleLine"’は‘"--single-line"’と等価です。

   メニューセパレーターにたいして‘:enable’や‘:visible’のようなキーワード
を指定するために、長い形式を使用できます。

   ‘(menu-item SEPARATOR-TYPE nil . ITEM-PROPERTY-LIST)’

   たとえば:

     (menu-item "--" nil :visible (boundp 'foo))

   いくつかのシステムおよびディスプレイツールキットは、これらすべてのセ
パレータータイプを実際に処理しません。サポートされないタイプのセパレータ
ーを使用した場合、メニューはサポートされている似た種別のセパレーターを表
示します。


File: elisp,  Node: Alias Menu Items,  Prev: Menu Separators,  Up: Defining Menus

21.17.1.4 Alias Menu Items
..........................

“同じ”コマンドを使用するが、有効条件が異なるメニューアイテムを作成すると
便利な場合が時折あります。Emacsでこれを行う最善の方法は、拡張メニューア
イテム(extended menu item)です。この機能が存在する以前は、エイリアスコマ
ンドを定義して、それらをメニューアイテムで使用することによりこれを行って
いました。以下は、‘read-only-mode’にたいする2つのエイリアスを作成して、
それらに異なる有効条件を与える例です:

     (defalias 'make-read-only 'read-only-mode)
     (put 'make-read-only 'menu-enable '(not buffer-read-only))
     (defalias 'make-writable 'read-only-mode)
     (put 'make-writable 'menu-enable 'buffer-read-only)

   メニュー内でエイリアスを使用するときは、エイリアスではなく“実際”のコ
マンド名にたいする等価なキーバインディングを表示するのが便利な場合が多々
あります(エイリアスはメニュー自身を除きキーバインディングを通常はもたな
い)。これを要求するには、エイリアスシンボルに‘menu-alias’プロパティに非
‘nil’を与えます。したがって、

     (put 'make-read-only 'menu-alias t)
     (put 'make-writable 'menu-alias t)

は、‘make-read-only’と‘make-writable’にたいするメニューアイテムに、
‘read-only-mode’のキーバインディングを表示します。


File: elisp,  Node: Mouse Menus,  Next: Keyboard Menus,  Prev: Defining Menus,  Up: Menu Keymaps

21.17.2 Menus and the Mouse
---------------------------

メニューキーマップがメニューを生成する通常の方法は、それをプレフィクスキ
ーの定義とすることです。(Lispプログラムは明示的にメニューをポップアップ
して、ユーザーの選択を受け取ることができる。*note Pop-Up Menus::を参照の
こと。)

   プレフィクスキーがマウスイベントで終わる場合、ユーザーがマウスで選択
できるように、Emacsは可視なメニューをポップアップすることによりメニュー
キーマップを処理します。ユーザーがメニューアイテムをクリックしたときは、
そのメニューアイテムによりもたらされるバインディングの文字、またはシンボ
ルが何であれ、イベントが生成されます(メニューが複数レベルをもつ場合やメ
ニューバー由来の場合、メニューアイテムは1連のイベントを生成するかもしれ
ない)。

   メニューのトリガーにbutton-downイベントを使用するのが最善な場合もしば
しばあります。その場合、ユーザーはマウスボタンをリリースすることにより、
メニューアイテムを選択できます。

   メニューキーマップがネストされたキーマップにたいするバインディングを
含む場合、そのネストされたキーマップは“サブメニュー(submenu)”を指定しま
す。それにはネストされたキーマップのアイテム文字列によりラベル付けされた
メニューアイテムがあり、そのアイテムをクリックすることにより、指定された
サブメニューが自動的にポップアップされます。特別な例外として、メニューキ
ーマップが単一のネストされたキーマップを含み、それ以外のメニューアイテム
を含まない場合、そのメニューはネストされたキーマップの内容を、サブメニュ
ーとしてではなく、直接メニューに表示します。

   しかし、XツールキットのサポートなしでEmacsをコンパイルした場合、また
はテキスト端末の場合、サブメニューはサポートされません。ネストされたキー
マップはメニューアイテムとして表示されますが、それをクリックしても、サブ
メニューは自動的にポップアップされません。サブメニューの効果を模倣したい
場合は、ネストされたキーマップに‘@’で始まるアイテム文字列を与えることに
より、これを行うことができます。これにより、Emacsは別個の“メニューペイン
(menu pane)”を使用してネストされたキーマップを表示します。‘@’の後の残り
のアイテム文字列は、そのペインのラベルです。Xツールキットのサポートなし
でEmacsをコンパイルした場合、またはメニューがテキスト端末で表示されてい
る場合、メニューペインは使用されません。この場合、アイテム文字列の先頭の
‘@’は、メニューラベル表示時には省略され、他に効果はありません。


File: elisp,  Node: Keyboard Menus,  Next: Menu Example,  Prev: Mouse Menus,  Up: Menu Keymaps

21.17.3 Menus and the Keyboard
------------------------------

キーボードイベント(文字かファンクションキー)で終わるプレフィクスキーがメ
ニューキーマップであるような定義をもつとき、そのキーマップはキーボードメ
ニューのように動作します。ユーザーは、キーボードでメニューアイテムを選択
して、次のイベントを指定します。

   Emacsは、エコーエリアにキーボードメニュー、そのマップのoverallプロン
プト文字列、その後に候補(そのマップのバインディングのアイテム文字列)を表
示します。そのバインディングを一度に全部表示できない場合、ユーザーは
<SPC>をタイプして、候補の次の行を確認できます。連続して<SPC>を使用すると
メニューの最後に達し、その後は先頭へ巡回します。(変数
‘menu-prompt-more-char’はこのために使用する文字を指定する。デフォルトは
<SPC>。)

   ユーザーがメニューから望ましい候補を見つけたら、バインディングがその
候補であるような、対応する文字をタイプする必要があります。

 -- Variable: menu-prompt-more-char
     この変数は、メニューの次の行を確認するために使用する文字を指定する
     。初期値は32で、これは<SPC>のコードである。


File: elisp,  Node: Menu Example,  Next: Menu Bar,  Prev: Keyboard Menus,  Up: Menu Keymaps

21.17.4 Menu Example
--------------------

以下は、メニューキーマップを定義する、完全な例です。これは、メニューバー
内の‘Edit’メニューにサブメニュー‘Replace’を定義して、その定義内で拡張メ
ニューフォーマット(*note Extended Menu Items::を参照)を使用します。例で
はまずキーマップを作成して、それに名前をつけます:

     (defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))

次にメニューアイテムを定義します:

     (define-key menu-bar-replace-menu [tags-repl-continue]
       '(menu-item "Continue Replace" tags-loop-continue
                   :help "Continue last tags replace operation"))
     (define-key menu-bar-replace-menu [tags-repl]
       '(menu-item "Replace in tagged files" tags-query-replace
                   :help "Interactively replace a regexp in all tagged files"))
     (define-key menu-bar-replace-menu [separator-replace-tags]
       '(menu-item "--"))
     ;; ...

バインディングがそのシンボルのために“作成された”ことに注意してください。
これらのシンボルは、定義されるキーシーケンス内の角カッコ内に記述されます
。このシンボルはコマンド名と同じときもあれば、異なることもあります。これ
らのシンボルは“ファンクションキー”として扱われますが、これらはキーボード
上の実際のファンクションキーではありません。これらはメニュー自体の機能に
影響しませんが、ユーザーがメニューから選択したときにエコーエリアに“エコ
ー”され、‘where-is’と‘apropos’の出力に現れます。

   この例のメニューは、マウスによる使用を意図しています。もしキーボード
の使用を意図したメニュー、つまりキーボードイベントで終了するキーシーケン
スにバインドされたメニューの場合、メニューアイテムはキーボードでタイプで
きる文字、または“実際”のファンクションキーにバインドされるべきです。

   定義が‘("--")’のバインディングは、セパレーターラインです。実際のメニ
ューアイテムと同様、セパレーターはキーシンボルをもち、この例では
‘separator-replace-tags’です。1つのメニューが2つのセパレーターをもつ場合
、それらは2つの異なるキーシンボルをもたなければなりません。

   以下では、親メニュー内のアイテムとしてこのメニューがどのように表示さ
れるかを記述しています:

     (define-key menu-bar-edit-menu [replace]
       (list 'menu-item "Replace" menu-bar-replace-menu))

これは、シンボル‘menu-bar-replace-menu’自体ではなく、変数
‘menu-bar-replace-menu’の値であるサブメニューキーマップを組み込むことに
注意してください。‘menu-bar-replace-menu’はコマンドではないので、親メニ
ューアイテムにそのシンボルを使用するのは無意味です。

   同じreplaceメニューをマウスクリックに割り当てたい場合は、以下のように
これを行うことができます:

     (define-key global-map [C-S-down-mouse-1]
        menu-bar-replace-menu)


File: elisp,  Node: Menu Bar,  Next: Tool Bar,  Prev: Menu Example,  Up: Menu Keymaps

21.17.5 The Menu Bar
--------------------

Emacsは通常、各フレームの最上部に“メニューバー(menu bar)”を表示します。
*note (emacs)Menu Bars::を参照してください。メニューバーのアイテムは、ア
クティブキーマップ内で定義される偽りの“ファンクションキー”‘menu-bar’のサ
ブコマンドです。

   メニューバーにアイテムを追加するには、自分で偽りの“ファンクションキー
”(これをKEYと呼ぶことにしましょう)を創作して、キーシーケンス‘[menu-bar
KEY]’にたいするキーバインディングを作成します。ほとんどの場合において、
そのバインディングはメニューキーマップなので、メニューバーアイテム上でボ
タンを押下すると、他のメニューに導かれます。

   メニューバーにたいして同じ“ファンクションキー”を定義するアクティブな
キーマップが1つ以上存在するとき、そのアイテムは1回だけ出現します。ユーザ
ーがメニューバーのそのアイテムをクリックした場合、そのアイテムのすべての
サブコマンド— グローバルサブコマンド、ローカルサブコマンド、マイナーモー
ドサブコマンドが組み合わされた単一のメニューを表示します。

   変数‘overriding-local-map’は通常、メニューバーのコンテンツを決定する
際は無視されます。つまり、メニューバーは‘overriding-local-map’が‘nil’の
場合にアクティブになるであろうキーマップから計算されます。*note Active
Keymaps::を参照してください。

   以下は、メニューバーのアイテムをセットアップする例です:

     ;; (プロンプト文字列とともに)メニューキーマップを作成して
     ;; それをメニューバーアイテムの定義にする
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))

     ;; メニュー内に具体的なサブコマンドを定義する
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))
     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

   ローカルキーマップは、グローバルキーマップにより作成されたメニューバ
ーアイテムにたいして、同じ偽ファンクションキーを‘undefined’にリバインド
してキャンセルすることができます。たとえば、以下はDiredが‘Edit’メニュー
バーアイテムを抑制する方法です:

     (define-key dired-mode-map [menu-bar edit] 'undefined)

ここで、‘edit’は‘Edit’メニューバーアイテムにたいしてグローバルキーマップ
により使用される偽ファンクションキーです。グローバルメニューバーアイテム
を抑制する主な理由は、モード特有のアイテムのためのスペースを確保するため
です。

 -- Variable: menu-bar-final-items
     通常メニューバーナーグローバルアイテムの後にローカルマップにより定
     義されるアイテムを表示する。

     この変数は、通常の順番による位置ではなく、メニューの最後に表示する
     アイテムのための偽ファンクションキーのリストを保持する。デフォルト
     値は‘(help-menu)’である。したがって、‘Help’メニューアイテムはメニュ
     ーバーの最後、ローカルメニューアイテムの後に表示される。

 -- Variable: menu-bar-update-hook
     このノーマルフックは、メニューバーの再表示の前に、メニューバーのコ
     ンテンツを更新するための再表示により実行される。コンテンツを変化さ
     せる必要があるメニューの更新に使用できる。このフックは頻繁に実行さ
     れるので、フックが呼び出す関数は、通常の場合は長い時間を要さないこ
     とを確実にするよう助言する。

   Emacsは、すべてのメニューバーアイテムの隣に、(もしそのようなキーバイ
ンディングが存在するなら)同じコマンドを実行するキーバインディングを表示
します。これは、キーバインディングを知らないユーザーにたいして便利なヒン
トを与える役目をもちます。コマンドが複数のバインディングをもつ場合、通常
Emacsは最初に見つけたバインディングを表示します。コマンドのシンボルプロ
パティ‘:advertised-binding’に割り当てることにより、特定のキーバインディ
ングを指定できます。*note Keys in Documentation::を参照してください。


File: elisp,  Node: Tool Bar,  Next: Modifying Menus,  Prev: Menu Bar,  Up: Menu Keymaps

21.17.6 Tool bars
-----------------

“ツールバー(tool bar)”とは、フレームの最上部、メニューバー直下にある、ク
リック可能なアイコンの行のことです。*note (emacs)Tool Bars::を参照してく
ださい。Emacsは通常、グラフィカルなディスプレイ上でツールバーを表示しま
す。

   各フレームでは、ツールバーに何行分の高さを割り当てるかを、フレームパ
ラメーター‘tool-bar-lines’が制御します。値0は、ツールバーを抑制します。
値が非0で、‘auto-resize-tool-bars’が非‘nil’の場合、指定されたコンテンツ
を維持するのに必要な分、ツールバーは拡大縮小されます。値が‘grow-only’の
場合、ツールバーは自動的に拡大されますが、自動的に縮小はされません。

   ツールバーのコンテンツは、(メニューバーが制御されるのと似た方法により
)‘tool-bar’と呼ばれる偽りの“ファンクションキー”に割り当てられたメニュー
キーマップにより制御されます。したがって、以下のように‘define-key’を使用
して、ツールバーアイテムを定義します。

     (define-key global-map [tool-bar KEY] ITEM)

ここでKEYは、そのアイテムを他のアイテムと区別する偽“ファンクションキー
”で、ITEMはそのアイテムを表示する方法とアイテムの振る舞いを示すメニュー
アイテムキーバインディングです(*note Extended Menu Items::を参照)。

   メニューキーマップの通常のプロパティ‘:visible’、‘:enable’、
‘:button’、‘:filter’はツールバーバインディングでも役に立ち、いずれのプロ
パティも通常通りの意味をもちます。アイテム内のREAL-BINDINGは、キーマップ
ではなくコマンドでなければなりません。別の言い方をすると、これはツールバ
ーアイコンをプレフィクスキーとして定義するようには機能しないということで
す。

   ‘:help’プロパティは、そのアイテム上にマウスがある間表示する、
“help-echo”文字列を指定します。これは、テキストプロパティ‘help-echo’と同
じ方法で表示されます(*note Help display::を参照)。

   これらに加えて、‘:image’プロパティも使用するべきでしょう。これは、ツ
ールバー内にイメージを表示するには、このプロパティを使用します。

‘:image IMAGE’
     IMAGESは単一イメージ様式(single image specification)、または4ベクタ
     ーイメージ様式(vector of four image specifications)で指定する。4ベ
     クターを使用する場合、状況に応じてそれらのうち1つが使用される:

     item 0
          アイテムが有効かつ選択されているとき使用される。
     item 1
          アイテムが有効かつ未選択のとき使用される。
     item 2
          アイテムが無効かつ選択されているとき使用される。
     item 3
          アイテムが無効かつ未選択のとき使用される。

   GTK+およびNSバージョンのEmacsは、無効、および/または未選択のイメージ
をitem0から自動的に計算するので、item1からitem3は無視されます。

   IMAGEが単一イメージ様式の場合、Emacsはそのイメージにエッジ検出アルゴ
リズム(edge-detection algorithm)を適用することにより、ツールバーの無効な
状態のボタンを描画します。

   ‘:rtl’プロパティには、右から左に記述する言語のためのイメージ候補を指
定します。現在のところ、これをサポートするのはGTK+バージョンのEmacsだけ
です。

   メニューバーと同様、ツールバーはセパレーター(*note Menu Separators::を
参照)を表示できます。ツールバーのセパレーターは水平ラインではなく垂直ラ
インであり、1つのスタイルだけがサポートされます。これらは、ツールバーキ
ーマップ内では‘(menu-item "--")’エントリーで表されます。ツールバーのセパ
レーターでは、‘:visible’のようなプロパティはサポートされません。GTK+と
Nextstepのツールバーでは、セパレーターはネイティブに描画されます。それ以
外では、セパレーターは垂直ラインイメージを使用して描画されます。

   デフォルトツールバーは、コマンドシンボルの‘mode-class’プロパティに
‘special’をもつメジャーモードにたいしては、編集に特化したアイテムは表示
されないよう定義されています(*note Major Mode Conventions::を参照)。メジ
ャーモードは、ローカルマップ内でバインディング‘[tool-bar FOO]’によって、
グローバルバーにアイテムを追加するかもしれません。デフォルトツールバーの
多くを適宜流用するのができないかもしれないため、デフォルトツールバーを完
全に置き換えることは、いくつかのメジャーモードにとっては意味があります。
デフォルトバインディングで‘tool-bar-map’を通じてインダイレクトすることに
より、これを簡単に行うことができます。

 -- Variable: tool-bar-map
     デフォルトでは、グローバルマップは‘[tool-bar]’を以下のようにバイン
     ドする:

          (global-set-key [tool-bar]
                          `(menu-item ,(purecopy "tool bar") ignore
                                      :filter tool-bar-make-keymap))

     関数‘tool-bar-make-keymap’は、変数‘tool-bar-map’の値より、順に実際
     のツールバーマップをダイナミックに継承する。したがって、通常はその
     マップを変更することにより、デフォルト(グローバル)ツールバーを調整
     すべきである。Infoモードのようないくつかのメジャーモードは、
     ‘tool-bar-map’をバッファーローカルにして、それに異なるキーマップを
     セットすることにより、グローバルツールバーを完全に置き換える。

   以下のような、ツールバーアイテムを定義するのに便利な関数があります。

 -- Function: tool-bar-add-item icon def key &rest props
     この関数は、‘tool-bar-map’を変更することにより、ツールバーにアイテ
     ムを追加する。使用するイメージはICONにより定義され、これは
     ‘find-image’に配置されたXPM、XBM、PBMのイメージファイルの拡張子を除
     いたファイル名(basename)である。たとえばカラーディスプレイ上では、
     値に‘"exit"’を与えると‘exit.xpm’、‘exit.pbm’、‘exit.xbm’の順に検索
     されるだろう。モノクロディスプレイでは、検索は‘.pbm’、‘.xbm’、
     ‘.xpm’の順になる。使用するバインディングはコマンドDEFで、KEYはプレ
     フィクスキーマップ内の偽ファンクションキーである。残りの引数PROPSは
     、メニューアイテム仕様に追加する、追加のプロパティリスト要素である
     。

     あるローカルマップ内にアイテムを定義するためには、この関数呼び出し
     の周囲の‘let’で‘tool-bar-map’をバインドする:
          (defvar foo-tool-bar-map
            (let ((tool-bar-map (make-sparse-keymap)))
              (tool-bar-add-item ...)
              ...
              tool-bar-map))

 -- Function: tool-bar-add-item-from-menu command icon &optional map
          &rest props
     この関数は、既存のメニューバインディングと矛盾しないツールバーアイ
     テムの定義に有用である。COMMANDのバインディングはMAP(デフォルトは
     ‘global-map’)内よりルックアップ(lookup: 照合)され、ICONにたいするイ
     メージ仕様は‘tool-bar-add-item’と同じ方法で見つけ出される。結果のバ
     インディングは‘tool-bar-map’に配されるので、この関数の使用はグロー
     バルツールバーアイテムに限定される。

     MAPには、‘[menu-bar]’にバインドされた適切なキーマップが含まれていな
     ければならない。残りの引数PROPSは、メニューアイテム仕様に追加する、
     追加のプロパティリスト要素である。

 -- Function: tool-bar-local-item-from-menu command icon in-map
          &optional from-map &rest props
     この関数は、非グローバルツールバーアイテムの作成に使用される。
     IN-MAPに定義を作成するローカルマップを指定する以外は、
     ‘tool-bar-add-item-from-menu’と同じように使用する。引数FROM-MAPは、
     ‘tool-bar-add-item-from-menu’のMAPと同様である。

 -- Variable: auto-resize-tool-bars
     この変数が非‘nil’の場合、定義されたすべてのツールバーアイテムを表示
     するために、ツールバーは自動的にリサイズ — ただし、そのフレーム高さ
     の1/4を超えてリサイズされることはない。

     値が‘grow-only’の場合、ツールバーは自動的に拡張されるが、自動的に縮
     小はされない。ツールバーを縮小するために、ユーザーは‘C-l’をエンター
     してフレームを再描画する必要がある。

     GTK、またはNextstepとともにEmacsがビルドされた場合、ツールバーが表
     示できるのは1行だけであり、この変数は効果がない。

 -- Variable: auto-raise-tool-bar-buttons
     この変数が非‘nil’の場合、ツールバーアイテムの上をマウスが通過したと
     き、浮き上がった形式(raised form)で表示される。

 -- Variable: tool-bar-button-margin
     この変数は、ツールバーアイテムの周囲に追加する余白(extra margin)を
     指定する。値はピクセル数を整数で指定し、デフォルトは4である。

 -- Variable: tool-bar-button-relief
     この変数は、ツールバーアイテムの影(shadow)を指定する。値はピクセル
     数を整数で指定し、デフォルトは1である。

 -- Variable: tool-bar-border
     この変数は、ツールバーエリアの下に描画するボーダー高さを指定する。
     値が整数の場合は、高さのピクセル数である。値が
     ‘internal-border-width’(デフォルト)か‘border-width’のいずれの場合、
     ツールバーのボーダー高さは、そのフレームの対応するパラメーターとな
     る。

   シフト、メタ等の修飾キーを押下した状態でのツールバーアイテムのクリッ
クにたいして、特別な意味を付与できます。偽りのファンクションキーを通じて
、元のアイテムに関連する追加アイテムをセットアップすることにより、これを
行うことができます。より具体的には、追加アイテムは、元のアイテムの命名に
使用されたのと同じ偽ファンクションキーの修飾されたバージョンを使用するべ
きです。

   つまり、元のアイテムが以下のように定義されている場合、

     (define-key global-map [tool-bar shell]
       '(menu-item "Shell" shell
                   :image (image :type xpm :file "shell.xpm")))

シフト修飾とともに同じツールバーイメージをクリックしたときは、以下のよう
な方法で定義することができます:

     (define-key global-map [tool-bar S-shell] 'some-command)

   ファンクションキーにたいして修飾を追加する方法についての詳細な情報は
、*note Function Keys::を参照してください。


File: elisp,  Node: Modifying Menus,  Next: Easy Menu,  Prev: Tool Bar,  Up: Menu Keymaps

21.17.7 Modifying Menus
-----------------------

既存のメニューに新たなアイテムを挿入するときは、そのメニューの既存のアイ
テムの中の特定の位置にアイテムを追加したいと思うかもしれません。
‘define-key’を使用してアイテムを追加した場合は通常、そのアイテムはメニュ
ーの先頭に追加されます。メニュー内の他の位置にアイテムを追加するには、
‘define-key-after’を使用します:

 -- Function: define-key-after map key binding &optional after
     ‘define-key’と同じように、MAP内にKEYにたいする値BINDINGのバインディ
     ングを定義するが、MAP内でそのバインディングの位置は、イベント
     AFTERにたいするバインディングの後になる。引数KEYは長さ1 — 1要素だけ
     のベクターか文字列にすべきである。しかしAFTERは単一のイベント型 — シ
     ーケンスではないシンボルか文字にすべきである。新たなバインディング
     は、AFTERにたいするバインディングの後に追加される。AFTERが‘t’、また
     は省略された場合、新たなバインディングはそのキーマップの最後に追加
     される。しかし、新たなバインディングは、すべての継承されたキーマッ
     プの前に追加される。

     以下に例を示す:

          (define-key-after my-menu [drink]
            '("Drink" . drink-command) 'eat)

     これは、偽ファンクションキー<DRINK>にたいするバインディングを作成し
     て、<EAT>にたいするバインディングの直後に追加する。

     以下に、Shellモードの‘Signals’メニュー内のアイテム‘break’の後に、
     ‘Work’と呼ばれるアイテムを追加する方法を示す:

          (define-key-after
            (lookup-key shell-mode-map [menu-bar signals])
            [work] '("Work" . work-command) 'break)


File: elisp,  Node: Easy Menu,  Prev: Modifying Menus,  Up: Menu Keymaps

21.17.8 Easy Menu
-----------------

以下のマクロは、ポップアップメニュー、および/またはメニューバーメニュー
を定義する便利な方法を提供します。

 -- Macro: easy-menu-define symbol maps doc menu
     このマクロは、MENUにより与えるコンテンツのポップアップメニュー、お
     よび/またはメニューバーサブメニューを定義する。

     SYMBOLが非‘nil’の場合、それはシンボルである。その場合、このマクロは
     ドキュメント文字列DOCをもつ、メニューをポップアップ(*note Pop-Up
     Menus::を参照)する関数としてSYMBOLをを定義する。SYMBOLはクォートさ
     れるべきではない。

     SYMBOLの値とは関係なく、MAPSがキーマップの場合、メニューはメニュー
     バーのトップレベルのメニュー(*note Menu Bar::を参照)としてMAPSに追
     加される。これにはキーマップのリストも指定でき、その場合メニューは
     それらのキーマップに個別に追加される。

     MENUの最初の要素は文字列でなければならず、それはメニューラベルの役
     割をもつ。値には、以下のキーワード/引数ペアーが任意の個数続くかもし
     れない:

     ‘:filter FUNCTION’
          FUNCTIONは1つの引数(他のメニューアイテムのリスト)で呼び出され
          る関数でなければならず、メニュー内に表示される実際のアイテムを
          リターンする。

     ‘:visible INCLUDE’
          INCLUDEには式を指定する。その式が‘nil’に評価された場合、メニュ
          ーは不可視になる。‘:included’は、‘:visible’にたいするエイリア
          スである。

     ‘:active ENABLE’
          ENABLEは式を。指定する。その式が‘nil’に評価された場合、メニュ
          ーは選択不可になる。‘:enable’は、‘:active’にたいするエイリアス
          である。

     MENU内の残りの要素は、メニューアイテムである。

     メニューアイテムには、3要素のベクター‘[NAME CALLBACK ENABLE]’を指定
     できる。ここでNAMEはメニューアイテム名(文字列)、CALLBACKはアイテム
     選択時に実行するコマンド、または評価される式である。ENABLEは式であ
     り、‘nil’に評価された場合、そのアイテムにたいする選択は無効になる。

     かわりに、メニューアイテムは以下の形式をもつかもしれない:

             [ NAME CALLBACK [ KEYWORD ARG ]... ]

     ここでNAMEとCALLBACKは上記と同じ意味をもち、オプションのKEYWORDと
     ARGの各ペアーは、以下のいずれかである:

     ‘:keys KEYS’
          KEYSは、メニューアイテムにたいする等価なキーボード入力(文字列
          )である。等価なキーボード入力は自動的に計算されるので、通常は
          必要ない。KEYSは、表示される前に‘substitute-command-keys’によ
          り展開される(*note Keys in Documentation::を参照)。

     ‘:key-sequence KEYS’
          KEYSは、最初にメニューを表示されるかをする際、Emacsを高速化す
          るヒントになる。等価なキーボード入力のないことが既知の場合は、
          ‘nil’を指定すべきである。それ以外では、メニューアイテムにたい
          する等価なキーボード入力を指定する文字列、またはベクターを指定
          すべきである。

     ‘:active ENABLE’
          ENABLEには式を指定する。その式が‘nil’に評価された場合、アイテ
          ムは選択不可になる。ENABLEは、‘:active’にたいするエイリアスで
          ある。

     ‘:visible INCLUDE’
          INCLUDEには式を指定する。その式が‘nil’に評価された場合、アイテ
          ムは不可視になる。‘:included’は、‘:visible’にたいするエイリア
          スである。

     ‘:label FORM’
          FORMは、メニューアイテムのラベル(デフォルトはNAME)の役目をもつ
          値を取得するために表示される式である。

     ‘:suffix FORM’
          FORMは、動的に評価される式であり、値はメニューエントリーのラベ
          ルに結合される。

     ‘:style STYLE’
          STYLEは、メニューアイテムの型を記述するシンボルであり、
          ‘toggle’(チェックボックス)、‘radio’(ラジオボタン)、またはそれ
          以外(通常のメニューアイテムであることを意味する)のいずれかであ
          る。

     ‘:selected SELECTED’
          SELECTEDには式を指定し、その式の値が非‘nil’のときはチェックボ
          ックス、またはラジオボタンが選択状態になる。

     ‘:help HELP’
          HELPは、メニューアイテムを説明する文字列である。

     かわりに、メニューアイテムに文字列を指定できる。その場合、文字列は
     選択不可なテキストとしてメニューに表示される。ダッシュから構成され
     る文字列は、セパレーターとして表示される(*note Menu Separators::を
     参照)

     かわりに、メニューアイテムにMENUと同じフォーマットのリストを指定で
     きる。これはサブメニューとなる。

   以下は、‘easy-menu-define’を使用して、*note Menu Bar::内で定義したメ
ニューと同等なメニューを定義する例である:

     (easy-menu-define words-menu global-map
       "単語単位コマンドにたいするメニュー"
       '("Words"
          ["Forward word" forward-word]
          ["Backward word" backward-word]))


File: elisp,  Node: Modes,  Next: Documentation,  Prev: Keymaps,  Up: Top

22 Major and Minor Modes
************************

“モード(mode)”とは、Emacsをカスタマイズする定義のセットであり、編集時に
オン/オフを切り替えることができます。モードには2つの種類があります。“メ
ジャーモード(major modes)”とは、互いに排他なモードであり、特定の種類のテ
キストの編集にたいして使用されます。“マイナーモード(minor modes)”とは、
ユーザーが個別に有効にすることができる機能を提供します。

   このチャプターでは、メジャーモード、およびマイナーモードを記述する方
法、モードラインにそれらを示す方法、そしてそれらのモードがユーザーが提供
するフックを実行する方法について説明します。キーマップ(keymaps)や構文テ
ーブル(syntax tables)のような関連するトピックについては*note Keymaps::お
よび*note Syntax Tables::を参照してください。

* Menu:

* Hooks::                    フックの使い方と、フックを提供するコードの記述方法。
* Major Modes::              メジャーモードの定義。
* Minor Modes::              マイナーモードの定義。
* Mode Line Format::         モードラインに表示されるテキストのカスタマイズ。
* Imenu::                    バッファーで作成された定義のメニューを提供する。
* Font Lock Mode::           モードが構文に応じてテキストをハイライトする方法。
* Auto-Indentation::         メジャーモードにたいするインデントをEmacsに伝える方法。
* Desktop Save Mode::        Emacsセッション間でモードがバッファー状態を保存する方法。


File: elisp,  Node: Hooks,  Next: Major Modes,  Up: Modes

22.1 Hooks
==========

“フック(hook)”とは、既存のプログラムから特定のタイミングで呼び出される関
数(複数可)を格納することができる変数のことです。Emacsはカスタマイズ用に
フックを提供します。ほとんどの場合は、initファイル内(*note Init File::を
参照)でフックをセットアップしますが、Lispプログラムもフックをセットでき
ます。標準的なフック変数のリストは、*note Standard Hooks::を参照してくだ
さい。

   Emacsのほとんどのフックは、“ノーマルフック(normal hooks)”です。これら
の変数は、引数なしで呼び出される、関数のリストを含んでいます。慣習により
、フック名が‘-hook’で終わるフックは、そのフックがノーマルフックであるこ
とを意味します。わたしたちは、一貫した方法でフックを使用できるよう、すべ
てのフックが可能な限りノーマルフックとなるよう努力しています。

   すべてのメジャーモードコマンドは、初期化の最終ステップの1つとして、
“モードフック(mode hook)”と呼ばれるノーマルフックを実行するとみなされま
す。これにより、そのモードによりすでに作成されたバッファーローカル変数割
り当てをオーバーライドすることにより、ユーザーがそのモードの動作をカスタ
マイズするのが簡単になります。ほとんどのマイナーモード関数も、最後にモー
ドフックを実行します。しかし、フックは他のコンテキストでも使用されます。
たとえばフック‘suspend-hook’は、Emacsが自身をサスペンド(*note Suspending
Emacs::を参照)する直前に実行されます。

   フックにフック関数を追加するには、‘add-hook’(*note Setting Hooks::を
参照)を呼び出す方法が推奨です。フック関数は、‘funcall’(*note What Is a
Function::を参照)が受け入れる任意の種類の関数を指定できます。ほとんどの
フック変数の初期値はvoidです。‘add-hook’は、これを扱う方法を知っています
。‘add-hook’により、グローバルフック、またはバッファーローカルフックのど
ちらを追加することも可能です。

   フック変数の名前が‘-hook’で終わらない場合は、それが恐らく“アブノーマ
ルフック(abnormal hook)”であることを示しています。こええは、フック関数が
引数とともに呼ぶ出されること、または何らかの方法により、そのリターン値が
使用されることを意味します。その関数の呼び出し方は、フックのドキュメント
に記載されています。アブノーマルフックとして関数を追加するために
‘add-hook’を使用できますが、その関数はフック呼び出しの慣習にしたがって記
述しななければなりません。慣習により、アブノーマルフックの名前は
‘-functions’で終わります。

   変数の名前が‘-function’で終わる場合、その値は関数のリストではなく単一
の関数です。‘add-hook’を、_単一関数フック_のように修正して使用することは
できないので、かわりに‘add-function’を使用します(*note Advising
Functions::を参照)。

* Menu:

* Running Hooks::            フックの実行方法。
* Setting Hooks::            関数をフックに登録、削除する方法。


File: elisp,  Node: Running Hooks,  Next: Setting Hooks,  Up: Hooks

22.1.1 Running Hooks
--------------------

このセクションでは、ノーマルフックを実行するために使用される、
‘run-hooks’について説明します。また、さまざまな種類のアブノーマルフック
を実行する関数についても説明します。

 -- Function: run-hooks &rest hookvars
     この関数は、引数として1つ以上のノーマルフック変数名をとり、各フック
     を順に実行する。引数はそれぞれ、ノーマルフック変数であるようなシン
     ボルであること。これらの引数は、指定された順に処理される。

     フック変数の値が非‘nil’の場合、その値は関数のリストであること。
     ‘run-hooks’は、すべての関数を引数なしで1つずつ呼び出す。

     フック変数の値には、単一の関数(ラムダ式、またはシンボルの関数定義
     )も指定でき、その場合‘run-hooks’はそれを喚び出す。しかし、この使い
     方は時代遅れである。

     フック変数がバッファーローカルな場合、グローバル変数のかわりにその
     バッファーローカル変数が使用される。しかし、そのバッファーローカル
     変数が要素‘t’を含む場合は、そのグローバルフック変数も同様に実行され
     るだろう。

 -- Function: run-hook-with-args hook &rest args
     この関数は、HOOK内のすべての関数に、1つの引数ARGSを渡して喚び出すこ
     とにより、アブノーマルフックを実行する。

 -- Function: run-hook-with-args-until-failure hook &rest args
     この関数は、各フック関数を順に呼び出すことによりアブノーマルフック
     関数を実行し、それらのうち1つが‘nil’をリターンして“失敗”したときは
     停止する。それぞれのフック関数は、引数にARGSを渡される。この関数は
     、フック関数の1つが失敗して停止した場合は‘nil’、それ以外は非‘nil’値
     をリターンする。

 -- Function: run-hook-with-args-until-success hook &rest args
     この関数は、各フック関数を順に呼び出すことによりアブノーマルフック
     関数を実行し、それらのうち1つが非‘nil’値をリターンして“成功”したと
     きは停止する。それぞれのフック関数は、引数にARGSを渡される。この関
     数は、フック関数の1つが失敗して停止した場合はその値を、それ以外は
     ‘nil’をリターンする。


File: elisp,  Node: Setting Hooks,  Prev: Running Hooks,  Up: Hooks

22.1.2 Setting Hooks
--------------------

以下は、Lisp Interactionモードのときに、モードフックを使用してAuto Fillモ
ードをオンに切り替える例です:

     (add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)

 -- Function: add-hook hook function &optional append local
     この関数は、フック変数に関数FUNCTIONを追加する手軽な方法である。ノ
     ーマルフックと同じように、アブノーマルフックにたいしてもこの関数を
     使用できる。FUNCTIONには、正しい数の引数を受け付ける任意のLisp関数
     を指定できる。たとえば、

          (add-hook 'text-mode-hook 'my-text-hook-function)

     は、‘text-mode-hook’と呼ばれるフックに‘my-text-hook-function’を追加
     する。

     HOOK内にFUNCTIONがすでに存在する場合(比較には‘equal’を使用)、
     ‘add-hook’は2回目の追加を行わない。

     FUNCTIONのプロパティ‘permanent-local-hook’が非‘nil’の場合、
     ‘kill-all-local-variables’(またはメジャーモードを変更しても)、その
     フック変数のローカル値から関数を削除しない。

     ノーマルフックにたいして、フック関数は実行される順序に無関係である
     ようにデザインされるべきである。順序への依存は、トラブルを招く。と
     はいえ、その順序は予測可能である。通常、FUNCTIONはフックリストの先
     頭に追加されるので、(他の‘add-hook’呼び出しがなければ)それは最初に
     実行される。オプション引数APPENDが非‘nil’の場合、新たなフック関数は
     フックリストの最後に追加され、実行されるのも最後になる。

     ‘add-hook’は、HOOKがvoidのとき、または値が単一の関数の場合、値を関
     数リストにセットまたは変更して、それらを扱うことができる。

     LOCALが非‘nil’の場合、それはグローバルフックリストではなくバッファ
     ーローカルフックリストにFUNCTIONを追加する。これはフックをバッファ
     ーローカルにして、そのバッファーローカルな値に‘t’を追加する。バッフ
     ァーローカルな値への‘t’の追加は、ローカル値と同じようにデフォルト値
     でもフック関数を実行するためのフラグである。

 -- Function: remove-hook hook function &optional local
     この関数は、フック変数HOOKからFUNCTIONを削除する。これは、‘equal’を
     使用してFUNCTIONとHOOK要素を比較するので、その比較はシンボルとラム
     ダ式の両方で機能する。

     LOCALが非‘nil’の場合、それはグローバルフックリストではなく、バッフ
     ァーローカルフックリストからFUNCTIONを削除する。


File: elisp,  Node: Major Modes,  Next: Minor Modes,  Prev: Hooks,  Up: Modes

22.2 Major Modes
================

メジャーモードは特定の種類のテキスト編集にEmacsを特化します。すべてのバ
ッファーは1度に1つのメジャーモードをもちます。すべてのメジャーモードは、
“メジャーモードコマンド(major mode command)”に関連付けられ、そのコマンド
名は‘-mode’で終わるべきです。このコマンドは、ローカルキーマップのような
さまざまなバッファーローカル変数をセットすることにより、カレントバッファ
ーないでそのモードに切り替える配慮をします。*note Major Mode
Conventions::を参照してください。

   “Fundamentalモード”と呼ばれるはもっとも特化されていないメジャーモード
であり、モード特有な定義や変数セッティングをもちません。

 -- Command: fundamental-mode
     これは、Fundamentalモードにたいするメジャーモードコマンドである。他
     のモードコマンドと異なり、このモードはカスタマイズしてはならないこ
     とになっているので、モードフックは何も実行_されない_(*note Major
     Mode Conventions::を参照)。

   メジャーモードを記述するもっとも簡単な方法は、マクロ
‘define-derived-mode’を使用する方法です。これは、既存のメジャーモードを
変形して、新たなモードをセットアップします。*note Derived Modes::を参照
してください。‘define-derived-mode’は多くのコーディング規約を自動的に強
要するので、たとえ新たなモードが他のモードから明示的に派生されない場合で
も、わたしたちは‘define-derived-mode’の使用を推奨します。派生元とするた
めの一般的なモードについては、*note Basic Major Modes::を参照してくださ
い。

   標準的なGNU EmacsのLispディレクトリーツリーには、いくつかのメジャーモ
ードが‘text-mode.el’、‘texinfo.el’、‘lisp-mode.el’、‘rmail.el’のようなフ
ァイルとして含まれています。モードの記述方法を確認するために、これらのラ
イブラリーを学ぶことができます。

 -- User Option: major-mode
     この変数のバッファーローカル値は、カレントのメジャーモードにたいす
     るシンボルを保持する。この変数のデフォルト値は、新たなバッファーに
     たいするデフォルトのメジャーモードを保持する。標準的なデフォルト値
     は、‘fundamental-mode’である。

     デフォルト値が‘nil’の場合、‘C-x b’(‘switch-to-buffer’)のようなコマ
     ンドを通じてEmacsが新たなバッファーを作成したとき、新たなバッファー
     は以前カレントだったバッファーのメジャーモードになる。例外として、
     以前のバッファーのメジャーモードのシンボルプロパティ‘mode-class’が
     値‘special’をもつ場合、新たなバッファーはFundamentalモードになる
     (*note Major Mode Conventions::を参照)。

* Menu:

* Major Mode Conventions::   キーマップなどにたいするコーディング規約。
* Auto Major Mode::          Emacsが自動的にメジャーモードを選択する方法。
* Mode Help::                モードの使用方法の探し方。
* Derived Modes::            他のメジャーモードにもとづき新たなメジャーモードを定義する。
* Basic Major Modes::        他のモードからよく派生元とさｒｗるモード。
* Mode Hooks::               メジャーモード関数の最後に実行されるフック。
* Tabulated List Mode::      表形式データを含むバッファーにたいする親モード。
* Generic Modes::            コメント構文とFont
                               Lockモードをサポートするシンプルなメジャーモードの定義。
* Example Major Modes::      TextモードとLispモード。


File: elisp,  Node: Major Mode Conventions,  Next: Auto Major Mode,  Up: Major Modes

22.2.1 Major Mode Conventions
-----------------------------

メジャーモードにたいするすべてのコードはさまざまなコーディング規約にした
がうべきであり、それらの規約にはローカルキーマップおよび構文テーブルの初
期化、関数名や変数名、フックにたいする規約が含まれます。

   ‘define-derived-mode’マクロを使用した場合は、これらの規約を自動的に配
慮します。*note Derived Modes::を参照してください。Fundamentalモードは、
Emacsのデフォルト状態を表すモードなにで、これらの規約が当てはまらないこ
とに注意してください。

   以下の規約リストは、ほんの一部です。一般的に、すべてのメジャーモード
は、Emacs全体が首尾一貫するよう、他のEmacsメジャーモードとの一貫性を目指
すべきです。ここで、この問題を洗い出すすべての想定される要点をリストする
のは不可能です。Emacs開発者が、自身の開発するメジャーモードが通常の規約
を逸脱する領域を示す場合は、互換性を保つようにしてください。

   • 名前が‘-mode’で終わるようにメジャーモードコマンドを定義する。引数な
     しで呼び出されたとき、このコマンドはキーマップ、構文テーブル、既存
     バッファーのバッファーローカル変数をセットアップして、カレントバッ
     ファーを新たなモードに切り替えるべきである。そのバッファーのコンテ
     ンツを変更するべきではない。

   • そのモードで利用できる特別なコマンドを説明するドキュメント文字列を
     記述する。*note Mode Help::を参照のこと。

     そのユーザー自身のキーバインディングに自動的に適合してヘルプが表示
     されるように、ドキュメント文字列に特別なドキュメントサブストリング
     ‘\[COMMAND]’、‘\{KEYMAP}’、‘\<KEYMAP>’を含めるとよいかもしれない。
     *note Keys in Documentation::を参照のこと。

   • メジャーモードコマンドは、‘kill-all-local-variables’を呼び出すこと
     により開始するべきである。これは、ノーマルフック
     ‘change-major-mode-hook’を実行してから、前のメジャーモードで効力の
     あったバッファーローカル変数を解放する。*note Creating
     Buffer-Local::を参照のこと。

   • メジャーモードコマンドは、変数‘major-mode’にメジャーモードコマンド
     のシンボルをセットするべきである。これは、‘describe-mode’がプリント
     するドキュメントを探す手掛かりとなる。

   • メジャーモードコマンドは、変数‘mode-name’にそのモードの“愛称(pretty
     name)”をセットするべきである(これは通常は文字列だが、他の利用可能な
     形式は、*note Mode Line Data::を参照のこと)。このモード名は、モード
     ラインに表示される。

   • すべてのグローバル名は同じネームスペースにあるので、モードの一部で
     あるようなすべてのグローバルな変数、定数、関数は、メジャーモード名
     (メジャーモード名が長いようなら短縮名)で始まる名前をもつべきである
     。*note Coding Conventions::を参照のこと。

   • プログラム言語のような、ある種の構造型テキストを編集するためのメジ
     ャーモードでは、その構造に応じたテキストのインデントはおそらく有用
     であろう。したがって、そのようなモードは‘indent-line-function’に適
     切な関数をセットするとともに、インデント用のその他の変数をカスタマ
     イズすべきだろう。

   • メジャーモードは通常、そのモードにあるすべてのバッファーのローカル
     キーマップとして使用される、自モード身のキーマップをもつべきである
     。メジャーモードコマンドは、そのローカルマップをインストールするた
     めに、‘use-local-map’を呼び出すべきである。詳細は、*note Active
     Keymaps::を参照のこと。

     このキーマップは、‘MODENAME-mode-map’という名前のグローバル変数に永
     続的に格納されるべきである。通常、そのモードを定義するライブラリー
     は、この変数をセットする。

     モード用のキーマップ変数をセットアップするコードの記述する方法に関
     するアドバイスは、*note Tips for Defining::を参照のこと。

   • メジャーモードのキーマップ内でバインドされるキーシーケンスは、通常
     は‘C-c’で始まり、その後にコントロール文字、数字、‘{’、‘}’、‘<’、
     ‘>’、‘:’、‘;’が続くべきである。その他の記号文字(punctuation
     characters)はマイナーモードに、通常のアルファベット文字はユーザーの
     ために予約されている。

     メジャーモードは‘M-n’、‘M-p’、‘M-s’などのキーもリバインドできる。
     ‘M-n’と‘M-p’にたいするバインディングは、通常は “前方あるいは後方へ
     の移動”を意味するような類のものであるべきだが、これは必ずしもカーソ
     ル移動を意味する必要はない。

     そのモードにより適した方法でテキストに“同じ処理”を行うコマンドを提
     供する場合に、メジャーモードが標準的なキーシーケンスをリバインドす
     るのは正当性がある。たとえば、プログラム言語を編集するためのメジャ
     ーモードは、その言語にとって“関数の先頭に移動する”がより良く機能す
     る方法で、‘C-M-a’を再定義するかもしれない。

     ある標準的なキーシーケンスの標準的な意味が、そのモードではほとんど
     役に立たないような場合にも、メジャーモードが標準的なキーシーケンス
     をリバインドする正当性がある。たとえば、ミニバッファーモードは、
     ‘M-r’の標準的な意味はミニバッファーではほとんど使用されないので、こ
     のキーシーケンスをリバインドする。テキストの自己挿入を許さない
     DiredやRmailのようなメジャーモードは、アルファベット文字や、その他
     のプリント文字を特別なコマンドに再定義する正当性がある。

   • テキストを編集するメジャーモードは、改行の挿入以外の何かに<RET>を定
     義すべきではない。しかし、ユーザーが直接テキストを編集しない、
     DiredやInfoのような特別なモードにたいしては、完全に異なることを行う
     ように<RET>を再定義しても構わない。

   • メジャーモードは、たとえばAuto-Fillモードを有効にするか等の、主にユ
     ーザーの好みに関するオプションを変更すべきではない。それらのオプシ
     ョンは、ユーザーに選択に任せること。ただし、_もし_ユーザーが
     Auto-Fillモードを使用すると決定した場合には、それが便利に機能するよ
     うに、他の変数をカスタマイズすべきである。

   • モードは自身の構文テーブルをもつかもしれず、他の関連するモードと構
     文テーブルを共有するかもするかもしれない。モードが自身の構文テーブ
     ルをもつ場合は、‘MODENAME-mode-syntax-table’という名前の変数にそれ
     を格納すべきである。*note Syntax Tables::を参照のこと。

   • コメントにたいして構文をもつ言語を扱うモードは、コメント構文を定義
     する変数をセットすべきである。*note Options Controlling Comments:
     (emacs)Options for Comments.を参照のこと。

   • モードは自身のabbrevテーブルをもつかもしれず、他の関連するモードと
     構文テーブルを共有するかもするかもしれない。モードが自身のabbrevテ
     ーブルをもつ場合は、‘MODENAME-mode-abbrev-table’という名前の変数に
     それを格納すべきである。メジャーモードコマンドが自身で何らかの
     abbrevを定義する場合は、‘define-abbrev’のSYSTEM-FLAG引数に‘t’を渡す
     べきである。*note Defining Abbrevs::を参照のこと。

   • モードは、変数‘font-lock-defaults’にバッファーローカルな値をセット
     することにより、Font Lockモードにたいしてハイライトする方法を指定す
     べきである(*note Font Lock Mode::を参照)。

   • モードが定義するすべてのフェイスは、もし可能なら既存のEmacsフェイス
     を継承すべきである。*note Basic Faces::と*note Faces for Font
     Lock::を参照のこと。

   • モードは変数‘imenu-generic-expression’、変数
     ‘imenu-prev-index-position-function’ and
     ‘imenu-extract-index-name-function’、または変数
     ‘imenu-create-index-function’にバッファーローカルな値をセットするこ
     とにより、Imenuがバッファー内の定義、またはセクションを探す方法を指
     定すべきである(*note Imenu::を参照)。

   • モードは、‘eldoc-documentation-function’にローカル値を指定して、
     ElDocモードがそのモードを処理する方法を指定できる。

   • モードは、スペシャルフック‘completion-at-point-functions’に1つ以上
     のバッファーローカルエントリーを追加することにより、さまざまなキー
     ワードの補完方法を指定できる。*note Completion in Buffers::を参照の
     こと。

   • Emacsのカスタマイズ変数にたいしてバッファーローカルなバインディング
     を作成するには、‘make-variable-buffer-local’ではなく、メジャーモー
     ドコマンド内で‘make-local-variable’を使用すること。関数、
     ‘make-variable-buffer-local’は、それ以降にカスタマイズ変数をセット
     するすべてのバッファーにたいしてその変数をローカルにし、そのモード
     を使用しないバッファーにたいしても影響があるだろう。そのようなグロ
     ーバルな効果は、モードにとって好ましくない。*note Buffer-Local
     Variables::を参照のこと。

     稀な例外として、Lispパッケージ内で‘make-variable-buffer-local’を使
     用する唯一の正当な方法は、そのパッケージ内でのみ使用される変数にた
     いして使用をする場合である。他のパッケージにより使用される変数にた
     いしてこの関数を使用すると、干渉が起こるだろう。

   • すべてのメジャーモードは、‘MODENAME-mode-hook’という名前のノーマル
     な“モードフック(mode hook)”をもつべきである。メジャーモードコマンド
     が一番最後に行うべきことは、‘run-mode-hooks’の呼び出しである。これ
     は、ノーマルフック‘change-major-mode-after-body-hook’、モードフック
     、その後に‘after-change-major-mode-hook’を実行する。*note Mode
     Hooks::を参照のこと。

   • メジャーモードコマンドは、“親モード(parent mode)”と呼ばれる他のいく
     つかのメジャーモードを呼び出すことにより開始されるかもしれず、それ
     らのセッティングのいくつかを変更するかもしれない。これを行うモード
     は、“派生モード(derived mode)”と呼ばれる。派生モードを定義する推奨
     方法は、‘define-derived-mode’マクロの使用であるが、これは必須ではな
     い。そのようなモードは、‘delay-mode-hooks’フォーム内で親のモードコ
     マンドを呼び出すべきである(‘define-derived-mode’は自動的にこれを行
     う)。*note Derived Modes::、および*note Mode Hooks::を参照のこと。

   • ユーザーが、そのモードのバッファーから他のモードのバッファーに切り
     替える際に特別な何かを行う必要がある場合、モードは
     ‘change-major-mode-hook’にたいしてバッファーローカル値をセットアッ
     プできる(*note Creating Buffer-Local::を参照)。

   • そのモードが、(ユーザーがキーボードでタイプしたテキストや、外部ファ
     イルのテキストではなく)モード自身が生成する特別に用意されたテキスト
     にたいしてのみ適す場合、メジャーモードコマンドのシンボルは、以下の
     ように‘mode-class’という名前のプロパティに値‘special’をputすべきで
     ある:

          (put 'funny-mode 'mode-class 'special)

     これはEmacsにたいして、カレントバッファーがFunnyモードのときに新た
     なバッファーを作成したとき、たとえ‘major-mode’のデフォルト値が
     ‘nil’であっても、そのバッファーをFunnyモードにしないよう指示する。
     デフォルトでは、‘major-mode’にたいする値‘nil’は、新たなバッファー作
     成時にカレントバッファーのメジャーモードを使用することを意味するが
     (*note Auto Major Mode::を参照)、‘special’なモードにたいしてはかわ
     りにFundamentalモードが使用される。Dired、Rmail、Buffer Listのよう
     なモードは、この機能を使用する。

     関数‘view-buffer’は、mode-classがspecialであるようなバッファーでは
     Viewモードを有効にしない。そのようなモードは、通常は自身でViewに相
     当するバインディングを提供するからである。

     ‘define-derived-mode’マクロは、親モードがspecialの場合は、自動的に
     派生モードをspecialにマークする。親モードでspecialモードが有用なら
     、それを継承したモードでもであろう。*note Basic Major Modes::を参照
     のこと。

   • 新たなモードを、識別可能な特定のファイルにたいするデフォルトとした
     い場合は、そのようなファイル名にたいしてそのモードを選択するために
     、‘auto-mode-alist’に要素を追加する。autoload用にモードコマンドを定
     義する場合は、‘autoload’を呼び出すのと同じファイル内にその要素を追
     加すべきである。モードコマンドにたいしてautoload cookieを使用する場
     合は、その要素を追加するフォームにたいしてもautoload cookieを使用で
     きる(*note autoload cookie::を参照)。モードコマンドをautoloadしない
     場合は、モード定義を含むファイル内で要素を追加すれば十分である。

   • 悪影響を与えることなく1回以上評価されるように、モード定義はファイル
     内のトップレベルのフォームとして記述すべきである。たとえば、すでに
     値をもつ変数が再初期化されないように、モードに関連した変数をセット
     するときは、‘defvar’か‘defcustom’を使用する(*note Defining
     Variables::を参照)。


File: elisp,  Node: Auto Major Mode,  Next: Mode Help,  Prev: Major Mode Conventions,  Up: Major Modes

22.2.2 How Emacs Chooses a Major Mode
-------------------------------------

ファイルをvisitするとき、ファイル名やファイル自体の内容などの情報を元に
、Emacsはそのバッファーにたいするメジャーモードを選択します。また、ファ
イルのテキスト内で指定されたローカル変数も処理します。

 -- Command: normal-mode &optional find-file
     この関数は、カレントバッファーにたいして適切なメジャーモードと、バ
     ッファーローカル変数のバインディングを設定する。これはまず
     ‘set-auto-mode’(以下参照)を呼び出し、その後に
     ‘hack-local-variables’を実行してパース処理を行って、そのファイルの
     ローカル変数(*note File Local Variables::を参照)を適切にバインド、
     または評価する。

     ‘normal-mode’のFIND-FILE引数が非‘nil’の場合、‘normal-mode’は
     ‘find-file’関数が自身を呼び出したとみなす。この場合、
     ‘normal-mode’はそのファイル内の‘-*-’行の、またはファイルの最後にあ
     るローカル変数を処理するかもしれない。これを行うかどうかは、変数
     ‘enable-local-variables’が制御する。ファイルのローカル変数セクショ
     ンの構文は、*note Local Variables in Files: (emacs)File Variables.を
     参照のこと。

     インタラクティブに‘normal-mode’を実行した場合、引数FIND-FILEは通常
     ‘nil’である。この場合、‘normal-mode’は無条件に任意のファイルローカ
     ル変数を処理する。

     この関数は、メジャーモードを選択するために‘set-auto-mode’を呼び出す
     。この関数がモードを特定しない場合、そのバッファーの‘major-mode’(以
     下参照)のデフォルト値により決定されるメジャーモードに留まる。

     ‘normal-mode’は、メジャーモードコマンド呼び出しの周囲に
     ‘condition-case’を使用するので、エラーはcatchされて、‘File mode
     specification error’とともに、元のエラーメッセージがその後に報告さ
     れる。

 -- Function: set-auto-mode &optional keep-mode-if-same
     この関数は、カレントバッファーにたいして適切なメジャーモードを選択
     する。この選択は、関数自身の(優先順位による)決定にもとづく。優先順
     位は、‘-*-’行、ファイル終端近傍の任意の‘mode:’ローカル変数、‘#!’行
     (‘interpreter-mode-alist’を使用)、バッファーの先頭のテキスト
     (‘magic-mode-alist’を使用)、最後がvisitされるファイル名
     (‘auto-mode-alist’を使用)の順である。*note How Major Modes are
     Chosen: (emacs)Choosing Modes.を参照のこと。
     ‘enable-local-variables’が‘nil’の場合、‘set-auto-mode’は‘-*-’行、お
     よびファイル終端近傍にたいして、modeタグのチェックを何もしない。

     モード特定のためにファイル内容をスキャンするのがふさわしくないファ
     イルタイプがいくつかある。たとえば、tarアーカイブファイルの終わり付
     近に、特定のファイルにたいしてモードを指定するローカル変数セクショ
     ンをもつアーカイブメンバーファイルが、たまたま含まれているかもしれ
     ない。これは、そのファイルを含むtarファイルに適用されるべきではない
     だろう。同様に、tiffイメージファイルが、‘-*-’パターンにマッチするよ
     うに見える行を、最初の行に偶然含むかもしれない。これらの理由により
     、これらのファイル拡張子はどちらも
     ‘inhibit-local-variables-regexps’リストのメンバーになっている。
     Emacsが、(モード指定に限らず)ファイルから任意の種類のローカル変数を
     検索することを防ぐには、このリストにパターンを追加する。

     KEEP-MODE-IF-SAMEが非‘nil’の場合は、すでにそのバッファーが適切なメ
     ジャーモードをもつとき、この関数はモードコマンドを呼び出さない。た
     とえば‘set-visited-file-name’は、ユーザーがセットしたかもしれないバ
     ッファーローカル変数をkillするのを防ぐために、これを‘t’にセットする
     。

 -- Function: set-buffer-major-mode buffer
     この関数は、BUFFERのメジャーモードを、‘major-mode’のデフォルト値に
     セットする。‘major-mode’が‘nil’の場合は、(それが適切なら)カレントバ
     ッファーのメジャーモードを使用する。例外として、BUFFERの名前が
     ‘*scratch*’の場合は、モードを‘initial-major-mode’にセットする。

     バッファーを作成する低レベルのプリミティブはこの関数を使用しないが
     、‘switch-to-buffer’や‘find-file-noselect’のような中位レベルのコマ
     ンドは、バッファーを作成するときは、常にこの関数を使用する。

 -- User Option: initial-major-mode
     この変数の値は、‘*scratch*’バッファーの初期のメジャーモードを決定す
     る。値は、メジャーモードコマンドであるようなシンボルであること。デ
     フォルト値は‘lisp-interaction-mode’である。

 -- Variable: interpreter-mode-alist
     この変数は、‘#!’行内のコマンドインタープリターを指定するスクリプト
     にたいして使用するメジャーモードを指定する。変数の値は、‘(REGEXP .
     MODE)’の形式の要素をもつalistである。これは、そのファイルが
     ‘\\`REGEXP\\'’にマッチするインタープリターを指定する場合は、MODEを
     使用することを意味する。たとえば、デフォルト要素の1つは
     ‘("python[0-9.]*" . python-mode)’である。

 -- Variable: magic-mode-alist
     この変数の値は、‘(REGEXP FUNCTION)’という形式の要素をもつalistであ
     る。ここで、REGEXPは正規表現、FUNCTIONは関数、または‘nil’である。フ
     ァイルをvisitした後に、バッファーの先頭のテキストがREGEXPにマッチし
     た場合、FUNCTIONが非‘nil’なら‘set-auto-mode’はFUNCTIONを呼び出す。
     FUNCTIONが‘nil’の場合は、‘auto-mode-alist’がモードを決定する。

 -- Variable: magic-fallback-mode-alist
     これは‘magic-mode-alist’と同様に機能するが、そのファイルにたいして
     ‘auto-mode-alist’がモードを指定しない場合だけ処理される点が異なる。

 -- Variable: auto-mode-alist
     この変数は、ファイル名パターン(正規表現)と対応するメジャーモードコ
     マンドの連想配列を含む。通常、ファイル名パターンは、‘.el’や‘.c’のよ
     うなサフィックスをテストするが、必須ではない。このalistの通常の要素
     は‘(REGEXP . MODE-FUNCTION)’のようになる。

     たとえば、

          (("\\`/tmp/fol/" . text-mode)
           ("\\.texinfo\\'" . texinfo-mode)
           ("\\.texi\\'" . texinfo-mode)
           ("\\.el\\'" . emacs-lisp-mode)
           ("\\.c\\'" . c-mode)
           ("\\.h\\'" . c-mode)
           ...)

     バージョン番号およびバックアップ用サフィックスをもつファイルを
     visitしたとき、それらは‘file-name-sans-versions’(*note File Name
     Components::を参照)を使用して展開されたファイル名(*note File Name
     Expansion::を参照)から取り除かれてREGEXPとマッチされて、
     ‘set-auto-mode’は対応するMODE-FUNCTIONを呼び出す。この機能により、
     ほとんどのファイルにたいしてEmacsが適切なメジャーモードを選択するこ
     とが可能になる。

     ‘auto-mode-alist’の要素が‘(REGEXP FUNCTION t)’という形式の場合は、
     FUNCTIONを呼び出した後、Emacsは前回マッチしなかったファイル名部分に
     たいしてマッチするために、再度‘auto-mode-alist’を検索する。この機能
     は、圧縮されたパッケージにたいして有用である。‘("\\.gz\\'" FUNCTION
     t)’という形式のエントリーは、ファイルを解凍してから、‘.gz’抜きのフ
     ァイル名にたいして適切なモードに解凍されたファイルを配す。

     以下は‘auto-mode-alist’の先頭に、複数のパターンペアーを追加する方法
     の例である(あなたは、initファイル内でこの種の式を使ったことがあるか
     もしれない)。

          (setq auto-mode-alist
            (append
             ;; ドットで始まる(ディレクトリー名付きの)ファイル名
             '(("/\\.[^/]*\\'" . fundamental-mode)
               ;; ドットのないファイル名
               ("/[^\\./]*\\'" . fundamental-mode)
               ;; ‘.C’で終わるファイル名
               ("\\.C\\'" . c++-mode))
             auto-mode-alist))


File: elisp,  Node: Mode Help,  Next: Derived Modes,  Prev: Auto Major Mode,  Up: Major Modes

22.2.3 Getting Help about a Major Mode
--------------------------------------

‘describe-mode’関数は、メジャーモードに関する情報を提供します。これは通
常、‘C-h m’にバインドされています。この関数は、変数‘major-mode’(*note
Major Modes::を参照)の値を使用します。すべてのメジャーモードがこの変数を
セットする必要があるのは、これが理由です。

 -- Command: describe-mode &optional buffer
     このコマンドは、カレントバッファーのメジャーモードとマイナーモード
     のドキュメントを表示する。この関数は、メジャーモードおよびマイナー
     モードのコマンドのドキュメント文字列を取得するために、
     ‘documentation’関数を使用する(*note Accessing Documentation::を参照
     )。

     BUFFER引数に非‘nil’を指定してLispから呼び出された場合、この関数はカ
     レントバッファーではなく、そのバッファーのメジャーモードとマイナー
     モードのドキュメントを表示する。


File: elisp,  Node: Derived Modes,  Next: Basic Major Modes,  Prev: Mode Help,  Up: Major Modes

22.2.4 Defining Derived Modes
-----------------------------

新しいメジャーモードを定義する推奨された方法は、‘define-derived-mode’を
使用して既存のメジャーモードから派生させる方法です。それほど近いモードが
存在しない場合は‘text-mode’、‘special-mode’、または‘prog-mode’から継承す
るべきです。*note Basic Major Modes::を参照してください。これらがどれも
適切でない場合は、‘fundamental-mode’から継承することができます(*note
Major Modes::を参照)。

 -- Macro: define-derived-mode variant parent name docstring
          keyword-args... body...
     このマクロは、VARIANTをメジャーモードコマンドとして定義し、NAMEをモ
     ード名の文字列形式とする。VARIANTとPARENTは、クォートされていないシ
     ンボルであること。

     新たなコマンドVARIANTは、関数PARENTを呼び出すよう定義され、その後そ
     の親モードの特定の性質をオーバーライドする。

        • 新たなモードは、‘VARIANT-map’という名前の、自身のsparseキーマ
          ップ(疎キーマップ)をもつ。‘define-derived-mode’は、
          ‘VARIANT-map’がすでにセットされていて、かつすでに親をもつ場合
          を除き、親モードのキーマップを新たなマップの親キーマップにする
          。

        • 新たなモードは、自身の構文テーブル(syntax table)をもち、それは
          変数‘VARIANT-syntax-table’に保持される。ただし、
          ‘:syntax-table’キーワード(以下参照)を使用して、これをオーバー
          ライドした場合は異なる。‘define-derived-mode’は、
          ‘VARIANT-syntax-table’がすでにセットされていて、かつ標準的な構
          文テーブルよ異なる親をもつ場合を除き、ペアレントモードの構文テ
          ーブルを‘VARIANT-syntax-table’の親とする。

        • 新たなモードは、自身のabbrevテーブル(略語テーブル)をもち、それ
          は変数‘VARIANT-abbrev-table’に保持される。ただし、
          ‘:abbrev-table’キーワード(以下参照)を使用して、これをオーバー
          ライドした場合は異なる。

        • 新たなモードは、自身のモードフック‘VARIANT-hook’をもつ。これは
          、このフックを実行した後に、最後に‘run-mode-hooks’により、自身
          の祖先のモードのフックを実行する。

     これらに加えて、BODYでPARENTのその他の性質をオーバーライドする方法
     を指定できます。コマンドVARIANTはー、通常のオーバーライドをセットア
     ップした後、そのモードのフックを実行する直前にBODY内のフォームを評
     価します。

     PARENTが非‘nil’の‘mode-class’シンボルプロパティをもつ場合、
     ‘define-derived-mode’はVARIANTの‘mode-class’プロパティに、同じ値を
     セットします。これは、たとえばPARENTがspecialモードの場合は、
     VARIANTもspecialモードになることを保証します(*note Major Mode
     Conventions::を参照)。

     PARENTにたいして‘nil’を指定することもできます。これにより、新たなモ
     ードは親をもたなくなります。その後、‘define-derived-mode’は上述のよ
     うに振る舞いますが、当然PARENTにつながるすべてのアクションは省略さ
     れます。

     引数DOCSTRINGは、新たなモードにたいするドキュメント文字列を指定しま
     す。‘define-derived-mode’は、このドキュメント文字列の最後にそのモー
     ドフックに関する一般的な情報と、その後にそのモードのキーマップを追
     加します。DOCSTRINGを省略した場合は、‘define-derived-mode’がドキュ
     メント文字列を生成します。

     KEYWORD-ARGSは、キーワードと値のペアーです。値は評価されます。現在
     、以下のキーワードがサポートされています:

     ‘:syntax-table’
          新たなモードにたいする構文テーブルを明示的に指定するために、こ
          れを使用できる。‘nil’値を指定した場合、新たなモードはPARENTと
          同じ構文テーブル、PARENTも‘nil’の場合は標準的な構文テーブルを
          使用する(これは、‘nil’値の非キーワード引数は引数を指定しないの
          と同じという通常の慣習には_したがわない_ことに注意されたい)。

     ‘:abbrev-table’
          新たなモードにたいするabbrevテーブルを明示的に指定するために、
          これを使用できる。‘nil’値を指定した場合、新たなモードは
          PARENTと同じabbrevテーブル、PARENTも‘nil’の場合は、
          ‘fundamental-mode-abbrev-table’を使用する(繰り返すが、‘nil’値
          はこのキーワードを指定しないことでは_ない_)。

     ‘:group’
          これが指定された場合、値はそのモードにたいするカスタマイズグル
          ープ(customization group)であること(すべてのメジャーモードがカ
          スタマイズグループをもつ訳ではない)。(まだ実験的かつ未公表だが
          )現在のところ、これを使用するのは‘customize-mode’コマンドだけ
          である。‘define-derived-mode’は、指定されたカスタマイズグルー
          プを自動的に定義_しない_。

     以下は架空の例である:

          (define-derived-mode hypertext-mode
            text-mode "Hypertext"
            "ハイパーテキスト用のメジャーモード
          \\{hypertext-mode-map}"
            (setq case-fold-search nil))

          (define-key hypertext-mode-map
            [down-mouse-3] 'do-hyper-link)

     ‘define-derived-mode’が自動的に行うので、この定義内に
     ‘interactive’指定を記述してはならない。

 -- Function: derived-mode-p &rest modes
     この関数は、シンボルMODESで与えられたメジャーモードのいずれかから、
     カレントメジャーモードが派生された場合は非‘nil’をリターンする。


File: elisp,  Node: Basic Major Modes,  Next: Mode Hooks,  Prev: Derived Modes,  Up: Major Modes

22.2.5 Basic Major Modes
------------------------

Fundamentalモードは別として、他のメジャーモードの一般的な派生元となるメ
ジャーモードが3つあります。それはTextモード、Progモード、およびSpecialで
す。Textモードはその本来もつ機能から有用なモードです(たとえば‘.txt’ファ
イルの編集など)。一方、ProgモードとSpecialモードは主にそのようなモード以
外のモードの派生元として存在します。

   新たなモードは、直接または間接を問わず、可能な限りれら3つのモードから
派生させるべきです。その理由の1つは、関連のあるモードファミリー全体(たと
えばすべてのプログラミング言語のモード)にたいして、ユーザーが単一のモー
ドフックをカスタマイズできる空からです。

 -- Command: text-mode
     Textモードは、人間の言語を編集するためのメジャーモードである。この
     モードは、文字‘"’および‘\’を区切り文字構文(punctuation syntax:
     *note Syntax Class Table::を参照)としてもち、‘M-<TAB>’を
     ‘ispell-complete-word’にバインドする(*note (emacs)Spelling::を参照
     )。

     Textモードから派生されたメジャーモードの例として、HTMLモードがある
     。*note SGML and HTML Modes: (emacs)HTML Mode.を参照のこと。

 -- Command: prog-mode
     Progモードは、プログラミング言語のソースコードを含むバッファーにた
     いする、基本的なメジャーモードである。Emacsビルトインのプログラミン
     グ言語用メジャーモードは、このモードから派生されている。

     Progモードは、‘parse-sexp-ignore-comments’を‘t’(*note Motion via
     Parsing::を参照)にバインドし、‘bidi-paragraph-direction’を
     ‘left-to-right’(*note Bidirectional Display::を参照)にバインドする
     。

 -- Command: special-mode
     Specialモードは、ファイルから直接ではなく、Emacsにより特別
     (specially)に生成されたテキストを含むバッファーにたいする、基本的な
     メジャーモードである。Specialモードから派生されたメジャーモードは、
     ‘mode-class’プロパティに‘special’ーが与えられる(*note Major Mode
     Conventions::を参照)。

     Specialモードは、バッファーを読み取り専用にセットする。このモードの
     キーマップは、いくつかの一般的なバインディングを定義し、それには
     ‘quit-window’にたいする‘q’、‘revert-buffer’(*note Reverting::を参照
     )にたいする‘g’が含まれる。

     Specialから派生されたメジャーモードの例としてはBuffer Menuモードが
     あり、これは‘*Buffer List*’バッファーにより使用される。*note
     Listing Existing Buffers: (emacs)List Buffers.を参照のこと。

   これらに加えて、表形式データのバッファーにたいするモードはTabulated
Listモードから継承できます。このモードは、Specialモードから順に派生され
ているモードです。*note Tabulated List Mode::を参照してください。


File: elisp,  Node: Mode Hooks,  Next: Tabulated List Mode,  Prev: Basic Major Modes,  Up: Major Modes

22.2.6 Mode Hooks
-----------------

すべてのメジャーモードコマンドは、モード独自のノーマルフック
‘change-major-mode-after-body-hook’、そのモードのモードフック、ノーマル
フック‘after-change-major-mode-hook’を実行することにより終了すべきです。
これは、‘run-mode-hooks’を呼び出すことにより行われます。もしそのモードが
派生モードなら、自身のbody内で他のメジャーモード(親モード)を呼び出す場合
は、親モードが自身でこれらのフックを実行しないように、
‘delay-mode-hooks’の中でこれを行うべきです。そのかわりに、派生モードは親
のモードフックも実行する、‘run-mode-hooks’を呼び出すのです。*note Major
Mode Conventions::を参照してください。

   Emacs 22より前のバージョンのEmacsには、‘delay-mode-hooks’がありません
。また、Emacs 24より前のバージョンには、
‘change-major-mode-after-body-hook’がありません。ユーザー実装のメジャー
モードが‘run-mode-hooks’を使用せず、これらの新しい機能を使用するようにア
ップデートされていないときは、これらのメジャーモードは以下の慣習に完全に
したがわないでしょう。それらのモードは、親のモードフックをあまりに早く実
行したり、‘after-change-major-mode-hook’の実行に失敗するかもしれません。
そのようなメジャーモードに遭遇した場合は、以下の慣習にしたがって修正をお
願いします。

   ‘define-derived-mode’を使用してメジャーモードを定義したときは、自動的
にこれらの慣習にしたがうことが確実になります。‘define-derived-mode’を使
用せずにメジャーモードを“手動”で定義した場合は、これらの慣習を自動的に処
理するように、以下の関数を使用してください。

 -- Function: run-mode-hooks &rest hookvars
     メジャーモード、この関数を使用してそれらのモードフックを実行すべき
     である。これは‘run-hooks’(*note Hooks::を参照)と似ているが、
     ‘change-major-mode-after-body-hook’と
     ‘after-change-major-mode-hook’も実行する。

     この関数が、‘delay-mode-hooks’フォーム実行中に呼び出されたときは、
     それらのフックを即座には実行しない。かわりに、次の
     ‘run-mode-hooks’呼び出しでそれらを実行するようにアレンジする。

 -- Macro: delay-mode-hooks body...
     あるメジャーモードコマンドが他のメジャーモードコマンドを呼び出すと
     き、それは‘delay-mode-hooks’の内部で行われるべきである。

     このマクロはBODYを実行するが、BODY実行中はすべての
     ‘run-mode-hooks’呼び出しにたいして、それらのフックの実行を遅延する
     よう指示する。それらのフックは、実際には‘delay-mode-hooks’構造の最
     後の後、次の‘run-mode-hooks’呼び出しの間に実行されるだろう。

 -- Variable: change-major-mode-after-body-hook
     これは、‘run-mode-hooks’により実行されるノーマルフックである。これ
     は、そのモードのフックの前に実行される。

 -- Variable: after-change-major-mode-hook
     これは、‘run-mode-hooks’により実行されるノーマルフックである。これ
     は、すべての適切に記述されたメジャーモードコマンドの一番最後に実行
     される。


File: elisp,  Node: Tabulated List Mode,  Next: Generic Modes,  Prev: Mode Hooks,  Up: Major Modes

22.2.7 Tabulated List mode
--------------------------

Tabulated Listモードとは、表形式データ(“エントリー”から構成されるデータ
であり、各エントリーはそれぞれテキストの1行を占め、エントリーの内容は列
に分割されるようなデータ)を表示するためのメジャーモードです。Tabulated
Listモードは、行列の見栄えよくプリントする機能、および各列の値に応じて行
をソートする機能を提供します。これは、Specialモードから派生されたモード
です(*note Basic Major Modes::を参照)。

   Tabulated Listモードは、より特化したメジャーモードの親モードとして使
用されることを意図しています。例としては、Process Menuモード(*note
Process Information::を参照)や、Package Menuモード(*note (emacs)Package
Menu::を参照)が含まれます。

   このような派生されたモードは、‘tabulated-list-mode’を2つ目の引数に指
定して、通常の方法で‘define-derived-mode’を使用するべきです(*note
Derived Modes::を参照)。‘define-derived-mode’フォームのbodyは、以下にド
キュメントされている変数に値を割り当てることにより、表形式データのフォー
マットを指定するべきです。その後、ヘッダー行を初期化するために関数
‘tabulated-list-init-header’を呼び出すべきです。

   派生されたモードは、“リスティングコマンド”も定義するべきです。これは
モードコマンドではなく、(‘M-x list-processes’のように)ユーザーが呼び出す
コマンドです。リスティングコマンドは、バッファーを作成または切り替えて、
派生モードをオンにして、表形式データを指定し、最後にそのバッファーを事前
設定(populate)するために‘tabulated-list-print’を呼び出すべきです。

 -- Variable: tabulated-list-format
     このバッファーローカル変数は、表形式データのフォーマットを指定する
     。値はベクターで、ベクターの各要素はデータ列を表すリスト‘(NAME
     WIDTH SORT)’である。ここで

        • NAMEは列の名前(文字列)。

        • WIDTHは列にたいして予約される文字数幅(整数)。最終列は各行の終
          端までなので意味がない。

        • SORTは列によりエントリーをソートする方法を指定する。‘nil’の場
          合、その列はソートに使用できない。‘t’の場合は、列の文字列値を
          比較することによりソートされる。それ以外の場合は、
          ‘tabulated-list-entries’の要素と同じ形式の2つの引数をとる、
          ‘sort’にたいする述語関数(predicate function)であること。

 -- Variable: tabulated-list-entries
     このバッファーローカル変数は、Tabulated Listバッファー内に表示され
     るエントリーを指定する。値にはリスト、または関数のいずれかであるこ
     と。

     値がリストの場合、各リスト要素は1つのエントリーに対応し、
     ‘(ID CONTENTS)’という形式であること。ここで

        • IDは‘nil’、またはエントリーを識別するLispオブジェクト。Lispオ
          ブジェクトの場合には、エントリーを再ソートした際、カーソルは
          “同じ”エントリー上に留まる。比較は‘equal’で行われる。

        • CONTENTSは、‘tabulated-list-format’と要素数が同じベクター。ベ
          クター要素は文字列、またはリスト。文字列の場合は、バッファーに
          そのまま挿入される。リスト‘(LABEL . PROPERTIES)’の場合には、
          LABELとPROPERTIESを引数として‘insert-text-button’を呼び出すこ
          とにより、テキストボタンを挿入することを意味する(*note Making
          Buttons::を参照)。

          これらの文字列には、改行を含めるべきではない。

     それ以外の場合、値は引数なしで呼び出され上記形式のリストをリターン
     する関数であること。

 -- Variable: tabulated-list-revert-hook
     このノーマルフックはTabulated Listバッファーのリバートに先立ち実行
     される。派生モードは、‘tabulated-list-entries’を再計算するために、
     このフックに関数を追加できる。

 -- Variable: tabulated-list-printer
     この変数の値は、ポイント位置にエントリー(エントリーを終端する改行を
     含む)を挿入するために呼び出される関数である。この関数は、
     ‘tabulated-list-entries’と同じ意味をもつ2つの引数IDとCONTENTSを受け
     取る。デフォルト値は、エントリーをそのまま挿入する関数である。より
     複雑な方法によりTabulated Listモードを使用するモードは、別の関数を
     指定できる。

 -- Variable: tabulated-list-sort-key
     この変数の値は、Tabulated Listバッファーにたいするカレントのソート
     キーを指定する。‘nil’の場合、ソートは行われていない。それ以外では、
     ‘(NAME . FLIP)’という形式の値をもつ。ここでNAMEは
     ‘tabulated-list-format’内の列目の1つとマッチする文字列、FLIPが非
     ‘nil’の場合は逆順でのソートを意味する。

 -- Function: tabulated-list-init-header
     この関数は、Tabulated Listバッファーにたいする
     ‘header-line-format’を計算してセットし、列ヘッダー上でのクリックで
     ソートを可能にするキーマップをヘッダー行に割り当てる。

     Tabulated Listから派生したモードは、上記の変数(特に
     ‘tabulated-list-format’をセットした後のみ)をセットした後にこれを呼
     び出すべきである。

 -- Function: tabulated-list-print &optional remember-pos
     この関数は、カレントバッファーにエントリーを準備(populate)する。こ
     れはリスティングコマンドとして呼び出されるべきである。この関数は、
     バッファーを消去して‘tabulated-list-entries’で指定されるエントリー
     を‘tabulated-list-sort-key’にしたがってソートした後、各エントリーを
     挿入するために‘tabulated-list-printer’で指定される関数を呼び出す。

     オプション引数REMEMBER-POSが非‘nil’の場合、この関数はカレント行で
     ID要素を探して、もしあればすべてのエントリーを(再)挿入して、その後
     へそのエントリーの移動を試みる。


File: elisp,  Node: Generic Modes,  Next: Example Major Modes,  Prev: Tabulated List Mode,  Up: Major Modes

22.2.8 Generic Modes
--------------------

“genericモード (generic mode:汎用モード))”とは、コメント構文にたいする基
本的なサポートとFont Lockモードをもつ、シンプルなメジャーモードです。
genericモードを定義するには、マクロ‘define-generic-mode’を使用します。
‘define-generic-mode’の使い方の例は、ファイル‘generic-x.el’を参照してく
ださい。

 -- Macro: define-generic-mode mode comment-list keyword-list
          font-lock-list auto-mode-list function-list &optional
          docstring
     このマクロは、MODE(クォートされていないシンボル)という名前の
     genericモードコマンドを定義する。オプション引数DOCSTRINGは、そのモ
     ードコマンドにたいするドキュメント文字列である。これを与えない場合
     は、‘define-generic-mode’がデフォルトのドキュメント文字列を生成する
     。

     引数COMMENT-LISTは、要素が文字、2文字以下の文字列、またはコンスセル
     である。文字か文字列の場合には、そのモードの構文テーブル内で“コメン
     ト開始識別子”としてセットアップされる。エントリーがコンスセルの場合
     、CARは“コメント開始識別子”、CDRは“コメント終了識別子”としてセット
     アップされる(行末によりコメントを終端させたい場合は、後者に‘nil’を
     使用する)。構文テーブルのメカニズムには、実際にコメントの開始および
     終了識別子に関する制限があることに注意されたい。 *note Syntax
     Tables::を参照のこと。

     引数KEYWORD-LISTは、‘font-lock-keyword-face’でハイライトするキーワ
     ードのリストである。キーワードは文字列であること。一方、
     FONT-LOCK-LISTはハイライトするための追加の式リストである。このリス
     トの各要素は、‘font-lock-keywords’の要素と同じ形式をもつべきである
     。*note Search-based Fontification::を参照のこと。

     引数AUTO-MODE-LISTは、変数‘auto-mode-alist’に追加する正規表現のリス
     トである。これらの式は、マクロ呼び出しの展開時ではなく、
     ‘define-generic-mode’の実行時に追加される。

     最後にFUNCTION-LISTは、追加セットアップのためにモードコマンドに呼び
     出される関数のリストである。これらの関数は、モードフック変数
     ‘MODE-hook’の実行の直前に呼び出される。


File: elisp,  Node: Example Major Modes,  Prev: Generic Modes,  Up: Major Modes

22.2.9 Major Mode Examples
--------------------------

Textモードは、Fundamentalを除き、おそらくもっともシンプルなモードです。
上述した慣習の多くを説明するために、以下に‘text-mode.el’の抜粋を示します
:

     ;; このモード用に構文テーブルを作成
     (defvar text-mode-syntax-table
       (let ((st (make-syntax-table)))
         (modify-syntax-entry ?\" ".   " st)
         (modify-syntax-entry ?\\ ".   " st)
         ;; M-cで`hello'が`hello'でなく`Hello'になるよう`p'を追加
         (modify-syntax-entry ?' "w p" st)
         st)
       "`text-mode'で使用される構文テーブル")

     ;; このモード用にキーマップを作成
     (defvar text-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\e\t" 'ispell-complete-word)
         map)
       "`text-mode'のキーマップ
     `mail-mode'、`outline-mode'、`indented-text-mode'のような
     他の多くのモードはこのマップ内で定義した全コマンドを継承する")

   そして、実際にモードコマンドが定義される方法です:

     (define-derived-mode text-mode nil "Text"
       "人間が読むために記述されたテキストを編集するためのメジャーモード
     このモードではパラグラフを区切るのはブランク行か空白行だけである
     したがって適応型フィル(adaptive filling)の全恩恵を受けられる
      (変数`adaptive-fill-mode'を参照のこと)
     \\{text-mode-map}
     Textモードのオンによりノーマルフック`text-mode-hook'が実行される"
       (set (make-local-variable 'text-mode-variant) t)
       (set (make-local-variable 'require-final-newline)
            mode-require-final-newline)
       (set (make-local-variable 'indent-line-function) 'indent-relative))

(‘indent-relative’がデフォルト値の現在では、最後の行は冗長なので、将来の
バージョンで削除するつもりです。)

   3つのLisp用モード(Lispモード、Emacs Lispモード、Lisp Interactionモー
ド)は、Textモードより多くの機能をもち、それにふさわしくコードもより複雑
です。そのようなモードの記述方法を説明するために、‘lisp-mode.el’の抜粋を
示します。

   以下は、Lispモードの構文テーブルとabbrevテーブルを定義する方法です:

     ;; モード固有のテーブル変数の作成
     (defvar lisp-mode-abbrev-table nil)
     (define-abbrev-table 'lisp-mode-abbrev-table ())

     (defvar lisp-mode-syntax-table
       (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
         (modify-syntax-entry ?\[ "_   " table)
         (modify-syntax-entry ?\] "_   " table)
         (modify-syntax-entry ?# "' 14" table)
         (modify-syntax-entry ?| "\" 23bn" table)
         table)
       "`lisp-mode'で使用される構文テーブル")

   Lisp用の3つのモードは、コードの多くを共有します。たとえば、以下の関数
呼び出しにより、さまざまな変数がセットされます:

     (defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
       (when syntax
         (set-syntax-table lisp-mode-syntax-table))
       (setq local-abbrev-table lisp-mode-abbrev-table)
       ...

その中でも特に、以下の関数はLispコメントを処理するために、変数
‘comment-start’をセットアップします:

       (make-local-variable 'comment-start)
       (setq comment-start ";")
       ...

   これら異なるLisp用モードは、微妙に異なるキーマップをもちます。たとえ
ば、Lispモードは‘C-c C-z’を‘run-lisp’にバインドしますが、他のLisp用モー
ドはこれを行いません。とはいえ、すべてのLisp用モードに共通なコマンドがい
くつかあります。以下のコードは、それらの共通コマンドをセットアップします
:

     (defvar lisp-mode-shared-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\e\C-q" 'indent-sexp)
         (define-key map "\177" 'backward-delete-char-untabify)
         map)
       "すべてのLisp用モードでコマンドを共有するためのキーマップ")

そして、以下がLispモードのためのキーマップをセットアップするコードです:

     (defvar lisp-mode-map
       (let ((map (make-sparse-keymap))
     	(menu-map (make-sparse-keymap "Lisp")))
         (set-keymap-parent map lisp-mode-shared-map)
         (define-key map "\e\C-x" 'lisp-eval-defun)
         (define-key map "\C-c\C-z" 'run-lisp)
         ...
         map)
       "Keymap for ordinary Lisp mode.
     All commands in `lisp-mode-shared-map' are inherited by this map.")

最後は、Lispモードのためのメジャーモードコマンドです:

     (define-derived-mode lisp-mode prog-mode "Lisp"
       "GNU Emacs Lisp以外のLispコードを編集するためのメジャーモード
     コマンド:
     後方に移動させるかのようにタブをスペースに削除変換する。
     パラグラフ区切りはブランク行。コメント開始はセミコロン。

     \\{lisp-mode-map}
     `run-lisp'はinferior Lispジョブの開始と既存ジョブ
     から戻るための両方に使われるかもしれないことに注意

     このモードへのエントリーにより、
     `lisp-mode-hook'の値が非nilならそれを呼び出す"
       (lisp-mode-variables nil t)
       (set (make-local-variable 'find-tag-default-function)
            'lisp-find-tag-default)
       (set (make-local-variable 'comment-start-skip)
            "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
       (setq imenu-case-fold-search t))


File: elisp,  Node: Minor Modes,  Next: Mode Line Format,  Prev: Major Modes,  Up: Modes

22.3 Minor Modes
================

“マイナーモード(minor mode)”は、メジャーモードの選択とは無関係にユーザー
が有効、あるいは無効にする可能性のある、オプション機能を使用を提供します
。マイナーモードは個別に、あるいは組み合わせて有効にできます。

   ほとんどのマイナーモードは、メジャーモードとは独立した機能を実装し、
それゆえにほとんどのメジャーモードとともに使用することができます。たとえ
ば、Auto Fillモードはテキスト挿入を許す任意のメジャーモードとともに機能
します。しかし少数ながら、特定のメジャーモードに特化した少数のマイナーモ
ードもあります。たとえば、Diff Auto Refineモードは、Diffモードとともに使
用されることだけを意図したマイナーモードです。

   理想的には、マイナーモードは他のマイナーモードの効果と無関係に、期待
する効果をもつべきです。これは、任意の順序でマイナーモードをアクティブ、
あるいは非アクティブにしても可能なはずです。

 -- Variable: minor-mode-list
     この変数の値は、すべてのマイナーモードコマンドのリストである。

* Menu:

* Minor Mode Conventions::   マイナーモードを記述するためのTips。
* Keymaps and Minor Modes::  マイナーモードが自身のキーマップをもつための方法。
* Defining Minor Modes::     マイナーモードを定義するための便利な機能。


File: elisp,  Node: Minor Mode Conventions,  Next: Keymaps and Minor Modes,  Up: Minor Modes

22.3.1 Conventions for Writing Minor Modes
------------------------------------------

メジャーモードにあるように、マイナーモードの記述にも慣習があります。以下
で、その慣習について説明します。これらの慣習にしたがうには、マクロ
‘define-minor-mode’を使用するのがもっとも簡単な方法です。*note Defining
Minor Modes::を参照してください。

   • 名前が‘-mode’で終わる変数を定義する。これを“モード変数(mode
     variable)”と呼ぶ。マイナーモードコマンドは、この変数をセットすべき
     である。値は、そのモードが無効な場合は‘nil’、有効な場合は非‘nil’に
     なるだろう。そのマイナーモードがバッファーローカルなら、この変数も
     バッファーローカルであること。

     この変数は、モードラインにマイナーモードの名前を表示するために、
     ‘minor-mode-alist’と結合して使用される。これは、
     ‘minor-mode-map-alist’を通じて、そのマイナーモードのキーマップがア
     クティブかどうかも判定する(*note Controlling Active Maps::を参照)。
     個々のコマンドやフックも、この変数の値をチェックできる。

   • モード変数と同じ名前をもつ、“モードコマンド(mode command)”と呼ばれ
     るコマンドを定義する。このコマンドの役目は、モード変数の値のセット
     に加えて、そのモードの機能を使用を実際に有効、または無効にするため
     に必要な、その他すべてを行うことである。

     モードコマンドは、1つのオプション引数を受け入れるべきである。プレフ
     ィクス引数なしでinteractiveに呼び出された場合は、モードをトグルする
     (toggle: 切り替える。たとえば無効なら有効に、有効なら無効にする)こ
     と。プレフィクス引数とともにinteractiveに呼び出された場合、その引数
     が正であればモードを有効に、それ以外は無効にすべきである。

     モードコマンドが、Lispから(つまりからの非interactiveに)呼び出された
     場合は、引数が省略、または‘nil’の場合はモードを有効にすべきである。
     引数がシンボル‘toggle’の場合はモードをトグルし、それ以外の場合は、
     上述の数引数とともにinteractiveに呼び出されたときと同じ方法により、
     その引数を扱うべきである。

     以下は、この挙動の実装方法を示す例である(‘define-minor-mode’マクロ
     が生成するコードも、これに類似する)。

          (interactive (list (or current-prefix-arg 'toggle)))
          (let ((enable (if (eq arg 'toggle)
                            (not foo-mode) ; このモードのモード変数
                          (> (prefix-numeric-value arg) 0))))
            (if enable
                DO-ENABLE
              DO-DISABLE))

     この、やや複雑な挙動の理由は、ユーザーが簡単かつinteractiveにマイナ
     ーモードをトグルでき、以下のようにモードフック内で簡単にマイナーモ
     ードを有効にできるからである:

          (add-hook 'text-mode-hook 'foo-mode)

     ‘foo-mode’モードコマンドは、引数なしでLispから呼び出されたときは、
     無条件にそのマイナーモードを有効にするので、これは‘foo-mode’がすで
     に有効でもそうでなくても正しく振る舞う。モードフック内でマイナーモ
     ードを無効にする場合は、少々醜くなる:

          (add-hook 'text-mode-hook (lambda () (foo-mode -1)))

     しかし、これは頻繁には行われない。

   • モードラインにマイナーモードを標示したい場合は、それぞれのマイナー
     モードにたいして、要素を‘minor-mode-alist’に追加する(*note
     Definition of minor-mode-alist::を参照)。この要素は以下の形式のリス
     トであること:

          (MODE-VARIABLE STRING)

     ここで、MODE-VARIABLEはマイナーモードの有効化を制御する変数であり、
     STRINGはモードラインに標示するための、スペースで始まる短い文字列で
     ある。一度に複数モードの文字列がスペースを占めるので、これらの文字
     列は短くなければならない。

     ‘minor-mode-alist’に要素を追加する際は、重複を避けるために、既存要
     素のチェックに‘assq’を使用すること。たとえば:

          (unless (assq 'leif-mode minor-mode-alist)
            (push '(leif-mode " Leif") minor-mode-alist))

     または、以下のように‘add-to-list’(*note List Variables::を参照)を使
     用すること:

          (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   これらに加えて、メジャーモードにたいする慣習のいくつかは、マイナーモ
ードにたいしても同様に適用されます。それらの慣習はグローバルシンボルの名
前、初期化関数の最後でのフックの使用、キーマップおよびその他のテーブルの
使用です。

   マイナーモードは、可能ならばCustom(*note Customization::を参照)を通じ
ての有効化および無効化をサポートするべきです。これを行うには、モード変数
はは通常は‘:type 'boolean’とともに‘defcustom’で定義されるべきです。その
変数をセットするだけではモードの有効化に不足なら、モードコマンドを呼び出
すことによりモードを有効にする‘:set’メソッドも指定するべきです。そして、
その変数のドキュメント文字列にCustomを通じて変数をセットしなければ効果が
ないことを注記してください。さらに、その定義をautoload cookie(*note
autoload cookie::を参照)でマークして、その変数のカスタマイズによりモード
を定義するライブラリーがロードされるように‘:require’を指定します。たとえ
ば:

     ;;;###autoload
     (defcustom msb-mode nil
       "msb-modeをトグルする
     この変数を直接セットしても効果がない
     \\[customize]か関数`msb-mode'を使用すること"
       :set 'custom-set-minor-mode
       :initialize 'custom-initialize-default
       :version "20.4"
       :type    'boolean
       :group   'msb
       :require 'msb)


File: elisp,  Node: Keymaps and Minor Modes,  Next: Defining Minor Modes,  Prev: Minor Mode Conventions,  Up: Minor Modes

22.3.2 Keymaps and Minor Modes
------------------------------

マイナーモードはそれぞれ自身のキーマップをもつことができ、そのモードが有
効になるとそのキーマップがアクティブになります。マイナーモード用のキーマ
ップをセットアップするには、‘minor-mode-map-alist’というalistに要素を追
加します。*note Definition of minor-mode-map-alist::を参照してください。

   特定の自己挿入文字にたいして、自己挿入と同様に他の何かを行うように振
る舞いを変更するのは、マイナーモードキーマップの1つの使い方です。
(‘self-insert-command’をカスタマイズする別の方法は、
‘post-self-insert-hook’を通じて行う方法です。これ以外の
‘self-insert-command’カスタマイズ用機能は特別なケースに限定されていて、
abbrevモードとAuto Fillモードのためにデザインされています。
‘self-insert-command’にたいする標準定義を、あなた独自の定義に置き換える
ことを試みてはなりません。エディターコマンドループは、この関数を特別に処
理します。)

   マイナーモードは、コマンドを‘C-c’とその後の区切り文字より構成されるキ
ーシーケンスにバインドするかもしれません。しかし、‘C-c’とその後の
‘{}<>:;’のいずれかの文字、またはコントロール文字、数字より構成されるシー
ケンスは、メジャーモード用に予約されています。また、‘C-c LETTER’はユーザ
ー用に予約されています。*note Key Binding Conventions::を参照してくださ
い。


File: elisp,  Node: Defining Minor Modes,  Prev: Keymaps and Minor Modes,  Up: Minor Modes

22.3.3 Defining Minor Modes
---------------------------

マクロ‘define-minor-mode’は、1つの自己完結した定義内にモードを実装する便
利な方法を提供します。

 -- Macro: define-minor-mode mode doc [init-value [lighter [keymap]]]
          keyword-args... body...
     このマクロは、名前がMODE(シンボル)の新たなマイナーモードを定義する
     。これは、ドキュメント文字列としてDOCをもつ、マイナーモードをトグル
     するための、MODEという名前のコマンドを定義する。

     トグルコマンドは１つのオプション(プレフィクス)引数をとる。引数なし
     でinteractiveに呼び出された場合は、そのモードのオンとオフをトグルす
     る。正のプレフィクス引数はモードを有効にし、それ以外のプレフィクス
     引数はモードを無効にする。Lispから呼び出した場合、引数が‘toggle’の
     場合はモードをトグルし、引数が省略もしくは‘nil’の場合はモードを有効
     にする。これはたとえば、メジャーモードフック内でマイナーモードを有
     効にするのを簡便にする。DOCが‘nil’の場合、このマクロは上記を説明す
     るデフォルトのドキュメント文字列を提供する。

     デフォルトでは、これはモードを有効にすると‘t’、無効にすると‘nil’に
     セットされる、MODEという名前の変数も定義する。この変数は、
     INIT-VALUEに初期化される。通常では(以下参照)、この値は‘nil’でなけれ
     ばならない。

     文字列LIGHTERは、モード有効時にモードライン内に何を表示するか指定す
     る。これが‘nil’の場合は、このモードはモードライン内に表示されない。

     オプション引数KEYMAPは、そのマイナーモードにたいするキーマップを指
     定する。非‘nil’の場合、それは(値がキーマップであるような)変数の名前
     、キーマップ、または以下の形式のalistであること

          (KEY-SEQUENCE . DEFINITION)

     ここで、それぞれのKEY-SEQUENCEとDEFINITIONは、‘define-key’に渡すの
     に適した引数である(*note Changing Key Bindings::を参照)。KEYMAPはキ
     ーマップまたはalistであり、これは変数‘MODE-map’も定義する。

     上記の3つの引数INIT-VALUE、LIGHTER、KEYMAPは、KEYWORD-ARGSが使用さ
     れたときは、(部分的に)省略できる。KEYWORD-ARGSは、キーワードとその
     後の対応する値により構成され、いくつかのキーワードは特別な意味をも
     つ:

     ‘:group GROUP’
          生成されるすべての‘defcustom’フォームで使用されるカスタムグル
          ープ名。MODE(後の‘-mode’がある場合はそれを除く)にたいするデフ
          ォルトである。*警告:* そのグループを定義するため‘defgroup’を正
          しく記述していない場合は、このデフォルトグループ名を使用しては
          ならない。*note Group Definitions::を参照のこと。

     ‘:global GLOBAL’
          非‘nil’の場合、これはそのマイナーモードがバッファーローカルで
          なくグローバルであることを指定する。デフォルトは‘nil’。

          マイナーモードをグローバルにしたときの効果の1つは、MODE変数が
          カスタマイズ変数になることである。Customizeインターフェイスを
          通じてこの変数をトグルするとモードがオン、またはオフになり、変
          数の値は将来のEmacsセッション用に保存できるようになる(*note
          (emacs)Saving Customizations::を参照)。保存された変数が機能す
          るためには、Emacsが開始されるたびに‘define-minor-mode’フォーム
          が確実に評価されるようにすべきである。Emacsの一部ではないパッ
          ケージにたいしては、‘:require’キーワードを指定するのが、これを
          行う一番簡単な方法である。

     ‘:init-value INIT-VALUE’
          これは、INIT-VALUE引数を指定するのと等しい。

     ‘:lighter LIGHTER’
          これは、LIGHTER引数を指定するのと等しい。

     ‘:keymap KEYMAP’
          これは、KEYMAP引数を指定するのと等しい。

     ‘:variable PLACE’
          これは、そのモードの状態を格納するために使用される、デフォルト
          の変数MODEを置き換える。これを指定した場合、MODE変数は定義され
          ず、すべてのINIT-VALUE引数は使用されない。PLACEは異なる名前の
          変数(あなた自身が定義しなければならない)、または‘setf’関数とと
          もに使用され得るすべてのもの(*note Generalized Variables::を参
          照)。PLACEにはコンス‘(GET . SET)’も指定できる。ここで、GETはカ
          レント状態をリターンする式であり、SETはそれをセットする1つの引
          数(状態)をとる関数である。

     ‘:after-hook AFTER-HOOK’
          これは、モードフック実行後に評価される、単一のLispフォームを定
          義する。これはクォートすべきでない。

     その他のすべてのキーワード引数は、変数MODEにたいして生成された
     ‘defcustom’に直接渡される。

     MODEという名前のコマンドは、最初にMODEという名前の変数をセットする
     等の標準的な動作を処理した後に、もしあればBODYフォームを実行する。
     それからモードフック変数‘MODE-hook’を実行し、‘:after-hook’内のフォ
     ームを評価して終了する。

   INIT-VALUEの値は‘nil’でなければなりません。ただし、(1)Emacsによりその
モードが事前ロードされている、または(2)たとえユーザーが要求しなくともモ
ードを有効にするためにロードするのが容易な場合を除きます。たとえば、他の
何かが有効でなければそのモードの効果がなく、常にそのタイミングでロードさ
れるような場合は、デフォルトでそのモードを有効にすることに害はありません
。しかし、この状況は通常はあり得ません。通常は、INIT-VALUEの値は‘nil’で
なければならないのです。

   ‘easy-mmode-define-minor-mode’という名前は、このマクロにたいするエイ
リアスです。

   以下は、‘define-minor-mode’の使い方の例です:

     (define-minor-mode hungry-mode
       "Hungryモードをトグルする。
     引数なしでinteractiveに呼び出すとモードをトグルする。
     正のプレフィクス引数でモードを有効に、その他のプレフィクス引数で
     無効にする。Lispから呼び出す場合、引数を省略、またはnilなら
     モードを有効に、`toggle'なら状態をトグルする。

     Hungryモードが有効なときは、C-DELキーは、
     最後を除く先行するすべての空白を飲み込む。
     コマンド \\[hungry-electric-delete] を参照のこと。"
      ;; 初期値
      nil
      ;; モードラインの標示
      " Hungry"
      ;; マイナーモードのバインディング
      '(([C-backspace] . hungry-electric-delete))
      :group 'hunger)

これは、“Hungry mode”という名前のマイナーモード、モードをトグルする
‘hungry-mode’という名前のコマンド、モードが有効かどうかを示す
‘hungry-mode’という名前の変数、モードが有効なときそのキーマップを保持す
る‘hungry-mode-map’という名前の変数を定義します。これは、‘C-<DEL>’にたい
するキーバインディングでキーマップを初期化します。また、変数
‘hungry-mode’をカスタムグループ‘hunger’に置きます。BODYフォームはありま
せん — 多くのマイナーモードは必要としません。

   以下は、これを記述する等価な方法です:

     (define-minor-mode hungry-mode
       "Hungryモードをトグルする。
     ...省略..."
      ;; 初期値
      :init-value nil
      ;; モードラインへのインジケーター
      :lighter " Hungry"
      ;; マイナーモードのバインディング
      :keymap
      '(([C-backspace] . hungry-electric-delete)
        ([C-M-backspace]
         . (lambda ()
             (interactive)
             (hungry-electric-delete t))))
      :group 'hunger)

 -- Macro: define-globalized-minor-mode global-mode mode turn-on
          keyword-args...
     これは、GLOBAL-MODEという名前をグローバルにトグルする。この意味は、
     MODEという名前のバッファーローカルなマイナーモードを、すべてのバッ
     ファーで有効、または無効にするということである。あるバッファー内で
     そのマイナーモードをオンにするには、関数TURN-ONを使用する。マイナー
     モードをオフにするには、−1を引数としてMODEを呼び出す。

     モードをグローバルに有効にすると、それ以降ファイルをvisitすることに
     より作成されるバッファー、Fundamental以外のメジャーモードを使用する
     バッファーにも影響がある。しかし、Fundamentalで作成される新たなバッ
     ファーは検知しない。

     これは、Customizeインターフェイス内でそのマイナーモードのオン/オフ
     を切り替える、カスタムオプションGLOBAL-MODE(*note Customization::)を
     定義する。‘define-minor-mode’と同様に、たとえば‘:require’を与える等
     により、毎回のEmacs開始時に確実に‘define-globalized-minor-mode’フォ
     ームが評価されるようにすべきである。

     グローバルマイナーモードのモード変数にたいしてカスタムグループを指
     定するには、KEYWORD-ARGS内で‘:group GROUP’を使用する。

     一般的には、グローバル化されたマイナーモードを定義するときは、ユー
     ザーがバッファーごとにモードを使用(または無効に)できるように、非グ
     ローバル版も定義すべきである。ことにより、特定のメジャーモード内で
     そのモードのフックを使用することにより、グローバル有効化されたマイ
     ナーモードを無効にすることができるようになる。


File: elisp,  Node: Mode Line Format,  Next: Imenu,  Prev: Minor Modes,  Up: Modes

22.4 Mode Line Format
=====================

Emacsの各ウィンドウ(ミニバッファーウィンドウを除く)には通常、最下部にモ
ードラインがあり、そのウィンドウ内に表示されたバッファーについてステータ
ス情報がモードラインに表示されます。モードラインには、バッファー名、関連
するファイル、再帰編集の深さ、およびメジャーモードやマイナーモードなどの
ような、そのバッファーに関する情報が含まれています。ウィンドウは“ヘッダ
ーライン(header line)”をもつこともでき、これはモードラインによく似ていま
すが、ウィンドウの最上部に表示されます。

   このセクションでは、モードラインおよびヘッダーラインのコンテンツの制
御の仕方について説明します。このチャプターにモードラインを含めた理由は、
モードラインに表示される情報の多くが、有効化されたメジャーモードとマイナ
ーモードに関係があるからです。

* Menu:

* Base: Mode Line Basics.    モードライン制御の基本概念。
* Data: Mode Line Data.      モードラインを制御するデータ構造。
* Top: Mode Line Top.        トップレベル変数、mode-line-format。
* Mode Line Variables::      そのデータ構造で使用される変数。
* %-Constructs::             モードラインへの情報の配置。
* Properties in Mode::       モードライン内でのテキストプロパティの使用。
* Header Lines::             モードラインに類似した最上部のライン。
* Emulating Mode Line::      モードラインのようにテキストをフォーマットする。


File: elisp,  Node: Mode Line Basics,  Next: Mode Line Data,  Up: Mode Line Format

22.4.1 Mode Line Basics
-----------------------

それぞれのモードラインのコンテンツは、バッファーローカル変数
‘mode-line-format’により指定されます(*note Mode Line Top::を参照)。この
変数は“モードライン構成(mode line construct)”を保持します。これは、その
バッファーのモードラインに何を表示するかを制御するテンプレートです。
‘header-line-format’の値は、同じ方法によりそのバッファーのヘッダーライン
を指定します。同一のバッファーにたいするすべてのウィンドウは、同じ
‘mode-line-format’と‘header-line-format’を使用します。

   効率的な理由により、Emacsは各ウィンドウのモードラインとヘッダーライン
を、連続して再評価しません。たとえばウィンドウ設定(window
configuration)の変更、バッファーの切り替え、バッファーのナローイング
(narrowing)またはワイドニング(widening)、スクロール、バッファーの変更等
、それを呼び出す状況が出現したときに、Emacsは再評価を行います。
‘mode-line-format’や‘header-line-format’(*note Mode Line Variables::を参
照)により参照される任意の変数、またはテキストが表示される方法に影響を与
えるデータ構造(*note Display::を参照)を変更した場合は、表示を更新するた
めに関数‘force-mode-line-update’を使用するべきです。

 -- Function: force-mode-line-update &optional all
     この関数は、次の再表示サイクルの間に、すべての関連する変数の最新の
     値にもとづき、カレントバッファーのモードラインとヘッダーラインの更
     新をEmacsに強制する。オプション引数ALLが非‘nil’の場合は、すべてのモ
     ードラインとヘッダーラインの更新を強制する。

     この関数は、メニューバーとフレームタイトルの更新も強制する。

   選択されたウィンドウのモードラインは、通常はフェイス‘mode-line’を使用
して異なるカラーで表示されます。かわりに、他のウィンドウのモードラインは
、フェイス‘mode-line-inactive’で表示されます。*note Faces::を参照してく
ださい。


File: elisp,  Node: Mode Line Data,  Next: Mode Line Top,  Prev: Mode Line Basics,  Up: Mode Line Format

22.4.2 The Data Structure of the Mode Line
------------------------------------------

モードラインのコンテンツは、“モードライン構成(mode line construct)”と呼
ばれるデータ構造により制御されます。モードライン構成はリスト、シンボル、
数字を保持するバッファーローカル変数により構成されます。それぞれのデータ
型は、以下で説明するようにモードラインの外見にたいして特別な意味をもちま
す。フレームタイトル(*note Frame Titles::を参照)とヘッダーライン(*note
Header Lines::を参照)にたいしても、同じデータ構造が使用されます。

   固定文字列のようにシンプルなモードライン構成の場合もありますが、通常
はモードライン構成のテキストを構築するために、固定文字列と変数の値を組み
合わせる方法を指定します。これらの変数の多くは、その変数自体がその値によ
りモードライン構成を定義する変数です。

   以下は、モードライン構成における、さまざまなデータ型の意味です:

‘STRING’
     モードライン構成においての文字列は、文字列内に“‘%’構成
     (‘%’-constructs)”を含む以外は、そのまま表現される。これらは、他のデ
     ータによる置換を意味する。*note %-Constructs::を参照のこと。

     文字列の一部が‘face’プロパティをもつ場合は、バッファー内でそれらが
     表示されるときと同じように、テキスト表示を制御する。‘face’プロパテ
     ィをもたない文字は、デフォルトのフェイス‘mode-line’、または
     ‘mode-line-inactive’で表示される(*note (emacs)Standard Faces::を参
     照)。STRING内の‘help-echo’プロパティと‘keymap’プロパティは、特別な
     意味をもつ。*note Properties in Mode::を参照のこと。

‘SYMBOL’
     モードライン構成においてのシンボルは、その値を意味する。モードライ
     ン構成としては、SYMBOLの値はSYMBOLの位置に使用される。しかし、シン
     ボル‘t’と‘nil’は、値がvoidであるようなシンボルとして無視される。

     例外が1つある。SYMBOLの値が文字列の場合、それはそのまま表示され、
     ‘%’構成は認識されない。

     SYMBOLが“危険”とマークされていない(非‘nil’の
     ‘risky-local-variable’プロパティをもつ)場合は、SYMBOLの値中で指定さ
     れたテキストプロパティはすべて無視される。これには、SYMBOLの値中の
     文字列のテキストプロパティ、同様に文字列内の‘:eval’フォームと
     ‘:propertize’フォームがすべて含まれる。(これはセキュリティー上の理
     由による。危険とマークされていない変数は、ユーザーへの問い合わせな
     しでファイル変数から自動的にセットされ得る。)

‘(STRING REST...)’
‘(LIST REST...)’
     最初の要素が文字列またはリストであるようなリストは、すべての要素を
     再帰的に処理して、その結果を結合することを意味する。これは、モード
     ライン構成において、もっとも一般的なフォームである。

‘(:eval FORM)’
     最初の要素がシンボル‘:eval’であるようなリストは、FORMを評価して、そ
     の結果を表示する文字列として使用するよう指示する。この評価がファイ
     ルをロードできないことを確認すること。ファイルをロードすると、無限
     再帰が発生するかもしれない。

‘(:propertize ELT PROPS...)’
     最初の要素がシンボル‘:propertize’であるようなリストは、モードライン
     構成ELTを再帰的に処理して、PROPSにより指定されるテキストプロパティ
     に結果を加えるよう指示する。引数PROPSは、0個以上のTEXT-PROPERTYと
     VALUEのペアーで構成されるべきである。

‘(SYMBOL THEN ELSE)’
     最初の要素がキーワード以外のシンボルであるようなリストは、条件文を
     指定する。その意味は、SYMBOLの値に依存する。SYMBOLが非‘nil’値をもつ
     場合は、モードライン構成として、2つ目の要素THENが再帰的に処理され、
     それ以外は3つ目の要素ELSEが再帰的に処理される。ELSEは省略でき、その
     場合SYMBOLの値が‘nil’かvoidならば、モードライン構成は何も表示しない
     。

‘(WIDTH REST...)’
     最初の要素が整数であるようなリストは、RESTの結果の切り詰め、または
     パディングを指定する。残りの要素RESTは、モードライン構成として再帰
     的に処理され、互いに結合される。WIDTHが正の場合、結果の幅がWIDTHよ
     り少ないときは、右側にスペースがパディングされる。WIDTHが負の場合、
     結果の幅が−WIDTHより大きいときは、右側が切り詰められる。

     たとえば、ウィンドウ最上部からのバッファー位置をパーセント表示する
     には、‘(-3 "%p")’のようなリストを使用すればよい。


File: elisp,  Node: Mode Line Top,  Next: Mode Line Variables,  Prev: Mode Line Data,  Up: Mode Line Format

22.4.3 The Top Level of Mode Line Control
-----------------------------------------

変数‘mode-line-format’は、モードラインの全体的な制御を行います。

 -- User Option: mode-line-format
     この変数の値は、モードラインのコンテンツを制御するモードライン構成
     である。これは、すべてのバッファーにおいて、常にバッファーローカル
     である。

     あるバッファー内でこの変数に‘nil’をセットした場合、そのバッファーは
     モードラインをもたない(高さが1行しかないウィンドウも、モードライン
     を表示しない)。

   ‘mode-line-format’のデフォルト値は、‘mode-line-position’や
‘mode-line-modes’(これは‘mode-name’と‘minor-mode-alist’の値を組み込む)の
ような、他の変数の値を使用するようデザインされています。
‘mode-line-format’自体を変更する必要があるモードは、ほとんどありません。
ほとんどの用途にたいしては、‘mode-line-format’が直接、または間接的に参照
する、いくつかの変数を修正すれば十分です。

   ‘mode-line-format’l自体の変更を行った場合、新たな値は他の様式でコンテ
ンツを複製したり情報を表示するのではなく、デフォルト値(*note Mode Line
Variables::を参照)に現れるのと同じ変数を使用するべきです。この方法を使用
すれば、ユーザーや(‘display-time’やメジャーモードのような)Lispプログラム
により行われたカスタマイズは、それらの変数への変更を通じて、効力を保ちま
す。

   以下は、Shellモードにたいして有用かもしれない、架空の
‘mode-line-format’の例です(実際には、Shellモードは‘mode-line-format’をセ
ットしない):

     (setq mode-line-format
       (list "-"
        'mode-line-mule-info
        'mode-line-modified
        'mode-line-frame-identification
        "%b--"
        ;; これはリスト作成中に評価されることに注意。
        ;; これは単なる文字列のモードライン構成を作成する。
        (getenv "HOST")
        ":"
        'default-directory
        "   "
        'global-mode-string
        "   %[("
        '(:eval (mode-line-mode-name))
        'mode-line-process
        'minor-mode-alist
        "%n"
        ")%]--"
        '(which-func-mode ("" which-func-format "--"))
        '(line-number-mode "L%l--")
        '(column-number-mode "C%c--")
        '(-3 "%p")))

(変数‘line-number-mode’、‘column-number-mode’、‘which-func-mode’は特定の
マイナーモードを有効にする。通例どおり、これらの変数名は、マイナーモード
コマンド名でもある。)


File: elisp,  Node: Mode Line Variables,  Next: %-Constructs,  Prev: Mode Line Top,  Up: Mode Line Format

22.4.4 Variables Used in the Mode Line
--------------------------------------

このセクションでは、‘mode-line-format’の標準的な値として、モードラインテ
キストに組み込まれる変数を説明します。これらの変数は、本質的には特別なも
のではありません。‘mode-line-format’が使用する変数を他の変数に変更すれば
、それらはモードライン上で同様の効果をもちます。しかし、Emacsのさまざま
な部分は、それらの変数がモードラインを制御するという認識の元、それらの変
数をセットします。したがって、事実上モードラインがそれらの変数を使用する
のは必須なのです。

 -- Variable: mode-line-mule-info
     この変数は、言語環境(language environment)、バッファーコーディング
     システム、カレント入力メソッド(current input method)に関する情報の
     モードライン構成の値を保持する。*note Non-ASCII Characters::を参照
     のこと。

 -- Variable: mode-line-modified
     この変数は、カレントバッファーが変更されたかどうかを表示する、モー
     ドライン構成の値を保持する。デフォルト値ではバッファーが変更されて
     いれば‘**’、バッファーが変更されていなければ‘--’、バッファーが読み
     取り専用なら‘%%’、読み取り専用だが変更されているときは‘%*’を表示す
     る。

     この変数を変更しても、モードラインは強制的に更新されない。

 -- Variable: mode-line-frame-identification
     この変数は、カレントフレームを識別する。デフォルト値では、複製フレ
     ームを表示可能なウィンドウシステムを使用している場合は‘" "’、一度に
     1つのフレームだけを表示する通常の端末では‘"-%F "’を表示する。

 -- Variable: mode-line-buffer-identification
     この変数は、そのウィンドウ内で表示されているバッファーを識別する。
     デフォルト値では、少なくとも12列になるようスペースパディングされた
     バッファー名を表示する。

 -- User Option: mode-line-position
     この変数は、バッファー内での位置を標示する。デフォルト値ではバッフ
     ァーのパーセントを表示し、オプションでバッファーサイズ、行番号、列
     番号を表示する。

 -- Variable: vc-mode
     変数‘vc-mode’は、各バッファーにたいしてバッファーローカルであり、そ
     のバッファーがvisitしているファイルがバージョンコントロールで保守さ
     れているかどうかと、保守されている場合はバージョンコントロールシス
     テムの種別を表示する。新しいモードラインに表示される文字列、バージ
     ョンコントロールされていない場合は‘nil’である。

 -- User Option: mode-line-modes
     この変数は、そのバッファーのメジャーモードとマイナーモードを表示す
     る。デフォルト値では再帰編集レベル(recursive editing level)、プロセ
     ス状態の情報、ナローイング(narrowing)効果の有無を表示する。

 -- Variable: mode-line-remote
     この変数は、カレントバッファーにたいする‘default-directory’がリモー
     トかどうかを表示するために使用される。

 -- Variable: mode-line-client
     この変数は、‘emacsclient’フレームを識別するために使用される。

   以下の3つの変数は、‘mode-line-modes’内で使用されます:

 -- Variable: mode-name
     このバッファーローカル変数は、カレントバッファーのメジャーモードの
     “愛称(pretty name)”を保持する。モード名がモードラインに表示されるよ
     うに、それぞれのメジャーモードは、この変数をセットすべきである。値
     は文字列である必要はなく、モードライン構成内で有効な任意のデータ型
     (*note Mode Line Data::を参照)を使用できる。モードライン内でモード
     名を識別する文字列の計算には、‘format-mode-line’を使用する(*note
     Emulating Mode Line::を参照)。

 -- Variable: mode-line-process
     このバッファーローカル変数には、そのモードにおいて、サブプロセスと
     の通信にたいするプロセス状態のモードライン情報が含まれる。これはメ
     ジャーモード名の直後(間のスペースはない)に表示される。たとえば、
     ‘*shell*’バッファーでの値は‘(":%s")’であり、これは‘(Shell:run)’のよ
     うに、メジャーモードとともにその状態を表示する。通常、この変数は
     ‘nil’である。

 -- Variable: minor-mode-alist
     この変数は、マイナーモードがアクティブかをモードラインに示す方法を
     指定する要素をもつ、連想リスト(association list)を保持する。
     ‘minor-mode-alist’の各要素は、2要素のリストであること:

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

     より一般的には、MODE-LINE-STRINGは任意のモードライン構成であり得る
     。MINOR-MODE-VARIABLEの値が非‘nil’の場合はモードラインに表示され、
     それ以外では表示されない。一緒に実行されないよう、これらの文字列は
     スペースで始まるべきである。慣例的に、特定のモードにたいする
     MINOR-MODE-VARIABLEは、そのマイナーモードがアクティブになった際には
     、非‘nil’値にセットされる。

     ‘minor-mode-alist’自体はバッファーローカルではない。このalist内で参
     照される各変数は、そのマイナーモードをバッファーごとに個別に有効に
     できる場合は、バッファーローカルであること。

 -- Variable: global-mode-string
     この変数は、モードライン内でマイナーモード‘which-func-mode’がセット
     されている場合はその直後、セットされていなければ‘mode-line-modes’の
     後に表示されるモードライン構成を保持する(デフォルト)。コマンド
     ‘display-time’は、時間とロードの情報を含む文字列を保持する変数
     ‘display-time-string’を参照する、‘global-mode-string’をセットする。

     ‘%M’構成は、‘global-mode-string’の値を置き換えるが、この変数は
     ‘mode-line-format’からモードラインにincludeされるので、時代遅れであ
     る。

   以下は、‘mode-line-format’のデフォルト値の簡略化バージョンです。実際
のデフォルト値には、追加のテキストプロパティ指定も含まれます。

     ("-"
      mode-line-mule-info
      mode-line-modified
      mode-line-frame-identification
      mode-line-buffer-identification
      "   "
      mode-line-position
      (vc-mode vc-mode)
      "   "
      mode-line-modes
      (which-func-mode ("" which-func-format "--"))
      (global-mode-string ("--" global-mode-string))
      "-%-")


File: elisp,  Node: %-Constructs,  Next: Properties in Mode,  Prev: Mode Line Variables,  Up: Mode Line Format

22.4.5 ‘%’-Constructs in the Mode Line
--------------------------------------

モードライン構成として使用される文字列は、さまざまな種類のデータを置き換
えるために、‘%’構成を使用できます。以下は、定義済みの‘%’構成と意味のリス
トです。

   ‘%%’以外の構成では、フィールドの最小幅を指定するために、‘%’の後に10進
整数を追加できます。幅がそれより小さい場合、そのフィールドは最小幅にパデ
ィングされます。純粋に数値的な構成(‘c’、‘i’、‘I’、‘l’)は左側、それ以外は
右側にスペースを追加してパディングされます。

‘%b’
     ‘buffer-name’関数により取得されるカレントバッファー名。*note Buffer
     Names::を参照のこと。

‘%c’
     ポイント位置のカレント列番号。

‘%e’
     EmacsがLispオブジェクトにたいしてメモリー不足になりそうなときは、そ
     れを伝える簡略なメッセージを示す。それ以外の場合は空である。

‘%f’
     ‘buffer-file-name’関数により取得される、visitしているファイル名。
     *note Buffer File Name::を参照のこと。

‘%F’
     選択されたフレームのタイトル(ウィンドウシステム上のみ)、または名前
     。*note Basic Parameters::を参照のこと。

‘%i’
     カレントバッファーのアクセス可能な範囲のサイズ。基本的には‘(-
     (point-max) (point-min))’。

‘%I’
     ‘%i’と同様だが、10^3は‘k’、10^6は‘M’、10^9は‘G’を使用して省略するこ
     とにより、より読みやすい方法でサイズをプリントする。

‘%l’
     ポイント位置のカレント行番号。そのバッファーのアクセス可能な範囲内
     でカウントされる。

‘%n’
     ナローイングが有効なときは‘Narrow’、それ以外は何も表示しない(*note
     Narrowing::の‘narrow-to-region’を参照されたい)。

‘%p’
     ウィンドウの*最上部*より上にあるバッファーテキストのパーセント表示
     、または‘Top’、‘Bottom’、‘All’のいずれか。デフォルトのモードライン
     構成は、これを3文字に切り詰めることに注意されたい。

‘%P’
     ウィンドウの*最下部*より上にあるバッファーテキスト(ウィンドウ内の可
     視なテキストと、最上部の上にあるテキスト)のパーセント表示、およびバ
     ッファーの最上部がスクリーン上で可視な場合は、それに加えて‘Top’。ま
     たは‘Bottom’か‘All’。

‘%s’
     ‘process-status’により取得される、カレントバッファーに属するサブプ
     ロセスの状態。*note Process Information::を参照のこと。

‘%z’
     キーボード、端末、およびバッファーコーディングシステムのニーモニッ
     ク。

‘%Z’
     ‘%z’と同様だが、EOL形式(end-of-line format: 改行形式)を含む。

‘%*’
     バッファーが読み取り専用(‘buffer-read-only’を参照)の場合は‘%’、
     変更されている場合(‘buffer-modified-p’を参照)は‘*’、
     それ以外は‘-’。*note Buffer Modification::を参照のこと。

‘%+’
     バッファーが変更されている場合(‘buffer-modified-p’を参照)は‘*’
     バッファーが読み取り専用(‘buffer-read-only’を参照)の場合は‘%’、
     それ以外は‘-’。これは、読み取り専用バッファーの変更にたいしてのみ
     ‘%*’と異なる。*note Buffer Modification::を参照のこと。

‘%&’
     バッファーが変更されている場合は‘*’、それ以外は‘-’。

‘%[’
     再帰編集レベルの深さを標示する(ミニバッファーレベルは勘定しない)。
     1つの編集レベルが‘[’。*note Recursive Editing::を参照のこと。

‘%]’
     1つの編集レベルが‘]’(ミニバッファーレベルは勘定しない)。

‘%-’
     モードラインの残りを充填するのに十分なダッシュ。

‘%%’
     文字‘%’。‘%’構成が許される文字列内に、リテラル‘%’を含めるには、この
     方法を使用する。

   以下の2つの‘%’構成はまだサポートされていますが、同じ結果を変数
‘mode-name’と‘global-mode-string’で取得できるので、これらは時代遅れです
。

‘%m’
     ‘mode-name’の値。

‘%M’
     ‘global-mode-string’の値。


File: elisp,  Node: Properties in Mode,  Next: Header Lines,  Prev: %-Constructs,  Up: Mode Line Format

22.4.6 Properties in the Mode Line
----------------------------------

モードライン内では、特定のテキストプロパティが意味をもちます。‘face’プロ
パティは、テキストの外見に影響します。‘help-echo’プロパティはそのテキス
トのヘルプ文字列に関連し、‘keymap’によりテキストをマウスに感応させること
ができます。

   モードライン内のテキストにたいしてテキストプロパティを指定するには、
4つの方法があります:

  1. モードラインデータ構造内に、テキストプロパティをもつ文字列を直接配
     する。

  2. ‘%12b’のような、モードライン%構成に、テキストプロパティを配する。そ
     の場合、%構成を展開すると、同じテキストプロパティをもつことになる。

  3. PROPSで指定されるテキストプロパティをELTに与えるために、
     ‘(:propertize ELT PROPS...)’構成を使用する。

  4. FORMがテキストプロパティをもつ文字列に評価されるように、モードライ
     ンデータ構造内に‘:eval FORM’を含むリストを使用する。

   キーマップを指定するために、‘keymap’プロパティを使用できます。このキ
ーマップは、マウスクリックにたいしてのみ、実際の効果をもちます。モードラ
イン内にポイントを移動させるのは不可能なので、文字キーやファンクションキ
ーをこれにバインドしても、効果はありません。

   モードラインが、‘risky-local-variable’が非‘nil’であるようなプロパティ
をもつ変数を参照する場合、その変数の値により与える、または指定されるテキ
ストプロパティは、すべて無視されます。これは、そのようなプロパティは呼び
出される関数を指定するかもしれず、その関数はファイルローカル変数が由来か
もしれないからです。


File: elisp,  Node: Header Lines,  Next: Emulating Mode Line,  Prev: Properties in Mode,  Up: Mode Line Format

22.4.7 Window Header Lines
--------------------------

ウィンドウは、最下部にモードラインをもつことができるのと同じように、最上
部に“ヘッダーライン(header line)”をもつことができます。ヘッダーライン機
能は、それが‘header-line-format’により制御されることを除けば、モードライ
ンと同じように機能します。

 -- Variable: header-line-format
     すべてのバッファーにたいしてローカルなこの変数は、そのバッファーを
     表示するバッファーにたいして、ヘッダーラインを表示する方法を指定す
     る。この変数の値のフォーマットは、‘mode-line-format’にたいするフォ
     ーマットと同じである(*note Mode Line Data::を参照)。通常、この変数
     は‘nil’なので、通常のバッファーはヘッダーラインをもたない。

 -- Function: window-header-line-height &optional window
     この関数は、WINDOWのヘッダーラインの高さを、ピクセルでリターンする
     。WINDOWは生きたウィンドウでなければならず、デフォルトは選択された
     ウィンドウである。

   高さが1行しかないウィンドウは、決してヘッダーラインを表示しません。ま
た、高さが2行しかないウィンドウは、一度にモードラインとヘッダーラインを
表示できません。そのようなウィンドウがモードラインをもつ場合、ヘッダーラ
インは表示されません。


File: elisp,  Node: Emulating Mode Line,  Prev: Header Lines,  Up: Mode Line Format

22.4.8 Emulating Mode Line Formatting
-------------------------------------

関数‘format-mode-line’を使用して、特定のモードライン構成にもとづきモード
ライン、またはヘッダーラインに表示されるテキストを計算できます。

 -- Function: format-mode-line format &optional face window buffer
     この関数は、あたかもWINDOWにたいしてモードラインを生成するかのよう
     に、FORMATに応じてテキスト行をフォーマットするが、さらにそのテキス
     トを文字列としてリターンする。引数WINDOWのデフォルトは、選択された
     ウィンドウである。BUFFERが非‘nil’の場合、使用されるすべての情報は
     BUFFERから取得される。デフォルトでは、WINDOWのバッファーから取得さ
     れる。

     文字列の値は通常、モードラインがもつであろうフェイス、キーマップ等
     に対応するテキストプロパティをもつ。FORMATにより指定された‘face’プ
     ロパティのないすべての文字は、FACEにより決定されるデフォルト値を取
     得する。FACEが‘t’の場合は、WINDOWが選択されていれば‘mode-line’、そ
     れ以外は‘mode-line-inactive’であることを意味する。FACEが‘nil’、また
     は省略された場合は、デフォルトのフェイスを意味する。FACEが整数の場
     合、この関数はテキストプロパティをもたない値をリターンするだろう。

     FACEの値として、他の有効なフェイスを指定することもできる。指定され
     た場合、それはFORMATでフェイスを指定されていない文字の‘face’プロパ
     ティのフェイスを提供する。

     FACEとして‘mode-line’、‘mode-line-inactive’、‘header-line’を使用す
     ることにより、フォーマットされた文字列のリターンに加えて、対応する
     フェイスのカレント定義を使用して、実際にモードラインやヘッダーライ
     ンが再描画されるだろうということに注意されたい(他のフェイスでは、再
     描画は行われない)。

     たとえば、‘(format-mode-line header-line-format)’は選択されたウィン
     ドウに表示されるテキスト(ヘッダーラインがない場合は‘""’)をリターン
     するだろう。‘(format-mode-line header-line-format 'header-line)’は
     、各文字がヘッダーライン内でもつであろうフェイスをもつ、同じテキス
     トをリターンし、加えてヘッダーラインの再描画も行う。


File: elisp,  Node: Imenu,  Next: Font Lock Mode,  Prev: Mode Line Format,  Up: Modes

22.5 Imenu
==========

“Imenu”とは、バッファー内の定義やセクションをすべてリストするメニューを
ユーザー選択することにより、バッファー内の該当箇所に直接移動する機能です
。Imenuは、定義(またはバッファーのその他の名前つき範囲)の名前とその定義
のバッファー内での位置をリストする、バッファーインデックスを構築して、ユ
ーザーがそれを選択すればポイントをおこに移動できるようにして機能します。
メジャーモードは、‘imenu-add-to-menubar’を使用して、メニューバーアイテム
を追加することができます。

 -- Command: imenu-add-to-menubar name
     この関数は、NAMEという名前のImenuを実行するためのローカルメニューバ
     ーを定義する。

   Imenuを使用ためのユーザーレベルコマンドは、Emacsマニュアル内で説明さ
れています(*note Imenu: (emacs)Imenu.を参照)。このセクションでは、特定の
メジャーモードにたいして、定義や名前つき範囲を見つける、Imenuメソッドの
カスタマイズ方法を説明します。

   変数‘imenu-generic-expression’をセットするのが通常の、そしてもっとも
シンプルな方法です:

 -- Variable: imenu-generic-expression
     この変数が非‘nil’の場合、それはImenuにたいして定義を探すための正規
     表現を指定するリストである。シンプルな‘imenu-generic-expression’の
     要素は、以下のようになる:

          (MENU-TITLE REGEXP INDEX)

     ここで、MENU-TITLEが非‘nil’の場合、それはこの要素にたいするマッチが
     、バッファーインデックスのサブメニューとなることを告げる。
     MENU-TITLE自体は、そのサブメニューにたいして名前を指定する。
     MENU-TITLEが‘nil’,の場合は、この要素にたいするマッチは、直接トップ
     レベルのバッファーインデックスとなる。

     このリストの2つ目の要素REGEXPは、正規表現である(*note Regular
     Expressions::を参照)。これは、バッファー内でこれにマッチするものは
     定義、あるいはバッファーインデックス内に記載すべき何かであると判断
     される。3つ目の要素INDEXは、0以上の整数の場合は、REGEXP内の部分式
     (subexpression)が定義名にマッチすることを示します。

     以下のような要素もある:

          (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)

     この要素にたいする各マッチはインデックスアイテムを作成し、ユーザー
     によりそのインデックスアイテムが選択されたとき、アイテム名、バッフ
     ァー位置、およびARGUMENTSから構成される引数で、FUNCTIONを呼び出す。

     Emacs Lispモードにたいしては、‘imenu-generic-expression’は以下のよ
     うになるだろう:

          ((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Types*"
            "^\\s-*\
          (def\\(type\\|struct\\|class\\|ine-condition\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2))

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。

 -- Variable: imenu-case-fold-search
     この変数は、‘imenu-generic-expression’の値中の正規表現マッチが、大
     文字小文字を区別するかどうかを制御する。‘t’,(デフォルト)の場合は、
     大文字小文字の違いを無視することを意味する。

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。

 -- Variable: imenu-syntax-alist
     この変数は、‘imenu-generic-expression’処理中に、カレントバッファー
     の構文テーブルをオーバーライドして使用する、構文テーブル変更用の
     alistである。このalistの各要素は、以下の形式をもつべきである:

          (CHARACTERS . SYNTAX-DESCRIPTION)

     CARのCHARACTERSには、文字または文字列を指定できる。この要素は、その
     文字、または文字列がSYNTAX-DESCRIPTIONにより指定される構文でありこ
     とを示し、‘modify-syntax-entry’に渡される(*note Syntax Table
     Functions::を参照)。

     典型的には、この機能は通常はシンボル構文(symbol syntax)をもつ文字に
     たいして単語構文(word syntax)を与えるために使用され、それにより
     ‘imenu-generic-expression’が単純になり、マッチングのスピードも向上
     する。たとえば、Fortranモードは以下のようにこれを使用する:

          (setq imenu-syntax-alist '(("_$" . "w")))

     ‘imenu-generic-expression’の正規表現は、‘\\(\\sw\\|\\s_\\)+’のかわ
     りに、‘\\sw+’を使用できる。このテクニックは、モードの名前として許さ
     れるより短い、頭文字に名前を制限する必要があるときは、不便かもしれ
     ないことに注意されたい。

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。

   あるメジャーモードにたいしてImenuをカスタマイズする別の方法には、
‘imenu-prev-index-position-function’と
‘imenu-extract-index-name-function’があります:

 -- Variable: imenu-prev-index-position-function
     この変数が非‘nil’の場合、その値はポイント位置からバッファーを後方に
     スキャンして、バッファーインデックスに配すべき、次の“定義”を探すた
     めの関数であること。そして、ポイントより前に他の“定義”が見つからな
     ければ、‘nil’をリターンすべきである。見つかった場合は、
     “definition”を見つけた場所にポイントを残し、任意の非‘nil’値をリター
     ンすべきである。

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。

 -- Variable: imenu-extract-index-name-function
     この変数が非‘nil’の場合、その値はポイントが定義中にある
     (‘imenu-prev-index-position-function’関数がポイントを残す場所)とい
     う想定の元、その定義の名前をリターンする関数であること。

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。

   メジャーモードにたいしてImenuをカスタマイズするための最後の方法は、変
数‘imenu-create-index-function’のセットです:

 -- Variable: imenu-create-index-function
     この変数は、バッファーインデックスを作成するために使用する関数を指
     定する。この関数は、引数がをとらず、カレントバッファーにたいするイ
     ンデックスalist(index alist)をリターンすべきである。この関数は
     ‘save-excursion’内で呼び出されるので、どこにポイントを残しても違い
     はない。

     このインデックスalistは、3つのタイプの要素をもつことができる。以下
     は、シンプル要素(simple element)の例である:

          (INDEX-NAME . INDEX-POSITION)

     シンプル要素の選択は、そのバッファー内の位置INDEX-POSITIONに移動す
     る効果をもつ。スペシャル要素(special element)は、以下のようなもので
     ある:

          (INDEX-NAME INDEX-POSITION FUNCTION ARGUMENTS...)

     スペシャル要素の選択により、以下が処理される:

          (funcall FUNCTION
                   INDEX-NAME INDEX-POSITION ARGUMENTS...)

     ネストされたサブalist要素(nested sub-alist element)は、以下のような
     ものである:

          (MENU-TITLE . SUB-ALIST)

     これは、SUB-ALISTにより指定される、サブメニューMENU-TITLEを作成する
     。

     ‘imenu-create-index-function’のデフォルト値は、
     ‘imenu-default-create-index-function’である。この関数は、インデック
     スalistを生成するために、‘imenu-prev-index-position-function’の値と
     、‘imenu-extract-index-name-function’の値を呼び出す。しかし、これら
     2つ変数のいずれかが‘nil’の場合、デフォルト関数はかわりに
     ‘imenu-generic-expression’を使用する。

     この変数をセットすることにより、カレントバッファーにたいしてバッフ
     ァーローカルになる。


File: elisp,  Node: Font Lock Mode,  Next: Auto-Indentation,  Prev: Imenu,  Up: Modes

22.6 Font Lock Mode
===================

“Font Lockモード”とは、バッファーの特定の部分にたいして、それらの構文的
役割(syntactic role)にもとづき、自動的に‘face’プロパティをアタッチする、
バッファーローカルなマイナーモードです。このモードがバッファーをパースす
る方法は、そのメジャーモードに依存します。ほとんどのメジャーモードは、ど
のコンテキストでどのフェイスを使用するかにたいして、構文的条件(syntactic
criteria)を定義します。このセクションでは、特定のメジャーモードにたいし
て、Font Lockをカスタマイズする方法を説明します。

   Font Lockモードは、2つの方法によりハイライトするテキストを探します。
それは構文テーブル(syntax table)にもとづく構文解析と、(通常は正規表現に
たいする)検索です。最初に構文的フォント表示(syntactic fontification)が発
生します。これはコメントと文字列定数を見つけて、それらをハイライトします
。検索ベースのフォント表示が発生するのは、2番目です。

* Menu:

* Font Lock Basics::         Font Lockカスタマイズの概要。
* Search-based Fontification::  正規表現にもとづくフォント表示。
* Customizing Keywords::     検索ベースフォント表示のカスタマイズ。
* Other Font Lock Variables::  追加のカスタマイズ機能。
* Levels of Font Lock::      多なりとも少ユーザーが選択できるように、それぞれのモードは代替レベルを定義できる。
* Precalculated Fontification::  バッファーコンテンツを生成するLispプログラムが、どのようにしてそれをフォント表示する方法も指定できるか。
* Faces for Font Lock::      Font
                               Lockにたいする具体的な特殊フェイス。
* Syntactic Font Lock::      構文テーブルにもとづくフォント表示。
* Multiline Font Lock::      Font
                               Lockに複数行構成の正しいハイライトを強制する方法。


File: elisp,  Node: Font Lock Basics,  Next: Search-based Fontification,  Up: Font Lock Mode

22.6.1 Font Lock Basics
-----------------------

Font Lockモードがテキストをハイライトする方法を制御する変数が、いくつか
あります。しかし、メジャーモードは、これらの変数を直接セットするべきでは
ありません。かわりに、メジャーモードはバッファーローカル変数として、
‘font-lock-defaults’をセットするべきです。Font Lockモードが有効なときは
、他のすべての変数をセットするために、この変数に割り当てられた値が使用さ
れます。

 -- Variable: font-lock-defaults
     この変数は、そのモード内のテキストをフォント表示する方法を指定する
     ために、メジャーモードによりセットされる。この変数は、セットした際
     に自動的にバッファーローカルになる。変数の値が‘nil’の場合、Font
     Lockモードはハイライトを行わず、バッファー内のテキストに明示的にフ
     ェイスを割り当てるために、‘Faces’メニュー(メニューバーの‘Edit’の下
     の‘Text Properties’)を使用できる。

     非‘nil’の場合、値は以下のようであること:

          (KEYWORDS [KEYWORDS-ONLY [CASE-FOLD
           [SYNTAX-ALIST [SYNTAX-BEGIN OTHER-VARS...]]]])

     1つ目の要素KEYWORDSは、検索ベースのフォント表示を制御する
     ‘font-lock-keywords’の値を、間接的に指定する。値にはシンボル、変数
     、または‘font-lock-keywords’にたいして使用するリストが値であるよう
     な関数を指定できる。また、それぞれのシンボルがフォント表示の可能な
     レベルであるような、いくつかのシンボルからなるリストも指定できる。
     この場合、1つ目のシンボルはフォント表示の‘モードデフォルト(mode
     default)’レベル、次のシンボルはフォント表示のレベル1、その次はレベ
     ル2、のようになる。通常、‘モードデフォルト’レベルはレベル1と等しい
     。これは、‘font-lock-maximum-decoration’が‘nil’値をもつとき使用され
     る。*note Levels of Font Lock::を参照のこと。

     2つ目の要素KEYWORDS-ONLYは、変数‘font-lock-keywords-only’の値を指定
     する。これが省略、または‘nil’の場合は、(文字列とコメントの)構文的フ
     ォント表示も行われる。非‘nil’の場合は、構文的フォント表示は行われな
     い。*note Syntactic Font Lock::を参照のこと。

     3つ目の要素CASE-FOLDは、‘font-lock-keywords-case-fold-search’の値を
     指定する。非‘nil’の場合、検索ベースフォント表示の間、Font Lockモー
     ドは大文字小文字の違いを無視する。

     4つ目の要素SYNTAX-ALISTが非‘nil’の場合、それは‘(CHAR-OR-STRING .
     STRING)’という形式のコンスセルのリストであること。これらは、構文的
     フォント表示にたいする構文テーブルのセットアップに使用される。結果
     となる構文テーブルは、‘font-lock-syntax-table’に格納される。
     SYNTAX-ALISTが省略、または‘nil’の場合、構文的フォント表示は
     ‘syntax-table’関数によりリターンされる構文テーブルを使用する。*note
     Syntax Table Functions::を参照のこと。

     5つ目の要素SYNTAX-BEGINは、
     ‘font-lock-beginning-of-syntax-function’の値を指定する。この変数は
     ‘nil’にセットして、かわりに‘syntax-begin-function’の使用を推奨する
     。

     (もしあれば)残りすべての要素は、まとめてOTHER-VARSと呼ばれる。これ
     らの要素はすべて、‘(VARIABLE . VALUE)’という形式をもつべきである。
     これは、VARIABLEをバッファーローカルにしてから、それにVALUEをセット
     することを意味する。これらOTHER-VARSを使用して、最初の5つの要素によ
     る制御とは別に、フォント表示に影響する他の変数をセットできる。*note
     Other Font Lock Variables::を参照のこと。

   モードが‘font-lock-face’プロパティ追加により明示的にテキストをフォン
ト表示する場合は、自動的なフォント表示すべてをオフにするために、
‘font-lock-defaults’に‘(nil t)’を指定できます。しかし、これは必須ではあ
りません。‘font-lock-face’を使用して何かをフォント表示して、それ以外の部
分のテキストを自動的にフォント表示するようにセットアップするのは可能です
。


File: elisp,  Node: Search-based Fontification,  Next: Customizing Keywords,  Prev: Font Lock Basics,  Up: Font Lock Mode

22.6.2 Search-based Fontification
---------------------------------

検索ベースフォント表示を直接制御する変数は、‘font-lock-keywords’です。こ
の変数は通常、‘font-lock-defaults’内の要素KEYWORDSを通じて指定されます。

 -- Variable: font-lock-keywords
     この変数の値は、ハイライトするキーワードのリストである。Lispプログ
     ラムは、この変数を直接セッすべきでない。通常は、
     ‘font-lock-defaults’内の要素KEYWORDSを使用して、Font Lockモードが自
     動的に値をセットする。この値は、関数‘font-lock-add-keywords’および
     ‘font-lock-remove-keywords’を使用して、変更されることもあり得る
     (*note Customizing Keywords::を参照)。

   ‘font-lock-keywords’の各要素は、特定のケースに該当するテキストを見つ
ける方法、およびそれらをハイライトする方法を指定します。Font Lockモード
は、‘font-lock-keywords’の要素をちくじ処理してマッチを探して、すべてのマ
ッチを処理します。通常は、テキストの一部はすでに一度はフォント表示されて
おり、同じテキスト内で連続するマッチによるこれをオーバーライドはできませ
ん。しかし、SUBEXP-HIGHLIGHTERの要素OVERRIDEを使用して、異なる挙動を指定
できます。

   ‘font-lock-keywords’の各要素は、以下の形式のいずれかをもつべきです:

‘REGEXP’
     ‘font-lock-keyword-face’を使用して、REGEXPにたいするすべてのマッチ
     をハイライトする。たとえば、

          ;; ‘font-lock-keyword-face’を使用して
          ;; 単語‘foo’をハイライトする
          "\\<foo\\>"

     これらの正規表現を作成するときは、慎重に行うこと。下手に記述された
     パターンにより、スピードが劇的に低下し得る! 関数‘regexp-opt’(*note
     Regexp Functions::を参照)は、いくつかのキーワードとマッチするために
     最適な正規表現の計算に有用である。

‘FUNCTION’
     FUNCTIONを呼び出すことによりテキストを探し、
     ‘font-lock-keyword-face’を使用して見つかったマッチをハイライトする
     。

     FUNCTIONは、呼び出される際に1つの引数(検索のリミット)を受け取る。検
     索はポイント位置から開始し、そのリミットを超えた検索は行うべきでは
     ない。これは、検索が成功した場合は非‘nil’をリターンして、見つかった
     マッチを表すマッチデータをセットすべきである。‘nil’のリターンは、検
     索の失敗を示す。

     フォント表示は、前の呼び出しでポイントが残された位置から、同じリミ
     ットを用いてFUNCTIONを呼び出し、FUNCTIONが失敗するまでFUNCTIONを繰
     り返し呼び出すだろう。検索が失敗しても、何らかの特別な方法により、
     FUNCTIONがポイントをリセットする必要はない。

‘(MATCHER . SUBEXP)’
     この種の要素では、MATCHERは上述のregexpかfunctionのいずれかである。
     CDRのSUBEXPは、(MATCHERがマッチするテキスト全体のかわりに)MATCHERの
     どの部分式(subexpression)がハイライトされるべきかを指定する。

          ;; ‘font-lock-keyword-face’Hを使用して
          ;; ‘bar’が‘fubar’の一部のときに
          ;; ハイライトする
          ("fu\\(bar\\)" . 1)

     正規表現MATCHERの生成に‘regexp-opt’を使用する場合は、SUBEXPにたいす
     る値の計算に‘regexp-opt-depth’(*note Regexp Functions::を参照)を使
     用できる。

‘(MATCHER . FACESPEC)’
     この種の要素では、FACESPECの値がハイライトに使用するフェイスを指定
     する。もっともシンプルな例では、FACESPECは値がフェイス名であるよう
     なはLisp変数(シンボル)である。

          ;; ‘fubar-face’の値のフェイスを使用して
          ;; ‘fubar’をハイライトする
          ("fubar" . fubar-face)

     しかし、FACESPECは以下のような形式のリストに評価されてもよい:

          (face FACE PROP1 VAL1 PROP2 VAL2...)

     これは、マッチしたテキストにフェイスFACEを指定し、さまざまなテキス
     トプロパティをputする。これを行う場合は、この方法により
     ‘font-lock-extra-managed-props’に値をセットする、他のテキストプロパ
     ティ名を確実に追加すること。そうすれば、それらのプロパティが妥当性
     を失ったとき、それらのプロパティもクリアーされるだろう。これらのプ
     ロパティをクリアーする関数を、変数
     ‘font-lock-unfontify-region-function’にセットすることもできる。
     *note Other Font Lock Variables::を参照のこと。

‘(MATCHER . SUBEXP-HIGHLIGHTER)’
     この種の要素では、SUBEXP-HIGHLIGHTERはMATCHERにより見つかったマッチ
     をハイライトする方法を指定するリストである。これは、以下の形式をも
     つ。

          (SUBEXP FACESPEC [OVERRIDE [LAXMATCH]])

     CARのSUBEXPは、マッチのどの部分式をフォント表示するかを指定する整数
     である(0はマッチしたテキスト全体を意味する)。これの2つ目の要素
     FACESPECは、上述したような値がフェイスを指定するような式である。

     SUBEXP-HIGHLIGHTER内の残りの値OVERRIDEとLAXMATCHは、オプションのフ
     ラグである。OVERRIDEが‘t’の場合、この要素は前の
     ‘font-lock-keywords’の要素により作成された既存のフォント表示をオー
     バーライドできる。値が‘keep’の場合は、すでに他の要素によりフォント
     表示されていない文字がフォント表示される。値が‘prepend’の場合は、
     FACESPECにより指定されたフェイスが、‘font-lock-face’プロパティの先
     頭に追加される。値が‘append’の場合は、そのフェイスが
     ‘font-lock-face’プロパティの最後に追加される。

     LAXMATCHが非‘nil’の場合、それはMATCHER内で番号付けされた部分式
     SUBEXPが存在しなくても、エラーにならないことを意味する。当然、番号
     付けされた部分式SUBEXPのフォント表示は発生しない。しかし、他の部分
     式(と他のregexp)のフォント表示は継続されるだろう。LAXMATCHが‘nil’で
     、指定された部分式が存在しない場合は、エラーがシグナルされて検索ベ
     ースのフォント表示は終了する。

     以下はこのタイプの要素と、それが何を行うかの例である:

          ;; ‘foo-bar-face’を使用して、たとえハイライト済みでも
          ;; ‘foo’と‘bar’をハイライトする
          ;; ‘foo-bar-face’は値がフェイスであるような変数であること
          ("foo\\|bar" 0 foo-bar-face t)

          ;; ‘fubar-face’の値のフェイスを使用して
          ;; 関数‘fubar-match’が見つけた各マッチの
          ;; 最初の部分式をハイライトする
          (fubar-match 1 fubar-face)

‘(MATCHER . ANCHORED-HIGHLIGHTER)’
     この種の要素では、ANCHORED-HIGHLIGHTERはMATCHERが見つけたマッチに後
     続するテキストをハイライトする方法を指定する。つまり、MATCHERが見つ
     けたマッチは、ANCHORED-HIGHLIGHTERにより指定されるその先の検索にた
     いする、アンカー(anchor)として機能する。ANCHORED-HIGHLIGHTERは、以
     下の形式のリストである:

          (ANCHORED-MATCHER PRE-FORM POST-FORM
                                  SUBEXP-HIGHLIGHTERS...)

     ここで、ANCHORED-MATCHERはMATCHERと同様、正規表現か関数である。
     MATCHERにたいするマッチを見つけた後に、ポイントはそのマッチの終端に
     移動する。そこで、Font LockはフォームPRE-FORMを評価する。それから
     ANCHORED-MATCHERにたいするマッチを検索し、SUBEXP-HIGHLIGHTERSを使用
     して、それらのマッチをハイライトする。SUBEXP-HIGHLIGHTERについては
     上記を参照のこと。最後にFont LockはPOST-FORMを評価する。

     フォームPRE-FORMおよびPOST-FORMは、ANCHORED-MATCHER使用時の事前の初
     期化、事後のクリーンアップに使用され得る。通常、PRE-FORMは
     ANCHORED-MATCHERを開始する前に、MATCHERのマッチに関連する何らかの位
     置にポイントを移動するために使用される。POST-FORMは、MATCHERを再開
     する前に、ポイントを戻すために使用されるかもしれない。

     PRE-FORMを評価した後、Font Lockはその行の終端の先にたいして、
     ANCHORED-MATCHERの検索を行わない。しかし、PRE-FORMがPRE-FORM評価後
     のポイント位置より大きいバッファー位置をリターンした場合には、かわ
     りにPRE-FORMによりリターンされた位置が検索リミットとして使用される
     。一般的に、その行の終端より大きい位置をリターンするのは、よいアイ
     デアではない。別の言い方をすると、ANCHORED-MATCHER検索は複数行にわ
     たる(span lines)べきではないと言えよう。

     たとえば、

          ;; ‘item-face’の値を使用して
          ;; 単語‘anchor’に(同一行内で)
          ;; 後続する単語‘item’をハイライトする
          ("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))

     ここで、PRE-FORMとPOST-FORMは‘nil’である。したがって、‘item’にたい
     する検索は‘anchor’にたいするマッチの終端から開始され、後続する
     ‘anchor’インスタンスにたいする検索は、‘item’にたいする検索が終了し
     た位置から再開される。

‘(MATCHER HIGHLIGHTERS...)’
     この種の要素は、単一のMATCHERにたいして、複数のHIGHLIGHTERリストを
     指定する。HIGHLIGHTERリストには、上述したSUBEXP-HIGHLIGHTER、または
     ANCHORED-HIGHLIGHTERのいずれかを指定できる。

     たとえば、

          ;; ‘anchor-face’の値内に現れる単語‘anchor’、
          ;; および、(同じ行の)後続の‘item-face’の
          ;;  値内に現れる単語‘item’をハイライトする
          ("\\<anchor\\>" (0 anchor-face)
                          ("\\<item\\>" nil nil (0 item-face)))

‘(eval . FORM)’
     ここでFORMは、バッファー内でこの‘font-lock-keywords’の値が最初に使
     用されるときに評価される式である。この値は、上述のこのテーブルで説
     明した、いずれかの形式をもつべきである。

   *警告:* 複数行にわたるテキストにたいするマッチさせるために、
‘font-lock-keywords’の要素をデザインしてはならない。これは確実に機能する
とは言えない。詳細は、*note Multiline Font Lock::を参照のこと。

   検索ベースのフォント表示が大文字小文字を区別すべきかどうかを告げる
‘font-lock-keywords-case-fold-search’の値を指定するために、
‘font-lock-defaults’内でCASE-FOLDを使用できる。

 -- Variable: font-lock-keywords-case-fold-search
     非‘nil’は、‘font-lock-keywords’のための正規表現マッチングが、大文字
     小文字を区別すべきではないことを意味する。


File: elisp,  Node: Customizing Keywords,  Next: Other Font Lock Variables,  Prev: Search-based Fontification,  Up: Font Lock Mode

22.6.3 Customizing Search-Based Fontification
---------------------------------------------

メジャーモードにたいして検索ベースフォント表示ルールを追加するために
‘font-lock-add-keywords’、削除には‘font-lock-remove-keywords’を使用する
ことができます。

 -- Function: font-lock-add-keywords mode keywords &optional how
     この関数は、カレントバッファー、またはメジャーモードMODEにたいして
     、ハイライトするKEYWORDSを追加する。引数KEYWORDSは、変数
     ‘font-lock-keywords’と同じ形式のリストであること。

     MODEが、‘c-mode’のような、あるメジャーモードのコマンド名であるよう
     なシンボルの場合には、そのMODE内でFont Lockモードを有効にすることに
     より、KEYWORDSが‘font-lock-keywords’に追加される効果がある。非
     ‘nil’値のMODEによる呼び出しは、‘~/.emacs’ファイル内でのみ正しい。

     MODEが‘nil’の場合、この関数はカレントバッファーの
     ‘font-lock-keywords’にKEYWORDSを追加する。この方法での
     ‘font-lock-add-keywords’呼び出しは、通常はモードフック関数内で使用
     される。

     デフォルトでは、KEYWORDSは‘font-lock-keywords’の先頭に追加される。
     オプション引数HOWが‘set’の場合、それらは‘font-lock-keywords’の値の
     置換に使用される。HOWがそれ以外の非‘nil’値の場合、これらは
     ‘font-lock-keywords’の最後に追加される。

     追加のハイライトパターンの使用を可能にする、特別なサポートを提供す
     るモードがいくつかある。それらの例については、変数
     ‘c-font-lock-extra-types’、‘c++-font-lock-extra-types’、
     ‘java-font-lock-extra-types’を参照のこと。

     *警告:* メジャーモードコマンドは、モードフックを除き、いかなる状況
     においても、直接間接を問わず‘font-lock-add-keywords’を呼び出しては
     ならない(これを行うと、いくつかのマイナーモードは不正な振る舞いを起
     こしかねない)。メジャーモードコマンドは、‘font-lock-keywords’をセッ
     トすることにより、検索ベースフォント表示のルールをセットアップすべ
     きである。

 -- Function: font-lock-remove-keywords mode keywords
     この関数は、カレントバッファー、またはメジャーモードMODEにたいして
     、‘font-lock-keywords’からKEYWORDSを削除する。
     ‘font-lock-add-keywords’の場合と同様、MODEはメジャーモードコマンド
     名か‘nil’であること。‘font-lock-add-keywords’にたいするすべての制約
     と条件は、この関数にも適用される。

   たとえば、以下はCモードに2つのフォント表示パターンを追加するコードの
例である。フォント表示の1つは、たとえコメント内であろうとも単語‘FIXME’を
フォント表示し、もう1つは‘and’、‘or’、‘not’をキーワードとしてフォント表
示する。

     (font-lock-add-keywords 'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
        ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))

この例は、正にCモードだけに効果がある。Cモード、_および_その派生モードに
たいして同じパターンを追加するには、かわりに以下を行う:

     (add-hook 'c-mode-hook
      (lambda ()
       (font-lock-add-keywords nil
        '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
          ("\\<\\(and\\|or\\|not\\)\\>" .
           font-lock-keyword-face)))))


File: elisp,  Node: Other Font Lock Variables,  Next: Levels of Font Lock,  Prev: Customizing Keywords,  Up: Font Lock Mode

22.6.4 Other Font Lock Variables
--------------------------------

このセクションでは、‘font-lock-defaults’内のOTHER-VARSを用いて、メジャー
モードがセットできる追加の変数について説明します(*note Font Lock
Basics::を参照)。

 -- Variable: font-lock-mark-block-function
     この変数が非‘nil’の場合、それはコマンド‘M-o
     M-o’(‘font-lock-fontify-block’)で再フォント表示するテキスト範囲を選
     択するために、引数なしで呼び出される関数であること。

     この関数は、結果を報告するために、選択されたテキスト範囲にリージョ
     ンを配すべきである。正しい結果を与えるのに十分、かつ再フォント表示
     が低速にならない程度のテキスト範囲を選択するのがよい。プログラミン
     グのモードにたいしては‘mark-defun’、テキストを扱うモードにたいして
     は‘mark-paragraph’が典型的な値である。

 -- Variable: font-lock-extra-managed-props
     この変数は、(‘font-lock-face’以外の)Font Lockにより管理される追加プ
     ロパティを指定する。これらの追加プロパティは、通常は
     ‘font-lock-face’プロパティだけを管理する、
     ‘font-lock-default-unfontify-region’により使用される。他のプロパテ
     ィも同様にFont Lockに管理させたい場合は、このリストに追加するのと同
     じように、‘font-lock-keywords’内のFACESPEC内でもこれらを指定しなけ
     ればならない。*note Search-based Fontification::を参照のこと。

 -- Variable: font-lock-fontify-buffer-function
     そのバッファーをフォント表示するために使用する関数。デフォルト値は
     ‘font-lock-default-fontify-buffer’。

 -- Variable: font-lock-unfontify-buffer-function
     そのバッファーを非フォント表示するために使用する関数。デフォルト値
     は‘font-lock-default-unfontify-buffer’。

 -- Variable: font-lock-fontify-region-function
     リージョンをフォント表示するための関数。この関数は、リージョンの開
     始と終了の2つを引数にとり、オプションで3つ目の引数VERBOSEをとるべき
     である。VERBOSEが非‘nil’の場合、その関数はステータスメッセージをプ
     リントすべきである。デフォルト値は
     ‘font-lock-default-fontify-region’。

 -- Variable: font-lock-unfontify-region-function
     リージョンを非フォント表示するための関数。この関数は、リージョンの
     開始と終了の2つを引数にとるべきである。デフォルト値は
     ‘font-lock-default-unfontify-region’。

 -- Function: jit-lock-register function &optional contextual
     この関数は、カレントバッファーの一部をフォント表示/非表示する必要が
     ある任意のタイミングで、Font LockモードがLisp関数FUNCTIONを実行する
     ことを宣言する。これは、デフォルトのフォント表示関数が呼び出される
     前に、フォント表示/非表示するリージョンを指定する2つの引数STARTと
     ENDでFUNCTIONを呼び出す。

     オプション引数CONTEXTUALが非‘nil’の場合は、行が更新されたときに限ら
     ず、そのバッファーの構文的に関連する部分を常にフォント表示するよう
     、Font Lockモードに強制する。この引数は、通常は省略できる。

 -- Function: jit-lock-unregister function
     以前に‘jit-lock-register’を使用して、フォント表示関数として
     FUNCTIONを登録した場合は、その関数を未登録にする。


File: elisp,  Node: Levels of Font Lock,  Next: Precalculated Fontification,  Prev: Other Font Lock Variables,  Up: Font Lock Mode

22.6.5 Levels of Font Lock
--------------------------

フォント表示にたいして3つの異なるレベルを提供するモードが、いくつかあり
ます。‘font-lock-defaults’内のKEYWORDSにたいしてシンボルのリストを使用す
ることにより、複数のレベルを定義できます。このリストのシンボルはそれぞれ
、フォント表示の1レベルを指定します。これらのレベルの選択は、通常は
‘font-lock-maximum-decoration’をセットすることにより、ユーザーの責任で行
われます(*note (emacs)Font Lock::を参照)。選択されたレベルのシンボルの値
は、‘font-lock-keywords’の初期化に使用されます。

   フォント表示レベルの定義方法に関する慣習を以下に挙げます:

   • レベル1: 関数宣言、(includeやimportのような)ファイルディレクティブ
     、文字列、コメントをハイライトする。これは、もっとも重要かつトップ
     レベルのコンポーネントだけをフォント表示すれば高速になるという発想
     である。

   • レベル2: レベル1に加えて、すべての言語のキーワード(キーワードと同様
     に作用する型名を含む)、および名前付き定数値をハイライトする。これは
     、(構文的、または意味的な)すべてのキーワードは適切にフォント表示さ
     れるべきという発想である。

   • レベル3: レベル2に加えて、関数内で定義されるシンボル、変数宣言、お
     よびすべてのビルトイン関数名にたいして、それがどこに出現しようとハ
     イライトする。


File: elisp,  Node: Precalculated Fontification,  Next: Faces for Font Lock,  Prev: Levels of Font Lock,  Up: Font Lock Mode

22.6.6 Precalculated Fontification
----------------------------------

‘list-buffers’や‘occur’のようないくつかのメジャーモードは、バッファーの
テキストをプログラム的に構築します。これらにたいしてFont Lockモードをサ
ポートするには、そのバッファーにテキストを挿入するタイミングで、テキスト
のフェイスを指定するのが、もっとも簡単な方法です。

   これは、スペシャルテキストプロパティ‘font-lock-face’(*note Special
Properties::を参照)により、テキスト内にフェイスを指定することにより行わ
れます。Font Lockモードが有効になったとき、このプロパティは‘face’と同じ
ように、表示を制御します。Font Lockモードが無効になると、
‘font-lock-face’は表示に効果をもちません。

   モードが、通常のFont Lockメカニズムとともに、あるテキストにたいして
‘font-lock-face’を使用しても問題はありません。しかし、そのモードが通常の
Font Lockメカニズムを使用しない場合は、変数‘font-lock-face’をセットする
べきではありません。


File: elisp,  Node: Faces for Font Lock,  Next: Syntactic Font Lock,  Prev: Precalculated Fontification,  Up: Font Lock Mode

22.6.7 Faces for Font Lock
--------------------------

Font Lockモードは、ハイライトに任意のフェイスを使用できますが、Emacsは、
特にFontLockがテキストのハイライトに使用するいくつかのフェイスを定義して
います。これらの“Font Lockフェイス(Font Lock faces)”を、以下にリストしま
す。これらのフェイスは、FontLockモードの外部における構文的なハイライトで
メジャーモードが使用することもできます(*note Major Mode Conventions::を
参照)。

   以下の各シンボルは、フェイス名であり、かつデフォルト値がシンボル自身
であるような変数でもあります。つまり、‘font-lock-comment-face’のデフォル
ト値は‘font-lock-comment-face’です。

   リストは、そのフェイスの典型的な使い方の説明とともに、“重要性”が大き
い順にソートされています。あるモードの構文的カテゴリーが、以下の使い方の
説明にうまく適合しない場合、この並び順をガイドとして使用することにより、
フェイスを割り当てることができるでしょう。

‘font-lock-warning-face’
     Emacs Lispの‘;;;###autoload’、Cの‘#error’のような、特有な構文、また
     はその他のテキスト意味を大きく変更する構文にたいして使用される。

‘font-lock-function-name-face’
     定義、または宣言される関数の名前にたいして使用される。

‘font-lock-variable-name-face’
     定義、または宣言される変数の名前にたいして使用される。

‘font-lock-keyword-face’
     Cの‘for’や‘if’のように、特別な構文的意味をもつキーワードにたいして
     使用される。

‘font-lock-comment-face’
     コメントにたいして使用される。

‘font-lock-comment-delimiter-face’
     Cの‘/*’と‘*/’のような、コメント区切りにたいして使用される。ほとんど
     の端末では、このフェイスは‘font-lock-comment-face’を継承する。

‘font-lock-type-face’
     ユーザー定義データ型にたいして使用される。

‘font-lock-constant-face’
     Cの‘NULL’のような、定数の名前にたいして使用される。

‘font-lock-builtin-face’
     ビルトイン関数の名前にたいして使用される。

‘font-lock-preprocessor-face’
     プロセッサーコマンドにたいして使用される。デフォルトでは、
     ‘font-lock-builtin-face’を継承する。

‘font-lock-string-face’
     文字列定数にたいして使用される。

‘font-lock-doc-face’
     コード内のドキュメント文字列にたいして使用される。デフォルトでは、
     ‘font-lock-string-face’を継承する。

‘font-lock-negation-char-face’
     見逃されやすい否定文字にたいして使用される。


File: elisp,  Node: Syntactic Font Lock,  Next: Multiline Font Lock,  Prev: Faces for Font Lock,  Up: Font Lock Mode

22.6.8 Syntactic Font Lock
--------------------------

構文的フォント表示(syntactic fontification)は、構文的に関連性のあるテキ
ストを探してハイライトするために、構文テーブル(syntax table: *note
Syntax Tables::を参照)を使用します。有効な場合は、検索ベースフォント表示
に先立ち実行されます。以下で説明する変数
‘font-lock-syntactic-face-function’,は、どの構文的構造をハイライトするか
を決定します。構文的フォント表示に影響を与える変数が、いくつかあります。
‘font-lock-defaults’のために、それらをセットするべきです(*note Font Lock
Basics::を参照)。

   Font Lockモードが一連のテキストにたいして構文的フォント表示を処理する
ときは、常に‘syntax-propertize-function’で指定される関数を最初に呼び出し
ます。メジャーモードは、特別なケースでは‘syntax-table’テキストプロパティ
を適用してバッファーの構文テーブルをオーバーライドするために、これを使用
することができます。*note Syntax Properties::を参照してください。

 -- Variable: font-lock-keywords-only
     この変数の値が非‘nil’の場合、Font Lockは構文的フォント表示を行わず
     、‘font-lock-keywords’にもとづく検索ベースフォント表示だけを行う。
     これは通常、‘font-lock-defaults’内のKEYWORDS-ONLY要素にもとづき、
     Font Lockモードによりセットされる。

 -- Variable: font-lock-syntax-table
     この変数は、コメントと文字列のフォント表示に使用するための構文テー
     ブルを保持する。これは通常、‘font-lock-defaults’内のSYNTAX-ALIST要
     素にもとづき、Font Lockモードによりセットされる。この値が‘nil’の場
     合、構文的フォント表示は、バッファーの構文テーブル(関数
     ‘syntax-table’がリターンする構文テーブル。*note Syntax Table
     Functions::を参照)を使用する。

 -- Variable: font-lock-beginning-of-syntax-function
     この変数が非‘nil’の場合、それは構文的に“トップレベル”で、かつ文字列
     やコメントの外部であるような位置に戻すようにポイントを移動する関数
     であること。この値は通常、‘font-lock-defaults’内のOTHER-VARS要素を
     通じてセットされる。これが‘nil’の場合、Font Lockはコメント、文字列
     、sexpの外部に戻って移動するために‘syntax-begin-function’を使用する
     (*note Position Parse::を参照)。

     この変数は、半ば時代遅れであり、通常はかわりに
     ‘syntax-begin-function’をセットすることを推奨する。これの用途の1つ
     は、たとえば異なる種類の文字列やコメントを異なるようにハイライトす
     る等、構文的フォント表示の振る舞いの調整する場合である。

     指定された関数は、引数なしで呼び出される。この関数は、周囲の構文的
     ブロックの先頭にポイントを残すべきである。典型的な値は
     ‘beginning-of-line’(行頭が構文的ブロック外部であることが既知の場合
     に使用)、プログラミングのモードにたいしては‘beginning-of-defun’、テ
     キストを扱うモードにたいしては‘backward-paragraph’が使用される。

 -- Variable: font-lock-syntactic-face-function
     この変数が非‘nil’の場合、それは与えられた構文的要素にどのフェイスを
     使用するかを決定する関数であること。この値は通常、
     ‘font-lock-defaults’内のOTHER-VARS要素を通じてセットされる。

     この関数は1つの引数で呼び出され、‘parse-partial-sexp’がリターンする
     ポイントの状態をパースして、フェイスをリターンすべきである。コメン
     トにたいしては‘font-lock-comment-face’、文字列にたいしては
     ‘font-lock-string-face’が、リターンされるデフォルト値である(*note
     Faces for Font Lock::を参照)。


File: elisp,  Node: Multiline Font Lock,  Prev: Syntactic Font Lock,  Up: Font Lock Mode

22.6.9 Multiline Font Lock Constructs
-------------------------------------

通常は、‘font-lock-keywords’の要素は複数行にわたるマッチを行うべきではあ
りません。それらの動作に信頼性はありません。なぜなら、Font Lockは通常は
バッファーのごく一部をスキャンするので、そのスキャンが開始される行境界を
またがる複数行構造を見逃しかねないからです(スキャンは通常、行頭から開始
される)。

   ある要素にたいして、複数行構造にたいするマッチを正しく機能させるには
、2つの観点があります。それは_識別(identification)_の補正と、_再ハイライ
ト(rehighlighting)_の補正です。1つ目は、Font Lockがすべての複数行構造を
探すことを意味します。2つ目は、複数行構造が変更されたとき、たとえば以前
は複数行構造の一部だったテキストが、複数行構造から除外されたときに、関連
するすべてのテキストをFont Lockに正しく再ハイライトさせることを意味しま
す。これら2つの観点は密接に関連しており、一方を機能させることがもう一方
を機能させるようなことが多々あります。しかし、信頼性のある結果を得るため
には、これら2つの観点双方にたいして、明示的に注意しなければなりません。

   複数行構造の識別を確実に補正するには、3つの方法があります:

   • スキャンされるテキストが複数行構造の途中で開始、または終了すること
     がないように_識別_を行いスキャンを拡張する関数を、
     ‘font-lock-extend-region-functions’に追加する。
   • 同様に、スキャンされるテキストが複数行構造の途中で開始、または終了
     することがないようスキャンを拡張するために、
     ‘font-lock-fontify-region-function’フックを使用する。
   • 複数行構造がバッファーに挿入されたとき(または挿入後、Font Lockがハ
     イライトを試みる前の任意のタイミングで)、何らかの方法によりそれを正
     しく認識して、Font Lockが複数行構造の途中で開始、または終了しないよ
     う指示する‘font-lock-multiline’でそれをマークする。

   複数行構造の再ハイライトを行うには、3つの方法があります:

   • その構造にたいして、正しく‘font-lock-multiline’を配する。これにより
     、その構造の一部が変更された場合は、構造全体が再ハイライトされるだ
     ろう。あるケースにおいては、それを参照する‘font-lock-multiline’変数
     をセットすることにより、これを自動的に行うことができる。
   • ‘jit-lock-contextually’を確実にセットして、それが行う処理に委ねる。
     これにより、実際の変更に続いて構造の一部だけが、若干の遅延の後に再
     ハイライトされるだろう。これは、複数行構造のさまざまな箇所のハイラ
     イトが、後続行のテキストに依存しない場合のみ機能する。
     ‘jit-lock-contextually’はデフォルトでアクティブなので、これは魅力的
     な解決策になり得る。
   • その構造上に、正しく‘jit-lock-defer-multiline’を配する。これは、
     ‘jit-lock-contextually’が使用された場合のみ機能し、再ハイライト前に
     同様の遅延を伴うが、‘font-lock-multiline’のように後続行に依存する箇
     所のハイライトも処理する。

* Menu:

* Font Lock Multiline::      テキストプロパティで複数行塊をマークする。
* Region to Refontify::      バッファー変更後にどのリージョンを再フォント表示するかを制御する。


File: elisp,  Node: Font Lock Multiline,  Next: Region to Refontify,  Up: Multiline Font Lock

22.6.9.1 Font Lock Multiline
............................

複数行構造のFont Lockを確実に再ハイライトする方法の1つは、それらをテキス
トプロパティ‘font-lock-multiline’にputする方法です。複数行構造の一部であ
るようなテキストにたいしては、このプロパティが存在し、値が非‘nil’である
べきです。

   Font Lockがテキスト範囲をハイライトしようとする際は、それらが
‘font-lock-multiline’プロパティでマークされたテキストにならないように、
まず必要に応じて範囲の境界を拡張します。それから、その範囲のすべての
‘font-lock-multiline’を削除して、ハイライトします。ハイライト指定(大抵は
‘font-lock-keywords’)は、適宜このプロパティを毎回再インストールしなけれ
ばなりません。

   *警告:* ハイライトが低速になるので、大きなテキスト範囲にたいして
‘font-lock-multiline’を使用してはならない。

 -- Variable: font-lock-multiline
     ‘font-lock-multiline’変数が‘t’にセットされている場合、Font Lockは自
     動的に複数行構造にたいして‘font-lock-multiline’プロパティの追加を試
     みる。しかし、これによりFont Lockが幾分遅くなるので、普遍的解ではな
     い。これは、何らかの複数行構造を見逃したり、必要なものより多く、ま
     たは少なくプロパティをセットするかもしれない。

     MATCHERが関数であるような要素は、たとえ少量のサブパート(subpart)だ
     けがハイライトされるような場合でも、submatch 0(訳注:正規表現の後方
     参照においてsubmatch 0はマッチした文字列全体を指す)が関連する複数行
     構造全体を確実に網羅するようにすべきである。単に手動で
     ‘font-lock-multiline’を追加するのが容易な場合も多々ある。

   ‘font-lock-multiline’プロパティは、正しい再フォント表示を確実に行うこ
とを意図しています。これは、新たな複数行構造を自動的に認識しません。Font
Lockの処理を要するものにたいする認識は、一度に処理を行うのに十分な大きさ
のchunkにたいして行われます。これは多くの場合にアクシデントにより発生し
得るかもしれないので、複数行構造が不可解に機能するような印象を与えるかも
しれません。変数‘font-lock-multiline’を非‘nil’にセットした場合、発見され
たこれらの構造にたいするハイライトは、変数をセットした後は正しく更新され
るので、さらにこの印象が強くなるでしょう。しかし、これは信頼性をもって機
能しません。

   信頼性を保ち複数行構造を見つけるためには、Font Lockが調べる前にテキス
トの‘font-lock-multiline’プロパティを手動で配すか、
‘font-lock-fontify-region-function’を使用しなければなりません。


File: elisp,  Node: Region to Refontify,  Prev: Font Lock Multiline,  Up: Multiline Font Lock

22.6.9.2 Region to Fontify after a Buffer Change
................................................

バッファーが変更されたとき、Font Lockが再フォント表示するリージョンは、
デフォルトではその変更に関連する、最小の行全体からなるシーケンスです。こ
れはほとんどの場合は良好に機能しますが、うまく機能しないとき(たとえば、
その変更がそれより前の行のテキストの構文的な意味を変更してしまうとき)も
あります。

   以下の変数をセットすることにより、再フォント表示するリージョンを拡張
(または縮小さえ)することができます:

 -- Variable: font-lock-extend-after-change-region-function
     このバッファーローカル変数は‘nil’、またはFont Lockモードにたいして
     スキャンしてフォント表示すべきリージョンを決定するために呼び出され
     る関数である。

     この関数には、標準的なBEGとEND、および‘after-change-functions’の
     OLD-LEN(*note Change Hooks::を参照)という、3つのパラメーターが渡さ
     れる。この関数はフォント表示するリージョンのバッファー位置の開始と
     終了(この順で)からなるコンスセル、または‘nil’(標準的な方法でリージ
     ョンを選択することを意味する)のいずれかをリターンすべきである。この
     関数は、ポイント位置、match-data、カレントのナローイングを保つ必要
     がある。これがリターンするリージョンは、行の途中で開始、または終了
     するかもしれない。

     この関数はバッファーを変更するたびに呼び出されるので、有意に高速で
     あること。


File: elisp,  Node: Auto-Indentation,  Next: Desktop Save Mode,  Prev: Font Lock Mode,  Up: Modes

22.7 Automatic Indentation of code
==================================

プログラミング言語のメジャーモードにとって、自動的なインデントの提供は、
重要な機能です。これには2つのパートがあります。1つ目は正しい行のインデン
トが何か、そして2つ目はいつ行を再インデントするかの判断です。デフォルト
では、‘electric-indent-chars’に含まれる文字(デフォルトでは改行のみ)をタ
イプしたとき、Emacsは常に行を再インデントします。メジャーモードは、その
言語の構文に合わせて、‘electric-indent-chars’に文字を追加できます。

   正しいインデントの決定は、‘indent-line-function’によりEmacs内で制御さ
れます(*note Mode-Specific Indent::を参照)。いくつかのモードでは、_右_へ
のインデントは信頼性がないことが知られています。これは通常、複数のインデ
ントが有効だが、それぞれが異なる意味をもつので、インデント自体が重要だか
らです。そのような場合、そのモードは行が常にユーザーの望み通り再インデン
トされないことを念押しするために、‘electric-indent-inhibit’をセットする
べきです。

   よいインデント関数の記述は難しく、その広範な領域において、未だ黒魔術
の域を脱していません。メジャーモード作者の多くは、単純なケース(たとえば
前のテキスト行のインデントとの比較)にたいして機能する、単純な関数の記述
からスタートすることでしょう。実際には行ベースではないほとんどのプログラ
ミング言語にたいして、これは貧弱なスケールになりがちです。そのような関数
にたいして、より多様な状況を処理するような改良を行うと、関数はより一層複
雑になり、最終的な結果は誰にも触れようとする気を起こさせない、巨大で複雑
な保守不可能のインデント関数になる傾向があります。

   よいインデント関数は通常、その言語の構文に応じて、実際にテキストをパ
ースする必要があるでしょう。幸運なことに、このテキストパースはコンパイラ
ーが要するほど詳細である必要はないでしょうが、その一方でインデントコード
に埋め込まれたパーサーは、構文的に不正なコードにたいして、コンパイラーよ
り幾分寛容な振る舞いを求められるでしょう。

   保守可能なよいインデント関数は、通常2つのカテゴリーに落ち着きます。ど
ちらも何らかの“安全”な開始ポイントから、関心のある位置まで前方にパースを
行うか、あるいは後方へパースを行います。この2つの方法は、どちらも一方が
他方に明快に優る選択ではありません。後方へのパースは、プログラミング言語
が前方にパースされるようデザインされているため、前方へのパースに比べて難
しいことが多々ありますが、インデントという目的においては“安全”な開始ポイ
ントを推測する必要がないという利点があり、一般的にある行のインデントの判
断のために分析を要するのは最小限のテキストだけという特性に恵まれているの
で、前の無関係なコード片内にある、何らかの構文エラーの影響をインデントが
受けにくくなる傾向があります。一方で前方へのパースは、通常はより簡単であ
り、一度のパースで、リージョン全体を効果的に再インデントすることが可能に
なるという利点があります。

   インデント関数をスクラッチから記述するよりも、既存のインデント関数の
試用と再利用、または一般的なインデントエンジンに委ねるほうが優る場合が、
しばしばあります。しかし、そのようなエンジンは悲しむべきほど少数しかあり
ません。CCモードのインデントコード(C、C++、Java、Awk、およびその類のモー
ドが使用)は年月を経てより一般化されてきているので、あなたの言語にこれら
の言語と何らかの相似点があるなら、このエンジンの使用を試みるかもしれませ
ん。もう一方のSMIEはLispのsexp精神によるアプローチを採用して、それを非
Lisp言語に適応します。

* Menu:

* SMIE::                     SMIE: Simple Minded Indentation
                               Engine(純真なインデントエンジン)


File: elisp,  Node: SMIE,  Up: Auto-Indentation

22.7.1 Simple Minded Indentation Engine
---------------------------------------

SMIEは、一般的な操作とインデントを提供するエンジンです。これは“演算子順
位文法(operator precedence grammar)”を使用する、非常にシンプルなパーサー
にもとづいたエンジンであり、メジャーモードがLispのS式ベースの操作を非
Lisp言語に拡張するのを助け、同様にシンプルに使用できるにも関わらず、信頼
できる自動インデントを提供します。

   演算子順位文法は、コンパイラー内で使用されるより一般的なパーサーと比
較すると、非常に原始的なパーステクノロジーです。このパーサーには次のよう
な特徴があります。このパーサーのパース能力は非常に限定的で、大概は構文エ
ラーを検出できません。しかし、アルゴリズム的に前方パースと同様に後方パー
スを効果的に行うことが可能です。実際にそれはSMIEが後方パースにもとづくイ
ンデントを使用でき、‘forward-sexp’と‘backward-sexp’の両方の機能を提供で
きるとともに、特別な努力を要さずに構文的に不正なコードにたいして自然に機
能するであろうことを意味します。欠点は、ほとんどのプログラミング言語は、
少なくとも何らかの特別なトリック(*note SMIE Tricks::を参照)で再分類しな
ければ、SMIEを使用して正しくパースできないことも意味するからです。

* Menu:

* SMIE setup::               SMIEのセットアップと機能。
* Operator Precedence Grammars::  非常にシンプルなパース技術。
* SMIE Grammar::             言語の文法を定義する。
* SMIE Lexer::               トークンの定義。
* SMIE Tricks::              パーサー制限の回避策。
* SMIE Indentation::         インデントルールの指定。
* SMIE Indentation Helpers::  インデントルールにたいするヘルパー関数。
* SMIE Indentation Example::  インデントルールの例。
* SMIE Customization::       インデントのカスタマイズ。


File: elisp,  Node: SMIE setup,  Next: Operator Precedence Grammars,  Up: SMIE

22.7.1.1 SMIE Setup and Features
................................

SMIEは、構造的な操作と、コードの構造的構造にもとづくその他さまざまな機能
、特に自動インデントにたいするワンストップショップ(一カ所で必要な全ての
買い物ができること、またはそのような場所)であることを意図しています。メ
インのエントリーポイントは‘smie-setup’で、これは通常メジャーモードセット
アップの間に呼び出される関数です。

 -- Function: smie-setup grammar rules-function &rest keywords
     SMIEの操作とインデントをセットアップする。GRAMMARは
     ‘smie-prec2->grammar’により生成される文法テーブル(grammar table)、
     RULES-FUNCTIONは‘smie-rules-function’で使用されるインデントルールの
     セット、KEYWORDSは追加の引数であり以下のキーワードを含むことができ
     る:
        • ‘:forward-token’ FUN: 使用する前方lexer(lexer=lexical
          analyzer: 字句解析プログラム)を指定する。
        • ‘:backward-token’ FUN: 使用する後方lexerを指定する。

   この関数を呼び出せば、‘forward-sexp’、‘backward-sexp’、
‘transpose-sexps’のようなコマンドが、すでに構文テーブルにより処理されて
いる単なるカッコのペアー以外の、構造的な要素を正しく扱うことができるよう
になります。たとえば、与えられた文法が十分に明快ならば、
‘transpose-sexps’はその言語の優先順位のルールを考慮して、‘+’演算子の2つ
の引数を正しく入れ替えることができます。

   ‘smie-setup’の呼び出しもまた、TABによるインデントを期待通り機能させ、
‘begin...end’のような要素に適用するために‘blink-matching-paren’を拡張し
、そのメジャーモードのキーマップ内でバインドできるいくつかのコマンドを提
供するのに十分です。

 -- Command: smie-close-block
     このコマンドは、もっとも最近オープンされた(まだクローズされていない
     )ブロックをクローズする。

 -- Command: smie-down-list &optional arg
     このコマンドは‘down-list’と似ているが、‘begin...end’のようなカッコ
     以外のネストされたトークンにも注意を払う。


File: elisp,  Node: Operator Precedence Grammars,  Next: SMIE Grammar,  Prev: SMIE setup,  Up: SMIE

22.7.1.2 Operator Precedence Grammars
.....................................

SMIEの演算子順位文法は、各トークンにたいしてシンプルに左優先
(left-precedence)と右優先(right-precedence)という順位ペアーを与えます。
トークン‘T1’の右優先が、トークン‘T2’の左優先より小さい場合は、‘T1 < T2’で
あると言うことにしましょう。これを解読するには、‘<’をカッコの一種だとみ
なすのがよい方法です。‘... T1 something T2 ...’を見つけたら、これは‘...
T1 something) T2 ...’ではなく‘... T1 (something T2 ...’とパースされるべ
きです。‘... T1 something) T2 ...’と解釈するのは、‘T1 > T2’を見つけた場
合でしょう。‘T1 = T2’を見つけた場合、それはトークンT2とその後のトークン
T1が同じ構文構成にあり、通常は‘"begin" = "end"’を得ます。このような優先
順位のペアーは、2項演算子(infix operator)、カッコのようなネストされたト
ークン、およびその他多くのケースにたいして左結合(left-associativity)や右
結合(right-associativity)を表現するのに十分です。

 -- Function: smie-prec2->grammar table
     この関数は、_prec2_文法TABLEを引数にとり、‘smie-setup’で使用するの
     に適したalistをリターンする。_prec2_文法TABLEは、それ自体が以下の関
     数のいずれかによりビルドされることを意図している。

 -- Function: smie-merge-prec2s &rest tables
     この関数は、複数の_prec2_文法TABLESを、新たな_prec2_テーブルにマー
     ジする。

 -- Function: smie-precs->prec2 precs
     この関数は、順位テーブルPRECSから_prec2_テーブルをビルドする。
     PRECSは優先順(たとえば‘"+"’は‘"*"’より前にくる)にソートされたリスト
     で、要素は‘(ASSOC OP ...)’の形式であること。ここで、OPは演算子とし
     て振る舞うトークン、ASSOCはそれらの結合法則であり、‘left’、
     ‘right’、‘assoc’、‘nonassoc’のいずれかである。与えられた要素内のす
     べての演算子は、同じ優先レベルと結合法則を共有する。

 -- Function: smie-bnf->prec2 bnf &rest resolvers
     この関数により、BNF記法を使用した文法を指定することができる。これは
     、その文法のBNF表記と、同様に競合解決ルールRESOLVERSを受け取り、
     _prec2_テーブルをリターンする。

     BNFは‘(NONTERM RHS1 RHS2 ...)’という形式の非終端定義で、各RHSは終端
     記号(トークンとも呼ばれる)、または非終端記号の(空でない)リストであ
     る。

     すべての文法が許される訳ではない:
        • RHSに空のリストは指定できない(いずれにせよSMIEは空文字列にマッ
          チさせるためにすべての非終端記号を許すので、空リストが必要にな
          ることは決してない)。
        • RHSの後に連続する2つの非終端記号は指定できない。非終端記号の各
          ペアーは終端記号(もしくはトークン)で区切られる必要がある。これ
          は、演算子順位文法の基本的な制約である。

     さらに、競合が発生し得る:
        • リターンされる_prec2_テーブルはトークンのペアー間の制約を保持
          し、与えられた任意のペアーはT1 < T2、T1 = T2、T1 > T2のいずれ
          かのうち、ただ1つの制約を与えることができる。
        • トークンは、‘opener’(開きカッコに似た何か)、‘closer’(閉じカッ
          コのようなもの)、またはこれら2つのいずれでもない‘neither’(2項
          演算子や‘"else"’のようなinnerトークン)である。

     順位の競合は、RESOLVERSを通じて解決され得る。これは_precs_テーブル
     (‘smie-precs->prec2’を参照)のリストである。それぞれの順位競合にたい
     して、これらの‘precs’テーブルが特定の制約を指定している場合は、かわ
     りにこの制約により競合が解決され、それ以外は競合する制約のうち任意
     の1つが報告され、他は単に無視される。


File: elisp,  Node: SMIE Grammar,  Next: SMIE Lexer,  Prev: Operator Precedence Grammars,  Up: SMIE

22.7.1.3 Defining the Grammar of a Language
...........................................

ある言語にたいしてSMIE文法を定義する通常の方法は、順位のテーブルを保持す
る新たなグローバル変数を定義して、BNFルールのセットを与える方法です。た
とえば、小規模なPascal風言語の文法定義は、以下のようになるでしょう:
     (require 'smie)
     (defvar sample-smie-grammar
       (smie-prec2->grammar
        (smie-bnf->prec2
         '((id)
           (inst ("begin" insts "end")
                 ("if" exp "then" inst "else" inst)
                 (id ":=" exp)
                 (exp))
           (insts (insts ";" insts) (inst))
           (exp (exp "+" exp)
                (exp "*" exp)
                ("(" exps ")"))
           (exps (exps "," exps) (exp)))
         '((assoc ";"))
         '((assoc ","))
         '((assoc "+") (assoc "*")))))

注意すべき点がいくつかあります:

   • 上記の文法は、関数呼び出しの構文に明示的に言及していない。SMIEは識
     別子、対応がとれたカッコ(balanced parentheses)、または‘begin ...
     end’ブロックのようなsexpの任意のシーケンスが、どこに、どのように出
     現しても、自動的にそれを許容するだろう。
   • 文法カテゴリー‘id’は、右側に何ももたない。これは、‘id’が空文字列だ
     けにマッチ可能なことを意味しない。なぜなら上述のように、任意の
     sexpシーケンスは、どこに、どのような方法でも出現するからである。
   • BNF文法では非終端記号が連続して出現し得ないので、終端記号として作用
     するトークンを正しく扱うのが困難なので、上述の文法では、SMIEが容易
     に扱える‘";"’を、_セパレーター(separator)_ステートメントのかわりと
     して扱っている。
   • シーケンス内で使用される、(上記の‘","’や‘";"’のような)セパレーター
     は、BNFルールでは‘(foo (foo "separator" foo) ...)’のように定義する
     のが最善である。これは、順位の競合を生成するが、明示的に‘(assoc
     "separator")’を与えることにより解決される、
   • SMIEは、構文テーブル(syntax table)内でカッコ構文(paren syntax)をも
     つようにマークされたー任意の文字をペアーにするだろうから、‘("("
     exps ")")’ルールにカッコをペアーにする必要はなかった。(‘exps’の定義
     と併せて)このルールはかわりに、‘","’がカッコの外に出現すべきではな
     いことを明確にする。
   • 競合解決のための_precs_テーブルは、単一のテーブルより複数のテーブル
     をもつほうが、可能な場合は文法のBNF部分が関連する順位を指定できるの
     で、優れている。
   • ‘left’または‘right’を選択すること優るという明白な理由がない場合は、
     通常は‘assoc’を使用して演算子を結合演算子(associative)とマークする
     ほうが優れている。この理由により、上述の‘"+"’と‘"*"’は、たとえその
     言語がそれらを形式上は左結合(left associative)と定義していても、
     ‘assoc’として定義されている。


File: elisp,  Node: SMIE Lexer,  Next: SMIE Tricks,  Prev: SMIE Grammar,  Up: SMIE

22.7.1.4 Defining Tokens
........................

SMIEには、事前定義された字句解析プログラムが付属しており、それは次の方法
で構文テーブルを使用します: 文字の任意のシーケンスは、トークンとみなせる
単語構文(word syntax)、またはシンボル構文(symbol syntax)をもち、句読点構
文(punctuation syntax)をもつ任意の文字シーケンスもトークンとみなされます
。このデフォルトのlexerは、開始ポイントとして適している場合が多々ありま
すが、任意の与えられた言語にたいして、実際に正しいことは稀です。たとえば
、これは‘"2,+3"’が3つのトークン‘"2"’、‘",+"’、‘"3"’から構成されていると
判断するでしょう。

   あなたの言語のlexerルールをSMIEにたいして説明するためには、次のトーク
ンをfetchする関数と、前のトークンをfetchする関数の、2つの関数が必要にな
ります。これらの関数は通常、最初に空白文字とコメントをスキップして、その
後に次のテキストchunk(塊)を調べて、それが特別なトークンか確認します。こ
れは通常、バッファーから単に抽出された文字列ですが、あなたが望む他の何か
でも構いません。たとえば:
     (defvar sample-keywords-regexp
       (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
     (defun sample-smie-forward-token ()
       (forward-comment (point-max))
       (cond
        ((looking-at sample-keywords-regexp)
         (goto-char (match-end 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-forward "w_")
                   (point))))))
     (defun sample-smie-backward-token ()
       (forward-comment (- (point)))
       (cond
        ((looking-back sample-keywords-regexp (- (point) 2) t)
         (goto-char (match-beginning 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-backward "w_")
                   (point))))))

   これらのlexerがカッコの前にあるとき、空文字列をリターンする方法に注目
してください。これは、SMIEが構文テーブル内で定義されているカッコにたいし
て、自動的に配慮するからです。より厳密には、lexerが‘nil’、または空文字列
をリターンした場合、SMIEは構文テーブルにしたがい、対応するテキストを
sexpとして処理します。


File: elisp,  Node: SMIE Tricks,  Next: SMIE Indentation,  Prev: SMIE Lexer,  Up: SMIE

22.7.1.5 Living With a Weak Parser
..................................

SMIEが使用するパーステクニックは、異なるコンテキストでトークンが異なる振
る舞いをすることを許しません。ほとんどのプログラミング言語にたいして、こ
れは順位の競合によりBNF文法を変換するとき明らかになります。

   その文法を若干異なるように表現することにより、これらの競合を回避でき
る場合があります。たとえばModula-2にたいしては、以下のようなBNF文法をも
つのが自然に思えるかもしれません:

       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (cases (cases "|" cases)
              (caselabel ":" insts)
              ("ELSE" insts))
       ...

   しかし、これは‘"ELSE"’にたいする競合を生み出すでしょう。その一方で
IFルールは、(他の多くのものの中でも特に)‘"ELSE" = "END"’を暗示します。し
かしその一方では、‘"ELSE"’は‘cases’内に出現しますが、‘cases’は‘"END"’の
左に出現するので、わたしたちは‘"ELSE" > "END"’も得ることになります。これ
は、以下を使用して解決できます:
       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ("CASE" exp "OF" cases "ELSE" insts "END")
             ...)
       (cases (cases "|" cases) (caselabel ":" insts))
       ...
   または
       ...
       (inst ("IF" exp "THEN" else "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (else (insts "ELSE" insts))
       (cases (cases "|" cases) (caselabel ":" insts) (else))
       ...

   文法を書き換えによる競合の解決には欠点があります。なぜなら、SMIEはそ
の文法がコードの論理的構造を反映すると仮定するからです。そのため、BNFと
意図する抽象的構文木の関係を密接に保つことが望まれます。

   注意深く考慮した後に、これらの競合は深刻ではなく、‘smie-bnf->prec2’の
RESOLVERS引数を通じて解決する決心する場合もあるでしょう。これは通常、そ
の文法が単に不明瞭だからです。その文法により記述されるプログラムセットは
競合の影響を受けませんが、それらのプログラムにたいする唯一の方法はパース
だけです。‘'((assoc "|"))’のようなリゾルバ(resolver: 解決するもの)を追加
したいと望むような場合、通常それはセパレーターと2項結合演算子にたいする
ケースです。これが発生し得る他のケースは、‘'((assoc "else" "then"))’を使
用するような場合における、古典的な_ぶら下がりelse問題dangling else
problem_です。これは実際に競合があり解決不能だが、実際のところ問題が発生
しそうにないケースにたいしても、発生し得ます。

   最後に、多くのケースでは、すべての文法再構築努力にも関わらず、いくつ
かの競合が残るでしょう。しかし失望しないでください。パーサーをより賢くす
ることはできませんが、あなたの望むようにlexerをスマートにすることは可能
です。その方法は、競合が発生したら競合を引き起こしたトークンを調べて、そ
れらのうちの1つを2つ以上の異なるトークンに分割する方法です。たとえば、ト
ークン‘"begin"’にたいする互換性のない2つの使用を文法が区別する必要があり
、見つかった‘"begin"’の種類により、lexerに異なるトークン(たとえば
‘"begin-fun"’と‘"begin-plain"’)をリターンさせる場合です。これはlexerにた
いして、異なるケースを区別する処理を強い、そのためにlexerは特別な手がか
りを見つけるために、周囲のテキストを調べる必要があるでしょう。


File: elisp,  Node: SMIE Indentation,  Next: SMIE Indentation Helpers,  Prev: SMIE Tricks,  Up: SMIE

22.7.1.6 Specifying Indentation Rules
.....................................

提供された文法にもとづき、他に特別なことを行わなくても、SMIEは自動的なイ
ンデントを提供できるでしょう。しかし実際には、このデフォルトのインデント
スタイルでは、恐らく十分ではありません。多くの異なる状況において、これを
微調整したいと思うかもしれません。

   SMIEのインデントは、インデントルールは可能な限りローカルであるべきと
いう考えにもとづきます。_バーチャルインデント(virtual indentation)_とい
う考えによって、この目的を達成します。これは、特定のプログラムポイント
(program point)は行頭にバーチャルインデントがある場合は、それをもつだろ
う、という発想です。もちろん、そのプログラムポイントが正に行頭にある場合
は、そのプログラムポイントのバーチャルインデントは、プログラムポイントの
カレントのインデントです。しかしそうでない場合は、SMIEがそのポイントのバ
ーチャルインデントを計算するために、インデントアルゴリズムを使用します。
ところで実際には、あるプログラムポイントのバーチャルインデントは、その前
に改行を挿入した場合にプログラムポイントがもつであろうインデントと等しい
必要はありません。これが機能する方法を確認するためには、Cにおける‘{’の後
のSMIEのインデントルールは、‘{’がインデントする行自体にあるか、あるいは
前の行の終端にあるかを配慮しないことが挙げられます。かわりに、これらの異
なるケースは、‘{’の前のインデントを決定するインデントルール内で処理され
ます。

   他の重要な考え方として、_parent_の概念があります。あるトークン
_parent_は、周囲にある直近の構文構造の代表トークン(head token)です。たと
えば、‘else’のparentは、それが属する‘if’であり、‘if’のparentは周囲を取り
囲む構造の先導トークン(lead token)です。コマンド‘backward-sexp’は、ある
トークンからトークンのparentにジャンプしますが、注意点がいくつかあります
。_opener_(‘if’のような、ある構造を開始するトークン)にたいしては、他のト
ークンではそのトークンの後のポイントから開始する必要があるのにたいして、
opnerではそのトークンの前のポイントから開始する必要があります。
‘backward-sexp’はparentトークンがそのトークンの_opener_の場合はparentト
ークンの前のポイントで停止し、それ以外ではparentトークンの後のポイントで
停止します。

   SMIEのインデントルールは、2つの引数METHODとARGをとる関数により指定さ
れます。ここでARGの値と期待されるリターン値は、METHODに依存します。

   METHODは、以下のいずれかを指定できます:
   • ‘:after’: この場合、ARGはトークンであり、関数はARGの後に使用するイ
     ンデントにたいするOFFSETをリターンすべきである。
   • ‘:before’: この場合、ARGはトークンであり、関数はARG自体に使用するイ
     ンデントのOFFSETをリターンすべきである。
   • ‘:elem’: この場合、関数は関数の引数に使用するインデントのオフセット
     (ARGが‘arg’の場合)、または基本的のインデントステップ(ARGが‘basic’の
     場合)、のいずれかをリターンすべきである。
   • ‘:list-intro’: この場合、ARGはトークンであり、関数はそのトークンの
     後が単一の式ではなく、(任意のトークンにより区切られない)式のリスト
     が続く場合は非‘nil’をリターンすべきである。

   ARGがトークンのとき、関数はそのトークンの直前のポイントで呼び出されま
す。リターン値‘nil’は常にデフォルトの振る舞いへのフォールバックを意味す
るので、関数は期待した引数でないときは‘nil’をリターンするべきです。

   OFFSETは、以下のいずれかを指定できます:
   • ‘nil’: デフォルトのインデントルールを使用する。
   • ‘(column . COLUMN)’: 列COLUMNにインデントする。
   • NUMBER: 基本トークン(base token: ‘:after’にたいするカレントトークン
     であり、かつ‘:before’にたいしてparentであるようなトークン)にたいし
     て相対的な、NUMBERによるオフセット。


File: elisp,  Node: SMIE Indentation Helpers,  Next: SMIE Indentation Example,  Prev: SMIE Indentation,  Up: SMIE

22.7.1.7 Helper Functions for Indentation Rules
...............................................

SMIEは、インデントを決定する関数内で使用するために特別にデザインされた、
さまざまな関数を提供します(これらの関数のうちのいくつかは、異なるコンテ
キスト内で使用された場合は中断する)。これらの関数はすべて、プレフィック
ス‘smie-rule-’で始まります。

 -- Function: smie-rule-bolp
     カレントトークンが行の先頭にある場合は、非‘nil’をリターンする。

 -- Function: smie-rule-hanging-p
     カレントトークンが_hanging(ぶら下がり)_の場合は、非‘nil’をリターン
     する。トークンがその行の最後のトークンであり、他のトークンが先行す
     る場合、そのトークンは_hanging_である。行に単独のトークンは
     hangingではない。

 -- Function: smie-rule-next-p &rest tokens
     次のトークンがTOKENS内にある場合は、非‘nil’をリターンする。

 -- Function: smie-rule-prev-p &rest tokens
     前のトークンがTOKENS内にある場合は、非‘nil’をリターンする。

 -- Function: smie-rule-parent-p &rest parents
     カレントトークンのparentがPARENTS内にある場合は、非‘nil’をリターン
     する。

 -- Function: smie-rule-sibling-p
     カレントトークンのparentが実際はsibling(兄弟)の場合は、非‘nil’をリ
     ターンする。たとえば‘","’のparentが直前の‘","’のような場合が該当す
     る。

 -- Function: smie-rule-parent &optional offset
     カレントトークンをparentとアライン(align: 桁揃え)するための適切なオ
     フセットをリターンする。OFFSETが非‘nil’の場合、それは追加オフセット
     として適用される整数であること。

 -- Function: smie-rule-separator method
     _セパレーター(separator)_としてカレントトークンをインデントする。

     ここでの_セパレーター_は、周囲を取り囲む何らかの構文構造内でさまざ
     まな要素を区切ることを唯一の目的とするトークンであり、それ自体は何
     も意味をもたないトークン(通常は抽象構文木内でノードとして存在しない
     )を意味する。

     このようなトークンは結合構文をもち、その構文的parentと密に結び付け
     られることが期待される。典型的な例としては引数リスト内の‘","’(カッ
     コで括られた内部)、または命令文シーケンス内の‘";"’(‘{...}’や
     ‘begin...end’で括られたブロックの内部)が挙げられる。

     METHODは、‘smie-rules-function’に渡されるメソッド名であること。


File: elisp,  Node: SMIE Indentation Example,  Next: SMIE Customization,  Prev: SMIE Indentation Helpers,  Up: SMIE

22.7.1.8 Sample Indentation Rules
.................................

以下は、インデント関数の例です:

     (defun sample-smie-rules (kind token)
       (pcase (cons kind token)
         (`(:elem . basic) sample-indent-basic)
         (`(,_ . ",") (smie-rule-separator kind))
         (`(:after . ":=") sample-indent-basic)
         (`(:before . ,(or `"begin" `"(" `"{")))
          (if (smie-rule-hanging-p) (smie-rule-parent)))
         (`(:before . "if")
          (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
               (smie-rule-parent)))))

注意すべき点がいくつかあります:

   • 最初のcaseは、使用する基本的なインデントの増分を示す。
     ‘sample-indent-basic’が‘nil’の場合、SMIEはグローバルセッティング
     ‘smie-indent-basic’を使用する。メジャーモードがかわりに
     ‘smie-indent-basic’をバッファーローカルにセットするかもしれないが、
     これは勧められない。

   • トークン‘","’にたいするルールにより、カンマセパレーターが行頭にある
     場合に、SMIEをより賢明に振る舞わせようとしている。これはセパレータ
     ーのインデントを解除(outdent)、カンマの後のコードにアラインされるよ
     う試みる。たとえば:

          x = longfunctionname (
                  arg1
                , arg2
              );

   • ‘":="’の後のインデントのルールは、そうしなければSMIEが‘":="’を2項演
     算子として扱い、左の引数に併せて右の引数をアラインするであろうから
     、このルールが存在する。

   • ‘"begin"’の前のインデントのルールは、バーチャルインデントの使用例で
     ある。このルールは‘"begin"’がhangingのときだけ使用され、これは
     ‘"begin"’が行頭にないときのみ発生し得る。そのため、これは
     ‘"begin"’自体のインデントには使用されないが、この‘"begin"’に関連す
     る何かをインデントするときだけ使用される。このルールは、具体的には
     以下のフォームを:

              if x > 0 then begin
                      dosomething(x);
                  end
     以下に変更する
              if x > 0 then begin
                  dosomething(x);
              end

   • ‘"if"’の前のインデントのルールは‘"begin"’のインデントルールと似てい
     るが、ここでの目的は‘"else if"’を1単位として扱うことにあり、それに
     より各テストより右にインデントされずに、一連のテストにアラインされ
     る。この関数は‘smie-rule-bolp’をテストして、‘"if"’が別の行にないと
     きだけこれを行う。

     ‘"else"’が、それの属する‘"if"’にたいして常にアラインされ、かつそれ
     が常に行頭であるることが判っている場合は、より効果的なルールを使用
     できる:
          ((equal token "if")
           (and (not (smie-rule-bolp))
                (smie-rule-prev-p "else")
                (save-excursion
                  (sample-smie-backward-token)
                  (cons 'column (current-column)))))

     この式の利点は、これがシーケンスの最初の‘"if"’まで戻ってすべてをや
     り直すのではなく、前の‘"else"’のインデントを再利用することである。

