This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: SMIE Customization,  Prev: SMIE Indentation Example,  Up: SMIE

22.7.1.9 Customizing Indentation
................................

SMIEにより提供されるインデントを使用するモードを使っている場合は、好みに
合わせてインデントをカスタマイズできます。これはモードごと(オプション
‘smie-config’を使用)、またはファイルごと(ファイルローカル変数指定内で関
数‘smie-config-local’を使用)に行うことができます。

 -- User Option: smie-config
     このオプションにより、モードごとにインデントをカスタマイズできる。
     これは‘(MODE . RULES)’という形式の要素をもつalistである。rulesの正
     確な形式については、変数のドキュメントを参照のこと。しかし、コマン
     ド‘smie-config-guess’を使用したほうが、より簡単に見つけられるかもし
     れない。

 -- Command: smie-config-guess
     このコマンドは、好みのスタイルのインデントを生成する、適切セッティ
     ングの解決を試みる。あなたのスタイルでインデントされたファイルを
     visitしているときに、単にこのコマンドを呼び出せばよい。

 -- Command: smie-config-save
     ‘smie-config-guess’を使用した後にこのコマンドを呼び出すと、将来のセ
     ッション用にセッティングを保存する。

 -- Command: smie-config-show-indent &optional move
     このコマンドは、カレント行のインデントに使用されているルールを表示
     する。

 -- Command: smie-config-set-indent
     このコマンドは、カレント行のインデントに合わせて、ローカルルールを
     追加する。

 -- Function: smie-config-local rules
     この関数は、カレントバッファーにたいするインデントルールとして、
     RULESを追加する。これらのルールは、‘smie-config’オプションにより定
     義された、任意のモード固有ルールに追加される。特定のファイルにたい
     してカスタムインデントルールを指定するには、‘eval:
     (smie-config-local '(RULES))’の形式のエントリーを、そのファイルのロ
     ーカル変数に追加する。


File: elisp,  Node: Desktop Save Mode,  Prev: Auto-Indentation,  Up: Modes

22.8 Desktop Save Mode
======================

“Desktop Saveモード”とは、あるセッションから別のセッションへ、Emacs状態
を保存する機能です。Desktop Saveモードの使用に関するユーザーレベルのコマ
ンドについては、GNU Emacsマニュアルに記載されています(*note
(emacs)Saving Emacs Sessions::を参照)。バッファーでファイルをvisitしてい
るモードでは、この機能を使うために何も行う必要はありません。

   ファイルをvisitしていないバッファーについて状態を保存するには、そのメ
ジャーモードがバッファーローカル変数‘desktop-save-buffer’を非‘nil’値にバ
インドしなければなりません。

 -- Variable: desktop-save-buffer
     このバッファーローカル変数が非‘nil’の場合は、デスクトップ保存時にそ
     のバッファー状態がdesktopファイルに保存される。値が関数の場合、その
     関数はデスクトップ保存時に引数DESKTOP-DIRNAMEで呼び出され、関数が呼
     び出されたバッファーの状態とともに、関数の値がdesktopファイルに保存
     される。補助的な情報の一部としてファイル名がリターンされたとき、そ
     れらは以下を呼び出してフォーマットされるべきである

          (desktop-file-name FILE-NAME DESKTOP-DIRNAME)

   ファイルをvisitしていないバッファーがリストアされるようにするには、そ
の初を行う関数をメジャーモードが定義しなければならず、その関数はalist
‘desktop-buffer-mode-handlers’にリストされなければならない。

 -- Variable: desktop-buffer-mode-handlers
     以下を要素にもつalistである

          (MAJOR-MODE . RESTORE-BUFFER-FUNCTION)

     関数RESTORE-BUFFER-FUNCTIONは、以下の引数リストで呼び出されるだろう

          (BUFFER-FILE-NAME BUFFER-NAME DESKTOP-BUFFER-MISC)

     この関数は、リストアされたバッファーをリターンすべきである。ここで
     、DESKTOP-BUFFER-MISCは、オプションで‘desktop-save-buffer’にバイン
     ドされる関数によりリターンされる値である。


File: elisp,  Node: Documentation,  Next: Files,  Prev: Modes,  Up: Top

23 Documentation
****************

GNU Emacsには便利なビルトインのヘルプ機能があり、それらのほとんどは、関
数や変数のドキュメント文字列に付属するドキュメント文字列の情報が由来です
。このチャプターでは、Lispプログラムからドキュメント文字列にアクセスする
方法について説明します。

   ドキュメント文字列のコンテンツは、ある種の慣習にしたがうべきです。特
に、最初の行は、その関数または変数を簡単に説明する1つ、または2つの完全な
センテンスであるべきです。よいドキュメント文字列を記述する方法については
、*note Documentation Tips::を参照してください。

   Emacs向けのドキュメント文字列は、Emacsマニュアルと同じものではないこ
とに注意してください。マニュアルは、Texinfo言語で記述された独自のソース
ファイルをもちます。それにたいしドキュメント文字列は、それが適用される関
数および変数の定義内で指定されます。ドキュメント文字列をコレクションして
も、それはマニュアルとしては不十分です。なぜなら、よいマニュアルとは、そ
のやり方でまとめられたものではなく、議論のトピックという観点によりまとめ
られているからです。

   ドキュメント文字列を表示するコマンドについては、*note Help:
(emacs)Help.を参照してください。

* Menu:

* Documentation Basics::     ドキュメント文字列が定義、格納される場所。
* Accessing Documentation::  Lispプログラムがドキュメント文字列にアクセスする方法。
* Keys in Documentation::    カレントキーバインディングの置き換え。
* Describing Characters::    非プリント文字やキーシーケンスをプリント可能な記述にする。
* Help Functions::           Emacsヘルプ機能により使用されるサブルーチン。


File: elisp,  Node: Documentation Basics,  Next: Accessing Documentation,  Up: Documentation

23.1 Documentation Basics
=========================

ドキュメント文字列は、テキストをダブルクォート文字で囲んだ、文字列にたい
するLisp構文を使用して記述されます。実はこれは実際のLisp文字列です。関数
または変数の定義内の適切な箇所に文字列があると、それは関数または変数のド
キュメントの役割を果たします。

   関数定義(‘lambda’や‘defun’フォーム)の中では、ドキュメント文字列は引数
リストの後に指定され、通常は関数オブジェクト内に直接格納されます。*note
Function Documentation::を参照してください。関数名の
‘function-documentation’プロパティに関数ドキュメントをputすることもでき
ます(*note Accessing Documentation::を参照)。

   変数定義(‘defvar’フォーム)の中では、ドキュメント文字列は初期値の後に
指定されます。*note Defining Variables::を参照してください。この文字列は
、その変数の‘variable-documentation’プロパティに格納されます。

   Emacsがメモリー内にドキュメント文字列を保持しないときがあります。それ
には、2つの状況があります。1つ目はメモリーを節約するためで、事前ロードさ
れた関数および変数(プリミティブを含む)のドキュメントは、
‘doc-directory’で指定されたディレクトリー内の、‘DOC’という名前のファイル
に保持されます(*note Accessing Documentation::を参照)。2つ目は関数または
変数がバイトコンパイルされたファイルからロードされたときで、Emacsはそれ
らのドキュメント文字列のロードを無効にします(*note Docs and
Compilation::を参照)。どちらの場合も、ある関数にたいしてユーザーが‘C-h
f’(‘describe-function’)を呼び出したときなど、Emacsは必要なときだけファイ
ルのドキュメント文字列を照会します。

   ドキュメント文字列には、ユーザーがドキュメントを閲覧するときのみ照会
されるキーバインディングを参照する、特別な“キー置換シーケンス(key
substitution sequences)”を含めることができます。これにより、たとえユーザ
ーがデフォルトのキーバインディングを変更していても、ヘルプコマンドが正し
いキーを表示できるようになります。

   オートロードされたコマンド(*note Autoload::を参照)のドキュメント文字
列では、これらのキー置換シーケンスは特別な効果をもち、そのコマンドにたい
する‘C-h f’により、オートロードをトリガーします(これは‘*Help*’バッファー
内のハイパーリンクを正しくセットアップするために必要となる)。


File: elisp,  Node: Accessing Documentation,  Next: Keys in Documentation,  Prev: Documentation Basics,  Up: Documentation

23.2 Access to Documentation Strings
====================================

 -- Function: documentation-property symbol property &optional verbatim
     この関数は、プロパティPROPERTY配下のSYMBOLのプロパティリスト内に記
     録されたドキュメント文字列をリターンする。ほとんどの場合、これは
     PROPERTYを‘variable-documentation’にして、変数のドキュメント文字列
     の照会に使用される。しかし、カスタマイゼーショングループのような、
     他の種類のドキュメント照会にも使用できる(が、関数のドキュメントには
     、以下の‘documentation’関数を使用する)。

     そのプロパティの値が‘DOC’ファイルやバイトコンパイル済みファイルに格
     納されたドキュメント文字列を参照する場合、この関数はその文字列を照
     会して、それをリターンする。

     プロパティの値が‘nil’や文字列以外で、ファイル内のテキストも参照しな
     い場合は、文字列を取得するLisp式として評価される。

     最終的に、この関数はキーバインディングを置換するために、文字列を
     ‘substitute-command-keys’に引き渡す(*note Keys in Documentation::を
     参照)。VERBATIMが非‘nil’の場合、このステップはスキップされる。

          (documentation-property 'command-line-processed
             'variable-documentation)
               ⇒ "Non-nil once command line has been processed"
          (symbol-plist 'command-line-processed)
               ⇒ (variable-documentation 188902)
          (documentation-property 'emacs 'group-documentation)
               ⇒ "Customization of the One True Editor."

 -- Function: documentation function &optional verbatim
     この関数は、FUNCTIONのドキュメント文字列をリターンする。この関数は
     マクロ、名前付きキーボードマクロ、およびスペシャルフォームも通常の
     関数と同様に処理する。

     FUNCTIONがシンボルの場合は、そのシンボルの
     ‘function-documentation’プロパティを最初に調べる。それが非‘nil’値を
     もつなら、その値(プロパティの値が文字列以外の場合は、それを評価した
     値)がドキュメントとなる。

     FUNCTIONがシンボル以外、あるいは‘function-documentation’プロパティ
     をもたない場合、‘documentation’は必要ならファイルを読み込んで、実際
     の関数定義のドキュメント文字列を抽出する。

     最後に、VERBATIMが‘nil’なら、この関数は‘substitute-command-keys’を
     呼び出す。結果はリターンするための文字列である。

     ‘documentation’関数は、FUNCTIONが関数定義をもたない場合は、
     ‘void-function’エラーをシグナルする。しかし、関数定義がドキュメント
     をもたない場合は問題ない。その場合、‘documentation’は‘nil’をリター
     ンする。

 -- Function: face-documentation face
     この関数は、FACEのドキュメント文字列をフェイスとしてリターンする。

   以下は、‘documentation’と‘documentation-property’を使用した例で、いく
つかのシンボルのドキュメント文字列を‘*Help*’バッファー内に表示します。

     (defun describe-symbols (pattern)
       "PATTERNにマッチするEmacs Lispシンボルを説明する。
     名前にPATTERNをもつすべてのシンボルの説明が
     `*Help*'バッファーに表示される。"
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (function
               (lambda (s)
                 ;; シンボルの説明をプリントする
                 (if (fboundp s)             ; これは関数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (commandp s)
                            (let ((keys (where-is-internal s)))
                              (if keys
                                  (concat
                                   "Keys: "
                                   (mapconcat 'key-description
                                              keys " "))
                                "Keys: none"))
                          "Function")
                        (or (documentation s)
                            "not documented"))))

                 (if (boundp s)              ; これは変数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (custom-variable-p s)
                            "Option " "Variable")
                        (or (documentation-property
                              s 'variable-documentation)
                            "not documented")))))))
             sym-list)

         ;; PATTERNにマッチするシンボルのリストを構築
         (mapatoms (function
                    (lambda (sym)
                      (if (string-match pattern (symbol-name sym))
                          (setq sym-list (cons sym sym-list))))))

         ;; データを表示
         (help-setup-xref (list 'describe-symbols pattern) (interactive-p))
         (with-help-window (help-buffer)
           (mapcar describe-func (sort sym-list 'string<)))))

   ‘describe-symbols’関数は‘apropos’のように機能しますが、より多くの情報
を提供します。

     (describe-symbols "goal")

     ---------- Buffer: *Help* ----------
     goal-column     Option
     Semipermanent goal column for vertical motion, as set by ...

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.
     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable `goal-column'.

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was
     at the start of current run of vertical motion commands.
     When the `track-eol' feature is doing its job, the value is 9999.
     ---------- Buffer: *Help* ----------

 -- Function: Snarf-documentation filename
     この関数は、Emacsビルド時の実行可能なEmacsダンプ直前に使用される。
     これは、ファイルFILENAME内に格納されたドキュメント文字列の位置を探
     して、メモリー上の関数定義および変数のプロパティリスト内にそれらの
     位置を記録する。*note Building Emacs::を参照のこと。

     Emacsは、‘emacs/etc’ディレクトリーから、ファイルFILENAMEを読み込む
     。その後、ダンプされたEmacs実行時に、ディレクトリー
     ‘doc-directory’内の同じファイルを照会する。FILENAMEは通常‘"DOC"’で
     ある。

 -- Variable: doc-directory
     この変数は、ビルトインおよび事前ロードされた関数および変数のドキュ
     メント文字列を含む、ファイル‘"DOC"’があるべきディレクトリーの名前を
     保持する。

     ほとんどの場合、これは‘data-directory’と同一である。実際にインスト
     ールしたEmacsではなく、EmacswpeyビルドしたディレクトリーからEmacsを
     実行したときは、異なるかもしれない。*note Definition of
     data-directory::を参照のこと。


File: elisp,  Node: Keys in Documentation,  Next: Describing Characters,  Prev: Accessing Documentation,  Up: Documentation

23.3 Substituting Key Bindings in Documentation
===============================================

ドキュメント文字列がキーシーケンスを参照する際、それらはカレントである実
際のキーバインディングを使用するべきです。これらは、以下で説明する特別な
キーシーケンスを使用して行うことができます。通常の方法によるドキュメント
文字列へのアクセスは、これらの特別なキーシーケンスをカレントキーバインデ
ィングに置き換えます。これは、‘substitute-command-keys’を呼び出すことに
より行われます。あなた自身がこの関数を呼び出すこともできます。

   以下は、それら特別なシーケンスと、その意味についてのリストです:

‘\[COMMAND]’
     これは、COMMANDを呼び出すキーシーケンス、またはCOMMANDがキーバイン
     ディングをもたない場合は‘M-x COMMAND’である。

‘\{MAPVAR}’
     これは、変数MAPVARの値であるようなキーマップの要約を意味する。この
     要約は、‘describe-bindings’を用いて作成される。

‘\<MAPVAR>’
     これ自体は、何のテキストも意味せず、副作用のためだけに使用される。
     これは、このドキュメント文字列内にある、後続のすべての
     ‘\[COMMAND]’にたいするキーマップとして、MAPVARの値を指定する。

‘\=’
     これは、後続の文字をクォートして、無効にする。したがって、‘\=\[’は
     ‘\[’、‘\=\=’は‘\=’を出力に配する。

   *注意してください:* Emacs Lisp内の文字列として記述する際は、‘\’を2つ
記述しなければなりません。

 -- Function: substitute-command-keys string
     この関数は、上述の特別なシーケンスをSTRINGからスキャンして、それら
     が意味するもので置き換え、その結果を文字列としてリターンする。これ
     により、そのユーザー自身がカスタマイズした、実際のキーシーケンスを
     参照するドキュメントが表示できる。

     あるコマンドが複数のバインディングをもつ場合、通常この関数は最初に
     見つかったバインディングを使用する。以下のようにして、コマンドのシ
     ンボルプロパティ‘:advertised-binding’に割り当てることにより、特定の
     キーバインディングを指定できる:

          (put 'undo :advertised-binding [?\C-/])

     ‘:advertised-binding’プロパティは、メニューアイテム(*note Menu
     Bar::を参照)に表示されるバインディングにも影響する。コマンドが実際
     にもたないキーバインディングを指定した場合、このプロパティは無視さ
     れる。

   以下は、特別なキーシーケンスの例である:

     (substitute-command-keys
        "再帰編集者abortするには、次をタイプする: \\[abort-recursive-edit]")
     ⇒ "再帰編集者abortするには、次をタイプする: C-]"

     (substitute-command-keys
        "ミニバッファーにたいして定義されたキーは:
       \\{minibuffer-local-must-match-map}")
     ⇒ "ミニバッファーにたいして定義されたキーは:

     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "

     (substitute-command-keys
        "ミニバッファーにたいして再帰編集をabortするには、次をタイプ:
     \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
     ⇒ "ミニバッファーにたいして再帰編集をabortするには、次をタイプ: C-g."

   ドキュメント文字列内のテキストにたいしては、他にも特別な慣習がありま
す。たとえば、このマニュアルの関数、変数、およびセクションで参照できます
。詳細は*note Documentation Tips::を参照してください。


File: elisp,  Node: Describing Characters,  Next: Help Functions,  Prev: Keys in Documentation,  Up: Documentation

23.4 Describing Characters for Help Messages
============================================

以下の関数はイベント、キーシーケンス、文字をテキスト表記(textual
descriptions)に変換します。これらの変換された表記は、メッセージ内に任意
のテキスト文字やキーシーケンスを含める場合に有用です。なぜなら非プリント
文字や空白文字は、プリント文字シーケンスに変換されるからです。空白文字以
外のプリント文字は、その文字自身が表記になります。

 -- Function: key-description sequence &optional prefix
     この関数は、SEQUENCE内の入力イベントにたいして、Emacsの標準表記を含
     む文字列をリターンする。PREFIXが非‘nil’の場合、それはSEQUENCEに前置
     される入力イベントシーケンスであり、リターン値にも含まれる。引数は
     どちらも文字列、ベクター、またはリストかもしれない。有効なイベント
     に関する詳細は、*note Input Events::を参照のこと。

          (key-description [?\M-3 delete])
               ⇒ "M-3 <delete>"
          (key-description [delete] "\M-3")
               ⇒ "M-3 <delete>"

     以下の‘single-key-description’の例も参照されたい。

 -- Function: single-key-description event &optional no-angles
     この関数は、キーボード入力にたいするEmacsの標準表記として、EVENTを
     表記する文字列をリターンする。通常のプリント文字はその文字自身で表
     れるが、コントロール文字は‘C-’で始まる文字列、メタ文字は‘M-’で始ま
     る文字列、スペース、タブなどは‘SPC’や‘TAB’のように変換される。ファ
     ンクションキーのシンボルは、‘<...>’のように角カッコ(angle
     brackets)の内側に表れる。リストであるようなイベントは、そのリストの
     CAR内のシンボル名が、角カッコの内側に表れる。

     オプション引数NO-ANGLESが非‘nil’の場合、ファンクションキーおよびイ
     ベントシンボルを括る角カッコは省略される。これは、角カッコを使用し
     ない古いバージョンのEmacsとの互換性のためである。

          (single-key-description ?\C-x)
               ⇒ "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
               ⇒ "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
          (single-key-description 'delete)
               ⇒ "<delete>"
          (single-key-description 'C-mouse-1)
               ⇒ "<C-mouse-1>"
          (single-key-description 'C-mouse-1 t)
               ⇒ "C-mouse-1"

 -- Function: text-char-description character
     この関数は、テキスト内に出現する文字にたいするEmacsの標準表記として
     、CHARACTERを表記する文字列をリターンする。これは
     ‘single-key-description’と似ているが、コントロール文字にカレットが
     前置されて表される点が異なる(これはEmacsバッファー内でコントロール
     文字を表示する通常の方法である)。他にも、‘single-key-description’が
     2**27ビットをメタ文字とするのにたいし、‘text-char-description’は
     2**7ビットをメタ文字とする点が異なる。

          (text-char-description ?\C-c)
               ⇒ "^C"
          (text-char-description ?\M-m)
               ⇒ "\xed"
          (text-char-description ?\C-\M-m)
               ⇒ "\x8d"
          (text-char-description (+ 128 ?m))
               ⇒ "M-m"
          (text-char-description (+ 128 ?\C-m))
               ⇒ "M-^M"

 -- Command: read-kbd-macro string &optional need-vector
     この関数は主にキーボードマクロを操作するために使用されるが、
     ‘key-description’の大雑把な意味で逆の処理にも使用できる。キー表記を
     含むスペース区切りの文字列でこれを呼び出すと、それに対応するイベン
     トを含む文字列、またはベクターをリターンする。(これは単一の有効なキ
     ーシーケンスであるか否かは問わず、何のイベントを使用するかに依存す
     る。*note Key Sequences::を参照されたい。) NEED-VECTORが非‘nil’の場
     合、リターン値は常にベクターになる。


File: elisp,  Node: Help Functions,  Prev: Describing Characters,  Up: Documentation

23.5 Help Functions
===================

Emacsは、さまざまなビルトインのヘルプ関数を提供し、それらはすべてプレフ
ィックス‘C-h’のサブコマンドとして、ユーザーがアクセスできます。それらに
ついての詳細は、*note Help: (emacs)Help.を参照してください。ここでは、同
様な情報についてプログラムレベルのインターフェイスを説明します。

 -- Command: apropos pattern &optional do-all
     この関数は、名前にaproposパターン(apropos pattern: 適切なパターン)
     PATTERNを含む、“重要”なすべてのシンボルを探す。マッチに使用される
     aproposパターンは単語、最低2つはマッチしなければならないスペース区
     切りの単語、または(特別な正規表現文字があれば)正規表現のいずれかで
     ある。あるシンボルが関数、変数、フェイスとしての定義、あるいはプロ
     パティをもつ場合、そのシンボルは“重要”とされる。

     関数は、以下のような要素のリストをリターンする:

          (SYMBOL SCORE FUNCTION-DOC VARIABLE-DOC
           PLIST-DOC WIDGET-DOC FACE-DOC GROUP-DOC)

     ここで、SCOREはマッチの面からそのシンボルがどれだけ重要に見えるかを
     比較する整数である。残りの各要素は、SYMBOLにたいする関数、変数、
     ...等のドキュメント文字列(または‘nil’)である。

     これは‘*Apropos*’という名前のバッファーにもシンボルを表示し、その際
     各行にはドキュメント文字列の先頭から取得した1行説明とともに表示され
     る。

     DO-ALLが非‘nil’、またはユーザーオプション‘apropos-do-all’が非
     ‘nil’の場合、‘apropos’は見つかった関数のキーバインディングも表示す
     る。これは重要なものだけでなく、のinternされた_すべて_のシンボルも
     表示する(同様にリターン値としてもそれらをリストする)。

 -- Variable: help-map
     この変数の値は、Helpキー‘C-h’に続く文字にたいするローカルキーマップ
     である。

 -- Prefix Command: help-command
     このシンボルは関数ではなく、関数定義セルには‘help-map’として知られ
     る、キーマップを保持する。これは、‘help.el’内で以下のように定義され
     ている:

          (define-key global-map (string help-char) 'help-command)
          (fset 'help-command help-map)

 -- User Option: help-char
     この変数の値は、ヘルプ文字(help character: Helpを意味する文字として
     Emacsが認識する文字)である。デフォルトでは、‘C-h’を意味する8が値で
     ある。この文字を読み取った際、‘help-form’が非‘nil’のLisp式ならば、
     Emacsはその式を評価して、結果が文字列の場合はウィンドウ内にそれを表
     示する。

     通常、‘help-form’の値は‘nil’である。その場合、ヘルプ文字はコマンド
     入力のレベルにおいて特別な意味を有せず、通常の方法におけるキーシー
     ケンスの一部となる。‘C-h’の標準的なキーバインディングは、複数の汎用
     目的をもつヘルプ機能のプレフィックスキーである。

     ヘルプ文字は、プレフィックスキーの後でも特別な意味をもつ。ヘルプ文
     字がプレフィックスキーのサブコマンドとしてバインディングをもたない
     場合は、そのプレフィックスキーのすべてのサブコマンドのリストを表示
     する、‘describe-prefix-bindings’を実行する。

 -- User Option: help-event-list
     この変数の値は、“ヘルプ文字”の代役を果たすイベント型のリストである
     。これらのイベントは、‘help-char’で指定されるイベントと同様に処理さ
     れる。

 -- Variable: help-form
     この変数が非‘nil’の場合、その値は文字‘help-char’が読み取られるたび
     に評価されるフォームである。そのフォームの評価により文字列が生成さ
     れた場合は、その文字列が表示される。

     ‘read-event’、‘read-char-choice’、‘read-char’を呼び出すコマンドは、
     それが入力を行う間は、恐らく‘help-form’を非‘nil’にバインドすべきで
     あろう(‘C-h’が他の意味をもつ場合は、これを行うべきではない)。この式
     を評価した結果は、何にたいする入力なのか、そしてそれを正しくエンタ
     ーする方法を説明する文字列であること。

     ミニバッファーへのエントリーにより、この変数は
     ‘minibuffer-help-form’の値にバインドされる(*note Definition of
     minibuffer-help-form::を参照)。

 -- Variable: prefix-help-command
     この変数は、プレフィックスキーにたいするヘルプをプリントする関数を
     保持する。その関数は、ユーザーが後にヘルプ文字を伴うプレフィックス
     キーをタイプし、そのヘルプ文字がプレフィックスの後のバインディング
     をもたないたときに呼び出される。この変数のデフォルト値は
     ‘describe-prefix-bindings’である。

 -- Command: describe-prefix-bindings
     この関数は、もっとも最近のプレフィックスキーのサブコマンドすべてに
     たいするリストを表示する。プレフィックスの説明は、そのキーシーケン
     スの最後のイベントを除くすべてから構成される(最後のイベントは、恐ら
     くヘルプ文字であろう)。

   以下の2つの関数は、“electric”モードのように制御を放棄することなくヘル
プを提供したいモードを意図しています。これらは、通常のヘルプ関数と区別す
るため、名前が‘Helper’で始まります。

 -- Command: Helper-describe-bindings
     このコマンドは、ローカルキーマップとグローバルキーマップの両方のキ
     ーバインディングすべてのリストを含むヘルプバッファーを表示するウィ
     ンドウをポップアップする。これは‘describe-bindings’を呼び出すことに
     より機能する。

 -- Command: Helper-help
     このコマンドは、カレントモードにたいするヘルプを提供する。これはミ
     ニバッファー内でメッセージ‘Help (Type ? for further options)’ととも
     にユーザーに入力を求め、その後キーバインディングが何か、何を意図す
     るモードなのかを探すための助けを提供する。これは‘nil’をリターンする
     。

     これは、マップ‘Helper-help-map’を変更することによりカスタマイズでき
     る。

 -- Variable: data-directory
     この変数は、Emacsに付随する特定のドキュメントおよびテキストファイル
     を探すディレクトリーの名前を保持する。

 -- Function: help-buffer
     この関数は、ヘルプバッファーの名前(通常は‘*Help*’)をリターンする。
     そのようなバッファーが存在しない場合は、最初にそれを作成する。

 -- Macro: with-help-window buffer-name body...
     このマクロは、‘with-output-to-temp-buffer’(*note Temporary
     Displays::を参照)のようにBODYを評価して、そのフォームが生成したすべ
     ての出力を、BUFFER-NAMEという名前のバッファーに挿入する
     (BUFFER-NAMEは、通常は関数‘help-buffer’によりリターンされる値である
     べきだろう)。これは、指定されたバッファーをHelpモードに置き、ヘルプ
     ウィンドウをquit、およびスクロールする方法を告げるメッセージを表示
     する。これは、ユーザーオプション‘help-window-select’のカレント値が
     適切にセットされていれば、ヘルプウィンドウの選択も行う。これは
     BODY内の最後の値をリターンする。

 -- Function: help-setup-xref item interactive-p
     この関数は、‘*Help*’バッファー内のクロスリファレンスデータを更新す
     る。このクロスリファレンスは、ユーザーが‘Back’ボタンまたは
     ‘Forward’ボタン上でクリックした際に、ヘルプ情報の再生成に使用される
     。‘*Help*’バッファーを使用するほとんどのコマンドは、バッファーをク
     リアーする前に、この関数を呼び出すべきである。ITEM引数は、
     ‘(FUNCTION . ARGS)’という形式であること。ここで、FUNCTIONは引数リス
     トARGSで呼び出されるヘルプバッファーを再生成する関数である。コマン
     ド呼び出しがinteractiveに行われた場合、INTERACTIVE-P引数は非‘nil’で
     ある。この場合、‘*Help*’バッファーの‘Back’ボタンにたいするitemのス
     タックはクリアーされる。

   ‘help-buffer’、‘with-help-window’、‘help-setup-xref’の使用例は、*note
describe-symbols example::を参照してください。

 -- Macro: make-help-screen fname help-line help-text help-map
     このマクロは、提供するサブコマンドのリストを表示するプレフィックス
     キーのように振る舞う、FNAMEという名前のヘルプコマンドを定義する。

     呼び出された際、FNAMEはウィンドウ内にHELP-TEXTを表示してから、
     HELP-MAPに応じてキーシーケンスの読み取りと実行を行う。文字列
     HELP-TEXTは、HELP-MAP内で利用可能なバインディングを説明すべきである
     。

     コマンドFNAMEは、HELP-TEXTの表示をスクロールすることによる、自身の
     いくつかのイベントを処理するために定義される。FNAMEがこれらのスペシ
     ャルイベントのいずれかを読み取った際は、スクロールを行った後で他の
     イベントを読み取る。自身が処理する以外のイベントを読み取り、そのイ
     ベントがHELP-MAP内にバインディングを有す際は、そのキーのバインディ
     ングを実行した後リターンする。

     引数HELP-LINEは、HELP-MAP内の候補の1行要約であること。Emacsのカレン
     トバージョンでは、オプション‘three-step-help’を‘t’にセットした場合
     のみ、この引数が使用される。

     このマクロは、‘C-h C-h’にバインドされるコマンド‘help-for-help’内で
     使用される。

 -- User Option: three-step-help
     この変数が非‘nil’の場合、‘make-help-screen’で定義されたコマンドは、
     最初にエコーエリア内に自身のHELP-LINE文字列を表示し、ユーザーが再度
     ヘルプ文字をタイプした場合のみ、長いHELP-TEXT文字列を表示する。


File: elisp,  Node: Files,  Next: Backups and Auto-Saving,  Prev: Documentation,  Up: Top

24 Files
********

このチャプターでは検索、作成、閲覧、保存、その他ファイルとディレクトリー
にたいして機能する、Emacs Lispの関数および変数について説明します。その他
のいくつかのファイルに関する関数については*note Buffers::、バックアップ
とauto-save(自動保存)に関する関数については*note Backups and
Auto-Saving::で説明されています。

   ファイル関数の多くは、ファイル名であるような引数を1つ以上とります。こ
のファイル名は文字列です。これらの関数のほとんどは、関数
‘expand-file-name’を使用してファイル名引数を展開するので、‘~’は相対ファ
イル名(‘../’を含む)として正しく処理されます。*note File Name
Expansion::を参照してください。

   加えて、特定の“magic”ファイル名は特別に扱われます。たとえば、リモート
ファイル名が指定された際、Emacsは適切なプロトコルを通じて、ネットワーク
越しにファイルにアクセスします。*note Remote Files: (emacs)Remote
Files.を参照してください。この処理は非常に低いレベルで行われるので、注記
されたものを除き、このチャプターで説明するすべての関数が、ファイル名引数
としてmagicファイル名を受け入れると想定しても良いでしょう。詳細は、*Note
Magic File Names::を参照してください。

   ファイルI/O関数がLispエラーをシグナルする際、通常はコンディション
‘file-error’を使用します(*note Handling Errors::を参照)。ほとんどの場合
、オペレーティングシステムからロケール‘system-messages-locale’に応じたエ
ラーメッセージが取得され、コーディングシステム‘locale-coding-system’を使
用してデコードされます(*note Locales::を参照)。

* Menu:

* Visiting Files::           編集のためにEmacsバッファーにファイルを読み込む。
* Saving Buffers::           変更されたバッファーをファイルに書き戻す。
* Reading from Files::       ファイルをvisitせずにバッファーに読み込む。
* Writing to Files::         バッファーの一部から新たなファイルに書き込む。
* File Locks::               複数名による同時編集を防ぐためにファイルをlockまたはunlockする。
* Information about Files::  ファイルの存在、アクセス権、サイズのテスト。
* Changing Files::           ファイル名のリネームやパーミッションの変更など。
* File Names::               ファイル名の分解と展開。
* Contents of Directories::  ディレクトリーないのファイルリストの取得。
* Create/Delete Dirs::       ディレクトリーの作成と削除。
* Magic File Names::         特定のファイル名にたいする特別な処理。
* Format Conversion::        さまざまなファイルフォーマットへ/からの変換。


File: elisp,  Node: Visiting Files,  Next: Saving Buffers,  Up: Files

24.1 Visiting Files
===================

ファイルのvisitとは、ファイルをバッファーに読み込むことを意味します。一
度これを行うと、わたしたちはバッファーがファイルを“visit(訪問)”している
と言い、ファイルのことをバッファーの“visit”されたファイルと呼んでいます
。

   ファイルとバッファーは、2つの異なる事柄です。ファイルとは、(削除しな
い限り)コンピューター内に永続的に記録された情報です。一方バッファーとは
、編集セッションの終了(またはバッファーのkill)とともに消滅する、Emacs内
部の情報です。あるバッファーがファイルをvistしているとき、バッファーぬは
ファイルからコピーされた情報が含まれます。編集コマンドにより変更されるの
は、バッファー内のコピーです。バッファーへの変更によりファイルは変更され
ません。その変更を永続化させるには、バッファーを“保存(save)”しなければな
りません。これは変更されたバッファーのコンテンツをファイルにコピーして戻
すことを意味します。

   ファイルとバッファーは異なるにも関わらず、人はバッファーという意味で
ファイルを呼んだり、その逆を行うことが多々あります。実際のところ、“わた
しは間もなく同じ名前のファイルに保存するバッファーを編集している”ではな
く、“わたしはファイルを編集している”と言います。人間がこの違いを明示する
必要は、通常はありません。しかし、コンピュータープログラムに対処する際は
、この違いを心に留めておくのが良いでしょう。

* Menu:

* Visiting Functions::       visit用の通常のインターフェイス関数。
* Subroutines of Visiting::  通常のvisit関数が使用する低レベルのサブルーチン。


File: elisp,  Node: Visiting Functions,  Next: Subroutines of Visiting,  Up: Visiting Files

24.1.1 Functions for Visiting Files
-----------------------------------

このセクションでは、ファイルのvisitに通常使用される関数を説明します。歴
史的な理由により、これらの関数は‘visit-’ではなく、‘find-’で始まる名前を
もちます。バッファーをvisitしているファイルの名前へのアクセスや、visitさ
れたファイル名から既存のバッファーを見つける関数および変数については、
*note Buffer File Name::を参照してください。

   Lispプログラム内では、ファイル内容を見たいものの変更したくない場合は
テンポラリーバッファー(temporary buffer: 一時的なバッファー)で
‘insert-file-contents’を使用例するのが、もっとも高速な方法です。時間を要
するファイルのvisitは必要ありません。*note Reading from Files::を参照し
てください。

 -- Command: find-file filename &optional wildcards
     このコマンドは、ファイルFILENAMEをvisitしているバッファーを選択する
     。visitしている既存のバッファーがあればそのバッファーを使用し、なけ
     ればバッファーを新たに作成して、そのバッファーにファイルを読み込む
     。これはそのバッファーをリターンする。

     技術的な詳細を別とすると、‘find-file’関数のbodyは基本的には以下と等
     価である:

          (switch-to-buffer (find-file-noselect filename nil nil wildcards))

     (*note Switching Buffers::の‘switch-to-buffer’を参照されたい。)

     WILDCARDSが非‘nil’(これはinteractiveに呼び出された場合は常にtrueで
     ある)の場合、‘find-file’はFILENAME内のワイルドカード文字を展開して
     、マッチするすべてのファイルをvisitする。

     ‘find-file’がinteractiveに呼び出された際は、ミニバッファー内で
     FILENAMEの入力を求める。

 -- Command: find-file-literally filename
     このコマンドは、‘find-file’が行うようにFILENAMEをvisitするが、フォ
     ーマット変換(*note Format Conversion::を参照)、文字コード変換(*note
     Coding Systems::を参照)、EOL変換(*note End of line conversion:
     Coding System Basics.を参照)を何も行わない。ファイルをvisitしている
     バッファーはunibyteになり、ファイル名とは無関係にバッファーのメジャ
     ーモードはFundamentalモードになる。ファイル内で指定されたファイルロ
     ーカル変数(*note File Local Variables::を参照)は無視され、自動的な
     解凍と‘require-final-newline’によるファイル終端への改行追加(*note
     require-final-newline: Saving Buffers.を参照)も無効になる。

     Emacsがすでにリテラリー(literally: 文字通り、そのまま)でない方法で
     同じファイルをvisitしているバッファーをもつ場合、Emacsはその同じフ
     ァイルをリテラリーにvisitせず、単に既存のバッファーに切り替わること
     に注意されたい。あるファイルのコンテンツにたいして、確実にリテラリ
     ーにアクセスしたい場合は、テンポラリーバッファーを作成し、
     ‘insert-file-contents-literally’を使用してファイルのコンテンツを読
     み込むべきである(*note Reading from Files::を参照)。

 -- Function: find-file-noselect filename &optional nowarn rawfile
          wildcards
     この関数は、ファイルをvisitするすべての関数の要である。これは、ファ
     イルFILENAMEをvisitしているバッファーをリターンする。望むならそのバ
     ッファーをカレントにしたり、あるウィンドウ内に表示することができる
     だろうが、この関数はそれを行わない。

     関数は、既存のバッファーがあればそれをリターンし、なければ新たにバ
     ッファーを作成し、それにファイルを読み込む。‘find-file-noselect’が
     既存のバッファーを使用する際は、まずファイルがそのバッファーに最後
     にvisit、または保存したときから変更されていないことを検証する。ファ
     イルが変更されている場合、この関数は変更されたファイルを再読み込み
     するかどうかをユーザーに尋ねる。ユーザーが‘yes’と応えた場合、以前に
     行われたそのバッファー内での編集は失われる。

     ファイルの読み込みは、EOL変換、フォーマット変換(*note Format
     Conversion::を参照)を含む、ファイルコンテンツのデコードを要する
     (*note Coding Systems::を参照)。WILDCARDSが非‘nil’の場合、
     ‘find-file-noselect’はFILENAME内のワイルドカード文字を展開して、マ
     ッチするすべてのファイルをvisitする。

     この関数は、オプション引数NOWARNが‘nil’の場合は、さまざまな特殊ケー
     スにおいて、警告メッセージ(warning message)、および注意メッセージ
     (advisory message)を表示する。たとえば、関数がバッファーの作成を必
     要とし、かつFILENAMEという名前のファイルが存在しない場合は、エコー
     エリア内にメッセージ‘(New file)’を表示して、そのバッファーを空のま
     まに留める。

     ‘find-file-noselect’関数は通常、ファイルを読み込んだ後に
     ‘after-find-file’を呼び出す(*note Subroutines of Visiting::を参照
     )。この関数はバッファーのメジャーモードのセット、ローカル変数のパー
     ス、正にvisitしたファイルより新しいauto-saveファイルが存在する場合
     のユーザーへの警告を行い、‘find-file-hook’内の関数を実行することに
     より終了する。

     オプション引数RAWFILEが非‘nil’の場合、‘after-find-file’は呼び出され
     ず、失敗時に‘find-file-not-found-functions’は呼び出されない。さらに
     、非‘nil’値のRAWFILEは、コーディングシステム変換およびフォーマット
     変換を抑制する。

     ‘find-file-noselect’関数は、通常はファイルFILENAMEをvisitしているバ
     ッファーをリターンする。しかし、ワイルドカードが実際に使用、展開さ
     れた場合は、それらのファイルをvisitしているバッファーのリストをリタ
     ーンする。

          (find-file-noselect "/etc/fstab")
               ⇒ #<buffer fstab>

 -- Command: find-file-other-window filename &optional wildcards
     このコマンドは、ファイルFILENAMEをvisitしているバッファーを選択する
     が、選択されたウィンドウではない他のウィンドウでこれを行う。これは
     、別の既存ウィンドウを使用したり、ウィンドウを分割するかもしれない
     。*note Switching Buffers::lを参照のこと。

     このコマンドがinteractiveに呼び出された際は、FILENAMEの入力を求める
     。

 -- Command: find-file-read-only filename &optional wildcards
     このコマンドは、‘find-file’のようにファイルFILENAMEをvisitしている
     バッファーを選択するが、そのバッファーを読み取り専用(read-only)とマ
     ークする。関連する関数および変数については、*note Read Only
     Buffers::を参照のこと。

     このコマンドがinteractiveに呼び出された際は、FILENAMEの入力を求める
     。

 -- User Option: find-file-wildcards
     この変数が非‘nil’の場合、各種‘find-file’コマンドはワイルドカード文
     字をチェックして、それらにマッチするすべてのファイルをvisitする
     (interactiveに呼び出されたとき、またはWILDCARDS引数が非‘nil’のとき
     )。このオプションが‘nil’の場合、‘find-file’コマンドはそれらの
     WILDCARDS引数を無視して、ワイルドカード文字を特別に扱うことは決して
     ない。

 -- User Option: find-file-hook
     この変数の値は、ファイルがvisitされた後に呼び出される、関数のリスト
     である。ファイルのローカル変数指定は、(もしあれば)このフックが実行
     される前に処理されるだろう。フック関数実行時は、そのファイルを
     visitしているバッファーがカレントになる。

     この変数はノーマルフックである。*note Hooks::を参照のこと。

 -- Variable: find-file-not-found-functions
     この変数の値は、‘find-file’または‘find-file-noselect’が存在しないフ
     ァイル名を受け取った際に呼び出される、関数のリストである。存在しな
     いファイルを検知すると、‘find-file-noselect’は直ちにこれらの関数を
     呼び出す。これらのうち、いずれかが非‘nil’をリターンするまで、リスト
     の順に関数を呼び出す。‘buffer-file-name’はすでにセットアップ済みで
     ある。

     関数の値が使用され、多くの場合いくつかの関数だけが呼び出されるので
     、これはノーマルフックではない。

 -- Variable: find-file-literally
     このバッファーローカル変数が非‘nil’値にセットされた場合、
     ‘save-buffer’はあたかもそのバッファーがリテラリー、つまり何の変換も
     行わずにファイルをvisitしていたかのように振る舞う。コマンド
     ‘find-file-literally’は、この変数のローカル値をセットするが、その他
     の等価な関数およびコマンドも、たとえばファイル終端への改行の自動追
     加を避けるために、同様にこれを行うことができる。この変数は恒久的に
     ローカルなので、メジャーモードの変更により影響を受けない。


File: elisp,  Node: Subroutines of Visiting,  Prev: Visiting Functions,  Up: Visiting Files

24.1.2 Subroutines of Visiting
------------------------------

‘find-file-noselect’関数は、2つの重要なサブルーチン
‘create-file-buffer’および‘after-find-file’を使用します。これらはユーザ
ーのLispコードでも役に立つことがあります。このセクションでは、それらの使
い方について説明します。

 -- Function: create-file-buffer filename
     この関数は、FILENAMEのvisitにたいして適切な名前のバッファーを作成し
     て、それをリターンする。これはFILENAME(ディレクトリー含まず)の名前
     がフリーならバッファー名にそれを使用し、フリーでなければ未使用の名
     前を取得するために‘<2>’のような文字列を付加する。*note Creating
     Buffers::も参照のこと。‘uniquify’ライブラリーは、この関数の結果に影
     響を与えることに注意されたい。*note (emacs)Uniquify::を参照のこと。

     *注意してください:* ‘create-file-buffer’はファイルに新たなバッファ
     ーを_関連付けません_。バッファーの選択もせず、さらにデフォルトのメ
     ジャーモードも使用しません。

          (create-file-buffer "foo")
               ⇒ #<buffer foo>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<2>>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<3>>

     この関数は、‘find-file-noselect’により使用される。この関数自身は
     ‘generate-new-buffer’を使用する(*note Creating Buffers::を参照)。

 -- Function: after-find-file &optional error warn noauto
          after-find-file-from-revert-buffer nomodes
     この関数は、バッファーのメジャーモードをセットして、ローカル変数を
     パースする(*note Auto Major Mode::を参照)。これは
     ‘find-file-noselect’、およびデフォルトのリバート関数(*note
     Reverting::を参照)により呼び出される。

     ファイルが存在しない理由によりファイルの読み込みがエラーを受け取る
     が、ディレクトリーは存在する場合、呼び出し側はERRORにたいして非
     ‘nil’値を綿すべきである。この場合、‘after-find-file’は警告‘(New
     file)’を発する。より深刻なエラーにたいしては、呼び出し側は通常は
     ‘after-find-file’を呼び出すべきでない。

     WARNが非‘nil’の場合、もしauto-saveファイルが存在し、かつそれが
     visitされているファイルより新しいなら、この関数は警告を発する。

     NOAUTOが非‘nil’の場合、それはAuto-Saveモードを有効、または無効にし
     ないことを告げる。以前にAuto-Saveモードが有効ならば、有効のまま留ま
     る。

     AFTER-FIND-FILE-FROM-REVERT-BUFFERが非‘nil’の場合、それはこの関数が
     ‘revert-buffer’から呼び出されたことを意味する。これに直接的な効果は
     ないが、モード関数およびフック関数の中には、この変数の値をチェック
     するものがいくつかある。

     NOMODESが非‘nil’の場合、それはバッファーのメジャーモードを変更せず
     、ファイル内のローカル変数指定を処理せず、‘find-file-hook’を実行し
     ないことを意味する。この機能は、あるケースにおいて‘revert-buffer’に
     より使用される。

     ‘after-find-file’が最後に行うのは、リスト‘find-file-hook’内のすべて
     の関数を呼び出すことである。


File: elisp,  Node: Saving Buffers,  Next: Reading from Files,  Prev: Visiting Files,  Up: Files

24.2 Saving Buffers
===================

Emacs内でファイルを編集とき、実際にはそのファイルをvisitしているバッファ
ーにたいして編集を行っています。つまり、ファイルのコンテンツをバッファー
にコピーして、編集しているのはそのコピーなのです。そのバッファーにを変更
しても、バッファーを“保存(save)”するまでファイルは変更されません。保存と
は、バッファーのコンテンツをファイルにコピーすることを意味します。

 -- Command: save-buffer &optional backup-option
     この関数は、バッファーが最後にvisitされたとき、または保存されたとき
     から変更されている場合は、カレントバッファーのコンテンツを、バッフ
     ァーによりvisitされているファイルに保存し、変更されていなければ何も
     行わない。

     ‘save-buffer’は、バックアップファイルの作成に責任を負う。通常、
     BACKUP-OPTIONは‘nil’であり、‘save-buffer’はファイルをvisit以降、そ
     れが最初の保存の場合のみバックアップファイルを作成する。
     BACKUP-OPTIONにたいする他の値は、別の条件によるバックアップファイル
     作成を要求する:

        • 引数4は1つの‘C-u’を、引数64は3つの‘C-u’を示すので、
          ‘save-buffer’はバッファーの次回保存時にこのバージョンのファイ
          ルがバックアップされるようマークする。

        • 引数16は2つの‘C-u’を、引数64は3つの‘C-u’を示すので、
          ‘save-buffer’関数はそれを保存する前に、前バージョンのファイル
          を無条件にバックアップする。

        • 引数0は、無条件にバックアップファイルを何も_作成しない_。

 -- Command: save-some-buffers &optional save-silently-p pred
     このコマンドは、ファイルをvisitしている変更されたバッファーのいくつ
     かを保存する。これは通常、各バッファーごとにユーザーに確認を求める
     。しかし、SAVE-SILENTLY-Pが非‘nil’の場合は、ユーザーに質問せずにフ
     ァイルをvisitしているすべてのバッファーを保存する。

     オプション引数PREDは、どのバッファーで確認を求めるか(または
     SAVE-SILENTLY-Pが非‘nil’の場合は、どのバッファーで確認せずに保存す
     るか)を制御する。これが‘nil’の場合、それはファイルをvisitしているバ
     ッファーにたいしてのみ確認を求めることを意味する。‘t’の場合、それは
     、‘buffer-offer-save’のバッファーローカル値が‘nil’であるような、非
     ファイルバッファー以外の特定のバッファーの保存も提案することを意味
     する(*note Killing Buffers::を参照)。ユーザーが、非ファイルバッファ
     ーの保存にたいして‘yes’と応えると、保存に使用するファイル名の指定を
     求める。‘save-buffers-kill-emacs’関数は、PREDにたいして値‘t’を渡す
     。

     PREDが‘t’と‘nil’のどちらでもない場合、それは引数なしの関数であるこ
     と。その関数は、そのバッファーの保存するを提案するか否かを決定する
     ために、バッファーごとに呼び出されるだろう。これが特定のバッファー
     で非‘nil’値をリターンした場合は、バッファーの保存を提案することを意
     味する。

 -- Command: write-file filename &optional confirm
     この関数は、カレントバッファーをファイルFILENAMEに書き込み、バッフ
     ァーがそのファイルをvisitしていることにして、未変更とマークする。次
     にFILENAMEにもとづいてバッファー名をリネームする。バッファー名を一
     意にするため、必要なら‘<2>’のような文字列を付加する。処理のほとんど
     は、‘set-visited-file-name’(*note Buffer File Name::を参照)、および
     ‘save-buffer’を呼び出すことにより行われる。

     CONFIRMが非‘nil’の場合、それは既存のファイルを上書きする前に確認を
     求めることを意味する。ユーザーがプレフィックス引数を与えない場合、
     interactiveに確認が求められる。

     FILENAMEが既存のディレクトリーであったり、既存のディレクトリーへの
     シンボリックリンクの場合、‘write-file’はディレクトリーFILENAME内で
     visitされているファイルの名前を使用する。そのバッファーがファイルを
     visitしていない場合は、かわりにバッファーの名前を使用する。

   バッファーの保存により、複数のフックが実行される。これはフォーマット
変換も処理する(*note Format Conversion::を参照)。

 -- Variable: write-file-functions
     この変数の値は、バッファーをvisitされているファイルに書き出す前に呼
     び出される、関数のリストである。それらのうちのいずれかが非‘nil’をリ
     ターンした場合、そのファイルは書き込み済みだと判断され、残りの関数
     は呼び出されないし、ファイルを書き込むための通常のコードも実行され
     ない。

     ‘write-file-functions’内の関数が非‘nil’をリターンした場合、(それが
     適切であれば)その関数はファイルをバックアップする責任を負う。これを
     行うには、以下のコードを実行する:

          (or buffer-backed-up (backup-buffer))

     ‘backup-buffer’によりリターンされるファイルモードの値を保存して、
     (もし非‘nil’なら)書き込むファイルのモードビットをセットしたいと思う
     かもしれない。これは正に‘save-buffer’が通常行うことである。*note
     Making Backup Files: Making Backups.を参照のこと。

     ‘write-file-functions’内のフック関数は、データのエンコード(が望まし
     ければ)にも責任を負う。これらは適切なコーディングシステムと改行規則
     (*note Lisp and Coding Systems::を参照)を選択してエンコード(*note
     Explicit Encoding::を参照)を処理し、使用されていたコーディングシス
     テム(*note Encoding and I/O::を参照)を‘last-coding-system-used’にセ
     ットしなければならない。

     バッファー内でこのフックをローカルにセットした場合、バッファーはそ
     のファイル、またはバッファーのコンテンツを取得したファイルに類する
     ものに関連付けられる。このようにして、変数は恒久的にローカルである
     とマークされるので、メジャーモードの変更がバッファーローカルな値を
     変更することはない。その一方で、‘set-visited-file-name’を呼び出すこ
     とにより、変数はリセットされるだろう。これを望まない場合は、かわり
     に‘write-contents-functions’を使用したいと思うだろう。

     たとえこれがノーマルフックでないとしても、このリストを操作するため
     に‘add-hook’および‘remove-hook’を使用することはできる。*note
     Hooks::を参照のこと。

 -- Variable: write-contents-functions
     これは正に‘write-file-functions’と同様に機能するが、こちらはvisitし
     ている特定のファイルやファイルの場所ではなく、バッファーのコンテン
     ツに関連するフックを意図している。そのようなフックは、この変数にた
     いするバッファーローカルなバインディングとして、通常はメジャーモー
     ドにより作成される。この変数は、セットされた際は、常に自動的にバッ
     ファーローカルになる。新たなメジャーモードへの切り替えは、常にこの
     変数をリセットするが、‘set-visited-file-name’の呼び出しではリセット
     されない。

     このフック内の関数のいずれかが非‘nil’をリターンした場合、そのファイ
     ルはすでに書き込み済みとみなされ、残りの関数は呼び出されず、
     ‘write-file-functions’内の関数も呼び出されない。

 -- User Option: before-save-hook
     このノーマルフックは、visitしているファイルにバッファーが保存される
     前に実行される。保存が通常の方法で行われるか、あるいは上述のフック
     のいずれかで行われたかは問題にしない。たとえば、‘copyright.el’プロ
     グラムは、ファイルの保存において、それの著作権表示が今年であること
     を確認するために、このフックを使用する。

 -- User Option: after-save-hook
     このノーマルフックは、visitしているファイルにバッファーを保存した後
     に実行される。このフックの使用例の1つは、Fast Lockモードにある。こ
     のモードは、キャッシュファイルにハイライト情報を保存するために、こ
     のフックを使用している。

 -- User Option: file-precious-flag
     この変数が非‘nil’の場合、‘save-buffer’は保存ファイルがもつ名前のか
     わりに、一時的な名前で新たなファイルに書き込み、エラーがないと明確
     になった後にファイルを意図する名前にリネームすることにより、保存中
     のI/Oエラーから防御する。この手順は、無効なファイルが原因となるディ
     スク容量逼迫のような問題を防ぐ。

     副作用として、バックアップ作成にコピーが必要になる。*note Rename or
     Copy::を参照のこと。しかし同時に、この高価なファイル保存により、保
     存したファイルと他のファイル名との間のすべてのハードリンクは切断さ
     れる。

     いくつかのモードは、特定のバッファーにおいて、この変数に非‘nil’のバ
     ッファーローカル値を与える。

 -- User Option: require-final-newline
     この変数は、ファイルが改行で_終わらない_ように書き込まれるかどうか
     を決定する。変数の値が‘t’の場合、‘save-buffer’はバッファーの終端に
     改行がなければ暗黙理に改行を追加する。値が‘visit’の場合、Emacsはフ
     ァイルをvisitした直後に不足している改行を追加する。値が
     ‘visit-save’の場合、Emacsはvisitと保存の両方のタイミングで、不足し
     ている改行を追加する。その他の非‘nil’値にたいしては、そのようなケー
     スが生じるたびに、改行を追加するかどうか、‘save-buffer’がユーザーに
     尋ねる。

     変数の値が‘nil’の場合、‘save-buffer’は改行を追加しない。デフォルト
     値は‘nil’だが、特定のバッファーでこれを‘t’にセットするメジャーモー
     ドも少数存在する。

   *note Buffer File Name::の関数‘set-visited-file-name’も参照されたい。


File: elisp,  Node: Reading from Files,  Next: Writing to Files,  Prev: Saving Buffers,  Up: Files

24.3 Reading from Files
=======================

ファイルのコンテンツをバッファーにコピーするためには、関数
‘insert-file-contents’を使用しします(マークをセットするので、Lispプログ
ラム内でコマンド‘insert-file’は使用してはならない)。

 -- Function: insert-file-contents filename &optional visit beg end
          replace
     この関数は、ファイルFILENAMEのコンテンツを、カレントバッファーのポ
     イントの後に挿入する。これは絶対ファイル名と、挿入だれたデータの長
     さからなるリストをリターンする。FILENAMEが読み取り可能なファイルの
     名前でない場合は、エラーがシグナルされる。

     この関数は、定義されたファイルフォーマットに照らしてファイルのコン
     テンツをチェックして、適切ならそのコンテンツの変換、およびリスト
     ‘after-insert-file-functions’内の関数の呼び出しも行う。*note Format
     Conversion::を参照のこと。通常は、リスト
     ‘after-insert-file-functions’内のいずれかの関数が、EOL変換を含むフ
     ァイルコンテンツのデコードに使用される、コーディングシステム(*note
     Coding Systems::を参照)を判断する。しかし、ファイルにnullバイトが含
     まれる場合、デフォルトではコード変換なしでvisitされる。*note
     inhibit-null-byte-detection: Lisp and Coding Systems.を参照のこと。

     VISITが非‘nil’の場合、この関数は追加でそのバッファーを未変更とマー
     クして、そのバッファーのさまざまなフィールドをセットアップして、バ
     ッファーがファイルFILENAMEをvisitしているようにする。これらのフィー
     ルドにはバッファーがvisitしたファイルの名前、最終保存したファイルの
     modtimeが含まれる。これらの機能は‘find-file-noselect’により使用され
     、恐らくあなた自身が使用するべきではない。

     BEGおよびENDが非‘nil’の場合、それらはファイル挿入範囲を指定する、バ
     イトオフセット数値であること。この場合、VISITは‘nil’でなければなら
     ない。たとえば、

          (insert-file-contents filename nil 0 500)

     これはファイルの先頭500文字(バイト)を挿入する。

     引数REPLACEが非‘nil’の場合、それはバッファーのコンテンツ(実際にはア
     クセス可能な範囲)を、ファイルのコンテンツで置き換えることを意味する
     。これは単にバッファーのコンテンツを削除してファイル全体を挿入する
     より優る。なぜなら、(1)マーカー位置を維持し、(2)undoリストに配すデ
     ータも少ないからである。

     REPLACEとVISITが‘nil’であれば、‘insert-file-contents’で(FIFOやI/Oデ
     バイスのような)スペシャルファイルの読み取りが可能である。

 -- Function: insert-file-contents-literally filename &optional visit
          beg end replace
     この関数は‘insert-file-contents’のように機能するが、
     ‘find-file-hook’を実行せず、フォーマットのデコード、文字コード変換
     、自動解凍、...などを行わない点が異なる。

   他のプログラムがファイルを読めるように、他のプロセスにファイル名を渡
したい場合は、関数‘file-local-copy’を使用します。*note Magic File
Names::を参照してください。


File: elisp,  Node: Writing to Files,  Next: File Locks,  Prev: Reading from Files,  Up: Files

24.4 Writing to Files
=====================

関数‘append-to-file’および‘write-region’を使用することにより、ディスク上
のファイルに直接、バッファーのコンテンツ、またはバッファーの一部を書き込
むことができます。visitされているファイルに書き込むために、これらの関数
を使用しないでください。これにより、visitにたいするメカニズムが混乱する
かもしれません。

 -- Command: append-to-file start end filename
     この関数は、カレントバッファー内で、STARTとENDによるリージョンのコ
     ンテンツを、ファイルFILENAMEの終端に追加する。そのファイルが存在し
     ない場合は作成する。この関数は‘nil’をリターンする。

     FILENAMEに書込不可能なファイル、またはファイルを作成不可なディレク
     トリー内の存在しないファイルを指定した場合は、エラーがシグナルされ
     る。

     Lispから呼び出した場合、この関数は以下と完全に等価である:

          (write-region start end filename t)

 -- Command: write-region start end filename &optional append visit
          lockname mustbenew
     この関数は、カレントバッファー内のSTARTとENDで区切られたリージョン
     を、FILENAMEで指定されたファイルに書き込む。

     STARTが‘nil’の場合、このコマンドはバッファーのコンテンツ全体(アクセ
     ス可能な範囲だけでは_ない_)をファイルに書き込み、ENDは無視する。

     STARTが文字列の場合、‘write-region’はバッファーのテキストではなく、
     その文字列を追加する。その場合、ENDは無視される。

     APPENDが非‘nil’の場合は、指定されたテキストが(もしあれば)既存のファ
     イルコンテンツに追加される。APPENDが数字の場合、‘write-region’はフ
     ァイル開始位置からそのバイトオフセットをseekして、データをそこに書
     き込む。

     MUSTBENEWが非‘nil’の場合、‘write-region’はもしFILENAMEが既存ファイ
     ルの名前なら確認を求める。MUSTBENEWがシンボル‘excl’なら、ファイルが
     すでに存在する場合は‘write-region’は確認を求めるかわりに、エラー
     ‘file-already-exists’をシグナルする。

     MUSTBENEWが‘excl’のときは、存在するファイルのテストに特別なシステム
     機能を使用する。少なくともローカルディスク上のファイルにたいしては
     、Emacsがファイルを作成する前に、Emacsに通知せずに他のプログラムが
     同じ名前のファイルを作成することはありえない。

     VISITが‘t’の場合、Emacsはバッファーとファイルの関連付けを設定し、そ
     のバッファーがそのファイルをvictimする。また、カレントバッファーに
     たいする最終ファイル変更日時にFILENAMEをセットして、そのバッファー
     を未変更としてマークする。この機能は‘save-buffer’により使用されるが
     、おそらくあなた自身が使用するべきではないだろう。

     VISITが文字列の場合、それはvisitするファイルの名前を指定する。この
     方法を使えば、そのバッファーが別のファイルをvisitしていると記録しつ
     つ、１つのファイル(FILENAME)にデータを書き込むことができる。引数
     VISITは、エコーエリアに使用される他に、ファイルのロックにも使用され
     、VISITが‘buffer-file-name’に格納される。この機能は、
     ‘file-precious-flag’の実装に使用される。自分が何をしているか本当に
     わかっているのでなければ、これを使用してはならない。

     オプション引数LOCKNAMEが非‘nil’の場合、それはロックとアンロックの目
     的に使用する、FILENAMEおよびVISITをオーバーライドするファイル名を指
     定する。

     関数‘write-region’は、書き込むデータを‘buffer-file-format’により指
     定される、適切なファイルフォーマットに変換しするとともに、リスト
     ‘write-region-annotate-functions’内の関数の呼び出しも行う。*note
     Format Conversion::を参照のこと。

     通常、‘write-region’はエコーエリア内にメッセージ‘Wrote FILENAME’を
     表示する。VISITが‘t’、‘nil’、文字列のいずれでもない場合、このメッセ
     ージは抑制される。この機能は、内部的な目的のために、ユーザーが知る
     必要がないファイルを使用する場合に有用である。

 -- Macro: with-temp-file file body...
     ‘with-temp-file’マクロは、一時バッファー(temporary buffer)をカレン
     トバッファーとしてBODYフォームを評価して、最後にそのバッファーのコ
     ンテンツをFILEに書き込む。これは終了時に一時バッファーをkillして、
     ‘with-temp-file’フォームの前にカレントだったバッファーをリストアす
     る。その後、BODY内の最後のフォームの値をリターンする。

     ‘throw’やエラーによる異常なexit(abnormal exit)でも、カレントバッフ
     ァーはリストアされる(*note Nonlocal Exits::を参照)。

     *note The Current Buffer: Definition of with-temp-buffer.の
     ‘with-temp-buffer’も参照のこと。


File: elisp,  Node: File Locks,  Next: Information about Files,  Prev: Writing to Files,  Up: Files

24.5 File Locks
===============

2人のユーザーが同時に同じファイルを編集する際、おそらく彼らは互いに干渉
しあうでしょう。Emacsは、ファイルが変更される際に“ファイルロック(file
lock)”を記録することにより、このような状況の発生を防ぎます。そして、
Emacsは他のEmacsジョブにロックされているファイルをvisitしているバッファ
ーへの変更の最初の試みを検知して、ユーザーに何を行うか尋ねます。このファ
イルロックの実態は、編集中のファイルと同じディレクトリーに格納される、特
別な名前をもつシンボリックリンクです(シンボリックリンクをサポートしない
ファイルシステムでは、通常のファイルが使用される)。

   ファイルのアクセスにNFSを使用する際には、可能性は小さいものの、他のユ
ーザーと同じファイルを“同時”にロックするかもしれません。これが発生した場
合、2人のユーザーが同時にファイルを変更することが可能になりますが、それ
でもEmacsは2番目に保存するユーザーにたいして警告を発するでしょう。たファ
イルをvisitしているバッファーで、ディスク上でファイル変更の検知により、
ある種の同時編集を捕捉できます。*note Modification Time::を参照してくだ
さい。

 -- Function: file-locked-p filename
     この関数は、ファイルFILENAMEがロックされていなければ‘nil’をリターン
     する。このEmacsプロセスによりロックされている場合は‘t’をリターンし
     、他のEmacsジョブによりロックされている場合はロックしたユーザーの名
     前をリターンする。

          (file-locked-p "foo")
               ⇒ nil

 -- Function: lock-buffer &optional filename
     この関数は、カレントバッファーが変更されている場合は、ファイル
     FILENAMEをロックする。引数FILENAMEのデフォルトは、カレントバッファ
     ーがvisitしているファイルである。カレントバッファーがファイルを
     visitしていない、またはバッファーが変更されていない、またはシステム
     がロックをサポートしない場合は、何もしない。

 -- Function: unlock-buffer
     この関数は、カレントバッファーが変更されている場合は、バッファーに
     よりvisitされているファイルをアンロックする。バッファーが変更されて
     いない場合は、そのファイルはロックされてはならないので、この関数は
     何もしない。カレントバッファーがファイルをvisitしていない、またはシ
     ステムがロックをサポートしない場合、この関数は何もしない。

 -- User Option: create-lockfiles
     この変数が‘nil’の場合、Emacsはファイルをロックしない。

 -- Function: ask-user-about-lock file other-user
     この関数は、ユーザーがFILEの変更を試みたが、それが名前OTHER-USERの
     ユーザーにロックされていたとき呼び出される。この関数のデフォルト定
     義は、何を行うかユーザーに尋ねる関数である。この関数がリターンする
     値は、Emacsが次に何を行うかを決定する:

        • 値‘t’は、そのファイルのロックを奪うことを意味する。その場合、
          OTHER-USERはロックを失い、このユーザーがファイルを編集すること
          ができる。

        • 値‘nil’は、ロックを無視して、とにかくユーザーがファイルを編集
          できるようにすることを意味する。

        • この関数は、かわりにエラー‘file-locked’をシグナルする。この場
          合、ユーザーが行おうとしていた変更は行われない。

          このエラーにたいするエラーメッセージは、以下のようになる:

               error→ File is locked: FILE OTHER-USER

          ここで、‘file’はファイル名、OTHER-USERはそのファイルのロックを
          所有するユーザーの名前である。

     望むなら、他の方法で判定を行う独自のバージョンで、
     ‘ask-user-about-lock’関数を置き換えることができる。


File: elisp,  Node: Information about Files,  Next: Changing Files,  Prev: File Locks,  Up: Files

24.6 Information about Files
============================

このセクションでは、ファイル(またはディレクトリーやシンボリックリンク)に
関して、ファイルが読み込み可能か、書き込み可能か、あるいはファイルのサイ
ズなｍのような、さまざまなタイプの情報を取得する関数を説明します。これら
の関数はすべて、引数にファイルの名前を取ります。注記した場合を除き、これ
らの引数には既存のファイルを指定する必要があり、ファイルが存在しない場合
はエラーをシグナルします。

   スペースで終わるファイル名には気をつけてください。いくつかのファイル
システム(特にMS-Windows)では、ファイル名の末尾の空白文字は、暗黙かつ自動
的に無視されます。

* Menu:

* Testing Accessibility::    そのファイルは読み取り可能か？書き込み可能か？
* Kinds of Files::           それはディレクトリー？それともシンボリックリンク？
* Truenames::                シンボリックリンクが行き着くファイル名。
* File Attributes::          ファイルのサイズ？更新日時など。
* Extended Attributes::      アクセス制御にたいするファイル属性の拡張。
* Locating Files::           標準的な場所でファイルを見つける方法。


File: elisp,  Node: Testing Accessibility,  Next: Kinds of Files,  Up: Information about Files

24.6.1 Testing Accessibility
----------------------------

以下の関数は、あるファイルを読み取り、書き込み、実行するためのパーミッシ
ョンをテストします。明示しない限り、これらの関数はファイル名引数にたいす
るシンボリックリンクを、すべてのレベル(ファイル自身のレベルおよび親ディ
レクトリーのレベル)において再帰的にフォローします。

   いくつかのオペレーティングシステムでは、ACL(Access Control Lists: ア
クセス制御リスト)のような機構を通じて、より複雑なアクセスパーミッション
セットが指定できます。それらのパーミッションにたいする問い合わせやセット
の方法については、*note Extended Attributes::を参照してください。

 -- Function: file-exists-p filename
     この関数は、ファイル名FILENAMEが存在しているようなら‘t’をリターンす
     る。これは、そのファイルが読み取り可能である必要はなく、ファイルの
     属性を調べることが可能なこと意味する(UnixおよびGNU/Linuではなく、そ
     のファイルが存在し、かつそのファイルを含むディレクトリーの実行パー
     ミッションをもつ場合に‘t’となり、そのファイル自体のパーミッションは
     無関係である)。

     ファイルが存在しない、またはACLポリシーがファイル属性を調べることを
     禁止する場合、この関数は‘nil’をリターンする。

     ディレクトリーはファイルなので、ディレクトリー名が与えられた場合、
     ‘file-exists-p’は‘t’をリターンする。しかし、シンボリックリンクは特
     別に扱われる。‘file-exists-p’はターゲットファイルが存在する場合のみ
     、シンボリックリンクにたいして‘t’をリターンする。

 -- Function: file-readable-p filename
     この関数は、FILENAMEという名前のファイルが存在し、それを読み取るこ
     とが可能な場合は‘t’をリターンする。それ以外は‘nil’をリターンする。

 -- Function: file-executable-p filename
     この関数は、FILENAMEという名前のファイルが存在し、それを実行するこ
     とが可能な場合は‘t’をリターンする。それ以外は‘nil’をリターンする。
     UnixおよびGNU/Linuxシステムでは、そのファイルがディレクトリーの場合
     、実行パーミッションはディレクトリー内のファイルの存在と属性をチェ
     ックでき、ファイルのモードが許せばオープンできることを意味する。

 -- Function: file-writable-p filename
     この関数は、FILENAMEという名前のファイルに書き込み可能、または作成
     可能可能な場合は‘t’をリターンする。それ以外は‘nil’をリターンする。
     ファイルが存在し、それに書き込むことができるなら、ファイルは書き込
     み可能である。ファイルが存在せず、指定されたディレクトリーが存在し
     て、そのディレクトリーに書き込むことができるなら、書き込み可能であ
     る。

     以下の例では、‘foo’は親ディレクトリーが存在しないので、たとえユーザ
     ーがそのディレクトリーを作成可能であっても、ファイルは書き込み可能
     ではない。

          (file-writable-p "~/no-such-dir/foo")
               ⇒ nil

 -- Function: file-accessible-directory-p dirname
     この関数は、ファイルとしての名前がDIRNAMEであるようなディレクトリー
     内にある既存のファイルをオープンするパーミッションをもつ場合は、
     ‘t’をリターンする。それ以外(またはそのようなディレクトリーが存在し
     ない場合)は‘nil’をリターンする。DIRNAMEの値はディレクトリー名
     (‘/foo/’など)、または名前がディレクトリー(最後のスラッシュがない
     ‘/foo’など)であるようなファイルである。

     たとえば、以下では‘/foo/’内の任意のファイルを読み取る試みは、エラー
     になると推測される:

          (file-accessible-directory-p "/foo")
               ⇒ nil

 -- Function: access-file filename string
     この関数は、読み取り用にファイルFILENAMEをオープンして、クローズし
     た後に‘nil’をリターンする。しかし、オープンに失敗した場合は、
     STRINGをエラーメッセージのテキストに使用して、エラーをシグナルする
     。

 -- Function: file-ownership-preserved-p filename &optional group
     この関数は、ファイルFILENAMEを削除して、それを新たに作成しても、そ
     のファイルの所有者が変更されずに維持される場合は、‘t’をリターンする
     。これは、存在しないファイルにたいしても‘t’をリターンする。

     オプション引数GROUPが非‘nil’の場合、この関数はファイルのグループが
     変更されないこともチェックする。

     FILENAMEがシンボリックリンクの場合は、ここで述べる他の関数と異なり
     、‘file-ownership-preserved-p’はFILENAMEをターゲットで_置き換えない
     _。しかし、この関数は親ディレクトリーのすべての階層において、シンボ
     リックリンクを再帰的にフォローする(follow: 辿る)。

 -- Function: file-modes filename
     この関数は、FILENAMEの“モードビット(mode bits)”をリターンする。これ
     は読み取り、書き込み、実行パーミッションを要約する整数である。
     FILENAMEでのシンボリックリンクは、すべての階層において再帰的にフォ
     ローされる。ファイルが存在しない場合のリターン値は‘nil’である。

     モードビットの説明は、*Note (coreutils)File permissions::を参照のこ
     と。たとえば最下位ビットが1なら、そのファイルは実行可能、2ビット目
     が1なら書き込み可能、...となる。設定できる最大の値は4095(8進の
     7777)であり、これはすべてのユーザーが読み取り、書き込み、実行のパー
     ミッションをもち、他のユーザーとグループにたいしてSUIDビット、およ
     びstickyビットがセットされる。

     これらのパーミッションのセットに使用される‘set-file-modes’関数につ
     いては、*note Changing Files::を参照のこと。

          (file-modes "~/junk/diffs")
               ⇒ 492               ; 10進整数
          (format "%o" 492)
               ⇒ "754"             ; 8進に変換した値

          (set-file-modes "~/junk/diffs" #o666)
               ⇒ nil

          $ ls -l diffs
          -rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs

     *MS-DOSにたいする注意:* MS-DOSでは、“実行可能”を表すようなファイル
     のモードビットは存在しない。そのため、‘file-modes’はファイル名が
     ‘.com’、‘.bat’、‘.exe’などのような標準的な実行可能な拡張子のいずれ
     かで終わる場合は、ファイルを実行可能であると判断する。Unix標準の
     ‘#!’署名で始まるshellスクリプトやPerlスクリプトも、実行可能と判断さ
     れる。Unixとの互換性のために、ディレクトリーも実行可能と報告される
     。‘file-attributes’(*note File Attributes::を参照)も、これらの慣習
     にしたがう。


File: elisp,  Node: Kinds of Files,  Next: Truenames,  Prev: Testing Accessibility,  Up: Information about Files

24.6.2 Distinguishing Kinds of Files
------------------------------------

このセクションでは、ディレクトリー、シンボリックリンク、および通常ファイ
ルのような、さまざまな種類のファイルを区別する方法を説明します。

 -- Function: file-symlink-p filename
     ファイルFILENAMEがシンボリックリンクの場合、‘file-symlink-p’関数は
     (非再帰的な)リンクターゲットを文字列としてリターンする(リンクターゲ
     ット文字列は、そのターゲットの完全な絶対ファイル名である必要はない
     。リンクが指すのが完全なファイル名か判断するのは、簡単な処理ではな
     い。以下を参照されたい)。FILENAMEのディレクトリー部分(leading
     directory)にシンボリックリンクが含まれる場合、この関数はそれらを再
     帰的にフォローする。

     ファイルFILENAMEがシンボリックリンクではない、または存在しない場合
     、‘file-symlink-p’は‘nil’をリターンする。

     この関数の使用例をいくつか示す:

          (file-symlink-p "not-a-symlink")
               ⇒ nil
          (file-symlink-p "sym-link")
               ⇒ "not-a-symlink"
          (file-symlink-p "sym-link2")
               ⇒ "sym-link"
          (file-symlink-p "/bin")
               ⇒ "/pub/bin"

     3つ目の例では、関数は‘sym-link’をリターンするものの、たとえそれ自体
     がシンボリックリンクであっても、リンク先の解決を行わないことに注意
     されたい。これが上述した“非再帰的(non-recursive)”の意味するところで
     あり、シンボリックリンクをフォローする処理は、そのリンクターゲット
     自体がリンクの場合、再帰的には行われない。

     この関数がリターンするのは、そのシンボリックリンクに何が記録されて
     いるかを示す文字列であり、それにはディレクトリー部分が含まれていて
     も、いなくても構わない。この関数は完全修飾されたファイル名を生成す
     るためにリンクターゲットを_展開しない_し、リンクターゲットが絶対フ
     ァイル名でなければ、(もしあっても)FILENAME引数のディレクトリー部分
     は使用しない。以下に例を示す:

          (file-symlink-p "/foo/bar/baz")
               ⇒ "some-file"

     ここでは、たとえ与えられた‘/foo/bar/baz’が完全修飾されたファイル名
     であるにも関わらず、その結果は異なり、実際には何のディレクトリー部
     分ももたない。‘some-file’自体がシンボリックリンクかもしれないので、
     単にその前に先行ディレクトリーを追加することはできず、絶対ファイル
     名を生成するために、単に‘expand-file-name’(*note File Name
     Expansion::を参照)を使用することもできないからである。

     この理由により、あるファイルがシンボリックリンクか否かという単一の
     事実よりも多くを判定する必要がある場合に、この関数が有用であること
     は稀である。実際にリンクターゲットのファイル名が必要な場合は、*note
     Truenames::で説明する‘file-chase-links’または‘file-truename’を使用
     すること。

   以下の2つの関数は、FILENAMEにたいして、シンボリックリンクを全階層にお
いて再帰的にフォローする。

 -- Function: file-directory-p filename
     この関数は、FILENAMEが既存のディレクトリー名なら‘t’、それ以外は
     ‘nil’をリターンする。

          (file-directory-p "~rms")
               ⇒ t
          (file-directory-p "~rms/lewis/files.texi")
               ⇒ nil
          (file-directory-p "~rms/lewis/no-such-file")
               ⇒ nil
          (file-directory-p "$HOME")
               ⇒ nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               ⇒ t

 -- Function: file-regular-p filename
     この関数は、ファイルFILENAMEが存在し、かつそれが通常ファイル(ディレ
     クトリー、名前付きパイプ、端末、その他I/Oデバイス以外)の場合は‘t’を
     リターンする。


File: elisp,  Node: Truenames,  Next: File Attributes,  Prev: Kinds of Files,  Up: Information about Files

24.6.3 Truenames
----------------

ファイルの“実名(truename)”とは、全階層においてシンボリックリンクを残らず
フォローした後、名前コンポーネントに出現する‘.’と‘..’を除いて簡略化した
名前のことです。これは、そのファイルにたいする正規名(canonical name)の一
種です。ファイルが常に一意な実名をもつ訳ではありません。あるファイルにた
いする異なる実名の個数は、そのファイルにたいするハードリンクの個数と同じ
です。しかし、実名はシンボリックリンクによる名前の変動を解消するのに有用
です。

 -- Function: file-truename filename
     この関数は、ファイルFILENAMEの実名をリターンする。引数が絶対ファイ
     ル名でない場合、この関数は最初に‘default-directory’にたいしてこれを
     展開する。

     この関数は、環境変数を展開しない。これを行うのは
     ‘substitute-in-file-name’だけである。*note Definition of
     substitute-in-file-name::を参照のこと。

     名前コンポーネントに出現する‘..’に先行するシンボリックリンクリンク
     をフォローする必要がある場合は、直接間接を問わず
     ‘expand-file-name’を呼び出す前に、‘file-truename’を呼び出すこと。そ
     うしないと、‘..’の直前にある名前コンポーネントは、‘file-truename’が
     呼び出される前に“簡略化”により取り除かれてしまう。
     ‘expand-file-name’呼び出しの必要を無くすため、‘file-truename’は
     ‘expand-file-name’が行うのと同じ方法で‘~’を扱う。*note Functions
     that Expand Filenames: File Name Expansion.を参照のこと。

 -- Function: file-chase-links filename &optional limit
     この関数は、FILENAMEで始まるシンボリックリンクを、シンボリックリン
     クではない名前のファイル名までフォローして、そのファイル名をリター
     ンする。この関数は、親ディレクトリーの階層にあるシンボリックリンク
     をフォロー_しない_。

     LIMITに数を指定した場合は、その数のリンクを追跡した後、この関数はた
     とえそれが依然としてシンボリックリンクであっても、それをリターンす
     る。

   ‘file-chase-links’と‘file-truename’の違いを説明するために、
‘/usr/foo’がディレクトリー‘/home/foo’へのシンボリックリンクであり、
‘/home/foo/hello’が(少なくともシンボリックリンクではない)通常ファイル、
または存在しないファイルであるとします。この場合は以下のようになります:

     (file-chase-links "/usr/foo/hello")
          ;; 親ディレクトリーのリンクはフォローしない
          ⇒ "/usr/foo/hello"
     (file-truename "/usr/foo/hello")
          ;; ‘/home’はシンボリックリンクではないと仮定
          ⇒ "/home/foo/hello"

 -- Function: file-equal-p file1 file2
     この関数は、ファイルFILE1とFILE2の名前が同じファイルの場合は‘t’をリ
     ターンする。これは、リモートファイル名も適切な方法で処理することを
     除き、実名の比較と似ている。FILE1またはFILE2が存在しない場合、リタ
     ーン値は不定である。

 -- Function: file-in-directory-p file dir
     この関数は、FILEがディレクトリーDIR内のファイル、またはサブディレク
     トリーの場合は、‘t’をリターンする。また、FILEとDIRが同じディレクト
     リーの場合も、‘t’をリターンする。この関数は、2つのディレクトリーの
     実名を比較する。DIRが既存のディレクトリーの名前でない場合、リターン
     値は‘nil’である。


File: elisp,  Node: File Attributes,  Next: Extended Attributes,  Prev: Truenames,  Up: Information about Files

24.6.4 File Attributes
----------------------

このセクションでは、ファイルの詳細な情報を取得する関数について説明します
。それらの情報にはファイルの所有者やグループの番号、ファイル名の個数、
inode番号、サイズやアクセス日時、変更日時が含まれます。

 -- Function: file-newer-than-file-p filename1 filename2
     この関数は、ファイルFILENAME1がファイルFILENAME2より新しい場合は、
     ‘t’をリターンする。FILENAME1が存在しない場合は‘nil’、FILENAME1は存
     在するがFILENAME2が存在しない場合は‘t’をリターンする。

     以下の例では、‘aug-19’が19日、‘aug-20’が20日に書き込まれ、ファイル
     ‘no-file’は存在しないものとする。

          (file-newer-than-file-p "aug-19" "aug-20")
               ⇒ nil
          (file-newer-than-file-p "aug-20" "aug-19")
               ⇒ t
          (file-newer-than-file-p "aug-19" "no-file")
               ⇒ t
          (file-newer-than-file-p "no-file" "aug-19")
               ⇒ nil

   以下の2つの関数のFILENAME引数がシンボリックリンクの場合、これらの関数
はそれをリンクターゲットで_置き換えません_。しかしどちらの関数も、親ディ
レクトリーのすべての階層において、シンボリックリンクを再帰的にフォローし
ます。

 -- Function: file-attributes filename &optional id-format
     この関数は、ファイルFILENAMEの属性(attributes)のリストをリターンす
     る。オープンできないファイルが指定された場合は、‘nil’をリターンする
     。オプション引数ID-FORMATは、属性UIDおよびGID(以下参照)にたいして望
     ましいフォーマットを指定し、有効な値は‘'string’および‘'integer’であ
     る。デフォルトは‘'integer’だが、わたしたちはこれの変更を計画してい
     るので、リターンされるUIDまたはGIDを使用する場合は、ID-FORMATにたい
     して非‘nil’値を指定するべきである。

     リストの要素は順に:

       0. ディレクトリーにたいしては‘t’、シンボリックリンクにたいしては
          文字列(リンクされる名前)、テキストファイルにたいしては‘nil’。

       1. そのファイルがもつ名前の個数。ハードリンクとして知られる代替え
          名は、関数‘add-name-to-file’を使用して作成できる(*note
          Changing Files::を参照)。

       2. ファイルのUIDで、通常は文字列。しかし、名前をもつユーザーに対
          応しない場合、値は整数。

       3. 同様に、ファイルのGID。

       4. 最終アクセス時刻を表す、4つの整数‘(SEC-HIGH SEC-LOW MICROSEC
          PICOSEC)’からなるリスト(これは‘current-time’の値と似ている。
          *note Time of Day::を参照されたい)。いくつかのFATベースのファ
          イルシステムでは、最終アクセスの日付だけが記録されるので、この
          時刻には常に最終アクセス日の真夜中が保持されることに注意。

       5. 最終変更時刻を表す4つの整数からなるリスト(上記参照)。これは、
          ファイルのコンテンツが変更された最終時刻である。

       6. ステータスの最終変更時刻を表す4つの整数からなるリスト(上記参照
          )。これはファイルのアクセスモードビット、所有者とグループ、お
          よびファイルにたいしてファイルのコンテンツ以外にファイルシステ
          ムが記録するその他の情報にたいする最終変更時刻である。

       7. ファイルのサイズ(バイト)。Lisp整数の範囲を超える大きさのサイズ
          では浮動小数点数。

       8. ‘ls -l’で表示されるような、10個の文字、またはダッシュからなる
          文字列で表されるファイルのモード。

       9. 後方互換のために提供される不定値。

       10. ファイルのinode番号。可能な場合は整数。Emacs Lispの整数として
          表せる範囲より大きいinode番号は、整数で表現可能な値を得るため
          に2^{16}で除され‘(HIGH . LOW)’という形式の値になる。ここで
          LOWは下位16ビットである。それにたいしてさえinode番号が大きい場
          合、値は‘(HIGH MIDDLE . LOW)’という形式になる。ここで‘high’は
          上位ビット、MIDDLEは中位24ビット、LOWは下位16ビットを保持する
          。

       11. そのファイルがあるデバイスのファイルシステム番号。その大きさ
          により、値は整数、またはinode番号と同じ様式のコンスセルとなる
          。この要素とファイルのinode番号を併せれば、システム上の2つを区
          別するに足る情報が得られる(2つのファイルがこれら両方の番号で同
          じ値をもつことはできない)。

     たとえば、以下は‘files.texi’のファイル属性である:

          (file-attributes "files.texi" 'string)
               ⇒  (nil 1 "lh" "users"
                    (20614 64019 50040 152000)
                    (20000 23 0 0)
                    (20614 64555 902289 872000)
                    122295 "-rw-rw-rw-"
                    t (5888 2 . 43978)
                    (15479 . 46724))

     この結果を解釈すると:

     ‘nil’
          ディレクトリーでもシンボリックリンクでもない。

     ‘1’
          (カレントデフォルトディレクトリー内で名前‘files.texi’は)単一の
          名前をもつ。

     ‘"lh"’
          名前"lh"のユーザーにより所有される。

     ‘"users"’
          名前"users"のグループ。

     ‘(20614 64019 50040 152000)’
          最終アクセスがOctober 23, 2012, at 20:12:03.050040152 UTC。

     ‘(20000 23 0 0)’
          最終更新がJuly 15, 2001, at 08:53:43 UTC。

     ‘(20614 64555 902289 872000)’
          最終ステータス変更がOctober 23, 2012, at 20:20:59.902289872
          UTC。

     ‘122295’
          バイト長は122295バイト(しかしマルチバイトシーケンスが含まれて
          いたり、EOLフォーマットがCRLFの場合は122295文字が含まれないだ
          ろう)。

     ‘"-rw-rw-rw-"’
          所有者、グループ、その他にたいして読み取り、書き込みアクセスの
          モードをもつ。

     ‘t’
          単なるプレースホルダーであり、何の情報ももたない。

     ‘(5888 2 . 43978)’
          inode番号は6473924464520138。

     ‘(15479 . 46724)’
          ファイルシステムのデバイス番号は1014478468。

 -- Function: file-nlinks filename
     この関数は、ファイルFILENAMEがもつ名前(ハードリンク)の個数をリター
     ンする。ファイルが存在しない場合、この関数は‘nil’をリターンする。シ
     ンボリックリンクは、リンク先のファイルの名前とは判断されないので、
     この関数に影響しないことに注意。

          $ ls -l foo*
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               ⇒ 2
          (file-nlinks "doesnt-exist")
               ⇒ nil


File: elisp,  Node: Extended Attributes,  Next: Locating Files,  Prev: File Attributes,  Up: Information about Files

24.6.5 Extended File Attributes
-------------------------------

いくつかのオペレーティングシステムでは、それぞれのファイルを任意の“拡張
ファイル属性(extended file attributes)”に関連付けることができます。現在
のところ、Emacsは拡張ファイル属性のうち2つの特定セット(ACL: Access
Control List、およびSELinuxコンテキスト)にたいする問い合わせと設定をサポ
ートします。これらの拡張ファイル属性は、前のセクションで議論した“Unixス
タイル”の基本的なパーミッションより洗練されたファイルアクセス制御を強い
るために、いくつかのシステムで利用されます。

   ACLとSELinuxについての詳細な解説は、このマニュアルの範囲を超えます。
わたしたちの目的のためには、それぞれのファイルは“ACL”(ACLベースのファイ
ル制御システムの元でACLのプロパティを指定)および/または“SELinuxコンテキ
スト”(SELinuxシステムの元でSELinuxのプロパティを指定)に割り当てることが
できる、という理解でよいでしょう。

 -- Function: file-acl filename
     この関数は、ファイルFILENAMEにたいするACLをリターンする。ACLにたい
     する正確なLisp表現は不確定(かつ将来のEmacsバージョンで変更され得る
     )だが、これは‘set-file-acl’が引数ACLにとる値と同じである(*note
     Changing Files::を参照)。

     根底にあるACL実装はプラットフォーム固有である。EmacsはGNU/Linuxおよ
     びBSDではPOSIX ACLインターフェイスを使用し、MS-Windowsではネイティ
     ブのファイルセキュリティAPIをPOSIX ACLインターフェイスでエミュレー
     トする。

     ACLサポートなしでEmacsがコンパイルされた場合、ファイルが存在しない
     かアクセス不能な場合、またはその他の理由によりEmacsがACLエントリー
     を判断できない場合、リターン値は‘nil’である。

 -- Function: file-selinux-context filename
     この関数は、ファイルFILENAMEのSELinuxコンテキストを、‘(USER ROLE
     TYPE RANGE)’という形式のリストでリターンする。リストの要素は、その
     コンテキストのユーザー、ロール、タイプ、レンジを文字列として表す値
     である。これらの実際の意味についての詳細は、SELinuxのドキュメントを
     参照のこと。リターン値は、‘set-file-selinux-context’がCONTEXT引数で
     とるのと同じ形式である(*note Changing Files::を参照)。

     SELinuxサポートなしでEmacsがコンパイルされた場合、ファイルが存在し
     ないかアクセス不能な場合、またはシステムがSELinuxをサポートしない場
     合、リターン値は‘(nil nil nil nil)’である。

 -- Function: file-extended-attributes filename
     この関数は、Emacsが認識するファイルFILENAMEの拡張属性をalistでリタ
     ーンする。現在のところ、この関数はACLとSELinuxの両方を取得するため
     の便利な方法としての役目を果たす。他のファイルに同じファイルアクセ
     ス属性を適用するために、リターンされたalistを2つ目の引数として
     ‘set-file-extended-attributes’を呼び出すことができる(*note Changing
     Files::を参照)。

     要素のうちの1つは‘(acl . ACL)’で、ACLは‘file-acl’がリターンするのと
     同じ形式である。

     他の要素は‘(selinux-context . CONTEXT)’で、CONTEXTは
     ‘file-selinux-context’がリターンするのと同じ形式である。


File: elisp,  Node: Locating Files,  Prev: Extended Attributes,  Up: Information about Files

24.6.6 Locating Files in Standard Places
----------------------------------------

このセクションでは、ディレクトリーのリスト(“パス(path)”)からファイルを検
索したり、標準の実行可能ファイル用ディレクトリーから実行可能ファイルを検
索する方法を説明します。

   ユーザー固有の設定ファイル(configuration file)の検索については、*note
Standard File Names::の関数‘locate-user-emacs-file’を参照してください。

 -- Function: locate-file filename path &optional suffixes predicate
     この関数は、PATHで与えられるディレクトリーリスト内で、FILENAMEとい
     う名前のファイルを検索して、SUFFIXES内のサフィックスの検索を試みる
     。そのようなファイルが見つかった場合はファイルの絶対ファイル名
     (*note Relative File Names::を参照)をリターンし、それ以外は‘nil’を
     リターンする。

     オプション引数SUFFIXESは、検索時にFILENAMEに追加するファイル名サフ
     ィックスのリストを与える。‘locate-file’は、検索するディレクトリーご
     とに、それらのサフィックスを試みる。SUFFIXESが‘nil’、または‘("")’の
     場合は、サフィックスなしで、FILENAMEだけがそのまま使用される。
     SUFFIXESの典型的な値は‘exec-suffixes’(*note Subprocess Creation::を
     参照)、‘load-suffixes’、‘load-file-rep-suffixes’、および関数
     ‘get-load-suffixes’(*note Load Suffixes::を参照)である。

     実行可能プログラムを探すときは‘exec-path’(*note Subprocess
     Creation::を参照)、Lispファイルを探すときは‘load-path’(*note
     Library Search::を参照)がPATHの典型的な値である。FILENAMEが絶対ファ
     イル名の場合、PATHは効果がないが、サフィックスにたいするSUFFIXESは
     依然として試行される。

     オプション引数PREDICATEが非‘nil’の場合、それは候補ファイルが適切か
     どうかテストする述語関数を指定する。述語関数には、単一の引数として
     候補ファイル名が渡される。PREDICATEが‘nil’、または省略された場合は
     、述語として‘file-readable-p’を使用する。‘file-executable-p’や
     ‘file-directory-p’など、その他の有用な述語については、*note Kinds
     of Files::を参照のこと。

     互換性のために、PREDICATEには‘executable’、‘readable’、‘writable’、
     ‘exists’、またはこれらシンボルの1つ以上のリストも指定できる。

 -- Function: executable-find program
     この関数は、PROGRAMという名前の実行可能ファイルを検索して、その実行
     可能ファイルの絶対ファイル名と、もしあればファイル名の拡張子も含め
     てリターンする。ファイルが見つからない場合は、‘nil’をリターンする。
     この関数は、‘exec-path’内のすべてのディレクトリーを検索し、
     ‘exec-suffixes’内のすべてのファイル名拡張子の検索も試みる(*note
     Subprocess Creation::を参照)。


File: elisp,  Node: Changing Files,  Next: File Names,  Prev: Information about Files,  Up: Files

24.7 Changing File Names and Attributes
=======================================

このセクションの関数は、ファイルのリネーム(rename: 改名)、コピー、削除
(delete)、リンク、およびモード(パーミッション)のセットを行います。

   NEWNAMEという引数をもつ関数では、NEWNAMEという名前のファイルが既に存
在する場合の振る舞いは、引数OK-IF-ALREADY-EXISTSの値に依存します。

   • OK-IF-ALREADY-EXISTSが‘nil’の場合は、‘file-already-exists’エラーが
     シグナルされる。

   • OK-IF-ALREADY-EXISTSが数字の場合は、確認を求める。

   • OK-IF-ALREADY-EXISTSが他の値の場合は、確認なしで古いファイルを置き
     換える。

   以下の4つのコマンドはすべて、1つ目の引数にたいして親ディレクトリーの
全階層のシンボリックリンクを再帰的にフォローしますが、その引数自体がシン
ボリックリンクの場合は、‘copy-file’だけが(再帰的な)ターゲットを置き換え
ます。

 -- Command: add-name-to-file oldname newname &optional
          ok-if-already-exists
     この関数は、OLDNAMEという名前のファイルに、NEWNAMEという名前を追加
     で与える。これはNEWNAMEという名前が、OLDNAMEにたいする新たな“ハード
     リンク”になることを意味する。

     以下の例の最初の部分として、2つのファイル‘foo’と‘foo3’をリストする
     。

          $ ls -li fo*
          81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     ここで、‘add-name-to-file’を呼び出してハードリンクを作成し、再度フ
     ァイルをリストする。このリストには、1つのファイルにたいして2つの名
     前‘foo’と‘foo2’が表示される。

          (add-name-to-file "foo" "foo2")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     最後に以下を評価する:

          (add-name-to-file "foo" "foo3" t)

     そして、ファイルを再度リストする。今度は1つのファイルにたいして3つ
     の名前‘foo’、‘foo2’、‘foo3’がある。‘foo3’の古いコンテンツは失われた
     。

          (add-name-to-file "foo1" "foo3")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3

     この関数は、1つのファイルにたいして複数の名前をもつことが許されない
     オペレーティングシステムでは無意味である。いくつかのシステムでは、
     かわりにファイルをコピーすることにより複数の名前を実装している。

     *note File Attributes::の‘file-nlinks’も参照のこと。

 -- Command: rename-file filename newname &optional ok-if-already-exists
     このコマンドは、FILENAMEをNEWNAMEにリネームする。

     FILENAMEがFILENAMEとは別に追加の名前をもつ場合、それらは自身の名前
     をもち続ける。実際のところ、‘add-name-to-file’で名前NEWNAMEを追加し
     てからFILENAMEを削除するのは、瞬間的な遷移状態を別とすると、リネー
     ムと同じ効果がある。

 -- Command: copy-file oldname newname &optional ok-if-exists time
          preserve-uid-gid preserve-extended-attributes
     このコマンドは、ファイルOLDNAMEをNEWNAMEにコピーする。OLDNAMEが存在
     しない場合は、エラーをシグナルする。NEWNAMEがディレクトリーの場合は
     、その最後の名前コンポーネントを保持するように、そのディレクトリー
     の中にOLDNAMEをコピーする。

     TIMEが非‘nil’の場合、この関数は新たなファイルにたいして、古いファイ
     ルと同じ最終変更時刻を与える(これはいくつかの限られたオペレーティン
     グシステムでのみ機能する)。時刻のセットでエラーが発生した場合、
     ‘copy-file’は‘file-date-error’エラーをシグナルする。インタラクティ
     ブに呼び出された場合、プレフィックス引数はTIMEにたいして非‘nil’値を
     指定する。

     引数PRESERVE-UID-GIDが‘nil’の場合は、新たなファイルのユーザーおよび
     グループの所有権の決定を、オペレーティングシステムに委ねる(通常は
     Emacsを実行中のユーザーである)。PRESERVE-UID-GIDが非‘nil’の場合は、
     そのファイルのユーザーとグループの所有権のコピーを試みる。これはい
     くつかのオペレーティングシステムで、かつそれを行うための正しいパー
     ミッションをもつ場合のみ機能する。

     オプション引数PRESERVE-PERMISSIONSが非‘nil’の場合、この関数は
     OLDNAMEのファイルモード(または“パーミッション”)、同様にACL(Access
     Control List)とSELinuxコンテキストをNEWNAMEにコピーする。*note
     Information about Files::を参照のこと。

     それ以外では、NEWNAMEが既存ファイルならファイルモードは変更されず、
     新たに作成された場合はデフォルトのファイルパーミッション(以下の
     ‘set-default-file-modes’を参照)によりマスクされる。どちらの場合も、
     ACLまたはSELinuxコンテキストはコピーされない。

 -- Command: make-symbolic-link filename newname &optional ok-if-exists
     このコマンドは、FILENAMEにたいしてNEWNAMEという名前のシンボリックリ
     ンクを作成する。これは、コマンド‘ln -s FILENAME NEWNAME’と似ている
     。

     この関数は、シンボリックリンクをサポートしないシステムでは利用でき
     ない。

 -- Command: delete-file filename &optional trash
     このコマンドは、ファイルFILENAMEを削除する。ファイルが複数の名前を
     もつ場合は、他の名前で存在し続ける。FILENAMEがシンボリックリンクの
     場合、‘delete-file’はシンボリックリンクだけを削除して、(たとえこれ
     が親ディレクトリーの全階層のシンボリックリンクをフォローするとして
     も)ターゲットは削除しない。

     ファイルが存在しない、または削除できない場合は、適切な種類の
     ‘file-error’エラーがシグナルされる(UnixおよびGNU/Linuxでは、ファイ
     ルのディレクトリーが書き込み可能ならファイルは削除可能である)。

     オプション引数TRASHが非‘nil’、かつ変数‘delete-by-moving-to-trash’が
     非‘nil’の場合、このコマンドはファイルを削除するかわりに、システムの
     Trash(ゴミ箱)にファイルを移動する。*note Miscellaneous File
     Operations: (emacs)Misc File Ops.を参照のこと。インタラクティブに呼
     び出された際は、プレフィックス引数がない場合TRASHは‘t’、それ以外は
     ‘nil’である。

     *note Create/Delete Dirs::の‘delete-directory’も参照のこと。

 -- Command: set-file-modes filename mode
     この関数は、FILENAMEの“ファイルモード”(または“パーミッション”)を
     MODEにセットする。この関数は、FILENAMEにたいして全階層でシンボリッ
     クリンクをフォローする。

     非インタラクティブに呼び出された場合、MODEは整数でなければならない
     。その整数の下位12ビットだけが使用される。ほとんどのシステムでは、
     意味があるのは下位9ビットだけである。MODEを入力刷る、Lisp構文を使用
     できる。たとえば、

          (set-file-modes #o644)

     これは、そのファイルが所有者により読み取りと書き込み、グループメン
     バーにより読み取り、その他のユーザーにより読み取り可能であることを
     指定する。モードビットの仕様の説明は、*note (coreutils)File
     permissions::を参照のこと。

     インタラクティブに呼び出された場合、MODEは‘read-file-modes’(以下参
     照)を使用してミニバッファーから読み取られる。この場合、ユーザーは整
     数、またはパーミッションをシンボルで表現する文字列をタイプできる。

     ファイルのパーミッションをリターンする関数‘file-modes’については、
     *note File Attributes::を参照のこと。

 -- Function: set-default-file-modes mode
     この関数は、EmacsおよびEmacsのサブプロセスが新たに作成するファイル
     に、デフォルトのパーミッションをセットする。Emacsにより作成されたす
     べてのファイルはこれらのパーミッション、およびそれらのサブセットと
     なるパーミッションをもつ(デフォルトファイルパーミッションが実行を許
     可しても、‘write-region’は実行パーミッションを付与しないだろう)。
     UnixおよびGNU/Linuxでは、デフォルトのパーミッションは“umask”の値の
     ビット単位の補数で与えられる。

     引数MODEは上記の‘set-file-modes’と同様、パーミッションを指定する整
     数であること。下位9ビットだけに意味がある。

     デフォルトのファイルパーミッションは、既存ファイルの変更されたバー
     ジョンを保存する際は効果がない。ファイルの保存では、既存のパーミッ
     ションが保持される。

 -- Function: default-file-modes
     この関数は、デフォルトのファイルモードを整数でリターンする。

 -- Function: read-file-modes &optional prompt base-file
     この関数は、ミニバッファーからファイルモードビットのセットを読み取
     る。1つ目のオプション引数PROMPTは非デフォルトのプロンプトを指定する
     。2つ目のオプション引数BASE-FILEは、ユーザーが既存ファイルのパーミ
     ッションに相対的なモードビット指定をタイプした場合に、この関数がリ
     ターンするモードビッの元となる権限をもつファイルの名前を指定する。

     ユーザー入力が8進数で表される場合、この関数はその数字をリターンする
     。それが‘"u=rwx"’のようなモードビットの完全なシンボル指定の場合、こ
     の関数は‘file-modes-symbolic-to-number’を使用して、それを等価な数字
     に変換し、結果をリターンする。‘"o+g"’のように相対的な指定の場合、そ
     の指定の元となるパーミッションは、BASE-FILEのモードビットから取得さ
     れる。BASE-FILEが省略、または‘nil’の場合、この関数は元となるモード
     ビットとして‘0’を使用する。完全指定および相対指定は、
     ‘"u+r,g+rx,o+r,g-w"’のように組み合わせることができる。ファイルモー
     ド指定の説明は、*note (coreutils)File permissions::を参照のこと。

 -- Function: file-modes-symbolic-to-number modes &optional base-modes
     この関数は、MODES内のシンボルによるファイルモード指定を、等価な整数
     に変換する。シンボル指定が既存ファイルにもとづく場合は、オプション
     引数BASE-MODESからそのファイルのモードビットが取得される。その引数
     が省略、または‘nil’の場合は、0(すべてのアクセスが許可されない)がデ
     フォルトになる。

 -- Function: set-file-times filename &optional time
     この関数は、FILENAMEのアクセス時刻と変更時刻をTIMEにセットする。時
     刻が正しくセットされれば‘t’、それ以外は‘nil’がリターン値となる。
     TIMEのデフォルトはカレント時刻であり、‘current-time’がリターンする
     フォーマットでなければならない(*note Time of Day::を参照)。

 -- Function: set-file-extended-attributes filename attribute-alist
     この関数は、‘filename’にたいしてEmacsが認識する拡張ファイル属性をセ
     ットする。2つ目の引数ATTRIBUTE-ALISTは、
     ‘file-extended-attributes’がリターンするalistと同じ形式であること。
     *note Extended Attributes::を参照のこと。

 -- Function: set-file-selinux-context filename context
     この関数は、FILENAMEにたいするSELinuxセキュリティコンテキストに
     CONTEXTをセットする。CONTEXT引数は、各要素が文字列であるような
     ‘(USER ROLE TYPE RANGE)’というリストであること。*note Extended
     Attributes::を参照されたい。

     この関数は、FILENAMEのSELinuxコンテキストのセットに成功した場合は
     ‘t’をリターンする。コンテキストがセットされなかった場合(SELinuxが無
     効、またはEmacsがSELinuxサポートなしでコンパイルされた場合等)は、
     ‘nil’をリターンする。

 -- Function: set-file-acl filename acl
     この関数は、FILENAMEにたいするACLにACLをセットする。ACL引数は、関数
     ‘file-acl’がリターンするのと同じ形式であること。*note Extended
     Attributes::を参照されたい。

     この関数はFILENAMEのACLのセットに成功したら‘t’、それ以外は‘nil’をリ
     ターンする。


File: elisp,  Node: File Names,  Next: Contents of Directories,  Prev: Changing Files,  Up: Files

24.8 File Names
===============

ファイルは一般的に名前で参照され、Emacsでも他と同様です。Emacsでは、ファ
イル名は文字列で表現されます。ファイルを操作する関数はすべて、ファイル名
引数に文字列を期待します。

   ファイル自体の操作に加えて、Emacs Lispプログラムでファイル名を処理す
る必要(ファイル名の一部を取得して、関連するファイル名構築にその一部を使
用する等)がしばしばあります。このセクションでは、ファイル名を扱う方法を
説明します。

   このセクションの関数は実際にファイルにアクセスする訳ではないので、既
存のファイルやディレクトリーを参照しないファイル名を処理できます。

   MS-DOSおよびMS-Windowsでは、これらの関数は(実際にファイルを操作する関
数と同様)、MS-DOSおよびMS-Windowsのファイル名構文を受け入れます。この構
文はUnix構文のようにバックスラッシュでコンポーネントを区切りますが、これ
らの関数は常にUnix構文をリターンします。これにより、Unix構文でファイル名
を指定するLispプログラムが、変更なしですべてのシステムで正しく機能するこ
とが可能になるのです。(1)

* Menu:

* File Name Components::     ファイル名のディレクトリー部分と、それ以外。
* Relative File Names::      カレントディレクトリーにたいして相対的なファイル名。
* Directory Names::          ディレクトリーとしてのディレクトリー名と、ファイルとしてのファイル名の違い。
* File Name Expansion::      相対ファイル名から絶対ファイル名への変換。
* Unique File Names::        一時ファイル用の名前の生成。
* File Name Completion::     与えられたファイル名にたいする補完を探す。
* Standard File Names::      パッケージが固定されたファイル名を使用する際に、種々のオペレーティングシステムをシンプルに処理する方法。

   ---------- Footnotes ----------

   (1) MS-WindowsバージョンのEmacsはCygwin環境用にコンパイルされており、
2つのファイル名構文の変換に、‘cygwin-convert-file-name-to-windows’と
‘cygwin-convert-file-name-from-windows’を使用できます。


File: elisp,  Node: File Name Components,  Next: Relative File Names,  Up: File Names

24.8.1 File Name Components
---------------------------

オペレーティングシステムは、ファイルをディレクトリーにグループ化します。
あるファイルを指定するためには、ディレクトリーと、そのディレクトリー内で
のファイルの名前を指定しなければなりません。それゆえ、Emacsはファイル名
を“ディレクトリー名”パートと“非ディレクトリー”(または“ディレクトリー内フ
ァイル名”)パートという、2つの主要パートから判断します。どちらのパートも
空の場合があり得ます。これら2つのパートを結合することにより、元のファイ
ル名が再作成されます。

   ほとんどのシステムでは、最後のスラッシュ(MS-DOSおよびMS-Windowsではバ
ックスラッシュも許される)までのすべてがディレクトリーパートです。残りが
非ディレクトリーパートです。

   ある目的のために、非ディレクトリーパートはさらに正式名称(the name
proper)と“バージョン番号”に細分されます。ほとんどのシステムでは、名前に
バージョン番号をもつのは、バックアップファイルだけです。

 -- Function: file-name-directory filename
     この関数は、FILENAMEのディレクトリーパートをディレクトリー名(*note
     Directory Names::を参照)としてリターンする。FILENAMEがディレクトリ
     ーパートを含まない場合は、‘nil’をリターンする。

     GNUおよびUnixシステムでは、この関数がリターンする文字列は常にスラッ
     シュで終わる。MS-DOSでは、コロンで終わることもあり得る。

          (file-name-directory "lewis/foo")  ; Unixの例
               ⇒ "lewis/"
          (file-name-directory "foo")        ; Unixの例
               ⇒ nil

 -- Function: file-name-nondirectory filename
     この関数は、FILENAMEの非ディレクトリーパートをリターンする。

          (file-name-nondirectory "lewis/foo")
               ⇒ "foo"
          (file-name-nondirectory "foo")
               ⇒ "foo"
          (file-name-nondirectory "lewis/")
               ⇒ ""

 -- Function: file-name-sans-versions filename &optional
          keep-backup-version
     この関数は、任意のファイルバージョン番号、バックアップバージョン番
     号、末尾のチルダを取り除いてFILENAMEをリターンする。

     KEEP-BACKUP-VERSIONが非‘nil’の場合は、ファイルシステムなどが理解す
     るような真のファイルバージョン番号は破棄されるが、バックアップバー
     ジョン番号は保持される。

          (file-name-sans-versions "~rms/foo.~1~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               ⇒ "~rms/foo"

 -- Function: file-name-extension filename &optional period
     この関数は、FILENAMEからもしあればすべてのバージョン番号とバックア
     ップ番号を取り除いた後、終端の“拡張子(extension)”をリターンする。フ
     ァイル名の拡張子とは、最後の名前コンポーネント(からすべてのバージョ
     ン番号とバックアップ番号を取り去った後)の最後の‘.’に後続するパート
     である。

     この関数は、‘foo’のような拡張子のないファイル名にたいしては、
     ‘nil’をリターンする。‘foo.’のようなnull拡張子にたいしては、‘""’をリ
     ターンする。ファイル名の最終コンポーネントが‘.’で始まる場合、その
     ‘.’は拡張子の開始とはみなされない。したがって、‘.emacs’の拡張子は
     ‘.emacs’ではなく‘nil’である。

     PERIODが非‘nil’の場合、拡張子を区切るピリオドもリターン値に含まれる
     ようにななる。その場合、もしFILENAMEが拡張子をもたないなら、リター
     ン値は‘""’である。

 -- Function: file-name-sans-extension filename
     この関数は、もしあればFILENAMEから拡張子を除いてリターンする。もし
     バージョン番号またはバックアップ番号があるなら、ファイルが拡張子を
     もつ場合のみ、それを削除する。たとえば、

          (file-name-sans-extension "foo.lose.c")
               ⇒ "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               ⇒ "big.hack/foo"
          (file-name-sans-extension "/my/home/.emacs")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "/my/home/.emacs.el")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "~/foo.el.~3~")
               ⇒ "~/foo"
          (file-name-sans-extension "~/foo.~3~")
               ⇒ "~/foo.~3~"

     最後の2つの例の‘.~3~’は、拡張子ではなくバックアップ番号であることに
     注意。

 -- Function: file-name-base &optional filename
     この関数は、‘file-name-sans-extension’と‘file-name-nondirectory’を
     組み合わせたものである。たとえば、

          (file-name-base "/my/home/foo.c")
              ⇒ "foo"

     FILENAME引数のデフォルトは、‘buffer-file-name’である。


File: elisp,  Node: Relative File Names,  Next: Directory Names,  Prev: File Name Components,  Up: File Names

24.8.2 Absolute and Relative File Names
---------------------------------------

ファイルシステム内のすべてのディレクトリーは、ルートディレクトリーから開
始されるツリーを形成します。このツリーのルートから開始されるすべてのディ
レクトリー名により、ファイル名を指定でき、それを“絶対(absolute)”ファイル
名と呼びます。デフォルトディレクトリーからの相対的なツリー中の位置でファ
イルを指定するこでき、それは“相対(relative)”ファイル名と呼ばれます。
UnixおよびGNU/Linuxでは、絶対ファイル名は‘/’または‘~’で始まり、相対ファ
イル名は違います(*note abbreviate-file-name::を参照)。MS-DOSおよび
MS-Windowsでは、絶対ファイル名はスラッシュ、バックスラッシュ、またはドラ
イブ指定‘X:/’で始まります。ここでXは“ドライブ文字(drive letter)”です。

 -- Function: file-name-absolute-p filename
     この関数は、FILENAMEが絶対ファイル名の場合は‘t’、それ以外は‘nil’を
     リターンする。

          (file-name-absolute-p "~rms/foo")
               ⇒ t
          (file-name-absolute-p "rms/foo")
               ⇒ nil
          (file-name-absolute-p "/user/rms/foo")
               ⇒ t

   相対ファイル名が与えられた場合は、‘expand-file-name’を使用して、それ
を絶対ファイル名に変換できます(*note File Name Expansion::を参照)。この
関数は、絶対ファイル名を相対ファイル名に変換します:

 -- Function: file-relative-name filename &optional directory
     この関数は、DIRECTORY(絶対ディレクトリー名またはディレクトリーファ
     イル名)から相対的な結果となると仮定して、FILENAMEと等価な相対ファイ
     ル名のリターンを試みる。DIRECTORYが省略、または‘nil’の場合、カレン
     トバッファーのデフォルトディレクトリーがデフォルトとなる。

     絶対ファイル名がデバイス名で始まるオペレーティングシステムが、いく
     つか存在する。そのようなシステムでは、2つの異なるデバイス名から開始
     されるFILENAMEは、DIRECTORYにもとづく等価な相対ファイル名をもたない
     。この場合、‘file-relative-name’は絶対形式でFILENAMEをリターンする
     。

          (file-relative-name "/foo/bar" "/foo/")
               ⇒ "bar"
          (file-relative-name "/foo/bar" "/hack/")
               ⇒ "../foo/bar"


File: elisp,  Node: Directory Names,  Next: File Name Expansion,  Prev: Relative File Names,  Up: File Names

24.8.3 Directory Names
----------------------

“ディレクトリー名(directory name)”とは、ディレクトリーの名前のことです。
ディレクトリーは実際にはファイルの一種なので、ファイル名をもちます。これ
はディレクトリー名と関連がありますが、同一ではありません(これは、Unixの
通常の用語とは異なる)。同じ実体にたいするこれら2つの異なる名前は、構文的
な変換により関連付けられます。GNUおよびUnixシステムでは、ことは単純です
。ディレクトリー名はスラッシュで終わり、ファイルとしてのディレクトリーの
名前には、そのスラッシュがありません。MS-DOSでは、この関連付けはより複雑
です。

   ディレクトリー名と、ファイルとしてのディレクトリーの名前の違いは、些
細ですが重要です。Emacsの変数、または関数の引数を記述する際、それがディ
レクトリー名であるとしており、ディレクトリーのファイル名は許されません。
‘file-name-directory’が文字列をリターンするときは、常にディレクトリー名
です。

   以下の2つの関数は、ディレクトリー名とファイル名の間で変換を行います。
これらの関数は、‘$HOME’のような環境変数や、‘~’、‘.’、‘..’などの構文にた
いして、特別なことは何も行いません。

 -- Function: file-name-as-directory filename
     この関数は、オペレーティングシステムがディレクトリーの名前と解釈す
     る形式で、FILENAMEを表す文字列をリターンする。ほとんどのシステムで
     は、(もし終端にそれがなければ)これは文字列にスラッシュを追加するこ
     とを意味する。

          (file-name-as-directory "~rms/lewis")
               ⇒ "~rms/lewis/"

 -- Function: directory-file-name dirname
     この関数は、オペレーティングシステムがファイルの名前と解釈する形式
     で、DIRNAMEを表す文字列をリターンする。ほとんどのシステムでは、これ
     は文字列から最後のスラッシュ(またはバックスラッシュ)を削除すること
     を意味する。

          (directory-file-name "~lewis/")
               ⇒ "~lewis"

   ディレクトリーにたいしては、‘concat’を使用して相対ファイルと組み合わ
せることができます:

     (concat DIRNAME RELFILE)

これを行う前に、ファイル名が相対的であるか確認してください。絶対ファイル
名を使用した場合、結果は構文的に不正になるか、間違ったファイルを参照する
可能性があります。

   ディレクトリーファイル名作成にこのような組み合わせを使用したい場合は
、最初に‘file-name-as-directory’を使用して、それをディレクトリー名に変換
しなければなりません:

     (concat (file-name-as-directory DIRFILE) RELFILE)

以下のような、手動によるスラッシュの結合を試みてはなりません

     ;;; 間違い!
     (concat DIRFILE "/" RELFILE)

なぜなら、これには可搬性がないからです。常に‘file-name-as-directory’を使
用してください。

   ディレクトリー名をディレクトリーの省略名に変換するには、以下の関数を
使用します:

 -- Function: abbreviate-file-name filename
     この関数は、FILENAMEの省略された形式をリターンする。これは
     ‘directory-abbrev-alist’(*note File Aliases: (emacs)File Aliases.)で
     指定される省略形を適用した後、引数のファイル名がユーザーのホームデ
     ィレクトリー、またはそのサブディレクトリーにある場合は、それを‘~’に
     置き換える。ホームディレクトリーがルートディレクトリーの場合、多く
     のシステムでは結果が短縮されないので、‘~’で置き換えない。

     これは名前の一部であるような省略形さえも認識するので、ディレクトリ
     ー名とファイル名にも使用できる。


File: elisp,  Node: File Name Expansion,  Next: Unique File Names,  Prev: Directory Names,  Up: File Names

24.8.4 Functions that Expand Filenames
--------------------------------------

ファイル名の“展開(expanding)”とは、相対ファイル名を絶対ファイル名に変換
することを意味します。これはデフォルトディレクトリーから相対的に行われる
ため、展開されるファイル名と同様、デフォルトディレクトリーも指定しなけれ
ばなりません。これは‘~/’のような省略形 (*note abbreviate-file-name::を参
照)、 の展開、および‘./’や‘NAME/../’のような冗長さの排除も行います。 も
展開します。

 -- Function: expand-file-name filename &optional directory
     この関数は、FILENAMEを絶対ファイル名に変換する。DIRECTORYが与えられ
     た場合、FILENAMEが相対的なら、それは開始点となるデフォルトディレク
     トリーになる(DIRECTORYの値は、それ自体が絶対ディレクトリー名、また
     はディレクトリーファイル名であるべきで、それは‘~’で始まるかもしれな
     い)。それ以外では、カレントバッファーの‘default-directory’の値が使
     用される。たとえば:

          (expand-file-name "foo")
               ⇒ "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               ⇒ "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               ⇒ "/usr/spool/foo"

     結合されたファイル名の最初のスラッシュの前が‘~’の場合は、環境変数
     ‘HOME’(通常はユーザーのホームディレクトリー)の値に展開される。最初
     のスラッシュの前が‘~USER’で、かつUSERが有効なログイン名の場合は、
     USERのホームディレクトリーに展開される。

     ‘.’または‘..’を含むファイル名は、正規化形式に簡略化される:

          (expand-file-name "bar/../foo")
               ⇒ "/xcssun/users/rms/lewis/foo"

     出力に‘..’コンポーネントが残り得る場合もある:

          (expand-file-name "../home" "/")
               ⇒ "/../home"

     これは、ルートディレクトリー‘/’の上位の“スーパールート
     (superroot)”という概念をもつファイルシステムのためのものである。そ
     の他のファイルシステムでは、‘/../’は‘/’とまったく同じに解釈される。

     ‘expand-file-name’は環境変数を展開_しない_ことに注意。
     ‘substitute-in-file-name’だけが、それを行う。

          (expand-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/lewis/$HOME/foo"

     ‘expand-file-name’は、あらゆる階層においてシンボリックリンクをフォ
     ローしないことにも注意。これは‘..’の扱いが‘file-truename’と
     ‘expand-file-name’で異なることに起因する。‘/tmp/bar’がディレクトリ
     ー‘/tmp/foo/bar’にたいするシンボリックリンクであると仮定すると:

          (file-truename "/tmp/bar/../myfile")
               ⇒ "/tmp/foo/myfile"
          (expand-file-name "/tmp/bar/../myfile")
               ⇒ "/tmp/myfile"

     直接間接を問わず、事前に‘expand-file-name’を呼び出さずに‘..’に先行
     するシンボリックリンクをフォローする必要があるかもしれない場合は、
     それを呼び出さずに確実に‘file-truename’を呼び出すべきである。*note
     Truenames::を参照のこと。

 -- Variable: default-directory
     このバッファーローカル変数の値は、カレントバッファーにたいするデフ
     ォルトディレクトリーである。これは絶対ディレクトリー名であること。
     これは‘~’で始まるかもしれない。この変数は、すべてのバッファーにおい
     てバッファーローカルである。

     2つ目の引数が‘nil’の場合、‘expand-file-name’はデフォルトディレクト
     リーを使用する。

     値は常にスラッシュで終わる文字列である。

          default-directory
               ⇒ "/user/lewis/manual/"

 -- Function: substitute-in-file-name filename
     この関数は、FILENAME内で参照される環境変数を、環境変数の値に置き換
     える。標準的なUnixシェル構文にしたがい、 ‘$’は環境変数値置き換えの
     プレフィックスである。入力に‘$$’が含まれる場合、それ‘$’に置き換えら
     れる。これにより、ユーザーが‘$’を“クォート”する手段が与えられる。

     環境変数名は‘$’の後に続く一連の英数字(アンダースコアを含む)である。
     ‘$’の後続文字が、‘{’の場合はマッチする‘}’までのすべてが変数名である
     。

     ‘substitute-in-file-name’により生成された出力で
     ‘substitute-in-file-name’を呼び出すと、不正な結果となる傾向がある。
     たとえば、単一の‘$’をクォートするための‘$$’の使用は正しく機能しない
     だろうし、環境変数値の中の‘$’は再帰的な置換を導くだろう。したがって
     、この関数を呼び出して、出力をこの関数に渡すプログラムは、その後の
     不正な結果を防ぐために、すべての‘$’文字を二重化する必要がある。

     以下では、ユーザーのホームディレクトリー名を保持する環境変数
     ‘HOME’は、値‘/xcssun/users/rms’をもつとする。

          (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"

     置き換え後は、‘/’の直後に‘~’や別の‘/’が出現した場合、この関数は、
     ‘/’の前にあるすべてを無視する。

          (substitute-in-file-name "bar/~/foo")
               ⇒ "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
               ;; ‘/usr/local/’は破棄された


File: elisp,  Node: Unique File Names,  Next: File Name Completion,  Prev: File Name Expansion,  Up: File Names

24.8.5 Generating Unique File Names
-----------------------------------

一時ファイルに書き込む必要があるプログラムが、いくつかあります。以下は、
そのようなファイルを構築する、便利な方法です:

     (make-temp-file NAME-OF-APPLICATION)

‘make-temp-file’の役目は、2人の異なるユーザー、またはジョブが、完全に一
致する名前のファイルの使用を防ぐことです。

 -- Function: make-temp-file prefix &optional dir-flag suffix
     この関数は、一時ファイルを作成して、その名前をリターンする。Emacsは
     、Emacsの各ジョブごとに異なるランダムないくつかの文字をPREFIXに追加
     することにより、一時ファイルの名前を作成する。結果として新たに空の
     ファイルが作成されることが保障される。MS-DOSでは、8+3のファイル名制
     限に適合するよう、文字列STRINGは切り詰められる可能性がある。
     PREFIXが相対ファイル名の場合、それは‘temporary-file-directory’にた
     いして展開される。

          (make-temp-file "foo")
               ⇒ "/tmp/foo232J6v"

     ‘make-temp-file’がリターンした際、一時ファイルは空で作成される。こ
     の時点で、そのファイルに意図するコンテンツを書き込むべきである。

     DIR-FLAGが‘nil’の場合、‘make-temp-file’は空のファイルのかわりに、空
     のディレクトリーを作成する。これはディレクトリー名ではなく、ディレ
     クトリーのファイル名をリターンする。*note Directory Names::を参照の
     こと。

     SUFFIXが非‘nil’の場合、‘make-temp-file’はそれをファイル名の最後に追
     加する。

     同じEmacs内で実行される異なるライブラリー間での競合を防ぐために、
     ‘make-temp-file’を使用する各Lispプログラムがプログラム自身の
     PREFIXを使用するべきである。PREFIXの最後に追加される数字は、異なる
     Emacsジョブ内で実行される、同じアプリケーションを区別する。追加され
     る文字により、同一のEmacsジョブ内でも、多数の名前を区別することが可
     能になる。

   一時ファイル用のデフォルトディレクトリーは、変数
‘temporary-file-directory’により制御されます。この変数により、すべての一
時ファイルにたいして、ユーザーがディレクトリーを指定する、一貫した方法が
与えられます。‘small-temporary-file-directory’が非‘nil’の場合は、かわり
にそれを使うプログラムもいくつかあります。これを使う場合は、
‘make-temp-file’を呼び出す前に、正しいディレクトリーにたいしてプレフィッ
クスを展開するべきです。

 -- User Option: temporary-file-directory
     この変数は、一時ファイル作成用のディレクトリー名を指定する。値はデ
     ィレクトリー名であるべきだが、もし値がディレクトリーのファイル名
     (*note Directory Names::を参照)ならば、Lispプログラムがかわりに対処
     すればよい。‘expand-file-name’の2つ目の引数としてその値を使用するの
     は、それを達成するよい方法である。

     デフォルト値は、オペレーティングシステムにたいして適切な方法により
     決定される。これは環境変数‘TMPDIR’、‘TMP’、‘TEMP’にもとづき、これら
     の変数が定義されていなければ、システム依存の名前にフォールバックす
     る。

     一時ファイルの作成に‘make-temp-file’を使用しない場合でも、一時ファ
     イルを置くディレクトリーを判断するために、依然としてこの変数を使用
     するべきである。しかし、一時ファイルが小さくなることを求める場合は
     、‘small-temporary-file-directory’が非‘nil’ならば、それを使用するべ
     きである。

 -- User Option: small-temporary-file-directory
     この変数は、小さいかもしれない特定の一時ファイル作成用のディレクト
     リー名を指定する。

     小さくなるかもしれない一時ファイルに書き込みたい場合は、以下のよう
     にディレクトリーを計算するべきである:

          (make-temp-file
            (expand-file-name PREFIX
                              (or small-temporary-file-directory
                                  temporary-file-directory)))

 -- Function: make-temp-name base-name
     この関数は、一意なファイル名として使用できる文字列を生成する。この
     名前はBASE-NAMEで始まり、それに各Emacsジョブごとに異なる、複数のラ
     ンダムな文字を追加したものである。これは‘make-temp-file’と似ている
     が、(i)名前だけを作成し、ファイルは作成しない、(ii)BASE-NAMEは絶対
     ファイル名であること、という点が異なる(MS-DOSシステムでは、8+3ファ
     イル名制限に適合するよう、BASE-NAMEが切り詰められる)。

     *警告:* この関数を使用するべきではない。かわりに‘make-temp-file’を
     使用すること! この関数は、競合状態の影響を受けやすい。
     ‘make-temp-name’呼び出しと一時ファイル作成のタイムラグは、セキュリ
     ティーホールとなる場合があるかもしれない。


File: elisp,  Node: File Name Completion,  Next: Standard File Names,  Prev: Unique File Names,  Up: File Names

24.8.6 File Name Completion
---------------------------

このセクションでは、ファイル名を補完するための、低レベルサブルーチンにつ
いて説明します。より高レベルの関数については、*note Reading File
Names::を参照してください。

 -- Function: file-name-all-completions partial-filename directory
     この関数は、ディレクトリーDIRECTORY内で、PARTIAL-FILENAMEで始まる名
     前のファイルにたいして、すべての補完可能なリストをリターンする。補
     完の順番はそのディレクトリー内でのファイル順序であり、これは予測不
     能で何の情報ももたない。

     引数PARTIAL-FILENAMEは非ディレクトリーパートを含むファイル名でなけ
     ればならず、スラッシュ(いくつかのシステムではバックスラッシュ)が含
     まれていてはならない。DIRECTORYが絶対ディレクトリーでない場合は、
     DIRECTORYの前にカレントバッファーのデフォルトディレクトリーが追加さ
     れる。

     以下の例では、‘~rms/lewis’がカレントデフォルトディレクトリーで、名
     前が‘f’で始まる5つのファイル‘foo’、‘file~’、‘file.c’、
     ‘file.c.~1~’、‘file.c.~2~’があるものとする:

          (file-name-all-completions "f" "")
               ⇒ ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")
               ⇒ ("foo")

 -- Function: file-name-completion filename directory &optional
          predicate
     この関数は、ディレクトリーDIRECTORY内で、ファイル名FILENAMEを補完す
     る。これはディレクトリーDIRECTORY内で、FILENAMEで始まるすべてのファ
     イル名にたいして、最長の共通プレフィックスをリターンする。
     PREDICATEが非‘nil’の場合は、この関数を1引数で呼び出して絶対ファイル
     名に展開後、PREDICATEを満足しない補完候補を無視する。

     マッチが1つだけ存在し、かつFILENAMEが正確にそれにマッチする場合、関
     数は‘t’をリターンする。関数は、ディレクトリーDIRECTORYがFILENAMEで
     始まる名前のファイルを含まない場合は、‘nil’をリターンする。

     以下の例では、‘~rms/lewis’がカレントデフォルトディレクトリーで、名
     前が‘f’で始まる5つのファイル‘foo’、‘file~’、‘file.c’、
     ‘file.c.~1~’、‘file.c.~2~’があるものとする:

          (file-name-completion "fi" "")
               ⇒ "file"

          (file-name-completion "file.c.~1" "")
               ⇒ "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               ⇒ t

          (file-name-completion "file.c.~3" "")
               ⇒ nil

 -- User Option: completion-ignored-extensions
     ‘file-name-completion’は通常、このリスト内の任意の文字列で終わるフ
     ァイル名を無視する。すべての可能な補完がこれらのサフィックスのいず
     れか1つで終わるときは、それらを無視しない。この変数は、
     ‘file-name-all-completions’に影響しない。

     典型的な値は、以下のようになる:

          completion-ignored-extensions
               ⇒ (".o" ".elc" "~" ".dvi")

     ‘completion-ignored-extensions’のある要素がスラッシュ‘/’で終わる場
     合、それはディレクトリーを示す。スラッシュで_終わらない_要素がディ
     レクトリーにマッチすることは決してない。したがって、上記の値は
     ‘foo.elc’という名前のディレクトリーを除外しないだろう。


File: elisp,  Node: Standard File Names,  Prev: File Name Completion,  Up: File Names

24.8.7 Standard File Names
--------------------------

Emacs Lispプログラムが特定の用途のために標準的なファイル名を指定する必要
がある場合があります。典型的には、カレントユーザーにより指定された設定デ
ータを保持する場合がそうです。そのようなファイルは通常、
‘user-emacs-directory’により指定されるディレクトリーに置かれ、デフォルト
では‘~/.emacs.d’です(*note Init File::を参照)。たとえば、
abbrev(abbreviation: 省略形)の定義は、デフォルトでは
‘~/.emacs.d/abbrev_defs’に格納されます。このようなファイル名を指定するに
は、関数‘locate-user-emacs-file’を使用するのが、もっとも簡単な方法です。

 -- Function: locate-user-emacs-file base-name &optional old-name
     この関数は、Emacs特有の設定ファイル、またはデータファイルにたいする
     絶対ファイル名をリターンする。引数‘base-name’は、ソファイル名である
     こと。リターン値は、‘user-emacs-directory’で指定されるディレクトリ
     ー内の絶対ファイル名である。このディレクトリーが存在しない場合、こ
     の関数はディレクトリーを作成する。

     オプション引数OLD-NAMEが非‘nil’の場合、それはユーザーのホームディレ
     クトリー内のファイル‘~/OLD-NAME’を指定する。そのようなファイルが存
     在する場合、リターン値はBASE-NAMEで指定されるファイルではなく、その
     ファイルの絶対ファイル名となる。これは、Emacsパッケージが後方互換を
     提供するために使用されることを意図した引数である。たとえば、
     ‘user-emacs-directory’導入前、abbrevファイルは‘~/.abbrev_defs’に置
     かれていた。以下は、‘abbrev-file-name’の定義である:

          (defcustom abbrev-file-name
            (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
            "Default name of file from which to read abbrevs."
            ...
            :type 'file)

   ファイル名の標準化のための低レベル関数は‘convert-standard-filename’で
、これはサブルーチンとして‘locate-user-emacs-file’により使用される。

 -- Function: convert-standard-filename filename
     この関数は、FILENAMEにもとづき、カレントオペレーティングシステムの
     慣習に適合するファイル名をリターンする。

     GNUおよびUnixシステムでは、これは単にFILENAMEをリターンする。その他
     のオペレーティングシステムでは、システム固有のファイル名規約にした
     がうだろう。たとえばMS-DOSでは、この関数はMS-DOSファイル名制限にし
     たがうよう、先頭の‘.’を‘_’に変換したり、‘.’の後続の文字を3文字に切
     り詰める等、さまざまな変更を行う。

     この関数でGNUおよびUnixシステムの慣習に適合する名前を指定して、それ
     を‘convert-standard-filename’に渡すのが推奨される使用方法である。


File: elisp,  Node: Contents of Directories,  Next: Create/Delete Dirs,  Prev: File Names,  Up: Files

24.9 Contents of Directories
============================

ディレクトリーとはファイルの一種で、さまざまな名前のファイルを含んでいま
す。ディレクトリーは、ファイルシステムの機能です。

   Emacsはディレクトリー内のファイル名をLispのリストとして一覧したり、シ
ェルコマンド‘ls’を使用してバッファー内にファイル名を表示することができま
す。後者の場合、Emacsはオプションで各ファイルに関する情報も表示でき、そ
れは‘ls’コマンドに渡すオプションに依存します。

 -- Function: directory-files directory &optional full-name match-regexp
          nosort
     この関数は、ディレクトリーDIRECTORY内のファイルの名前のリストをリタ
     ーンする。デフォルトでは、このリストはアルファベット順である。

     FULL-NAMEが非‘nil’の場合、この関数はファイルの絶対ファイル名をリタ
     ーンし、それ以外は指定されたディレクトリーにたいする相対ファイル名
     をリターンする。

     MATCH-REGEXPが非‘nil’の場合、この関数はその正規表現にたいするマッチ
     を含むファイル名だけをリターンし、それ以外のファイル名はリストから
     除外される。大文字小文字を区別するファイルシステムでは、大文字小文
     字を区別する正規表現マッチングが行われる。

     NOSORTが非‘nil’の場合、‘directory-files’はリストをソートしないので
     、取得するファイル名に特定の順序はない。最大限の可能なスピードを得
     る必要があり、ファイル処理順を気にしない場合は、この関数を使用する
     。ユーザーから処理順が可視の場合は、名前をソートすれば、おそらくユ
     ーザーはより幸せになるだろう。

          (directory-files "~lewis")
               ⇒ ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")

     DIRECTORYが読み取り可能なディレクトリー名でない場合は、エラーがシグ
     ナルされる。

 -- Function: directory-files-and-attributes directory &optional
          full-name match-regexp nosort id-format
     これは、どのファイルを報告するか、およびファイル名を報告する方法に
     おいて、‘directory-files’と似ている。しかし、この関数はファイル名の
     リストをリターンするかわりに、各ファイルごとにリスト‘(FILENAME .
     ATTRIBUTES)’をリターンする。ここでATTRIBUTESは、そのファイルにたい
     して‘file-attributes’がリターンするであろう値である。オプション引数
     ID-FORMATは、‘file-attributes’の対応する引数と同じ意味をもつ(*note
     Definition of file-attributes::を参照)。

 -- Function: file-expand-wildcards pattern &optional full
     この関数は、ワイルドカードパッケージPATTERNを展開して、それにマッチ
     するファイル名のリストをリターンする。

     絶対ファイル名としてPATTERNが記述された場合は、値も絶対ファイル名に
     なる。

     PATTERNが相対ファイル名で記述されている場合、それはカレントデフォル
     トディレクトリーにたいして相対的に解釈される。リターンされるファイ
     ル名も、通常はカレントデフォルトディレクトリーにたいする相対ファイ
     ル名になる。しかしFULLが非‘nil’の場合は、絶対ファイル名がリターンさ
     れる。

 -- Function: insert-directory file switches &optional wildcard
          full-directory-p
     この関数は、‘ls’のSWITCHESに対応するフォーマットで、(カレントバッフ
     ァー内に)ディレクトリーFILEのディレクトリーリストを挿入する。これは
     、挿入したテキストの後にポイントを残す。SWITCHESにはオプション文字
     列、または個別のオプションを表す文字列リストを指定できる。

     引数FILEにはディレクトリー名、またはワイルドカード文字を含むファイ
     ル名を指定できる。WILDCARDが非‘nil’の場合、FILEはワイルドカードを伴
     うファイル指定として扱われることを意味する。

     FULL-DIRECTORY-Pが非‘nil’の場合、ディレクトリーリストにたいしてディ
     レクトリーの完全なコンテンツ表示を要求することを意味する。FILEがデ
     ィレクトリーで、スイッチに‘-d’が含まれないときは、‘t’を指定するべき
     である(‘ls’へのオプション‘-d’は、ディレクトリーのコンテンツではなく
     、ファイルとしてディレクトリーを表示するよう指定する)。

     ほとんどのシステムでは、この関数は変数‘insert-directory-program’の
     名前のディレクトリーリスト用プログラムを実行することにより機能する
     。WILDCARDが非‘nil’の場合は、ワイルドカード展開するために、
     ‘shell-file-name’で指定されるシェルの実行も行う。

     MS-DOSおよびMS-Windowsシステムは、標準的なUnixプログラム‘ls’を欠く
     ので、この関数はLispコードで‘ls’をエミュレートする。

     技術的な詳細としては、SWITCHESにロングオプション‘--dired’が含まれる
     際に‘insert-directory’は、diredのためにこれを特別に扱う。しかし他の
     オプションと同様、通常は等価なショートオプション‘-D’が単に
     ‘insert-directory-program’に渡されるだけである。

 -- Variable: insert-directory-program
     この変数の値は、関数‘insert-directory’用にディレクトリーリストを生
     成するプログラムである。この値は、Lispコードでリストを生成するシス
     テムでは無視される。


File: elisp,  Node: Create/Delete Dirs,  Next: Magic File Names,  Prev: Contents of Directories,  Up: Files

24.10 Creating, Copying and Deleting Directories
================================================

Emacs Lispのファイル操作関数のほとんどは、ディレクトリーであるようなファ
イルに使用されたときはエラーとなります。たとえば、‘delete-file’でディレ
クトリーの削除はできません。以下のスペシャルカは、ディレクトリーの作成と
削除を行うために存在します。

 -- Command: make-directory dirname &optional parents
     このコマンドは、DIRNAMEという名前のディレクトリーを作成する。
     PARENTSが非‘nil’の場合(インタラクティブな呼び出しでは、常に非
     ‘nil’となる)、その親ディレクトリーがまだ存在しなければ、最初にそれ
     を作成することを意味する。

     ‘mkdir’は、これにたいするエイリアスである。

 -- Command: copy-directory dirname newname &optional keep-time parents
          copy-contents
     このコマンドは、DIRNAMEという名前のディレクトリーを、NEWNAMEにコピ
     ーする。NEWNAMEが既存のディレクトリーの場合、DIRNAMEはそれのサブデ
     ィレクトリーにコピーされるだろう。

     これは、常にコピーされるファイルのファイルモードを、対応する元のフ
     ァイルモードに一致させる。

     3つ目の引数KEEP-TIMEが非‘nil’の場合は、コピーされるファイルの修正時
     刻を保持することを意味する。プレフィックス引数を与えると、
     KEEP-TIMEが非‘nil’になる。

     4つ目の引数PARENTSは、親ディレクトリーが存在しない場合に作成するか
     どうかを指定する。インタラクティブな場合、これはデフォルトで発生す
     る。

     5つ目の引数COPY-CONTENTSが非‘nil’の場合、それはNEWNAMEが既存のディ
     レクトリーならば、そのサブディレクトリーとしてDIRNAMEをコピーするか
     わりに、DIRNAMEのコンテンツをNEWNAMEにコピーする。

 -- Command: delete-directory dirname &optional recursive trash
     このコマンドは、DIRNAMEという名前のディレクトリーを削除する。関数
     ‘delete-file’はディレクトリーであるようなファイルにたいしては機能し
     ない。それらにたいしては、‘delete-directory’を使用しなければならな
     い。RECURSIVEが‘nil’で、ディレクトリー内にファイルが存在する場合、
     ‘delete-directory’はエラーをシグナルする。

     ‘delete-directory’は、親ディレクトリーの階層のシンボリックリンクだ
     けをフォローする。

     オプション引数TRASHが非‘nil’、かつ変数‘delete-by-moving-to-trash’が
     非‘nil’の場合、このコマンドはファイルを削除するかわりに、システムの
     Trash(ゴミ箱)にファイルを移動する。*note Miscellaneous File
     Operations: (emacs)Misc File Ops.を参照のこと。インタラクティブに呼
     び出された際は、プレフィックス引数がない場合TRASHは‘t’、それ以外は
     ‘nil’である。


File: elisp,  Node: Magic File Names,  Next: Format Conversion,  Prev: Create/Delete Dirs,  Up: Files

24.11 Making Certain File Names “Magic”
=======================================

特定のファイル名にたいして、特別な処理を実装できます。これは、それらの名
前の“magic”化と呼ばれます。この機能は主に、リモートファイルにたいするア
クセスの実装に使用されます(*note Remote Files: (emacs)Remote Files.を参
照)。

   magicファイル名を定義するには、名前クラスを定義するための正規表現、お
よびそれにマッチするファイル名にたいするEmacsファイル操作プリミティブす
べてを実装するハンドラーを定義しなければなりません。

   変数‘file-name-handler-alist’は各ハンドラーに適用するときを決定する正
規表現とともに、ハンドラーのリストを保持します。各要素は、以下の形式をも
ちます:

     (REGEXP . HANDLER)

ファイルアクセス、およびファイル名変換にたいするすべてのEmacsプリミティ
ブは、‘file-name-handler-alist’にたいして与えられたファイル名をチェック
します。そのファイル名がREGEXPにマッチした場合、そのプリミティブが
HANDLERを呼び出してファイルを処理します。

   HANDLERの1つ目の引数には、プリミティブの名前をシンボルとして与えます
。残りの引数は、そのプリミティブに引数として渡されます(これらの引数の1つ
目は、ほとんどの場合はファイル名自体である)。たとえば以下を行い:

     (file-exists-p FILENAME)

FILENAMEがハンドラーHANDLERをもつ場合、HANDLERは以下のように呼び出されま
す:

     (funcall HANDLER 'file-exists-p FILENAME)

   関数が2つ以上の引数をとる場合、それらはファイル名でなければならず、関
数はそれらのファイル名それぞれにたいしてハンドラーをチェックします。たと
えば、

     (expand-file-name FILENAME DIRNAME)

以下を行った場合は、FILENAMEにたいするハンドラーをチェックした後、
DIRNAMEにたいするハンドラーをチェックします。どちらの場合も、HANDLERは以
下のように呼び出されます:

     (funcall HANDLER 'expand-file-name FILENAME DIRNAME)

その後、HANDLERはFILENAMEとDIRNAMEのどちらを処理するか解決する必要があり
ます。

   指定されたファイル名が2つ以上のハンドラーにマッチする場合は、ファイル
名内で最後に開始するマッチが優先されます。リモートファイルアクセスのよう
なジョブにたいするハンドラーに先立ち、解凍のようなジョブにたいするハンド
ラーが最初に処理されるように、このルールが選択されました。

   以下は、magicファイル名ハンドラーが処理する操作です:

‘access-file’、‘add-name-to-file’、‘byte-compiler-base-file-name’、
‘copy-directory’、‘copy-file’、‘delete-directory’、‘delete-file’、
‘diff-latest-backup-file’、‘directory-file-name’、‘directory-files’、
‘directory-files-and-attributes’、‘dired-compress-file’、
‘dired-uncache’、
‘expand-file-name’、‘file-accessible-directory-p’、‘file-acl’、
‘file-attributes’、‘file-directory-p’、‘file-equal-p’、
‘file-executable-p’、‘file-exists-p’、‘file-in-directory-p’、
‘file-local-copy’、‘file-modes’、‘file-name-all-completions’、
‘file-name-as-directory’、‘file-name-completion’、
‘file-name-directory’、‘file-name-nondirectory’、
‘file-name-sans-versions’、‘file-newer-than-file-p’、
‘file-notify-add-watch’、‘file-notify-rm-watch’、
‘file-ownership-preserved-p’、‘file-readable-p’、‘file-regular-p’、
‘file-remote-p’、‘file-selinux-context’、‘file-symlink-p’、
‘file-truename’、‘file-writable-p’、‘find-backup-file-name’、
‘get-file-buffer’、‘insert-directory’、‘insert-file-contents’、
‘load’、‘make-auto-save-file-name’、‘make-directory’、
‘make-directory-internal’、‘make-symbolic-link’、
‘process-file’、‘rename-file’、‘set-file-acl’、‘set-file-modes’、
‘set-file-selinux-context’、‘set-file-times’、
‘set-visited-file-modtime’、‘shell-command’、‘start-file-process’、
‘substitute-in-file-name’、
‘unhandled-file-name-directory’、‘vc-registered’、
‘verify-visited-file-modtime’、
‘write-region’

   ‘insert-file-contents’にたいするハンドラーは通常、VISIT引数が非
‘nil’の場合は、‘(set-buffer-modified-p nil)’によりそのバッファーの変更フ
ラグをクリアーする必要があります。これには、もしそのバッファーがロックさ
れていたら、ロックを解除する効果もあります。

   ハンドラー関数は上記すべての操作を処理しなければならず、他の操作が将
来追加される可能性もあります。これらの操作自体すべてを実装する必要はあり
ません — 特定の操作にたいして特別なことを行う必要がないときは、その操作
を“通常の方法”で処理するよう、そのプリミティブを再呼び出しできます。認識
できない操作にたいしては、常にそのプリミティブを再呼び出しするべきです。
以下は、これを行う方法の1つです:

     (defun my-file-handler (operation &rest args)
       ;; 特別に処理する必要がある、
       ;; 特別な操作を最初にチェックする
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; 関知しないその他の操作を処理する
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))

   ハンドラー関数が通常のEmacsプリミティブを呼び出す決定をした際は、無限
再起を引き起こすような、同一ハンドラーからのプリミティブの再呼び出しを防
ぐ必要があります。上記の例では、変数‘inhibit-file-name-handlers’と
‘inhibit-file-name-operation’により、これを行う方法を示しています。上記
の例のように、これらを正確に使用するよう、注意してください。複数ハンドラ
ーの正しい振る舞い、およびそれぞれがハンドラーをもつかもしれない2つのフ
ァイル名にたいする操作にたいする詳細は、非常に重要です。

   ファイルへの実アクセスにたいして実際には特別なことを行わないハンドラ
ー(たとえばリモートファイル名にたいしてホスト名の補完を実装するハンドラ
ーなど)は、‘safe-magic’プロパティに非‘nil’をもつべきです。たとえば、
Emacsは通常は‘PATH’内で見い出されるようなディレクトリーが、プレフィック
ス‘/:’によりmagicファイル名に見えるような場合に、magicファイル名にならな
いよう“保護”します。しかし、‘safe-magic’プロパティに非‘nil’をもつハンド
ラーがそれらにたいして使用された場合、‘/:’は追加されません。

   ファイル名ハンドラーは、普通とは異なる方法でそれを処理(handle)するの
が、どの操作(operation)なのかを宣言するために、‘operations’プロパティを
もつことができます。このプロパティが非‘nil’値をもつ場合、それは操作のリ
ストであるべきです。その場合は、それらの操作だけがハンドラーを呼び出すで
しょう。これは無駄を省きますが、主な目的はオートロードされるハンドラー関
数が実際に処理を行うとき以外はロードされないようにすることです。

   通常のプリミティブにたいして、単にすべての操作を延期するのは、機能し
ません。たとえば、ファイル名ハンドラーが‘file-exists-p’にたいして適用さ
れた場合は、通常の‘load’コードは正しく機能しないでしょうから、ハンドラー
自身で‘load’を処理しなければなりません。しかし、ハンドラーが
‘file-exists-p’プロパティを使用して、‘file-exists-p’を処理しないことを宣
言した場合は、普通とは異なる方法で‘load’を処理する必要はなくなります。

 -- Variable: inhibit-file-name-handlers
     この変数は、特定の操作にたいして現在のところ使用を抑制されているハ
     ンドラーのリストを保持する。

 -- Variable: inhibit-file-name-operation
     特定のハンドラーにたいして、現在のところ抑制されている操作。

 -- Function: find-file-name-handler file operation
     この関数は、FILEというファイル名にたいするハンドラー関数、それが存
     在しなければ‘nil’をリターンする。引数OPERATIONは、そのファイルを処
     理する操作であること。これは、ハンドラー呼び出し時に1つ目の引数とし
     て渡すことになる値である。OPERATIONが
     ‘inhibit-file-name-operation’と等しい、またはそのハンドラーの
     ‘operations’内に存在しない場合、この関数は‘nil’をリターンする。

 -- Function: file-local-copy filename
     この関数は、ファイルFILENAMEがまだローカルマシン上にない場合は、そ
     れをローカルマシン上の通常の非magicファイルにコピーする。magicファ
     イル名は、それらが他のマシン上のファイルを参照する場合は、
     ‘file-local-copy’操作を処理するべきである。リモートファイルアクセス
     以外の目的にたいして使用されるmagicファイル名は、
     ‘file-local-copy’を処理するべきではない。その場合、この関数はそのフ
     ァイルをローカルファイルとして扱うだろう。

     FILENAMEがローカルの場合、それがmagicか否かにかかわらず、この関数は
     何も行わずに、‘nil’をリターンする。それ以外では、ローカルコピーファ
     イルのファイル名をリターンする。

 -- Function: file-remote-p filename &optional identification connected
     この関数は、FILENAMEがリモートファイルかどうかをテストする。
     FILENAMEがローカル(リモートではない)の場合、リターン値は‘nil’である
     。FILENAMEが正にリモートの場合、リターン値はそのリモートシステムを
     識別する文字列である。

     この識別子文字列は、ホスト名とユーザー名、およびリモートシステムへ
     のアクセスに使用されるメソッドを表す文字列も同様に含めることができ
     る。たとえば、ファイル名‘/sudo::/some/file’にたいするリモート識別子
     文字列は、‘/sudo:root@localhost:’となる。

     2つの異なるファイルにたいして‘file-remote-p’が同じ識別子をリターン
     した場合は、それらが同じファイルシステム上に格納されていて、互いに
     配慮しつつアクセス可能であることを意味する。これはたとえば、同時に
     両方のファイルにアクセスするリモートプロセスを開始することが可能な
     ことを意味する。ファイルハンドラーの実装者は、この方式を保証する必
     要がある。

     IDENTIFICATIONは、文字列としてリターンされるべき識別子の一部を指定
     する。IDENTIFICATIONには‘method’、‘user’、‘host’のシンボルを指定で
     きる。他の値はすべて‘nil’のように扱われ、それは完全な識別子文字列を
     リターンすることを意味する。上記の例では、リモートの‘user’識別子文
     字列は、‘root’になるだろう。

     CONNECTEDが非‘nil’の場合、たとえFILENAMEがリモートであっても、
     Emacsがそのホストにたいする接続をもたない場合、この関数は‘nil’をリ
     ターンする。これは、接続が存在しない際の接続の遅延を回避したいとき
     に有用である。

 -- Function: unhandled-file-name-directory filename
     この関数は、magicではないディレクトリーの名前をリターンする。これは
     、FILENAMEがmagicでなければ、それのディレクトリーパートを使用する。
     magicファイル名にたいしては、何の値をリターンするかを決定するために
     、ファイル名ハンドラーを呼び出す。FILENAMEがローカルプロセスからア
     クセス不能な場合、ファイル名ハンドラーは‘nil’をリターンすることによ
     り、それを示すべきである。

     これは、サブプロセスの実行に有用である。すべてのサブプロセスは、自
     身が属すカレントディレクトリーとして非magicディレクトリーをもたなけ
     ればならず、この関数はそれを導出するよい手段である。

 -- User Option: remote-file-name-inhibit-cache
     リモートファイルの属性は、よりよいパフォーマンスのためにキャッシュ
     することができる。キャッシュがEmacsの制御外で変更された場合、そのキ
     ャッシュ値は無効になり、再読込しなければならない。

     この変数が‘nil’にセットされていると、キャッシュ値は決して失効しない
     。このセッティングは、Emacs以外にリモートファイルを変更するものがな
     いことが確実な場合のみ、慎重に使用すること。これが‘t’にセットされて
     いると、キャッシュ値は決して使用されない。これはもっとも安全な値で
     あるが、パフォーマンスは低下するかもしれない。

     折衷的な値としては、これを正の数字にセットする。これは、キャッシュ
     されてからその数字の秒数の間は、キャッシュ値を使用することを意味す
     る。リモートファイルが定期的にチェックされる場合には、この変数を定
     期的なチェックの間隔より小さい値にletバインドするのは、よい考えかも
     しれない。たとえば:

          (defun display-time-file-nonempty-p (file)
            (let ((remote-file-name-inhibit-cache
                   (- display-time-interval 5)))
              (and (file-exists-p file)
                   (< 0 (nth 7 (file-attributes
                                 (file-chase-links file)))))))


File: elisp,  Node: Format Conversion,  Prev: Magic File Names,  Up: Files

24.12 File Format Conversion
============================

Emacsは、バッファー内のデータ(テキスト、テキストプロパティ、あるいはその
他の情報)と、ファイル名に格納するのに適した表現との間で双方向の変換をす
るために、複数のステップを処理します。このセクションでは、この“フォーマ
ット変換(format conversion)”を行う基本的な関数、すなわちファイルをバッフ
ァーに読み込む‘insert-file-contents’と、バッファーをファイルに書き込む
‘write-region’を説明します。

* Menu:

* Overview: Format Conversion Overview.  ‘insert-file-contents’と‘write-region’
* Round-Trip: Format Conversion Round-Trip.  ‘format-alist’の使用。
* Piecemeal: Format Conversion Piecemeal.  非ペアー変換の指定。


File: elisp,  Node: Format Conversion Overview,  Next: Format Conversion Round-Trip,  Up: Format Conversion

24.12.1 Overview
----------------

関数‘insert-file-contents’:

   • 最初に、ファイルからバイトをバッファーに挿入し、
   • バイトを適切な文字にデコードした後、
   • ‘format-alist’のエントリーにより定義されているようにフォーマット処
     理して、
   • ‘after-insert-file-functions’内の関数を呼び出す。

関数‘write-region’:

   • 最初に、‘write-region-annotate-functions’内の関数を呼び出し、
   • ‘format-alist’のエントリーにより定義されているようにフォーマット処
     理して、
   • 文字を適切なバイトにエンコードした後、
   • そのバイトでファイルを変更する。

   これは、もっとも低レベルでの操作を対照的に示したもので、対象の読み取
りと書き込みの処理が逆順で対応しています。このセクションの残りでは、上記
で名前のでた3つの変数を取り囲む2つの機能と、いくつかの関連する関数を説明
します。文字のエンコードとデコードについての詳細は、*note Coding
Systems::を参照してください。


File: elisp,  Node: Format Conversion Round-Trip,  Next: Format Conversion Piecemeal,  Prev: Format Conversion Overview,  Up: Format Conversion

24.12.2 Round-Trip Specification
--------------------------------

読み取りと書き込みのもっとも一般的な機能は、変数‘format-alist’で制御され
ます。これは“ファイルフォーマット(file format)”仕様のリストで、Emacsバッ
ファー内のデータにたいして、ファイル内で使用されるテキスト表現を記述しま
す。読み取りと書き込みの仕様記述はペアーになっており、わたしたちがそれを
“ラウンドトリップ(round-trip)”仕様と呼ぶのは、これが理由です(非ペアー仕
様については、*note Format Conversion Piecemeal::を参照)。

 -- Variable: format-alist
     このリストには、定義されるファイルフォーマットごとに、1つのフォーマ
     ット定義が含まれる。フォーマット定義はそれぞれ、以下の形式のリスト
     である:

          (NAME DOC-STRING REGEXP FROM-FN TO-FN MODIFY MODE-FN PRESERVE)

以下は、フォーマット定義内で要素がもつ意味である:

NAME
     フォーマットの名前。

DOC-STRING
     フォーマットのドキュメント文字列。

REGEXP
     このフォーマットで表現されるファイルの認識に使用される正規表現。
     ‘nil’の場合、フォーマットが自動的に適用されることは決してない。

FROM-FN
     このフォーマットのデータをデコードする、(ファイルデータを通常の
     Emacsデータ表現に変換するための)シェルコマンド、または関数。

     シェルコマンドは文字列として表され、Emacsはそのコマンドを、変換処理
     のためのフィルターとして実行する。

     FROM-FNが関数の場合、それは変換するべきバッファー部分を指定する2つ
     の引数、BEGINとENDで呼び出される。これは、インプレースでテキストを
     編集することにより変換を行うべきである。これはテキスト長を変更する
     可能性があるので、FROM-FNは変更されたend位置をリターンすること。

     ファイルの先頭が、この変換によりREGEXPにマッチしないようにするのは
     、FROM-FNの役目の1つである。そうでないと、おそらく再度変換が呼び出
     される。

TO-FN
     このフォーマットのデータをエンコード、すなわち通常のEmacsデータ表現
     をこのフォーマットに変換するためのシェルコマンド、または関数。

     TO-FNが文字列の場合、それはシェルコマンドである。Emacsは変換処理の
     ためのフィルターとして、このコマンドを実行する。

     TO-FNが関数の場合、それは3つの引数で呼び出される。BEGINとENDは変換
     されるべきバッファー部分、BUFFERでそれがどのバッファーかを指定する
     。変換を行うには、2つの方法がある:

        • そのバッファー内でインプレースで編集を行う。この場合、TO-FNは
          変更にしたがい、テキスト範囲のend位置をリターンするべきである
          。

        • 注釈(annotation)のリストをリターンする。これは、‘(POSITION .
          STRING)’という形式の要素をもつリストで、POSITIONは書き込まれる
          テキスト内での相対位置を指定する整数、STRINGはそこに追加される
          注釈である。このリストは、TO-FNがそれをリターンする際、位置順
          でソートされていなければならない。

          ‘write-region’が実際にバッファーからファイルにテキストを書き込
          む際には、指定された注釈を対応する位置に混合する。これはすべて
          、バッファーを変更せずに行われる。

MODIFY
     フラグ。エンコード関数がバッファーを変更する場合は‘t’、注釈リストを
     リターンすることにより機能する場合は‘nil’。

MODE-FN
     このフォーマットから変換されたファイルをvisit後に呼び出される、マイ
     ナーモード関数。この関数は1つの引数で呼び出され、それが整数1の場合
     、マイナーモード関数はそのモードを有効にする。

PRESERVE
     フラグ。‘format-write-file’が‘buffer-file-format’からこのフォーマッ
     トを取り除くべきでない場合は‘t’。

   関数‘insert-file-contents’は、指定されたファイルを読み込む際にファイ
ルフォーマットを自動的に認識します。これは、フォーマット定義の正規表現に
たいしてファイルの先頭テキストをチェックして、マッチが見つかった場合は、
そのフォーマットにたいするデコード関数を呼び出します。その後は再度、既知
のフォーマットすべてをチェックします。適用できるフォーマットがない間は、
チェックを続行します。

   ‘find-file-noselect’、またはそれを使用するコマンドでファイルをvisitす
ることにより、同じように変換が行われます(内部で‘insert-file-contents’を
呼び出すため)。さらに、それをデコードする各フォーマットのモード関数も呼
び出します。これは、バッファーローカル変数‘buffer-file-format’内に、フォ
ーマット名のリストを格納します。

 -- Variable: buffer-file-format
     この変数は、visitしているファイルのフォーマットを表す。より正確には
     、これはカレントバッファーのファイルをvisitに起因するデコードのファ
     イルフォーマット名のリストである。これは、すべてのバッファーにたい
     して、常にローカルである。

   ‘write-region’がデータをファイルに書き込む際には、まず
‘buffer-file-format’にリストされたフォーマットにたいするエンコード関数を
、リスト内での出現順に呼び出します。

 -- Command: format-write-file file format &optional confirm
     このコマンドは、カレントバッファーのコンテンツを、フォーマット名の
     リストFORMATにもとづいたフォーマットで、ファイルFILEに書き込む。こ
     れはFORMATを起点に、‘buffer-file-format’の値からPRESERVEフラグ(上記
     参照)が非‘nil’の要素にたいして、それがまだFORMAT内に存在しない場合
     は、任意の個数それらを追加する。その後、将来の保存においてデフォル
     トとなるよう、このフォーマットで‘buffer-file-format’を更新する。
     FORMAT引数を除き、このコマンドは‘write-file’と似ている。特に、
     CONFIRMは‘write-file’での対応する引数と、意味およびinteractiveでの
     扱いが同じである。*note Definition of write-file::を参照のこと。

 -- Command: format-find-file file format
     このコマンドは、ファイルFILEを探して、それをフォーマットFORMATにし
     たがって変換する。これは、後でそのバッファーを保存する場合に、
     FORMATをデフォルトにすることも行う。

     引数FORMATは、フォーマット名のリストである。FORMATが‘nil’の場合、何
     の変換も行われない。interactiveに呼び出した場合は、FORMATにたいして
     単に<RET>をタイプすると、‘nil’が指定される。

 -- Command: format-insert-file file format &optional beg end
     このコマンドは、ファイルFILEのコンテンツを、フォーマットFORMATにし
     たがって変換して挿入する。BEGとENDが非‘nil’の場合、それは
     ‘insert-file-contents’と同様、ファイルのどの部分を読み込むかを指定
     する(*note Reading from Files::を参照)。

     リターン値は、絶対ファイル名のリスト、および挿入されたデータの長さ
     (変換後)であり、これは‘insert-file-contents’がリターンするものと同
     様である。

     引数FORMATは、フォーマット名のリストである。FORMATが‘nil’の場合、何
     の変換も行われない。interactiveに呼び出した場合は、FORMATにたいして
     単に<RET>をタイプすると、‘nil’が指定される。

 -- Variable: buffer-auto-save-file-format
     この変数は、自動保存(auto-saving)にたいして使用するフォーマットを指
     定する。値は‘buffer-file-format’と同様、ファイル名のリストであるが
     、これはauto-saveファイルへの書き込みで、‘buffer-file-format’のかわ
     りに使用される。値が‘t’(デフォルト)の場合、自動保存は当バッファーの
     通常の保存時と同じフォーマットを使用する。この変数は、すべてのバッ
     ファーにおいて、常にバッファーローカルである。


File: elisp,  Node: Format Conversion Piecemeal,  Prev: Format Conversion Round-Trip,  Up: Format Conversion

24.12.3 Piecemeal Specification
-------------------------------

前のサブセクション(*note Format Conversion Round-Trip::を参照)で説明した
ラウンドトリップ指定とは対照的に、変数‘after-insert-file-functions’と
‘write-region-annotate-functions’を使用して、読み取りと書き込みの変換を
個別に制御できます。

   変換は、ある表現を起点として、他の表現を生成します。これを行う変換が
1つだけのときは、何を起点とするかに関して競合は存在しません。しかし、複
数の変換呼び出しが存在する場合、同じデータを起点にする必要がある2つの変
換の間に、競合が発生するかもしれません。

   この状況を理解するには、‘write-region’中のテキストプロパティの変換コ
ンテキストが最善です。たとえば、あるバッファーの位置42の文字が‘X’で、そ
れのテキストプロパティが‘foo’だとします。‘foo’にたいする変換が、たとえば
そのバッファーに‘FOO:’を挿入することにより行われる場合、それは位置42の文
字‘X’を‘F’に変更します。そして次の変換は、間違ったデータを起点に開始され
るでしょう。

   競合を避けるためには、協調的な変換がバッファーを変更せずに、
POSITION昇順でソートされた、‘(POSITION . STRING)’という形式の要素をもつ
リストを、“注釈(annotations)”に指定します。

   2つ以上の変換が存在する場合、‘write-region’はそれらの注釈を、1つのソ
ート済みリストに破壊的にマージします。後でそのバッファーのテキストを実際
にファイルに書き込む際に、対応する位置にある指定された注釈を混合します。
これはすべて、バッファーを変更せずに行われます。

   これとは対照的に、読み取り時にはそのテキストの混合された注釈は、即座
に処理されます。‘insert-file-contents’は、変更される何らかのテキストの先
頭にポイントをセットしてから、そのテキストの長さで変換関数を呼び出します
。これらの関数は常に、挿入されるテキストの先頭のポイントをリターンするべ
きです。最初の変換により注釈が削除されても、その後の変換が誤って処理する
ことはないので、このアプローチは読み取りに際しては正しく機能します。すべ
ての変換関数は、それが認識する注釈のスキャン、その注釈の削除、バッファー
テキストの変更(たとえばテキストプロパティのセット等)、およびそれらの変更
に由来する更新されたテキスト長のリターンを行うべきです。１つの関数により
リターンされた値は、次の関数への引数になります。

 -- Variable: write-region-annotate-functions
     ‘write-region’にたいして呼び出す、関数のリスト。リスト内の各関数は
     、書き込まれるリージョンの開始と終了の、2つの引数で呼び出される。こ
     れらの関数は、そのバッファーのコンテンツを変更するべきではない。か
     わりに注釈をリターンすること。

     特別なケースとして、関数がカレントと異なるバッファーをリターンする
     かもしれない。Emacsはこれを、カレントバッファーが出力される変更され
     たテキストを含むものとして理解する。つまり、Emacsは‘write-region’呼
     び出しの引数STARTとENDを、新たなバッファーの‘point-min’と
     ‘point-max’に変更して与える。さらに、以前のすべての注釈はこの関数に
     より処理されるので、Emacsはそれらの破棄も行う。

 -- Variable: write-region-post-annotation-function
     この変数の値が非‘nil’の場合、それは関数であること。この関数は、
     ‘write-region’完了後に引数なしで呼び出される。

     ‘write-region-annotate-functions’内のある関数がカレントと異なるバッ
     ファーをリターンした場合、Emacsは
     ‘write-region-post-annotation-function’を複数回呼び出す。Emacsは最
     後にカレントだったバッファーでそれを呼び出し、その前にカレントだっ
     たバッファーで再度これを呼び出す、...のようにして元のバッファーに戻
     る。

     したがって、‘write-region-annotate-functions’内の関数は、バッファー
     を作成して、‘kill-buffer’のそのバッファーでのローカル値にこの変数を
     与え、変更されたテキストでそのバッファーをセットアップして、そのバ
     ッファーをカレントにすることができる。そのバッファーは、
     ‘write-region’完了後にkillされるだろう。

 -- Variable: after-insert-file-functions
     このリスト内の各関数は、挿入されるテキストの先頭にポイントがある状
     態で、挿入される文字数を１つの引数として、‘insert-file-contents’に
     より呼び出される。すべての関数はポイントを未変更のまま、その関数に
     よって変更された、挿入後テキストの新たな文字数をリターンするべきで
     ある。

   わたしたちは、ユーザーがファイル内にテキストプロパティを格納したりそ
れらを取得するために、そしてさまざまなデータフォーマットを体験することに
より、適切なフォーマットを見つけるために、これらのフックを使用してLispプ
ログラムを記述することを推奨します。最終的には、わたしたちがEmacs内にイ
ンストールできる、良質で汎用性のある拡張をユーザーが開発することを望みま
す。

   わたしたちは、テキストプロパティの名前や値として、任意のLispオブジェ
クトの処理を試みることは推奨しません — なぜなら汎用的なプログラムはおそ
らく記述が困難で、かつ低速だからです。かわりに、十分な柔軟性をもち、エン
コードが難しすぎない、想定されるデータ型のセットを選択してください。


File: elisp,  Node: Backups and Auto-Saving,  Next: Buffers,  Prev: Files,  Up: Top

25 Backups and Auto-Saving
**************************

バックアップファイルおよびauto-save(自動保存)ファイルは、Emacsがクラッシ
ュ、またはユーザー自身のエラーからユーザーの保護を試みるための、2つの手
段です。自動保存(auto-saving)は、カレントの編集セッション開始以降のテキ
ストを保存します。一方バックアップファイルは、カレントセッションの前のフ
ァイルコンテンツを保存します。

* Menu:

* Backup Files::             バックアップファイルの作成と名前選択の方法。
* Auto-Saving::              auto-saveファイルの作成と名前選択の方法。
* Reverting::                ‘revert-buffer’とその動作のカスタマイズ方法。


File: elisp,  Node: Backup Files,  Next: Auto-Saving,  Up: Backups and Auto-Saving

25.1 Backup Files
=================

“バックアップファイル(backup file)”とは、編集中ファイルの古いコンテンツ
のコピーです。Emacsは、visitされているファイルにバッファーを最初に保存す
るとき、バックアップファイルを作成します。したがって、バックアップファイ
ルには通常、カレント編集セッションの前にあったような、ファイルのコンテン
ツが含まれています。バックアップファイルのコンテンツには、通常は一度存在
したバックアップファイルが変更されずに残ります。

   バックアップは通常、visitされているファイルを新たな名前にリネームする
ことにより作成されます。オプションで、バックアップファイルがvisitされて
いるファイルをコピーすることにより作成されるように指定できます。この選択
により、複数の名前をもつファイルのときに、違いが生じます。また、編集中の
ファイルの所有者が元のオーナーのままか、それとも編集ユーザーになるかにも
、影響し得ます。

   デフォルトでは、Emacsは編集中のファイルごとに、単一のバックアップファ
イルを作成します。かわりに、番号付きバックアップ(numbered backup)を要求
することもできます。その場合は、新たなバックアップファイルそれぞれが、新
たな名前を得ます。必要なくなったときは古い番号付きバックアップを削除した
り、Emacsがそれらを自動的に削除することもできます。

* Menu:

* Making Backups::           Emacsがバックアップファイルを作成する方法とタイミング。
* Rename or Copy::           2つの選択肢:
                               古いファイルのリネームとコピー。
* Numbered Backups::         ソースファイルごとに複数のバックアップを保持する。
* Backup Names::             バックアップファイル名の計算方法とカスタマイズ。


File: elisp,  Node: Making Backups,  Next: Rename or Copy,  Up: Backup Files

25.1.1 Making Backup Files
--------------------------

 -- Function: backup-buffer
     この関数は、もしそれが適切であれば、カレントバッファーにvisitされて
     いるファイルのバックアップを作成する。これは、最初のバッファー保存
     を行う前に、‘save-buffer’により呼び出される。

     リネームによりバックアップが作成された場合、リターン値は(MODES
     EXTRA-ALIST BACKUPNAME)という形式のコンスセルである。ここでMODESは
     、‘file-modes’(*note Testing Accessibility::を参照)でリターンされる
     ような元ファイルのモードビット、EXTRA-ALISTは
     ‘file-extended-attributes’(*note Extended Attributes::を参照)により
     リターンされるような元ファイルの拡張属性を示すalist、そして
     BACKUPNAMEはバックアップの名前である。

     他のすべての場合(コピーによりバックアップが作成された、またはバック
     アップが作成されなかった)、この関数は‘nil’をリターンする。

 -- Variable: buffer-backed-up
     このバッファーローカル変数は、そのバッファーのファイルがバッファー
     によりバックアップされたかどうかを明示する。非‘nil’の場合、バックア
     ップファイルは書き込み済みであり、それ以外では、(バックアップが有効
     なら)次回保存時にファイルはバックアップされる。この変数は永続的にロ
     ーカルであり、‘kill-all-local-variables’はそれを変更しない。

 -- User Option: make-backup-files
     この変数は、バックアップファイルを作成するかどうかを決定する。非
     ‘nil’の場合、Emacsは初回保存時にすべてのファイルのバックアップを作
     成する — ただし‘backup-inhibited’が‘nil’の場合(以下参照)。

     以下の例は、Rmailバッファーだけで変数‘make-backup-files’を変更して
     、それ以外では変更しない方法を示す。この変数を‘nil’にセットすると、
     Emacsはそれらのファイルのバックアップ作成をストップし、それはディス
     ク容量の消費を節約するだろう(あなたは、このコードをinitファイルに配
     置したいと思うかもしれない)。

          (add-hook 'rmail-mode-hook
                    (lambda () (setq-local make-backup-files nil)))

 -- Variable: backup-enable-predicate
     この変数の値は、あるファイルがバックアップファイルをもつべきかどう
     かを決定する、特定の機会に呼び出される関数である。関数は、判断すべ
     き絶対ファイル名という、1つの引数を受け取る。この関数が‘nil’をリタ
     ーンした場合、そのファイルにたいするバックアップは無効になる。それ
     以外では、このセクション内の他の変数がバックアップ作成の是非と方法
     を指定する。

     デフォルト値は‘normal-backup-enable-predicate’で、これは
     ‘temporary-file-directory’と‘small-temporary-file-directory’内のフ
     ァイルをチェックする。

 -- Variable: backup-inhibited
     この変数が非‘nil’の場合、バックアップは抑止される。これは、visitさ
     れているファイル名にたいする‘backup-enable-predicate’のテスト結果を
     記録する。さらに、visitされているファイルにたいするバックアップ抑止
     にもとづくその他機構によっても、使用され得る。たとえば、VCはバージ
     ョンコントロールシステムに管理されるファイルのバックアップを防ぐた
     めに、この変数を非‘nil’にセットする。

     これは永続的にローカルなので、メジャーモード変更により値は失われな
     い。メジャーモードはこの変数ではなく、かわりに‘make-backup-files’を
     セットするべきである。

 -- User Option: backup-directory-alist
     この変数の値は、ファイル名パターンとバックアップディレクトリー名の
     alistである。各要素は以下の形式をもつ
          (REGEXP . DIRECTORY)

     名前がREGEXPにマッチするファイルのバックアップが、DIRECTORY内に作成
     されるだろう。DIRECTORYには相対ディレクトリー、または絶対ディレクト
     リーを指定できる。絶対ディレクトリーの場合は、マッチするすべてのフ
     ァイルが同じディレクトリー内にバックアップされる。このディレクトリ
     ー内でのファイル名は、クラッシュを避けるために、バックアップされる
     ファイルの完全名のすべてのディレクトリー区切りは、‘!’に変更される。
     結果の名前を切り詰めるファイルシステムでは、これは正しく機能しない
     だろう。

     すべてのバックアップが単一のディレクトリーで行われる一般的なケース
     では、alistは‘"."’と適切なディレクトリーからなるペアーの、単一の要
     素を含むべきである。

     この変数が‘nil’(デフォルト)、またはファイル名のマッチに失敗した場合
     、バックアップは元のファイルのディレクトリーに作成される。

     長いファイル名のないMS-DOSファイルシステムでは、この変数は常に無視
     される。

 -- User Option: make-backup-file-name-function
     この変数の値は、バックアップファイル名を作成する関数である。関数
     ‘make-backup-file-name’は、これを呼び出す。*note Naming Backup
     Files: Backup Names.を参照のこと。

     特定のファイルにたいして特別なことを行うために、これをバッファーロ
     ーカルにすることもできる。変更する場合は、‘backup-file-name-p’と
     ‘file-name-sans-versions’も変更する必要があるかもしれない。


File: elisp,  Node: Rename or Copy,  Next: Numbered Backups,  Prev: Making Backups,  Up: Backup Files

25.1.2 Backup by Renaming or by Copying?
----------------------------------------

Emacsがバックアップファイルを作成できる、2つの方法があります:

   • Emacsは元のファイルをリネームすることができ、それがバックアップファ
     イルになる。その後、バッファーの保存は新たなファイルに書き込まれる
     。この手順後、元ファイルの他のすべての名前(ハードリンク)はバックア
     ップファイルを参照することになる。新たなファイルの所有者は編集を行
     っているユーザーになり、グループはそのディレクトリー内でそのユーザ
     ーが新たなファイルを書き込んだときのデフォルトのグループになる。

   • Emacsは元のファイルをバックアップファイルにコピーでき、新たな内容は
     その後、元のファイルに上書きされる。この手順後、元のファイルの他の
     すべての名前(ハードリンク)は、そのファイルの(更新された)カレントバ
     ージョンを参照し続ける。ファイルの所有者とグループは変更されない。

   デフォルトは、1つ目の方法のリネームです。

   変数‘backup-by-copying’が非‘nil’の場合、それは2つ目の方法、つまり元の
ファイルをコピーして、新たなバッファー内容で上書きすることを意味します。
変数‘file-precious-flag’が非‘nil’の場合にも、(メイン機能の副作用として
)この効果があります。*note Saving Buffers::を参照してください。

 -- User Option: backup-by-copying
     この変数が非‘nil’の場合、Emacsは常にコピーによりバックアップファイ
     ルを作成する。デフォルトは‘nil’。

   以下の3つの変数が非‘nil’の際は、ある特定のケースに2つ目の方法が使用さ
れます。その特定のケースに該当しないファイルの処理に影響はありません。

 -- User Option: backup-by-copying-when-linked
     この変数が非‘nil’の場合、Emacsは複数名(ハードリンク)をもつファイル
     にたいして、コピーによりバックアップを作成する。デフォルトは‘nil’。

     ‘backup-by-copying’が非‘nil’の場合は常にコピーによりバックアップが
     作成されるので、この変数は‘backup-by-copying’が‘nil’のときだけ意味
     がある。

 -- User Option: backup-by-copying-when-mismatch
     この変数が非‘nil’(デフォルト)の場合、リネームによりファイルの所有者
     、またはグループが変更されるケースでは、Emacsはコピーによりバックア
     ップを作成する。

     リネームによりファイルの所有者、またはグループが変更されない場合、
     値は効果をもたない。つまり、そのディレクトリーで新たに作成されるフ
     ァイルにたいするデフォルトのグループに属するユーザーにより所有され
     るファイルが該当する。

     ‘backup-by-copying’が非‘nil’の場合は常にコピーによりバックアップが
     作成されるので、この変数は‘backup-by-copying’が‘nil’のときだけ意味
     がある。

 -- User Option: backup-by-copying-when-privileged-mismatch
     この変数が非‘nil’の場合、特定のユーザーID値(具体的には、特定の値以
     下のID数値)にたいしてのみ、‘backup-by-copying-when-mismatch’と同じ
     ように振る舞うことを指定する。変数には、その数値をセットする。

     したがって、ファイル所有者の変更を防ぐ必要がある際は、
     ‘backup-by-copying-when-privileged-mismatch’を0にセットすれば、スー
     パーユーザーだけがコピーによるバックアップを行うことができる。

     デフォルトは200。


File: elisp,  Node: Numbered Backups,  Next: Backup Names,  Prev: Rename or Copy,  Up: Backup Files

25.1.3 Making and Deleting Numbered Backup Files
------------------------------------------------

ファイルの名前が‘foo’の場合、番号付きバックアップのバージョン名は
‘foo.~V~’となります。Vは‘foo.~1~’、‘foo.~2~’、‘foo.~3~’、...、
‘foo.~259~’のように、さまざまな整数です。

 -- User Option: version-control
     この変数は、単一の非番号付きバックアップファイルを作成するか、それ
     とも複数の番号付きバックアップを作成するかを制御する。

     ‘nil’
          visitされたファイルが番号付きバックアップの場合は番号付きバッ
          クアップを作成し、それ以外は作成しない。これがデフォルトである
          。

     ‘never’
          番号付きバックアップを作成しない。

     ANYTHING ELSE
          番号付きバックアップを作成する。

   番号付きバックアップを使用することにより、バックアップのバージョン番
号は最終的には非常に大きな番号になるので、それらを削除しなければなりませ
ん。Emacsはこれを自動で行うことができ、ユーザーに削除するか確認すること
もできます。

 -- User Option: kept-new-versions
     この変数の値は、新たな番号付きバックアップが作成された際に保持すべ
     き、もっとも新しいバージョンの個数である。新たに作成されたバックア
     ップもカウントされる。デフォルトは2。

 -- User Option: kept-old-versions
     この変数の値は、新たな番号付きバックアップが作成された際に保持すべ
     き、もっとも古いバージョンの個数である。デフォルトは2。

   番号が1、2、3、5、7のバックアップがあり、かつこれらの変数が値2をもつ
場合は、番号が1と2のバックアップは古いバージョンとして保持され、番号が
5と7のバックアップは新しいバージョンとして保持される。そして、番号が3の
バックアップは、余分なバックアップとなる。関数
‘find-backup-file-name’(*note Backup Names::を参照)は、どのバージョンの
バックアップを削除するかを決定する役目を負うが、この関数自身がバックアッ
プを削除する訳ではない。

 -- User Option: delete-old-versions
     この変数が‘t’の場合は、ファイルの保存により、余分なバージョンのバッ
     クアップは、暗黙里に削除される。‘nil’の場合は、余分なバックアップの
     削除前に確認を求めることを意味し、それ以外では、余分なバックアップ
     は削除されない。

 -- User Option: dired-kept-versions
     この変数は、Dired内のコマンド‘.’(ピリオド。
     ‘dired-clean-directory’)で、もっとも新しいバージョンのバックアップ
     をいくつ保持するかを指定する。これは、新たにバックアップファイルを
     作成する際に、‘kept-new-versions’を指定するのと同等である。デフォル
     トは2。


File: elisp,  Node: Backup Names,  Prev: Numbered Backups,  Up: Backup Files

25.1.4 Naming Backup Files
--------------------------

このセクションでは、主にバックアップファイルの命名規則を再定義してカスタ
マイズできる関数を記載します。これらの1つを変更した場合は、おそらく残り
も変更する必要があります。

 -- Function: backup-file-name-p filename
     この関数は、FILENAMEがバックアップファイルとして利用可能ならば、非
     ‘nil’値をリターンする。これは名前のチェックだけを行い、FILENAMEとい
     う名前のファイルが存在するかどうかはチェックしない。

          (backup-file-name-p "foo")
               ⇒ nil
          (backup-file-name-p "foo~")
               ⇒ 3

     この関数の標準的な定義は、以下のようになる:

          (defun backup-file-name-p (file)
            "FILEがバックアップファイルなら\
          (番号付きか否かに関わらず)非nilをリターンする"
            (string-match "~\\'" file))

     このように、ファイル名が‘~’で終わる場合、この関数は非‘nil’値をリタ
     ーンする(ドキュメント文字列を分割するために、1行目でバックスラッシ
     ュを使用しているが、これはドキュメント文字列内で単一行を生成する)。

     この単純な式は、カスタマイズのための再定義を簡便にするために、個々
     の関数内に配されている。

 -- Function: make-backup-file-name filename
     この関数は、ファイルFILENAMEの非番号付きバックアップファイル名とし
     て使用される文字列をリターンする。Unixでは、これは単にFILENAMEにチ
     ルダを追加する。

     ほとんどのオペレーティングシステムでは、この関数の標準的な定義は以
     下のようになる:

          (defun make-backup-file-name (file)
            "FILEにたいして非番号付きバックアップファイル名を作成する"
            (concat file "~"))

     この関数を再定義することにより、バックアップファイルの命名規則を変
     更できる。以下は、チルダの追加に加えて、先頭に‘.’を追加するよう、
     ‘make-backup-file-name’を再定義する例である:

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               ⇒ ".backups.texi~"

     Diredコマンドのいくつかを含むEmacsの一部では、バックアップファイル
     名が‘~’で終わると仮定している。この規則にしたがわない場合、深刻な問
     題とはならないだろうが、それらのコマンドが若干好ましくない結果をも
     たらすかもしれない。

 -- Function: find-backup-file-name filename
     この関数は、FILENAMEの新たなバックアップファイル用のファイル名を計
     算する。これは、特定の既存バックアップファイルにたいする削除の提案
     も行うかもしれない。‘find-backup-file-name’は、CARが新たなバックア
     ップファイル名で、CDRが削除を提案するバックアップファイルのリストで
     あるようなリストをリターンする。値には‘nil’も指定でき、これはバック
     アップが作成されないことを意味する。

     ‘kept-old-versions’および‘kept-new-versions’の2つの変数は、どのバー
     ジョンのバックアップを保持するべきかを決定する。この関数は、値の
     CDRから該当するバージョンを除外することにより、それらを保持する。
     *note Numbered Backups::を参照のこと。

     以下の例の値は、新しいバックアップファイルに使用する名前が
     ‘~rms/foo.~5~’で、‘~rms/foo.~3~’は呼び出し側が今削除を検討するべき
     “余分”なバージョンであることを示している。

          (find-backup-file-name "~rms/foo")
               ⇒ ("~rms/foo.~5~" "~rms/foo.~3~")

 -- Function: file-newest-backup filename
     この関数は、FILENAMEにたいするもっとも最近のバックアップファイル名
     、バックアップファイルがない場合は‘nil’をリターンする。

     ファイル比較関数のいくつかは、自動的にもっとも最近のバックアップを
     比較できるように、この関数を使用している。


File: elisp,  Node: Auto-Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto-Saving

25.2 Auto-Saving
================

Emacsは、visitしているすべてのファイルを定期的に保存します。これは“自動
保存(auto-saving)”と呼ばれます。自動保存は、システムがクラッシュした場合
に失われる作業量を、ある作業量以下にします。デフォルトでは、自動保存は
300キーストロークごと、またはidle時の30秒後に発生します。自動保存に関す
るユーザー向けの情報については、*note Auto Save: (emacs)Auto Save.を参照
してください。ここでは、自動保存の実施に使用される関数と、それらを制御す
る変数について説明します。

 -- Variable: buffer-auto-save-file-name
     このバッファーローカル変数は、カレントバッファーの自動保存に使用さ
     れるファイル名である。そのバッファーが自動保存されるべきでない場合
     は、‘nil’。

          buffer-auto-save-file-name
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

 -- Command: auto-save-mode arg
     これはバッファーローカルなマイナーモードであるAuto Saveモードにたい
     する、モードコマンドである。Auto Saveモードが有効なときは、そのバッ
     ファーで自動保存が有効である。呼び出し方は、他のマイナーモードと同
     様(*note Minor Mode Conventions::を参照)。

     ほとんどのマイナーモードとは異なり、‘auto-save-mode’変数は存在しな
     い。‘buffer-auto-save-file-name’が非‘nil’、かつ
     ‘buffer-saved-size’(以下参照)が非0ならば、Auto Saveモードは有効であ
     る。

 -- Function: auto-save-file-name-p filename
     この関数は、FILENAMEがauto-saveファイルのような文字列の場合は、非
     ‘nil’をリターンする。先頭と末尾がハッシュマーク(‘#’)の名前は
     auto-saveファイルの可能性があるという、auto-saveファイルにたいする
     通常の命名規則を想定する。引数FILENAMEは、ディレクトリーパートを含
     むべきではない。

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
          (auto-save-file-name-p "#backups.texi#")
               ⇒ 0
          (auto-save-file-name-p "backups.texi")
               ⇒ nil

     この関数の標準的な定義は、以下のようになる:

          (defun auto-save-file-name-p (filename)
            "FILENAMEが以下を満たすなら非nilをリターンする"
            (string-match "^#.*#$" filename))

     auto-saveファイルの命名規則規則を変更したいときにカスタマイズできる
     ようにするために、この関数は存在する。これを再定義した場合は、それ
     に対応して関数‘make-auto-save-file-name’も忘れずに再定義すること。

 -- Function: make-auto-save-file-name
     この関数は、カレントバッファーの自動保存に使用されるファイル名をリ
     ターンする。これは、ファイル名の先頭と末尾にハッシュマーク(‘#’)を単
     に追加する。この関数は、変数‘auto-save-visited-file-name’(以下参照
     )を調べない。呼び出し側は、まずその変数をチェックするべきである。

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

     以下は、この関数の標準的な定義の簡略版である:

          (defun make-auto-save-file-name ()
            "カレントバッファーの自動保存に使用される\
          ファイル名をリターンする"
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))

     auto-saveファイルの命名規則をカスタマイズするために再定義できるよう
     に、これは独立した関数として存在している。ただし、これに対応した方
     法で‘auto-save-file-name-p’も忘れずに変更すること。

 -- User Option: auto-save-visited-file-name
     この変数が非‘nil’の場合、Emacsはvisit中のファイルにバッファーを自動
     保存する。つまり、自動保存は編集中ファイルと同じファイルにたいして
     行われる。通常この変数は‘nil’なので、auto-saveファイルは
     ‘make-auto-save-file-name’で作成された別の名前をもつ。

     この変数の値を変更した際は、バッファー内でauto-saveモードが再度有効
     になるまで、既存バッファーにたいして新たな値は効果をもたない。すで
     にauto-saveモードが有効な場合は、再度‘auto-save-mode’が呼び出される
     まで、同じファイルに自動保存が行われる。

 -- Function: recent-auto-save-p
     この関数は、カレントバッファーが最後に読み込み、または保存されて以
     降、自動保存されていれば‘t’をリターンする。

 -- Function: set-buffer-auto-saved
     この関数は、カレントバッファーを自動保存済みとマークする。そのバッ
     ファーは、バッファーテキストが再度変更されるまで、自動保存されない
     だろう。この関数は‘nil’をリターンする。

 -- User Option: auto-save-interval
     この変数の値は、自動保存の頻度を入力イベント数で指定する。この分の
     入力イベント読み取りごとに、Emacsは自動保存が有効なすべてのバッファ
     ーにたいして、自動保存を行う。これを0にすると、タイプした文字数にも
     とづく自動保存は無効になる。

 -- User Option: auto-save-timeout
     この変数の値は、自動保存が発生すべきidle時間の秒数である。この秒数
     分ユーザーが休止するたびに、Emacsは自動保存が有効なすべてのバッファ
     ーにたいして、自動保存を行う(カレントバッファーが非常に大きい場合、
     指定されたタイムアウトはサイズ増加とともに増加される因子で乗ぜられ
     る。1MBのバッファーにたいして、この因子はおよそ4である)。

     値が0、または‘nil’の場合、idle時間にもとづく自動保存は行われず、
     ‘auto-save-interval’で指定される入力イベント数の後のみ自動保存が行
     われる。

 -- Variable: auto-save-hook
     このノーマルフックは、自動保存が行われようとするたびに毎回実行され
     る。

 -- User Option: auto-save-default
     この変数が非‘nil’の場合は、ファイルをvisitするバッファーの自動保存
     がデフォルトで有効になり、それ以外では有効にならない。

 -- Command: do-auto-save &optional no-message current-only
     この関数は、自動保存される必要があるすべてのバッファーを自動保存す
     る。これは自動保存が有効、かつ前回の自動保存以降に変更されたすべて
     のバッファーを保存する。

     いずれかのバッファーが自動保存される場合、通常‘do-auto-save’は自動
     保存が行われる間、それを示すメッセージ‘Auto-saving...’をエコーエリ
     アに表示する。しかし、NO-MESSAGEが非‘nil’の場合、このメッセージは抑
     制される。

     CURRENT-ONLYが非‘nil’の場合は、カレントバッファーだけが自動保存され
     る。

 -- Function: delete-auto-save-file-if-necessary &optional force
     この関数は、‘delete-auto-save-files’が非‘nil’なら、カレントバッファ
     ーのauto-saveファイルを削除する。これは、バッファー保存時に毎回呼び
     出される。

     FORCEが‘nil’の場合、この関数は最後に本当の保存が行われて以降、カレ
     ントEmacsセッションにより書き込まれたファイルだけを削除する。

 -- User Option: delete-auto-save-files
     この変数は、関数‘delete-auto-save-file-if-necessary’により使用され
     る。これが非‘nil’の場合、Emacsは(visitされているファイルに)本当に保
     存が行われたとき、auto-saveファイルを削除する。これはデスク容量を節
     約し、ディレクトリーを整理する。

 -- Function: rename-auto-save-file
     この関数は、visitされているファイルの名前が変更されていれば、カレン
     トバッファーのauto-saveファイルの名前を調整する。これは、カレント
     Emacsセッションでauto-saveファイルが作成されていれば、既存の
     auto-saveファイルもリネームする。visitされているファイルの名前が変
     更されていない場合、この関数は何も行わない。

 -- Variable: buffer-saved-size
     このバッファーローカル変数の値は、カレントバッファーが最後に読み取
     り、保存、または自動保存されたときのバッファーの長さである。これは
     、サイズの大幅な減少の検知に使用され、それに応じて自動保存がオフに
     切り替えられる。

     −1の場合、それはサイズの大幅な減少により、そのバッファーの自動保存
     が一時的に停止されていることを意味する。明示的な保存により、この変
     数に正の値が格納され、自動保存が再び有効になる。自動保存をオフやオ
     ンに切り替えることでも、またはこの変数を更新されるので、サイズの大
     幅な減少は忘れられてしまう。

     −2の場合は、そのバッファーがバッファーサイズの変更を無視すべきこと
     を意味する。特に、バッファーサイズの変更により、一時的に自動保存を
     停止するべきではない。

 -- Variable: auto-save-list-file-name
     この変数は、(非‘nil’の場合は)すべてのauto-saveファイルの名前を記録
     するファイルを指定する。Emacsが自動保存を行うたびに、そのEmacsは自
     動保存が有効な各バッファーごとに2行ずつ書き込みを行う。1行目は
     visitされているファイルの名前(ファイルをvisitしないバッファーの場合
     は空)、2行目はauto-saveファイルの名前を示す。

     Emacsを正常にexitしたときは、このファイルは削除される。Emacsがクラ
     ッシュした場合は、このファイルを調べることにより、失われるはずだっ
     た作業を含む、すべてのauto-saveファイルを探すことができる。
     ‘recover-session’コマンドは、それらを見つけるために、このファイルを
     使用する。

     このファイルにたいするデフォルト名は、ユーザーのホームディレクトリ
     ーの、‘.saves-’で始まるファイルを指定する。この名前には、Emacsのプ
     ロセスIDと、ホスト名も含まれる。

 -- User Option: auto-save-list-file-prefix
     initファイルを読み込んだ後、(‘nil’にセット済みでなければ)Emacsはこ
     のプレフィックスにもとづきホスト名とプロセスIDを追加して、
     ‘auto-save-list-file-name’を初期化する。initファイル内でこれを
     ‘nil’にセットした場合、Emacsは‘auto-save-list-file-name’を初期化し
     ない。


File: elisp,  Node: Reverting,  Prev: Auto-Saving,  Up: Backups and Auto-Saving

25.3 Reverting
==============

あるファイルにたいして大きな変更を行った後、気が変わって元に戻したくなっ
た場合は、‘revert-buffer’コマンドでそのファイルの以前のバージョンを読み
込むことにより、それらの変更を取り消すことができます。詳細は、*note
Reverting a Buffer: (emacs)Reverting.を参照してください。

 -- Command: revert-buffer &optional ignore-auto noconfirm
          preserve-modes
     このコマンドは、バージョンのテキストを、ディスク上のvisitされている
     ファイルのテキストで置き換える。これにより、ファイルがvisit、または
     保存された以降に行ったすべての変更は、アンドゥ(undo: 取り消し)され
     る。

     デフォルトでは、もっとも最近のauto-saveファイルのほうがvisitされて
     いるファイルより新しく、かつ引数IGNORE-AUTOが‘nil’の場合、
     ‘revert-buffer’はユーザーにたいしてかわりにauto-saveファイルを使用
     するかどうか確認を求める。このコマンドをinteractiveに呼び出したとき
     、プレフィックス数引数が指定されていなければ、IGNORE-AUTOは‘t’とな
     る。つまり、interactive呼び出しは、デフォルトではauto-saveファイル
     のチェックを行わない。

     ‘revert-buffer’は通常、バッファーを変更する前に確認を求める。しかし
     、引数NOCONFIRMが非‘nil’の場合、‘revert-buffer’は確認を求めない。

     このコマンドは通常、‘normal-mode’を使用することにより、そのバッファ
     ーのメジャーモードとマイナーモードを再初期化する。しかし、
     PRESERVE-MODESが非‘nil’の場合、モードは変更されずに残る。

     リバート(revert: 戻す、復元する)は、‘insert-file-contents’の置き換
     え機能を使用することにより、バッファー内のマーカー位置の保持を試み
     る。バッファーのコンテンツとファイルのコンテンツがリバート操作を行
     う前に等しい場合、リバートはすべてのマーカーを保持する。等しくない
     場合、リバートによりバッファーは変更される。この場合は、(もしあれば
     )バッファーの最初と最後にある未変更のテキスト内にあるマーカーは保持
     される。他のマーカーを保持しても、それらは正しくないだろう。

 -- Variable: revert-buffer-in-progress-p
     ‘revert-buffer’は処理を行っている間、この変数を非‘nil’値にバインド
     する。

   このセクションの残りの部分で説明する変数をセットすることにより、
‘revert-buffer’が処理を行う方法をカスタマイズできます。

 -- User Option: revert-without-query
     この変数は、問い合わせなしでリバートされるべきファイルのリストを保
     持する。値は、正規表現のリスト。visitされているファイルの名前がこれ
     らの正規表現のいずれかにマッチし、かつバッファーが未変更だがディス
     ク上のファイルは変更されている場合、‘revert-buffer’はユーザーに確認
     を求めることなく、ファイルをリバートする。

   メジャーモードのいくつかは、以下の変数をローカルにバインドすることに
より、‘revert-buffer’をカスタマイズします:

 -- Variable: revert-buffer-function
     この変数の値は、そのバッファーをリバートするために使用する関数であ
     る。これはリバート処理を行うための、2つのオプション引数をとる関数で
     あること。2つのオプション引数IGNORE-AUTOとNOCONFIRMは、
     ‘revert-buffer’が受け取る引数である。

     Diredモードのような、編集されるテキストにファイルのコンテンツは含ま
     れず、他の方式により再生成され得るモードは、この変数のバッファーロ
     ーカル値に、コンテンツを再生成する特別な関数を与えることができる。

 -- Variable: revert-buffer-insert-file-contents-function
     この変数の値は、そのバッファーをリバートする際に、更新されたコンテ
     ンツの挿入に使用される関数を指定する。その関数は、2つの引数をとる。
     1つ目は使用するファイル名で、2つ目が‘t’ならユーザーはauto-saveファ
     イルの読み込みにたいして確認を求められる。

     ‘revert-buffer-function’のかわりにこの変数をモードが変更する理由は
     、‘revert-buffer’が行残りの処理(ユーザーへの確認、アンドゥリストの
     クリアー、適切なメジャーモードの決定、以下のフックの実行)にたいする
     重複や置き換えを避けるためである。

 -- Variable: before-revert-hook
     このノーマルフックは、変更されたコンテンツを挿入する前に、デフォル
     トの‘revert-buffer-function’により実行される。カスタマイズした
     ‘revert-buffer-function’は、このフックを実行するかどうか判らない。

 -- Variable: after-revert-hook
     このノーマルフックは、変更されたコンテンツを挿入した後に、デフォル
     トの‘revert-buffer-function’により実行される。カスタマイズした
     ‘revert-buffer-function’は、このフックを実行するかどうか判らない。

 -- Variable: buffer-stale-function
     この変数の値は、バッファーがリバートを要するかどうかをチェックする
     ために呼び出される関数を指定する。デフォルト値は、修正時刻をチェッ
     クすることにより、ファイルをvisitするバッファーだけを処理する。ファ
     イルをvisitしないバッファーには、カスタム関数が必要になる (*note
     (emacs)Supporting additional buffers::を参照)。


File: elisp,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto-Saving,  Up: Top

26 Buffers
**********

“バッファー(buffer)”とは、編集されるテキストを含むLispオブジェクトのこと
です。バッファーは、visitされるファイルのコンテンツを保持するために使用
されます。しかし、ファイルをvisitしないバッファーも存在するかもしれませ
ん。一度に複数のバッファーが存在するかもしれませんが、“カレントバッファ
ー(current buffer)”に指定できるのは、常に1つのバッファーだけです。ほとん
どの編集コマンドは、カレントバッファーのコンテンツにたいして作用します。
カレントバッファーを含むすべてのバッファーは、任意のウィンドウ内に表示さ
れるときも、表示されない場合もあります。

* Menu:

* Buffer Basics::            バッファーとは?
* Current Buffer::           バッファーをカレントに指定することにより、プリミティブはバッファーのコンテンツにアクセスする。
* Buffer Names::             バッファー名にたいするアクセスと変更。
* Buffer File Name::         バッファーファイル名は、どのファイルをvisitしているかを示す。
* Buffer Modification::      保存が必要なら、バッファーは“変更されている(modified)”。
* Modification Time::        "Emacsの裏"でvisitされているファイルが変更されたかどうかを判断する。
* Read Only Buffers::        読み取り専用バッファーでのテキスト変更は許されない。
* Buffer List::              すべての既存バッファーを閲覧する方法。
* Creating Buffers::         バッファーを作成する関数。
* Killing Buffers::          明示的にkillされるまで、バッファーは存在する。
* Indirect Buffers::         インダイレクトバッファーは、他のバッファーとテキストを共有する。
* Swapping Text::            2つのバッファー間でのテキストの交換。
* Buffer Gap::               バッファー内のギャップ。


File: elisp,  Node: Buffer Basics,  Next: Current Buffer,  Up: Buffers

26.1 Buffer Basics
==================

“バッファー(buffer)”とは、編集されるテキストを含むLispオブジェクトのこと
です。バッファーは、visitされるファイルのコンテンツを保持するために使用
されます。しかし、ファイルをvisitしないバッファーも存在します。一度に複
数のバッファーが存在するかもしれませんが、“カレントバッファー(current
buffer)”に指定できるのは、常に1つのバッファーだけです。ほとんどの編集コ
マンドは、カレントバッファーのコンテンツにたいして作用します。カレントバ
ッファーを含むすべてのバッファーは、任意のウィンドウ内に表示されるときも
、表示されない場合もあります。

   Emacs編集におけるバッファーは、個別に名前をもち、編集可能なテキストを
保持するオブジェクトです。Lispプログラムにたいして、バッファーはスペシャ
ルデータ型として表されます。バッファーのコンテンツを、拡張可能な文字列と
考えることができます。挿入と削除は、バッファー内の任意の箇所で発生し得ま
す。*note Text::を参照してください。

   Lispのバッファーオブジェクトは、多くの情報要素を含んでいます。これら
の情報のいくつかは変数を通じてプログラマーが直接アクセスできるのにたいし
て、その他の情報は特殊な目的のための関数を通じてのみアクセスすることがで
きます。たとえば、visitされているファイルの名前は変数を通じて直接アクセ
スできますが、ポイント値はプリミティブ関数からのみアクセスできます。

   直接アクセス可能な、バッファー固有の情報は、“バッファーローカル
(buffer-local)”な変数バインディング内に格納されます。これは、特定のバッ
ファー内だけで効力のある変数値のことです。この機能により、それぞれのバッ
ファーは、特定の変数の値をオーバーライドすることができます。ほとんどのメ
ジャーモードは、この方法で‘fill-column’や‘comment-column’のような変数を
オーバーライドしています。バッファーローカルな変数、およびそれらに関連す
る関数についての詳細は、*note Buffer-Local Variables::を参照してください
。

   バッファーからファイルをvisitする関数および変数については、*note
Visiting Files::、および*note Saving Buffers::を参照してください。ウィン
ドウ内へのバッファー表示に関連する関数および変数については、*note
Buffers and Windows::を参照してください。

 -- Function: bufferp object
     この関数は、OBJECTがバッファーなら‘t’、それ以外は‘nil’をリターンす
     る。


File: elisp,  Node: Current Buffer,  Next: Buffer Names,  Prev: Buffer Basics,  Up: Buffers

26.2 The Current Buffer
=======================

一般的に、1つのEmacsセッション内には、多くのバッファーが存在します。常に
、それらのうちの1つが“カレントバッファー(current buffer)”に指定され、ま
す。カレントバッファーとは、ほとんどの編集が行われるバッファーのことです
。テキストを調べたり変更するプリミティブのほとんどは、暗黙的にカレントバ
ッファーにたいして処理を行います(*note Text::を参照)。

   通常は、選択されたウィンドウ内に表示されるバッファーがカレントバッフ
ァーですが、常にそうではありません。Lispプログラムは、バッファーのコンテ
ンツを処理するために、スクリーン上に表示されているものを変更することなく
、任意のバッファーを一時的にカレントに指定できます。カレントバッファーの
指定にたいしてもっとも基本的な関数は、‘set-buffer’です。

 -- Function: current-buffer
     この関数は、カレントバッファーをリターンする関数。

          (current-buffer)
               ⇒ #<buffer buffers.texi>

 -- Function: set-buffer buffer-or-name
     この関数は、BUFFER-OR-NAMEをカレントバッファーにする。
     BUFFER-OR-NAMEは既存のバッファー、または既存のバッファーの名前でな
     ければならない。リターン値は、カレントになったバッファーである。

     この関数は、そのバッファーをどのウィンドウにも表示しないので、必然
     的にユーザーはそのバッファーを見ることはできない。しかし、Lispプロ
     グラムはその後、そのバッファーにたいして処理を行うことになるだろう
     。

   編集コマンドがエディターコマンドループにリターンする際、Emacsは選択さ
れたウィンドウ内に表示されているバッファーにたいして、自動的に
‘set-buffer’を呼び出します。これは混乱を防ぐためで、これにより、Emacsが
コマンドを読み取るときに、カーソルのあるバッファーが、コマンドを適用され
るバッファーになるのが保証されます(*note Command Loop::を参照)。したがっ
て、異なるバッファーを指示して切り替える場合に、‘set-buffer’を使用するべ
きではありません。これを行うためには、*note Switching Buffers::で説明さ
れているカを使用してください。

   Lisp関数を記述する際は、処理後にカレントバッファーをリストアするため
に、コマンドループのこの振る舞いに_依存しないでください_。編集コマンドは
、コマンドループだけではなく、他のプログラムからLisp関数としても呼び出さ
れます。呼び出し側にとっては、そのサブルーチンがカレントだったバッファー
を変更しないほうが便利です(もちろん、それがサブルーチンの目的でない場合
ですが)。

   他のバッファーにたいして一時的に処理を行うには、
‘save-current-buffer’フォーム内に‘set-buffer’を置きます。以下の例は、コ
マンド‘append-to-buffer’の簡略版です:

     (defun append-to-buffer (buffer start end)
       "リージョンのテキストをBUFFERに追加する"
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-current-buffer
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

ここでは、カレントバッファーを記録するためにローカル変数にバインドしてか
ら、後で‘save-current-buffer’がそれを再びカレントにするよう、取り計らっ
ています。次に、‘set-buffer’が指定されたバッファーをカレントにして、
‘insert-buffer-substring’が元のバッファーの文字列を、指定された(今はカレ
ントの)バッファーにコピーします。

   かわりに、‘with-current-buffer’マクロを使用することもできます:

     (defun append-to-buffer (buffer start end)
       "BUFFERにリージョンのテキストを追加する"
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (with-current-buffer (get-buffer-create buffer)
           (insert-buffer-substring oldbuf start end))))

   どちらの場合でも、追加されるバッファーが偶然他のウィンドウに表示され
ていた場合には、次回の再表示でそのテキストがどのように変更されたか表示さ
れるでしょう。どのウィンドウにも表示されていない場合には、スクリーン上で
即座に変更を目にすることはありません。コマンドはバッファーを一時的にカレ
ントにしますが、そのことがバッファーの表示を誘因する訳ではありません。

   バッファーローカルバインディングをもつ変数にたいして、(‘let’や関数引
数などで)ローカルバインディングを作成する場合は、そのローカルバインディ
ングのスコープの最初と最後で、同じバッファーがカレントとなることを確認し
てください。そうしないと、あるバッファーではバインドして、他のバッファー
ではバインドされないことになるかもしれません!

   ‘set-buffer’の使用において、カレントバッファーが戻ることに依存しない
でください。なぜなら、間違ったバッファーがカレントのときにquitが発生した
場合、その処理は行われないでしょう。たとえば上記の例に倣うと、以下は間違
ったやり方です:

       (let ((oldbuf (current-buffer)))
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end)
         (set-buffer oldbuf))

例で示したように‘save-current-buffer’、または‘with-current-buffer’を使用
すれば、quitや‘throw’を、通常の評価と同様に処理できます。

 -- Special Form: save-current-buffer body...
     スペシャルフォーム‘save-current-buffer’は、カレントバッファーの識別
     を保存して、BODYフォームを評価し、最後にそのバッファーをカレントに
     リストアする。リターン値は、BODY内の最後のフォームの値である。
     ‘throw’やエラーを通じた異常exitの場合でも、カレントバッファーはリス
     トアされる(*note Nonlocal Exits::を参照)。

     カレントとして使用されていたバッファーが、‘save-current-buffer’によ
     るexit時にkillされていた場合は、それが再びカレントとなることは当然
     ない。かわりに、exit直前にカレントバッファーが何であれ、それがカレ
     ントになる。

 -- Macro: with-current-buffer buffer-or-name body...
     ‘with-current-buffer’マクロは、カレントバッファーの識別を保存して、
     BUFFER-OR-NAMEをカレントにし、BODYフォームを評価して、最後にカレン
     トバッファーをリストアする。BUFFER-OR-NAMEには既存のバッファー、ま
     たは既存のバッファー名を指定しなければならない。

     リターン値は、BODY内の最後のフォームの値である。‘throw’やエラーを通
     じた異常exitの場合でも、カレントバッファーはリストアされる(*note
     Nonlocal Exits::を参照)。

 -- Macro: with-temp-buffer body...
     ‘with-temp-buffer’マクロは、一時的なバッファーをカレントバッファー
     として、BODYフォームを評価する。これはカレントバッファーの識別を保
     存して、一時的なバッファーを作成、それをカレントとして、BODYフォー
     ムを評価し、一時バッファーをkillする間に、以前のカレントバッファー
     をリストアする。 デフォルトでは、このマクロにより作成されたバッファ
     ー内のアンドゥ情報(*note Undo::を参照)は記録されない(が、必要なら
     BODYでそれを有効にできる)。

     リターン値は、BODY内の最後のフォームの値である。最後のフォームとし
     て‘(buffer-string)’を使用することにより、一時バッファーのコンテンツ
     をリターンできる。

     ‘throw’やエラーを通じた異常exitの場合でも、カレントバッファーはリス
     トアされる(*note Nonlocal Exits::を参照)。

     *note Writing to Files: Definition of with-temp-file.の
     ‘with-temp-file’も参照されたい。


File: elisp,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Current Buffer,  Up: Buffers

26.3 Buffer Names
=================

それぞれのバッファーは、文字列で表される一意な名前をもちます。バッファー
にたいして機能する関数の多くは、引数としてバッファーとバッファー名の両方
を受け入れます。BUFFER-OR-NAMEという名前の引数がこのタイプで、それが文字
列でもバッファーでもない場合は、エラーがシグナルされます。BUFFERという名
前の引数は、名前ではなく実際のバッファーオブジェクトでなければなりません
。

   短命でユーザーが関心をもたないようなバッファーは名前がスペースで始ま
り、それらについては‘list-buffers’および‘buffer-menu’コマンドは無視しま
す(が、ファイルをvisitしているようなバッファーは*無視されない*)。スペー
スで始まる名前は、初期状態ではアンドゥ情報の記録も無効になっています。
*note Undo::を参照してください。

 -- Function: buffer-name &optional buffer
     この関数は、BUFFERの名前を文字列としてリターンする。BUFFERのデフォ
     ルトは、カレントバッファーである。

     ‘buffer-name’が‘nil’をリターンした場合、それはBUFFERがkillされてい
     ることを意味する。*note Killing Buffers::を参照のこと。

          (buffer-name)
               ⇒ "buffers.texi"

          (setq foo (get-buffer "temp"))
               ⇒ #<buffer temp>
          (kill-buffer foo)
               ⇒ nil
          (buffer-name foo)
               ⇒ nil
          foo
               ⇒ #<killed buffer>

 -- Command: rename-buffer newname &optional unique
     この関数は、カレントバッファーをNEWNAMEにリネームする。NEWNAMEが文
     字列でない場合は、エラーをシグナルする。

     NEWNAMEがすでに使用済みの場合、‘rename-buffer’は通常はエラーをシグ
     ナルする。しかし、UNIQUEが非‘nil’の場合は、未使用の名前となるように
     NEWNAMEを変更する。interactiveに呼び出した場合は、プレフィックス数
     引数によりUNIQUEに非‘nil’を指定できる(この方法により、コマンド
     ‘rename-uniquely’は実装される)。

     この関数は、実際にバッファーに与えられた名前をリターンする。

 -- Function: get-buffer buffer-or-name
     この関数は、BUFFER-OR-NAMEで指定されたバッファーをリターンする。
     BUFFER-OR-NAMEが文字列で、かつそのような名前のバッファーが存在しな
     い場合、値は‘nil’になる。BUFFER-OR-NAMEがバッファーの場合は、与えら
     れたバッファーをリターンする。これは有用とは言い難く、引数は通常は
     名前である。たとえば:

          (setq b (get-buffer "lewis"))
               ⇒ #<buffer lewis>
          (get-buffer b)
               ⇒ #<buffer lewis>
          (get-buffer "Frazzle-nots")
               ⇒ nil

     *note Creating Buffers::の関数‘get-buffer-create’も参照のこと。

 -- Function: generate-new-buffer-name starting-name &optional ignore
     この関数は、新たなバッファーにたいして一意となるような名前をリター
     ンする — が、バッファーは作成しない。この名前はSTARTING-NAMEで始ま
     り、内部が数字であるような‘<...>’を追加することにより、すべてのバッ
     ファーでカレントで使用されていない名前を生成する。この数字は2で始ま
     り、既存バッファーの名前でない名前になる数字まで増加される。

     オプション引数IGNOREが非‘nil’の場合、それは潜在的にバッファー名であ
     るような文字列であること。これは、たとえそれが(通常は拒絶されるであ
     ろう)既存バッファーの名前であっても、試みられた場合は、潜在的に受容
     可能なバッファーとして考慮することを意味する。つまり‘foo’、
     ‘foo<2>’、‘foo<3>’、‘foo<4>’という名前のバッファーが存在する場合、

          (generate-new-buffer-name "foo")
               ⇒ "foo<5>"
          (generate-new-buffer-name "foo" "foo<3>")
               ⇒ "foo<3>"
          (generate-new-buffer-name "foo" "foo<6>")
               ⇒ "foo<5>"

     *note Creating Buffers::の関連する関数‘generate-new-buffer’も参照の
     こと。


File: elisp,  Node: Buffer File Name,  Next: Buffer Modification,  Prev: Buffer Names,  Up: Buffers

26.4 Buffer File Name
=====================

“バッファーファイル名(buffer file name)”とは、そのバッファーにvisitされ
ているファイルの名前です。バッファーがファイルをvisiblyしていなければ、
バッファーファイル名は‘nil’です。大抵、バッファー名はバッファーファイル
名の非ディレクトリーパートと同じですが、バッファーファイル名とバッファー
名は別物であり、個別にセットすることができます。*note Visiting Files::を
参照してください。

 -- Function: buffer-file-name &optional buffer
     この関数は、BUFFERがvisitしているファイルの、絶対ファイル名をリター
     ンする。BUFFERがファイルをvisitしていない場合、‘buffer-file-name’は
     ‘nil’をリターンする。BUFFERが与えられない場合のデフォルトは、カレン
     トバッファーになる。

          (buffer-file-name (other-buffer))
               ⇒ "/usr/user/lewis/manual/files.texi"

 -- Variable: buffer-file-name
     このバッファーローカル変数は、カレントバッファーにvisitされているフ
     ァイルの名前、ファイルをvisitしていなければ‘nil’が含まれる。これは
     永続的なローカル変数であり、‘kill-all-local-variables’の影響を受け
     ない。

          buffer-file-name
               ⇒ "/usr/user/lewis/manual/buffers.texi"

     他のさまざまな事項を変更せずに、この変数を変更するのは危険である。
     通常は、‘set-visited-file-name’を使用するほうがよい(以下参照)。バッ
     ファー名の変更などのような、そこで行われることのいくつかは、絶対必
     要という訳ではないが、その他の事項はEmacsが混乱するのを防ぐために必
     要不可欠である。

 -- Variable: buffer-file-truename
     このバッファーローカル変数は、カレントバッファーにvisitされているフ
     ァイルの省略された形式の実名(truename)、ファイルをvisitしていない場
     合は‘nil’を保持する。これは永続的にローカルであり、
     ‘kill-all-local-variables’の影響を受けない。*Note Truenames::、およ
     び*note abbreviate-file-name::を参照のこと。

 -- Variable: buffer-file-number
     このバッファーローカル変数は、カレントバッファーにvisitされているフ
     ァイルのファイル番号(file number)とデバイス番号(device number)、フ
     ァイルをvisitしていない場合は‘nil’を保持する。これは永続的にローカ
     ルであり、‘kill-all-local-variables’の影響を受けない。

     値は通常、‘(FILENUM DEVNUM)’のような形式のリストである。この番号ペ
     アーは、システム上でアクセス可能なすべてのファイルの中から、ファイ
     ルを一意に識別する。より詳細な情報は、*note File Attributes::の
     ‘file-attributes’を参照のこと。

     ‘buffer-file-name’がシンボリックリンク名の場合は、どちらの番号も再
     帰的なターゲットを参照する。

 -- Function: get-file-buffer filename
     この関数は、ファイルFILENAMEをvisitしているバッファーをリターンする
     。そのようなバッファーが存在しない場合は、‘nil’をリターンする。引数
     FILENAMEは文字列でなければならず、展開(*note File Name Expansion::を
     参照)された後、killされていないすべてのバッファーがvisitしているフ
     ァイル名と比較される。バッファーの‘buffer-file-name’は、FILENAMEの
     展開形と正確にマッチしなければならないことに注意。この関数は、同じ
     ファイルにたいする他の名前は、認識しないだろう。

          (get-file-buffer "buffers.texi")
              ⇒ #<buffer buffers.texi>

     特殊な状況下では、複数のバッファーが同じファイル名をvisitすることが
     あり得る。そのような場合、この関数はバッファーリスト内の最初に該当
     するバッファーをリターンする。

 -- Function: find-buffer-visiting filename &optional predicate
     これは‘get-file-buffer’と似ているが、そのファイルを_違う名前_で
     visitしているかもしれないすべてのバッファーをリターンする。つまり、
     バッファーの‘buffer-file-name’はFILENAMEの展開形式と正確にマッチす
     る必要はなく、同じファイルを参照することだけが要求される。
     PREDICATEが非‘nil’の場合、それはFILENAMEをvisitしているバッファーを
     1つの引数とする関数であること。そのバッファーにたいして、
     PREDICATEが非‘nil’をリターンした場合のみ、適切なリターン値と判断さ
     れる。リターンすべき適切なバッファーが見つからない場合、
     ‘find-buffer-visiting’は‘nil’をリターンする。

 -- Command: set-visited-file-name filename &optional no-query
          along-with-file
     FILENAMEが非空文字列の場合、この関数はカレントバッファーにvisitされ
     ているファイルの名前を、FILENAMEに変更する(バッファーがファイルを
     visitしていない場合は、visitするファイルとしてFILENAMEを与える)。そ
     のバッファーにたいする_次回_の保存では、新たに指定されたファイルに
     保存されるだろう。

     このコマンドは、たとえそのバッファーのコンテンツがその前にvisitされ
     ていたファイルとマッチしていても、(Emacsが関知するかぎり)FILENAMEの
     コンテンツとはマッチしないので、バッファーが変更されている
     (modified)とマークする。これは、その名前がすでに使用されていなけれ
     ば、新たなファイル名に対応してバッファーをリネームする。

     FILENAMEが‘nil’、または空文字列の場合、それは“visitされているファイ
     ルがない”ことを意味する。この場合、‘set-visited-file-name’はバッフ
     ァーの変更フラグを変更することなく、そのバッファーがファイルを
     visitしていないとマークする。

     この関数はFILENAMEをvisitしているバッファーがすでに存在する場合は、
     通常はユーザーに確認を求める。しかし、NO-QUERYが非‘nil’の場合は、こ
     の質問を行わない。FILENAMEをvisitしているバッファーがすでに存在し、
     かつユーザーが承認、またはNO-QUERYが非‘nil’の場合、この関数は中に数
     字が入った‘<...>’をFILENAMEに追加して、新たなバッファーの名前を一意
     にする。

     ALONG-WITH-FILEが非‘nil’の場合、それは前にvisitされていたファイルが
     FILENAMEにリネームされたと想定することを意味する。この場合、コマン
     ドはバッファーの修正フラグを変更せず、そのバッファーの記録されてい
     る最終ファイル変更時刻を‘visited-file-modtime’が報告する時刻(*note
     Modification Time::を参照)で変更もしない。ALONG-WITH-FILEが‘nil’の
     場合、この関数は‘visited-file-modtime’が0をリターンした後に、記録済
     みの最終ファイル変更時刻をクリアーする。

     関数‘set-visited-file-name’がinteractiveに呼び出されたときは、ミニ
     バッファー内でFILENAMEの入力を求める。

 -- Variable: list-buffers-directory
     このバッファーローカル変数は、visitしているファイル名をもたないバッ
     ファーにたいして、バッファーリスト中のvisitしているファイル名を表示
     する場所に表示する文字列を指定する。Diredバッファーは、この変数を使
     用する。


File: elisp,  Node: Buffer Modification,  Next: Modification Time,  Prev: Buffer File Name,  Up: Buffers

26.5 Buffer Modification
========================

Emacsは、各バッファーにたいして、バッファーのテキストを変更したかどうか
を記録するために、“変更フラグ(modified flag)”と呼ばれるフラグを管理して
います。このフラグは、バッファーのコンテンツを変更すると常に‘t’にセット
され、バッファーを保存したとき‘nil’にクリアーされます。したがって、この
フラグは保存されていない変更があるかどうかを表します。フラグの値は通常、
モードライン内(*note Mode Line Variables::を参照)に表示され、保存(*note
Saving Buffers::を参照)と自動保存(*note Auto-Saving::を参照)を制御します
。

   いくつかのLispプログラムは、このフラグを明示的にセットします。たとえ
ば、関数‘set-visited-file-name’は、このフラグを‘t’にセットします。なぜな
ら、たとえその前にvisitしていたファイルが変更されていなくても、テキスト
は新たにvisitされたファイルとマッチしないからです。

   バッファーのコンテンツを変更する関数については、*note Text::で説明さ
れています。

 -- Function: buffer-modified-p &optional buffer
     この関数は、バッファーBUFFERが最後にファイルから読み込まれた、ある
     いは保存されてから変更されていれば‘t’、それ以外では‘nil’をリターン
     する。BUFFERが与えられない場合は、カレントバッファーがテストされる
     。

 -- Function: set-buffer-modified-p flag
     この関数は、FLAGが非‘nil’ならカレントバッファーを変更済みとしてマー
     クし、‘nil’なら未変更としてマークする。

     この関数を呼び出すことによる別の効果は、それがカレントバッファーの
     モードラインの無条件な再表示を引き起こすことである。実際のところ、
     関数‘force-mode-line-update’は、以下を行うことにより機能する:

          (set-buffer-modified-p (buffer-modified-p))

 -- Function: restore-buffer-modified-p flag
     ‘set-buffer-modified-p’と同様だが、モードラインにたいする強制的な再
     表示を行わない。

 -- Command: not-modified &optional arg
     このコマンドは、カレントバッファーが変更されておらず、保存する必要
     がないとマークする。ARGが非‘nil’の場合、これは変更されているとマー
     クするので、次回の適切なタイミングでバッファーは保存されるだろう。
     interactiveに呼び出された場合、ARGはプレフィックス引数である。

     この関数は、エコーエリア内にメッセージをプリントするので、プログラ
     ム内で使用してはならない。かわりに、‘set-buffer-modified-p’(上記)を
     使用すること。

 -- Function: buffer-modified-tick &optional buffer
     この関数は、BUFFERの変更カウント(modification-count)をリターンする
     。これは、バッファーが変更されるたびに増加されるカウンターである。
     BUFFERが‘nil’(または省略)の場合は、カレントバッファーが使用される。
     このカウンターは、時折0にクリアーされ得る。

 -- Function: buffer-chars-modified-tick &optional buffer
     この関数は、BUFFERの文字変更に関わる変更カウントをリターンする。テ
     キストプロパティを変更しても、このカウンターは変化しない。しかし、
     そのバッファーにテキストが挿入、または削除されるたびに、このカウン
     ターは‘buffer-modified-tick’によりリターンされるであろう値にリセッ
     トされる。‘buffer-chars-modified-tick’を2回呼び出してリターンされる
     値を比較することにより、その呼び出しの間にバッファー内で文字変更が
     あったかどうかを知ることができる。BUFFERが‘nil’(または省略)の場合は
     、カレントバッファーが使用される。


File: elisp,  Node: Modification Time,  Next: Read Only Buffers,  Prev: Buffer Modification,  Up: Buffers

26.6 Buffer Modification Time
=============================

あるファイルをvisitして、そのバッファー内で変更を行って、その一方ではデ
ィスク上でファイル自身が変更されたとします。この時点でバッファーを保存す
ると、ファイル内の変更は上書きされるでしょう。これが正に望んでいる動作の
ときもありますが、通常は有用な情報が失われてしまいます。したがって、
Emacsはファイルを保存する前に、以下で説明する関数を使用して、ファイルの
変更時刻をチェックします(ファイルの変更時刻を調べる方法は、*note File
Attributes::を参照)。

 -- Function: verify-visited-file-modtime &optional buffer
     この関数は、BUFFER(デフォルトはカレントバッファー)にvisitされている
     ファイルにたいして記録されている変更時刻と、オペレーティングシステ
     ムにより記録された実際の変更時刻を比較する。これら2つの時刻は、
     Emacsがそのファイルをvisit、もしくは保存して以降、他のプロセスによ
     り書き込みがされていなければ、等しくなるはずである。

     この関数は、実際の最終変更時刻と、Emacsが記録した変更時刻が同じなら
     ‘t’、それ以外は‘nil’をリターンする。そのバッファーが記録済みの最終
     変更時刻をもたない、すなわち‘visited-file-modtime’が0をリターンする
     ような場合も、‘t’をリターンする。

     これは、たとえ‘visited-file-modtime’が非0の値をリターンしたとしても
     、ファイルをvisitしていないバッファーにたいしては、常に‘t’をリター
     ンする。たとえば、diredバッファーにたいして、この関数は常に‘t’をリ
     ターンする。また、存在せず、 以前に存在したこともなかったファイルを
     visitするバッファーにたいして‘t’をリターンするが、visitしているファ
     イルが削除されたバッファーにたいしては‘nil’をリターンする。

 -- Function: clear-visited-file-modtime
     この関数は、カレントバッファーによりvisitされているファイルの最終変
     更時刻の記録をクリアーする。結果として、このバッファーにを次回の保
     存では、ファイルの変更時刻の食い違いは報告されなくなる。

     この関数は‘set-visited-file-name’、および変更済みファイルの上書きを
     防ぐための通常テストを行わない例外的な箇所で呼び出される。

 -- Function: visited-file-modtime
     この関数は、カレントバッファーの記録された最終ファイル変更時刻を、
     ‘(HIGH LOW MICROSEC PICOSEC)’のような形式のリストでリターンする(こ
     れは、‘file-attributes’が時刻値をリターンするために使用するフォーマ
     ットと同じである。*note File Attributes::を参照されたい)。

     バッファーが最終変更時刻の記録をもたない場合、この関数は0をリターン
     する。これが発生するのは、たとえばバッファーがファイルをvisitしてい
     なかったり、‘clear-visited-file-modtime’で最終変更時刻が明示的にク
     リアーされた場合である。しかし‘visited-file-modtime’は、いくつかの
     非ファイルバッファーにたいするリストをリターンすることに注意。たと
     えば、ディレクトリーをリストするDiredバッファーでは、Diredが記録す
     るそのディレクトリーの最終変更時刻がリターンされる。

     バッファーがファイルをvisitしていない場合、この関数は-1をリターンす
     る。

 -- Function: set-visited-file-modtime &optional time
     この関数は、バッファーがvisitしているファイルの最終変更時刻の記録を
     、TIMEが非‘nil’、それ以外はvisitしているファイルの最終変更時刻によ
     り更新する。

     TIMEが‘nil’や0でない場合、それは‘current-time’で使用される形式
     ‘(HIGH LOW MICROSEC PICOSEC)’というフォーマットであること(*note
     Time of Day::を参照)。

     この関数は、バッファーが通常のようにファイルから読み取られたもので
     ない場合や、ファイル自身が害のない既知の理由により変更されている場
     合に有用である。

 -- Function: ask-user-about-supersession-threat filename
     これは、visitしているファイルFILENAMEがバッファーのテキストより新し
     いときにバッファーの変更を試みた後、ユーザーに処理方法を尋ねるため
     に使用する関数である。Emacsはディスク上のファイルの変更時刻が、バッ
     ファーを最後に保存した時刻より新しいかどうかで、これを検知する。こ
     れはおそらく、他のプログラムがそのファイルを変更したことを意味する
     。

     この関数が正常にリターンするかどうかは、ユーザーの答えに依存する。
     関数はバッファーの変更が処理された場合は正常にリターンし、バッファ
     ーの変更が許可されなかった場合は、データ‘(FILENAME)’とともにエラー
     ‘file-supersession’をシグナルする。

     この関数は、適切なタイミングでEmacsにより自動的に呼び出される。これ
     は、再定義することによりEmacsをカスタマイズ可能にするために存在する
     。標準的な定義は、ファイル‘userlock.el’を参照されたい。

     *note File Locks::のファイルロックのメカニズムも参照のこと。


File: elisp,  Node: Read Only Buffers,  Next: Buffer List,  Prev: Modification Time,  Up: Buffers

26.7 Read-Only Buffers
======================

あるバッファーが“読み取り専用(read-only)”の場合は、たとえスクロールやナ
ローイングによってファイルのコンテンツのビューを変更しても、そのコンテン
ツを変更することはできません。

   読み取り専用バッファーは、2つのタイプの状況において使用されます:

   • 書き込み保護されたファイルをvisitするバッファーは、通常は読み取り専
     用になる。

     ここでの目的は、ユーザーにたいしてそのファイルへの保存を意図したバ
     ッファーの編集が無益、または望ましくないかもしれないことを伝えるこ
     とである。それにも関わらずバッファーのテキストの変更を望むユーザー
     は、‘C-x C-q’で読み取り専用フラグをクリアーした後、これを行うことが
     できる。

   • DiredやRmailのようなモードは、通常の編集コマンドによるコンテンツの
     変更がおそらく間違いであるようなときに、バッファーを読み取り専用に
     する。

     このようなモードのスペシャルコマンドは、‘buffer-read-only’を
     (‘let’により)‘nil’にバインドしたり、テキストを変更する箇所では
     ‘inhibit-read-only’を‘t’にバインドする。

 -- Variable: buffer-read-only
     このバッファーローカル変数は、そのバッファーが読み取り専用かどうか
     を指定する。この変数が非‘nil’なら、そのバッファーは読み取り専用であ
     る。

 -- Variable: inhibit-read-only
     この変数が非‘nil’の場合、読み取り専用バッファー、およびその実際の値
     に依存して、一部もしくはすべての読み取り専用文字が変更されている。
     バッファー内の読み取り専用文字とは、テキストプロパティ‘read-only’が
     非‘nil’の文字である。テキストプロパティについての詳細は、*note
     Special Properties::を参照のこと。

     ‘inhibit-read-only’が‘t’の場合、すべての‘read-only’文字プロパティは
     効果がなくなる。‘inhibit-read-only’がリストの場合、‘read-only’文字
     プロパティがリストのメンバーなら効果がなくなる(比較は‘eq’で行われる
     )。

 -- Command: read-only-mode &optional arg
     これは、バッファーローカルなマイナーモードである、Read Onlyモードに
     たいするモードコマンドである。このモードが有効なときは、そのバッフ
     ァーの‘buffer-read-only’は非‘nil’である。無効なときは、そのバッファ
     ーの‘buffer-read-only’は‘nil’である。呼び出す際の慣習は、他のマイナ
     ーモードコマンドの慣習と同じである(*note Minor Mode Conventions::を
     参照)。

     このマイナーモードは他のマイナーモードとは異なり、主に
     ‘buffer-read-only’にたいするラッパーの役目を果たし、別個に
     ‘read-only-mode’変数は存在しない。Read Onlyモードが無効なときでも、
     ‘read-only’テキストプロパティが非‘nil’の文字は読み取り専用のままで
     ある。一時的にすべての読み取り専用ステータスを無視するには、上述の
     ‘inhibit-read-only’をバインドすること。

     Read Onlyモードを有効にする際、このモードコマンドはオプション
     ‘view-read-only’が非‘nil’なら、Viewモードも有効にする。*note
     Miscellaneous Buffer Operations: (emacs)Misc Buffer.を参照のこと。
     Read Onlyモードを無効にする際に、もしもViewモードが有効なら、Viewモ
     ードも無効にする。

 -- Function: barf-if-buffer-read-only
     この関数は、カレントバッファーが読み取り専用の場合は、
     ‘buffer-read-only’エラーをシグナルする。カレントバッファーが読み取
     り専用の場合にエラーをシグナルする他の方法については、*note Using
     Interactive::を参照のこと。


File: elisp,  Node: Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

26.8 The Buffer List
====================

“バッファーリスト(buffer list)”とは、すべての生きた(killされていない)バ
ッファーのリストです。このリスト内のバッファーの順序は主に、それぞれのバ
ッファーがウィンドウに表示されたのがどれほど最近なのかにもとづきます。い
くつかの関数、特に‘other-buffer’はこの順序を使用します。ユーザーに表示さ
れるバッファーリストも、この順序にしたがいます。

   バッファーを作成すると、それはバッファーリストの最後に追加され バッフ
ァーをkillすることにより、そのリストから削除されます。ウィンドウに表示す
るためにバッファーが選択されたとき(*note Switching Buffers::を参照)、あ
るいはバッファーを表示するウィンドウが選択されたとき(*note Selecting
Windows::を参照)、そのバッファーは常にこのリストの先頭に移動します。バッ
ファーがバリー(以下の‘bury-buffer’を参照)されたときは、このリストの最後
に移動します。バッファーリストを直接操作するために利用できる、Lispプログ
ラマー向けの関数は存在しません。

   説明した基本バッファーリスト(fundamental buffer list)に加えて、
Emacsはそれぞれのフレームにたいしてローカルバッファーリスト(local buffer
list)を保守します。ローカルバッファーリストでは、そのフレーム内で表示さ
れていた(または選択されたウィンドウの)バッファーが先頭になります(この順
序は、そのフレームのフレームパラメーター‘buffer-list’に記録される。*note
Buffer Parameters::を参照されたい)。そのフレームでは表示されていないフレ
ームは後になるよう、並び順は基本バッファーリストに準じます。

 -- Function: buffer-list &optional frame
     この関数は、すべてのバッファーを含むバッファーリストをリターンする
     (名前がスペースで始まるバッファーも含む)。リストの要素はバッファー
     の名前ではなく、実際のバッファーである。

     FRAMEがフレームの場合は、FRAMEのローカルバッファーリストをリターン
     する。FRAMEが‘nil’、または省略された場合は、基本バッファーリストが
     使用される。その場合、そのバッファーを表示するフレームがどれかとは
     無関係に、もっとも最近に表示、または選択されたバッファーの順になる
     。

          (buffer-list)
               ⇒ (#<buffer buffers.texi>
                   #<buffer  *Minibuf-1*> #<buffer buffer.c>
                   #<buffer *Help*> #<buffer TAGS>)

          ;; ミニバッファーの名前が
          ;;   スペースで始まることに注意!
          (mapcar (function buffer-name) (buffer-list))
              ⇒ ("buffers.texi" " *Minibuf-1*"
                  "buffer.c" "*Help*" "TAGS")

   ‘buffer-list’からリターンされるリストは、それ専用に構築されたリストで
あり、Emacsの内部的なデータ構造ではないし、それを変更してもバッファーの
並び順に影響はありません。基本バッファーリスト内のバッファーの並び順を変
更したい場合に簡単なのは、以下の方法です:

     (defun reorder-buffer-list (new-list)
       (while new-list
         (bury-buffer (car new-list))
         (setq new-list (cdr new-list))))

   この方法により、バッファーを失ったり、有効な生きたバッファー以外の何
かを追加する危険を犯さずに、リストに任意の並び順を指定できます。

   特定のフレームのバッファーリストの並び順や値を変更するには、
‘modify-frame-parameters’でそのフレームの‘buffer-list’パラメーターをセッ
トしてください(*note Parameter Access::を参照)。

 -- Function: other-buffer &optional buffer visible-ok frame
     この関数は、バッファーリスト中でBUFFER以外の最初のバッファーをリタ
     ーンする。これは通常選択されたウィンドウ(フレームFRAME、または選択
     されたフレーム。*note Input Focus::を参照)に、もっとも最近表示され
     た、BUFFER以外のバッファーである。名前がスペースで始まるバッファー
     は、考慮されない。

     BUFFERが与えられない(または生きたバッファーでない)場合、
     ‘other-buffer’は選択されたフレームのローカルバッファーリスト内の、
     最初のバッファーをリターンする(FRAMEが非‘nil’の場合は、FRAMEのロー
     カルバッファーリスト内の最初のバッファーをリターンする)。

     FRAMEが非‘nil’の‘buffer-predicate’パラメーターをもつ場合は、どのバ
     ッファーを考慮すべきかを決定するために、‘other-buffer’はその述語を
     使用する。これはそれぞれのバッファーごとにその述語を一度呼び出して
     、値が‘nil’ならそのバッファーは無視される。*note Buffer
     Parameters::を参照のこと。

     VISIBLE-OKが‘nil’ならば、‘other-buffer’はやむを得ない場合を除き、任
     意の可視のフレーム上のウィンドウ内で可視のバッファーをリターンする
     ことを避ける。VISIBLE-OKが非‘nil’の場合は、バッファーがどこかで表示
     されているかどうかは問題にしない。

     適切なバッファーが存在しない場合は、バッファー‘*scratch*’を(必要な
     ら作成して)リターンする。

 -- Function: last-buffer &optional buffer visible-ok frame
     この関数は、FRAMEのバッファーリスト内から、BUFFER以外の最後のバッフ
     ァーをリターンする。FRAMEが省略、または‘nil’の場合は、選択されたフ
     レームのバッファーリストを使用する。

     引数VISIBLE-OKは、上述した‘other-buffer’と同様に扱われる。適切なバ
     ッファーを見つけられない場合は、バッファー‘*scratch*’がリターンされ
     る。

 -- Command: bury-buffer &optional buffer-or-name
     このコマンドは、バッファーリスト内の他のバッファーの並び順を変更す
     ることなく、BUFFER-OR-NAMEをバッファーリストの最後に置く。つまり、
     このバッファーは‘other-buffer’がリターンする候補で、もっとも期待度
     が低くなる。引数はバッファー自身か、バッファーの名前を指定できる。

     この関数は、基本バッファーリストと同様に、それぞれのフレームの
     ‘buffer-list’パラメーターを操作する。したがってバリー(bury: 埋める
     、隠す)したバッファーは、‘(buffer-list FRAME)’および
     ‘(buffer-list)’の値の最後に置かれるだろう。さらに、そのバッファーが
     選択されたウィンドウに表示されていれば、そのウィンドウのバッファー
     リストの最後にバッファーを置くことも行う(*note Window History::を参
     照)。

     BUFFER-OR-NAMEが‘nil’、または省略された場合は、カレントバッファーを
     バリーすることを意味する。加えて、カレントバッファーが選択されたウ
     ィンドウに表示されている場合は、そのウィンドウを削除するか、他のバ
     ッファーを表示する。より正確には、選択されたウィンドウが専用
     (dedicated)のウィンドウ(*note Dedicated Windows::)であり、かつその
     フレーム上に他のウィンドウが存在する場合、専用ウィンドウは削除され
     る。それがフレーム上で唯一のウィンドウであり、かつそのフレームが端
     末上で唯一のフレームでない場合、そのフレームは
     ‘frame-auto-hide-function’で指定される関数を呼び出すことにより、“開
     放”される(*note Quitting Windows::を参照)。それ以外の場合は、他のバ
     ッファーをそのウィンドウ内に表示するために、
     ‘switch-to-prev-buffer’を呼び出す(*note Window History::を参照)。
     BUFFER-OR-NAMEが他のウィンドウで表示されていた場合は、そのまま表示
     され続ける。

     あるバッファーにたいして、それを表示するすべてのウィンドウでバッフ
     ァーを置き換えるには、‘replace-buffer-in-windows’を使用する。*note
     Buffers and Windows::を参照のこと。

 -- Command: unbury-buffer
     このコマンドは、選択されたフレームのローカルバッファーリストの最後
     のバッファーに切り替える。より正確には、選択されたウィンドウ内で、
     ‘last-buffer’(上記参照)がリターンするバッファーを表示するために、関
     数‘switch-to-buffer’を呼び出す(*note Switching Buffers::を参照)。

 -- Variable: buffer-list-update-hook
     これは、バッファーリストが変更されたときは、常に実行されるノーマル
     フックである。(暗黙的に)このフックを実行する関数は
     ‘get-buffer-create’(*note Creating Buffers::を参照)、
     ‘rename-buffer’(*note Buffer Names::を参照)、‘kill-buffer’(*note
     Killing Buffers::を参照)、‘bury-buffer’(上記参照)、
     ‘select-window’(*note Selecting Windows::を参照)である。

