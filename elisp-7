This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’
corresponding to Emacs version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or
     modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any
     later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU
     General Public License,” with the Front-Cover Texts
     being “A GNU Manual,” and with the Back-Cover Texts
     as in (a) below.  A copy of the license is included
     in the section entitled “GNU Free Documentation
     License.”

     (a) The FSF’s Back-Cover Text is: “You have the
     freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU
     and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: SMIE Lexer,  Next: SMIE Tricks,  Prev: SMIE Grammar,  Up: SMIE

22.7.1.4 Defining Tokens
........................

SMIEには、事前定義された字句解析プログラムが付属しており
、それは次の方法で構文テーブルを使用します: 文字の任意の
シーケンスは、トークンとみなせる単語構文(word syntax)、
またはシンボル構文(symbol syntax)をもち、句読点構文
(punctuation syntax)をもつ任意の文字シーケンスもトークン
とみなされます。このデフォルトのlexerは、開始ポイントと
して適している場合が多々ありますが、任意の与えられた言語
にたいして、実際に正しいことは稀です。たとえば、これは
‘"2,+3"’が3つのトークン‘"2"’、‘",+"’、‘"3"’から構成され
ていると判断するでしょう。

   あなたの言語のlexerルールをSMIEにたいして説明するため
には、次のトークンをfetchする関数と、前のトークンを
fetchする関数の、2つの関数が必要になります。これらの関数
は通常、最初に空白文字とコメントをスキップして、その後に
次のテキストchunk(塊)を調べて、それが特別なトークンか確
認します。これは通常、バッファーから単に抽出された文字列
ですが、あなたが望む他の何かでも構いません。たとえば:
     (defvar sample-keywords-regexp
       (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
     (defun sample-smie-forward-token ()
       (forward-comment (point-max))
       (cond
        ((looking-at sample-keywords-regexp)
         (goto-char (match-end 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-forward "w_")
                   (point))))))
     (defun sample-smie-backward-token ()
       (forward-comment (- (point)))
       (cond
        ((looking-back sample-keywords-regexp (- (point) 2) t)
         (goto-char (match-beginning 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-backward "w_")
                   (point))))))

   これらのlexerがカッコの前にあるとき、空文字列をリター
ンする方法に注目してください。これは、SMIEが構文テーブル
内で定義されているカッコにたいして、自動的に配慮するから
です。より厳密には、lexerが‘nil’、または空文字列をリター
ンした場合、SMIEは構文テーブルにしたがい、対応するテキス
トをsexpとして処理します。


File: elisp,  Node: SMIE Tricks,  Next: SMIE Indentation,  Prev: SMIE Lexer,  Up: SMIE

22.7.1.5 Living With a Weak Parser
..................................

SMIEが使用するパーステクニックは、異なるコンテキストでト
ークンが異なる振る舞いをすることを許しません。ほとんどの
プログラミング言語にたいして、これは順位の競合により
BNF文法を変換するとき明らかになります。

   その文法を若干異なるように表現することにより、これら
の競合を回避できる場合があります。たとえばModula-2にたい
しては、以下のようなBNF文法をもつのが自然に思えるかもし
れません:

       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (cases (cases "|" cases)
              (caselabel ":" insts)
              ("ELSE" insts))
       ...

   しかし、これは‘"ELSE"’にたいする競合を生み出すでしょ
う。その一方でIFルールは、(他の多くのものの中でも特に
)‘"ELSE" = "END"’を暗示します。しかしその一方では、
‘"ELSE"’は‘cases’内に出現しますが、‘cases’は‘"END"’の左
に出現するので、わたしたちは‘"ELSE" > "END"’も得ることに
なります。これは、以下を使用して解決できます:
       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ("CASE" exp "OF" cases "ELSE" insts "END")
             ...)
       (cases (cases "|" cases) (caselabel ":" insts))
       ...
   または
       ...
       (inst ("IF" exp "THEN" else "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (else (insts "ELSE" insts))
       (cases (cases "|" cases) (caselabel ":" insts) (else))
       ...

   文法を書き換えによる競合の解決には欠点があります。な
ぜなら、SMIEはその文法がコードの論理的構造を反映すると仮
定するからです。そのため、BNFと意図する抽象的構文木の関
係を密接に保つことが望まれます。

   注意深く考慮した後に、これらの競合は深刻ではなく、
‘smie-bnf->prec2’のRESOLVERS引数を通じて解決する決心する
場合もあるでしょう。これは通常、その文法が単に不明瞭だか
らです。その文法により記述されるプログラムセットは競合の
影響を受けませんが、それらのプログラムにたいする唯一の方
法はパースだけです。‘'((assoc "|"))’のようなリゾルバ
(resolver: 解決するもの)を追加したいと望むような場合、通
常それはセパレーターと2項結合演算子にたいするケースです
。これが発生し得る他のケースは、‘'((assoc "else"
"then"))’を使用するような場合における、古典的な_ぶら下が
りelse問題dangling else problem_です。これは実際に競合が
あり解決不能だが、実際のところ問題が発生しそうにないケー
スにたいしても、発生し得ます。

   最後に、多くのケースでは、すべての文法再構築努力にも
関わらず、いくつかの競合が残るでしょう。しかし失望しない
でください。パーサーをより賢くすることはできませんが、あ
なたの望むようにlexerをスマートにすることは可能です。そ
の方法は、競合が発生したら競合を引き起こしたトークンを調
べて、それらのうちの1つを2つ以上の異なるトークンに分割す
る方法です。たとえば、トークン‘"begin"’にたいする互換性
のない2つの使用を文法が区別する必要があり、見つかった
‘"begin"’の種類により、lexerに異なるトークン(たとえば
‘"begin-fun"’と‘"begin-plain"’)をリターンさせる場合です
。これはlexerにたいして、異なるケースを区別する処理を強
い、そのためにlexerは特別な手がかりを見つけるために、周
囲のテキストを調べる必要があるでしょう。


File: elisp,  Node: SMIE Indentation,  Next: SMIE Indentation Helpers,  Prev: SMIE Tricks,  Up: SMIE

22.7.1.6 Specifying Indentation Rules
.....................................

提供された文法にもとづき、他に特別なことを行わなくても、
SMIEは自動的なインデントを提供できるでしょう。しかし実際
には、このデフォルトのインデントスタイルでは、恐らく十分
ではありません。多くの異なる状況において、これを微調整し
たいと思うかもしれません。

   SMIEのインデントは、インデントルールは可能な限りロー
カルであるべきという考えにもとづきます。_バーチャルイン
デント(virtual indentation)_という考えによって、この目的
を達成します。これは、特定のプログラムポイント(program
point)は行頭にバーチャルインデントがある場合は、それをも
つだろう、という発想です。もちろん、そのプログラムポイン
トが正に行頭にある場合は、そのプログラムポイントのバーチ
ャルインデントは、プログラムポイントのカレントのインデン
トです。しかしそうでない場合は、SMIEがそのポイントのバー
チャルインデントを計算するために、インデントアルゴリズム
を使用します。ところで実際には、あるプログラムポイントの
バーチャルインデントは、その前に改行を挿入した場合にプロ
グラムポイントがもつであろうインデントと等しい必要はあり
ません。これが機能する方法を確認するためには、Cにおける
‘{’の後のSMIEのインデントルールは、‘{’がインデントする行
自体にあるか、あるいは前の行の終端にあるかを配慮しないこ
とが挙げられます。かわりに、これらの異なるケースは、
‘{’の前のインデントを決定するインデントルール内で処理さ
れます。

   他の重要な考え方として、_parent_の概念があります。あ
るトークン_parent_は、周囲にある直近の構文構造の代表トー
クン(head token)です。たとえば、‘else’のparentは、それが
属する‘if’であり、‘if’のparentは周囲を取り囲む構造の先導
トークン(lead token)です。コマンド‘backward-sexp’は、あ
るトークンからトークンのparentにジャンプしますが、注意点
がいくつかあります。_opener_(‘if’のような、ある構造を開
始するトークン)にたいしては、他のトークンではそのトーク
ンの後のポイントから開始する必要があるのにたいして、
opnerではそのトークンの前のポイントから開始する必要があ
ります。‘backward-sexp’はparentトークンがそのトークンの
_opener_の場合はparentトークンの前のポイントで停止し、そ
れ以外ではparentトークンの後のポイントで停止します。

   SMIEのインデントルールは、2つの引数METHODとARGをとる
関数により指定されます。ここでARGの値と期待されるリター
ン値は、METHODに依存します。

   METHODは、以下のいずれかを指定できます:
   • ‘:after’: この場合、ARGはトークンであり、関数は
     ARGの後に使用するインデントにたいするOFFSETをリター
     ンすべきである。
   • ‘:before’: この場合、ARGはトークンであり、関数は
     ARG自体に使用するインデントのOFFSETをリターンすべき
     である。
   • ‘:elem’: この場合、関数は関数の引数に使用するインデ
     ントのオフセット(ARGが‘arg’の場合)、または基本的の
     インデントステップ(ARGが‘basic’の場合)、のいずれか
     をリターンすべきである。
   • ‘:list-intro’: この場合、ARGはトークンであり、関数
     はそのトークンの後が単一の式ではなく、(任意のトーク
     ンにより区切られない)式のリストが続く場合は非
     ‘nil’をリターンすべきである。

   ARGがトークンのとき、関数はそのトークンの直前のポイン
トで呼び出されます。リターン値‘nil’は常にデフォルトの振
る舞いへのフォールバックを意味するので、関数は期待した引
数でないときは‘nil’をリターンするべきです。

   OFFSETは、以下のいずれかを指定できます:
   • ‘nil’: デフォルトのインデントルールを使用する。
   • ‘(column . COLUMN)’: 列COLUMNにインデントする。
   • NUMBER: 基本トークン(base token: ‘:after’にたいする
     カレントトークンであり、かつ‘:before’にたいして
     parentであるようなトークン)にたいして相対的な、
     NUMBERによるオフセット。


File: elisp,  Node: SMIE Indentation Helpers,  Next: SMIE Indentation Example,  Prev: SMIE Indentation,  Up: SMIE

22.7.1.7 Helper Functions for Indentation Rules
...............................................

SMIEは、インデントを決定する関数内で使用するために特別に
デザインされた、さまざまな関数を提供します(これらの関数
のうちのいくつかは、異なるコンテキスト内で使用された場合
は中断する)。これらの関数はすべて、プレフィックス
‘smie-rule-’で始まります。

 -- Function: smie-rule-bolp
     カレントトークンが行の先頭にある場合は、非‘nil’をリ
     ターンする。

 -- Function: smie-rule-hanging-p
     カレントトークンが_hanging(ぶら下がり)_の場合は、非
     ‘nil’をリターンする。トークンがその行の最後のトーク
     ンであり、他のトークンが先行する場合、そのトークン
     は_hanging_である。行に単独のトークンはhangingでは
     ない。

 -- Function: smie-rule-next-p &rest tokens
     次のトークンがTOKENS内にある場合は、非‘nil’をリター
     ンする。

 -- Function: smie-rule-prev-p &rest tokens
     前のトークンがTOKENS内にある場合は、非‘nil’をリター
     ンする。

 -- Function: smie-rule-parent-p &rest parents
     カレントトークンのparentがPARENTS内にある場合は、非
     ‘nil’をリターンする。

 -- Function: smie-rule-sibling-p
     カレントトークンのparentが実際はsibling(兄弟)の場合
     は、非‘nil’をリターンする。たとえば‘","’のparentが
     直前の‘","’のような場合が該当する。

 -- Function: smie-rule-parent &optional offset
     カレントトークンをparentとアライン(align: 桁揃え)す
     るための適切なオフセットをリターンする。OFFSETが非
     ‘nil’の場合、それは追加オフセットとして適用される整
     数であること。

 -- Function: smie-rule-separator method
     _セパレーター(separator)_としてカレントトークンをイ
     ンデントする。

     ここでの_セパレーター_は、周囲を取り囲む何らかの構
     文構造内でさまざまな要素を区切ることを唯一の目的と
     するトークンであり、それ自体は何も意味をもたないト
     ークン(通常は抽象構文木内でノードとして存在しない
     )を意味する。

     このようなトークンは結合構文をもち、その構文的
     parentと密に結び付けられることが期待される。典型的
     な例としては引数リスト内の‘","’(カッコで括られた内
     部)、または命令文シーケンス内の‘";"’(‘{...}’や
     ‘begin...end’で括られたブロックの内部)が挙げられる
     。

     METHODは、‘smie-rules-function’に渡されるメソッド名
     であること。


File: elisp,  Node: SMIE Indentation Example,  Next: SMIE Customization,  Prev: SMIE Indentation Helpers,  Up: SMIE

22.7.1.8 Sample Indentation Rules
.................................

以下は、インデント関数の例です:

     (defun sample-smie-rules (kind token)
       (pcase (cons kind token)
         (`(:elem . basic) sample-indent-basic)
         (`(,_ . ",") (smie-rule-separator kind))
         (`(:after . ":=") sample-indent-basic)
         (`(:before . ,(or `"begin" `"(" `"{")))
          (if (smie-rule-hanging-p) (smie-rule-parent)))
         (`(:before . "if")
          (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
               (smie-rule-parent)))))

注意すべき点がいくつかあります:

   • 最初のcaseは、使用する基本的なインデントの増分を示
     す。‘sample-indent-basic’が‘nil’の場合、SMIEはグロ
     ーバルセッティング‘smie-indent-basic’を使用する。メ
     ジャーモードがかわりに‘smie-indent-basic’をバッファ
     ーローカルにセットするかもしれないが、これは勧めら
     れない。

   • トークン‘","’にたいするルールにより、カンマセパレー
     ターが行頭にある場合に、SMIEをより賢明に振る舞わせ
     ようとしている。これはセパレーターのインデントを解
     除(outdent)、カンマの後のコードにアラインされるよう
     試みる。たとえば:

          x = longfunctionname (
                  arg1
                , arg2
              );

   • ‘":="’の後のインデントのルールは、そうしなければ
     SMIEが‘":="’を2項演算子として扱い、左の引数に併せて
     右の引数をアラインするであろうから、このルールが存
     在する。

   • ‘"begin"’の前のインデントのルールは、バーチャルイン
     デントの使用例である。このルールは‘"begin"’が
     hangingのときだけ使用され、これは‘"begin"’が行頭に
     ないときのみ発生し得る。そのため、これは‘"begin"’自
     体のインデントには使用されないが、この‘"begin"’に関
     連する何かをインデントするときだけ使用される。この
     ルールは、具体的には以下のフォームを:

              if x > 0 then begin
                      dosomething(x);
                  end
     以下に変更する
              if x > 0 then begin
                  dosomething(x);
              end

   • ‘"if"’の前のインデントのルールは‘"begin"’のインデン
     トルールと似ているが、ここでの目的は‘"else if"’を
     1単位として扱うことにあり、それにより各テストより右
     にインデントされずに、一連のテストにアラインされる
     。この関数は‘smie-rule-bolp’をテストして、‘"if"’が
     別の行にないときだけこれを行う。

     ‘"else"’が、それの属する‘"if"’にたいして常にアライ
     ンされ、かつそれが常に行頭であるることが判っている
     場合は、より効果的なルールを使用できる:
          ((equal token "if")
           (and (not (smie-rule-bolp))
                (smie-rule-prev-p "else")
                (save-excursion
                  (sample-smie-backward-token)
                  (cons 'column (current-column)))))

     この式の利点は、これがシーケンスの最初の‘"if"’まで
     戻ってすべてをやり直すのではなく、前の‘"else"’のイ
     ンデントを再利用することである。


File: elisp,  Node: SMIE Customization,  Prev: SMIE Indentation Example,  Up: SMIE

22.7.1.9 Customizing Indentation
................................

SMIEにより提供されるインデントを使用するモードを使ってい
る場合は、好みに合わせてインデントをカスタマイズできます
。これはモードごと(オプション‘smie-config’を使用)、また
はファイルごと(ファイルローカル変数指定内で関数
‘smie-config-local’を使用)に行うことができます。

 -- User Option: smie-config
     このオプションにより、モードごとにインデントをカス
     タマイズできる。これは‘(MODE . RULES)’という形式の
     要素をもつalistである。rulesの正確な形式については
     、変数のドキュメントを参照のこと。しかし、コマンド
     ‘smie-config-guess’を使用したほうが、より簡単に見つ
     けられるかもしれない。

 -- Command: smie-config-guess
     このコマンドは、好みのスタイルのインデントを生成す
     る、適切セッティングの解決を試みる。あなたのスタイ
     ルでインデントされたファイルをvisitしているときに、
     単にこのコマンドを呼び出せばよい。

 -- Command: smie-config-save
     ‘smie-config-guess’を使用した後にこのコマンドを呼び
     出すと、将来のセッション用にセッティングを保存する
     。

 -- Command: smie-config-show-indent &optional move
     このコマンドは、カレント行のインデントに使用されて
     いるルールを表示する。

 -- Command: smie-config-set-indent
     このコマンドは、カレント行のインデントに合わせて、
     ローカルルールを追加する。

 -- Function: smie-config-local rules
     この関数は、カレントバッファーにたいするインデント
     ルールとして、RULESを追加する。これらのルールは、
     ‘smie-config’オプションにより定義された、任意のモー
     ド固有ルールに追加される。特定のファイルにたいして
     カスタムインデントルールを指定するには、‘eval:
     (smie-config-local '(RULES))’の形式のエントリーを、
     そのファイルのローカル変数に追加する。


File: elisp,  Node: Desktop Save Mode,  Prev: Auto-Indentation,  Up: Modes

22.8 Desktop Save Mode
======================

“Desktop Saveモード”とは、あるセッションから別のセッショ
ンへ、Emacs状態を保存する機能です。Desktop Saveモードの
使用に関するユーザーレベルのコマンドについては、GNU
Emacsマニュアルに記載されています(*note (emacs)Saving
Emacs Sessions::を参照)。バッファーでファイルをvisitして
いるモードでは、この機能を使うために何も行う必要はありま
せん。

   ファイルをvisitしていないバッファーについて状態を保存
するには、そのメジャーモードがバッファーローカル変数
‘desktop-save-buffer’を非‘nil’値にバインドしなければなり
ません。

 -- Variable: desktop-save-buffer
     このバッファーローカル変数が非‘nil’の場合は、デスク
     トップ保存時にそのバッファー状態がdesktopファイルに
     保存される。値が関数の場合、その関数はデスクトップ
     保存時に引数DESKTOP-DIRNAMEで呼び出され、関数が呼び
     出されたバッファーの状態とともに、関数の値が
     desktopファイルに保存される。補助的な情報の一部とし
     てファイル名がリターンされたとき、それらは以下を呼
     び出してフォーマットされるべきである

          (desktop-file-name FILE-NAME DESKTOP-DIRNAME)

   ファイルをvisitしていないバッファーがリストアされるよ
うにするには、その初を行う関数をメジャーモードが定義しな
ければならず、その関数はalist
‘desktop-buffer-mode-handlers’にリストされなければならな
い。

 -- Variable: desktop-buffer-mode-handlers
     以下を要素にもつalistである

          (MAJOR-MODE . RESTORE-BUFFER-FUNCTION)

     関数RESTORE-BUFFER-FUNCTIONは、以下の引数リストで呼
     び出されるだろう

          (BUFFER-FILE-NAME BUFFER-NAME DESKTOP-BUFFER-MISC)

     この関数は、リストアされたバッファーをリターンすべ
     きである。ここで、DESKTOP-BUFFER-MISCは、オプション
     で‘desktop-save-buffer’にバインドされる関数によりリ
     ターンされる値である。


File: elisp,  Node: Documentation,  Next: Files,  Prev: Modes,  Up: Top

23 Documentation
****************

GNU Emacsには便利なビルトインのヘルプ機能があり、それら
のほとんどは、関数や変数のドキュメント文字列に付属するド
キュメント文字列の情報が由来です。このチャプターでは、
Lispプログラムからドキュメント文字列にアクセスする方法に
ついて説明します。

   ドキュメント文字列のコンテンツは、ある種の慣習にした
がうべきです。特に、最初の行は、その関数または変数を簡単
に説明する1つ、または2つの完全なセンテンスであるべきです
。よいドキュメント文字列を記述する方法については、*note
Documentation Tips::を参照してください。

   Emacs向けのドキュメント文字列は、Emacsマニュアルと同
じものではないことに注意してください。マニュアルは、
Texinfo言語で記述された独自のソースファイルをもちます。
それにたいしドキュメント文字列は、それが適用される関数お
よび変数の定義内で指定されます。ドキュメント文字列をコレ
クションしても、それはマニュアルとしては不十分です。なぜ
なら、よいマニュアルとは、そのやり方でまとめられたもので
はなく、議論のトピックという観点によりまとめられているか
らです。

   ドキュメント文字列を表示するコマンドについては、*note
Help: (emacs)Help.を参照してください。

* Menu:

* Documentation Basics::     ドキュメント文字列が定義、格納される場所。
* Accessing Documentation::  Lispプログラムがドキュメント文字列にアクセスする方法。
* Keys in Documentation::    カレントキーバインディングの置き換え。
* Describing Characters::    非プリント文字やキーシーケンスをプリント可能な記述にする。
* Help Functions::           Emacsヘルプ機能により使用されるサブルーチン。


File: elisp,  Node: Documentation Basics,  Next: Accessing Documentation,  Up: Documentation

23.1 Documentation Basics
=========================

ドキュメント文字列は、テキストをダブルクォート文字で囲ん
だ、文字列にたいするLisp構文を使用して記述されます。実は
これは実際のLisp文字列です。関数または変数の定義内の適切
な箇所に文字列があると、それは関数または変数のドキュメン
トの役割を果たします。

   関数定義(‘lambda’や‘defun’フォーム)の中では、ドキュメ
ント文字列は引数リストの後に指定され、通常は関数オブジェ
クト内に直接格納されます。*note Function
Documentation::を参照してください。関数名の
‘function-documentation’プロパティに関数ドキュメントを
putすることもできます(*note Accessing Documentation::を
参照)。

   変数定義(‘defvar’フォーム)の中では、ドキュメント文字
列は初期値の後に指定されます。*note Defining
Variables::を参照してください。この文字列は、その変数の
‘variable-documentation’プロパティに格納されます。

   Emacsがメモリー内にドキュメント文字列を保持しないとき
があります。それには、2つの状況があります。1つ目はメモリ
ーを節約するためで、事前ロードされた関数および変数(プリ
ミティブを含む)のドキュメントは、‘doc-directory’で指定さ
れたディレクトリー内の、‘DOC’という名前のファイルに保持
されます(*note Accessing Documentation::を参照)。2つ目は
関数または変数がバイトコンパイルされたファイルからロード
されたときで、Emacsはそれらのドキュメント文字列のロード
を無効にします(*note Docs and Compilation::を参照)。どち
らの場合も、ある関数にたいしてユーザーが‘C-h
f’(‘describe-function’)を呼び出したときなど、Emacsは必要
なときだけファイルのドキュメント文字列を照会します。

   ドキュメント文字列には、ユーザーがドキュメントを閲覧
するときのみ照会されるキーバインディングを参照する、特別
な“キー置換シーケンス(key substitution sequences)”を含め
ることができます。これにより、たとえユーザーがデフォルト
のキーバインディングを変更していても、ヘルプコマンドが正
しいキーを表示できるようになります。

   オートロードされたコマンド(*note Autoload::を参照)の
ドキュメント文字列では、これらのキー置換シーケンスは特別
な効果をもち、そのコマンドにたいする‘C-h f’により、オー
トロードをトリガーします(これは‘*Help*’バッファー内のハ
イパーリンクを正しくセットアップするために必要となる)。


File: elisp,  Node: Accessing Documentation,  Next: Keys in Documentation,  Prev: Documentation Basics,  Up: Documentation

23.2 Access to Documentation Strings
====================================

 -- Function: documentation-property symbol property
          &optional verbatim
     この関数は、プロパティPROPERTY配下のSYMBOLのプロパ
     ティリスト内に記録されたドキュメント文字列をリター
     ンする。ほとんどの場合、これはPROPERTYを
     ‘variable-documentation’にして、変数のドキュメント
     文字列の照会に使用される。しかし、カスタマイゼーシ
     ョングループのような、他の種類のドキュメント照会に
     も使用できる(が、関数のドキュメントには、以下の
     ‘documentation’関数を使用する)。

     そのプロパティの値が‘DOC’ファイルやバイトコンパイル
     済みファイルに格納されたドキュメント文字列を参照す
     る場合、この関数はその文字列を照会して、それをリタ
     ーンする。

     プロパティの値が‘nil’や文字列以外で、ファイル内のテ
     キストも参照しない場合は、文字列を取得するLisp式と
     して評価される。

     最終的に、この関数はキーバインディングを置換するた
     めに、文字列を‘substitute-command-keys’に引き渡す
     (*note Keys in Documentation::を参照)。VERBATIMが非
     ‘nil’の場合、このステップはスキップされる。

          (documentation-property 'command-line-processed
             'variable-documentation)
               ⇒ "Non-nil once command line has been processed"
          (symbol-plist 'command-line-processed)
               ⇒ (variable-documentation 188902)
          (documentation-property 'emacs 'group-documentation)
               ⇒ "Customization of the One True Editor."

 -- Function: documentation function &optional verbatim
     この関数は、FUNCTIONのドキュメント文字列をリターン
     する。この関数はマクロ、名前付きキーボードマクロ、
     およびスペシャルフォームも通常の関数と同様に処理す
     る。

     FUNCTIONがシンボルの場合は、そのシンボルの
     ‘function-documentation’プロパティを最初に調べる。
     それが非‘nil’値をもつなら、その値(プロパティの値が
     文字列以外の場合は、それを評価した値)がドキュメント
     となる。

     FUNCTIONがシンボル以外、あるいは
     ‘function-documentation’プロパティをもたない場合、
     ‘documentation’は必要ならファイルを読み込んで、実際
     の関数定義のドキュメント文字列を抽出する。

     最後に、VERBATIMが‘nil’なら、この関数は
     ‘substitute-command-keys’を呼び出す。結果はリターン
     するための文字列である。

     ‘documentation’関数は、FUNCTIONが関数定義をもたない
     場合は、‘void-function’エラーをシグナルする。しかし
     、関数定義がドキュメントをもたない場合は問題ない。
     その場合、‘documentation’は‘nil’をリターンする。

 -- Function: face-documentation face
     この関数は、FACEのドキュメント文字列をフェイスとし
     てリターンする。

   以下は、‘documentation’と‘documentation-property’を使
用した例で、いくつかのシンボルのドキュメント文字列を
‘*Help*’バッファー内に表示します。

     (defun describe-symbols (pattern)
       "PATTERNにマッチするEmacs Lispシンボルを説明する。
     名前にPATTERNをもつすべてのシンボルの説明が
     `*Help*'バッファーに表示される。"
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (function
               (lambda (s)
                 ;; シンボルの説明をプリントする
                 (if (fboundp s)             ; これは関数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (commandp s)
                            (let ((keys (where-is-internal s)))
                              (if keys
                                  (concat
                                   "Keys: "
                                   (mapconcat 'key-description
                                              keys " "))
                                "Keys: none"))
                          "Function")
                        (or (documentation s)
                            "not documented"))))

                 (if (boundp s)              ; これは変数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (custom-variable-p s)
                            "Option " "Variable")
                        (or (documentation-property
                              s 'variable-documentation)
                            "not documented")))))))
             sym-list)

         ;; PATTERNにマッチするシンボルのリストを構築
         (mapatoms (function
                    (lambda (sym)
                      (if (string-match pattern (symbol-name sym))
                          (setq sym-list (cons sym sym-list))))))

         ;; データを表示
         (help-setup-xref (list 'describe-symbols pattern) (interactive-p))
         (with-help-window (help-buffer)
           (mapcar describe-func (sort sym-list 'string<)))))

   ‘describe-symbols’関数は‘apropos’のように機能しますが
、より多くの情報を提供します。

     (describe-symbols "goal")

     ---------- Buffer: *Help* ----------
     goal-column     Option
     Semipermanent goal column for vertical motion, as set by ...

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.
     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable `goal-column'.

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was
     at the start of current run of vertical motion commands.
     When the `track-eol' feature is doing its job, the value is 9999.
     ---------- Buffer: *Help* ----------

 -- Function: Snarf-documentation filename
     この関数は、Emacsビルド時の実行可能なEmacsダンプ直
     前に使用される。これは、ファイルFILENAME内に格納さ
     れたドキュメント文字列の位置を探して、メモリー上の
     関数定義および変数のプロパティリスト内にそれらの位
     置を記録する。*note Building Emacs::を参照のこと。

     Emacsは、‘emacs/etc’ディレクトリーから、ファイル
     FILENAMEを読み込む。その後、ダンプされたEmacs実行時
     に、ディレクトリー‘doc-directory’内の同じファイルを
     照会する。FILENAMEは通常‘"DOC"’である。

 -- Variable: doc-directory
     この変数は、ビルトインおよび事前ロードされた関数お
     よび変数のドキュメント文字列を含む、ファイル
     ‘"DOC"’があるべきディレクトリーの名前を保持する。

     ほとんどの場合、これは‘data-directory’と同一である
     。実際にインストールしたEmacsではなく、Emacswpeyビ
     ルドしたディレクトリーからEmacsを実行したときは、異
     なるかもしれない。*note Definition of
     data-directory::を参照のこと。


File: elisp,  Node: Keys in Documentation,  Next: Describing Characters,  Prev: Accessing Documentation,  Up: Documentation

23.3 Substituting Key Bindings in Documentation
===============================================

ドキュメント文字列がキーシーケンスを参照する際、それらは
カレントである実際のキーバインディングを使用するべきです
。これらは、以下で説明する特別なキーシーケンスを使用して
行うことができます。通常の方法によるドキュメント文字列へ
のアクセスは、これらの特別なキーシーケンスをカレントキー
バインディングに置き換えます。これは、
‘substitute-command-keys’を呼び出すことにより行われます
。あなた自身がこの関数を呼び出すこともできます。

   以下は、それら特別なシーケンスと、その意味についての
リストです:

‘\[COMMAND]’
     これは、COMMANDを呼び出すキーシーケンス、または
     COMMANDがキーバインディングをもたない場合は‘M-x
     COMMAND’である。

‘\{MAPVAR}’
     これは、変数MAPVARの値であるようなキーマップの要約
     を意味する。この要約は、‘describe-bindings’を用いて
     作成される。

‘\<MAPVAR>’
     これ自体は、何のテキストも意味せず、副作用のためだ
     けに使用される。これは、このドキュメント文字列内に
     ある、後続のすべての‘\[COMMAND]’にたいするキーマッ
     プとして、MAPVARの値を指定する。

‘\=’
     これは、後続の文字をクォートして、無効にする。した
     がって、‘\=\[’は‘\[’、‘\=\=’は‘\=’を出力に配する。

   *注意してください:* Emacs Lisp内の文字列として記述す
る際は、‘\’を2つ記述しなければなりません。

 -- Function: substitute-command-keys string
     この関数は、上述の特別なシーケンスをSTRINGからスキ
     ャンして、それらが意味するもので置き換え、その結果
     を文字列としてリターンする。これにより、そのユーザ
     ー自身がカスタマイズした、実際のキーシーケンスを参
     照するドキュメントが表示できる。

     あるコマンドが複数のバインディングをもつ場合、通常
     この関数は最初に見つかったバインディングを使用する
     。以下のようにして、コマンドのシンボルプロパティ
     ‘:advertised-binding’に割り当てることにより、特定の
     キーバインディングを指定できる:

          (put 'undo :advertised-binding [?\C-/])

     ‘:advertised-binding’プロパティは、メニューアイテム
     (*note Menu Bar::を参照)に表示されるバインディング
     にも影響する。コマンドが実際にもたないキーバインデ
     ィングを指定した場合、このプロパティは無視される。

   以下は、特別なキーシーケンスの例である:

     (substitute-command-keys
        "再帰編集者abortするには、次をタイプする: \\[abort-recursive-edit]")
     ⇒ "再帰編集者abortするには、次をタイプする: C-]"

     (substitute-command-keys
        "ミニバッファーにたいして定義されたキーは:
       \\{minibuffer-local-must-match-map}")
     ⇒ "ミニバッファーにたいして定義されたキーは:

     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "

     (substitute-command-keys
        "ミニバッファーにたいして再帰編集をabortするには、次をタイプ:
     \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
     ⇒ "ミニバッファーにたいして再帰編集をabortするには、次をタイプ: C-g."

   ドキュメント文字列内のテキストにたいしては、他にも特
別な慣習があります。たとえば、このマニュアルの関数、変数
、およびセクションで参照できます。詳細は*note
Documentation Tips::を参照してください。


File: elisp,  Node: Describing Characters,  Next: Help Functions,  Prev: Keys in Documentation,  Up: Documentation

23.4 Describing Characters for Help Messages
============================================

以下の関数はイベント、キーシーケンス、文字をテキスト表記
(textual descriptions)に変換します。これらの変換された表
記は、メッセージ内に任意のテキスト文字やキーシーケンスを
含める場合に有用です。なぜなら非プリント文字や空白文字は
、プリント文字シーケンスに変換されるからです。空白文字以
外のプリント文字は、その文字自身が表記になります。

 -- Function: key-description sequence &optional prefix
     この関数は、SEQUENCE内の入力イベントにたいして、
     Emacsの標準表記を含む文字列をリターンする。PREFIXが
     非‘nil’の場合、それはSEQUENCEに前置される入力イベン
     トシーケンスであり、リターン値にも含まれる。引数は
     どちらも文字列、ベクター、またはリストかもしれない
     。有効なイベントに関する詳細は、*note Input
     Events::を参照のこと。

          (key-description [?\M-3 delete])
               ⇒ "M-3 <delete>"
          (key-description [delete] "\M-3")
               ⇒ "M-3 <delete>"

     以下の‘single-key-description’の例も参照されたい。

 -- Function: single-key-description event &optional
          no-angles
     この関数は、キーボード入力にたいするEmacsの標準表記
     として、EVENTを表記する文字列をリターンする。通常の
     プリント文字はその文字自身で表れるが、コントロール
     文字は‘C-’で始まる文字列、メタ文字は‘M-’で始まる文
     字列、スペース、タブなどは‘SPC’や‘TAB’のように変換
     される。ファンクションキーのシンボルは、‘<...>’のよ
     うに角カッコ(angle brackets)の内側に表れる。リスト
     であるようなイベントは、そのリストのCAR内のシンボル
     名が、角カッコの内側に表れる。

     オプション引数NO-ANGLESが非‘nil’の場合、ファンクシ
     ョンキーおよびイベントシンボルを括る角カッコは省略
     される。これは、角カッコを使用しない古いバージョン
     のEmacsとの互換性のためである。

          (single-key-description ?\C-x)
               ⇒ "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
               ⇒ "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
          (single-key-description 'delete)
               ⇒ "<delete>"
          (single-key-description 'C-mouse-1)
               ⇒ "<C-mouse-1>"
          (single-key-description 'C-mouse-1 t)
               ⇒ "C-mouse-1"

 -- Function: text-char-description character
     この関数は、テキスト内に出現する文字にたいする
     Emacsの標準表記として、CHARACTERを表記する文字列を
     リターンする。これは‘single-key-description’と似て
     いるが、コントロール文字にカレットが前置されて表さ
     れる点が異なる(これはEmacsバッファー内でコントロー
     ル文字を表示する通常の方法である)。他にも、
     ‘single-key-description’が2**27ビットをメタ文字とす
     るのにたいし、‘text-char-description’は2**7ビットを
     メタ文字とする点が異なる。

          (text-char-description ?\C-c)
               ⇒ "^C"
          (text-char-description ?\M-m)
               ⇒ "\xed"
          (text-char-description ?\C-\M-m)
               ⇒ "\x8d"
          (text-char-description (+ 128 ?m))
               ⇒ "M-m"
          (text-char-description (+ 128 ?\C-m))
               ⇒ "M-^M"

 -- Command: read-kbd-macro string &optional need-vector
     この関数は主にキーボードマクロを操作するために使用
     されるが、‘key-description’の大雑把な意味で逆の処理
     にも使用できる。キー表記を含むスペース区切りの文字
     列でこれを呼び出すと、それに対応するイベントを含む
     文字列、またはベクターをリターンする。(これは単一の
     有効なキーシーケンスであるか否かは問わず、何のイベ
     ントを使用するかに依存する。*note Key Sequences::を
     参照されたい。) NEED-VECTORが非‘nil’の場合、リター
     ン値は常にベクターになる。


File: elisp,  Node: Help Functions,  Prev: Describing Characters,  Up: Documentation

23.5 Help Functions
===================

Emacsは、さまざまなビルトインのヘルプ関数を提供し、それ
らはすべてプレフィックス‘C-h’のサブコマンドとして、ユー
ザーがアクセスできます。それらについての詳細は、*note
Help: (emacs)Help.を参照してください。ここでは、同様な情
報についてプログラムレベルのインターフェイスを説明します
。

 -- Command: apropos pattern &optional do-all
     この関数は、名前にaproposパターン(apropos pattern:
     適切なパターン) PATTERNを含む、“重要”なすべてのシン
     ボルを探す。マッチに使用されるaproposパターンは単語
     、最低2つはマッチしなければならないスペース区切りの
     単語、または(特別な正規表現文字があれば)正規表現の
     いずれかである。あるシンボルが関数、変数、フェイス
     としての定義、あるいはプロパティをもつ場合、そのシ
     ンボルは“重要”とされる。

     関数は、以下のような要素のリストをリターンする:

          (SYMBOL SCORE FUNCTION-DOC VARIABLE-DOC
           PLIST-DOC WIDGET-DOC FACE-DOC GROUP-DOC)

     ここで、SCOREはマッチの面からそのシンボルがどれだけ
     重要に見えるかを比較する整数である。残りの各要素は
     、SYMBOLにたいする関数、変数、...等のドキュメント文
     字列(または‘nil’)である。

     これは‘*Apropos*’という名前のバッファーにもシンボル
     を表示し、その際各行にはドキュメント文字列の先頭か
     ら取得した1行説明とともに表示される。

     DO-ALLが非‘nil’、またはユーザーオプション
     ‘apropos-do-all’が非‘nil’の場合、‘apropos’は見つか
     った関数のキーバインディングも表示する。これは重要
     なものだけでなく、のinternされた_すべて_のシンボル
     も表示する(同様にリターン値としてもそれらをリストす
     る)。

 -- Variable: help-map
     この変数の値は、Helpキー‘C-h’に続く文字にたいするロ
     ーカルキーマップである。

 -- Prefix Command: help-command
     このシンボルは関数ではなく、関数定義セルには
     ‘help-map’として知られる、キーマップを保持する。こ
     れは、‘help.el’内で以下のように定義されている:

          (define-key global-map (string help-char) 'help-command)
          (fset 'help-command help-map)

 -- User Option: help-char
     この変数の値は、ヘルプ文字(help character: Helpを意
     味する文字としてEmacsが認識する文字)である。デフォ
     ルトでは、‘C-h’を意味する8が値である。この文字を読
     み取った際、‘help-form’が非‘nil’のLisp式ならば、
     Emacsはその式を評価して、結果が文字列の場合はウィン
     ドウ内にそれを表示する。

     通常、‘help-form’の値は‘nil’である。その場合、ヘル
     プ文字はコマンド入力のレベルにおいて特別な意味を有
     せず、通常の方法におけるキーシーケンスの一部となる
     。‘C-h’の標準的なキーバインディングは、複数の汎用目
     的をもつヘルプ機能のプレフィックスキーである。

     ヘルプ文字は、プレフィックスキーの後でも特別な意味
     をもつ。ヘルプ文字がプレフィックスキーのサブコマン
     ドとしてバインディングをもたない場合は、そのプレフ
     ィックスキーのすべてのサブコマンドのリストを表示す
     る、‘describe-prefix-bindings’を実行する。

 -- User Option: help-event-list
     この変数の値は、“ヘルプ文字”の代役を果たすイベント
     型のリストである。これらのイベントは、‘help-char’で
     指定されるイベントと同様に処理される。

 -- Variable: help-form
     この変数が非‘nil’の場合、その値は文字‘help-char’が
     読み取られるたびに評価されるフォームである。そのフ
     ォームの評価により文字列が生成された場合は、その文
     字列が表示される。

     ‘read-event’、‘read-char-choice’、‘read-char’を呼び
     出すコマンドは、それが入力を行う間は、恐らく
     ‘help-form’を非‘nil’にバインドすべきであろう
     (‘C-h’が他の意味をもつ場合は、これを行うべきではな
     い)。この式を評価した結果は、何にたいする入力なのか
     、そしてそれを正しくエンターする方法を説明する文字
     列であること。

     ミニバッファーへのエントリーにより、この変数は
     ‘minibuffer-help-form’の値にバインドされる(*note
     Definition of minibuffer-help-form::を参照)。

 -- Variable: prefix-help-command
     この変数は、プレフィックスキーにたいするヘルプをプ
     リントする関数を保持する。その関数は、ユーザーが後
     にヘルプ文字を伴うプレフィックスキーをタイプし、そ
     のヘルプ文字がプレフィックスの後のバインディングを
     もたないたときに呼び出される。この変数のデフォルト
     値は‘describe-prefix-bindings’である。

 -- Command: describe-prefix-bindings
     この関数は、もっとも最近のプレフィックスキーのサブ
     コマンドすべてにたいするリストを表示する。プレフィ
     ックスの説明は、そのキーシーケンスの最後のイベント
     を除くすべてから構成される(最後のイベントは、恐らく
     ヘルプ文字であろう)。

   以下の2つの関数は、“electric”モードのように制御を放棄
することなくヘルプを提供したいモードを意図しています。こ
れらは、通常のヘルプ関数と区別するため、名前が‘Helper’で
始まります。

 -- Command: Helper-describe-bindings
     このコマンドは、ローカルキーマップとグローバルキー
     マップの両方のキーバインディングすべてのリストを含
     むヘルプバッファーを表示するウィンドウをポップアッ
     プする。これは‘describe-bindings’を呼び出すことによ
     り機能する。

 -- Command: Helper-help
     このコマンドは、カレントモードにたいするヘルプを提
     供する。これはミニバッファー内でメッセージ‘Help
     (Type ? for further options)’とともにユーザーに入力
     を求め、その後キーバインディングが何か、何を意図す
     るモードなのかを探すための助けを提供する。これは
     ‘nil’をリターンする。

     これは、マップ‘Helper-help-map’を変更することにより
     カスタマイズできる。

 -- Variable: data-directory
     この変数は、Emacsに付随する特定のドキュメントおよび
     テキストファイルを探すディレクトリーの名前を保持す
     る。

 -- Function: help-buffer
     この関数は、ヘルプバッファーの名前(通常は
     ‘*Help*’)をリターンする。そのようなバッファーが存在
     しない場合は、最初にそれを作成する。

 -- Macro: with-help-window buffer-name body...
     このマクロは、‘with-output-to-temp-buffer’(*note
     Temporary Displays::を参照)のようにBODYを評価して、
     そのフォームが生成したすべての出力を、BUFFER-NAMEと
     いう名前のバッファーに挿入する(BUFFER-NAMEは、通常
     は関数‘help-buffer’によりリターンされる値であるべき
     だろう)。これは、指定されたバッファーをHelpモードに
     置き、ヘルプウィンドウをquit、およびスクロールする
     方法を告げるメッセージを表示する。これは、ユーザー
     オプション‘help-window-select’のカレント値が適切に
     セットされていれば、ヘルプウィンドウの選択も行う。
     これはBODY内の最後の値をリターンする。

 -- Function: help-setup-xref item interactive-p
     この関数は、‘*Help*’バッファー内のクロスリファレン
     スデータを更新する。このクロスリファレンスは、ユー
     ザーが‘Back’ボタンまたは‘Forward’ボタン上でクリック
     した際に、ヘルプ情報の再生成に使用される。
     ‘*Help*’バッファーを使用するほとんどのコマンドは、
     バッファーをクリアーする前に、この関数を呼び出すべ
     きである。ITEM引数は、‘(FUNCTION . ARGS)’という形式
     であること。ここで、FUNCTIONは引数リストARGSで呼び
     出されるヘルプバッファーを再生成する関数である。コ
     マンド呼び出しがinteractiveに行われた場合、
     INTERACTIVE-P引数は非‘nil’である。この場合、
     ‘*Help*’バッファーの‘Back’ボタンにたいするitemのス
     タックはクリアーされる。

   ‘help-buffer’、‘with-help-window’、
‘help-setup-xref’の使用例は、*note describe-symbols
example::を参照してください。

 -- Macro: make-help-screen fname help-line help-text
          help-map
     このマクロは、提供するサブコマンドのリストを表示す
     るプレフィックスキーのように振る舞う、FNAMEという名
     前のヘルプコマンドを定義する。

     呼び出された際、FNAMEはウィンドウ内にHELP-TEXTを表
     示してから、HELP-MAPに応じてキーシーケンスの読み取
     りと実行を行う。文字列HELP-TEXTは、HELP-MAP内で利用
     可能なバインディングを説明すべきである。

     コマンドFNAMEは、HELP-TEXTの表示をスクロールするこ
     とによる、自身のいくつかのイベントを処理するために
     定義される。FNAMEがこれらのスペシャルイベントのいず
     れかを読み取った際は、スクロールを行った後で他のイ
     ベントを読み取る。自身が処理する以外のイベントを読
     み取り、そのイベントがHELP-MAP内にバインディングを
     有す際は、そのキーのバインディングを実行した後リタ
     ーンする。

     引数HELP-LINEは、HELP-MAP内の候補の1行要約であるこ
     と。Emacsのカレントバージョンでは、オプション
     ‘three-step-help’を‘t’にセットした場合のみ、この引
     数が使用される。

     このマクロは、‘C-h C-h’にバインドされるコマンド
     ‘help-for-help’内で使用される。

 -- User Option: three-step-help
     この変数が非‘nil’の場合、‘make-help-screen’で定義さ
     れたコマンドは、最初にエコーエリア内に自身の
     HELP-LINE文字列を表示し、ユーザーが再度ヘルプ文字を
     タイプした場合のみ、長いHELP-TEXT文字列を表示する。


File: elisp,  Node: Files,  Next: Backups and Auto-Saving,  Prev: Documentation,  Up: Top

24 Files
********

このチャプターでは検索、作成、閲覧、保存、その他ファイル
とディレクトリーにたいして機能する、Emacs Lispの関数およ
び変数について説明します。その他のいくつかのファイルに関
する関数については*note Buffers::、バックアップと
auto-save(自動保存)に関する関数については*note Backups
and Auto-Saving::で説明されています。

   ファイル関数の多くは、ファイル名であるような引数を1つ
以上とります。このファイル名は文字列です。これらの関数の
ほとんどは、関数‘expand-file-name’を使用してファイル名引
数を展開するので、‘~’は相対ファイル名(‘../’を含む)として
正しく処理されます。*note File Name Expansion::を参照し
てください。

   加えて、特定の“magic”ファイル名は特別に扱われます。た
とえば、リモートファイル名が指定された際、Emacsは適切な
プロトコルを通じて、ネットワーク越しにファイルにアクセス
します。*note Remote Files: (emacs)Remote Files.を参照し
てください。この処理は非常に低いレベルで行われるので、注
記されたものを除き、このチャプターで説明するすべての関数
が、ファイル名引数としてmagicファイル名を受け入れると想
定しても良いでしょう。詳細は、*Note Magic File Names::を
参照してください。

   ファイルI/O関数がLispエラーをシグナルする際、通常はコ
ンディション‘file-error’を使用します(*note Handling
Errors::を参照)。ほとんどの場合、オペレーティングシステ
ムからロケール‘system-messages-locale’に応じたエラーメッ
セージが取得され、コーディングシステム
‘locale-coding-system’を使用してデコードされます(*note
Locales::を参照)。

* Menu:

* Visiting Files::           編集のためにEmacsバッファーにファイルを読み込む。
* Saving Buffers::           変更されたバッファーをファイルに書き戻す。
* Reading from Files::       ファイルをvisitせずにバッファーに読み込む。
* Writing to Files::         バッファーの一部から新たなファイルに書き込む。
* File Locks::               複数名による同時編集を防ぐためにファイルをlockまたはunlockする。
* Information about Files::  ファイルの存在、アクセス権、サイズのテスト。
* Changing Files::           ファイル名のリネームやパーミッションの変更など。
* File Names::               ファイル名の分解と展開。
* Contents of Directories::  ディレクトリーないのファイルリストの取得。
* Create/Delete Dirs::       ディレクトリーの作成と削除。
* Magic File Names::         特定のファイル名にたいする特別な処理。
* Format Conversion::        さまざまなファイルフォーマットへ/からの変換。


File: elisp,  Node: Visiting Files,  Next: Saving Buffers,  Up: Files

24.1 Visiting Files
===================

ファイルのvisitとは、ファイルをバッファーに読み込むこと
を意味します。一度これを行うと、わたしたちはバッファーが
ファイルを“visit(訪問)”していると言い、ファイルのことを
バッファーの“visit”されたファイルと呼んでいます。

   ファイルとバッファーは、2つの異なる事柄です。ファイル
とは、(削除しない限り)コンピューター内に永続的に記録され
た情報です。一方バッファーとは、編集セッションの終了(ま
たはバッファーのkill)とともに消滅する、Emacs内部の情報で
す。あるバッファーがファイルをvistしているとき、バッファ
ーぬはファイルからコピーされた情報が含まれます。編集コマ
ンドにより変更されるのは、バッファー内のコピーです。バッ
ファーへの変更によりファイルは変更されません。その変更を
永続化させるには、バッファーを“保存(save)”しなければなり
ません。これは変更されたバッファーのコンテンツをファイル
にコピーして戻すことを意味します。

   ファイルとバッファーは異なるにも関わらず、人はバッフ
ァーという意味でファイルを呼んだり、その逆を行うことが多
々あります。実際のところ、“わたしは間もなく同じ名前のフ
ァイルに保存するバッファーを編集している”ではなく、“わた
しはファイルを編集している”と言います。人間がこの違いを
明示する必要は、通常はありません。しかし、コンピューター
プログラムに対処する際は、この違いを心に留めておくのが良
いでしょう。

* Menu:

* Visiting Functions::       visit用の通常のインターフェイス関数。
* Subroutines of Visiting::  通常のvisit関数が使用する低レベルのサブルーチン。


File: elisp,  Node: Visiting Functions,  Next: Subroutines of Visiting,  Up: Visiting Files

24.1.1 Functions for Visiting Files
-----------------------------------

このセクションでは、ファイルのvisitに通常使用される関数
を説明します。歴史的な理由により、これらの関数は
‘visit-’ではなく、‘find-’で始まる名前をもちます。バッフ
ァーをvisitしているファイルの名前へのアクセスや、visitさ
れたファイル名から既存のバッファーを見つける関数および変
数については、*note Buffer File Name::を参照してください
。

   Lispプログラム内では、ファイル内容を見たいものの変更
したくない場合はテンポラリーバッファー(temporary buffer:
一時的なバッファー)で‘insert-file-contents’を使用例する
のが、もっとも高速な方法です。時間を要するファイルの
visitは必要ありません。*note Reading from Files::を参照
してください。

 -- Command: find-file filename &optional wildcards
     このコマンドは、ファイルFILENAMEをvisitしているバッ
     ファーを選択する。visitしている既存のバッファーがあ
     ればそのバッファーを使用し、なければバッファーを新
     たに作成して、そのバッファーにファイルを読み込む。
     これはそのバッファーをリターンする。

     技術的な詳細を別とすると、‘find-file’関数のbodyは基
     本的には以下と等価である:

          (switch-to-buffer (find-file-noselect filename nil nil wildcards))

     (*note Switching Buffers::の‘switch-to-buffer’を参
     照されたい。)

     WILDCARDSが非‘nil’(これはinteractiveに呼び出された
     場合は常にtrueである)の場合、‘find-file’は
     FILENAME内のワイルドカード文字を展開して、マッチす
     るすべてのファイルをvisitする。

     ‘find-file’がinteractiveに呼び出された際は、ミニバ
     ッファー内でFILENAMEの入力を求める。

 -- Command: find-file-literally filename
     このコマンドは、‘find-file’が行うようにFILENAMEを
     visitするが、フォーマット変換(*note Format
     Conversion::を参照)、文字コード変換(*note Coding
     Systems::を参照)、EOL変換(*note End of line
     conversion: Coding System Basics.を参照)を何も行わ
     ない。ファイルをvisitしているバッファーはunibyteに
     なり、ファイル名とは無関係にバッファーのメジャーモ
     ードはFundamentalモードになる。ファイル内で指定され
     たファイルローカル変数(*note File Local
     Variables::を参照)は無視され、自動的な解凍と
     ‘require-final-newline’によるファイル終端への改行追
     加(*note require-final-newline: Saving Buffers.を参
     照)も無効になる。

     Emacsがすでにリテラリー(literally: 文字通り、そのま
     ま)でない方法で同じファイルをvisitしているバッファ
     ーをもつ場合、Emacsはその同じファイルをリテラリーに
     visitせず、単に既存のバッファーに切り替わることに注
     意されたい。あるファイルのコンテンツにたいして、確
     実にリテラリーにアクセスしたい場合は、テンポラリー
     バッファーを作成し、
     ‘insert-file-contents-literally’を使用してファイル
     のコンテンツを読み込むべきである(*note Reading from
     Files::を参照)。

 -- Function: find-file-noselect filename &optional
          nowarn rawfile wildcards
     この関数は、ファイルをvisitするすべての関数の要であ
     る。これは、ファイルFILENAMEをvisitしているバッファ
     ーをリターンする。望むならそのバッファーをカレント
     にしたり、あるウィンドウ内に表示することができるだ
     ろうが、この関数はそれを行わない。

     関数は、既存のバッファーがあればそれをリターンし、
     なければ新たにバッファーを作成し、それにファイルを
     読み込む。‘find-file-noselect’が既存のバッファーを
     使用する際は、まずファイルがそのバッファーに最後に
     visit、または保存したときから変更されていないことを
     検証する。ファイルが変更されている場合、この関数は
     変更されたファイルを再読み込みするかどうかをユーザ
     ーに尋ねる。ユーザーが‘yes’と応えた場合、以前に行わ
     れたそのバッファー内での編集は失われる。

     ファイルの読み込みは、EOL変換、フォーマット変換
     (*note Format Conversion::を参照)を含む、ファイルコ
     ンテンツのデコードを要する(*note Coding Systems::を
     参照)。WILDCARDSが非‘nil’の場合、
     ‘find-file-noselect’はFILENAME内のワイルドカード文
     字を展開して、マッチするすべてのファイルをvisitする
     。

     この関数は、オプション引数NOWARNが‘nil’の場合は、さ
     まざまな特殊ケースにおいて、警告メッセージ(warning
     message)、および注意メッセージ(advisory message)を
     表示する。たとえば、関数がバッファーの作成を必要と
     し、かつFILENAMEという名前のファイルが存在しない場
     合は、エコーエリア内にメッセージ‘(New file)’を表示
     して、そのバッファーを空のままに留める。

     ‘find-file-noselect’関数は通常、ファイルを読み込ん
     だ後に‘after-find-file’を呼び出す(*note Subroutines
     of Visiting::を参照)。この関数はバッファーのメジャ
     ーモードのセット、ローカル変数のパース、正にvisitし
     たファイルより新しいauto-saveファイルが存在する場合
     のユーザーへの警告を行い、‘find-file-hook’内の関数
     を実行することにより終了する。

     オプション引数RAWFILEが非‘nil’の場合、
     ‘after-find-file’は呼び出されず、失敗時に
     ‘find-file-not-found-functions’は呼び出されない。さ
     らに、非‘nil’値のRAWFILEは、コーディングシステム変
     換およびフォーマット変換を抑制する。

     ‘find-file-noselect’関数は、通常はファイル
     FILENAMEをvisitしているバッファーをリターンする。し
     かし、ワイルドカードが実際に使用、展開された場合は
     、それらのファイルをvisitしているバッファーのリスト
     をリターンする。

          (find-file-noselect "/etc/fstab")
               ⇒ #<buffer fstab>

 -- Command: find-file-other-window filename &optional
          wildcards
     このコマンドは、ファイルFILENAMEをvisitしているバッ
     ファーを選択するが、選択されたウィンドウではない他
     のウィンドウでこれを行う。これは、別の既存ウィンド
     ウを使用したり、ウィンドウを分割するかもしれない。
     *note Switching Buffers::lを参照のこと。

     このコマンドがinteractiveに呼び出された際は、
     FILENAMEの入力を求める。

 -- Command: find-file-read-only filename &optional
          wildcards
     このコマンドは、‘find-file’のようにファイル
     FILENAMEをvisitしているバッファーを選択するが、その
     バッファーを読み取り専用(read-only)とマークする。関
     連する関数および変数については、*note Read Only
     Buffers::を参照のこと。

     このコマンドがinteractiveに呼び出された際は、
     FILENAMEの入力を求める。

 -- User Option: find-file-wildcards
     この変数が非‘nil’の場合、各種‘find-file’コマンドは
     ワイルドカード文字をチェックして、それらにマッチす
     るすべてのファイルをvisitする(interactiveに呼び出さ
     れたとき、またはWILDCARDS引数が非‘nil’のとき)。この
     オプションが‘nil’の場合、‘find-file’コマンドはそれ
     らのWILDCARDS引数を無視して、ワイルドカード文字を特
     別に扱うことは決してない。

 -- User Option: find-file-hook
     この変数の値は、ファイルがvisitされた後に呼び出され
     る、関数のリストである。ファイルのローカル変数指定
     は、(もしあれば)このフックが実行される前に処理され
     るだろう。フック関数実行時は、そのファイルをvisitし
     ているバッファーがカレントになる。

     この変数はノーマルフックである。*note Hooks::を参照
     のこと。

 -- Variable: find-file-not-found-functions
     この変数の値は、‘find-file’または
     ‘find-file-noselect’が存在しないファイル名を受け取
     った際に呼び出される、関数のリストである。存在しな
     いファイルを検知すると、‘find-file-noselect’は直ち
     にこれらの関数を呼び出す。これらのうち、いずれかが
     非‘nil’をリターンするまで、リストの順に関数を呼び出
     す。‘buffer-file-name’はすでにセットアップ済みであ
     る。

     関数の値が使用され、多くの場合いくつかの関数だけが
     呼び出されるので、これはノーマルフックではない。

 -- Variable: find-file-literally
     このバッファーローカル変数が非‘nil’値にセットされた
     場合、‘save-buffer’はあたかもそのバッファーがリテラ
     リー、つまり何の変換も行わずにファイルをvisitしてい
     たかのように振る舞う。コマンド
     ‘find-file-literally’は、この変数のローカル値をセッ
     トするが、その他の等価な関数およびコマンドも、たと
     えばファイル終端への改行の自動追加を避けるために、
     同様にこれを行うことができる。この変数は恒久的にロ
     ーカルなので、メジャーモードの変更により影響を受け
     ない。


File: elisp,  Node: Subroutines of Visiting,  Prev: Visiting Functions,  Up: Visiting Files

24.1.2 Subroutines of Visiting
------------------------------

‘find-file-noselect’関数は、2つの重要なサブルーチン
‘create-file-buffer’および‘after-find-file’を使用します
。これらはユーザーのLispコードでも役に立つことがあります
。このセクションでは、それらの使い方について説明します。

 -- Function: create-file-buffer filename
     この関数は、FILENAMEのvisitにたいして適切な名前のバ
     ッファーを作成して、それをリターンする。これは
     FILENAME(ディレクトリー含まず)の名前がフリーならバ
     ッファー名にそれを使用し、フリーでなければ未使用の
     名前を取得するために‘<2>’のような文字列を付加する。
     *note Creating Buffers::も参照のこと。‘uniquify’ラ
     イブラリーは、この関数の結果に影響を与えることに注
     意されたい。*note (emacs)Uniquify::を参照のこと。

     *注意してください:* ‘create-file-buffer’はファイル
     に新たなバッファーを_関連付けません_。バッファーの
     選択もせず、さらにデフォルトのメジャーモードも使用
     しません。

          (create-file-buffer "foo")
               ⇒ #<buffer foo>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<2>>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<3>>

     この関数は、‘find-file-noselect’により使用される。
     この関数自身は‘generate-new-buffer’を使用する(*note
     Creating Buffers::を参照)。

 -- Function: after-find-file &optional error warn
          noauto after-find-file-from-revert-buffer
          nomodes
     この関数は、バッファーのメジャーモードをセットして
     、ローカル変数をパースする(*note Auto Major Mode::を
     参照)。これは‘find-file-noselect’、およびデフォルト
     のリバート関数(*note Reverting::を参照)により呼び出
     される。

     ファイルが存在しない理由によりファイルの読み込みが
     エラーを受け取るが、ディレクトリーは存在する場合、
     呼び出し側はERRORにたいして非‘nil’値を綿すべきであ
     る。この場合、‘after-find-file’は警告‘(New file)’を
     発する。より深刻なエラーにたいしては、呼び出し側は
     通常は‘after-find-file’を呼び出すべきでない。

     WARNが非‘nil’の場合、もしauto-saveファイルが存在し
     、かつそれがvisitされているファイルより新しいなら、
     この関数は警告を発する。

     NOAUTOが非‘nil’の場合、それはAuto-Saveモードを有効
     、または無効にしないことを告げる。以前にAuto-Saveモ
     ードが有効ならば、有効のまま留まる。

     AFTER-FIND-FILE-FROM-REVERT-BUFFERが非‘nil’の場合、
     それはこの関数が‘revert-buffer’から呼び出されたこと
     を意味する。これに直接的な効果はないが、モード関数
     およびフック関数の中には、この変数の値をチェックす
     るものがいくつかある。

     NOMODESが非‘nil’の場合、それはバッファーのメジャー
     モードを変更せず、ファイル内のローカル変数指定を処
     理せず、‘find-file-hook’を実行しないことを意味する
     。この機能は、あるケースにおいて‘revert-buffer’によ
     り使用される。

     ‘after-find-file’が最後に行うのは、リスト
     ‘find-file-hook’内のすべての関数を呼び出すことであ
     る。


File: elisp,  Node: Saving Buffers,  Next: Reading from Files,  Prev: Visiting Files,  Up: Files

24.2 Saving Buffers
===================

Emacs内でファイルを編集とき、実際にはそのファイルを
visitしているバッファーにたいして編集を行っています。つ
まり、ファイルのコンテンツをバッファーにコピーして、編集
しているのはそのコピーなのです。そのバッファーにを変更し
ても、バッファーを“保存(save)”するまでファイルは変更され
ません。保存とは、バッファーのコンテンツをファイルにコピ
ーすることを意味します。

 -- Command: save-buffer &optional backup-option
     この関数は、バッファーが最後にvisitされたとき、また
     は保存されたときから変更されている場合は、カレント
     バッファーのコンテンツを、バッファーによりvisitされ
     ているファイルに保存し、変更されていなければ何も行
     わない。

     ‘save-buffer’は、バックアップファイルの作成に責任を
     負う。通常、BACKUP-OPTIONは‘nil’であり、
     ‘save-buffer’はファイルをvisit以降、それが最初の保
     存の場合のみバックアップファイルを作成する。
     BACKUP-OPTIONにたいする他の値は、別の条件によるバッ
     クアップファイル作成を要求する:

        • 引数4は1つの‘C-u’を、引数64は3つの‘C-u’を示す
          ので、‘save-buffer’はバッファーの次回保存時に
          このバージョンのファイルがバックアップされるよ
          うマークする。

        • 引数16は2つの‘C-u’を、引数64は3つの‘C-u’を示す
          ので、‘save-buffer’関数はそれを保存する前に、
          前バージョンのファイルを無条件にバックアップす
          る。

        • 引数0は、無条件にバックアップファイルを何も_作
          成しない_。

 -- Command: save-some-buffers &optional save-silently-p
          pred
     このコマンドは、ファイルをvisitしている変更されたバ
     ッファーのいくつかを保存する。これは通常、各バッフ
     ァーごとにユーザーに確認を求める。しかし、
     SAVE-SILENTLY-Pが非‘nil’の場合は、ユーザーに質問せ
     ずにファイルをvisitしているすべてのバッファーを保存
     する。

     オプション引数PREDは、どのバッファーで確認を求める
     か(またはSAVE-SILENTLY-Pが非‘nil’の場合は、どのバッ
     ファーで確認せずに保存するか)を制御する。これが
     ‘nil’の場合、それはファイルをvisitしているバッファ
     ーにたいしてのみ確認を求めることを意味する。‘t’の場
     合、それは、‘buffer-offer-save’のバッファーローカル
     値が‘nil’であるような、非ファイルバッファー以外の特
     定のバッファーの保存も提案することを意味する(*note
     Killing Buffers::を参照)。ユーザーが、非ファイルバ
     ッファーの保存にたいして‘yes’と応えると、保存に使用
     するファイル名の指定を求める。
     ‘save-buffers-kill-emacs’関数は、PREDにたいして値
     ‘t’を渡す。

     PREDが‘t’と‘nil’のどちらでもない場合、それは引数な
     しの関数であること。その関数は、そのバッファーの保
     存するを提案するか否かを決定するために、バッファー
     ごとに呼び出されるだろう。これが特定のバッファーで
     非‘nil’値をリターンした場合は、バッファーの保存を提
     案することを意味する。

 -- Command: write-file filename &optional confirm
     この関数は、カレントバッファーをファイルFILENAMEに
     書き込み、バッファーがそのファイルをvisitしているこ
     とにして、未変更とマークする。次にFILENAMEにもとづ
     いてバッファー名をリネームする。バッファー名を一意
     にするため、必要なら‘<2>’のような文字列を付加する。
     処理のほとんどは、‘set-visited-file-name’(*note
     Buffer File Name::を参照)、および‘save-buffer’を呼
     び出すことにより行われる。

     CONFIRMが非‘nil’の場合、それは既存のファイルを上書
     きする前に確認を求めることを意味する。ユーザーがプ
     レフィックス引数を与えない場合、interactiveに確認が
     求められる。

     FILENAMEが既存のディレクトリーであったり、既存のデ
     ィレクトリーへのシンボリックリンクの場合、
     ‘write-file’はディレクトリーFILENAME内でvisitされて
     いるファイルの名前を使用する。そのバッファーがファ
     イルをvisitしていない場合は、かわりにバッファーの名
     前を使用する。

   バッファーの保存により、複数のフックが実行される。こ
れはフォーマット変換も処理する(*note Format
Conversion::を参照)。

 -- Variable: write-file-functions
     この変数の値は、バッファーをvisitされているファイル
     に書き出す前に呼び出される、関数のリストである。そ
     れらのうちのいずれかが非‘nil’をリターンした場合、そ
     のファイルは書き込み済みだと判断され、残りの関数は
     呼び出されないし、ファイルを書き込むための通常のコ
     ードも実行されない。

     ‘write-file-functions’内の関数が非‘nil’をリターンし
     た場合、(それが適切であれば)その関数はファイルをバ
     ックアップする責任を負う。これを行うには、以下のコ
     ードを実行する:

          (or buffer-backed-up (backup-buffer))

     ‘backup-buffer’によりリターンされるファイルモードの
     値を保存して、(もし非‘nil’なら)書き込むファイルのモ
     ードビットをセットしたいと思うかもしれない。これは
     正に‘save-buffer’が通常行うことである。*note Making
     Backup Files: Making Backups.を参照のこと。

     ‘write-file-functions’内のフック関数は、データのエ
     ンコード(が望ましければ)にも責任を負う。これらは適
     切なコーディングシステムと改行規則(*note Lisp and
     Coding Systems::を参照)を選択してエンコード(*note
     Explicit Encoding::を参照)を処理し、使用されていた
     コーディングシステム(*note Encoding and I/O::を参照
     )を‘last-coding-system-used’にセットしなければなら
     ない。

     バッファー内でこのフックをローカルにセットした場合
     、バッファーはそのファイル、またはバッファーのコン
     テンツを取得したファイルに類するものに関連付けられ
     る。このようにして、変数は恒久的にローカルであると
     マークされるので、メジャーモードの変更がバッファー
     ローカルな値を変更することはない。その一方で、
     ‘set-visited-file-name’を呼び出すことにより、変数は
     リセットされるだろう。これを望まない場合は、かわり
     に‘write-contents-functions’を使用したいと思うだろ
     う。

     たとえこれがノーマルフックでないとしても、このリス
     トを操作するために‘add-hook’および‘remove-hook’を使
     用することはできる。*note Hooks::を参照のこと。

 -- Variable: write-contents-functions
     これは正に‘write-file-functions’と同様に機能するが
     、こちらはvisitしている特定のファイルやファイルの場
     所ではなく、バッファーのコンテンツに関連するフック
     を意図している。そのようなフックは、この変数にたい
     するバッファーローカルなバインディングとして、通常
     はメジャーモードにより作成される。この変数は、セッ
     トされた際は、常に自動的にバッファーローカルになる
     。新たなメジャーモードへの切り替えは、常にこの変数
     をリセットするが、‘set-visited-file-name’の呼び出し
     ではリセットされない。

     このフック内の関数のいずれかが非‘nil’をリターンした
     場合、そのファイルはすでに書き込み済みとみなされ、
     残りの関数は呼び出されず、‘write-file-functions’内
     の関数も呼び出されない。

 -- User Option: before-save-hook
     このノーマルフックは、visitしているファイルにバッフ
     ァーが保存される前に実行される。保存が通常の方法で
     行われるか、あるいは上述のフックのいずれかで行われ
     たかは問題にしない。たとえば、‘copyright.el’プログ
     ラムは、ファイルの保存において、それの著作権表示が
     今年であることを確認するために、このフックを使用す
     る。

 -- User Option: after-save-hook
     このノーマルフックは、visitしているファイルにバッフ
     ァーを保存した後に実行される。このフックの使用例の
     1つは、Fast Lockモードにある。このモードは、キャッ
     シュファイルにハイライト情報を保存するために、この
     フックを使用している。

 -- User Option: file-precious-flag
     この変数が非‘nil’の場合、‘save-buffer’は保存ファイ
     ルがもつ名前のかわりに、一時的な名前で新たなファイ
     ルに書き込み、エラーがないと明確になった後にファイ
     ルを意図する名前にリネームすることにより、保存中の
     I/Oエラーから防御する。この手順は、無効なファイルが
     原因となるディスク容量逼迫のような問題を防ぐ。

     副作用として、バックアップ作成にコピーが必要になる
     。*note Rename or Copy::を参照のこと。しかし同時に
     、この高価なファイル保存により、保存したファイルと
     他のファイル名との間のすべてのハードリンクは切断さ
     れる。

     いくつかのモードは、特定のバッファーにおいて、この
     変数に非‘nil’のバッファーローカル値を与える。

 -- User Option: require-final-newline
     この変数は、ファイルが改行で_終わらない_ように書き
     込まれるかどうかを決定する。変数の値が‘t’の場合、
     ‘save-buffer’はバッファーの終端に改行がなければ暗黙
     理に改行を追加する。値が‘visit’の場合、Emacsはファ
     イルをvisitした直後に不足している改行を追加する。値
     が‘visit-save’の場合、Emacsはvisitと保存の両方のタ
     イミングで、不足している改行を追加する。その他の非
     ‘nil’値にたいしては、そのようなケースが生じるたびに
     、改行を追加するかどうか、‘save-buffer’がユーザーに
     尋ねる。

     変数の値が‘nil’の場合、‘save-buffer’は改行を追加し
     ない。デフォルト値は‘nil’だが、特定のバッファーでこ
     れを‘t’にセットするメジャーモードも少数存在する。

   *note Buffer File Name::の関数
‘set-visited-file-name’も参照されたい。


File: elisp,  Node: Reading from Files,  Next: Writing to Files,  Prev: Saving Buffers,  Up: Files

24.3 Reading from Files
=======================

ファイルのコンテンツをバッファーにコピーするためには、関
数‘insert-file-contents’を使用しします(マークをセットす
るので、Lispプログラム内でコマンド‘insert-file’は使用し
てはならない)。

 -- Function: insert-file-contents filename &optional
          visit beg end replace
     この関数は、ファイルFILENAMEのコンテンツを、カレン
     トバッファーのポイントの後に挿入する。これは絶対フ
     ァイル名と、挿入だれたデータの長さからなるリストを
     リターンする。FILENAMEが読み取り可能なファイルの名
     前でない場合は、エラーがシグナルされる。

     この関数は、定義されたファイルフォーマットに照らし
     てファイルのコンテンツをチェックして、適切ならその
     コンテンツの変換、およびリスト
     ‘after-insert-file-functions’内の関数の呼び出しも行
     う。*note Format Conversion::を参照のこと。通常は、
     リスト‘after-insert-file-functions’内のいずれかの関
     数が、EOL変換を含むファイルコンテンツのデコードに使
     用される、コーディングシステム(*note Coding
     Systems::を参照)を判断する。しかし、ファイルに
     nullバイトが含まれる場合、デフォルトではコード変換
     なしでvisitされる。*note
     inhibit-null-byte-detection: Lisp and Coding
     Systems.を参照のこと。

     VISITが非‘nil’の場合、この関数は追加でそのバッファ
     ーを未変更とマークして、そのバッファーのさまざまな
     フィールドをセットアップして、バッファーがファイル
     FILENAMEをvisitしているようにする。これらのフィール
     ドにはバッファーがvisitしたファイルの名前、最終保存
     したファイルのmodtimeが含まれる。これらの機能は
     ‘find-file-noselect’により使用され、恐らくあなた自
     身が使用するべきではない。

     BEGおよびENDが非‘nil’の場合、それらはファイル挿入範
     囲を指定する、バイトオフセット数値であること。この
     場合、VISITは‘nil’でなければならない。たとえば、

          (insert-file-contents filename nil 0 500)

     これはファイルの先頭500文字(バイト)を挿入する。

     引数REPLACEが非‘nil’の場合、それはバッファーのコン
     テンツ(実際にはアクセス可能な範囲)を、ファイルのコ
     ンテンツで置き換えることを意味する。これは単にバッ
     ファーのコンテンツを削除してファイル全体を挿入する
     より優る。なぜなら、(1)マーカー位置を維持し、
     (2)undoリストに配すデータも少ないからである。

     REPLACEとVISITが‘nil’であれば、
     ‘insert-file-contents’で(FIFOやI/Oデバイスのような
     )スペシャルファイルの読み取りが可能である。

 -- Function: insert-file-contents-literally filename
          &optional visit beg end replace
     この関数は‘insert-file-contents’のように機能するが
     、‘find-file-hook’を実行せず、フォーマットのデコー
     ド、文字コード変換、自動解凍、...などを行わない点が
     異なる。

   他のプログラムがファイルを読めるように、他のプロセス
にファイル名を渡したい場合は、関数‘file-local-copy’を使
用します。*note Magic File Names::を参照してください。


File: elisp,  Node: Writing to Files,  Next: File Locks,  Prev: Reading from Files,  Up: Files

24.4 Writing to Files
=====================

関数‘append-to-file’および‘write-region’を使用することに
より、ディスク上のファイルに直接、バッファーのコンテンツ
、またはバッファーの一部を書き込むことができます。
visitされているファイルに書き込むために、これらの関数を
使用しないでください。これにより、visitにたいするメカニ
ズムが混乱するかもしれません。

 -- Command: append-to-file start end filename
     この関数は、カレントバッファー内で、STARTとENDによ
     るリージョンのコンテンツを、ファイルFILENAMEの終端
     に追加する。そのファイルが存在しない場合は作成する
     。この関数は‘nil’をリターンする。

     FILENAMEに書込不可能なファイル、またはファイルを作
     成不可なディレクトリー内の存在しないファイルを指定
     した場合は、エラーがシグナルされる。

     Lispから呼び出した場合、この関数は以下と完全に等価
     である:

          (write-region start end filename t)

 -- Command: write-region start end filename &optional
          append visit lockname mustbenew
     この関数は、カレントバッファー内のSTARTとENDで区切
     られたリージョンを、FILENAMEで指定されたファイルに
     書き込む。

     STARTが‘nil’の場合、このコマンドはバッファーのコン
     テンツ全体(アクセス可能な範囲だけでは_ない_)をファ
     イルに書き込み、ENDは無視する。

     STARTが文字列の場合、‘write-region’はバッファーのテ
     キストではなく、その文字列を追加する。その場合、
     ENDは無視される。

     APPENDが非‘nil’の場合は、指定されたテキストが(もし
     あれば)既存のファイルコンテンツに追加される。
     APPENDが数字の場合、‘write-region’はファイル開始位
     置からそのバイトオフセットをseekして、データをそこ
     に書き込む。

     MUSTBENEWが非‘nil’の場合、‘write-region’はもし
     FILENAMEが既存ファイルの名前なら確認を求める。
     MUSTBENEWがシンボル‘excl’なら、ファイルがすでに存在
     する場合は‘write-region’は確認を求めるかわりに、エ
     ラー‘file-already-exists’をシグナルする。

     MUSTBENEWが‘excl’のときは、存在するファイルのテスト
     に特別なシステム機能を使用する。少なくともローカル
     ディスク上のファイルにたいしては、Emacsがファイルを
     作成する前に、Emacsに通知せずに他のプログラムが同じ
     名前のファイルを作成することはありえない。

     VISITが‘t’の場合、Emacsはバッファーとファイルの関連
     付けを設定し、そのバッファーがそのファイルを
     victimする。また、カレントバッファーにたいする最終
     ファイル変更日時にFILENAMEをセットして、そのバッフ
     ァーを未変更としてマークする。この機能は
     ‘save-buffer’により使用されるが、おそらくあなた自身
     が使用するべきではないだろう。

     VISITが文字列の場合、それはvisitするファイルの名前
     を指定する。この方法を使えば、そのバッファーが別の
     ファイルをvisitしていると記録しつつ、１つのファイル
     (FILENAME)にデータを書き込むことができる。引数
     VISITは、エコーエリアに使用される他に、ファイルのロ
     ックにも使用され、VISITが‘buffer-file-name’に格納さ
     れる。この機能は、‘file-precious-flag’の実装に使用
     される。自分が何をしているか本当にわかっているので
     なければ、これを使用してはならない。

     オプション引数LOCKNAMEが非‘nil’の場合、それはロック
     とアンロックの目的に使用する、FILENAMEおよびVISITを
     オーバーライドするファイル名を指定する。

     関数‘write-region’は、書き込むデータを
     ‘buffer-file-format’により指定される、適切なファイ
     ルフォーマットに変換しするとともに、リスト
     ‘write-region-annotate-functions’内の関数の呼び出し
     も行う。*note Format Conversion::を参照のこと。

     通常、‘write-region’はエコーエリア内にメッセージ
     ‘Wrote FILENAME’を表示する。VISITが‘t’、‘nil’、文字
     列のいずれでもない場合、このメッセージは抑制される
     。この機能は、内部的な目的のために、ユーザーが知る
     必要がないファイルを使用する場合に有用である。

 -- Macro: with-temp-file file body...
     ‘with-temp-file’マクロは、一時バッファー(temporary
     buffer)をカレントバッファーとしてBODYフォームを評価
     して、最後にそのバッファーのコンテンツをFILEに書き
     込む。これは終了時に一時バッファーをkillして、
     ‘with-temp-file’フォームの前にカレントだったバッフ
     ァーをリストアする。その後、BODY内の最後のフォーム
     の値をリターンする。

     ‘throw’やエラーによる異常なexit(abnormal exit)でも
     、カレントバッファーはリストアされる(*note Nonlocal
     Exits::を参照)。

     *note The Current Buffer: Definition of
     with-temp-buffer.の‘with-temp-buffer’も参照のこと。


File: elisp,  Node: File Locks,  Next: Information about Files,  Prev: Writing to Files,  Up: Files

24.5 File Locks
===============

2人のユーザーが同時に同じファイルを編集する際、おそらく
彼らは互いに干渉しあうでしょう。Emacsは、ファイルが変更
される際に“ファイルロック(file lock)”を記録することによ
り、このような状況の発生を防ぎます。そして、Emacsは他の
Emacsジョブにロックされているファイルをvisitしているバッ
ファーへの変更の最初の試みを検知して、ユーザーに何を行う
か尋ねます。このファイルロックの実態は、編集中のファイル
と同じディレクトリーに格納される、特別な名前をもつシンボ
リックリンクです(シンボリックリンクをサポートしないファ
イルシステムでは、通常のファイルが使用される)。

   ファイルのアクセスにNFSを使用する際には、可能性は小さ
いものの、他のユーザーと同じファイルを“同時”にロックする
かもしれません。これが発生した場合、2人のユーザーが同時
にファイルを変更することが可能になりますが、それでも
Emacsは2番目に保存するユーザーにたいして警告を発するでし
ょう。たファイルをvisitしているバッファーで、ディスク上
でファイル変更の検知により、ある種の同時編集を捕捉できま
す。*note Modification Time::を参照してください。

 -- Function: file-locked-p filename
     この関数は、ファイルFILENAMEがロックされていなけれ
     ば‘nil’をリターンする。このEmacsプロセスによりロッ
     クされている場合は‘t’をリターンし、他のEmacsジョブ
     によりロックされている場合はロックしたユーザーの名
     前をリターンする。

          (file-locked-p "foo")
               ⇒ nil

 -- Function: lock-buffer &optional filename
     この関数は、カレントバッファーが変更されている場合
     は、ファイルFILENAMEをロックする。引数FILENAMEのデ
     フォルトは、カレントバッファーがvisitしているファイ
     ルである。カレントバッファーがファイルをvisitしてい
     ない、またはバッファーが変更されていない、またはシ
     ステムがロックをサポートしない場合は、何もしない。

 -- Function: unlock-buffer
     この関数は、カレントバッファーが変更されている場合
     は、バッファーによりvisitされているファイルをアンロ
     ックする。バッファーが変更されていない場合は、その
     ファイルはロックされてはならないので、この関数は何
     もしない。カレントバッファーがファイルをvisitしてい
     ない、またはシステムがロックをサポートしない場合、
     この関数は何もしない。

 -- User Option: create-lockfiles
     この変数が‘nil’の場合、Emacsはファイルをロックしな
     い。

 -- Function: ask-user-about-lock file other-user
     この関数は、ユーザーがFILEの変更を試みたが、それが
     名前OTHER-USERのユーザーにロックされていたとき呼び
     出される。この関数のデフォルト定義は、何を行うかユ
     ーザーに尋ねる関数である。この関数がリターンする値
     は、Emacsが次に何を行うかを決定する:

        • 値‘t’は、そのファイルのロックを奪うことを意味
          する。その場合、OTHER-USERはロックを失い、この
          ユーザーがファイルを編集することができる。

        • 値‘nil’は、ロックを無視して、とにかくユーザー
          がファイルを編集できるようにすることを意味する
          。

        • この関数は、かわりにエラー‘file-locked’をシグ
          ナルする。この場合、ユーザーが行おうとしていた
          変更は行われない。

          このエラーにたいするエラーメッセージは、以下の
          ようになる:

               error→ File is locked: FILE OTHER-USER

          ここで、‘file’はファイル名、OTHER-USERはそのフ
          ァイルのロックを所有するユーザーの名前である。

     望むなら、他の方法で判定を行う独自のバージョンで、
     ‘ask-user-about-lock’関数を置き換えることができる。


File: elisp,  Node: Information about Files,  Next: Changing Files,  Prev: File Locks,  Up: Files

24.6 Information about Files
============================

このセクションでは、ファイル(またはディレクトリーやシン
ボリックリンク)に関して、ファイルが読み込み可能か、書き
込み可能か、あるいはファイルのサイズなｍのような、さまざ
まなタイプの情報を取得する関数を説明します。これらの関数
はすべて、引数にファイルの名前を取ります。注記した場合を
除き、これらの引数には既存のファイルを指定する必要があり
、ファイルが存在しない場合はエラーをシグナルします。

   スペースで終わるファイル名には気をつけてください。い
くつかのファイルシステム(特にMS-Windows)では、ファイル名
の末尾の空白文字は、暗黙かつ自動的に無視されます。

* Menu:

* Testing Accessibility::    そのファイルは読み取り可能か？書き込み可能か？
* Kinds of Files::           それはディレクトリー？それともシンボリックリンク？
* Truenames::                シンボリックリンクが行き着くファイル名。
* File Attributes::          ファイルのサイズ？更新日時など。
* Extended Attributes::      アクセス制御にたいするファイル属性の拡張。
* Locating Files::           標準的な場所でファイルを見つける方法。


File: elisp,  Node: Testing Accessibility,  Next: Kinds of Files,  Up: Information about Files

24.6.1 Testing Accessibility
----------------------------

以下の関数は、あるファイルを読み取り、書き込み、実行する
ためのパーミッションをテストします。明示しない限り、これ
らの関数はファイル名引数にたいするシンボリックリンクを、
すべてのレベル(ファイル自身のレベルおよび親ディレクトリ
ーのレベル)において再帰的にフォローします。

   いくつかのオペレーティングシステムでは、ACL(Access
Control Lists: アクセス制御リスト)のような機構を通じて、
より複雑なアクセスパーミッションセットが指定できます。そ
れらのパーミッションにたいする問い合わせやセットの方法に
ついては、*note Extended Attributes::を参照してください
。

 -- Function: file-exists-p filename
     この関数は、ファイル名FILENAMEが存在しているような
     ら‘t’をリターンする。これは、そのファイルが読み取り
     可能である必要はなく、ファイルの属性を調べることが
     可能なこと意味する(UnixおよびGNU/Linuではなく、その
     ファイルが存在し、かつそのファイルを含むディレクト
     リーの実行パーミッションをもつ場合に‘t’となり、その
     ファイル自体のパーミッションは無関係である)。

     ファイルが存在しない、またはACLポリシーがファイル属
     性を調べることを禁止する場合、この関数は‘nil’をリタ
     ーンする。

     ディレクトリーはファイルなので、ディレクトリー名が
     与えられた場合、‘file-exists-p’は‘t’をリターンする
     。しかし、シンボリックリンクは特別に扱われる。
     ‘file-exists-p’はターゲットファイルが存在する場合の
     み、シンボリックリンクにたいして‘t’をリターンする。

 -- Function: file-readable-p filename
     この関数は、FILENAMEという名前のファイルが存在し、
     それを読み取ることが可能な場合は‘t’をリターンする。
     それ以外は‘nil’をリターンする。

 -- Function: file-executable-p filename
     この関数は、FILENAMEという名前のファイルが存在し、
     それを実行することが可能な場合は‘t’をリターンする。
     それ以外は‘nil’をリターンする。Unixおよび
     GNU/Linuxシステムでは、そのファイルがディレクトリー
     の場合、実行パーミッションはディレクトリー内のファ
     イルの存在と属性をチェックでき、ファイルのモードが
     許せばオープンできることを意味する。

 -- Function: file-writable-p filename
     この関数は、FILENAMEという名前のファイルに書き込み
     可能、または作成可能可能な場合は‘t’をリターンする。
     それ以外は‘nil’をリターンする。ファイルが存在し、そ
     れに書き込むことができるなら、ファイルは書き込み可
     能である。ファイルが存在せず、指定されたディレクト
     リーが存在して、そのディレクトリーに書き込むことが
     できるなら、書き込み可能である。

     以下の例では、‘foo’は親ディレクトリーが存在しないの
     で、たとえユーザーがそのディレクトリーを作成可能で
     あっても、ファイルは書き込み可能ではない。

          (file-writable-p "~/no-such-dir/foo")
               ⇒ nil

 -- Function: file-accessible-directory-p dirname
     この関数は、ファイルとしての名前がDIRNAMEであるよう
     なディレクトリー内にある既存のファイルをオープンす
     るパーミッションをもつ場合は、‘t’をリターンする。そ
     れ以外(またはそのようなディレクトリーが存在しない場
     合)は‘nil’をリターンする。DIRNAMEの値はディレクトリ
     ー名(‘/foo/’など)、または名前がディレクトリー(最後
     のスラッシュがない‘/foo’など)であるようなファイルで
     ある。

     たとえば、以下では‘/foo/’内の任意のファイルを読み取
     る試みは、エラーになると推測される:

          (file-accessible-directory-p "/foo")
               ⇒ nil

 -- Function: access-file filename string
     この関数は、読み取り用にファイルFILENAMEをオープン
     して、クローズした後に‘nil’をリターンする。しかし、
     オープンに失敗した場合は、STRINGをエラーメッセージ
     のテキストに使用して、エラーをシグナルする。

 -- Function: file-ownership-preserved-p filename
          &optional group
     この関数は、ファイルFILENAMEを削除して、それを新た
     に作成しても、そのファイルの所有者が変更されずに維
     持される場合は、‘t’をリターンする。これは、存在しな
     いファイルにたいしても‘t’をリターンする。

     オプション引数GROUPが非‘nil’の場合、この関数はファ
     イルのグループが変更されないこともチェックする。

     FILENAMEがシンボリックリンクの場合は、ここで述べる
     他の関数と異なり、‘file-ownership-preserved-p’は
     FILENAMEをターゲットで_置き換えない_。しかし、この
     関数は親ディレクトリーのすべての階層において、シン
     ボリックリンクを再帰的にフォローする(follow: 辿る
     )。

 -- Function: file-modes filename
     この関数は、FILENAMEの“モードビット(mode bits)”をリ
     ターンする。これは読み取り、書き込み、実行パーミッ
     ションを要約する整数である。FILENAMEでのシンボリッ
     クリンクは、すべての階層において再帰的にフォローさ
     れる。ファイルが存在しない場合のリターン値は‘nil’で
     ある。

     モードビットの説明は、*Note (coreutils)File
     permissions::を参照のこと。たとえば最下位ビットが
     1なら、そのファイルは実行可能、2ビット目が1なら書き
     込み可能、...となる。設定できる最大の値は4095(8進の
     7777)であり、これはすべてのユーザーが読み取り、書き
     込み、実行のパーミッションをもち、他のユーザーとグ
     ループにたいしてSUIDビット、およびstickyビットがセ
     ットされる。

     これらのパーミッションのセットに使用される
     ‘set-file-modes’関数については、*note Changing
     Files::を参照のこと。

          (file-modes "~/junk/diffs")
               ⇒ 492               ; 10進整数
          (format "%o" 492)
               ⇒ "754"             ; 8進に変換した値

          (set-file-modes "~/junk/diffs" #o666)
               ⇒ nil

          $ ls -l diffs
          -rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs

     *MS-DOSにたいする注意:* MS-DOSでは、“実行可能”を表
     すようなファイルのモードビットは存在しない。そのた
     め、‘file-modes’はファイル名が‘.com’、‘.bat’、
     ‘.exe’などのような標準的な実行可能な拡張子のいずれ
     かで終わる場合は、ファイルを実行可能であると判断す
     る。Unix標準の‘#!’署名で始まるshellスクリプトや
     Perlスクリプトも、実行可能と判断される。Unixとの互
     換性のために、ディレクトリーも実行可能と報告される
     。‘file-attributes’(*note File Attributes::を参照
     )も、これらの慣習にしたがう。


File: elisp,  Node: Kinds of Files,  Next: Truenames,  Prev: Testing Accessibility,  Up: Information about Files

24.6.2 Distinguishing Kinds of Files
------------------------------------

このセクションでは、ディレクトリー、シンボリックリンク、
および通常ファイルのような、さまざまな種類のファイルを区
別する方法を説明します。

 -- Function: file-symlink-p filename
     ファイルFILENAMEがシンボリックリンクの場合、
     ‘file-symlink-p’関数は(非再帰的な)リンクターゲット
     を文字列としてリターンする(リンクターゲット文字列は
     、そのターゲットの完全な絶対ファイル名である必要は
     ない。リンクが指すのが完全なファイル名か判断するの
     は、簡単な処理ではない。以下を参照されたい)。
     FILENAMEのディレクトリー部分(leading directory)にシ
     ンボリックリンクが含まれる場合、この関数はそれらを
     再帰的にフォローする。

     ファイルFILENAMEがシンボリックリンクではない、また
     は存在しない場合、‘file-symlink-p’は‘nil’をリターン
     する。

     この関数の使用例をいくつか示す:

          (file-symlink-p "not-a-symlink")
               ⇒ nil
          (file-symlink-p "sym-link")
               ⇒ "not-a-symlink"
          (file-symlink-p "sym-link2")
               ⇒ "sym-link"
          (file-symlink-p "/bin")
               ⇒ "/pub/bin"

     3つ目の例では、関数は‘sym-link’をリターンするものの
     、たとえそれ自体がシンボリックリンクであっても、リ
     ンク先の解決を行わないことに注意されたい。これが上
     述した“非再帰的(non-recursive)”の意味するところであ
     り、シンボリックリンクをフォローする処理は、そのリ
     ンクターゲット自体がリンクの場合、再帰的には行われ
     ない。

     この関数がリターンするのは、そのシンボリックリンク
     に何が記録されているかを示す文字列であり、それには
     ディレクトリー部分が含まれていても、いなくても構わ
     ない。この関数は完全修飾されたファイル名を生成する
     ためにリンクターゲットを_展開しない_し、リンクター
     ゲットが絶対ファイル名でなければ、(もしあっても
     )FILENAME引数のディレクトリー部分は使用しない。以下
     に例を示す:

          (file-symlink-p "/foo/bar/baz")
               ⇒ "some-file"

     ここでは、たとえ与えられた‘/foo/bar/baz’が完全修飾
     されたファイル名であるにも関わらず、その結果は異な
     り、実際には何のディレクトリー部分ももたない。
     ‘some-file’自体がシンボリックリンクかもしれないので
     、単にその前に先行ディレクトリーを追加することはで
     きず、絶対ファイル名を生成するために、単に
     ‘expand-file-name’(*note File Name Expansion::を参
     照)を使用することもできないからである。

     この理由により、あるファイルがシンボリックリンクか
     否かという単一の事実よりも多くを判定する必要がある
     場合に、この関数が有用であることは稀である。実際に
     リンクターゲットのファイル名が必要な場合は、*note
     Truenames::で説明する‘file-chase-links’または
     ‘file-truename’を使用すること。

   以下の2つの関数は、FILENAMEにたいして、シンボリックリ
ンクを全階層において再帰的にフォローする。

 -- Function: file-directory-p filename
     この関数は、FILENAMEが既存のディレクトリー名なら
     ‘t’、それ以外は‘nil’をリターンする。

          (file-directory-p "~rms")
               ⇒ t
          (file-directory-p "~rms/lewis/files.texi")
               ⇒ nil
          (file-directory-p "~rms/lewis/no-such-file")
               ⇒ nil
          (file-directory-p "$HOME")
               ⇒ nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               ⇒ t

 -- Function: file-regular-p filename
     この関数は、ファイルFILENAMEが存在し、かつそれが通
     常ファイル(ディレクトリー、名前付きパイプ、端末、そ
     の他I/Oデバイス以外)の場合は‘t’をリターンする。


File: elisp,  Node: Truenames,  Next: File Attributes,  Prev: Kinds of Files,  Up: Information about Files

24.6.3 Truenames
----------------

ファイルの“実名(truename)”とは、全階層においてシンボリッ
クリンクを残らずフォローした後、名前コンポーネントに出現
する‘.’と‘..’を除いて簡略化した名前のことです。これは、
そのファイルにたいする正規名(canonical name)の一種です。
ファイルが常に一意な実名をもつ訳ではありません。あるファ
イルにたいする異なる実名の個数は、そのファイルにたいする
ハードリンクの個数と同じです。しかし、実名はシンボリック
リンクによる名前の変動を解消するのに有用です。

 -- Function: file-truename filename
     この関数は、ファイルFILENAMEの実名をリターンする。
     引数が絶対ファイル名でない場合、この関数は最初に
     ‘default-directory’にたいしてこれを展開する。

     この関数は、環境変数を展開しない。これを行うのは
     ‘substitute-in-file-name’だけである。*note
     Definition of substitute-in-file-name::を参照のこと
     。

     名前コンポーネントに出現する‘..’に先行するシンボリ
     ックリンクリンクをフォローする必要がある場合は、直
     接間接を問わず‘expand-file-name’を呼び出す前に、
     ‘file-truename’を呼び出すこと。そうしないと、‘..’の
     直前にある名前コンポーネントは、‘file-truename’が呼
     び出される前に“簡略化”により取り除かれてしまう。
     ‘expand-file-name’呼び出しの必要を無くすため、
     ‘file-truename’は‘expand-file-name’が行うのと同じ方
     法で‘~’を扱う。*note Functions that Expand
     Filenames: File Name Expansion.を参照のこと。

 -- Function: file-chase-links filename &optional limit
     この関数は、FILENAMEで始まるシンボリックリンクを、
     シンボリックリンクではない名前のファイル名までフォ
     ローして、そのファイル名をリターンする。この関数は
     、親ディレクトリーの階層にあるシンボリックリンクを
     フォロー_しない_。

     LIMITに数を指定した場合は、その数のリンクを追跡した
     後、この関数はたとえそれが依然としてシンボリックリ
     ンクであっても、それをリターンする。

   ‘file-chase-links’と‘file-truename’の違いを説明するた
めに、‘/usr/foo’がディレクトリー‘/home/foo’へのシンボリ
ックリンクであり、‘/home/foo/hello’が(少なくともシンボリ
ックリンクではない)通常ファイル、または存在しないファイ
ルであるとします。この場合は以下のようになります:

     (file-chase-links "/usr/foo/hello")
          ;; 親ディレクトリーのリンクはフォローしない
          ⇒ "/usr/foo/hello"
     (file-truename "/usr/foo/hello")
          ;; ‘/home’はシンボリックリンクではないと仮定
          ⇒ "/home/foo/hello"

 -- Function: file-equal-p file1 file2
     この関数は、ファイルFILE1とFILE2の名前が同じファイ
     ルの場合は‘t’をリターンする。これは、リモートファイ
     ル名も適切な方法で処理することを除き、実名の比較と
     似ている。FILE1またはFILE2が存在しない場合、リター
     ン値は不定である。

 -- Function: file-in-directory-p file dir
     この関数は、FILEがディレクトリーDIR内のファイル、ま
     たはサブディレクトリーの場合は、‘t’をリターンする。
     また、FILEとDIRが同じディレクトリーの場合も、‘t’を
     リターンする。この関数は、2つのディレクトリーの実名
     を比較する。DIRが既存のディレクトリーの名前でない場
     合、リターン値は‘nil’である。


File: elisp,  Node: File Attributes,  Next: Extended Attributes,  Prev: Truenames,  Up: Information about Files

24.6.4 File Attributes
----------------------

このセクションでは、ファイルの詳細な情報を取得する関数に
ついて説明します。それらの情報にはファイルの所有者やグル
ープの番号、ファイル名の個数、inode番号、サイズやアクセ
ス日時、変更日時が含まれます。

 -- Function: file-newer-than-file-p filename1 filename2
     この関数は、ファイルFILENAME1がファイルFILENAME2よ
     り新しい場合は、‘t’をリターンする。FILENAME1が存在
     しない場合は‘nil’、FILENAME1は存在するがFILENAME2が
     存在しない場合は‘t’をリターンする。

     以下の例では、‘aug-19’が19日、‘aug-20’が20日に書き
     込まれ、ファイル‘no-file’は存在しないものとする。

          (file-newer-than-file-p "aug-19" "aug-20")
               ⇒ nil
          (file-newer-than-file-p "aug-20" "aug-19")
               ⇒ t
          (file-newer-than-file-p "aug-19" "no-file")
               ⇒ t
          (file-newer-than-file-p "no-file" "aug-19")
               ⇒ nil

   以下の2つの関数のFILENAME引数がシンボリックリンクの場
合、これらの関数はそれをリンクターゲットで_置き換えませ
ん_。しかしどちらの関数も、親ディレクトリーのすべての階
層において、シンボリックリンクを再帰的にフォローします。

 -- Function: file-attributes filename &optional
          id-format
     この関数は、ファイルFILENAMEの属性(attributes)のリ
     ストをリターンする。オープンできないファイルが指定
     された場合は、‘nil’をリターンする。オプション引数
     ID-FORMATは、属性UIDおよびGID(以下参照)にたいして望
     ましいフォーマットを指定し、有効な値は‘'string’およ
     び‘'integer’である。デフォルトは‘'integer’だが、わ
     たしたちはこれの変更を計画しているので、リターンさ
     れるUIDまたはGIDを使用する場合は、ID-FORMATにたいし
     て非‘nil’値を指定するべきである。

     リストの要素は順に:

       0. ディレクトリーにたいしては‘t’、シンボリックリ
          ンクにたいしては文字列(リンクされる名前)、テキ
          ストファイルにたいしては‘nil’。

       1. そのファイルがもつ名前の個数。ハードリンクとし
          て知られる代替え名は、関数‘add-name-to-file’を
          使用して作成できる(*note Changing Files::を参
          照)。

       2. ファイルのUIDで、通常は文字列。しかし、名前を
          もつユーザーに対応しない場合、値は整数。

       3. 同様に、ファイルのGID。

       4. 最終アクセス時刻を表す、4つの整数‘(SEC-HIGH
          SEC-LOW MICROSEC PICOSEC)’からなるリスト(これ
          は‘current-time’の値と似ている。*note Time of
          Day::を参照されたい)。いくつかのFATベースのフ
          ァイルシステムでは、最終アクセスの日付だけが記
          録されるので、この時刻には常に最終アクセス日の
          真夜中が保持されることに注意。

       5. 最終変更時刻を表す4つの整数からなるリスト(上記
          参照)。これは、ファイルのコンテンツが変更され
          た最終時刻である。

       6. ステータスの最終変更時刻を表す4つの整数からな
          るリスト(上記参照)。これはファイルのアクセスモ
          ードビット、所有者とグループ、およびファイルに
          たいしてファイルのコンテンツ以外にファイルシス
          テムが記録するその他の情報にたいする最終変更時
          刻である。

       7. ファイルのサイズ(バイト)。Lisp整数の範囲を超え
          る大きさのサイズでは浮動小数点数。

       8. ‘ls -l’で表示されるような、10個の文字、または
          ダッシュからなる文字列で表されるファイルのモー
          ド。

       9. 後方互換のために提供される不定値。

       10. ファイルのinode番号。可能な場合は整数。Emacs
          Lispの整数として表せる範囲より大きいinode番号
          は、整数で表現可能な値を得るために2^{16}で除さ
          れ‘(HIGH . LOW)’という形式の値になる。ここで
          LOWは下位16ビットである。それにたいしてさえ
          inode番号が大きい場合、値は‘(HIGH MIDDLE .
          LOW)’という形式になる。ここで‘high’は上位ビッ
          ト、MIDDLEは中位24ビット、LOWは下位16ビットを
          保持する。

       11. そのファイルがあるデバイスのファイルシステム
          番号。その大きさにより、値は整数、または
          inode番号と同じ様式のコンスセルとなる。この要
          素とファイルのinode番号を併せれば、システム上
          の2つを区別するに足る情報が得られる(2つのファ
          イルがこれら両方の番号で同じ値をもつことはでき
          ない)。

     たとえば、以下は‘files.texi’のファイル属性である:

          (file-attributes "files.texi" 'string)
               ⇒  (nil 1 "lh" "users"
                    (20614 64019 50040 152000)
                    (20000 23 0 0)
                    (20614 64555 902289 872000)
                    122295 "-rw-rw-rw-"
                    t (5888 2 . 43978)
                    (15479 . 46724))

     この結果を解釈すると:

     ‘nil’
          ディレクトリーでもシンボリックリンクでもない。

     ‘1’
          (カレントデフォルトディレクトリー内で名前
          ‘files.texi’は)単一の名前をもつ。

     ‘"lh"’
          名前"lh"のユーザーにより所有される。

     ‘"users"’
          名前"users"のグループ。

     ‘(20614 64019 50040 152000)’
          最終アクセスがOctober 23, 2012, at
          20:12:03.050040152 UTC。

     ‘(20000 23 0 0)’
          最終更新がJuly 15, 2001, at 08:53:43 UTC。

     ‘(20614 64555 902289 872000)’
          最終ステータス変更がOctober 23, 2012, at
          20:20:59.902289872 UTC。

     ‘122295’
          バイト長は122295バイト(しかしマルチバイトシー
          ケンスが含まれていたり、EOLフォーマットが
          CRLFの場合は122295文字が含まれないだろう)。

     ‘"-rw-rw-rw-"’
          所有者、グループ、その他にたいして読み取り、書
          き込みアクセスのモードをもつ。

     ‘t’
          単なるプレースホルダーであり、何の情報ももたな
          い。

     ‘(5888 2 . 43978)’
          inode番号は6473924464520138。

     ‘(15479 . 46724)’
          ファイルシステムのデバイス番号は1014478468。

 -- Function: file-nlinks filename
     この関数は、ファイルFILENAMEがもつ名前(ハードリンク
     )の個数をリターンする。ファイルが存在しない場合、こ
     の関数は‘nil’をリターンする。シンボリックリンクは、
     リンク先のファイルの名前とは判断されないので、この
     関数に影響しないことに注意。

          $ ls -l foo*
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               ⇒ 2
          (file-nlinks "doesnt-exist")
               ⇒ nil


File: elisp,  Node: Extended Attributes,  Next: Locating Files,  Prev: File Attributes,  Up: Information about Files

24.6.5 Extended File Attributes
-------------------------------

いくつかのオペレーティングシステムでは、それぞれのファイ
ルを任意の“拡張ファイル属性(extended file attributes)”に
関連付けることができます。現在のところ、Emacsは拡張ファ
イル属性のうち2つの特定セット(ACL: Access Control List、
およびSELinuxコンテキスト)にたいする問い合わせと設定をサ
ポートします。これらの拡張ファイル属性は、前のセクション
で議論した“Unixスタイル”の基本的なパーミッションより洗練
されたファイルアクセス制御を強いるために、いくつかのシス
テムで利用されます。

   ACLとSELinuxについての詳細な解説は、このマニュアルの
範囲を超えます。わたしたちの目的のためには、それぞれのフ
ァイルは“ACL”(ACLベースのファイル制御システムの元でACLの
プロパティを指定)および/または“SELinuxコンテキスト
”(SELinuxシステムの元でSELinuxのプロパティを指定)に割り
当てることができる、という理解でよいでしょう。

 -- Function: file-acl filename
     この関数は、ファイルFILENAMEにたいするACLをリターン
     する。ACLにたいする正確なLisp表現は不確定(かつ将来
     のEmacsバージョンで変更され得る)だが、これは
     ‘set-file-acl’が引数ACLにとる値と同じである(*note
     Changing Files::を参照)。

     根底にあるACL実装はプラットフォーム固有である。
     EmacsはGNU/LinuxおよびBSDではPOSIX ACLインターフェ
     イスを使用し、MS-Windowsではネイティブのファイルセ
     キュリティAPIをPOSIX ACLインターフェイスでエミュレ
     ートする。

     ACLサポートなしでEmacsがコンパイルされた場合、ファ
     イルが存在しないかアクセス不能な場合、またはその他
     の理由によりEmacsがACLエントリーを判断できない場合
     、リターン値は‘nil’である。

 -- Function: file-selinux-context filename
     この関数は、ファイルFILENAMEのSELinuxコンテキストを
     、‘(USER ROLE TYPE RANGE)’という形式のリストでリタ
     ーンする。リストの要素は、そのコンテキストのユーザ
     ー、ロール、タイプ、レンジを文字列として表す値であ
     る。これらの実際の意味についての詳細は、SELinuxのド
     キュメントを参照のこと。リターン値は、
     ‘set-file-selinux-context’がCONTEXT引数でとるのと同
     じ形式である(*note Changing Files::を参照)。

     SELinuxサポートなしでEmacsがコンパイルされた場合、
     ファイルが存在しないかアクセス不能な場合、またはシ
     ステムがSELinuxをサポートしない場合、リターン値は
     ‘(nil nil nil nil)’である。

 -- Function: file-extended-attributes filename
     この関数は、Emacsが認識するファイルFILENAMEの拡張属
     性をalistでリターンする。現在のところ、この関数は
     ACLとSELinuxの両方を取得するための便利な方法として
     の役目を果たす。他のファイルに同じファイルアクセス
     属性を適用するために、リターンされたalistを2つ目の
     引数として‘set-file-extended-attributes’を呼び出す
     ことができる(*note Changing Files::を参照)。

     要素のうちの1つは‘(acl . ACL)’で、ACLは‘file-acl’が
     リターンするのと同じ形式である。

     他の要素は‘(selinux-context . CONTEXT)’で、
     CONTEXTは‘file-selinux-context’がリターンするのと同
     じ形式である。


File: elisp,  Node: Locating Files,  Prev: Extended Attributes,  Up: Information about Files

24.6.6 Locating Files in Standard Places
----------------------------------------

このセクションでは、ディレクトリーのリスト(“パス
(path)”)からファイルを検索したり、標準の実行可能ファイル
用ディレクトリーから実行可能ファイルを検索する方法を説明
します。

   ユーザー固有の設定ファイル(configuration file)の検索
については、*note Standard File Names::の関数
‘locate-user-emacs-file’を参照してください。

 -- Function: locate-file filename path &optional
          suffixes predicate
     この関数は、PATHで与えられるディレクトリーリスト内
     で、FILENAMEという名前のファイルを検索して、
     SUFFIXES内のサフィックスの検索を試みる。そのような
     ファイルが見つかった場合はファイルの絶対ファイル名
     (*note Relative File Names::を参照)をリターンし、そ
     れ以外は‘nil’をリターンする。

     オプション引数SUFFIXESは、検索時にFILENAMEに追加す
     るファイル名サフィックスのリストを与える。
     ‘locate-file’は、検索するディレクトリーごとに、それ
     らのサフィックスを試みる。SUFFIXESが‘nil’、または
     ‘("")’の場合は、サフィックスなしで、FILENAMEだけが
     そのまま使用される。SUFFIXESの典型的な値は
     ‘exec-suffixes’(*note Subprocess Creation::を参照
     )、‘load-suffixes’、‘load-file-rep-suffixes’、およ
     び関数‘get-load-suffixes’(*note Load Suffixes::を参
     照)である。

     実行可能プログラムを探すときは‘exec-path’(*note
     Subprocess Creation::を参照)、Lispファイルを探すと
     きは‘load-path’(*note Library Search::を参照)が
     PATHの典型的な値である。FILENAMEが絶対ファイル名の
     場合、PATHは効果がないが、サフィックスにたいする
     SUFFIXESは依然として試行される。

     オプション引数PREDICATEが非‘nil’の場合、それは候補
     ファイルが適切かどうかテストする述語関数を指定する
     。述語関数には、単一の引数として候補ファイル名が渡
     される。PREDICATEが‘nil’、または省略された場合は、
     述語として‘file-readable-p’を使用する。
     ‘file-executable-p’や‘file-directory-p’など、その他
     の有用な述語については、*note Kinds of Files::を参
     照のこと。

     互換性のために、PREDICATEには‘executable’、
     ‘readable’、‘writable’、‘exists’、またはこれらシン
     ボルの1つ以上のリストも指定できる。

 -- Function: executable-find program
     この関数は、PROGRAMという名前の実行可能ファイルを検
     索して、その実行可能ファイルの絶対ファイル名と、も
     しあればファイル名の拡張子も含めてリターンする。フ
     ァイルが見つからない場合は、‘nil’をリターンする。こ
     の関数は、‘exec-path’内のすべてのディレクトリーを検
     索し、‘exec-suffixes’内のすべてのファイル名拡張子の
     検索も試みる(*note Subprocess Creation::を参照)。


File: elisp,  Node: Changing Files,  Next: File Names,  Prev: Information about Files,  Up: Files

24.7 Changing File Names and Attributes
=======================================

このセクションの関数は、ファイルのリネーム(rename: 改名
)、コピー、削除(delete)、リンク、およびモード(パーミッシ
ョン)のセットを行います。

   NEWNAMEという引数をもつ関数では、NEWNAMEという名前の
ファイルが既に存在する場合の振る舞いは、引数
OK-IF-ALREADY-EXISTSの値に依存します。

   • OK-IF-ALREADY-EXISTSが‘nil’の場合は、
     ‘file-already-exists’エラーがシグナルされる。

   • OK-IF-ALREADY-EXISTSが数字の場合は、確認を求める。

   • OK-IF-ALREADY-EXISTSが他の値の場合は、確認なしで古
     いファイルを置き換える。

   以下の4つのコマンドはすべて、1つ目の引数にたいして親
ディレクトリーの全階層のシンボリックリンクを再帰的にフォ
ローしますが、その引数自体がシンボリックリンクの場合は、
‘copy-file’だけが(再帰的な)ターゲットを置き換えます。

 -- Command: add-name-to-file oldname newname &optional
          ok-if-already-exists
     この関数は、OLDNAMEという名前のファイルに、
     NEWNAMEという名前を追加で与える。これはNEWNAMEとい
     う名前が、OLDNAMEにたいする新たな“ハードリンク”にな
     ることを意味する。

     以下の例の最初の部分として、2つのファイル‘foo’と
     ‘foo3’をリストする。

          $ ls -li fo*
          81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     ここで、‘add-name-to-file’を呼び出してハードリンク
     を作成し、再度ファイルをリストする。このリストには
     、1つのファイルにたいして2つの名前‘foo’と‘foo2’が表
     示される。

          (add-name-to-file "foo" "foo2")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     最後に以下を評価する:

          (add-name-to-file "foo" "foo3" t)

     そして、ファイルを再度リストする。今度は1つのファイ
     ルにたいして3つの名前‘foo’、‘foo2’、‘foo3’がある。
     ‘foo3’の古いコンテンツは失われた。

          (add-name-to-file "foo1" "foo3")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3

     この関数は、1つのファイルにたいして複数の名前をもつ
     ことが許されないオペレーティングシステムでは無意味
     である。いくつかのシステムでは、かわりにファイルを
     コピーすることにより複数の名前を実装している。

     *note File Attributes::の‘file-nlinks’も参照のこと
     。

 -- Command: rename-file filename newname &optional
          ok-if-already-exists
     このコマンドは、FILENAMEをNEWNAMEにリネームする。

     FILENAMEがFILENAMEとは別に追加の名前をもつ場合、そ
     れらは自身の名前をもち続ける。実際のところ、
     ‘add-name-to-file’で名前NEWNAMEを追加してから
     FILENAMEを削除するのは、瞬間的な遷移状態を別とする
     と、リネームと同じ効果がある。

 -- Command: copy-file oldname newname &optional
          ok-if-exists time preserve-uid-gid
          preserve-extended-attributes
     このコマンドは、ファイルOLDNAMEをNEWNAMEにコピーす
     る。OLDNAMEが存在しない場合は、エラーをシグナルする
     。NEWNAMEがディレクトリーの場合は、その最後の名前コ
     ンポーネントを保持するように、そのディレクトリーの
     中にOLDNAMEをコピーする。

     TIMEが非‘nil’の場合、この関数は新たなファイルにたい
     して、古いファイルと同じ最終変更時刻を与える(これは
     いくつかの限られたオペレーティングシステムでのみ機
     能する)。時刻のセットでエラーが発生した場合、
     ‘copy-file’は‘file-date-error’エラーをシグナルする
     。インタラクティブに呼び出された場合、プレフィック
     ス引数はTIMEにたいして非‘nil’値を指定する。

     引数PRESERVE-UID-GIDが‘nil’の場合は、新たなファイル
     のユーザーおよびグループの所有権の決定を、オペレー
     ティングシステムに委ねる(通常はEmacsを実行中のユー
     ザーである)。PRESERVE-UID-GIDが非‘nil’の場合は、そ
     のファイルのユーザーとグループの所有権のコピーを試
     みる。これはいくつかのオペレーティングシステムで、
     かつそれを行うための正しいパーミッションをもつ場合
     のみ機能する。

     オプション引数PRESERVE-PERMISSIONSが非‘nil’の場合、
     この関数はOLDNAMEのファイルモード(または“パーミッシ
     ョン”)、同様にACL(Access Control List)とSELinuxコン
     テキストをNEWNAMEにコピーする。*note Information
     about Files::を参照のこと。

     それ以外では、NEWNAMEが既存ファイルならファイルモー
     ドは変更されず、新たに作成された場合はデフォルトの
     ファイルパーミッション(以下の
     ‘set-default-file-modes’を参照)によりマスクされる。
     どちらの場合も、ACLまたはSELinuxコンテキストはコピ
     ーされない。

 -- Command: make-symbolic-link filename newname
          &optional ok-if-exists
     このコマンドは、FILENAMEにたいしてNEWNAMEという名前
     のシンボリックリンクを作成する。これは、コマンド‘ln
     -s FILENAME NEWNAME’と似ている。

     この関数は、シンボリックリンクをサポートしないシス
     テムでは利用できない。

 -- Command: delete-file filename &optional trash
     このコマンドは、ファイルFILENAMEを削除する。ファイ
     ルが複数の名前をもつ場合は、他の名前で存在し続ける
     。FILENAMEがシンボリックリンクの場合、
     ‘delete-file’はシンボリックリンクだけを削除して、
     (たとえこれが親ディレクトリーの全階層のシンボリック
     リンクをフォローするとしても)ターゲットは削除しない
     。

     ファイルが存在しない、または削除できない場合は、適
     切な種類の‘file-error’エラーがシグナルされる(Unixお
     よびGNU/Linuxでは、ファイルのディレクトリーが書き込
     み可能ならファイルは削除可能である)。

     オプション引数TRASHが非‘nil’、かつ変数
     ‘delete-by-moving-to-trash’が非‘nil’の場合、このコ
     マンドはファイルを削除するかわりに、システムの
     Trash(ゴミ箱)にファイルを移動する。*note
     Miscellaneous File Operations: (emacs)Misc File
     Ops.を参照のこと。インタラクティブに呼び出された際
     は、プレフィックス引数がない場合TRASHは‘t’、それ以
     外は‘nil’である。

     *note Create/Delete Dirs::の‘delete-directory’も参
     照のこと。

 -- Command: set-file-modes filename mode
     この関数は、FILENAMEの“ファイルモード”(または“パー
     ミッション”)をMODEにセットする。この関数は、
     FILENAMEにたいして全階層でシンボリックリンクをフォ
     ローする。

     非インタラクティブに呼び出された場合、MODEは整数で
     なければならない。その整数の下位12ビットだけが使用
     される。ほとんどのシステムでは、意味があるのは下位
     9ビットだけである。MODEを入力刷る、Lisp構文を使用で
     きる。たとえば、

          (set-file-modes #o644)

     これは、そのファイルが所有者により読み取りと書き込
     み、グループメンバーにより読み取り、その他のユーザ
     ーにより読み取り可能であることを指定する。モードビ
     ットの仕様の説明は、*note (coreutils)File
     permissions::を参照のこと。

     インタラクティブに呼び出された場合、MODEは
     ‘read-file-modes’(以下参照)を使用してミニバッファー
     から読み取られる。この場合、ユーザーは整数、または
     パーミッションをシンボルで表現する文字列をタイプで
     きる。

     ファイルのパーミッションをリターンする関数
     ‘file-modes’については、*note File Attributes::を参
     照のこと。

 -- Function: set-default-file-modes mode
     この関数は、EmacsおよびEmacsのサブプロセスが新たに
     作成するファイルに、デフォルトのパーミッションをセ
     ットする。Emacsにより作成されたすべてのファイルはこ
     れらのパーミッション、およびそれらのサブセットとな
     るパーミッションをもつ(デフォルトファイルパーミッシ
     ョンが実行を許可しても、‘write-region’は実行パーミ
     ッションを付与しないだろう)。UnixおよびGNU/Linuxで
     は、デフォルトのパーミッションは“umask”の値のビット
     単位の補数で与えられる。

     引数MODEは上記の‘set-file-modes’と同様、パーミッシ
     ョンを指定する整数であること。下位9ビットだけに意味
     がある。

     デフォルトのファイルパーミッションは、既存ファイル
     の変更されたバージョンを保存する際は効果がない。フ
     ァイルの保存では、既存のパーミッションが保持される
     。

 -- Function: default-file-modes
     この関数は、デフォルトのファイルモードを整数でリタ
     ーンする。

 -- Function: read-file-modes &optional prompt base-file
     この関数は、ミニバッファーからファイルモードビット
     のセットを読み取る。1つ目のオプション引数PROMPTは非
     デフォルトのプロンプトを指定する。2つ目のオプション
     引数BASE-FILEは、ユーザーが既存ファイルのパーミッシ
     ョンに相対的なモードビット指定をタイプした場合に、
     この関数がリターンするモードビッの元となる権限をも
     つファイルの名前を指定する。

     ユーザー入力が8進数で表される場合、この関数はその数
     字をリターンする。それが‘"u=rwx"’のようなモードビッ
     トの完全なシンボル指定の場合、この関数は
     ‘file-modes-symbolic-to-number’を使用して、それを等
     価な数字に変換し、結果をリターンする。‘"o+g"’のよう
     に相対的な指定の場合、その指定の元となるパーミッシ
     ョンは、BASE-FILEのモードビットから取得される。
     BASE-FILEが省略、または‘nil’の場合、この関数は元と
     なるモードビットとして‘0’を使用する。完全指定および
     相対指定は、‘"u+r,g+rx,o+r,g-w"’のように組み合わせ
     ることができる。ファイルモード指定の説明は、*note
     (coreutils)File permissions::を参照のこと。

 -- Function: file-modes-symbolic-to-number modes
          &optional base-modes
     この関数は、MODES内のシンボルによるファイルモード指
     定を、等価な整数に変換する。シンボル指定が既存ファ
     イルにもとづく場合は、オプション引数BASE-MODESから
     そのファイルのモードビットが取得される。その引数が
     省略、または‘nil’の場合は、0(すべてのアクセスが許可
     されない)がデフォルトになる。

 -- Function: set-file-times filename &optional time
     この関数は、FILENAMEのアクセス時刻と変更時刻を
     TIMEにセットする。時刻が正しくセットされれば‘t’、そ
     れ以外は‘nil’がリターン値となる。TIMEのデフォルトは
     カレント時刻であり、‘current-time’がリターンするフ
     ォーマットでなければならない(*note Time of Day::を
     参照)。

 -- Function: set-file-extended-attributes filename
          attribute-alist
     この関数は、‘filename’にたいしてEmacsが認識する拡張
     ファイル属性をセットする。2つ目の引数
     ATTRIBUTE-ALISTは、‘file-extended-attributes’がリタ
     ーンするalistと同じ形式であること。*note Extended
     Attributes::を参照のこと。

 -- Function: set-file-selinux-context filename context
     この関数は、FILENAMEにたいするSELinuxセキュリティコ
     ンテキストにCONTEXTをセットする。CONTEXT引数は、各
     要素が文字列であるような‘(USER ROLE TYPE RANGE)’と
     いうリストであること。*note Extended Attributes::を
     参照されたい。

     この関数は、FILENAMEのSELinuxコンテキストのセットに
     成功した場合は‘t’をリターンする。コンテキストがセッ
     トされなかった場合(SELinuxが無効、またはEmacsが
     SELinuxサポートなしでコンパイルされた場合等)は、
     ‘nil’をリターンする。

 -- Function: set-file-acl filename acl
     この関数は、FILENAMEにたいするACLにACLをセットする
     。ACL引数は、関数‘file-acl’がリターンするのと同じ形
     式であること。*note Extended Attributes::を参照され
     たい。

     この関数はFILENAMEのACLのセットに成功したら‘t’、そ
     れ以外は‘nil’をリターンする。


File: elisp,  Node: File Names,  Next: Contents of Directories,  Prev: Changing Files,  Up: Files

24.8 File Names
===============

ファイルは一般的に名前で参照され、Emacsでも他と同様です
。Emacsでは、ファイル名は文字列で表現されます。ファイル
を操作する関数はすべて、ファイル名引数に文字列を期待しま
す。

   ファイル自体の操作に加えて、Emacs Lispプログラムでフ
ァイル名を処理する必要(ファイル名の一部を取得して、関連
するファイル名構築にその一部を使用する等)がしばしばあり
ます。このセクションでは、ファイル名を扱う方法を説明しま
す。

   このセクションの関数は実際にファイルにアクセスする訳
ではないので、既存のファイルやディレクトリーを参照しない
ファイル名を処理できます。

   MS-DOSおよびMS-Windowsでは、これらの関数は(実際にファ
イルを操作する関数と同様)、MS-DOSおよびMS-Windowsのファ
イル名構文を受け入れます。この構文はUnix構文のようにバッ
クスラッシュでコンポーネントを区切りますが、これらの関数
は常にUnix構文をリターンします。これにより、Unix構文でフ
ァイル名を指定するLispプログラムが、変更なしですべてのシ
ステムで正しく機能することが可能になるのです。(1)

* Menu:

* File Name Components::     ファイル名のディレクトリー部分と、それ以外。
* Relative File Names::      カレントディレクトリーにたいして相対的なファイル名。
* Directory Names::          ディレクトリーとしてのディレクトリー名と、ファイルとしてのファイル名の違い。
* File Name Expansion::      相対ファイル名から絶対ファイル名への変換。
* Unique File Names::        一時ファイル用の名前の生成。
* File Name Completion::     与えられたファイル名にたいする補完を探す。
* Standard File Names::      パッケージが固定されたファイル名を使用する際に、種々のオペレーティングシステムをシンプルに処理する方法。

   ---------- Footnotes ----------

   (1) MS-WindowsバージョンのEmacsはCygwin環境用にコンパ
イルされており、2つのファイル名構文の変換に、
‘cygwin-convert-file-name-to-windows’と
‘cygwin-convert-file-name-from-windows’を使用できます。


File: elisp,  Node: File Name Components,  Next: Relative File Names,  Up: File Names

24.8.1 File Name Components
---------------------------

オペレーティングシステムは、ファイルをディレクトリーにグ
ループ化します。あるファイルを指定するためには、ディレク
トリーと、そのディレクトリー内でのファイルの名前を指定し
なければなりません。それゆえ、Emacsはファイル名を“ディレ
クトリー名”パートと“非ディレクトリー”(または“ディレクト
リー内ファイル名”)パートという、2つの主要パートから判断
します。どちらのパートも空の場合があり得ます。これら2つ
のパートを結合することにより、元のファイル名が再作成され
ます。

   ほとんどのシステムでは、最後のスラッシュ(MS-DOSおよび
MS-Windowsではバックスラッシュも許される)までのすべてが
ディレクトリーパートです。残りが非ディレクトリーパートで
す。

   ある目的のために、非ディレクトリーパートはさらに正式
名称(the name proper)と“バージョン番号”に細分されます。
ほとんどのシステムでは、名前にバージョン番号をもつのは、
バックアップファイルだけです。

 -- Function: file-name-directory filename
     この関数は、FILENAMEのディレクトリーパートをディレ
     クトリー名(*note Directory Names::を参照)としてリタ
     ーンする。FILENAMEがディレクトリーパートを含まない
     場合は、‘nil’をリターンする。

     GNUおよびUnixシステムでは、この関数がリターンする文
     字列は常にスラッシュで終わる。MS-DOSでは、コロンで
     終わることもあり得る。

          (file-name-directory "lewis/foo")  ; Unixの例
               ⇒ "lewis/"
          (file-name-directory "foo")        ; Unixの例
               ⇒ nil

 -- Function: file-name-nondirectory filename
     この関数は、FILENAMEの非ディレクトリーパートをリタ
     ーンする。

          (file-name-nondirectory "lewis/foo")
               ⇒ "foo"
          (file-name-nondirectory "foo")
               ⇒ "foo"
          (file-name-nondirectory "lewis/")
               ⇒ ""

 -- Function: file-name-sans-versions filename &optional
          keep-backup-version
     この関数は、任意のファイルバージョン番号、バックア
     ップバージョン番号、末尾のチルダを取り除いて
     FILENAMEをリターンする。

     KEEP-BACKUP-VERSIONが非‘nil’の場合は、ファイルシス
     テムなどが理解するような真のファイルバージョン番号
     は破棄されるが、バックアップバージョン番号は保持さ
     れる。

          (file-name-sans-versions "~rms/foo.~1~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               ⇒ "~rms/foo"

 -- Function: file-name-extension filename &optional
          period
     この関数は、FILENAMEからもしあればすべてのバージョ
     ン番号とバックアップ番号を取り除いた後、終端の“拡張
     子(extension)”をリターンする。ファイル名の拡張子と
     は、最後の名前コンポーネント(からすべてのバージョン
     番号とバックアップ番号を取り去った後)の最後の‘.’に
     後続するパートである。

     この関数は、‘foo’のような拡張子のないファイル名にた
     いしては、‘nil’をリターンする。‘foo.’のようなnull拡
     張子にたいしては、‘""’をリターンする。ファイル名の
     最終コンポーネントが‘.’で始まる場合、その‘.’は拡張
     子の開始とはみなされない。したがって、‘.emacs’の拡
     張子は‘.emacs’ではなく‘nil’である。

     PERIODが非‘nil’の場合、拡張子を区切るピリオドもリタ
     ーン値に含まれるようにななる。その場合、もし
     FILENAMEが拡張子をもたないなら、リターン値は‘""’で
     ある。

 -- Function: file-name-sans-extension filename
     この関数は、もしあればFILENAMEから拡張子を除いてリ
     ターンする。もしバージョン番号またはバックアップ番
     号があるなら、ファイルが拡張子をもつ場合のみ、それ
     を削除する。たとえば、

          (file-name-sans-extension "foo.lose.c")
               ⇒ "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               ⇒ "big.hack/foo"
          (file-name-sans-extension "/my/home/.emacs")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "/my/home/.emacs.el")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "~/foo.el.~3~")
               ⇒ "~/foo"
          (file-name-sans-extension "~/foo.~3~")
               ⇒ "~/foo.~3~"

     最後の2つの例の‘.~3~’は、拡張子ではなくバックアップ
     番号であることに注意。

 -- Function: file-name-base &optional filename
     この関数は、‘file-name-sans-extension’と
     ‘file-name-nondirectory’を組み合わせたものである。
     たとえば、

          (file-name-base "/my/home/foo.c")
              ⇒ "foo"

     FILENAME引数のデフォルトは、‘buffer-file-name’であ
     る。


File: elisp,  Node: Relative File Names,  Next: Directory Names,  Prev: File Name Components,  Up: File Names

24.8.2 Absolute and Relative File Names
---------------------------------------

ファイルシステム内のすべてのディレクトリーは、ルートディ
レクトリーから開始されるツリーを形成します。このツリーの
ルートから開始されるすべてのディレクトリー名により、ファ
イル名を指定でき、それを“絶対(absolute)”ファイル名と呼び
ます。デフォルトディレクトリーからの相対的なツリー中の位
置でファイルを指定するこでき、それは“相対(relative)”ファ
イル名と呼ばれます。UnixおよびGNU/Linuxでは、絶対ファイ
ル名は‘/’または‘~’で始まり、相対ファイル名は違います
(*note abbreviate-file-name::を参照)。MS-DOSおよび
MS-Windowsでは、絶対ファイル名はスラッシュ、バックスラッ
シュ、またはドライブ指定‘X:/’で始まります。ここでXは“ド
ライブ文字(drive letter)”です。

 -- Function: file-name-absolute-p filename
     この関数は、FILENAMEが絶対ファイル名の場合は‘t’、そ
     れ以外は‘nil’をリターンする。

          (file-name-absolute-p "~rms/foo")
               ⇒ t
          (file-name-absolute-p "rms/foo")
               ⇒ nil
          (file-name-absolute-p "/user/rms/foo")
               ⇒ t

   相対ファイル名が与えられた場合は、
‘expand-file-name’を使用して、それを絶対ファイル名に変換
できます(*note File Name Expansion::を参照)。この関数は
、絶対ファイル名を相対ファイル名に変換します:

 -- Function: file-relative-name filename &optional
          directory
     この関数は、DIRECTORY(絶対ディレクトリー名またはデ
     ィレクトリーファイル名)から相対的な結果となると仮定
     して、FILENAMEと等価な相対ファイル名のリターンを試
     みる。DIRECTORYが省略、または‘nil’の場合、カレント
     バッファーのデフォルトディレクトリーがデフォルトと
     なる。

     絶対ファイル名がデバイス名で始まるオペレーティング
     システムが、いくつか存在する。そのようなシステムで
     は、2つの異なるデバイス名から開始されるFILENAMEは、
     DIRECTORYにもとづく等価な相対ファイル名をもたない。
     この場合、‘file-relative-name’は絶対形式で
     FILENAMEをリターンする。

          (file-relative-name "/foo/bar" "/foo/")
               ⇒ "bar"
          (file-relative-name "/foo/bar" "/hack/")
               ⇒ "../foo/bar"


File: elisp,  Node: Directory Names,  Next: File Name Expansion,  Prev: Relative File Names,  Up: File Names

24.8.3 Directory Names
----------------------

“ディレクトリー名(directory name)”とは、ディレクトリーの
名前のことです。ディレクトリーは実際にはファイルの一種な
ので、ファイル名をもちます。これはディレクトリー名と関連
がありますが、同一ではありません(これは、Unixの通常の用
語とは異なる)。同じ実体にたいするこれら2つの異なる名前は
、構文的な変換により関連付けられます。GNUおよびUnixシス
テムでは、ことは単純です。ディレクトリー名はスラッシュで
終わり、ファイルとしてのディレクトリーの名前には、そのス
ラッシュがありません。MS-DOSでは、この関連付けはより複雑
です。

   ディレクトリー名と、ファイルとしてのディレクトリーの
名前の違いは、些細ですが重要です。Emacsの変数、または関
数の引数を記述する際、それがディレクトリー名であるとして
おり、ディレクトリーのファイル名は許されません。
‘file-name-directory’が文字列をリターンするときは、常に
ディレクトリー名です。

   以下の2つの関数は、ディレクトリー名とファイル名の間で
変換を行います。これらの関数は、‘$HOME’のような環境変数
や、‘~’、‘.’、‘..’などの構文にたいして、特別なことは何も
行いません。

 -- Function: file-name-as-directory filename
     この関数は、オペレーティングシステムがディレクトリ
     ーの名前と解釈する形式で、FILENAMEを表す文字列をリ
     ターンする。ほとんどのシステムでは、(もし終端にそれ
     がなければ)これは文字列にスラッシュを追加することを
     意味する。

          (file-name-as-directory "~rms/lewis")
               ⇒ "~rms/lewis/"

 -- Function: directory-file-name dirname
     この関数は、オペレーティングシステムがファイルの名
     前と解釈する形式で、DIRNAMEを表す文字列をリターンす
     る。ほとんどのシステムでは、これは文字列から最後の
     スラッシュ(またはバックスラッシュ)を削除することを
     意味する。

          (directory-file-name "~lewis/")
               ⇒ "~lewis"

   ディレクトリーにたいしては、‘concat’を使用して相対フ
ァイルと組み合わせることができます:

     (concat DIRNAME RELFILE)

これを行う前に、ファイル名が相対的であるか確認してくださ
い。絶対ファイル名を使用した場合、結果は構文的に不正にな
るか、間違ったファイルを参照する可能性があります。

   ディレクトリーファイル名作成にこのような組み合わせを
使用したい場合は、最初に‘file-name-as-directory’を使用し
て、それをディレクトリー名に変換しなければなりません:

     (concat (file-name-as-directory DIRFILE) RELFILE)

以下のような、手動によるスラッシュの結合を試みてはなりま
せん

     ;;; 間違い!
     (concat DIRFILE "/" RELFILE)

なぜなら、これには可搬性がないからです。常に
‘file-name-as-directory’を使用してください。

   ディレクトリー名をディレクトリーの省略名に変換するに
は、以下の関数を使用します:

 -- Function: abbreviate-file-name filename
     この関数は、FILENAMEの省略された形式をリターンする
     。これは‘directory-abbrev-alist’(*note File
     Aliases: (emacs)File Aliases.)で指定される省略形を
     適用した後、引数のファイル名がユーザーのホームディ
     レクトリー、またはそのサブディレクトリーにある場合
     は、それを‘~’に置き換える。ホームディレクトリーがル
     ートディレクトリーの場合、多くのシステムでは結果が
     短縮されないので、‘~’で置き換えない。

     これは名前の一部であるような省略形さえも認識するの
     で、ディレクトリー名とファイル名にも使用できる。


File: elisp,  Node: File Name Expansion,  Next: Unique File Names,  Prev: Directory Names,  Up: File Names

24.8.4 Functions that Expand Filenames
--------------------------------------

ファイル名の“展開(expanding)”とは、相対ファイル名を絶対
ファイル名に変換することを意味します。これはデフォルトデ
ィレクトリーから相対的に行われるため、展開されるファイル
名と同様、デフォルトディレクトリーも指定しなければなりま
せん。これは‘~/’のような省略形 (*note
abbreviate-file-name::を参照)、 の展開、および‘./’や
‘NAME/../’のような冗長さの排除も行います。 も展開します
。

 -- Function: expand-file-name filename &optional
          directory
     この関数は、FILENAMEを絶対ファイル名に変換する。
     DIRECTORYが与えられた場合、FILENAMEが相対的なら、そ
     れは開始点となるデフォルトディレクトリーになる
     (DIRECTORYの値は、それ自体が絶対ディレクトリー名、
     またはディレクトリーファイル名であるべきで、それは
     ‘~’で始まるかもしれない)。それ以外では、カレントバ
     ッファーの‘default-directory’の値が使用される。たと
     えば:

          (expand-file-name "foo")
               ⇒ "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               ⇒ "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               ⇒ "/usr/spool/foo"

     結合されたファイル名の最初のスラッシュの前が‘~’の場
     合は、環境変数‘HOME’(通常はユーザーのホームディレク
     トリー)の値に展開される。最初のスラッシュの前が
     ‘~USER’で、かつUSERが有効なログイン名の場合は、
     USERのホームディレクトリーに展開される。

     ‘.’または‘..’を含むファイル名は、正規化形式に簡略化
     される:

          (expand-file-name "bar/../foo")
               ⇒ "/xcssun/users/rms/lewis/foo"

     出力に‘..’コンポーネントが残り得る場合もある:

          (expand-file-name "../home" "/")
               ⇒ "/../home"

     これは、ルートディレクトリー‘/’の上位の“スーパール
     ート(superroot)”という概念をもつファイルシステムの
     ためのものである。その他のファイルシステムでは、
     ‘/../’は‘/’とまったく同じに解釈される。

     ‘expand-file-name’は環境変数を展開_しない_ことに注
     意。‘substitute-in-file-name’だけが、それを行う。

          (expand-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/lewis/$HOME/foo"

     ‘expand-file-name’は、あらゆる階層においてシンボリ
     ックリンクをフォローしないことにも注意。これは
     ‘..’の扱いが‘file-truename’と‘expand-file-name’で異
     なることに起因する。‘/tmp/bar’がディレクトリー
     ‘/tmp/foo/bar’にたいするシンボリックリンクであると
     仮定すると:

          (file-truename "/tmp/bar/../myfile")
               ⇒ "/tmp/foo/myfile"
          (expand-file-name "/tmp/bar/../myfile")
               ⇒ "/tmp/myfile"

     直接間接を問わず、事前に‘expand-file-name’を呼び出
     さずに‘..’に先行するシンボリックリンクをフォローす
     る必要があるかもしれない場合は、それを呼び出さずに
     確実に‘file-truename’を呼び出すべきである。*note
     Truenames::を参照のこと。

 -- Variable: default-directory
     このバッファーローカル変数の値は、カレントバッファ
     ーにたいするデフォルトディレクトリーである。これは
     絶対ディレクトリー名であること。これは‘~’で始まるか
     もしれない。この変数は、すべてのバッファーにおいて
     バッファーローカルである。

     2つ目の引数が‘nil’の場合、‘expand-file-name’はデフ
     ォルトディレクトリーを使用する。

     値は常にスラッシュで終わる文字列である。

          default-directory
               ⇒ "/user/lewis/manual/"

 -- Function: substitute-in-file-name filename
     この関数は、FILENAME内で参照される環境変数を、環境
     変数の値に置き換える。標準的なUnixシェル構文にした
     がい、 ‘$’は環境変数値置き換えのプレフィックスであ
     る。入力に‘$$’が含まれる場合、それ‘$’に置き換えられ
     る。これにより、ユーザーが‘$’を“クォート”する手段が
     与えられる。

     環境変数名は‘$’の後に続く一連の英数字(アンダースコ
     アを含む)である。‘$’の後続文字が、‘{’の場合はマッチ
     する‘}’までのすべてが変数名である。

     ‘substitute-in-file-name’により生成された出力で
     ‘substitute-in-file-name’を呼び出すと、不正な結果と
     なる傾向がある。たとえば、単一の‘$’をクォートするた
     めの‘$$’の使用は正しく機能しないだろうし、環境変数
     値の中の‘$’は再帰的な置換を導くだろう。したがって、
     この関数を呼び出して、出力をこの関数に渡すプログラ
     ムは、その後の不正な結果を防ぐために、すべての‘$’文
     字を二重化する必要がある。

     以下では、ユーザーのホームディレクトリー名を保持す
     る環境変数‘HOME’は、値‘/xcssun/users/rms’をもつとす
     る。

          (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"

     置き換え後は、‘/’の直後に‘~’や別の‘/’が出現した場合
     、この関数は、‘/’の前にあるすべてを無視する。

          (substitute-in-file-name "bar/~/foo")
               ⇒ "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
               ;; ‘/usr/local/’は破棄された


File: elisp,  Node: Unique File Names,  Next: File Name Completion,  Prev: File Name Expansion,  Up: File Names

24.8.5 Generating Unique File Names
-----------------------------------

一時ファイルに書き込む必要があるプログラムが、いくつかあ
ります。以下は、そのようなファイルを構築する、便利な方法
です:

     (make-temp-file NAME-OF-APPLICATION)

‘make-temp-file’の役目は、2人の異なるユーザー、またはジ
ョブが、完全に一致する名前のファイルの使用を防ぐことです
。

 -- Function: make-temp-file prefix &optional dir-flag
          suffix
     この関数は、一時ファイルを作成して、その名前をリタ
     ーンする。Emacsは、Emacsの各ジョブごとに異なるラン
     ダムないくつかの文字をPREFIXに追加することにより、
     一時ファイルの名前を作成する。結果として新たに空の
     ファイルが作成されることが保障される。MS-DOSでは、
     8+3のファイル名制限に適合するよう、文字列STRINGは切
     り詰められる可能性がある。PREFIXが相対ファイル名の
     場合、それは‘temporary-file-directory’にたいして展
     開される。

          (make-temp-file "foo")
               ⇒ "/tmp/foo232J6v"

     ‘make-temp-file’がリターンした際、一時ファイルは空
     で作成される。この時点で、そのファイルに意図するコ
     ンテンツを書き込むべきである。

     DIR-FLAGが‘nil’の場合、‘make-temp-file’は空のファイ
     ルのかわりに、空のディレクトリーを作成する。これは
     ディレクトリー名ではなく、ディレクトリーのファイル
     名をリターンする。*note Directory Names::を参照のこ
     と。

     SUFFIXが非‘nil’の場合、‘make-temp-file’はそれをファ
     イル名の最後に追加する。

     同じEmacs内で実行される異なるライブラリー間での競合
     を防ぐために、‘make-temp-file’を使用する各Lispプロ
     グラムがプログラム自身のPREFIXを使用するべきである
     。PREFIXの最後に追加される数字は、異なるEmacsジョブ
     内で実行される、同じアプリケーションを区別する。追
     加される文字により、同一のEmacsジョブ内でも、多数の
     名前を区別することが可能になる。

   一時ファイル用のデフォルトディレクトリーは、変数
‘temporary-file-directory’により制御されます。この変数に
より、すべての一時ファイルにたいして、ユーザーがディレク
トリーを指定する、一貫した方法が与えられます。
‘small-temporary-file-directory’が非‘nil’の場合は、かわ
りにそれを使うプログラムもいくつかあります。これを使う場
合は、‘make-temp-file’を呼び出す前に、正しいディレクトリ
ーにたいしてプレフィックスを展開するべきです。

 -- User Option: temporary-file-directory
     この変数は、一時ファイル作成用のディレクトリー名を
     指定する。値はディレクトリー名であるべきだが、もし
     値がディレクトリーのファイル名(*note Directory
     Names::を参照)ならば、Lispプログラムがかわりに対処
     すればよい。‘expand-file-name’の2つ目の引数としてそ
     の値を使用するのは、それを達成するよい方法である。

     デフォルト値は、オペレーティングシステムにたいして
     適切な方法により決定される。これは環境変数
     ‘TMPDIR’、‘TMP’、‘TEMP’にもとづき、これらの変数が定
     義されていなければ、システム依存の名前にフォールバ
     ックする。

     一時ファイルの作成に‘make-temp-file’を使用しない場
     合でも、一時ファイルを置くディレクトリーを判断する
     ために、依然としてこの変数を使用するべきである。し
     かし、一時ファイルが小さくなることを求める場合は、
     ‘small-temporary-file-directory’が非‘nil’ならば、そ
     れを使用するべきである。

 -- User Option: small-temporary-file-directory
     この変数は、小さいかもしれない特定の一時ファイル作
     成用のディレクトリー名を指定する。

     小さくなるかもしれない一時ファイルに書き込みたい場
     合は、以下のようにディレクトリーを計算するべきであ
     る:

          (make-temp-file
            (expand-file-name PREFIX
                              (or small-temporary-file-directory
                                  temporary-file-directory)))

 -- Function: make-temp-name base-name
     この関数は、一意なファイル名として使用できる文字列
     を生成する。この名前はBASE-NAMEで始まり、それに各
     Emacsジョブごとに異なる、複数のランダムな文字を追加
     したものである。これは‘make-temp-file’と似ているが
     、(i)名前だけを作成し、ファイルは作成しない、
     (ii)BASE-NAMEは絶対ファイル名であること、という点が
     異なる(MS-DOSシステムでは、8+3ファイル名制限に適合
     するよう、BASE-NAMEが切り詰められる)。

     *警告:* この関数を使用するべきではない。かわりに
     ‘make-temp-file’を使用すること! この関数は、競合状
     態の影響を受けやすい。‘make-temp-name’呼び出しと一
     時ファイル作成のタイムラグは、セキュリティーホール
     となる場合があるかもしれない。


File: elisp,  Node: File Name Completion,  Next: Standard File Names,  Prev: Unique File Names,  Up: File Names

24.8.6 File Name Completion
---------------------------

このセクションでは、ファイル名を補完するための、低レベル
サブルーチンについて説明します。より高レベルの関数につい
ては、*note Reading File Names::を参照してください。

 -- Function: file-name-all-completions partial-filename
          directory
     この関数は、ディレクトリーDIRECTORY内で、
     PARTIAL-FILENAMEで始まる名前のファイルにたいして、
     すべての補完可能なリストをリターンする。補完の順番
     はそのディレクトリー内でのファイル順序であり、これ
     は予測不能で何の情報ももたない。

     引数PARTIAL-FILENAMEは非ディレクトリーパートを含む
     ファイル名でなければならず、スラッシュ(いくつかのシ
     ステムではバックスラッシュ)が含まれていてはならない
     。DIRECTORYが絶対ディレクトリーでない場合は、
     DIRECTORYの前にカレントバッファーのデフォルトディレ
     クトリーが追加される。

     以下の例では、‘~rms/lewis’がカレントデフォルトディ
     レクトリーで、名前が‘f’で始まる5つのファイル‘foo’、
     ‘file~’、‘file.c’、‘file.c.~1~’、‘file.c.~2~’がある
     ものとする:

          (file-name-all-completions "f" "")
               ⇒ ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")
               ⇒ ("foo")

 -- Function: file-name-completion filename directory
          &optional predicate
     この関数は、ディレクトリーDIRECTORY内で、ファイル名
     FILENAMEを補完する。これはディレクトリーDIRECTORY内
     で、FILENAMEで始まるすべてのファイル名にたいして、
     最長の共通プレフィックスをリターンする。PREDICATEが
     非‘nil’の場合は、この関数を1引数で呼び出して絶対フ
     ァイル名に展開後、PREDICATEを満足しない補完候補を無
     視する。

     マッチが1つだけ存在し、かつFILENAMEが正確にそれにマ
     ッチする場合、関数は‘t’をリターンする。関数は、ディ
     レクトリーDIRECTORYがFILENAMEで始まる名前のファイル
     を含まない場合は、‘nil’をリターンする。

     以下の例では、‘~rms/lewis’がカレントデフォルトディ
     レクトリーで、名前が‘f’で始まる5つのファイル‘foo’、
     ‘file~’、‘file.c’、‘file.c.~1~’、‘file.c.~2~’がある
     ものとする:

          (file-name-completion "fi" "")
               ⇒ "file"

          (file-name-completion "file.c.~1" "")
               ⇒ "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               ⇒ t

          (file-name-completion "file.c.~3" "")
               ⇒ nil

 -- User Option: completion-ignored-extensions
     ‘file-name-completion’は通常、このリスト内の任意の
     文字列で終わるファイル名を無視する。すべての可能な
     補完がこれらのサフィックスのいずれか1つで終わるとき
     は、それらを無視しない。この変数は、
     ‘file-name-all-completions’に影響しない。

     典型的な値は、以下のようになる:

          completion-ignored-extensions
               ⇒ (".o" ".elc" "~" ".dvi")

     ‘completion-ignored-extensions’のある要素がスラッシ
     ュ‘/’で終わる場合、それはディレクトリーを示す。スラ
     ッシュで_終わらない_要素がディレクトリーにマッチす
     ることは決してない。したがって、上記の値は
     ‘foo.elc’という名前のディレクトリーを除外しないだろ
     う。


File: elisp,  Node: Standard File Names,  Prev: File Name Completion,  Up: File Names

24.8.7 Standard File Names
--------------------------

Emacs Lispプログラムが特定の用途のために標準的なファイル
名を指定する必要がある場合があります。典型的には、カレン
トユーザーにより指定された設定データを保持する場合がそう
です。そのようなファイルは通常、‘user-emacs-directory’に
より指定されるディレクトリーに置かれ、デフォルトでは
‘~/.emacs.d’です(*note Init File::を参照)。たとえば、
abbrev(abbreviation: 省略形)の定義は、デフォルトでは
‘~/.emacs.d/abbrev_defs’に格納されます。このようなファイ
ル名を指定するには、関数‘locate-user-emacs-file’を使用す
るのが、もっとも簡単な方法です。

 -- Function: locate-user-emacs-file base-name &optional
          old-name
     この関数は、Emacs特有の設定ファイル、またはデータフ
     ァイルにたいする絶対ファイル名をリターンする。引数
     ‘base-name’は、ソファイル名であること。リターン値は
     、‘user-emacs-directory’で指定されるディレクトリー
     内の絶対ファイル名である。このディレクトリーが存在
     しない場合、この関数はディレクトリーを作成する。

     オプション引数OLD-NAMEが非‘nil’の場合、それはユーザ
     ーのホームディレクトリー内のファイル‘~/OLD-NAME’を
     指定する。そのようなファイルが存在する場合、リター
     ン値はBASE-NAMEで指定されるファイルではなく、そのフ
     ァイルの絶対ファイル名となる。これは、Emacsパッケー
     ジが後方互換を提供するために使用されることを意図し
     た引数である。たとえば、‘user-emacs-directory’導入
     前、abbrevファイルは‘~/.abbrev_defs’に置かれていた
     。以下は、‘abbrev-file-name’の定義である:

          (defcustom abbrev-file-name
            (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
            "Default name of file from which to read abbrevs."
            ...
            :type 'file)

   ファイル名の標準化のための低レベル関数は
‘convert-standard-filename’で、これはサブルーチンとして
‘locate-user-emacs-file’により使用される。

 -- Function: convert-standard-filename filename
     この関数は、FILENAMEにもとづき、カレントオペレーテ
     ィングシステムの慣習に適合するファイル名をリターン
     する。

     GNUおよびUnixシステムでは、これは単にFILENAMEをリタ
     ーンする。その他のオペレーティングシステムでは、シ
     ステム固有のファイル名規約にしたがうだろう。たとえ
     ばMS-DOSでは、この関数はMS-DOSファイル名制限にした
     がうよう、先頭の‘.’を‘_’に変換したり、‘.’の後続の文
     字を3文字に切り詰める等、さまざまな変更を行う。

     この関数でGNUおよびUnixシステムの慣習に適合する名前
     を指定して、それを‘convert-standard-filename’に渡す
     のが推奨される使用方法である。


File: elisp,  Node: Contents of Directories,  Next: Create/Delete Dirs,  Prev: File Names,  Up: Files

24.9 Contents of Directories
============================

ディレクトリーとはファイルの一種で、さまざまな名前のファ
イルを含んでいます。ディレクトリーは、ファイルシステムの
機能です。

   Emacsはディレクトリー内のファイル名をLispのリストとし
て一覧したり、シェルコマンド‘ls’を使用してバッファー内に
ファイル名を表示することができます。後者の場合、Emacsは
オプションで各ファイルに関する情報も表示でき、それは
‘ls’コマンドに渡すオプションに依存します。

 -- Function: directory-files directory &optional
          full-name match-regexp nosort
     この関数は、ディレクトリーDIRECTORY内のファイルの名
     前のリストをリターンする。デフォルトでは、このリス
     トはアルファベット順である。

     FULL-NAMEが非‘nil’の場合、この関数はファイルの絶対
     ファイル名をリターンし、それ以外は指定されたディレ
     クトリーにたいする相対ファイル名をリターンする。

     MATCH-REGEXPが非‘nil’の場合、この関数はその正規表現
     にたいするマッチを含むファイル名だけをリターンし、
     それ以外のファイル名はリストから除外される。大文字
     小文字を区別するファイルシステムでは、大文字小文字
     を区別する正規表現マッチングが行われる。

     NOSORTが非‘nil’の場合、‘directory-files’はリストを
     ソートしないので、取得するファイル名に特定の順序は
     ない。最大限の可能なスピードを得る必要があり、ファ
     イル処理順を気にしない場合は、この関数を使用する。
     ユーザーから処理順が可視の場合は、名前をソートすれ
     ば、おそらくユーザーはより幸せになるだろう。

          (directory-files "~lewis")
               ⇒ ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")

     DIRECTORYが読み取り可能なディレクトリー名でない場合
     は、エラーがシグナルされる。

 -- Function: directory-files-and-attributes directory
          &optional full-name match-regexp nosort
          id-format
     これは、どのファイルを報告するか、およびファイル名
     を報告する方法において、‘directory-files’と似ている
     。しかし、この関数はファイル名のリストをリターンす
     るかわりに、各ファイルごとにリスト‘(FILENAME .
     ATTRIBUTES)’をリターンする。ここでATTRIBUTESは、そ
     のファイルにたいして‘file-attributes’がリターンする
     であろう値である。オプション引数ID-FORMATは、
     ‘file-attributes’の対応する引数と同じ意味をもつ
     (*note Definition of file-attributes::を参照)。

 -- Function: file-expand-wildcards pattern &optional
          full
     この関数は、ワイルドカードパッケージPATTERNを展開し
     て、それにマッチするファイル名のリストをリターンす
     る。

     絶対ファイル名としてPATTERNが記述された場合は、値も
     絶対ファイル名になる。

     PATTERNが相対ファイル名で記述されている場合、それは
     カレントデフォルトディレクトリーにたいして相対的に
     解釈される。リターンされるファイル名も、通常はカレ
     ントデフォルトディレクトリーにたいする相対ファイル
     名になる。しかしFULLが非‘nil’の場合は、絶対ファイル
     名がリターンされる。

 -- Function: insert-directory file switches &optional
          wildcard full-directory-p
     この関数は、‘ls’のSWITCHESに対応するフォーマットで
     、(カレントバッファー内に)ディレクトリーFILEのディ
     レクトリーリストを挿入する。これは、挿入したテキス
     トの後にポイントを残す。SWITCHESにはオプション文字
     列、または個別のオプションを表す文字列リストを指定
     できる。

     引数FILEにはディレクトリー名、またはワイルドカード
     文字を含むファイル名を指定できる。WILDCARDが非
     ‘nil’の場合、FILEはワイルドカードを伴うファイル指定
     として扱われることを意味する。

     FULL-DIRECTORY-Pが非‘nil’の場合、ディレクトリーリス
     トにたいしてディレクトリーの完全なコンテンツ表示を
     要求することを意味する。FILEがディレクトリーで、ス
     イッチに‘-d’が含まれないときは、‘t’を指定するべきで
     ある(‘ls’へのオプション‘-d’は、ディレクトリーのコン
     テンツではなく、ファイルとしてディレクトリーを表示
     するよう指定する)。

     ほとんどのシステムでは、この関数は変数
     ‘insert-directory-program’の名前のディレクトリーリ
     スト用プログラムを実行することにより機能する。
     WILDCARDが非‘nil’の場合は、ワイルドカード展開するた
     めに、‘shell-file-name’で指定されるシェルの実行も行
     う。

     MS-DOSおよびMS-Windowsシステムは、標準的なUnixプロ
     グラム‘ls’を欠くので、この関数はLispコードで‘ls’を
     エミュレートする。

     技術的な詳細としては、SWITCHESにロングオプション
     ‘--dired’が含まれる際に‘insert-directory’は、
     diredのためにこれを特別に扱う。しかし他のオプション
     と同様、通常は等価なショートオプション‘-D’が単に
     ‘insert-directory-program’に渡されるだけである。

 -- Variable: insert-directory-program
     この変数の値は、関数‘insert-directory’用にディレク
     トリーリストを生成するプログラムである。この値は、
     Lispコードでリストを生成するシステムでは無視される
     。


File: elisp,  Node: Create/Delete Dirs,  Next: Magic File Names,  Prev: Contents of Directories,  Up: Files

24.10 Creating, Copying and Deleting Directories
================================================

Emacs Lispのファイル操作関数のほとんどは、ディレクトリー
であるようなファイルに使用されたときはエラーとなります。
たとえば、‘delete-file’でディレクトリーの削除はできませ
ん。以下のスペシャルカは、ディレクトリーの作成と削除を行
うために存在します。

 -- Command: make-directory dirname &optional parents
     このコマンドは、DIRNAMEという名前のディレクトリーを
     作成する。PARENTSが非‘nil’の場合(インタラクティブな
     呼び出しでは、常に非‘nil’となる)、その親ディレクト
     リーがまだ存在しなければ、最初にそれを作成すること
     を意味する。

     ‘mkdir’は、これにたいするエイリアスである。

 -- Command: copy-directory dirname newname &optional
          keep-time parents copy-contents
     このコマンドは、DIRNAMEという名前のディレクトリーを
     、NEWNAMEにコピーする。NEWNAMEが既存のディレクトリ
     ーの場合、DIRNAMEはそれのサブディレクトリーにコピー
     されるだろう。

     これは、常にコピーされるファイルのファイルモードを
     、対応する元のファイルモードに一致させる。

     3つ目の引数KEEP-TIMEが非‘nil’の場合は、コピーされる
     ファイルの修正時刻を保持することを意味する。プレフ
     ィックス引数を与えると、KEEP-TIMEが非‘nil’になる。

     4つ目の引数PARENTSは、親ディレクトリーが存在しない
     場合に作成するかどうかを指定する。インタラクティブ
     な場合、これはデフォルトで発生する。

     5つ目の引数COPY-CONTENTSが非‘nil’の場合、それは
     NEWNAMEが既存のディレクトリーならば、そのサブディレ
     クトリーとしてDIRNAMEをコピーするかわりに、
     DIRNAMEのコンテンツをNEWNAMEにコピーする。

 -- Command: delete-directory dirname &optional
          recursive trash
     このコマンドは、DIRNAMEという名前のディレクトリーを
     削除する。関数‘delete-file’はディレクトリーであるよ
     うなファイルにたいしては機能しない。それらにたいし
     ては、‘delete-directory’を使用しなければならない。
     RECURSIVEが‘nil’で、ディレクトリー内にファイルが存
     在する場合、‘delete-directory’はエラーをシグナルす
     る。

     ‘delete-directory’は、親ディレクトリーの階層のシン
     ボリックリンクだけをフォローする。

     オプション引数TRASHが非‘nil’、かつ変数
     ‘delete-by-moving-to-trash’が非‘nil’の場合、このコ
     マンドはファイルを削除するかわりに、システムの
     Trash(ゴミ箱)にファイルを移動する。*note
     Miscellaneous File Operations: (emacs)Misc File
     Ops.を参照のこと。インタラクティブに呼び出された際
     は、プレフィックス引数がない場合TRASHは‘t’、それ以
     外は‘nil’である。


File: elisp,  Node: Magic File Names,  Next: Format Conversion,  Prev: Create/Delete Dirs,  Up: Files

24.11 Making Certain File Names “Magic”
=======================================

特定のファイル名にたいして、特別な処理を実装できます。こ
れは、それらの名前の“magic”化と呼ばれます。この機能は主
に、リモートファイルにたいするアクセスの実装に使用されま
す(*note Remote Files: (emacs)Remote Files.を参照)。

   magicファイル名を定義するには、名前クラスを定義するた
めの正規表現、およびそれにマッチするファイル名にたいする
Emacsファイル操作プリミティブすべてを実装するハンドラー
を定義しなければなりません。

   変数‘file-name-handler-alist’は各ハンドラーに適用する
ときを決定する正規表現とともに、ハンドラーのリストを保持
します。各要素は、以下の形式をもちます:

     (REGEXP . HANDLER)

ファイルアクセス、およびファイル名変換にたいするすべての
Emacsプリミティブは、‘file-name-handler-alist’にたいして
与えられたファイル名をチェックします。そのファイル名が
REGEXPにマッチした場合、そのプリミティブがHANDLERを呼び
出してファイルを処理します。

   HANDLERの1つ目の引数には、プリミティブの名前をシンボ
ルとして与えます。残りの引数は、そのプリミティブに引数と
して渡されます(これらの引数の1つ目は、ほとんどの場合はフ
ァイル名自体である)。たとえば以下を行い:

     (file-exists-p FILENAME)

FILENAMEがハンドラーHANDLERをもつ場合、HANDLERは以下のよ
うに呼び出されます:

     (funcall HANDLER 'file-exists-p FILENAME)

   関数が2つ以上の引数をとる場合、それらはファイル名でな
ければならず、関数はそれらのファイル名それぞれにたいして
ハンドラーをチェックします。たとえば、

     (expand-file-name FILENAME DIRNAME)

以下を行った場合は、FILENAMEにたいするハンドラーをチェッ
クした後、DIRNAMEにたいするハンドラーをチェックします。
どちらの場合も、HANDLERは以下のように呼び出されます:

     (funcall HANDLER 'expand-file-name FILENAME DIRNAME)

その後、HANDLERはFILENAMEとDIRNAMEのどちらを処理するか解
決する必要があります。

   指定されたファイル名が2つ以上のハンドラーにマッチする
場合は、ファイル名内で最後に開始するマッチが優先されます
。リモートファイルアクセスのようなジョブにたいするハンド
ラーに先立ち、解凍のようなジョブにたいするハンドラーが最
初に処理されるように、このルールが選択されました。

   以下は、magicファイル名ハンドラーが処理する操作です:

‘access-file’、‘add-name-to-file’、
‘byte-compiler-base-file-name’、
‘copy-directory’、‘copy-file’、‘delete-directory’、
‘delete-file’、‘diff-latest-backup-file’、
‘directory-file-name’、‘directory-files’、
‘directory-files-and-attributes’、
‘dired-compress-file’、‘dired-uncache’、
‘expand-file-name’、‘file-accessible-directory-p’、
‘file-acl’、‘file-attributes’、‘file-directory-p’、
‘file-equal-p’、‘file-executable-p’、‘file-exists-p’、
‘file-in-directory-p’、‘file-local-copy’、‘file-modes’、
‘file-name-all-completions’、‘file-name-as-directory’、
‘file-name-completion’、‘file-name-directory’、
‘file-name-nondirectory’、‘file-name-sans-versions’、
‘file-newer-than-file-p’、‘file-notify-add-watch’、
‘file-notify-rm-watch’、‘file-ownership-preserved-p’、
‘file-readable-p’、‘file-regular-p’、‘file-remote-p’、
‘file-selinux-context’、‘file-symlink-p’、
‘file-truename’、‘file-writable-p’、
‘find-backup-file-name’、‘get-file-buffer’、
‘insert-directory’、‘insert-file-contents’、
‘load’、‘make-auto-save-file-name’、‘make-directory’、
‘make-directory-internal’、‘make-symbolic-link’、
‘process-file’、‘rename-file’、‘set-file-acl’、
‘set-file-modes’、‘set-file-selinux-context’、
‘set-file-times’、‘set-visited-file-modtime’、
‘shell-command’、‘start-file-process’、
‘substitute-in-file-name’、
‘unhandled-file-name-directory’、‘vc-registered’、
‘verify-visited-file-modtime’、
‘write-region’

   ‘insert-file-contents’にたいするハンドラーは通常、
VISIT引数が非‘nil’の場合は、‘(set-buffer-modified-p
nil)’によりそのバッファーの変更フラグをクリアーする必要
があります。これには、もしそのバッファーがロックされてい
たら、ロックを解除する効果もあります。

   ハンドラー関数は上記すべての操作を処理しなければなら
ず、他の操作が将来追加される可能性もあります。これらの操
作自体すべてを実装する必要はありません — 特定の操作にた
いして特別なことを行う必要がないときは、その操作を“通常
の方法”で処理するよう、そのプリミティブを再呼び出しでき
ます。認識できない操作にたいしては、常にそのプリミティブ
を再呼び出しするべきです。以下は、これを行う方法の1つで
す:

     (defun my-file-handler (operation &rest args)
       ;; 特別に処理する必要がある、
       ;; 特別な操作を最初にチェックする
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; 関知しないその他の操作を処理する
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))

   ハンドラー関数が通常のEmacsプリミティブを呼び出す決定
をした際は、無限再起を引き起こすような、同一ハンドラーか
らのプリミティブの再呼び出しを防ぐ必要があります。上記の
例では、変数‘inhibit-file-name-handlers’と
‘inhibit-file-name-operation’により、これを行う方法を示
しています。上記の例のように、これらを正確に使用するよう
、注意してください。複数ハンドラーの正しい振る舞い、およ
びそれぞれがハンドラーをもつかもしれない2つのファイル名
にたいする操作にたいする詳細は、非常に重要です。

   ファイルへの実アクセスにたいして実際には特別なことを
行わないハンドラー(たとえばリモートファイル名にたいして
ホスト名の補完を実装するハンドラーなど)は、
‘safe-magic’プロパティに非‘nil’をもつべきです。たとえば
、Emacsは通常は‘PATH’内で見い出されるようなディレクトリ
ーが、プレフィックス‘/:’によりmagicファイル名に見えるよ
うな場合に、magicファイル名にならないよう“保護”します。
しかし、‘safe-magic’プロパティに非‘nil’をもつハンドラー
がそれらにたいして使用された場合、‘/:’は追加されません。

   ファイル名ハンドラーは、普通とは異なる方法でそれを処
理(handle)するのが、どの操作(operation)なのかを宣言する
ために、‘operations’プロパティをもつことができます。この
プロパティが非‘nil’値をもつ場合、それは操作のリストであ
るべきです。その場合は、それらの操作だけがハンドラーを呼
び出すでしょう。これは無駄を省きますが、主な目的はオート
ロードされるハンドラー関数が実際に処理を行うとき以外はロ
ードされないようにすることです。

   通常のプリミティブにたいして、単にすべての操作を延期
するのは、機能しません。たとえば、ファイル名ハンドラーが
‘file-exists-p’にたいして適用された場合は、通常の
‘load’コードは正しく機能しないでしょうから、ハンドラー自
身で‘load’を処理しなければなりません。しかし、ハンドラー
が‘file-exists-p’プロパティを使用して、‘file-exists-p’を
処理しないことを宣言した場合は、普通とは異なる方法で
‘load’を処理する必要はなくなります。

 -- Variable: inhibit-file-name-handlers
     この変数は、特定の操作にたいして現在のところ使用を
     抑制されているハンドラーのリストを保持する。

 -- Variable: inhibit-file-name-operation
     特定のハンドラーにたいして、現在のところ抑制されて
     いる操作。

 -- Function: find-file-name-handler file operation
     この関数は、FILEというファイル名にたいするハンドラ
     ー関数、それが存在しなければ‘nil’をリターンする。引
     数OPERATIONは、そのファイルを処理する操作であること
     。これは、ハンドラー呼び出し時に1つ目の引数として渡
     すことになる値である。OPERATIONが
     ‘inhibit-file-name-operation’と等しい、またはそのハ
     ンドラーの‘operations’内に存在しない場合、この関数
     は‘nil’をリターンする。

 -- Function: file-local-copy filename
     この関数は、ファイルFILENAMEがまだローカルマシン上
     にない場合は、それをローカルマシン上の通常の非
     magicファイルにコピーする。magicファイル名は、それ
     らが他のマシン上のファイルを参照する場合は、
     ‘file-local-copy’操作を処理するべきである。リモート
     ファイルアクセス以外の目的にたいして使用される
     magicファイル名は、‘file-local-copy’を処理するべき
     ではない。その場合、この関数はそのファイルをローカ
     ルファイルとして扱うだろう。

     FILENAMEがローカルの場合、それがmagicか否かにかかわ
     らず、この関数は何も行わずに、‘nil’をリターンする。
     それ以外では、ローカルコピーファイルのファイル名を
     リターンする。

 -- Function: file-remote-p filename &optional
          identification connected
     この関数は、FILENAMEがリモートファイルかどうかをテ
     ストする。FILENAMEがローカル(リモートではない)の場
     合、リターン値は‘nil’である。FILENAMEが正にリモート
     の場合、リターン値はそのリモートシステムを識別する
     文字列である。

     この識別子文字列は、ホスト名とユーザー名、およびリ
     モートシステムへのアクセスに使用されるメソッドを表
     す文字列も同様に含めることができる。たとえば、ファ
     イル名‘/sudo::/some/file’にたいするリモート識別子文
     字列は、‘/sudo:root@localhost:’となる。

     2つの異なるファイルにたいして‘file-remote-p’が同じ
     識別子をリターンした場合は、それらが同じファイルシ
     ステム上に格納されていて、互いに配慮しつつアクセス
     可能であることを意味する。これはたとえば、同時に両
     方のファイルにアクセスするリモートプロセスを開始す
     ることが可能なことを意味する。ファイルハンドラーの
     実装者は、この方式を保証する必要がある。

     IDENTIFICATIONは、文字列としてリターンされるべき識
     別子の一部を指定する。IDENTIFICATIONには‘method’、
     ‘user’、‘host’のシンボルを指定できる。他の値はすべ
     て‘nil’のように扱われ、それは完全な識別子文字列をリ
     ターンすることを意味する。上記の例では、リモートの
     ‘user’識別子文字列は、‘root’になるだろう。

     CONNECTEDが非‘nil’の場合、たとえFILENAMEがリモート
     であっても、Emacsがそのホストにたいする接続をもたな
     い場合、この関数は‘nil’をリターンする。これは、接続
     が存在しない際の接続の遅延を回避したいときに有用で
     ある。

 -- Function: unhandled-file-name-directory filename
     この関数は、magicではないディレクトリーの名前をリタ
     ーンする。これは、FILENAMEがmagicでなければ、それの
     ディレクトリーパートを使用する。magicファイル名にた
     いしては、何の値をリターンするかを決定するために、
     ファイル名ハンドラーを呼び出す。FILENAMEがローカル
     プロセスからアクセス不能な場合、ファイル名ハンドラ
     ーは‘nil’をリターンすることにより、それを示すべきで
     ある。

     これは、サブプロセスの実行に有用である。すべてのサ
     ブプロセスは、自身が属すカレントディレクトリーとし
     て非magicディレクトリーをもたなければならず、この関
     数はそれを導出するよい手段である。

 -- User Option: remote-file-name-inhibit-cache
     リモートファイルの属性は、よりよいパフォーマンスの
     ためにキャッシュすることができる。キャッシュが
     Emacsの制御外で変更された場合、そのキャッシュ値は無
     効になり、再読込しなければならない。

     この変数が‘nil’にセットされていると、キャッシュ値は
     決して失効しない。このセッティングは、Emacs以外にリ
     モートファイルを変更するものがないことが確実な場合
     のみ、慎重に使用すること。これが‘t’にセットされてい
     ると、キャッシュ値は決して使用されない。これはもっ
     とも安全な値であるが、パフォーマンスは低下するかも
     しれない。

     折衷的な値としては、これを正の数字にセットする。こ
     れは、キャッシュされてからその数字の秒数の間は、キ
     ャッシュ値を使用することを意味する。リモートファイ
     ルが定期的にチェックされる場合には、この変数を定期
     的なチェックの間隔より小さい値にletバインドするのは
     、よい考えかもしれない。たとえば:

          (defun display-time-file-nonempty-p (file)
            (let ((remote-file-name-inhibit-cache
                   (- display-time-interval 5)))
              (and (file-exists-p file)
                   (< 0 (nth 7 (file-attributes
                                 (file-chase-links file)))))))


File: elisp,  Node: Format Conversion,  Prev: Magic File Names,  Up: Files

24.12 File Format Conversion
============================

Emacsは、バッファー内のデータ(テキスト、テキストプロパテ
ィ、あるいはその他の情報)と、ファイル名に格納するのに適
した表現との間で双方向の変換をするために、複数のステップ
を処理します。このセクションでは、この“フォーマット変換
(format conversion)”を行う基本的な関数、すなわちファイル
をバッファーに読み込む‘insert-file-contents’と、バッファ
ーをファイルに書き込む‘write-region’を説明します。

* Menu:

* Overview: Format Conversion Overview.  ‘insert-file-contents’と‘write-region’
* Round-Trip: Format Conversion Round-Trip.  ‘format-alist’の使用。
* Piecemeal: Format Conversion Piecemeal.  非ペアー変換の指定。


File: elisp,  Node: Format Conversion Overview,  Next: Format Conversion Round-Trip,  Up: Format Conversion

24.12.1 Overview
----------------

関数‘insert-file-contents’:

   • 最初に、ファイルからバイトをバッファーに挿入し、
   • バイトを適切な文字にデコードした後、
   • ‘format-alist’のエントリーにより定義されているよう
     にフォーマット処理して、
   • ‘after-insert-file-functions’内の関数を呼び出す。

関数‘write-region’:

   • 最初に、‘write-region-annotate-functions’内の関数を
     呼び出し、
   • ‘format-alist’のエントリーにより定義されているよう
     にフォーマット処理して、
   • 文字を適切なバイトにエンコードした後、
   • そのバイトでファイルを変更する。

   これは、もっとも低レベルでの操作を対照的に示したもの
で、対象の読み取りと書き込みの処理が逆順で対応しています
。このセクションの残りでは、上記で名前のでた3つの変数を
取り囲む2つの機能と、いくつかの関連する関数を説明します
。文字のエンコードとデコードについての詳細は、*note
Coding Systems::を参照してください。


File: elisp,  Node: Format Conversion Round-Trip,  Next: Format Conversion Piecemeal,  Prev: Format Conversion Overview,  Up: Format Conversion

24.12.2 Round-Trip Specification
--------------------------------

読み取りと書き込みのもっとも一般的な機能は、変数
‘format-alist’で制御されます。これは“ファイルフォーマッ
ト(file format)”仕様のリストで、Emacsバッファー内のデー
タにたいして、ファイル内で使用されるテキスト表現を記述し
ます。読み取りと書き込みの仕様記述はペアーになっており、
わたしたちがそれを“ラウンドトリップ(round-trip)”仕様と呼
ぶのは、これが理由です(非ペアー仕様については、*note
Format Conversion Piecemeal::を参照)。

 -- Variable: format-alist
     このリストには、定義されるファイルフォーマットごと
     に、1つのフォーマット定義が含まれる。フォーマット定
     義はそれぞれ、以下の形式のリストである:

          (NAME DOC-STRING REGEXP FROM-FN TO-FN MODIFY MODE-FN PRESERVE)

以下は、フォーマット定義内で要素がもつ意味である:

NAME
     フォーマットの名前。

DOC-STRING
     フォーマットのドキュメント文字列。

REGEXP
     このフォーマットで表現されるファイルの認識に使用さ
     れる正規表現。‘nil’の場合、フォーマットが自動的に適
     用されることは決してない。

FROM-FN
     このフォーマットのデータをデコードする、(ファイルデ
     ータを通常のEmacsデータ表現に変換するための)シェル
     コマンド、または関数。

     シェルコマンドは文字列として表され、Emacsはそのコマ
     ンドを、変換処理のためのフィルターとして実行する。

     FROM-FNが関数の場合、それは変換するべきバッファー部
     分を指定する2つの引数、BEGINとENDで呼び出される。こ
     れは、インプレースでテキストを編集することにより変
     換を行うべきである。これはテキスト長を変更する可能
     性があるので、FROM-FNは変更されたend位置をリターン
     すること。

     ファイルの先頭が、この変換によりREGEXPにマッチしな
     いようにするのは、FROM-FNの役目の1つである。そうで
     ないと、おそらく再度変換が呼び出される。

TO-FN
     このフォーマットのデータをエンコード、すなわち通常
     のEmacsデータ表現をこのフォーマットに変換するための
     シェルコマンド、または関数。

     TO-FNが文字列の場合、それはシェルコマンドである。
     Emacsは変換処理のためのフィルターとして、このコマン
     ドを実行する。

     TO-FNが関数の場合、それは3つの引数で呼び出される。
     BEGINとENDは変換されるべきバッファー部分、BUFFERで
     それがどのバッファーかを指定する。変換を行うには、
     2つの方法がある:

        • そのバッファー内でインプレースで編集を行う。こ
          の場合、TO-FNは変更にしたがい、テキスト範囲の
          end位置をリターンするべきである。

        • 注釈(annotation)のリストをリターンする。これは
          、‘(POSITION . STRING)’という形式の要素をもつ
          リストで、POSITIONは書き込まれるテキスト内での
          相対位置を指定する整数、STRINGはそこに追加され
          る注釈である。このリストは、TO-FNがそれをリタ
          ーンする際、位置順でソートされていなければなら
          ない。

          ‘write-region’が実際にバッファーからファイルに
          テキストを書き込む際には、指定された注釈を対応
          する位置に混合する。これはすべて、バッファーを
          変更せずに行われる。

MODIFY
     フラグ。エンコード関数がバッファーを変更する場合は
     ‘t’、注釈リストをリターンすることにより機能する場合
     は‘nil’。

MODE-FN
     このフォーマットから変換されたファイルをvisit後に呼
     び出される、マイナーモード関数。この関数は1つの引数
     で呼び出され、それが整数1の場合、マイナーモード関数
     はそのモードを有効にする。

PRESERVE
     フラグ。‘format-write-file’が‘buffer-file-format’か
     らこのフォーマットを取り除くべきでない場合は‘t’。

   関数‘insert-file-contents’は、指定されたファイルを読
み込む際にファイルフォーマットを自動的に認識します。これ
は、フォーマット定義の正規表現にたいしてファイルの先頭テ
キストをチェックして、マッチが見つかった場合は、そのフォ
ーマットにたいするデコード関数を呼び出します。その後は再
度、既知のフォーマットすべてをチェックします。適用できる
フォーマットがない間は、チェックを続行します。

   ‘find-file-noselect’、またはそれを使用するコマンドで
ファイルをvisitすることにより、同じように変換が行われま
す(内部で‘insert-file-contents’を呼び出すため)。さらに、
それをデコードする各フォーマットのモード関数も呼び出しま
す。これは、バッファーローカル変数‘buffer-file-format’内
に、フォーマット名のリストを格納します。

 -- Variable: buffer-file-format
     この変数は、visitしているファイルのフォーマットを表
     す。より正確には、これはカレントバッファーのファイ
     ルをvisitに起因するデコードのファイルフォーマット名
     のリストである。これは、すべてのバッファーにたいし
     て、常にローカルである。

   ‘write-region’がデータをファイルに書き込む際には、ま
ず‘buffer-file-format’にリストされたフォーマットにたいす
るエンコード関数を、リスト内での出現順に呼び出します。

 -- Command: format-write-file file format &optional
          confirm
     このコマンドは、カレントバッファーのコンテンツを、
     フォーマット名のリストFORMATにもとづいたフォーマッ
     トで、ファイルFILEに書き込む。これはFORMATを起点に
     、‘buffer-file-format’の値からPRESERVEフラグ(上記参
     照)が非‘nil’の要素にたいして、それがまだFORMAT内に
     存在しない場合は、任意の個数それらを追加する。その
     後、将来の保存においてデフォルトとなるよう、このフ
     ォーマットで‘buffer-file-format’を更新する。
     FORMAT引数を除き、このコマンドは‘write-file’と似て
     いる。特に、CONFIRMは‘write-file’での対応する引数と
     、意味およびinteractiveでの扱いが同じである。*note
     Definition of write-file::を参照のこと。

 -- Command: format-find-file file format
     このコマンドは、ファイルFILEを探して、それをフォー
     マットFORMATにしたがって変換する。これは、後でその
     バッファーを保存する場合に、FORMATをデフォルトにす
     ることも行う。

     引数FORMATは、フォーマット名のリストである。
     FORMATが‘nil’の場合、何の変換も行われない。
     interactiveに呼び出した場合は、FORMATにたいして単に
     <RET>をタイプすると、‘nil’が指定される。

 -- Command: format-insert-file file format &optional
          beg end
     このコマンドは、ファイルFILEのコンテンツを、フォー
     マットFORMATにしたがって変換して挿入する。BEGと
     ENDが非‘nil’の場合、それは‘insert-file-contents’と
     同様、ファイルのどの部分を読み込むかを指定する
     (*note Reading from Files::を参照)。

     リターン値は、絶対ファイル名のリスト、および挿入さ
     れたデータの長さ(変換後)であり、これは
     ‘insert-file-contents’がリターンするものと同様であ
     る。

     引数FORMATは、フォーマット名のリストである。
     FORMATが‘nil’の場合、何の変換も行われない。
     interactiveに呼び出した場合は、FORMATにたいして単に
     <RET>をタイプすると、‘nil’が指定される。

 -- Variable: buffer-auto-save-file-format
     この変数は、自動保存(auto-saving)にたいして使用する
     フォーマットを指定する。値は‘buffer-file-format’と
     同様、ファイル名のリストであるが、これはauto-saveフ
     ァイルへの書き込みで、‘buffer-file-format’のかわり
     に使用される。値が‘t’(デフォルト)の場合、自動保存は
     当バッファーの通常の保存時と同じフォーマットを使用
     する。この変数は、すべてのバッファーにおいて、常に
     バッファーローカルである。


File: elisp,  Node: Format Conversion Piecemeal,  Prev: Format Conversion Round-Trip,  Up: Format Conversion

24.12.3 Piecemeal Specification
-------------------------------

前のサブセクション(*note Format Conversion Round-Trip::を
参照)で説明したラウンドトリップ指定とは対照的に、変数
‘after-insert-file-functions’と
‘write-region-annotate-functions’を使用して、読み取りと
書き込みの変換を個別に制御できます。

   変換は、ある表現を起点として、他の表現を生成します。
これを行う変換が1つだけのときは、何を起点とするかに関し
て競合は存在しません。しかし、複数の変換呼び出しが存在す
る場合、同じデータを起点にする必要がある2つの変換の間に
、競合が発生するかもしれません。

   この状況を理解するには、‘write-region’中のテキストプ
ロパティの変換コンテキストが最善です。たとえば、あるバッ
ファーの位置42の文字が‘X’で、それのテキストプロパティが
‘foo’だとします。‘foo’にたいする変換が、たとえばそのバッ
ファーに‘FOO:’を挿入することにより行われる場合、それは位
置42の文字‘X’を‘F’に変更します。そして次の変換は、間違っ
たデータを起点に開始されるでしょう。

   競合を避けるためには、協調的な変換がバッファーを変更
せずに、POSITION昇順でソートされた、‘(POSITION .
STRING)’という形式の要素をもつリストを、“注釈
(annotations)”に指定します。

   2つ以上の変換が存在する場合、‘write-region’はそれらの
注釈を、1つのソート済みリストに破壊的にマージします。後
でそのバッファーのテキストを実際にファイルに書き込む際に
、対応する位置にある指定された注釈を混合します。これはす
べて、バッファーを変更せずに行われます。

   これとは対照的に、読み取り時にはそのテキストの混合さ
れた注釈は、即座に処理されます。‘insert-file-contents’は
、変更される何らかのテキストの先頭にポイントをセットして
から、そのテキストの長さで変換関数を呼び出します。これら
の関数は常に、挿入されるテキストの先頭のポイントをリター
ンするべきです。最初の変換により注釈が削除されても、その
後の変換が誤って処理することはないので、このアプローチは
読み取りに際しては正しく機能します。すべての変換関数は、
それが認識する注釈のスキャン、その注釈の削除、バッファー
テキストの変更(たとえばテキストプロパティのセット等)、お
よびそれらの変更に由来する更新されたテキスト長のリターン
を行うべきです。１つの関数によりリターンされた値は、次の
関数への引数になります。

 -- Variable: write-region-annotate-functions
     ‘write-region’にたいして呼び出す、関数のリスト。リ
     スト内の各関数は、書き込まれるリージョンの開始と終
     了の、2つの引数で呼び出される。これらの関数は、その
     バッファーのコンテンツを変更するべきではない。かわ
     りに注釈をリターンすること。

     特別なケースとして、関数がカレントと異なるバッファ
     ーをリターンするかもしれない。Emacsはこれを、カレン
     トバッファーが出力される変更されたテキストを含むも
     のとして理解する。つまり、Emacsは‘write-region’呼び
     出しの引数STARTとENDを、新たなバッファーの
     ‘point-min’と‘point-max’に変更して与える。さらに、
     以前のすべての注釈はこの関数により処理されるので、
     Emacsはそれらの破棄も行う。

 -- Variable: write-region-post-annotation-function
     この変数の値が非‘nil’の場合、それは関数であること。
     この関数は、‘write-region’完了後に引数なしで呼び出
     される。

     ‘write-region-annotate-functions’内のある関数がカレ
     ントと異なるバッファーをリターンした場合、Emacsは
     ‘write-region-post-annotation-function’を複数回呼び
     出す。Emacsは最後にカレントだったバッファーでそれを
     呼び出し、その前にカレントだったバッファーで再度こ
     れを呼び出す、...のようにして元のバッファーに戻る。

     したがって、‘write-region-annotate-functions’内の関
     数は、バッファーを作成して、‘kill-buffer’のそのバッ
     ファーでのローカル値にこの変数を与え、変更されたテ
     キストでそのバッファーをセットアップして、そのバッ
     ファーをカレントにすることができる。そのバッファー
     は、‘write-region’完了後にkillされるだろう。

 -- Variable: after-insert-file-functions
     このリスト内の各関数は、挿入されるテキストの先頭に
     ポイントがある状態で、挿入される文字数を１つの引数
     として、‘insert-file-contents’により呼び出される。
     すべての関数はポイントを未変更のまま、その関数によ
     って変更された、挿入後テキストの新たな文字数をリタ
     ーンするべきである。

   わたしたちは、ユーザーがファイル内にテキストプロパテ
ィを格納したりそれらを取得するために、そしてさまざまなデ
ータフォーマットを体験することにより、適切なフォーマット
を見つけるために、これらのフックを使用してLispプログラム
を記述することを推奨します。最終的には、わたしたちが
Emacs内にインストールできる、良質で汎用性のある拡張をユ
ーザーが開発することを望みます。

   わたしたちは、テキストプロパティの名前や値として、任
意のLispオブジェクトの処理を試みることは推奨しません — な
ぜなら汎用的なプログラムはおそらく記述が困難で、かつ低速
だからです。かわりに、十分な柔軟性をもち、エンコードが難
しすぎない、想定されるデータ型のセットを選択してください
。


File: elisp,  Node: Backups and Auto-Saving,  Next: Buffers,  Prev: Files,  Up: Top

25 Backups and Auto-Saving
**************************

バックアップファイルおよびauto-save(自動保存)ファイルは
、Emacsがクラッシュ、またはユーザー自身のエラーからユー
ザーの保護を試みるための、2つの手段です。自動保存
(auto-saving)は、カレントの編集セッション開始以降のテキ
ストを保存します。一方バックアップファイルは、カレントセ
ッションの前のファイルコンテンツを保存します。

* Menu:

* Backup Files::             バックアップファイルの作成と名前選択の方法。
* Auto-Saving::              auto-saveファイルの作成と名前選択の方法。
* Reverting::                ‘revert-buffer’とその動作のカスタマイズ方法。


File: elisp,  Node: Backup Files,  Next: Auto-Saving,  Up: Backups and Auto-Saving

25.1 Backup Files
=================

“バックアップファイル(backup file)”とは、編集中ファイル
の古いコンテンツのコピーです。Emacsは、visitされているフ
ァイルにバッファーを最初に保存するとき、バックアップファ
イルを作成します。したがって、バックアップファイルには通
常、カレント編集セッションの前にあったような、ファイルの
コンテンツが含まれています。バックアップファイルのコンテ
ンツには、通常は一度存在したバックアップファイルが変更さ
れずに残ります。

   バックアップは通常、visitされているファイルを新たな名
前にリネームすることにより作成されます。オプションで、バ
ックアップファイルがvisitされているファイルをコピーする
ことにより作成されるように指定できます。この選択により、
複数の名前をもつファイルのときに、違いが生じます。また、
編集中のファイルの所有者が元のオーナーのままか、それとも
編集ユーザーになるかにも、影響し得ます。

   デフォルトでは、Emacsは編集中のファイルごとに、単一の
バックアップファイルを作成します。かわりに、番号付きバッ
クアップ(numbered backup)を要求することもできます。その
場合は、新たなバックアップファイルそれぞれが、新たな名前
を得ます。必要なくなったときは古い番号付きバックアップを
削除したり、Emacsがそれらを自動的に削除することもできま
す。

* Menu:

* Making Backups::           Emacsがバックアップファイルを作成する方法とタイミング。
* Rename or Copy::           2つの選択肢:
                               古いファイルのリネームとコピー。
* Numbered Backups::         ソースファイルごとに複数のバックアップを保持する。
* Backup Names::             バックアップファイル名の計算方法とカスタマイズ。


File: elisp,  Node: Making Backups,  Next: Rename or Copy,  Up: Backup Files

25.1.1 Making Backup Files
--------------------------

 -- Function: backup-buffer
     この関数は、もしそれが適切であれば、カレントバッフ
     ァーにvisitされているファイルのバックアップを作成す
     る。これは、最初のバッファー保存を行う前に、
     ‘save-buffer’により呼び出される。

     リネームによりバックアップが作成された場合、リター
     ン値は(MODES EXTRA-ALIST BACKUPNAME)という形式のコ
     ンスセルである。ここでMODESは、‘file-modes’(*note
     Testing Accessibility::を参照)でリターンされるよう
     な元ファイルのモードビット、EXTRA-ALISTは
     ‘file-extended-attributes’(*note Extended
     Attributes::を参照)によりリターンされるような元ファ
     イルの拡張属性を示すalist、そしてBACKUPNAMEはバック
     アップの名前である。

     他のすべての場合(コピーによりバックアップが作成され
     た、またはバックアップが作成されなかった)、この関数
     は‘nil’をリターンする。

 -- Variable: buffer-backed-up
     このバッファーローカル変数は、そのバッファーのファ
     イルがバッファーによりバックアップされたかどうかを
     明示する。非‘nil’の場合、バックアップファイルは書き
     込み済みであり、それ以外では、(バックアップが有効な
     ら)次回保存時にファイルはバックアップされる。この変
     数は永続的にローカルであり、
     ‘kill-all-local-variables’はそれを変更しない。

 -- User Option: make-backup-files
     この変数は、バックアップファイルを作成するかどうか
     を決定する。非‘nil’の場合、Emacsは初回保存時にすべ
     てのファイルのバックアップを作成する — ただし
     ‘backup-inhibited’が‘nil’の場合(以下参照)。

     以下の例は、Rmailバッファーだけで変数
     ‘make-backup-files’を変更して、それ以外では変更しな
     い方法を示す。この変数を‘nil’にセットすると、
     Emacsはそれらのファイルのバックアップ作成をストップ
     し、それはディスク容量の消費を節約するだろう(あなた
     は、このコードをinitファイルに配置したいと思うかも
     しれない)。

          (add-hook 'rmail-mode-hook
                    (lambda () (setq-local make-backup-files nil)))

 -- Variable: backup-enable-predicate
     この変数の値は、あるファイルがバックアップファイル
     をもつべきかどうかを決定する、特定の機会に呼び出さ
     れる関数である。関数は、判断すべき絶対ファイル名と
     いう、1つの引数を受け取る。この関数が‘nil’をリター
     ンした場合、そのファイルにたいするバックアップは無
     効になる。それ以外では、このセクション内の他の変数
     がバックアップ作成の是非と方法を指定する。

     デフォルト値は‘normal-backup-enable-predicate’で、
     これは‘temporary-file-directory’と
     ‘small-temporary-file-directory’内のファイルをチェ
     ックする。

 -- Variable: backup-inhibited
     この変数が非‘nil’の場合、バックアップは抑止される。
     これは、visitされているファイル名にたいする
     ‘backup-enable-predicate’のテスト結果を記録する。さ
     らに、visitされているファイルにたいするバックアップ
     抑止にもとづくその他機構によっても、使用され得る。
     たとえば、VCはバージョンコントロールシステムに管理
     されるファイルのバックアップを防ぐために、この変数
     を非‘nil’にセットする。

     これは永続的にローカルなので、メジャーモード変更に
     より値は失われない。メジャーモードはこの変数ではな
     く、かわりに‘make-backup-files’をセットするべきであ
     る。

 -- User Option: backup-directory-alist
     この変数の値は、ファイル名パターンとバックアップデ
     ィレクトリー名のalistである。各要素は以下の形式をも
     つ
          (REGEXP . DIRECTORY)

     名前がREGEXPにマッチするファイルのバックアップが、
     DIRECTORY内に作成されるだろう。DIRECTORYには相対デ
     ィレクトリー、または絶対ディレクトリーを指定できる
     。絶対ディレクトリーの場合は、マッチするすべてのフ
     ァイルが同じディレクトリー内にバックアップされる。
     このディレクトリー内でのファイル名は、クラッシュを
     避けるために、バックアップされるファイルの完全名の
     すべてのディレクトリー区切りは、‘!’に変更される。結
     果の名前を切り詰めるファイルシステムでは、これは正
     しく機能しないだろう。

     すべてのバックアップが単一のディレクトリーで行われ
     る一般的なケースでは、alistは‘"."’と適切なディレク
     トリーからなるペアーの、単一の要素を含むべきである
     。

     この変数が‘nil’(デフォルト)、またはファイル名のマッ
     チに失敗した場合、バックアップは元のファイルのディ
     レクトリーに作成される。

     長いファイル名のないMS-DOSファイルシステムでは、こ
     の変数は常に無視される。

 -- User Option: make-backup-file-name-function
     この変数の値は、バックアップファイル名を作成する関
     数である。関数‘make-backup-file-name’は、これを呼び
     出す。*note Naming Backup Files: Backup Names.を参
     照のこと。

     特定のファイルにたいして特別なことを行うために、こ
     れをバッファーローカルにすることもできる。変更する
     場合は、‘backup-file-name-p’と
     ‘file-name-sans-versions’も変更する必要があるかもし
     れない。


File: elisp,  Node: Rename or Copy,  Next: Numbered Backups,  Prev: Making Backups,  Up: Backup Files

25.1.2 Backup by Renaming or by Copying?
----------------------------------------

Emacsがバックアップファイルを作成できる、2つの方法があり
ます:

   • Emacsは元のファイルをリネームすることができ、それが
     バックアップファイルになる。その後、バッファーの保
     存は新たなファイルに書き込まれる。この手順後、元フ
     ァイルの他のすべての名前(ハードリンク)はバックアッ
     プファイルを参照することになる。新たなファイルの所
     有者は編集を行っているユーザーになり、グループはそ
     のディレクトリー内でそのユーザーが新たなファイルを
     書き込んだときのデフォルトのグループになる。

   • Emacsは元のファイルをバックアップファイルにコピーで
     き、新たな内容はその後、元のファイルに上書きされる
     。この手順後、元のファイルの他のすべての名前(ハード
     リンク)は、そのファイルの(更新された)カレントバージ
     ョンを参照し続ける。ファイルの所有者とグループは変
     更されない。

   デフォルトは、1つ目の方法のリネームです。

   変数‘backup-by-copying’が非‘nil’の場合、それは2つ目の
方法、つまり元のファイルをコピーして、新たなバッファー内
容で上書きすることを意味します。変数
‘file-precious-flag’が非‘nil’の場合にも、(メイン機能の副
作用として)この効果があります。*note Saving Buffers::を
参照してください。

 -- User Option: backup-by-copying
     この変数が非‘nil’の場合、Emacsは常にコピーによりバ
     ックアップファイルを作成する。デフォルトは‘nil’。

   以下の3つの変数が非‘nil’の際は、ある特定のケースに2つ
目の方法が使用されます。その特定のケースに該当しないファ
イルの処理に影響はありません。

 -- User Option: backup-by-copying-when-linked
     この変数が非‘nil’の場合、Emacsは複数名(ハードリンク
     )をもつファイルにたいして、コピーによりバックアップ
     を作成する。デフォルトは‘nil’。

     ‘backup-by-copying’が非‘nil’の場合は常にコピーによ
     りバックアップが作成されるので、この変数は
     ‘backup-by-copying’が‘nil’のときだけ意味がある。

 -- User Option: backup-by-copying-when-mismatch
     この変数が非‘nil’(デフォルト)の場合、リネームにより
     ファイルの所有者、またはグループが変更されるケース
     では、Emacsはコピーによりバックアップを作成する。

     リネームによりファイルの所有者、またはグループが変
     更されない場合、値は効果をもたない。つまり、そのデ
     ィレクトリーで新たに作成されるファイルにたいするデ
     フォルトのグループに属するユーザーにより所有される
     ファイルが該当する。

     ‘backup-by-copying’が非‘nil’の場合は常にコピーによ
     りバックアップが作成されるので、この変数は
     ‘backup-by-copying’が‘nil’のときだけ意味がある。

 -- User Option:
          backup-by-copying-when-privileged-mismatch
     この変数が非‘nil’の場合、特定のユーザーID値(具体的
     には、特定の値以下のID数値)にたいしてのみ、
     ‘backup-by-copying-when-mismatch’と同じように振る舞
     うことを指定する。変数には、その数値をセットする。

     したがって、ファイル所有者の変更を防ぐ必要がある際
     は、‘backup-by-copying-when-privileged-mismatch’を
     0にセットすれば、スーパーユーザーだけがコピーによる
     バックアップを行うことができる。

     デフォルトは200。


File: elisp,  Node: Numbered Backups,  Next: Backup Names,  Prev: Rename or Copy,  Up: Backup Files

25.1.3 Making and Deleting Numbered Backup Files
------------------------------------------------

ファイルの名前が‘foo’の場合、番号付きバックアップのバー
ジョン名は‘foo.~V~’となります。Vは‘foo.~1~’、‘foo.~2~’、
‘foo.~3~’、...、‘foo.~259~’のように、さまざまな整数です
。

 -- User Option: version-control
     この変数は、単一の非番号付きバックアップファイルを
     作成するか、それとも複数の番号付きバックアップを作
     成するかを制御する。

     ‘nil’
          visitされたファイルが番号付きバックアップの場
          合は番号付きバックアップを作成し、それ以外は作
          成しない。これがデフォルトである。

     ‘never’
          番号付きバックアップを作成しない。

     ANYTHING ELSE
          番号付きバックアップを作成する。

   番号付きバックアップを使用することにより、バックアッ
プのバージョン番号は最終的には非常に大きな番号になるので
、それらを削除しなければなりません。Emacsはこれを自動で
行うことができ、ユーザーに削除するか確認することもできま
す。

 -- User Option: kept-new-versions
     この変数の値は、新たな番号付きバックアップが作成さ
     れた際に保持すべき、もっとも新しいバージョンの個数
     である。新たに作成されたバックアップもカウントされ
     る。デフォルトは2。

 -- User Option: kept-old-versions
     この変数の値は、新たな番号付きバックアップが作成さ
     れた際に保持すべき、もっとも古いバージョンの個数で
     ある。デフォルトは2。

   番号が1、2、3、5、7のバックアップがあり、かつこれらの
変数が値2をもつ場合は、番号が1と2のバックアップは古いバ
ージョンとして保持され、番号が5と7のバックアップは新しい
バージョンとして保持される。そして、番号が3のバックアッ
プは、余分なバックアップとなる。関数
‘find-backup-file-name’(*note Backup Names::を参照)は、
どのバージョンのバックアップを削除するかを決定する役目を
負うが、この関数自身がバックアップを削除する訳ではない。

 -- User Option: delete-old-versions
     この変数が‘t’の場合は、ファイルの保存により、余分な
     バージョンのバックアップは、暗黙里に削除される。
     ‘nil’の場合は、余分なバックアップの削除前に確認を求
     めることを意味し、それ以外では、余分なバックアップ
     は削除されない。

 -- User Option: dired-kept-versions
     この変数は、Dired内のコマンド‘.’(ピリオド。
     ‘dired-clean-directory’)で、もっとも新しいバージョ
     ンのバックアップをいくつ保持するかを指定する。これ
     は、新たにバックアップファイルを作成する際に、
     ‘kept-new-versions’を指定するのと同等である。デフォ
     ルトは2。


File: elisp,  Node: Backup Names,  Prev: Numbered Backups,  Up: Backup Files

25.1.4 Naming Backup Files
--------------------------

このセクションでは、主にバックアップファイルの命名規則を
再定義してカスタマイズできる関数を記載します。これらの
1つを変更した場合は、おそらく残りも変更する必要がありま
す。

 -- Function: backup-file-name-p filename
     この関数は、FILENAMEがバックアップファイルとして利
     用可能ならば、非‘nil’値をリターンする。これは名前の
     チェックだけを行い、FILENAMEという名前のファイルが
     存在するかどうかはチェックしない。

          (backup-file-name-p "foo")
               ⇒ nil
          (backup-file-name-p "foo~")
               ⇒ 3

     この関数の標準的な定義は、以下のようになる:

          (defun backup-file-name-p (file)
            "FILEがバックアップファイルなら\
          (番号付きか否かに関わらず)非nilをリターンする"
            (string-match "~\\'" file))

     このように、ファイル名が‘~’で終わる場合、この関数は
     非‘nil’値をリターンする(ドキュメント文字列を分割す
     るために、1行目でバックスラッシュを使用しているが、
     これはドキュメント文字列内で単一行を生成する)。

     この単純な式は、カスタマイズのための再定義を簡便に
     するために、個々の関数内に配されている。

 -- Function: make-backup-file-name filename
     この関数は、ファイルFILENAMEの非番号付きバックアッ
     プファイル名として使用される文字列をリターンする。
     Unixでは、これは単にFILENAMEにチルダを追加する。

     ほとんどのオペレーティングシステムでは、この関数の
     標準的な定義は以下のようになる:

          (defun make-backup-file-name (file)
            "FILEにたいして非番号付きバックアップファイル名を作成する"
            (concat file "~"))

     この関数を再定義することにより、バックアップファイ
     ルの命名規則を変更できる。以下は、チルダの追加に加
     えて、先頭に‘.’を追加するよう、
     ‘make-backup-file-name’を再定義する例である:

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               ⇒ ".backups.texi~"

     Diredコマンドのいくつかを含むEmacsの一部では、バッ
     クアップファイル名が‘~’で終わると仮定している。この
     規則にしたがわない場合、深刻な問題とはならないだろ
     うが、それらのコマンドが若干好ましくない結果をもた
     らすかもしれない。

 -- Function: find-backup-file-name filename
     この関数は、FILENAMEの新たなバックアップファイル用
     のファイル名を計算する。これは、特定の既存バックア
     ップファイルにたいする削除の提案も行うかもしれない
     。‘find-backup-file-name’は、CARが新たなバックアッ
     プファイル名で、CDRが削除を提案するバックアップファ
     イルのリストであるようなリストをリターンする。値に
     は‘nil’も指定でき、これはバックアップが作成されない
     ことを意味する。

     ‘kept-old-versions’および‘kept-new-versions’の2つの
     変数は、どのバージョンのバックアップを保持するべき
     かを決定する。この関数は、値のCDRから該当するバージ
     ョンを除外することにより、それらを保持する。*note
     Numbered Backups::を参照のこと。

     以下の例の値は、新しいバックアップファイルに使用す
     る名前が‘~rms/foo.~5~’で、‘~rms/foo.~3~’は呼び出し
     側が今削除を検討するべき“余分”なバージョンであるこ
     とを示している。

          (find-backup-file-name "~rms/foo")
               ⇒ ("~rms/foo.~5~" "~rms/foo.~3~")

 -- Function: file-newest-backup filename
     この関数は、FILENAMEにたいするもっとも最近のバック
     アップファイル名、バックアップファイルがない場合は
     ‘nil’をリターンする。

     ファイル比較関数のいくつかは、自動的にもっとも最近
     のバックアップを比較できるように、この関数を使用し
     ている。


File: elisp,  Node: Auto-Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto-Saving

25.2 Auto-Saving
================

Emacsは、visitしているすべてのファイルを定期的に保存しま
す。これは“自動保存(auto-saving)”と呼ばれます。自動保存
は、システムがクラッシュした場合に失われる作業量を、ある
作業量以下にします。デフォルトでは、自動保存は300キース
トロークごと、またはidle時の30秒後に発生します。自動保存
に関するユーザー向けの情報については、*note Auto Save:
(emacs)Auto Save.を参照してください。ここでは、自動保存
の実施に使用される関数と、それらを制御する変数について説
明します。

 -- Variable: buffer-auto-save-file-name
     このバッファーローカル変数は、カレントバッファーの
     自動保存に使用されるファイル名である。そのバッファ
     ーが自動保存されるべきでない場合は、‘nil’。

          buffer-auto-save-file-name
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

 -- Command: auto-save-mode arg
     これはバッファーローカルなマイナーモードであるAuto
     Saveモードにたいする、モードコマンドである。Auto
     Saveモードが有効なときは、そのバッファーで自動保存
     が有効である。呼び出し方は、他のマイナーモードと同
     様(*note Minor Mode Conventions::を参照)。

     ほとんどのマイナーモードとは異なり、
     ‘auto-save-mode’変数は存在しない。
     ‘buffer-auto-save-file-name’が非‘nil’、かつ
     ‘buffer-saved-size’(以下参照)が非0ならば、Auto
     Saveモードは有効である。

 -- Function: auto-save-file-name-p filename
     この関数は、FILENAMEがauto-saveファイルのような文字
     列の場合は、非‘nil’をリターンする。先頭と末尾がハッ
     シュマーク(‘#’)の名前はauto-saveファイルの可能性が
     あるという、auto-saveファイルにたいする通常の命名規
     則を想定する。引数FILENAMEは、ディレクトリーパート
     を含むべきではない。

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
          (auto-save-file-name-p "#backups.texi#")
               ⇒ 0
          (auto-save-file-name-p "backups.texi")
               ⇒ nil

     この関数の標準的な定義は、以下のようになる:

          (defun auto-save-file-name-p (filename)
            "FILENAMEが以下を満たすなら非nilをリターンする"
            (string-match "^#.*#$" filename))

     auto-saveファイルの命名規則規則を変更したいときにカ
     スタマイズできるようにするために、この関数は存在す
     る。これを再定義した場合は、それに対応して関数
     ‘make-auto-save-file-name’も忘れずに再定義すること
     。

 -- Function: make-auto-save-file-name
     この関数は、カレントバッファーの自動保存に使用され
     るファイル名をリターンする。これは、ファイル名の先
     頭と末尾にハッシュマーク(‘#’)を単に追加する。この関
     数は、変数‘auto-save-visited-file-name’(以下参照)を
     調べない。呼び出し側は、まずその変数をチェックする
     べきである。

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"

     以下は、この関数の標準的な定義の簡略版である:

          (defun make-auto-save-file-name ()
            "カレントバッファーの自動保存に使用される\
          ファイル名をリターンする"
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))

     auto-saveファイルの命名規則をカスタマイズするために
     再定義できるように、これは独立した関数として存在し
     ている。ただし、これに対応した方法で
     ‘auto-save-file-name-p’も忘れずに変更すること。

 -- User Option: auto-save-visited-file-name
     この変数が非‘nil’の場合、Emacsはvisit中のファイルに
     バッファーを自動保存する。つまり、自動保存は編集中
     ファイルと同じファイルにたいして行われる。通常この
     変数は‘nil’なので、auto-saveファイルは
     ‘make-auto-save-file-name’で作成された別の名前をも
     つ。

     この変数の値を変更した際は、バッファー内で
     auto-saveモードが再度有効になるまで、既存バッファー
     にたいして新たな値は効果をもたない。すでに
     auto-saveモードが有効な場合は、再度
     ‘auto-save-mode’が呼び出されるまで、同じファイルに
     自動保存が行われる。

 -- Function: recent-auto-save-p
     この関数は、カレントバッファーが最後に読み込み、ま
     たは保存されて以降、自動保存されていれば‘t’をリター
     ンする。

 -- Function: set-buffer-auto-saved
     この関数は、カレントバッファーを自動保存済みとマー
     クする。そのバッファーは、バッファーテキストが再度
     変更されるまで、自動保存されないだろう。この関数は
     ‘nil’をリターンする。

 -- User Option: auto-save-interval
     この変数の値は、自動保存の頻度を入力イベント数で指
     定する。この分の入力イベント読み取りごとに、Emacsは
     自動保存が有効なすべてのバッファーにたいして、自動
     保存を行う。これを0にすると、タイプした文字数にもと
     づく自動保存は無効になる。

 -- User Option: auto-save-timeout
     この変数の値は、自動保存が発生すべきidle時間の秒数
     である。この秒数分ユーザーが休止するたびに、Emacsは
     自動保存が有効なすべてのバッファーにたいして、自動
     保存を行う(カレントバッファーが非常に大きい場合、指
     定されたタイムアウトはサイズ増加とともに増加される
     因子で乗ぜられる。1MBのバッファーにたいして、この因
     子はおよそ4である)。

     値が0、または‘nil’の場合、idle時間にもとづく自動保
     存は行われず、‘auto-save-interval’で指定される入力
     イベント数の後のみ自動保存が行われる。

 -- Variable: auto-save-hook
     このノーマルフックは、自動保存が行われようとするた
     びに毎回実行される。

 -- User Option: auto-save-default
     この変数が非‘nil’の場合は、ファイルをvisitするバッ
     ファーの自動保存がデフォルトで有効になり、それ以外
     では有効にならない。

 -- Command: do-auto-save &optional no-message
          current-only
     この関数は、自動保存される必要があるすべてのバッフ
     ァーを自動保存する。これは自動保存が有効、かつ前回
     の自動保存以降に変更されたすべてのバッファーを保存
     する。

     いずれかのバッファーが自動保存される場合、通常
     ‘do-auto-save’は自動保存が行われる間、それを示すメ
     ッセージ‘Auto-saving...’をエコーエリアに表示する。
     しかし、NO-MESSAGEが非‘nil’の場合、このメッセージは
     抑制される。

     CURRENT-ONLYが非‘nil’の場合は、カレントバッファーだ
     けが自動保存される。

 -- Function: delete-auto-save-file-if-necessary
          &optional force
     この関数は、‘delete-auto-save-files’が非‘nil’なら、
     カレントバッファーのauto-saveファイルを削除する。こ
     れは、バッファー保存時に毎回呼び出される。

     FORCEが‘nil’の場合、この関数は最後に本当の保存が行
     われて以降、カレントEmacsセッションにより書き込まれ
     たファイルだけを削除する。

 -- User Option: delete-auto-save-files
     この変数は、関数
     ‘delete-auto-save-file-if-necessary’により使用され
     る。これが非‘nil’の場合、Emacsは(visitされているフ
     ァイルに)本当に保存が行われたとき、auto-saveファイ
     ルを削除する。これはデスク容量を節約し、ディレクト
     リーを整理する。

 -- Function: rename-auto-save-file
     この関数は、visitされているファイルの名前が変更され
     ていれば、カレントバッファーのauto-saveファイルの名
     前を調整する。これは、カレントEmacsセッションで
     auto-saveファイルが作成されていれば、既存の
     auto-saveファイルもリネームする。visitされているフ
     ァイルの名前が変更されていない場合、この関数は何も
     行わない。

 -- Variable: buffer-saved-size
     このバッファーローカル変数の値は、カレントバッファ
     ーが最後に読み取り、保存、または自動保存されたとき
     のバッファーの長さである。これは、サイズの大幅な減
     少の検知に使用され、それに応じて自動保存がオフに切
     り替えられる。

     −1の場合、それはサイズの大幅な減少により、そのバッ
     ファーの自動保存が一時的に停止されていることを意味
     する。明示的な保存により、この変数に正の値が格納さ
     れ、自動保存が再び有効になる。自動保存をオフやオン
     に切り替えることでも、またはこの変数を更新されるの
     で、サイズの大幅な減少は忘れられてしまう。

     −2の場合は、そのバッファーがバッファーサイズの変更
     を無視すべきことを意味する。特に、バッファーサイズ
     の変更により、一時的に自動保存を停止するべきではな
     い。

 -- Variable: auto-save-list-file-name
     この変数は、(非‘nil’の場合は)すべてのauto-saveファ
     イルの名前を記録するファイルを指定する。Emacsが自動
     保存を行うたびに、そのEmacsは自動保存が有効な各バッ
     ファーごとに2行ずつ書き込みを行う。1行目はvisitされ
     ているファイルの名前(ファイルをvisitしないバッファ
     ーの場合は空)、2行目はauto-saveファイルの名前を示す
     。

     Emacsを正常にexitしたときは、このファイルは削除され
     る。Emacsがクラッシュした場合は、このファイルを調べ
     ることにより、失われるはずだった作業を含む、すべて
     のauto-saveファイルを探すことができる。
     ‘recover-session’コマンドは、それらを見つけるために
     、このファイルを使用する。

     このファイルにたいするデフォルト名は、ユーザーのホ
     ームディレクトリーの、‘.saves-’で始まるファイルを指
     定する。この名前には、EmacsのプロセスIDと、ホスト名
     も含まれる。

 -- User Option: auto-save-list-file-prefix
     initファイルを読み込んだ後、(‘nil’にセット済みでな
     ければ)Emacsはこのプレフィックスにもとづきホスト名
     とプロセスIDを追加して、
     ‘auto-save-list-file-name’を初期化する。initファイ
     ル内でこれを‘nil’にセットした場合、Emacsは
     ‘auto-save-list-file-name’を初期化しない。


File: elisp,  Node: Reverting,  Prev: Auto-Saving,  Up: Backups and Auto-Saving

25.3 Reverting
==============

あるファイルにたいして大きな変更を行った後、気が変わって
元に戻したくなった場合は、‘revert-buffer’コマンドでその
ファイルの以前のバージョンを読み込むことにより、それらの
変更を取り消すことができます。詳細は、*note Reverting a
Buffer: (emacs)Reverting.を参照してください。

 -- Command: revert-buffer &optional ignore-auto
          noconfirm preserve-modes
     このコマンドは、バージョンのテキストを、ディスク上
     のvisitされているファイルのテキストで置き換える。こ
     れにより、ファイルがvisit、または保存された以降に行
     ったすべての変更は、アンドゥ(undo: 取り消し)される
     。

     デフォルトでは、もっとも最近のauto-saveファイルのほ
     うがvisitされているファイルより新しく、かつ引数
     IGNORE-AUTOが‘nil’の場合、‘revert-buffer’はユーザー
     にたいしてかわりにauto-saveファイルを使用するかどう
     か確認を求める。このコマンドをinteractiveに呼び出し
     たとき、プレフィックス数引数が指定されていなければ
     、IGNORE-AUTOは‘t’となる。つまり、interactive呼び出
     しは、デフォルトではauto-saveファイルのチェックを行
     わない。

     ‘revert-buffer’は通常、バッファーを変更する前に確認
     を求める。しかし、引数NOCONFIRMが非‘nil’の場合、
     ‘revert-buffer’は確認を求めない。

     このコマンドは通常、‘normal-mode’を使用することによ
     り、そのバッファーのメジャーモードとマイナーモード
     を再初期化する。しかし、PRESERVE-MODESが非‘nil’の場
     合、モードは変更されずに残る。

     リバート(revert: 戻す、復元する)は、
     ‘insert-file-contents’の置き換え機能を使用すること
     により、バッファー内のマーカー位置の保持を試みる。
     バッファーのコンテンツとファイルのコンテンツがリバ
     ート操作を行う前に等しい場合、リバートはすべてのマ
     ーカーを保持する。等しくない場合、リバートによりバ
     ッファーは変更される。この場合は、(もしあれば)バッ
     ファーの最初と最後にある未変更のテキスト内にあるマ
     ーカーは保持される。他のマーカーを保持しても、それ
     らは正しくないだろう。

 -- Variable: revert-buffer-in-progress-p
     ‘revert-buffer’は処理を行っている間、この変数を非
     ‘nil’値にバインドする。

   このセクションの残りの部分で説明する変数をセットする
ことにより、‘revert-buffer’が処理を行う方法をカスタマイ
ズできます。

 -- User Option: revert-without-query
     この変数は、問い合わせなしでリバートされるべきファ
     イルのリストを保持する。値は、正規表現のリスト。
     visitされているファイルの名前がこれらの正規表現のい
     ずれかにマッチし、かつバッファーが未変更だがディス
     ク上のファイルは変更されている場合、
     ‘revert-buffer’はユーザーに確認を求めることなく、フ
     ァイルをリバートする。

   メジャーモードのいくつかは、以下の変数をローカルにバ
インドすることにより、‘revert-buffer’をカスタマイズしま
す:

 -- Variable: revert-buffer-function
     この変数の値は、そのバッファーをリバートするために
     使用する関数である。これはリバート処理を行うための
     、2つのオプション引数をとる関数であること。2つのオ
     プション引数IGNORE-AUTOとNOCONFIRMは、
     ‘revert-buffer’が受け取る引数である。

     Diredモードのような、編集されるテキストにファイルの
     コンテンツは含まれず、他の方式により再生成され得る
     モードは、この変数のバッファーローカル値に、コンテ
     ンツを再生成する特別な関数を与えることができる。

 -- Variable:
          revert-buffer-insert-file-contents-function
     この変数の値は、そのバッファーをリバートする際に、
     更新されたコンテンツの挿入に使用される関数を指定す
     る。その関数は、2つの引数をとる。1つ目は使用するフ
     ァイル名で、2つ目が‘t’ならユーザーはauto-saveファイ
     ルの読み込みにたいして確認を求められる。

     ‘revert-buffer-function’のかわりにこの変数をモード
     が変更する理由は、‘revert-buffer’が行残りの処理(ユ
     ーザーへの確認、アンドゥリストのクリアー、適切なメ
     ジャーモードの決定、以下のフックの実行)にたいする重
     複や置き換えを避けるためである。

 -- Variable: before-revert-hook
     このノーマルフックは、変更されたコンテンツを挿入す
     る前に、デフォルトの‘revert-buffer-function’により
     実行される。カスタマイズした
     ‘revert-buffer-function’は、このフックを実行するか
     どうか判らない。

 -- Variable: after-revert-hook
     このノーマルフックは、変更されたコンテンツを挿入し
     た後に、デフォルトの‘revert-buffer-function’により
     実行される。カスタマイズした
     ‘revert-buffer-function’は、このフックを実行するか
     どうか判らない。

 -- Variable: buffer-stale-function
     この変数の値は、バッファーがリバートを要するかどう
     かをチェックするために呼び出される関数を指定する。
     デフォルト値は、修正時刻をチェックすることにより、
     ファイルをvisitするバッファーだけを処理する。ファイ
     ルをvisitしないバッファーには、カスタム関数が必要に
     なる (*note (emacs)Supporting additional buffers::を
     参照)。


File: elisp,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto-Saving,  Up: Top

26 Buffers
**********

“バッファー(buffer)”とは、編集されるテキストを含むLispオ
ブジェクトのことです。バッファーは、visitされるファイル
のコンテンツを保持するために使用されます。しかし、ファイ
ルをvisitしないバッファーも存在するかもしれません。一度
に複数のバッファーが存在するかもしれませんが、“カレント
バッファー(current buffer)”に指定できるのは、常に1つのバ
ッファーだけです。ほとんどの編集コマンドは、カレントバッ
ファーのコンテンツにたいして作用します。カレントバッファ
ーを含むすべてのバッファーは、任意のウィンドウ内に表示さ
れるときも、表示されない場合もあります。

* Menu:

* Buffer Basics::            バッファーとは?
* Current Buffer::           バッファーをカレントに指定することにより、プリミティブはバッファーのコンテンツにアクセスする。
* Buffer Names::             バッファー名にたいするアクセスと変更。
* Buffer File Name::         バッファーファイル名は、どのファイルをvisitしているかを示す。
* Buffer Modification::      保存が必要なら、バッファーは“変更されている(modified)”。
* Modification Time::        "Emacsの裏"でvisitされているファイルが変更されたかどうかを判断する。
* Read Only Buffers::        読み取り専用バッファーでのテキスト変更は許されない。
* Buffer List::              すべての既存バッファーを閲覧する方法。
* Creating Buffers::         バッファーを作成する関数。
* Killing Buffers::          明示的にkillされるまで、バッファーは存在する。
* Indirect Buffers::         インダイレクトバッファーは、他のバッファーとテキストを共有する。
* Swapping Text::            2つのバッファー間でのテキストの交換。
* Buffer Gap::               バッファー内のギャップ。


File: elisp,  Node: Buffer Basics,  Next: Current Buffer,  Up: Buffers

26.1 Buffer Basics
==================

“バッファー(buffer)”とは、編集されるテキストを含むLispオ
ブジェクトのことです。バッファーは、visitされるファイル
のコンテンツを保持するために使用されます。しかし、ファイ
ルをvisitしないバッファーも存在します。一度に複数のバッ
ファーが存在するかもしれませんが、“カレントバッファー
(current buffer)”に指定できるのは、常に1つのバッファーだ
けです。ほとんどの編集コマンドは、カレントバッファーのコ
ンテンツにたいして作用します。カレントバッファーを含むす
べてのバッファーは、任意のウィンドウ内に表示されるときも
、表示されない場合もあります。

   Emacs編集におけるバッファーは、個別に名前をもち、編集
可能なテキストを保持するオブジェクトです。Lispプログラム
にたいして、バッファーはスペシャルデータ型として表されま
す。バッファーのコンテンツを、拡張可能な文字列と考えるこ
とができます。挿入と削除は、バッファー内の任意の箇所で発
生し得ます。*note Text::を参照してください。

   Lispのバッファーオブジェクトは、多くの情報要素を含ん
でいます。これらの情報のいくつかは変数を通じてプログラマ
ーが直接アクセスできるのにたいして、その他の情報は特殊な
目的のための関数を通じてのみアクセスすることができます。
たとえば、visitされているファイルの名前は変数を通じて直
接アクセスできますが、ポイント値はプリミティブ関数からの
みアクセスできます。

   直接アクセス可能な、バッファー固有の情報は、“バッファ
ーローカル(buffer-local)”な変数バインディング内に格納さ
れます。これは、特定のバッファー内だけで効力のある変数値
のことです。この機能により、それぞれのバッファーは、特定
の変数の値をオーバーライドすることができます。ほとんどの
メジャーモードは、この方法で‘fill-column’や
‘comment-column’のような変数をオーバーライドしています。
バッファーローカルな変数、およびそれらに関連する関数につ
いての詳細は、*note Buffer-Local Variables::を参照してく
ださい。

   バッファーからファイルをvisitする関数および変数につい
ては、*note Visiting Files::、および*note Saving
Buffers::を参照してください。ウィンドウ内へのバッファー
表示に関連する関数および変数については、*note Buffers
and Windows::を参照してください。

 -- Function: bufferp object
     この関数は、OBJECTがバッファーなら‘t’、それ以外は
     ‘nil’をリターンする。


File: elisp,  Node: Current Buffer,  Next: Buffer Names,  Prev: Buffer Basics,  Up: Buffers

26.2 The Current Buffer
=======================

一般的に、1つのEmacsセッション内には、多くのバッファーが
存在します。常に、それらのうちの1つが“カレントバッファー
(current buffer)”に指定され、ます。カレントバッファーと
は、ほとんどの編集が行われるバッファーのことです。テキス
トを調べたり変更するプリミティブのほとんどは、暗黙的にカ
レントバッファーにたいして処理を行います(*note Text::を
参照)。

   通常は、選択されたウィンドウ内に表示されるバッファー
がカレントバッファーですが、常にそうではありません。
Lispプログラムは、バッファーのコンテンツを処理するために
、スクリーン上に表示されているものを変更することなく、任
意のバッファーを一時的にカレントに指定できます。カレント
バッファーの指定にたいしてもっとも基本的な関数は、
‘set-buffer’です。

 -- Function: current-buffer
     この関数は、カレントバッファーをリターンする関数。

          (current-buffer)
               ⇒ #<buffer buffers.texi>

 -- Function: set-buffer buffer-or-name
     この関数は、BUFFER-OR-NAMEをカレントバッファーにす
     る。BUFFER-OR-NAMEは既存のバッファー、または既存の
     バッファーの名前でなければならない。リターン値は、
     カレントになったバッファーである。

     この関数は、そのバッファーをどのウィンドウにも表示
     しないので、必然的にユーザーはそのバッファーを見る
     ことはできない。しかし、Lispプログラムはその後、そ
     のバッファーにたいして処理を行うことになるだろう。

   編集コマンドがエディターコマンドループにリターンする
際、Emacsは選択されたウィンドウ内に表示されているバッフ
ァーにたいして、自動的に‘set-buffer’を呼び出します。これ
は混乱を防ぐためで、これにより、Emacsがコマンドを読み取
るときに、カーソルのあるバッファーが、コマンドを適用され
るバッファーになるのが保証されます(*note Command Loop::を
参照)。したがって、異なるバッファーを指示して切り替える
場合に、‘set-buffer’を使用するべきではありません。これを
行うためには、*note Switching Buffers::で説明されている
カを使用してください。

   Lisp関数を記述する際は、処理後にカレントバッファーを
リストアするために、コマンドループのこの振る舞いに_依存
しないでください_。編集コマンドは、コマンドループだけで
はなく、他のプログラムからLisp関数としても呼び出されます
。呼び出し側にとっては、そのサブルーチンがカレントだった
バッファーを変更しないほうが便利です(もちろん、それがサ
ブルーチンの目的でない場合ですが)。

   他のバッファーにたいして一時的に処理を行うには、
‘save-current-buffer’フォーム内に‘set-buffer’を置きます
。以下の例は、コマンド‘append-to-buffer’の簡略版です:

     (defun append-to-buffer (buffer start end)
       "リージョンのテキストをBUFFERに追加する"
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-current-buffer
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

ここでは、カレントバッファーを記録するためにローカル変数
にバインドしてから、後で‘save-current-buffer’がそれを再
びカレントにするよう、取り計らっています。次に、
‘set-buffer’が指定されたバッファーをカレントにして、
‘insert-buffer-substring’が元のバッファーの文字列を、指
定された(今はカレントの)バッファーにコピーします。

   かわりに、‘with-current-buffer’マクロを使用することも
できます:

     (defun append-to-buffer (buffer start end)
       "BUFFERにリージョンのテキストを追加する"
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (with-current-buffer (get-buffer-create buffer)
           (insert-buffer-substring oldbuf start end))))

   どちらの場合でも、追加されるバッファーが偶然他のウィ
ンドウに表示されていた場合には、次回の再表示でそのテキス
トがどのように変更されたか表示されるでしょう。どのウィン
ドウにも表示されていない場合には、スクリーン上で即座に変
更を目にすることはありません。コマンドはバッファーを一時
的にカレントにしますが、そのことがバッファーの表示を誘因
する訳ではありません。

   バッファーローカルバインディングをもつ変数にたいして
、(‘let’や関数引数などで)ローカルバインディングを作成す
る場合は、そのローカルバインディングのスコープの最初と最
後で、同じバッファーがカレントとなることを確認してくださ
い。そうしないと、あるバッファーではバインドして、他のバ
ッファーではバインドされないことになるかもしれません!

   ‘set-buffer’の使用において、カレントバッファーが戻る
ことに依存しないでください。なぜなら、間違ったバッファー
がカレントのときにquitが発生した場合、その処理は行われな
いでしょう。たとえば上記の例に倣うと、以下は間違ったやり
方です:

       (let ((oldbuf (current-buffer)))
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end)
         (set-buffer oldbuf))

例で示したように‘save-current-buffer’、または
‘with-current-buffer’を使用すれば、quitや‘throw’を、通常
の評価と同様に処理できます。

 -- Special Form: save-current-buffer body...
     スペシャルフォーム‘save-current-buffer’は、カレント
     バッファーの識別を保存して、BODYフォームを評価し、
     最後にそのバッファーをカレントにリストアする。リタ
     ーン値は、BODY内の最後のフォームの値である。
     ‘throw’やエラーを通じた異常exitの場合でも、カレント
     バッファーはリストアされる(*note Nonlocal Exits::を
     参照)。

     カレントとして使用されていたバッファーが、
     ‘save-current-buffer’によるexit時にkillされていた場
     合は、それが再びカレントとなることは当然ない。かわ
     りに、exit直前にカレントバッファーが何であれ、それ
     がカレントになる。

 -- Macro: with-current-buffer buffer-or-name body...
     ‘with-current-buffer’マクロは、カレントバッファーの
     識別を保存して、BUFFER-OR-NAMEをカレントにし、
     BODYフォームを評価して、最後にカレントバッファーを
     リストアする。BUFFER-OR-NAMEには既存のバッファー、
     または既存のバッファー名を指定しなければならない。

     リターン値は、BODY内の最後のフォームの値である。
     ‘throw’やエラーを通じた異常exitの場合でも、カレント
     バッファーはリストアされる(*note Nonlocal Exits::を
     参照)。

 -- Macro: with-temp-buffer body...
     ‘with-temp-buffer’マクロは、一時的なバッファーをカ
     レントバッファーとして、BODYフォームを評価する。こ
     れはカレントバッファーの識別を保存して、一時的なバ
     ッファーを作成、それをカレントとして、BODYフォーム
     を評価し、一時バッファーをkillする間に、以前のカレ
     ントバッファーをリストアする。 デフォルトでは、この
     マクロにより作成されたバッファー内のアンドゥ情報
     (*note Undo::を参照)は記録されない(が、必要なら
     BODYでそれを有効にできる)。

     リターン値は、BODY内の最後のフォームの値である。最
     後のフォームとして‘(buffer-string)’を使用することに
     より、一時バッファーのコンテンツをリターンできる。

     ‘throw’やエラーを通じた異常exitの場合でも、カレント
     バッファーはリストアされる(*note Nonlocal Exits::を
     参照)。

     *note Writing to Files: Definition of
     with-temp-file.の‘with-temp-file’も参照されたい。


File: elisp,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Current Buffer,  Up: Buffers

26.3 Buffer Names
=================

それぞれのバッファーは、文字列で表される一意な名前をもち
ます。バッファーにたいして機能する関数の多くは、引数とし
てバッファーとバッファー名の両方を受け入れます。
BUFFER-OR-NAMEという名前の引数がこのタイプで、それが文字
列でもバッファーでもない場合は、エラーがシグナルされます
。BUFFERという名前の引数は、名前ではなく実際のバッファー
オブジェクトでなければなりません。

   短命でユーザーが関心をもたないようなバッファーは名前
がスペースで始まり、それらについては‘list-buffers’および
‘buffer-menu’コマンドは無視します(が、ファイルをvisitし
ているようなバッファーは*無視されない*)。スペースで始ま
る名前は、初期状態ではアンドゥ情報の記録も無効になってい
ます。*note Undo::を参照してください。

 -- Function: buffer-name &optional buffer
     この関数は、BUFFERの名前を文字列としてリターンする
     。BUFFERのデフォルトは、カレントバッファーである。

     ‘buffer-name’が‘nil’をリターンした場合、それは
     BUFFERがkillされていることを意味する。*note Killing
     Buffers::を参照のこと。

          (buffer-name)
               ⇒ "buffers.texi"

          (setq foo (get-buffer "temp"))
               ⇒ #<buffer temp>
          (kill-buffer foo)
               ⇒ nil
          (buffer-name foo)
               ⇒ nil
          foo
               ⇒ #<killed buffer>

 -- Command: rename-buffer newname &optional unique
     この関数は、カレントバッファーをNEWNAMEにリネームす
     る。NEWNAMEが文字列でない場合は、エラーをシグナルす
     る。

     NEWNAMEがすでに使用済みの場合、‘rename-buffer’は通
     常はエラーをシグナルする。しかし、UNIQUEが非‘nil’の
     場合は、未使用の名前となるようにNEWNAMEを変更する。
     interactiveに呼び出した場合は、プレフィックス数引数
     によりUNIQUEに非‘nil’を指定できる(この方法により、
     コマンド‘rename-uniquely’は実装される)。

     この関数は、実際にバッファーに与えられた名前をリタ
     ーンする。

 -- Function: get-buffer buffer-or-name
     この関数は、BUFFER-OR-NAMEで指定されたバッファーを
     リターンする。BUFFER-OR-NAMEが文字列で、かつそのよ
     うな名前のバッファーが存在しない場合、値は‘nil’にな
     る。BUFFER-OR-NAMEがバッファーの場合は、与えられた
     バッファーをリターンする。これは有用とは言い難く、
     引数は通常は名前である。たとえば:

          (setq b (get-buffer "lewis"))
               ⇒ #<buffer lewis>
          (get-buffer b)
               ⇒ #<buffer lewis>
          (get-buffer "Frazzle-nots")
               ⇒ nil

     *note Creating Buffers::の関数‘get-buffer-create’も
     参照のこと。

 -- Function: generate-new-buffer-name starting-name
          &optional ignore
     この関数は、新たなバッファーにたいして一意となるよ
     うな名前をリターンする — が、バッファーは作成しない
     。この名前はSTARTING-NAMEで始まり、内部が数字である
     ような‘<...>’を追加することにより、すべてのバッファ
     ーでカレントで使用されていない名前を生成する。この
     数字は2で始まり、既存バッファーの名前でない名前にな
     る数字まで増加される。

     オプション引数IGNOREが非‘nil’の場合、それは潜在的に
     バッファー名であるような文字列であること。これは、
     たとえそれが(通常は拒絶されるであろう)既存バッファ
     ーの名前であっても、試みられた場合は、潜在的に受容
     可能なバッファーとして考慮することを意味する。つま
     り‘foo’、‘foo<2>’、‘foo<3>’、‘foo<4>’という名前のバ
     ッファーが存在する場合、

          (generate-new-buffer-name "foo")
               ⇒ "foo<5>"
          (generate-new-buffer-name "foo" "foo<3>")
               ⇒ "foo<3>"
          (generate-new-buffer-name "foo" "foo<6>")
               ⇒ "foo<5>"

     *note Creating Buffers::の関連する関数
     ‘generate-new-buffer’も参照のこと。


File: elisp,  Node: Buffer File Name,  Next: Buffer Modification,  Prev: Buffer Names,  Up: Buffers

26.4 Buffer File Name
=====================

“バッファーファイル名(buffer file name)”とは、そのバッフ
ァーにvisitされているファイルの名前です。バッファーがフ
ァイルをvisiblyしていなければ、バッファーファイル名は
‘nil’です。大抵、バッファー名はバッファーファイル名の非
ディレクトリーパートと同じですが、バッファーファイル名と
バッファー名は別物であり、個別にセットすることができます
。*note Visiting Files::を参照してください。

 -- Function: buffer-file-name &optional buffer
     この関数は、BUFFERがvisitしているファイルの、絶対フ
     ァイル名をリターンする。BUFFERがファイルをvisitして
     いない場合、‘buffer-file-name’は‘nil’をリターンする
     。BUFFERが与えられない場合のデフォルトは、カレント
     バッファーになる。

          (buffer-file-name (other-buffer))
               ⇒ "/usr/user/lewis/manual/files.texi"

 -- Variable: buffer-file-name
     このバッファーローカル変数は、カレントバッファーに
     visitされているファイルの名前、ファイルをvisitして
     いなければ‘nil’が含まれる。これは永続的なローカル変
     数であり、‘kill-all-local-variables’の影響を受けな
     い。

          buffer-file-name
               ⇒ "/usr/user/lewis/manual/buffers.texi"

     他のさまざまな事項を変更せずに、この変数を変更する
     のは危険である。通常は、‘set-visited-file-name’を使
     用するほうがよい(以下参照)。バッファー名の変更など
     のような、そこで行われることのいくつかは、絶対必要
     という訳ではないが、その他の事項はEmacsが混乱するの
     を防ぐために必要不可欠である。

 -- Variable: buffer-file-truename
     このバッファーローカル変数は、カレントバッファーに
     visitされているファイルの省略された形式の実名
     (truename)、ファイルをvisitしていない場合は‘nil’を
     保持する。これは永続的にローカルであり、
     ‘kill-all-local-variables’の影響を受けない。*Note
     Truenames::、および*note abbreviate-file-name::を参
     照のこと。

 -- Variable: buffer-file-number
     このバッファーローカル変数は、カレントバッファーに
     visitされているファイルのファイル番号(file number)と
     デバイス番号(device number)、ファイルをvisitしてい
     ない場合は‘nil’を保持する。これは永続的にローカルで
     あり、‘kill-all-local-variables’の影響を受けない。

     値は通常、‘(FILENUM DEVNUM)’のような形式のリストで
     ある。この番号ペアーは、システム上でアクセス可能な
     すべてのファイルの中から、ファイルを一意に識別する
     。より詳細な情報は、*note File Attributes::の
     ‘file-attributes’を参照のこと。

     ‘buffer-file-name’がシンボリックリンク名の場合は、
     どちらの番号も再帰的なターゲットを参照する。

 -- Function: get-file-buffer filename
     この関数は、ファイルFILENAMEをvisitしているバッファ
     ーをリターンする。そのようなバッファーが存在しない
     場合は、‘nil’をリターンする。引数FILENAMEは文字列で
     なければならず、展開(*note File Name Expansion::を
     参照)された後、killされていないすべてのバッファーが
     visitしているファイル名と比較される。バッファーの
     ‘buffer-file-name’は、FILENAMEの展開形と正確にマッ
     チしなければならないことに注意。この関数は、同じフ
     ァイルにたいする他の名前は、認識しないだろう。

          (get-file-buffer "buffers.texi")
              ⇒ #<buffer buffers.texi>

     特殊な状況下では、複数のバッファーが同じファイル名
     をvisitすることがあり得る。そのような場合、この関数
     はバッファーリスト内の最初に該当するバッファーをリ
     ターンする。

 -- Function: find-buffer-visiting filename &optional
          predicate
     これは‘get-file-buffer’と似ているが、そのファイルを
     _違う名前_でvisitしているかもしれないすべてのバッフ
     ァーをリターンする。つまり、バッファーの
     ‘buffer-file-name’はFILENAMEの展開形式と正確にマッ
     チする必要はなく、同じファイルを参照することだけが
     要求される。PREDICATEが非‘nil’の場合、それは
     FILENAMEをvisitしているバッファーを1つの引数とする
     関数であること。そのバッファーにたいして、
     PREDICATEが非‘nil’をリターンした場合のみ、適切なリ
     ターン値と判断される。リターンすべき適切なバッファ
     ーが見つからない場合、‘find-buffer-visiting’は
     ‘nil’をリターンする。

 -- Command: set-visited-file-name filename &optional
          no-query along-with-file
     FILENAMEが非空文字列の場合、この関数はカレントバッ
     ファーにvisitされているファイルの名前を、FILENAMEに
     変更する(バッファーがファイルをvisitしていない場合
     は、visitするファイルとしてFILENAMEを与える)。その
     バッファーにたいする_次回_の保存では、新たに指定さ
     れたファイルに保存されるだろう。

     このコマンドは、たとえそのバッファーのコンテンツが
     その前にvisitされていたファイルとマッチしていても、
     (Emacsが関知するかぎり)FILENAMEのコンテンツとはマッ
     チしないので、バッファーが変更されている
     (modified)とマークする。これは、その名前がすでに使
     用されていなければ、新たなファイル名に対応してバッ
     ファーをリネームする。

     FILENAMEが‘nil’、または空文字列の場合、それは
     “visitされているファイルがない”ことを意味する。この
     場合、‘set-visited-file-name’はバッファーの変更フラ
     グを変更することなく、そのバッファーがファイルを
     visitしていないとマークする。

     この関数はFILENAMEをvisitしているバッファーがすでに
     存在する場合は、通常はユーザーに確認を求める。しか
     し、NO-QUERYが非‘nil’の場合は、この質問を行わない。
     FILENAMEをvisitしているバッファーがすでに存在し、か
     つユーザーが承認、またはNO-QUERYが非‘nil’の場合、こ
     の関数は中に数字が入った‘<...>’をFILENAMEに追加して
     、新たなバッファーの名前を一意にする。

     ALONG-WITH-FILEが非‘nil’の場合、それは前にvisitされ
     ていたファイルがFILENAMEにリネームされたと想定する
     ことを意味する。この場合、コマンドはバッファーの修
     正フラグを変更せず、そのバッファーの記録されている
     最終ファイル変更時刻を‘visited-file-modtime’が報告
     する時刻(*note Modification Time::を参照)で変更もし
     ない。ALONG-WITH-FILEが‘nil’の場合、この関数は
     ‘visited-file-modtime’が0をリターンした後に、記録済
     みの最終ファイル変更時刻をクリアーする。

     関数‘set-visited-file-name’がinteractiveに呼び出さ
     れたときは、ミニバッファー内でFILENAMEの入力を求め
     る。

 -- Variable: list-buffers-directory
     このバッファーローカル変数は、visitしているファイル
     名をもたないバッファーにたいして、バッファーリスト
     中のvisitしているファイル名を表示する場所に表示する
     文字列を指定する。Diredバッファーは、この変数を使用
     する。

