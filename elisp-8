This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: Buffer List,  Up: Buffers

26.9 Creating Buffers
=====================

このセクションでは、バッファーを作成する2つのプリミティブについて説明し
ます。‘get-buffer-create’は、指定された名前の既存バッファーが見つからな
い場合は作成します。‘generate-new-buffer’は、常に新たにバッファーを作成
して、それに一意な名前を与えます。

   バッファーを作成するために使用できる他の関数には、
‘with-output-to-temp-buffer’(*note Temporary Displays::を参照)、および
‘create-file-buffer’(*note Visiting Files::を参照)が含まれます。サブプロ
セスの開始によっても、バッファーを作成することができます(*note
Processes::を参照)。

 -- Function: get-buffer-create buffer-or-name
     この関数は、BUFFER-OR-NAMEという名前のバッファーをリターンする。リ
     ターンされたバッファーはカレントにならない — この関数はカレントがど
     のバッファーであるかを変更しない。

     BUFFER-OR-NAMEは文字列、または既存バッファーのいずれかでなければな
     らない。これが文字列で、かつ既存の生きたバッファーの名前の場合、
     ‘get-buffer-create’はそのバッファーをリターンする。そのようなバッフ
     ァーが存在しなければ、新たにバッファーを作成する。BUFFER-OR-NAMEが
     文字列ではなくバッファーの場合、たとえそのバッファーが生きていなく
     ても、与えられたバッファーをリターンする。

          (get-buffer-create "foo")
               ⇒ #<buffer foo>

     新たに作成されたバッファーにたいするメジャーモードは、Fundamentalモ
     ードにセットされる(変数‘major-mode’のデフォルト値は、より高いレベル
     で処理される。*note Auto Major Mode::を参照されたい)。名前がスペー
     スで始まる場合、そのバッファーのアンドゥ情報の記録は、初期状態では
     無効である(*note Undo::を参照)。

 -- Function: generate-new-buffer name
     この関数は、新たに空のバッファーを作成してリターンするが、それをカ
     レントにはしない。バッファーの名前は、関数
     ‘generate-new-buffer-name’にNAMEを渡すことにより生成される(*note
     Buffer Names::を参照)。つまり、NAMEという名前のバッファーが存在しな
     ければ、それが新たなバッファーの名前になり、その名前が使用されてい
     た場合は、‘<N>’という形式のサフィックスがNAMEに追加される。ここで
     Nは整数である。

     NAMEが文字列でない場合は、エラーがシグナルされる。

          (generate-new-buffer "bar")
               ⇒ #<buffer bar>
          (generate-new-buffer "bar")
               ⇒ #<buffer bar<2>>
          (generate-new-buffer "bar")
               ⇒ #<buffer bar<3>>

     新たなバッファーにたいするメジャーモードは、Fundamentalモードにセッ
     トされる。変数‘major-mode’のデフォルト値は、より高いレベルで処理さ
     れる。*note Auto Major Mode::を参照のこと。


File: elisp,  Node: Killing Buffers,  Next: Indirect Buffers,  Prev: Creating Buffers,  Up: Buffers

26.10 Killing Buffers
=====================

“バッファーのkill”により、 そのバッファーの名前はEmacsにとって未知の名前
となり、そのバッファーが占めていたメモリースペースは、他の用途に使用でき
るようになります。

   バッファーに対応するバッファーオブジェクトは、それを参照するものがあ
ればkillされても存在し続けますが、それをカレントにしたり表示することがで
きないよう、特別にマークされます。とはいえ、killされたバッファーの同一性
は保たれるので、2つの識別可能なバッファーをkillした場合、たとえ両方死ん
だバッファーであっても、‘eq’による同一性は残ります。

   あるウィンドウ内においてカレント、あるいは表示されているバッファーを
killした場合、Emacsはかわりに他の何らかのバッファーを自動的に選択、また
は表示します。これは、バッファーのkillにより、カレントバッファーが変更さ
れることを意味します。したがって、バッファーをkillする際は、(killされる
バッファーがカレントを偶然知っていた場合を除き)カレントバッファーの変更
に関しても、事前に注意を払うべきです。*note Current Buffer::を参照してく
ださい。

   1つ以上のインダイレクト バッファー(*note Indirect Buffers::を参照) の
ベースとなるバッファーをkillした場合は、インダイレクトバッファーも同様に
自動的にkillされます。

   バッファーの‘buffer-name’が‘nil’の場合のみ、バッファーはkillされる。
killされていないバッファーは“生きた(live)”バッファーと呼ばれる。あるバッ
ファーにたいして、そのバッファーが生きているか、またはkillされているかを
確認するには、‘buffer-live-p’を使用する(下記参照)。

 -- Command: kill-buffer &optional buffer-or-name
     この関数は、バッファーBUFFER-OR-NAMEをkillして、そのバッファーのメ
     モリーを他の用途のために開放、またはオペレーティングシステムに返却
     する。BUFFER-OR-NAMEが‘nil’、または省略された場合は、カレントバッフ
     ァーをkillする。

     そのバッファーを‘process-buffer’として所有するすべてのプロセスには
     、通常はプロセスを終了させるシグナル‘SIGHUP’(“hangup”)が送信される
     。*note Signals to Processes::を参照のこと。

     バッファーがファイルをvisitしていて、かつ保存されていない変更が含ま
     れる場合、‘kill-buffer’はバッファーをkillする前に、ユーザーにたいし
     て確認を求める。これは、‘kill-buffer’がinteractiveに呼び出されてい
     なくても、行われる。この確認要求を抑制するには、‘kill-buffer’の呼び
     出し前に、変更フラグ(modified flag)をクリアーすればよい。*note
     Buffer Modification::を参照のこと。

     killされるバッファーをカレントで表示しているすべてのバッファーをク
     リーンアップするために、この関数は‘replace-buffer-in-windows’を呼び
     出す。

     すでに死んでいるバッファーをkillしても、効果はない。

     この関数は、実際にバッファーをkillした場合は、‘t’をリターンする。ユ
     ーザーが確認で拒否を選択、またはBUFFER-OR-NAMEがすでに死んでいる場
     合は、‘nil’をリターンする。

          (kill-buffer "foo.unchanged")
               ⇒ t
          (kill-buffer "foo.changed")

          ---------- Buffer: Minibuffer ----------
          Buffer foo.changed modified; kill anyway? (yes or no) yes
          ---------- Buffer: Minibuffer ----------

               ⇒ t

 -- Variable: kill-buffer-query-functions
     保存されていない変更について確認を求める前に、‘kill-buffer’はリスト
     ‘kill-buffer-query-functions’内の関数を、出現順に引数なしで呼び出す
     。 Before confirming unsaved changes, calls the functions in the
     list , in order of appearance, with no arguments. それらが呼び出さ
     れる際には、killされるバッファーがカレントになる。この機能は、これ
     らの関数がユーザーに確認を求めるというアイデアが元となっている。こ
     れらの関数のいずれかが‘nil’をリターンした場合、‘kill-buffer’はその
     バッファーの命を奪わない。

 -- Variable: kill-buffer-hook
     これは、尋ねることになっている質問をすべて終えた後、実際にバッファ
     ーをkillする直前に、‘kill-buffer’により実行されるノーマルフックであ
     る。この変数は永続的にローカルであり、メジャーモードの変更により、
     そのローカルバインディングはクリアーされない。

 -- User Option: buffer-offer-save
     特定のバッファーにおいてこの変数が非‘nil’の場合、
     ‘save-buffers-kill-emacs’および‘save-some-buffers’(この関数の2つ目
     のオプション引数が‘t’の場合)は、ファイルをvisitしているバッファーと
     同じように、そのバッファーの保存を提案する。*note Definition of
     save-some-buffers::を参照のこと。何らかの理由により変数
     ‘buffer-offer-save’をセットする際は、自動的にバッファーローカルにな
     る。*note Buffer-Local Variables::を参照のこと。

 -- Variable: buffer-save-without-query
     特定のバッファーにおいてこの変数が非‘nil’の場合、
     ‘save-buffers-kill-emacs’および‘save-some-buffers’は、(バッファーが
     変更されていれば)ユーザーに確認を求めることなく、そのバッファーを保
     存する。何らかの理由によりこの変数をセットする際は、自動的にバッフ
     ァーローカルになる。

 -- Function: buffer-live-p object
     この関数は、OBJECTが生きたバッファー(killされていないバッファー)な
     ら‘t’、それ以外は‘nil’をリターンする。


File: elisp,  Node: Indirect Buffers,  Next: Swapping Text,  Prev: Killing Buffers,  Up: Buffers

26.11 Indirect Buffers
======================

“インダイレクトバッファー(indirect buffer: 間接バッファー)”とは、“ベース
バッファー(base buffer)”と呼ばれる他のバッファーとテキストを共有します。
いくつかの点において、インダイレクトバッファーはファイル間でのシンボリッ
クリンクに類似しています。ベースバッファー自身は、インダイレクトバッファ
ーでない可能性があります。

   インダイレクトバッファーのテキストは、常にベースバッファーのテキスト
と同一です。編集により一方が変更されると、それは即座に他方のバッファーか
ら可視になります。これには文字自体に加えて、テキストプロパティも同様に含
まれます。

   他のすべての観点において、インダイレクトバッファーとそのベースバッフ
ァーは、完全に別物です。それらは別の名前、独自のポイント値、ナローイング
、マーカー、オーバーレイ、メジャーモード、バッファーローカルな変数バイン
ディングをもちます(ただし、どちらかのバッファーでのテキストの挿入や削除
を行うと、両方のバッファーでマーカーとオーバーレイの再配置が行われる)。

   インダイレクトバッファーはファイルをvisitできませんが、ベースバッファ
ーは可能です。インダイレクトバッファーの保存を試みた場合、実際にはベース
バッファーが保存されます。

   インダイレクトバッファーをkillしても、ベースバッファーに影響はありま
せん。ベースバッファーをkillすると、インダイレクトバッファーはkillされて
、再びカレントバッファーになることはできません。

 -- Command: make-indirect-buffer base-buffer name &optional clone
     これは、ベースバッファーがBASE-BUFFERであるような、NAMEという名前の
     インダイレクトバッファーを作成してリターンする。引数BASE-BUFFERは生
     きたバッファー、または既存バッファーの名前(文字列)を指定できる。
     NAMEが既存バッファーの名前の場合は、エラーがシグナルされる。

     CLONEが非‘nil’の場合、インダイレクトバッファーは最初はBASE-BUFFERの
     メジャーモード、マイナーモード、バッファーローカル変数等の“状態”を
     共有する。CLONEが省略、または‘nil’の場合、インダイレクトバッファー
     の情報は、新たなバッファーにたいするデフォルト状態にセットされる。

     BASE-BUFFERがインダイレクトバッファーの場合は、新たなバッファーのベ
     ースとして、それのベースバッファーが使用される。さらに、CLONEが非
     ‘nil’ならば、初期状態はBASE-BUFFERではなく、実際のベースバッファー
     からコピーされる。

 -- Command: clone-indirect-buffer newname display-flag &optional
          norecord
     この関数は、カレントバッファーのベースバッファーを共有するインダイ
     レクトバッファーを新たに作成し、カレントバッファーの残りの属性をコ
     ピーしてリターンする(カレントバッファーがインダイレクトバッファーで
     ない場合は、それがベースバッファーとして使用される)。

     DISPLAY-FLAGが非‘nil’の場合、それは‘pop-to-buffer’を呼び出すことに
     より新しいバッファーを表示することを意味する。NORECORDが非‘nil’の場
     合、それは新しいバッファーをバッファーリストの先頭に置かないことを
     意味する。

 -- Function: buffer-base-buffer &optional buffer
     この関数は、BUFFER(デフォルトはカレントバッファー)のベースバッファ
     ーをリターンする。BUFFERがインダイレクトバッファーでない場合、値は
     ‘nil’になり、それ以外では値は他のバッファーとなり、このバッファーが
     インダイレクトバッファーではあり得ない。


File: elisp,  Node: Swapping Text,  Next: Buffer Gap,  Prev: Indirect Buffers,  Up: Buffers

26.12 Swapping Text Between Two Buffers
=======================================

特別なモードでは、ユーザーが同一のバッファーから複数の非常に異なったテキ
ストにアクセスできるようにしなければならない場合があります。たとえば、バ
ッファーのテキストのサマリーを表示して、ユーザーがそのテキストにアクセス
できるようにする場合です。

   これは、(ユーザーがテキストを編集した際には同期を保つ)複数バッファー
や、ナローイング(*note Narrowing::を参照)により実装することができるかも
しれません。しかし、これらの候補案はときに退屈になりがちであり、特にそれ
ぞれのテキストタイプが正しい表示と編集コマンドを提供するために高価なバッ
ファーグローバル操作を要求する場合には、飛び抜けて高価になる場合がありま
す。

   Emacsは、そのようなモードにたいする、別の機能を提供します。
‘buffer-swap-text’を使用すれば、2つのバッファー間でバッファーテキストを
素早く交換することができます。この関数は、テキストの移動は行わず、異なる
テキスト塊(text chunk)をポイントするように、バッファーオブジェクトの内部
的なデータ構造だけを変更するので、非常に高速です。これを使用することによ
り、2つ以上のバッファーグループから、個々のバッファーのコンテンツすべて
を併せもつような、単一の仮想バッファー(virtual buffer)が実在するように、
見せかけることができます。

 -- Function: buffer-swap-text buffer
     この関数は、カレントバッファーのテキストと、引数BUFFERのテキストを
     交換する。2つのバッファーのいずれか一方がインダイレクトバッファー
     (*note Indirect Buffers::を参照)、またはインダイレクトバッファーの
     ベースバッファーの場合は、エラーをシグナルする。

     バッファーテキストに関連するすべてのバッファープロパティ、つまりポ
     イントとマークの位置、すべてのマーカーとオーバーレイ、テキストプロ
     パティ、アンドゥリスト、‘enable-multibyte-characters’フラグの値
     (*note enable-multibyte-characters: Text Representations.を参照)等
     も、同じように交換される。

   ファイルをvisitしているバッファーに‘buffer-swap-text’を使用した場合は
、交換されたテキストではなく、そのバッファーの元のテキストを保存するよう
にフックをセットアップするべきです。‘write-region-annotate-functions’は
、正にこの目的のために機能します。そのバッファーの‘buffer-saved-size’を
、おそらく交換されたテキストにたいする変更が自動保存に干渉しないであろう
、−2にセットするべきでしょう。


File: elisp,  Node: Buffer Gap,  Prev: Swapping Text,  Up: Buffers

26.13 The Buffer Gap
====================

Emacsのバッファーは、挿入と削除を高速にするために、不可視の“ギャップ
(gap)”を使用して実装されています。挿入はギャップ部分を充填し、削除はギャ
ップを追加することにより機能します。もちろん、これは最初にギャップを挿入
もしくは削除の部位(locus)に移動しなければならないことを意味します。
Emacsは、ユーザーが挿入、または削除を試みたときだけ、ギャップを移動しま
す。大きなバッファー内の遠く離れた位置で編集した後、他の箇所での最初の編
集コマンドに無視できない遅延が発生する場合があるのは、これが理由です。

   このメカニズムは暗に機能するものであり、Lispコードはギャップのカレン
ト位置に影響されるべきでは決してありませんが、以下の関数はギャップ状態に
関する情報の取得に利用できます。

 -- Function: gap-position
     この関数は、カレントバッファー内のギャップのカレント位置をリターン
     する。

 -- Function: gap-size
     この関数は、カレントバッファー内のギャップのサイズをリターンする。


File: elisp,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

27 Windows
**********

このチャプターでは、Emacsのウィンドウに関連する関数と変数について説明し
ます。Emacsが利用可能なスクリーン領域にウィンドウが割り当てられる方法に
ついては、*note Frames::を参照してください。ウィンドウ内にテキストが表示
される方法についての情報は、*note Display::を参照してください。

* Menu:

* Basic Windows::            ウィンドウ使用についての基本情報。
* Windows and Frames::       ウィンドウとそれらが表示されるフレームとの関連。
* Window Sizes::             ウィンドウのサイズへのアクセス。
* Resizing Windows::         ウィンドウのサイズの変更。
* Splitting Windows::        新たなウィンドウの作成。
* Deleting Windows::         フレームからのウィンドウの削除。
* Recombining Windows::      ウィンドウの分割や削除時のフレームレイアウトの保存。
* Selecting Windows::        選択されたウィンドウとは、編集を行っているウィンドウである。
* Cyclic Window Ordering::   既存のウィンドウ間の移動。
* Buffers and Windows::      それぞれのウィンドウは、バッファーのコンテンツを表示する。
* Switching Buffers::        バッファー切り替えのための、より高レベルな関数。
* Choosing Window::          バッファーを表示するウィンドウの選択方法。
* Display Action Functions::  ‘display-buffer’用のサブルーチン。
* Choosing Window Options::  バッファー表示方法に影響する拡張オプション。
* Window History::           それぞれのウィンドウは、表示されていたバッファーを記憶する。
* Dedicated Windows::        特定のウィンドウ内で他のバッファーの表示を無効にする。
* Quitting Windows::         以前に表示していたバッファーの状態をリストアする方法。
* Window Point::             それぞれのウィンドウは、自身の位置とポイントをもつ。
* Window Start and End::     ウィンドウ内でスクリーン表示されるテキストを表すバッファー位置。
* Textual Scrolling::        ウィンドウを通じたテキストの上下移動。
* Vertical Scrolling::       ウィンドウ上のコンテンツの上下移動。
* Horizontal Scrolling::     ウィンドウ上のコンテンツの横移動。
* Coordinates and Windows::  座標からウィンドウへの変換。
* Window Configurations::    スクリーンの情報の保存とリストア。
* Window Parameters::        ウィンドウへの追加情報の割り当て。
* Window Hooks::             スクロール、ウィンドウのサイズ変更、ある特定のしきい値を超えたときに行われる再表示、ウィンドウ設定の変更にたいするフック。


File: elisp,  Node: Basic Windows,  Next: Windows and Frames,  Up: Windows

27.1 Basic Concepts of Emacs Windows
====================================

“ウィンドウ(window)”とは、任意のバッファーを表示するために使用される、ス
クリーンの領域です。Emacs Lispでは、ウィンドウはスペシャルLispオブジェク
トとして表現されます。

   ウィンドウは、フレームへとグループ化されます(*note Frames::を参照)。
それぞれのフレームは、最低でも1つのウィンドウを含みます。ユーザーは、複
数のバッファーを1度に閲覧するために、それを複数のオーバーラップしないウ
ィンドウに分割することができます。Lispプログラムは、さまざまな目的にたい
して、複数のウィンドウを使用できます。たとえばRmailでは、1つのウィンドウ
でメッセージタイトル、もう一方のウィンドウで選択したメッセージのコンテン
ツを閲覧できます。

   Emacsは、グラフィカルなデスクトップ環境や、X Window Systemのようなウ
ィンドウシステムとは異なる意味で、“ウィンドウ(window)”という単語を使用し
ます。EmacsがX上で実行されているときは、XのグラフィカルなXウィンドウは、
Emacsでの(1つ以上のEmacsウィンドウを含んだ)フレームになります。Emacsがテ
キスト端末上で実行されているときは、フレームが端末スクリーン全体を占有し
ます。

   Xのウィンドウとは異なり、Emacsのウィンドウは“タイル表示(tiled)”され、
フレームの領域内でオーバーラップされることは決してありません。あるウィン
ドウが作成、リサイズ、削除されるとき、変更されたウィンドウスペースの変更
は各ウィンドウの調整により取得・譲与されるので、そのフレームの総領域に変
化はありません。

 -- Function: windowp object
     この関数は、OBJECTがウィンドウ(バッファーの表示有無に関わらず)なら
     ‘t’、それ以外は‘nil’をリターンする。

   “生きたウィンドウ(live window)”とは、あるフレーム内で実際にバッファー
を表示しているウィンドウのことです。

 -- Function: window-live-p object
     この関数は、OBJECTが生きたウィンドウなら‘t’、それ以外は‘nil’をリタ
     ーンする。生きたウィンドウとは、バッファーを表示するウィンドウのこ
     と。

   各フレーム内のウィンドウは、“ウィンドウツリー(window tree)”内へと組織
化されます。*note Windows and Frames::を参照してください。それぞれのウィ
ンドウツリーのリーフノード(leaf nodes)は、実際にバッファーを表示している
生きたウィンドウです。ウィンドウツリーの内部ノード(internal node)は“内部
ウィンドウ(internal windows)”と呼ばれ、これらは生きたウィンドウではあり
ません。

   “有効なウィンドウ(valid window)”とは、生きたウィンドウか、内部ウィン
ドウのいずれかです。有効なウィンドウにたいしては、それを“削除(delete)”、
すなわちそのウィンドウのフレームから削除することができます(*note
Deleting Windows::を参照)。その場合、それは有効なウィンドウではなくなり
ますが、それを表すLispオブジェクトは依然として他のLispオブジェクトから参
照されたままかもしれません。削除されたウィンドウは、保存されたウィンドウ
設定(window configuration)をリストアすることにより、再び有効になるかもし
れません(*note Window Configurations::を参照)。

   ‘window-valid-p’により、削除されたウィンドウから有効なウィンドウを区
別できます。

 -- Function: window-valid-p object
     この関数は、OBJECTが生きたウィンドウ、またはウィンドウツリー内の内
     部ウィンドウの場合は、‘t’をリターンする。それ以外(OBJECTが削除され
     たウィンドウの場合も含む)は、‘nil’をリターンする。

   それぞれのフレーム内において、常にただ1つのEmacsウィンドウが“そのフレ
ームで選択されている(selected within the frame)”もとして指定されます。選
択されたフレームにたいしては、そのウィンドウは“選択されたウィンドウ
(selected window)”と呼ばれます。選択されたウィンドウは、編集のほとんどが
行われるウィンドウであり、選択されたウィンドウに表示されるカーソルがある
ウィンドウです(*note Cursor Parameters::を参照)。選択されたウィンドウの
バッファーは通常は、‘set-buffer’が使用された場合を除き、カレントバッファ
ーでもあります(*note Current Buffer::を参照)。選択されていないフレームで
は、そのフレームが選択されたときは、そのフレームで選択されていたウィンド
ウが選択されたウィンドウになります。*note Selecting Windows::を参照して
ください。

 -- Function: selected-window
     この関数は、選択されたウィンドウをリターンする(これは常に生きたウィ
     ンドウである)。


File: elisp,  Node: Windows and Frames,  Next: Window Sizes,  Prev: Basic Windows,  Up: Windows

27.2 Windows and Frames
=======================

ウィンドウはそれぞれ、正確に1つのフレームに属します(*note Frames::を参照
)。

 -- Function: window-frame &optional window
     この関数は、ウィンドウWINDOWが属するフレームをリターンする。
     WINDOWが‘nil’の場合のデフォルトは、選択されたウィンドウである。

 -- Function: window-list &optional frame minibuffer window
     この関数は、フレームFRAMEに属する、生きたウィンドウのリストをリター
     ンする。FRAMEが省略、または‘nil’の場合のデフォルトは、選択されたフ
     レームである。

     オプション引数MINIBUFFERは、リターンされるリストにミニバッファーウ
     ィンドウを含めるべきかどうかを指定する。MINIBUFFERが‘t’の場合は、ミ
     ニバッファーウィンドウが含まれる。MINIBUFFERが‘nil’、または省略され
     た場合は、ミニバッファーウィンドウがアクティブのときだけ含まれる。
     MINIBUFFERが‘nil’と‘t’以外の場合、ミニバッファーウィンドウは含まれ
     ない。

     オプション引数WINDOWが非‘nil’の場合、それは指定されたフレーム上の生
     きたウィンドウであること。その場合は、WINDOWがリターンされるリスト
     の最初の要素になる。WINDOWが省略、または‘nil’の場合は、そのフレーム
     の選択されたウィンドウが最初の要素になる。

   同一フレーム内のウィンドウは、リーフノード(leaf nodes)が生きたウィン
ドウであるような、“ウィンドウツリー(window tree)”内に組織化されます。ウ
ィンドウツリーの内部ノード(internal nodes)は生きたウィンドウではありませ
ん。これらのウィンドウは、生きたウィンドウ間の関係を組織化するという目的
のために存在します。ウィンドウツリーのルートノード(root node)は、“ルート
ウィンドウ(root window)”と呼ばれます。ルートノードは生きたウィンドウ(そ
のフレームにウィンドウが1つだけの場合)、または内部ウィンドウのいずれかで
す。

   ミニバッファーウィンドウ(*note Minibuffer Windows::を参照)は、そのフ
レームがミニバッファーだけのフレームでない限り、そのフレームのウィンドウ
ツリーの一部にはなりません。にもかかわらず、このセクションのほとんどの関
数は、引数としてミニバッファーウィンドウを受け付けます。さらにこのセクシ
ョンの最後に説明する関数‘window-tree’は、実際のウィンドウツリーと並列し
てミニバッファーウィンドウをリストします。

 -- Function: frame-root-window &optional frame-or-window
     この関数は、FRAME-OR-WINDOWにたいするルートウィンドウをリターンする
     。引数FRAME-OR-WINDOWは、ウィンドウかフレームのいずれかであること。
     これが省略、または‘nil’の場合のデフォルトは、選択されたフレームであ
     る。FRAME-OR-WINDOWがウィンドウの場合、リターン値はそのウィンドウの
     フレームのルートウィンドウである。

   ウィンドウが分割(split)されているときは、以前は1つだった2つの生きたウ
ィンドウが存在します。これらのうちの一方は、元のウィンドウと同じLispウィ
ンドウオブジェクトとして表され、もう一方は新たに作成されたLispウィンドウ
オブジェクトとして表されます。これらの生きたウィンドウは両方とも、単一の
内部ウィンドウの“子ウィンドウ(child windows)”として、ウィンドウツリーの
リーフノードになります。もし必要なら、Emacsはこの内部ウィンドウを自動的
に作成します。この内部ウィンドウは“親ウィンドウ(parent window)”とも呼ば
れ、ウィンドウツリー内の適切な位置に配置されます。同じ親を共有するウィン
ドウセットは、“兄弟(sibling)”と呼ばれます。

 -- Function: window-parent &optional window
     この関数は、WINDOWの親ウィンドウ(parent window)をリターンする。
     WINDOWが省略、または‘nil’の場合のデフォルトは、選択されたウィンドウ
     である。WINDOWが親をもたない(ミニバッファーウィンドウやそのフレーム
     のルートウィンドウ)場合、リターン値は‘nil’である。

   内部ウィンドウはそれぞれ、常に最低でも2つの子ウィンドウをもちます。ウ
ィンドウ削除によりこの数値が1になった場合、Emacsは自動的に内部ウィンドウ
を削除して、その残った単一の子ウィンドウがウィンドウツリー内のその位置に
配置されます。

   子ウィンドウはそれぞれ生きたウィンドウ、または(次に自身の子ウィンドウ
をもつであろう)内部ウィンドウのいずれかです。したがって、各内部ウィンド
ウは、最終的にはその内部ウィンドウの子孫であるような生きたウィンドウによ
り占有される領域を結合した、特定の矩形“スクリーン領域(screen area)”を占
有すると考えることができます。

   内部ウィンドウそれぞれにたいして、近接する子たちのスクリーン領域は、
垂直(vertically)または水平(horizontally)のいずれかにより整列されます(両
方で整列されることはない)。子ウィンドウが他の子ウィンドウと上下に整列さ
れる場合、それらは“垂直コンビネーション(vertical combination)”、左右に整
列される場合は“水平コンビネーション(horizontal combination)”を形成すると
表現されます。以下の例で考えてみましょう:

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


このフレームのルートウィンドウは、内部ウィンドウW1です。これの子ウィンド
ウは、生きたウィンドウW2と内部ウィンドウW3からなる水平コンビネーションを
形成します。W3の子ウィンドウは、生きたウィンドウW4とW5からなる垂直コンビ
ネーションを形成します。したがって、このウィンドウツリー内の生きたウィン
ドウはW2、W4、およびW5です。

   以下の関数は、内部ウィンドウの子ウィンドウ、および子ウィンドウの兄弟
を取得するのに使用できます。

 -- Function: window-top-child &optional window
     この関数は、内部ウィンドウWINDOWの子ウィンドウが垂直コンビネーショ
     ンを形成する場合は、WINDOWの一番上の子ウィンドウをリターンする。他
     のタイプのウィンドウにたいするリターン値は‘nil’である。

 -- Function: window-left-child &optional window
     この関数は、内部ウィンドウWINDOWの子ウィンドウが水平コンビネーショ
     ンを形成する場合は、WINDOWの一番左の子ウィンドウをリターンする。他
     のタイプのウィンドウにたいするリターン値は‘nil’である。

 -- Function: window-child window
     この関数は、内部ウィンドウWINDOWの最初の子ウィンドウをリターンする
     。これは、垂直コンビネーションにたいしては一番上、水平コンビネーシ
     ョンにたいしては一番左の子ウィンドウである。WINDOWが生きたウィンド
     ウの場合、リターン値は‘nil’である。

 -- Function: window-combined-p &optional window horizontal
     この関数は、WINDOWが垂直コンビネーションの一部である場合のみ、非
     ‘nil’をリターンする。WINDOWが省略、または‘nil’の場合のデフォルトは
     、選択されたウィンドウである。

     オプション引数HORIZONTALが非‘nil’ならば、WINDOWが水平コンビネーショ
     ンの一部である場合のみ非‘nil’をリターンすることを意味する。

 -- Function: window-next-sibling &optional window
     この関数は、ウィンドウWINDOWの次の兄弟をリターンする。省略または
     ‘nil’の場合、WINDOWのデフォルトは選択されたウィンドウになる。
     WINDOWが、その親の最後の子の場合、リターン値は‘nil’である。

 -- Function: window-prev-sibling &optional window
     この関数は、ウィンドウWINDOWの前の兄弟をリターンする。省略または
     ‘nil’の場合、WINDOWのデフォルトは選択されたウィンドウになる。
     WINDOWが、その親の最初の子の場合、リターン値は‘nil’である。

   関数‘window-next-sibling’および‘window-prev-sibling’を、ウィンドウの
サイクル順(*note Cyclic Window Ordering::を参照)において次、または前のウ
ィンドウをリターンする関数‘next-window’および‘previous-window’と混同しな
いでください。

   任意のフレーム上の最初の生きたウィンドウや、与えられたウィンドウにも
っとも近いウィンドウを探すために、以下の関数を使用できます。

 -- Function: frame-first-window &optional frame-or-window
     この関数は、FRAME-OR-WINDOWにより指定されたフレームの、左上隅の生き
     たウィンドウをリターンする。引数FRAME-OR-WINDOWでは、ウィンドウか生
     きたフレームを示さなければならず、デフォルトは選択されたフレームで
     ある。FRAME-OR-WINDOWがウィンドウを指定する場合、この関数はそのウィ
     ンドウのフレームの最初のウィンドウをリターンする。前の例のフレーム
     が‘(frame-first-window)’に指定されたとするならば、W2がリターンされ
     る。

 -- Function: window-in-direction direction &optional window ignore sign
          wrap mini
     この関数は、ウィンドウWINDOW内の位置‘window-point’から、方向
     DIRECTIONにあるもっとも近い生きたウィンドウをリターンする。引数
     DIRECTIONは‘above’、‘below’、‘left’、‘right’のいずれかでなければな
     らない。オプション引数WINDOWは生きたウィンドウを示さなければならず
     、デフォルトは選択されたウィンドウである。

     この関数は、パラメーター‘no-other-window’が非‘nil’のウィンドウをリ
     ターンしない(*note Window Parameters::を参照)。もっとも近いウィンド
     ウの‘no-other-window’パラメーターが非‘nil’の場合、この関数は指定さ
     れた方向で‘no-other-window’パラメーターが‘nil’の、他のウィンドウを
     探す。オプション引数IGNOREが非‘nil’の場合は、たとえ
     ‘no-other-window’パラメーターが非‘nil’のウィンドウでも、リターンさ
     れ得る。

     オプション引数SIGNが負の数値の場合、それは参照位置として
     ‘window-point’のかわりに、WINDOWの右端、または下端を使用することを
     意味する。SIGNが正の数値の場合、それは参照位置としてWINDOWの左端、
     または上端を使用することを意味する。

     オプション引数WRAPが非‘nil’の場合、それはフレームのボーダー
     (borders: 枠線)をDIRECTIONがラップアラウンド(wrap around: 最後に達
     したら最初に戻る)することを意味する。たとえば、WINDOWはフレームの最
     上にあり、DIRECTIONが‘above’の場合、フレームにミニバッファーがあれ
     ばミニバッファーウィンドウ、それ以外はフレーム最下のウィンドウウィ
     ンドウリターンする。

     オプション引数MINIが‘nil’の場合、それはミニバッファーがカレントでア
     クティブな場合のみ、ミニバッファーウィンドウをリターンすることを意
     味する。MINIが非‘nil’ならば、たとえ非アクティブなときでもミニバッフ
     ァーウィンドウをリターンする。しかし、WRAPが非‘nil’の場合は、常に
     MINIが‘nil’であるかのように動作する。

     適切なウィンドウが見つからない場合、この関数は‘nil’をリターンする。

   以下の関数により、任意のフレームのウィンドウツリー全体を取得できます:

 -- Function: window-tree &optional frame
     この関数は、フレームFRAMEにたいするウィンドウツリーを表すリストをリ
     ターンする。FRAMEが省略、または‘nil’の場合のデフォルトは、選択され
     たフレームである。

     リターン値は、‘(ROOT MINI)’という形式のリストである。ここでROOTはそ
     のフレームのウィンドウツリーのルートウィンドウ、MINIはそのフレーム
     のミニバッファーウィンドウを表す。

     ルートウィンドウが生きている場合、ROOTはそのウィンドウ自身である。
     それ以外では、ROOTはリスト‘(DIR EDGES W1 W2 ...)’である。ここで
     DIRは水平コンビネーションなら‘nil’、垂直コンビネーションなら‘t’とな
     り、EDGESはそのコンビネーションのサイズと位置を与え、残りの要素は子
     ウィンドウである。子ウィンドウはそれぞれ、同じようにウィンドウオブ
     ジェクト(生きたウィンドウにたいして)、または上記フォーマットと同じ
     形式のリスト(内部ウィンドウにたいして)かもしれない。EDGES要素は
     ‘window-edges’がリターンする値のような、リスト‘(LEFT TOP RIGHT
     BOTTOM)’である(*note Coordinates and Windows::を参照)。


File: elisp,  Node: Window Sizes,  Next: Resizing Windows,  Prev: Windows and Frames,  Up: Windows

27.3 Window Sizes
=================

以下の図は、生きたウィンドウの構造を示しています:

             ____________________________________________
            |______________ Header Line ______________|RD| ^
          ^ |LS|LF|LM|                       |RM|RF|RS|  | |
          | |  |  |  |                       |  |  |  |  | |
     Window |  |  |  |       Text Area       |  |  |  |  | Window
     Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
     Height |  |  |  |                       |  |  |  |  | Height
          | |  |  |  |<- Window Body Width ->|  |  |  |  | |
          v |__|__|__|_______________________|__|__|__|  | |
            |_______________ Mode Line _______________|__| |
            |_____________ Bottom Divider _______________| v
             <---------- Window Total Width ------------>


   ウィンドウの中央は“テキストエリア(text area: テキスト領域)”、または
“ボディー(body: 本体、本文)”と呼ばれる、バッファーテキストが表示される場
所です。テキストエリアは、一連のオプションエリアで囲まれている可能性があ
ります。左右には、内側から外側に向かって、図中にLMとRMで示される左右のマ
ージン(*note Display Margins::を参照)、LFとRFで示される左右のフリンジ
(*note Fringes::を参照)、そしてLSとRSはスクロールバー(*note Scroll
Bars::を参照)で、常に表示されるのはいずれか一方だけです。そしてRDはディ
バイダー(*note Window Dividers::を参照)を示しています。ウィンドウの上端
はヘッダーライン(*note Header Lines::を参照)、下端にはモードライン(*note
Mode Line Format::を参照)と、その下に下端ディバイダー(*note Window
Dividers::を参照)があります。

   Emacsは、ウィンドウの高さと幅を求めるために、さまざまな関数を提供しま
す。これらの関数がリターンする値の多くは、ピクセル単位か、行単位と列単位
のいずれかにより指定できます。グラフィカルなディスプレイでは、後者は実際
には‘frame-char-height’および‘frame-char-width’によりリターンされる、そ
のフレームのデフォルトフォントが指定する、“デフォルト文字”の高さと幅に対
応します。したがって、あるウィンドウが異なるフォントやサイズでテキストを
表示していると、そのウィンドウにたいして報告される行高さと列幅は、実際に
ウィンドウ内で表示されるテキスト行数と列数とは、異なるかもしれません。

   ウィンドウの“トータル高さ(total height)”とは、そのウィンドウのボディ
ー、ヘッダーライン、モードライン、(もしあれば)下端ディバイダーを構成する
行数のことです。フレームにはエコーエリア、メニューバー、ツールバーが含ま
れるかもしれないので、フレームの高さはそのフレームのルートウィンドウ
(*note Windows and Frames::を参照)の高さとは異なることに注意してください
(*note Size and Position::を参照)。

 -- Function: window-total-height &optional window round
     この関数は、ウィンドウWINDOWのトータル高さを、行でリターンする。
     WINDOWが省略、または‘nil’の場合のデフォルトは、選択されたウィンドウ
     である。WINDOWが内部ウィンドウの場合、リターン値はそのウィンドウの
     子孫となるウィンドウにより占有されるトータル高さになる。

     ウィンドウのピクセル高さが、そのウィンドウがあるフレームのデフォル
     ト文字高さの整数倍でない場合は、そのウィンドウが占有する行数が内部
     で丸められる。これは、そのウィンドウが親ウィンドウの場合は、すべて
     の子ウィンドウのトータル高さの合計が、親ウィンドウのトータル高さと
     内部的に等しくなるような方法により行われる。これは、たとえ2つのウィ
     ンドウのピクセル高さが等しくでも、内部的なトータル高さは1行分異なる
     かもしれないことを意味する。さらにこれは、そのウィンドウが垂直コン
     ビネーションされていて、かつ右の兄弟をもつ場合、その兄弟の上端行は
     、このウィンドウの上端行とトータル高さから計算されるかもしれないこ
     とも意味する(*note Coordinates and Windows::を参照)。

     オプション引数ROUNDが‘ceiling’の場合、この関数はWINDOWのピクセル高
     さを、そのフレームの文字高さで除した数より大であるような最小の整数
     、‘floor’の場合は除した数より小であるような最大の整数、それ以外の
     ROUNDにたいしては、WINDOWSのトータル高さの内部値をリターンする。

   “トータル幅(total width)”とは、そのウィンドウのボディーを構成する列数
、マージン、フリンジ、スクロールバー、(もしあれば)右ディバイダーです。

 -- Function: window-total-width &optional window round
     この関数は、ウィンドウWINDOWのトータル幅を列でリターンする。
     WINDOWが省略、または‘nil’の場合のデフォルトは、選択されたウィンドウ
     である。WINDOWが内部ウィンドウの場合、リターン値はその子孫のウィン
     ドウが占有するトータル幅になる。

     ウィンドウのピクセル幅が、そのウィンドウがあるフレームのデフォルト
     文字幅の整数倍でない場合は、そのウィンドウが占有する列数が内部で丸
     められる。これは、そのウィンドウが親ウィンドウの場合は、すべての子
     ウィンドウのトータル幅の合計が、親ウィンドウのトータル幅と内部的に
     等しくなるような方法により行われる。これは、たとえ2つのウィンドウの
     ピクセル幅が等しくでも、内部的なトータル幅は1列分異なるかもしれない
     ことを意味する。さらにこれは、そのウィンドウが水平コンビネーション
     されていて、かつ右の兄弟をもつ場合、その兄弟の左端行は、このウィン
     ドウの左端行とトータル幅から計算されるかもしれないことも意味する
     (*note Coordinates and Windows::を参照)。オプション引数ROUNDは、
     ‘window-total-height’の場合と同様に振る舞う。

 -- Function: window-total-size &optional window horizontal round
     この関数は、ウィンドウWINDOWのトータル高さを行で、またはトータル幅
     を列でリターンする。HORIZONTALが省略、または‘nil’の場合はWINDOWにた
     いして‘window-total-height’を呼び出すのと等価であり、それ以外では
     WINDOWにたいして‘window-total-width’を呼び出すのと等価である。オプ
     ション引数ROUNDは、‘window-total-height’の場合と同様に振る舞う。

   以下の2つの関数は、ウィンドウのトータルサイズをピクセル単位でリターン
させるために使用できます。

 -- Function: window-pixel-height &optional window
     この関数は、ウィンドウWINDOWのトータル高さを、ピクセルでリターンす
     る。WINDOWは有効なウィンドウでなければならず、デフォルトは選択され
     たウィンドウである。

     リターン値には、(もしあれば)モードライン、ヘッダーライン、下端ディ
     バイダーが含まれる。WINDOWが内部ウィンドウの場合、そのピクセル高さ
     は子ウィンドウたちによりスパンされるスクリーン領域のピクセル高さに
     なる。

 -- Function: window-pixel-width &optional Lisp_Object &optional window
     この関数は、ウィンドウWINDOWの幅をピクセルでリターンする。WINDOWは
     有効なウィンドウでなければならず、デフォルトは選択されたウィンドウ
     である。

     リターン値には、フリンジ、WINDOWのマージン、同様にWINDOWに属する垂
     直ディバイダーとスクロールバーが含まれる。WINDOWが内部ウィンドウの
     場合、そのピクセル幅は子ウィンドウたちによりスパンされるスクリーン
     領域の幅になる。

   以下の関数は、与えられたウィンドウに隣接するウィンドウがあるかどうか
を判断するために使用できます。

 -- Function: window-full-height-p &optional window
     この関数は、フレーム内でWINDOWの上下に他のウィンドウがなければ非
     ‘nil’をリターンする(トータル高さがそのフレーム上のルートウィンドウ
     と等しい)。WINDOWが省略、または‘nil’の場合のデフォルトは、選択され
     たウィンドウである。

 -- Function: window-full-width-p &optional window
     この関数は、フレーム内でWINDOWの左右に他のウィンドウがなければ非
     ‘nil’をリターンする(トータル幅がそのフレーム上のルートウィンドウと
     等しい)。WINDOWが省略、または‘nil’の場合のデフォルトは、選択された
     ウィンドウである。

   ウィンドウの“ボディー高さ(body height)”とは、モードライン、ヘッダーラ
イン、下端ディバイダーを含まないテキスト領域の高さです。

 -- Function: window-body-height &optional window pixelwise
     この関数は、ウィンドウWINDOWのボディーの高さを、行でリターンする。
     WINDOWが省略、または‘nil’の場合のデフォルトは選択されたウィンドウで
     、それ以外では生きたウィンドウでなければならない。

     オプション引数PIXELWISEが非‘nil’の場合、この関数はピクセルで計算
     WINDOWのボディー高さをリターンする。

     PIXELWISEが‘nil’の場合は、必要ならリターン値はもっとも近い整数に切
     り下げられる。これは、テキスト領域の下端行が部分的に可視の場合、そ
     の行は計数されないこと、さらに任意のウィンドウのボディー高さは、
     ‘window-total-height’によりリターンされるそのウィンドウのトータル高
     さ決して超過し得ないことをも意味する。

   ウィンドウの“ボディー幅(body width)”とは、スクロールバー、フリンジ、
マージン、右ディバイダーを含まないテキスト領域の幅です。

 -- Function: window-body-width &optional window pixelwise
     この関数は、ウィンドウWINDOWのボディーの幅を、列でリターンする。
     WINDOWが省略、または‘nil’の場合のデフォルトは選択されたウィンドウで
     あり、それ以外では生きたウィンドウでなければならない

     オプション引数PIXELWISEが非‘nil’の場合、この関数はWINDOWのボディー
     の幅をピクセル単位でリターンする。

     PIXELWISEが‘nil’の場合、リターン値は必要ならもっとも近い整数に切り
     下げられる。これはテキスト領域の右端の列が部分的に可視な場合は、そ
     の列は計数されないことを意味する。さらにこれは、ウィンドウのボディ
     ーの幅が、‘window-total-width’によりリターンされるウィンドウのトー
     タル幅を決して超過し得ないことをも意味する。

 -- Function: window-body-size &optional window horizontal pixelwise
     この関数は、WINDOWのボディーの高さ、または幅をリターンする。
     HORIZONTALが省略、または‘nil’の場合は、WINDOWにたいして
     ‘window-body-height’、それ以外の場合は、‘window-body-width’を呼び出
     すのと同じである。いずれの場合も、オプション引数PIXELWISEは、呼び出
     された関数に渡される。

   以前のバージョンのEmacsとの互換性のため、‘window-height’は
‘window-total-height’、‘window-width’は‘window-body-width’にたいするエイ
リアスです。これらのエイリアス時代遅れと考えられております、将来的には削
除されるでしょう。

   ウィンドウのモードラインとヘッダーラインのピクセル高さは、以下の関数
により取得できる。それらのリターン値は、そのウィンドウが以前に表示されて
いない場合を除き、通常は加算される。その場合、リターン値はそのウィンドウ
のフレームにたいして使用を予想されるフォントが元になる。

 -- Function: window-mode-line-height &optional window
     この関数は、WINDOWモードラインの高さをピクセルでリターンする。
     WINDOWは生きたウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。WINDOWにモードラインがない場合、リターン値は0である
     。

 -- Function: window-header-line-height &optional window
     この関数は、WINDOWのヘッダーラインの高さをピクセルでリターンする。
     WINDOWは生きたウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。WINDOWにヘッダーラインがない場合のリターン値は0であ
     る。

   ウィンドウディバイダー(*note Window Dividers::を参照)、フリンジ(*note
Fringes::を参照)、スクロールバー(*note Scroll Bars::を参照)、ディスプレ
イマージン(*note Display Margins::を参照)を取得する関数については、対応
するセクションで説明されています。

   ウィンドウのサイズを変更(*note Resizing Windows::を参照)したり、ウィ
ンドウを分割(split)するコマンド(*note Splitting Windows::を参照)は、指定
できるウィンドウの最小の高さと幅を指定する変数‘window-min-height’および
‘window-min-width’にしたがう。これらのコマンドは、ウィンドウのサイズが
“fixed(固定)”になる変数‘window-size-fixed’にもしたがう。

 -- User Option: window-min-height
     このオプションは、任意のウィンドウの最小のトータル高さを行で指定す
     る。この値は最低でも1つのテキスト行、同様にモードライン、ヘッダーラ
     イン、(もしあれば)下端ディバイダーに対応する必要がある。

 -- User Option: window-min-width
     このオプションは、すべてのウィンドウの最小のトータル幅を列で指定す
     る。この値は、2つのテキスト列、同様に(もしあれば)マージン、フリンジ
     、スクロールバー、右ディバイダーに対応する必要がある。

 -- Variable: window-size-fixed
     このバッファーローカル変数が非‘nil’の場合、そのバッファーを表示する
     すべてのウィンドウのサイズが、通常は変更できなくなる。ウィンドウ削
     除やそのフレームのサイズ変更により、それ以外に方法がなければ、依然
     としてウィンドウのサイズは変更されるかもしれない。

     値が‘height’の場合は、そのウィンドウの高さだけが固定される。値が
     ‘width’の場合は、そのウィンドウの幅だけが固定される。その他の非
     ‘nil’値では、幅と高さの両方が固定される。

     この変数が‘nil’場合でも、そのバッファーを表示している任意のウィンド
     ウを任意の方向にリサイズできるとはいえない。これを決定するには、関
     数‘window-resizable’を使用する。*note Resizing Windows::を参照のこ
     と。

   以降の関数は、ある特定の大きさのウィンドウにたいして、それの
‘window-min-height’と‘window-min-width’と‘window-size-fixed’の値と、領域
のサイズを示す。

 -- Function: window-min-size &optional window horizontal ignore
          pixelwise
     この関数は、WINDOWの最小のサイズをリターンする。WINDOWは有効なウィ
     ンドウでなければならず、デフォルトは選択されたウィンドウ。オプショ
     ン引数HORIZONTALが非‘nil’の場合は、WINDOWの最小の列数、それ以外は
     WINDOWの最小の行数をリターンすることを意味する。

     このリターン値により、WINDOWのサイズが実際にその値にセットされた場
     合に、WINDOWのすべてのコンポーネントが完全に可視にとどまることが保
     証される。HORIZONTALが‘nil’の場合は、モードライン、ヘッダーライン、
     および下端ディバイダーが含まれる。HORIZONTALが非‘nil’の場合は、もし
     あればフリンジ、スクロールバー、右ディバイダーが含まれる。しかしこ
     れには、マージン用に予約済みのスペースは含まれない。

     オプション引数IGNOREが非‘nil’の場合は、‘window-min-height’または
     ‘window-min-width’によりセットされる固定サイズのウィンドウに強いら
     れる制限を無視することを意味する。IGNOREが‘safe’の場合は、生きたウ
     ィンドウは可能な限り小さな‘window-safe-min-height’の行と、
     ‘window-safe-min-width’の列を得る。IGNOREにウィンドウが指定された場
     合は、そのウィンドウにたいする制限だけを無視する。その他の非‘nil’値
     では、すべてのウィンドウにたいする上記制限のすべてが無視されること
     を意味する。

     オプション引数PIXELWISEが非‘nil’の場合は、WINDOWの最小サイズがピク
     セルで計数されてリターンされることを意味する。


File: elisp,  Node: Resizing Windows,  Next: Splitting Windows,  Prev: Window Sizes,  Up: Windows

27.4 Resizing Windows
=====================

このセクションでは、フレームのサイズを変更せずにウィンドウのサイズを変更
する関数について説明します。生きたウィンドウはオーバーラップしないので、
これらの関数は2つ以上のウィンドウを含む関数上でのみ意味があります(ウィン
ドウのリサイズにより隣接するウィンドウのサイズも変更される)。フレーム上
に単一のウィンドウしか存在しない場合には、フレームの変更以外によりウィン
ドウのサイズ変更はできません(*note Size and Position::を参照)。

   注記した場合を除き、これらの関数は引数として内部ウィンドウも受け付け
ます。内部ウィンドウのリサイズにより、同じスペースにフィットするよう、子
ウィンドウもリサイズされます。

 -- Function: window-resizable window delta &optional horizontal ignore
          pixelwise
     この関数は、WINDOWのサイズがDELTA行により垂直に変更され得る場合は、
     DELTAをリターンする。オプション引数HORIZONTALが非‘nil’の場合は、
     WINDOWがDELTA列単位に水平方向にリサイズ可能ならば、かわりにDELTAを
     リターンする。これは、実際にはウィンドウのサイズを変更しない。

     WINDOWが‘nil’の場合のデフォルトは選択されたウィンドウ。

     DELTAが正の値の場合は、そのウィンドウが行または列の単位で拡張可能か
     どうかをチェックすることを意味し、DELTAが負の値の場合は、そのウィン
     ドウが行または列の単位で縮小可能かどうかをチェックすることを意味す
     る。DELTAが非0の場合のリターン値0は、そのウィンドウがリサイズ可能で
     あることを意味する。

     通常、変数‘window-min-height’と‘window-min-width’は許容される最小の
     ウィンドウサイズを指定する(*note Window Sizes::を参照)。しかし、オ
     プション引数IGNOREが非‘nil’の場合、この関数は‘window-size-fixed’と
     同様に‘window-min-height’と‘window-min-width’を無視する。そのかわり
     に、ヘッダーライン、モードライン、(もしあれば)下端ディバイダーに加
     えて1行分の高さのテキストエリアから構成されるウィンドウを、最小高さ
     のウィンドウとし、フリンジ、マージン、スクロールバー、(もしあれば
     )右ディバイダーに加えて1列分の幅のテキストエリアから構成されるウィ
     ンドウを、最小幅のウィンドウと判断する。

     オプション引数PIXELWISEが非‘nil’の場合、DELTAはピクセル単位として解
     釈される。

 -- Function: window-resize window delta &optional horizontal ignore
          pixelwise
     この関数は、WINDOWをDELTA増加することによりリサイズする。
     HORIZONTALが‘nil’の場合は高さをDELTA行、それ以外は幅をDELTA行変更す
     る。正のDELTAはウィンドウの拡大、負のDELTAは縮小を意味する。

     WINDOWが‘nil’の場合のデフォルトは、選択されたウィンドウである。要求
     されたようにウィンドウをリサイズできない場合は、エラーをシグナルす
     る。

     オプション引数IGNOREは、上述の関数‘window-resizable’の場合と同じ意
     味をもつ。

     オプション引数PIXELWISEが非‘nil’の場合、DELTAはピクセル単位として解
     釈される。

     この関数はどのウィンドウのエッジを変更するかの選択は、オプション
     ‘window-combination-resize’の値と、関連するウィンドウのコンビネーシ
     ョンリミット(combination limits: 組み合わせ制限)に依存し、両方のエ
     ッジを変更するような場合もいくつかある。*note Recombining
     Windows::を参照のこと。ウィンドウの下端または右端のエッジを移動する
     ことだけでリサイズするには、関数‘adjust-window-trailing-edge’を使用
     すること。

 -- Function: adjust-window-trailing-edge window delta &optional
          horizontal pixelwise
     この関数は、WINDOWの下端エッジをDELTA行分移動する。オプション引数
     HORIZONTALが非‘nil’の場合は、かわりに右端エッジをDELTA列分移動する
     。WINDOWが‘nil’の場合のデフォルトは、選択されたウィンドウである。

     オプション引数PIXELWISEが非‘nil’の場合、DELTAはピクセル単位として解
     釈される。

     正のDELTAはエッジを下方もしくは右方へ移動し、負のDELTAはエッジを上
     方もしくは左方へ移動する。DELTAで指定された範囲までエッジを移動でき
     ない場合、この関数はエラーをシグナルすることなく、可能な限りエッジ
     を移動する。

     この関数は、移動されたエッジに隣接するウィンドウのリサイズを試みる
     。何らかの理由(隣接するウィンドウが固定サイズの場合等)により、それ
     が不可能な場合は、他のウィンドウをリサイズするかもしれない。

 -- User Option: window-resize-pixelwise
     このオプションの値が非‘nil’の場合、Emacsはウィンドウをピクセル単位
     でリサイズする。現在のところ、これは‘split-window’(*note Splitting
     Windows::を参照)、‘maximize-window’、‘minimize-window’、
     ‘fit-window-to-buffer’、‘shrink-window-if-larger-than-buffer’(すべ
     て以下に記述)、および‘fit-frame-to-buffer’(*note Size and
     Position::を参照)のような関数に影響を与える。

     あるフレームのピクセルサイズがそのフレームの文字サイズの整数倍でな
     いときは、たとえこのオプションが‘nil’であっても、少なくとも1つのウ
     ィンドウがピクセル単位でリサイズされるであろうことに注意されたい。
     デフォルト値は‘nil’である。

   以下のコマンドは、より具体的な方法でウィンドウをリサイズします。これ
らがインタラクティブに呼び出されたときは、選択されたウィンドウにたいして
作用します。

 -- Command: fit-window-to-buffer &optional window max-height min-height
          max-width min-width
     このコマンドは、WINDOWの高さまたは幅を、ウィンドウ内のテキストにフ
     ィットするように調整する。WINDOWがリサイズできた場合は非‘nil’、それ
     以外は‘nil’をリターンする。WINDOWが省略または‘nil’の場合のデフォル
     トは選択されたウィンドウ、それ以外の場合は生きたウィンドウであるこ
     と。

     WINDOWが垂直コンビネーションの一部の場合、この関数はWINDOWの高さを
     調整する。新たな高さは、そのウィンドウのバッファーのアクセス可能な
     範囲の実際の高さから計算される。オプション引数MAX-HEIGHTが非‘nil’の
     場合、それはこの関数がWINDOWに与えることができる、最大のトータル高
     さを指定する。オプション引数MIN-HEIGHTが非‘nil’の場合、それは与える
     ことができる最小のトータル高さを指定し、それは変数
     ‘window-min-height’をオーバーライドする。MAX-HEIGHTとMIN-HEIGHTはど
     ちらも、(もしあれば)モードライン、ヘッダーライン、下端ディバイダー
     を含む行数で指定する。

     WINDOWが水平コンビネーションの一部で、かつオプション
     ‘fit-window-to-buffer-horizontally’(以下参照)の値が非‘nil’の場合、
     この関数はWINDOWの幅を調整する。新たな幅は、WINDOWのカレントのスタ
     ート位置以降の、バッファーの最長の行から計算される。オプション引数
     MAX-WIDTHは最大幅を指定し、デフォルトはWINDOWのフレーム幅である。オ
     プション引数MIN-WIDTHは最小幅を指定し、デフォルトは
     ‘window-min-width’である。MAX-WIDTHとMIN-WIDTHはどちらも、(もしあれ
     ば)フリンジ、マージン、スクロールバーを含む列数で指定する。

     オプション‘fit-frame-to-buffer’(以下参照)が非‘nil’の場合、この関数
     は‘fit-frame-to-buffer’(*note Size and Position::)を呼び出すことに
     より、WINDOWのコンテンツにフィットするように、WINDOWのフレームのリ
     サイズを試みるだろう。

 -- User Option: fit-window-to-buffer-horizontally
     これが非‘nil’の場合、‘fit-window-to-buffer’はウィンドウを水平方向に
     リサイズできる。これが‘nil’(デフォルト)の場合、
     ‘fit-window-to-buffer’はウィンドウウィンドウ決して水平方向にリサイ
     ズしない。これが‘only’の場合は、ウィンドウを水平方向だけにリサイズ
     できる。その他の値では、‘fit-window-to-buffer’がウィンドウをどちら
     の方向にもリサイズできることを意味する。

 -- User Option: fit-frame-to-buffer
     このオプションが非‘nil’の場合、‘fit-window-to-buffer’はフレームをフ
     レームのコンテンツにフィットさせることができる。フレームは、フレー
     ムのルートウィンドウが生きたウィンドウで、かつこのオプションが非
     ‘nil’の場合のみ、フィットされる。これが‘horizontally’の場合、フレー
     ムは水平方向にのみフィットされる。これが‘vertically’の場合、フレー
     ムは垂直方向にのみフィットされる。その他の非‘nil’値は、フレームがど
     ちらの方向にもフィットできることを意味する。

 -- Command: shrink-window-if-larger-than-buffer &optional window
     このコマンドは、WINDOWにたいしてそのバッファーを完全に表示できるが
     、‘window-min-height’以上の行を表示できるまで、可能な限りWINDOWの高
     さを縮小する。リターン値は、そのウィンドウがリサイズされれば非
     ‘nil’、それ以外は非‘nil’。WINDOWが省略または‘nil’の場合のデフォルト
     は、選択されたウィンドウである。それ以外では、生きたウィンドウであ
     ること。

     このコマンドは、そのウィンドウがバッファーのすべてを表示するにはす
     でに高さが低すぎる場合、バッファーのどこかがスクリーンからスクロー
     ルオフされている場合、またはそのウィンドウがフレーム内で唯一の生き
     たウィンドウの場合は何も行わない。

     このコマンドは、自身の処理を行うために、‘fit-window-to-buffer’(上記
     参照)を呼び出す。

 -- Command: balance-windows &optional window-or-frame
     この関数は、各ウィンドウにたいして完全な幅、および/または完全な高さ
     を与えるような方法により、各ウィンドウのバランスをとる。
     WINDOW-OR-FRAMEにフレームを指定した場合は、そのフレーム上のすべての
     ウィンドウのバランスをとる。WINDOW-OR-FRAMEにウィンドウを指定した場
     合は、そのウィンドウとウィンドウのsiblings(兄弟)にたいしてのみのバ
     ランスをとる(*note Windows and Frames::を参照)。

 -- Command: balance-windows-area
     この関数は、選択されたフレーム上のすべてのウィンドウにたいして、お
     およそ同じスクリーンエリアを与えようと試みる。完全な幅、または高さ
     をもつウィンドウにたいしては、他のウィンドウと比較して、より多くの
     スペースは与えられない。

 -- Command: maximize-window &optional window
     この関数は、WINDOWにたいして、そのフレームをリサイズしたり、他のウ
     ィンドウを削除することなく、水平垂直の両方向において、可能な限り大
     きくなるように試みる。WINDOWが省略または‘nil’の場合のデフォルトは、
     選択されたウィンドウである。

 -- Command: minimize-window &optional window
     この関数は、WINDOWにたいして、そのフレームをリサイズしたり、そのウ
     ィンドウを削除することなく、水平垂直の両方向において、可能な限り小
     さくなるように試みる。WINDOWが省略または‘nil’の場合のデフォルトは、
     選択されたウィンドウである。


File: elisp,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Resizing Windows,  Up: Windows

27.5 Splitting Windows
======================

このセクションでは、既存のウィンドウを“分割(split: スプリット”することに
より、新たにウィンドウを作成する関数について説明します。

 -- Function: split-window &optional window size side pixelwise
     この関数は、ウィンドウWINDOWの隣に、新たに生きたウィンドウを作成す
     る。WINDOWが省略または‘nil’の場合のデフォルトは、選択されたウィンド
     ウである。そのウィンドウは“分割(split)”されて、サイズは縮小される。
     そのスペースは、リターンされる新たなウィンドウにより吸収される。

     オプションの第2引数SIZEは、WINDOWおよび/または新たなウィンドウのサ
     イズを決定する。これが省略または‘nil’の場合は、両方のウィンドウに同
     じサイズが割り当てられる。行数が奇数の場合、余りの1行は新たなウィン
     ドウに割り当てられる。SIZEが正の数値の場合、WINDOWにSIZEの行数
     (SIDEの値によっては列数)が与えられる。SIZEが負の数値の場合、新たな
     ウィンドウに−SIZEの行数(または列数)が与えられる。

     SIZEが‘nil’の場合、この関数は変数‘window-min-height’と
     ‘window-min-width’にしたがう(*note Window Sizes::を参照)。つまり、
     分割によりこれらの変数の指定より小さいウィンドウが作成されるような
     ときは、エラーをシグナルする。しかし、SIZEにたいして非‘nil’値を指定
     すれば、これらの変数は無視される。その場合、許容される最小のウィン
     ドウは、テキストエリアの高さが1行、および/または幅が2列のウィンドウ
     であるとされる。

     したがって、SIZEが指定された場合、生成されるウィンドウがモードライ
     ンやスクロールバー等すべてのエリアを含むのに十分な大きさがあるかど
     うかチェックするのは、呼び出し側の責任である。これに関して、必要最
     小限のWINDOWを決定するために、関数‘window-min-size’(*note Window
     Sizes::を参照)を使用できる。新たなウィンドウは通常、モードラインや
     スクロールバー等のエリアをWINDOWから“継承”するので、この関数は新た
     なウィンドウの最小サイズも良好に推定する。呼び出し側は、次回の再表
     示前にこれに応じて継承されたエリアを削除する場合のみ、より小さなサ
     イズを指定すること。

     オプションの第3引数SIDEは、新たなウィンドウの位置をWINDOWから相対的
     に指定する。‘nil’または‘below’の場合、新たなウィンドウはWINDOWの下
     に、‘above’の場合はWINDOWの上に配される。どちらの場合も、SIZEはウィ
     ンドウのトータル高さを行数で指定する。

     SIDEが‘t’または‘right’の場合、新たなウィンドウはWINDOWの右に、
     SIDEが‘left’の場合はWINDOWの左に配される。どちらの場合も、SIZEはウ
     ィンドウのトータル幅を列数で指定する。

     オプションの第4引数PIXELWISEが非‘nil’の場合は、SIZEを行や列ではなく
     ピクセル単位で解釈することを意味する。

     WINDOWが生きたウィンドウの場合、新たなウィンドウはマージンやスクロ
     ールバーを含む、さまざまなプロパティを継承する。WINDOWが内部ウィン
     ドウ(internal window)の場合、新たなウィンドウはWINDOWのフレームのプ
     ロパティを継承する。

     変数‘ignore-window-parameters’が‘nil’の場合に限り、この関数の挙動は
     WINDOWなパラメーターにより変更されるかもしれない。ウィンドウパラメ
     ーター‘split-window’の値が‘t’の場合、この関数はその他すべてのウィン
     ドウパラメーターを無視する。それ以外では、ウィンドウパラメーター
     ‘split-window’の値が関数の場合は、‘split-window’の通常アクションの
     かわりに、引数WINDOW、SIZE、SIDEでその関数が呼び出される。値が関数
     以外の場合、この関数は(もしあれば)ウィンドウパラメーター
     ‘window-atom’または‘window-side’にしたがう。*note Window
     Parameters::を参照のこと。

   例として、*note Windows and Frames::で議論したウィンドウ構成(window
configuration)を得るための、一連の‘split-window’呼び出しを以下に挙げます
。この例では、生きたウィンドウの分割と、内部ウィンドウの分割も示します。
最初はW4で表される、単一のウィンドウ(生きたルートウィンドウ)を含むフレー
ムから開始します。‘(split-window W4)’を呼び出すことにより、以下のウィン
ドウ構成が得られます。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W5_________________||
         |__________________W3__________________|


‘split-window’呼び出しにより、W5で示す生きたウィンドウが新たに作成されま
した。W3で示される内部ウィンドウも新たに作成され、これはルートウィンドウ
かつW4とW5の親ウィンドウになります。

   次は、引数として内部ウィンドウW3を渡して、‘(split-window W3 nil
'left)’を呼び出します。

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|

内部ウィンドウW3の左に、生きたウィンドウW2が新たに作成されました。そして
、内部ウィンドウW1が新たに作成され、これが新たにルートウィンドウになりま
す。

   インタラクティブな使用にたいして、Emacsは選択されたウィンドウを常に分
割するコマンドを2つ提供します。これらは内部で‘split-window’を呼び出しま
す。

 -- Command: split-window-right &optional size
     この関数は、選択されたウィンドウが左となるような、横並びの2つのウィ
     ンドウに分割する。SIZEが正ならば左のウィンドウがSIZE列、負ならば右
     のウィンドウが−SIZE列を与えられる。

 -- Command: split-window-below &optional size
     この関数は、選択されたウィンドウが上となるような、縦並びの2つのウィ
     ンドウに分割する。SIZEが正ならば上のウィンドウがSIZE行、負ならば下
     のウィンドウが−SIZE行を与えられる。

 -- User Option: split-window-keep-point
     この変数の値が非‘nil’(デフォルト)なら、 ‘split-window-below’は上述
     のように振る舞う。

     ‘nil’の場合、‘split-window-below’は再表示が最小となるように、2つの
     ウィンドウの各ポイントを調節する(これは低速な端末で有用である)。こ
     れは何であれ、以前ポイントがあったスクリーン行(screen line)を含むウ
     ィンドウを選択する。これは低レベル‘split-window’関数ではなく、
     ‘split-window-below’だけに影響することに注意。


File: elisp,  Node: Deleting Windows,  Next: Recombining Windows,  Prev: Splitting Windows,  Up: Windows

27.6 Deleting Windows
=====================

ウィンドウを“削除(delete)”することにより、フレームのウィンドウツリーから
ウィンドウが取り除かれます。それが生きたウィンドウの場合は、スクリーンに
表示されなくなります。内部ウィンドウの場合は、その子ウィンドウも削除され
ます。

   ウィンドウを削除した後でも、それへの参照が残っている限り、Lispオブジ
ェクトとして存在し続けます。ウィンドウ構成(window configuration)をリスト
アすることにより、ウィンドウの削除は取り消すことができます(*note Window
Configurations::を参照)。

 -- Command: delete-window &optional window
     この関数は、表示からWINDOWを削除して、‘nil’をリターンする。WINDOWが
     省略または‘nil’の場合のデフォルトは、選択されたウィンドウである。そ
     のウィンドウを削除するとウィンドウツリーにウィンドウが存在しなくな
     るような場合(それがフレーム内で唯一の生きたウィンドウである場合等
     )は、エラーをシグナルする。

     デフォルトでは、WINDOWが占めていたスペースは、(もしあれば)隣接する
     兄弟ウィンドウのうちの1つに与えられる。しかし、変数
     ‘window-combination-resize’が非‘nil’の場合、そのスペースはウィンド
     ウコンビネーション内の残りのすべてのウィンドウに比例的に分配される
     。*Note Recombining Windows::を参照のこと。

     変数‘ignore-window-parameters’が‘nil’の場合に限り、この関数の振る舞
     いはWINDOWのウィンドウパラメーターにより変更される可能性がある。ウ
     ィンドウパラメーター‘delete-window’の値が‘t’の場合、この関数はその
     他すべてのウィンドウパラメーターを無視する。ウィンドウパラメーター
     ‘delete-window’が関数の場合は、通常の‘delete-window’のかわりに、引
     数WINDOWでその関数が呼び出される。それ以外では、この関数は(もしあれ
     ば)ウィンドウパラメーター‘window-atom’または‘window-side’にしたがう
     。*note Window Parameters::を参照のこと。

 -- Command: delete-other-windows &optional window
     この関数は、必要に応じて他のウィンドウを削除することにより、
     WINDOWでフレームを充填する。WINDOWが省略または‘nil’の場合のデフォル
     トは、選択されたウィンドウである。リターン値は‘nil’。

     変数‘ignore-window-parameters’が‘nil’の場合に限り、この関数の振る舞
     いは変更される可能性がある。ウィンドウパラメーター
     ‘delete-other-windows’の値が‘t’の場合、この関数は他のすべてのウィン
     ドウパラメーターを無視する。ウィンドウパラメーター
     ‘delete-other-windows’の値が関数の場合は、‘delete-other-windows’の
     通常の動作のかわりに、引数WINDOWでその関数が呼び出される。それ以外
     では、この関数は(もしあれば)ウィンドウパラメーター‘window-atom’また
     は‘window-side’にしたがう。*note Window Parameters::を参照のこと。

 -- Command: delete-windows-on &optional buffer-or-name frame
     この関数は、BUFFER-OR-NAMEを表示しているすべてのウィンドウにたいし
     て‘delete-window’を呼び出すことにより、それらを削除する。
     BUFFER-OR-NAMEはバッファー、またはバッファー名であること。省略また
     は‘nil’の場合のデフォルトはカレントバッファーである。指定されたバッ
     ファーを表示するウィンドウが存在しない場合、この関数は何も行わない
     。ミニバッファーが指定された場合は、エラーをシグナルする。

     そのバッファーの表示に専用(dedicated)のウィンドウがあり、フレーム上
     でそれが唯一のウィンドウの場合、それが端末上で唯一のフレームでなけ
     れば、この関数はそのフレームも削除する。

     オプション引数FRAMEは、操作を行うフレームがどれかを指定する:

        • ‘nil’ すべてのフレームを処理することを意味する。
        • ‘t’ 選択されたフレームを処理することを意味する。
        • ‘visible’ 可視なすべてのフレームを処理することを意味する。
        • ‘0’ 可視またはアイコン化されたすべてのフレームを処理することを
          意味する。
        • フレーム そのフレームを処理することを意味する。

     この引数の意味は、すべての生きたウィンドウを走査する他の関数(*note
     Cyclic Window Ordering::を参照)における場合とは異なることに注意。特
     に、ここでの‘t’と‘nil’のもつ意味は、これら他の関数の場合とは逆であ
     る。


File: elisp,  Node: Recombining Windows,  Next: Selecting Windows,  Prev: Deleting Windows,  Up: Windows

27.7 Recombining Windows
========================

ウィンドウWの最後の兄弟を削除したときは、ウィンドウツリー内の親ウィンド
ウをWを置き換えることにより、その親ウィンドウも削除されます。これは、新
たなウィンドウコンビネーションを形成するために、Wがその親の兄弟たちと再
結合されなければならないことを意味します。生きたウィンドウを削除すること
により、必然的に2つの内部ウィンドウが削除されるかもしれない場合もありま
す。

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      ||| ___________  ___________ |||
         ||      ||||           ||           ||||
         ||      ||||____W6_____||_____W7____||||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


この構成におけるW5の削除は、通常はW3とW4の削除を引き起こします。残りの生
きたウィンドウW2、W6、W7は親をW7とする水平コンビネーションを形成するため
に再結合されます。

   しかし、ときにはW4のような親ウィンドウを削除しないほうが合理的な場合
もあります。特に、親ウィンドウが同じタイプのコンビネーション内に埋め込ま
れるコンビネーションを保護するために使用されるときは、それを削除するべき
ではありません。そのような埋め込みは、あるウィンドウを分割した後に続けて
新たなウィンドウを削除する際、Emacsが関連するフレームで分割前にあったレ
イアウトを確実に再確立するために意味があります。

   親がW1であるような2つの生きたウィンドウW2とW3を開始点とするシナリオを
考えてみましょう。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


W2を分割すると、以下のようにウィンドウW4が新たに作成されます。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


ここでウィンドウを垂直方向に拡大すると、Emacsはもしそのようなウィンドウ
があれば、下位の兄弟ウィンドウから対応するスペースを得ようと試みます。こ
のシナリオでふぁW4の拡大により、W3からスペースが奪われます。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


W4を削除すると、前にW3から奪ったスペースを含む、スペース全体がW2に与えら
れるでしょう。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


これは特にW4が一時的にバッファーを表示するために使用されていて(*note
Temporary Displays::を参照)、かつ初期のレイアウトで作業を継続したい場合
は直感に反するかもしれません。

   この振る舞いは、W2を分割する際に、新たな親ウィンドウを作成することに
より解決できます。

 -- User Option: window-combination-limit
     この変数は、ウィンドウ分割により新たに親ウィンドウを作成させるかど
     うかを制御する。以下の値が認識される:

     ‘nil’
          これは、既存のウィンドウコンビネーションと同じ方向で分割が発生
          した場合(これ以外の場合は、いずれにせよ内部ウィンドウが新たに
          作成される)は、既存の親ウィンドウが存在するならば、新たな生き
          たウィンドウがそれを共有できることを意味する。

     ‘window-size’
          この場合、‘display-buffer’はALIST引数内のエントリー
          ‘window-height’または‘window-width’に親ウィンドウが渡されるな
          ら、新たに親ウィンドウを作成する(*note Display Action
          Functions::を参照)。

     ‘temp-buffer’
          この値は、一時的なバッファーを表示するウィンドウの分割に際し、
          新たに親ウィンドウを作成する。

     ‘display-buffer’
          これは、‘display-buffer’(*note Choosing Window::を参照)がウィ
          ンドウを分割する際に、常に親ウィンドウを新たに作成することを意
          味する。

     ‘t’
          この場合は、ウィンドウを分割する際、常に親ウィンドウが新たに作
          成される。したがって、この変数の値が常に‘t’の場合は、すべての
          ウィンドウツリーｍ常に2分木(ルートウィンドウ以外のすべてのウィ
          ンドウが正確に1つの兄弟をもつようなツリー)になる。

     デフォルトは‘nil’で、これら以外の値は将来のために予約済みである。

     この返信のセッティングの結果として‘split-window’が新たに親ウィンド
     ウを作成した場合は、新たに作成された内部ウィンドウにたいして
     ‘set-window-combination-limit’(以下参照)も呼び出す。これは、子ウィ
     ンドウが削除された際の、ウィンドウツリーの再配置に影響する(以下参照
     )。

   ‘window-combination-limit’が‘t’の場合、このシナリオの初期構成では以下
のようになるでしょう:

          ______________________________________
         | ____________________________________ |
         || __________________________________ ||
         |||                                  |||
         |||________________W2________________|||
         || __________________________________ ||
         |||                                  |||
         |||________________W4________________|||
         ||_________________W5_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


子としてW2および新たな生きたウィンドウをもつ内部ウィンドウW5が新たに作成
されます。ここでW2はW4の唯一の兄弟なので、W4を拡大するとW3は変更せずに、
W2を縮小しようと試みるでしょう。W5は垂直コンビネーションW1に埋め込まれた
、2つのウィンドウからなる垂直コンビネーションを表すことに注意してくださ
い。

 -- Function: set-window-combination-limit window limit
     この関数は、ウィンドウWINDOWの“コンビネーションリミット(combination
     limit: 結合限界”をLIMITにセットする。この値は、関数
     ‘window-combination-limit’を通じて取得できる。効果については以下を
     参照のこと。これは内部ウィンドウにたいしてのみ意味をもつことに注意
     されたい。‘split-window’は、呼び出された際に変数
     ‘window-combination-limit’が‘t’ならば、‘t’をLIMITとして、この関数を
     呼び出す。

 -- Function: window-combination-limit window
     この関数は、WINDOWにたいするコンビネーションリミットをリターンする
     。

     コンビネーションリミットは、内部ウィンドウにたいしてのみ意味をもつ
     。これが‘nil’の場合は、Emacsはウィンドウ削除に応じて、兄弟同士で新
     たなウィンドウコンビネーションを形成することにより、WINDOWの子ウィ
     ンドウをグループ化するために、WINDOWの自動的な削除を許す。コンビネ
     ーションリミットが‘t’の場合、WINDOWの子ウィンドウは、その兄弟と自動
     的に再結合されることは決してない。

     このセクションの冒頭で示した構成の場合、W4(W6とW7の親ウィンドウ)の
     コンビネーションリミットは‘t’なので、‘t’を削除しても暗黙でW4も削除
     されることはない。

   かわりに、同じ構成内の中の1つのウィンドウが分割または削除されたときは
常に構成内のすべてのウィンドウをリサイズすることにより、上記で示した問題
を避けることができます。これは、そのような操作にたいして、この方法以外で
は小さすぎるようなウィンドウの分割も可能にします。

 -- User Option: window-combination-resize
     この変数が‘nil’の場合、‘split-window’はウィンドウ(以下WINDOW)自身と
     新たなウィンドウの両方にたいして、WINDOWのスクリーンエリアが十分大
     きい場合のみ、WINDOWを分割できる。

     この変数が‘t’の場合、‘split-window’は新たなウィンドウに対応するため
     、WINDOWと同じコンビネーション内の、すべてのウィンドウのリサイズを
     試みる。これは特に、WINDOWが固定サイズウィンドウのときや、通常の分
     割には小さすぎるときも、‘split-window’をが成功することを許す。さら
     に、続けてWINDOWをリサイズ、または削除すると、そのコンビネーション
     内のその他すべてのウィンドウをリサイズする。

     デフォルトは‘nil’で、それ以外の値は、将来の使用のため予約済みである
     。この変数の値は、‘window-combination-limit’が非‘nil’の場合は無視さ
     れる。

   ‘window-combination-resize’の効果を説明するために、以下のフレームレイ
アウトを考えてください。

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


‘window-combination-resize’が‘nil’の場合、ウィンドウW3を分割しても、W2の
サイズは変更されません:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


‘window-combination-resize’が‘t’の場合は、W3を分割すると3つの生きたウィ
ンドウすべてを、おおよそ同じ高さにします:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


生きたウィンドウW2、W3、W4のいずれを削除しても、削除されたウィンドウのス
ペースは、残りの2つの生きたウィンドウに相対的に分配されます。


File: elisp,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Recombining Windows,  Up: Windows

27.8 Selecting Windows
======================

 -- Function: select-window window &optional norecord
     この関数は、WINDOWを選択されたウィンドウにして、そのフレーム内で選
     択されたウィンドウとし(*note Basic Windows::を参照)、そのフレームを
     選択する。また、WINDOWのバッファー(*note Buffers and Windows::を参
     照)をカレントにして、そのバッファーの‘point’の値(*note Window
     Point::を参照)を、WINDOWの‘window-point’の値にセットする。WINDOWは
     生きたウィンドウでなければならない。リターン値はWINDOWである。

     デフォルトでは、この関数はWINDOWのバッファーをバッファーリストの先
     頭(*note Buffer List::を参照)に移動して、WINDOWをもっとも最近選択さ
     れたウィンドウにする。しかし、オプション引数NORECORDが非‘nil’の場合
     は、これらの追加処理は省略される。

     この関数は、NORECORDが‘nil’ならば、‘buffer-list-update-hook’(*note
     Buffer List::)を実行する。コーディングを単純にするために、アプリケ
     ーションや内部ルーチンは、しばしばウィンドウを一時的に選択すること
     があることに注意。一般的には、そのような選択(以下のマクロ
     ‘save-selected-window’と‘with-selected-window’による選択も含む)は記
     録されないので、‘buffer-list-update-hook’の汚染は避けられる。選択を
     “実際にカウント”するのは、WINDOWのフレームの次回表示時に可視の変更
     が発生したときで、それらは常に記録されるべきである。これは、あるウ
     ィンドウが選択されるたびに関数を実行するためには、それを
     ‘buffer-list-update-hook’に配するのが良い選択であることも意味してい
     る。

   引数NORECORDに非‘nil’を指定した‘select-window’の連続呼び出しは、ウィ
ンドウの並び順を選択時刻により決定します。関数‘get-lru-window’は、もっと
も昔に選択された生きたウィンドウ(*note Cyclic Window Ordering::を参照)を
取得するために使用できます。

 -- Macro: save-selected-window forms...
     このマクロは、選択されたフレーム、同様に各フレームの選択されたウィ
     ンドウを記録し、FORMSを順に実行してから、以前に選択されていたフレー
     ムとウィンドウをリストアする。これはカレントバッファーの保存とリス
     トアも行う。リターン値はFORMS内の最後のフォームの値である。

     このマクロは、ウィンドウのサイズ、コンテンツ、配置についての保存や
     リストアは何も行わない。したがって、FORMSがそれらを変更した場合、そ
     の変更は永続化される。あるフレームにおいて以前に選択されていたウィ
     ンドウがFORMSのexit時にもはや生きていない場合、そのフレームの選択さ
     れたウィンドウはそのまま放置される。以前に選択されていたウィンドウ
     がもはや生きていない場合はFORMSの最後に選択されていたウィンドウが何
     であれ、それが選択されたままになる。カレントバッファーFORMSのexit時
     にそれが生きている場合のみリストアされる。

     このマクロは、もっとも最近に選択されたウィンドウとバッファーリスト
     の順番を、どちらも変更しない。

 -- Macro: with-selected-window window forms...
     このマクロはWINDOWを選択して、FORMSを順に実行してから、以前に選択さ
     れていたウィンドウとカレントバッファーをリストアする。たとえば、引
     数NORECORDを‘nil’で‘select-window’を呼び出す等、FORMS内で故意に変更
     しない限り、もっとも最近に選択されたウィンドウとバッファーリストの
     順番は変更されない。

     このマクロは、もっとも最近に選択されたウィンドウとバッファーリスト
     の順番を変更しない。

 -- Function: frame-selected-window &optional frame
     この関数は、フレームFRAME内で選択されているウィンドウをリターンする
     。FRAMEは生きたフレームであること。省略または‘nil’の場合のデフォル
     トは、選択されたフレームである。

 -- Function: set-frame-selected-window frame window &optional norecord
     この関数は、WINDOWをフレームFRAME内で選択されたウィンドウにする。
     FRAMEは生きたフレームであること。省略または‘nil’の場合のデフォルト
     は、選択されたフレームである。WINDOWは生きたウィンドウであること。
     省略または‘nil’の場合のデフォルトは選択されたウィンドウである。

     FRAMEが選択されたフレームの場合は、WINDOWを選択されたウィンドウにす
     る。

     オプション引数NORECORDが非‘nil’の場合、この関数はもっとも最近に選択
     されたウィンドウのリストとバッファーリストを、どちらも変更しない。


File: elisp,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

27.9 Cyclic Ordering of Windows
===============================

他のウィンドウを選択するためにコマンド‘C-x o’(‘other-window’)を使う際に
は、特定の順番で生きたウィンドウを巡回します。与えられた任意のウィンドウ
構成にたいして、この順序は決して変更されません。これは、“ウィンドウのサ
イクル順序(cyclic ordering of windows)”と呼ばれます。

   この順序は、そのフレームのリーフノードである生きたウィンドウを取得す
るために、ツリーを深さ優先で走査することにより決定されます(*note Windows
and Frames::を参照)。ミニバッファーがアクティブな場合は、ミニバッファー
ウィンドウも含まれます。この順序は巡回的(cyclic)なので、この順序の最後の
ウィンドウの次には最初のウィンドウが配されます。

 -- Function: next-window &optional window minibuf all-frames
     この関数は、ウィンドウのサイクル順でWINDOWの次の生きたウィンドウを
     リターンする。WINDOWは生きたウィンドウであること。省略または‘nil’の
     場合のデフォルトは選択されたウィンドウである。

     オプション引数MINIBUFは、サイクル順にミニバッファーウィンドウを含め
     るべきかどうかを指定する。通常は、MINIBUFが‘nil’のときは、ミニバッ
     ファーウィンドウがカレントで“アクティブ”な場合のみミニバッファーウ
     ィンドウが含まれる。これは、‘C-x o’の振る舞うと合致する(ミニバッフ
     ァーが使用されている限りミニバッファーウィンドウはアクティブである
     ことに注意。*note Minibuffers::を参照のこと)。

     MINIBUFが‘t’の場合、サイクル順にはすべてのミニバッファーウィンドウ
     が含まれる。MINIBUFが‘t’と‘nil’のいずれとも異なる場合は、たとえアク
     ティブであってもミニバッファーウィンドウは含まれない。

     オプション引数ALL-FRAMESは、考慮に入れるフレームを指定する:

        • ‘nil’ を指定した場合は、WINDOWのフレーム上にあるウィンドウを考
          慮することを意味する。。(MINIBUF引数で指定されたことにより)ミ
          ニバッファーウィンドウが考慮される場合は、ミニバッファーウィン
          ドウを共有するフレームも考慮される。

        • ‘t’ を指定した場合は、すべての既存フレーム上のウィンドウを考慮
          することを意味する。

        • ‘visible’ を指定した場合は、すべての可視フレーム上のウィンドウ
          を考慮することを意味する。

        • 0 を指定した場合は、可視またはアイコン化されたすべてのフレーム
          上のウィンドウを考慮することを意味する。

        • フレーム を指定した場合は、指定されたフレーム上のウィンドウを
          考慮することを意味する。

        • その他 を指定した場合は、WINDOWのあるフレーム上のウィンドウを
          考慮し、それ以外は考慮しないことを意味する。

     複数のフレームが考慮される場合は、すべての生きたフレームのリストの
     順にしたがってそれらのフレームを順に追加することにより、サイクル順
     を取得する(*note Finding All Frames::を参照)。

 -- Function: previous-window &optional window minibuf all-frames
     この関数は、ウィンドウのサイクル順においてWINDOWの前に位置する、生
     きたウィンドウをリターンする。その他の引数は、‘next-window’の場合と
     同様に処理される。

 -- Command: other-window count &optional all-frames
     この関数は、ウィンドウのサイクル順において、選択されたウィンドウか
     らCOUNT番目に位置する、生きたウィンドウをリターンする。COUNTが正の
     数ならCOUNT個のウィンドウを前方にスキップし、負の数なら−COUNT個のウ
     ィンドウを後方にスキップする。COUNTが0の場合は、選択されたウィンド
     ウを単に再選択する．インタラクティブに呼び出された場合、COUNTはプレ
     フィックス数引数である。

     オプション引数ALL-FRAMESは、‘next-window’に‘nil’のMINIBUF引数を指定
     したときの‘next-window’の場合と同じ意味をもつ。

     この関数は、非‘nil’のウィンドウパラメーター‘no-other-window’をもつ
     ウィンドウを選択しない。

 -- Function: walk-windows fun &optional minibuf all-frames
     この関数は、生きたウィンドウそれぞれにたいして、ウィンドウを引数に
     関数FUNを呼び出す。

     これはウィンドウのサイクル順にしたがう。オプション引数MINIBUFと
     ALL-FRAMESは、含まれるウィンドウセットを指定する。これらは、
     ‘next-window’の引数の場合と同じ意味をもつ。ALL-FRAMESがフレームを指
     定する場合、最初に処理されるのはそのフレームの最初のウィンドウ
     (‘frame-first-window’がリターンするウィンドウ)であり、選択されたウ
     ィンドウである必要はない。

     FUNがウィンドウの分割や削除によりウィンドウ構成を変更する場合でも、
     処理するウィンドウセットは初回のFUN呼び出しに先立ち決定されるため、
     変更されない。

 -- Function: one-window-p &optional no-mini all-frames
     この関数は、選択されたウィンドウが唯一の生きたウィンドウの場合は
     ‘t’、それ以外は‘nil’をリターンする。

     ミニバッファーウィンドウがアクティブな場合、ミニバッファーウィンド
     ウは通常は考慮される(そのため、この関数は‘nil’をリターンする)。しか
     し、オプション引数NO-MINIが非‘nil’の場合は、たとえアクティブであっ
     ても、ミニバッファーウィンドウは無視される。オプション引数
     ALL-FRAMESは、‘next-window’の場合と同じ意味をもつ。

   以下は、何らかの条件を満足するウィンドウを、それらを選択することなく
リターンする関数です:

 -- Function: get-lru-window &optional all-frames dedicated not-selected
     この関数は、発見的には“もっとも最近に使用された”ウィンドウであるよ
     うな、生きたウィンドウをリターンする。オプション引数ALL-FRAMESは、
     ‘next-window’の場合と同じ意味をもつ。

     フル幅のウィンドウが存在する場合は、それらのウィンドウだけが考慮さ
     れる。ミニバッファーが候補になることは、決してない。オプション引数
     DEDICATEDが‘nil’の場合は、専用のバッファー(*note Dedicated
     Windows::を参照)が候補になることは、決してない。唯一の候補が選択さ
     れたウィンドウである場合以外は、決して選択されたウィンドウをリター
     ンしない。しかし、オプション引数NOT-SELECTEDが非‘nil’ならば、そのよ
     うな場合でもこの関数は‘nil’をリターンする。

 -- Function: get-largest-window &optional all-frames dedicated
          not-selected
     この関数は、もっとも大きいエリア(高さ掛ける幅)をもつウィンドウをリ
     ターンする。オプション引数ALL-FRAMESは検索するウィンドウを指定し、
     意味は‘next-window’の場合と同様。

     ミニバッファーウィンドウは決して候補とならない。オプション引数
     DEDICATEDが‘nil’の場合、専用ウィンドウ(*note Dedicated Windows::ウ
     ィンドウを参照)は決して候補にならない。オプション引数NOT-SELECTEDが
     非‘nil’の場合、選択されたウィンドウは決して候補にならない。オプショ
     ン引数NOT-SELECTEDが非‘nil’、かつ唯一の候補が選択されたウィンドウの
     場合、この関数は‘nil’をリターンする。

     同サイズの候補ウィンドウが2つある場合、この関数はウィンドウのサイク
     ル順で、選択されたウィンドウから数えて最初にあるウィンドウを優先す
     る。

 -- Function: get-window-with-predicate predicate &optional minibuf
          all-frames default
     この関数は、ウィンドウのサイクル順内の各ウィンドウにたいして、その
     ウィンドウを引数に、関数PREDICATEを順に呼び出す。いずれかのウィンド
     ウにたいしてPREDICATEが非‘nil’をリターンした場合、この関数は処理を
     停止して、そのウィンドウをリターンする。そのようなうｌが見つからな
     ければ、リターン値はDEFAULT(これのデフォルトは‘nil’)となる。

     オプション引数 MINIBUFとALL-FRAMESは検索するウィンドウを指定し、意
     味は‘next-window’の場合と同様である。


File: elisp,  Node: Buffers and Windows,  Next: Switching Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

27.10 Buffers and Windows
=========================

このセクションでは、ウィンドウのコンテンツを調べたりセットするための、低
レベルな関数を説明します。ウィンドウ内に特定のバッファーを表示するための
高レベルな関数については、*note Switching Buffers::を参照してください。

 -- Function: window-buffer &optional window
     この関数は、WINDOWが表示しているバッファーをリターンする。WINDOWが
     省略または‘nil’の場合のデフォルトは、選択されたウィンドウである。
     WINDOWが内部ウィンドウの場合、この関数は‘nil’をリターンする。

 -- Function: set-window-buffer window buffer-or-name &optional
          keep-margins
     この関数は、 WINDOWにBUFFER-OR-NAMEウィンドウ表示させる。WINDOWは生
     きたウィンドウであること。‘nil’の場合のデフォルトは、選択されたウィ
     ンドウである。BUFFER-OR-NAMEは、バッファー、あるいは既存のバッファ
     ー名であること。この関数は、選択されていたウィンドウを変更せず、カ
     レントバッファーも直接は変更しない(*note Current Buffer::を参照)。
     リターン値は‘nil’である。

     WINDOWが、あるバッファーにたいして“特に専用”で、かつ
     BUFFER-OR-NAMEがそのバッファーを指定しない場合、この関数はエラーを
     シグナルする。*note Dedicated Windows::を参照のこと。

     デフォルトでは、この関数は指定されたバッファーのローカル変数にもと
     づいて、WINDOWの位置、ディスプレイマージン、フリンジ幅、スクロール
     バーのセッティングをリセットする。しかし、オプション引数
     KEEP-MARGINSが非‘nil’の場合は、ディスプレイマージンとフリンジ幅は未
     変更のままにする。

     アプリケーションを記述する際は、直接‘set-window-buffer’を呼び出すの
     ではなく、通常は*note Switching Buffers::で説明する高レベルの関数を
     使用するべきである。

     これは、‘window-scroll-functions’の後に
     ‘window-configuration-change-hook’を実行する。*note Window Hooks::を
     参照のこと。

 -- Variable: buffer-display-count
     このバッファーローカル変数は、ウィンドウ内にバッファーが表示された
     回数を記録する。。これは、そのバッファーにたいして
     ‘set-window-buffer’が呼び出されるたびに増分される

 -- Variable: buffer-display-time
     このバッファーローカル変数は、バッファーがウィンドウに最後に表示さ
     れた時刻を記録する。バッファーが表示されたことがない場合は、‘nil’を
     リターンする。これは、そのバッファーにたいして‘set-window-buffer’が
     呼び出されるたびに、‘current-time’がリターンする値により更新される
     (*note Time of Day::を参照)。

 -- Function: get-buffer-window &optional buffer-or-name all-frames
     この関数は、ウィンドウのサイクル順内で、選択されたウィンドウを起点
     に、BUFFER-OR-NAMEを表示する最初のウィンドウをリターンする.<(*note
     Cyclic Window Ordering::を参照)。そのようなウィンドウが存在しない場
     合、リターン値は‘nil’となる。

     BUFFER-OR-NAMEはバッファーか、バッファーの名前であること。省略また
     は‘nil’の場合のデフォルトは、カレントバッファーである。オプション引
     数ALL-FRAMESは、考慮するウィンドウを指定する。

        • ‘t’は、すべての既存フレーム上のウィンドウを考慮することを意味
          する。
        • ‘visible’は、すべての可視フレーム上のウィンドウを考慮すること
          を意味する。
        • 0は、すべての可視またはアイコン化されたフレーム上のウィンドウ
          を考慮することを意味する。
        • フレームを指定した場合は、そのフレーム上のウィンドウだけを考慮
          することを意味する。
        • その他の値は、選択されたフレーム上のウィンドウを考慮することを
          意味する。

     これらの意味は、‘next-window’のALL-FRAMES引数の場合とは若干異なるこ
     とに注意されたい(*note Cyclic Window Ordering::を参照)。この不一致
     の解消のために、EEmacsの将来のバージョンにおいて、この関数は変更さ
     れるかもしれない。

 -- Function: get-buffer-window-list &optional buffer-or-name minibuf
          all-frames
     この関数は、その時点でBUFFER-OR-NAMEを表示する、すべてのウィンドウ
     のリストをリターンする。BUFFER-OR-NAMEはバッファー、または既存バッ
     ファーの名前であること。省略または‘nil’の場合のデフォルトは、カレン
     トバッファーである。

     引数MINIBUFとALL-FRAMESは、関数‘next-window’の場合と同じ意味をもつ
     (*note Cyclic Window Ordering::を参照)。ALL-FRAMES引数は、
     ‘get-buffer-window’の場合と正確に同じようには_振る舞わない_ことに注
     意すること。

 -- Command: replace-buffer-in-windows &optional buffer-or-name
     このコマンドは、BUFFER-OR-NAMEを表示しているすべてのウィンドウで、
     それを他の何らかのバッファーに置き換える。BUFFER-OR-NAMEはバッファ
     ー、または既存のバッファーの名前であること。省略または‘nil’の場合の
     デフォルトは、カレントバッファーである。

     各ウィンドウで置き換えられるバッファーは、‘switch-to-prev-buffer’を
     通じて選択される(*note Window History::を参照)。BUFFER-OR-NAMEを表
     示している専用ウィンドウはすべて、可能なら削除される(*note
     Dedicated Windows::を参照)。そのようなウィンドウがそのフレームで唯
     一のウィンドウで、かつ同一端末上に他のフレームが存在する場合は、そ
     のフレームも同様に削除される。その端末上の唯一のフレームの唯一のウ
     ィンドウの場合は、いずれにせよそのバッファーは置き換えられる。


File: elisp,  Node: Switching Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

27.11 Switching to a Buffer in a Window
=======================================

このセクションでは、あるウィンドウ内で特定のバッファーにスイッチするため
の、高レベルな関数について説明します。“バッファーをスイッチする”とは一般
的に、(1)そのバッファーをあるウィンドウに表示して、(2)そのウィンドウを選
択されたウィンドウとし(かつそのフレームを選択されたフレームとし、(3)その
バッファーウィンドウカレントバッファーにすることを意味します。

   Lispプログラムがアクセスや変更できるように、バッファーを一時的にカレ
ントにするのにこれらの関数を_使用しないでください_。これらはウィンドウヒ
ストリー(*note Window History::を参照)の変更のような副作用をもつので、そ
のような方法での使用はユーザーを驚かせることになるでしょう。バッファーを
Lispで変更するためにカレントにしたい場合は‘with-current-buffer’、
‘save-current-buffer’、‘set-buffer’を使用します。*note Current Buffer::を
参照してください。

 -- Command: switch-to-buffer buffer-or-name &optional norecord
          force-same-window
     このコマンドは、選択されたウィンドウ内でBUFFER-OR-NAMEを表示して、
     それをカレントバッファーにしようと試みる。これはよくインタラクティ
     ブ(‘C-x b’のバインディングで)に使用され、同様にLispプログラムでも使
     用される。リターン値はスイッチしたバッファーである。

     BUFFER-OR-NAMEが‘nil’の場合のデフォルトは、‘other-buffer’によりリタ
     ーンされるバッファーになる(*note Buffer List::を参照)。
     BUFFER-OR-NAMEが既存のバッファーの名前でない文字列の場合、この関数
     はその名前で新たにバッファーを作成する。新たなバッファーのメジャー
     モードは、変数‘major-mode’により決定される(*note Major Modes::を参
     照)。

     通常は、指定されたバッファーはバッファーリスト — グローバルバッファ
     ーリストと選択されたフレームのバッファーリストの両方の先頭に置かれ
     る(*note Buffer List::を参照)。しかし、オプション引数NORECORDが非
     ‘nil’なら、これは行われない。

     ‘switch-to-buffer’が、選択されたウィンドウ内にバッファーを表示する
     のが不可能なことが時折ある。これは、選択されたウィンドウがミニバッ
     ファーウィンドウの場合や、選択されたウィンドウがそのバッファーにた
     いして特に専用(strongly dedicated)な場合に発生する(*note Dedicated
     Windows::を参照)。この場合、このコマンドは‘pop-to-buffer’(以下参照
     )を呼び出すことにより、通常は何か他のウィンドウにそのバッファーの表
     示を試みる。しかし、オプション引数が非‘nil’なら、かわりにエラーをシ
     グナルする。

   デフォルトでは、‘switch-to-buffer’はバッファーの‘point’位置でバッファ
ーを表示します。この振る舞いは、以下のオプションを使用して調整できます。

 -- User Option: switch-to-buffer-preserve-window-point
     この変数が‘nil’の場合、‘switch-to-buffer’はBUFFER-OR-NAMEにより指定
     されたバッファーを、そのバッファーの‘point’位置で表示する。この変数
     が‘already-displayed’なら、そのバッファーが任意の可視またはアイコン
     化されたフレーム上の他のウィンドウで表示されている場合は、選択され
     たウィンドウ内の以前の位置でのバッファーの表示を試みる。この変数が
     ‘t’なら、‘switch-to-buffer’は選択されたウィンドウ内の以前の位置でそ
     のバッファーを表示しようと試みる。

     この変数は、バッファーがすでに選択されたウィンドウに表示されている
     か、これまで表示されたことがない、またはバッファーを表示するために
     ‘switch-to-buffer’が‘pop-to-buffer’を呼び出した場合は無視される。

   以下の2つのコマンドは、説明している機能以外は‘switch-to-buffer’と類似
しています。

 -- Command: switch-to-buffer-other-window buffer-or-name &optional
          norecord
     この関数は、BUFFER-OR-NAMEで指定されたバッファーを、選択されたウィ
     ンドウ以外の、別のウィンドウに表示する。これは関数
     ‘pop-to-buffer’(以下参照)を内部で使用する。

     選択されたウィンドウが指定されたバッファーをすでに表示している場合
     は表示を続けるが、見つかった他のウィンドウも同様にそのバッファーを
     表示する。

     引数BUFFER-OR-NAMEとNORECORDは、‘switch-to-buffer’の場合と同じ意味
     をもつ。

 -- Command: switch-to-buffer-other-frame buffer-or-name &optional
          norecord
     この関数は、BUFFER-OR-NAMEで指定されたバッファーを、新たなフレーム
     に表示する。これは関数‘pop-to-buffer’(以下参照)を内部で使用する。

     指定されたバッファーがすでにカレント端末上の任意のフレームの他のウ
     ィンドウに表示されている場合、これはフレームを新たに作成せずにその
     ウィンドウに切り替える。しかし、これを行うために選択されたウィンド
     ウを使用することは決してない。

     引数BUFFER-OR-NAMEとNORECORDは、‘switch-to-buffer’の場合と同じ意味
     をもつ。

   上述したコマンドは、任意のウィンドウにバッファーを柔軟に表示して、編
集用にそのウィンドウを選択する関数‘pop-to-buffer’を使用しています。次に
、‘pop-to-buffer’はバッファーの表示に‘display-buffer’を使用します。した
がって、‘display-buffer’に影響する変数も、同様に影響します。
‘display-buffer’のドキュメントについては、*note Choosing Window::を参照
してください。

 -- Command: pop-to-buffer buffer-or-name &optional action norecord
     この関数は、BUFFER-OR-NAMEをカレントバッファーにして、なるべく前に
     選択されていたウィンドウではないウィンドウにそれを表示する。そして
     その後に、表示しているウィンドウを選択する。そのウィンドウが別のグ
     ラフィカルなフレーム上にある場合は、可能ならそのフレームが入力フォ
     ーカスを与えられる(*note Input Focus::を参照)。リターン値は、切り替
     えたバッファーである。

     BUFFER-OR-NAMEが‘nil’の場合のデフォルトは、‘other-buffer’によりリタ
     ーンされるバッファーになる(*note Buffer List::を参照)。
     BUFFER-OR-NAMEが既存のバッファーの名前でない文字列の場合、この関数
     はその名前で新たにバッファーを作成する。新たなバッファーのメジャー
     モードは、変数‘major-mode’により決定される(*note Major Modes::を参
     照)。

     ACTIONが非‘nil’の場合、それは‘display-buffer’に渡すディスプレイアク
     ション(display action)であること(*note Choosing Window::を参照)。非
     ‘nil’、非リスト値の場合は、たとえそのバッファーがすでに選択されたウ
     ィンドウに表示されていたとしても、選択されたウィンドウではなく、ウ
     ィンドウをポップ(pop)することを意味する。

     ‘switch-to-buffer’と同様、NORECORDが‘nil’なら、この関数はバッファー
     リストを更新する。


File: elisp,  Node: Choosing Window,  Next: Display Action Functions,  Prev: Switching Buffers,  Up: Windows

27.12 Choosing a Window for Display
===================================

コマンド‘display-buffer’は、表示のために柔軟にウィンドウを選択して、その
ウィンドウ内に指定されたバッファーを表示します。これは、キーバインディン
グ‘C-x 4 C-o’を通じて、インタラクティブに呼び出すことができます。また、
‘switch-to-buffer’や‘pop-to-buffer’を含む、多くの関数およびコマンドによ
り、サブルーチンとしても使用されます(*note Switching Buffers::を参照)。

   このコマンドは、ウィンドウ内に表示するウィンドウを探すために、いくつ
かの複雑なステップを実行します。これらのステップは“ディスプレイアクショ
ン(display actions)”を用いて記述されます。ディスプレイアクションは、
‘(FUNCTION . ALIST)’という形式をもちます。ここで、FUNCTIONは関数、または
関数リストで、わたしたちはこれを“アクション関数(action functions)”として
参照します。ALISTは連想リスト(association list)で、わたしたちはこれを“ア
クションalist(action alists)”として参照します。

   アクション関数は、表示するバッファーと、アクションalistという、2つの
引数を受け取ります。これは、自身の条件にしたがってウィンドウウィンドウ選
択、または作成して、バッファーをウィンドウ内に表示します。成功した場合は
そのウィンドウ、それ以外は‘nil’をリターンします。事前定義されたアクショ
ン関数については、*note Display Action Functions::を参照してください。

   ‘display-buffer’は、複数ソースからのディスプレイアクションを組み合わ
せて、アクション関数のいずれか1つがバッファーの表示を管理して非‘nil’値を
リターンするまで、アクション関数を順に呼び出します。

 -- Command: display-buffer buffer-or-name &optional action frame
     このコマンドは、ウィンドウウィンドウ選択したり、そのバッファーをカ
     レントにすることなく、BUFFER-OR-NAMEをウィンドウに表示させる。引数
     BUFFER-OR-NAMEはバッファー、または既存のバッファーの名前でなければ
     ならない。リターン値は、そのバッファーを表示するために選ばれたウィ
     ンドウである。

     オプション引数ACTIONが非‘nil’の場合、それは通常はディスプレイアクシ
     ョン(上述)であること。‘display-buffer’は、以下のソース(記載順)から
     ディスプレイアクションを集約して、アクション関数リストとアクション
     alistを構築する:

        • 変数‘display-buffer-overriding-action’。

        • ユーザーオプション‘display-buffer-alist’。

        • ACTION引数。

        • ユーザーオプション‘display-buffer-base-action’。

        • 定数‘display-buffer-fallback-action’。

     各アクション関数は、いずれかが非‘nil’をリターンするまで、第1引数に
     バッファー、第2引数に組み合わせられたアクションalistで、順番に呼び
     出される。呼び出し側は、ウィンドウ内にバッファーを表示しない場合を
     処理する用意があることを示すために、アクションalistの要素として
     ‘(allow-no-window . t)’を渡すことができる。

     引数ACTIONには非‘nil’の非list値も指定できる。これは、たとえ選択され
     たウィンドウがすでにそのバッファーを表示していても、選択されたウィ
     ンドウではない別のウィンドウにバッファーが表示されるべきだという、
     特別な意味をもつ。プレフィックス引数とともにインタラクティブに呼び
     出された場合、ACTIONは‘t’である。

     オプション引数FRAMEが非‘nil’の場合は、そのバッファーがすでに表示さ
     れているか判断する際、どのフレームをチェックするかを指定する。これ
     はACTIONのアクションalistに、要素‘(reusable-frames . FRAME)’を追加
     するのと等価である。*note Display Action Functions::を参照のこと。

 -- Variable: display-buffer-overriding-action
     この変数の値は、‘display-buffer’により最高の優先順で扱われるディス
     プレイアクションであること。デフォルト値は空(つまり‘(nil . nil)’)で
     ある。

 -- User Option: display-buffer-alist
     このオプションの値は、ディスプレイアクションにコンディション
     (condition: 状態)をマップするalistである。コンディションはそれぞれ
     、バッファー名にマッチする正規表現か、2つの引数をとる関数で、引数は
     バッファー名と‘display-buffer’に渡すACTION引数である。
     ‘display-buffer’に渡されたバッファー名がこのalist内の正規表現にマッ
     チするか、コンディションで指定された関数が非‘nil’をリターンした場合
     、‘display-buffer’はバッファーを表示すために、対応するディスプレイ
     アクションを使用する。

 -- User Option: display-buffer-base-action
     このオプションの値は、ディスプレイアクションであること。このオプシ
     ョンは、‘display-buffer’呼び出しにたいする、“標準”のディスプレイア
     クションを定義するために使用できる。

 -- Constant: display-buffer-fallback-action
     このディスプレイアクションは、‘display-buffer’にたいして、他のディ
     スプレイアクションが与えられなかった場合の代替え処理を指定する。


File: elisp,  Node: Display Action Functions,  Next: Choosing Window Options,  Prev: Choosing Window,  Up: Windows

27.13 Action Functions for ‘display-buffer’
===========================================

以下の基本的なアクション関数がEmacs内で定義されています。これらの関数は
それぞれ表示するバッファーBUFFERと、アクションalistという、2つの引数をと
ります。それぞれのアクション関数は、成功した場合はウィンドウ、失敗したら
‘nil’をリターンします。

 -- Function: display-buffer-same-window buffer alist
     この関数は、選択されたウィンドウ内に、BUFFERの表示を試みる。選択さ
     れたウィンドウがミニバッファーウィンドウや、他のバッファー専用
     (*note Dedicated Windows::を参照)の場合は失敗する。ALISTに非‘nil’の
     ‘inhibit-same-window’エントリーがある場合も失敗する。

 -- Function: display-buffer-reuse-window buffer alist
     この関数は、すでにBUFFERを表示しているウィンドウを探すことにより、
     バッファーの“表示”を試みる。

     ALISTに非‘nil’の‘inhibit-same-window’エントリーがある場合、選択され
     たウィンドウは再利用に適さない。ALISTに‘reusable-frames’エントリー
     が含まれる場合、その値により再利用可能なウィンドウをどのフレームで
     検索するか決定される:

        • ‘nil’は、選択されたフレーム(実際には最後の非ミニバッファーフレ
          ーム)上のウィンドウを考慮することを意味する。
        • ‘t’は、すべてのフレーム上のウィンドウを考慮することを意味する
          。
        • ‘visible’は、すべての可視フレーム上のウィンドウを考慮すること
          を意味する。
        • 0は、すべての可視またはアイコン化されたフレーム上のウィンドウ
          を考慮することを意味する。
        • フレームを指定した場合は、そのフレーム上のウィンドウだけを考慮
          することを意味する。

     これらは、‘next-window’にたいするALL-FRAMES引数の場合とは若干異なる
     ことに注意(*note Cyclic Window Ordering::を参照)。

     ALISTに‘reusable-frames’エントリーが含まれない場合、通常この関数は
     選択されたフレームだけを検索する。しかし、変数‘pop-up-frames’が非
     ‘nil’なら、カレント端末上のすべてのフレームを検索する。*note
     Choosing Window Options::を参照。

     この関数が他のフレーム上のウィンドウを選択した場合は、そのフレーム
     を可視にするとともに、ALISTが‘inhibit-switch-frame’エントリー(*note
     Choosing Window Options::を参照)を含んでいなければ、必要ならそのフ
     レームを最前面に移動(raise)する。

 -- Function: display-buffer-pop-up-frame buffer alist
     この関数は、新たにフレームを作成して、そのフレームのウィンドウ内に
     バッファーを表示する。これは実際には、‘pop-up-frame-function’(*note
     Choosing Window Options::を参照)内で指定された関数を呼び出すことに
     より、フレーム作成を行う。ALISTが‘pop-up-frame-parameters’エントリ
     ーを含む場合は、その連想値(associated value)が新たに作成されたフレ
     ームのパラメーターに追加される。

 -- Function: display-buffer-pop-up-window buffer alist
     この関数は、最大もしくはもっとも長い間参照されていない(LRU: least
     recently-used)ウィンドウを分割することにより、BUFFERの表示を試みる
     。これは実際には、‘split-window-preferred-function’(*note Choosing
     Window Options::を参照)内で指定された関数を呼び出すことにより分割を
     行う。

     新たなウィンドウのサイズは、ALISTにエントリー‘window-height’と
     ‘window-width’を与えることにより調整できる。ウィンドウの高さを調整
     するには、CARが‘window-height’でCDRが以下のいずれかであるようなエン
     トリーを使用する:

        • ‘nil’は、新たなウィンドウの高さを変更しないことを意味する。

        • 数字は、新たなウィンドウの高さを指定する。整数は、ウィンドウの
          行数を指定する。浮動小数点数は、そのフレームのルートウィンドウ
          にたいするウィンドウの高さの割合を与える。

        • CDRが関数を指定する場合、その関数は新たなウィンドウを引数とし
          て呼び出される関数である。この関数は、そのウィンドウの高さを調
          整することを期待されており、リターン値は無視される。これに適し
          た関数は‘shrink-window-if-larger-than-buffer’および
          ‘fit-window-to-buffer’である。*note Resizing Windows::を参照の
          こと。

     ウィンドウの幅を調整するには、CARが‘window-width’でCDRが以下のいず
     れかであるようなエントリーを使用する:

        • ‘nil’は、新たなウィンドウの幅を変更しないことを意味する。

        • 数字は、新たなウィンドウの幅を指定する。整数は、ウィンドウの列
          数を指定する。浮動小数点数は、そのフレームのルートウィンドウに
          たいするウィンドウの幅の割合を与える。

        • CDRが関数を指定する場合、その関数は新たなウィンドウを引数とし
          て呼び出される関数である。この関数は、そのウィンドウの幅を調整
          することを期待されており、リターン値は無視される。

     この関数は、何らかの理由により分割を行えるウィンドウが存在しない場
     合は、失敗する可能性がある(選択されたフレームがフレームパラメーター
     ‘unsplittable’をもつ場合等。*note Buffer Parameters::を参照のこと
     )。

 -- Function: display-buffer-below-selected buffer alist
     この関数は、選択されたウィンドウの下のウィンドウ内にBUFFERの表示を
     試みる。これは選択されたウィンドウの分割、または選択されたウィンド
     ウの下のウィンドウの使用を意味する。新たにウィンドウを作成した場合
     は、ALISTに適切な‘window-height’または‘window-width’エントリーが含
     まれていれば、サイズの調整も行うだろう。上記を参照のこと。

 -- Function: display-buffer-in-previous-window buffer alist
     この関数は、以前にBUFFERを表示していたウィンドウ内に、そのバッファ
     ーの表示を試みる。ALISTに非‘nil’の‘inhibit-same-window’エントリーが
     ある場合、選択されたウィンドウは再利用に適さない。ALISTに
     ‘reusable-frames’エントリーが含まれる場合、その値は
     ‘display-buffer-reuse-window’と同様、適正なウィンドウをどのフレーム
     から検索するかを決定する。

     ALISTに‘previous-window’エントリーがある場合は、そのエントリーによ
     り指定されたウィンドウは、たとえそのウィンドウが以前にBUFFERを表示
     したことが一度もなくても、上記メソッドが見つけた他のすべてのウィン
     ドウをオーバーライドするだろう。

 -- Function: display-buffer-at-bottom buffer alist
     この関数は、選択されたフレームの最下にあるウィンドウ内にBUFFERの表
     示を試みる。

     これは、フレーム最下のウィンドウまたはフレームのルートウィンドウを
     分割するか、選択されたフレーム最下の既存ウィンドウを再利用する。

 -- Function: display-buffer-use-some-window buffer alist
     この関数は、既存のウィンドウを選択して、そのウィンドウ内にBUFFERを
     表示することにより、バッファーの表示を試みる。すべてのウィンドウが
     他のバッファー専用の場合、この関数は失敗する可能性がある(*note
     Dedicated Windows::を参照)。

 -- Function: display-buffer-no-window buffer alist
     ALISTに非‘nil’の‘allow-no-window’エントリーがある場合、この関数は
     ‘buffer’を表示しない。これにより、デフォルトの動作をオーバーライド
     して、バッファーの表示を避けることができる。これは、呼び出し側が
     ‘allow-no-window’に非‘nil’値を指定して、‘display-buffer’からリター
     ンされた‘nil’値を処理できるようなケースを想定している。

   アクション関数を説明するために、以下の例を考えてみましょう。

     (display-buffer
      (get-buffer-create "*foo*")
      '((display-buffer-reuse-window
         display-buffer-pop-up-window
         display-buffer-pop-up-frame)
        (reusable-frames . 0)
        (window-height . 10) (window-width . 40)))

上記のフォームを評価することにより、以下のように‘display-buffer’が実行さ
れます: (1)*foo*と呼ばれるバッファーが、すでに可視またはアイコン化された
フレームに表示されている場合は、そのウィンドウを再利用する。 (2)それ以外
の場合は、新たなウィンドウをポップアップするか、それが不可能なら新たなフ
レームでバッファーを表示する。(3) すべてのステップが失敗した場合は、それ
が何であれ‘display-buffer-base-action’および
‘display-buffer-fallback-action’が指示するものを使用して処理を行う。

   さらに‘display-buffer’は、(‘display-buffer’により*foo*が前からそこに
配置されていた場合は)再使用されるウィンドウ、およびポップアップされたウ
ィンドウにたいして調整を試みます。そのウィンドウが垂直コンビネーションの
一部なら、高さはその行数にセットされるでしょう。数字“10”のかわりに関数
‘fit-window-to-buffer’を指定した場合、‘display-buffer’は空のバッファーに
フィットするようにウィンドウを1行にセットするでしょう。ウィンドウが水平
コンビネーションの一部なら、列数を40にセットします。新たなウィンドウが垂
直または水平に組み合わせられるかは、ウィンドウの分割方向と
‘split-window-preferred-function’、‘split-height-threshold’、
‘split-width-threshold’の値に依存します(*note Choosing Window Options::を
参照)。

   ここで、事前に以下のような‘display-buffer-alist’にたいするセットアッ
プが存在していて、この呼び出しを組み合わせたとしましょう。

     (let ((display-buffer-alist
            (cons
             '("\\*foo\\*"
               (display-buffer-reuse-window display-buffer-below-selected)
               (reusable-frames)
               (window-height . 5))
             display-buffer-alist)))
       (display-buffer
        (get-buffer-create "*foo*")
        '((display-buffer-reuse-window
           display-buffer-pop-up-window
           display-buffer-pop-up-frame)
          (reusable-frames . 0)
          (window-height . 10) (window-width . 40))))

このフォームは、まず選択されたフレーム上で*foo*を表示しているウィンドウ
を再利用するよう、‘display-buffer’に試みさせます。そのようなウィンドウが
存在しなければ、選択されたウィンドウの分割を試み、またはそれが不可能なら
選択されたウィンドウの下のウィンドウを使用します。

   選択されたウィンドウの下にウィンドウがない、あるいは下のウィンドウが
それのバッファーに専用の場合、‘display-buffer’は前の例で説明したように処
理を行うでしょう。しかし、再利用されたウィンドウやポップアップされたウィ
ンドウの高さ調整を試みる場合は、‘display-buffer’のACTION引数内の行数に対
応する指定をオーバーライドする、行数“5”へのセットを試みることに注意して
ください。


File: elisp,  Node: Choosing Window Options,  Next: Window History,  Prev: Display Action Functions,  Up: Windows

27.14 Additional Options for Displaying Buffers
===============================================

‘display-buffer’の標準のディスプレイアクション(*note Choosing Window::)は
、さまざまなユーザーオプションにより変更が可能です。

 -- User Option: pop-up-windows
     この変数の値が非‘nil’の場合、‘display-buffer’は表示のために既存のバ
     ッファーを分割して新たなウィンドウの作成を許される。

     この変数は、主に後方互換のために提供される。値が‘nil’のときは、アク
     ション関数‘display-buffer-pop-up-window’(*note Display Action
     Functions::を参照)を呼び出すだけの
     ‘display-buffer-fallback-action’内の特別なメカニズムを経由して、
     ‘display-buffer’にしたがう。この変数は、‘display-buffer-alist’等に
     より直接指定できる、‘display-buffer-pop-up-window’自体からは参照さ
     れない。

 -- User Option: split-window-preferred-function
     この変数は、バッファーを表示する新たなウィンドウを作成するための、
     ウィンドウを分割する関数を指定する。これは、実際にウィンドウを分割
     するために、アクション関数‘display-buffer-pop-up-window’により使用
     される(*note Display Action Functions::を参照)。

     デフォルト値は‘split-window-sensibly’で、これは以下で記述する。値は
     、ウィンドウを引数とする関数でなければならず、(要求されたバッファー
     を表示するために使用されるであろう)新たなウィンドウ、または‘nil’(分
     割の失敗を意味する)をリターンしなければならない。

 -- Function: split-window-sensibly window
     この関数は、WINDOWを分割して、新たに作成したウィンドウをリターンす
     る。WINDOWを分割できなければ、‘nil’をリターンする。

     この関数は、ウィンドウが分割できるかどうか判断する際の、通常のルー
     ルにしたがう(*note Splitting Windows::を参照)。最初にまず、
     ‘split-height-threshold’(以下参照)、およびその他が課す制約の元、新
     たなウィンドウが下になるように分割を試みる。これが失敗したら、
     ‘split-width-threshold’(以下参照)が課す制約の元、新たなウィンドウが
     右になるように分割を試みる。これが失敗して、かつそのウィンドウがそ
     のフレームの唯一のウィンドウの場合、この関数は
     ‘split-height-threshold’を無視して、新たなウィンドウが下になるよう
     、再度分割を試みる。これも同様に失敗したら、この関数は諦めて‘nil’を
     リターンする。

 -- User Option: split-height-threshold
     これは‘split-window-sensibly’により使用される変数であり、ウィンドウ
     を分割して新たなウィンドウを下に配置するかどうかを指定する。整数の
     場合は、元のウィンドウが最低でもその行数なければ分割しないことを意
     味する。‘nil’の場合は、この方法では分割しないことを意味する。

 -- User Option: split-width-threshold
     これは‘split-window-sensibly’により使用される変数であり、ウィンドウ
     を分割して新たなウィンドウを右に配置するかどうかを指定する。整数の
     場合は、元のウィンドウが最低でもその列数なければ分割しないことを意
     味する。‘nil’の場合は、この方法では分割しないことを意味する。

 -- User Option: pop-up-frames
     この変数の値が非‘nil’の場合、新たにフレームを作成することにより
     ‘display-buffer’がバッファーを表示できることを意味する。デフォルト
     は‘nil’。

     非‘nil’値は、‘display-buffer’がすでにBUFFER-OR-NAMEを表示しているウ
     ィンドウを探す際に、選択されたフレームだけでなく、可視およびアイコ
     ン化されたフレームを検索できることも意味する。

     この変数は主に、後方互換のために提供されている。値が非‘nil’のときは
     、アクション関数‘display-buffer-pop-up-frame’(*note Display Action
     Functions::を参照)を呼び出すだけの
     ‘display-buffer-fallback-action’内の特別なメカニズムを経由して、
     ‘display-buffer’にしたがう。この変数は、‘display-buffer-alist’等に
     より直接指定できる、‘display-buffer-pop-up-window’自体からは参照さ
     れない(これはウィンドウの分割前に行われる)。この変数は、
     ‘display-buffer-alist’等により直接指定できる、
     ‘display-buffer-pop-up-frame’自体からは参照されない。

 -- User Option: pop-up-frame-function
     この変数は、バッファーを表示する新たなウィンドウを作成するための、
     フレームを作成する関数を指定する。これは、アクション関数
     ‘display-buffer-pop-up-frame’により使用される(*note Display Action
     Functions::を参照)。

     値は、フレームまたはフレームを作成できなかった場合は‘nil’をリターン
     する、引数をとらない関数であること。デフォルト値は、
     ‘pop-up-frame-alist’(以下参照)により指定されるパラメーターを使用し
     てフレームを作成する関数である。

 -- User Option: pop-up-frame-alist
     この変数は、フレームを新たに作成するための‘pop-up-frame-function’の
     デフォルト関数により使用される、フレームパラメーター(*note Frame
     Parameters::を参照)のalistを保持する。デフォルトは‘nil’。

 -- User Option: same-window-buffer-names
     選択されたウィンドウ内に表示されるべきバッファー名のリスト。このリ
     スト内にバッファーの名前がある場合、‘display-buffer’は選択されたウ
     ィンドウ内にそのバッファーを表示することにより、そのバッファーを処
     理する。

 -- User Option: same-window-regexps
     選択されたウィンドウ内に表示されるバッファーを指定する、正規表現の
     リスト。バッファー名がこのリスト内の正規表現のいずれかにマッチする
     場合、‘display-buffer’は選択されたウィンドウ内にそのバッファーを表
     示することにより、そのバッファーを処理する。

 -- Function: same-window-p buffer-name
     この関数は、BUFFER-NAMEという名前のバッファーを‘display-buffer’で表
     示する場合、それが選択されたウィンドウ内に表示されるバッファーなら
     ‘t’をリターンする。


File: elisp,  Node: Window History,  Next: Dedicated Windows,  Prev: Choosing Window Options,  Up: Windows

27.15 Window History
====================

ウィンドウはそれぞれ、リスト内に以前表示されていたバッファーと、それらの
バッファーがウィンドウから削除された順序を記憶しています。このヒストリー
が、たとえば‘replace-buffer-in-windows’(*note Buffers and Windows::を参
照)により使用されます。このリストはEmacsにより自動的に保守されますが、こ
れを明示的に調べたり変更するために、以下の関数を使用できます:

 -- Function: window-prev-buffers &optional window
     この関数は、WINDOWの前のコンテンツを指定するリストをリターンする。
     オプション引数WINDOWには生きたウィンドウを指定すべきであり、デフォ
     ルトは選択されたウィンドウである。

     リスト要素はそれぞれ、‘(BUFFER WINDOW-START WINDOW-POS)’という形式
     をもつ。ここでBUFFERは、そのウィンドウで前に表示されていたウィンド
     ウ、WINDOW-STARTはそのバッファーが最後に表示されていたときのウィン
     ドウのスタート位置(*note Window Start and End::を参照)、
     WINDOW-POSはWINDOW内にそのバッファーが最後に表示されていたときのポ
     イント位置(*note Window Point::を参照)である。

     このリストは順序付きで、より前の要素がより最近に表示されたバッファ
     ーに対応しており、通常は最初の要素がそのウィンドウからもっとも最近
     削除されたバッファーに対応する。

 -- Function: set-window-prev-buffers window prev-buffers
     この関数は、WINDOWの前のバッファーを、PREV-BUFFERSの値にセットする
     。引数WINDOWは生きたウィンドウでなければならず、デフォルトは選択さ
     れたウィンドウである。引数PREV-BUFFERSは、‘window-prev-buffers’によ
     りリターンされるリストと同じ形式であること。

   これらに加えて、それぞれのバッファーは“次バッファー(next buffers)”の
リストを保守します。これは‘switch-to-prev-buffer’(以下参照)により再表示
されたバッファーのリストです。このリストは主に、切り替えるバッファーを選
択するために、‘switch-to-prev-buffer’と‘switch-to-next-buffer’により使用
されます。

 -- Function: window-next-buffers &optional window
     この関数は、‘switch-to-prev-buffer’を通じてWINDOW内に最近表示された
     バッファーのリストをリターンする。WINDOW引数は、生きたウィンドウか
     ‘nil’(選択されたウィンドウの意)でなければならない。

 -- Function: set-window-next-buffers window next-buffers
     この関数は、WINDOWの次バッファーリストを、NEXT-BUFFERSにセットする
     。WINDOW引数は、生きたウィンドウか‘nil’(選択されたウィンドウの意)で
     あること。引数NEXT-BUFFERSは、バッファーのリストであること。

   以下のコマンドは、‘bury-buffer’や‘unbury-buffer’のように、グローバル
バッファーリストを巡回するために使用できます。ただし、これらはグローバル
バッファーリストではなく、指定されたウィンドウのヒストリーリストのしたが
って巡回します。それに加えて、これらはウィンドウ固有なウィンドウのスター
ト位置とポイント位置をリストアし、すでに他のウィンドウに表示されているバ
ッファーをも表示できます。特に‘switch-to-prev-buffer’コマンドは、ウィン
ドウにたいする置き換えバッファーを探すために
‘replace-buffer-in-windows’、‘bury-buffer’、‘quit-window’により使用され
ます。

 -- Command: switch-to-prev-buffer &optional window bury-or-kill
     このコマンドは、WINDOW内に前のバッファーを表示する。引数WINDOWは生
     きたウィンドウ、または‘nil’(選択されたウィンドウの意)であること。オ
     プション引数BURY-OR-KILLが非‘nil’、それはWINDOW内にカレントで表示さ
     れているバッファーは今まさにバリーもしくはkillされるバッファーであ
     り、したがって将来におけるこのコマンドの呼び出しで、このバッファー
     に切り替えるべきではないことを意味する。

     前のバッファーは通常、WINDOW内にカレントで表示されているバッファー
     の前に表示されていたバッファーである。しかし、バリーまたはkillされ
     たバッファー、または直近の‘switch-to-prev-buffer’呼び出しですでに表
     示されたバッファーは、前のバッファーとして適格とはならない。

     このコマンドを繰り返して呼び出すことにより、WINDOW内で前に表示され
     たすべてのバッファーが表示されてしまった場合、将来の呼び出しにおい
     ては、WINDOWが表示されているフレームのバッファーリスト(*note Buffer
     List::を参照)から、そのフレームの他のウィンドウで表示済みのバッファ
     ーをスキップするようにして、バッファーを表示するだろう。

 -- Command: switch-to-next-buffer &optional window
     このコマンドは、WINDOW内の次バッファーに切り替える。つまり、
     WINDOW内での最後の‘switch-to-prev-buffer’コマンドの効果をアンドゥす
     る。引数WINDOWは生きたウィンドウであること。デフォルトは選択された
     ウィンドウである。

     アンドゥ可能な‘switch-to-prev-buffer’の直近の呼び出しが存在しない場
     合、この関数はWINDOWが表示されているフレームのバッファーリスト
     (*note Buffer List::を参照)からバッファーの表示を試みる。

   デフォルトでは、‘switch-to-prev-buffer’と‘switch-to-next-buffer’は、
同一フレーム上の他のウィンドウで表示済みのバッファーに切り替えることがで
きます。以下のオプションは、この挙動をオーバーライドするために使用できま
す。

 -- User Option: switch-to-visible-buffer
     この変数が非‘nil’の場合、‘switch-to-prev-buffer’および
     ‘switch-to-next-buffer’は、そのバッファーが当該ウィンドウで過去に表
     示されていれば、同一フレーム上ですでに可視のバッファーに切り替える
     ことができる。‘nil’の場合、‘switch-to-prev-buffer’および
     ‘switch-to-next-buffer’は、同一フレーム上ですでに可視なバッファーへ
     の切り替えを常に避けるよう試みる。デフォルトは‘t’。


File: elisp,  Node: Dedicated Windows,  Next: Quitting Windows,  Prev: Window History,  Up: Windows

27.16 Dedicated Windows
=======================

バッファーを表示する関数は、特定のウィンドウが、そのウィンドウのバッファ
ーにたいして“専用(dedicated)”であるとマークすることにより、使用しないよ
う告げることができます。‘display-buffer’(*note Choosing Window::を参照
)は、他のバッファーの表示に、専用バッファーを決して使用しません。 and
‘get-largest-window’(*note Cyclic Window Ordering::)は、DEDICATED引数が
非‘nil’のときは、専用ウィンドウを候補とみなしません。専用ウィンドウにた
いする配慮に関して、‘set-window-buffer’(*note Buffers and Windows::を参
照)の挙動は若干異なります。以下を参照してください。

   ウィンドウからバッファー、およびフレームからウィンドウを削除すること
を意図した関数は、処理するウィンドウが専用ウィンドウのときは特別な挙動を
示す可能性があります。ここでは3つの基本ケース、すなわち(1)そのウィンドウ
がフレーム上で唯一のウィンドウの場合、(2)ウィンドウはフレーム上で唯一の
ウィンドウだが同一端末上に別のフレームがある場合、(3)そのウィンドウが同
一端末上で唯一のフレームの唯一のウィンドウの場合、を明確に区別することに
します。

   特に、‘delete-windows-on’(*note Deleting Windows::を参照)は関連するフ
レームを削除する際にケース(2)を、フレーム上で唯一のウィンドウに他のバッ
ファーを表示する際にケース(3)を処理します。バッファーがkillされる際に呼
び出される関数‘replace-buffer-in-windows’(*note Buffers and Windows::)は
、ケース(1)ではウィンドウを削除して、それ以外では‘delete-windows-on’のよ
うに振る舞います。

   ‘bury-buffer’(*note Buffer List::を参照)が選択されたウィンドウを操作
する際は、選択されたフレームを処理するために、
‘frame-auto-hide-function’(*note Quitting Windows::を参照)を呼び出すこと
により、ケース(2)を取り扱います。他の2つのケースは、
‘replace-buffer-in-windows’と同様に処理されます。

 -- Function: window-dedicated-p &optional window
     この関数は、WINDOWがそのバッファーにたいして専用なら非‘nil’、それ以
     外は‘nil’をリターンする。より正確には、最後の
     ‘set-window-dedicated-p’呼び出しで割り当てられた値、または
     ‘set-window-dedicated-p’がWINDOWを引数として呼び出されたことがない
     場合は‘nil’がリターン値となる。WINDOWのデフォルトは、選択されたウィ
     ンドウである。

 -- Function: set-window-dedicated-p window flag
     この関数は、FLAGが非‘nil’ならWINDOWがそのバッファーに専用とマークし
     、それ以外は非専用とマークする。

     特別なケースとして、FLAGが‘t’の場合、WINDOWはそのバッファーにたいし
     て“特に専用(strongly dedicated)”となる。‘set-window-buffer’は、処理
     対象のウィンドウが特に専用のウィンドウで、かつ表示を要求されたバッ
     ファーが表示済みでない場合は、エラーをシグナルする。その他の関数は
     、‘t’を他の非‘nil’値と区別して扱わない。


File: elisp,  Node: Quitting Windows,  Next: Window Point,  Prev: Dedicated Windows,  Up: Windows

27.17 Quitting Windows
======================

バッファーを表示するために使用しているウィンドウを削除したいときは、フレ
ームからそのウィンドウを削除するために、‘delete-window’や
‘delete-windows-on’を呼び出すことができます(*note Deleting Windows::を参
照)。その、が別フレームで表示されているときは、かわりに‘delete-frame’を
呼び出したいと思うかもしれません(*note Deleting Frames::を参照)。一方で
、そのバッファーを表示するためにウィンドウが再利用されている場合は、関数
‘switch-to-prev-buffer’を呼び出して、前に表示されていたバッファーを表示
したいと思うかもしれません(*note Window History::を参照)。最終的には、そ
のウィンドウのバッファーをバリー(*note Buffer List::を参照)、または
kill(*note Killing Buffers::を参照)したいと思うかもしれません。

   以下のコマンドは、ウィンドウがバッファーを表示する方法を最初に入手す
る情報を使用して、上述した説明の自動化を試みます。

 -- Command: quit-window &optional kill window
     このコマンドは、WINDOWをquitして、そのバッファーをバリーする。引数
     WINDOWは生きたウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。プレフィックス引数KILLが非‘nil’なら、バッファーをバ
     リーするかわりにkillする。これは、ウィンドウとそのバッファーを処理
     するために、次に説明する関数‘quit-restore-window’を呼び出す。

 -- Function: quit-restore-window &optional window bury-or-kill
     この関数は、WINDOWにたいして、そのバッファーが表示される前に存在し
     た状態へのリストアを試みる。オプション引数WINDOWは生きたウィンドウ
     でなければならず、デフォルトは選択されたウィンドウである。

     WINDOWがそのバッファーを表示するために特別に作成されたバッファーの
     場合、この関数はそのフレームに他に少なくとも1つの生きたウィンドウが
     なければ、WINDOWを削除しない。WINDOWがそのフレームで唯一のウィンド
     ウであり、かつそのフレームの端末上に他のフレームが存在する場合、オ
     プション引数BURY-OR-KILLがそのウィンドウをどうするかを決定する。If
     equals ‘kill’の場合は、無条件でフレームは削除される。それ以外では、
     フレームの運命はそのフレームを単一の引数とする
     ‘frame-auto-hide-function’(以下参照)呼び出しにより決定される。

     特別に作成されたウィンドウでない場合、この関数はWINDOW内で前に表示
     されていたバッファーの再表示を試みる。これは、前に表示されていたバ
     ッファーのウィンドウのスタート位置(*note Window Start and End::を参
     照)とポイント位置(*note Window Point::を参照)のリストアも試みる。加
     えて、WINDOWのバッファーが過去に一時的にリサイズされていた場合、こ
     の関数はWINDOWの元の高さのリストアも試みる。

     これまで説明したケースでは、WINDOW内で表示されているバッファーは、
     依然としてそのウィンドウにたいする最後のバッファー表示関数で表示さ
     れたバッファーである。その時点で他のバッファーが表示されている、ま
     たは前に表示されていたバッファーがもはや存在しない場合、この関数は
     かわりに何か他のバッファーを表示するために、
     ‘switch-to-prev-buffer’(*note Window History::を参照)を呼び出す。

     オプション引数BURY-OR-KILLは、WINDOWを処理する方法を指定し、以下の
     値を処理する。

     ‘nil’
          これは、バッファーを特別な方法で処理しないことを意味する。結果
          、WINDOWが削除されない場合は、‘switch-to-prev-buffer’の呼び出
          しにより、通常はそのバッファーが再び表示されるだろう。

     ‘append’
          これは、WINDOWが削除されない場合、そのバッファーをWINDOWの前の
          バッファーリストの最後に移動するので、将来の
          ‘switch-to-prev-buffer’呼び出しでこのバッファーには切り替わる
          ことは少なくなる。これは、そのバッファーをフレームのバッファー
          リストの最後への移動も行う。

     ‘bury’
          これは、WINDOWが削除されない場合、そのバッファーをWINDOWの前の
          バッファーリストから削除する。これは、そのバッファーをフレーム
          のバッファーリストの最後への移動も行う。この値は、バッファーを
          killすることなく‘switch-to-prev-buffer’がこのバッファーに再び
          切り替えさせないようにする、もっとも信頼できる解決手段を提供す
          る。

     ‘kill’
          これは、WINDOWのバッファーをkillすることを意味する。

     ‘quit-restore-window’は、WINDOWの‘quit-restore’ウィンドウパラメータ
     ー(*note Window Parameters::を参照)の情報にもとづき判定を行い、処理
     後にそれを‘nil’にリセットしている。

   以下のオプションは、quitすべきウィンドウ、あるいはバリーすべきバッフ
ァーをもつウィンドウを1つだけ含むフレームを処理する方法を指定します。

 -- User Option: frame-auto-hide-function
     このオプションで指定された関数は、自動的にフレームを隠すために呼び
     出される。この関数は、フレームを唯一の引数として呼び出される。

     ここで指定される関数は、選択されたウィンドウが専用(dedicated)で、か
     つバリーされるバッファーを表示しているときに、‘bury-buffer’(*note
     Buffer List::を参照)から呼び出される。また、quitされるウィンドウの
     フレームが、そのウィンドウのバッファーを表示するために特別に作成さ
     れたフレームで、かつそのバッファーがkillされないときにも、
     ‘quit-restore-window’(上記)から呼び出される。

     デフォルトでは、‘iconify-frame’(*note Visibility of Frames::を参照
     )を呼び出す。かわりに、フレームをディスプレイから削除する
     ‘delete-frame’(*note Deleting Frames::を参照)、フレームを変更せずに
     残す‘ignore’、またはフレームを唯一の引数とする任意の関数のいずれか
     を指定できる。

     このオプションで指定された関数は、指定されたフレームが生きたウィン
     ドウただ1つを含み、かつ同一端末上に少なくとも1つ他のフレームが存在
     する場合のみ呼び出されることに注意。


File: elisp,  Node: Window Point,  Next: Window Start and End,  Prev: Quitting Windows,  Up: Windows

27.18 Windows and Point
=======================

それぞれのウィンドウは独自のポイント値(*note Point::を参照)をもっており
、同じバッファーを表示する他のウィンドウの間でも、それぞれのポイント値は
独立しています。これは、1つのバッファーを複数ウィンドウで表示するのに有
用です。

   • ウィンドウポイント(window point)は、ウィンドウが最初に作成されたと
     きに設定される。ウィンドウポイントはバッファーのポイント、またはそ
     のバッファーからオープンされたウィンドウがあればそのウィンドウのウ
     ィンドウポイントより初期化される。

   • ウィンドウ選択により、ウィンドウのポイント値からそのバッファーのポ
     イント値がセットされる。反対に、ウィンドウの非選択により、ウィンド
     ウのポイント値にバッファーのポイント値がセットされる。つまり、与え
     られたバッファーを表示するウィンドウ間で切り替えを行ったときは、そ
     のバッファーでは選択されたウィンドウのポイント値が効力をもつが、他
     のウィンドウのポイント値はそのウィンドウに格納される。

   • 選択されたウィンドウがカレントバッファーの表示を続ける限り、そのウ
     ィンドウのポイントとバッファーのポイントは常に同時に移動し、等しく
     あり続ける。

   ユーザーが関与し続ける限りポイントはカーソル位置にあり、ユーザーが他
のバッファーに切り替えた際には、カーソルはそのバッファーのポイント位置に
ジャンプします。

 -- Function: window-point &optional window
     この関数は、WINDOW内のカレントのポイント位置をリターンする。選択さ
     れていないウィンドウにたいしては、そのウィンドウが選択された場合の
     、(そのウィンドウのバッファーの)ポイント値である。WINDOWにたいする
     デフォルトは、選択されたウィンドウである。

     WINDOWが選択されたウィンドウのときのリターン値は、そのウィンドウの
     バッファーのポイント値である。厳密には、すべての‘save-excursion’フ
     ォームの外側の“トップレベル”のポイント値のほうが、より正確であろう
     。しかし、この値は見つかるのが困難である。

 -- Function: set-window-point window position
     この関数は、WINDOW内のポイントを、WINDOWのバッファー内の位置
     POSITIONに配置する。リターン値はPOSITIONである。

     WINDOWが選択されている場合は、単にWINDOW内で‘goto-char’を行う。

 -- Variable: window-point-insertion-type
     この変数は、‘window-point’のマーカー挿入型(*note Marker Insertion
     Types::を参照)を指定する。デフォルトは‘nil’で、‘window-point’は挿入
     されたテキストの後に留まるだろう。


File: elisp,  Node: Window Start and End,  Next: Textual Scrolling,  Prev: Window Point,  Up: Windows

27.19 The Window Start and End Positions
========================================

ウィンドウはそれぞれ、バッファー位置を追跡するために、バッファー内で表示
を開始すべき位置を指定するマーカーを保守しています。この位置は、そのウィ
ンドウの“display-start(表示開始)”、または単に“start(開始)”と呼ばれます。
この位置の後の文字が、ウィンドウの左上隅に表示される文字となります。これ
は通常はテキスト行の先頭になりますが、必須ではありません。

   ウィンドウやバッファーを切り替えた後、およびいくつかのケースにおいて
は、ウィンドウが行の途中で開始される場合は、Emacsがィンドウの開始を行の
開始に調整します。これは、行中で無意味な位置のウィンドウ開始のまま、特定
の操作が行われるのを防ぐためです。この機能は、Lispモードのコマンドを使用
して実行することによりある種のLispコードをテストする場合は、それらのコマ
ンドがこの再調整を誘発するために邪魔になるかもしれません。そのようなコー
ドをテストするためには、それをコマンド内に記述して、何らかのキーにバイン
ドしてください。

 -- Function: window-start &optional window
     この関数は、ウィンドウWINDOWの表示開始位置をリターンする。WINDOWが
     ‘nil’なら、選択されたウィンドウが使用される。

     ウィンドウを作成したり、他のバッファーをウィンドウ内に表示する際、
     display-start位置は同じバッファーにたいしてもっとも最近に使用された
     display-start位置か、そのバッファーがそれをもたなければ
     ‘point-min’にセットされる。

     ポイントがスクリーン上に確実に現れるように、再表示はwindow-start位
     置を更新する(前の再表示以降にwindow-start位置を明示的に指定していな
     い場合)。再表示以外に、window-start位置を自動的に変更するものはない
     。ポイントを移動した場合は、次の再表示後までポイントの移動に応じて
     window-startが変更されるのを期待してはならない。

 -- Function: window-end &optional window update
     この関数は、WINDOWのバッファーの最後を表示する位置をリターンする。
     WINDOWにたいするデフォルトは、選択されたウィンドウである。

     バッファーテキストの単なる変更やポイントの移動では、‘window-end’が
     リターンする値は更新されない。この値は、Emacsが再表示を行い、それが
     妨害されることなく再表示が完了したときのみ更新される。

     WINDOWの最後の再表示が妨害されて完了しなかった場合、Emacsはそのウィ
     ンドウ内の表示のend位置を知らない。この場合、関数は‘nil’をリターン
     する。

     UPDATEが非‘nil’の場合、‘window-end’は‘window-start’のカレント値にも
     とづき、どこが表示のendかにたいして最新の値をリターンする。以前に保
     存された位置の値がまだ有効なら、‘window-end’はその値をリターンする
     。それ以外は、バッファーのテキストをスキャンして、正しい値を計算す
     る。

     たとえUPDATEが非‘nil’でも、‘window-end’はポイントが画面外に移動して
     いても、実際の再表示が行うような表示のスクロールを試みない。これは
     、‘window-start’の値を変更しない。これは実際には、スクロールが要求
     されない場合の表示されたテキストのendがどこかを報告する。

 -- Function: set-window-start window position &optional noforce
     この関数は、WINDOWのdisplay-start位置を、WINDOWのバッファーの
     POSITIONにセットする。リターン値は、POSITIONである。

     表示ルーチンは、バッファーが表示されたときに、ポイント位置が可視に
     なることを強要する。通常これらは、ポイントを可視にするために必要な
     ときは常に、display-start位置を変更(つまりウィンドウをスクロール)す
     る。しかし、この関数でNOFORCEに‘nil’を使用してstart位置を指定した場
     合は、たとえポイントを画面外になるような場所に配したとしても、
     POSITIONでの表示開始を望んでいることを意味する。これによりポイント
     が画面外に配された場合、表示ルーチンはポイントをウィンドウ内の中央
     行の左マージンに移動する。

     たとえば、ポイントが1のときにウィンドウのstartを次行の開始37にセッ
     トした場合、ポイントはウィンドウの最上端の“上”になるだろう。表示ル
     ーチンは、再表示が発生したときにポイントが1のままなら、ポイントを動
     かすことになる。以下に例を示す:

          ;; 以下は式‘set-window-start’実行前
          ;;   ‘foo’の様子である

          ---------- Buffer: foo ----------
          ★This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------

          (set-window-start
           (selected-window)
           (save-excursion
             (goto-char 1)
             (forward-line 1)
             (point)))
          ⇒ 37

          ;; 以下は式‘set-window-start’実行後の
          ;;   ‘foo’の様子である
          ---------- Buffer: foo ----------
          2
          3
          ★4
          5
          6
          ---------- Buffer: foo ----------

     NOFORCEが非‘nil’で、かつ次回の再表示でポイントが画面外に配される場
     合、再表示はポイントと協調して機能する位置となるような新たな
     window-startを計算するので、POSITIONは使用されない。

 -- Function: pos-visible-in-window-p &optional position window
          partially
     この関数は、WINDOW内のPOSITIONが画面上カレントで可視のテキスト範囲
     内にある場合は、非‘nil’をリターンし、POSITIONが表示範囲のスクロール
     外にある場合は、‘nil’をリターンする。PARTIALLYが‘nil’なら、部分的に
     不明瞭な位置は可視とは判断されない。引数POSITIONのデフォルトは、
     WINDOW内のポイントのカレント位置で、WINDOWのデフォルトは選択された
     ウィンドウである。POSITIONが‘t’なら、それはWINDOWの最後に可視だった
     位置をチェックすることを意味する。

     この関数は、垂直スクロールだけを考慮する。 This function considers
     only vertical scrolling.  WINDOWが水平にスクロールされたことだけの
     理由でPOSITIONが表示範囲外の場合は、いずれにせよ
     ‘pos-visible-in-window-p’は非‘nil’をリターンする。*note Horizontal
     Scrolling::を参照のこと。

     POSITIONが可視でPARTIALLYが‘nil’なら、‘pos-visible-in-window-p’は
     ‘t’をリターンする。PARTIALLYが非‘nil’でPOSITION以降の文字が完全に可
     視の場合は、‘(X Y)’という形式のリストをリターンする。ここでXとYは、
     ウィンドウの左上隅からの相対的なピクセル座標である。POSITION以降の
     文字が完全に可視ではない場合は、拡張された形式のリスト‘(X Y RTOP
     RBOT ROWH VPOS)’をリターンする。ここでRTOPとRBOTはPOSITIONでウィン
     ドウ外となった上端と下端のピクセル数、ROWHはその行の可視な部分の高
     さ、VPOSはその行の垂直位置(0基準の行番号)を指定する。

     以下に例を示す:

          ;; ポイントが画面外ならrecenterする
          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))

 -- Function: window-line-height &optional line window
     この関数は、WINDOW内のテキスト行LINEの高さをリターンする。LINEが
     ‘header-line’、‘mode-line’、‘window-line-height’のいずれかの場合は
     、そのウィンドウの対応する行についての情報をリターンする。それ以外
     では、LINEは0から始まるテキスト行番号である。負数の場合は、そのウィ
     ンドウのendから数える。LINEにたいするデフォルトは、WINDOW内のカレン
     ト行、WINDOWにたいするデフォルトは、選択されたウィンドウである。

     表示が最新でなければ、‘window-line-height’は‘nil’をリターンする。そ
     の場合は、関連する情報を入手するために、‘pos-visible-in-window-p’を
     使用できる。

     指定されたLINEに対応する行がなければ、‘window-line-height’は‘nil’を
     リターンする。それ以外では、リスト‘(HEIGHT VPOS YPOS OFFBOT)’をリタ
     ーンする。ここでHEIGHTはその行の可視部分のピクセル高さ、VPOSと
     YPOSは最初のテキスト行上端からのその行への相対的な垂直位置の行数と
     ピクセル数、OFFBOTはそのテキスト行下端のウィンドウ外のピクセル数で
     ある。(最初の)テキスト行上端にウィンドウ外のピクセルがある場合、
     YPOSは負となる。


File: elisp,  Node: Textual Scrolling,  Next: Vertical Scrolling,  Prev: Window Start and End,  Up: Windows

27.20 Textual Scrolling
=======================

“テキスト的なスクロール(textual scrolling)”とは、ウィンドウ内のテキスト
を上や下に移動することを意味します。これは、そのウィンドウの
display-startを変更することにより機能します。これは、ポイントを画面上に
維持するために、‘window-point’の値も変更するかもしれません(*note Window
Point::を参照)。

   テキスト的なスクロールの基本的な関数は、(前方にスクロールする
)‘scroll-up’と、(後方にスクロールする)‘scroll-down’です。これらの関数の
名前における“up”と“down”は、バッファーテキストのそのウィンドウにたいする
相対的な移動方向を示します。そのテキストが長いロール紙に記述されていて、
スクロールコマンドはその上を上下に移動すると想像してみてください。つまり
、バッファーの中央に注目している場合、繰り返して‘scroll-down’を呼び出す
と、最終的にはバッファーの先頭を目にすることになるでしょう。

   残念なことに、これは時折混乱を招きます。なぜなら、ある人はこれを逆の
慣習にもとづいて考える傾向があるからです。彼らは、テキストがその場所に留
まりウィンドウが移動して、“down”コマンドによりバッファー終端に移動するだ
ろうと想像します。この慣習は、そのようなコマンドが現代風のキーボード上の
<PageDown>という名前のキーにバインドされているという事実と一致しています
。

   選択されたウィンドウ内で表示されているバッファーがカレントバッファー
でない場合、(‘scroll-other-window’以外の)テキスト的スクロール関数の結果
は予測できません。*note Current Buffer::を参照してください。

   (たとえば大きなイメージがある等で)ウィンドウにウィンドウの高さより高
い行が含まれる場合、スクロール関数は部分的に可視な行をスクロールするため
に、そのウィンドウの垂直スクロール位置を調整します。Lisp呼び出し側は、変
数‘auto-window-vscroll’を‘nil’にバインドすることにより、この機能を無効に
できます(*note Vertical Scrolling::を参照)。

 -- Command: scroll-up &optional count
     この関数は、選択されたウィンドウ内でCOUNT行前方にスクロールする。

     COUNT負の場合は、かわりに後方へスクロールする。COUNTが‘nil’(または
     省略)の場合、スクロールされる距離は、そのウィンドウのテキストエリア
     の高さより小さい‘next-screen-context-lines’となる。

     選択されたウィンドウがそれ以上スクロールできない場合、この関数はエ
     ラーをシグナルし、それ以外は‘nil’をリターンする。

 -- Command: scroll-down &optional count
     この関数は、選択されたウィンドウ内でCOUNT行後方にスクロールする。

     COUNT負の場合は、かわりに後方へスクロールする。それ以外の点では、こ
     れは‘scroll-up’が行うのと同様に振る舞う。

 -- Command: scroll-up-command &optional count
     これは‘scroll-up’と同様に振る舞うが、選択されたウィンドウがそれ以上
     スクロールできず、かつ変数‘scroll-error-top-bottom’の値が‘t’の場合
     は、かわりにそのバッファーの終端への移動を試みる。ポイントがすでに
     終端にある場合は、エラーをシグナルする。

 -- Command: scroll-down-command &optional count
     これは‘scroll-down’と同様に振る舞うが、選択されたウィンドウがそれ以
     上スクロールできず、かつ変数‘scroll-error-top-bottom’の値が‘t’の場
     合は、かわりにそのバッファーの先頭への移動を試みる。ポイントがすで
     に先頭にある場合は、エラーをシグナルする。

 -- Command: scroll-other-window &optional count
     この関数は、他のウィンドウ内のテキストを上方にCOUNT行スクロールする
     。COUNTが負、または‘nil’の場合は、‘scroll-up’のように処理される。

     変数‘other-window-scroll-buffer’にバッファーをセットすることにより
     、どのバッファーをスクロールするかを指定できる。そのバッファーが表
     示されていない場合、‘scroll-other-window’はそれを何らかのウィンドウ
     に表示する、

     選択されたウィンドウがミニバッファーのとき、次ウィンドウは通常はそ
     のウィンドウの直上最左のウィンドウである。変数
     ‘minibuffer-scroll-window’をセットすることにより、スクロールする別
     のウィンドウを指定できる。この変数は、ミニバッファー以外のウィンド
     ウが選択されているときは効果がない。これが非‘nil’で、かつミニバッフ
     ァーが選択されているとき、これは‘other-window-scroll-buffer’より優
     先される。*note Definition of minibuffer-scroll-window::を参照のこ
     と。

     ミニバッファーがアクティブのとき、選択されたウィンドウが下端右角の
     ウィンドウなら、ミニバッファーが次ウィンドウになる。この場合、
     ‘scroll-other-window’はミニバッファーのスクロールを試みる。ミニバッ
     ファーに含まれるのが1行だけの場合はどこにもスクロールできないので、
     エコーエリアに瞬時メッセージ‘End of buffer’を表示後、その行を再表示
     する。

 -- Variable: other-window-scroll-buffer
     この変数が非‘nil’なら、それは‘scroll-other-window’がどのバッファー
     のウィンドウをスクロールするかを指定する。

 -- User Option: scroll-margin
     このオプションは、スクロールマージン(ポイントとウィンドウの上端/下
     端との最小行数)のサイズを指定する。ポイントがウィンドウの上端/下端
     からその行数になったとき、再表示は(可能なら)ポイントをそのマージン
     外、ウィンドウの中央付近に移動するために、テキストを自動的にスクロ
     ールする。

 -- User Option: scroll-conservatively
     この変数は、ポイントがスクリーン外(またはスクロールマージン内)に移
     動したとき、スクロールを自動的に行う方法を指定する。値が正の整数Nの
     場合、再表示はそれが正しい表示範囲内にポイントを戻すなら、いずれか
     の方向にN行以下のテキストをスクロールする。この振る舞いは、“保守的
     なスクロール(conservative scrolling)”と呼ばれる。それ以外の場合、ス
     クロールは‘scroll-up-aggressively’や‘scroll-down-aggressively’のよ
     うな他の変数の制御の下、通常の方法で発生する。

     デフォルトの値は0で、これは保守的スクロールが発生し得ないことを意味
     する。

 -- User Option: scroll-down-aggressively
     この変数の値は、‘nil’か、0から1までの小数Fであること。これが小数な
     ら、スクリーン上でポイントが置かれたとき、下にスクロールする場所を
     指定する。より正確には、ポイントがウィンドウstartより上という理由に
     よりウィンドウが下にスクロールされるとき、新たなstart位置はウィンド
     ウ上端からウィンドウ高さのFの箇所にポイントが置かれるように選択され
     る。より大きなFでは、よりaggressive(積極的)にスクロールする。

     ポイントを中央に配すのがその効果なので、値‘nil’は.5と等価である。ど
     のような方法によりセットされたときでも、この変数は自動的にバッファ
     ーローカルになる。

 -- User Option: scroll-up-aggressively
     ‘scroll-up-aggressively’と同様。値Fは、ポイントがウィンドウ下端から
     どれほどの位置に置かれるべきかを指定する。つまり、
     ‘scroll-up-aggressively’と同様、大きな値ｄｗはよりaggressive(積極的
     )になる。

 -- User Option: scroll-step
     この変数は、‘scroll-conservatively’のより古い変種である。違いは、値
     がNならN以下の値ではなく、正確にNだけのスクロールを許容することであ
     る。この機能は、‘scroll-margin’とは共に機能しない。デフォルトは0。

 -- User Option: scroll-preserve-screen-position
     このオプションが‘t’なら、スクロールによりポイントがウィンドウ外に移
     動したとき、Emacsは常に、ポイントがポイントの上下端ではなくカーソル
     がそのウィンドウ内の元の垂直位置に保たれるようポイントの調整を試み
     る。

     値が非‘nil’かつ非‘t’の場合、たとえスクロールコマンドによりポイント
     がウィンドウ外に移動していなくとも、Emacsはカーソルが同じ垂直位置に
     保たれるよう、ポイントを調整する。

     このオプションはシンボルプロパティ‘scroll-command’が非‘nil’であるよ
     うな、すべてのスクロールコマンドに影響する。

 -- User Option: next-screen-context-lines
     この変数の値は、全画面スクロールされたときに残される継続される行数
     を指定する。たとえば、引数が‘nil’の‘scroll-up’は、ウィンドウ上端で
     はなく下端に残される行数でスクロールする。デフォルト値は‘2’。

 -- User Option: scroll-error-top-bottom
     このオプションが‘nil’(デフォルト)の場合、それ以上のスクロールが不可
     能な際に、‘scroll-up-command’と‘scroll-down-command’は単にエラーを
     シグナルする。

     値が‘t’なら、これらのコマンドはかわりにポイントをバッファーの先頭か
     終端(スクロール方向に依存する)に移動する。ポイントがすでにその位置
     にある場合のみ、エラーをシグナルする。

 -- Command: recenter &optional count
     この関数は、選択されたウィンドウ内の指定された垂直位置にポイントを
     表示するように、ウィンドウ内のテキストをスクロールする。これはテキ
     ストに応じた“ポイント移動”を行わない。

     COUNTが非負の数の場合は、そのウィンドウ上端からCOUNT行下にポイント
     を含む行を配す。COUNTが負なら、ウィンドウ下端から上に数えるので、
     −1はそのウィンドウ内で最後の利用可能な行となる。

     COUNTが‘nil’(または非‘nil’のリスト)の場合、‘recenter’はポイントを含
     む行をウィンドウの中央に配す。COUNTが‘nil’なら、この関数は
     ‘recenter-redisplay’の値に応じて、フレームを再描画するかもしれない
     。

     ‘recenter’がインタラクティブに呼び出されたときは、rawプレフィックス
     引数がCOUNTとなる。したがって、プレフィックスとして‘C-u’をタイプす
     るとCOUNTに非‘nil’、‘C-u 4’ではCOUNTに4がセットされ、後者ではカレン
     ト行を上端から4行目にセットする。

     引数0では、‘recenter’はカレント行をウィンドウ上端に配す。コマンド
     ‘recenter-top-bottom’は、これを達成するためにより簡便な方法を提供す
     る。

 -- User Option: recenter-redisplay
     この変数が非‘nil’の場合は、引数‘nil’で‘recenter’を呼び出すことによ
     り、フレームを再描画する。デフォルト値は‘tty’で、これはフレームが
     ttyフレームのときだけフレームを再描画することを意味する。

 -- Command: recenter-top-bottom &optional count
     デフォルトでは‘C-l’にバインドされているこのコマンドは、‘recenter’と
     同様に動作するが、引数なしで呼び出されたときの動作が異なる。この場
     合、連続して呼び出すことにより、変数‘recenter-positions’で定義され
     るサイクル順に応じてポイントを配する。

 -- User Option: recenter-positions
     これは、‘recenter-top-bottom’を引数なしで呼び出したときの挙動を制御
     する。デフォルト値は‘(middle top bottom)’で、これは引数なしで
     ‘recenter-top-bottom’を連続して呼び出すと、ポイントをウィンドウの中
     央、上端、下端と巡回して配すことを意味する。


File: elisp,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Textual Scrolling,  Up: Windows

27.21 Vertical Fractional Scrolling
===================================

“垂直フラクショナルスクロール(vertical fractional scrolling)”とは、指定
された値を行に乗ずるることによりウィンドウ内のテキストを上下にシフトする
ことを意味します。ウィンドウはそれぞれ、決して0より小さくなることはない
、“垂直スクロール位置(vertical scroll position)”という数値をもっています
。これは、ウィンドウのコンテンツをどこから表示開始(raise)するかを指定し
ます。ウィンドウのコンテンツの表示開始により、一般的には上端の何行かのす
べて、または一部が表示されなくなり、他の何行かのすべて、または一部が下端
に表示されるようになります。通常の値は0です。

   垂直スクロール位置は、通常行の高さ(デフォルトフォントの高さ)の単位で
数えられます。したがって、値が.5なら、それはウィンドウのコンテンツが、通
常行の半分の高さで上にスクロールされていることを、3.3なら通常行の3倍を若
干超える高さで上にスクロールされていることを意味します。

   垂直スクロールが覆い隠す(cover)のがどれほどの行断片(fraction of a
line)、あるいは行数かは、それらの行に何が含まれるかに依存します。3.3とい
う値が高さが高い行やイメージの一部だけを画面外にスクロールできることもあ
れば、.5という値が非常に低い高さの行を画面外にスクロールできることもあり
ます。

 -- Function: window-vscroll &optional window pixels-p
     この関数は、WINDOWのカレントの垂直スクロール位置をリターンする。
     WINDOWのデフォルトは、選択されたウィンドウである。PIXELS-Pが非
     ‘nil’の場合、リターン値は通常行高さ単位ではなく、ピクセル単位で測定
     される。

          (window-vscroll)
               ⇒ 0

 -- Function: set-window-vscroll window lines &optional pixels-p
     この関数は、WINDOWの垂直スクロール位置をLINESにセットする。WINDOWが
     ‘nil’なら、選択されたウィンドウが使用される。引数LINESは0または正で
     あること。それ以外は0として扱われる。

     実際の垂直スクロール位置は、常にピクセルの整数に対応しなければなら
     ないため、指定した値はそれに応じて丸められる。

     こも丸め結果がリターン値となる。

          (set-window-vscroll (selected-window) 1.2)
               ⇒ 1.13

     PIXELS-Pが非‘nil’の場合、LINESはピクセル数を指定する。この場合、リ
     ターン値はLINESである。

 -- Variable: auto-window-vscroll
     この変数が非‘nil’なら、関数‘line-move’、‘scroll-up’、
     ‘scroll-down’は、たとえば大きなイメージが存在する等でウィンドウ高さ
     より高いディスプレイ行をスクロールするために、垂直スクロール位置を
     自動的に変更するだろう。


File: elisp,  Node: Horizontal Scrolling,  Next: Coordinates and Windows,  Prev: Vertical Scrolling,  Up: Windows

27.22 Horizontal Scrolling
==========================

“水平スクロール(horizontal scrolling)”とは、指定された通常文字幅の倍数で
ウィンドウ内のイメージを左右にシフトすることを意味します。ウィンドウはそ
れぞれ、決して0より小さくなることはない、“水平スクロール位置(horizontal
scroll position)”という数値をもっています。これは、コンテンツをどれほど
左にシフトするかを指定します。ウィンドウのコンテンツを左にシフトすること
により、一般的には左にある文字のすべて、または一部が表示されなくなり、右
にある文字のすべて、または一部が表示されることを意味します。通常の値は
0です。

   水平スクロール位置は、通常文字幅を単位として数えられます。したがって
値が5なら、それはウィンドウのコンテンツは通常文字幅の5倍左にスクロールさ
れることを意味します。左の何文字が表示されなくなるかは、それらの文字の文
字幅とに依存しており、行ごとに異なります。

   読み取りを行う際は、“inner loop”で横方向に、“outer loop”で上から下に
読み取るため、水平スクロールの効果はテキスト的スクロールや垂直スクロール
とは異なります。テキスト的スクロールは表示するためのテキスト範囲の選択を
引き起こし、垂直スクロールはウィンドウコンテンツを連続して移動します。し
かし、水平スクロールは_すべての行_の一部をスクリーン外へスクロールします
。

   通常は、水平スクロールは行われないので、ウィンドウ左端には最左列があ
ります。この状態では、右スクロールにより左端に新たに表示されるデータは存
在しないので、右へのスクロールはできません。左スクロールにより、テキスト
の1列目がウィンドウ端からウィンドウ外にスクロールされ、右端にはその前は
切り詰められていた(truncated)列が新たに表示されるので、左へのスクロール
はできます。ウィンドウが左へ非0の量を水平スクロールされていれば、右スク
ロールしてそれを戻すことができますが、正味の水平スクロールが0に減少する
までの間のみ、右スクロールができます。左へどれほどスクロールできるかに制
限はありませんが、最終的にはすべてのテキストが左端の外に消えるでしょう。

   ‘auto-hscroll-mode’がセットされている場合、再表示はポイントが常に可視
となることを保証するために、必要に応じて水平スクロールを自動的に変更する
。とはいえ、依然として水平スクロール位置を明示的に指定するのは可能である
。指定した値は、自動スクロールの下限値としての役目を果たす(自動スクロー
ルは指定された値より小さい列にウィンドウをスクロールしない)。

 -- Command: scroll-left &optional count set-minimum
     この関数は、選択されたウィンドウを左(COUNTが負なら右)にCOUNT列スク
     ロールする。COUNTのデフォルトはウィンドウ幅から2を減じた値である。

     リターン値は、‘window-hscroll’(以下参照)がリターンする値と同様、変
     更後に実際に左に水平スクロールされたトータル量である。

     ウィンドウを可能な限り右にスクロールした後は、左スクロールの合計が
     0であるような通常の位置に戻り、右へのそれ以上のスクロールの試みは効
     果をもたない。

     SET-MINIMUMが非‘nil’の場合、新たなスクロール量は自動スクロールの下
     限値となる。つまり自動スクロールは、この関数がリターンする値より小
     さい列にウィンドウをスクロールしないだろう。インタラクティブに呼び
     出すと、SET-MINIMUMに非‘nil’を渡す。

 -- Command: scroll-right &optional count set-minimum
     この関数は、選択されたウィンドウを右(COUNTが負なら左)にCOUNT列スク
     ロールする。COUNTのデフォルトはウィンドウ幅から2を減じた値である。
     スクロール方向を除けば、これは‘scroll-left’と同様に機能する。

 -- Function: window-hscroll &optional window
     この関数は、WINDOWの左への水平スクロールのトータル(左マージンを超え
     て左にスクロールされたWINDOW内のテキスト列数)をリターンする。
     WINDOWのデフォルトは、選択されたウィンドウである。

     リターン値が負になることは決してない。WINDOWで水平スクロールが行わ
     れていない場合(これが通常)、リターン値は0である。

          (window-hscroll)
               ⇒ 0
          (scroll-left 5)
               ⇒ 5
          (window-hscroll)
               ⇒ 5

 -- Function: set-window-hscroll window columns
     この関数は、WINDOWの水平スクロールをセットする。COLUMNSの値は、スク
     ロール量を左マージンからの列数で指定する。引数COLUMNSは0または正の
     数であること。そうでない場合は、0とみなされる。小数値のCOLUMNSは、
     現在のところサポートされない。

     シンプルに‘M-:’を呼び出して評価する方法でテストした場合は、
     ‘set-window-hscroll’が機能していないように見えるかもしれないことに
     注意されたい。何が発生しているかというと、この関数は水平スクロール
     値をセットしてリターンするが、その後にポイントを可視にするために水
     平スクロールを調整するよう再表示が行なわれ、これが関数の行った処理
     をオーバーライドしている。この関数の効果は、左マージンからポイント
     までのスクロール量が、ポイントが可視のまま留まるように関数を呼び出
     すことにより観察できる。

     リターン値はCOLUMNSである。

          (set-window-hscroll (selected-window) 10)
               ⇒ 10

   以下は、与えられた位置POSITIONが水平スクロールによりスクリーン外にあ
るかどうかを判断する例です:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))


File: elisp,  Node: Coordinates and Windows,  Next: Window Configurations,  Prev: Horizontal Scrolling,  Up: Windows

27.23 Coordinates and Windows
=============================

このセクションでは、ウィンドウの位置を報告する関数を説明します。これらの
関数のほとんどは、そのウィンドウのフレームから相対的な位置を報告します。
この場合の座標原点‘(0,0)’は、そのフレームの左上隅付近になります。技術的
な理由から、グラフィカルなディスプレイ上では、原点はスクリーン上のグラフ
ィカルなウィンドウの左上隅に正確には配置されません。EmacsがGTK+とともに
ビルドされた場合、原点は(Emacsではなくウィンドウマネージャーおよび/また
はGTK+により描画される)タイトルバー、GTK+メニューバー、ツールバーの下の
Emacsウィンドウ表示に使用されるフレーム領域の左上隅になります。しかし、
GTK+なしでEmacsがビルドされた場合の原点は、ツールバーの左上隅になります
(この場合はEmacs自身がツールバーを描画する)。どちらの場合も、X座標とY座
標は、右または下に行くにつれ増加します。

   注記された箇所を除き、X座標とY座標は整数の文字単位(行数と列数)で報告
されます。グラフィカルなディスプレイ上では、“行”と“列”はそれぞれ、そのフ
レームのデフォルトフォントにより指定される、デフォルト文字の高さと幅に対
応します。

 -- Function: window-edges &optional window
     この関数は、WINDOW端の座標のリストをリターンする。If WINDOWが省略ま
     たは‘nil’の場合のデフォルトは、選択されたウィンドウである。

     リターン値は、‘(LEFT TOP RIGHT BOTTOM)’という形式をもつ。リストの要
     素は順に、そのウィンドウにより占有される最左列のX座標、最上行のY座
     標、最右列より1列右のX座標、最下行より1行下のY座標である。

     これらは、ヘッダーライン、モードライン、スクロールバー、ウィンドウ
     ディバイダー、ディスプレイマージンを含む、ウィンドウの実際の外端で
     あることに注意。テキスト端末では、そのウィンドウの右に隣接するウィ
     ンドウがある場合、ウィンドウの右端にはそのウィンドウと隣接するウィ
     ンドウの間のセパレーターラインが含まれる。

 -- Function: window-inside-edges &optional window
     この関数は‘window-edges’と似ているが、そのウィンドウのテキストエリ
     ア端の値をリターンする。これらからはヘッダーライン、モードライン、
     スクロールバー、フリンジ、ウィンドウディバイダー、ディスプレイマー
     ジン、垂直セパレーターは除外される。

 -- Function: window-top-line &optional window
     この関数は、WINDOWの最上行のY座標をリターンする。これは
     ‘window-edges’によりリターンされるリストのTOPエントリーと等価である
     。

 -- Function: window-left-column &optional window
     この関数は、WINDOWの最左列のX座標をリターンする。これは
     ‘window-edges’によりリターンされるリストのLEFTエントリーと等価であ
     る。

   以下の関数は、フレーム相対座標(frame-relative coordinates)のセットか
らウィンドウへの関連付けに使用できます:

 -- Function: window-at x y &optional frame
     この関数は、フレームFRAME上の、フレーム相対座標X、Yにある生きたウィ
     ンドウをリターンする。その位置にウィンドウがなければ、‘nil’をリター
     ンする。FRAMEが省略または‘nil’の場合のデフォルトは、選択されたフレ
     ームである。

 -- Function: coordinates-in-window-p coordinates window
     この関数は、ウィンドウWINDOWがフレーム相対座標COORDINATESを占有する
     かどうかをチェックし、もしそうならウィンドウのどの部分かをチェック
     する。WINDOWは生きたウィンドウであること。COORDINATESは‘(X . Y)’と
     いう形式であるべきで、XとYはフレーム相対座標であること。

     指定された位置にウィンドウが存在しない場合、リターン値は‘nil’である
     。それ以外では、リターン値は以下のいずれかになる:

     ‘(RELX . RELY)’
          その座標はWINDOW内にある。数値RELXとRELYは、指定された位置にた
          いするウィンドウ左上隅を原点に0から数えたウィンドウ相対座標と
          等価である。

     ‘mode-line’
          その座標はWINDOWのモードライン内にある。

     ‘header-line’
          その座標はWINDOWのヘッダーライン内にある。

     ‘right-divider’
          その座標はWINDOWと右に隣接するウィンドウを分けるディバイダー内
          にある。

     ‘right-divider’
          その座標はWINDOWと下にあるウィンドウを分けるディバイダー内にあ
          る。

     ‘vertical-line’
          その座標はWINDOWと右に隣接するウィンドウを分ける垂直ライン内に
          ある。この値は、ウィンドウにスクロールバーがないときのみ発生し
          得る。スクロールバー内の位置は、これらの目的にたいしてはウィン
          ドウ外と判断される。

     ‘left-fringe’
     ‘right-fringe’
          その座標はウィンドウの左か右のフリンジ内にある。

     ‘left-margin’
     ‘right-margin’
          その座標はウィンドウの左か右のマージン内にある。

     ‘nil’
          その座標は、WINDOWのいずれの部分でもない。

     関数‘coordinates-in-window-p’はWINDOWのあるフレームを使用するので、
     引数としてフレームを要求しない。

   以下の関数は、文字単位ではなくピクセル単位でウィンドウ位置をリターン
します。主にグラフィカルなディスプレイで有用ですが、テキスト端末上でも呼
び出すことができ、その場合は各文字の占めるスクリーン領域が“1ピクセル”と
なります。

 -- Function: window-pixel-edges &optional window
     この関数は、WINDOW端のピクセル座標のリストをリターンする。WINDOWが
     省略または‘nil’の場合のデフォルトは、選択されたウィンドウである。

     リターン値は‘(LEFT TOP RIGHT BOTTOM)’という形式をもつ。リストの要素
     は順にウィンドウ左端のXピクセル座標、上端のYピクセル座標、右端のXピ
     クセル座標+1、下端のYピクセル座標+1である。

 -- Function: window-inside-pixel-edges &optional window
     この関数は‘window-pixel-edges’と同様だが、ウィンドウ端のピクセル座
     標ではなく、ウィンドウのテキストエリア端のピクセル座標をリターンす
     る。WINDOWには生きたウィンドウを指定しなければならない。

   以下の関数は、フレームではなく、ディスプレイ画面(display screen)に相
対的なウィンドウ位置をピクセルでリターンする。

 -- Function: window-absolute-pixel-edges &optional window
     この関数は‘window-pixel-edges’と同様だが、ディスプレイ画面の左上隅
     からの相対ピクセル座標でウィンドウ端の座標をリターンする。

 -- Function: window-inside-absolute-pixel-edges &optional window
     この関数は‘window-inside-pixel-edges’と同様だが、ディスプレイ画面の
     左上隅からの相対ピクセル座標でウィンドウのテキストエリア端の座標を
     リターンする。WINDOWには生きたウィンドウを指定しなければならない。

 -- Function: window-pixel-left &optional window
     この関数は、ウィンドウWINDOWの左端のピクセルをリターンする。
     WINDOWは有効なウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。

 -- Function: window-pixel-top &optional window
     この関数は、ウィンドウWINDOWの上端のピクセルをリターンする。
     WINDOWは有効なウィンドウでなければならず、デフォルトは選択されたウ
     ィンドウである。


File: elisp,  Node: Window Configurations,  Next: Window Parameters,  Prev: Coordinates and Windows,  Up: Windows

27.24 Window Configurations
===========================

“ウィンドウ構成(window configuration)”とは1つのフレーム上全体のレイアウ
ト — すべてのウィンドウ、およびそれらのサイズ、どんなバッファーを含んで
いるか、それらのバッファーがスクロールされる方法、ポイント値とマーク値を
記録し、フリンジ、マージン、スクロールバーのセッティングも記録します。こ
れには‘minibuffer-scroll-window’の値も含まれます。特別な例外として、ウィ
ンドウ構成には選択されたウィンドウのカレントバッファーのポイント値は記録
されません。

   以前に保存されたウィンドウ構成をリストアすることにより、フレーム全体
のレイアウトを取り戻すことができます。1つだけではなくすべてのフレームの
レイアウトを記録したい場合は、ウィンドウ構成のかわりに、フレーム構成
(frame configuration)を使用します。*note Frame Configurations::を参照し
てください。

 -- Function: current-window-configuration &optional frame
     この関数は、FRAMEのカレントのウィンドウ構成を表す新たなオブジェクト
     をリターンする。FRAMEのデフォルトは選択されたフレームである。変数
     ‘window-persistent-parameters’は、この関数により保存されるウィンド
     ウパラメーター(もしあれば)を指定する。*note Window Parameters::を参
     照のこと。

 -- Function: set-window-configuration configuration
     この関数は、CONFIGURATIONが作成されたフレームにたいして、ウィンドウ
     とバッファーの構成をCONFIGURATIONで指定された構成にリストアする。

     引数CONFIGURATIONは、以前に‘current-window-configuration’がリターン
     した値でなければならない。この構成は、そのフレームが選択されている
     か否かに関わらず、CONFIGURATIONが作成時のフレームから、当該フレーム
     にリストアされる。これは常にウィンドウのサイズ変更とみなされ、
     ‘window-size-change-functions’(*note Window Hooks::を参照)の実行を
     トリガーする。なぜなら、‘set-window-configuration’は、新たな構成が
     古い構成と実際に異なるかを示す方法を知らないからである。

     CONFIGURATIONが保存されたフレームが死んでいる(生きていない)場合、こ
     の関数が行うのは3つの変数‘window-min-height’、‘window-min-width’、
     ‘minibuffer-scroll-window’のリストアだけである。この場合、関数は
     ‘nil’をリターンし、それ以外は‘t’をリターンする。

     以下は、‘save-window-excursion’と同様な効果を得るためにこの関数を使
     用する例である:

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-below nil)
                       ...)
              (set-window-configuration config)))

 -- Macro: save-window-excursion forms...
     このマクロは、選択されたフレームのウィンドウ構成を記録して、FORMSを
     順に実行してから、以前のウィンドウ構成をリストアする。リターン値は
     、FORMS内の最後のフォームの値である。

     Lispコードのほとんどは、このマクロを使用すべきではない。大抵は
     ‘save-selected-window’で十分である。特に、このマクロはFORMS内で新た
     なウィンドウをオープンするコードを確実に防ぐことができず、新たなウ
     ィンドウは別のフレーム内でオープンされるかもしれないが(*note
     Choosing Window::を参照)、‘save-window-excursion’が保存およびリスト
     アするのは、カレントフレーム上のウィンドウ構成だけだからである。

     このマクロを‘window-size-change-functions’内で使用してはならない。
     このマクロをexitすることにより‘window-size-change-functions’の実行
     がトリガーされるが、これは無限ループを引き起こす。

 -- Function: window-configuration-p object
     この関数は、OBJECTがウィンドウ構成なら‘t’をリターンする。

 -- Function: compare-window-configurations config1 config2
     この関数は、ポイント値、マーク値、保存されたスクロール位置を無視し
     て(これらの観点が異なっても‘t’をリターンし得る)、ウィンドウ構造の観
     点から2つのウィンドウ構成を比較する。

     関数‘equal’も2つのウィンドウ構成を比較できる。これはすべての点から
     、たとえ1つでも異なるものがあれば等しい構成とはみなさず、たとえ保存
     されたポイント値やマーク値が異なるだけでも、等しくないとみなす。

 -- Function: window-configuration-frame config
     この関数は、ウィンドウ構成CONFIGが作成されたフレームをリターンする
     。

   ウィンドウ構成の内部を調べる他のプリミティブも有用かもしれませんが、
わたしたちはこれらを必要としないので実装されていません。ウィンドウ構成に
たいしてより多くの操作を知りたい場合は、ファイル‘winner.el’を参照してく
ださい。

   ‘current-window-configuration’がリターンするオブジェクトは、Emacsプロ
セスとともに終焉します。ウィンドウ構成をディスク上に格納して、それを別の
Emacsセッションに読み戻すために、次に説明する関数を使用できます。これら
の関数は、フレームの状態を任意の生きたウィンドウにクローンする場合も有用
です(‘set-window-configuration’はフレームのウィンドウを、そのフレームの
ルートウィンドウだけに効果的にクローンする)。

 -- Function: window-state-get &optional window writable
     この関数は、WINDOWの状態をLispオブジェクトとしてリターンする。引数
     WINDOWは有効なウィンドウでなければならず、デフォルトは選択されたフ
     レームのルートウィンドウである。

     オプション引数WRITABLEが非‘nil’の場合、それは‘window-point’や
     ‘window-start’のようなサンプリング位置にたいするマーカーを使用しな
     いことを意味する。この状態をディスクに書き込んで別のセッションに読
     み戻す場合は、この引数は非‘nil’であること。

     引数WRITABLEと変数‘window-persistent-parameters’の両方で、この関数
     によりどのウィンドウパラメーターが保存されるかを指定する。*note
     Window Parameters::を参照のこと。

   ‘window-state-get’によりリターンされる値は、同一セッション内の他のウ
ィンドウ内にあるウィンドウのクローンを作成するために使用できます。これは
ディスクに書き込んで、別のセッションに読み戻すこともできます。どちらの場
合でも、ウィンドウの状態をリストアするためには以下の関数を使用します。

 -- Function: window-state-put state &optional window ignore
     この関数は、ウィンドウ状態STATEをWINDOW内にputする。引数STATEは以前
     に呼び出した‘window-state-get’がリターンしたウィンドウ状態であるこ
     と。オプション引数WINDOWには生きたウィンドウ、または内部ウィンドウ
     (*note Windows and Frames::を参照)のいずれかを指定でき、デフォルト
     は選択されたウィンドウである。WINDOWが生きていない場合は、STATEを
     putする前に生きたウィンドウに置き換える。

     オプション引数IGNOREが非‘nil’の場合、それは最小ウィンドウサイズと固
     定サイズの制限を無視することを意味する。IGNOREが‘safe’なら、それは
     1行および/または2列まで、できる限り小さくできることを意味する。


File: elisp,  Node: Window Parameters,  Next: Window Hooks,  Prev: Window Configurations,  Up: Windows

27.25 Window Parameters
=======================

このセクションでは、ウィンドウに追加の情報を関連付けるためにウィンドウパ
ラメーターを使用する方法を説明します。

 -- Function: window-parameter window parameter
     この関数は、WINDOWのPARAMETERの値をリターンする。WINDOWのデフォルト
     は、選択されたウィンドウである。WINDOWにPARAMETERにたいするセッティ
     ングがない場合、この関数は‘nil’をリターンする。

 -- Function: window-parameters &optional window
     この関数は、WINDOWのすべてのパラメーターと、その値をリターンする。
     WINDOWのデフォルトは、選択されたウィンドウである。リターン値は
     ‘nil’、または‘(PARAMETER . VALUE)’という形式をもつ要素からなる連想
     リストである。

 -- Function: set-window-parameter window parameter value
     この関数は、WINDOWのPARAMETERの値にVALUEをセットして、VALUEをリター
     ンする。WINDOWのデフォルトは、選択されたウィンドウである。

   デフォルトでは、ウィンドウ構成(window configuration)やウィンドウ状態
(states of windows)の保存とリストアを行う関数は、ウィンドウパラメーター
については関知しません(*note Window Configurations::を参照)。これは、
‘save-window-excursion’のbody内でパラメーターの値を変更したときは、その
マクロのexit時に以前の値がリストアされないことを意味します。これはまた、
以前に‘window-state-get’で保存されたウィンドウ状態を‘window-state-put’で
リストアしたときは、クローンされたすべてのウィンドウのパラメーターが
‘nil’にリセットされることも意味します。以下の変数により、この標準の挙動
をオーバーライドできます:

 -- Variable: window-persistent-parameters
     この変数は、‘current-window-configuration’と‘window-state-get’によ
     り保存され、‘set-window-configuration’と‘window-state-put’によりリ
     ストアされるパラメーターを指定するalistである。*note Window
     Configurations::を参照のこと。

     このalistの各エントリーのCARはパラメーターを指定するシンボルである
     。CDRは以下のいずれかであること:

     ‘nil’
          この値は、そのパラメーターが‘window-state-get’と
          ‘current-window-configuration’のいずれによっても保存されていな
          いことを意味する。

     ‘t’
          この値は、そのパラメーターが‘current-window-configuration’、お
          よび(WRITABLE引数が‘nil’の場合は)‘window-state-get’により保存
          されたことを意味する。

     ‘writable’
          これは、そのパラメーターが無条件で
          ‘current-window-configuration’と‘window-state-get’の両方により
          保存されたことを意味する。この値は、入力構文(read syntax)をも
          たないパラメーターに使用するべきではない。使用した場合、別のセ
          ッションで‘window-state-put’を呼び出すと、
          ‘invalid-read-syntax’エラーで失敗するだろう。

   いくつかの関数(特に‘delete-window’、‘delete-other-windows’、
‘split-window’)は、WINDOW引数にパラメーターセットをもつ場合は特別な挙動
を示すかもしれません。以下の変数を非‘nil’値にバインドすることにより、そ
のような特別な挙動をオーバーライドできます:

 -- Variable: ignore-window-parameters
     この変数が非‘nil’の場合、いくつかの標準関数はウィンドウパラメーター
     を処理しない。現在のところ影響を受ける関数は‘split-window’、
     ‘delete-window’、‘delete-other-windows’、‘other-window’である。

     アプリケーションは、これらの関数の呼び出し周辺で、この変数を非
     ‘nil’にバインドできる。これを行った場合、そのアプリケーションはその
     関数のexit時に、関連するすべてのウィンドウのパラメーターを正しく割
     り当てる責任をもつ。

   以下のパラメーターは現在のところ、ウィンドウ管理コードにより使用され
ています:

‘delete-window’
     このパラメーターは、‘delete-window’の実行に影響する(*note Deleting
     Windows::を参照)。

‘delete-other-windows’
     このパラメーターは、‘delete-other-windows’の実行に影響する(*note
     Deleting Windows::を参照)。

‘split-window’
     このパラメーターは、‘split-window’の実行に影響する(*note Splitting
     Windows::を参照)。

‘other-window’
     このパラメーターは、‘other-window’の実行に影響する(*note Cyclic
     Window Ordering::を参照)。

‘no-other-window’
     このパラメーターは、そのウィンドウを‘other-window’により選択不可と
     マークする(*note Cyclic Window Ordering::を参照)。

‘clone-of’
     このパラメーターは、そのウィンドウがクローンされたことを指定する。
     これは‘window-state-get’によりインストールされる(*note Window
     Configurations::を参照)。

‘quit-restore’
     このパラメーターは、バッファー表示関数によりインストールされ、
     ‘quit-restore-window’により参照される(*note Quitting Windows::を参
     照)。これは4つの要素を含む:

     1つ目の要素は‘window’(ウィンドウは‘display-buffer’により特別に作ら
     れた)、‘frame’(別のフレームが作られた)、‘same’(ウィンドウは前と同じ
     バッファーを表示する)、‘other’(ウィンドウは前と異なるバッファーを表
     示する)のシンボルのいずれかである。

     2つ目の要素はシンボル‘window’、‘frame’、または要素がそのウィンドウ
     に前に表示されていたバッファー、そのときのウィンドウstart位置、ウィ
     ンドウポイント位置、ウィンドウの高さであるようなリストの、いずれか
     である。

     3つ目の要素は、そのパラメーター作成時点に選択されていたウィンドウで
     ある。関数‘quit-restore-window’は、その引数としてこのウィンドウが渡
     された際は、そのウィンドウの再選択を試みる。

     4つ目の要素は、その表示がこのパラメーターの生成を引き起こしたバッフ
     ァーである。‘quit-restore-window’は、指定されたウィンドウがまだその
     バッファーを表示している場合のみ、それを削除する。

   追加のパラメーターとして、‘window-atom’と‘window-side’があります。こ
れらは予約されており、アプリケーションが使用するべきではありません。


File: elisp,  Node: Window Hooks,  Prev: Window Parameters,  Up: Windows

27.26 Hooks for Window Scrolling and Changes
============================================

このセクションでは、あるウィンドウがそのバッファーの違う部分を表示したり
、別のバッファーを表示したとき常にLispプログラムを実行可能にする方法につ
いて説明します。これを変更できる3つのアクションがあります。それはウィン
ドウのスクロール、ウィンドウ内でのバッファーの切り替え、ウィンドウのサイ
ズ変更です。最初の2つのアクションは‘window-scroll-functions’、最後のアク
ションは‘window-size-change-functions’を実行します。

 -- Variable: window-scroll-functions
     この変数は、ウィンドウのスクロールによりEmacsが再表示前に呼び出すべ
     き関数のリストを保持する。そのウィンドウ内に異なるバッファーを表示
     したときも、これらの関数が実行される。

     この変数は、それぞれの関数が2つの引数、ウィンドウとウィンドウの新た
     なdisplay-start位置で呼び出されるので、ノーマルフックではない。

     これらの関数は、‘window-end’(*note Window Start and End::を参照)を
     使用する際には気をつけなければならない。最新の値が必要な場合は、そ
     れを確実に入力するためにUPDATE引数を使用しなければならない。

     *警告:* ウィンドウのスクロール方法を変更するためにこの機能を使用し
     てはならない。これは、そのような用途のためにデザインされておらず、
     そのような使用は機能しないだろう。

 -- Variable: window-size-change-functions
     この変数は、理由は何であれ、任意のウィンドウのサイズが変更された場
     合に呼び出される関数のリストを保持する。これらの関数は、再表示ごと
     に1回、サイズ変更が発生したフレーム上で1回呼び出される。

     それぞれの関数は、フレームを唯一の引数として呼び出される。そのフレ
     ーム上のどのウィンドウのサイズが変更されたか、および変更された正確
     な方法を直接探す方法はない。とはいえ、各呼び出しにおいて
     size-change関数が既存のウィンドウと、それらのサイズを記録すれば、現
     在のサイズと以前のサイズを比較することも可能である。

     ウィンドウの作成と削除はサイズの変更とみなされるので、これらの関数
     の呼び出しを引き起こす。フレームのサイズ変更は、既存のウィンドウの
     サイズを変更するので、これも変更とみなされる。

     これらの関数内で、‘save-selected-window’を使用できる(*note
     Selecting Windows::を参照)。しかし、‘save-window-excursion’(*note
     Window Configurations::を参照)を使用してはならない。このマクロの
     exitはサイズ変更とみなされ、それはこれらの関数の際限ない呼び出しを
     引き起こすだろう。

 -- Variable: window-configuration-change-hook
     既存フレームのウィンドウ構成を変更するたびに毎回実行される、ノーマ
     ルフックである。これにはウィンドウの分割と削除、ウィンドウのサイズ
     変更、ウィンドウ内への異なるバッファーの表示が含まれる。

     このフックのバッファーローカルな部分は、影響を受けるフレーム上の各
     ウィンドウにたいして、関係するウィンドウを選択、およびそのバッファ
     ーをカレントにして1回実行される。グローバルな部分は、変更されたフレ
     ームにたいして、そのフレームを選択して1回実行される。

   加えて、Font Lockフォント表示関数(Font Lock fontification function)を
登録するために、‘jit-lock-register’を使用できる。バッファーの一部が(再
)フォント表示されたときは、ウィンドウがスクロール、またはサイズ変更され
たという理由で、これが常に呼び出されるだろう。*note Other Font Lock
Variables::を参照のこと。


File: elisp,  Node: Frames,  Next: Positions,  Prev: Windows,  Up: Top

28 Frames
*********

“フレーム(frame)”とは、1つ以上のEmacsウィンドウを含むスクリーンオブジェ
クトです(*note Windows::を参照)。これは、グラフィカル環境では“ウィンドウ
”と呼ばれる類のオブジェクトです。しかし、Emacsはこの単語を異なる方法で使
用しているので、ここではそれを“ウィンドウ”と呼ぶことはできません。Emacs
Lispにおいて“フレームオブジェクト(frame object)”とは、スクリーン上のフレ
ームを表すLispオブジェクトです。*note Frame Type::を参照してください。

   フレームには最初、1つのメインウィンドウおよび/またはミニバッファーウ
ィンドウが含まれます。メインウィンドウは、より小さいウィンドウに垂直、ま
たは水平に分割することができます。*note Splitting Windows::を参照してく
ださい。

   “端末(terminal)”とは、1つ以上のEmacsフレームを表示する能力のあるデバ
イスのことです。Emacs Lispにおいて、“端末オブジェクト(terminal object)”と
は端末を表すLispオブジェクトです。*note Terminal Type::を参照してくださ
い。

   端末には“テキスト端末(text terminals)”と“グラフィカル端末(graphical
terminals)”という、2つのクラスがあります。テキスト端末はグラフィック能力
をもたないディスプレイで、‘xterm’やその他の端末エミュレーターが含まれま
す。テキスト端末上では、それぞれのEmacsフレームは、その端末のスクリーン
全体を占有します。たとえ追加のフレームを作成してそれらを切り替えることが
できたとしても、端末が表示するのは一度に1つのフレームだけです。一方でグ
ラフィカル端末は、X Window Systemのようなグラフィカルディスプレイシステ
ムにより管理されています。これにより、Emacsは同一ディスプレイ上に複数の
フレームを同時に表示することができます。

   GNUおよびUnix systemsシステムでは、単一のEmacsセッション内で、その
Emacsがテキスト端末とグラフィカル端末のいずれで開始されたかに関わらず、
任意の利用可能な端末上で、追加のフレームを作成することができます。
Emacsは、グラフィカル端末とテキスト端末の両方を、同時に表示することがで
きます。 これはたとえば、リモート地から同じセッションに接続する際などに
便利でしょう。*note Multiple Terminals::を参照してください。

 -- Function: framep object
     この述語(predicate)は、OBJECTがフレームなら非‘nil’、それ以外は
     ‘nil’をリターンする。フレームにたいしては、フレームが使用するディス
     プレイの種類の値となる:

     ‘t’
          そのフレームはテキスト端末上で表示されている。
     ‘x’
          そのフレームはXグラフィカル端末上で表示されている。
     ‘w32’
          そのフレームはMS-Windowsグラフィカル端末上で表示されている。
     ‘ns’
          そのフレームはGNUStepまたはMacintosh Cocoaグラフィカル端末上で
          表示されている。
     ‘pc’
          そのフレームはMS-DOS端末上で表示されている。

 -- Function: frame-terminal &optional frame
     この関数は、FRAMEを表示する端末オブジェクトをリターンする。FRAMEが
     ‘nil’または未指定の場合のデフォルトは、選択されたフレームである。

 -- Function: terminal-live-p object
     この述語は、OBJECTが生きた(削除されていない)端末なら非‘nil’、それ以
     外は‘nil’をリターンする。生きた端末にたいしては、リターン値はその端
     末上で表示されているフレームの種類を示す。可能な値は、上述の
     ‘framep’と同様。

* Menu:

* Creating Frames::          追加のフレームの作成。
* Multiple Terminals::       異なる複数デバイス上での表示。
* Frame Parameters::         フレームのサイズ、位置、フォント等の制御。
* Terminal Parameters::      端末上のすべてのフレームにたいして一般的なパラメーター。
* Frame Titles::             フレームタイトルの自動的な更新。
* Deleting Frames::          明示的に削除されるまでフレームは存続する。
* Finding All Frames::       すべての既存フレームを調べる方法。
* Minibuffers and Frames::   フレームが使用するミニバッファーを見つける方法。
* Input Focus::              選択されたフレームの指定。
* Visibility of Frames::     フレームは可視、不可視、またはアイコン化されているかもしれない。
* Raising and Lowering::     フレームを前面に移動して他のウィンドウを隠し、背面に移動して他のウィンドウがフレームを隠す。
* Frame Configurations::     すべてのフレームの状態の保存。
* Mouse Tracking::           マウス移動時のイベントの取得。
* Mouse Position::           マウスの場所や移動を問い合わせる。
* Pop-Up Menus::             ユーザーに選択させるためのメニューの表示。
* Dialog Boxes::             yes/noを問い合わせるためのボックスの表示。
* Pointer Shape::            マウスポインターのシェイプの指定。
* Window System Selections::  他のXクライアントとのテキストの転送。
* Drag and Drop::            ドラッグアンドドロップの実装の内部。
* Color Names::              カラー名定義の取得。
* Text Terminal Colors::     テキスト端末のカラーの定義。
* Resources::                サーバーからのリソース値の取得。
* Display Feature Testing::  端末の機能の判定。


File: elisp,  Node: Creating Frames,  Next: Multiple Terminals,  Up: Frames

28.1 Creating Frames
====================

新たにフレームを作成するためには、関数‘make-frame’を呼び出します。

 -- Command: make-frame &optional alist
     この関数は、カレントバッファーを表示するフレームを作成して、それを
     リターンする。

     ALIST引数は、新たなフレームのフレームパラメーターを指定するalistで
     ある。*note Frame Parameters::を参照のこと。ALIST内で‘terminal’パラ
     メーターを指定した場合、新たなフレームはその端末上で作成される。そ
     れ以外の場合、ALIST内で‘window-system’フレームパラメーターを指定し
     た場合、それはフレームがテキスト端末とグラフィカル端末のどちらで表
     示されるべきかを決定する。*note Window Systems::を参照のこと。どち
     らも指定されない場合、新たなフレームは選択されたフレームと同じ端末
     上に作成される。

     ALISTで指定されなかったパラメーターのデフォルトは、alist
     ‘default-frame-alist’内の値となる。そこでも指定されないパラメーター
     のデフォルトは、Xリソース、またはそのオペレーティングシステムで同等
     のものの値となる(*note X Resources: (emacs)X Resources.を参照)。フ
     レームが作成された後、Emacsは ‘frame-inherited-parameters’(以下参照
     )内にリストされたすべてのパラメーターを適用して、引数にないものは
     ‘make-frame’呼び出し時に選択されていたフレームから値を取得する。

     マルチモニターディスプレイ(*note Multiple Terminals::を参照)では、
     ウィンドウマネージャーがALIST内の位置パラメーター(*note Position
     Parameters::を参照)の指定とは異なる位置にフレームを配置するかもしれ
     ないことに注意。たとえば、ウィンドウの大きな部分、いわゆる“支配モニ
     ター(dominating monitor)”上のフレームを表示するポリシーをもつウィン
     ドウマネージャーがいくつかあります。

     この関数自体はーが、新たなフレームを選択されたフレームにする訳では
     ない。*Note Input Focus::を参照のこと。以前に選択されていたフレーム
     は、選択されたままである。しかしグラフィカル端末上では、ウィンドウ
     システム自身の理由により、新たなフレームが選択されるかもしれない。

 -- Variable: before-make-frame-hook
     ‘make-frame’がフレームを作成する前に、それにより実行されるノーマル
     フック。

 -- Variable: after-make-frame-functions
     ‘make-frame’がフレームを作成した後に、それにより実行されるアブノー
     マルフック。‘after-make-frame-functions’内の各関数は、作成された直
     後のフレームを単一の引数として受け取る。

 -- Variable: frame-inherited-parameters
     この変数は、カレントで選択されているフレームから継承して新たに作成
     されたフレームのフレームパラメーターのリストを指定する。リスト内の
     各要素は‘make-frame’の引数として与えられなかったパラメーター(シンボ
     ル)であり、‘make-frame’は新たに作成されたフレームのそのパラメーター
     に、選択されたフレームの値をセットする。


File: elisp,  Node: Multiple Terminals,  Next: Frame Parameters,  Prev: Creating Frames,  Up: Frames

28.2 Multiple Terminals
=======================

Emacsは、それぞれの端末を“端末オブジェクト(terminal object)”というデータ
型で表します(*note Terminal Type::を参照)。GNUおよびUnixシステムでは、
Emacsはそれぞれのセッション内で複数の端末を同時に実行できます。その他の
システムでは、単一の端末だけが使用できます。端末オブジェクトはそれぞれ、
以下の属性をもちます:

   • その端末により使用されるデバイスの名前(たとえば‘:0.0’や
     ‘/dev/tty’)。

   • その端末により使用される端末とキーボードのコーディングシステム。
     *note Terminal I/O Encoding::を参照のこと。

   • その端末に関連付けられたディスプレイの種類。これは、関数
     ‘terminal-live-p’によりリターンされるシンボル(たとえば‘x’、‘t’、
     ‘w32’、‘ns’、‘pc’)である。*note Frames::を参照のこと。

   • 端末パラメーターのリスト。*note Terminal Parameters::を参照のこと。

   端末オブジェクトを作成するプリミティブはありません。
‘make-frame-on-display’(以下参照)を呼び出したときなど、Emacsは必要に応じ
てそれらを作成します。

 -- Function: terminal-name &optional terminal
     この関数は、TERMINALにより使用されるデバイスのファイル名をリターン
     する。TERMINALが省略または‘nil’の場合のデフォルトは、選択されたフレ
     ームの端末である。TERMINALはフレームでもよく、その場合はそのフレー
     ムの端末となる。

 -- Function: terminal-list
     この関数は、すべての生きた端末オブジェクトのリストをリターンする。

 -- Function: get-device-terminal device
     この関数は、DEVICEにより与えられたデバイス名の端末をリターンする。
     DEVICEが文字列の場合は端末デバイス名、または‘HOST:SERVER.SCREEN’と
     いう形式のXディスプレイ名のいずれかを指定できる。DEVICEの場合、この
     関数はそのフレームの端末をリターンする。‘nil’は選択されたフレームを
     意味する。最後に、もしDEVICEが生きた端末を表す端末オブジェクトなら
     、その端末がリターンされる。引数がこれらのいずれとも異なる場合、こ
     の関数はエラーをシグナルする。

 -- Function: delete-terminal &optional terminal force
     この関数は、TERMINAL上のすべてのフレームを削除して、それらが使用し
     ていたリソースを解放する。これらはアブノーマルフック
     ‘delete-terminal-functions’を実行し、各関数の引数としてTERMINALを渡
     す。

     TERMINALが省略または‘nil’の場合のデフォルトは、選択されたフレームの
     端末である。TERMINALはフレームでもよく、その場合はそのフレームの端
     末を意味する。

     この関数は通常、唯一アクティブな端末の削除を試みるとエラーをシグナ
     ルするが、FORCEが非‘nil’なら、これを行うことができる。端末上で最後
     のフレームを削除した際、Emacsは自動的にこの関数を呼び出す(*note
     Deleting Frames::を参照)。

 -- Variable: delete-terminal-functions
     ‘delete-terminal’により実行されるアブノーマルフック。各関数は、
     ‘delete-terminal’に渡されたTERMINALを、唯一の引数として受け取る。技
     術的な詳細により、この関数は端末の削除の直前、または直後のいずれか
     に呼び出される。

   数は多くありませんが、いくつかのLisp変数は“端末ローカル
(terminal-local)”です。つまり、それらは端末それぞれにたいして、個別にバ
インディングをもちます。いかなるときも、実際に効果をもつバインディングは
、カレントで選択されたフレームに属する端末にたいして1つだけです。これら
の変数には‘default-minibuffer-frame’、‘defining-kbd-macro’、
‘last-kbd-macro’、‘system-key-alist’が含まれます。これらは常に端末ローカ
ルであり、決してバッファーローカル(*note Buffer-Local Variables::を参照
)にはできません。

   GNUおよびUnixシステムでは、Xディスプレイはそれぞれ別のグラフィカル端
末になります。Xウィンドウシステム内でEmacsが開始された際は環境変数
‘DISPLAY’、または‘--display’オプション(*note (emacs)Initial Options::を
参照)により指定されたXディスプレイを使用します。Emacsはコマンド
‘make-frame-on-display’を通じて、別のXディスプレイに接続できます。それぞ
れのXディスプレイは各自、選択されたフレームとミニバッファーをもちます。
しかしあらゆる瞬間(*note Input Focus::を参照)において、それらのフレーム
のうちの1つだけが、“_いわゆる_選択されたフレーム”になります。
‘emacsclient’との対話することにより、Emacsが別のテキスト端末と接続するこ
とさえ可能です。*note (emacs)Emacs Server::を参照してください。

   1つのXサーバーが、1つ以上のディスプレイを処理できます。各Xディスプレ
イには、‘HOSTNAME:DISPLAYNUMBER.SCREENNUMBER’という3つの部分からなる名前
があります。1つ目の部分のHOSTNAMEは、その端末が物理的に接続されるマシン
名です。2つ目の部分のDISPLAYNUMBERは、同じキーボードとポインティングデバ
イス(マウスやタブレット等)を共有するマシンに接続された、1つ以上のモニタ
ーを識別するための、0基準の番号です。3つ目の部分のSCREENNUMBERは、その
Xサーバー上の単一のモニターコレクション(a single monitor collection)の一
部である、0基準のスクリーン番号(個別のモニター)です。1つのサーバー配下に
ある2つ以上のスクリーンを使用する際、Emacsはそれらの名前の同一部分から、
それらが単一のキーボードを共有することを知ることができるのです。

   MS-WindowsのようにXウィンドウシステムを使用しないシステムは、Xディス
プレイの概念をサポートせず、各ホスト上には1つのディスプレイだけがありま
す。これらのシステム上のディスプレイ名は、上述したような3つの部分からな
る名前にしたがいません。たとえば、MS-Windowsシステム上のディスプレイ名は
文字列定数‘w32’です。これは互換性のために存在するものであり、ディスプレ
イ名を期待する関数にこれを渡すことができます。

 -- Command: make-frame-on-display display &optional parameters
     この関数は、DISPLAY上に新たにフレームを作成して、それをリターンする
     。その他のフレームパラメーターは、alist PARAMETERSから取得する。
     DISPLAYはXディスプレイの名前(文字列)であること。

     この関数は、フレーム作成前にEmacsがグラフィックを表示するために“セ
     ットアップ”されることを保証する。たとえば、Emacsが(テキスト端末上で
     開始された等で)Xリソースを未処理なら、この時点で処理を行う。他のす
     べての点においては、この関数は‘make-frame’(*note Creating Frames::を
     参照)と同様に振る舞う。

 -- Function: x-display-list
     この関数は、EmacsがどのXディスプレイに接続したかを識別するリストを
     リターンする。このリストの要素は文字列で、それぞれがディスプレイ名
     を表す。

 -- Function: x-open-connection display &optional xrm-string
          must-succeed
     この関数は、ディスプレイ上にフレームを作成することなく、Xディスプレ
     イDISPLAYへの接続をオープンする。通常は、‘make-frame-on-display’が
     自動的に呼び出すので、Emacs Lispプログラムがこの関数を呼び出す必要
     はない。これを呼び出す唯一の理由は、与えられたXディスプレイにたいし
     て通信を確立できるかどうかチェックするためである。

     オプション引数XRM-STRINGが非‘nil’なら、それは‘.Xresources’ファイル
     内で使用されるフォーマットと同一な、リソース名とリソース値である。
     *note X Resources: (emacs)X Resources.を参照のこと。これらの値はそ
     のXサーバー上で記録されたリソース値をオーバーライドして、このディス
     プレイ上で作成されるすべてのEmacsフレームにたいして適用される。以下
     は、この文字列がどのようなものかを示す例である:

          "*BorderWidth: 3\n*InternalBorder: 2\n"

     MUST-SUCCEEDが非‘nil’なら、接続オープンの失敗によりEmacsが終了させ
     られる。それ以外の場合は、通常のLispエラーとなる。

 -- Function: x-close-connection display
     この関数は、ディスプレイDISPLAYへの接続をクローズする。これを行う前
     にまず、そのディスプレイ上でオープンしたすべてのフレームを削除しな
     ければならない(*note Deleting Frames::を参照)。

   “マルチモニター”のセットアップにおいて、単一のXディスプレイが複数の物
理モニターに出力される場合があります。そのようなセットアップを取得するた
めに、関数‘display-monitor-attributes-list’と
‘frame-monitor-attributes’を使用できます。

 -- Function: display-monitor-attributes-list &optional display
     この関数は、DISPLAY上の物理モニターの属性のリストをリターンする。
     DISPLAYにはディスプレイ名(文字列)、端末、フレームを指定でき、省略ま
     たは‘nil’の場合のデフォルトは、選択されたフレームのディスプレイであ
     る。このリストの各要素は、物理モニターの属性を表す連想リストである
     。1つ目の要素はプライマリーモニターである。以下は属性のキーと値であ
     る:

     ‘geometry’
          ‘(X Y WIDTH HEIGHT)’のような、ピクセル単位でのそのモニターのス
          クリーンの左上隅の位置、そのサイズ。そのモニターがプライマリー
          モニターでない場合は、いくつかの座標が負になり得る。

     ‘workarea’
          ‘(X Y WIDTH HEIGHT)’のような、ピクセル単位でのワークエリア(“使
          用可能”なスペース)の左上隅の位置と、そのサイズ。これはワークエ
          リアから除外され得る、ウィンドウマネージャーのさまざまな機能
          (dock、taskbar等)が占めるスペースの分、‘geometry’とは異なるか
          もしれない。そのような機能が実際にワークエリアから差し引かれる
          かどうかは、そのプラットフォームと環境に依存する。繰り返しにな
          るが、そのモニターがプライマリーモニターでない場合、いくつかの
          座標は負になり得る。

     ‘mm-size’
          ‘(WIDTH HEIGHT)’<のような、ミリメートル単位での幅と高さ。

     ‘frames’
          その物理モニターが支配(dominate)するフレームのリスト(以下参照
          )。

     ‘name’
          STRINGのような、その物理モニターの名前。

     ‘source’
          STRINGのような、マルチモニターの情報ソース(例: ‘XRandr’、
          ‘Xinerama’等)。

     X、Y、WIDTH、HEIGHTは整数。‘name’と‘source’は欠落しているかもしれな
     い。

     あるモニター内にフレームの最大領域がある、または(フレームがどの物理
     モニターに跨がらないなら)そのモニターがフレームに最も近いとき、フレ
     ームは物理モニターにより“支配(dominate)”される。グラフィカルなディ
     スプレイ内の(ツールチップではない)すべてのフレームは、たとえそのフ
     レームが複数の物理モニターに跨がる(または物理モニター上にない)とし
     ても、(可視か否かによらず)正確に1つの物理モニターにより支配される。

     以下は、2つのモニターディスプレイ上でこの関数により生成されたデータ
     の例である:

            (display-monitor-attributes-list)
            ⇒
            (((geometry 0 0 1920 1080) ;; 左手側プライマリーモニター
              (workarea 0 0 1920 1050) ;; タスクバーが幾分かの高さを占有
              (mm-size 677 381)
              (name . "DISPLAY1")
              (frames #<frame emacs@host *Messages* 0x11578c0>
                      #<frame emacs@host *scratch* 0x114b838>))
             ((geometry 1920 0 1680 1050) ;; 右手側モニター
              (workarea 1920 0 1680 1050) ;; スクリーン全体を使用可
              (mm-size 593 370)
              (name . "DISPLAY2")
              (frames)))

 -- Function: frame-monitor-attributes &optional frame
     この関数は、 FRAMEを支配(上記参照)する物理モニターの属性をリターン
     する。 FRAMEのデフォルトは選択されたフレームである。


File: elisp,  Node: Frame Parameters,  Next: Terminal Parameters,  Prev: Multiple Terminals,  Up: Frames

28.3 Frame Parameters
=====================

フレームはに、その外見と挙動を制御する、多くのパラメーターがあります。フ
レームがどのようなパラメーターをもつかは、そのフレームが使用するディスプ
レイのメカニズムに依存します。

   フレームパラメーターは主に、グラフィカルディスプレイのために存在しま
す。ほとんどのフレームパラメーターは、テキスト端末上のフレームに適用時は
効果がありません。テキスト端末上のフレームでは、何か特別なことを行うパラ
メーターは‘height’、‘width’、‘name’、‘title’、‘menu-bar-lines’、
‘buffer-list’、‘buffer-predicate’だけです。その端末がカラーをサポートに
は‘foreground-color’、‘background-color’、‘background-mode’、
‘display-type’などのパラメーターも意味をもちます。その端末が透過フレーム
(frame transparency)をサポートする場合には、パラメーター‘alpha’も意味を
もちます。

* Menu:

* Parameter Access::         フレームのパラメーターの変更方法。
* Initial Parameters::       フレーム作成時に指定するフレームパラメーター。
* Window Frame Parameters::  ウィンドウシステムにたいするフレームパラメーターのリスト。
* Size and Position::        フレームのサイズと位置の変更。
* Geometry::                 ジオメトリー仕様の解析。


File: elisp,  Node: Parameter Access,  Next: Initial Parameters,  Up: Frame Parameters

28.3.1 Access to Frame Parameters
---------------------------------

以下の関数により、フレームのパラメーター値の読み取りと変更ができます。

 -- Function: frame-parameter frame parameter
     この関数は、FRAMEのパラメーターPARAMETER(シンボル)の値をリターンす
     る。FRAMEが‘nil’なら、選択されたフレームのパラメーターをリターンす
     る。FRAMEがPARAMETERにたいするセッティングをもたない場合、この関数
     は‘nil’をリターンする。

 -- Function: frame-parameters &optional frame
     関数‘frame-parameters’は、FRAMEのすべてのパラメーターとその値をリス
     トするalistをリターンする。FRAMEが省略または‘nil’の場合は、選択され
     たフレームのパラメーターをリターンする。

 -- Function: modify-frame-parameters frame alist
     この関数は、ALISTの要素にもとづきフレームFRAMEのパラメーターを変更
     する。ALIST内の要素はそれぞれ‘(PARM . VALUE)’という形式をもち、ここ
     でPARMはパラメーターを名付けるシンボルである。 ALIST内に指定されな
     いパラメーターの値は変更されない。FRAMEが‘nil’の場合のデフォルトは
     、選択されたフレームである。

 -- Function: set-frame-parameter frame parm value
     この関数は、フレームパラメーターPARMに、指定されたVALUEをセットする
     。FRAMEが‘nil’の場合のデフォルトは、選択されたフレームである。

 -- Function: modify-all-frames-parameters alist
     この関数は、 ALISTに応じて既存のフレームすべてのフレームパラメータ
     ーを変更してから、今後に作成されるフレームに同じパラメーター値を適
     用するために、‘default-frame-alist’(と必要なら
     ‘initial-frame-alist’)を変更する。


File: elisp,  Node: Initial Parameters,  Next: Window Frame Parameters,  Prev: Parameter Access,  Up: Frame Parameters

28.3.2 Initial Frame Parameters
-------------------------------

initファイル(*note Init File::を参照)内で‘initial-frame-alist’をセットす
ることにより、フレームの初期スタートアップにパラメーターを指定できます。

 -- User Option: initial-frame-alist
     この変数の値は、初期フレーム作成時に使用されるパラメーター値の
     alistである。以降のフレームを変更することなく、初期フレームの外見を
     指定するために、この変数を使用できる。要素はそれぞれ以下の形式をも
     つ:

          (PARAMETER . VALUE)

     Emacsは、initファイル読み取り前に初期フレームを作成する。After
     reading that file, Emacs checks ‘initial-frame-alist’をチェックして
     、すでに作成済みの初期フレームに、変更する値に含まれるパラメーター
     のセッティングを適用する。

     これらのセッティングがフレームのジオメトリーと外見に影響する場合に
     は、間違った外見のフレームを見た後、指定した外見に変更されるのを目
     にするだろう。これが煩わしい場合は、Xリソースで同じジオメトリーと外
     見を指定できる。これらは、フレーム作成前に効果をもつ。*note X
     Resources: (emacs)X Resources.を参照されたい。

     Xリソースセッティングは通常、すべての!に適用される。初期フレームの
     ために、あるXリソースを単独で指定して、それ以降のフレームには適用し
     たくない場合は、次の方法によりこれを達成できる。それ以降のフレーム
     にたいするXリソースをオーバーライドするために、
     ‘default-frame-alist’内でパラメーターを指定してから、それらが初期フ
     レームに影響するのを防ぐために、‘initial-frame-alist’内の同じパラメ
     ーターにたいして、Xリソースにマッチする値を指定すればよい。

   これらのパラメーターに‘(minibuffer . nil)’が含まれるなら、それは初期
フレームがミニバッファーをもつべきではないことを示します。この場合、
Emacsは同じように“ミニバッファーオンリーフレーム(minibuffer-only
frame)”を別個作成します。

 -- User Option: minibuffer-frame-alist
     この変数の値は、初期ミニバッファーオンリーフレーム
     (‘initial-frame-alist’がミニバッファーのないフレームを指定する場合
     にEmacsが作成するミニバッファーオンリーフレームのこと)を作成時に使
     用されるパラメーター値のalistである。

 -- User Option: default-frame-alist
     これは、すべてのEmacsフレーム(最初のフレームとそれ以降のフレーム)に
     たいして、フレームパラメーターのデフォルト値を指定するalistである。
     Xウィンドウシステム使用時には、大抵はXリソースで同じ結果を得られる
     。

     この変数のセットは既存フレームに影響しない。さらに、別フレームにバ
     ッファーを表示する関数は、自身のパラメーターを提供することにより、
     デフォルトパラメーターをオーバーライドできる。

   フレームの外見を指定するコマンドラインオプションとともにEmacsを呼び出
した場合、これらのオプションは‘initial-frame-alist’または
‘default-frame-alist’のいずれかに要素を追加することにより、効果を発揮し
ます。‘--geometry’や‘--maximized’のような、初期フレームだけに影響するオ
プションは‘initial-frame-alist’、その他のオプションは
‘default-frame-alist’に要素を追加します。*note Command Line Arguments
for Emacs Invocation: (emacs)Emacs Invocation.を参照してください。


File: elisp,  Node: Window Frame Parameters,  Next: Size and Position,  Prev: Initial Parameters,  Up: Frame Parameters

28.3.3 Window Frame Parameters
------------------------------

フレームがどんなパラメーターをもつかは、どのようなディスプレイのメカニズ
ムがそれを使用するかに依存します。このセクションでは、一部、またはすべて
の端末種類において特別な意味をもつパラメーターを説明します。これらのうち
‘name’、‘title’、‘height’、‘width’、‘buffer-list’、‘buffer-predicate’は
端末フレームにおいて有意な情報を提供し、‘tty-color-mode’はテキスト端末上
のフレームにたいして意味があります。

* Menu:

* Basic Parameters::         基本的なパラメーター。
* Position Parameters::      スクリーン上のフレームの位置。
* Size Parameters::          フレームのサイズ。
* Layout Parameters::        フレームのパーツのサイズと、一部パーツの有効化と無効化。
* Buffer Parameters::        表示済みまたは表示されるべきバッファーはどれか。
* Management Parameters::    ウィンドウマネージャーとの対話。
* Cursor Parameters::        カーソルの外見の制御。
* Font and Color Parameters::  フレームテキストにたいするフォントとカラー。


File: elisp,  Node: Basic Parameters,  Next: Position Parameters,  Up: Window Frame Parameters

28.3.3.1 Basic Parameters
.........................

以下のフレームパラメーターは、フレームに関してもっとも基本的な情報を提供
します。‘title’と‘name’は、すべての端末において意味をもちます。

‘display’
     このフレームをオープンするためのディスプレイ。これは環境変数
     ‘DISPLAY’のような、‘HOST:DPY.SCREEN’という形式の文字列であること。
     ディスプレイ名についての詳細は、*Note Multiple Terminals::を参照の
     こと。

‘display-type’
     このパラメーターは、このフレーム内で使用できる利用可能なカラーの範
     囲を記述する。値は‘color’、‘grayscale’、‘mono’のいずれか。

‘title’
     フレームが非‘nil’のtitleをもつ場合、それはフレーム上端にあるウィン
     ドウシステムのタイトルバーに表示され、
     ‘mode-line-frame-identification’に‘%F’(*note %-Constructs::を参照
     )を使用していればそのフレーム内のウィンドウのモードラインにも表示さ
     れる。これは通常、Emacsがウィンドウシステムを使用しておらず、かつ同
     時に1つのフレームのみ表示可能なケースが該当する。*note Frame
     Titles::を参照のこと。

‘name’
     そのフレームの名前。‘title’が未指定または‘nil’なら、フレーム名はフ
     レームタイトルにたいしてデフォルトの役割りを果たす。nameを指定しな
     い場合、Emacsは自動的にフレーム名をセットする(*note Frame Titles::を
     参照)。

     フレーム作成時に明示的にフレーム名を指定した場合は、そのフレームに
     たいしてXリソースを照合する際にも、(Emacs実行可能形式名のかわりに
     )その名前が使用される。

‘explicit-name’
     フレーム作成時にフレーム名が明示的に指定された場合、このパラメータ
     ーはその名前になるだろう。明示的に名付けられなかった場合、このパラ
     メーターは‘nil’になる。


File: elisp,  Node: Position Parameters,  Next: Size Parameters,  Prev: Basic Parameters,  Up: Window Frame Parameters

28.3.3.2 Position Parameters
............................

位置パラメーターの値は通常はピクセル単位ですが、テキスト端末ではピクセル
単位のかわりに文字数か行数で数えられます。

‘left’
     スクリーンの左(右)端からフレームの左(右)端までの、ピクセル単位での
     位置。値は:

     整数
          正の整数は、スクリーン左端をフレーム左端に、負の整数はフレーム
          右端をスクリーン右端に関連付ける。

     ‘(+ POS)’
          これは、スクリーン左端にたいしフレーム左端の相対的位置を指定す
          る。整数POSは正および負の値をとり得る。負の値はスクリーン外側
          、または(マルチモニターディスプレイにたいしては)プライマリーモ
          ニター以外のモニター上の位置を指定する。

     ‘(- POS)’
          これは、スクリーン右端にたいしフレーム右端の相対的位置を指定す
          る。整数POSは正および負の値をとり得る。負の値はスクリーン外側
          、または(マルチモニターディスプレイにたいしては)プライマリーモ
          ニター以外のモニター上の位置を指定する。

     プログラム指定の位置を無視するウィンドウマネージャーがいくつかある
     。指定した位置が無視されない保証を望む場合は、パラメーター
     ‘user-position’にも同様に非‘nil’値を指定すること。

‘top’
     スクリーン上(下)端にたいして、上(下)端のスクリーン位置をピクセル単
     位で指定する。方向が水平ではなく垂直である点を除き、これは‘left’と
     同様に機能する。

‘icon-left’
     スクリーン左端から数えた、フレームアイコン左端のピクセル単位のスク
     リーン位置。ウィンドウマネージャーがこの機能をサポートすれば、これ
     はフレームをアイコン化したとき効果を発揮する。このパラメーターに値
     を指定する場合は‘icon-top’にも値を指定しなければならず、その逆も真
     である。

‘icon-top’
     スクリーン上端から数えた、フレームアイコン上端のピクセル単位のスク
     リーン位置。ウィンドウマネージャーがこの機能をサポートすれば、これ
     はフレームをアイコン化したとき効果を発揮する。

‘user-position’
     フレームを作成してパラメーター‘left’と‘top’で位置を指定する際は、指
     定した位置がユーザー指定(人間であるユーザーにより明示的に要求された
     位置)なのか、それとも単なるプログラム指定(プログラムにより選択され
     た位置)なのかを告げるために、このパラメーターを使用する。非‘nil’値
     は、それがユーザー指定の位置であることを告げる。

     ウィンドウマネージャーは一般的にユーザー指定位置に留意し、プログラ
     ム指定位置にも幾分か留意する。しかし、多くはプログラム指定位置を無
     視してウィンドウをウィンドウマネージャーのデフォルトの方法で配すか
     、ユーザーのマウスによる配置に任せる。‘twm’を含むウィンドウマネージ
     ャーのいくつかは、プログラム指定位置にしたがうか無視するかをユーザ
     ーの指定に任せる。

     ‘make-frame’を呼び出す際、パラメーター‘left’および‘top’の値がそのユ
     ーザーにより示される嗜好を表すなら、このパラメーターに非‘nil’値を、
     それ以外は‘nil’を指定するべきである。


File: elisp,  Node: Size Parameters,  Next: Layout Parameters,  Prev: Position Parameters,  Up: Window Frame Parameters

28.3.3.3 Size Parameters
........................

フレームパラメーターはフレームのサイズを文字単位で指定します。グラフィカ
ルなディスプレイ上では、‘default’フェイスがこれら文字単位の実際のピクセ
ルサイズを決定します(*note Face Attributes::を参照)。

‘height’
     文字単位によるフレームコンテンツの高さ(ピクセル単位で高さを取得する
     には‘frame-pixel-height’を呼び出す。*note Size and Position::を参照
     のこと)。

‘width’
     文字単位によるフレームコンテンツの幅(ピクセル単位で幅を取得するには
     ‘frame-pixel-width’を呼び出す。*note Size and Position::を参照のこ
     と)。

‘user-size’
     これは、サイズパラメーター‘height’および‘width’にたいして、
     ‘user-position’(*note user-position: Position Parameters.を参照)が
     ‘top’および‘left’が行うのと同じことを行う。

‘fullscreen’
     幅または高さ、もしくはその両方を最大化することを指定する。値
     ‘fullwidth’は、可能な限り幅を広く、値‘fullheight’は高さを可能な限り
     高く、値‘fullboth’は幅と高さをスクリーンサイズにセット、値
     ‘maximized’はフレームを最大化することを指定する。‘maximized’と
     ‘fullboth’の違いは、前者がマウスでそのウィンドウマネージャーによる
     装飾をドラッグしてサイズ変更が可能なのにたいし、後者は実際のスクリ
     ーン全体を覆うためマウスによるサイズ変更ができないことである。

     いくつかのウィンドウマネージャーでは、フレームを“maximized”または
     “fullscreen”にするために、変数‘frame-resize-pixelwise’を非‘nil’値に
     カスタマイズする必要があるかもしれない。

