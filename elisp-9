This is elisp, produced by makeinfo version 6.6 from elisp.texi.

This is the ‘GNU Emacs Lisp Reference Manual’ corresponding to Emacs
version 24.5.

   Copyright © 1990–1996, 1998–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).               The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Layout Parameters,  Next: Buffer Parameters,  Prev: Size Parameters,  Up: Window Frame Parameters

28.3.3.4 Layout Parameters
..........................

以下のフレームパラメーターにより、フレームのさまざまなパーツを有効または
無効にしたり、サイズを制御できます。

‘border-width’
     ピクセル単位でのフレームのボーダー幅。

‘internal-border-width’
     テキスト(またはフリンジ)とフレームボーダーとのピクセル単位による距
     離。

‘vertical-scroll-bars’
     フレームが垂直スクロール用のスクロールバーをもつべきか否か、スクロ
     ールバーをフレームのどちら側に置くか。可能な値は‘left’、‘right’、ス
     クロールバーなしは‘nil’。

‘scroll-bar-width’
     垂直スクロールバーのピクセル単位による幅。‘nil’はデフォルト幅の使用
     を意味する。

‘left-fringe’
‘right-fringe’
     そのフレーム内のウィンドウの左右フリンジのデフォルト幅(*note
     Fringes::を参照)。いずれかが0なら、対応するフリンジを削除する効果が
     ある。 If either of these is zero, that effectively removes the
     corresponding fringe.

     これら2つのフレームパラメーターの値を問い合わせるために
     ‘frame-parameter’を使用する際、リターン値は常に整数となる。‘nil’値
     を渡して‘set-frame-parameter’を使用する際は、実際のデフォルト値8ピ
     クセルが課せられる。

     合成済みフリンジ幅は列数の合計数まで加算されなければならないので、
     ‘frame-parameter’の応答値は指定値より大きくなるかもしれない。左右の
     フリンジ間には、余分な幅が均等に配分される。しかし、フリンジのいず
     れか幅に負の整数を指定することにより、フリンジに正確な幅を強制でき
     る。どちらのフリンジ幅も負の場合は、左フリンジだけが指定された幅と
     なる。

‘right-divider-width’
     フレーム上のすべてのウィンドウの右ディバイダー(*note Window
     Dividers::を参照)用に予約される、ピクセル単位の幅(厚さ)。値0は右デ
     ィバイダーを描画しないことを意味する。

‘bottom-divider-width’
     フレーム上のすべてのウィンドウの下ディバイダー(*note Window
     Dividers::を参照)用に予約される、ピクセル単位の幅(厚さ)。値0は下デ
     ィバイダーを描画しないことを意味する。

‘menu-bar-lines’
     メニューバー用にフレーム上端に割り当てる行数。Menu Barモードが有効
     の場合のデフォルトは1、それ以外は0である。*note (emacs)Menu Bars::を
     参照のこと。

‘tool-bar-lines’
     ツールバー用に使用する行数。Tool Barモードが有効の場合のデフォルト
     は1、それ以外は0である。*Note (emacs)Tool Bars::を参照のこと。

‘tool-bar-position’
     ツールバーの位置。現在のところGTKツールバーのみ。可能な値は‘top’、
     ‘bottom’、‘left’、‘right’。デフォルトは‘top’。

‘line-spacing’
     各テキスト行配下に残す、ピクセル単位の追加スペース(正の整数)。詳細
     は*note Line Height::を参照のこと。


File: elisp,  Node: Buffer Parameters,  Next: Management Parameters,  Prev: Layout Parameters,  Up: Window Frame Parameters

28.3.3.5 Buffer Parameters
..........................

以下は、フレーム内でどのバッファーが表示されているか、されるべきかを扱う
ためのフレームパラメーターで、すべての種類の端末上で意味があります。

‘minibuffer’
     そのフレームが自身のミニバッファーをもつか否か。もつ場合は‘t’、もた
     ない場合は‘nil’、‘only’ならそのフレームが正にミニバッファーであるこ
     とを意味する。値が(別フレーム内の)ミニバッファーウィンドウの場合、
     そのフレームはそのミニバッファーを使用する。

     このフレームパラメーターはフレーム作成時に効果があち、その後は変更
     できない。

‘buffer-predicate’
     このフレームにたいする、buffer-predicate関数。関数‘other-buffer’は
     、どのバッファーを考慮すべきか決定するために、(選択されたフレームか
     ら)この述語が‘nil’でなければ、これを使用する。これは各バッファーに
     たいして、そのバッファーを唯一の引数として、この述語を1回呼び出す。
     この述語が非‘nil’値をリターンしたら、そのバッファーは考慮される。

‘buffer-list’
     そのフレーム内で選択されているバッファーの、もっとも最近選択された
     バッファーが先頭になるような順のリスト。

‘unsplittable’
     非‘nil’なら、このフレームのウィンドウは決して自動的に分割されること
     はない。


File: elisp,  Node: Management Parameters,  Next: Cursor Parameters,  Prev: Buffer Parameters,  Up: Window Frame Parameters

28.3.3.6 Window Management Parameters
.....................................

以下のフレームパラメーターは、ウィンドウマネージャーとフレームとの相互作
用のさまざまな面を制御します。これらは、テキスト端末上では効果がありませ
ん。

‘visibility’
     フレームの可視性(visibility)の状態。可能な値は3つあり、‘nil’は不可
     視、‘t’は可視、‘icon’はアイコン化されていることを意味する。*note
     Visibility of Frames::を参照のこと。

‘auto-raise’
     非‘nil’なら、Emacsはそのフレーム選択時に自動的にそれを前面に移動
     (raise)する。これを許さないウィンドウマネージャーがいくつかある。

‘auto-lower’
     非‘nil’なら、Emacsはそのフレームの選択解除時に自動的にそれを背面に
     移動(lower)する。これを許さないウィンドウマネージャーがいくつかある
     。

‘icon-type’
     そのフレームに使用するアイコンのタイプ。値が文字列の場合、それは使
     用するビットマップを含むファイルを指定し、‘nil’はアイコンなしを指定
     する(何を表示するかはウィンドウマネージャーが決定する)。その他の非
     ‘nil’値は、デフォルトのEmacsアイコンを指定する。

‘icon-name’
     このフレームにたいするアイコンで使用する名前。アイコンを表示する場
     合は、その際に表示される。これが‘nil’なら、フレームのタイトルが使用
     される。

‘window-id’
     グラフィカルディスプレイがこのフレームにたいして使用するID番号。
     Emacsは、フレーム作成時にこのパラメーターを割り当てる。このパラメー
     ターを変更しても、実際のID番号に効果はない。

‘outer-window-id’
     そのフレームが存在する最外殻のウィンドウシステムのウィンドウのID番
     号。‘window-id’と同様、このパラメーターを変更しても実際の効果はない
     。

‘wait-for-wm’
     非‘nil’なら、ジオメトリー変更を確認するために、ウィンドウマネージャ
     ーを待機するようXtに指示する。Fvwm2およびKDEのバージョンを含むウィ
     ンドウマネージャーのいくつかは確認に失敗するので、Xtがハングする。
     これらウィンドウマネージャーのハングを防ぐために、これを‘nil’にセッ
     トする。

‘sticky’
     非‘nil’なら、仮想デスクトップを伴うシステム上のすべての仮想デスクト
     ップ上で、そのフレームが可視になる。


File: elisp,  Node: Cursor Parameters,  Next: Font and Color Parameters,  Prev: Management Parameters,  Up: Window Frame Parameters

28.3.3.7 Cursor Parameters
..........................

このフレームパラメーター!、カーソルの外見を制御します。

‘cursor-type’
     カーソルの表示方法。適正な値は:

     ‘box’
          塗りつぶされた四角形(filled box)を表示する(デフォルト)。
     ‘hollow’
          中抜きの四角形(hollow box)を表示する。
     ‘nil’
          カーソルウィンドウ表示しない。
     ‘bar’
          文字間に垂直バー(vertical bar)を表示する。
     ‘(bar . WIDTH)’
          文字間に幅がWIDTHピクセルの垂直バー(vertical bar)を表示する。
     ‘hbar’
          文字間に水平バー(horizontal bar)を表示する。
     ‘(hbar . HEIGHT)’
          文字間に高さがHEIGHTピクセルの水平バー(horizontal bar)を表示す
          る。

   フレームパラメーター‘cursor-type’は、変数‘cursor-type’および
‘cursor-in-non-selected-windows’によりオーバーライドされるかもしれません
。

 -- Variable: cursor-type
     このバッファーローカル変数は、選択されたウィンドウ内で表示されてい
     るそのバッファーのカーソルの外見を制御する。この値が‘t’なら、それは
     フレームパラメーター‘cursor-type’で指定されたカーソルのーを使用する
     ことを意味する。それ以外では、値は上記リストのカーソルタイプのいず
     れかであるべきで、これはフレームパラメーター‘cursor-type’をオーバー
     ライドする。

 -- User Option: cursor-in-non-selected-windows
     このバッファーローカル変数は、選択されていないウィンドウ内でのカー
     ソルの外見を制御する。これは、フレームパラメーター‘cursor-type’と同
     じ値をサポートする。さらに、‘nil’は選択されていないウィンドウ内には
     カーソルを表示せず、‘t’は通常のカーソルタイプの標準的な変更(塗りつ
     ぶされた四角形は中抜きの四角形に、バーはより細いバーにする)の使用を
     意味する。

 -- User Option: blink-cursor-alist
     この変数は、カーソルのブリンク(blink: 点滅)方法を指定する。各要素は
     ‘(ON-STATE . OFF-STATE)’という形式をもつ。カーソルタイプが
     ON-STATEと等しい(‘equal’を用いて比較)ときは常に、これに対応する
     OFF-STATEがブリンクが“off”の際のカーソルの外見を指定する。
     ON-STATEとOFF-STATEはどちらもフレームパラメーター‘cursor-type’に適
     した値であること。

     それぞれのカーソルタイプのブリンク方法にたいして、そのタイプがここ
     でON-STATEとして指定されていなければ、さまざまなデフォルトが存在す
     る。フレームパラメーター‘cursor-type’で指定した際に限り、この変数内
     での変更は即座に効果を発揮しない。


File: elisp,  Node: Font and Color Parameters,  Prev: Cursor Parameters,  Up: Window Frame Parameters

28.3.3.8 Font and Color Parameters
..................................

以下のフレームパラメーターは、フォントとカラーの使用を制御します。

‘font-backend’
     フレーム内でフォントの描画に使用するための“フォントバックエンド
     (font backends)”を指定する、優先順のシンボルのリスト。Xでは現在のと
     ころ、‘x’(X core font driver)と‘xft’(Xft font driver)の2つの利用可
     能なフォントバックエンドがある。MS-Windowsでは現在のところ、‘gdi’と
     ‘uniscribe’の2つの利用可能なフォントバックエンドがある(*note
     (emacs)Windows Fonts::を参照)。その他のシステムでは利用可能なフォン
     トバックエンドは1つだけなので、このフレームパラメーターを変更しても
     意味がない。

‘background-mode’
     このパラメーターは‘dark’か‘light’のいずれかで、それぞれバックグラウ
     ンドを暗く(dark)するか、明るく(light)するかに対応する。

‘tty-color-mode’
     このパラメーターは端末上で使用するカラーモードを指定し、、そのシス
     テムの端末機能データベース(terminal capabilities database、
     termcap)により与えられた端末のカラーサポートを、その値でオーバーラ
     イドする。値にはシンボルか数値を指定できる。数値の場合は、使用する
     カラー数(および間接的にはそれぞれのカラーを生成するためのコマンド
     )を指定する。たとえば‘(tty-color-mode . 8)’は、標準的なテキストカラ
     ーにたいしてANSIエスケープシーケンスの使用を指定する。値-1はカラー
     サポートをオフに切り替える。

     このパラメーターの値がシンボルの場合、それは
     ‘tty-color-mode-alist’の値を通じた数値を指定するもので、かわりにそ
     のシンボルに割り当てられた数値が使用される。

‘screen-gamma’
     これが数値の場合、Emacsはすべてのカラーの輝度を調整する“ガンマ補正
     (gamma correction)”を行う。値はディスプレイのスクリーンのガンマであ
     ること。

     通常のPCモニター／あスクリーンガンマが2.2なので、EmacsおよびXウィン
     ドウのカラー値は一般的にそのガンマ値のモニター上で正しく表示するよ
     う校正されている。‘screen-gamma’にたいして2.2を指定した場合、それは
     補正が不必要であることを意味する。その他の値は、通常のモニター上で
     ガンマ値2.2で表示されるであろう、補正されたカラーがスクリーン上に表
     示されるように意図された補正を要求する。

     モニターが表示するカラーが明るすぎる場合は、‘screen-gamma’に2.2より
     小さい値を指定するべきである。これは、カラーをより暗くする補正を要
     求する。スクリーンガンマの値1.5は、LCDカラーディスプレイにたいして
     、よい結果を与えるだろう。

‘alpha’
     このパラメーターは、可変透明度(variable opacity)をサポートするグラ
     フィカルディスプレイ上での、そのフレームの透明度を指定する(訳注:
     opacityを訳すと逆の不透明度だが、このような場合は一般的に透明度と訳
     すようなので、それに倣う)。これは0から100の整数であるべきで、0は完
     全な透明、100hは完全な不透明を意味する。‘nil’値をもつこともでき、こ
     れはEmacsにフレームのopacityをセットしない(ウィンドウマネージャーに
     委ねる)よう告げる。

     フレームが完全に見えなくなるのを防ぐために、変数
     ‘frame-alpha-lower-limit’は透明度の最低限度を定義する。フレームパラ
     メーターの値がこの変数の値より小さい場合、Emacsは後者を使用する。デ
     フォルトの‘frame-alpha-lower-limit’は20。

     フレームパラメーター‘alpha’にはコンスセル‘(‘active’ . ‘inactive’)’も
     指定できる。ここで、‘active’は選択時のフレームの透明度、
     ‘inactive’は未選択時の透明度である。

   以下は、特定のフェイスの特定のフェイス属性と自動的に等しくなるので、
凖時代遅れとなったフレームパラメーターです(*note (emacs)Standard
Faces::を参照)。

‘font’
     フレーム内でテキストを表示するためのフォントの名前。これはシステム
     で有効なフォント名、またはEmacsフォントセット名(*note Fontsets::を
     参照)のいずれかであるような文字列である。これは、‘default’フェイス
     の‘font’属性と等価である。

‘foreground-color’
     文字のイメージに使用するカラー。これは、‘default’フェイスの
     ‘:foreground’属性と等価である。

‘background-color’
     文字のバックグラウンドに使用するカラー。これは、‘default’フェイスの
     ‘:background’属性と等価である。

‘mouse-color’
     マウスポインターのカラー。これは‘mouse’フェイスの‘:background’属性
     と等価である。

‘cursor-color’
     ポイントを表示するカーソルのカラー。これは、‘cursor’フェイスの
     ‘:background’属性と等価である。

‘border-color’
     これは、フレームのボーダーのカラーと等価である。これは、‘border’フ
     ェイスの‘:background’属性と等価である。

‘scroll-bar-foreground’
     非‘nil’の場合は、スクロールバーのフォアグラウンドカラー。これは、
     ‘scroll-bar’フェイスの‘:foreground’属性と等価である。

‘scroll-bar-background’
     非‘nil’の場合は、スクロールバーのバックグラウンドカラー。これは、
     ‘scroll-bar’フェイスの‘:background’属性と等価である。


File: elisp,  Node: Size and Position,  Next: Geometry,  Prev: Window Frame Parameters,  Up: Frame Parameters

28.3.4 Frame Size And Position
------------------------------

フレームパラメーター‘left’、‘top’、‘height’、‘width’を使用することにより
、フレームのサイズと位置の読み取りや変更ができます。未指定のジオメトリー
パラメーターは、それが何であれウィンドウマネージャーの通常の方法により選
択されます。

   以下はサイズやポジションの特別な機能にたいして動作します(正確には、こ
れらの関数により使用される“選択されたフレーム”にたいして動作するという意
味。*note Input Focus::を参照のこと)。

 -- Function: set-frame-position frame left top
     この関数は、FRAMEの左上隅をLEFT、TOPにセットする。これらの引数はピ
     クセル単位で、通常はスクリーンの左上隅から測られる。

     負のパラメーター値は、スクリーン下端から上方向にウィンドウ下端、ま
     たはスクリーン右端から左方向にウィンドウ右端の位置である。この値が
     常に左上隅から数えるようにして、負の引数ならフレームの一部をスクリ
     ーン左上隅の外側に配置するようにしたほうがよいのだろうが、今更これ
     を変更するのは賢明と思えない。

 -- Function: frame-height &optional frame
 -- Function: frame-width &optional frame
     これらの関数は、行または列で測ったFRAMEの高さまたは幅をリターンする
     。FRAMEを指定しないと選択されたフレームを使用する。

 -- Function: frame-pixel-height &optional frame
 -- Function: frame-pixel-width &optional frame
     これらの関数は、ピクセルで測ったFRAMEの主要表示領域の高さまたは幅を
     リターンする。FRAMEを指定しないと選択されたフレームを使用する。テキ
     スト端末では、結果はピクセルではなく文字単位となる。

     これらの値には各ウィンドウの内枠ボーダー(internal borders)、スクロ
     ールバー、フリンジ(これらはフレーム自体ではなく個別のウィンドウに属
     す)が含まれる。高さの正確な値は、そのウィンドウシステムと使用するツ
     ールキットに依存する。GTK+では、高さにツールバーやメニューバーは含
     まれない。MotifとLucidのツールキットでは、ツールバーは含まれるが、
     メニューバーは含まれない。ツールキットなしのグラフィカルなバージョ
     ンでは、ツールバーとメニューバーの両方が含まれる。テキスト端末の場
     合は、結果にメニューバーが含まれる。

 -- Function: frame-char-height &optional frame
 -- Function: frame-char-width &optional frame
     これらの関数は、ピクセルで測ったFRAMEの高さまたは幅をリターンする。
     値は選択されたフォントに依存する。FRAMEを指定しないと選択されたフレ
     ームを使用する。

 -- User Option: frame-resize-pixelwise
     このオプションが‘nil’なら、フレームのサイズは、通常はそのフレームの
     ‘frame-char-height’と‘frame-char-width’のカレント値の倍数に丸められ
     る。非‘nil’の場合、丸めは行われずフレームのサイズはピクセル単位で増
     加/減少が可能になる。

     これをセットすることにより、次回のリサイズ処理では、ウィンドウマネ
     ージャーにこれに相当するサイズのヒントを渡す。これは、ユーザーの初
     期ファイル内でのみこの変数をセットすべきで、アプリケーションが一時
     的にこれをバインドすべきではないことを意味する。

     このオプションにたいして‘nil’値がもつ正確な意味は、使用されるツール
     キットに依存する。マウスによるフレームボーダーのドラッグは、通常は
     文字単位で行われる。文字サイズの整数倍ではないフレームサイズを引数
     として‘set-frame-size’(以下参照)を呼び出すと、もしかしたら丸められ
     たり(GTK+)、あるいは受容される(Lucid、Motif、MS-Windows)かもしれな
     い。

     いくつかのウィンドウマネージャーでは、フレームを本当に“最大化”ある
     いは“全画面”で表示させるためには、これを非‘nil’にセットする必要があ
     るかもしれない。

 -- Function: set-frame-size frame width height pixelwise
     この関数は、文字単位でFRAMEのサイズをセットする。WIDTHは列数で新た
     な幅を指定し、HEIGHTは行数で新たな高さを指定する。

     オプション引数PIXELWISEが非‘nil’の場合は、かわりにピクセル単位で新
     たな幅と高さを測ることを意味する。‘frame-resize-pixelwise’が‘nil’の
     場合、それが文字の整数倍でフレームサイズを増加あるいは減少させない
     なら、この要求を完全には尊重せずに拒絶するツールキットがいくつかあ
     ることに注意されたい。

 -- Function: set-frame-height frame height &optional pretend pixelwise
     この関数は、FRAMEを高さHEIGHT行にリサイズする。FRAME内の既存ウィン
     ドウのサイズは、フレームにフィットするよう比例して変更される。

     PRETENDが非‘nil’の場合、EmacsはFRAME内でHEIGHT行の出力を表示するが
     、そのフレームの実際の高さにたいする値は変更しない。これはテキスト
     端末上でのみ有用である。端末が実際に実装するより小さい高さの使用は
     、より小さいスクリーン上での振る舞いの再現したり、スクリーン全体を
     使用時の端末の誤動作を観察するとき有用かもしれない。フレームの高さ
     を“実際”のようにセットするのは、常に機能するとは限らない。なぜなら
     、テキスト端末上でのカーソルを正しく配置するために、正確な実サイズ
     を知る必要があるかもしれないからである。

     オプションの第4引数PIXELWISEが非‘nil’なら、それはFRAMEの高さが
     HEIGHTピクセル高くなることを意味する。‘frame-resize-pixelwise’が
     ‘nil’の場合、それが文字の整数倍でフレームサイズを増加あるいは減少さ
     せないなら、この要求を完全には尊重せずに拒絶するツールキットがいく
     つかあることに注意されたい。

 -- Function: set-frame-width frame width &optional pretend pixelwise
     この関数は、文字単位でFRAMEの幅をセットする。引数PRETENDは、
     ‘set-frame-height’のときと同じ意味をもつ。

     オプションの第4引数PIXELWISEが非‘nil’なら、それはFRAMEの幅が
     HEIGHTピクセル広くなることを意味する。‘frame-resize-pixelwise’が
     ‘nil’の場合、それが文字の整数倍でフレームサイズを増加あるいは減少さ
     せないなら、この要求を完全には尊重せずに拒絶するツールキットがいく
     つかあることに注意されたい。

   ウィンドウ1つだけを表示するフレームの場合は、コマンド
‘fit-frame-to-buffer’を使用してそのフレームをウィンドウのバッファーにフ
ィットさせることができます。

 -- Command: fit-frame-to-buffer &optional frame max-height min-height
          max-width min-width only
     このコマンドは、FRAME内のバッファーのコンテンツを正確に表示するため
     に、FRAMEのサイズを調整する。FRAMEには任意の生きたフレームを指定で
     き、デフォルトは選択されたフレームである。この調整は、FRAMEのルート
     ウィンドウが生きている場合のみ行われる。引数MAX-HEIGHT、
     MIN-HEIGHT、MAX-WIDTH、MIN-WIDTHはFRAMEのルートウィンドウの新たなト
     ータルサイズの境界を指定する。MIN-HEIGHTとMIN-WIDTHのデフォルトは、
     ‘window-min-height’および‘window-min-width’である。

     オプション引数ONLYが‘vertically’の場合、この関数はフレームを垂直方
     向にたいしてだけリサイズするだろう。ONLYが‘horizontally’なら、水平
     方向だけにリサイズする。

   ‘fit-frame-to-buffer’の挙動は、以下にリストに挙げた2つのオプションに
より制御できます。

 -- User Option: fit-frame-to-buffer-margins
     このオプションは、‘fit-frame-to-buffer’によりフィットされるフレーム
     周囲のマージンを指定する。このようなマージンは、たとえばフレームが
     タスクバーとオーバーラップするのを防ぐのに有用かもしれない。

     これは、フィットされるフレームの上下左右にフリーのまま残すピクセル
     数を指定する。デフォルトは‘nil’で、これは上下左右にマージンを使用し
     ないことを意味する。ここで指定した値は、フレームの
     ‘fit-frame-to-buffer-margins’パラメーターが与えられていれば、それに
     オーバーライドされるかもしれない。

 -- User Option: fit-frame-to-buffer-sizes
     このオプションは、‘fit-frame-to-buffer’にたいしてサイズの境界を指定
     する。これは、自身のバッファーにフィットされるすべてのフレームのル
     ートウィンドウの最小/最大の行数および最小/最大の列数のトータルを指
     定する。これらの値のいずれかが非‘nil’なら、‘fit-frame-to-buffer’の
     相当する引数をオーバーライドする。


File: elisp,  Node: Geometry,  Prev: Size and Position,  Up: Frame Parameters

28.3.5 Geometry
---------------

以下は、Xスタイルのウィンドウジオメトリー指定によるアクションのデータを
調べる方法です:

 -- Function: x-parse-geometry geom
     関数‘x-parse-geometry’は、標準的なXウィンドウのジオメトリー文字列を
     、‘make-frame’の引数の一部として使用できるalistに変換する。

     このalistはGEOM内で指定されたパラメーターと、そのパラメーターに指定
     された値を記述する。各要素は‘(PARAMETER . VALUE)’のような形式である
     。可能なPARAMETERの値は‘left’、‘top’、‘width’、‘height’である。

     サイズのパラメーターの値は整数でなければならない。位置のパラメータ
     ー‘left’および‘top’の名前に関しては、かわりに右端または下端の位置を
     示す値もいくつかあるので、完全に正確ではない。位置パラメーターにた
     いして可能なVALUEは前述(*note Position Parameters::を参照)したよう
     な整数、リスト‘(+ POS)’、リスト‘(- POS)’である。

     以下は例である:

          (x-parse-geometry "35x70+0-0")
               ⇒ ((height . 70) (width . 35)
                   (top - 0) (left . 0))


File: elisp,  Node: Terminal Parameters,  Next: Frame Titles,  Prev: Frame Parameters,  Up: Frames

28.4 Terminal Parameters
========================

端末はそれぞれ、関連するパラメーターのリストをもっています。これら“端末
パラメーター(terminal parameters)”は主に、端末ローカル変数を格納するため
の便利な手段ですが、いくつかの端末パラメーターは特別な意味をもっています
。

   このセクションでは、端末のパラメーター値の読み取りや変更を行う関数を
説明します。これらはすべて引数として端末かフレームいずれかを受け入れます
。フレームの場合、それはそのフレームの端末の使用を意味します。引数
‘nil’は、選択されたフレームの端末という意味です。

 -- Function: terminal-parameters &optional terminal
     この関数は、TERMINALnのすべてのパラメーターとその値をリストする
     alistをリターンする。

 -- Function: terminal-parameter terminal parameter
     この関数は、TERMINALのパラメーターPARAMETER(シンボル)の値をリターン
     する。TERMINALがPARAMETERにたいするセッティングをもたない場合、この
     関数は‘nil’をリターンする。

 -- Function: set-terminal-parameter terminal parameter value
     この関数は、TERMINALのパラメーターPARMに指定されたVALUEをセットして
     、そのパラメーターの以前の値をリターンする。

   以下は、特別な意味をもついくつかの端末パラメーターのリストです:

‘background-mode’
     端末のバックグラウンドカラーの区分で、‘light’か‘dark’のいずれか。
‘normal-erase-is-backspace’
     値は1か0で、これはその端末上で‘normal-erase-is-backspace-mode’がオ
     ンまたはオフのいずれに切り替えられたかに依存する。*note (emacs)DEL
     Does Not Delete::を参照のこと。
‘terminal-initted’
     端末の初期化後に、端末固有の初期化関数にセットされる。


File: elisp,  Node: Frame Titles,  Next: Deleting Frames,  Prev: Terminal Parameters,  Up: Frames

28.5 Frame Titles
=================

それぞれのフレームには‘name’というパラメーターがあります。これは、ウィン
ドウシステムが通常フレーム上端に表示するフレームタイトルにたいする、デフ
ォルトとしての役割をもちます。フレームプロパティ‘name’をセットすることに
より、明示的に名前を指定できます。

   通常は名前を明示的に指定せず、Emacsが変数‘frame-title-format’に格納さ
れたテンプレートにもとづき、自動的にフレーム名を計算します。Emacsはフレ
ームが再表示されるたびに、毎回名前を再計算します。

 -- Variable: frame-title-format
     この変数は、フレーム名が明示的に指定されないときに、フレーム名を計
     算する方法を指定する。この変数の値は、実際には‘mode-line-format’の
     ようなモードライン構成(mode line construct)だが、‘%c’および‘%l’の構
     成は無視される。*note Mode Line Data::を参照のこと。

 -- Variable: icon-title-format
     この変数は、フレームタイトルを明示的に指定しないときの、アイコン化
     されたフレームの名前の計算方法を指定する。このタイトルはアイコン自
     体に表示される。

 -- Variable: multiple-frames
     この変数はEmacsにより自動的にセットされる。フレームが2つ以上(ミニバ
     ッファーのみのフレームと不可視のフレームは勘定に入らない)のとき、値
     は‘t’となる。‘frame-title-format’のデフォルト値は、フレームが複数存
     在する場合のみ、フレーム名にバッファー名を入れるために、
     ‘multiple-frames’を使用する。

     この変数の値は、‘frame-title-format’と‘icon-title-format’の処理中を
     除き、正確である保証はない。


File: elisp,  Node: Deleting Frames,  Next: Finding All Frames,  Prev: Frame Titles,  Up: Frames

28.6 Deleting Frames
====================

“生きたフレーム(live frame)”とは、削除されていないフレームのことです。フ
レームが削除される際は、たとえそれへの参照元がなくなるまでLispオブジェク
トとして存在し続けるとしても、端末ディスプレイからは削除されます。

 -- Command: delete-frame &optional frame force
     この関数は、フレームFRAMEを削除する。FRAMEがツールチップでなければ
     、まずフック‘delete-frame-functions’を実行する(フックの各関数は唯一
     の引数としてFRAMEを受け取る)。デフォルトでは、FRAMEは選択されたフレ
     ームである。

     ミニバッファーが別のフレームに使用されているフレームは削除できない
     。通常、他のフレームすべてが不可視の場合、フレームは削除できないが
     、FORCEが非‘nil’なら、削除が可能になる。

 -- Function: frame-live-p frame
     関数‘frame-live-p’は、フレームFRAMEが削除されていなければ、非
     ‘nil’をリターンする。リターンされ得る非‘nil’の値は、‘framep’と同様
     である。*note Frames::を参照のこと。

   いくつかのウィンドウマネージャーは、ウィンドウを削除するコマンドを提
供します。これらは、そのウィンドウを操作するプログラムに特別なメッセージ
を送ることにより機能します。Emacsがそれらメッセージのいずれかを受け取っ
たときは、‘delete-frame’イベントを生成します。このイベントの通常の定義は
、関数‘delete-frame’を呼び出すコマンドです。*note Misc Events::を参照し
てください。


File: elisp,  Node: Finding All Frames,  Next: Minibuffers and Frames,  Prev: Deleting Frames,  Up: Frames

28.7 Finding All Frames
=======================

 -- Function: frame-list
     この関数は、すべての生きたフレーム(削除されていないフレーム)のリス
     トをリターンする。これはバッファーにたいする‘buffer-list’に類似して
     おり、すべての端末上のフレームが含まれる。リターンされるリストは新
     たに作成されたものであり、このリストを変更してもEmacs内部への影響は
     ない。

 -- Function: visible-frame-list
     この関数はカレントで可視なフレームだけのリストをリターンする。*Note
     Visibility of Frames::を参照のこと。テキスト端末上のフレームは、実
     際に表示されるのが選択されたフレームだけだとしても、常に“可視”であ
     るとみなされる。

 -- Function: next-frame &optional frame minibuf
     この関数は、カレントディスプレイ上そすべてのフレームを、任意のフレ
     ームを開始点としいぇ巡回するのに便利である。これは、そのその巡回サ
     イクル上でFRAMEの“次”に該当するフレームをリターンする。FRAMEが省略
     または‘nil’の場合のデフォルトは、選択されたフレーム(*note Input
     Focus::を参照)である。

     2つ目の引数MINIBUFは、どのフレームを考慮するかを示す:

     ‘nil’
          ミニバッファーのみのフレームを除外。
     ‘visible’
          すべての可視フレームを考慮する。
     0
          すべての可視およびアイコン化されたフレームを考慮する。
     ウィンドウ
          特定のウィンドウをミニバッファーとして使用するフレームだけを考
          慮する。
     その他
          すべてのフレームを考慮する。

 -- Function: previous-frame &optional frame minibuf
     ‘next-frame’と同様だが、すべてのフレームを逆方向に巡回する。

   *note Cyclic Window Ordering::の‘next-window’と‘previous-window’も参
照してください。


File: elisp,  Node: Minibuffers and Frames,  Next: Input Focus,  Prev: Finding All Frames,  Up: Frames

28.8 Minibuffers and Frames
===========================

通常は、それぞれのフレームは下端に自身のミニバッファーウィンドウをもち、
そのフレームが選択された際は常にそれを使用します。フレームにミニバッファ
ーがある場合は、‘minibuffer-window’でそれを取得できます(*note Definition
of minibuffer-window::を参照)。

   しかし、ミニバッファーのないフレームの作成も可能です。そのようなフレ
ームは、別のフレームのミニバッファーウィンドウを使用しなければなりません
。フレーム作成時に、(別フレーム上にある)使用するミニバッファーを明示的に
指定できます。これを行わない場合は、変数‘default-minibuffer-frame’の値の
フレーム内でミニバッファーを探します。この値は、ミニバッファーをもつフレ
ームにしてください。

   ミニバッファーのみのフレームを使用する場合は、ミニバッファーにエンタ
ー時にそのフレームを前面に移動(raise)したいと思うかもしれません。その場
合は、変数‘minibuffer-auto-raise’に‘t’をセットします。*note Raising and
Lowering::を参照してください。

 -- Variable: default-minibuffer-frame
     この変数は、デフォルトでミニバッファーウィンドウとして使用するフレ
     ームを指定する。これは、既存のフレームには影響しない。これはカレン
     ト端末にたいして常にローカルで、バッファーローカルにはできない。
     *note Multiple Terminals::を参照のこと。


File: elisp,  Node: Input Focus,  Next: Visibility of Frames,  Prev: Minibuffers and Frames,  Up: Frames

28.9 Input Focus
================

どんなときでも、Emacs内のただ1つのフレームが“選択されたフレーム(selected
frame)”です。選択されたウィンドウは、常に選択されたフレーム上にあります
。

   Emacsがフレームを複数端末(*note Multiple Terminals::を参照)上に表示す
る際、各端末は自身の選択されたフレームをもちます。しかし、それらのうち
1つだけが、“_いわゆる_選択されたフレーム”であり、それはもっとも最近に入
力があった端末に属すフレームです。つまり、特定の端末からのコマンドを
Emacsが実行する際は、その端末上の1つが選択されたフレームです。Emacsが実
行するコマンドは常に1つだけなので、選択されたフレームは常に1つだけだと考
える必要があります。このフレームこそ、このマニュアルで“選択されたフレー
ム”と呼ぶフレームです。選択されたフレームを表示するディスプレイは、“選択
されたフレームのディスプレイ(selected frame’s display)”です。

 -- Function: selected-frame
     この関数は選択されたフレームをリターンする。

   いくつかのウィンドウシステムおよびウィンドウマネージャーは、マウスが
あるウィンドウオブジェクトにキーボード入力をダイレクトします。それ以外は
、さまざまなウィンドウオブジェクトに“フォーカスをシフト(shift the
focus)”するために、明示的なクリックやコマンドを要求します。どちらの方法
でも、Emacsはフォーカスをもつフレームを自動的に追跡します。Lisp関数から
別フレームに明示的に切り替えるためには、‘select-frame-set-input-focus’を
呼び出します。

   関数‘select-frame’を呼び出すことにより、Lispプログラムが“一時的”にフ
レームを切り替えることもできます。これは、そのウィンドウシステムのフォー
カス概念を変更はしません。変更ではなく、何らかの方法により制御が再確認
(reasserted)されるまで、ウィンドウマネージャーの制御から抜け出す
(escape)のです。

   テキスト端末使用時は、その端末上で一度に表示できるフレームは1つだけな
ので、‘select-frame’呼び出し後、次回の再表示で新たに選択されたフレームが
実際に表示されます。このフレームは、次の‘select-frame’呼び出しまで、選択
されたままです。テキスト端末上の各フレームは、バッファー名の前に表示され
る番号をもちます(*note Mode Line Variables::を参照)。

 -- Function: select-frame-set-input-focus frame &optional norecord
     この関数は、FRAMEを選択、(他のフレームのせいで不明瞭な場合には)それ
     を前面に移動(raise)して、Xサーバーのフォーカス授与を試みる。テキス
     ト端末上では、次回再表示時に端末スクリーン全体に新たにフレームが表
     示される。オプション引数NORECORDは、‘select-frame’(下記参照)のとき
     と同じ意味をもつ。この関数のリターン値に意味はない。

 -- Command: select-frame frame &optional norecord
     この関数は、フレームFRAMEを選択し、Xサーバーのフォーカスがあればそ
     れを一時的に無視する。FRAMEにたいする選択は、次回ユーザーが別フレー
     ムに何かを行うか、この関数の次回呼び出しまで継続する(ウィンドウシス
     テムを使用する場合は、以前に選択されていたフレームに依然としてウィ
     ンドウシステムの入力フォーカスがあるかもしれないので、コマンドルー
     プからリターン後に、そのフレームが選択されたフレームとしてリストア
     されるかもしれない)。

     指定されたFRAMEは選択されたフレームとなり、その端末が選択された端末
     になる。その後、この関数はFRAME内で選択されていたウィンドウを第1引
     数、NORECORDを第2引数でサブルーチンとして‘select-window’を呼び出す
     (したがって、NORECORDが非‘nil’なら、もっとも最近に選択されたウィン
     ドウおよびバッファーリストの変更を避ける)。*note Selecting
     Windows::を参照のこと。

     この関数はFRAME、またはFRAMEが削除されていれば‘nil’をリターンする。

     一般的には、実行後に端末を戻すよう切り替えることなく、別の端末に切
     り替えるのが可能な手段として‘select-frame’を決して使用すべきではな
     い。

   Emacsは、サーバーおよびウィンドウマネージャーのリクエストとしてフレー
ム選択をアレンジすることにより、ウィンドウシステムと協調します。これは、
適切なときに“フォーカス(focus)”と呼ばれる特殊な入力イベントを生成するこ
とにより行われます。コマンドループは、‘handle-switch-frame’を呼び出して
フォーカスイベントを処理します。*note Focus Events::を参照してください。

 -- Command: handle-switch-frame frame
     この関数は、フレームFRAME選択によりフォーカスイベントを処理する。

     フォーカスイベントは通常、このコマンドを呼び出すことにより、その処
     理を行う。他の理由でこれを呼び出しではならない。

 -- Function: redirect-frame-focus frame &optional focus-frame
     この関数は、FRAMEからFOCUS-FRAMEにフォーカスをリダイレクトする。こ
     れは、FRAMEにかわってFOCUS-FRAMEが以降のキーストロークとイベントを
     受け取るであろうことを意味する。そのようなイベント後は、
     ‘last-event-frame’の値はFOCUS-FRAMEになるだろう。また、FRAMEを指定
     したswitch-frameイベントも、かわりに FOCUS-FRAMEを選択するだろう。

     FOCUS-FRAMEが省略または‘nil’の場合は、FRAMEにたいするすべての既存の
     リダイレクションがキャンセルされ、したがってFRAMEが自身のイベントを
     再度受け取ることになる。

     フォーカスリダイレクトの用途の1つは、ミニバッファーをもたないフレー
     ムにたいしてである。これらのフレームは、別フレーム上のミニバッファ
     ーを使用する。別フレーム上のミニバッファーをアクティブにすることは
     、そのフレームにフォーカスをリダイレクトすることである。これは、た
     とえマウスがミニバッファーをアクティブにしたフレーム内に留まってい
     ても、ミニバッファーが属すフレームにフォーカスを置く。

     フレーム選択は、フォーカスリダイレクションの変更も可能にする。
     ‘foo’が選択されているときにフレーム‘bar’を選択することにより、
     ‘foo’を指すすべてのリダイレクションは、かわりに‘bar’を指す。これは
     、ユーザーが‘select-window’を使用してあるフレームから別のフレームに
     切り替えた際に、フォーカスのリダイレクトが正しく機能することを可能
     にする。

     これは、フォーカスが自身にリダイレクトされたフレームが、フォーカス
     がリダイレクトされていないフレームとは異なう扱いを受けることを意味
     する。前者にたいして‘select-frame’は影響するが、後者には影響がない
     。

     このリダイレクションは、それを変更するために
     ‘redirect-frame-focus’が呼び出されるまで継続する。

 -- Variable: focus-in-hook
     これは、Emacsフレームが入力フォーカスを得た際に実行されるノーマルフ
     ックである。

 -- Variable: focus-out-hook
     これは、Emacsフレームが入力フォーカスを失った際に実行されるノーマル
     フックである。

 -- User Option: focus-follows-mouse
     これは、ユーザーがマウスを移動した際に、ウィンドウマネージャーがフ
     ォーカスを転送するかどうかをEmacsに告げるためのオプションである。非
     ‘nil’なら、フォーカスは転送される。その場合、コマンド
     ‘other-frame’は新たに選択されたフレームと一貫性のある位置にマウスを
     移動する。


File: elisp,  Node: Visibility of Frames,  Next: Raising and Lowering,  Prev: Input Focus,  Up: Frames

28.10 Visibility of Frames
==========================

グラフィカルなディスプレイ上のフレームは“可視(visible)”、“不可視
(invisible)”、または“アイコン化(iconified)”されているかもしれません。可
視なら、そのコンテンツは通常の方法により表示されます。アイコン化されてい
る場合、そのコンテンツは表示されませんが、ビュー内にフレームを戻すための
小さいアイコンがどこかにあります(いくつかのウィンドウマネージャーは、こ
の状態を“アイコン化”ではなく“最小化”と呼ぶが、Emacsの見地ではこれらは同
等である)。フレームが不可視なら、それはまったく表示されません。

   テキスト端末では、いつでも実際に表示されるのはただ1つの選択されたフレ
ームだけなので、可視性に意味はありません。

 -- Function: frame-visible-p frame
     この関数は、フレームFRAMEの可視性の状態をリターンする。値は、
     FRAMEが可視なら‘t’、不可視なら‘nil’、アイコン化されている場合は
     ‘icon’になる。

     テキスト端末上では、たとえ1つのフレームだけが表示されているとしても
     、この関数の目的にたいしては、すべてのフレームが“可視”とみなされる
     。*note Raising and Lowering::を参照のこと。

 -- Command: iconify-frame &optional frame
     この関数は、フレームFRAMEをアイコン化する。FRAMEを省略した場合は、
     選択されたフレームをアイコン化する。

 -- Command: make-frame-visible &optional frame
     この関数は、フレームFRAMEを可視にする。FRAMEを省略した場合は、選択
     されたフレームを可視にする。これはフレームを前面に移動しないが、望
     むなら‘raise-frame’でそれを行うことができる(*note Raising and
     Lowering::を参照)。

 -- Command: make-frame-invisible &optional frame force
     この関数は、フレームFRAMEを不可視にする。FRAMEを省略した場合は、選
     択されたフレームを不可視にする。

     FORCEが‘nil’なら、この関数は他のすべてのフレームが不可視の場合は、
     FRAMEを不可視にするのを拒絶する。

   フレームの可視性の状態は、フレームパラメーターとしても利用可能である
。つまりフレームパラメーターとして読み取りと変更ができる。*note
Management Parameters::を参照のこと。ウィンドウマネージャーによりユーザ
ーがフレームのアイコン化や非アイコン化を行うこともできる。これは、
Emacsが何らかの制御を及ぼすのが可能なレベルより下のレベルにおいて発生す
るが、Emacsはそのような変化を追跡するために使用するイベントを提供する。
*note Misc Events::を参照のこと。


File: elisp,  Node: Raising and Lowering,  Next: Frame Configurations,  Prev: Visibility of Frames,  Up: Frames

28.11 Raising and Lowering Frames
=================================

ほとんどのウィンドウシステムは、デスクトップというメタファー(metaphor: 比
喩的概念)を使用します。このメタファーの一部は、システムレベルのウィンド
ウ(Emacsではフレーム)が、スクリーン表面に向かって、概念的3次元の垂直方向
に積まれていくというアイデアです。2つが重なる箇所では、より高い一方が、
より低い一方を覆い隠します。関数‘raise-frame’および‘lower-frame’を使用し
て、フレームを“前面に移動(raise: より高い位置へ上げる)”したり“背面に移動
(lower: より低い位置へ移動)”したりすることができます。

 -- Command: raise-frame &optional frame
     この関数は、フレームFRAME(デフォルトは選択されたフレーム)を前面に移
     動する。FRAMEが不可視もしくはアイコン化されている場合は、それを可視
     にする。

 -- Command: lower-frame &optional frame
     この関数は、フレームFRAME(デフォルトは選択されたフレーム)を背面に移
     動する。

 -- User Option: minibuffer-auto-raise
     これが非‘nil’なら、ミニバッファーをアクティブにすることにより、ミニ
     バッファーウィンドウのあるフレームが前面に移動される。

   ウィンドウシステム上では、フレームパラメーターを使用して、(フレーム選
択時に)auto-raising、(フレーム選択解除時に)auto-loweringを有効にできます
。*note Management Parameters::を参照してください。

   フレームを前面または背面に移動するという概念は、テキスト端末のフレー
ムにも適用できます。各テキスト端末上で、一度に表示されるのは、常に最前面
のフレームだけです。

 -- Function: tty-top-frame terminal
     この関数は、TERMINAL上の最前面のフレームをリターンする。TERMINALは
     端末オブジェクト、フレーム(そのフレームの端末を意味する)、または
     ‘nil’(選択されたフレームの端末を意味する)であること。これがテキスト
     端末を参照しなければ、リターン値は‘nil’となる。


File: elisp,  Node: Frame Configurations,  Next: Mouse Tracking,  Prev: Raising and Lowering,  Up: Frames

28.12 Frame Configurations
==========================

“フレーム構成(frame configuration)”はフレームのカレント配置、すべてのプ
ロパティ、および各ウィンドウのウィンドウ構成(*note Window
Configurations::を参照)を記録します。

 -- Function: current-frame-configuration
     この関数は、フレームのカレント配置およびそのコンテンツを記述するフ
     レーム構成のリストをリターンする。

 -- Function: set-frame-configuration configuration &optional nodelete
     この関数は、フレームの状態をCONFIGURATIONの記述にリストアする。しか
     し、この関数は削除されたフレームはリストアしない。

     通常、この関数はCONFIGURATION内にリストされない既存フレームすべてを
     削除する。しかしNODELETEが非‘nil’なら、希望しないそれらフレームはか
     わりにアイコン化される。


File: elisp,  Node: Mouse Tracking,  Next: Mouse Position,  Prev: Frame Configurations,  Up: Frames

28.13 Mouse Tracking
====================

マウスを“トラック(track: 追跡)”するのが有用なことが時折あります。マウス
のトラックとは、マウスの位置を示す何かを表示して、マウス移動とともにその
インジケーターを移動する、という意味です。効果的にマウスをトラックするた
めには、マウスが実際に移動するまで待機する手段が必要になります。

   マウスをトラックする便利なのは、マウスのモーション(motion: 移動)を表
すイベントを問い合わせる方法です。その後は、そのイベントを待機することに
より、モーションを待機できます。加えて、発生し得る他の類のイベントも、簡
単に処理できます。ボタンのリリースのような何か他のイベントだけを待機して
マウスを永久にトラックするは通常は望ましくないので、これは有用です。

 -- Special Form: track-mouse body...
     このスペシャルフォームは、マウスモーションイベントの生成を有効にし
     て、BODYを実行する。通常、BODYはモーションイベントを読み取るために
     ‘read-event’を使用し、それに対応して表示を変更する。マウスモーショ
     ンイベントのフォーマットについては、*note Motion Events::を参照のこ
     と。

     ‘track-mouse’の値は、BODY内の最後のフォームの値である。ボタンのリリ
     ースを示すup-event、またはトラックを止めるべきタイミングを意味する
     類のイベントを確認した際にはリターンするよう、BODYをデザインするべ
     きである。

   マウスモーションをトラックする通常の目的は、それ以降に発生するボタン
のプッシュやリリースをカレント位置に示すことです。

   多くの場合は、テキストプロパティ‘mouse-face’(*note Special
Properties::を参照)を使用することにより、マウスをトラックする必要性を回
避できます。これは、より低レベルで機能し、かつLispレベルのマウストラッキ
ングよりスムーズに実行されます。


File: elisp,  Node: Mouse Position,  Next: Pop-Up Menus,  Prev: Mouse Tracking,  Up: Frames

28.14 Mouse Position
====================

関数‘mouse-position’および‘set-mouse-position’は、マウスのカレント位置に
たいするアクセスを提供します。

 -- Function: mouse-position
     この関数は、マウス位置の記述をリターンする。値は‘(FRAME X . Y)’のよ
     うな形式で、XとYはFRAME内部の左上隅から相対的な位置を文字単位で与え
     る整数である。

 -- Variable: mouse-position-function
     非‘nil’なら、この変数の値は‘mouse-position’にたいして呼び出される関
     数である。‘mouse-position’はリターン直前には、自身の通常のリターン
     値を唯一の引数としてこの関数を呼び出し、それが何であれその関数がリ
     ターンしたものをリターンする。

     このアブノーマルフックは、‘xt-mouse.el’のようにLispレベルでマウス処
     理を行う必要があるパッケージのために存在する。

 -- Function: set-mouse-position frame x y
     この関数は、フレームFRAME内の位置X、Yに“マウスをワープ”させる。引数
     XとYは、FRAME内部の左上隅から相対的な位置を文字単位で与える整数であ
     る。FRAMEが不可視なら、この関数は何も行わない。リターン値に意味はな
     い。

 -- Function: mouse-pixel-position
     この関数は‘mouse-position’と似ているが、文字単位ではなくピクセル単
     位の座標をリターンする。

 -- Function: set-mouse-pixel-position frame x y
     この関数は‘set-mouse-position’のようにマウスをワープするが、XとYが
     文字単位ではなくピクセル単位であることを除く。これらの座標が、その
     フレーム内にあることは要求されない。

     FRAMEが不可視なら、この関数は何も行わない。リターン値に意味はない。

 -- Function: frame-pointer-visible-p &optional frame
     この述語関数は、FRAME上に表示されたマウスポインターが可視なら非
     ‘nil’、それ以外は‘nil’をリターンする。FRAMEが省略または‘nil’なら、
     それは選択されたフレームを意味する。これは、
     ‘make-pointer-invisible’が‘t’にセットされているとき有用である。これ
     により、ポインターが隠されていることを知ることができる。*note
     (emacs)Mouse Avoidance::を参照のこと。


File: elisp,  Node: Pop-Up Menus,  Next: Dialog Boxes,  Prev: Mouse Position,  Up: Frames

28.15 Pop-Up Menus
==================

Lispプログラムはポップアップメニューを表示できるので、ユーザーはマウスで
候補を選択できます。テキスト端末上では、マウスが利用不可なら、キーボード
のモーションキー‘C-n’、‘C-p’、上矢印キー、下矢印キーで候補を選択できます
。

 -- Function: x-popup-menu position menu
     この関数は、ポップアップメニューを表示して、ユーザーが何を選択した
     かの指標をリターンする。

     引数POSITIONは、メニュー左上隅をスクリーン上どこに置くか指定する。
     これはマウスボタンイベント(ユーザーがボタンを操作した位置にメニュー
     を置くよう告げる)、または以下の形式のリストのいずれかである:

          ((XOFFSET YOFFSET) WINDOW)

     ここで、XOFFSETとYOFFSETはWINDOW左上隅からピクセル単位で測られた座
     標である。WINDOWはウィンドウ、またはフレームかもしれない。

     POSITIONが‘t’の場合、それはマウスのカレント位置の使用を意味する(テ
     キスト端末上でマウスが利用不可ならフレーム左上隅)。POSITIONが
     ‘nil’なら、それは実際にメニューをポップアップせずに、MENU内で指定さ
     れたキーマップと等価なキーバインディングを事前に計算することを意味
     する。

     引数MENUは、メニュー内で何を表示するかを告げる。これはキーマップま
     たはキーマップのリストを指定できる(*note Menu Keymaps::を参照)。こ
     の場合、リターン値はユーザー選択に対応するイベントのリストである。
     選択がサブメニュー内で発生した場合、このリストには複数の要素がある
     (‘x-popup-menu’はそのイベントシーケンスにバインドされたコマンドを実
     際には実行しないことに注意)。テキスト端末、およびメニュータイトルを
     サポートするツールキットでは、MENUがキーマップならタイトルはMENUの
     プロンプト文字列、MENUがキーマップのリストなら最初のキーマップのプ
     ロンプト文字列から取得される(*note Defining Menus::を参照)。

     かわりに、MENUは以下の形式をもつこともできる:

          (TITLE PANE1 PANE2...)

     ここで、それぞれのpaneは以下の形式のリストである

          (TITLE ITEM1 ITEM2...)

     それぞれITEMは、コンスセル‘(LINE . VALUE)’であること。ここでLINEは
     文字列、VALUEはLINEが選択された場合にリターンされる値である。メニュ
     ーキーマップと異なり、‘nil’のVALUEは選択不可のメニューアイテムを作
     成しない。かわりに、それぞれのITEMにコンスセルではなく文字列を指定
     できる。これは選択不可のメニューアイテムを作成する。

     たとえば有効な選択からマウスを外してクリックしたり、‘C-g’をタイプす
     ることにより、有効な選択を行うことなくユーザーがメニューを取り除い
     た場合は、通常はquitして‘x-popup-menu’はリターンしない。しかし、
     POSITIONがマウスボタンイベント(ユーザーがマウスでメニューを呼び出し
     たことを示す)なら、quitは起こらず‘x-popup-menu’はリターンする。

   *使用上の注意: *メニューキーマップで定義したプレフィクスキー処理を行
えるなら、メニューの表示に‘x-popup-menu’を使用しないでください。メニュー
の実装にメニューキーマップを使用する場合は、‘C-h c’および‘C-h a’でメニュ
ー内の個別アイテムの確認、およびそれらにたいするヘルプを提供できます。か
わりに‘x-popup-menu’を呼び出すコマンドを定義することによりメニューを実装
した場合、ヘルプ機能はそのコマンド内部で何が起こっているか知ることができ
ず、そのメニューアイテムのヘルプを何も与えられません。

   マウス移動によりサブメニュー間を切り替えるメニューバーのメカニズムは
、それが‘x-popup-menu’を呼び出すか確認するために、コマンドの定義を見るこ
とができません。したがって、‘x-popup-menu’を使用してサブメニューの実装を
試みた場合、それは統合された方式でメニューバーとともに機能しません。メニ
ューバーのすべてのサブメニューは、親メニューのメニューキーマップにより実
装され、決して‘x-popup-menu’で実装されないのは、これが理由です。*note
Menu Bar::を参照してください。

   メニューバーのサブメニューのコンテンツを変化させたい場合にも、その実
装には依然としてメニューキーマップを使用するべきです。コンテンツを変化さ
せるためには、必要に応じてメニューキーマップのコンテンツを更新するために
、フック関数を‘menu-bar-update-hook’に追加してください。


File: elisp,  Node: Dialog Boxes,  Next: Pointer Shape,  Prev: Pop-Up Menus,  Up: Frames

28.16 Dialog Boxes
==================

ダイアログボックスとはポップアップメニューの一種です。外見は多少異なり、
常にフレーム中央に表示され、階層を1つしかもたず1つ以上のボタンがあります
。ユーザーが“yes”、“no”、および別の少数の候補で応答ができる質問を尋ねる
のが、ダイアログボックスの主な用途です。単一のボタンでは、ユーザーに重要
な情報の確認を強いることもできます。関数‘y-or-n-p’および‘yes-or-no-p’は
、マウスのクリックにより呼び出されたコマンドから呼び出された際は、キーボ
ードのかわりにダイアログボックスを使用します。

 -- Function: x-popup-dialog position contents &optional header
     この関数は、ポップアップダイアログボックスを表示して、ユーザーが何
     を選択したかの指標をリターンする。引数CONTENTSは、提供するための候
     補を指定する。これは、以下のフォーマットをもつ:

          (TITLE (STRING . VALUE)...)

     これは、‘x-popup-menu’にたいして単一paneを指定するリストのように見
     える。

     リターン値は、選択された候補のVALUEである。

     ‘x-popup-menu’の場合と同様、このリストの要素はコンスセル‘(STRING .
     VALUE)’のかわりに、単なる文字列かもしれない。これは、選択不可のボッ
     クスを作成する。

     このリスト内に‘nil’がある場合、それは左手側と右手側のアイテムを分け
     る。つまり、‘nil’より前のアイテムは左、‘nil’より後のアイテムは右に
     表示される。リスト内に‘nil’を含めない場合は、およそ半数づつが両サイ
     ドに表示される。

     ダイアログボックスは、常にフレームの中央に表示される。引数
     POSITIONは、どのフレームかを指定する。可能な値は‘x-popup-menu’の場
     合と同様だが、正確な座標や個別のウィンドウは問題ではなく、フレーム
     だけが問題となる。

     HEADERが非‘nil’ならボックスのフレームタイトルは‘Information’、それ
     以外は‘Question’になる。前者は‘message-box’(*note message-box::を参
     照)にたいして使用される(テキスト端末上ではボックスタイトルは表示さ
     れない)。

     いくつかの構成では、Emacsは本当のダイアログボックスを表示できないの
     で、かわりにフレーム中央のポップアップメニュー内に同じアイテムを表
     示する。

     たとえばウィンドウマネージャーを使用して、有効な選択を行うことなく
     ユーザーがダイアログボックスを取り除いた場合は、通常はquitして
     ‘x-popup-dialog’はリターンしない。


File: elisp,  Node: Pointer Shape,  Next: Window System Selections,  Prev: Dialog Boxes,  Up: Frames

28.17 Pointer Shape
===================

テキストプロパティ‘pointer’や、イメージならイメージプロパティ
‘:pointer’および‘:map’を使用して、特定のテキストやイメージにたいしてマウ
スポインターのスタイルを指定できます。これらのプロパティに使用できる値は
‘text’(または‘nil’)、‘arrow’、‘hand’、‘vdrag’、‘hdrag’、‘modeline’、
‘hourglass’です。‘text’は、テキスト上で使用される、通常のマウスポインタ
ースタイルを意味します。

   ウィンドウの空部分(void parts: バッファーコンテンツのどの部分にも対応
しない部分)の上では、マウスポインターは通常‘arrow’スタイルを使用しますが
、‘void-text-area-pointer’をセットすることにより、異なるスタイルを指定で
きます。

 -- User Option: void-text-area-pointer
     この変数は、空テキストエリアにたいするマウスポインタースタイルを指
     定する。このエリアには、行末の後や、バッファー終端行の下が含まれる
     。デフォルトでは、‘arrow’(non-text)ポインタースタイルを使用。

   Xを使用する際は、変数‘x-pointer-shape’をセットすることにより、
‘text’の本当の外見を指定できます。

 -- Variable: x-pointer-shape
     この変数は、Emacsフレーム内で‘text’ポインタースタイルに通常使用する
     ポインターシェイプを指定する。

 -- Variable: x-sensitive-text-pointer-shape
     この変数は、マウスがマウスセンシティブテキスト上にあるときのポイン
     ターシェイプを指定する。

   これらの変数は、新たに作成されるフレームに影響します。通常これらは既
存のフレームに効果はありませんが、フレームのマウスカラーのインストール時
には、これら2つ変数のカレント値もインストールされます。*note Font and
Color Parameters::を参照してください。

   これらのポインターシェイプのいずれかを指定するために使用可能な値は、
ファイル‘lisp/term/x-win.el’内で定義されています。それらのリストを確認す
るには、‘M-x apropos <RET> x-pointer <RET>’を使用してください。


File: elisp,  Node: Window System Selections,  Next: Drag and Drop,  Prev: Pointer Shape,  Up: Frames

28.18 Window System Selections
==============================

Xウィンドウシステムでは、異なるアプリケーション間のデータ転送は、“選択
(selections)”により行われます。Xは任意の数の“選択タイプ(selection
types)”を定義し、それぞれが独自にデータを格納できます。しかし、一般的に
使用されるのは“クリップボード(clipboard)”、“プライマリー選択(primary
selection)”、“セカンダリー選択(secondary selection)”の3つだけです。これ
ら3つの選択を使用するEmacsコマンドについては、*note Cut and Paste:
(emacs)Cut and Paste.を参照してください。このセクションでは、X選択の読み
取りとセットを行う、低レベル関数について説明します。

 -- Command: x-set-selection type data
     この関数は、X選択をセットする。これは、選択タイプTYPEと、それに割り
     当てる値DATAの、2つの引数をとる。

     TYPEはシンボルであること。通常は‘PRIMARY’、‘SECONDARY’、
     ‘CLIPBOARD’のいずれかである。これらは、Xウィンドウシステムの慣例に
     対応する大文字のシンボル名である。TYPEが‘nil’なら、それは
     ‘PRIMARY’を意味する。

     DATAが‘nil’なら、それはその選択をクリアーすることを意味する。それ以
     外では、DATAは文字列、シンボル、整数(2つの整数からなるコンスかリス
     ト)、オーバーレイ、同じバッファーを指す2つのマーカーのコンスを指定
     できる。オーバーレイとマーカーのペアは、そのオーバーレイまたはマー
     カー間のテキストを意味する。引数DATAには、非ベクターの選択の値のベ
     クターも指定できる。

     この関数はDATAをリターンする。

 -- Function: x-get-selection &optional type data-type
     この関数は、Emacsおよび別のXクライアントによりセットアップされた選
     択にアクセスする。これはTYPEとDATA-TYPEの、2つの引数をとる。TYPEは
     選択のタイプで、デフォルトは‘PRIMARY’。

     DATA-TYPE引数は、別のXクライアントから取得したrawデータをLispデータ
     に変換するための、データ変換に使用する形式を指定する。意味のある値
     には‘TEXT’、‘STRING’、‘UTF8_STRING’、‘TARGETS’、‘LENGTH’、
     ‘DELETE’、‘FILE_NAME’、‘CHARACTER_POSITION’、‘NAME’、
     ‘LINE_NUMBER’、‘COLUMN_NUMBER’、‘OWNER_OS’、‘HOST_NAME’、‘USER’、
     ‘CLASS’、‘ATOM’、‘INTEGER’が含まれる(これらは、対応するX慣習の大文
     字シンボル名である)。DATA-TYPEのデフォルトは‘STRING’。

 -- User Option: selection-coding-system
     この変数は、選択やクリップボードに読み書きする際のコーディングシス
     テムを指定する。*note Coding Systems::を参照してください。デフォル
     トは‘compound-text-with-extensions’で、これはX11が通常使用するテキ
     スト表現に変換する。

   EmacsがMS-Windows上で実行されている際は、一般的にX選択はサポートしま
せんが、クリップボードはサポートします。MS-Windowsでは、
‘x-get-selection’および‘x-set-selection’は、テキストデータタイプだけをサ
ポートします。クリップボードが他のタイプのデータを保持している場合、
Emacsはクリップボードを空として扱います。


File: elisp,  Node: Drag and Drop,  Next: Color Names,  Prev: Window System Selections,  Up: Frames

28.19 Drag and Drop
===================

ユーザーが別のアプリケーションからEmacsに何かをドラッグをした際、その別
アプリケーションはEmacsがドラッグされたデータを処理可能か告げることを期
待します。変数‘x-dnd-test-function’は、何を応答するか決定するために、
Emacsにより使用されます。デフォルト値は‘x-dnd-default-test-function’で、
これはドロップされたデータのタイプが‘x-dnd-known-types’内にあれば、ドロ
ップを受け入れます。何か別の条件にもとづいてEmacsにドロップを許容または
拒絶させたい場合は、‘x-dnd-test-function’および/または
‘x-dnd-known-types’をカスタマイズできます。

   Emacsが異なるタイプのドロップを処理する方法を変更したり、新たなタイプ
を追加したい場合は、‘x-dnd-types-alist’をカスタマイズします。これには、
他のアプリケーションがドラッグアンドドロップに使用するのが何のタイプなの
か、詳細な知識が要求されます。

   EmacsにURLがドロップされたとき、それはファイルかもしれませんが、他の
URLタイプ(ftp、http、...)であるかもしれません。Emacsはまず、そのURLに何
を行うべきか判断するために、‘dnd-protocol-alist’をチェックします。それに
マッチがなく、かつ‘browse-url-browser-function’がalistなら、Emacsはそこ
でマッチを探します。それでもマッチが見つからなければ、そのURLにたいする
テキストを挿入します。これらの変数をカスタマイズすれば、Emacsの挙動を変
更できます。


File: elisp,  Node: Color Names,  Next: Text Terminal Colors,  Prev: Drag and Drop,  Up: Frames

28.20 Color Names
=================

カラー名(color name)とは、カラーを指定するテキスト(通常は文字列)です。
‘black’、‘white’、‘red’等が指定できます。定義された名前のリストは、‘M-x
list-colors-display’を使用して確認できます。‘#RGB’や‘RGB:R/G/B’のような
、数値的な形式でカラーを指定することもできます。ここで、Rは赤(red)、Gは
緑(green)、Bは青(blue)のレベルを指定します。1桁、2桁、3桁、または4桁の
16進数をRに使用できます。その後、GとBには同じ桁数の16進数を同様に使用し
なければなりません。これにより、総桁数が3､6､9､または12桁の16進数となりま
す(カラーの数値的なRGB指定についての詳細は、Xウィンドウシステムのドキュ
メントを参照されたい)。

   以下の関数は、有効なカラー名と、それらの外見を判断する手段を提供しま
す。以下で説明するように、その値は“選択されたフレーム(selected frame)”に
依存する場合があります。“選択されたフレーム”という用語の意味については、
*note Input Focus::を参照してください。

   補完付きでカラー名のユーザー入力を読み取るには、‘read-color’を使用し
ます(*note read-color: High-Level Completion.を参照)。

 -- Function: color-defined-p color &optional frame
     この関数は、カラー名が有意かどうかを報告する。もし有意なら‘t’、それ
     以外は‘nil’をリターンする。引数FRAMEは、どのフレームのディスプレイ
     にたいして問い合わせるかを指定する。FRAMEが省略または‘nil’の場合は
     、選択されたフレームが使用される。

     これは、使用しているディスプレイがそのカラーをサポートするかどうか
     は告げないことに注意。X使用時には、すべての種類のディスプレイ上のす
     べての定義されたカラーを問い合わせることができ、何らかの結果(通常は
     可能な限り近いカラー)を得ることができるでしょう。あるフレームが特定
     のカラーを実際に表示できるかどうか判断するためには、
     ‘color-supported-p’(以下参照)を使用してください。

     この関数は、以前は‘x-color-defined-p’と呼ばれており、その名前は今で
     もエイリアスとしてサポートされている。

 -- Function: defined-colors &optional frame
     この関数は、FRAME(デフォルトは選択されたフレーム)上で定義かつサポー
     トされるカラー名のリストをリターンする。FRAMEがカラーをサポートしな
     ければ、値は‘nil’となる。

     この関数は、以前は‘x-defined-colors’と呼ばれており、その名前は今で
     もエイリアスとしてサポートされている。

 -- Function: color-supported-p color &optional frame background-p
     これは、FRAMEが実際にカラーCOLOR(または最低でもそれに近いカラー)を
     表示可能なら‘t’をリターンする。FRAMEが省略または‘nil’なら、この問い
     は選択されたフレームに適用される。

     フォアグラウンドおよびバックグラウンドにたいして異なるカラーセット
     をサポートする端末がいくつかある。BACKGROUND-Pが非‘nil’の場合、それ
     はCOLORがバックグラウンドとして、それ以外はフォアグラウンドとして使
     用可能かどうかを問うことを意味する。

     引数COLORは、有効なカラー名でなければならない。

 -- Function: color-gray-p color &optional frame
     これは、COLORがFRAMEのディスプレイ上の定義として、グレイスケールな
     ら‘t’をリターンする。FRAMEが省略または‘nil’なら、この問いは選択され
     たフレームに適用される。COLORが有効なカラー名でなければ、この関数は
     ‘nil’をリターンする。

 -- Function: color-values color &optional frame
     この関数は、FRAME上で理想的にはCOLORがどのように見えるべきかを記述
     する値をリターンする。COLORが定義済みの場合、値は赤、緑、青の割合を
     与える3つの整数からなるリストである。それぞれの整数の範囲は原則とし
     て0から65535だが、この範囲全体を使用しないディスプレイもいくつか存
     在するだろう。この3要素のリストは、カラーの“RGB値(rgb values)”と呼
     ばれる。

     COLORが未定義なら、値は‘nil’である。

          (color-values "black")
               ⇒ (0 0 0)
          (color-values "white")
               ⇒ (65280 65280 65280)
          (color-values "red")
               ⇒ (65280 0 0)
          (color-values "pink")
               ⇒ (65280 49152 51968)
          (color-values "hungry")
               ⇒ nil

     カラーの値は、FRAMEのディスプレイにたいしてリターンされる。FRAMEが
     省略または‘nil’の場合、この情報は選択されたフレームのディスプレイに
     たいしてリターンされる。このフレームがカラーを表示できない場合、値
     は‘nil’となる。

     この関数は、以前は‘x-color-values’と呼ばれており、その名前は今でも
     エイリアスとしてサポートされている。


File: elisp,  Node: Text Terminal Colors,  Next: Resources,  Prev: Color Names,  Up: Frames

28.21 Text Terminal Colors
==========================

通常、テキスト端末は少しのカラーしかサポートせず、コンピューターはカラー
選択に小さい整数を使用します。これは、選択したカラーがどのように見えるか
コンピューターが信頼性をもって告げることができず、どのカラーがどのような
小さい整数に対応するかという情報を、をアプリケーションに伝える必要がある
ことを意味します。しかし、Emacsは標準的なカラーセットを知っており、それ
らの自動的な使用を試みるでしょう。

   このセクションで説明する関数は、Emacsが端末カラーを使用する方法を制御
します。

   これらの関数のうちのいくつかは、*note Color Names::で説明した“RGB値
(rgb values)”を使用またはリターンします。

   これらの関数は、オプション引数としてディスプレイ(フレームまたは端末名
のいずれか)を受け取ります。わたしたちは将来、異なる端末上で異なるカラー
をEmacsにサポートさせたいと望んでいます。そうすれば、この引数はどの端末
を処理するか(デフォルトは選択されたフレームの端末。*note Input Focus::を
参照のこと)を指定するようになるでしょう。しかし現在のところ、FRAME引数に
効果はありません。

 -- Function: tty-color-define name number &optional rgb frame
     この関数は、カラー名NAMEを、その端末上のカラー値NUMBERに関連付ける
     。

     オプション引数RGBが指定された場合、それはそのカラーが実際にどのよう
     に見えるかを指定する、3つの数値のリストからなるRGB値である。RGBを指
     定しない場合、Emacsはそれがどのように見えるか知らないので、そのカラ
     ーを他のカラーに近似するために‘tty-color-approximate’で使用すること
     ができない。

 -- Function: tty-color-clear &optional frame
     この関数は、テキスト端末の定義済みカラーのテーブルをクリアーする。

 -- Function: tty-color-alist &optional frame
     この関数は、テキスト端末がサポートする既知のカラーを記録したalistを
     リターンする。

     それぞれの要素は、‘(NAME NUMBER . RGB)’または‘(NAME NUMBER)’という
     形式をもつ。ここで、NAMEはカラー名、NUMBERはその端末でカラー指定に
     使用される数値である。RGBが与えられた場合、それはそのカラーが実際に
     どのように見えるかを告げる3つのカラー値(赤、緑、青)のリストである。

 -- Function: tty-color-approximate rgb &optional frame
     この関数は、DISPLAYにたいしてサポートされた既知のカラーの中から、
     RGB値RGB(カラー値のリスト)で記述されたもっとも近いカラーを探す。リ
     ターン値は、‘tty-color-alist’の要素である。

 -- Function: tty-color-translate color &optional frame
     この関数は、DISPLAYにたいしてサポートされた既知のカラーの中から、も
     っとも近いカラーのインデックス(整数)をリターンする。名前COLORが未定
     義なら、値は‘nil’となる。


File: elisp,  Node: Resources,  Next: Display Feature Testing,  Prev: Text Terminal Colors,  Up: Frames

28.22 X Resources
=================

このセクションでは、Xリソース、または他のオペレーティングシステム上での
等価物を問い合わせたり使用する関数および変数をいくつか説明します。Xリソ
ースにたいする詳細な情報は、*note X Resources: (emacs)X Resources.を参照
してください。

 -- Function: x-get-resource attribute class &optional component
          subclass
     関数‘x-get-resource’は、Xウィンドウのデフォルトデータベースからリソ
     ース値を取得する。

     リソースは、“キー(key)”と“クラス(class)”の組み合わせによりインデッ
     クス付けされている。この関数は、‘INSTANCE.ATTRIBUTE’という形式をキ
     ー(INSTANCEはEmacsが呼び出されたときの名前)、クラスとして
     ‘Emacs.CLASS’として使用することにより検索を行う。

     オプション引数COMPONENTおよびSUBCLASSは、それぞれキーおよびクラスを
     追加する。指定する場合は両方を指定するか、さもなくばどちらも指定し
     てはならない。これらを指定した場合、キーは
     ‘INSTANCE.COMPONENT.ATTRIBUTE’、クラスは‘Emacs.CLASS.SUBCLASS’とな
     る。

 -- Variable: x-resource-class
     この変数は、‘x-get-resource’が照会すべきアプリケーション名を指定す
     る。デフォルト値は‘"Emacs"’。‘x-get-resource’の呼び出し周辺で、この
     変数を“Emacs”以外の文字列にバインドすることにより、アプリケーション
     名にたいしてXリソースを調べることができる。

 -- Variable: x-resource-name
     この変数は、‘x-get-resource’が照会すべきインスタンス名を指定する。
     デフォルト値はEmacs呼び出し時の名前、またはスイッチ‘-name’または
     ‘-rn’で指定された値である。

   上述のいくつかを説明するために、Xリソースファイル(通常は
‘~/.Xdefaults’や‘~/.Xresources’)内に以下のような行があるとしましょう:

     xterm.vt100.background: yellow

その場合は:

     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "vt100.background" "VT100.Background"))
          ⇒ "yellow"
     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "background" "VT100" "vt100" "Background"))
          ⇒ "yellow"

 -- Variable: inhibit-x-resources
     この変数が非‘nil’なら、EmacsはXリソースを照会せず、新たなフレーム作
     成時にXリソースは何も効果をもたない。


File: elisp,  Node: Display Feature Testing,  Prev: Resources,  Up: Frames

28.23 Display Feature Testing
=============================

このセクションの関数は、特定のディスプレイの基本的な能力を説明します。
Lispプログラムは、そのディスプレイが行えることに挙動を合わせるために、そ
れらを使用できます。たとえば、ポップアップメニューがサポートされなければ
、通常はポップアップメニューを使用するプログラムは、ミニバッファーを使用
できます。

   これらの関数のオプション引数DISPLAYは、問い合わせるディスプレイを指定
します。これにはディスプレイ名、フレーム(フレームがあるディスプレイを指
定)、または‘nil’(選択されたフレームのディスプレイを参照する。*note Input
Focus::を参照されたい)を指定できます。

   ディスプレイに関する情報を取得するその他の関数については、*note Color
Names::を参照してください。

 -- Function: display-popup-menus-p &optional display
     この関数は、DISPLAY上でポップアップメニューがサポートされていれば
     ‘t’、それ以外は‘nil’をリターンする。Emacsディスプレイのある部分をマ
     ウスでクリックすることによりメニューがポップアップするので、ポップ
     アップメニューのサポートにはマウスが利用可能であることが要求される
     。

 -- Function: display-graphic-p &optional display
     この関数は、DISPLAYが一度に複フレームおよび複数の異なるフォントを表
     示する能力を有すグラフィックディスプレイなら‘t’をリターンする。これ
     は、Xのようなウィンドウシステムのディスプレイにたいしては真、テキス
     ト端末にたいしては偽となる。

 -- Function: display-mouse-p &optional display
     この関数は、DISPLAYでマウスが利用可能なら‘t’、それ以外は‘nil’をリタ
     ーンする。

 -- Function: display-color-p &optional display
     この関数は、そのスクリーンがカラースクリーンなら‘t’をリターンする。
     これは以前は‘x-display-color-p’と呼ばれており、その名前はエイリアス
     として今でもサポートされる。

 -- Function: display-grayscale-p &optional display
     この関数は、スクリーンがグレースケールを表示可能なら‘t’をリターンす
     る(カラーディスプレイはすべてこれを行うことができる)。

 -- Function: display-supports-face-attributes-p attributes &optional
          display
     この関数は、ATTRIBUTES内のすべてのフェイス属性がサポートされていれ
     ば非‘nil’をリターンする(*note Face Attributes::を参照)。

     幾分発見的ではあるが、‘サポートされる’という言葉は、基本的にはある
     フェイスがATTRIBUTES内のすべての属性を含み、ディスプレイにたいして
     デフォルトフェイスにマージ時に、

       1. デフォルトフェイスとは異なる外見で表示でき、かつ

       2. 指定した属性と正確に一致しない場合は、‘より近い(close in
          spirit)’

     方法で表現可能なことを意味する。2つ目のポイントは、属性‘:weight
     black’は太字(bold)表示可能な、同様に属性‘:foreground "yellow"’は黄
     色がかった何らかのカラーを表示可能なすべてのディスプレイで満たされ
     るだろうが、属性‘:slant italic’は斜体(italic)を自動的に‘淡色
     (dim)’に置き換えるttyの表示コードでは_満たされない_であろうことを暗
     に示している。

 -- Function: display-selections-p &optional display
     この関数は、DISPLAYが選択(selections)をサポートすれば‘t’をリターン
     する。ウィンドウ化されたディスプレイでは、通常は選択がサポートされ
     るが、他の場合にもサポートされ得る。

 -- Function: display-images-p &optional display
     この関数は、DISPLAYがイメージを表示可能なら‘t’をリターンする。ウィ
     ンドウ化されたディスプレイは原則イメージを処理するが、イメージにた
     いするサポートを欠くシステムもいくつかある。イメージをサポートしな
     いディスプレイ上では、Emacsはツールバーを表示できない。

 -- Function: display-screens &optional display
     この関数は、そのディスプレイに割り当てられたスクリーンの数をリター
     ンする。

 -- Function: display-pixel-height &optional display
     この関数は、スクリーンの高さをピクセルでリターンする。文字端末では
     、文字数で高さを与える。

     “マルチモニター”にセットアップされているグラフィカル端末では、
     DISPLAYに割り当てられたすべての物理モニターのピクセル幅を参照するこ
     とに注意。*note Multiple Terminals::を参照のこと。

 -- Function: display-pixel-width &optional display
     この関数は、スクリーンの幅をピクセルでリターンする。文字端末では、
     文字数で幅を与える。

     “マルチモニター”にセットアップされているグラフィカル端末では、
     DISPLAYに割り当てられたすべての物理モニターのピクセル幅を参照するこ
     とに注意。*note Multiple Terminals::を参照のこと。

 -- Function: display-mm-height &optional display
     この関数は、スクリーンの高さをミリメートルでリターンする。‘nil’なら
     、Emacsがその情報を取得できなかったことを意味する。

     “マルチモニター”にセットアップされているグラフィカル端末では、
     DISPLAYに割り当てられたすべての物理モニターのピクセル幅を参照するこ
     とに注意。*note Multiple Terminals::を参照のこと。

 -- Function: display-mm-width &optional display
     この関数は、スクリーンの幅をミリメートルでリターンする。‘nil’なら、
     Emacsがその情報を取得できなかったことを意味する。

     “マルチモニター”にセットアップされているグラフィカル端末では、
     DISPLAYに割り当てられたすべての物理モニターのピクセル幅を参照するこ
     とに注意。*note Multiple Terminals::を参照のこと。

 -- User Option: display-mm-dimensions-alist
     この変数は、システムの提供する値が不正な場合に‘display-mm-height’お
     よび‘display-mm-width’がリターンするグラフィカルなディスプレイのサ
     イズを、ユーザーが指定できるようにする。

 -- Function: display-backing-store &optional display
     この関数は、そのディスプレイのバッキングストアー(backing store)の能
     力をリターンする。バッキングストアーとは、非露出ウィンドウ(およびウ
     ィンドウの一部)のピクセルを記録しておいて、露出時に素早く表示できる
     ようにすることを意味する。

     値にはシンボル‘always’、‘when-mapped’、‘not-useful’である。特定の種
     類のディスプレイにたいしてこの問いが適用外の際、この関数は‘nil’をリ
     ターンすることもある。

 -- Function: display-save-under &optional display
     この関数は、そのディスプレイがSaveUnder機能をサポートすれば非
     ‘nil’をリターンする。この機能は、ポップアップウィンドウに隠されるピ
     クセルを保存して、素早くポップダウンができるようにするために使用さ
     れる。

 -- Function: display-planes &optional display
     この関数は、そのディスプレイがサポートする平面数(number of planes)を
     リターンする。これは通常、ピクセルごとのビット(bits per pixel: 色深
     度[bpp])数である。ttyディスプレイでは、サポートされるカラー数の2進
     対数(log to base two)である。

 -- Function: display-visual-class &optional display
     この関数は、そのスクリーンのビジュアルクラスをリターンする。値はシ
     ンボル‘static-gray’(カラー数変更不可の限定されたグレイ)、
     ‘gray-scale’(フルレンジのグレイ)、‘static-color’(カラー数変更不可の
     限定されたカラー)、‘pseudo-color’(限定されたカラー数のカラー)、
     ‘true-color’(フルレンジのカラー)、および‘direct-color’(フルレンジの
     カラー)のいずれかである。

 -- Function: display-color-cells &optional display
     この関数は、そのスクリーンがサポートするカラーのセル数をリターンす
     る。

   以下の関数は、Emacsが指定されたDISPLAYを表示する場所に使用されるウィ
ンドウシステムの追加情報を取得します(関数名先頭の‘x-’は歴史的理由による
)。

 -- Function: x-server-version &optional display
     この関数は、GNUおよびUnixシステム上のXサーバーのような、DISPLAY上で
     実行されているGUIウィンドウシステムのバージョン番号のリストをリター
     ンする。値は3つの整数からなるリストで、1つ目と2つ目の整数はそのプロ
     トコルのメジャーバージョン番号とマイナーバージョン番号、3つ目の整数
     はウィンドウシステムソフトウェア自体のディストリビューター固有のリ
     リース番号である。GNUおよびUnixシステムでは、通常これらはXプロトコ
     ルのバージョン番号と、Xサーバーソフトウェアのディストリビューター固
     有のリリース番号である。MS-Windowsでは、WidowsのOSバージョン番号で
     ある。

 -- Function: x-server-vendor &optional display
     この関数は、ウィンドウシステムソフトウェアを提供する“ベンダー”をリ
     ターン(文字列)する。GNUおよびUnixシステムでは、それが誰であれその
     Xサーバーを配布するベンダーを意味する。MS-Windowsでは、Widows OSの
     ベンダーID文字列(Microsoft)である。

     X開発者がソフトウェア配布者を“vendors”とラベル付けしたことは、いか
     なるシステムも非商業的に開発および配布できないと彼らが誤って仮定し
     たことを示している。


File: elisp,  Node: Positions,  Next: Markers,  Prev: Frames,  Up: Top

29 Positions
************

“位置(position)”とは、バッファーのテキストの文字のインデックスです。より
正確には、位置とは2つの文字間(または最初の文字の前、または最後の文字の後
)の箇所を識別し、与えられた位置の前あるいは後の文字のように表現すること
ができます。しかし、“ある位置にある文字”のように表現することもあり、その
場合はその位置の後の文字を意味します。

   位置は通常、1から始まる整数として表されますが、“マーカー(markers)”と
して表現することもできます。関数は引数に位置(整数)を期待しますが、代替と
してマーカーも受け入れ、通常はそのマーカーが指すのがどのバッファーなのか
は無視します。これらの関数はマーカーを整数に変換して、たとえそのマーカー
が“誤った”バッファーを指していたとしても、まるで引数としてその整数が渡さ
れたかのように、その整数を使用します。整数に変換できない場所を指すマーカ
ーを整数のかわりに使用すると、エラーとなります。*note Markers::を参照し
てください。

   多くのカーソルモーションコマンドにより使用される関数を提供する“フィー
ルド(field)”機能(*note Fields::)も参照してください。

* Menu:

* Point::                    編集タスクが行われる特別な位置。
* Motion::                   ポイントの変更。
* Excursions::               一時的な移動とバッファーの変更。
* Narrowing::                バッファーの一部に編集を限定する。


File: elisp,  Node: Point,  Next: Motion,  Up: Positions

29.1 Point
==========

“ポイント(point)”とは、多くの編集コマンドにより使用される、バッファーの
特別な位置のことです。これらのコマンドには、自己挿入型のタイプ文字やテキ
スト挿入関数が含まれます。その他のコマンドは、別の箇所でテキストの編集や
挿入ができるようにポイントを移動します。

   他の位置と同様、ポイントは特定の文字ではなく、2つの文字の間(または最
初の文字の前、または最後の文字の後)を指します。通常、端末ではポイント直
後の文字の上にカーソルを表示します。つまり、ポイントは実際はカーソルのあ
る文字の前にあります。

   ポイントの値は1より小さくなることはなく、そのバッファーのサイズに1を
加えた値より大きくなることはありません。ナローイング(*note Narrowing::を
参照)が効力をもつ場合、ポイントはそのバッファーのアクセス可能な範囲内(範
囲の境界はバッファーの先頭か終端のいずれかの可能性がある)に閉じ込められ
ます。

   バッファーはそれぞれ自身のポイント値をもち、それは他のバッファーのポ
イント値とは無関係です。ウィンドウもそれぞれポイント値をもち、他のウィン
ドウ内の同じバッファー上のポイント値とは無関係です。同じバッファーを表示
する種々のウィンドウが異なるポイント値をもてるのは、これが理由です。ある
バッファーがただ1つのウィンドウに表示されているときは、そのバッファーの
ポイントとそのウィンドウのポイントは、通常は同じ値をもち、区別が重要にな
るのは稀です。詳細は*note Window Point::を参照してください。

 -- Function: point
     この関数は、カレントバッファー内のポイントの値を、整数でリターンす
     る。

          (point)
               ⇒ 175

 -- Function: point-min
     この関数は、カレントバッファー内のアクセス可能なポイントの最小値を
     リターンする。これは通常は1だが、ナローイングが効力をもつ場合は、ナ
     ローイングしたリージョンの開始位置となる(*note Narrowing::を参照)。

 -- Function: point-max
     この関数は、カレントバッファー内のアクセス可能なポイントの最大値を
     リターンする。これはナローイングされていなければは‘(1+
     (buffer-size))’だが、ナローイングが効力をもつ場合は、ナローイングし
     たリージョンの終端位置となる(*note Narrowing::を参照)。

 -- Function: buffer-end flag
     この関数は、FLAGが0より大なら‘(point-max)’、それ以外は
     ‘(point-min)’をリターンする。引数FLAGは数値でなければならない。

 -- Function: buffer-size &optional buffer
     この関数は、カレントバッファー内の文字数のトータルをリターンする。
     ナローイング(*note Narrowing::を参照)されていなければ、
     ‘point-max’はこれに1を加えた値をリターンする。

     BUFFERにバッファーを指定した場合、値はBUFFERのサイズになる。

          (buffer-size)
               ⇒ 35
          (point-max)
               ⇒ 36


File: elisp,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

29.2 Motion
===========

モーション関数は、ポイントのカレント値、バッファーの先頭または終端、また
は選択されたウィンドウ端のいずれかより、相対的にポイントの値を変更します
。*note Point::を参照してください。

* Menu:

* Character Motion::         文字単位での移動。
* Word Motion::              単語単位での移動。
* Buffer End Motion::        バッファー先頭または終端への移動。
* Text Lines::               テキスト行単位での移動。
* Screen Lines::             表示される行単位での移動。
* List Motion::              リストやS式の解析による移動。
* Skipping Characters::      特定の集合に属す文字のスキップ。


File: elisp,  Node: Character Motion,  Next: Word Motion,  Up: Motion

29.2.1 Motion by Characters
---------------------------

以下の関数は、文字数にもとづいてポイントを移動します。 ‘goto-char’は基本
的なプリミティブで、その他の関数はこれを使用しています。

 -- Command: goto-char position
     この関数は、カレントバッファー内のポイントの値をPOSITIONにセットす
     る。

     ナローイングが効力をもつ場合でも、POSITIONは依然としてバッファー先
     頭から数えられるが、ポイントをアクセス可能な範囲外に移動することは
     できない。POSITIONが範囲外の場合、‘goto-char’はアクセス可能な範囲の
     先頭または終端にポイントを移動する。

     この関数がインタラクティブに呼び出された際は、POSITIONの値は数プレ
     フィクス引数、プレフィクス引数が与えられなかった場合はミニバッファ
     ーから値を読み取る。

     ‘goto-char’はPOSITIONをリターンする。

 -- Command: forward-char &optional count
     この関数は前方、すなわちバッファーの終端方向にポイントをCOUNT文字移
     動する(COUNTが負なら後方、すなわちバッファーの先頭方向にポイントを
     移動する)。COUNTが‘nil’の場合のデフォルトは1。

     バッファー(ナローイングが効力をもつ場合はアクセス可能な範囲の境界
     )の先頭または終端を超えて移動を試みた場合はエラーシンボル
     ‘beginning-of-buffer’または‘end-of-buffer’のエラーをシグナルする。

     インタラクティブな呼び出しでは、数プレフィクス引数がCOUNTとなる。

 -- Command: backward-char &optional count
     移動方向が逆であることを除き、これは‘forward-char’と同様である。


File: elisp,  Node: Word Motion,  Next: Buffer End Motion,  Prev: Character Motion,  Up: Motion

29.2.2 Motion by Words
----------------------

以下の関数は、与えられた文字が単語の一部なのかどうかを判断するための構文
テーブルを使用して単語を解析します。*note Syntax Tables::を参照してくだ
さい。

 -- Command: forward-word &optional count
     この関数は、COUNTの単語数分ポイントを前方に移動する。(COUNTが負なら
     後方に移動する)。COUNTが省略または‘nil’の場合のデフォルトは1。

     “単語1つ移動”とは、単語構成文字を横断して、単語区切り文字に遭遇する
     までポイントを移動することを意味する。しかし、この関数はバッファー
     のアクセス可能範囲の境界およびフィールド境界(*note Fields::を参照
     )を超えてポイントを移動できない。フィールド境界のもっとも一般的な例
     は、ミニバッファー内のプロンプト終端である。

     バッファー境界またはフィールド境界により途中で停止することなく単語
     COUNT個分の移動が可能なら、値は‘t’となる。それ以外ではリターン値は
     ‘nil’で、ポイントはバッファー境界またはフィールド境界で停止する。

     ‘inhibit-field-text-motion’が非‘nil’なら、この関数はフィールド境界
     を無視する。

     インタラクティブに呼び出された場合、COUNTは数プレフィクス引数により
     指定される。

 -- Command: backward-word &optional count
     この関数は、単語の前に遭遇するまで、前方ではなく後方に移動すること
     を除き、‘forward-word’と同様である。

 -- User Option: words-include-escapes
     この変数は、‘forward-word’とそれを使用するすべての関数の挙動に影響
     する。これが非‘nil’なら、構文クラス“エスケープ(escape)”および“クォ
     ート文字(character quote)”内の文字は、単語の一部とみなされる。それ
     以外では、単語の一部とはみなされない。

 -- Variable: inhibit-field-text-motion
     この変数が非‘nil’なら‘forward-word’、‘forward-sentence’、
     ‘forward-paragraph’を含む特定のモーション関数は、フィールド境界を無
     視する。


File: elisp,  Node: Buffer End Motion,  Next: Text Lines,  Prev: Word Motion,  Up: Motion

29.2.3 Motion to an End of the Buffer
-------------------------------------

バッファーの先頭にポイントを移動するには、以下のように記述します:

     (goto-char (point-min))

同様に、バッファーの終端に移動するには、以下を使用します:

     (goto-char (point-max))

   以下の2つは、ユーザーがこれらを行うためのコマンドです。これらはマーク
をセットしてメッセージをエコーエリアに表示するため、Lispプログラム内で使
用しないよう警告するために、ここに記述します。

 -- Command: beginning-of-buffer &optional n
     この関数は、バッファー(ナローイングが効力をもつ場合はアクセス可能範
     囲の境界)の先頭にポイントを移動して、以前の位置にマークをセットする
     (Transient Markモードの場合、マークがすでにアクティブならマークはセ
     ットしない)。

     Nが非‘nil’なら、バッファーのアクセス可能範囲の先頭から10分のNの位置
     にポイントを置く。インタラクティブな呼び出しでは、Nは数プレフィクス
     引数が与えられればその値、それ以外でのデフォルトは‘nil’である。

     *警告:* この関数をLispプログラム内で使用してはならない。

 -- Command: end-of-buffer &optional n
     この関数は、バッファー(ナローイングが効力をもつ場合はアクセス可能範
     囲の境界)の終端にポイントを移動して、以前の位置にマークをセットする
     (Transient Markモードの場合、マークがすでにアクティブならマークはセ
     ットしない)。Nが非‘nil’なら、バッファーのアクセス可能範囲の終端から
     10分のNの位置にポイントを置く。

     インタラクティブな呼び出しでは、Nは数プレフィクス引数が与えられれば
     その値、それ以外でのデフォルトは‘nil’である。<

     *警告:* この関数をLispプログラム内で使用してはならない。


File: elisp,  Node: Text Lines,  Next: Screen Lines,  Prev: Buffer End Motion,  Up: Motion

29.2.4 Motion by Text Lines
---------------------------

テキスト行とは、改行で区切られたバッファーの範囲です。改行は前の行の一部
とみなされます。最初のテキスト行はバッファー先頭で始まり、最後のテキスト
行は最後の文字が改行かどうかは関係なくバッファー終端で終わります。バッフ
ァーからテキスト行への分割は、そのウィンドウの幅、表示の行継続、タブおよ
びその他の制御文字の表示方法に影響されません。

 -- Command: beginning-of-line &optional count
     この関数は、カレント行の先頭にポイントを移動する。引数COUNTが非
     ‘nil’または1以外なら、前方にCOUNT−1行移動してから、その行の先頭に移
     動する。

     この関数は、別の行に移動する場合を除き、フィールド境界(*note
     Fields::を参照)を超えてポイントを移動しない。したがって、COUNTが
     ‘nil’または1で、かつポイントがフィールド境界で開始される場合は、ポ
     イントを移動しない。フィールド境界を無視させるには、
     ‘inhibit-field-text-motion’を‘t’にバインドするか、かわりに
     ‘forward-line’関数を使用する。たとえば、フィールド境界を無視するこ
     とを除けば、‘(forward-line 0)’は‘(beginning-of-line)’と同じことを行
     う。

     この関数がバッファー(ナローイングが効力をもつ場合はアクセス可能範囲
     )の終端に到達した場合は、ポイントをその位置に置く。エラーはシグナル
     されない。

 -- Function: line-beginning-position &optional count
     ‘(beginning-of-line COUNT)’が移動するであろう位置をリターンする。

 -- Command: end-of-line &optional count
     この関数は、カレント行の終端にポイントを移動する。引数COUNTが非
     ‘nil’または1以外なら、前方にCOUNT−1行移動してから、その行の終端に移
     動する。

     この関数は、別の行に移動する場合を除き、フィールド境界(*note
     Fields::を参照)を超えてポイントを移動しない。したがって、COUNTが
     ‘nil’または1で、かつポイントがフィールド境界で開始される場合は、ポ
     イントを移動しない。フィールド境界を無視させるには、
     ‘inhibit-field-text-motion’を‘t’にバインドする。

     この関数がバッファー(ナローイングが効力をもつ場合はアクセス可能範囲
     )の終端に到達した場合は、ポイントをその位置に置く。エラーはシグナル
     されない。

 -- Function: line-end-position &optional count
     ‘(end-of-line COUNT)’が移動するであろう位置をリターンする。

 -- Command: forward-line &optional count
     この関数は、前方にCOUNT行移動して、その行の先頭にポイントを移動する
     。COUNTが負なら、後方に−COUNT行移動して、その行の先頭にポイントを移
     動する。COUNTが0の場合は、カレント行の先頭にポイントを移動する。
     COUNTが‘nil’なら、それは1を意味する。

     ‘forward-line’が指定された行数を移動する前にバッファー(またはアクセ
     ス可能範囲)の先頭か終端に遭遇した場合は、そこにポイントをセットする
     。エラーはシグナルされない。

     ‘forward-line’は、COUNTと実際に移動した行数の差をリターンする。3行
     しかないバッファーの先頭から、5行したへの移動を試みた場合、ポイント
     は最終行の終端で停止し、値は2となるだろう。

     インタラクティブな呼び出しでは、数プレフィクス引数がCOUNTとなる。

 -- Function: count-lines start end
     この関数は、カレントバッファー内の位置STARTとENDの間の行数をリター
     ンする。STARTとENDが等しければ、リターン値は0になる。それ以外は、た
     とえSTARTとENDが同一行にあっても、最小でも1をリターンする。これらの
     間にあるテキストは、それだけを孤立して考えたると、それが空でない限
     りは最小でも1行を含まなければならないからである。

 -- Command: count-words start end
     この関数は、カレントバッファー内の位置STARTとENDの間にある単語の数
     をリターンする。

     この関数は、インタラクティブに呼び出すこともできる。その場合はバッ
     ファー、またはリージョンがアクティブならリージョン内の行数、単語数
     、文字数を報告するメッセージをプリントする。

 -- Function: line-number-at-pos &optional pos
     この関数は、カレントバッファー内のバッファー位置POSに対応する行番号
     をリターンする。POSが‘nil’または省略された場合は、カレントのバッフ
     ァー位置が使用される。

   *note Near Point::の関数‘bolp’と‘eolp’も参照してください。これらの関
数はポイントを移動しませんが、ポイントがすでに行頭または行末にあるかどう
かをテストします。


File: elisp,  Node: Screen Lines,  Next: List Motion,  Prev: Text Lines,  Up: Motion

29.2.5 Motion by Screen Lines
-----------------------------

前のセクションの行関数は、改行文字で区切られたテキスト行だけを数えました
。対照的に、以下の関数はスクリーン行を数えます。スクリーン行は、スクリー
ン上でテキストが表示される方法にしたがって定義されます。あるテキスト行
1行が、選択されたウィンドウの幅にフィット可能な程に十分短ければ、それは
スクリーン行で1行になりますが、それ以外は複数のスクリーン行になり得ます
。

   テキスト行が追加スクリーン行に継続されずに、そのスクリーンで切り詰め
られる(truncated)場合があります。そのような場合は、‘vertical-motion’で
‘forward-line’のようにポイントを移動します。*note Truncation::を参照して
ください。

   文字列が与えられた場合、その幅は、文字の外見を制御するフラグに依存す
るため、与えられたテキスト断片にたいして、たとえそれが選択されたウィンド
ウ上でさえも(幅、切り詰め有無、ディスプレイテーブルはウィンドウごとに異
なり得るので)、そのテキストがあるバッファーに応じて、‘vertical-motion’の
挙動は異なります。*note Usual Display::を参照してください。

   以下の関数は、スクリーン行のブレーク位置を判断するためにテキストをス
キャンするため、スキャンする長さに比例して時間を要します。

 -- Function: vertical-motion count &optional window
     この関数は、ポイントのあるスクリーン行からスクリーン行でCOUNT行下に
     移動して、そのスクリーン行の先頭にポイントを移動する。COUNTが負なら
     、かわりに上に移動する。

     COUNT引数には、整数のかわりにコンスセル‘(COLS . LINES)’を指定できる
     。その場合、関数はスクリーン行でLINES行移動して、そのスクリーン行の
     視覚的な行頭(visual start)からCOLS列目にポイントを置く。COLSは、そ
     の行の_視覚的(visual)_な開始から数えられることに注意。そのウィンド
     ウが水平スクロール(*note Horizontal Scrolling::を参照)されている場
     合には、ポイントが置かれる列は、スクロールされたテキストの列数が加
     えられるだろう。

     リターン値は、ポイントが移動したスクリーン行の行数である。バッファ
     ーの先頭か終端に到達していたら、この値は絶対値ではCOUNTより小になる
     かもしれない。

     ウィンドウWINDOW引数幅、水平スクロール、ディスプレイテーブルのよう
     なパラメーターの取得に使用される。しかし‘vertical-motion’は、たとえ
     WINDOWがカレントで他のバッファーを表示していたとしても常に、カレン
     トバッファーにたいして処理を行う。

 -- Function: count-screen-lines &optional beg end count-final-newline
          window
     この関数は、BEGからENDのテキスト内のスクリーン行の行数をリターンす
     る。スクリーン行数は行継続やディスプレイテーブル等により、実際の行
     数とは異なるかもしれない。BEGおよびENDが‘nil’、または省略された場合
     のデフォルトは、そのバッファーのアクセス可能範囲の先頭と終端である
     。

     そのリージョンが改行で終わる場合、オプションの第3引数
     COUNT-FINAL-NEWLINEが‘nil’なら、それは無視される。

     オプションの第4引数WINDOWは、幅や水平スクロール等のパラメーターを取
     得するウィンドウを指定する。デフォルトは、選択されたウィンドウのパ
     ラメーターを使用する。

     ‘vertical-motion’と同様、‘count-screen-lines’はWINDOW内にどのバッフ
     ァーが表示されていようと、常にカレントバッファーを使用する。これに
     より、バッファーが何らかのウィンドウにカレントで表示されているか否
     かにかかわらず、任意にバッファーにたいして‘count-screen-lines’の使
     用が可能になる。

 -- Command: move-to-window-line count
     この関数は、選択されたウィンドウ内にカレントで表示されているテキス
     トに応じてポイントを移動する。これは、ウィンドウ上端からスクリーン
     行でCOUNT行目の先頭にポイントを移動する。COUNTが負なら、それはバッ
     ファー下端(バッファーが指定されたスクリーン位置の上で終わる場合はバ
     ッファーの最終行)から、−COUNT行目の位置を指定する。

     COUNTが‘nil’の場合、ポイントはウィンドウ中央の行の先頭に移動する。
     COUNTの絶対値がウィンドウサイズより大なら、ウィンドウが十分に高かっ
     たならそのスクリーン行は表示されていたであろう位置に、ポイントを移
     動する。これは、おそらく次回の再表示の際に、その箇所がスクリーン上
     になるようなスクロールを発生させるだろう。

     インタラクティブな呼び出しでは、数プレフィクス引数がCOUNTとなる。

     リターン値は、ウィンドウ上端行を0とする、ポイントが移動した先の行番
     号である。

 -- Function: compute-motion from frompos to topos width offsets window
     この関数は、カレントバッファーをスキャンして、スクリーン位置を計算
     する。これは位置FROMがスクリーン座標FROMPOSにあると仮定して、そこか
     ら位置TOまたは座標TOPOSのいずれか先に到達したほうまで、バッファーを
     前方にスキャンする。これはスキャン終了のバッファー位置と、スクリー
     ン座標をリターンする。

     座標引数FROMPOSおよびTOPOSは、‘(HPOS . VPOS)’という形式のコンスセル
     である。

     引数WIDTHは、テキストを表示するために利用可能な列数である。これは、
     継続行の処理に影響する。‘nil’は、そのウィンドウ内で使用可能な実際の
     テキスト列数で、‘(window-width window)’がリターンする値と等しい。

     引数OFFSETSは‘nil’、または‘(HSCROLL . TAB-OFFSET)’という形式のコン
     スセルのいずれかである。ここでHSCROLLは、左マージンのために表示され
     ない列数であり、呼び出し側のほとんどは‘window-hscroll’を呼び出すこ
     とにより、これを取得する。一方TAB-OFFSETは、スクリーン上の列数と、
     バッファー内の列数の間のオフセットである。これは継続行において、前
     のスクリーン行の幅が‘tab-width’の整数倍でないときは、非0になる可能
     性がある。非継続行では、これは常に0である。

     ウィンドウWINDOWの役割は、使用するディスプレイテーブルの指定するこ
     とだけである。‘compute-motion’は、WINDOW内に表示されているのがどの
     バッファーであろうと、カレントバッファーを処理する。

     リターン値は、5つの要素をもつリストである:

          (POS HPOS VPOS PREVHPOS CONTIN)

     ここで、POSはスキャンが停止したバッファー位置、VPOSは垂直スクリーン
     位置、HPOSは水平スクリーン位置である。

     結果PREVHPOSは、POSから1文字戻った水平位置である。結果CONTINは、最
     後の行が前の文字の後(または中)から継続されていれば、‘t’となる。

     たとえば、あるウィンドウのスクリーン行LINEの列COLのバッファー位置を
     求めるには、そのウィンドウのdisplay-start(表示開始)位置をFROM、その
     ウィンドウの左上隅の座標をFROMPOSとして渡す。スキャンをそのバッファ
     ーのアクセス可能範囲の終端に制限するために、バッファーの
     ‘(point-max)’をTOに、LINEとCOLをTOPOSに渡す。以下は、これを行う関数
     である:

          (defun coordinates-of-position (col line)
            (car (compute-motion (window-start)
                                 '(0 . 0)
                                 (point-max)
                                 (cons col line)
                                 (window-width)
                                 (cons (window-hscroll) 0)
                                 (selected-window))))

     ミニバッファーにたいして‘compute-motion’を使う際は、最初のスクリー
     ン行の先頭の水平位置を取得するために、‘minibuffer-prompt-width’を使
     用する必要がある。


File: elisp,  Node: List Motion,  Next: Skipping Characters,  Prev: Screen Lines,  Up: Motion

29.2.6 Moving over Balanced Expressions
---------------------------------------

以下は、バランスの取れたカッコ式(balanced-parenthesis。これらの式を横断
して移動することと関連して、Emacsでは“sexp(S式)”とも呼ばれる)と関連する
、いくつかの関数です。これらの関数がさまざまな文字を処理する方法は、構文
テーブル(syntax table)が制御します。*note Syntax Tables::を参照してくだ
さい。sexp、またはその一部にたいする低レベルのプリミティブについては、
*note Parsing Expressions::を参照してください。ユーザーレベルのコマンド
については、*note Commands for Editing with Parentheses:
(emacs)Parentheses.を参照してください。

 -- Command: forward-list &optional arg
     この関数は、バランスの取れたカッコのグループを、ARG(デフォルトは
     1)グループ前方に移動する(単語やクォート文字のペアーでクォートされた
     文字列は無視される)。

 -- Command: backward-list &optional arg
     この関数は、バランスの取れたカッコのグループを、ARG(デフォルトは
     1)グループ後方に移動する(単語やクォート文字のペアーでクォートされた
     文字列は無視される)。

 -- Command: up-list &optional arg
     この関数は、カッコをARG(デフォルトは1)レベル外側前方に移動する。負
     の引数では後方に移動するが、同様に浅いレベルに移動する。

 -- Command: down-list &optional arg
     この関数は、カッコをARG(デフォルトは1)レベル内側前方に移動する。負
     の引数では後方に移動するが、同様に深いレベル(−ARGレベル)に移動する
     。

 -- Command: forward-sexp &optional arg
     この関数は、バランスの取れた式(balanced expressions)を、ARG(デフォ
     ルトは1)前方に移動する。バランスの取れた式にはカッコ等で区切られた
     式、および単語や文字列定数のようなものも含まれる。*note Parsing
     Expressions::を参照のこと。たとえば、

          ---------- Buffer: foo ----------
          (concat★ "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               ⇒ nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y★ z)
          ---------- Buffer: foo ----------

 -- Command: backward-sexp &optional arg
     この関数は、バランスの取れた式(balanced expressions)を、ARG(デフォ
     ルトは1)後方に移動する。

 -- Command: beginning-of-defun &optional arg
     この関数は、後方にARG番目のdefunの先頭に移動する。ARGが負なら、実際
     には前方に移動するが、defunの終端ではなく先頭に移動することは変わら
     ない。ARGのデフォルトは1。

 -- Command: end-of-defun &optional arg
     この関数は、前方にARG番目のdefunの終端に移動する。ARGが負なら、実際
     には後方に移動するが、defunの先頭ではなく終端に移動することは変わら
     ない。ARGのデフォルトは1。

 -- User Option: defun-prompt-regexp
     非‘nil’なら、このバッファーローカル変数はdefunの始まりとなる開きカ
     ッコの前に出現し得るテキストを指定する正規表現を保持する。つまりd、
     この正規表現にたいするマッチで始まり、その後に開きカッコ構文
     (open-parenthesis syntax)が続くのがdefunである。

 -- User Option: open-paren-in-column-0-is-defun-start
     この変数の値が非‘nil’なら、列0にある開きカッコはdefunの始まりとみな
     される。‘nil’の場合、列0の開きカッコは特別な意味をもたない。デフォ
     ルトは‘t’。

 -- Variable: beginning-of-defun-function
     非‘nil’なら、この変数はdefunの開始を見つける関数を保持する。関数
     ‘beginning-of-defun’は、通常の手法を使うかわりに、その関数に自身の
     オプション引数を渡して、その関数を呼び出す。その引数が非‘nil’なら、
     その関数はその回数分の関数呼び出しにより、‘beginning-of-defun’が行
     うように後方に移動すること。

 -- Variable: end-of-defun-function
     非‘nil’なら、この変数はdefunの終端を見つける関数を保持する。関数
     ‘end-of-defun’は、通常の手法を使うかわりに、その関数を呼び出す。


File: elisp,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

29.2.7 Skipping Characters
--------------------------

以下の2つの関数は、指定された文字セットを超えてポイントを移動します。こ
れらの関数は、たとえば空白文字をスキップするためによく使用されます。関連
する関数については、*note Motion and Syntax::を参照してください。

   これらの関数は検索関数(*note Searching and Matching::を参照)が行うよ
うに、そのバッファーがマルチバイト(multibyte)ならマルチバイトに、ユニバ
イト(unibyte)ならユニバイトに、そのセットト文字列を変換します。

 -- Function: skip-chars-forward character-set &optional limit
     この関数は、与えられた文字セットをスキップして、カレントバッファー
     内のポイント前方に移動する。これはポイントの後の文字を調べて、その
     文字がCHARACTER-SETにマッチすればポイントを進める。そして、マッチし
     ない文字に到達するまで、これを継続する。この関数は、超えて移動した
     文字数をリターンする。

     引数CHARACTER-SETが、正規表現での‘[...]’内部と同様だが、‘]’で終端さ
     れず、‘\’が‘^’、‘-’、‘\’をクォートする点が異なる。つまり、
     ‘"a-zA-Z"’はすべての英字をスキップして最初の非英字の前で停止し、
     ‘"^a-zA-Z"’はすべての非英字をスキップして最初の英字の前で停止する。
     *note Regular Expressions::を参照のこと。‘"[:alnum:]"’のような文字
     クラスも使用できる。*note Char Classes::を参照されたい。

     LIMIT(数字かマーカー)が与えられた場合、それはポイントがスキップして
     到達できる、そのバッファー内の最大位置を指定する。ポイントはLIMIT、
     またはLIMITの前でストップするだろう。

     以下の例では、ポイントは最初‘T’の直前に置かれている。フォーム評価後
     、ポイントはその行の末尾(‘hat’の‘t’と改行の間)に置かれる。この関数
     は、すべての英字とスペースをスキップするが、改行はスキップしない。

          ---------- Buffer: foo ----------
          I read "★The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               ⇒ 18

          ---------- Buffer: foo ----------
          I read "The cat in the hat★
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward character-set &optional limit
     この関数は、LIMITに至るまでCHARACTER-SETにマッチする文字をスキップ
     して、ポイントを後方に移動する。これは‘skip-chars-forward’と同様だ
     が、ポイントを移動する方向が異なる。

     リターン値は、移動した距離を示す。これは、0以上の整数である。


File: elisp,  Node: Excursions,  Next: Narrowing,  Prev: Motion,  Up: Positions

29.3 Excursions
===============

プログラム中の限定された部分で、ポイントを“一時的”に移動するのが便利なこ
とが時折あります。これは“エクスカーション(excursion: 遠足、小旅行)”と呼
ばれ、スペシャルフォーム‘save-excursion’により行います。この構成は、初期
のカレントバッファー自体、ポイントおよびマークの値を記憶して、そのエクス
カーション完了時にそれらをリストアします。これはプログラムのある部分にお
いて、プログラムの他の部分に影響を与えることなくポイントを移動する標準的
な手段であり、EmacsのLispソース内では何度も使用されています。

   カレントバッファー自体のみの保存およびリストアが必要な場合は、かわり
に‘save-current-buffer’や‘with-current-buffer’を使用してください(*note
Current Buffer::を参照)。ウィンドウ構成の保存やリストアが必要なら、*note
Window Configurations::および*note Frame Configurations::で説明されてい
るフォームを参照してください。

 -- Special Form: save-excursion body...
     このスペシャルフォームは、カレントバッファー自体、およびポイント値
     とマーク値を保存してBODYを評価し、最後にバッファーおよび保存したポ
     イントとマークの値をリストアする。‘throw’またはエラーを通じたアブノ
     ーマルexit(*note Nonlocal Exits::を参照)の場合でも、保存された3つす
     べての値はリストアされる。

     ‘save-excursion’がリターンする値はBODY内の最後のフォームの結果、ま
     たはBODYフォームが与えられなければ‘nil’をリターンする。

   ‘save-excursion’は、エクスカーション開始時にカレントだったバッファー
のポイントとマークだけを保存ため、そのエクスカーション中に変更された他の
バッファーのポイントおよび/またはマークは、その後も効果が残るでしょう。
これはしばしば予期せぬ結果を招くので、エクスカーション中に‘set-buffer’を
呼び出した場合、バイトコンパイラーは警告を発します:

     Warning: Use `with-current-buffer' rather than
              save-excursion+set-buffer

このような問題を避けるには、以下の例のように望むカレントバッファーをセッ
ト後にのみ‘save-excursion’を呼び出すべきです:

     (defun append-string-to-buffer (string buffer)
       "BUFFER末尾にSTRINGを追加"
       (with-current-buffer buffer
         (save-excursion
           (goto-char (point-max))
           (insert string))))

   同じように、‘save-excursion’は‘switch-to-buffer’のような関数が変更し
たウィンドウ/バッファーの対応をリストアしません。

   *警告:* 保存されたポイント値に隣接する通常のテキスト挿入は、それがす
べてのマーカーを再配置するのと同様、保存されたポイントカーを再配置します
。より正確には、保存される値は挿入タイプ‘nil’のマーカーです。*note
Marker Insertion Types::を参照してください。したがって、保存されたポイン
ト値のリストア時は、通常は挿入されたテキストの直前になります。

   たとえ‘save-excursion’がマーク位置を保存しても、バッファーを変更する
関数が‘deactivate-mark’をセットするのを禁止しないため、そのコマンド完了
後にマークの非アクティブ化が効力を発揮します。*note The Mark::を参照して
ください。


File: elisp,  Node: Narrowing,  Prev: Excursions,  Up: Positions

29.4 Narrowing
==============

“ナローイング(narrowing)”とは、Emacs編集コマンドがアドレス指定可能なテキ
ストを、あるバッファー内の制限された文字範囲に限定することを意味します。
アドレス可能なテキストは、そのバッファーの“アクセス可能範囲(accessible
portion)”と呼ばれます。

   ナローイングは2つのバッファー位置により指定され、それがアクセス可能範
囲の開始と終了になります。ほとんどの編集コマンドおよびプリミティブにたい
し、これらの位置はそれぞれそのバッファーの先頭と終端に置き換えられます。
ナローイングが効果をもつ間、アクセス可能範囲外のテキストは表示されず、そ
の外部にポイントを移動することはできません。ナローイングは実際のバッファ
ー位置(*note Point::を参照)を変更しないことに注意してください。ほとんど
の関数は、アクセス可能範囲外のテキストにたいする操作を受け付けません。

   バッファーを保存するコマンドは、ナローイングの影響を受けません。どん
なナローイングであろうと、それらはバッファー全体を保存します。

   単一バッファー内に、タイプが大きく異なるテキストを複数表示する必要が
ある場合は、*note Swapping Text::で説明する代替機能の使用を考慮してみて
ください。

 -- Command: narrow-to-region start end
     この関数は、アクセス可能範囲の開始と終了に、カレントバッファーの
     STARTとENDをセットする。どちらの引数も、文字位置で指定すること。

     インタラクティブな呼び出しでは、STARTとENDはカレントリージョン(ポイ
     ントとマークで、小さいほうが前者)にセットされる。

 -- Command: narrow-to-page &optional move-count
     この関数は、カレントページだけを含むように、カレントバッファーのア
     クセス可能範囲をセットする。1つ目のオプション引数MOVE-COUNTが非
     ‘nil’の場合は、MOVE-COUNTで前方または後方へ移動後に、1ページにナロ
     ーすることを意味する。変数‘page-delimiter’は、ページの開始と終了の
     位置を指定する(*note Standard Regexps::を参照)。

     インタラクティブな呼び出しでは、MOVE-COUNTには数プレフィクス引数が
     セットされる。

 -- Command: widen
     この関数は、カレントバッファーにたいするすべてのナローイングをキャ
     ンセルする。これは“ワイドニング(widening)”と呼ばれる。これは、以下
     の式と等価である:

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Function: buffer-narrowed-p
     この関数は、そのバッファーがナローされていれば非‘nil’、それ以外は
     ‘nil’をリターンする。

 -- Special Form: save-restriction body...
     このスペシャルフォームは、アクセス可能範囲のカレントのバインドを保
     存してBODYを評価し、以前に有効だったナローイング(またはナローイング
     のない状態)と同じ状態になるよう最後に保存されたバインドをリストアす
     る。ナローイングの状態は、‘throw’またはエラーを通じたアブノーマル
     exit(*note Nonlocal Exits::を参照)イベント内においても、リストアさ
     れる。したがって、この構成は一時的にバッファーをナローする明快な手
     段である。

     ‘save-restriction’がリターンする値は、BODY内の最後のフォームのリタ
     ーン値、またはBODYフォームが与えられなければ‘nil’である。

     *注意:* ‘save-restriction’使用時は間違いを起こしやすい。これを試み
     る前にここでの説明全体を通読すること。

     BODYがカレントバッファーを変更する場合でも、‘save-restriction’は依
     然として元のバッファー(その制限が保存されたバッファー)上の制限をリ
     ストアするが、カレントバッファー自体はリストアしない。

     ‘save-restriction’は、ポイントとマークを_リストアしない_。これを行
     うには‘save-excursion’を使用する。‘save-restriction’と
     ‘save-excursion’の両方を共に使用するなら、始め(外側)に
     ‘save-excursion’を記述すること。それ以外では、一時的なナローイング
     影響下で古いポイント値がリストアされる。古いポイント値が一時的なナ
     ローイング境界外なら、それを実際にリストアするのは失敗するだろう。

     以下は、‘save-restriction’の正しい使い方の簡単な例である:

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo★
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo★
          ---------- Buffer: foo ----------


File: elisp,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

30 Markers
**********

“マーカー(marker)”とは、あるバッファー内で取り囲んでいるテキストにたいし
て相対的な位置を指定するために使用されるオブジェクトです。テキストが挿入
または削除されると常に、マーカーは自動的にそのバッファーの先頭からのオフ
セットを自動的に変更して、自身の左右にある文字の間に留まります。

* Menu:

* Overview of Markers::      マーカー構成要素と再配置方法。
* Predicates on Markers::    オブジェクトがマーカーか否かのテスト。
* Creating Markers::         空マーカーや特定箇所のマーカーの作成。
* Information from Markers::  マーカーのバッファーや文字位置を探す。
* Marker Insertion Types::   マーカーが指す位置への挿入時にマーカーを再配置する2つの方法。
* Moving Markers::           新たなバッファーや位置にマーカーを移動する。
* The Mark::                 マーカーによる"マーク"の実装方法。
* The Region::               "リージョン"へのアクセス方法。


File: elisp,  Node: Overview of Markers,  Next: Predicates on Markers,  Up: Markers

30.1 Overview of Markers
========================

マーカーは、バッファーとそのバッファー内の位置を指定します。マーカーは、
位置を要求する関数内において、位置を表すために整数と同じようにして使用す
ることができます。その場合、そのマーカーのバッファーは、通常は無視されま
す。この方法で使用されるマーカーは通常、その関数が処理するバッファー内の
位置を指しますが、それは完全にプログラマーの責任です。位置についての完全
な説明は、*note Positions::を参照してください。

   マーカーはマーカー位置(marker position)、マーカーバッファー(marker
buffer)、挿入タイプ(insertion type)という3つの属性をもちます。マーカー位
置は、そのバッファー内の位置としてのマーカーと、(その時点において)等しい
整数です。しかし、マーカー位置はマーカー生存期間中に変化し得るものであり
、頻繁に変化されます。バッファー内でのテキストの挿入や削除で、マーカーは
再配置されます。マーカー前後の2文字以外の場所で挿入や削除がおこなわれて
も、マーカー位置はその2文字間に留まるというのが、このアイデアです。再配
置により、マーカーと等価な整数は変更されます。

   マーカー位置周辺のテキストを削除することにより、そのマーカーは削除さ
れたテキストの直前および直後にある文字の間に残されます。マーカー位置への
テキスト挿入では、マーカーは通常は新たなテキストの前か後のいずれかに置か
れます。その挿入が‘insert-before-markers’(*note Insertion::を参照)で行わ
れたものでなければ、どちらに置かれるかはマーカーの“挿入タイプ”(*note
Marker Insertion Types::を参照)に依存します。

   バッファーでの挿入と削除では、すべてのマーカーをチェックして、必要な
らそれらを再配置しなければなりません。これは、多数のマーカーをもつバッフ
ァーでの処理を遅くします。それ以上マーカーが不必要なのが確信できる場合に
は、存在しない場所も指さないようにマーカーを設定することは、この理由によ
りよいアイデアといえるでしょう。それ以上アクセスされる可能性がないマーカ
ーは、最終的には削除されます(*note Garbage Collection::を参照)。

   マーカー位置にたいして算術演算を行うことは一般的なので、それらの演算
子のほとんど(‘+’や‘-’を含む)が、引数としてマーカーに渡すことができます。
そのような場合には、マーカーはカレント位置を意味します。

   以下ではマーカー渡す作成とセットを行い、ポイントをマーカーに移動して
います:

     ;; 最初はどこも指さない新たなマーカーを作成:
     (setq m1 (make-marker))
          ⇒ #<marker in no buffer>

     ;; カレントバッファーの99と100番目の
     ;;   文字間を指すよう‘m1’をセット:
     (set-marker m1 100)
          ⇒ #<marker at 100 in markers.texi>

     ;; ここでバッファー先頭に1文字挿入:
     (goto-char (point-min))
          ⇒ 1
     (insert "Q")
          ⇒ nil

     ;; ‘m1’は適切に更新された
     m1
          ⇒ #<marker at 101 in markers.texi>

     ;; 同じ位置を指す2つのマーカーは
     ;;   ‘equal’だが‘eq’に非ず
     (setq m2 (copy-marker m1))
          ⇒ #<marker at 101 in markers.texi>
     (eq m1 m2)
          ⇒ nil
     (equal m1 m2)
          ⇒ t

     ;; マーカー使用終了時、存在しない場所を指すようセット
     (set-marker m1 nil)
          ⇒ #<marker in no buffer>


File: elisp,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Overview of Markers,  Up: Markers

30.2 Predicates on Markers
==========================

あるオブジェクトがマーカーなのか、それとも整数かマーカーのいずれかである
か確認するために、テストを行うことができます。後者のテストは、マーカーと
整数の両方にたいして機能する算術関数において有用です。

 -- Function: markerp object
     この関数は、OBJECTがマーカーなら‘nil’、それ以外は‘t’をリターンする
     。多くの関数はマーカーか整数のいずれかを受け入れるだろうが、整数は
     マーカーと異なることに注意。

 -- Function: integer-or-marker-p object
     この関数は、OBJECTが整数またはマーカーなら‘t’、それ以外は‘nil’をリ
     ターンする。

 -- Function: number-or-marker-p object
     この関数は、OBJECTが数値(整数か浮動小数点数のいずれか)またはマーカ
     ーなら‘t’、それ以外は‘nil’をリターンする。


File: elisp,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

30.3 Functions that Create Markers
==================================

マーカーを新たに作成する際は、存在しない場所、ポイントの現在位置、バッフ
ァーのアクセス可能範囲の先頭や終端、または別の与えられたマーカーと同じ箇
所を指すようにすることができます。

   以下の4つの関数はすべて、挿入タイプ‘nil’のマーカーをリターンします。
*note Marker Insertion Types::を参照してください。

 -- Function: make-marker
     この関数は、どこも指さないマーカーを新たに作成してリターンする。

          (make-marker)
               ⇒ #<marker in no buffer>

 -- Function: point-marker
     この関数は、カレントバッファーのポイント現在位置を指すマーカーを新
     たに作成してリターンする。*Note Point::を参照のこと。例は以下の
     ‘copy-marker’を参照されたい。

 -- Function: point-min-marker
     この関数は、バッファーのアクセス可能範囲の先頭を指すマーカーを新た
     に作成してリターンする。ナローイングが効力をもたなければ、これはバ
     ッファーの先頭になるだろう。*note Narrowing::を参照のこと。

 -- Function: point-max-marker
     この関数は、バッファーのアクセス可能範囲の終端を指すマーカーを新た
     に作成してリターンする。ナローイングが効力をもたなければ、これはバ
     ッファーの終端になるだろう。*note Narrowing::を参照のこと。

     以下に、このチャプターのテキストのソースファイルのバージョンを含む
     バッファーにたいして、この関数および‘point-min-marker’を使用した例
     を示す。

          (point-min-marker)
               ⇒ #<marker at 1 in markers.texi>
          (point-max-marker)
               ⇒ #<marker at 24080 in markers.texi>

          (narrow-to-region 100 200)
               ⇒ nil
          (point-min-marker)
               ⇒ #<marker at 100 in markers.texi>
          (point-max-marker)
               ⇒ #<marker at 200 in markers.texi>

 -- Function: copy-marker &optional marker-or-integer insertion-type
     引数としてマーカーを渡されると、‘copy-marker’はMARKER-OR-INTEGERが
     行うようにして、同じバッファーの同じ位置を指すマーカーを新たに作成
     してリターンする。整数を渡された場合、‘copy-marker’はカレントバッフ
     ァーの位置MARKER-OR-INTEGERを指すマーカーを新たに作成してリターンす
     る。

     新たなマーカーの挿入タイプは、引数INSERTION-TYPEにより指定される。
     *note Marker Insertion Types::を参照のこと。

          (copy-marker 0)
               ⇒ #<marker at 1 in markers.texi>

          (copy-marker 90000)
               ⇒ #<marker at 24080 in markers.texi>

     MARKERがマーカーと整数のいずれでもない場合は、エラーがシグナルされ
     る。

   2つのマーカーは、それらが同じバッファーの同じ位置、またはどちらも存在
しない場所を指す場合は、(‘eq’ではないものの)‘equal’とみなされます。

     (setq p (point-marker))
          ⇒ #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          ⇒ #<marker at 2139 in markers.texi>

     (eq p q)
          ⇒ nil

     (equal p q)
          ⇒ t


File: elisp,  Node: Information from Markers,  Next: Marker Insertion Types,  Prev: Creating Markers,  Up: Markers

30.4 Information from Markers
=============================

このセクションでは、マーカーオブジェクトの構成要素にアクセスする関数を説
明します。

 -- Function: marker-position marker
     この関数は、MARKERが指す位置、または存在しない場所なら‘nil’をリター
     ンする。

 -- Function: marker-buffer marker
     この関数は、MARKERがその内部を指すバッファー、存在しない場所を指す
     場合は‘nil’をリターンする。

          (setq m (make-marker))
               ⇒ #<marker in no buffer>
          (marker-position m)
               ⇒ nil
          (marker-buffer m)
               ⇒ nil

          (set-marker m 3770 (current-buffer))
               ⇒ #<marker at 3770 in markers.texi>
          (marker-buffer m)
               ⇒ #<buffer markers.texi>
          (marker-position m)
               ⇒ 3770


File: elisp,  Node: Marker Insertion Types,  Next: Moving Markers,  Prev: Information from Markers,  Up: Markers

30.5 Marker Insertion Types
===========================

マーカーが指す位置に直接テキストを挿入する際、そのマーカーを再配置するた
めに利用可能な手段が2つあります。そのマーカーはは挿入されたテキストの前
、あるいは後を指すことができます。マーカーの“挿入タイプ(insertion
type)”を指定することにより、マーカーがどちらを行うか指定できます。
‘insert-before-markers’を使用する場合は、マーカーの挿入タイプを無視して
、常にマーカーが挿入されたテキストの後を指すよう再配置されることに注意し
てください。

 -- Function: set-marker-insertion-type marker type
     この関数は、マーカーMARKERの挿入タイプを、TYPEにセットする。TYPEが
     ‘t’の場合、テキスト挿入時にMARKERはその位置まで進められるだろう。
     TYPEが‘nil’なら、テキスト挿入時にMARKERはそこまで進められない。

 -- Function: marker-insertion-type marker
     この関数は、MARKERのカレント挿入タイプを報告する。

   挿入タイプを指定するための引数を受け取らない、マーカーを作成する関数
のほとんどは、挿入タイプ‘nil’のマーカーを作成します。また、マークがもつ
デフォルトの挿入タイプも‘nil’です。


File: elisp,  Node: Moving Markers,  Next: The Mark,  Prev: Marker Insertion Types,  Up: Markers

30.6 Moving Marker Positions
============================

このセクションでは、既存マーカーの位置を変更する方法について説明します。
これを行う際は、そのマーカーがあなたのプログラム外部に使用されているかど
うか、もし使用されているならマーカーを移動した結果どのような影響が生じる
かを確実に理解する必要があります。さもないと、Emacsの他の部分で、混乱し
た出来事が発生するかもしれません。

 -- Function: set-marker marker position &optional buffer
     この関数は、BUFFER内でMARKERをPOSITIONに移動する。BUFFERが与えられ
     なかった場合のデフォルトは、カレントバッファーである。

     POSITIONが‘nil’、または存在しない場所を指すマーカーの場合、MARKERは
     存在しない場所を指すようにセットされる。

     リターン値はMARKERである。

          (setq m (point-marker))
               ⇒ #<marker at 4714 in markers.texi>
          (set-marker m 55)
               ⇒ #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               ⇒ #<buffer foo>
          (set-marker m 0 b)
               ⇒ #<marker at 1 in foo>

 -- Function: move-marker marker position &optional buffer
     これは‘set-marker’の別名である。


File: elisp,  Node: The Mark,  Next: The Region,  Prev: Moving Markers,  Up: Markers

30.7 The Mark
=============

バッファーはそれぞれ、“マーク(mark)”という、バッファー専用の特別なマーカ
ーをもちますバッファーが新たに作成される際、すでにこのマーカーは存在して
いますが、どこも指していません。これは、そのバッファーにはまだマークが
“存在しない”ことを意味します。それ以降のコマンドがマークをセットできます
。

   マークは、‘kill-region’や‘indent-rigidly’のような多くのコマンドにたい
して、テキスト範囲をバインドするための位置を指定します。通常これらのコマ
ンドは、ポイントとマークの間の、“リージョン(region)”と呼ばれるテキストに
作用します。リージョンを操作するコマンドを記述する場合は、マークを直接調
べず、かわりに‘r’指定とともに‘interactive’を使用してください。このように
すれば、インタラクティブな呼び出しではコマンドの引数としてポイントとマー
クの値が提供され、かつ他のLispプログラムは引数を明示的に指定できます。
*note Interactive Codes::を参照してください。

   いくつかのコマンドは、その副作用(side-effect)としてマークをセットしま
す。コマンドは、ユーザーがそれを使用する可能性がある場合のみマークをセッ
トするべきであり、決してコマンドの内部的な目的にたいして使用してはなりま
せん。たとえば‘replace-regexp’コマンドは、何らかの置換を行う前にマークに
ポイントの値をセットしますが、その理由はこれによりユーザーが置換を終えた
後、簡単にその位置に戻ることが可能になるからです。

   一度バッファー内にマークが“存在”すれば、その存在は通常は決して消える
ことはありません。しかし、Transient Markモードが有効な場合、マークが“非
アクティブ(inactive)”になることはあります。バッファーローカル変数
‘mark-active’が非‘nil’なら、それはマークがアクティブであることを意味しま
す。コマンドはマークを直接非アクティブにするために関数
‘deactivate-mark’を呼び出すことができ、変数‘deactivate-mark’を非‘nil’値
にセットすることにより、エディターコマンドループ(editor command loop)に
リターン時にマークの非アクティブ化を要求できます。

   Transient Markモードが有効な場合、通常ならポイント近傍に適用される特
定の編集コマンドは、マークがアクティブなときはかわりにリージョンに適用さ
れます。これがTransient Markモードを使用する主な動機です(他にも、マーク
アクティブ時にはリージョンのハイライトが有効になるという理由もある。
*note Display::を参照されたい)。

   マークに加えて、バッファーはそれぞれ“マークリング(mark ring)”をもって
います。これは、以前のマーク値を含むマーカーのリストです。編集コマンドが
マークを変更する際、それらのコマンドは通常はマークの旧値をマークリングに
保存するべきです。変数‘mark-ring-max’は、マークリング内のエントリー最大
数を指定します。リストがこの長さに達すると、最後の要素を削除して、新たな
要素が追加されます。

   これとは別にグローバルマークリング(global mark ring)がありますが、そ
れは少数の特定のユーザーレベルコマンドでのみ使用され、Lispプログラムとは
関連しないので、ここでは説明しません。

 -- Function: mark &optional force
     この関数は、カレントバッファーのマーク位置を整数でリターンする。そ
     のバッファー内でそれまでマークがセットされていなければ‘nil’をリター
     ンする。

     Transient Markモードが有効、かつ‘mark-even-if-inactive’が‘nil’の場
     合、マークが非アクティブなら‘mark’はエラーをシグナルする。しかし、
     FORCEが非‘nil’なら、‘mark’はマークの非アクティブ性を無視して、何に
     せよマーク位置(か‘nil’)をリターンする。

 -- Function: mark-marker
     この関数は、カレントバッファーのマークを表すマーカーをリターンする
     。これはコピーではなく、内部的に使用されるマーカーである。したがっ
     て、このマーカー位置にたいする変更は、そのバッファーのマークに直接
     影響する。それが望む効果でなければ、これを行ってはならない。

          (setq m (mark-marker))
               ⇒ #<marker at 3420 in markers.texi>
          (set-marker m 100)
               ⇒ #<marker at 100 in markers.texi>
          (mark-marker)
               ⇒ #<marker at 100 in markers.texi>

     他のマーカー同様、このマーカーを任意のバッファー位置にセットできる
     。このマーカーに、これがマークする以外のバッファーを指すようにする
     と、完全に整合性があるものの、いささか奇妙な結果を得ることになるだ
     ろう。これを行わないことを、わたしたちは推奨する!

 -- Function: set-mark position
     この関数は、マークをPOSITIONにセットして、そのマークをアクティブに
     する。マークの旧値はマークリングに_pushされない_。

     *注意:* マークが移動したことをユーザーに確認させ、かつ前のマーク位
     置が失われることを望む場合のみ、この関数を使用すること。通常は、マ
     ークセット時に古いマークは‘mark-ring’にpushされるべきである。この理
     由により、ほとんどのアプリケーションは‘set-mark’ではなく、
     ‘push-mark’および‘pop-mark’を使用するべきである。

     Emacs Lispの初心者プログラマーは、誤った用途にマークの使用を試みが
     ちである。ユーザーの利便のために位置を保存するのがマークである。編
     集コマンドは、マーク変更がコマンドのユーザーレベル機能の一部でない
     限り、マークを変更するべきではない(そして、そのような場合にはその効
     果をドキュメントするべきである)。Lispプログラムの内部的な使用のため
     に位置を記憶するためには、マークをLisp変数に格納すること。たとえば:

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point)))

 -- Function: push-mark &optional position nomsg activate
     この関数は、カレントバッファーのマークをPOSITIONにセットして、前の
     マークを‘mark-ring’にpushする。POSITIONが‘nil’の場合は、ポイントの
     値を使用する。

     関数‘push-mark’は通常、マークをアクティブに_しない_。アクティブにす
     る場合は、引数ACTIVATEに‘t’を指定する。

     NOMSGが‘nil’なら、メッセージ‘Mark set’が表示される。

 -- Function: pop-mark
     この関数は、‘mark-ring’のトップ要素をpopして、そのマークをバッファ
     ーの実際のマークにする。これはバッファー内のポイントを移動せず、
     ‘mark-ring’が空なら何も行わない。これはマークを非アクティブ化する。

 -- User Option: transient-mark-mode
     この変数が非‘nil’なら、Transient Markモードを有効にする。Transient
     Markモードでは、すべてのバッファー変更プリミティブが
     ‘deactivate-mark’をセットする。結果として、バッファーを変更するほと
     んどのコマンドも、マークを非アクティブにする。

     Transient Markモードが有効かつマークがアクティブの場合、通常はポイ
     ント近傍に適用されるコマンドの多くは、かわりにリージョンに適用され
     る。そのようなコマンドは、リージョンを処理すべきかどうかをテストす
     るために、関数‘use-region-p’を使用するべきである。*note The
     Region::を参照のこと。

     Lispプログラムは、一時的にTransient Markモードを有効にするために、
     ‘transient-mark-mode’を‘nil’でも‘t’でもない値にセットできる。値が
     ‘lambda’なら、バッファー変更のような通常ならマークを非アクティブ化
     するような操作の後、Transient Markモードを自動的にオフに切り替える
     。値が‘(only . OLDVAL)’なら、後続のコマンドがポイントを移動かつシフ
     ト変換(*note shift-translation: Key Sequence Input.を参照)されてい
     ない場合、あるいは通常はマークを非アクティブにするその他の操作の場
     合は、‘transient-mark-mode’に値OLDVALをセットする。

 -- User Option: mark-even-if-inactive
     これが非‘nil’なら、LispプログラムおよびEmacsユーザーは、たとえ非ア
     クティブでもマークを使用できる。このオプションは、Transient Markモ
     ードの動作に影響を及ぼす。このオプションが非‘nil’なら、マークの非ア
     クティブ化によりリージョンのハイライトはオフに切り替えられるが、マ
     ークを使用するコマンドは、あたかもマークがアクティブであるかのよう
     に振る舞う。

 -- Variable: deactivate-mark
     エディターコマンドがこの変数を非‘nil’にセットすると、エディターコマ
     ンドループはコマンドのリターン後に、(Transient Markモードが有効なら
     )マークを非アクティブにする。バッファーを変更するすべてのプリミティ
     ブは、コマンド終了時にマークを非アクティブにするために、
     ‘deactivate-mark’をセットする。

     コマンド終了時にマークを非アクティブにすることなくバッファーを変更
     するLispコードを記述するためには、変更を行うコードの周辺で
     ‘deactivate-mark’を‘nil’にバインドすること。たとえば:

          (let (deactivate-mark)
            (insert " "))

 -- Function: deactivate-mark &optional force
     Transient Markモードが有効、またはFORCEが非‘nil’の場合、この関数は
     マークを非アクティブにしてノーマルフック‘deactivate-mark-hook’を実
     行し、それ以外は何も行わない。

 -- Variable: mark-active
     この変数が非‘nil’なら、マークはアクティブである。この変数は、それぞ
     れのバッファーにたいして、常にローカルである。通常はポイント近傍を
     操作するコマンドが、かわりにリージョンを操作すべきかどうかを判断す
     るために、この変数の値を_使用してはならない_。その目的にたいしては
     、関数‘use-region-p’を使用すること(*note The Region::を参照)。

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     これらのノーマルフックは、マークがアクティブまたは非アクティブにな
     った際に、順次実行される。マークがアクティブで、かつリージョンが変
     更された可能性があるなら、コマンドループの最後にフック
     ‘activate-mark-hook’も実行される。

 -- Function: handle-shift-selection
     この関数は、ポイント移動コマンドの“シフト選択(shift-selection)”の動
     作を実装する。*note (emacs)Shift Selection::を参照のこと。これは、
     ‘interactive’指定に文字‘^’を含むコマンド呼び出し時は常に、そのコマ
     ンド自身を実行する前に、Emacsコマンドループにより自動的に呼び出され
     る(*note ^: Interactive Codes.を参照)。

     ‘shift-select-mode’が非‘nil’、かつカレントコマンドがシフト変換
     (*note shift-translation: Key Sequence Input.を参照)を通じて呼び出
     された場合、この関数はマークをセットして一時的にリージョンをアクテ
     ィブにする(すでにこの方法によりリージョンが一時的にアクティブにされ
     ている場合を除く)。それ以外では、リージョンが一時的にアクティブにさ
     れていれば、マークを非アクティブにして、変数‘transient-mark-mode’に
     前の値をリストアする。

 -- Variable: mark-ring
     このバッファーローカル変数の値は、もっとも最近のものが先頭となった
     、カレントバッファーの以前に保存されたマークのリストである。

          mark-ring
          ⇒ (#<marker at 11050 in markers.texi>
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     この変数の値は、‘mark-ring’の最大サイズである。これより多くのマーク
     が‘mark-ring’にpushされると、新たなマーク追加時に‘push-mark’は古い
     マークを破棄する。


File: elisp,  Node: The Region,  Prev: The Mark,  Up: Markers

30.8 The Region
===============

ポイントとマークの間のテキストは、“リージョン(region)”という名で知られて
います。さまざまな関数がポイントとマークで区切られたテキストを操作します
が、ここではリージョンそのものに特に関連する関数だけを説明します。

   以下の2つの関数は、マークが何処も指していなければエラーをシグナルしま
す。Transient Markモードが有効、かつ‘mark-even-if-inactive’が‘nil’なら、
マークが非アクティブな場合のエラーをシグナルします。

 -- Function: region-beginning
     この関数は、リージョンの先頭位置を、(整数として)リターンする。これ
     は、ポイントかマークのいずれか小さいほうの位置である。

 -- Function: region-end
     この関数は、リージョンの終端位置を、(整数として)リターンする。これ
     は、ポイントかマークのいずれか大きいほうの位置である。

   リージョンにたいして操作を行うようにデザインされたコマンドがリージョ
ンの先頭と終端を探すには、‘region-beginning’および‘region-end’を使用する
かわりに、通常は‘r’指定とともに‘interactive’を使用するべきです。これによ
り、他のLispプログラムが引数として明示的にリージョンの境界を指定できるよ
うになります。*note Interactive Codes::を参照してください。。

 -- Function: use-region-p
     この関数は、Transient Markモードが有効でマークがアクティブであり、
     かつバッファー内に有効なリージョンがあれば‘t’をリターンする。この関
     数は、マークアクティブ時にはポイント近傍のテキストのかわりにリージ
     ョンを操作するコマンドにより使用されることを意図している。

     リージョンは、それが非0のサイズをもつか、あるいはユーザーオプション
     ‘use-empty-active-region’が非‘nil’(デフォルトは‘nil’)なら有効である
     。関数‘region-active-p’は‘use-region-p’と同様だが、すべてのリージョ
     ンを有効とみなす。リージョンが空ならポイントにたいして操作を行うほ
     うが適切な場合が多いため、ほとんどの場合は‘region-active-p’を使用す
     るべきではない。


File: elisp,  Node: Text,  Next: Non-ASCII Characters,  Prev: Markers,  Up: Top

31 Text
*******

このチャプターでは、バッファー内のテキストを扱う関数を説明します。ほとん
どはカレントバッファー内のテキストにたいして検査、挿入、削除を行い、ポイ
ント位置やポイントに隣接するテキストを操作することが多々あります。その多
くはインタラクティブ(interactive: 対話的)です。テキストを変更するすべて
の関数は、その変更にたいするundo(アンドゥ、取り消し)を提供します(*note
Undo::を参照)。

   テキストに関連する関数の多くが、STARTおよびENDという名前の引数として
渡された、2つのバッファー位置により定義された、テキストのリージョンを操
作します。これらの引数は、マーカー(*note Markers::を参照)か、数値的な文
字位置(*note Positions::を参照)のいずれかであるべきです。これらの引数の
順序は関係ありません。STARTがリージョンの終端で、ENDがリージョンの先頭で
あっても、何も問題はないのです。たとえば、‘(delete-region 1 10)’と
‘(delete-region 10 1)’は等価です。STARTとENDのいずれかが、バッファーのア
クセス可能範囲の外部なら、‘args-out-of-range’エラーがシグナルされます。
インタラクティブな呼び出しでは、これらの引数にポイントとマークが使用され
ます。

   このチャプターを通じて、“テキスト(text)”とは(関係あるときは)そのプロ
パティも含めた、バッファー内の文字を意味します。ポイントは常に2つの文字
の間にあり、カーソルはポイントの後の文字上に表示されることを覚えておいて
ください。

* Menu:

* Near Point::               ポイント付近のテキストを調べる。
* Buffer Contents::          一般的な方法によってテキストを調べる。
* Comparing Text::           バッファーの部分文字列を比較する。
* Insertion::                バッファーへの新たなテキストの追加。
* Commands for Insertion::   テキスト挿入のためのユーザーレベルコマンド。
* Deletion::                 バッファーからテキストを削除する。
* User-Level Deletion::      テキスト削除のためのユーザーレベルコマンド。
* The Kill Ring::            テキスト削除時にユーザーのためにそれを保存する場所。
* Undo::                     バッファーのテキストにたいする変更の取り消し。
* Maintaining Undo::         undo情報の有効と無効。情報をどれだけ保持するか制御する方法。
* Filling::                  明示的にフィルを行う関数。
* Margins::                  フィルコマンドにたいしてマージンを指定する方法。
* Adaptive Fill::            コンテキストからフィルプレフィクスを選択するAdaptive
                               Fillモード。
* Auto Filling::             行ブレークにたいするauto-fillの実装方法。
* Sorting::                  バッファーの一部をソートする関数。
* Columns::                  水平位置の計算とその使用方法。
* Indentation::              インデントの挿入や調整のための関数。
* Case Changes::             バッファーの一部にたいする大文字小文字変換。
* Text Properties::          テキスト文字にたいするLispプロパティリストの追加。
* Substitution::             与ええられた文字の出現箇所を置換する。
* Registers::                レジスターの実装方法。レジスターに格納されたテキストや位置にアクセスする。
* Transposition::            バッファーの2つの部分を交換する。
* Decompression::            圧縮データの扱い。
* Base 64::                  Base64エンコーディングとの変換。
* Checksum/Hash::            暗号ハッシュの計算。
* Parsing HTML/XML::         HTMLおよびXMLの解析。
* Atomic Changes::           複数バッファーへの変更を"アトミック"にインストールする。
* Change Hooks::             テキスト変更時に実行する関数の指定。


File: elisp,  Node: Near Point,  Next: Buffer Contents,  Up: Text

31.1 Examining Text Near Point
==============================

ポイント付近にある文字を調べるための関数が、数多く提供されています。簡単
な関数のいくつかは、ここで説明します。*note Regexp Search::の
‘looking-at’も参照してください。

   以下の4つの関数においてバッファーの“先頭(beginning)”と“終端(end)”はそ
れぞれ、アクセス可能範囲の先頭と終端を意味します。

 -- Function: char-after &optional position
     この関数は、カレントバッファーの位置POSITION(つまり直後)の文字をリ
     ターンする。POSITIONが、この目的にたいする範囲の外にある場合、すな
     わちバッファーの先頭より前、またはバッファーの終端以降にある場合、
     値は‘nil’となる。POSITIONのデフォルトは、ポイントである。

     以下の例では、バッファーの最初の文字が‘@’であると仮定する:

          (string (char-after 1))
               ⇒ "@"

 -- Function: char-before &optional position
     この関数は、カレントバッファーの位置POSITIONの直前の文字をリターン
     する。POSITIONが、この目的にたいする範囲の外にある場合、すなわちバ
     ッファーの先頭より前、またはバッファーの終端より後にある場合、値は
     ‘nil’となる。POSITIONのデフォルトは、ポイントである。

 -- Function: following-char
     この関数は、カレントバッファーのポイントの後にある文字をリターンす
     る。これは‘(char-after (point))’と同様。ただし、ポイントがバッファ
     ー終端にある場合、‘following-char’は0をリターンする。

     ポイントが常に2文字間にあり、通常カーソルはポイント後の文字上に表示
     されることを思い出していただきたい。したがって、‘following-char’が
     リターンする文字は、カーソル上の文字となる。

     以下の例では、‘a’と‘c’の間にポイントがある。

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea★ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (string (preceding-char))
               ⇒ "a"
          (string (following-char))
               ⇒ "c"

 -- Function: preceding-char
     この関数は、カレントバッファーのポイントの前の文字をリターンする。
     上記‘following-char’の下の例を参照されたい。ポイントがバッファー先
     頭にある場合、‘preceding-char’は0をリターンする。

 -- Function: bobp
     この関数は、ポイントがバッファー先頭にあれば‘t’をリターンする。ナロ
     ーイングが効力をもつ場合、これはテキストのアクセス可能範囲の先頭を
     意味する。*note Point::の‘point-min’も参照のこと。

 -- Function: eobp
     この関数は、ポイントがバッファー終端にあれば‘t’をリターンする。ナロ
     ーイングが効力をもつ場合、これはテキストのアクセス可能範囲の終端を
     意味する。*note Point::の‘point-max’も参照のこと。

 -- Function: bolp
     この関数は、ポイントが行の先頭にあれば‘t’をリターンする。*note Text
     Lines::を参照のこと。バッファー(またはアクセス可能範囲)の先頭は、常
     に行の先頭とみなされる。

 -- Function: eolp
     この関数は、ポイントが行の終端にあれば‘t’をリターンする。*note Text
     Lines::を参照のこと。バッファー(またはアクセス可能範囲)の終端は、常
     に行の先頭とみなされる。


File: elisp,  Node: Buffer Contents,  Next: Comparing Text,  Prev: Near Point,  Up: Text

31.2 Examining Buffer Contents
==============================

このセクションでは、Lispプログラムがバッファー内の任意の範囲のテキストを
、文字列に変換するための関数を説明します。

 -- Function: buffer-substring start end
     この関数は、カレントバッファー内の位置STARTとENDで定義されるリージ
     ョンのテキストのコピーを含む文字列をリターンする。引数がバッファー
     のアクセス可能範囲内の位置でない場合、‘buffer-substring’は
     ‘args-out-of-range’エラーをリターンする。

     以下の例では、Font-Lockモードが有効でないものとする:

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
               ⇒ "This is t"
          (buffer-substring (point-max) 10)
               ⇒ "he contents of buffer foo\n"

     コピーされるテキストが何らかのテキストプロパティをもっていた場合、
     それらのプロパティが属す文字とともに文字列にコピーされる。しかし、
     バッファー内のオーバーレイ(*note Overlays::を参照)、およびそれらの
     プロパティは無視されるため、コピーされない。

     たとえば、Font-Lockモードが有効なら、以下のような結果を得るだろう:

          (buffer-substring 1 10)
               ⇒ #("This is t" 0 1 (fontified t) 1 9 (fontified t))

 -- Function: buffer-substring-no-properties start end
     これは‘buffer-substring’と同様だが、テキストプロパティはコピーせず
     、文字自体だけをコピーする点が異なる。*note Text Properties::を参照
     のこと。

 -- Function: buffer-string
     この関数は、カレントバッファーのアクセス可能範囲全体のコンテンツを
     、文字列としてリターンする。

 -- Function: filter-buffer-substring start end &optional delete
     この関数は、変数‘filter-buffer-substring-function’により指定された
     関数を使用して、STARTとENDの間のバッファーテキストをフィルターし、
     その結果をリターンする。

     デフォルトのフィルター関数は時代遅れとなったラッパーフック
     ‘filter-buffer-substring-functions’、および同様に時代遅れとなった変
     数‘buffer-substring-filters’を参照する。これら両者が‘nil’なら、バッ
     ファーから未変更のテキスト、すなわち‘buffer-substring’がリターンす
     るであろうテキストをリターンする。

     DELETEが非‘nil’なら、この関数は‘delete-and-extract-region’と同様、
     コピー後にSTARTとENDの間のテキストを削除する。

     Lispコードは、killリング、Xクリップボード、レジスターのようなユーザ
     ーがアクセス可能なデータ構造内にコピーする際は‘buffer-substring’、
     ‘buffer-substring-no-properties’、‘delete-and-extract-region’のかわ
     りにこの関数を使用するべきである。メジャーモードおよびマイナーモー
     ドは、バッファー外部にコピーするテキストを変更するために
     ‘filter-buffer-substring-function’を変更することができる。

 -- Variable: filter-buffer-substring-function
     この変数の値は、実際の処理を行うために‘filter-buffer-substring’が呼
     び出す関数である。その関数は、‘filter-buffer-substring’と同じように
     3つの引数を受けとり、それらは‘filter-buffer-substring’にドキュメン
     トされているように扱われるべきである。関数は、フィルターされたテキ
     ストをリターン(およびオプションでソーステキストを削除)すること。

以下の2つの変数は、‘filter-buffer-substring-function’により時代遅れにな
りましたが、後方互換のために依然サポートされます。

 -- Variable: filter-buffer-substring-functions
     これは時代遅れとなったラッパーフックであり、このフックのメンバーは
     FUN、START、END、DELETEの4つの引数を受け取る関数であること。FUNは
     3つの引数(START、END、DELETE)をとり、文字列をリターンする関数である
     。両者とも、引数START、END、DELETEは‘filter-buffer-substring’のとき
     と同様の意味をもつ。

     1つ目のフック関数は‘filter-buffer-substring’のデフォルトの処理と同
     じくSTARTとENDの間の(任意の‘buffer-substring-filters’により処理され
     た)バッファー部分文字列をリターンし、オプションでバッファーから元テ
     キストを削除する関数で、それがFUNに渡される。ほとんどの場合、フック
     関数はFUNを1回だけ呼び出してから、その結果にたいして自身の処理を行
     う。次のフック関数はこれと等しいFUNを受け取り、順次それが繰り返され
     ていく。実際のリターン値は、すべてのフック関数が順次処理した結果で
     ある。

 -- Variable: buffer-substring-filters
     時代遅れとなったこの変数の値は、文字列を唯一の引数ちして別の文字列
     をリターンする関数のリストであること。デフォルトの
     ‘filter-buffer-substring’関数は、バッファー部分文字列をこのリストの
     1つ目の関数に渡し、そのリターン値を次の関数に渡して、それぞれの関数
     にたいしてこれが順次繰り返される。最後の関数のリターン値は、
     ‘filter-buffer-substring-functions’に渡される。

 -- Function: current-word &optional strict really-word
     この関数は、ポイント位置またはその付近のシンボル(または単語)を、文
     字列としてリターンする。リターン値にはテキストプロパティは含まれな
     い。

     オプション引数REALLY-WORDが非‘nil’なら単語、それ以外はシンボル(単語
     文字とシンボル構成文字の両方を含む)を探す。

     オプション引数STRICTが非‘nil’の場合、ポイントは単語(またはシンボル
     )の内部にあるか隣接しなければならない。そこに単語(またはシンボル)が
     なければ、この関数は‘nil’をリターンする。STRICTが‘nil’なら、ポイン
     トと同一行にある近接する単語(またはシンボル)が許容される。

 -- Function: thing-at-point thing
     ポイントに隣接または周辺にあるTHINGを、文字列としてリターンする。

     引数THINGは、構文エンティティの種別を指定するシンボルである。可能な
     シンボルとしては‘symbol’、‘list’、‘sexp’、‘defun’、‘filename’、
     ‘url’、‘word’、‘sentence’、‘whitespace’、‘line’、‘page’、その他が含
     まれる。

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea★ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               ⇒ "Peace"
          (thing-at-point 'line)
               ⇒ "Gentlemen may cry ``Peace! Peace!,''\n"
          (thing-at-point 'whitespace)
               ⇒ nil


File: elisp,  Node: Comparing Text,  Next: Insertion,  Prev: Buffer Contents,  Up: Text

31.3 Comparing Text
===================

この関数により、最初にバッファー内のテキストを文字列内にコピーすることな
く、バッファー内のテキスト断片を比較することが可能になります。

 -- Function: compare-buffer-substrings buffer1 start1 end1 buffer2
          start2 end2
     この関数により、1つのバッファー、または2つの異なるバッファーの、2つ
     の部分文字列(substrings)を比較できる。最初の3つの引数は、バッファー
     とそのバッファー内の2つの位置を与えることにより、1つの部分文字列を
     指定する。最後の3つの引数は、同様の方法によりもう一方の部分文字列を
     指定する。BUFFER1とBUFFER2のいずれか、または両方にたいして、カレン
     トバッファーを意味する‘nil’を使用できる。

     1つ目の部分文字列が2つ目の部分文字列より小なら負、大なら正、等しけ
     れば値は0となる。結果の絶対値は、部分文字列内で最初に異なる文字のイ
     ンデックスに1を和した値である。

     ‘case-fold-search’が非‘nil’なら、この関数は大文字小文字の違いを無視
     する。テキストプロパティは常に無視される。

     カレントバッファー内にテキスト‘foobarbar haha!rara!’があるとしよう
     。そしてこの例では2つの部分文字列が‘rbar ’と‘rara!’であるとする。
     1つ目の文字列の2つ目の文字が大きいので、値は2となる。

          (compare-buffer-substrings nil 6 11 nil 16 21)
               ⇒ 2


File: elisp,  Node: Insertion,  Next: Commands for Insertion,  Prev: Comparing Text,  Up: Text

31.4 Inserting Text
===================

“挿入(insertion)”とは、バッファーへの新たなテキストの追加を意味します。
テキストはポイント位置、すなわちポイント前の文字とポイント後の文字の間に
追加されます。挿入関数は挿入されたテキストの後にポイントを残しますが、前
にポイントを残す関数もいくつかあります。前者の挿入を“ポイント後挿入
(after point)”、後者を“ポイント前挿入(before point)”と呼びます。

   挿入により、挿入位置の後にあったマーカーは、テキストを取り囲むように
移動されます(*note Markers::を参照)。マーカーは挿入箇所をさしている際は
、挿入によるマーカー再配置の有無は、そのマーカーの挿入タイプに依存します
(*note Marker Insertion Types::を参照)。‘insert-before-markers’のような
特定のスペシャル関数は、マーカーの挿入タイプとは関係なく、挿入されたテキ
ストの後にそのようなマーカーすべてを再配置します。

   カレントバッファーが読み取り専用(*note Read Only Buffers::を参照)、ま
たは読み取り専用テキスト(*note Special Properties::を参照)を挿入しようと
した場合、挿入関数はエラーをシグナルします。

   以下の関数は、文字列およびバッファーからプロパティとともにテキスト文
字をコピーします。挿入される文字は、コピー元の文字と完全に同一のプロパテ
ィをもちます。それとは対照的に、文字列やバッファーの一部ではない個別の引
数として指定された文字は、隣接するテキストからテキストプロパティを継承し
ます。

   テキストが文字列またはバッファー由来の場合、マルチバイトバッファーに
挿入するために、挿入関数はユニバイトからマルチバイトへの変換、およびその
逆も行います。しかし、たとえカレントバッファーがマルチバイトバッファーで
あったとしても、コード128から255までのユニバイトはマルチバイトに変換しま
せん。*note Converting Representations::を参照してください。

 -- Function: insert &rest args
     この関数は、文字列および/または1つ以上の文字ARGSを、カレントバッフ
     ァーのポイント位置に挿入して、ポイントを前方に移動する。別の言い方
     をすると、ポイントの前にテキストを挿入する。すべてのARGSが文字列が
     文字列と文字のいずれでもない場合は、エラーをシグナルする。値は
     ‘nil’。

 -- Function: insert-before-markers &rest args
     この関数は、文字列および/または1つ以上の文字ARGSを、カレントバッフ
     ァーのポイント位置に挿入して、ポイントを前方に移動する。すべての
     ARGSが文字列が文字列と文字のいずれでもない場合は、エラーをシグナル
     する。値は‘nil’。

     他の挿入関数と異なり、この関数は挿入されたテキストの後を指すように
     、まずマーカーが挿入位置を指すように再配置する。挿入位置からオーバ
     ーレイが開始される場合、挿入されたテキストはそのオーバーレイの外側
     に出される。空でないオーバーレイが挿入位置で終わる場合、挿入された
     テキストはそのオーバーレイの内側に入れられる。

 -- Command: insert-char character &optional count inherit
     このコマンドは、カレントバッファーのポイントの前に、CHARACTERのイン
     スタンスをCOUNT個挿入する。引数COUNTは整数、CHARACTERは文字でなけれ
     ばならない。

     インタラクティブに呼び出された際は、このコマンドはCHARACTERにたいし
     てコードポイントかUnicode名による入力を求める。*note
     (emacs)Inserting Text::を参照のこと。

     この関数は、たとえカレントバッファーがマルチバイトバッファーであっ
     ても、コード128から255のユニバイト文字をマルチバイト文字に変換しな
     い。*note Converting Representations::を参照のこと。

     INHERITが非‘nil’の場合、挿入された文字は挿入位置前後の2文字から、ス
     テッキーテキストプロパティ(sticky text properties)を継承する。*note
     Sticky Properties::を参照のこと。

 -- Function: insert-buffer-substring from-buffer-or-name &optional
          start end
     この関数は、カレントバッファーのポイント前に、バッファー
     FROM-BUFFER-OR-NAMEの一部を挿入する。挿入されるテキストは、START(を
     含む)からEND(を含まない)の間のリージョン(これらの引数のデフォルトは
     、そのバッファーのアクセス可能範囲の先頭と終端)である。この関数は
     ‘nil’をリターンする。

     以下の例では、バッファー‘bar’をカレントバッファーとしてフォームを実
     行する。バッファー‘bar’は、最初は空であるものとする。

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               ⇒ nil

          ---------- Buffer: bar ----------
          We hold these truth★
          ---------- Buffer: bar ----------

 -- Function: insert-buffer-substring-no-properties from-buffer-or-name
          &optional start end
     これは‘insert-buffer-substring’と似ているが、テキストプロパティをコ
     ピーしない点が異なる。

   テキスト挿入に加えて、隣接するテキストからテキストプロパティを継承す
る他の関数については、*note Sticky Properties::を参照のこと。インデント
関数により挿入された空白文字も、テキストプロパティを継承する。


File: elisp,  Node: Commands for Insertion,  Next: Deletion,  Prev: Insertion,  Up: Text

31.5 User-Level Insertion Commands
==================================

このセクションでは、テキスト挿入のための高レベルコマンド、ユーザーによる
使用を意図しているがLispプログラムでも有用なコマンドについて説明します。

 -- Command: insert-buffer from-buffer-or-name
     このコマンドは、FROM-BUFFER-OR-NAME(存在しなければならない)のアクセ
     ス可能範囲全体を、カレントバッファーのポイントの後に挿入する。マー
     クは挿入されたテキストの後に残される。値は‘nil’。

 -- Command: self-insert-command count
     このコマンドは、タイプされた最後の文字を挿入する。これをポイント前
     でCOUNT回繰り返して、‘nil’をリターンする。ほとんどのプリント文字が
     、このコマンドにバインドされる。通常の使用では、
     ‘self-insert-command’はEmacsでもっとも頻繁に呼び出される関数だが、
     Lispプログラムではそれをキーマップにインストールする場合を除き、使
     用されるのは稀である。

     インタラクティブな呼び出しでは、COUNTは数プレフィクス引数である。

     自己挿入では、入力文字は‘translation-table-for-input’を通じて変換さ
     れる。*note Translation of Characters::を参照のこと。

     これは、入力文字がテーブル‘auto-fill-chars’内にあり、
     ‘auto-fill-function’が非‘nil’なら、常にそれを呼び出す(*note Auto
     Filling::を参照)。

     このコマンドは、Abbrevモードが有効で、入力文字が単語コウセ構文をも
     たなければ、abbrev展開を行う(*note Abbrevs::および*note Syntax
     Class Table::を参照されたい)。さらに、入力文字が閉じカッコ構文
     (close parenthesis syntax)をもつ場合は、‘blink-paren-function’を呼
     び出す責任もある(*note Blinking::を参照)。

     このコマンドは最後に、フック‘post-self-insert-hook’を実行する。たと
     えば、タイプされたテキストにしたがい自動インデントするために、これ
     を使用できる。

     ‘self-insert-command’の標準的な定義にたいして、独自の定義による置き
     換えを試みてはならない。エディターコマンドループは、このコマンドを
     特別に扱うからだ。

 -- Command: newline &optional number-of-newlines
     このコマンドは、カレントバッファーのポイントの前に、改行を挿入する
     。NUMBER-OF-NEWLINESが与えられた場合は、その個数の改行文字が挿入さ
     れる。

     この関数は、カレント列数が‘fill-column’より大、かつ
     NUMBER-OF-NEWLINESが‘nil’なら、‘auto-fill-function’を呼び出す。
     ‘auto-fill-function’が通常行うのは改行の挿入ではり、最終的な結果と
     しては、ポイント位置と、その行のより前方の位置という、2つの異なる箇
     所に改行を挿入する。NUMBER-OF-NEWLINESが非‘nil’なら、‘newline’は
     auto-fillを行わない。

     このコマンドは、左マージンが0でなければ、左マージンにインデントする
     。*note Margins::を参照のこと。

     リターン値は‘nil’。インタラクティブな呼び出しでは、COUNTは数プレフ
     ィクス引数である。

 -- Variable: overwrite-mode
     この変数は、overwriteモードに効力をもつかどうかを制御する。値は
     ‘overwrite-mode-textual’、‘overwrite-mode-binary’、または‘nil’であ
     ること。‘overwrite-mode-textual’はテキスト的なoverwriteモード(改行
     とタブを特別に扱う)、‘overwrite-mode-binary’はバイナリーoverwriteモ
     ード(改行とタブを普通の文字と同様に扱う)を指定する。


File: elisp,  Node: Deletion,  Next: User-Level Deletion,  Prev: Commands for Insertion,  Up: Text

31.6 Deleting Text
==================

削除とは、バッファー内のテキストの一部を、killリングに保存せずに取り除く
ことを意味します。(*note The Kill Ring::を参照)。削除されたテキストを
yankすることはできませんが、undoメカニズム(*note Undo::を参照)を使用すれ
ば再挿入が可能です。特別なケースにおいては、killリングにテキストの保存を
行う削除関数がいくつかあります。

   削除関数はすべて、カレントバッファーにたいして処理を行います。

 -- Command: erase-buffer
     この関数は、カレントバッファーのテキスト全体(アクセス可能範囲だけで
     は_ない_)を削除してバッファーが読み取り専用なら‘buffer-read-only’、
     バッファー内の一部テキストが読み取り専用の場合は‘text-read-only’を
     シグナルする。それ以外では、確認なしでテキストを削除する。リターン
     値は‘nil’。

     バッファーからの大量テキストの削除により、“バッファーが大幅に縮小さ
     れた”という理由で、通常はさらなる自動保存ふぁ抑制される。しかし
     ‘erase-buffer’は、将来のテキストが以前のテキストと関連があるのは稀
     であり、以前のテキストのサイズと比較されるべきではないというアイデ
     アにもとづき、これを行わない。

 -- Command: delete-region start end
     このコマンドは、カレントバッファー内の位置STARTからENDまでの間のテ
     キストを削除して、‘nil’をリターンする。削除されるリージョン内にポイ
     ントがある場合、リージョン削除後のポイントの値はSTARTになる。それ以
     外の場合は、マーカーが行うようにポイントはテキストを取り囲むように
     再配置される。

 -- Function: delete-and-extract-region start end
     この関数は、カレントバッファー内の位置STARTからENDまでの間のテキス
     トを削除して、削除されたテキストを含む文字列をリターンする。

     削除されるリージョン内にポイントがある場合、リージョン削除後のポイ
     ントの値はSTARTになる。それ以外の場合は、マーカーが行うようにポイン
     トはテキストを取り囲むように再配置される。

 -- Command: delete-char count &optional killp
     このコマンドは、ポイント直後のCOUNT文字、COUNTが負なら直前のCOUNT文
     字を削除する。KILLPが非‘nil’なら、削除した文字をkillリングに保存す
     る。

     インタラクティブな呼び出しでは、COUNTは数プレフィクス引数、KILLPは
     未処理プレフィクス引数(unprocessed prefix argument)である。すなわち
     、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存
     され、与えられなければ、1文字が削除され、それはkillリングに保存され
     ない。

     リターン値は常に‘nil’である。

 -- Command: delete-backward-char count &optional killp
     このコマンドは、ポイント直前のCOUNT文字、COUNTが負なら直後のCOUNT文
     字を削除する。KILLPが非‘nil’なら、削除した文字をkillリングに保存す
     る。

     インタラクティブな呼び出しでは、COUNTは数プレフィクス引数、KILLPは
     未処理プレフィクス引数(unprocessed prefix argument)である。すなわち
     、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存
     され、与えられなければ、1文字が削除され、それはkillリングに保存され
     ない。

     リターン値は常に‘nil’である。

 -- Command: backward-delete-char-untabify count &optional killp
     このコマンドは、タブをスペースに変換しながら、後方にCOUNT文字を削除
     する。次に削除する文字がタブなら、まず適正な位置を保つような数のス
     ペースに変換してから、それらのうちのスペース1つをタブのかわりに削除
     する。KILLPが非‘nil’なら、このコマンドは削除した文字をkillリングに
     保存する。

     タブからスペースへの変換は、COUNTが正の場合のみ発生する。負の場合は
     、ポイント後の−COUNT文字が、正確に削除される。

     インタラクティブな呼び出しでは、COUNTは数プレフィクス引数、KILLPは
     未処理プレフィクス引数(unprocessed prefix argument)である。すなわち
     、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存
     され、与えられなければ、1文字が削除され、それはkillリングに保存され
     ない。

     リターン値は常に‘nil’である。

 -- User Option: backward-delete-char-untabify-method
     このオプションは、‘backward-delete-char-untabify’が空白文字を扱う方
     法を指定する。可能な値には‘untabify’(タブを個数分のスペースに変換し
     てスペースを1つ削。これがデフォルト除)、‘hungry’(1コマンドでポイン
     ト前のタブとスペースすべてを削除する)、‘all’(ポイント前のタブとスペ
     ース、および改行すべてを削除する)、‘nil’(空白文字にたいして特に何も
     しない)。


File: elisp,  Node: User-Level Deletion,  Next: The Kill Ring,  Prev: Deletion,  Up: Text

31.7 User-Level Deletion Commands
=================================

このセクションでは、主にユーザーにたいして有用なものの、Lispプログラムで
も有用な、テキストを削除するための高レベルんｑコマンドを説明します。

 -- Command: delete-horizontal-space &optional backward-only
     この関数は、ポイント近辺のすべてのスペースとタブを削除する。リター
     ン値は‘nil’。

     BACKWARD-ONLYが非‘nil’の場合、この関数はポイント前のスペースとタブ
     を削除するがポイント後のスペースとタブは削除しない。

     以下の例では、各行ごとに、2番目と3番目の間にポイントを置いて、
     ‘delete-horizontal-space’を4回呼び出している。

          ---------- Buffer: foo ----------
          I ★thought
          I ★     thought
          We★ thought
          Yo★u thought
          ---------- Buffer: foo ----------

          (delete-horizontal-space)   ; Four times.
               ⇒ nil

          ---------- Buffer: foo ----------
          Ithought
          Ithought
          Wethought
          You thought
          ---------- Buffer: foo ----------

 -- Command: delete-indentation &optional join-following-p
     この関数は、ポイントのある行を、その前の行に結合(join)する。結合に
     おいては、すべての空白文字を削除、特定のケースにおいてはそれらを1つ
     のスペースに置き換える。JOIN-FOLLOWING-Pが非‘nil’なら、
     ‘delete-indentation’はかわりに後続行と結合を行う。この関数は‘nil’を
     リターンする。

     fillプレフィクスがあり、結合される2つ目の行もそのプレフィクスで始ま
     る場合、行の結合前に‘delete-indentation’はそのfillプレフィクスを削
     除する。*note Margins::を参照のこと。

     以下の例では、‘events’で始まる行にポイントがあり、前の行の末尾に1つ
     以上のスペースが存在しても、違いは生じない。

          ---------- Buffer: foo ----------
          When in the course of human
          ★    events, it becomes necessary
          ---------- Buffer: foo ----------

          (delete-indentation)
               ⇒ nil

          ---------- Buffer: foo ----------
          When in the course of human★ events, it becomes necessary
          ---------- Buffer: foo ----------

     行の結合後に、結合点に単一のスペースを残すか否かを決定するのは、関
     数‘fixup-whitespace’の責任である。

 -- Command: fixup-whitespace
     この関数は、ポイントを取り囲むすべての水平スペースを、コンテキスト
     に応じて1つのスペースまたはスペースなしに置き換える。リターン値は
     ‘nil’。

     行の先頭または末尾において、スペースの適正な数は0である。閉じカッコ
     構文(close parenthesis syntax)の前の文字、開きカッコの後の文字、式
     プレフィクス構文(expression-prefix syntax)においても、スペースの適
     正な数は0である。それ以外では、スペースの適正な数は1である。*note
     Syntax Class Table::を参照のこと。

     以下の例では、最初に1行目の単語‘spaces’の前にポイントがある状態で、
     ‘fixup-whitespace’を呼び出している。2回目の呼び出しでは、‘(’の直後
     にポイントがある。

          ---------- Buffer: foo ----------
          This has too many     ★spaces
          This has too many spaces at the start of (★   this list)
          ---------- Buffer: foo ----------

          (fixup-whitespace)
               ⇒ nil
          (fixup-whitespace)
               ⇒ nil

          ---------- Buffer: foo ----------
          This has too many spaces
          This has too many spaces at the start of (this list)
          ---------- Buffer: foo ----------

 -- Command: just-one-space &optional n
     このコマンドは、ポイントを取り囲むすべてのスペースを1つのスペース、
     またはNが指定された場合はN個のスペースで置き換える。リターン値は
     ‘nil’。

 -- Command: delete-blank-lines
     この関数は、ポイントを取り囲む空行を削除する。ポイントが前後に1行以
     上の空行がある空の行にある場合は、1行を除きそれらすべてを削除する。
     ポイントが孤立した空行にあるなら、その行を削除する。ポイントが空で
     ない行にあるなら、その直後にあるすべての空白を削除する。

     空行とは、タブまたはスペースのみを含む行として定義される。

     ‘delete-blank-lines’は‘nil’をリターンする。

 -- Command: delete-trailing-whitespace start end
     STARTとENDで定義されるリージョン内の、末尾の空白文字を削除する。

     このコマンドは、リージョン内の各行の最後の非空白文字後にある空白文
     字を削除する。

     このコマンドがバッファー全体(マークが非アクティブな状態で呼び出され
     た場合やLispからENDと‘nil’で呼び出された場合)にたいして動作する場合
     、変数‘delete-trailing-lines’が非‘nil’ならバッファーの終端行の末尾
     の行も削除する。


File: elisp,  Node: The Kill Ring,  Next: Undo,  Prev: User-Level Deletion,  Up: Text

31.8 The Kill Ring
==================

“kill関数(kill functions)”は削除関数のようにテキストを削除しますが、ユー
ザーが“yank”により再挿入できるようにそれらを保存する点が異なります。これ
らの関数のほとんどは、‘kill-’という名前をもちます。対照的に名前が
‘delete-’で始まる関数は、(たとえ削除をundoできるとしても)通常はyank用に
テキストを保存しません。それらは“削除(deletion)”関数です。

   ほとんどのkillコマンドは、主にインタラクティブな使用を意図しており、
ここでは説明しません。ここで説明するのは、そのようなコマンドの記述に使用
されるために提供される関数です。テキストをkillするために、これらのカを使
用できます。Lisp関数の内部的な目的のためにテキストの削除を要するときは、
killリング内のコンテンツに影響を与えないように、通常は削除関数を使用する
べきでしょう。*note Deletion::を参照してください。

   killされたテキストは、後のyank用に“killリング(kill ring)”内に保存され
ます。これは、直前のkillだけでなく直近のkillのいくつかを保持するリストで
す。yankがそれをサイクル順に要素をもつリストとして扱うので、これを“リン
グ(ring)”と称しています。このリストは変数‘kill-ring’に保持されており、リ
スト用の通常関数で操作可能です。このセクションで説明する、これをリングと
して扱うために特化された関数も存在します。

   特に“kill”された実体が_破壊_されてしまわないような操作を参照するとい
う理由から、“kill”という単語の使用が不適切だと考える人もいます。これは通
常の生活において、死は永遠であり“kill”された実体は生活に戻ることはないこ
とと対照的です。したがって、他の比喩表現も提案されてきました。たとえば、
“cutリング(cut ring)”という用語は、コンピューター誕生前に原稿を再配置す
るためにハサミで切り取って貼り付けていたような人に意味があるでしょう。し
かし、今となってはこの用語を変更するのは困難です。

* Menu:

* Kill Ring Concepts::       killリング内のテキストがどのように見えるか。
* Kill Functions::           テキストをkillする関数。
* Yanking::                  yankが行われる方法。
* Yank Commands::            killリングにアクセスするコマンド。
* Low-Level Kill Ring::      killリングアクセス用の関数および変数。
* Internals of Kill Ring::   killリングのデータを保持する変数。


File: elisp,  Node: Kill Ring Concepts,  Next: Kill Functions,  Up: The Kill Ring

31.8.1 Kill Ring Concepts
-------------------------

killリングは、リスト内でもっとも最近にkillされたテキストが先頭になるよう
に、killされたテキストを記録します。たとえば、短いkillリングは以下のよう
になるでしょう:

     ("some text" "a different piece of text" "even older text")

このリストのエントリー長が‘kill-ring-max’に達すると、新たなエントリー追
加により最後のエントリーが自動的に削除されます。

   killコマンドが他のコマンドと混ざり合っているときは、各killコマンドは
killリング内に新たなエントリーを作成します。連続する複数のkillコマンドは
単一のkillリングエントリーを構成します。これは1つの単位としてyankされま
す。2つ目以降の連続するkillコマンドは、最初のkillにより作成されたエント
リーにテキストを追加します。

   yankにたいしては、killリング内のただ1つのエントリーが、そのリングの
“先頭”のエントリーとなります。いくつかのyankコマンドは、異なる要素を“先
頭”に指定することにより、リングを“回転(rotate)”させます。しかしこの仮想
的回転はリスト自身を変更しません。もっとも最近のエントリーが、常にリスト
内の最初に配置されます。


File: elisp,  Node: Kill Functions,  Next: Yanking,  Prev: Kill Ring Concepts,  Up: The Kill Ring

31.8.2 Functions for Killing
----------------------------

‘kill-region’は、テキストkill用の通常サブルーチンです。この関数を呼び出
すすべてのコマンドは、“killコマンド”です(そして恐らくは名前に‘kill’が含
まれる)。‘kill-region’は新たにkillされたテキストをkillリング内の最初の要
素内に置くか、それをもっとも最近の要素に追加します。これは、前のコマンド
がkillコマンドか否かを、(‘last-command’を使用して)自動的に判別し、もし
killコマンドならkillされたテキストをもっとも最近のエントリーに追加します
。

 -- Command: kill-region start end
     この関数は、STARTとENDから定義されるリージョン内のテキストをkillす
     る。そのテキストは削除されるが、そのテキストプロパティと共にkillリ
     ングに保存される。値は常に‘nil’。

     インタラクティブな呼び出しでは、STARTとENDは、ポイントとマークにな
     る。

     バッファーまたはテキストが読み取り専用の場合、‘kill-region’は同じよ
     うにkillリングを変更後、バッファーを変更せずにエラーをシグナルする
     。これは、ユーザーが一連のkillコマンドで、読み取り専用バッファーか
     らkillリングにテキストをコピーするのに有用である。

 -- User Option: kill-read-only-ok
     このオプションが非‘nil’なら、バッファーやテキストが読み取り専用でも
     、‘kill-region’はエラーをシグナルしない。かわりに、バッファーを変更
     せずにkillリングを更新して、単にリターンする。

 -- Command: copy-region-as-kill start end
     このコマンドは、killリングにSTARTとENDで定義されるリージョン(テキス
     トプロパティを含む)を保存するが、バッファーからテキストを削除しない
     。リターン値は‘nil’。

     このコマンドは、後続のkillコマンドが同一のkillリングエントリーに追
     加しないよう、‘this-command’に‘kill-region’をセットしない。

     Lispプログラム内では、このコマンドより‘kill-new’や‘kill-append’を使
     うほうがよい。*note Low-Level Kill Ring::を参照のこと。


File: elisp,  Node: Yanking,  Next: Yank Commands,  Prev: Kill Functions,  Up: The Kill Ring

31.8.3 Yanking
--------------

yankとは、killリングからテキストを挿入するものの、単なる挿入ではないこと
を意味します。‘yank’および関連するコマンドは、テキスト挿入前に特別な処理
を施すために、‘insert-for-yank’を使用します。

 -- Function: insert-for-yank string
     この関数は‘insert’と同様に機能するが、結果をカレントバッファーに挿
     入する前に、テキストプロパティ‘yank-handler’、同様に変数
     ‘yank-handled-properties’および‘yank-excluded-properties’に応じて
     STRING内のテキストを処理する点が異なる。

 -- Function: insert-buffer-substring-as-yank buf &optional start end
     この関数は‘insert-buffer-substring’と似ているが、
     ‘yank-handled-properties’および‘yank-excluded-properties’に応じてテ
     キストを処理する点が異なる(これは‘yank-handler’プロパティを処理しな
     いが、いずれにせよバッファー内のテキストでは通常は発生しない)。

   文字列の一部またはすべてにテキストプロパティ‘yank-handler’をputした場
合、‘insert-for-yank’が文字列を挿入する方法が変更されます。文字列の別の
箇所が異なる‘yank-handler’の値をもつ場合(比較は‘eq’で行われる)、部分文字
列はそれぞれ個別に処理されます。プロパティ値は以下の形式からなる1から4要
素のリストでなければなりません(2番目以降の要素は省略されるかもしれない):

     (FUNCTION PARAM NOEXCLUDE UNDO)

   以下は、これらの要素が何を行うかです:

FUNCTION
     FUNCTIONが非‘nil’なら、‘insert’のかわりに文字列を挿入するために、挿
     入する文字列を単一の引数として、その関数が呼び出される。

PARAM
     非‘nil’のPARAMが与えられた場合、それはSTRING(または処理される
     STRINGの部分文字列)を置き換えるオブジェクトとしてFUNCTION(または
     ‘insert’)に渡される。たとえばFUNCTIONが‘yank-rectangle’なら、
     PARAMは矩形(rectangle)として挿入されるべき文字列のリストになる。

NOEXCLUDE
     非‘nil’のNOEXCLUDEが与えられた場合は、挿入される文字列にたいする
     ‘yank-handled-properties’および‘yank-excluded-properties’の通常の動
     作を無効にする。

UNDO
     非‘nil’のUNDOが与えられた場合、それはカレントオブジェクトの挿入を
     undoするために‘yank-pop’が呼び出す関数である。この関数は、カレント
     リージョンのstartとendの、2つの引数で呼び出される。FUNCTIONは
     ‘yank-undo-function’をセットすることにより、UNDOの値をオーバーライ
     ドできる。

 -- User Option: yank-handled-properties
     この変数は、yankされるテキストの状態を処理するスペシャルテキストプ
     ロパティを指定する。これは(通常の方法、または‘yank-handler’を通じた
     )テキスト挿入後、‘yank-excluded-properties’が効力をもつ前に効果を発
     揮する。

     値は、要素が‘(PROP . FUN)’であるようなalistであること。alistの各要
     素は、順番に処理される。挿入されるテキストはテキスト範囲にたいして
     、テキストプロパティがPROPと‘eq’なものがスキャンされる。そのような
     範囲には、そのプロパティの値、そのテキストの開始と終了の位置という
     、3つの引数によりFUNが呼び出される。

 -- User Option: yank-excluded-properties
     この変数の値は、挿入されるテキストから削除するための、プロパティの
     リストである。デフォルト値には、マウスに応答したりキーバインディン
     グの指定を引き起こすテキストのような、煩わしい結果をもたらすかもし
     れないプロパティが含まれる。これは、‘yank-handled-properties’の後に
     効果を発揮する。


File: elisp,  Node: Yank Commands,  Next: Low-Level Kill Ring,  Prev: Yanking,  Up: The Kill Ring

31.8.4 Functions for Yanking
----------------------------

このセクションでは、yank用の高レベルなコマンドを説明します。これらのコマ
ンドは主にユーザー用に意図されたものですが、Lispプログラム内での使用にた
いしても有用です。‘yank’および‘yank-pop’はどちらも、変数
‘yank-excluded-properties’およびテキストプロパティ‘yank-handler’にしたが
います(*note Yanking::を参照)。

 -- Command: yank &optional arg
     このコマンドは、killリングの先頭にあるテキストを、ポイントの前に挿
     入する。これは‘push-mark’(*note The Mark::を参照)を使用して、そのテ
     キストの先頭にマークをセットする。

     ARGが非‘nil’のリスト(これはユーザーがインタラクティブに数字を指定せ
     ずに‘C-u’をタイプ時に発生する)なら、‘yank’は上述のようにテキストを
     挿入するが、ポイントはyankされたテキストの前、マークはyankされたテ
     キストの後に置かれる。

     ARGが数字なら、‘yank’はARG番目に最近killされたテキスト、すなわち
     killリングリストのARG番目の要素を挿入する。この順番は、コマンドの目
     的にたいして1番目の要素としてみなされる、リスト先頭の要素から巡回的
     に数えられる。

     ‘yank’は、それが他のプログラムから提供されるテキストを使用しないか
     ぎり(使用する場合はそのテキストをkillリングにpushする)、killリング
     のコンテンツを変更しない。しかし、ARGが非1の整数の場合は、killリン
     グを転回(rotate)してyankされるテキストをリング先頭に置く。

     ‘yank’は‘nil’をリターンする。

 -- Command: yank-pop &optional arg
     このコマンドは、killリング上の正にyankされたばかりのエントリーを、
     killリングの別エントリーで置き換える。

     このコマンドは、‘yank’または別の‘yank-pop’の直後のみ許される。その
     ような際、そのリージョンにはyankにより正に挿入されたテキストが含ま
     れる。‘yank-pop’はそのテキストを削除して、killされた別のテキスト片
     をその位置に挿入する。そのテキスト片はすでにkillリング内のどこか別
     の箇所にあるので、これは削除されたテキストをkillリングに追加しない
     。しかし、新たにyankされたテキストが先頭になるよう、killリングの転
     回は行う。

     ARGが‘nil’なら、置換テキストはkillリングの1つ前の要素である。ARGが
     数字なら、置換テキストはkillリングのARG個前の要素である。ARGが負の
     場合は、より最近のkillが置換される。

     killリング内のkillされたエントリーの順序はラップする。すなわちもっ
     とも古いkillの次にもっとも新しいkill、もっとも新しいkillの前はもっ
     とも古いkillとなる。

     リターン値は常に‘nil’である。

 -- Variable: yank-undo-function
     この変数が非‘nil’の場合、関数‘yank-pop’は前の‘yank’または
     ‘yank-pop’により挿入されたテキストを削除するために、
     ‘delete-region’のかわりにこの変数の値を使用する。値は、カレントリー
     ジョンの開始と終了という、2つの引数をとる関数でなければならない。

     関数‘insert-for-yank’は、テキストプロパティ‘yank-handler’の要素
     UNDOに対応して、この変数を自動的にセットする。


File: elisp,  Node: Low-Level Kill Ring,  Next: Internals of Kill Ring,  Prev: Yank Commands,  Up: The Kill Ring

31.8.5 Low-Level Kill Ring
--------------------------

以下の関数および変数は、killリングにたいして低レベルなアクセスを提供しま
すが、それらはウィンドウシステムの選択(*note Window System Selections::を
参照)との相互作用にも留意するので、Lispプログラム内での使用に関しても依
然として有用です。

 -- Function: current-kill n &optional do-not-move
     関数‘current-kill’は、killリングの“先頭”を指すyankポインターを、(新
     しいkillから古いkillに)N個転回して、リング内のその箇所のテキストを
     リターンする。

     オプションの第2引数DO-NOT-MOVEが非‘nil’なら、‘current-kill’はyankポ
     インターを変更しない。カレントyankポインターから、N個目のkillを単に
     リターンする。

     Nが0の場合、それは最新のkillの要求を意味しており、‘current-kill’は
     killリング照会前に‘interprogram-paste-function’(以下参照)の値を呼び
     出す。その値が関数で、かつそれが文字列または複数の文字列からなるリ
     ストをリターンした場合、‘current-kill’はその文字列をkillリング上に
     pushして、最初の文字列をリターンする。これはDO-NOT-MOVEの値に関わら
     ず、‘interprogram-paste-function’がリターンする最初の文字列のkillリ
     ングエントリーを指すように、yankポインターのセットも行う。それ以外
     では、‘current-kill’はNにたいする0値を特別に扱うことはなく、yankポ
     インターが指すエントリーをリターンし、yankポインターの移動は行わな
     い。

 -- Function: kill-new string &optional replace
     この関数は、テキストSTRINGをkillリング上にpushして、yankポインター
     がそれを指すようにセットする。それが適切なら、もっとも古いエントリ
     ーを破棄する。‘interprogram-cut-function’(以下参照)の呼び出しも行う
     。

     REPLACEが非‘nil’なら、‘kill-new’はkillリング上にSTRINGをpushせずに
     、killリングの1つ目の要素をSTRINGに置き換える。

 -- Function: kill-append string before-p
     この関数は、killリング内の最初のエントリーにテキストSTRINGを追加し
     て、その結合されたエントリーを指すようにyankポインターをセットする
     。通常はそのエントリーの終端にSTRINGが追加されるが、BEFORE-Pが非
     ‘nil’ならエントリーの先頭に追加される。この関数は、
     ‘interprogram-cut-function’(以下参照)の呼び出しも行う。

 -- Variable: interprogram-paste-function
     この変数は、他のプログラムからkillリングへkillされたテキストを転送
     する方法を提供する。値は‘nil’、または引数のない関数であること。

     値が関数なら、“もっとも最近のkill”を取得するために、
     ‘current-kill’はそれを呼び出す。その関数が非‘nil’値をリターンした場
     合は、その値が“もっとも最近のkill”として使用される。‘nil’をリターン
     した場合は、killリングの先頭が使用される。

     複数選択をサポートするウィンドウシステムのサポートを容易にするため
     に、この関数は文字列のリストもリターンするかもしれない。その場合、
     1つ目の文字列が“もっとも最近のkill”として使用され、その他の文字列は
     すべて‘yank-pop’によるアクセスを容易にするために、killリング上に
     pushされる。

     この関数の通常の用途は、たとえそれが他アプリケーションに属する選択
     であっても、もっとも最近のkillとして、ウィンドウシステムのクリップ
     ボードからそれを取得することである。しかし、クリップボードのコンテ
     ンツがカレントEmacsセッション由来なら、この関数は‘nil’をリターンす
     る筈である。

 -- Variable: interprogram-cut-function
     この変数は、ウィンドウシステム使用時に、他のプログラムにkillされた
     テキストを転送する方法を提供する。値は‘nil’、または1つの引数を要求
     する関数であること。

     値が関数なら、‘kill-new’および‘kill-append’は、killリングの新たな
     1つ目要素を引数として、それを呼び出す。

     この関数の通常の用途は、新たにkillされたテキストを、ウィンドウシス
     テムのクリップボードに配すことである。*note Window System
     Selections::を参照のこと。


File: elisp,  Node: Internals of Kill Ring,  Prev: Low-Level Kill Ring,  Up: The Kill Ring

31.8.6 Internals of the Kill Ring
---------------------------------

変数‘kill-ring’は、文字列リスト形式でkillリングのコンテンツを保持します
。もっとも最近のkillが、常にこのリストの先頭になります。

   変数‘kill-ring-yank-pointer’は、CARが次のyankのテキストであるような、
killリングリスト内のリンクをpointします。これを、リングの“先頭”を識別す
ると言います。そして、‘kill-ring-yank-pointer’を異なるリンクに移動するこ
とを、“killリングの転回(rotating the kill ring)”と呼びます。yankポインタ
ーを移動する関数は、yankポインターをリスト終端から先頭、またはその逆へラ
ップするので、、killリングを“ring”と呼びます。killリングの転回は仮想的な
ものであり、‘kill-ring’の値は変更しません。

   ‘kill-ring’および‘kill-ring-yank-pointer’はどちらも、通常は値がリスト
であるようなLisp変数です。‘kill-ring-yank-pointer’の名前にある単語
“pointer”は、その変数の目的が次回yankコマンドにより使用されるリストの最
初の要素を指すことであるのを示します。

   ‘kill-ring-yank-pointer’の値は常にkillリングリスト内の1つのリンクと
‘eq’です。それが指す要素は、そのリンクのCARです。killリングを変更する
killコマンドも、この変数に‘kill-ring’の値をセットします。その効果は、新
たにkillされた先頭になるように、リングを転回することです。

   以下は、変数‘kill-ring-yank-pointer’が、killリング‘("some text" "a
different piece of text" "yet older text")’内の2番目のエントリーを指すこ
とを表すダイアグラムです。

     kill-ring                  ---- kill-ring-yank-pointer
       |                       |
       |                       v
       |     --- ---          --- ---      --- ---
        --> |   |   |------> |   |   |--> |   |   |--> nil
             --- ---          --- ---      --- ---
              |                |            |
              |                |            |
              |                |             -->"yet older text"
              |                |
              |                 --> "a different piece of text"
              |
               --> "some text"

この状態は、‘C-y’(‘yank’)の直後に‘M-y’(‘yank-pop’)を行うことにより発生し
得ます。

 -- Variable: kill-ring
     この変数は、もっとも最近にkillされたテキストが先頭になるように、
     killされたテキストのシーケンスのリストを保持する。

 -- Variable: kill-ring-yank-pointer
     この変数の値は、yankにたいして使用される、killリングの先頭にある要
     素を示す。より正確には、値は‘kill-ring’の値のtail値であり、その
     CARが‘C-y’によりyankされるはずのkill文字列となる。

 -- User Option: kill-ring-max
     この変数の値は、リング終端の要素を破棄する前に、killリングが成長し
     得る最大長である。‘kill-ring-max’のデフォルト値は60。


File: elisp,  Node: Undo,  Next: Maintaining Undo,  Prev: The Kill Ring,  Up: Text

31.9 Undo
=========

ほとんどのバッファーは、バッファーのテキストにたいして行われた変更を
undoできるように、すべての変更を記録する“undoリスト(undo list)”をもちま
す(undoリストをもたないバッファーとは通常、Emacsがundoを有用とみなさない
特殊用途のバッファーである。特に、名前がスペースで始まるバッファーはすべ
て、undo記録がデフォルトでオフになっている。*note Buffer Names::を参照さ
れたい)。バッファー内でテキストを変更するすべてのプリミティブは、undoリ
ストの先頭に自動的に要素を追加し、それは変数‘buffer-undo-list’に格納され
ます。

 -- Variable: buffer-undo-list
     このバッファーローカル変数の値は、カレントバッファーのundoリストで
     ある。値が‘t’なら、undo情報の記録を無効にする。

   以下は、undoリストが保有可能な要素の種類です:

‘POSITION’
     この種の要素は、前のポイント値を記録する。この要素をundoすることに
     より、ポイントはPOSITIONに移動する。通常のカーソル移動はどのような
     類のundo記録も作成しないが、削除操作はそのコマンド以前にポイントが
     あった場所を記録するために、このエントリーを使用する。

‘(BEG . END)’
     この種の要素は、挿入されたテキストを削除する方法を示す。挿入におい
     て、そのテキストはバッファー内の範囲BEGからENDを占める。

‘(TEXT . POSITION)’
     この種の要素は、削除されたテキストを再度挿入する方法を示す。文字列
     TEXTは、削除されたテキストそのものである。削除されたテキストを再挿
     入する位置は‘(abs POSITION)’である。POSITIONが正ならポイントがあっ
     たのは削除されたテキストの先頭、それ以外では末尾である。0個以上の
     (MARKER .  ADJUSTMENT)要素が、この要素の直後に続く。

‘(t . TIME-FLAG)’
     この種の要素は、未変更のバッファーが変更されたことを示す。
     ‘(SEC-HIGH SEC-LOW MICROSEC PICOSEC)’という形式のTIME-FLAGは、
     visitされたファイルにたいして、それが以前にvisitまたは保存されたと
     きの更新時刻(modification time)を、‘current-time’と同じ形式を用いて
     表す。*note Time of Day::を参照のこと。TIME-FLAGが0ならそのバッファ
     ーに対応するファイルがないことを、−1ならvisitされたファイルは以前は
     存在しなかったことを意味する。‘primitive-undo’は、バッファーを再度
     未変更とマークするかどうかを判断するために、これらの値を使用(ファイ
     ルの状態がTIME-FLAGのそれとマッチする場合のみ未変更とマーク)する。

‘(nil PROPERTY VALUE BEG . END)’
     この種の要素は、テキストプロパティの変更を記録する。変更をundoする
     方法は、以下のようになる:

          (put-text-property BEG END PROPERTY VALUE)

‘(MARKER . ADJUSTMENT)’
     この種の要素は、マーカーMARKERがそれを取り囲むテキストの削除により
     再配置されて、ADJUSTMENT文字位置を移動したということを記録する。
     undoリスト内の前にある要素(TEXT .  POSITION)とマーカーの位置が一致
     する場合、は、この要素をundoすることにより、MARKER − ADJUSTMENT文字
     移動する。

‘(apply FUNNAME . ARGS)’
     これは拡張可能なundoアイテムであり、引数ARGSとともにFUNNAMEを呼び出
     すことによりundoが行われる。

‘(apply DELTA BEG END FUNNAME . ARGS)’
     これは拡張可能なundoアイテムであり、BEGからENDまでに限定された範囲
     にたいして、そのバッファーのサイズをDELTA文字増加させる変更を記録す
     る。これは、引数ARGSとともにFUNNAMEを呼び出すことによりundoが行われ
     る。

     この種の要素は、それがリージョンと関係するか否かを判断することによ
     り、リージョンに限定されたundoを有効にする。

‘nil’
     この要素は境界(boundary)である。2つの境界の間にある要素を“変更グル
     ープ(change group)”と呼び、それぞれの変更グループは通常1つのキーボ
     ードコマンドに対応するとともに、undoコマンドは通常、グループを1つの
     単位として全体をundoを行う。

 -- Function: undo-boundary
     この関数は、undoリスト内に境界を配置する。このような境界ごとに
     undoコマンドは停止し、連続するundoコマンドは、より以前の境界へと
     undoを行っていく。この関数は‘nil’をリターンする。

     エディターコマンドループは、各キーシーケンス実行の直前に、1つの
     undoごとに通常は1つのコマンドがundoされるよう、自動的に
     ‘undo-boundary’を呼び出す。例外として、入力文字の自己挿入を引き起こ
     すコマンド‘self-insert-command’(*note Commands for Insertion::を参
     照)は、コマンドループにより挿入された境界を削除するかもしれない。そ
     のような自己挿入文字の1つ目の境界は許容されるが、後続する19個の自己
     挿入する入力文字は境界をもたず、20個目の自己挿入文字は境界をもつ。
     そして、自己挿入文字が続くかぎり、これが繰り返される。したがって、
     連続する文字挿入シーケンスは、グループとしてundoすることが可能であ
     る。

     他のバッファーに行われたundo可能な以前の変更が何であれ、すべてのバ
     ッファー変更は境界を追加する。これは各バッファー内で変更を行なった
     箇所で、すべてのコマンドが境界を作成することを保証する。

     この関数を明示的に呼び出すことは、あるコマンドの効果を複数単位に分
     割するために有用である。たとえば‘query-replace’は、ユーザーが個別に
     置換をundoできるように、それぞれの置換後に‘undo-boundary’を呼び出し
     ている。

 -- Variable: undo-in-progress
     この変数は通常‘nil’だが、undoコマンドはこれを‘t’にバインドする。こ
     れにより、さまざまな種類の変更フックがundoにより呼び出された際、そ
     れを告げることが可能になる。

 -- Function: primitive-undo count list
     これは、undoリストの要素のundoにたいする基本的な関数である。これは
     LISTの最初のCOUNT要素をundoして、LISTの残りをリターンする。

     ‘primitive-undo’はバッファー変更時、そのバッファーのundoリストに要
     素を追加する。undoコマンドは混乱を避けるために、undo操作シーケンス
     冒頭にundoリストの値を保存する。その後、undo操作は保存された値の使
     用および更新を行う。undoにより追加された新たな要素はこの保存値の一
     部でないので、継続するundoと干渉しない。

     この関数は、‘undo-in-progress’をバインドしない。


File: elisp,  Node: Maintaining Undo,  Next: Filling,  Prev: Undo,  Up: Text

31.10 Maintaining Undo Lists
============================

このセクションでは、与えられたバッファーにたいしてundo情報を有効、および
無効にする方法を説明します。undoリストが巨大化しないように、undoリストを
切り詰める方法も説明します。

   新たに作成されたバッファー内のundo情報記録は、開始とともに通常は有効
になります。しかしバッファー名がスペースで始まる場合、undoの記録は初期状
態では無効になっています。以下の2つの関数、または自身で
‘buffer-undo-list’をセットすることにより、undo記録の有効、または無効化を
明示的に行うことができます。

 -- Command: buffer-enable-undo &optional buffer-or-name
     このコマンドは、以降の変更をundo可能にするよう、バッファー
     BUFFER-OR-NAMEのundo情報記録を有効にする。引数が与えられない場合は
     、カレントバッファーを使用する。そのバッファー内のundo記録がすでに
     有効なら、この関数は何も行わない。リターン値は‘nil’。

     インタラクティブな呼び出しでは、BUFFER-OR-NAMEはカレントバッファー
     であり、他のバッファーを指定することはできない。

 -- Command: buffer-disable-undo &optional buffer-or-name
     この関数はBUFFER-OR-NAMEのundoリストを破棄して、それ以上のundo情報
     記録を無効にする。結果として、以前の変更および以降のすべての変更に
     たいするそれ以上のundoは不可能になる。BUFFER-OR-NAMEのundoリストが
     すでに無効なら、この関数に効果はない。

     インタラクティブな呼び出しでは、BUFFER-OR-NAMEはカレントバッファー
     となる。他のバッファーを指定することはできない。リターン値は‘nil’。

   編集が継続されるにつれ、undoリストは次第に長くなっていく。利用可能な
メモリー空間すべてを使い尽くすのを防ぐために、ガベージコレクションが
undoリストを設定可能な制限サイズに切り詰め戻す(この目的のために、undoリ
ストの“サイズ”はリストを構成するコンスセルに加えて削除された文字列により
算出される)。‘undo-limit’、‘undo-strong-limit’、‘undo-outer-limit’の3つ
の変数は、許容できるサイズの範囲を制御する。これらの変数においてサイズは
専有するバイト数で計数され、それには保存されたテキストとその他データが含
まれる。

 -- User Option: undo-limit
     これは、許容できるundoリストサイズのソフトリミットである。このサイ
     ズを超過した箇所の変更グループは、最新の変更グループ1つが保持される
     。

 -- User Option: undo-strong-limit
     これは、undoリストの許容できるサイズの上限である。このサイズを超過
     する箇所の変更グループは(その他すべてのより古い変更グループとともに
     )自身を破棄する。1つ例外があり、‘undo-outer-limit’を超過した場合は
     、最新の変更グループだけが破棄される。

 -- User Option: undo-outer-limit
     ガベージコレクション時にカレントコマンドのundo情報がこの制限を超過
     したら、Emacsはその情報を破棄して、警告を表示する。これはメモリーオ
     ーバーフローを防ぐための、最後の回避用リミットである。

 -- User Option: undo-ask-before-discard
     この変数が非‘nil’なら、undo情報の‘undo-outer-limit’超過時、Emacsは
     その情報を破棄するかどうかを、エコーエリアで尋ねる。デフォルト値は
     ‘nil’で、これは自動的な破棄を意味する。

     このオプションは、主にデバッグを意図している。これを尋ねる際、ガベ
     ージコレクションは抑制されており、もしユーザーがその問にたいして答
     えるのをあまりに長くかかるなら、Emacsがメモリーリークを起こすかもし
     れないことを意味する。


File: elisp,  Node: Filling,  Next: Margins,  Prev: Maintaining Undo,  Up: Text

31.11 Filling
=============

“フィル(fill: 充填)”とは、指定された最大幅付近(ただし超えず)に、(行ブレ
ークを移動することにより)行の長さを調整することを意味します。加えて、複
数行を“位置揃え(justify)”することもできます。位置揃えとは、スペースを挿
入して左および/または右マージンを正確に整列させることを意味します。その
幅は、変数‘fill-column’により制御されます。読みやすくするために、行の長
さは70列程度を超えないようにするべきです。

   テキストの挿入とともに自動的にテキストをフィルするAuto Fillモードを使
用できますが、既存テキストの変更では不適切にフィルされたままになるかもし
れません。その場合は、テキストを明示的にフィルしなければなりません。

   このセクションのコマンドのほとんどは、有意な値をリターンしません。フ
ィルを行うすべての関数は、カレント左マージン、カレント右マージン、カレン
ト位置揃えスタイルに留意します(*note Margins::を参照)。カレント位置揃え
スタイルが‘none’の場合、フィル関数は実際には何も行いません。

   フィル関数のいくつかは、引数JUSTIFYをもちます。これが非‘nil’なら、そ
れは何らかの類の位置揃えを要求します。特定の位置揃えスタイルを要求するた
めに‘left’、‘right’、‘full’、‘center’を指定できます。これが‘t’なら、それ
はそのテキスト部分にたいしてカレント位置揃えスタイルを使用することを意味
します(以下の‘current-justification’を参照)。その他すべての値は、
‘full’として扱われます。

   インタラクティブにフィル関数を呼び出す際、プレフィクス引数の使用は
JUSTIFYにたいして暗に値‘full’を指定します。

 -- Command: fill-paragraph &optional justify region
     このコマンドは、ポイント位置、またはその後のパラグラフ(paragraph: 段
     落)をフィルする。JUSTIFYが非‘nil’なら、同様に各行が位置揃えされる。
     これはパラグラフ境界を探すために、通常のパラグラフ移動コマンドを使
     用する。*note (emacs)Paragraphs::を参照のこと。

     もしREGIONが非‘nil’で、Transient Markモードが有効かつマークがアクテ
     ィブなら、このコマンドはカレントパラグラフのみフィルするかわりに、
     リージョン内すべてのパラグラフをフィルするために、コマンド
     ‘fill-region’を呼び出す。このコマンドがインタラクティブに呼び出され
     たとき、REGIONは‘t’である。

 -- Command: fill-region start end &optional justify nosqueeze to-eop
     このコマンドは、STARTからENDのリージョン内のすべてのパラグラフをフ
     ィルする。JUSTIFYが非‘nil’なら、同様に位置揃えも行う。

     NOSQUEEZEが非‘nil’なら、それは行ブレーク以外の空白文字を残すことを
     意味する。TO-EOPが非‘nil’の場合、それはパラグラフ終端(以下の
     ‘use-hard-newlines’が有効なら次のhard改行)までのフィルを維持するこ
     とを意味する

     変数‘paragraph-separate’は、パラグラフを分割する方法を制御する。
     *note Standard Regexps::を参照のこと。

 -- Command: fill-individual-paragraphs start end &optional justify
          citation-regexp
     このコマンドは、リージョン内の各パラグラフを、それの固有なフィルプ
     レフィクスに応じてフィルする。したがって、パラグラフの行がスペース
     でインデントされている場合、フィルされたパラグラフは同じ様式でイン
     デントされた状態に保たれるだろう。

     最初の2つの引数STARTとENDは、フィルするリージョンの先頭と終端である
     。3つ目の引数JUSTIFY、4つ目の引数CITATION-REGEXPはオプションである
     。JUSTIFYが非‘nil’なら、そのパラグラフはフィルと同様に位置揃えもさ
     れる。CITATION-REGEXPが非‘nil’なら、それはこの関数がメールメッセー
     ジを処理しているので、ヘッダーラインをフィルするべきではないことを
     意味する。CITATION-REGEXPが文字列の場合、それは正規表現として扱われ
     る。それが行の先頭にマッチすれば、その行は引用マーカー(citation
     marker)として扱われる。

     ‘fill-individual-paragraphs’は通常、インデントの変更を新たなパラグ
     ラフの開始とみなす。‘fill-individual-varying-indent’が非‘nil’の場合
     は、セパレーターラインだけがパラグラフを分割する。その場合は、最初
     の行からさらにインデントが追加されたパラグラフを処理することが可能
     になる。

 -- User Option: fill-individual-varying-indent
     この変数は、上述のように‘fill-individual-paragraphs’の動作を変更す
     る。

 -- Command: fill-region-as-paragraph start end &optional justify
          nosqueeze squeeze-after
     このコマンドは、テキストのリージョンを1つのパラグラフとみなして、そ
     れをフィルする。そのリージョンが多数のパラグラフから構成されていた
     ら、パラグラフ間の空行は削除される。JUSTIFYが非‘nil’なら、フィルと
     ともに位置揃えも行う。

     NOSQUEEZEが非‘nil’なら、それは改行以外の空白に手を加えずに残すこと
     を意味する。SQUEEZE-AFTERが非‘nil’の場合、それはリージョン内の位置
     を指定し、その位置より前にあるスペースについては標準化を行わないこ
     とを意味する。

     Adaptive Fillモードでは、このコマンドはフィルプレフィクスを選択する
     ために、デフォルトで‘fill-context-prefix’を呼び出す。*note Adaptive
     Fill::を参照のこと。

 -- Command: justify-current-line &optional how eop nosqueeze
     このコマンドは、その行が正確に‘fill-column’で終わるように、単語間に
     スペースを挿入する。リターン値は‘nil’。

     引数HOWが非‘nil’なら、それは位置揃えスタイルを明示的に指定する。指
     定できる値は‘left’、‘right’、‘full’、‘center’、または‘none’。値が
     ‘t’の場合、それは指定済みの位置揃えスタイル(以下の
     ‘current-justification’を参照)にしたがうことを意味する。‘nil’は位置
     揃え‘full’と同じ。

     EOPが非‘nil’なら、それは‘current-justification’がfull位置揃えを指定
     する場合にleft位置揃えだけを行うことを意味する。これは、パラグラフ
     最終行にたいして使用される。パラグラフ全体がfull位置揃えだったとし
     ても、最終行はfull位置揃えであるべきではない。

     NOSQUEEZEが非‘nil’なら、それは内部のスペースを変更しないことを意味
     する。

 -- User Option: default-justification
     この変数の値は、位置揃えに使用するスタイルをテキストプロパティで指
     定しないテキストにたいするスタイルを指定する。可能な値は‘left’、
     ‘right’、‘full’、‘center’、または‘none’。デフォルト値は‘left’である
     。

 -- Function: current-justification
     この関数は、ポイント周辺のフィルに使用するための、適正な位置揃えス
     タイルをリターンする。

     これは、ポイント位置のテキストプロパティ‘justification’の値、そのよ
     うなテキストプロパティが存在しなければ変数DEFAULT-JUSTIFICATIONの値
     をリターンする。しかし、“位置揃えなし”の場合は、‘none’ではなく
     ‘nil’をリターンする。

 -- User Option: sentence-end-double-space
     この変数が非‘nil’の場合、ピリオドの後の単一のスペースをセンテンスの
     終わりとみなさず、フィル関数はそのような箇所でのラインブレークを行
     わない。

 -- User Option: sentence-end-without-period
     この変数が非‘nil’なら、ピリオドなしでセンテンスは終了できる。これは
     たとえば、ピリオドなしの2連スペースでセンテンスが終わるタイ語な土に
     使用される。

 -- User Option: sentence-end-without-space
     この変数が非‘nil’なら、それは後にスペースをともなうことなくセンテン
     スを終了させ得る文字列であること。

 -- Variable: fill-paragraph-function
     この変数は、パラグラフのフィルをオーバーライドする手段を提供する。
     この値が非‘nil’なら、‘fill-paragraph’はその処理を行うためにその関数
     を呼び出す。その関数が非‘nil’値をリターンした場合、
     ‘fill-paragraph’は処理が終了したとみなして、即座にその値をリターン
     する。

     この機能の通常の用途は、プログラミング言語のモードにおいてコメント
     をフィルすることである。通常の方法でその関数がパラグラフをフィルす
     る必要がある場合は、以下のようにそれを行うことができる:

          (let ((fill-paragraph-function nil))
            (fill-paragraph arg))

 -- Variable: fill-forward-paragraph-function
     この変数は、‘fill-region’や‘fill-paragraph’のようなフィル関数が、次
     のパラグラフへ前方に移動する方法を、オーバーライドするための手段を
     提供する。値は、移動するパラグラフの数Nを唯一の引数として呼び出され
     る関数で、Nと実際に移動したパラグラフ数の差をリターンするべきである
     。この変数のデフォルト値は‘forward-paragraph’。*note
     (emacs)Paragraphs::を参照のこと。

 -- Variable: use-hard-newlines
     この変数が非‘nil’なら、フィル関数はテキストプロパティ‘hard’をもつ改
     行を削除しない。これらの“hard改行’は、パラグラフのセパレーターとし
     て機能する。*note Hard and Soft Newlines: (emacs)Hard and Soft
     Newlines.を参照のこと。


File: elisp,  Node: Margins,  Next: Adaptive Fill,  Prev: Filling,  Up: Text

31.12 Margins for Filling
=========================

 -- User Option: fill-prefix
     このバッファーローカル変数が非‘nil’なら、それは通常のテキスト行の先
     頭に出現そ、それらのテキスト行をフィルする際には無視されるべきテキ
     スト文字列を指定する。そのフィルプレフィクスで始まらない行はパラグ
     ラフの開始とみなされ、フィルプレフィクスで始まる行は、その後にスペ
     ースが追加される。フィルプレフィクスで始まりその後に追加のスペース
     がない行は、フィル可能な通常のテキスト行である。結果となるフィル済
     みの行も、フィルプレフィクスで開始される。

     もしあれば、フィルプレフィクスは左マージンのスペースの後になる。

 -- User Option: fill-column
     このバッファーローカル変数は、フィルされる行の最大幅を指定する。値
     は列数を表す整数であること。Auto Fillモード(*note Auto Filling::を
     参照)を含む、フィル、位置揃え、センタリングを行うすべてのコマンドが
     、この変数の影響を受ける。

     実際の問題として、他の人が読むためのテキストを記述する場合は、
     ‘fill-column’を70より大きくするべきではない。これにしたがわない場合
     、人が快適に読むには行が長くなり過ぎ、それは下手に記述されたテキス
     トに見えてしまうだろう。

     ‘fill-column’のデフォルト値は70である。

 -- Command: set-left-margin from to margin
     これは、FROMからTOのテキストの‘left-margin’プロパティに、値MARGINを
     セットする。Auto Fillモードが有効なら、このコマンドは新たなマージン
     にフィットするよう、リージョンの再フィルも行う。

 -- Command: set-right-margin from to margin
     これは、FROMからTOのテキストの‘right-margin’プロパティに、値
     MARGINをセットする。Auto Fillモードが有効なら、このコマンドは新たな
     マージンにフィットするよう、リージョンの再フィルも行う。

 -- Function: current-left-margin
     この関数は、ポイント周辺をフィルするために使用する、適切な左マージ
     ン値をリターンする。値はカレント行開始文字の‘left-margin’プロパティ
     の値(なければ0)と、変数‘left-margin’の値の合計。

 -- Function: current-fill-column
     この関数は、ポイント周辺のテキストをフィルするために使用する、適切
     なフィル列値をリターンする。値は、変数‘fill-column’からポイント後の
     文字の‘right-margin’プロパティの値を減じた値。

 -- Command: move-to-left-margin &optional n force
     この関数は、カレント行の左マージンにポイントを移動する。移動先の列
     は、関数‘current-left-margin’により決定される。引数Nが非‘nil’なら、
     ‘move-to-left-margin’はまずN行前方に移動する。

     FORCEが非‘nil’の場合、それは行のインデントが左マージン値とマッチし
     なければ、インデントを修正するよう指定する。

 -- Function: delete-to-left-margin &optional from to
     この関数は、FROMからTOの間のテキストから、左マージンのインデントを
     取り除く。削除するインデントの量は、‘current-left-margin’を呼び出す
     ことにより決定される。この関数が、非空白文字を削除することはない。
     FROMとTOが省略された場合のデフォルトは、そのバッファー全体である。

 -- Function: indent-to-left-margin
     この関数は、カレント行の先頭のインデントを、変数‘left-margin’に指定
     された値に調整する(これにより空白文字の挿入や削除が起こるかもしれな
     い)。Paragraph-Indent Textモード内の変数‘indent-line-function’の値
     は、この関数である。

 -- User Option: left-margin
     この変数は左マージンの基本列を指定する。Fundamentalモードでは、
     ‘RET’はこの列にインデントする。手段の如何を問わず、この変数がセット
     されると自動的にバッファーローカルになる。

 -- User Option: fill-nobreak-predicate
     この変数はメジャーモードにたいして、特定の箇所で行ブレークしないよ
     う指定する手段を提供する。値は関数のリストであること。フィルがバッ
     ファー内の特定箇所で行ブレークすると判断されるときは常に、その箇所
     にポイントを置いた状態で、これらの関数を引数なしで呼び出す。これら
     の関数のいずれ可が非‘nil’をリターンした場合は、その行のその箇所では
     行ブレークしない。


File: elisp,  Node: Adaptive Fill,  Next: Auto Filling,  Prev: Margins,  Up: Text

31.13 Adaptive Fill Mode
========================

“Adaptive Fillモード”が有効なとき、Emacsは事前定義された値を使用するので
はなく、フィルされる各パラグラフのテキストから自動的に、フィルプレフィク
スを決定します。このフィルプレフィクスはフィルの間、*note Filling::と
*note Auto Filling::で説明されているように、そのパラグラフの2行目以降の
行頭に挿入されます。

 -- User Option: adaptive-fill-mode
     この変数が非‘nil’なら、Adaptive Fillモードは有効である。デフォルト
     は‘t’。

 -- Function: fill-context-prefix from to
     この関数は、Adaptive Fillモードの肝を実装する。これはFROMからTO、通
     常はパラグラフの開始から終了にあるテキストにもとづいて、フィルプレ
     フィクスを選択する。これは、以下で説明する変数にもとづき、そのパラ
     グラフの最初の2行を調べることにより、これを行う。

     この関数は通常、文字列としてフィルプレフィクスをリターンする。しか
     しこれを行う前に、この関数はそのプレフィクスで始まる行がパラグラフ
     の開始とは見えないだろうか、最終チェックを行う(以降では特に明記しな
     い)。これが発生した場合、この関数はかわりに‘nil’をリターンすること
     により、異常を通知する。

     以下が、‘fill-context-prefix’が行う詳細である:

       1. 1行目からフィルプレフィクス候補を取得するために、(もしあれば
          )まず‘adaptive-fill-function’内の関数、次に
          ‘adaptive-fill-regexp’(以下参照)の正規表現を試みる。これらの非
          ‘nil’の最初の結果、いずれも‘nil’なら空文字列が1行目の候補とな
          る。
       2. そのパラグラフが1行だけなら、関数は見つかったプレフィクス候補
          の妥当性をテストする。その後、この関数はそれが妥当ならその候補
          を、それ以外はスペース文字列をリターンする(以下の
          ‘adaptive-fill-first-line-regexp’の説明を参照)。
       3. すでにそのパラグラフが2行以上なら、この関数は次に1行目にたいし
          て行なったのとまったく同じ方法で、2行目でプレフィクス候補を探
          す。見つからなければ‘nil’をリターンする。
       4. ここで、この関数は発見的手法により2つのプレフィクス候補を比較
          する。2行目の候補の非空白文字の並びが1行目の候補と同じなら、こ
          の関数は2行目の候補をリターンする。それ以外では、2つの候補に共
          通するもっとも長い先頭の部分文字列(これは空文字列かもしれない
          )をリターンする。

 -- User Option: adaptive-fill-regexp
     Adaptive Fillモードは、(もしあれば)行の左マージン空白文字の後から開
     始されるテキストにたいして、この正規表現をマッチする。マッチする文
     字列が、その行のフィルプレフィクス候補である。

     デフォルト値は、空白文字と特定の句読点文字が混在した文字列にマッチ
     する。

 -- User Option: adaptive-fill-first-line-regexp
     この正規表現は1行だけのパラグラフに使用され、1つの可能なフィルプレ
     フィクス候補の追加の妥当性評価として機能する。その候補は、この正規
     表現にマッチするか、‘comment-start-skip’にマッチしなければならない
     。マッチしなければ、‘fill-context-prefix’はその候補を“同じ幅”のスペ
     ース文字列に置き換える。

     この変数のデフォルト値は ‘"\\`[ \t]*\\'"’で、これは空白文字列だけに
     マッチする。このデフォルトの効果は、1行パラグラフで見つかったフィル
     プレフィクスが、常に純粋な空白文字となるよう強制することである。

 -- User Option: adaptive-fill-function
     この変数に関数をセットすることにより、自動的なフィルプレフィクス選
     択にたいして、より複雑な方法を指定することが可能になる。その関数は
     、(もしあれば)行の左マージンの後のポイントで呼び出され、かつポイン
     トを保たなければならない。その関数は、“その行”のフィルプレフィクス
     、またはプレフィクスの判断に失敗したことを意味する‘nil’のいずれかを
     リターンすること。


File: elisp,  Node: Auto Filling,  Next: Sorting,  Prev: Adaptive Fill,  Up: Text

31.14 Auto Filling
==================

Auto Fillモードは、テキスト挿入とともに自動的に行をフィルするマイナーモ
ードです。このセクションでは、Auto Fillモードにより使用されるフックを説
明します。既存テキストを明示的にフィルしたり位置揃えすることができる関数
の説明は、*note Filling::を参照してください。

   Auto Fillモードでは、テキスの一部を再フィルするために、マージンや位置
揃えを変更する関数も利用できます。*note Margins::を参照してください。

 -- Variable: auto-fill-function
     このバッファーローカル変数の値は、テーブル‘auto-fill-chars’からの文
     字の自己挿入後に呼び出される関数(引数なし)であること。‘nil’も可で、
     その場合は特に何もしない。

     Auto-Fillモードが有効なら、‘auto-fill-function’の値は
     ‘do-auto-fill’である。これは、行ブレークにたいする通常の戦略を実装
     することを唯一の目的とする関数である。

 -- Variable: normal-auto-fill-function
     この変数は、もしAuto Fillがオンのときは‘auto-fill-function’にたいし
     て使用する関数を指定する。Auto Fillの動作方法を変更するために、メジ
     ャーモードはこの変数にバッファーローカル値をセットである。

 -- Variable: auto-fill-chars
     文字が自己挿入された際に‘auto-fill-function’を呼び出す文字(ほとんど
     の言語環境においてはスペースと改行)からなる文字テーブル。


File: elisp,  Node: Sorting,  Next: Columns,  Prev: Auto Filling,  Up: Text

31.15 Sorting Text
==================

このセクションで説明するソート関数はすべて、バッファー内のテキストを再配
置し。これはリスト要素を再配置する‘sort’関数とは対照的です(*note
Rearrangement::)。これらの関数がリターンする値に意味はありません。

 -- Function: sort-subr reverse nextrecfun endrecfun &optional
          startkeyfun endkeyfun predicate
     この関数はバッファーをレコードに細分してそれらをソートする、一般的
     なテキストソートルーチンである。このセクションのコマンドのほとんど
     は、この関数を使用する。

     ‘sort-subr’が機能する方法を理解するためには、バッファーのアクセス可
     能範囲を“ソートレコード(sort records)”と呼ばれる、分離された断片に
     分割すると考えればよい。レコードは連続、あるいは非連続かもしれない
     が、オーバーラップしてはならない。各ソートレコードの一部(全体かもし
     れない)は、ソートキーとして指定される。これらソートキーによるソート
     により、レコードは再配置される。

     通常、レコードはソートキー昇順で再配置される。‘sort-subr’の1つ目の
     引数REVERSEが非‘nil’なら、レコードはソートキー降順にソートされて再
     配置される。

     ‘sort-subr’にたいする以下の4つの引数は、ソートレコード間でポイント
     を移動するために呼び出される。これらは‘sort-subr’内で頻繁に呼び出さ
     れる。

       1. NEXTRECFUNは、レコード終端のポイントで呼び出される。この関数は
          次のレコードの先頭にポイントを移動する。‘sort-subr’が呼び出さ
          れた際は、ポイント位置が1つ目のレコードの開始とみなされる。し
          たがって‘sort-subr’を呼び出す前は、通常はそのバッファーの先頭
          にポイントを移動すること。

          この関数はバッファー終端にポイントを残すことにより、それ以上の
          ソートレコードがないことを示すことができるできる。

       2. ENDRECFUNは、レコード内にあるポイントで呼び出される。これはレ
          コード終端にポイントを移動する。

       3. STARTKEYFUNは、ポイントをレコード先頭からソートキー先頭に移動
          する。この引数はオプションで、省略された場合はレコード全体がソ
          ートキーとなる。もし与えられた場合、その関数はソートキーとして
          使用する非‘nil’値、または‘nil’(ソートキーはそのバッファー内の
          ポイント位置から始まることを示す)のいずれかをリターンすること
          。後者の場合は、ソートキー終端を見るけるためにENDKEYFUNが呼び
          出される。

       4. ENDKEYFUNは、ソートキー先頭からソートキー終端にポイントを移動
          するために呼び出される。引数はオプション。STARTKEYFUNが‘nil’を
          リターンし、かつこの引数が省略(または‘nil’)の場合、そのソート
          キーはレコード終端まで拡張される。STARTKEYFUNが非‘nil’値をリタ
          ーンした場合、ENDKEYFUNは不要。

     引数PREDICATEは、キーを比較するために使用される関数である。キーが数
     字の場合のデフォルトは‘<’、それ以外では‘string<’がデフォルトである
     。

     ‘sort-subr’の例として、以下は‘sort-lines’関数の完全な定義である:

          ;; ドキュメント文字列の冒頭2行は
          ;; ユーザー閲覧時には1行となることに注意
          (defun sort-lines (reverse beg end)
            "リージョン内の行をアルファベット順にソート;\
           引数は降順を意味する
          プログラムから呼び出す場合は、以下の3つの引数がある:
          REVERSE(非nilは逆順の意)、\
          およびBEGとEND(ソートするリージョン)
          変数`sort-fold-case'は英字\
          大文字小文字の違いが
          ソート順に影響するかどうかを決定する"
            (interactive "P\nr")
            (save-excursion
              (save-restriction
                (narrow-to-region beg end)
                (goto-char (point-min))
                (let ((inhibit-field-text-motion t))
                  (sort-subr reverse 'forward-line 'end-of-line)))))

     ここで、‘forward-line’は次のレコードの先頭にポイントを移動し、
     ‘end-of-line’はレコードの終端にポイントを移動する。レコード全体をソ
     ートキーとするため、引数STARTKEYFUNおよびENDKEYFUNは渡していない。

     ‘sort-paragraphs’はほとんど同じだが、‘sort-subr’呼び出しが以下のよ
     うになる:

          (sort-subr reverse
                     (function
                      (lambda ()
                        (while (and (not (eobp))
                                    (looking-at paragraph-separate))
                          (forward-line 1))))
                     'forward-paragraph)

     ソートレコード内を指す任意のマーカーは、‘sort-subr’リターン後は無意
     味なマーカー位置のまま取り残される。

 -- User Option: sort-fold-case
     この変数が非‘nil’なら‘sort-subr’、およびその他のバッファーソート関
     数は、文字列比較時に大文字小文字の違いを無視する。

 -- Command: sort-regexp-fields reverse record-regexp key-regexp start
          end
     このコマンドは、STARTからENDの間のリージョンを、RECORD-REGEXPおよび
     KEY-REGEXPで指定されたようにアルファベット順にソートする。REVERSEが
     負の整数なら、逆順にソートする。

     アルファベット順のソートとは、2つのソートキーにたいして、それぞれの
     1つ目の文字同士、2つ目の文字同士といったように比較することにより、
     キーを比較することを意味する。文字が一致しなければ、それはソートキ
     ーが不等なことを意味する。最初の不一致箇所で文字が小さいソートキー
     が、小さいソートキーとなる。個別の文字は、Emacs文字セット内の文字コ
     ードの数値に応じて比較される。

     引数RECORD-REGEXPの値は、バッファーをソートレコードに分割する方法を
     指定する。各レコードの終端で、この正規表現にたいする検索は完了し、
     これにマッチするテキストが次のレコードとして採用される。たとえば、
     改行の前に少なくとも1つの文字がある行にマッチする正規表現‘^.+$’は、
     そのような行をソートレコードとするだろう。正規表現の構文と意味につ
     いては、*note Regular Expressions::を参照のこと。

     引数KEY-REGEXPの値は、各レコードのどの部分がソートキーかを指定する
     。KEY-REGEXPはレコード全体、またはその一部にマッチすることができる
     。後者の場合、レコードの残りの部分はソート順に影響しないが、レコー
     ドが新たな位置に移動される際は、ともに移動される。

     引数KEY-REGEXPは、RECORD-REGEXPの部分式(subexpression)、またはその
     正規表現自体にマッチしたテキストを参照できる。

     KEY-REGEXPは、以下を指定できる:

     ‘\DIGIT’
          RECORD-REGEXP内でDIGIT番目のカッコ‘\(...\)’でグループ化により
          マッチしたテキストがソートキーになる。

     ‘\&’
          レコード全体がソートキーとなる。

     正規表現
          ‘sort-regexp-fields’は、そのレコード内で正規表現にたいするマッ
          チを検索する。そのようなマッチがあれば、それがソートキーである
          。レコード内にKEY-REGEXPにたいするマッチがなければそのレコード
          は無視され、そのバッファー内でのレコードの位置は変更されないこ
          とを意味する(他のレコードがそのレコードを移動するかもしれない
          )。

     たとえば、リージョン内のすべての行にたいして、最初の単語が文字‘f’で
     始まる行をソートすることを目論む場合は、RECORD-REGEXPを‘^.*$’、
     KEY-REGEXPを‘\<f\w*\>’にセットするべきである。結果は、以下のような
     式になるだろう

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     ‘sort-regexp-fields’をインタラクティブに呼び出した場合は、ミニバッ
     ファー内でRECORD-REGEXPとKEY-REGEXPの入力を求める。

 -- Command: sort-lines reverse start end
     このコマンドは、STARTとENDの間のリージョン内の行を、アルファベット
     順にソートする。REVERSEが非‘nil’なら、逆順にソートする。

 -- Command: sort-paragraphs reverse start end
     このコマンドは、STARTとENDの間のリージョン内のパラグラフを、アルフ
     ァベット順にソートする。REVERSEが非‘nil’なら、逆順にソートする。

 -- Command: sort-pages reverse start end
     このコマンドは、STARTとENDの間のリージョン内のページを、アルファベ
     ット順にソートする。REVERSEが非‘nil’なら、逆順にソートする。

 -- Command: sort-fields field start end
     このコマンドは、STARTとENDの間のリージョン内の行にたいして、各行の
     FIELD番目のフィールドをアルファベット順に比較することに、行をソート
     する。FIELDは空白文字により区切られ、1から数えられる。FIELDが負なら
     、行の終端から−FIELD番目のフィールドでソートする。このコマンドは、
     テーブルのソートに有用である。

 -- Command: sort-numeric-fields field start end
     このコマンドは、STARTとENDの間のリージョン内の行にたいして、各行の
     FIELD番目のフィールドを数値的に比較することにより、行をソートする。
     FIELDは空白文字により区切られ、1から数えられる。リージョン内の各行
     の指定されたフィールドは、数字を含んでいなければならない。0で始まる
     数字は8進数、‘0x’で始まる数字は16進数として扱われる。

     FIELDが負なら、行の終端から−FIELD番目のフィールドでソートする。この
     コマンドは、テーブルのソートに有用である。

 -- User Option: sort-numeric-base
     この変数は、‘sort-numeric-fields’にたいして、数字を解析するための基
     本基数を指定する。

 -- Command: sort-columns reverse &optional beg end
     このコマンドは、BEGとENDの間にある行にたいして、特定の列範囲をアル
     ファベット順に比較することによりソートする。BEGとENDの列位置は、ソ
     ートが行われる列範囲にバインドされる。

     REVERSEが非‘nil’なら、逆順にソートする。

     このコマンドが普通と異なるのは、位置BEGを含む行全体と、位置ENDを含
     む行全体が、ソートされるリージョンに含まれることである。

     タブは指定された列に分割される可能性があるので、‘sort-columns’はタ
     ブを含むテキストを受け付けないことに注意。ソート前に‘M-x untabify’を
     使用して、タブをスペースに変換すること。

     可能なら、ユーティリティプログラム‘sort’を呼び出すことにより、この
     コマンドは実際に機能する。


File: elisp,  Node: Columns,  Next: Indentation,  Prev: Sorting,  Up: Text

31.16 Counting Columns
======================

列関数は、文字位置(バッファー先頭から数えた文字数)と、列位置(行先頭から
数えたスクリーン文字数)を変換する関数です。

   これら列関数は、スクリーン上占める列数に応じて、各文字を数えます。こ
れはコントロール文字は‘ctl-arrow’の値に応じて2列、または4列を、タブは
‘tab-width’の値と、タブが始まる列の位置に依存する列数を占めるものとして
数えられることを意味します。*Note Usual Display::を参照してください。

   列数計算はウィンドウ幅と水平スクロール量を無視します。結果として、列
値は任意に大きくなる可能性があります。最初(または左端)の列は0と数えられ
ます。列値は不可視性を別として、オーバーレイとテキストプロパティを無視し
ます。

 -- Function: current-column
     この関数は、左マージンを0として、列単位で数えたポイントの水平位置を
     リターンする。列の位置は、カレント行の開始からポイントまでの間の文
     字の表示上の表現すべての幅の和である。

     ‘current-column’の使用例は、*note Text Lines::にある‘count-lines’の
     説明を参照されたい。

 -- Command: move-to-column column &optional force
     この関数は、カレント行のCOLUMNにポイントを移動する。COLUMNの計算に
     は、行の開始からポイントまでの文字の表示上の表現の幅が考慮される。

     インタラクティブに呼び出された際は、COLUMNはプレフィクス数引数の値
     である。COLUMNが整数でなければエラーがシグナルされる。

     列COLUMNが、タブのような複数列を占める文字の中間にあるために列を移
     動することが不可能な場合、ポイントはその文字の終端に移動される。し
     かしFORCEが非‘nil’、かつCOLUMNがタブの中間にあるなら、
     ‘move-to-column’はタブをスペースに変換して、正確に列COLUMNに移動す
     ることができる。それ以外の複数列文字については、それらを分割する手
     段がないので、FORCE指定に関わらず、異常を引き起こす恐れがある。

     その行が列COLUMNに達するほど長くない場合にも、引数FORCEは効果をもつ
     。COLUMNが‘t’なら、その列に達するよう行端に空白を追加することを意味
     する。

     リターン値は、実際に移動した列である。


File: elisp,  Node: Indentation,  Next: Case Changes,  Prev: Columns,  Up: Text

31.17 Indentation
=================

インデント関数は、行の先頭にある空白文字の調査、移動、変更に使用されます
。行の他の箇所にある空白文字を変更できる関数も、いくつかあります。列およ
びインデントは、左マージンを0として数えられます。

* Menu:

* Primitive Indent::         インデントのカウントと挿入に使用される関数。
* Mode-Specific Indent::     異なるモード用にインデントをカスタマイズする。
* Region Indent::            リージョン内すべての行のインデント。
* Relative Indent::          前の行にもとづきカレント行をインデントする。
* Indent Tabs::              調整可能なタイプライター形式のタブストップ。
* Motion by Indent::         最初の非ブランク文字への移動。


File: elisp,  Node: Primitive Indent,  Next: Mode-Specific Indent,  Up: Indentation

31.17.1 Indentation Primitives
------------------------------

このセクションでは、インデントのカウントと挿入に使用されるプリミティブ関
数について説明します。以降のセクションの関数は、これらのプリミティブを使
用します。関連する関数については、*note Size of Displayed Text::を参照し
てください。

 -- Function: current-indentation
     この関数は、カレント行のインデント、すなわち最初の非ブランク文字の
     水平位置をリターンする。行のコンテンツ全体がブランクなら、それは行
     終端の水平位置である。

 -- Command: indent-to column &optional minimum
     この関数は、ポイントからCOLUMNに達するまで、タブとスペースでインデ
     ントを行う。MINIMUMが指定され、かつそれが非‘nil’なら、たとえ
     COLUMNを超えることが要求される場合であっても、少なくともその個数の
     スペースが挿入される。それ以外では、ポイントがすでにCOLUMNを超える
     場合、この関数は何も行わない。値は、挿入されたインデントの終端列で
     ある。

     挿入される空白文字は、周囲のテキスト(通常は先行するテキストのみ)の
     テキストプロパティを継承する。*note Sticky Properties::を参照のこと
     。

 -- User Option: indent-tabs-mode
     この変数が非‘nil’なら、インデント関数はスペースと同様、タブを挿入で
     き、それ以外ではスペースだけを挿入できる。この変数をセットすること
     により、自動的にカレントバッファー内でバッファーローカルになる。


File: elisp,  Node: Mode-Specific Indent,  Next: Region Indent,  Prev: Primitive Indent,  Up: Indentation

31.17.2 Indentation Controlled by Major Mode
--------------------------------------------

すべてのメジャーモードにとって重要な関数は、編集対象の言語にたいして正し
くインデントを行うように、<TAB>キーをカスタマイズします。このセクション
では、<TAB>キーのメカニズムと、それを制御する方法について説明します。こ
のセクションの関数は、予期せぬ値をリターンします。

 -- Command: indent-for-tab-command &optional rigid
     これはほとんどの編集用モードで、<TAB>にバインドされるコマンドである
     。これの通常の動作はカレント行のインデントだが、かわりにタブ文字の
     挿入や、リージョンのインデントを行うこともできる。

     これは以下のことを行う:

        • まずTransient Markモードが有効か、そしてリージョンがアクティブ
          かどうかをチェックする。もしそうなら、リージョン内のテキストす
          べてをインデントするために‘indent-region’を呼び出す(*note
          Region Indent::を参照)。

        • それ以外なら、‘indent-line-function’内のインデント関数が
          ‘indent-to-left-margin’の場合、または変数‘tab-always-indent’が
          挿入する文字としてタブ文字を指定する場合(以下参照)は、タブ文字
          を挿入する。

        • それ以外なら、カレント行をインデントする。これは
          ‘indent-line-function’内の関数を呼び出すことにより行われる。そ
          の行がすでにインデント済みで、かつ‘tab-always-indent’の値が
          ‘complete’(以下参照)なら、ポイント位置のテキストの補完を試みる
          。

     RIGIDが非‘nil’(インタラクティブな場合はプレフィクス引数)の場合、こ
     のコマンドが行をインデントした後、あるいはタブを挿入後、新たなイン
     デントを反映するために、このコマンドはカレント行先頭にあるバランス
     された式全体も厳正にインデントする。この引数は、コマンドがリージョ
     ンをインデントする場合は無視される。

 -- Variable: indent-line-function
     この変数の値はカレント行をインデントするために
     ‘indent-for-tab-command’、およびその他種々のインデントコマンドによ
     り使用される関数である。これは通常メジャーモードにより割り当てられ
     、たとえばLispモードはこれを‘lisp-indent-line’、Cモードは
     ‘c-indent-line’、のようにセットする。デフォルト値は
     ‘indent-relative’。*note Auto-Indentation::を参照のこと。

 -- Command: indent-according-to-mode
     このコマンドは、カレントのメジャーモードに適した方法でカレント行を
     インデントするために、‘indent-line-function’内の関数を呼び出す。

 -- Command: newline-and-indent
     この関数は改行を挿入後、メジャーモードに応じて新たな行(挿入した改行
     の次の行)をインデントする。これは‘indent-according-to-mode’を呼び出
     すことによりインデントを行う。

 -- Command: reindent-then-newline-and-indent
     このコマンドは、カレント行の再インデント、ポイント位置への改行の挿
     入、その後新たな行(挿入した改行の次の行)のインデントを行う。これは
     ‘indent-according-to-mode’を呼び出すことにより、両方の行をインデン
     トする。

 -- User Option: tab-always-indent
     この変数は、<TAB>(‘indent-for-tab-command’)コマンドの挙動のカスタマ
     イズに使用できる。値が‘t’(デフォルト)なら、コマンドは通常カレント行
     だけをインデントする。値が‘nil’なら、コマンドはポイントが左マージン
     、またはその行のインデント内ににあるときのみ、カレント行をインデン
     トし、それ以外はタブ文字を挿入する。値が‘complete’なら、コマンドは
     まずカレント行のインデントを試み、その行がすでにインデント済みなら
     ポイント位置のテキストを補完するために‘completion-at-point’を呼び出
     す(*note Completion in Buffers::を参照)。

