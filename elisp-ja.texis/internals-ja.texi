@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1993, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node GNU Emacs Internals
@appendix GNU Emacs Internals

このチャプターでは、実行可能なEmacs実行可能形式を事前ロードされたLispライブラリーとともにダンプする方法と、ストレージが割り当てられる方法、およびCプログラマーが興味をもつかもしれないGNU
Emacsの内部的な側面のいくつかを説明します。

@menu
* Building Emacs::           ダンプ済みEmacsの作成方法。
* Pure Storage::             その場かぎりの事前ロードされたLisp関数を共有する。
* Garbage Collection::       Lispオブジェクトの使用されないスペースの回収。
* Memory Usage::             これまでに作成されたLispオブジェクトの総サイズの情報。
* C Dialect::                Emacsを記述するC系言語は何か。
* Writing Emacs Primitives::  Emacs用にCコードを記述する。
* Object Internals::         バッファー、ウィンドウ、プロセスのデーラフォーマット。
* C Integer Types::          Emacs内部でCの整数型が使用される方法。
@end menu

@node Building Emacs
@section Building Emacs
@cindex building Emacs
@pindex temacs

  このセクションでは、Emacs実行可能形式のビルドに関するステップの説明をします。makefileがこれらすべてを自動的に行うので、Emacsをビイルドおよびインストールするために、この題材を知る必要はありません。この情報は、Emacs開発者にとって適切です。

   @file{src}ディレクトリー内のCソースファイルをコンパイルすることにより、@file{temacs}と呼ばれる実行可能形式ファイルが生成されます。これは@dfn{bare
impure Emacs()裸で不純なEmacs}とも呼ばれます。これにはEmacs
LispインタープリターとI/Oルーチンが含まれますが、編集コマンドは含まれません。

@cindex @file{loadup.el}
  コマンド@w{@command{temacs -l
loadup}}は@file{temacs}を実行して、それが@file{loadup.el}をロードするよう計らいます。@code{loadup}ライブラリーは、通常のEmacs編集環境をセットアップする、追加のLispライブラリーをロードします。このステップの後には、そのEmacs実行可能形式は@dfn{bare(裸)}ではなくなります。

@cindex dumping Emacs
  標準的なLispファイルのロードには若干の時間を要するので、ユーザーが直接@file{temacs}実行可能形式を実行することは、通常はありません。そのかわり、Emacsビルドの最終ステップとして、コマンド@samp{temacs
-batch -l loadup
dump}が実行されます。特別な引数@samp{dump}により、@command{temacs}は@file{emacs}と呼ばれる実行可能形式のプログラムにダンプされます。これには、標準的なLispファイルがすべて事前ロードされています。(引数@samp{-batch}は@file{temacs}がその端末上でデータの初期化を試みることを防げるので、端末情報のテーブルはダンプされたEmacsでは空になる。)

@cindex preloaded Lisp files
@vindex preloaded-file-list
  ダンプされた@file{emacs}実行可能形式(@dfn{純粋}なEmacsとも呼ばれる)が、インストールされるEmacsになります。変数@code{preloaded-file-list}には、ダンプ済みEmacsに事前ロードされるLispファイルのリストが格納されています。新たなオペレーティングシステムにEmacsをポートする際、そのOSがダンプを実装していなければ、Emacsは起動時に毎回@file{loadup.el}をロードしなければなりません。

@cindex @file{site-load.el}
  @file{site-load.el}という名前のライブラリーを記述することにより、事前ロードするファイルを追加指定できます。追加するファイルを保持するための純粋なスペース@var{n}バイトを追加するように、以下の定義

@example
#define SITELOAD_PURESIZE_EXTRA @var{n}
@end example

@noindent
でEmacsをリビルドする必要があるでしょう。@file{src/puresize.h}を参考にしてください(十分大きくなるまで、20000▽ずつ増加させる)。しかし、追加ファイルの事前ロードの優位は、マシンの高速化により減少します。現代的なマシンでは、通常はお勧めしません。

  @file{loadup.el}が@file{site-load.el}を読み込んだ後に@code{Snarf-documentation}を呼び出すことにより、それらが格納された場所のファイル@file{etc/DOC}内にある、プリミティブと事前ロードされる関数(と変数)のドキュメント文字列を探します(@ref{Definition
of Snarf-documentation,, Accessing Documentation}を参照)。

@cindex @file{site-init.el}
@cindex preloading additional functions and variables
  @file{site-init.el}という名前のライブラリー名に配置することにより、ダンプ直前に実行する他のLisp式を指定できます。このファイルは、ドキュメント文字列を見つけた後に実行されます。

  関数または変数の定義を事前ロードしたい場合には、それを行うために、3つの方法があります。それらにより定義ロードして、その後のEmacs実行時にドキュメント文字列をアクセス可能にします:

@itemize @bullet
@item
@file{etc/DOC}の生成時にそれらのファイルをスキャンするよう計らい、それらを@file{site-load.el}でロードする。

@item
ファイルを@file{site-init.el}でロードして、Emacsインストール時にLispファイルのインストール先ディレクトリーに、そのファイルをコピーする。

@item
それらの各ファイルで、ローカル変数として@code{byte-compile-dynamic-docstrings}に@code{nil}値を指定して、それらを@file{site-load.el}か@file{site-init.el}でロードする(この手法には、Emacsが毎回そのドキュメント文字列用のスペースを確保するという欠点がある)。
@end itemize

@cindex change @code{load-path} at configure time
@cindex @option{--enable-locallisppath} option to @command{configure}
  通常の未変更のEmacsでユーザーが期待する何らかの機能を変更するような何かを、@file{site-load.el}または@file{site-init.el}内に配置することはお勧めしません。あなたのサイトで通常の機能をオーバーライドしなければならないと感じた場合には、@file{default.el}でそれを行えば、ユーザーが望む場合にあなたの変更をオーバーライドできます。@ref{Startup
Summary}を参照してください。@file{site-load.el}か@file{site-init.el}のいずれかが@code{load-path}を変更する場合、その変更はダンプ後に失われます。@ref{Library
Search}を参照してください。@code{load-path}を永続的に変更するには、@command{configure}の@option{--enable-locallisppath}オプションを指定してください。

  事前ロード可能なパッケージでは、その後のEmacsスタートアップまで、特定の評価を遅延させのが必要(または便利)なことがあります。そのようなケースの大半は、カスタマイズ可能な変数の値に関するものです。たとえば@code{tutorial-directory}は、事前ロードされる@file{startup.el}内で定義される変数です。これのデフォルト値は、@code{data-directory}にもとづいてセットされます。この変数はEmacsダンプ時ではなく、スタート時に@code{data-directory}の値を必要とします。なぜならEmacs実行可能形式はダンプされたものなので、恐らく異なる場所にインストールされます。

@defun custom-initialize-delay symbol value
この関数は、次回のEmacs開始まで@var{symbol}の初期化を遅延する。通常は、カスタマイズ可能変数の@code{:initialize}プロパティとしてこの関数を指定することにより使用する(引数@var{value}はフォームCustom由来の互換性のためだけに提供されており使用しない)。
@end defun

@code{custom-initialize-delay}が提供するより一般的な機能を要するような稀なケースでは、@code{before-init-hook}を使用できます(@ref{Startup
Summary}を参照)。

@defun dump-emacs to-file from-file
@cindex unexec
この関数は、Emacsのカレント状態を、実行可能ファイル@var{to-file}にダンプする。これは@var{from-file}(通常はファイル@file{temacs})からシンボルを取得する。

すでにダンプ済みのEmacs内でこの関数を使用する場合には、@samp{-batch}でEmacsを実行しなければならない。
@end defun

@node Pure Storage
@section Pure Storage
@cindex pure storage

  Emacs Lispはユーザー作成Lispオブジェクトにたいして、@dfn{通常ストレージ(normal
storage)}と@dfn{純粋ストレージ(pure
storage)}という、2種のストレージをもちます。通常ストレージは、Emacsセッションが維持される間に、新たにデータが作成される場所です。純粋ストレージは、事前ロードされた標準Lispファイル内の、特定のデータのために使用されます。このデータは実際のEmacs使用中に決して変更されるべきではないデータです。

  純粋ストレージは、@command{temacs}が標準的な事前ローLispライブラリーのロード中だけ割り当てられます。ファイル@file{emacs}では、このメモリースペースは読み取り専用とマークされるので、そのマシン上で実行中のすべてのEmacsジョブで共有できます。純粋ストレージは拡張できません。Emacsのコンパイル時に固定された量が割り当てられ、それが事前ロードされるライブラリーにたいして不足なら、@file{temacs}はそれに収まらない部分を動的メモリーに割り当てます。結果イメージは動作するでしょうが、この状況ではメモリーリークとなるので、ガーベージコレクション(@ref{Garbage
Collection}を参照)は無効です。そのような通常なら発生しないオーバーフローは、あなたが事前ロードライブラリの追加や、標準的な事前ロードライブラリに追加を試みないかぎり発生しません。Emacsはオーバーロードの開始時に、オーバーロードに関する警告を表示するでしょう。これが発生したら、ファイル@file{src/puresize.h}内のコンパイルパラメーターを@code{SYSTEM_PURESIZE_EXTRA}を増やして、Emacsをリビルドする必要があります。

@defun purecopy object
この関数は純粋ストレージに@var{object}のコピーを作成して、それをリターンする。これは同じ文字で新たに文字列を作成することにより文字列をコピーするが、純粋ストレージではテキストプロパティはない。これはベクターとコンスセルのコンテンツを、再帰的にコピーする。シンボルのような他のオブジェクトのコピーは作成しないが、それらを未変更でリターンする。マーカーのコピーを試みると、エラーをシグナルする。

この関数は、Emacsのビルド中とダンプ中を除き、何もしない。通常は事前ロードされるLispファイル内でのみ呼び出される。
@end defun

@defvar pure-bytes-used
この変数の値は、これまでに割り当てられた純粋ストレージのバイト数である。ダンプされたEmacsでは、通常は利用可能な純粋ストレージの総量とほとんど同じであり、もしそうでないならわたしたちは事前割り当てをもっと少なくするだろう。
@end defvar

@defvar purify-flag
この変数は、@code{defun}が純粋ストレージにその関数定義のコピーを作成するべきか否かを判断する。これが非@code{nil}なら、その関数の定義は純粋ストレージにコピーされる。

このフラグは、Emacsのビルド用の基本的な関数の初回ロード中は@code{t}となる。実行可能形式としてEmacsをダンプすることにより、ダンプ前後の実際の値とは無関係に、常にこの変数に@code{nil}が書き込まれる。

実行中のEmacsで、このフラグを変更しないこと。
@end defvar

@node Garbage Collection
@section Garbage Collection

@cindex memory allocation
  プログラムがリストを作成するときや、(ライブライのロード等により)ユーザーが新しい関数を定義する際、そのデータは通常ストレージに配置されます。通常ストレージが少なくなると、Emacsはもっとメモリーを割り当てるようオペレーティングシステムに要求します。シンボル、コンスセル、小さいベクター、マーカー等のような別のタイプのLispオブジェクトは、メモリー内の個別のブロックに隔離されます(大きいベクター、長い文字列、バッファー、および他の特定の編集タイプは非常に巨大であり、1つのオブジェクトにたいして個別のブロックが割り当てられ、小さな文字列は8kバイトのブロック、小さいベクターは4kバイトのブロックにパックされる)。

@cindex vector-like objects, storage
@cindex storage of vector-like Lisp objects
  基本的なベクトではないウィンドウ、バッファー、フレームがあたかもベクターであるかのように管理されています。対応するCデータ構造体には@code{struct
vectorlike_header}フィールドが含まれ、そのメンバー@code{size}には@code{enum
pvec_type}で列挙されたサブタイプ、その構造体が含む@code{Lisp_Object}フィールドの数に関する情報、および残りのデータのサイズが含まれます。この情報は、オブジェクトのメモリーフットプリントの計算に必要であり、ベクターブロックの繰り返し処理の際のベクター割り当てコードにより使用されます。

@cindex garbage collection
  しばらくの間いくつかのストレージを使用して、(たとえば)バッファーのkillやあるオブジェクトを指す最後のポインターの削除によりそれを開放するのは、非常に一般的なことです。この放棄されたストレージを再利用するために、Emacsは@dfn{ガーベージコレクター(garbage
collector)}を提供します。ガーベージコレクターは、いまだLispプログラムからアクセス可能なすべてのLispオブジェクトを検索、マークすることにより動作します。これを開始するには、すべてのシンボル、それらの値と関連付けられている関数定義、現在スタック上にあるすべてのデータをアクセス可能と仮定します。別のアクセス可能オブジェクトを介して間接的に到達できるスベテのオブジェクトも、アクセス可能とみなされます。

  マーキングが終了して、それでもマークされないオブジェクトはすべてガーベージ(garbage:
ごみ)です。Lispプログラムかユーザーの行為かに関わらず、それらに到達する手段はもはや存在しないので、それらを参照することは不可能です。誰もそれを失うことはないので、それらのスペースは再利用されることになります。ガーベージコレクターの2つ目の((``スイープ(sweep:
一掃'')))のフェーズでは、それらの再利用を計らいます。

@c ??? Maybe add something describing weak hash tables here?

@cindex free list
  スイープフェーズは将来の割り当て用に、シンボルやマーカーと同様に、未使用のコンスセルを@dfn{フリーリスト(free
list)}上に配置します。これは、アクセス可能な文字列は少数の8kブロックを占有するように圧縮して、その後に他の8kブロックを開放します。ベクターブロックから到達不可能はベクターは、可能なかぎり最大のフリーエリアを作成するために統合し、フリーエリアが完全な4kブロックに跨がるようなら、そのブロックは開放されます。それ以外なら、そのフリーエリアはフリーリスト配列に記録されます。これは、各エントリーが同サイズのエリアのフリーリストに対応します。巨大なベクター、バッファー、その他の巨大なオブジェクトは、個別に割り当てと開放が行われます。

@cindex CL note---allocate more storage
@quotation
@b{Common Lispに関する注意:} 他のLispと異なり、GNU Emacs
Lispはフリーリストが空のときにガーベージコレクターを呼び出さない。かわりに、単にオペレーティングシステムに更なるストレージの割り当てを要求して、@code{gc-cons-threshold}バイトを使い切るまで処理を継続する。

これは特定のLispプログラムの範囲の実行直前に、明示的にガーベージコレクターを呼び出せば、その範囲の実行中はガーベージコレクターが実行されないだろうと確信できることを意味する(そのプログラム範囲が2回目のガーベージコレクションを強制するほど、多くのスペースを使用しないという前提)。
@end quotation

@deffn Command garbage-collect
このコマンドはガーベージコレクションを実行して、使用中のスペース量の情報をリターンする(前回のガーベージコレクション以降、@code{gc-cons-threshold}バイトより多いLispデータを使用した場合には、自然にガーベージコレクションが発生することもあり得る)。

@code{garbage-collect}は使用中のスペース量の情報をリストでリターンする。これの各エントリーは@samp{(@var{name}
@var{size}
@var{used})}という形式をもつ。このエントリーで@var{name}はそのエントリーが対応するオブジェクトの種類を記述するシンボル、@var{size}はそれが使用するバイト数、@var{used}はヒープ内で生きていることが解ったオブケウトの数、オプションの@var{free}は、生きていないがEmacsが将来の割り当て用に保持しているオブジェクトの数である。全体的な結果は以下のようになる:

@example
((@code{conses} @var{cons-size} @var{used-conses} @var{free-conses})
 (@code{symbols} @var{symbol-size} @var{used-symbols} @var{free-symbols})
 (@code{miscs} @var{misc-size} @var{used-miscs} @var{free-miscs})
 (@code{strings} @var{string-size} @var{used-strings} @var{free-strings})
 (@code{string-bytes} @var{byte-size} @var{used-bytes})
 (@code{vectors} @var{vector-size} @var{used-vectors})
 (@code{vector-slots} @var{slot-size} @var{used-slots} @var{free-slots})
 (@code{floats} @var{float-size} @var{used-floats} @var{free-floats})
 (@code{intervals} @var{interval-size} @var{used-intervals} @var{free-intervals})
 (@code{buffers} @var{buffer-size} @var{used-buffers})
 (@code{heap} @var{unit-size} @var{total-size} @var{free-size}))
@end example

以下に例を示す:

@example
(garbage-collect)
      @result{} ((conses 16 49126 8058) (symbols 48 14607 0)
                 (miscs 40 34 56) (strings 32 2942 2607)
                 (string-bytes 1 78607) (vectors 16 7247)
                 (vector-slots 8 341609 29474) (floats 8 71 102)
                 (intervals 56 27 26) (buffers 944 8)
                 (heap 1024 11715 2678))
@end example

以下は、各要素を説明するためのテーブルである。最後の@code{heap}エントリーはオプションであり、背景の@code{malloc}実装が@code{mallinfo}関数を提供する場合のみ与えられることに注意。

@table @var
@item cons-size
コンスセルの内部的サイズ(@code{sizeof (struct Lisp_Cons)})。

@item used-conses
使用中のコンスセルの数。

@item free-conses
オペレーティングシステムから取得したスペースにあるが、カレントで未使用のコンスセルの数。

@item symbol-size
シンボルの内部的サイズ(@code{sizeof (struct Lisp_Symbol)})。

@item used-symbols
使用中のシンボルの数。

@item free-symbols
オペレーティングシステムから取得したスペースにあるが、カレントで未使用のシンボルの数。

@item misc-size
雑多なエンティティーの内部的なサイズ。@code{sizeof (union Lisp_Misc)}は@code{enum
Lisp_Misc_Type}に列挙された最大タイプのサイズ。

@item used-miscs
使用中の雑多なエンティティーの数。これらのエンティティーにはマーカー、オーバーレイに加えて、ユーザーにとって不可視な特定オブジェクトが含まれる。

@item free-miscs
オペレーティングシステムから取得したスペースにあるが、カレントで未使用の雑多なオブジェクトの数。

@item string-size
文字列ヘッダーの内部的サイズ(@code{sizeof (struct Lisp_String)})。

@item used-strings
使用中の文字列ヘッダーの数。

@item free-strings
オペレーティングシステムから取得したスペースにあるが、カレントで未使用の文字列ヘッダーの数。

@item byte-size
これは利便性のために使用され、@code{sizeof (char)}と同じ。

@item used-bytes
すべての文字列データの総バイト数。

@item vector-size
ベクターヘッダーの内部的サイズ(@code{sizeof (struct Lisp_Vector)})。

@item used-vectors
ベクターブロックから割り当てられたベクターブロック数。

@item slot-size
ベクタースロットの内部的なサイズで、常に@code{sizeof (Lisp_Object)}と等しい。

@item used-slots
使用されているすべてのベクターのスロット数。

@item free-slots
すべてのベクターブロックのフリースロットの数。

@item float-size
浮動小数点数オブジェクトの内部的なサイズ(@code{sizeof (struct
Lisp_Float)})。(ネイティブプラットフォームの@code{float}や@code{double}と混同しないこと。)

@item used-floats
使用中の浮動小数点数の数。

@item free-floats
オペレーティングシステムから取得したスペースにあるが、カレントで未使用の浮動小数点数の数。

@item interval-size
インターバルオブジェクト(interval object)の内部的なサイズ(@code{sizeof (struct interval)})。

@item used-intervals
使用中のインターバルの数。

@item free-intervals
オペレーティングシステムから取得したスペースにあるが、カレントで未使用のインターバルの数。

@item buffer-size
バッファーの内部的なサイズ(@code{sizeof (struct
buffer)})。(@code{buffer-size}関数がリターンする値と混同しないこと。)

@item used-buffers
使用中のバッファーオブジェクトの数。これにはユーザーからは不可視のkillされたバッファー、つまりリスト@code{all_buffers}内のバッファーすべてが含まれる。

@item unit-size
ヒープスペースを計る単位で、常に1024バイトと等しい。

@item total-size
@var{unit-size}単位での総ヒープサイズ。

@item free-size
@var{unit-size}単位での、カレントで未使用のヒープスペース。
@end table

純粋スペース(@ref{Pure
Storage}を参照)内にオーバーフローがあれば、実際にガーベージコレクションを行うことは不可能なので、@code{garbage-collect}は@code{nil}をリターンする。
@end deffn

@defopt garbage-collection-messages
この変数が非@code{nil}なら、Emacsはガーベージコレクションの最初と最後にメッセージを表示する。デフォルト値は@code{nil}。
@end defopt

@defvar post-gc-hook
これはガーベージコレクションの終わりに実行される、ノーマルフックである。ガーベージコレクションは、このフックの関数の実行中は抑制されるので、慎重に記述されたい。
@end defvar

@defopt gc-cons-threshold
この変数の値は、別のガーベージコレクションをトリガーするために、ガーベージコレクション後にLispオブジェクト用に割り当てなければならない、ストレージのバイト数である。特定ノオブジェクトタイプに関する情報を取得するために、@code{garbage-collect}がリターンした結果を使用できる。バッファーのコンテンツに割り当てられたスペースは、勘定に入らない。後続のガーベージコレクションは、このthreshold(閾値)が消費されても即座には実行されず、次回にLispインタープリターが呼び出されたときのみ実行されることに注意。

thresholdの初期値は@code{GC_DEFAULT_THRESHOLD}で、これは@file{alloc.c}内で定義されている。これは@code{word_size}単位で定義されているので、デフォルトの32ビット設定では400,000800,000、64ビット設定ではになる。大きい値を指定すると、ガーベージコレクションの頻度が下る。これはガーベージコレクションにより費やされる時間を減少させるが、メモリーの総使用量は増大する。大量のLispデータを作成するプログラムの実行時には、これを行いたいと思うかもしれない。

@code{GC_DEFAULT_THRESHOLD}の1/10まで下げた小さな値を指定することにより、より頻繁にガーベージコレクションを発生させることができる。この最小値より小さい値は、後続のガーベージコレクションで、@code{garbage-collect}がthresholdを最小値に戻すときまでしか効果をもたないだろう。
@end defopt

@defopt gc-cons-percentage
この変数の値は、ガーベージコレクション発生するまでのコンス(訳注:
これは@code{gc-cons-threshold}や@code{gc-cons-percentage}の@samp{-cons-}のことで、これらの変数が定義されている@file{alloc.c}内では、Lisp方言での@samp{cons}をより一般化したメモリー割り当てプロセスのことを指すようです)の量を、カレントヒープサイズにたいする割り合いで指定する。この条件と@code{gc-cons-threshold}を並行して適用し、条件が両方満足されたときだけ、ガーベージコレクションが発生する。

ヒープサイズ増加にともない、ガーベージコレクションの処理時間は増大する。したがって、ガーベージコレクションの頻度割合を減らすのが望ましいことがある。
@end defopt

  @code{garbage-collect}がリターンする値は、データ型に分類されたLispデータノめもりー使用量を記述します。それと対照的に関数@code{memory-limit}は、Emacsがカレントで使用中の総メモリー量の情報を提供します。

@defun memory-limit
この関数は、Emacsが割り当てたメモリーの最後のバイトアドレスを1024で除した値をリターンする。その値を1024で除しているのは、Lisp整数に収まるようにするためである。

あなたのアクションがメモリー使用に与える影響について、大まかなアイデアを得るために、これを使用することができる。
@end defun

@defvar memory-full
この変数は、Lispオブジェクト用のメモリーが不足に近い状態なら@code{t}、それ以外なら@code{nil}となる。
@end defvar

@defun memory-use-counts
これはそのEmacsセッションで作成されたオブジェクト数をカウントしたリストである。これらのカウンターはそれぞれ、特定の種類のオブジェクトを数える。詳細はドキュメント文字列を参照のこと。
@end defun

@defvar gcs-done
この変数は、そのEmacsセッションでそれまでに行われたガーベージコレクションの合計回数である。
@end defvar

@defvar gc-elapsed
この変数は、そのEmacsセッションでガーベージコレクションの間に費やされた経過時間を、浮動小数点数で表した総秒数である。
@end defvar

@node Memory Usage
@section Memory Usage
@cindex memory usage

  以下の関数と変数は、Emacsが行なったメモリー割り当ての総量に関する情報を、データ型ごとに分類して提供します。これらの関数や変数と、@code{garbage-collect}がリターンする値との違いに注意してください。@code{garbage-collect}はカレントで存在するオブジェクトを数えますが、以下の関数および変数はすでに開放されたオブジェクトを含めて、すべての割り当ての数またはサイズを数えます。

@defvar cons-cells-consed
そのEmacsセッションで、それまでに割り当てられたコンスセルの総数。
@end defvar

@defvar floats-consed
そのEmacsセッションで、それまでに割り当てられた浮動小数点数の総数。
@end defvar

@defvar vector-cells-consed
そのEmacsセッションで、それまでに割り当てられたベクターセル
@end defvar

@defvar symbols-consed
そのEmacsセッションで、それまでに割り当てられたシンボルの総数。
@end defvar

@defvar string-chars-consed
そのEmacsセッションで、それまでに割り当てられた文字列の文字の総数。
@end defvar

@defvar misc-objects-consed
そのEmacsセッションで、それまでに割り当てられた雑多なオブジェクトの総数。これにはマーカー、オーバーレイに加えて、ユーザーには不可視な特定のオブジェクトが含まれる。
@end defvar

@defvar intervals-consed
そのEmacsセッションで、それまでに割り当てられたインターバルの総数。
@end defvar

@defvar strings-consed
そのEmacsセッションで、それまでに割り当てられた文字列の総数。
@end defvar

@node C Dialect
@section C Dialect
@cindex C programming language

EmacsのC部分は、C89にたいして移植性があります。@samp{<stdbool.h>}や@samp{inline}のようなC99固有の機能は、通常configure時に行われるチェックなしでは使用しておらず、Emacsのビルド手順は必要なら代替えの実装を提供します。ステートメントの後の宣言のような、その他のC99機能は代替えの提供が非常に困難なので、すべて回避されています。

そう遠くない将来のある時点で、基本となるC方言はC89からC99に変更され、最終的には間違いなくC11に変更されるでしょう。

@node Writing Emacs Primitives
@section Writing Emacs Primitives
@cindex primitive function internals
@cindex writing Emacs primitives

  Lispプリミティブとは、Cで実装されたLisp関数です。Lispから呼び出せるように、C関数インターフェースの詳細は、Cのマクロで処理されます。新たなCコードの記述のしかたを真に理解するには、ソースを読むのが唯一の方法ですが、ここではいくつかの事について説明します。

  スペシャルフォームの例として、以下は@file{eval.c}の@code{or}です(通常の関数は、同様の一般的な外観をもつ)。

@cindex garbage collection protection
@smallexample
@group
DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
  doc: /* Eval args until one of them yields non-nil, then return
that value.
The remaining args are not evalled at all.
If all args return nil, return nil.
@end group
@group
usage: (or CONDITIONS ...)  */)
  (Lisp_Object args)
@{
  register Lisp_Object val = Qnil;
  struct gcpro gcpro1;
@end group

@group
  GCPRO1 (args);
@end group

@group
  while (CONSP (args))
    @{
      val = eval_sub (XCAR (args));
      if (!NILP (val))
        break;
      args = XCDR (args);
    @}
@end group

@group
  UNGCPRO;
  return val;
@}
@end group
@end smallexample

@cindex @code{DEFUN}, C macro to define Lisp primitives
  では@code{DEFUN}マクロの引数について、詳細に説明しましょう。以下は、それらのテンプレートです:

@example
DEFUN (@var{lname}, @var{fname}, @var{sname}, @var{min}, @var{max}, @var{interactive}, @var{doc})
@end example

@table @var
@item lname
これは、関数名として定義する、Lispシンボル名である。上記例では@code{or}。

@item fname
これは、その関数のC関数名である。これはCコードでその関数を呼び出すために使用される名前である。名前は慣習として@samp{F}の後にLisp名をつけ、Lisp名のすべてのダッシュ(@samp{-})は、アンダースコアに変更する。つまりCコードから呼び出す場合は、@code{For}を呼び出す。

@item sname
これは、Lispでその関数を表すsubrオブジェクト用に、データ保持のための構造体に使用されるC変数名である。この構造体は、そのシンボルを作成してそれの定義にsubrオブジェクトを格納する初期化ルーチンにおいて、Lispシンボル名を伝達する。慣習により、これは常に@var{fname}の@samp{F}を@samp{S}に置き換えた名前になる

@item min
これは、その関数が要求する、引数の最小個数である。関数@code{or}は、最小で0個の関数を受け入れる。

@item max
これは、その関数が受け入れる引数の最大個数が定数なら、引数の最大個数である。または@code{UNEVALLED}ならそれは未評価の引数を受け取るスペシャルフォームを示し、@code{MANY}なら評価される引数の個数に制限がないことを意味する(@code{&rest}と等価)。@code{UNEVALLED}と@code{MANY}は、いずれもマクロである。@var{max}が数字ならそれは@var{min}より大きく、8より小さいこと。

@cindex interactive specification in primitives
@item interactive
これはLisp関数で@code{interactive}の引数として使用されるような、インタラクティブ仕様である(文字列)。@code{or}の場合は0(nullポインター)で、それは@code{or}がインタラクティブに呼び出せないことを示す。値@code{""}は、インタラクティブに呼び出し時、関数が引き受けるべきではないことを示す。値が@samp{"(}で始まる場合、その文字列はLispフォームとして評価される。たとえば:

@example
@group
DEFUN ("foo", Ffoo, Sfoo, 0, UNEVALLED,
       "(list (read-char-by-name \"Insert character: \")\
              (prefix-numeric-value current-prefix-arg)\
              t))",
  doc: /* @dots{} /*)
@end group
@end example

@item doc
これはドキュメント文字列である。複数行を含むために特別なことを要しないので、これにはCの文字列構文ではなく、Cコメント構文を使用する。@samp{doc:}の後のコメントは、ドキュメント文字列として認識する。コメントの開始と終了の区切り文字@samp{/*}と@samp{*/}は、ドキュメント文字列の一部にはならない。

ドキュメント文字列の最後の行がキーワード@samp{usage:}で始まる場合、その行の残りの部分は引数リストをドキュメント化するためのものとして扱われる。この方法により、Cコード内で使用される引数名とは異なる引数名を、ドキュメント文字列内で使用することができる。その関数の引数の個数に制限がない場合、@samp{usage:}は必須。

Lispコードでのドキュメント文字列にたいする通常ルールのすべて(@ref{Documentation
Tips}を参照)は、Cコードのドキュメント文字列にも適用される。
@end table

  @code{DEFUN}マクロ呼び出しの後には、そのC関数にたいする引数リストを、その引数のタイプを含めて記述しなければなりません。そのプリミティブがLispで固定された最大個数をもつ引数を受け入れるなら、Lisp引数それぞれにたいして1つのC引数をもち、各引数のタイプは@code{Lisp_Object}でなければなりません(ファイル@file{lisp.h}では、タイプ@code{Lisp_Object}の値を作成する種々のマクロと関数が宣言されている)。そのプリミティブのLispの最大引数個数に上限がない場合、それは正確に2つのC引数をもたなければなりません。1つ目はLisp引数の個数で、2つ目はそれらの値を含むブロックのアドレスです。これらはそれぞれ@code{int}、@w{@code{Lisp_Object
*}}のタイプをもちます。@code{Lisp_Object}は任意のデータ型と任意のLispオブジェクトを保持できるので、実行時のみ実際のデータ型を判断できます。特定のタイプの引数だけを受け入れるプリミティブを記述したい場合は、適切な述語を使用してタイプを明確にチェックしなければなりません(@ref{Type
Predicates}を参照)。
@cindex type checking internals

@cindex @code{GCPRO} and @code{UNGCPRO}
@cindex protect C variables from garbage collection
  関数@code{For}自身の中では、マクロ@code{GCPRO1}と@code{UNGCPRO}の使用に注意してください。これらのマクロは、Emacsのデフォルトであるスタックマーキングを使用したガーベージコレクションを使用しない、いくつかのプラットフォームのために定義されています。@code{GCPRO1}マクロは、ガーベージコレクションにその変数とコンテンツすべてがアクセス可能でなければならないと、明示的にガーベージコレクションに通知して、ガーベージコレクションから変数を``保護''します。直接または間接的に、サブルーチンとして@code{eval_sub}か@code{Feval}を呼び出してLisp評価を行うかもしれないすべての関数で、GC保護は必要です。

  各オブジェクトにたいして、それを指すポインターが少なくとも1つあれば、GCからの保護を確実に満足することができます。つまり、ある特定のローカル変数が、(@code{GCPRO}をもつ別のローカル変数のような)別のポインターにより保護されるであろうオブジュクトを指すことが確実なら、保護なしでこれを行うことができます。それ以外なら、そのローカル変数には@code{GCPRO}が必要になります。

  マクロ@code{GCPRO1}は、ただ1つのローカル変数を保護します。2つの変数を保護したい場合には、かわりに@code{GCPRO2}を使用します。@code{GCPRO1}を繰り返しても、機能しないでしょう。@code{GCPRO3}、@code{GCPRO4}、@code{GCPRO5}、@code{GCPRO6}のマクロもあります。これらのマクロのすべては、@code{gcpro1}のようなローカル変数を暗黙に使用します。あなたはこれらをタイプ@code{struct
gcpro}で、明示的に宣言しなければなりません。つまり@code{GCPRO2}を使用するなら、@code{gcpro1}と@code{gcpro2}を宣言しなければなりません。

  @code{UNGCPRO}は、カレントの関数内で保護された、変数の保護を取り消します。これは明示的に行う必要があります。

  一度Emacsがダンプされた後に、その変数に何か書き込まれているときには、その静的変数またはグローバル変数に、Cの初期化を使用してはなりません。初期化されたこれらの変数は、Emacsのダンプの結果として、(特定のオペレーティングシステムでは)読み取り専用となるメモリーエリアに割り当てられます。@ref{Pure
Storage}を参照してください。

@cindex @code{defsubr}, Lisp symbol for a primitive
  C関数の定義だけでは、Lispプリミティブを利用可能にするのに十分ではありません。そのプリミティブにたいしてLispシンボルを作成して、その関数セルに適切なsubrオブジェクトを格納しなければなりません。このコードは以下のようになるでしょう:

@example
defsubr (&@var{sname});
@end example

@noindent
ここで@var{sname}は、@code{DEFUN}の3つ目の引数として使用する名前です。

  すでにLispプリミティブが定義されたファイルにプリミティブを追加する場合には、(そのファイル終端付近にある)@code{syms_of_@var{something}}という名前の関数を探して、そこに@code{defsubr}の呼び出しを追加してください。そのファイルにこの関数がない、または新たなファイルを作成する場合には、それに@code{syms_of_@var{filename}}(例:
@code{syms_of_myfile})を追加します。それから@file{emacs.c}で、それらの関数すべてが呼び出されるが呼び出される箇所を探して、そこに@code{syms_of_@var{filename}}の呼び出しを追加してください。

@anchor{Defining Lisp variables in C}
@vindex byte-boolean-vars
@cindex defining Lisp variables in C
@cindex @code{DEFVAR_INT}, @code{DEFVAR_LISP}, @code{DEFVAR_BOOL}
  関数@code{syms_of_@var{filename}}は、Lisp変数として可視となるすべてのC変数を定義する場所でもあります。@code{DEFVAR_LISP}はタイプ@code{Lisp_Object}のC変数を、Lispから可視にします。@code{DEFVAR_INT}はタイプ@code{int}のC変数を、常に整数となる値をもつようにして、Lispから可視にします。@code{DEFVAR_BOOL}はタイプ@code{int}のC変数を、常に@code{t}か@code{nil}のいずれかとなる値をもつようにして、Lispから可視にします。@code{DEFVAR_BOOL}で定義された変数は、バイトコンパイラーに使用されるリスト@code{byte-boolean-vars}に、自動的に追加されることに注意してください。

@cindex defining customization variables in C
  Cで定義されたLisp変数を、@code{defcustom}で宣言された変数のように振る舞わせたい場合は、@file{cus-start.el}に適切なエントリーを追加してください。

@cindex @code{staticpro}, protection from GC
  タイプ@code{Lisp_Object}のファイルをスコープとするC変数を定義する場合には、以下のように@code{syms_of_@var{filename}}内で@code{staticpro}を呼び出して、ガーベージコレクションからそれを保護しなければなりません:

@example
staticpro (&@var{variable});
@end example

  以下は、より複雑な引数をもつ別の関数例です。これは@file{window.c}からのコードで、Lispオブジェクトを操作するためのマクロと関数の使用を示すものです。

@smallexample
@group
DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
  Scoordinates_in_window_p, 2, 2, 0,
  doc: /* Return non-nil if COORDINATES are in WINDOW.
  ...
@end group
@group
  or `right-margin' is returned.  */)
  (register Lisp_Object coordinates, Lisp_Object window)
@{
  struct window *w;
  struct frame *f;
  int x, y;
  Lisp_Object lx, ly;
@end group

@group
  CHECK_LIVE_WINDOW (window);
  w = XWINDOW (window);
  f = XFRAME (w->frame);
  CHECK_CONS (coordinates);
  lx = Fcar (coordinates);
  ly = Fcdr (coordinates);
  CHECK_NUMBER_OR_FLOAT (lx);
  CHECK_NUMBER_OR_FLOAT (ly);
  x = FRAME_PIXEL_X_FROM_CANON_X (f, lx) + FRAME_INTERNAL_BORDER_WIDTH(f);
  y = FRAME_PIXEL_Y_FROM_CANON_Y (f, ly) + FRAME_INTERNAL_BORDER_WIDTH(f);
@end group

@group
  switch (coordinates_in_window (w, x, y))
    @{
    case ON_NOTHING:            /* NOT in window at all. */
      return Qnil;
@end group

    ...

@group
    case ON_MODE_LINE:          /* In mode line of window. */
      return Qmode_line;
@end group

    ...

@group
    case ON_SCROLL_BAR:         /* On scroll-bar of window.  */
      /* Historically we are supposed to return nil in this case.  */
      return Qnil;
@end group

@group
    default:
      abort ();
    @}
@}
@end group
@end smallexample

  Cコードは、それらがCで記述されていなければ、名前で呼び出すことはできないことに注意してください。Lispで記述された関数を呼び出すには、関数@code{funcall}を具現化した@code{Ffuncall}を使用します。Lisp関数@code{funcall}は個数制限なしの引数を受け付けるので、Cでの引数はLispレベルでの引数個数と、それらの値を含む1次元配列という、2個の引数になります。Lispレベルでの1つ目の引数は呼び出す関数で、残りはそれに渡す引数です。@code{Ffuncall}は評価機能(evaluator)を呼び出すかもしれないので、@code{Ffuncall}の呼び出し前後でガーベージコレクションからポインターを保護しなければなりません。

  C関数@code{call0}、@code{call1}、@code{call2}、...は個数が固定された引数でLisp関数を手軽に呼び出す、便利な方法を提供します。これらは@code{Ffuncall}を呼び出すことにより機能します。

  @file{eval.c}は例を探すには、よいファイルです。@file{lisp.h}には、重要なマクロと関数の定義がいくつか含まれています。

  副作用をもたない関数を定義する場合には、コンパイラーのオプティマイザーに知らせるために@code{side-effect-free-fns}と@code{side-effect-and-error-free-fns}をバインドする、@file{byte-opt.el}内のコードを更新してください。

@node Object Internals
@section Object Internals
@cindex object internals

  Emacs
Lispは豊富なデータタイプのセットを提供します。コンスセル、整数、文字列のようにこれらのいくつかは、ほとんどすべてのLisp方言で一般的です。マーカやバッファーのようなそれ以外のものは、Lisp内でエディターコマンドを記述するための基本的サポートを提供するために、極めて特別で必要なものです。そのような種々のオブジェクトタイプを実装して、インタープリターのサブシステムとの間でオブジェクトを渡す効果的な方法を提供するに、Cデータ構造体セットとそれらすべてにたいするポインターを表す、@dfn{タグ付きポインター(tagged
pointer)}と呼ばれる、特別なタイプが存在します。

  Cでは、タグ付きポインターは、タイプ@code{Lisp_Object}のオブジェクトです。そのようなタイプの初期化された変数は、基本的なデータタイプである整数、シンボル、文字列、コンスセル、浮動小数点数、ベクター類似オブジェクトや、その他の雑多なオブジェクトのいずれかを、常に値として保持します。これらのデータタイプのそれぞれは、対応するタグ値をもちます。すべてのタグは@code{enum
Lisp_Type}により列挙され、@code{Lisp_Object}の3ビットのビットフィールソに配置されます。残りのビットは、それ自身の値です。整数は即値(@dfn{値ビット}で直接表される)、他のすべてのオブジェクトは、ヒープに割り当てられた対応するオブジェクトへのCポインターで表されます。@code{Lisp_Object}のサイズはプラットフォームと設定に依存します。これは通常は背景プラットフォームのポインターと等しい(32ビットマシンなら32ビット、64ビットマシンなら64ビット)ですが、@code{Lisp_Object}が64ビットでも、すべてのポインターが32ビットのような特別な構成もあります。後者は@code{Lisp_Object}にたいして、64ビットの@code{long
long}タイプを使用することにより、32ビットシステム上のLisp整数にたいする、値範囲の制限を乗り越えるためにデザインされたトリックです。

  以下のCデータ構造体は、整数ではない基本的なデータタイプを表すために、@file{lisp.h}で定義されています:

@table @code
@item struct Lisp_Cons
コンスセル。リストを構築するために使用されるオブジェクトである。

@item struct Lisp_String
文字列。文字シーケンスを表す基本的オブジェクトである。

@item struct Lisp_Vector
配列。インデックスによりアクセスできる、固定サイズのLispオブジェクトのセットである。

@item struct Lisp_Symbol
シンボル。一般的に識別子として使用される一意な名前のエンティティである。

@item struct Lisp_Float
Floating-point value.

@item union Lisp_Misc
上記のいずれにも適合しない、雑多な種類のオブジェクト。
@end table

  これらのタイプは、内部的タイプシステムの一級クラスの市民です。タグスペースは限られているので、他のすべてのタイプは@code{Lisp_Vectorlike}か@code{Lisp_Misc}のサブクラスです。サブタイプのベクターは@code{enum
pvec_type}により列挙されておりウィンドウ、バッファー、フレーム、プロセスのようなほとんどすべての複雑なオブジェクトは、このカテゴリーに分類されます。マーカーとオーバーレイを含む残りのスペシャルタイプは、@code{enum
Lisp_Misc_Type}により列挙されており、@code{Lisp_Misc}のサブタイプセットを形成します。

  @code{Lisp_Vectorlike}のいくつかのサブタイプを説明します。バッファーオブジェクトは、表示および編集を行うテキストを表します。ウィンドウはバッファーを表示したり、同一フレーム上で再帰的に他のウィンドウを配置するためのコンテナーに使用される、表示構造の一部です(Emacs
Lispのウィンドウオブジェクトと、Xのようなユーザーインターフェースシステムに管理されるエンティティとしてのウィンドウを混同しないこと。Emacsの用語では後者はフレームと呼ばれる)。最後に、プロセスオブジェクトは、サブプロセスの管理に使用されます。

@menu
* Buffer Internals::         バッファー構造体の構成子。
* Window Internals::         ウィンドウ構造体の構成子。
* Process Internals::        プロセス構造体の構成子。
@end menu

@node Buffer Internals
@subsection Buffer Internals
@cindex internals, of buffer
@cindex buffer internals

  2つの構造体(@file{buffer.h}を参照)は、Cでバッファーを表すために使用されます。@code{buffer_text}構造体には、バッファーのテキストを記述するフィールドが含まれます。@code{buffer}構造体は他のフィールドを保持します。インダイレクトバッファーの場合には、2つ以上の@code{buffer}構造体が、同じ@code{buffer_text}構造体を参照します。

以下に@code{struct buffer_text}内のフィールドをいくつか示します:

@table @code
@item beg
バッファーコンテンツのアドレス。

@item gpt
@itemx gpt_byte
バッファーのギャップの文字位置とバイト位置。@ref{Buffer Gap}を参照のこと。

@item z
@itemx z_byte
バッファーテキストの終端の文字位置とバイト位置。

@item gap_size
バッファーのギャップのサイズ。@ref{Buffer Gap}を参照のこと。

@item modiff
@itemx save_modiff
@itemx chars_modiff
@itemx overlay_modiff
これらのフィールドは、そのバッファーで行われた、バッファー変更イベントの数をカウントする。@code{modiff}はバッファー変更イベントのたびに増分され、それ以外では決して変化しない。@code{save_modiff}には、そのバッファーが最後にvisitまたは保存されたときの、@code{modiff}の値が含まれる。@code{chars_modiff}は、そのバッファー内の文字にたいする変更だけをカウントし、その他すべての種類の変更を無視する。@code{overlay_modiff}は、オーバーレイにたいする変更だけをカウントする。

@item beg_unchanged
@itemx end_unchanged
最後の再表示完了以降に、未変更だと解っているテキストの、開始と終了の箇所での文字数。

@item unchanged_modified
@itemx overlay_unchanged_modified
それぞれ、最後に再表示が完了した後の@code{modiff}と@code{overlay_modiff}の値。これらのカレント値が@code{modiff}や@code{overlay_modiff}とマッチしたら、それは@code{beg_unchanged}と@code{end_unchanged}に有用な情報が含まれないことを意味する。

@item markers
このバッファーを参照するマーカー。これは実際には単一のマーカーであり、自身のマーカー``チェーン''内の一連の要素が、そのバッファー内のテキストを参照する他のマーカーになる。

@item intervals
そのバッファーのテキストプロパティを記録する、インターバルツリー。
@end table

@code{struct buffer}のいくつかのフィールドを以下に示します:

@table @code
@item header
タイプ@code{struct vectorlike_header}のヘッダーは、すべてのベクター類似のオブジェクトに共通。

@item own_text
構造体@code{struct
buffer_text}は、通常はバッファーのコンテンツを保持する。インダイレクトバッファーでは、このフィールドは使用されない。

@item text
そのバッファーの@code{buffer_text}構造体へのポインター。通常のバッファーでは、上述の@code{own_text}フィールドである。インダイレクトバッファーでは、そのベースバッファーの@code{own_text}フィールドになる。

@item next
killされたバッファーを含むすべてのバッファーのチェーン内において、次のバッファーへのポインター。このチェーンは、killされたバッファーを正しく回収するために、割り当てとガーベージコレクションのためだけに使用される。

@item pt
@itemx pt_byte
バッファー内のポイントの文字位置とバイト位置。

@item begv
@itemx begv_byte
そのバッファー内のアクセス可能範囲の、先頭位置の文字位置とバイト位置。

@item zv
@itemx zv_byte
そのバッファー内のアクセス可能範囲の、終端位置の文字位置とバイト位置。

@item base_buffer
インダイレクトバッファーでは、これはベースバッファーのポイントである。通常のバッファーではnull。

@item local_flags
このフィールドは、そのバッファー内でローカルな変数にたいして、それを示すフラグを含む。そのような変数はCコードでは@code{DEFVAR_PER_BUFFER}を使用して宣言され、それらのバッファーローカルなバインディングは、このバッファー構造体自身内のフィールドに格納される(これらのフィールドのいくつかは、このテーブル内で説明されておる)。

@item modtime
visitされているファイルの変更時刻。これは、そのファイルの書き込みおよび読み込み時にセットされる。そのバッファーをファイルに書き込む前に、そのファイルがディスク上で変更されていないことを確認するために、このフィールドとそのファイルの変更時刻を比較する。@ref{Buffer
Modification}を参照のこと。

@item auto_save_modified
そのバッファーが最後に自動保存さらたときの時刻。

@item last_window_start
そのバッファー最後にウィンドウに表示されたときの、の@code{window-start}位置。

@item clip_changed
このフラグは、そのバッファーでのナローイングが変更されているかを示す。@ref{Narrowing}を参照のこと。

@item prevent_redisplay_optimizations_p
このフラグは、そのバッファーの表示において、再表示最適化が使用されるべきではないことを示す。

@item overlay_center
このフィールドは、カレントオーバーレイの中心位置を保持する。@ref{Managing Overlays}を参照のこと。

@item overlays_before
@itemx overlays_after
これらのフィールドは、カレントオーバーレイ中心、またはその前で終わるオーバーレイのリスト、およびカレントオーバーレイの後で終わるオーバーレイのリストである。@ref{Managing
Overlays}を参照のこと。@code{overlays_before}は終端位置の記述順に格納され、@code{overlays_after}は先頭位置増加順で格納される。

@c FIXME? the following are now all Lisp_Object BUFFER_INTERNAL_FIELD (foo).

@item name
そのバッファーを命名するLisp文字列。これは一意であることが保証されている。@ref{Buffer Names}を参照のこと。

@item save_length
そのバッファーがvisitしているファイルを、最後に読み込みまたは保存したときの長さ。インダイレクトバッファーは決して保存されることはないので、保存に関して、このフィールドとその他のフィールドは、@code{buffer_text}構造体で維持されない

@item directory
相対ファイル名を展開するディレクトリー。これはバッファーローカル変数@code{default-directory}の値である(@ref{File
Name Expansion}を参照)。

@item filename
そのバッファーがvisitしているファイルの名前。これは、バッファーローカル変数@code{buffer-file-name}の値である(@ref{Buffer
File Name}を参照)。

@item undo_list
@itemx backed_up
@itemx auto_save_file_name
@itemx auto_save_file_format
@itemx read_only
@itemx file_format
@itemx file_truename
@itemx invisibility_spec
@itemx display_count
@itemx display_time
これらのフィールドは、自動的にバッファーローカル(@ref{Buffer-Local
Variables}を参照)になるLisp変数の値を格納する。これらに対応する変数は、名前に追加のプレフィクス@code{buffer-}がつき、アンダースコアがダッシュで置換される。たとえば@code{undo_list}は、@code{buffer-undo-list}の値を格納する。

@item mark
そのバッファーにたいするマーク。マークはマーカーなので、リスト@code{markers}内にも含まれる。@ref{The Mark}を参照のこと。

@item local_var_alist
この連想リストは、そのバッファーのバッファーローカル変数のバインディングを記述する。これにはバッファーオブジェクト内に特別なスロットをもつ、ビルトインのバッファーローカルなバインディングは含まれない(このテーブルでは、それらのスロットは省略している)。@ref{Buffer-Local
Variables}を参照のこと。

@item major_mode
そのバッファーのメジャーモードを命名するシンボル(例: @code{lisp-mode})。

@item mode_name
そのメジャーモードの愛称(例: @code{"Lisp"})。

@item keymap
@itemx abbrev_table
@itemx syntax_table
@itemx category_table
@itemx display_table
これらのフィールドは、そのバッファーのローカルキーマップ(@ref{Keymaps}を参照)、abbrevテーブル(@ref{Abbrev
Tables}を参照)、構文テーブル(@ref{Syntax
Tables}を参照)、カテゴリーテーブル(@ref{Categories}を参照)、ディスプレーテーブル(@ref{Display
Tables}を参照)を格納する。

@item downcase_table
@itemx upcase_table
@itemx case_canon_table
これらのフィールドはテキストを小文字、大文字、およびcase-fold検索でのテキストの正規化の変換テーブルを格納する。@ref{Case
Tables}を参照のこと。

@item minor_modes
そのバッファーのマイナーモードのalist。

@item pt_marker
@itemx begv_marker
@itemx zv_marker
これらのフィールドはインダイレクトバッファー、またはインダイレクトバッファーのベースバッファーであるようなバッファーでのみ使用される。これらはそれぞれ、そのバッファーがカレントでないときに、そのバッファーにたいする@code{pt}、@code{begv}、@code{zv}を記録するマーカーを保持する。

@item mode_line_format
@itemx header_line_format
@itemx case_fold_search
@itemx tab_width
@itemx fill_column
@itemx left_margin
@itemx auto_fill_function
@itemx truncate_lines
@itemx word_wrap
@itemx ctl_arrow
@itemx bidi_display_reordering
@itemx bidi_paragraph_direction
@itemx selective_display
@itemx selective_display_ellipses
@itemx overwrite_mode
@itemx abbrev_mode
@itemx mark_active
@itemx enable_multibyte_characters
@itemx buffer_file_coding_system
@itemx cache_long_line_scans
@itemx point_before_scroll
@itemx left_fringe_width
@itemx right_fringe_width
@itemx fringes_outside_margins
@itemx scroll_bar_width
@itemx indicate_empty_lines
@itemx indicate_buffer_boundaries
@itemx fringe_indicator_alist
@itemx fringe_cursor_alist
@itemx scroll_up_aggressively
@itemx scroll_down_aggressively
@itemx cursor_type
@itemx cursor_in_non_selected_windows
これらのフィールドは、自動的にバッファーローカル(@ref{Buffer-Local
Variables}を参照)になるLisp変数の値を格納する。これらに対応する変数は、名前のアンダースコアがダッシュで置換される。たとえば@code{mode_line_format}は、@code{mode-line-format}の値を格納する。

@item last_selected_window
これは、最後に選択されていたときにそのバッファーを表示していたウィンドウ、またはそのウィンドウがすでにそのバッファーを表示していなければ@code{nil}である。
@end table

@node Window Internals
@subsection Window Internals
@cindex internals, of window
@cindex window internals

  ウィンドウのフィールドには、以下が含まれます(完全なリストは@file{window.h}の@code{struct window}を参照されたい):

@table @code
@item frame
そのウィンドウがあるフレーム。

@item mini_p
そのウィンドウがミニバッファーウィンドウなら非@code{nil}。

@item parent
Emacsは内部的に、ウィンドウをツリーにアレンジする。ウィンドウの兄弟グループは、そのエリアがすべての兄弟を含むような親ウィンドウをもつ。このフィールドは、ウィンドウの親を指す。

親ウィンドウはバッファーを表示せず、子ウィンドウ形成を除き、表示では少ししか役割を果たさない。Emacs
Lispプログラムでからは、通常は親ウィンドウへのアクセスがない。Emacs
Lispプログラムでは、実際にバッファーを表示するツリーの子ノードのウィンドウにたいして操作を行う。

@c FIXME: These two slots and the `buffer' slot below were replaced
@c with a single slot `contents' on 2013-03-28.  --xfq
@item hchild
@itemx vchild
これらのフィールドは、そのウィンドウの左端の子、上端の子を含む。子ウィンドウによりウィンドウが分割される場合は@code{hchild}、垂直に分割される場合は@code{vchild}が使用される。生きたウィンドウでは@code{hchild}、@code{vchild}、@code{buffer}のいずれか1つだけが非@code{nil}となる。

@item next
@itemx prev
そのウィンドウの次の兄弟と、前の兄弟。自身のグループ内でそのウィンドウが右端か下端なら、@code{next}は@code{nil}。自身のグループ内でそのウィンドウが左端か上端なら、@code{prev}は@code{nil}。

@item left_col
そのウィンドウの左端を、そのフレームの最左列(列0)から相対的に数えた列数。

@item top_line
そのウィンドウの上端を、そのフレームの最上行(行0)から相対的に数えた行数。

@item total_cols
@itemx total_lines
列数と行数で数えた、そのウィンドウの幅と高さ。幅にはスクロールバーとフリンジ、および/または(もしあれば)ウィンドウ右側のセパレーターラインが含まれる。

@item buffer
そのウィンドウが表示しているバッファー。

@item start
そのウィンドウ内に表示されるバッファーで、ウィンドウに最初に表示される文字の位置を指すマーカー。

@item pointm
@cindex window point internals
これは、そのウィンドウが選択されているときの、カレントバッファーのポイント値。選択されていなければ、前の値が保たれる。

@item force_start
このフラグが非@code{nil}なら、Lispプログラムによりそのウィンドウが明示的にスクロールされたことを示す。これはポイントがスクリーン外の場合の、次回再表示に影響を与える。影響とは、ポイント周辺のテキストを表示するためにウィンドウをスクロールするかわりに、スクリーン上にある位置にポイントを移動するというものである。

@item frozen_window_start_p
このフィールドは再表示にたいして、たとえポイントが不可視になったとしても、そのウィンドウの@code{start}を変更するべきではないことを示すために、一時的に1にセットされる。

@item start_at_line_beg
非@code{nil}は、@code{start}のカレント値が、そのウィンドウ選択時に先頭行だったことを意味する。

@item use_time
これは、そのウィンドウが最後に選択された時刻である。関数@code{get-lru-window}はこの値を使用する。

@item sequence_number
そのウィンドウ作成時に割り当てられた一意な番号。

@item last_modified
前回のそのウィンドウの再表示完了時の、そのウィンドウのバッファーの@code{modiff}フィールド。

@item last_overlay_modified
前回のそのウィンドウの再表示完了時の、そのウィンドウのバッファーの@code{overlay_modiff}フィールド。

@item last_point
前回のそのウィンドウの再表示完了時の、そのウィンドウのバッファーのポイント値。

@item last_had_star
非@code{nil}値は、そのウィンドウが最後に更新されたとき、そのウィンドウのバッファーが``変更''されたことを意味する。

@item vertical_scroll_bar
そのウィンドウの垂直スクロールバー。

@item left_margin_cols
@itemx right_margin_cols
そのウィンドウの、左マージンと右マージンの幅。値@code{nil}はマージンがないことを意味する。

@item left_fringe_width
@itemx right_fringe_width
そのウィンドウの、左フリンジと右フリンジの幅。値@code{nil}と@code{t}は、フレームの値の使用を意味する。

@item fringes_outside_margins
非@code{nil}値は、ディスプレーマージン外側のフリンジ、それ以外ならフリンジはマージンとテキストの間にあることを意味する。

@item window_end_pos
これは@code{z}から、そのウィンドウのカレントマトリクス内の最後のグリフのバッファー位置を減じて算出される。この値は、@code{window_end_valid}が非@code{nil}のときだけ有効である。

@item window_end_bytepos
@code{window_end_pos}に対応するバイト位置。

@item window_end_vpos
@code{window_end_pos}を含む行の、ウィンドウに相対的な垂直位置。

@item window_end_valid
このフィールドは、@code{window_end_pos}が真に有効なら、非@code{nil}値にセットされる。これは重要な再表示が先に割り込んだ場合には、@code{window_end_pos}を算出した表示がスクリーン上に出現しなくなるので@code{nil}となる。

@item cursor
そのウィンドウ内でカーソルがどこにあるかを記述する構造体。

@item last_cursor
完了した最後の表示での@code{cursor}の値。

@item phys_cursor
そのウィンドウのカーソルが物理的にどこにあるかを記述する構造体。

@item phys_cursor_type
@c FIXME What is this?
@c itemx phys_cursor_ascent
@itemx phys_cursor_height
@itemx phys_cursor_width
そのウィンドウの最後の表示での、カーソルのタイプ、高さ、幅。

@item phys_cursor_on_p
このフィールドは、カーソルが物理的にオンなら非0。

@item cursor_off_p
非0はそのウィンドウのカーソルが、論理的にオフであることを意味する。これはカーソルの点滅に使用される。

@item last_cursor_off_p
このフィールドは最後の再表示時の、@code{cursor_off_p}の値を含む。

@item must_be_updated_p
これは、そのウィンドウを更新しなければならないとき、再表示の間1にセットされる。

@item hscroll
これは、そのウィンドウ内の表示が左へ水平スクロールされている列数。通常これは0。

@item vscroll
ピクセル単位での垂直スクロール量。通常これは0。

@item dedicated
そのウィンドウがそれのバッファー専用(dedicated)なら、非@code{nil}。

@item display_table
そのウィンドウのディスプレーテーブル、それが何も指定されていなければ@code{nil}。

@item update_mode_line
非@code{nil}は、そのウィンドウのモードラインの更新が必要なことを意味する。

@item base_line_number
そのバッファーの特定の位置の行番号か@code{nil}。これは、モードラインでポイントの行番号を表示するために使用される。

@item base_line_pos
行番号が既知であるバッファー位置、それが知られていなければ@code{nil}。これがバッファーなら、そのウィンドウがバッファーを表示するかぎり、行番号は表示されない。

@item column_number_displayed
そのウィンドウのモードラインに表示されているカレント列番号、列番号が表示されていなければ@code{nil}。

@item current_matrix
@itemx desired_matrix
そのウィンドウのカレント、および望まれる表示を記述するグリフ。
@end table

@node Process Internals
@subsection Process Internals
@cindex internals, of process
@cindex process internals

  プロセスのフィールドには以下が含まれます(完全なリストは、@file{process.h}の@code{struct
Lisp_Process}の定義を参照されたい):

@table @code
@item name
プロセス名(文字列)。

@item command
そのプロセスの開始に使用された、コマンド引数を含むリスト。ネットワークプロセスとシリアルプロセスでは、そのプロセスが実行中なら@code{nil}、停止していたら@code{t}。

@item filter
そのプロセスから出力を受け取るために使用される関数。

@item sentinel
そのプロセスの状態が変化したら常に呼び出される関数。

@item buffer
そのプロセスに関連付けられたバッファー。

@item pid
オペレーティングシステムのプロセス@acronym{ID}(整数)。ネットワークプロセスやシリアルプロセスのような疑似プロセスでは、値0を使用する。

@item childp
フラグで、もし実際に子プロセスなら@code{t}。ネットワークプロセスやシリアルプロセスでは、@code{make-network-process}または@code{make-serial-process}にもとづくplist。

@item mark
そのプロセスからの出力から、バッファーに挿入された終端位置を示すマーカー。常にではないが、これはしばしばバッファー終端である。

@item kill_without_query
これが非0なら、そのプロセス実行中にEmacsをkillしても、そのプロセスをkillすることにたいして確認を求めない。

@item raw_status
システムコール@code{wait}がリターンする、rawプロセス状態。

@item status
@code{process-status}がリターンするようなプロセス状態。

@item tick
@itemx update_tick
これら2つのフィールドが等しくないなら、センチネル実行またはプロセスバッファーへのメッセージ挿入により、そのプロセスの状態変更は報告される必要がある。

@item pty_flag
そのサブプロセスがptyを使用して対話する場合は非@code{nil}。パイプを使用する場合には@code{nil}。

@item infd
そのプロセスからの入力にたいする、ファイルデゥクリプター。

@item outfd
そのプロセスへの出力にたいする、ファイルデゥクリプター。

@item tty_name
そのサブプロセスが使用する端末の名前、またはパイプを使用する場合は@code{nil}。

@item decode_coding_system
そのプロセスからの入力のデコーディングにたいするコーディングシステム。

@item decoding_buf
デコーディング用の作業バッファー。

@item decoding_carryover
デコーディングでのキャリーオーバーのサイズ。

@item encode_coding_system
そのプロセスからの出力のエンコーディングにたいするコーディングシステム。

@item encoding_buf
エンコーディング用の作業バッファー。

@item inherit_coding_system_flag
プロセス出力のデコードに使用されるコーディングシステムから、プロセスバッファーの@code{coding-system}をセットするフラグ。

@item type
プロセスのタイプを示す@code{real}、@code{network}、@code{serial}いずれかのシンボル。

@end table

@node C Integer Types
@section C Integer Types
@cindex integer types (C programming language)

以下はEmacsのCソースコード内で、整数タイプを使用する際のガイドラインです。これらのガイドラインはときに相反するアドバイスを与えることがありますが、一般的な常識に沿ったものがアドバイスです。

@itemize @bullet
@item
任意の制限の使用を避ける。たとえば、@code{s}の長さを@code{int}の範囲に収めることが要求されるのでなければ、@code{int len
= strlen (s);}を使用しないこと。

@item
符号付き整数の算術演算のオーバーフローのラップアラウンドを前提としてはならない。Emacsのポート対象先によっては、これは成り立たない。実際には、符号付き整数のオーバーフローは未定義であり、コアダンプや、早晩に``非論理的''な振る舞いさえ起こし得る。符号なし整数のオーバーフローは、2のべき乗の剰余に確実にラップアラウンドされることが保証されています。

@item
符号なしタイプと符号付きタイプを組み合わせるとコードが混乱するので、符号なしタイプより符号付きタイプを優先すること。他のガイドラインの多くはタイプが符号付きだとみなしている。符号なしタイプを要する稀なケースでは、符号付きの符号なし版(@code{ptrdiff_t}のかわりに@code{size_t}、@code{intptr_t}のかわりに@code{uintptr_t})にたいして同様のアドバイスを適用できる。

@item
Emacsの文字コードでは、0から0x3FFFFFを優先すること。

@item
サイズ(たとえばすべての個別のCオブジェクトの最大サイズや、すべてのC配列の最大要素数にバインドされる整数)にたいしては、@code{ptrdiff_t}を優先すること。これは符号付きタイプにたいする、Emacsの一般的な優先事項である。@code{ptrdiff_t}の使用によりオブジェクトは@code{PTRDIFF_MAX}に制限されるが、より大きいオブジェクトはポインター減算を破壊するかもしれず、結局のところ問題を起こす可能性があるので、これは一方的に制限を課すものではない。

@item
ポインターの内部表現や、与えられた任意のタイミングで存在可能なオブジェクト数や割り当て可能な総バイト数にのみバインドされる整数には、@code{intptr_t}を優先すること。現在のことこEmacsは@code{intptr_t}の使用したほうがよいときに、別のタイプを使用する場合がある。現在のEmacsのカレント移植先にたいして未修正でコードが動作するので、これの修正の優先度は低い。

@item
Emacs
Lispのfixnumへの変換や逆変換を表す値では、fixnum演算が@code{EMACS_INT}にもとづくので、Emacsで定義されたタイプ@code{EMACS_INT}を優先すること。

@item
(ファイルサイズやエポック以降の経過秒数等の)システム値を表す際は、(@code{off_t}や@code{time_t}等の)システムタイプを優先すること。安全だと解っていなければ、システムタイプが符号付きだと仮定してはならない。たとえば@code{off_t}は常に符号付きだが、@code{time_t}は符号付きである必要はない。

@item
@code{printf}族の関数を使用してプリントされ得る任意の符号付き整数であるかもしれない値を表す場合は、Emacsの定義タイプ@code{printmax_t}を優先すること。

@item
任意の符号付き整数であるかもしれない値を表す場合は、@code{intmax_t}を優先すること。

@item
ブーリーンには@code{bool}、@code{false}、@code{true}を使用すること。@code{bool}の使用によりプログラムの可読性が増し、@code{int}を使用するより若干高速になる。@code{int}、@code{0}、@code{1}を使用しても大丈夫だが、この旧スタイルは段階的に廃止される。@code{bool}を使用する際には、ソースファイル@file{lib/stdbool.in.h}に文書化されている@code{bool}の代替実装の制限を尊重すれば、C99以前のプラットフォームにたいするEmacsの可搬性か保たれる。特にブーリーンのビットフィールドは@code{bool}ではなく、@code{bool_bf}タイプであること。そうすれば標準のGCCでObjective
Cをコンパイルするときでさえ、正しく機能する。

@item
ビットフィールドでは、@code{int}は可搬性に劣るので、@code{int}より@code{unsigned int}か@code{signed
int}を優先すること。単一ビットのビットフィールドの値は0か1なので、@code{unsigned
int}か@code{bool_bf}を使用すること。
@end itemize

@c FIXME Mention src/globals.h somewhere in this file?
