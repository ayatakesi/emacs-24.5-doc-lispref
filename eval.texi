@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998, 2001-2015 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node Evaluation
@chapter Evaluation
@cindex evaluation
@cindex interpreter
@cindex interpreter
@cindex value of expression

  Emacs Lispでの式の@dfn{評価(evaluation)}は、@dfn{Lispインタープリター} ---
入力としてLispオブジェクトを受け取り、それの@dfn{式としての値(value as an expression)}を計算します ---
により処理されます。評価を行なう方法は、そのオブジェクトのデータ型に依存し、それはこのチャプターで説明するルールにより行なわれます。インタープリターは、プログラムの一部を評価するために自動的に実行されますが、Lisp基本関数の@code{eval}を通じて、明示的に呼び出すこともできます。

@ifnottex
@menu
* Intro Eval::               事の在り方における評価。
* Forms::                    さまざまなオブジェクト類が評価される方法。
* Quoting::                  (プログラム内に定数を配すための)評価の回避。
* Backquote::                リスト構造の、より簡単な構築。
* Eval::                     Lispインタープリターを明示的に呼び出す方法。
@end menu

@node Intro Eval
@section Introduction to Evaluation

  Lispインタープリター(またはLispエバリュエーター)は、Emacsの一部で、与えられた式の値を計算します。Lispで記述された関数が呼び出されるとき、エバリュエーターはその関数のbody(本文)の中の式を評価することにより、その関数の値を計算します。したがって、Lispプログラムを実行するとは、実際にはLispインタープリターを実行することを意味します。
@end ifnottex

@cindex form
@cindex expression
@cindex S-expression
@cindex sexp
  評価されることを意図したLispオブジェクトは、@dfn{フォーム(form)}、または@dfn{式(expression)}と呼ばれます@footnote{@dfn{S式(S-expression)}、短くは@dfn{sexp}という言葉でも呼ばれることがありますが、わたしたちは通常、このマニュアル内ではこの用語は使用しません。}。フォームはデータオブジェクトであり、単なるテキストではないというのは、Lisp風の言語と、通常のプログラミング言語との間にある、基本的な相違の1つです。任意のオブジェクトを評価できますが、実際に評価される事が非常に多いのは数字、シンボル、リスト、文字列です。

  以降のセクションでは、各種フォームにたいして、それを評価することが何を意味するかの詳細を説明します。

  Lispフォームを読み取り、それからそのフォームを評価するのは、非常に一般的なアクティビティーですが、読み取りと評価は別のアクティビティーであり、どちらか一方を単独で処理することができます。読み取りだけでは、何も評価されません。読み取りはLispオブジェクトのプリント表現を、そのオブジェクト自体に変換します。このオブジェクトは評価されるべきフォームなのか、そのれともまったく違う目的をもつかを指定するのは、@code{read}の呼び出し元の役目です@ref{Input
Functions}を参照してください。

@cindex recursive evaluation
  評価とは再帰的な処理であり、あるフォームを評価することにより、そのフォームの一部が評価されるといったことがよくあります。たとえば、@code{(car
x)}のような@dfn{関数呼び出し(function
call)}のフォームを評価する場合、Emacsは最初にその引数(サブフォーム@code{x})を評価します。引数を評価した後、Emacsはその関数(@code{car})を@dfn{実行(executes)}します。その関数がLispで記述されている場合は、関数の@dfn{body(本文)}を評価することにより、実行が行なわれます(しかし、この例で使用している@code{car}はLisp関数ではなく、Cで実装された基本関数です)。関数と関数呼び出しについての情報は、@ref{Functions}を参照してください。

@cindex environment
  評価は、@dfn{環境(environment)}と呼ばれるコンテキストの内部で行なわれます。環境は、すべてのLisp変数(@ref{Variables}を参照してください)のカレント値とバインディングにより構成されます。@footnote{``環境''にたいするこの定義は、プログラムの結果に影響し得るすべてのデータを特に意図するものではありません。}フォームが新たなバインディングを作成することなく、変数を参照するとき、その変数はカレントの環境により与えられる値に評価されます。フォームの評価は、変数のバインディングにより、一時的にその環境を変更することもあります(@ref{Local
Variables}を参照してください)。

@cindex side effect
  フォームの評価が、永続する変更を行なうこともあります。これらの変更は、@dfn{副作用(side
effects)}と呼ばれます。副作用を生成するフォームの例は、@code{(setq foo 1)}です。

  コマンドキー解釈にたいする評価と混同しないでください。エディターのコマンドループは、アクティブなキーマップを使用して、キーボード入力をコマンド(インタラクティブに呼び出すことができる関数)に変換してから、そのコマンドを実行するために@code{call-interactively}を使用します。そのコマンドはLispで記述されている場合、コマンドの実行は通常、評価を伴います。しかし、このステップはコマンドキー解釈の一部とは考えません。@ref{Command
Loop}を参照してください。

@node Forms
@section Kinds of Forms

  評価される事を意図したLispオブジェクトは、@dfn{フォーム(form)}または@dfn{式(expression)})と呼ばれます。Emacsがフォームを評価する方法は、フォームのデータ型に依存します。Emacsは、3種の異なるフォーム
--- シンボル、リスト、および``その他すべての型'' ---
を持ち、それらは評価される方法は異なります。このセクションでは、まず最初は自己評価フォームの``その他すべての型''から開始して、3つの種類をすべて1つずつ説明します。

@menu
* Self-Evaluating Forms::    自分自身を評価するフォーム。
* Symbol Forms::             変数として評価されるシンボル。
* Classifying Lists::        さまざまな種類のリストフォームを区別する方法。
* Function Indirection::     シンボルがリストのcarにある場合、そのシンボルを通じて実際の関数を見つけます。
* Function Forms::           関数を呼び出すフォーム。
* Macro Forms::              マクロを呼び出すフォーム。
* Special Forms::            "スペシャルフォーム"は特有な基本のフォームで、それらのほとんどがとても重要です。
* Autoloading::              実際の定義を含むファイルのロードをセットアップする関数。
@end menu

@node Self-Evaluating Forms
@subsection Self-Evaluating Forms
@cindex vector evaluation
@cindex literal evaluation
@cindex self-evaluating form

  @dfn{自己評価フォーム(self-evaluating
form)}は、リストやシンボルではない、任意のフォームです。自己評価フォームは、フォーム自身を評価します。評価の結果は、評価されたのと同じオブジェクトです。したがって、数字の25は25に評価され、文字列@code{"foo"}は文字列@code{"foo"}に評価されます。同様に、ベクターの評価では、ベクターの要素の評価は起こりません
--- 内容が変更されずに同じベクターがreturnされます。

@example
@group
'123               ; @r{評価されずに表示される数字。}
     @result{} 123
@end group
@group
123                ; @r{通常どおり評価され、同じものがreturnされる。}
     @result{} 123
@end group
@group
(eval '123)        ; @r{``手動''による評価 --- 同じものがreturnされる。}
     @result{} 123
@end group
@group
(eval (eval '123)) ; @r{2度評価しても何も変わらない。}
     @result{} 123
@end group
@end example

  事項評価されるという事実による利点から、数字、文字、文字列、そしてベクターでさえ、Lispコード内で記述されるのは一般的です。しかし、入力構文がない型にたいしてこれを行なうのは極めて異例です。なぜなら、これらをテキスト的に記述する方法がないからです。Lispプログラムを使用して、これらの型を含むLisp式を構築するのは、可能です。以下は例です:

@example
@group
;; @r{バッファーオブジェクトを含む式を構築する。}
(setq print-exp (list 'print (current-buffer)))
     @result{} (print #<buffer eval.texi>)
@end group
@group
;; @r{それを評価する。}
(eval print-exp)
     @print{} #<buffer eval.texi>
     @result{} #<buffer eval.texi>
@end group
@end example

@node Symbol Forms
@subsection Symbol Forms
@cindex symbol evaluation

  シンボルが評価されるときは、変数として扱われます。それが値をもつ場合、結果はその変数の値になります。そのシンボルが変数としての値をもたない場合、Lispインタープリターはエラーをシグナルします。変数の使用法についての情報は、@ref{Variables}を参照してください。

  以降の例では、@code{setq}でシンボルに値をセットしています。その後シンボルを評価してから、その値を@code{setq}に戻します。

@example
@group
(setq a 123)
     @result{} 123
@end group
@group
(eval 'a)
     @result{} 123
@end group
@group
a
     @result{} 123
@end group
@end example

  シンボル@code{nil}と@code{t}は特別に扱われるので、@code{nil}の値は常に@code{nil}になり、@code{t}の値は常に@code{t}になります。これらに他の値をセットしたり、他の値にバインドすることはできません。したがって、この2つのシンボルは、(たとえ@code{eval}がそれらを他の任意のシンボルと同じように扱うとはいえ)自己評価フォームと同じように振る舞います。名前が@samp{:}で始まるシンボルも、同じ方法で自己評価されます。そして、(通常は)値を変更できない点も同じです。@ref{Constant
Variables}を参照してください。

@node Classifying Lists
@subsection Classification of List Forms
@cindex list form evaluation

  空ではないリストフォームは、関数呼び出し、マクロ呼び出し、スペシャルフォームのいずれかで、それは1番目の引数にしたがいます。これら3種のフォームは、以下で説明するように、異なる方法で評価されます。残りの要素は関数、マクロ、またはスペシャルフォームにたいする@dfn{引数(arguments)}を構成します。

  空ではないリストを評価する最初のステップは、1番目の要素の確認です。この要素は単独で、そのリストがどの種類のフォームか、そして残りの引数をどのように処理するがを決定します。SchemeのようなLisp方言とは異なり、1番目の要素は評価されません。

@node Function Indirection
@subsection Symbol Function Indirection
@cindex symbol function indirection
@cindex indirection for functions
@cindex void function

  リストの最初の要素がシンボルの場合、評価はそのシンボルの関数セルを調べて、元のシンボルの代わりに、関数セルの内容を使用します。その内容が他のシンボルの場合、シンボルではないものが得られるまで、このプロセスが繰り返されます。このプロセスを@dfn{シンボル関数インダイレクション(symbol
function indirection:
indirectionは間接の意)}と呼びます。シンボル関数インダイレクションについての情報は、@ref{Function
Names}を参照してください。

  このプロセスの結果、シンボルの関数競るが同じシンボルを参照する場合、無限ループを起こす可能性があります。それ以外は、最終的には非シンボルにたどりつき、これは関数か、他の適切なオブジェクトであるはずです。

@kindex invalid-function
  より正確に言うと、それはLisp関数(ラムダ式)、バイトコード関数、基本関数、Lispマクロ、スペシャルフォーム、またはオートロードオブジェクトであるべきです。これらの型のそれぞれについては、以降のセクションで説明します。これらの型以外のオブジェクトの場合、emacsは@code{invalid-function}エラーをシグナルします。

  以下の例は、シンボルインダイレクションのプロセスを説明するものです。わたしたちは、シンボルの関数セルに関数をセットするのに@code{fset}、関数セルの内容(@ref{Function
Cells}を参照してください)を得るために@code{symbol-function}を使用します。具体的に言うと、@code{first}の関数セルにシンボル@code{car}を格納し、シンボル@code{first}を@code{erste}の関数セルに格納します。

@example
@group
;; @r{この関数セルのリンクを構築する:}
;;   -------------       -----        -------        -------
;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
;;   -------------       -----        -------        -------
@end group
@group
(symbol-function 'car)
     @result{} #<subr car>
@end group
@group
(fset 'first 'car)
     @result{} car
@end group
@group
(fset 'erste 'first)
     @result{} first
@end group
@group
(erste '(1 2 3))   ; @r{@code{erste}により参照される関数を呼び出す。}
     @result{} 1
@end group
@end example

  対照的に、以下の例はシンボル関数インダイレクションを使用せずに関数を呼び出します。なぜなら、1番目の要素はシンボルではなく、無名Lisp関数(anonymous
Lisp function)だからです。

@example
@group
((lambda (arg) (erste arg))
 '(1 2 3))
     @result{} 1
@end group
@end example

@noindent
関数自身を実行すると、その関数のbodyを評価します。これは、@code{erste}を呼び出すとき、シンボル関数インダイレクションが行なわれます。

  このフォームが使用されるのは稀で、今では推奨されません。かわりに以下のように記述するべきです:

@example
@group
(funcall (lambda (arg) (erste arg))
         '(1 2 3))
@end group
@end example
または単に
@example
@group
(let ((arg '(1 2 3))) (erste arg))
@end group
@end example

  ビルトイン関数の@code{indirect-function}は、明示的にシンボル関数インダイレクションを処理するための、簡単な方法を提供します。

@c Emacs 19 feature
@defun indirect-function function &optional noerror
@anchor{Definition of indirect-function}
この関数は、@var{function}が意味するものを、関数としてreturnします。@var{function}がシンボルの場合は、@var{function}の関数定義を探して、その値で最初からやり直します。@var{function}がシンボルでない場合は、@var{function}自身をreturnします。

この関数は、最後のシンボルがバインドされておらず、オプション引数@var{noerror}が省略されているか@code{nil}の場合は、@code{void-function}エラーをシグナルします。それ以外は、@var{noerror}が非@code{nil}の場合は、最後のシンボルがバインドされていなければ@code{nil}をreturnします。

特定のシンボル内にループがある場合、この関数は@code{cyclic-function-indirection}エラーをシグナルします。

以下は、Lispで@code{indirect-function}を定義できるという例です:

@example
(defun indirect-function (function)
  (if (symbolp function)
      (indirect-function (symbol-function function))
    function))
@end example
@end defun

@node Function Forms
@subsection Evaluation of Function Forms
@cindex function form evaluation
@cindex function call

  リストの1番目の要素がLispの関数オブジェクト。バイトコードオブジェクト、基本関数オブジェクトと評価された場合、そのリストは@dfn{関数呼び出し(function
call)}になります。たとえば、以下は関数@code{+}を呼び出します:

@example
(+ 1 x)
@end example

  関数呼び出しを評価する最初のステップは、そのリストの残りの要素を左から右に評価します。結果は引数の実際の値で、リストの各要素にたいして1つの値となります。次のステップは、関数@code{apply}(@ref{Calling
Functions}を参照してください)を使用して、引数のリストでその関数を呼び出します。関数がLispで記述されている場合、引数はその関数の引数変数にバインドするために使用されます。その後、関数body内のフォームが順番に評価され、listのbodyフォームの値は、関数呼び出しの値になります。

@node Macro Forms
@subsection Lisp Macro Evaluation
@cindex macro call evaluation

  リストの最初の要素がマクロオブジェクトと評価された場合、そのリストは@dfn{マクロ呼び出し(macro
call)}になります。マクロ呼び出しが評価されるとき、リストの残りの要素は、最初は評価され@emph{ません}。そのかわり、これらの要素自体が、マクロの引数に使用されます。そのマクロ定義は、これは元のフォームの場所で評価される、置き換えのフォームを計算します。これは、マクロの@dfn{展開(expansion)}と呼ばれます。展開した結果は、任意の種類のフォーム
---
自己評価定数、シンボル、リストになります。展開した結果自体がマクロ呼び出しの場合、結果が他の種類のフォームになるまで、繰り返し展開処理が行なわれます。

  通常のマクロ展開は、その展開形を評価することにより終了します。しかし、他のプログラムもマクロ呼び出しを展開し、それらが展開形を評価するかもしれないし、評価しないかもしれないので、そのマクロ展開がすぐに、または最終的に評価される必要がない場合があります。

  引き数式は通常、マクロ展開の計算の一部としては評価されませんが、展開の部分として現れるので、展開形が評価されるとき計算されます。

  たとえば、以下のようなマクロ定義が与えられたとします:

@example
@group
(defmacro cadr (x)
  (list 'car (list 'cdr x)))
@end group
@end example

@noindent
@code{(cadr (assq 'handler list))}のような式はマクロ呼び出しであり、展開形は以下のようになります:

@example
(car (cdr (assq 'handler list)))
@end example

@noindent
引数@code{(assq 'handler list)}が、展開形に含まれることに注意してください。

Emacs Lispマクロの完全な説明は、@ref{Macros}を参照してください。

@node Special Forms
@subsection Special Forms
@cindex special forms
@cindex evaluation of special forms

  @dfn{スペシャルフォーム(special
form)}は特別だとマークされた基本関数で、その引数のすべては評価されません。もっともスペシャルなフォームは、制御構造の定義や、変数バインディングの処理など、関数ではできないことを行ないます。

  スペシャルフォームはそれぞれ、どの引数が評価されて、どの引数が評価されないかについて、独自のルールをもちます。特定の引数が評価されるかどうかは、他の引数を評価した結果に依存します。

  式の最初のシンボルがスペシャルフォームの場合、その式はそのスペシャルフォームのルールにしたがう必要があります。それ以外では、Emacsの挙動は(たとえクラッシュしなくても)定義されていません。たとえば@code{((lambda
(x) x . 3)
4)}は、@code{lambda}で始まるサブ式を含みますが、これは適正な@code{lambda}式ではないので、Emacsはエラーをシグナルするか、3、または4、または@code{nil}、もしかしたら他の挙動を示すかもしれません。

@defun special-form-p object
この述語は、引数がスペシャルフォームかをテストし、スペシャルフォームなら@code{t}、それ以外は@code{nil}をreturnします。
@end defun

  以下に、Emacs Lispのスペシャルフォームすべてと、それらがどこで説明されているかのリファレンスとともに、アルファベット順でリストします。

@table @code
@item and
@pxref{Combining Conditions}

@item catch
@pxref{Catch and Throw}

@item cond
@pxref{Conditionals}

@item condition-case
@pxref{Handling Errors}

@item defconst
@pxref{Defining Variables}

@item defvar
@pxref{Defining Variables}

@item function
@pxref{Anonymous Functions}

@item if
@pxref{Conditionals}

@item interactive
@pxref{Interactive Call}

@item lambda
@pxref{Lambda Expressions}

@item let
@itemx let*
@pxref{Local Variables}

@item or
@pxref{Combining Conditions}

@item prog1
@itemx prog2
@itemx progn
@pxref{Sequencing}

@item quote
@pxref{Quoting}

@item save-current-buffer
@pxref{Current Buffer}

@item save-excursion
@pxref{Excursions}

@item save-restriction
@pxref{Narrowing}

@item setq
@pxref{Setting Variables}

@item setq-default
@pxref{Creating Buffer-Local}

@item track-mouse
@pxref{Mouse Tracking}

@item unwind-protect
@pxref{Nonlocal Exits}

@item while
@pxref{Iteration}
@end table

@cindex CL note---special forms compared
@quotation
@b{Common Lispに関する注意: }ここで、GNU Emacsのスペシャルフォームと、Common
Lispのスペシャルフォームを比較してみます。@code{setq}、@code{if}、@code{catch}は、Emacs LispとCommon
Lispの両方でスペシャルフォームです。@code{save-excursion}はEmacs Lispではスペシャルフォームですが、Common
Lispには存在しません。@code{throw}はCommon
Lispではスペシャルフォーム(なぜなら複数の値をthrowできなければならない)ですが、Emacs Lispでは(複数の値をもたない)関数です。
@end quotation

@node Autoloading
@subsection Autoloading

  @dfn{オートロード(autoload)}機能により、関数定義がだEmacsにロードされていない関数(またはマクロ)を呼び出すことができます。オートロードは、定義がどのファイルに含まれるかを指定します。オートロードオブジェクトがシンボルの関数定義にある場合、関数としてそのシンボルを呼び出すことにより、自動的に指定されたファイルがロードされます。その後、ファイルからロードされた実際の定義を呼び出します。シンボル内の関数定義としてオートロードオブジェクトをアレンジする方法は、@ref{Autoload}で説明します。

@node Quoting
@section Quoting

  スペシャルフォーム@code{quote}は、単一の引数を、記述されたとおり、評価せずにreturnします。これはプログラムに、自己評価オブジェクトではない、定数シンボルや定数リストを含める方法を提供します(数字、文字列、ベクターのような自己評価オブジェクトをクォートする必要はありません)。

@defspec quote object
このスペシャルフォームは、評価せずに@var{object}をreturnします。
@end defspec

@cindex @samp{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
プログラム中で@code{quote}はよく使用されるので、Lispはそれにたいする便利な入力構文を提供します。アポストロフィー文字(@samp{'})に続けてLispオブジェクト(の入力構文)を記述すると、それは1番目の要素が@code{quote}で、2番目の要素がそのオブジェクトであるリストに展開されます。したがって、入力構文@code{'x}は、@code{(quote
x)}の略記になります。

以下に、@code{quote}を使用した式の例をいくつか示します:

@example
@group
(quote (+ 1 2))
     @result{} (+ 1 2)
@end group
@group
(quote foo)
     @result{} foo
@end group
@group
'foo
     @result{} foo
@end group
@group
''foo
     @result{} (quote foo)
@end group
@group
'(quote foo)
     @result{} (quote foo)
@end group
@group
['foo]
     @result{} [(quote foo)]
@end group
@end example

  他のクォート構成には、コンパイル用にLispで記述された無名のラムダ式の元になる@code{function}(@ref{Anonymous
Functions}を参照してください)、および、リストを計算して置き換える際に、リストの一部だけをクォートするのに使用される@samp{`}(@ref{Backquote}を参照してください)があります。

@node Backquote
@section Backquote
@cindex backquote (list substitution)
@cindex ` (list substitution)
@findex `

  @dfn{バッククォート構成(backquote
constructs)}を使用することにより、リストをクォートして、そのリストのある要素を選択的に評価することができます。もっとも簡単な使い方では、スペシャルフォーム@code{quote}と同じです
@iftex
@end iftex
@ifnottex
(前のセクションで説明しています。@ref{Quoting}を参照してください)。
@end ifnottex
たとえば、以下の2つのフォームは同じ結果を生みます:

@example
@group
`(a list of (+ 2 3) elements)
     @result{} (a list of (+ 2 3) elements)
@end group
@group
'(a list of (+ 2 3) elements)
     @result{} (a list of (+ 2 3) elements)
@end group
@end example

@findex , @r{(with backquote)}
  バッククォートする引数の内側でスペシャルマーカー@samp{,}を使用すると、それは値が定数でないことを示します。Emacs
Lispエバリュエーターは@samp{,}がついた引数を放火して、リスト構造内にその値を配します:

@example
@group
`(a list of ,(+ 2 3) elements)
     @result{} (a list of 5 elements)
@end group
@end example

@noindent
@samp{,}による置き換え、リスト構造のより深いレベルでも使用できます。たとえば:

@example
@group
`(1 2 (3 ,(+ 4 5)))
     @result{} (1 2 (3 9))
@end group
@end example

@findex ,@@ @r{(with backquote)}
@cindex splicing (with backquote)
  スペシャルマーカー@samp{,@@}を使用すれば、評価された値を結果リストに@dfn{継ぎ足す(splice)}こともできます。継ぎ足されたリストの要素は、結果リスト内の他の要素を同じレベルになります。@samp{`}を使用しない等価なコードは、しばしば読むのが困難です。以下にいくつかの例を示します:

@example
@group
(setq some-list '(2 3))
     @result{} (2 3)
@end group
@group
(cons 1 (append some-list '(4) some-list))
     @result{} (1 2 3 4 2 3)
@end group
@group
`(1 ,@@some-list 4 ,@@some-list)
     @result{} (1 2 3 4 2 3)
@end group

@group
(setq list '(hack foo bar))
     @result{} (hack foo bar)
@end group
@group
(cons 'use
  (cons 'the
    (cons 'words (append (cdr list) '(as elements)))))
     @result{} (use the words foo bar as elements)
@end group
@group
`(use the words ,@@(cdr list) as elements)
     @result{} (use the words foo bar as elements)
@end group
@end example


@node Eval
@section Eval

  ほとんどの場合、実行されるプログラム内に出現することにより、フォームは自動的に評価されます。稀に、実行時 ---
たとえば編集されているテキストや、プロパティーリストから取得したフォームを読み取った後 ---
に計算されるように、フォームを評価するコードを記述する必要があるかもしれません。このようなときは、@code{eval}関数を使用します。@code{eval}が不必要だったり、かわりに他の何かを使用すべきときが、しばしばあります。たとえば、変数から値を取得するには、@code{eval}も機能しますが、@code{symbol-value}のほうが適しています。@code{eval}で評価するためにプロパティーリストに式を格納するより、かわりに@code{funcall}に渡すように関数を格納した方がよいでしょう。

  このセクションで説明する関数と変数は、フォームの評価、評価処理の制限の指定、最後にreturnされた値の記録を行なうものです。ファイルのロードでも評価が行なわれます(@ref{Loading}を参照してください)。

  データ構造に式を格納してそれを評価するより、データ構造に関数を格納して、それを@code{funcall}や@code{apply}で呼び出すほうが、より明解かつ柔軟です。関数を使用することにより、引数に情報を渡す能力が提供されます。

@defun eval form &optional lexical
これは、式を評価する、基本的な関数です。この関数は、カレント環境内で@var{form}を評価して、その結果をreturnします。@var{form}オブジェクトの型は、それが評価される方法を決定します。@ref{Forms}を参照してください。

引数@var{lexical}は、ローカル変数にたいするスコープ規則(@ref{Variable
Scoping}を参照してください)を指定します。これが省略されるか@code{nil}の場合、デフォルトのダイナミックスコープ規則を使用して@var{form}を評価することを意味します。@code{t}の場合は、レキシカルスコープ規則が使用されることを意味します。@var{lexical}の値には、レキシカルバインディングにたいする特定の@dfn{レキシカル環境(lexical
environment)}を指定する、空ではないalistも指定できます。しかし、この機能はEmacs
Lispデバッガーのような、特別な目的にたいしてのみ有用です。@ref{Lexical Binding}を参照してください。

@code{eval}は関数なので、@code{eval}呼び出しに現れる引数式は2回 ---
1度は@code{eval}が呼び出される前の準備、そして@code{eval}関数自身によりもう1度 --- 評価されます。以下は例です:

@example
@group
(setq foo 'bar)
     @result{} bar
@end group
@group
(setq bar 'baz)
     @result{} baz
;; @r{@code{eval}が引数@code{foo}を受け取る。}
(eval 'foo)
     @result{} bar
;; @r{@code{eval}が、@code{foo}の値である、引数@code{bar}を受け取る。}
(eval foo)
     @result{} baz
@end group
@end example

@code{eval}により現在アクティブな呼び出しの数は、@code{max-lisp-eval-depth}に制限されます(以下参照)。
@end defun

@deffn Command eval-region start end &optional stream read-function
@anchor{Definition of eval-region}
この関数は、カレントバッファー内の、位置@var{start}と@var{end}で定義されるリージョン内のフォームを評価します。この関数はそのリージョンからフォームを読み取り、それらにたいし@code{eval}を呼び出します。これは、リージョンの最後に達するまで、または処理されないエラーがシグナルされるまで行なわれます。

デフォルトでは、@code{eval-region}は何の出力も生成しません。しかし、@var{stream}が非@code{nil}の場合、出力関数(@ref{Output
Functions}を参照してください)で生成された任意の出力、同様にリージョン内の式を評価した結果の値は、@var{stream}を使用してプリントされます。@ref{Output
Streams}を参照してください。

@var{read-function}が非@code{nil}の場合、@code{read}のかわりに1つずつ式を読み取るために使用する関数を指定します。これは、入力を読み取るストリームを指定する、1つの引数で呼び出される関数です。この関数を指定するために変数@code{load-read-function}(@ref{Definition
of load-read-function,, How Programs Do
Loading}を参照してください)も使用できますが、引数@var{read-function}を使用するほうが確実です。

@code{eval-region}はポイントを移動しません。つねに@code{nil}をreturnします。
@end deffn

@cindex evaluation of buffer contents
@deffn Command eval-buffer &optional buffer-or-name stream filename unibyte print
この関数は@code{eval-region}と似ていますが、引数は異なるオプション機能を提供します。@code{eval-buffer}は、バッファー@var{buffer-or-name}のアクセス可能な部分全体を処理します。@var{buffer-or-name}にはバッファー名(文字列)を指定でき、@code{nil}(または省略)のときはカレントバッファーを意味します。@var{stream}が@code{nil}かつ@var{print}が非@code{nil}でない場合、@code{eval-region}のように@var{stream}が使用されます。この場合、式の評価による結果の値は依然として破棄されますが、出力関数による出力はエコーエリアにプリントされます。@var{filename}は、@code{load-history}(@ref{Unloading}を参照してください)に使用されるファイル名で、デフォルトは@code{buffer-file-name}(@ref{Buffer
File
Name}を参照してください)です。@var{unibyte}が非@code{nil}の場合、可能な限り@code{read}は文字列をユニコードに変換します。

@findex eval-current-buffer
@code{eval-current-buffer}は、このコマンドのエイリアスです。
@end deffn

@defopt max-lisp-eval-depth
@anchor{Definition of max-lisp-eval-depth}
この変数は、エラー(エラーメッセージは@code{"Lisp nesting exceeds
max-lisp-eval-depth"})がシグナルされる前に、@code{eval}、@code{apply}、@code{funcall}の呼び出しで許される最大の深さを定義します。

制限を超えたときのエラーをもつこの制限は、Emacs
Lispで誤って定義された関数による無限再帰を避ける方法の1つです。@code{max-lisp-eval-depth}の値を過大に増加させた場合、そのようなコードはかわりにスタックオーバーフローを起こすでしょう。
@cindex Lisp nesting error

たとえば、Lisp式に記述された関数の呼び出し、関数呼び出しの引数と、関数bodyフォームにたいする再帰評価、Lispコード内での明示的な呼び出しなどにたいして、深さ制限を数えるために、内部的に@code{eval}、@code{apply}、@code{funcall}を使用します。

この変数のデフォルト値は400です。この値を100未満にセットした場合、値が与えられた値に達すると、Lispはそれを100にリセットします。空きが少ない場合、デバッガー自身を実行するために空きが必要になるので、Lispデバッガーに入ったときは、この値が増加されます。

@code{max-specpdl-size}はネストの他の制限を提供します。@ref{Definition of max-specpdl-size,,
Local Variables}を参照してください。
@end defopt

@defvar values
この変数の値は、読み取り、評価、プリントを行なった標準的なEmacsコマンドにより、バッファー(ミニバッファーを含む)からreturnされる値のリストです(これには@file{*ielm*}バッファーでの評価や、@code{lisp-interaction-mode}での@kbd{C-j}を使用した評価は含まれ@emph{ない}ことに注意してください)。要素の順番は、もっとも最近のものが最初になります。

@example
@group
(setq x 1)
     @result{} 1
@end group
@group
(list 'A (1+ 2) auto-save-default)
     @result{} (A 3 t)
@end group
@group
values
     @result{} ((A 3 t) 1 @dots{})
@end group
@end example

この変数は、最近評価されたフォームの値を後で参照するのに便利です。@code{values}自体の値をプリントするのは、それがおそらく非常に長くなるので、通常は悪いアイデアです。かわりに、以下のように特定の要素を調べます:

@example
@group
;; @r{もっとも最近評価された結果を参照する。}
(nth 0 values)
     @result{} (A 3 t)
@end group
@group
;; @r{これは新たな要素をputするので、}
;;   @r{すべての要素が1つ後に移動する。}
(nth 1 values)
     @result{} (A 3 t)
@end group
@group
;; @r{これは次に新しい、この例の前の次に新しい要素を取得する。}
(nth 3 values)
     @result{} 1
@end group
@end example
@end defvar
