# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-30 22:41+0900\n"
"PO-Revision-Date: 2019-10-11 00:00+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: eval.texi.orig:6 eval.texi.orig:7
#, no-wrap
msgid "Evaluation"
msgstr "Evaluation"

#. type: cindex
#: eval.texi.orig:8
#, no-wrap
msgid "evaluation"
msgstr "evaluation"

#. type: cindex
#: eval.texi.orig:9 eval.texi.orig:10
#, no-wrap
msgid "interpreter"
msgstr "interpreter"

#. type: cindex
#: eval.texi.orig:11
#, no-wrap
msgid "value of expression"
msgstr "value of expression"

#. type: Plain text
#: eval.texi.orig:20
msgid "The @dfn{evaluation} of expressions in Emacs Lisp is performed by the @dfn{Lisp interpreter}---a program that receives a Lisp object as input and computes its @dfn{value as an expression}.  How it does this depends on the data type of the object, according to rules described in this chapter.  The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function @code{eval}."
msgstr "Emacs Lispでの式の@dfn{評価(evaluation)}は、@dfn{Lispインタープリター} --- 入力としてLispオブジェクトを受け取り、それの@dfn{式としての値(value as an expression)}を計算します --- により処理されます。評価を行なう方法は、そのオブジェクトのデータ型に依存し、それはこのチャプターで説明するルールにより行なわれます。インタープリターは、プログラムの一部を評価するために自動的に実行されますが、Lisp基本関数の@code{eval}を通じて、明示的に呼び出すこともできます。"

#. type: node
#: eval.texi.orig:28 eval.texi.orig:30
#, no-wrap
msgid "Intro Eval"
msgstr "Intro Eval"

#. type: menuentry
#: eval.texi.orig:28
msgid "Evaluation in the scheme of things."
msgstr "事の在り方における評価。"

#. type: node
#: eval.texi.orig:28 eval.texi.orig:101
#, no-wrap
msgid "Forms"
msgstr "Forms"

#. type: menuentry
#: eval.texi.orig:28
msgid "How various sorts of objects are evaluated."
msgstr "さまざまなオブジェクト類が評価される方法。"

#. type: section
#: eval.texi.orig:28 eval.texi.orig:494 eval.texi.orig:544 eval.texi.orig:545
#, no-wrap
msgid "Quoting"
msgstr "Quoting"

#. type: menuentry
#: eval.texi.orig:28
msgid "Avoiding evaluation (to put constants in the program)."
msgstr "(プログラム内に定数を配すための)評価の回避。"

#. type: section
#: eval.texi.orig:28 eval.texi.orig:600 eval.texi.orig:601
#, no-wrap
msgid "Backquote"
msgstr "Backquote"

#. type: menuentry
#: eval.texi.orig:28
msgid "Easier construction of list structure."
msgstr "リスト構造の、より簡単な構築。"

#. type: section
#: eval.texi.orig:28 eval.texi.orig:690 eval.texi.orig:691
#, no-wrap
msgid "Eval"
msgstr "Eval"

#. type: menuentry
#: eval.texi.orig:28
msgid "How to invoke the Lisp interpreter explicitly."
msgstr "Lispインタープリターを明示的に呼び出す方法。"

#. type: section
#: eval.texi.orig:31
#, no-wrap
msgid "Introduction to Evaluation"
msgstr "Introduction to Evaluation"

#. type: ifnottex
#: eval.texi.orig:39
msgid "The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it.  When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body.  Thus, running any Lisp program really means running the Lisp interpreter."
msgstr "Lispインタープリター(またはLispエバリュエーター)は、Emacsの一部で、与えられた式の値を計算します。Lispで記述された関数が呼び出されるとき、エバリュエーターはその関数のbody(本文)の中の式を評価することにより、その関数の値を計算します。したがって、Lispプログラムを実行するとは、実際にはLispインタープリターを実行することを意味します。"

#. type: cindex
#: eval.texi.orig:41
#, no-wrap
msgid "form"
msgstr "form"

#. type: cindex
#: eval.texi.orig:42
#, no-wrap
msgid "expression"
msgstr "expression"

#. type: cindex
#: eval.texi.orig:43
#, no-wrap
msgid "S-expression"
msgstr "S-expression"

#. type: cindex
#: eval.texi.orig:44
#, no-wrap
msgid "sexp"
msgstr "sexp"

#. type: Plain text
#: eval.texi.orig:53
msgid "A Lisp object that is intended for evaluation is called a @dfn{form} or @dfn{expression}@footnote{It is sometimes also referred to as an @dfn{S-expression} or @dfn{sexp}, but we generally do not use this terminology in this manual.}.  The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages.  Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often."
msgstr "評価されることを意図したLispオブジェクトは、@dfn{フォーム(form)}、または@dfn{式(expression)}と呼ばれます@footnote{@dfn{S式(S-expression)}、短くは@dfn{sexp}という言葉でも呼ばれることがありますが、わたしたちは通常、このマニュアル内ではこの用語は使用しません。}。フォームはデータオブジェクトであり、単なるテキストではないというのは、Lisp風の言語と、通常のプログラミング言語との間にある、基本的な相違の1つです。任意のオブジェクトを評価できますが、実際に評価される事が非常に多いのは数字、シンボル、リスト、文字列です。"

#. type: Plain text
#: eval.texi.orig:56
msgid "In subsequent sections, we will describe the details of what evaluation means for each kind of form."
msgstr "以降のセクションでは、各種フォームにたいして、それを評価することが何を意味するかの詳細を説明します。"

#. type: Plain text
#: eval.texi.orig:64
msgid "It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone.  Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself.  It is up to the caller of @code{read} to specify whether this object is a form to be evaluated, or serves some entirely different purpose.  @xref{Input Functions}."
msgstr "Lispフォームを読み取り、それからそのフォームを評価するのは、非常に一般的なアクティビティーですが、読み取りと評価は別のアクティビティーであり、どちらか一方を単独で処理することができます。読み取りだけでは、何も評価されません。読み取りはLispオブジェクトのプリント表現を、そのオブジェクト自体に変換します。このオブジェクトは評価されるべきフォームなのか、そのれともまったく違う目的をもつかを指定するのは、@code{read}の呼び出し元の役目です@ref{Input Functions}を参照してください。"

#. type: cindex
#: eval.texi.orig:65
#, no-wrap
msgid "recursive evaluation"
msgstr "recursive evaluation"

#. type: Plain text
#: eval.texi.orig:76
msgid "Evaluation is a recursive process, and evaluating a form often involves evaluating parts within that form.  For instance, when you evaluate a @dfn{function call} form such as @code{(car x)}, Emacs first evaluates the argument (the subform @code{x}).  After evaluating the argument, Emacs @dfn{executes} the function (@code{car}), and if the function is written in Lisp, execution works by evaluating the @dfn{body} of the function (in this example, however, @code{car} is not a Lisp function; it is a primitive function implemented in C).  @xref{Functions}, for more information about functions and function calls."
msgstr "評価とは再帰的な処理であり、あるフォームを評価することにより、そのフォームの一部が評価されるといったことがよくあります。たとえば、@code{(car x)}のような@dfn{関数呼び出し(function call)}のフォームを評価する場合、Emacsは最初にその引数(サブフォーム@code{x})を評価します。引数を評価した後、Emacsはその関数(@code{car})を@dfn{実行(executes)}します。その関数がLispで記述されている場合は、関数の@dfn{body(本文)}を評価することにより、実行が行なわれます(しかし、この例で使用している@code{car}はLisp関数ではなく、Cで実装された基本関数です)。関数と関数呼び出しについての情報は、@ref{Functions}を参照してください。"

#. type: cindex
#: eval.texi.orig:77
#, no-wrap
msgid "environment"
msgstr "environment"

#. type: Plain text
#: eval.texi.orig:87
msgid "Evaluation takes place in a context called the @dfn{environment}, which consists of the current values and bindings of all Lisp variables (@pxref{Variables}).@footnote{This definition of ``environment'' is specifically not intended to include all the data that can affect the result of a program.} Whenever a form refers to a variable without creating a new binding for it, the variable evaluates to the value given by the current environment.  Evaluating a form may also temporarily alter the environment by binding variables (@pxref{Local Variables})."
msgstr "評価は、@dfn{環境(environment)}と呼ばれるコンテキストの内部で行なわれます。環境は、すべてのLisp変数(@ref{Variables}を参照してください)のカレント値とバインディングにより構成されます。@footnote{``環境''にたいするこの定義は、プログラムの結果に影響し得るすべてのデータを特に意図するものではありません。}フォームが新たなバインディングを作成することなく、変数を参照するとき、その変数はカレントの環境により与えられる値に評価されます。フォームの評価は、変数のバインディングにより、一時的にその環境を変更することもあります(@ref{Local Variables}を参照してください)。"

#. type: cindex
#: eval.texi.orig:88
#, no-wrap
msgid "side effect"
msgstr "side effect"

#. type: Plain text
#: eval.texi.orig:92
msgid "Evaluating a form may also make changes that persist; these changes are called @dfn{side effects}.  An example of a form that produces a side effect is @code{(setq foo 1)}."
msgstr "フォームの評価が、永続する変更を行なうこともあります。これらの変更は、@dfn{副作用(side effects)}と呼ばれます。副作用を生成するフォームの例は、@code{(setq foo 1)}です。"

#. type: Plain text
#: eval.texi.orig:100
msgid "Do not confuse evaluation with command key interpretation.  The editor command loop translates keyboard input into a command (an interactively callable function) using the active keymaps, and then uses @code{call-interactively} to execute that command.  Executing the command usually involves evaluation, if the command is written in Lisp; however, this step is not considered a part of command key interpretation.  @xref{Command Loop}."
msgstr "コマンドキー解釈にたいする評価と混同しないでください。エディターのコマンドループは、アクティブなキーマップを使用して、キーボード入力をコマンド(インタラクティブに呼び出すことができる関数)に変換してから、そのコマンドを実行するために@code{call-interactively}を使用します。そのコマンドはLispで記述されている場合、コマンドの実行は通常、評価を伴います。しかし、このステップはコマンドキー解釈の一部とは考えません。@ref{Command Loop}を参照してください。"

#. type: section
#: eval.texi.orig:102
#, no-wrap
msgid "Kinds of Forms"
msgstr "Kinds of Forms"

#. type: Plain text
#: eval.texi.orig:110
msgid "A Lisp object that is intended to be evaluated is called a @dfn{form} (or an @dfn{expression}).  How Emacs evaluates a form depends on its data type.  Emacs has three different kinds of form that are evaluated differently: symbols, lists, and ``all other types''.  This section describes all three kinds, one by one, starting with the ``all other types'' which are self-evaluating forms."
msgstr "評価される事を意図したLispオブジェクトは、@dfn{フォーム(form)}または@dfn{式(expression)})と呼ばれます。Emacsがフォームを評価する方法は、フォームのデータ型に依存します。Emacsは、3種の異なるフォーム --- シンボル、リスト、および``その他すべての型'' --- を持ち、それらは評価される方法は異なります。このセクションでは、まず最初は自己評価フォームの``その他すべての型''から開始して、3つの種類をすべて1つずつ説明します。"

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:125 eval.texi.orig:126
#, no-wrap
msgid "Self-Evaluating Forms"
msgstr "Self-Evaluating Forms"

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that evaluate to themselves."
msgstr "自分自身を評価するフォーム。"

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:179 eval.texi.orig:180
#, no-wrap
msgid "Symbol Forms"
msgstr "Symbol Forms"

#. type: menuentry
#: eval.texi.orig:123
msgid "Symbols evaluate as variables."
msgstr "変数として評価されるシンボル。"

#. type: node
#: eval.texi.orig:123 eval.texi.orig:215
#, no-wrap
msgid "Classifying Lists"
msgstr "Classifying Lists"

#. type: menuentry
#: eval.texi.orig:123
msgid "How to distinguish various sorts of list forms."
msgstr "さまざまな種類のリストフォームを区別する方法。"

#. type: node
#: eval.texi.orig:123 eval.texi.orig:231
#, no-wrap
msgid "Function Indirection"
msgstr "Function Indirection"

#. type: menuentry
#: eval.texi.orig:123
msgid "When a symbol appears as the car of a list, we find the real function via the symbol."
msgstr "シンボルがリストのcarにある場合、そのシンボルを通じて実際の関数を見つける。"

#. type: node
#: eval.texi.orig:123 eval.texi.orig:349
#, no-wrap
msgid "Function Forms"
msgstr "Function Forms"

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that call functions."
msgstr "関数を呼び出すフォーム。"

#. type: node
#: eval.texi.orig:123 eval.texi.orig:373
#, no-wrap
msgid "Macro Forms"
msgstr "Macro Forms"

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that call macros."
msgstr "マクロを呼び出すフォーム。"

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:419 eval.texi.orig:420
#, no-wrap
msgid "Special Forms"
msgstr "Special Forms"

#. type: menuentry
#: eval.texi.orig:123
msgid "\"Special forms\" are idiosyncratic primitives, most of them extremely important."
msgstr "\"スペシャルフォーム\"は特別な基本フォームで、それらのほとんどがとても重要である。"

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:532 eval.texi.orig:533
#, no-wrap
msgid "Autoloading"
msgstr "Autoloading"

#. type: menuentry
#: eval.texi.orig:123
msgid "Functions set up to load files containing their real definitions."
msgstr "実際の定義を含むファイルのロードをセットアップする関数。"

#. type: cindex
#: eval.texi.orig:127
#, no-wrap
msgid "vector evaluation"
msgstr "vector evaluation"

#. type: cindex
#: eval.texi.orig:128
#, no-wrap
msgid "literal evaluation"
msgstr "literal evaluation"

#. type: cindex
#: eval.texi.orig:129
#, no-wrap
msgid "self-evaluating form"
msgstr "self-evaluating form"

#. type: Plain text
#: eval.texi.orig:138
msgid "A @dfn{self-evaluating form} is any form that is not a list or symbol.  Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated.  Thus, the number 25 evaluates to 25, and the string @code{\"foo\"} evaluates to the string @code{\"foo\"}.  Likewise, evaluating a vector does not cause evaluation of the elements of the vector---it returns the same vector with its contents unchanged."
msgstr "@dfn{自己評価フォーム(self-evaluating form)}は、リストやシンボルではない、任意のフォームです。自己評価フォームは、フォーム自身を評価します。評価の結果は、評価されたのと同じオブジェクトです。したがって、数字の25は25に評価され、文字列@code{\"foo\"}は文字列@code{\"foo\"}に評価されます。同様に、ベクターの評価では、ベクターの要素の評価は起こりません --- 内容が変更されずに同じベクターがreturnされます。"

#. type: group
#: eval.texi.orig:143
#, no-wrap
msgid ""
"'123               ; @r{A number, shown without evaluation.}\n"
"     @result{} 123\n"
msgstr ""
"'123               ; @r{評価されずに表示される数字。}\n"
"     @result{} 123\n"

#. type: group
#: eval.texi.orig:147
#, no-wrap
msgid ""
"123                ; @r{Evaluated as usual---result is the same.}\n"
"     @result{} 123\n"
msgstr ""
"123                ; @r{通常どおり評価され、同じものがreturnされる。}\n"
"     @result{} 123\n"

#. type: group
#: eval.texi.orig:151
#, no-wrap
msgid ""
"(eval '123)        ; @r{Evaluated ``by hand''---result is the same.}\n"
"     @result{} 123\n"
msgstr ""
"(eval '123)        ; @r{``手動''による評価 --- 同じものがreturnされる。}\n"
"     @result{} 123\n"

#. type: group
#: eval.texi.orig:155
#, no-wrap
msgid ""
"(eval (eval '123)) ; @r{Evaluating twice changes nothing.}\n"
"     @result{} 123\n"
msgstr ""
"(eval (eval '123)) ; @r{2度評価しても何も変わらない。}\n"
"     @result{} 123\n"

#. type: Plain text
#: eval.texi.orig:164
msgid "It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate.  However, it is quite unusual to do this for types that lack a read syntax, because there's no way to write them textually.  It is possible to construct Lisp expressions containing these types by means of a Lisp program.  Here is an example:"
msgstr "事項評価されるという事実による利点から、数字、文字、文字列、そしてベクターでさえ、Lispコード内で記述されるのは一般的です。しかし、入力構文がない型にたいしてこれを行なうのは極めて異例です。なぜなら、これらをテキスト的に記述する方法がないからです。Lispプログラムを使用して、これらの型を含むLisp式を構築するのは、可能です。以下は例です:"

#. type: group
#: eval.texi.orig:170
#, no-wrap
msgid ""
";; @r{Build an expression containing a buffer object.}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"
msgstr ""
";; @r{バッファーオブジェクトを含む式を構築する。}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"

#. type: group
#: eval.texi.orig:176
#, no-wrap
msgid ""
";; @r{Evaluate it.}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"
msgstr ""
";; @r{それを評価する。}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"

#. type: cindex
#: eval.texi.orig:181
#, no-wrap
msgid "symbol evaluation"
msgstr "symbol evaluation"

#. type: Plain text
#: eval.texi.orig:187
msgid "When a symbol is evaluated, it is treated as a variable.  The result is the variable's value, if it has one.  If the symbol has no value as a variable, the Lisp interpreter signals an error.  For more information on the use of variables, see @ref{Variables}."
msgstr "シンボルが評価されるときは、変数として扱われます。それが値をもつ場合、結果はその変数の値になります。そのシンボルが変数としての値をもたない場合、Lispインタープリターはエラーをシグナルします。変数の使用法についての情報は、@ref{Variables}を参照してください。"

#. type: Plain text
#: eval.texi.orig:191
msgid "In the following example, we set the value of a symbol with @code{setq}.  Then we evaluate the symbol, and get back the value that @code{setq} stored."
msgstr "以降の例では、@code{setq}でシンボルに値をセットしています。その後シンボルを評価してから、その値を@code{setq}に戻します。"

#. type: group
#: eval.texi.orig:196
#, no-wrap
msgid ""
"(setq a 123)\n"
"     @result{} 123\n"
msgstr ""
"(setq a 123)\n"
"     @result{} 123\n"

#. type: group
#: eval.texi.orig:200
#, no-wrap
msgid ""
"(eval 'a)\n"
"     @result{} 123\n"
msgstr ""
"(eval 'a)\n"
"     @result{} 123\n"

#. type: group
#: eval.texi.orig:204
#, no-wrap
msgid ""
"a\n"
"     @result{} 123\n"
msgstr ""
"a\n"
"     @result{} 123\n"

#. type: Plain text
#: eval.texi.orig:214
msgid "The symbols @code{nil} and @code{t} are treated specially, so that the value of @code{nil} is always @code{nil}, and the value of @code{t} is always @code{t}; you cannot set or bind them to any other values.  Thus, these two symbols act like self-evaluating forms, even though @code{eval} treats them like any other symbol.  A symbol whose name starts with @samp{:} also self-evaluates in the same way; likewise, its value ordinarily cannot be changed.  @xref{Constant Variables}."
msgstr "シンボル@code{nil}と@code{t}は特別に扱われるので、@code{nil}の値は常に@code{nil}になり、@code{t}の値は常に@code{t}になります。これらに他の値をセットしたり、他の値にバインドすることはできません。したがって、この2つのシンボルは、(たとえ@code{eval}がそれらを他の任意のシンボルと同じように扱うとはいえ)自己評価フォームと同じように振る舞います。名前が@samp{:}で始まるシンボルも、同じ方法で自己評価されます。そして、(通常は)値を変更できない点も同じです。@ref{Constant Variables}を参照してください。"

#. type: subsection
#: eval.texi.orig:216
#, no-wrap
msgid "Classification of List Forms"
msgstr "Classification of List Forms"

#. type: cindex
#: eval.texi.orig:217
#, no-wrap
msgid "list form evaluation"
msgstr "list form evaluation"

#. type: Plain text
#: eval.texi.orig:224
msgid "A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element.  These three kinds of forms are evaluated in different ways, described below.  The remaining list elements constitute the @dfn{arguments} for the function, macro, or special form."
msgstr "空ではないリストフォームは、関数呼び出し、マクロ呼び出し、スペシャルフォームのいずれかで、それは1番目の引数にしたがいます。これら3種のフォームは、以下で説明するように、異なる方法で評価されます。残りの要素は関数、マクロ、またはスペシャルフォームにたいする@dfn{引数(arguments)}を構成します。"

#. type: Plain text
#: eval.texi.orig:230
msgid "The first step in evaluating a nonempty list is to examine its first element.  This element alone determines what kind of form the list is and how the rest of the list is to be processed.  The first element is @emph{not} evaluated, as it would be in some Lisp dialects such as Scheme."
msgstr "空ではないリストを評価する最初のステップは、1番目の要素の確認です。この要素は単独で、そのリストがどの種類のフォームか、そして残りの引数をどのように処理するがを決定します。SchemeのようなLisp方言とは異なり、1番目の要素は評価されません。"

#. type: subsection
#: eval.texi.orig:232
#, no-wrap
msgid "Symbol Function Indirection"
msgstr "Symbol Function Indirection"

#. type: cindex
#: eval.texi.orig:233
#, no-wrap
msgid "symbol function indirection"
msgstr "symbol function indirection"

#. type: cindex
#: eval.texi.orig:234
#, no-wrap
msgid "indirection for functions"
msgstr "indirection for functions"

#. type: cindex
#: eval.texi.orig:235
#, no-wrap
msgid "void function"
msgstr "void function"

#. type: Plain text
#: eval.texi.orig:243
msgid "If the first element of the list is a symbol then evaluation examines the symbol's function cell, and uses its contents instead of the original symbol.  If the contents are another symbol, this process, called @dfn{symbol function indirection}, is repeated until it obtains a non-symbol.  @xref{Function Names}, for more information about symbol function indirection."
msgstr "リストの最初の要素がシンボルの場合、評価はそのシンボルの関数セルを調べて、元のシンボルの代わりに、関数セルの内容を使用します。その内容が他のシンボルの場合、シンボルではないものが得られるまで、このプロセスが繰り返されます。このプロセスを@dfn{シンボル関数インダイレクション(symbol function indirection: indirectionは間接の意)}と呼びます。シンボル関数インダイレクションについての情報は、@ref{Function Names}を参照してください。"

#. type: Plain text
#: eval.texi.orig:248
msgid "One possible consequence of this process is an infinite loop, in the event that a symbol's function cell refers to the same symbol.  Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object."
msgstr "このプロセスの結果、シンボルの関数競るが同じシンボルを参照する場合、無限ループを起こす可能性があります。それ以外は、最終的には非シンボルにたどりつき、これは関数か、他の適切なオブジェクトであるはずです。"

#. type: kindex
#: eval.texi.orig:249
#, no-wrap
msgid "invalid-function"
msgstr "invalid-function"

#. type: Plain text
#: eval.texi.orig:255
msgid "More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object.  Each of these types is a case described in one of the following sections.  If the object is not one of these types, Emacs signals an @code{invalid-function} error."
msgstr "より正確に言うと、それはLisp関数(ラムダ式)、バイトコード関数、基本関数、Lispマクロ、スペシャルフォーム、またはオートロードオブジェクトであるべきです。これらの型のそれぞれについては、以降のセクションで説明します。これらの型以外のオブジェクトの場合、emacsは@code{invalid-function}エラーをシグナルします。"

#. type: Plain text
#: eval.texi.orig:262
msgid "The following example illustrates the symbol indirection process.  We use @code{fset} to set the function cell of a symbol and @code{symbol-function} to get the function cell contents (@pxref{Function Cells}).  Specifically, we store the symbol @code{car} into the function cell of @code{first}, and the symbol @code{first} into the function cell of @code{erste}."
msgstr "以下の例は、シンボルインダイレクションのプロセスを説明するものです。わたしたちは、シンボルの関数セルに関数をセットするのに@code{fset}、関数セルの内容(@ref{Function Cells}を参照してください)を得るために@code{symbol-function}を使用します。具体的に言うと、@code{first}の関数セルにシンボル@code{car}を格納し、シンボル@code{first}を@code{erste}の関数セルに格納します。"

#. type: group
#: eval.texi.orig:269
#, no-wrap
msgid ""
";; @r{Build this function cell linkage:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"
msgstr ""
";; @r{この関数セルのリンクを構築する:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"

#. type: group
#: eval.texi.orig:273
#, no-wrap
msgid ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"
msgstr ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"

#. type: group
#: eval.texi.orig:277
#, no-wrap
msgid ""
"(fset 'first 'car)\n"
"     @result{} car\n"
msgstr ""
"(fset 'first 'car)\n"
"     @result{} car\n"

#. type: group
#: eval.texi.orig:281
#, no-wrap
msgid ""
"(fset 'erste 'first)\n"
"     @result{} first\n"
msgstr ""
"(fset 'erste 'first)\n"
"     @result{} first\n"

#. type: group
#: eval.texi.orig:285
#, no-wrap
msgid ""
"(erste '(1 2 3))   ; @r{Call the function referenced by @code{erste}.}\n"
"     @result{} 1\n"
msgstr ""
"(erste '(1 2 3))   ; @r{@code{erste}により参照される関数を呼び出す。}\n"
"     @result{} 1\n"

#. type: Plain text
#: eval.texi.orig:291
msgid "By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol."
msgstr "対照的に、以下の例はシンボル関数インダイレクションを使用せずに関数を呼び出します。なぜなら、1番目の要素はシンボルではなく、無名Lisp関数(anonymous Lisp function)だからです。"

#. type: group
#: eval.texi.orig:297
#, no-wrap
msgid ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"
msgstr ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"

#. type: Plain text
#: eval.texi.orig:303
msgid "Executing the function itself evaluates its body; this does involve symbol function indirection when calling @code{erste}."
msgstr "関数自身を実行すると、その関数のbodyを評価します。これは、@code{erste}を呼び出すとき、シンボル関数インダイレクションが行なわれます。"

#. type: Plain text
#: eval.texi.orig:306
msgid "This form is rarely used and is now deprecated.  Instead, you should write it as:"
msgstr "このフォームが使用されるのは稀で、今では推奨されません。かわりに以下のように記述するべきです:"

#. type: group
#: eval.texi.orig:311
#, no-wrap
msgid ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"
msgstr ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"

#. type: Plain text
#: eval.texi.orig:314
msgid "or just"
msgstr "または単に"

#. type: group
#: eval.texi.orig:317
#, no-wrap
msgid "(let ((arg '(1 2 3))) (erste arg))\n"
msgstr "(let ((arg '(1 2 3))) (erste arg))\n"

#. type: Plain text
#: eval.texi.orig:322
msgid "The built-in function @code{indirect-function} provides an easy way to perform symbol function indirection explicitly."
msgstr "ビルトイン関数の@code{indirect-function}は、明示的にシンボル関数インダイレクションを処理するための、簡単な方法を提供します。"

#. type: defun
#: eval.texi.orig:324
#, no-wrap
msgid "indirect-function function &optional noerror"
msgstr "indirect-function function &optional noerror"

#. type: anchor{#1}
#: eval.texi.orig:330
msgid "Definition of indirect-function"
msgstr "Definition of indirect-function"

#. type: defun
#: eval.texi.orig:330
msgid "This function returns the meaning of @var{function} as a function.  If @var{function} is a symbol, then it finds @var{function}'s function definition and starts over with that value.  If @var{function} is not a symbol, then it returns @var{function} itself."
msgstr "この関数は、@var{function}が意味するものを、関数としてreturnします。@var{function}がシンボルの場合は、@var{function}の関数定義を探して、その値で最初からやり直します。@var{function}がシンボルでない場合は、@var{function}自身をreturnします。"

#. type: defun
#: eval.texi.orig:335
msgid "This function signals a @code{void-function} error if the final symbol is unbound and optional argument @var{noerror} is @code{nil} or omitted.  Otherwise, if @var{noerror} is non-@code{nil}, it returns @code{nil} if the final symbol is unbound."
msgstr "この関数は、最後のシンボルがバインドされておらず、オプション引数@var{noerror}が省略されているか@code{nil}の場合は、@code{void-function}エラーをシグナルします。それ以外は、@var{noerror}が非@code{nil}の場合は、最後のシンボルがバインドされていなければ@code{nil}をreturnします。"

#. type: defun
#: eval.texi.orig:338
msgid "It signals a @code{cyclic-function-indirection} error if there is a loop in the chain of symbols."
msgstr "特定のシンボル内にループがある場合、この関数は@code{cyclic-function-indirection}エラーをシグナルします。"

#. type: defun
#: eval.texi.orig:340
msgid "Here is how you could define @code{indirect-function} in Lisp:"
msgstr "以下は、Lispで@code{indirect-function}を定義できるという例です:"

#. type: example
#: eval.texi.orig:346
#, no-wrap
msgid ""
"(defun indirect-function (function)\n"
"  (if (symbolp function)\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"
msgstr ""
"(defun indirect-function (function)\n"
"  (if (symbolp function)\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"

#. type: subsection
#: eval.texi.orig:350
#, no-wrap
msgid "Evaluation of Function Forms"
msgstr "Evaluation of Function Forms"

#. type: cindex
#: eval.texi.orig:351
#, no-wrap
msgid "function form evaluation"
msgstr "function form evaluation"

#. type: cindex
#: eval.texi.orig:352
#, no-wrap
msgid "function call"
msgstr "function call"

#. type: Plain text
#: eval.texi.orig:358
msgid "If the first element of a list being evaluated is a Lisp function object, byte-code object or primitive function object, then that list is a @dfn{function call}.  For example, here is a call to the function @code{+}:"
msgstr "リストの1番目の要素がLispの関数オブジェクト。バイトコードオブジェクト、基本関数オブジェクトと評価された場合、そのリストは@dfn{関数呼び出し(function call)}になります。たとえば、以下は関数@code{+}を呼び出します:"

#. type: example
#: eval.texi.orig:361
#, no-wrap
msgid "(+ 1 x)\n"
msgstr "(+ 1 x)\n"

#. type: Plain text
#: eval.texi.orig:372
msgid "The first step in evaluating a function call is to evaluate the remaining elements of the list from left to right.  The results are the actual argument values, one value for each list element.  The next step is to call the function with this list of arguments, effectively using the function @code{apply} (@pxref{Calling Functions}).  If the function is written in Lisp, the arguments are used to bind the argument variables of the function (@pxref{Lambda Expressions}); then the forms in the function body are evaluated in order, and the value of the last body form becomes the value of the function call."
msgstr "関数呼び出しを評価する最初のステップは、そのリストの残りの要素を左から右に評価します。結果は引数の実際の値で、リストの各要素にたいして1つの値となります。次のステップは、関数@code{apply}(@ref{Calling Functions}を参照してください)を使用して、引数のリストでその関数を呼び出します。関数がLispで記述されている場合、引数はその関数の引数変数にバインドするために使用されます。その後、関数body内のフォームが順番に評価され、listのbodyフォームの値は、関数呼び出しの値になります。"

#. type: subsection
#: eval.texi.orig:374
#, no-wrap
msgid "Lisp Macro Evaluation"
msgstr "Lisp Macro Evaluation"

#. type: cindex
#: eval.texi.orig:375
#, no-wrap
msgid "macro call evaluation"
msgstr "macro call evaluation"

#. type: Plain text
#: eval.texi.orig:386
msgid "If the first element of a list being evaluated is a macro object, then the list is a @dfn{macro call}.  When a macro call is evaluated, the elements of the rest of the list are @emph{not} initially evaluated.  Instead, these elements themselves are used as the arguments of the macro.  The macro definition computes a replacement form, called the @dfn{expansion} of the macro, to be evaluated in place of the original form.  The expansion may be any sort of form: a self-evaluating constant, a symbol, or a list.  If the expansion is itself a macro call, this process of expansion repeats until some other sort of form results."
msgstr "リストの最初の要素がマクロオブジェクトと評価された場合、そのリストは@dfn{マクロ呼び出し(macro call)}になります。マクロ呼び出しが評価されるとき、リストの残りの要素は、最初は評価され@emph{ません}。そのかわり、これらの要素自体が、マクロの引数に使用されます。そのマクロ定義は、これは元のフォームの場所で評価される、置き換えのフォームを計算します。これは、マクロの@dfn{展開(expansion)}と呼ばれます。展開した結果は、任意の種類のフォーム --- 自己評価定数、シンボル、リストになります。展開した結果自体がマクロ呼び出しの場合、結果が他の種類のフォームになるまで、繰り返し展開処理が行なわれます。"

#. type: Plain text
#: eval.texi.orig:391
msgid "Ordinary evaluation of a macro call finishes by evaluating the expansion.  However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions."
msgstr "通常のマクロ展開は、その展開形を評価することにより終了します。しかし、他のプログラムもマクロ呼び出しを展開し、それらが展開形を評価するかもしれないし、評価しないかもしれないので、そのマクロ展開がすぐに、または最終的に評価される必要がない場合があります。"

#. type: Plain text
#: eval.texi.orig:395
msgid "Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated."
msgstr "引き数式は通常、マクロ展開の計算の一部としては評価されませんが、展開の部分として現れるので、展開形が評価されるとき計算されます。"

#. type: Plain text
#: eval.texi.orig:397
msgid "For example, given a macro defined as follows:"
msgstr "たとえば、以下のようなマクロ定義が与えられたとします:"

#. type: group
#: eval.texi.orig:402
#, no-wrap
msgid ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"
msgstr ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"

#. type: Plain text
#: eval.texi.orig:408
msgid "an expression such as @code{(cadr (assq 'handler list))} is a macro call, and its expansion is:"
msgstr "@code{(cadr (assq 'handler list))}のような式はマクロ呼び出しであり、展開形は以下のようになります:"

#. type: example
#: eval.texi.orig:411
#, no-wrap
msgid "(car (cdr (assq 'handler list)))\n"
msgstr "(car (cdr (assq 'handler list)))\n"

#. type: Plain text
#: eval.texi.orig:416
msgid "Note that the argument @code{(assq 'handler list)} appears in the expansion."
msgstr "引数@code{(assq 'handler list)}が、展開形に含まれることに注意してください。"

#. type: Plain text
#: eval.texi.orig:418
msgid "@xref{Macros}, for a complete description of Emacs Lisp macros."
msgstr "Emacs Lispマクロの完全な説明は、@ref{Macros}を参照してください。"

#. type: cindex
#: eval.texi.orig:421
#, no-wrap
msgid "special forms"
msgstr "special forms"

#. type: cindex
#: eval.texi.orig:422
#, no-wrap
msgid "evaluation of special forms"
msgstr "evaluation of special forms"

#. type: Plain text
#: eval.texi.orig:428
msgid "A @dfn{special form} is a primitive function specially marked so that its arguments are not all evaluated.  Most special forms define control structures or perform variable bindings---things which functions cannot do."
msgstr "@dfn{スペシャルフォーム(special form)}は特別だとマークされた基本関数で、その引数のすべては評価されません。もっともスペシャルなフォームは、制御構造の定義や、変数バインディングの処理など、関数ではできないことを行ないます。"

#. type: Plain text
#: eval.texi.orig:432
msgid "Each special form has its own rules for which arguments are evaluated and which are used without evaluation.  Whether a particular argument is evaluated may depend on the results of evaluating other arguments."
msgstr "スペシャルフォームはそれぞれ、どの引数が評価されて、どの引数が評価されないかについて、独自のルールをもちます。特定の引数が評価されるかどうかは、他の引数を評価した結果に依存します。"

#. type: Plain text
#: eval.texi.orig:440
msgid "If an expression's first symbol is that of a special form, the expression should follow the rules of that special form; otherwise, Emacs's behavior is not well-defined (though it will not crash).  For example, @code{((lambda (x) x . 3) 4)} contains a subexpression that begins with @code{lambda} but is not a well-formed @code{lambda} expression, so Emacs may signal an error, or may return 3 or 4 or @code{nil}, or may behave in other ways."
msgstr "式の最初のシンボルがスペシャルフォームの場合、その式はそのスペシャルフォームのルールにしたがう必要があります。それ以外では、Emacsの挙動は(たとえクラッシュしなくても)定義されていません。たとえば@code{((lambda (x) x . 3) 4)}は、@code{lambda}で始まるサブ式を含みますが、これは適正な@code{lambda}式ではないので、Emacsはエラーをシグナルするか、3、または4、または@code{nil}、もしかしたら他の挙動を示すかもしれません。"

#. type: defun
#: eval.texi.orig:441
#, no-wrap
msgid "special-form-p object"
msgstr "special-form-p object"

#. type: defun
#: eval.texi.orig:444
msgid "This predicate tests whether its argument is a special form, and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は、引数がスペシャルフォームかをテストし、スペシャルフォームなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: Plain text
#: eval.texi.orig:448
msgid "Here is a list, in alphabetical order, of all of the special forms in Emacs Lisp with a reference to where each is described."
msgstr "以下に、Emacs Lispのスペシャルフォームすべてと、それらがどこで説明されているかのリファレンスとともに、アルファベット順でリストします。"

#. type: item
#: eval.texi.orig:450
#, no-wrap
msgid "and"
msgstr "and"

#. type: pxref{#1}
#: eval.texi.orig:452 eval.texi.orig:486
msgid "Combining Conditions"
msgstr "Combining Conditions"

#. type: item
#: eval.texi.orig:453
#, no-wrap
msgid "catch"
msgstr "catch"

#. type: pxref{#1}
#: eval.texi.orig:455
msgid "Catch and Throw"
msgstr "Catch and Throw"

#. type: item
#: eval.texi.orig:456
#, no-wrap
msgid "cond"
msgstr "cond"

#. type: pxref{#1}
#: eval.texi.orig:458 eval.texi.orig:473
msgid "Conditionals"
msgstr "Conditionals"

#. type: item
#: eval.texi.orig:459
#, no-wrap
msgid "condition-case"
msgstr "condition-case"

#. type: pxref{#1}
#: eval.texi.orig:461
msgid "Handling Errors"
msgstr "Handling Errors"

#. type: item
#: eval.texi.orig:462
#, no-wrap
msgid "defconst"
msgstr "defconst"

#. type: pxref{#1}
#: eval.texi.orig:464 eval.texi.orig:467
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: item
#: eval.texi.orig:465
#, no-wrap
msgid "defvar"
msgstr "defvar"

#. type: item
#: eval.texi.orig:468
#, no-wrap
msgid "function"
msgstr "function"

#. type: pxref{#1}
#: eval.texi.orig:470
msgid "Anonymous Functions"
msgstr "Anonymous Functions"

#. type: item
#: eval.texi.orig:471
#, no-wrap
msgid "if"
msgstr "if"

#. type: item
#: eval.texi.orig:474
#, no-wrap
msgid "interactive"
msgstr "interactive"

#. type: pxref{#1}
#: eval.texi.orig:476
msgid "Interactive Call"
msgstr "Interactive Call"

#. type: item
#: eval.texi.orig:477
#, no-wrap
msgid "lambda"
msgstr "lambda"

#. type: pxref{#1}
#: eval.texi.orig:479
msgid "Lambda Expressions"
msgstr "Lambda Expressions"

#. type: item
#: eval.texi.orig:480
#, no-wrap
msgid "let"
msgstr "let"

#. type: itemx
#: eval.texi.orig:481
#, no-wrap
msgid "let*"
msgstr "let*"

#. type: pxref{#1}
#: eval.texi.orig:483
msgid "Local Variables"
msgstr "Local Variables"

#. type: item
#: eval.texi.orig:484
#, no-wrap
msgid "or"
msgstr "or"

#. type: item
#: eval.texi.orig:487
#, no-wrap
msgid "prog1"
msgstr "prog1"

#. type: itemx
#: eval.texi.orig:488
#, no-wrap
msgid "prog2"
msgstr "prog2"

#. type: itemx
#: eval.texi.orig:489
#, no-wrap
msgid "progn"
msgstr "progn"

#. type: pxref{#1}
#: eval.texi.orig:491
msgid "Sequencing"
msgstr "Sequencing"

#. type: item
#: eval.texi.orig:492
#, no-wrap
msgid "quote"
msgstr "quote"

#. type: item
#: eval.texi.orig:495
#, no-wrap
msgid "save-current-buffer"
msgstr "save-current-buffer"

#. type: pxref{#1}
#: eval.texi.orig:497
msgid "Current Buffer"
msgstr "Current Buffer"

#. type: item
#: eval.texi.orig:498
#, no-wrap
msgid "save-excursion"
msgstr "save-excursion"

#. type: pxref{#1}
#: eval.texi.orig:500
msgid "Excursions"
msgstr "Excursions"

#. type: item
#: eval.texi.orig:501
#, no-wrap
msgid "save-restriction"
msgstr "save-restriction"

#. type: pxref{#1}
#: eval.texi.orig:503
msgid "Narrowing"
msgstr "Narrowing"

#. type: item
#: eval.texi.orig:504
#, no-wrap
msgid "setq"
msgstr "setq"

#. type: pxref{#1}
#: eval.texi.orig:506
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: item
#: eval.texi.orig:507
#, no-wrap
msgid "setq-default"
msgstr "setq-default"

#. type: pxref{#1}
#: eval.texi.orig:509
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: item
#: eval.texi.orig:510
#, no-wrap
msgid "track-mouse"
msgstr "track-mouse"

#. type: pxref{#1}
#: eval.texi.orig:512
msgid "Mouse Tracking"
msgstr "Mouse Tracking"

#. type: item
#: eval.texi.orig:513
#, no-wrap
msgid "unwind-protect"
msgstr "unwind-protect"

#. type: pxref{#1}
#: eval.texi.orig:515
msgid "Nonlocal Exits"
msgstr "Nonlocal Exits"

#. type: item
#: eval.texi.orig:516
#, no-wrap
msgid "while"
msgstr "while"

#. type: pxref{#1}
#: eval.texi.orig:518
msgid "Iteration"
msgstr "Iteration"

#. type: cindex
#: eval.texi.orig:520
#, no-wrap
msgid "CL note---special forms compared"
msgstr "CL note---special forms compared"

#. type: quotation
#: eval.texi.orig:530
msgid "@b{Common Lisp note:} Here are some comparisons of special forms in GNU Emacs Lisp and Common Lisp.  @code{setq}, @code{if}, and @code{catch} are special forms in both Emacs Lisp and Common Lisp.  @code{save-excursion} is a special form in Emacs Lisp, but doesn't exist in Common Lisp.  @code{throw} is a special form in Common Lisp (because it must be able to throw multiple values), but it is a function in Emacs Lisp (which doesn't have multiple values)."
msgstr "@b{Common Lispに関する注意: }ここで、GNU Emacsのスペシャルフォームと、Common Lispのスペシャルフォームを比較してみます。@code{setq}、@code{if}、@code{catch}は、Emacs LispとCommon Lispの両方でスペシャルフォームです。@code{save-excursion}はEmacs Lispではスペシャルフォームですが、Common Lispには存在しません。@code{throw}はCommon Lispではスペシャルフォーム(なぜなら複数の値をthrowできなければならない)ですが、Emacs Lispでは(複数の値をもたない)関数です。"

#. type: Plain text
#: eval.texi.orig:543
msgid "The @dfn{autoload} feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs.  It specifies which file contains the definition.  When an autoload object appears as a symbol's function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file.  The way to arrange for an autoload object to appear as a symbol's function definition is described in @ref{Autoload}."
msgstr "@dfn{オートロード(autoload)}機能により、関数定義がだEmacsにロードされていない関数(またはマクロ)を呼び出すことができます。オートロードは、定義がどのファイルに含まれるかを指定します。オートロードオブジェクトがシンボルの関数定義にある場合、関数としてそのシンボルを呼び出すことにより、自動的に指定されたファイルがロードされます。その後、ファイルからロードされた実際の定義を呼び出します。シンボル内の関数定義としてオートロードオブジェクトをアレンジする方法は、@ref{Autoload}で説明します。"

#. type: Plain text
#: eval.texi.orig:552
msgid "The special form @code{quote} returns its single argument, as written, without evaluating it.  This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program.  (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)"
msgstr "スペシャルフォーム@code{quote}は、単一の引数を、記述されたとおり、評価せずにreturnします。これはプログラムに、自己評価オブジェクトではない、定数シンボルや定数リストを含める方法を提供します(数字、文字列、ベクターのような自己評価オブジェクトをクォートする必要はありません)。"

#. type: defspec
#: eval.texi.orig:553
#, no-wrap
msgid "quote object"
msgstr "quote object"

#. type: defspec
#: eval.texi.orig:555
msgid "This special form returns @var{object}, without evaluating it."
msgstr "このスペシャルフォームは、評価せずに@var{object}をreturnします。"

#. type: cindex
#: eval.texi.orig:557
#, no-wrap
msgid "@samp{'} for quoting"
msgstr "@samp{'} for quoting"

#. type: cindex
#: eval.texi.orig:558
#, no-wrap
msgid "quoting using apostrophe"
msgstr "quoting using apostrophe"

#. type: cindex
#: eval.texi.orig:559
#, no-wrap
msgid "apostrophe for quoting"
msgstr "apostrophe for quoting"

#. type: Plain text
#: eval.texi.orig:565
msgid "Because @code{quote} is used so often in programs, Lisp provides a convenient read syntax for it.  An apostrophe character (@samp{'})  followed by a Lisp object (in read syntax) expands to a list whose first element is @code{quote}, and whose second element is the object.  Thus, the read syntax @code{'x} is an abbreviation for @code{(quote x)}."
msgstr "プログラム中で@code{quote}はよく使用されるので、Lispはそれにたいする便利な入力構文を提供します。アポストロフィー文字(@samp{'})に続けてLispオブジェクト(の入力構文)を記述すると、それは1番目の要素が@code{quote}で、2番目の要素がそのオブジェクトであるリストに展開されます。したがって、入力構文@code{'x}は、@code{(quote x)}の略記になります。"

#. type: Plain text
#: eval.texi.orig:567
msgid "Here are some examples of expressions that use @code{quote}:"
msgstr "以下に、@code{quote}を使用した式の例をいくつか示します:"

#. type: group
#: eval.texi.orig:572
#, no-wrap
msgid ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"
msgstr ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"

#. type: group
#: eval.texi.orig:576
#, no-wrap
msgid ""
"(quote foo)\n"
"     @result{} foo\n"
msgstr ""
"(quote foo)\n"
"     @result{} foo\n"

#. type: group
#: eval.texi.orig:580
#, no-wrap
msgid ""
"'foo\n"
"     @result{} foo\n"
msgstr ""
"'foo\n"
"     @result{} foo\n"

#. type: group
#: eval.texi.orig:584
#, no-wrap
msgid ""
"''foo\n"
"     @result{} (quote foo)\n"
msgstr ""
"''foo\n"
"     @result{} (quote foo)\n"

#. type: group
#: eval.texi.orig:588
#, no-wrap
msgid ""
"'(quote foo)\n"
"     @result{} (quote foo)\n"
msgstr ""
"'(quote foo)\n"
"     @result{} (quote foo)\n"

#. type: group
#: eval.texi.orig:592
#, no-wrap
msgid ""
"['foo]\n"
"     @result{} [(quote foo)]\n"
msgstr ""
"['foo]\n"
"     @result{} [(quote foo)]\n"

#. type: Plain text
#: eval.texi.orig:599
msgid "Other quoting constructs include @code{function} (@pxref{Anonymous Functions}), which causes an anonymous lambda expression written in Lisp to be compiled, and @samp{`} (@pxref{Backquote}), which is used to quote only part of a list, while computing and substituting other parts."
msgstr "他のクォート構成には、コンパイル用にLispで記述された無名のラムダ式の元になる@code{function}(@ref{Anonymous Functions}を参照してください)、および、リストを計算して置き換える際に、リストの一部だけをクォートするのに使用される@samp{`}(@ref{Backquote}を参照してください)があります。"

#. type: cindex
#: eval.texi.orig:602
#, no-wrap
msgid "backquote (list substitution)"
msgstr "backquote (list substitution)"

#. type: cindex
#: eval.texi.orig:603
#, no-wrap
msgid "` (list substitution)"
msgstr "` (list substitution)"

#. type: findex
#: eval.texi.orig:604
#, no-wrap
msgid "`"
msgstr "`"

#. type: Plain text
#: eval.texi.orig:609
msgid "@dfn{Backquote constructs} allow you to quote a list, but selectively evaluate elements of that list.  In the simplest case, it is identical to the special form @code{quote}"
msgstr "@dfn{バッククォート構成(backquote constructs)}を使用することにより、リストをクォートして、そのリストのある要素を選択的に評価することができます。もっとも簡単な使い方では、スペシャルフォーム@code{quote}と同じです"

#. type: ifnottex
#: eval.texi.orig:613
msgid "(described in the previous section; @pxref{Quoting})."
msgstr "(前のセクションで説明しています。@ref{Quoting}を参照してください)。"

#. type: Plain text
#: eval.texi.orig:615
msgid "For example, these two forms yield identical results:"
msgstr "たとえば、以下の2つのフォームは同じ結果を生みます:"

#. type: group
#: eval.texi.orig:620
#, no-wrap
msgid ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"

#. type: group
#: eval.texi.orig:624
#, no-wrap
msgid ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"

#. type: findex
#: eval.texi.orig:627
#, no-wrap
msgid ", @r{(with backquote)}"
msgstr ", @r{(with backquote)}"

#. type: Plain text
#: eval.texi.orig:632
msgid "The special marker @samp{,} inside of the argument to backquote indicates a value that isn't constant.  The Emacs Lisp evaluator evaluates the argument of @samp{,}, and puts the value in the list structure:"
msgstr "バッククォートする引数の内側でスペシャルマーカー@samp{,}を使用すると、それは値が定数でないことを示します。Emacs Lispエバリュエーターは@samp{,}がついた引数を放火して、リスト構造内にその値を配します:"

#. type: group
#: eval.texi.orig:637
#, no-wrap
msgid ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"
msgstr ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"

#. type: Plain text
#: eval.texi.orig:643
msgid "Substitution with @samp{,} is allowed at deeper levels of the list structure also.  For example:"
msgstr "@samp{,}による置き換え、リスト構造のより深いレベルでも使用できます。たとえば:"

#. type: group
#: eval.texi.orig:648
#, no-wrap
msgid ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"
msgstr ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"

#. type: findex
#: eval.texi.orig:651
#, no-wrap
msgid ",@@ @r{(with backquote)}"
msgstr ",@@ @r{(with backquote)}"

#. type: cindex
#: eval.texi.orig:652
#, no-wrap
msgid "splicing (with backquote)"
msgstr "splicing (with backquote)"

#. type: Plain text
#: eval.texi.orig:658
msgid "You can also @dfn{splice} an evaluated value into the resulting list, using the special marker @samp{,@@}.  The elements of the spliced list become elements at the same level as the other elements of the resulting list.  The equivalent code without using @samp{`} is often unreadable.  Here are some examples:"
msgstr "スペシャルマーカー@samp{,@@}を使用すれば、評価された値を結果リストに@dfn{継ぎ足す(splice)}こともできます。継ぎ足されたリストの要素は、結果リスト内の他の要素を同じレベルになります。@samp{`}を使用しない等価なコードは、しばしば読むのが困難です。以下にいくつかの例を示します:"

#. type: group
#: eval.texi.orig:663
#, no-wrap
msgid ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"
msgstr ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"

#. type: group
#: eval.texi.orig:667
#, no-wrap
msgid ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"

#. type: group
#: eval.texi.orig:671
#, no-wrap
msgid ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"

#. type: group
#: eval.texi.orig:676
#, no-wrap
msgid ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"
msgstr ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"

#. type: group
#: eval.texi.orig:682
#, no-wrap
msgid ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"

#. type: group
#: eval.texi.orig:686
#, no-wrap
msgid ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"

#. type: Plain text
#: eval.texi.orig:703
msgid "Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run.  On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list.  On these occasions, use the @code{eval} function.  Often @code{eval} is not needed and something else should be used instead.  For example, to get the value of a variable, while @code{eval} works, @code{symbol-value} is preferable; or rather than store expressions in a property list that then need to go through @code{eval}, it is better to store functions instead that are then passed to @code{funcall}."
msgstr "ほとんどの場合、実行されるプログラム内に出現することにより、フォームは自動的に評価されます。稀に、実行時 --- たとえば編集されているテキストや、プロパティーリストから取得したフォームを読み取った後 --- に計算されるように、フォームを評価するコードを記述する必要があるかもしれません。このようなときは、@code{eval}関数を使用します。@code{eval}が不必要だったり、かわりに他の何かを使用すべきときが、しばしばあります。たとえば、変数から値を取得するには、@code{eval}も機能しますが、@code{symbol-value}のほうが適しています。@code{eval}で評価するためにプロパティーリストに式を格納するより、かわりに@code{funcall}に渡すように関数を格納した方がよいでしょう。"

#. type: Plain text
#: eval.texi.orig:707
msgid "The functions and variables described in this section evaluate forms, specify limits to the evaluation process, or record recently returned values.  Loading a file also does evaluation (@pxref{Loading})."
msgstr "このセクションで説明する関数と変数は、フォームの評価、評価処理の制限の指定、最後にreturnされた値の記録を行なうものです。ファイルのロードでも評価が行なわれます(@ref{Loading}を参照してください)。"

#. type: Plain text
#: eval.texi.orig:713
msgid "It is generally cleaner and more flexible to store a function in a data structure, and call it with @code{funcall} or @code{apply}, than to store an expression in the data structure and evaluate it.  Using functions provides the ability to pass information to them as arguments."
msgstr "データ構造に式を格納してそれを評価するより、データ構造に関数を格納して、それを@code{funcall}や@code{apply}で呼び出すほうが、より明解かつ柔軟です。関数を使用することにより、引数に情報を渡す能力が提供されます。"

#. type: defun
#: eval.texi.orig:714
#, no-wrap
msgid "eval form &optional lexical"
msgstr "eval form &optional lexical"

#. type: defun
#: eval.texi.orig:719
msgid "This is the basic function for evaluating an expression.  It evaluates @var{form} in the current environment, and returns the result.  The type of the @var{form} object determines how it is evaluated.  @xref{Forms}."
msgstr "これは、式を評価する、基本的な関数です。この関数は、カレント環境内で@var{form}を評価して、その結果をreturnします。@var{form}オブジェクトの型は、それが評価される方法を決定します。@ref{Forms}を参照してください。"

#. type: defun
#: eval.texi.orig:728
msgid "The argument @var{lexical} specifies the scoping rule for local variables (@pxref{Variable Scoping}).  If it is omitted or @code{nil}, that means to evaluate @var{form} using the default dynamic scoping rule.  If it is @code{t}, that means to use the lexical scoping rule.  The value of @var{lexical} can also be a non-empty alist specifying a particular @dfn{lexical environment} for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers.  @xref{Lexical Binding}."
msgstr "引数@var{lexical}は、ローカル変数にたいするスコープ規則(@ref{Variable Scoping}を参照してください)を指定します。これが省略されるか@code{nil}の場合、デフォルトのダイナミックスコープ規則を使用して@var{form}を評価することを意味します。@code{t}の場合は、レキシカルスコープ規則が使用されることを意味します。@var{lexical}の値には、レキシカルバインディングにたいする特定の@dfn{レキシカル環境(lexical environment)}を指定する、空ではないalistも指定できます。しかし、この機能はEmacs Lispデバッガーのような、特別な目的にたいしてのみ有用です。@ref{Lexical Binding}を参照してください。"

#. type: defun
#: eval.texi.orig:733
msgid "Since @code{eval} is a function, the argument expression that appears in a call to @code{eval} is evaluated twice: once as preparation before @code{eval} is called, and again by the @code{eval} function itself.  Here is an example:"
msgstr "@code{eval}は関数なので、@code{eval}呼び出しに現れる引数式は2回 --- 1度は@code{eval}が呼び出される前の準備、そして@code{eval}関数自身によりもう1度 --- 評価されます。以下は例です:"

#. type: group
#: eval.texi.orig:738
#, no-wrap
msgid ""
"(setq foo 'bar)\n"
"     @result{} bar\n"
msgstr ""
"(setq foo 'bar)\n"
"     @result{} bar\n"

#. type: group
#: eval.texi.orig:748
#, no-wrap
msgid ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{Here @code{eval} receives argument @code{foo}}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{Here @code{eval} receives argument @code{bar}, which is the value of @code{foo}}\n"
"(eval foo)\n"
"     @result{} baz\n"
msgstr ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{@code{eval}が引数@code{foo}を受け取る。}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{@code{eval}が、@code{foo}の値である、引数@code{bar}を受け取る。}\n"
"(eval foo)\n"
"     @result{} baz\n"

#. type: defun
#: eval.texi.orig:753
msgid "The number of currently active calls to @code{eval} is limited to @code{max-lisp-eval-depth} (see below)."
msgstr "@code{eval}により現在アクティブな呼び出しの数は、@code{max-lisp-eval-depth}に制限されます(以下参照)。"

#. type: deffn
#: eval.texi.orig:755
#, no-wrap
msgid "Command eval-region start end &optional stream read-function"
msgstr "Command eval-region start end &optional stream read-function"

#. type: anchor{#1}
#: eval.texi.orig:761
msgid "Definition of eval-region"
msgstr "Definition of eval-region"

#. type: deffn
#: eval.texi.orig:761
msgid "This function evaluates the forms in the current buffer in the region defined by the positions @var{start} and @var{end}.  It reads forms from the region and calls @code{eval} on them until the end of the region is reached, or until an error is signaled and not handled."
msgstr "この関数は、カレントバッファー内の、位置@var{start}と@var{end}で定義されるリージョン内のフォームを評価します。この関数はそのリージョンからフォームを読み取り、それらにたいし@code{eval}を呼び出します。これは、リージョンの最後に達するまで、または処理されないエラーがシグナルされるまで行なわれます。"

#. type: deffn
#: eval.texi.orig:767
msgid "By default, @code{eval-region} does not produce any output.  However, if @var{stream} is non-@code{nil}, any output produced by output functions (@pxref{Output Functions}), as well as the values that result from evaluating the expressions in the region are printed using @var{stream}.  @xref{Output Streams}."
msgstr "デフォルトでは、@code{eval-region}は何の出力も生成しません。しかし、@var{stream}が非@code{nil}の場合、出力関数(@ref{Output Functions}を参照してください)で生成された任意の出力、同様にリージョン内の式を評価した結果の値は、@var{stream}を使用してプリントされます。@ref{Output Streams}を参照してください。"

#. type: deffn
#: eval.texi.orig:775
msgid "If @var{read-function} is non-@code{nil}, it should be a function, which is used instead of @code{read} to read expressions one by one.  This function is called with one argument, the stream for reading input.  You can also use the variable @code{load-read-function} (@pxref{Definition of load-read-function,, How Programs Do Loading})  to specify this function, but it is more robust to use the @var{read-function} argument."
msgstr "@var{read-function}が非@code{nil}の場合、@code{read}のかわりに1つずつ式を読み取るために使用する関数を指定します。これは、入力を読み取るストリームを指定する、1つの引数で呼び出される関数です。この関数を指定するために変数@code{load-read-function}(@ref{Definition of load-read-function,, How Programs Do Loading}を参照してください)も使用できますが、引数@var{read-function}を使用するほうが確実です。"

#. type: deffn
#: eval.texi.orig:777
msgid "@code{eval-region} does not move point.  It always returns @code{nil}."
msgstr "@code{eval-region}はポイントを移動しません。つねに@code{nil}をreturnします。"

#. type: cindex
#: eval.texi.orig:779
#, no-wrap
msgid "evaluation of buffer contents"
msgstr "evaluation of buffer contents"

#. type: deffn
#: eval.texi.orig:780
#, no-wrap
msgid "Command eval-buffer &optional buffer-or-name stream filename unibyte print"
msgstr "Command eval-buffer &optional buffer-or-name stream filename unibyte print"

#. type: deffn
#: eval.texi.orig:794
msgid "This is similar to @code{eval-region}, but the arguments provide different optional features.  @code{eval-buffer} operates on the entire accessible portion of buffer @var{buffer-or-name}.  @var{buffer-or-name} can be a buffer, a buffer name (a string), or @code{nil} (or omitted), which means to use the current buffer.  @var{stream} is used as in @code{eval-region}, unless @var{stream} is @code{nil} and @var{print} non-@code{nil}.  In that case, values that result from evaluating the expressions are still discarded, but the output of the output functions is printed in the echo area.  @var{filename} is the file name to use for @code{load-history} (@pxref{Unloading}), and defaults to @code{buffer-file-name} (@pxref{Buffer File Name}).  If @var{unibyte} is non-@code{nil}, @code{read} converts strings to unibyte whenever possible."
msgstr "この関数は@code{eval-region}と似ていますが、引数は異なるオプション機能を提供します。@code{eval-buffer}は、バッファー@var{buffer-or-name}のアクセス可能な部分全体を処理します。@var{buffer-or-name}にはバッファー名(文字列)を指定でき、@code{nil}(または省略)のときはカレントバッファーを意味します。@var{stream}が@code{nil}かつ@var{print}が非@code{nil}でない場合、@code{eval-region}のように@var{stream}が使用されます。この場合、式の評価による結果の値は依然として破棄されますが、出力関数による出力はエコーエリアにプリントされます。@var{filename}は、@code{load-history}(@ref{Unloading}を参照してください)に使用されるファイル名で、デフォルトは@code{buffer-file-name}(@ref{Buffer File Name}を参照してください)です。@var{unibyte}が非@code{nil}の場合、可能な限り@code{read}は文字列をユニコードに変換します。"

#. type: findex
#: eval.texi.orig:795
#, no-wrap
msgid "eval-current-buffer"
msgstr "eval-current-buffer"

#. type: deffn
#: eval.texi.orig:797
msgid "@code{eval-current-buffer} is an alias for this command."
msgstr "@code{eval-current-buffer}は、このコマンドのエイリアスです。"

#. type: defopt
#: eval.texi.orig:799
#, no-wrap
msgid "max-lisp-eval-depth"
msgstr "max-lisp-eval-depth"

#. type: anchor{#1}
#: eval.texi.orig:804
msgid "Definition of max-lisp-eval-depth"
msgstr "Definition of max-lisp-eval-depth"

#. type: defopt
#: eval.texi.orig:804
msgid "This variable defines the maximum depth allowed in calls to @code{eval}, @code{apply}, and @code{funcall} before an error is signaled (with error message @code{\"Lisp nesting exceeds max-lisp-eval-depth\"})."
msgstr "この変数は、エラー(エラーメッセージは@code{\"Lisp nesting exceeds max-lisp-eval-depth\"})がシグナルされる前に、@code{eval}、@code{apply}、@code{funcall}の呼び出しで許される最大の深さを定義します。"

#. type: defopt
#: eval.texi.orig:809
msgid "This limit, with the associated error when it is exceeded, is one way Emacs Lisp avoids infinite recursion on an ill-defined function.  If you increase the value of @code{max-lisp-eval-depth} too much, such code can cause stack overflow instead."
msgstr "制限を超えたときのエラーをもつこの制限は、Emacs Lispで誤って定義された関数による無限再帰を避ける方法の1つです。@code{max-lisp-eval-depth}の値を過大に増加させた場合、そのようなコードはかわりにスタックオーバーフローを起こすでしょう。"

#. type: cindex
#: eval.texi.orig:809
#, no-wrap
msgid "Lisp nesting error"
msgstr "Lisp nesting error"

#. type: defopt
#: eval.texi.orig:815
msgid "The depth limit counts internal uses of @code{eval}, @code{apply}, and @code{funcall}, such as for calling the functions mentioned in Lisp expressions, and recursive evaluation of function call arguments and function body forms, as well as explicit calls in Lisp code."
msgstr "たとえば、Lisp式に記述された関数の呼び出し、関数呼び出しの引数と、関数bodyフォームにたいする再帰評価、Lispコード内での明示的な呼び出しなどにたいして、深さ制限を数えるために、内部的に@code{eval}、@code{apply}、@code{funcall}を使用します。"

#. type: defopt
#: eval.texi.orig:821
msgid "The default value of this variable is 400.  If you set it to a value less than 100, Lisp will reset it to 100 if the given value is reached.  Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute."
msgstr "この変数のデフォルト値は400です。この値を100未満にセットした場合、値が与えられた値に達すると、Lispはそれを100にリセットします。空きが少ない場合、デバッガー自身を実行するために空きが必要になるので、Lispデバッガーに入ったときは、この値が増加されます。"

#. type: defopt
#: eval.texi.orig:824
msgid "@code{max-specpdl-size} provides another limit on nesting.  @xref{Definition of max-specpdl-size,, Local Variables}."
msgstr "@code{max-specpdl-size}はネストの他の制限を提供します。@ref{Definition of max-specpdl-size,, Local Variables}を参照してください。"

#. type: defvar
#: eval.texi.orig:826
#, no-wrap
msgid "values"
msgstr "values"

#. type: defvar
#: eval.texi.orig:834
msgid "The value of this variable is a list of the values returned by all the expressions that were read, evaluated, and printed from buffers (including the minibuffer) by the standard Emacs commands which do this.  (Note that this does @emph{not} include evaluation in @file{*ielm*} buffers, nor evaluation using @kbd{C-j} in @code{lisp-interaction-mode}.)  The elements are ordered most recent first."
msgstr "この変数の値は、読み取り、評価、プリントを行なった標準的なEmacsコマンドにより、バッファー(ミニバッファーを含む)からreturnされる値のリストです(これには@file{*ielm*}バッファーでの評価や、@code{lisp-interaction-mode}での@kbd{C-j}を使用した評価は含まれ@emph{ない}ことに注意してください)。要素の順番は、もっとも最近のものが最初になります。"

#. type: group
#: eval.texi.orig:839
#, no-wrap
msgid ""
"(setq x 1)\n"
"     @result{} 1\n"
msgstr ""
"(setq x 1)\n"
"     @result{} 1\n"

#. type: group
#: eval.texi.orig:843
#, no-wrap
msgid ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"
msgstr ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: eval.texi.orig:847
#, no-wrap
msgid ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"
msgstr ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"

#. type: defvar
#: eval.texi.orig:854
msgid "This variable is useful for referring back to values of forms recently evaluated.  It is generally a bad idea to print the value of @code{values} itself, since this may be very long.  Instead, examine particular elements, like this:"
msgstr "この変数は、最近評価されたフォームの値を後で参照するのに便利です。@code{values}自体の値をプリントするのは、それがおそらく非常に長くなるので、通常は悪いアイデアです。かわりに、以下のように特定の要素を調べます:"

#. type: group
#: eval.texi.orig:860
#, no-wrap
msgid ""
";; @r{Refer to the most recent evaluation result.}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""
";; @r{もっとも最近評価された結果を参照する。}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: eval.texi.orig:866
#, no-wrap
msgid ""
";; @r{That put a new element on,}\n"
";;   @r{so all elements move back one.}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""
";; @r{これは新たな要素をputするので、}\n"
";;   @r{すべての要素が1つ後に移動する。}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"

#. type: group
#: eval.texi.orig:872
#, no-wrap
msgid ""
";; @r{This gets the element that was next-to-most-recent}\n"
";;   @r{before this example.}\n"
"(nth 3 values)\n"
"     @result{} 1\n"
msgstr ""
";; @r{これは次に新しい、この例の前の次に新しい要素を取得する。}\n"
"(nth 3 values)\n"
"     @result{} 1\n"
