# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-30 22:41+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: eval.texi.orig:6 eval.texi.orig:7
#, no-wrap
msgid "Evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:8
#, no-wrap
msgid "evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:9 eval.texi.orig:10
#, no-wrap
msgid "interpreter"
msgstr ""

#. type: cindex
#: eval.texi.orig:11
#, no-wrap
msgid "value of expression"
msgstr ""

#. type: Plain text
#: eval.texi.orig:20
msgid ""
"The @dfn{evaluation} of expressions in Emacs Lisp is performed by the "
"@dfn{Lisp interpreter}---a program that receives a Lisp object as input and "
"computes its @dfn{value as an expression}.  How it does this depends on the "
"data type of the object, according to rules described in this chapter.  The "
"interpreter runs automatically to evaluate portions of your program, but can "
"also be called explicitly via the Lisp primitive function @code{eval}."
msgstr ""

#. type: node
#: eval.texi.orig:28 eval.texi.orig:30
#, no-wrap
msgid "Intro Eval"
msgstr ""

#. type: menuentry
#: eval.texi.orig:28
msgid "Evaluation in the scheme of things."
msgstr ""

#. type: node
#: eval.texi.orig:28 eval.texi.orig:101
#, no-wrap
msgid "Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:28
msgid "How various sorts of objects are evaluated."
msgstr ""

#. type: section
#: eval.texi.orig:28 eval.texi.orig:494 eval.texi.orig:544 eval.texi.orig:545
#, no-wrap
msgid "Quoting"
msgstr ""

#. type: menuentry
#: eval.texi.orig:28
msgid "Avoiding evaluation (to put constants in the program)."
msgstr ""

#. type: section
#: eval.texi.orig:28 eval.texi.orig:600 eval.texi.orig:601
#, no-wrap
msgid "Backquote"
msgstr ""

#. type: menuentry
#: eval.texi.orig:28
msgid "Easier construction of list structure."
msgstr ""

#. type: section
#: eval.texi.orig:28 eval.texi.orig:690 eval.texi.orig:691
#, no-wrap
msgid "Eval"
msgstr ""

#. type: menuentry
#: eval.texi.orig:28
msgid "How to invoke the Lisp interpreter explicitly."
msgstr ""

#. type: section
#: eval.texi.orig:31
#, no-wrap
msgid "Introduction to Evaluation"
msgstr ""

#. type: ifnottex
#: eval.texi.orig:39
msgid ""
"The Lisp interpreter, or evaluator, is the part of Emacs that computes the "
"value of an expression that is given to it.  When a function written in Lisp "
"is called, the evaluator computes the value of the function by evaluating "
"the expressions in the function body.  Thus, running any Lisp program really "
"means running the Lisp interpreter."
msgstr ""

#. type: cindex
#: eval.texi.orig:41
#, no-wrap
msgid "form"
msgstr ""

#. type: cindex
#: eval.texi.orig:42
#, no-wrap
msgid "expression"
msgstr ""

#. type: cindex
#: eval.texi.orig:43
#, no-wrap
msgid "S-expression"
msgstr ""

#. type: cindex
#: eval.texi.orig:44
#, no-wrap
msgid "sexp"
msgstr ""

#. type: Plain text
#: eval.texi.orig:53
msgid ""
"A Lisp object that is intended for evaluation is called a @dfn{form} or "
"@dfn{expression}@footnote{It is sometimes also referred to as an "
"@dfn{S-expression} or @dfn{sexp}, but we generally do not use this "
"terminology in this manual.}.  The fact that forms are data objects and not "
"merely text is one of the fundamental differences between Lisp-like "
"languages and typical programming languages.  Any object can be evaluated, "
"but in practice only numbers, symbols, lists and strings are evaluated very "
"often."
msgstr ""

#. type: Plain text
#: eval.texi.orig:56
msgid ""
"In subsequent sections, we will describe the details of what evaluation "
"means for each kind of form."
msgstr ""

#. type: Plain text
#: eval.texi.orig:64
msgid ""
"It is very common to read a Lisp form and then evaluate the form, but "
"reading and evaluation are separate activities, and either can be performed "
"alone.  Reading per se does not evaluate anything; it converts the printed "
"representation of a Lisp object to the object itself.  It is up to the "
"caller of @code{read} to specify whether this object is a form to be "
"evaluated, or serves some entirely different purpose.  @xref{Input "
"Functions}."
msgstr ""

#. type: cindex
#: eval.texi.orig:65
#, no-wrap
msgid "recursive evaluation"
msgstr ""

#. type: Plain text
#: eval.texi.orig:76
msgid ""
"Evaluation is a recursive process, and evaluating a form often involves "
"evaluating parts within that form.  For instance, when you evaluate a "
"@dfn{function call} form such as @code{(car x)}, Emacs first evaluates the "
"argument (the subform @code{x}).  After evaluating the argument, Emacs "
"@dfn{executes} the function (@code{car}), and if the function is written in "
"Lisp, execution works by evaluating the @dfn{body} of the function (in this "
"example, however, @code{car} is not a Lisp function; it is a primitive "
"function implemented in C).  @xref{Functions}, for more information about "
"functions and function calls."
msgstr ""

#. type: cindex
#: eval.texi.orig:77
#, no-wrap
msgid "environment"
msgstr ""

#. type: Plain text
#: eval.texi.orig:87
msgid ""
"Evaluation takes place in a context called the @dfn{environment}, which "
"consists of the current values and bindings of all Lisp variables "
"(@pxref{Variables}).@footnote{This definition of ``environment'' is "
"specifically not intended to include all the data that can affect the result "
"of a program.} Whenever a form refers to a variable without creating a new "
"binding for it, the variable evaluates to the value given by the current "
"environment.  Evaluating a form may also temporarily alter the environment "
"by binding variables (@pxref{Local Variables})."
msgstr ""

#. type: cindex
#: eval.texi.orig:88
#, no-wrap
msgid "side effect"
msgstr ""

#. type: Plain text
#: eval.texi.orig:92
msgid ""
"Evaluating a form may also make changes that persist; these changes are "
"called @dfn{side effects}.  An example of a form that produces a side effect "
"is @code{(setq foo 1)}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:100
msgid ""
"Do not confuse evaluation with command key interpretation.  The editor "
"command loop translates keyboard input into a command (an interactively "
"callable function) using the active keymaps, and then uses "
"@code{call-interactively} to execute that command.  Executing the command "
"usually involves evaluation, if the command is written in Lisp; however, "
"this step is not considered a part of command key interpretation.  "
"@xref{Command Loop}."
msgstr ""

#. type: section
#: eval.texi.orig:102
#, no-wrap
msgid "Kinds of Forms"
msgstr ""

#. type: Plain text
#: eval.texi.orig:110
msgid ""
"A Lisp object that is intended to be evaluated is called a @dfn{form} (or an "
"@dfn{expression}).  How Emacs evaluates a form depends on its data type.  "
"Emacs has three different kinds of form that are evaluated differently: "
"symbols, lists, and ``all other types''.  This section describes all three "
"kinds, one by one, starting with the ``all other types'' which are "
"self-evaluating forms."
msgstr ""

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:125 eval.texi.orig:126
#, no-wrap
msgid "Self-Evaluating Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that evaluate to themselves."
msgstr ""

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:179 eval.texi.orig:180
#, no-wrap
msgid "Symbol Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "Symbols evaluate as variables."
msgstr ""

#. type: node
#: eval.texi.orig:123 eval.texi.orig:215
#, no-wrap
msgid "Classifying Lists"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "How to distinguish various sorts of list forms."
msgstr ""

#. type: node
#: eval.texi.orig:123 eval.texi.orig:231
#, no-wrap
msgid "Function Indirection"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid ""
"When a symbol appears as the car of a list, we find the real function via "
"the symbol."
msgstr ""

#. type: node
#: eval.texi.orig:123 eval.texi.orig:349
#, no-wrap
msgid "Function Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that call functions."
msgstr ""

#. type: node
#: eval.texi.orig:123 eval.texi.orig:373
#, no-wrap
msgid "Macro Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "Forms that call macros."
msgstr ""

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:419 eval.texi.orig:420
#, no-wrap
msgid "Special Forms"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid ""
"\"Special forms\" are idiosyncratic primitives, most of them extremely "
"important."
msgstr ""

#. type: subsection
#: eval.texi.orig:123 eval.texi.orig:532 eval.texi.orig:533
#, no-wrap
msgid "Autoloading"
msgstr ""

#. type: menuentry
#: eval.texi.orig:123
msgid "Functions set up to load files containing their real definitions."
msgstr ""

#. type: cindex
#: eval.texi.orig:127
#, no-wrap
msgid "vector evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:128
#, no-wrap
msgid "literal evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:129
#, no-wrap
msgid "self-evaluating form"
msgstr ""

#. type: Plain text
#: eval.texi.orig:138
msgid ""
"A @dfn{self-evaluating form} is any form that is not a list or symbol.  "
"Self-evaluating forms evaluate to themselves: the result of evaluation is "
"the same object that was evaluated.  Thus, the number 25 evaluates to 25, "
"and the string @code{\"foo\"} evaluates to the string @code{\"foo\"}.  "
"Likewise, evaluating a vector does not cause evaluation of the elements of "
"the vector---it returns the same vector with its contents unchanged."
msgstr ""

#. type: group
#: eval.texi.orig:143
#, no-wrap
msgid ""
"'123               ; @r{A number, shown without evaluation.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: eval.texi.orig:147
#, no-wrap
msgid ""
"123                ; @r{Evaluated as usual---result is the same.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: eval.texi.orig:151
#, no-wrap
msgid ""
"(eval '123)        ; @r{Evaluated ``by hand''---result is the same.}\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: eval.texi.orig:155
#, no-wrap
msgid ""
"(eval (eval '123)) ; @r{Evaluating twice changes nothing.}\n"
"     @result{} 123\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:164
msgid ""
"It is common to write numbers, characters, strings, and even vectors in Lisp "
"code, taking advantage of the fact that they self-evaluate.  However, it is "
"quite unusual to do this for types that lack a read syntax, because there's "
"no way to write them textually.  It is possible to construct Lisp "
"expressions containing these types by means of a Lisp program.  Here is an "
"example:"
msgstr ""

#. type: group
#: eval.texi.orig:170
#, no-wrap
msgid ""
";; @r{Build an expression containing a buffer object.}\n"
"(setq print-exp (list 'print (current-buffer)))\n"
"     @result{} (print #<buffer eval.texi>)\n"
msgstr ""

#. type: group
#: eval.texi.orig:176
#, no-wrap
msgid ""
";; @r{Evaluate it.}\n"
"(eval print-exp)\n"
"     @print{} #<buffer eval.texi>\n"
"     @result{} #<buffer eval.texi>\n"
msgstr ""

#. type: cindex
#: eval.texi.orig:181
#, no-wrap
msgid "symbol evaluation"
msgstr ""

#. type: Plain text
#: eval.texi.orig:187
msgid ""
"When a symbol is evaluated, it is treated as a variable.  The result is the "
"variable's value, if it has one.  If the symbol has no value as a variable, "
"the Lisp interpreter signals an error.  For more information on the use of "
"variables, see @ref{Variables}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:191
msgid ""
"In the following example, we set the value of a symbol with @code{setq}.  "
"Then we evaluate the symbol, and get back the value that @code{setq} stored."
msgstr ""

#. type: group
#: eval.texi.orig:196
#, no-wrap
msgid ""
"(setq a 123)\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: eval.texi.orig:200
#, no-wrap
msgid ""
"(eval 'a)\n"
"     @result{} 123\n"
msgstr ""

#. type: group
#: eval.texi.orig:204
#, no-wrap
msgid ""
"a\n"
"     @result{} 123\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:214
msgid ""
"The symbols @code{nil} and @code{t} are treated specially, so that the value "
"of @code{nil} is always @code{nil}, and the value of @code{t} is always "
"@code{t}; you cannot set or bind them to any other values.  Thus, these two "
"symbols act like self-evaluating forms, even though @code{eval} treats them "
"like any other symbol.  A symbol whose name starts with @samp{:} also "
"self-evaluates in the same way; likewise, its value ordinarily cannot be "
"changed.  @xref{Constant Variables}."
msgstr ""

#. type: subsection
#: eval.texi.orig:216
#, no-wrap
msgid "Classification of List Forms"
msgstr ""

#. type: cindex
#: eval.texi.orig:217
#, no-wrap
msgid "list form evaluation"
msgstr ""

#. type: Plain text
#: eval.texi.orig:224
msgid ""
"A form that is a nonempty list is either a function call, a macro call, or a "
"special form, according to its first element.  These three kinds of forms "
"are evaluated in different ways, described below.  The remaining list "
"elements constitute the @dfn{arguments} for the function, macro, or special "
"form."
msgstr ""

#. type: Plain text
#: eval.texi.orig:230
msgid ""
"The first step in evaluating a nonempty list is to examine its first "
"element.  This element alone determines what kind of form the list is and "
"how the rest of the list is to be processed.  The first element is "
"@emph{not} evaluated, as it would be in some Lisp dialects such as Scheme."
msgstr ""

#. type: subsection
#: eval.texi.orig:232
#, no-wrap
msgid "Symbol Function Indirection"
msgstr ""

#. type: cindex
#: eval.texi.orig:233
#, no-wrap
msgid "symbol function indirection"
msgstr ""

#. type: cindex
#: eval.texi.orig:234
#, no-wrap
msgid "indirection for functions"
msgstr ""

#. type: cindex
#: eval.texi.orig:235
#, no-wrap
msgid "void function"
msgstr ""

#. type: Plain text
#: eval.texi.orig:243
msgid ""
"If the first element of the list is a symbol then evaluation examines the "
"symbol's function cell, and uses its contents instead of the original "
"symbol.  If the contents are another symbol, this process, called "
"@dfn{symbol function indirection}, is repeated until it obtains a "
"non-symbol.  @xref{Function Names}, for more information about symbol "
"function indirection."
msgstr ""

#. type: Plain text
#: eval.texi.orig:248
msgid ""
"One possible consequence of this process is an infinite loop, in the event "
"that a symbol's function cell refers to the same symbol.  Otherwise, we "
"eventually obtain a non-symbol, which ought to be a function or other "
"suitable object."
msgstr ""

#. type: kindex
#: eval.texi.orig:249
#, no-wrap
msgid "invalid-function"
msgstr ""

#. type: Plain text
#: eval.texi.orig:255
msgid ""
"More precisely, we should now have a Lisp function (a lambda expression), a "
"byte-code function, a primitive function, a Lisp macro, a special form, or "
"an autoload object.  Each of these types is a case described in one of the "
"following sections.  If the object is not one of these types, Emacs signals "
"an @code{invalid-function} error."
msgstr ""

#. type: Plain text
#: eval.texi.orig:262
msgid ""
"The following example illustrates the symbol indirection process.  We use "
"@code{fset} to set the function cell of a symbol and @code{symbol-function} "
"to get the function cell contents (@pxref{Function Cells}).  Specifically, "
"we store the symbol @code{car} into the function cell of @code{first}, and "
"the symbol @code{first} into the function cell of @code{erste}."
msgstr ""

#. type: group
#: eval.texi.orig:269
#, no-wrap
msgid ""
";; @r{Build this function cell linkage:}\n"
";;   -------------       -----        -------        -------\n"
";;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |\n"
";;   -------------       -----        -------        -------\n"
msgstr ""

#. type: group
#: eval.texi.orig:273
#, no-wrap
msgid ""
"(symbol-function 'car)\n"
"     @result{} #<subr car>\n"
msgstr ""

#. type: group
#: eval.texi.orig:277
#, no-wrap
msgid ""
"(fset 'first 'car)\n"
"     @result{} car\n"
msgstr ""

#. type: group
#: eval.texi.orig:281
#, no-wrap
msgid ""
"(fset 'erste 'first)\n"
"     @result{} first\n"
msgstr ""

#. type: group
#: eval.texi.orig:285
#, no-wrap
msgid ""
"(erste '(1 2 3))   ; @r{Call the function referenced by @code{erste}.}\n"
"     @result{} 1\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:291
msgid ""
"By contrast, the following example calls a function without any symbol "
"function indirection, because the first element is an anonymous Lisp "
"function, not a symbol."
msgstr ""

#. type: group
#: eval.texi.orig:297
#, no-wrap
msgid ""
"((lambda (arg) (erste arg))\n"
" '(1 2 3))\n"
"     @result{} 1\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:303
msgid ""
"Executing the function itself evaluates its body; this does involve symbol "
"function indirection when calling @code{erste}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:306
msgid ""
"This form is rarely used and is now deprecated.  Instead, you should write "
"it as:"
msgstr ""

#. type: group
#: eval.texi.orig:311
#, no-wrap
msgid ""
"(funcall (lambda (arg) (erste arg))\n"
"         '(1 2 3))\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:314
msgid "or just"
msgstr ""

#. type: group
#: eval.texi.orig:317
#, no-wrap
msgid "(let ((arg '(1 2 3))) (erste arg))\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:322
msgid ""
"The built-in function @code{indirect-function} provides an easy way to "
"perform symbol function indirection explicitly."
msgstr ""

#. type: defun
#: eval.texi.orig:324
#, no-wrap
msgid "indirect-function function &optional noerror"
msgstr ""

#. type: anchor{#1}
#: eval.texi.orig:330
msgid "Definition of indirect-function"
msgstr ""

#. type: defun
#: eval.texi.orig:330
msgid ""
"This function returns the meaning of @var{function} as a function.  If "
"@var{function} is a symbol, then it finds @var{function}'s function "
"definition and starts over with that value.  If @var{function} is not a "
"symbol, then it returns @var{function} itself."
msgstr ""

#. type: defun
#: eval.texi.orig:335
msgid ""
"This function signals a @code{void-function} error if the final symbol is "
"unbound and optional argument @var{noerror} is @code{nil} or omitted.  "
"Otherwise, if @var{noerror} is non-@code{nil}, it returns @code{nil} if the "
"final symbol is unbound."
msgstr ""

#. type: defun
#: eval.texi.orig:338
msgid ""
"It signals a @code{cyclic-function-indirection} error if there is a loop in "
"the chain of symbols."
msgstr ""

#. type: defun
#: eval.texi.orig:340
msgid "Here is how you could define @code{indirect-function} in Lisp:"
msgstr ""

#. type: example
#: eval.texi.orig:346
#, no-wrap
msgid ""
"(defun indirect-function (function)\n"
"  (if (symbolp function)\n"
"      (indirect-function (symbol-function function))\n"
"    function))\n"
msgstr ""

#. type: subsection
#: eval.texi.orig:350
#, no-wrap
msgid "Evaluation of Function Forms"
msgstr ""

#. type: cindex
#: eval.texi.orig:351
#, no-wrap
msgid "function form evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:352
#, no-wrap
msgid "function call"
msgstr ""

#. type: Plain text
#: eval.texi.orig:358
msgid ""
"If the first element of a list being evaluated is a Lisp function object, "
"byte-code object or primitive function object, then that list is a "
"@dfn{function call}.  For example, here is a call to the function @code{+}:"
msgstr ""

#. type: example
#: eval.texi.orig:361
#, no-wrap
msgid "(+ 1 x)\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:372
msgid ""
"The first step in evaluating a function call is to evaluate the remaining "
"elements of the list from left to right.  The results are the actual "
"argument values, one value for each list element.  The next step is to call "
"the function with this list of arguments, effectively using the function "
"@code{apply} (@pxref{Calling Functions}).  If the function is written in "
"Lisp, the arguments are used to bind the argument variables of the function "
"(@pxref{Lambda Expressions}); then the forms in the function body are "
"evaluated in order, and the value of the last body form becomes the value of "
"the function call."
msgstr ""

#. type: subsection
#: eval.texi.orig:374
#, no-wrap
msgid "Lisp Macro Evaluation"
msgstr ""

#. type: cindex
#: eval.texi.orig:375
#, no-wrap
msgid "macro call evaluation"
msgstr ""

#. type: Plain text
#: eval.texi.orig:386
msgid ""
"If the first element of a list being evaluated is a macro object, then the "
"list is a @dfn{macro call}.  When a macro call is evaluated, the elements of "
"the rest of the list are @emph{not} initially evaluated.  Instead, these "
"elements themselves are used as the arguments of the macro.  The macro "
"definition computes a replacement form, called the @dfn{expansion} of the "
"macro, to be evaluated in place of the original form.  The expansion may be "
"any sort of form: a self-evaluating constant, a symbol, or a list.  If the "
"expansion is itself a macro call, this process of expansion repeats until "
"some other sort of form results."
msgstr ""

#. type: Plain text
#: eval.texi.orig:391
msgid ""
"Ordinary evaluation of a macro call finishes by evaluating the expansion.  "
"However, the macro expansion is not necessarily evaluated right away, or at "
"all, because other programs also expand macro calls, and they may or may not "
"evaluate the expansions."
msgstr ""

#. type: Plain text
#: eval.texi.orig:395
msgid ""
"Normally, the argument expressions are not evaluated as part of computing "
"the macro expansion, but instead appear as part of the expansion, so they "
"are computed when the expansion is evaluated."
msgstr ""

#. type: Plain text
#: eval.texi.orig:397
msgid "For example, given a macro defined as follows:"
msgstr ""

#. type: group
#: eval.texi.orig:402
#, no-wrap
msgid ""
"(defmacro cadr (x)\n"
"  (list 'car (list 'cdr x)))\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:408
msgid ""
"an expression such as @code{(cadr (assq 'handler list))} is a macro call, "
"and its expansion is:"
msgstr ""

#. type: example
#: eval.texi.orig:411
#, no-wrap
msgid "(car (cdr (assq 'handler list)))\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:416
msgid "Note that the argument @code{(assq 'handler list)} appears in the expansion."
msgstr ""

#. type: Plain text
#: eval.texi.orig:418
msgid "@xref{Macros}, for a complete description of Emacs Lisp macros."
msgstr ""

#. type: cindex
#: eval.texi.orig:421
#, no-wrap
msgid "special forms"
msgstr ""

#. type: cindex
#: eval.texi.orig:422
#, no-wrap
msgid "evaluation of special forms"
msgstr ""

#. type: Plain text
#: eval.texi.orig:428
msgid ""
"A @dfn{special form} is a primitive function specially marked so that its "
"arguments are not all evaluated.  Most special forms define control "
"structures or perform variable bindings---things which functions cannot do."
msgstr ""

#. type: Plain text
#: eval.texi.orig:432
msgid ""
"Each special form has its own rules for which arguments are evaluated and "
"which are used without evaluation.  Whether a particular argument is "
"evaluated may depend on the results of evaluating other arguments."
msgstr ""

#. type: Plain text
#: eval.texi.orig:440
msgid ""
"If an expression's first symbol is that of a special form, the expression "
"should follow the rules of that special form; otherwise, Emacs's behavior is "
"not well-defined (though it will not crash).  For example, @code{((lambda "
"(x) x . 3) 4)} contains a subexpression that begins with @code{lambda} but "
"is not a well-formed @code{lambda} expression, so Emacs may signal an error, "
"or may return 3 or 4 or @code{nil}, or may behave in other ways."
msgstr ""

#. type: defun
#: eval.texi.orig:441
#, no-wrap
msgid "special-form-p object"
msgstr ""

#. type: defun
#: eval.texi.orig:444
msgid ""
"This predicate tests whether its argument is a special form, and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: eval.texi.orig:448
msgid ""
"Here is a list, in alphabetical order, of all of the special forms in Emacs "
"Lisp with a reference to where each is described."
msgstr ""

#. type: item
#: eval.texi.orig:450
#, no-wrap
msgid "and"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:452 eval.texi.orig:486
msgid "Combining Conditions"
msgstr ""

#. type: item
#: eval.texi.orig:453
#, no-wrap
msgid "catch"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:455
msgid "Catch and Throw"
msgstr ""

#. type: item
#: eval.texi.orig:456
#, no-wrap
msgid "cond"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:458 eval.texi.orig:473
msgid "Conditionals"
msgstr ""

#. type: item
#: eval.texi.orig:459
#, no-wrap
msgid "condition-case"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:461
msgid "Handling Errors"
msgstr ""

#. type: item
#: eval.texi.orig:462
#, no-wrap
msgid "defconst"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:464 eval.texi.orig:467
msgid "Defining Variables"
msgstr ""

#. type: item
#: eval.texi.orig:465
#, no-wrap
msgid "defvar"
msgstr ""

#. type: item
#: eval.texi.orig:468
#, no-wrap
msgid "function"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:470
msgid "Anonymous Functions"
msgstr ""

#. type: item
#: eval.texi.orig:471
#, no-wrap
msgid "if"
msgstr ""

#. type: item
#: eval.texi.orig:474
#, no-wrap
msgid "interactive"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:476
msgid "Interactive Call"
msgstr ""

#. type: item
#: eval.texi.orig:477
#, no-wrap
msgid "lambda"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:479
msgid "Lambda Expressions"
msgstr ""

#. type: item
#: eval.texi.orig:480
#, no-wrap
msgid "let"
msgstr ""

#. type: itemx
#: eval.texi.orig:481
#, no-wrap
msgid "let*"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:483
msgid "Local Variables"
msgstr ""

#. type: item
#: eval.texi.orig:484
#, no-wrap
msgid "or"
msgstr ""

#. type: item
#: eval.texi.orig:487
#, no-wrap
msgid "prog1"
msgstr ""

#. type: itemx
#: eval.texi.orig:488
#, no-wrap
msgid "prog2"
msgstr ""

#. type: itemx
#: eval.texi.orig:489
#, no-wrap
msgid "progn"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:491
msgid "Sequencing"
msgstr ""

#. type: item
#: eval.texi.orig:492
#, no-wrap
msgid "quote"
msgstr ""

#. type: item
#: eval.texi.orig:495
#, no-wrap
msgid "save-current-buffer"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:497
msgid "Current Buffer"
msgstr ""

#. type: item
#: eval.texi.orig:498
#, no-wrap
msgid "save-excursion"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:500
msgid "Excursions"
msgstr ""

#. type: item
#: eval.texi.orig:501
#, no-wrap
msgid "save-restriction"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:503
msgid "Narrowing"
msgstr ""

#. type: item
#: eval.texi.orig:504
#, no-wrap
msgid "setq"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:506
msgid "Setting Variables"
msgstr ""

#. type: item
#: eval.texi.orig:507
#, no-wrap
msgid "setq-default"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:509
msgid "Creating Buffer-Local"
msgstr ""

#. type: item
#: eval.texi.orig:510
#, no-wrap
msgid "track-mouse"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:512
msgid "Mouse Tracking"
msgstr ""

#. type: item
#: eval.texi.orig:513
#, no-wrap
msgid "unwind-protect"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:515
msgid "Nonlocal Exits"
msgstr ""

#. type: item
#: eval.texi.orig:516
#, no-wrap
msgid "while"
msgstr ""

#. type: pxref{#1}
#: eval.texi.orig:518
msgid "Iteration"
msgstr ""

#. type: cindex
#: eval.texi.orig:520
#, no-wrap
msgid "CL note---special forms compared"
msgstr ""

#. type: quotation
#: eval.texi.orig:530
msgid ""
"@b{Common Lisp note:} Here are some comparisons of special forms in GNU "
"Emacs Lisp and Common Lisp.  @code{setq}, @code{if}, and @code{catch} are "
"special forms in both Emacs Lisp and Common Lisp.  @code{save-excursion} is "
"a special form in Emacs Lisp, but doesn't exist in Common Lisp.  "
"@code{throw} is a special form in Common Lisp (because it must be able to "
"throw multiple values), but it is a function in Emacs Lisp (which doesn't "
"have multiple values)."
msgstr ""

#. type: Plain text
#: eval.texi.orig:543
msgid ""
"The @dfn{autoload} feature allows you to call a function or macro whose "
"function definition has not yet been loaded into Emacs.  It specifies which "
"file contains the definition.  When an autoload object appears as a symbol's "
"function definition, calling that symbol as a function automatically loads "
"the specified file; then it calls the real definition loaded from that "
"file.  The way to arrange for an autoload object to appear as a symbol's "
"function definition is described in @ref{Autoload}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:552
msgid ""
"The special form @code{quote} returns its single argument, as written, "
"without evaluating it.  This provides a way to include constant symbols and "
"lists, which are not self-evaluating objects, in a program.  (It is not "
"necessary to quote self-evaluating objects such as numbers, strings, and "
"vectors.)"
msgstr ""

#. type: defspec
#: eval.texi.orig:553
#, no-wrap
msgid "quote object"
msgstr ""

#. type: defspec
#: eval.texi.orig:555
msgid "This special form returns @var{object}, without evaluating it."
msgstr ""

#. type: cindex
#: eval.texi.orig:557
#, no-wrap
msgid "@samp{'} for quoting"
msgstr ""

#. type: cindex
#: eval.texi.orig:558
#, no-wrap
msgid "quoting using apostrophe"
msgstr ""

#. type: cindex
#: eval.texi.orig:559
#, no-wrap
msgid "apostrophe for quoting"
msgstr ""

#. type: Plain text
#: eval.texi.orig:565
msgid ""
"Because @code{quote} is used so often in programs, Lisp provides a "
"convenient read syntax for it.  An apostrophe character (@samp{'})  followed "
"by a Lisp object (in read syntax) expands to a list whose first element is "
"@code{quote}, and whose second element is the object.  Thus, the read syntax "
"@code{'x} is an abbreviation for @code{(quote x)}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:567
msgid "Here are some examples of expressions that use @code{quote}:"
msgstr ""

#. type: group
#: eval.texi.orig:572
#, no-wrap
msgid ""
"(quote (+ 1 2))\n"
"     @result{} (+ 1 2)\n"
msgstr ""

#. type: group
#: eval.texi.orig:576
#, no-wrap
msgid ""
"(quote foo)\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: eval.texi.orig:580
#, no-wrap
msgid ""
"'foo\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: eval.texi.orig:584
#, no-wrap
msgid ""
"''foo\n"
"     @result{} (quote foo)\n"
msgstr ""

#. type: group
#: eval.texi.orig:588
#, no-wrap
msgid ""
"'(quote foo)\n"
"     @result{} (quote foo)\n"
msgstr ""

#. type: group
#: eval.texi.orig:592
#, no-wrap
msgid ""
"['foo]\n"
"     @result{} [(quote foo)]\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:599
msgid ""
"Other quoting constructs include @code{function} (@pxref{Anonymous "
"Functions}), which causes an anonymous lambda expression written in Lisp to "
"be compiled, and @samp{`} (@pxref{Backquote}), which is used to quote only "
"part of a list, while computing and substituting other parts."
msgstr ""

#. type: cindex
#: eval.texi.orig:602
#, no-wrap
msgid "backquote (list substitution)"
msgstr ""

#. type: cindex
#: eval.texi.orig:603
#, no-wrap
msgid "` (list substitution)"
msgstr ""

#. type: findex
#: eval.texi.orig:604
#, no-wrap
msgid "`"
msgstr ""

#. type: Plain text
#: eval.texi.orig:609
msgid ""
"@dfn{Backquote constructs} allow you to quote a list, but selectively "
"evaluate elements of that list.  In the simplest case, it is identical to "
"the special form @code{quote}"
msgstr ""

#. type: ifnottex
#: eval.texi.orig:613
msgid "(described in the previous section; @pxref{Quoting})."
msgstr ""

#. type: Plain text
#: eval.texi.orig:615
msgid "For example, these two forms yield identical results:"
msgstr ""

#. type: group
#: eval.texi.orig:620
#, no-wrap
msgid ""
"`(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""

#. type: group
#: eval.texi.orig:624
#, no-wrap
msgid ""
"'(a list of (+ 2 3) elements)\n"
"     @result{} (a list of (+ 2 3) elements)\n"
msgstr ""

#. type: findex
#: eval.texi.orig:627
#, no-wrap
msgid ", @r{(with backquote)}"
msgstr ""

#. type: Plain text
#: eval.texi.orig:632
msgid ""
"The special marker @samp{,} inside of the argument to backquote indicates a "
"value that isn't constant.  The Emacs Lisp evaluator evaluates the argument "
"of @samp{,}, and puts the value in the list structure:"
msgstr ""

#. type: group
#: eval.texi.orig:637
#, no-wrap
msgid ""
"`(a list of ,(+ 2 3) elements)\n"
"     @result{} (a list of 5 elements)\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:643
msgid ""
"Substitution with @samp{,} is allowed at deeper levels of the list structure "
"also.  For example:"
msgstr ""

#. type: group
#: eval.texi.orig:648
#, no-wrap
msgid ""
"`(1 2 (3 ,(+ 4 5)))\n"
"     @result{} (1 2 (3 9))\n"
msgstr ""

#. type: findex
#: eval.texi.orig:651
#, no-wrap
msgid ",@@ @r{(with backquote)}"
msgstr ""

#. type: cindex
#: eval.texi.orig:652
#, no-wrap
msgid "splicing (with backquote)"
msgstr ""

#. type: Plain text
#: eval.texi.orig:658
msgid ""
"You can also @dfn{splice} an evaluated value into the resulting list, using "
"the special marker @samp{,@@}.  The elements of the spliced list become "
"elements at the same level as the other elements of the resulting list.  The "
"equivalent code without using @samp{`} is often unreadable.  Here are some "
"examples:"
msgstr ""

#. type: group
#: eval.texi.orig:663
#, no-wrap
msgid ""
"(setq some-list '(2 3))\n"
"     @result{} (2 3)\n"
msgstr ""

#. type: group
#: eval.texi.orig:667
#, no-wrap
msgid ""
"(cons 1 (append some-list '(4) some-list))\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""

#. type: group
#: eval.texi.orig:671
#, no-wrap
msgid ""
"`(1 ,@@some-list 4 ,@@some-list)\n"
"     @result{} (1 2 3 4 2 3)\n"
msgstr ""

#. type: group
#: eval.texi.orig:676
#, no-wrap
msgid ""
"(setq list '(hack foo bar))\n"
"     @result{} (hack foo bar)\n"
msgstr ""

#. type: group
#: eval.texi.orig:682
#, no-wrap
msgid ""
"(cons 'use\n"
"  (cons 'the\n"
"    (cons 'words (append (cdr list) '(as elements)))))\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""

#. type: group
#: eval.texi.orig:686
#, no-wrap
msgid ""
"`(use the words ,@@(cdr list) as elements)\n"
"     @result{} (use the words foo bar as elements)\n"
msgstr ""

#. type: Plain text
#: eval.texi.orig:703
msgid ""
"Most often, forms are evaluated automatically, by virtue of their occurrence "
"in a program being run.  On rare occasions, you may need to write code that "
"evaluates a form that is computed at run time, such as after reading a form "
"from text being edited or getting one from a property list.  On these "
"occasions, use the @code{eval} function.  Often @code{eval} is not needed "
"and something else should be used instead.  For example, to get the value of "
"a variable, while @code{eval} works, @code{symbol-value} is preferable; or "
"rather than store expressions in a property list that then need to go "
"through @code{eval}, it is better to store functions instead that are then "
"passed to @code{funcall}."
msgstr ""

#. type: Plain text
#: eval.texi.orig:707
msgid ""
"The functions and variables described in this section evaluate forms, "
"specify limits to the evaluation process, or record recently returned "
"values.  Loading a file also does evaluation (@pxref{Loading})."
msgstr ""

#. type: Plain text
#: eval.texi.orig:713
msgid ""
"It is generally cleaner and more flexible to store a function in a data "
"structure, and call it with @code{funcall} or @code{apply}, than to store an "
"expression in the data structure and evaluate it.  Using functions provides "
"the ability to pass information to them as arguments."
msgstr ""

#. type: defun
#: eval.texi.orig:714
#, no-wrap
msgid "eval form &optional lexical"
msgstr ""

#. type: defun
#: eval.texi.orig:719
msgid ""
"This is the basic function for evaluating an expression.  It evaluates "
"@var{form} in the current environment, and returns the result.  The type of "
"the @var{form} object determines how it is evaluated.  @xref{Forms}."
msgstr ""

#. type: defun
#: eval.texi.orig:728
msgid ""
"The argument @var{lexical} specifies the scoping rule for local variables "
"(@pxref{Variable Scoping}).  If it is omitted or @code{nil}, that means to "
"evaluate @var{form} using the default dynamic scoping rule.  If it is "
"@code{t}, that means to use the lexical scoping rule.  The value of "
"@var{lexical} can also be a non-empty alist specifying a particular "
"@dfn{lexical environment} for lexical bindings; however, this feature is "
"only useful for specialized purposes, such as in Emacs Lisp debuggers.  "
"@xref{Lexical Binding}."
msgstr ""

#. type: defun
#: eval.texi.orig:733
msgid ""
"Since @code{eval} is a function, the argument expression that appears in a "
"call to @code{eval} is evaluated twice: once as preparation before "
"@code{eval} is called, and again by the @code{eval} function itself.  Here "
"is an example:"
msgstr ""

#. type: group
#: eval.texi.orig:738
#, no-wrap
msgid ""
"(setq foo 'bar)\n"
"     @result{} bar\n"
msgstr ""

#. type: group
#: eval.texi.orig:748
#, no-wrap
msgid ""
"(setq bar 'baz)\n"
"     @result{} baz\n"
";; @r{Here @code{eval} receives argument @code{foo}}\n"
"(eval 'foo)\n"
"     @result{} bar\n"
";; @r{Here @code{eval} receives argument @code{bar}, which is the value of "
"@code{foo}}\n"
"(eval foo)\n"
"     @result{} baz\n"
msgstr ""

#. type: defun
#: eval.texi.orig:753
msgid ""
"The number of currently active calls to @code{eval} is limited to "
"@code{max-lisp-eval-depth} (see below)."
msgstr ""

#. type: deffn
#: eval.texi.orig:755
#, no-wrap
msgid "Command eval-region start end &optional stream read-function"
msgstr ""

#. type: anchor{#1}
#: eval.texi.orig:761
msgid "Definition of eval-region"
msgstr ""

#. type: deffn
#: eval.texi.orig:761
msgid ""
"This function evaluates the forms in the current buffer in the region "
"defined by the positions @var{start} and @var{end}.  It reads forms from the "
"region and calls @code{eval} on them until the end of the region is reached, "
"or until an error is signaled and not handled."
msgstr ""

#. type: deffn
#: eval.texi.orig:767
msgid ""
"By default, @code{eval-region} does not produce any output.  However, if "
"@var{stream} is non-@code{nil}, any output produced by output functions "
"(@pxref{Output Functions}), as well as the values that result from "
"evaluating the expressions in the region are printed using @var{stream}.  "
"@xref{Output Streams}."
msgstr ""

#. type: deffn
#: eval.texi.orig:775
msgid ""
"If @var{read-function} is non-@code{nil}, it should be a function, which is "
"used instead of @code{read} to read expressions one by one.  This function "
"is called with one argument, the stream for reading input.  You can also use "
"the variable @code{load-read-function} (@pxref{Definition of "
"load-read-function,, How Programs Do Loading})  to specify this function, "
"but it is more robust to use the @var{read-function} argument."
msgstr ""

#. type: deffn
#: eval.texi.orig:777
msgid "@code{eval-region} does not move point.  It always returns @code{nil}."
msgstr ""

#. type: cindex
#: eval.texi.orig:779
#, no-wrap
msgid "evaluation of buffer contents"
msgstr ""

#. type: deffn
#: eval.texi.orig:780
#, no-wrap
msgid "Command eval-buffer &optional buffer-or-name stream filename unibyte print"
msgstr ""

#. type: deffn
#: eval.texi.orig:794
msgid ""
"This is similar to @code{eval-region}, but the arguments provide different "
"optional features.  @code{eval-buffer} operates on the entire accessible "
"portion of buffer @var{buffer-or-name}.  @var{buffer-or-name} can be a "
"buffer, a buffer name (a string), or @code{nil} (or omitted), which means to "
"use the current buffer.  @var{stream} is used as in @code{eval-region}, "
"unless @var{stream} is @code{nil} and @var{print} non-@code{nil}.  In that "
"case, values that result from evaluating the expressions are still "
"discarded, but the output of the output functions is printed in the echo "
"area.  @var{filename} is the file name to use for @code{load-history} "
"(@pxref{Unloading}), and defaults to @code{buffer-file-name} (@pxref{Buffer "
"File Name}).  If @var{unibyte} is non-@code{nil}, @code{read} converts "
"strings to unibyte whenever possible."
msgstr ""

#. type: findex
#: eval.texi.orig:795
#, no-wrap
msgid "eval-current-buffer"
msgstr ""

#. type: deffn
#: eval.texi.orig:797
msgid "@code{eval-current-buffer} is an alias for this command."
msgstr ""

#. type: defopt
#: eval.texi.orig:799
#, no-wrap
msgid "max-lisp-eval-depth"
msgstr ""

#. type: anchor{#1}
#: eval.texi.orig:804
msgid "Definition of max-lisp-eval-depth"
msgstr ""

#. type: defopt
#: eval.texi.orig:804
msgid ""
"This variable defines the maximum depth allowed in calls to @code{eval}, "
"@code{apply}, and @code{funcall} before an error is signaled (with error "
"message @code{\"Lisp nesting exceeds max-lisp-eval-depth\"})."
msgstr ""

#. type: defopt
#: eval.texi.orig:809
msgid ""
"This limit, with the associated error when it is exceeded, is one way Emacs "
"Lisp avoids infinite recursion on an ill-defined function.  If you increase "
"the value of @code{max-lisp-eval-depth} too much, such code can cause stack "
"overflow instead."
msgstr ""

#. type: cindex
#: eval.texi.orig:809
#, no-wrap
msgid "Lisp nesting error"
msgstr ""

#. type: defopt
#: eval.texi.orig:815
msgid ""
"The depth limit counts internal uses of @code{eval}, @code{apply}, and "
"@code{funcall}, such as for calling the functions mentioned in Lisp "
"expressions, and recursive evaluation of function call arguments and "
"function body forms, as well as explicit calls in Lisp code."
msgstr ""

#. type: defopt
#: eval.texi.orig:821
msgid ""
"The default value of this variable is 400.  If you set it to a value less "
"than 100, Lisp will reset it to 100 if the given value is reached.  Entry to "
"the Lisp debugger increases the value, if there is little room left, to make "
"sure the debugger itself has room to execute."
msgstr ""

#. type: defopt
#: eval.texi.orig:824
msgid ""
"@code{max-specpdl-size} provides another limit on nesting.  @xref{Definition "
"of max-specpdl-size,, Local Variables}."
msgstr ""

#. type: defvar
#: eval.texi.orig:826
#, no-wrap
msgid "values"
msgstr ""

#. type: defvar
#: eval.texi.orig:834
msgid ""
"The value of this variable is a list of the values returned by all the "
"expressions that were read, evaluated, and printed from buffers (including "
"the minibuffer) by the standard Emacs commands which do this.  (Note that "
"this does @emph{not} include evaluation in @file{*ielm*} buffers, nor "
"evaluation using @kbd{C-j} in @code{lisp-interaction-mode}.)  The elements "
"are ordered most recent first."
msgstr ""

#. type: group
#: eval.texi.orig:839
#, no-wrap
msgid ""
"(setq x 1)\n"
"     @result{} 1\n"
msgstr ""

#. type: group
#: eval.texi.orig:843
#, no-wrap
msgid ""
"(list 'A (1+ 2) auto-save-default)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: eval.texi.orig:847
#, no-wrap
msgid ""
"values\n"
"     @result{} ((A 3 t) 1 @dots{})\n"
msgstr ""

#. type: defvar
#: eval.texi.orig:854
msgid ""
"This variable is useful for referring back to values of forms recently "
"evaluated.  It is generally a bad idea to print the value of @code{values} "
"itself, since this may be very long.  Instead, examine particular elements, "
"like this:"
msgstr ""

#. type: group
#: eval.texi.orig:860
#, no-wrap
msgid ""
";; @r{Refer to the most recent evaluation result.}\n"
"(nth 0 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: eval.texi.orig:866
#, no-wrap
msgid ""
";; @r{That put a new element on,}\n"
";;   @r{so all elements move back one.}\n"
"(nth 1 values)\n"
"     @result{} (A 3 t)\n"
msgstr ""

#. type: group
#: eval.texi.orig:872
#, no-wrap
msgid ""
";; @r{This gets the element that was next-to-most-recent}\n"
";;   @r{before this example.}\n"
"(nth 3 values)\n"
"     @result{} 1\n"
msgstr ""
