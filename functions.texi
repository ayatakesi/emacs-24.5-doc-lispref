@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Functions

  Lispプログラムは主にLisp関数で構成されます。このチャプターは、関数とは何か、引数を受け取る方法、関数を定義する方法を説明します。

@menu
* What Is a Function::       Lisp関数 vs. プリミティブ; 
                               専門用語。
* Lambda Expressions::       関数がLispオブジェクトとして表現される方法。
* Function Names::           シンボルは関数を名づける役割を果たすことができる。
* Defining Functions::       関数定義のためのLisp式。
* Calling Functions::        既存の関数を使う方法。
* Mapping Functions::        リストの各要素などに関数を適用する。
* Anonymous Functions::      ラムダ式、それは無名の関数。
* Function Cells::           シンボルの関数定義へのアクセスとセット。
* Closures::                 レキシカル環境に囲まれた関数。
* Advising Functions::       関数の定義への追加。
* Obsolete Functions::       関数を陳腐と宣言する。
* Inline Functions::         コンパイラーによりインライン展開される関数。
* Declare Form::             関数についての補足的な情報の追加。
* Declaring Functions::      関数が定義されていることをコンパイラーに知らせる。
* Function Safety::          呼び出しても安全な関数なのか判断する。
* Related Topics::           関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。
@end menu

@node What Is a Function
@section What Is a Function?

@cindex return value
@cindex value of function
@cindex argument
  一般的な意味では、関数とは@dfn{引数(arguments)}と呼ばれる与えられた入力値の計算を担うルールです。計算の結果は、その関数の@dfn{値(value)}、または@dfn{return値(return
value)}と呼ばれます。計算は、変数の値やデータ構造の内容を変更する等の副作用をもつこともできます。

  ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しかしLispでは、厳密な意味において、関数は名前をもちません。関数はオブジェクトであり、関数の名前の役割を果たすシンボルに関連づけることができますが(たとえば@code{car})、それは@emph{オプション}です。@ref{Function
Names}を参照してください。関数が名前を与えられたとき、通常はそのシンボルを``関数''として参照します(たとえば、関数@code{car}のように参照します)。このマニュアルでは、関数名と関数オブジェクト自身との間の区別は、通常は重要ではありませんが、それが意味をもつような場合は注記します。

  @dfn{スペシャルフォーム(special
form)}、@dfn{マクロ(macro)}と呼ばれる、関数likeなオブジェクトがいくつかあり、それらも引数を受け受け、計算を担います。しかし以下で説明するように、Emacs
Lispではこれらは関数とは考えられません。

  以下は関数および関数likeなオブジェクトにたいする、重要な条件です:

@table @dfn
@item lambda expression
Lispで記述された関数(厳密には関数オブジェクト)です。これらについては、以降のセクションで説明します。
@ifnottex
@ref{Lambda Expressions}を参照してください。
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Lispから呼び出すことができますが、実際にはCで記述されています。プリミティブは、@dfn{ビルトイン関数(built-in
functions)}や、@dfn{サブルーチン(subr)}といった呼ばれかたもします。それらの例には関数likeな@code{car}や@code{append}が含まれます。加えて、すべてのスペシャルフォーム(以下参照)もプリミティブと考えられます。

関数はLispの基礎となる部分(たとえば@code{car})であり、オペレーティングシステムのサービスにたいして値レベルのインターフェースを与え、高速に実行される必要があるため、通常はプリミティブとして実装されています。Lispで定義された関数とは異なり、プリミティブの修正や追加には、Cソースの変更とEmacsのリコンパイルが必要です。@ref{Writing
Emacs Primitives}を参照してください。

@item special form
プリミティブは関数と似ていますが、すべての引数が通常の方法で評価はされません。いくつかの引数だけが評価されるかもしれず、通常ではない順序で、複数回評価されるかもしれません。プリミティブの例には、@code{if}、@code{and}、@code{while}が含まれます。@ref{Special
Forms}を参照してください。

@item macro
@cindex macro
あるLisp式を、オリジナルの式のかわりに評価される別の式に変換する、関数とは別のLispで定義された構造です。マクロは、スペシャルフォームが行う一連のことを、Lispプログラマーが行うのを可能にします。@ref{Macros}を参照してください。

@item command
@cindex command
@code{command-execute}プリミティブを通じて呼び出すことができるオブジェクトで、通常はそのコマンドに@dfn{バインド}されたキーシーケンスを、ユーザーがタイプすることにより呼び出されます。@ref{Interactive
Call}を参照してください。コマンドは通常、関数です。その関数がLispで記述されている場合は、関数の定義内の@code{interactive}フォームによりコマンドとなります(@ref{Defining
Commands}を参照してください)。関数であるコマンドは、他の関数と同様、Lisp式から呼び出すこともできます。

キーボードマクロ(文字列およびベクター)は関数ではありませんが、これらもコマンドです。@ref{Keyboard
Macros}を参照してください。シンボルの関数セルにコマンドが含まれている場合、わたしたちはそのシンボルをコマンドと言います(@ref{Symbol
Components}を参照してください)。そのような@dfn{名前つきコマンド(named
command)}は、@kbd{M-x}で呼び出すことができます。

@item closure
ラムダ式とよく似た関数オブジェクトですが、クロージャーはレキシカル変数バインディングの``環境''にも囲まれています。@ref{Closures}を参照してください。

@item byte-code function
バイトコンパイラーによりコンパイルされた関数です。@ref{Byte-Code Type}を参照してください。

@item autoload object
@cindex autoload object
実際の関数のプレースホルダーです。autoloadオブジェクトが呼び出された場合、Emacsは実際の関数の定義を含むファイルをロードした後、実際の関数を呼び出します。@ref{Autoload}を参照してください。
@end table

  関数@code{functionp}を使用して、あるオブジェクトが関数かどうかテストできます:

@defun functionp object
この関数は@var{object}が任意の種類の関数(たとえば@code{funcall}に渡すことができる)の場合は、@code{t}をreturnします。@code{functionp}は関数を名づけるシンボルにたいしては@code{t}、スペシャルフォームにたいしては@code{nil}をreturnすることに注意してください。
@end defun

@noindent
@code{functionp}とは異なり、以下の3つの関数は、シンボルをそれの関数定義としては扱い@emph{ません}。

@defun subrp object
この関数は、@var{object}がビルトイン関数(たとえばLispプリミティブ)の場合は、@code{t}をreturnします。

@example
@group
(subrp 'message)            ; @r{@code{message}はシンボルであり、}
     @result{} nil                 ;   @r{subrオブジェクトではない。}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
この関数は、@var{object}がバイトコード関数の場合は、@code{t}をreturnします。たとえば:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
この関数はプリミティブ@var{subr}の引数リストについての情報を提供します。retrun値は、@code{(@var{min}
.
@var{max})}というペアーです。@var{min}は引数の最小数です。@var{max}は最大数、または引数@code{&rest}を伴う関数にたいしてはシンボル@code{many}、@var{subr}がスペシャルフォームの場合はシンボル@code{unevalled}です。
@end defun

@node Lambda Expressions
@section Lambda Expressions
@cindex lambda expression

  ラムダ式(lambda expression)は、Lispで記述された関数オブジェクトです。以下は例です:

@example
(lambda (x)
  "Xの双曲線コサインをreturnする。"
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
Emacs Lispでは、このようなリストは、関数オブジェクトに評価される、有効な式です。

  ラムダ式自身は名前をもたない、@dfn{無名関数(anonymous
function)}です。ラムダ式をこの方法で使用できますが(@ref{Anonymous
Functions}を参照してください)、@dfn{名前付き関数(named
functions)}を作成するためにシンボルに関連付けられる方が一般的です(@pxref{Function
Names})。これらの詳細に触れる前に、以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。

@menu
* Lambda Components::        ラムダ式のパーツ。
* Simple Lambda::            シンプルな例。
* Argument List::            引数リストの詳細と特別な機能。
* Function Documentation::   関数内にドキュメントを記述する方法。
@end menu

@node Lambda Components
@subsection Components of a Lambda Expression

  ラムダ式は、以下のようなリストです:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  ラムダ式の1番目の要素は常にシンボル@code{lambda}です。これは、そのリストが関数を表すことを示します。@code{lambda}で関数定義を開始する理由は、他の目的のたまえの使用が意図された他のリストが、意図せず関数として評価されないようにするためです。

  2番目の要素は、シンボル --- 引数変数名のリストです。これは@dfn{ラムダリスト(lambda
list)}と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストは、与えられた値にたいするローカルバインディングが付与されます。@ref{Local
Variables}を参照してください。

  ドキュメント文字列(documentation string)はEmacs
Lispのヘルプ機能にたいしてその、関数を説明する、関数定義に配されたLisp文字列オブジェクトです。@ref{Function
Documentation}を参照してください。

  インタラクティブ宣言(interactive declaration)は、@code{(interactive
@var{code-string})}という形式のリストです。これは、この関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、@dfn{コマンド(command)}と呼ばれます。コマンドは@kbd{M-x}を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、@xref{Defining
Commands}を参照してください。

@cindex body of function
  残りの要素は、その関数の@dfn{body(本体)} ---
その関数が処理を行うためのLispコード(Lispプログラマーは``評価されるLispフォームのリスト''と言うでしょう)です。この関数からreturnされる値は、bodyの最後の要素によりreturnされる値です。

@node Simple Lambda
@subsection A Simple Lambda Expression Example

  以下の例を考えてみてください:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
以下のように、@code{funcall}に渡すことにより、この関数を呼び出すことができます:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
この呼び出しは、変数@code{a}に1、@code{b}に2、@code{c}に3をバインドして、ラムダ式のbodyを評価します。bodyの評価により、これら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより、6がreturnされます。

  以下のように、引数は他の関数の結果であってもよいことに注意してください:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
これは引数@code{1}、@code{(* 2 3)}、@code{(- 5
4)}を左から右に評価します。その後、ラムダ式に引数1、6、1を適用して、値8が生成されます。

  これらの例が示すように、ローカル変数を作成して、それらに値を与えるフォームとして、@sc{car}がラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在では、この目的にはフォーム@code{let}を使用するほうが明解です(@ref{Local
Variables}を参照してください)。ラムダ式は主に、他の関数の引数として渡される無名関数(@ref{Anonymous
Functions}を参照してください)として、あるいは名前つき関数(@ref{Function
Names}を参照してください)を生成するためにシンボルの関数定義に格納するために使用されます。

@node Argument List
@subsection Other Features of Argument Lists
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  シンプルなサンプル関数@code{(lambda (a b c) (+ a b
c))}は、3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合は、@code{wrong-number-of-arguments}エラーとなります。

  特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数@code{substring}は3つの引数 ---
文字列、開始インデックス、終了インデックス ---
を受け取りますが、3つ目の引数を省略した場合、デフォルトでその文字列の@var{length}となります。関数@code{list}や@code{+}が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード@code{&optional}を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード@code{&rest}を含めます。

  したがって、引数リストの完全な構文は以下のようになります:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @var{optional-vars}@dots{}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
角カッコ(square
bracket)は、@code{&optional}と@code{&rest}、およびそれらに続く変数が省略できることを示します。

  この関数の呼び出しには、@var{required-vars}のそれぞれにたいして、実際の引数が要求されます。0個以上の@var{optional-vars}にたいして実際の引数があるかもしれませんが、ラムダ式が@code{&rest}を使用していなければ、その個数を超えて実際の引数を記述することはできません。@code{&rest}が記述されている場合、追加で任意個の実際の引数があるかもしれません。

  optionaやrest変数にたいして実際の引数が省略された場合、それらのデフォルトは常に@code{nil}になります。関数にたいして引数に明示的に@code{nil}が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、@code{nil}を他の有意な値が省略されたと判断することは自由です。これは@code{substring}が行っていることです。@code{substring}の3つ目の引数が@code{nil}の場合、それは文字列の長さを使用することを意味します。

@cindex CL note---default optional arg
@quotation
@b{Common Lispに関する注意:} Common
Lispでは、オプションの引数が省略されたときに使用するデフォルト値を指定できます。Emacs
Lispは、引数が明示的に渡されたかを調べる、``supplied-p''変数はサポートしません。
@end quotation

  例えば、引数リストは以下のようになります:

@example
(a b &optional c d &rest e)
@end example

@noindent
これは@code{a}と@code{b}は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合、それらは順番に@code{c}と@code{d}にバインドされます。1つ目から4つ目の引数の後の引数は、リストにまとめられて、@code{e}にそのリストがバインドされます。2つしか引数が指定されなかった場合、@code{c}は@code{nil}になります。2つまたは3つの引数の場合、@code{d}は@code{nil}です。引数が4つ以下の場合、@code{e}は@code{nil}になります。

  オプションの引数の後ろに必須の引数を指定する方法はありません ---
これは意味を成さないからです。なぜそうなるかは、この例で@code{c}がオプションで@code{d}が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか?
この引数は@var{c}なのでしょうか、それとも@var{d}に使用されるのでしょうか?
両方の場合が考えられます。同様に、@code{&rest}引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。

  以下に引数リストと、それを正しく呼び出す例をいくつか示します:

@example
(funcall (lambda (n) (1+ n))        ; @r{1つの必須:}
         1)                         ; @r{これは正確に1つの引数を要求する。}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{1つは必須で、1つはオプション:}
           (if n1 (+ n n1) (1+ n))) ; @r{1つまたは2つの引数。}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{1つは必須で、後は残り:}
           (+ n (apply '+ ns)))     ; @r{1つ以上の引数。}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Documentation Strings of Functions
@cindex documentation of function

  ラムダ式は、ラムダリストの食後に、オプションで@dfn{ドキュメント文字列(documentation
string)}をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですが、Lisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、@ref{Documentation}を参照してください。

  たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。

  ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら@code{apropos}は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する、1つまたは2つの完全なセンテンスで構成されるべきです。

  ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。@emph{これは、間違いです。}後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。

  ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれません。なぜなら、ドキュメント文字列の後には必須となる関数の構成要素であるbodyが続くからです。文字列を評価するとその文字列自身がれつｒｎされるので、それがbody内の最後のフォームでない限りなんの効果もありません。したがって、実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません。bodyの唯一のフォームが文字列の場合、それはreturn値とドキュメントの両方の役目を果たします。

  ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します

@example
\(fn @var{arglist})
@end example

@noindent
ただし、このテキストの前に空行があり、テキスト自身が行頭から記述されていて、ドキュメント文字列内でこのテキストの後に改行が続かない場合です(@samp{\}はEmacsの移動コマンドが混乱するのを避けるために使用されます)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。

  マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法と合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。

@node Function Names
@section Naming a Function
@cindex function definition
@cindex named function
@cindex function name

  シンボルは関数の名前となることができます。これは、そのシンボルの@dfn{関数セル(function cell}: @ref{Symbol
Components}を参照してください)が、関数オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価になります。

  関数セルの内容は、そのシンボルの@dfn{関数定義(function
definition)}と呼ぶこともできます。そのシンボルのかわりに、シンボルの関数定義を使う手続きのことを@dfn{シンボル関数インダイレクション(symbol
function indirection)}と呼びます。@ref{Function
Indirection}を参照してください。与えられたシンボルに関数定義がない場合、シンボルの関数セルは@dfn{void}と呼ばれ、それを関数として使用することはできません。

  実際のところ、ほとんどすべての関数は名前をもち、その名前により参照されます。ラムダ式を定義することにより名前つきのLisp関数を作成、それを関数セル(@ref{Function
Cells}を参照してください)に置くことができます。しかし、さらに一般的なのは@code{defun}スペシャルフォーム(次のセクションで説明します)を使う方法です。
@ifnottex
@ref{Defining Functions}を参照してください。
@end ifnottex

  わたしたちは関数名を与えるのは、Lisp式内で関数を名前で参照するのが便利だからです。また、名前つきの関数は簡単に自分自身を
---再帰的(recursive)に参照することができます。さらに、プリミティブはテキスト的な名前だけで参照することができます。なぜならプリミティブ関数は入力構文(read
syntax)をもたないオブジェクトだからです(@ref{Primitive Function Type}を参照してください)。

  関数は一意な名前をもつ必要はありません。与えられた関数オブジェクトは、@emph{通常}は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的なものです。@code{fset}を使用して、関数を複数のシンボルに格納するのは簡単です。それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。

  関数として使用されているシンボルを、変数としても利用できることに注意してください。シンボルのこれら2つの利用法は独立しており、競合はしません(これはSchemaのような他のいくつかのLisp方言には当てはまりません)。

@node Defining Functions
@section Defining Functions
@cindex defining a function

  わたしたちは通常、関数を最初に作成したときに名前を与えます。これは@dfn{関数の定義(defining a
function)}と呼ばれ、@code{defun}マクロにより行われます。

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun}は新たなLisp関数を定義する通常の方法です。これは、引数リスト@var{args}、および@var{body}により与えられるbodyフォームとともに、シンボル@var{name}を関数として定義します。@var{name}と@var{args}を、クォートする必要はありません。

@var{doc}が与えられた場合、それはその関数のドキュメント文字列を指定する文字列であるべきです(@ref{Function
Documentation}を参照してください)。@var{declare}が与えられた場合、それは関数のメタデータを指定する、@code{declare}フォームであるべきです(@ref{Declare
Form}を参照してください)。@var{interactive}が与えられた場合、それは関数が対話的に呼び出される方法を指定する@code{interactive}フォームであるべきです(@ref{Interactive
Call}を参照してください)。

@code{defun}のreturn値は定義されていません。

以下にいくつか例を示します:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

意図せず既存の関数を再定義しないように、注意してください。@code{defun}は@code{car}のようなプリミティブ関数でさえ、躊躇なく問い合わせもなしに再定義します。Emacsががががこれを妨げることはありません。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はないからです。
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
この関数は、定義@var{definition}(任意の有効なLisp関数)とともに、シンボル@var{name}を関数として定義します。この関数のreturn値は@emph{未定義}です。

@var{doc}が非@code{nil}の場合、それは関数@var{name}のドキュメントになります。それ以外は、@var{definition}により提供されるドキュメントが使用されます。

@cindex defalias-fset-function property
内部的には、@code{defalias}は通常、定義のセットに@code{fset}を使用します。しかし@var{name}が@code{defalias-fset-function}プロパティーをもつ場合、@code{fset}を呼び出すかわりに、それに割り当てられた値が使用されます。

@code{defalias}を使う正しい場所は、特定の関数名がまさに定義される場所 ---
特にソースファイルがロードされるとき明示的にその名前が出現する場所です。これは@code{defalias}が、@code{defun}と同じように、どれが関数を定義するファイルなのか記録するからです(@ref{Unloading}を参照してください)。

それとは対象的に、他の目的のために関数を操作するプログラムでは、そのような記録を保持しない@code{fset}を使用するほうがよいでしょう。@ref{Function
Cells}を参照してください。
@end defun

  @code{defun}や@code{defalias}で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである@code{car}や@code{x-popup-menu}のような関数でさえ変更することができます。しかし、これは危険なことです。たとえば、Lispの完全性を損なうことなく、@code{car}を再定義するのはほとんど不可能だからです。それほど有名ではない@code{x-popup-menu}のような関数の再定義では、危険は減るものの、それでも期待したとおりに機能しないかもしれません。Cコードにこのプリミティブの呼び出しがある場合、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更しても、それらに影響はありません。

  @code{defsubst}も参照してください。これは@code{defun}のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。@ref{Inline
Functions}を参照してください。

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  関数を定義しただけでは、半分しか終わっていません。関数はそれを@dfn{呼び出す(call)} ---
たとえば実行(run)するまでは、何も行いません。関数のcallは、@dfn{invocation}としても知られています。

  関数を呼び出すもっとも一般的な方法は、リストの評価による方法です。たとえば、リスト@code{(concat "a"
"b")}を評価することにより、関数@code{concat}が引数@code{"a"}と@code{"b"}で呼び出されます。評価については、@ref{Evaluation}を参照してください。

  プログラム内で式としてリストを記述するときは、プログラム内にテキストで、どの関数を呼び出すか、いくつの引数を与えるかを指定します。通常は、これが行いたいことです。どの関数を呼び出すかを、実行時に計算する必要がある場合もあります。これを行うには、関数@code{funcall}を使用します。実行時にいくつの引数を渡すか決定する必要があるときは、@code{apply}を使用します。

@defun funcall function &rest arguments
@code{funcall}は、関数@var{function}を引数@var{arguments}で呼び出し、@var{function}がreturnした値をreturnします。

@code{funcall}は関数なので、@var{function}を含むすべての引数は、@code{funcall}の呼び出し前に評価されます。これは、呼び出される関数を得るための任意の式を使用できることを意味します。これはまた、@code{funcall}が@var{arguments}に記述した式ではなく、その値だけを見ることを意味します。これらの値は@var{function}呼び出し中では、2回目は評価@emph{されません}。@code{funcall}の処理は、関数の通常の呼び出し手続きと似ており、すでに評価された引数は評価されません。

引数@var{function}は、Lisp関数、またはプリミティブ関数でなければなりません。つまりスペシャルフォームやマクロは、``評価されていない''引数式を与えられたときだけ意味があるので、指定することはできません。上述したように、@code{funcall}は最初に指定された評価前の引数を提供することはできません。

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

これらの例を、@code{apply}の例と比較してみてください。
@end defun

@defun apply function &rest arguments
@code{apply}は、関数@var{function}を引数@var{arguments}で呼び出します。これは@code{funcall}と同様ですが、1つ違いがあります。@var{arguments}の最後はオブジェクトのリストです。これは1つのリストではなく、個別の引数として@var{function}に渡されます。わたしたちはこれを、@code{apply}がこのリストを@dfn{展開(spread)}(個々の要素が引数となるので)する、と言います。

@code{apply}は、@var{function}を呼び出した結果をreturnします。@code{funcall}と同様、@var{function}はLisp関数かプリミティブ関数でなければなりません。つまりスペシャルフォームやマクロは、@code{apply}では意味をもちません。

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

@code{apply}を使用した興味深い例は、@ref{Definition of mapcar}を参照してください。
@end defun

@cindex partial application of functions
@cindex currying
  ある関数にたいして、その関数のある引数を特定の値に固定し、他の引数は実際に呼びだされたときの値にできれば便利なことがあります。関数のいくつかの引数を固定することは、その関数の@dfn{部分適用(partial
application)}と呼ばれます@footnote{これは@dfn{カリー化(currying)}と関連しますが、異なる機能です。カーリングは、複数の引数をとる関数を、関数チェーンとして呼び出せるような、１つの引数を取る個々の関数に変換するような方法です。}。結果は、残りの引数をとる新たな関数で、すべての引数を合わせて元の関数を呼び出します。

  Emacs Lispで部分適用を行う方法を示します:

@defun apply-partially func &rest args
この関数は、新たな関数をreturnします。この新しい関数は、呼びだされたときに@var{args}と、呼び出し時に指定された追加の引数から成る引数リストで@var{func}を呼び出す関数です。@var{func}に@var{n}個の引数を指定できる場合、@w{@code{@var{m}
< @var{n}}}個の引数で@code{apply-partially}を呼び出すと、@w{@code{@var{n} -
@var{m}}}個の新たな関数を生成します。

以下は、@code{apply-partially}と他のビルトイン関数@code{+},を使用して、(もし存在しないなら)ビルトイン関数@code{1+}を定義する例です:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  引数として関数をとったり、データ構造(特にフック変数やプロパティーリスト)から関数を探す関数はLispでは一般的で、それらは@code{funcall}や@code{apply}を使用してそれらの関数を呼び出します。引数として関数をとる関数は、@dfn{ファンクショナル(functional)}と呼ばれるときもあります。

  ファンクショナルを呼び出すとき、引数としてno-op関数(何も行わない関数)を指定できると便利なときがあります。以下に２つの異なるno-op関数を示します:

@defun identity arg
この関数は@var{arg}をreturnします。副作用はありません。
@end defun

@defun ignore &rest args
この関数は任意の引数を無視して、@code{nil}をreturnします。
@end defun

  いくつかの関数はユーザーに可視な@dfn{コマンド}で、これらは(通常はキーシーケンスを介して)対話的に呼び出すことができます。そのようなコマンドは、@code{call-interactively}関数を使用することにより、対話的に呼びだされたときと同様に呼び出すことができます。@ref{Interactive
Call}を参照してください。

@node Mapping Functions
@section Mapping Functions
@cindex mapping functions

  @dfn{マップ関数(mapping
function)}は与えられた関数(スペシャルフォームやマクロでは@emph{ない})を、リストや他のコレクションの各要素に適用します。Emacs
Lispにはそのような関数がいくつかあります。このセクションでは、リストにたいしてマッピングを行う@code{mapcar}、@code{mapc}、@code{mapconcat}を説明します。obarray内のシンボルにたいしてマッピングを行う関数@code{mapatoms}は、@ref{Definition
of
mapatoms}を参照してください。ハッシュテーブル内のkey/value関係にたいしてマッピングを行う関数@code{maphash}は、@ref{Definition
of maphash}を参照してください。

  これらのマップ関数は、文字テーブル(char-table)には適用されません。なぜなら文字テーブルは非常に広い範囲の疎な配列だからです。疎な配列であるという性質に適う方法で文字いテーブルにマッピングするには、関数@code{map-char-table}を使用します(@ref{Char-Tables}を参照してください)。

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar}は、関数@var{function}を@var{sequence}の各要素にたいして順番に適用し、その結果をリストでreturnします。

引数@var{sequence}には、文字テーブルを除く任意の種類のシーケンス ---
つまりリスト、ベクター、ブールベクター、文字列を指定できます。結果は常にリストになります。結果の長さは、@var{sequence}の長さと同じです。たとえば:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{@code{my-hooks}内の各関数を呼び出す。}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{リストが消費されていなければ、}
  (if (not (memq nil args))
      ;; @r{@sc{car}に関数を適用する。}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{残りの要素のための再帰。}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc}は@code{mapcar}と似ていますが、@var{function}は副作用のためだけに使用されます ---
つまり@var{function}がreturnする値は無視され、リストに収集されません。@code{mapc}は常に@var{sequence}をreturnします。
@end defun

@defun mapconcat function sequence separator
@code{mapconcat}は関数@var{function}を@var{sequence}の各要素に適用します。結果は結合された文字列になります。結果文字列の間に、@code{mapconcat}は文字列@var{separator}を挿入します。@var{separator}には通常、スペースやカンマ、あるいはその他の適切な区切り文字が含まれます。

引数@var{function}はははは、1つの引数を取り文字列をreturnする関数でなければなりません。引数@var{sequence}には、文字テーブルを除く、任意の種類のシーケンス
--- つまりリスト、ベクター、ブールベクター、文字列を指定できます。

@example
@group
(mapconcat 'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Anonymous Functions
@cindex anonymous function

  関数は通常、@code{defun}により定義され、同時に名前が与えられますが、明示的にラムダ式を使う --- @dfn{無名関数(anonymous
function)}のほうが便利なときもあります。無名関数は、名前つき関数が有効な場所なら、どこでも有効です。無名関数は変数や関数の引数に割り当てられることがよくあります。たとえば、ある関数をリストの各要素に適用する@code{mapcar}の@var{function}引数に渡すかもしれません(@ref{Mapping
Functions}を参照してください)。現実的な例は、@ref{describe-symbols example}を参照してください。

  無名関数として使用するためのラムダ式を定義するとき、原則的にはリストを構築する任意の手法を使用できます。しかし通常は、マクロ@code{lambda}、スペシャルフォーム@code{function}、または入力構文@code{#'}を使用するべきです。

@defmac lambda args [doc] [interactive] body@dots{}
このマクロは引数リスト@var{args}、(もしあれば)ドキュメント文字列@var{doc}、(もしあれば)インタラクティブ指定@var{interactive}、および@var{body}で与えられるbodyフォームをもつ無名関数をreturnします。

実際にはこのマクロは@code{lambda}フォームを``自己クォート(self-quoting)''します。つまり@sc{car}が@code{lambda}であるようなフォームは、そのフォーム自身を得ます。

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

@code{lambda}フォームは別に、1つの効果をもちます。このマクロは、@code{function}(以下参照)をサブルーチンとして使用することにより、Emacs評価機能(Emacs
evaluator)とバイトコンパイラーに、その引数が関数であることを告げます。
@end defmac

@defspec function function-object
@cindex function quoting
このスペシャルフォームは、評価を行わずに、@var{function-object}をreturnします。この点では、@code{quote}(@ref{Quoting}を参照してください)と似ています。しかし@code{quote}とは異なり、Emacs評価機能とバイトコンパイラーに、これを関数として使用する意図を告げる役割をもちます。@var{function-object}が有効なラムダ式と仮定すると、これは２つの効果をもちます:

@itemize
@item
そのコードがバイトコンパイルされているとき、@var{function-object}はバイトコード関数オブジェクトにコンパイルされます(@ref{Byte
Compilation}を参照してください)。

@item
レキシカルバインドが有効な場合、@var{function-object}はクロージャーに変換されます。@ref{Closures}を参照してください。
@end itemize
@end defspec

@cindex @samp{#'} syntax
入力構文@code{#'}は、@code{function}の使用の略記です。以下のフォームは等価です:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  以下の例では、3つ目の引数に関数をとる、@code{change-property}関数を定義し、その後の@code{change-property}で、無名関数を渡してこれを使用しています:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
@code{lambda}フォームをクォートしていないことに注意してください。

   上記のコードをコンパイルした場合は、無名関数もコンパイルされます。リストをクォートすることにより無名関数を構築した場合、コンパイルはされません。

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
この場合、無名関数はコンパイルされたコード内のラムダ式に保持されます。バイトコンパイラーは、@code{change-property}が関数としての使用を意図していることを知ることができないので、たとえこの関数が関数のように見えるとしても、このリストが関数であると決め込むことはできません。

@node Function Cells
@section Accessing Function Cell Contents

  あるシンボルの@dfn{関数定義(function
definition)}とは、そのシンボルの関数セルに格納されたオブジェクトのことです。ここでは、シンボルの関数セルにアクセス、テスト、セットする関数を説明します。

  @ref{Definition of indirect-function}の、関数@code{indirect-function}も参照してください。

@defun symbol-function symbol
@kindex void-function
これは@var{symbol}の関数セル内のオブジェクトをreturnします。これは、returnされたオブジェクトが本物のの関数であるかチェックしません。

関数セルがvoidの場合、return値は@code{nil}です。関数セルがvoidのときと、@code{nil}がセットされているときを区別するには、@code{fboundp}(以下参照)を使用します。

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  シンボルに何の関数定義も与えていない場合、そのシンボルの関数セルは@dfn{void}だと言います。別の言い方をすると、その関数セルは、どんなLispオブジェクトも保持しません。そのシンボルを関数として呼びだそうとすると、Emacsは@code{void-function}エラーをシグナルします。

  voidは、@code{nil}やシンボル@code{void}とは異なることに注意してください。シンボル@code{nil}および@code{void}はLispオブジェクトであり、他のオブジェクトと同様、関数セルに格納することができます(これらのシンボルは@code{defun}を使用して有効な関数に成ることができます)。voidである関数セルは、どのようなオブジェクトも含みません。

  @code{fboundp}を使用して、任意のシンボルの関数定義がvoidかどうかテストすることができます。シンボルに関数定義を与えた後は、@code{fmakunbound}をつかえば、再びvoidにすることができます。

@defun fboundp symbol
この関数は、そのシンボルが関数セルにオブジェクトをもっていれば@code{t}、それ以外は@code{nil}をreturnします。これは、そのオブジェクトが本物の関数であるかチェックしません。
@end defun

@defun fmakunbound symbol
この関数は@var{symbol}の関数セルをvoidにします。そのため、これ以降に関数セルにアクセスしようと試みると、@code{void-function}エラーが発生します。これは@var{symbol}をreturnします(@ref{Void
Variables}の@code{makunbound}も参照してください)。

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
この関数は@var{symbol}の関数セルに、@var{definition}を格納します。結果は@var{definition}です。@var{definition}は通常、関数または関数の名前であるべきですが、これはチェックされません。引数@var{symbol}は、通常のどおり評価される引数です。

この関数は主に、関数を定義したり変更すして構成を行う、@code{defun}や@code{advice-add}のようなものからサブルーチンとして使用されます。シンボルにたいして、たとえばキーボードマクロ(@ref{Keyboard
Macros}を参照してください)のような、関数ではない関数定義与えるためにも使用することができます:

@example
;; @r{名前つきのキーボードマクロを定義する。}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

関数にたいして別の名前を作成するために@code{fset}を使いたい場合は、かわりに@code{defalias}の使用を考慮してください。@ref{Definition
of defalias}を参照してください。
@end defun

@node Closures
@section Closures

  @ref{Variable
Scoping}で説明したように、Emacsはオプションで変数のレキシカルバインディングを有効にできます。レキシカルバインディングが有効な場合、あなたが(たとえば@code{defun}などで)作成した任意の名前つき関数、同様に@code{lambda}マクロ、@code{function}スペシャルフォーム、@code{#'}構文を使用して作成した任意の無名関数(@ref{Anonymous
Functions}を参照してください)は、自動的に@dfn{クロージャー(closure)}に変換されます。

@cindex closure
  クロージャーとは、その関数が定ぎされたどときに存在したレキシカル環境の記録もあわせもつ関数です。クロージャーが呼び出されたとき、定義内のレキシカル変数の参照には、その保持されたレキシカル環境を使用されます。他のすべての点では、クロージャーは通常の関数と同様に振る舞います。特に、クロージャーは通常の関数と同じ方法で呼び出すことができます。

  クロージャー使用する例は、@ref{Lexical Binding}を参照してください。

  現在のところ、Emacs
Lispのクロージャーオブジェクトは、1つ目の要素にシンボル@code{closure}をもつリストとして表現されます。そのリストは2つ目の要素としてレキシカル環境を表し、残りの要素で引数リストとbodyフォームを表します:

@example
;; @r{レキシカルバインディングが有効。}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example

@noindent
しかし実際には、クロージャーの内部構造は、内部的な実装の詳細と判断される残りのLisp界を``晒け出す''ものだと言えます。この理由により、クロージャーオブジェクトの構造を直接調べたり変更することは推奨しません。

@node Advising Functions
@section Advising Emacs Lisp Functions
@cindex advising functions
@cindex piece of advice

他のライブラリーの関数定義を変更する必要があるとき、または@code{@var{foo}-function}oのようなフックやプロセスフィルター(process
filter)、または関数を値としてもつ任意の変数またはオブジェクトを変更する必要があるときには、名前つきの関数には@code{fset}か@code{defun}、フック変数には@code{setq}、プロセスフィルターには@code{set-process-filter}のように、適切なセッター関数(setter
function)を使用することができます。しかし、これらが以前の値を完全に破棄してしまうのが好ましくない場合もあります。

  @dfn{アドバイス(advice)}機能により、@dfn{関数にアドバイス}することにより、既存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手法です。

Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コアとなるセットは、変数やオブジェクトのフィールドに保持された関数値にたいするものです(対応するプリミティブは@code{add-function}と@code{remove-function}です)。もう1つのセットは、名前つき関数の最上位のレイヤーとなるものです(主要なプリミティブは@code{advice-add}と@code{advice-remove}です)。

たとえば、プロセス@var{proc}のプロセスフィルターの呼び出しをトレースするためには、以下を使用できます:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

これにより、そのプロセスの出力は、元のプロセスフィルターに渡される前に、@code{my-tracing-function}に渡されるようになります。@code{my-tracing-function}は元の関数と同じ引数を受け取ります。これを行った場合、以下のようにしてトレースを行わない振る舞いにリバートすることができます。

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

同様に、@code{display-buffer}という名前つきの関数の実行をトレースしたい場合は、以下を使用できます:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

ここで、@code{his-tracing-function}は元の関数のかわりに呼び出され、元の関数(加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び出すことができます。出力を確認し終えたら、以下のようにしてトレースしない振る舞いにリバートできます:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

上記の例で使用されている引数@code{:before}と@code{:around}は、2つの関数が構成される方法を指定します(これを行うには多くの方法があるからです)。追加された関数も、@emph{アドバイス(advice)}と呼ばれます。

@menu
* Core Advising Primitives::  アドバイスを扱うプリミティブ。
* Advising Named Functions::  名前つき関数のアドバイス。
* Advice combinators::       アドバイスを構成する方法。
* Porting old advices::      古いdefadviceを使用したコードの改良。
@end menu

@node Core Advising Primitives
@subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
このマクロは@var{place}(@ref{Generalized
Variables}を参照してください)に格納された関数に、アドバイス@var{function}を追加する手軽な方法です。

@var{where}は、既存の関数のどこに --- たとえば元の関数の前、または後に ---
@var{function}が構成されるかを決定します。2つの関数を構成するために利用可能な方法のリストは、@ref{Advice
combinators}を参照してください。

(通常は名前が@code{-function}で終わる)変数を変更するときには、@var{function}がグローバルに使用されるか、あるいはカレントバッファーだけに使用されるか選ぶことができます。@var{place}が単にシンボルの場合、@var{function}は@var{place}のグローバル値に追加されます。@var{place}が@code{(local
@var{symbol})}というフォームの場合、@var{symbol}はその変数の名前をreturnする式なので、@var{function}はカレントバッファーだけに追加されます。最後に、レキシカル変数を変更したい場合には、@code{(var
@var{variable})}を使用する必要があるでしょう。

@code{add-function}で追加されたすべての関数は、自動的にプロパティー@var{props}の関連リストに加えることができます。現在のところ、特別な意味をもつのは2つのプロパティーだけです:

@table @code
@item name
これはアドバイスの名前を与えます。この名前は、@code{remove-function}が取り除く関数を識別するのに使用できます。これは通常、@var{function}が無名関数のときに使用されます。

@item depth
これは複数のアドバイスが与えられたときに、どのようにアドバイスを順番づけるかを指定します。depthのデフォルト0です。depthが100のとき、このアドバイスは可能な限りの深さを保持すべきことを意味し、-100のときは最外のアドバイスに留めることを意味します。同じdepthで2つのアドバイスが指定された場合、もっとも最近に追加されたアドバイスが最外になります。

@code{:before}アドバイスにたいしては、最外(outermost)になるということは、このアドバイスが他のアドバイスの前、つまり1番目に実行されることを意味し、最内(innermost)とは元の関数が実行される直前、すなわちこのアドバイスと元の関数の間に実行されるアドバイスは存在しないことを意味します。同様に@code{:after}アドバイスにたいしては、最内とは元の関数の直後、つまりこの元の関数とアドバイスの間に実行される他のアドバイスは存在せず、最外とは他のすべてのアドバイスが実行された後にこのアドバイスが実行されることを意味します。@code{:override}の最内アドバイスは、元の関数だけをオーバーライドし、他のアドバイスは適用されませんが、@code{:override}の最外アドバイスは元の関数だけではなく。その他すべての適用済みのアドバイスををオーバーライドします。
@end table

@var{function}がインタラクティブでない場合、欠オグされた関数は、(もしあれば)元の関数のインタラクティブ指定(interactive
spec)を継承します。それ以外は、結合された関数はインタラクティブになり、@var{function}のインタラクティブ指定を使用します。1つ例外があります。@var{function}のインタラクティブ指定が、(式や文字列ではない)関数の場合、元の関数のインタラクティブ指定を唯一の引数として、その関数を呼び出して、それが結合された関数のインタラクティブ指定になります。引数として受け取ったインタラクティブ指定を解釈するためには、@code{advice-eval-interactive-spec}を使用します。

注意:
@var{function}のインタラクティブ指定は結合された関数に適用され、@var{function}ではなく、結合された関数の呼び出し規約に従うべきです。多くの場合、これらは等しいので差異は生じませんが、@var{function}の@code{:around}、@code{:filter-args}、@code{filter-return}では、重要になります。
@end defmac

@defmac remove-function place function
このマクロは@var{place}に格納された関数から、@var{function}を取り除きます。これは、@code{add-function}を使用して、@var{function}が@var{place}に追加されたときだけ機能します。

@var{function}は、@var{place}に追加された関数にたいして、ラムダ式にたいしても機能するように、@code{equal}を使用して比較を試みます。これは追加で@var{place}に追加された関数の@code{name}プロパティーも比較します。これは@code{equal}を使用してラムダ式を比較するより信頼性があります。
@end defmac

@defun advice-function-member-p advice function-def
@var{advice}がすでに@var{function-def}内にある場合は、非@code{nil}をreturnします。上記の@code{remove-function}と同様、実際の関数@var{advice}のかわりに、アドバイス断片(piece
of advice)の@code{name}も使用できます。
@end defun

@defun advice-function-mapc f function-def
@var{function-def}に追加されたすべてのアドバイスに対して、関数@var{f}を呼び出します。@var{f}は2つの引数 ---
アドバイス関数と、それのプロパティーで呼びだされます。
@end defun

@defun advice-eval-interactive-spec spec
そのような指定で関数がインタラクティブに呼び出されたように、インタラクティブ指定@var{spec}を評価して、構築された引数のリストに対応するリストをreturnします。たとえば、@code{(advice-eval-interactive-spec
"r\nP")}は、リージョンの境界、カレントプレフィクス引数を含む、3つの要素からなるリストをreturnします。
@end defun

@node Advising Named Functions
@subsection Advising Named Functions
@cindex advising named functions

アドバイスの一般的な使い方は、名前つき関数やマクロにたいして使用する方法です。これは単に@code{add-function}を使用して以下のように行うことができます:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  しかし、かわりに@code{advice-add}と@code{advice-remove}を使うべきです。この別の関数セットは名前つき関数に適用されるアドバイス断片を操作するためのもので、@code{add-function}と比較して以下の追加機能があります。まず、これらはマクロおよびオートロードされた関数を扱う方法を知っています。次に、@code{describe-function}にたいして、追加されたアドバイスと同様に、元のドキュメント文字列を維持します。さらに、関数が定義される前でも、アドバイスの追加と削除ができます。

  既存の関数を関数全体を再定義せずに、既存の呼び出しを変更するために、@code{advice-add}は有用になります。しかし、その関数の既存の呼び出し元は、古い振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更されたときに正しく機能しないかもしれないので、これはソースのバグにもなり得ます。アドバイスはデバッグを難しくする可能性もあります。デバッグを行う人は、その関数がアドバイスにより変更されたことに気づかなかったり、失念しているかもしれません。

  これらの理由により、他の方法で関数の振る舞いを変更できない場合のために、アドバイスの使用は控えるべきです。フックを通じて同じことが行えるなら、フック(@ref{Hooks}を参照してください)の使用が望ましい方法です。特定のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマンドのキーバインドを新しいコマンドに再マップ(@ref{Remapping
Commands}を参照してください)するのが、おそらくより良い方法です。特に、Emacs自身のソースファイルは、Emacs内の関数をアドバイスするべきではありません(現在のところこの慣習には数少ない例外がありますが、わたしたちはこれを改善しようと思っています)。

  スペシャルフォーム(@ref{Special
Forms}を参照してください)はアドバイスできませんが、マクロは関数と同じ方法でアドバイスできます。もちろん、これはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバイスが確実にインストールされる必要があります。

  プリミティブ(@ref{What Is a
Function}を参照してください)にアドバイスするのは可能ですが、2つの理由により通常は行うべきでは@emph{ありません}。1つ目の理由は、いくつかのプリミティブはアドバイスのメカニズム内で使用されているため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。2つ目の理由は、多くのプリミティブがCから直接呼び出されていて、そのような呼び出しはアドバイスを無視するからです。したがって、プリミティブにたいしてアドバイスの使用を控えることは、ある呼び出しはアドバイスにしたがい(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわない(Cコードから呼び出されたため)という混乱した状況を解決します。

@defun advice-add symbol where function &optional props
名前つき関数@var{symbol}に、アドバイス@var{function}を追加します。@var{where}と@var{props}は、@code{add-function}(@ref{Core
Advising Primitives}を参照してください)のときと同じ意味をもちます。
@end defun

@defun advice-remove symbol function
名前つき関数@var{symbol}からアドバイス@var{function}を取り除きます。@var{function}にアドバイスの@code{name}を指定することもできます。
@end defun

@defun advice-member-p function symbol
名前つき関数@var{symbol}内にすでにアドバイス@var{function}がある場合は、非@code{nil}をreturnします。@var{function}にアドバイスの@code{name}を指定することもできます。
@end defun

@defun advice-mapc function symbol
名前つき関数@var{symbol}にすでに追加されたすべての関数にたいして、@var{function}を呼び出します。@var{function}は2つの引数、アドバイス関数と、そのプロパティーで呼び出されます。
@end defun

@node Advice combinators
@subsection Ways to compose advices

以下は@code{add-function}および@code{advice-add}の@var{where}引数に可能な値で、そのアドバイス@var{function}と元の関数が構成されるべき方法を指定します。

@table @code
@item :before
古い関数の前に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar}
@var{function})}は、ノーマルフックにたいする@code{(add-hook '@var{hookvar}
@var{function})}のような、1関数のフックと同等です。

@item :after
古い関数の後に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar}
@var{function})}は、ノーマルフックにたいする@code{(add-hook '@var{hookvar} @var{function}
'append)}のような、1関数のフックと同等です。

@item :override
これは古い関数を新しい関数に完全に置き換えます。もちろん、@code{remove-function}を呼び出した後に、古い関数は復元されます。

@item :around
古い関数のかわりに@var{function}を呼び出しますが、古い関数は@var{function}の追加の引数になります。これはもっとも柔軟な結合です。たとえば、古い関数を異なる引数で呼び出したり、複数回呼び出したり、letバインディングで呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完全にオーバーライドすることが可能になります。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をreturnした場合は古い関数を呼び出しません。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような、1関数のフックと同等です。

@item :before-until
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をreturnした場合だけ古い関数を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})}
は、@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような、1関数のフックと同等です。

@item :after-while
古い関数が非@code{nil}をreturnした場合だけ、古い関数の後に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、@var{function}のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような、1関数のフックと同等です。

@item :after-until
古い関数が@code{nil}をreturnした場合だけ、古い関数の後に@var{function}を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような、1関数のフックと同等です。

@item :filter-args
最初に@var{function}を呼び出し、その結果(リスト)を新たな引数として古い関数に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
最初に古い関数を呼び出し、その結果を@var{function}に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advices
@subsection Adapting code using the old defadvice
@cindex old advices, porting

多くのコードは古い@code{defadvice}メカニズムを使用しており、これらの大半は@code{advice-add}により陳腐化しました。@code{advice-add}の実装と意味は、とてもシンプルです。

古いアドバイスは以下のようなものです:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できます:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

これが実際の@code{previous-line}を変更しないことは明確です。古いアドバイスには、以下が必要です:
@example
(ad-activate 'previous-line)
@end example
一方、新しいアドバイスメカニズムでは、以下が必要です:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

@code{ad-activate}はグローバルな効果をもつことに注意してください。これは、指定された関数にたいして、アドバイスのすべての断片を有効にします。特定のアドバイスだけをアクティブ、または非アクティブにしたい場合、@code{ad-enable-advice}、または@code{ad-disable-advice}により、@emph{有効}または@emph{無効}にする必要があります。新しいメカニズムではこの区別はなくなりました。

以下のようなaroundのアドバイスがあるとします:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

これは以下のように変換できます:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

アドバイスの@emph{クラス}について、新たな@code{:before}は、古い@code{before}は完全に等価ではないことに注意してください。なぜなら古いアドバイス内では、(たとえば@code{ad-set-arg}を使って)その関数の引数を変更できそれは元の関数が参照する引数値に影響します。しかし新しい@code{:before}は、@code{setq}を通じてアドバイス内の引数をし、その変更は元の関数からの参照に影響しません。この振る舞いにもとづいて@code{before}アドバイスを移行するときは、代わりにそれを新たなアドバイス@code{:around}または@code{:filter-args}に変更する必要があるでしょう。

同様に、古い@code{after}アドバイスは、@code{ad-return-value}を変更することによりreturn値を変更できますが、新しい@code{:after}は変更できないので、そのような@code{after}を移行するときは、かわりにそれらを新しいアドバイス@code{:around}または@code{:filter-return}に変更する必要があるでしょう。

@node Obsolete Functions
@section Declaring Functions Obsolete
@cindex obsolete functions

  名前つき関数を@dfn{陳腐化している(obsolete)}とマークすることができます。これは、その関数が将来のある時点で削除されるかもしれないことを意味します。陳腐化しているとマークされた関数を含むコードをバイトコンパイルしたとき、Ｅｍａｃｓは警告を発します。また、その関数のヘルプドキュメントは表示されなくなります。他の点においては、陳腐化した関数は他の任意の関数と同様に振る舞います。

  関数を陳腐化しているとマークするもっとも簡単な方法は、その関数の@code{defun}定義に@code{(declare (obsolete
@dots{}))}を配置することです。@ref{Declare
Form}を参照してください。かわりに、以下で説明している@code{make-obsolete}関数を使うこともできます。

  @code{make-obsolete}を使用して、マクロ(@ref{Macros}を参照してください)を陳腐化しているとマークすることもできます。これは関数のときと同じ効果をもちます。関数またはマクロにたいするエイリアスも、陳腐化しているとマークできます。これはエイリアス自身をマークし、名前解決される関数またはマクロにたいしてではありません。

@defun make-obsolete obsolete-name current-name &optional when
この関数は、@var{obsolete-name}を陳腐化しているとマークします。@var{obsolete-name}には関数またはマクロを名前づけるシンボル、、または関数やマクロにたいするエイリアスを指定します。

@var{current-name}がシンボルの場合は、@var{obsolete-name}のかわりに@var{current-name}の使用を促す警告メッセージになります。@var{current-name}は、@var{obsolete-name}にたいするエイリアスである必要はありません。似たような機能をもつ、別の関数かもしれません。@var{current-name}には、警告メッセージとなる文字列も指定できます。メッセージは小文字で始まりピリオドで終えるべきです。@code{nil}も指定でき、この場合には警告メッセージに追加の詳細は提供されません。

@var{when}が与えられた場合、それは最初にその関数が陳腐化する時期を示す文字列 --- たとえば火付けやリリース番号を指定します。
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
この便利なマクロは関数@var{obsolete-name}を陳腐化しているとマークするとともに、それを関数@var{current-name}のエイリアスにします。これは以下と等価です:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

加えて、陳腐化した関数にたいする特定の呼び出し規約をマークできます。

@defun set-advertised-calling-convention function signature when
この関数は、@var{function}を呼び出す正しい方法として、引数リスト@var{signature}を指定します。これにより、Emacs
Lispプログラムが他の方法で@var{function}を呼び出している場合には、Emacsのバイトコンパイラーが警告を発します(それでもコードはバイトコンパイルされます)。@var{when}には、その変数が最初に陳腐化するときを示す文字列(通常はバージョン番号)を指定します。

たとえば、古いバージョンのEmacsでは、@code{sit-for}には以下のように3つの引数を指定していました

@example
  (sit-for seconds milliseconds nodisp)
@end example

しかしこの方法による@code{sit-for}の呼び出しは陳腐化していると判断されます(@ref{Waiting}を参照してください)。以下のように、古い呼び出し規約は推奨されません:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Inline Functions
@cindex inline functions

  @dfn{インライン関数(inline
function)}は関数と同様に機能しますが、1つ例外があります。その関数の呼び出しがバイトコンパイルされると(@ref{Byte
Compilation}を参照してください)、その関数の定義が呼び出し元に展開されます。インライン関数を定義するには、@code{defun}のかわりに@code{defsubst}を使用します。

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
このマクロはインライン関数を定義します。マクロの構文は@code{defun}とまったく同じです(@ref{Defining
Functions}を参照してください)。
@end defmac

  関数をインラインにすることにより、その関数の呼び出しが高速になる場合があります。しかし欠点もあります。1つは柔軟性の減少です。その関数の定義を変更した場合、すでにインライン化された呼び出しは、リコンパイルを行うまで古い定義を使用します。

  もう1つの欠点は、大きな関数をインライン化することにより、コンパイルされたコードのファイル上およびメモリー上のサイズが増大することです。スピード面でのインライン化の有利性は小さい関数にたいして顕著なので、一般的に大きな関数をインライン化するべきではありません。

  インライン関数は、デバッグ、トレース、アドバイス(@ref{Advising
Functions}を参照してください)に際してうまく機能しません。デバッグの容易さと関数の再定義の柔軟さはEmacsの重要な機能なので、スピードがとても重要であり、@code{defun}の使用が実際に性能の面で問題となるのか検証するためにすでにコードをチューニングしたのでなければ、たとえその関数が小さくてもインライン化するべきでは
ありません。

  インライン関数が実行するのと同じコードに展開されるマクロ(@ref{Macros}を参照してください)を定義することは可能です。しかし式内でのマクロの直接の使用には制限があります
---
@code{apply}、@code{mapcar}などでマクロを呼び出すことはできません。通常の関数からマクロへの変換には、そのための余分な作業が必要になります。通常の関数をインライン関数に変換するのは簡単です。@code{defun}を@code{defsubst}に置き換えるだけです。インライン関数の引数はそれぞれ正確に1回評価されるので、マクロのときのように、bodyで引数を何回使用するか心配する必要はありません。

  インライン関数を定義した後、そのインライン展開はマクロ同様、同じファイル内の後の部分で処理されます。

@node Declare Form
@section The @code{declare} Form
@findex declare

  @code{declare}(宣言)は特別なマクロで、関数やマクロに``メタ''プロパティーを追加するために使用できます。たとえば陳腐化しているとマークしたり、Emacs
Lispモード内の特別な@key{TAB}インデント規則を与えることができます。

@anchor{Definition of declare}
@defmac declare specs@dots{}
このマクロは引数を無視して、@code{nil}として評価され、実行時の効果はありません。しかし@code{defun}または@code{defsubst}(@ref{Defining
Functions}を参照してください)、または@code{defmacro}マクロ(@ref{Defining
Macros}を参照してください)の定義の@var{declare}引数に@code{declare}フォームがある場合は、@var{specs}で指定されたプロパティーを関数またはマクロに追加します。これは@code{defun}、@code{defsubst}、@code{defmacro}により特別に処理されます。

@var{specs}内の各要素は@code{(@var{property}
@var{args}@dots{})}というフォームをもつべきです。また、クォートするべきではありません。これらは、以下の効果をもちます:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
これは@code{set-advertised-calling-convention}(@ref{Obsolete
Functions}を参照してください)の呼び出しと同じように振る舞います。@var{signature}はその関数(またはマクロにたいする正しい引数リスト)で、@var{when}は古い引数リストが最初に陳腐化する時期を示す文字列を指定します。

@item (debug @var{edebug-form-spec})
これはマクロだけに有効です。Edebugでそのマクロ入ったときに、@var{edebug-form-spec}を使用します。@ref{Instrumenting
Macro Calls}を参照してください。

@item (doc-string @var{n})
それ自身が関数、マクロ、または変数のようなエンティティーを定義するために使用される関数やマクロを定義するときに使用されます。これは@var{n}番目の引数を示し、もしあれば、それはドキュメント文字列です。

@item (indent @var{indent-spec})
この関数(またはマクロ)にたいするインデント呼び出しは、@var{indent-spec}にしたがいます。これは関数でも機能しますが、通常はマクロで使用されます。@ref{Indenting
Macros}を参照してください。

@item (obsolete @var{current-name} @var{when})
@code{make-obsolete}(@ref{Obsolete
Functions}を参照してください)と同様に、関数(またはマクロ)を陳腐化しているとマークします。@var{current-name}にはシンボル(かわりにこのシンボルを使うことをすすめる警告メッセージになります)、文字列(警告メッセージを指定します)、または@code{nil}(警告メッセージには追加の詳細が含まれません)を指定します。@var{when}には、その関数(またはマクロ)が最初に陳腐化する時期を示す文字列を指定します。

@item (compiler-macro @var{expander})
これは関数だけに使用でき、最適化関数(optimization
function)として@var{expander}を使用するようコンパイラーに告げます。@code{(@var{function}
@var{args}@dots{})}のようなその関数への呼び出しフォームに出会うと、マクロ展開機能(macro
expander)は@var{args}@dots{}と同様のフォームで@var{expander}を呼び出します。@var{expander}はその関数呼び出しのかわりに使用するための新しい式、または変更されていないフォーム(その関数呼び出しを変更しないことを示す)のどちらかをreturnすることができます。@var{expander}にはシンボル、またはフォーム@code{(lambda
(@var{arg})
@var{body})}を指定できます。フォームの場合、@var{arg}は元の関数呼び出し式を保持して、その関数の形式に適う引数を使用することにより、その関数にたいする(評価されていない)引数にアクセスできます。

@item (gv-expander @var{expander})
@var{expander}が@code{gv-define-expander}と同様、汎変数としてマクロ(または関数)にたいする呼び出しを処理する関数であることを宣言します。@var{expander}はシンボル、またはフォーム@code{(lambda
(@var{arg}) @var{body})}を指定できます。フォームの場合、その関数は追加でそのマクロ(または関数)にアクセスできます。

@item (gv-setter @var{setter})
@var{setter}が、汎変数としてマクロ(または関数)にたいする呼び出しを処理する関数であることを宣言します。@var{setter}はシンボル、またはフォームを指定できます。シンボルの場合、そのシンボルは@code{gv-define-simple-setter}に渡されます。フォームの場合は@code{(lambda
(@var{arg})
@var{body})}という形式で、その関数は追加でマクロ(または関数)にアクセスでき、@code{gv-define-setter}に渡されます。

@end table

@end defmac

@node Declaring Functions
@section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

あるファイルをバイトコンパイルするとき、コンパイラーが知らない関数について警告が生成されるときがあります(@ref{Compiler
Errors}を参照してください)。実際に問題がある場合もありますが、問題となっている関数がそのコードの実行時にロードされる他のファイルで定義されている場合が通常です。たとえば以前は、@file{fortran.el}をバイトコンパイルすると、以下のような警告が出ていました:

@example
In end of data:
fortran.el:2152:1:Warning: the function `gud-find-c-expr' is not
    known to be defined.
@end example

実際のところ、@code{gud-find-c-expr}は、Fortranモードが使用する@code{gud-find-expr-function}のローカル値(GUDからのコールバック)の中だけで使用されていて、呼びだされた場合はGUD関数がロードされます。そのような警告が実際には問題を示さないことを知っているときには、警告を抑制したほうがよいでしょう。そうすれば、実際に問題があることを示す新しい警告の識別性が良くなります。@code{declare-function}を使用して、これを行うことができます。

必要なのは、問題となっている関数を最初に使用する前に@code{declare-function}命令を追加するだけです:

@example
(declare-function gud-find-c-expr "gud.el" nil)
@end example

これは@code{gud-find-c-expr}が@file{gud.el}(@samp{.el}は省略可)の中で定義していることを告げます。コンパイラーは関数がそのファイルで実際に定義されているとみなし、チェックを行いません。

  3つ目の引数はオプションで、@code{gud-find-c-expr}の引数リストを指定します。この例では、引数はありません(@code{nil}と値を指定しないのは、異なります)。それ以外の場合は、@code{(file
&optional
overwrite)}のようになります。引数リストを指定する必要はありませんが、指定すればコンパイラーはその呼び出しが宣言と合致するかチェックできます。

@defmac declare-function function file &optional arglist fileonly
バイトコンパイラーにたいして、引数@var{arglist}をとる@var{function}が定義されていて、その定義は@var{file}にあるとみなすように告げます。@var{fileonly}が非@code{nil}の場合は、@var{file}が存在することだけをチェックして、実際の@var{function}の定義はチェックしないことを意味します。
@end defmac

  これらの関数が@code{declare-function}が告げる場所で実際に宣言されているか検証するには、@code{check-declare-file}を使用して、1つのソースファイル中のすべての@code{declare-function}呼び出しをチェックするか、@code{check-declare-directory}を使用して、特定のディレクトリー配下のすべてのファイルをチェックします。

  これらのコマンドは、@code{locate-library}で使用する関数の定義を含むべきファイルを探します。ファイルが見つからない場合、これらのコマンドは@code{declare-function}の呼び出しを含むファイルをがあるディレクトリーからの相対ファイル名に、定義ファイル名を展開します。

  @samp{.c}や@samp{.m}で終わるファイル名を指定することにより、プリミティブ関数を指定することもできます。これが有用なのは、特定のシステムだけで定義されるプリミティブを呼び出す場合だけです。ほとんどのプリミティブは常に定義されているので、それらについて警告を受け取ることはありえないはずです。

  あるファイルがオプションとして外部のパッケージの関数を使う場合があります。@code{declare-function}命令内のファイル名のプレフィクスを@samp{ext:}にすると、そのファイルが見つかった場合はチェックして、見つからない場合はエラーとせずにスキップします。

  @samp{check-declare}が理解しない関数定義もいくつか存在します(たとえば@code{defstruct}や、その他いくつかのマクロ)。そのような場合、@code{declare-function}の@var{fileonly}引数に、非@code{nil}を渡すことができます。これはファイルの存在だけをチェックして、その関数の実際の定義はチェックしないことを意味します。これを行う場合、引数リストを指定する必要はないのですが、@var{arglist}引数には@code{t}をセットするべきだということに注意してください(なぜなら@code{nil}は、引数リストが指定されなかったという意味ではなく、空の引数リストを意味するからです)。

@node Function Safety
@section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

SESのようないくつかのメジャーモードは、ユーザーファイル内に格納された関数を呼び出します(@inforef{Top, ,ses}, for more
information on SESを参照してください)。 ユーザーファイルには素性があやふやな場合があります ---
初対面の人から受け取ったスプレッドシートかもしれず、会ったことのない誰かから受け取ったeメールかもしれません。そのため、ユーザーファイルに格納されたソースコードの関数を呼び出すのは、それが安全だと決定されるすまでは危険です。

@defun unsafep form &optional unsafep-vars
@var{form}が@dfn{安全(safe)}なLisp式の場合は@code{nil}、危険な場合はなぜその式が危険かもしれないのか説明するリストをreturnします。引数@var{unsafep-vars}は、この時点で一時的なバインドだと判っているシンボルのリストです。これは主に内部的な再帰呼び出しで使用されます。カレントバッファーは暗黙の引数になり、これはバッファーローカルなバインディングのリストを提供します。
@end defun

高速かつシンプルにするために、@code{unsafep}は、とても軽量な分析を行うので、実際には安全な多くのLisp式を拒絶します。安全ではない式にたいして、@code{unsafep}が@code{nil}をreturnするケースは確認されていません。しかし``安全''なLisp式は@code{display}プロパティーと一緒に文字列をreturnでき、これはその文字列がバッファーに挿入された後に実行される、割り当てられたLisp式を含みます。割り当てられた式は、ウィルスかもしれません。安全であるためには、バッファーへ挿入する前に、ユーザーコードにより計算されたすべての文字列からプロパティーを削除しなければなりません。

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (see @pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section Other Topics Related to Functions

  以下のテーブルは、関数呼び出しと関数定義に関連したことを行ういくつかの関数です。これらは別の場所で説明されているので、ここではクロスリファレンスを提供します。

@table @code
@item apply
@ref{Calling Functions}を参照してください。

@item autoload
@ref{Autoload}を参照してください。

@item call-interactively
@ref{Interactive Call}を参照してください。

@item called-interactively-p
@ref{Distinguish Interactive}を参照してください。

@item commandp
@ref{Interactive Call}を参照してください。

@item documentation
@ref{Accessing Documentation}を参照してください。

@item eval
@ref{Eval}を参照してください。

@item funcall
@ref{Calling Functions}を参照してください。

@item function
@ref{Anonymous Functions}を参照してください。

@item ignore
@ref{Calling Functions}を参照してください。

@item indirect-function
@ref{Function Indirection}を参照してください。

@item interactive
@ref{Using Interactive}を参照してください。

@item interactive-p
@ref{Distinguish Interactive}を参照してください。

@item mapatoms
@ref{Creating Symbols}を参照してください。

@item mapcar
@ref{Mapping Functions}を参照してください。

@item map-char-table
@ref{Char-Tables}を参照してください。

@item mapconcat
@ref{Mapping Functions}を参照してください。

@item undefined
@ref{Functions for Key Lookup}を参照してください。
@end table
