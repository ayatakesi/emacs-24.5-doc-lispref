# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-08-30 00:48+0900\n"
"PO-Revision-Date: 2016-09-07 22:50+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: functions.texi.orig:6 functions.texi.orig:7
#, no-wrap
msgid "Functions"
msgstr "Functions"

#. type: Plain text
#: functions.texi.orig:12
msgid ""
"A Lisp program is composed mainly of Lisp functions.  This chapter explains "
"what functions are, how they accept arguments, and how to define them."
msgstr "Lispプログラムは主にLisp関数で構成されます。このチャプターは、関数とは何か、引数を受け取る方法、関数を定義する方法を説明します。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:34
#, no-wrap
msgid "What Is a Function"
msgstr "What Is a Function"

#. type: menuentry
#: functions.texi.orig:32
msgid "Lisp functions vs. primitives; terminology."
msgstr "Lisp関数 vs. プリミティブ; 専門用語。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:186 functions.texi.orig:187
#, no-wrap
msgid "Lambda Expressions"
msgstr "Lambda Expressions"

#. type: menuentry
#: functions.texi.orig:32
msgid "How functions are expressed as Lisp objects."
msgstr "関数がLispオブジェクトとして表現される方法。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:471
#, no-wrap
msgid "Function Names"
msgstr "Function Names"

#. type: menuentry
#: functions.texi.orig:32
msgid "A symbol can serve as the name of a function."
msgstr "シンボルは関数を名づける役割を果たすことができる。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:517 functions.texi.orig:518
#, no-wrap
msgid "Defining Functions"
msgstr "Defining Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Lisp expressions for defining functions."
msgstr "関数定義のためのLisp式。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:626 functions.texi.orig:627
#, no-wrap
msgid "Calling Functions"
msgstr "Calling Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "How to use an existing function."
msgstr "既存の関数を使う方法。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:793 functions.texi.orig:794
#, no-wrap
msgid "Mapping Functions"
msgstr "Mapping Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Applying a function to each element of a list, etc."
msgstr "リストの各要素などに関数を適用する。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:891 functions.texi.orig:892
#, no-wrap
msgid "Anonymous Functions"
msgstr "Anonymous Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Lambda expressions are functions with no names."
msgstr "ラムダ式、それは無名の関数。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:998
#, no-wrap
msgid "Function Cells"
msgstr "Function Cells"

#. type: menuentry
#: functions.texi.orig:32
msgid "Accessing or setting the function definition of a symbol."
msgstr "シンボルの関数定義へのアクセスとセット。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:1102 functions.texi.orig:1103
#, no-wrap
msgid "Closures"
msgstr "Closures"

#. type: menuentry
#: functions.texi.orig:32
msgid "Functions that enclose a lexical environment."
msgstr "レキシカル環境に囲まれた関数。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1140
#, no-wrap
msgid "Advising Functions"
msgstr "Advising Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Adding to the definition of a function."
msgstr "関数の定義への追加。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1584
#, no-wrap
msgid "Obsolete Functions"
msgstr "Obsolete Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Declaring functions obsolete."
msgstr "関数を陳腐と宣言する。"

#. type: section
#: functions.texi.orig:32 functions.texi.orig:1664 functions.texi.orig:1665
#, no-wrap
msgid "Inline Functions"
msgstr "Inline Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Functions that the compiler will expand inline."
msgstr "コンパイラーによりインライン展開される関数。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1709
#, no-wrap
msgid "Declare Form"
msgstr "Declare Form"

#. type: menuentry
#: functions.texi.orig:32
msgid "Adding additional information about a function."
msgstr "関数についての補足的な情報の追加。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1796
#, no-wrap
msgid "Declaring Functions"
msgstr "Declaring Functions"

#. type: menuentry
#: functions.texi.orig:32
msgid "Telling the compiler that a function is defined."
msgstr "関数が定義されていることをコンパイラーに知らせる。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1877
#, no-wrap
msgid "Function Safety"
msgstr "Function Safety"

#. type: menuentry
#: functions.texi.orig:32
msgid "Determining whether a function is safe to call."
msgstr "呼び出しても安全な関数なのか判断する。"

#. type: node
#: functions.texi.orig:32 functions.texi.orig:1964
#, no-wrap
msgid "Related Topics"
msgstr "Related Topics"

#. type: menuentry
#: functions.texi.orig:32
msgid ""
"Cross-references to specific Lisp primitives that have a special bearing on "
"how functions work."
msgstr "関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。"

#. type: section
#: functions.texi.orig:35
#, no-wrap
msgid "What Is a Function?"
msgstr "What Is a Function?"

#. type: cindex
#: functions.texi.orig:37
#, no-wrap
msgid "return value"
msgstr "return value"

#. type: cindex
#: functions.texi.orig:38
#, no-wrap
msgid "value of function"
msgstr "value of function"

#. type: cindex
#: functions.texi.orig:39
#, no-wrap
msgid "argument"
msgstr "argument"

#. type: Plain text
#: functions.texi.orig:45
msgid ""
"In a general sense, a function is a rule for carrying out a computation "
"given input values called @dfn{arguments}.  The result of the computation is "
"called the @dfn{value} or @dfn{return value} of the function.  The "
"computation can also have side effects, such as lasting changes in the "
"values of variables or the contents of data structures."
msgstr "一般的な意味では、関数とは@dfn{引数(arguments)}と呼ばれる与えられた入力値の計算を担うルールです。計算の結果は、その関数の@dfn{値(value)}、または@dfn{return値(return value)}と呼ばれます。計算は、変数の値やデータ構造の内容を変更する等の副作用をもつこともできます。"

#. type: Plain text
#: functions.texi.orig:55
msgid ""
"In most computer languages, every function has a name.  But in Lisp, a "
"function in the strictest sense has no name: it is an object which can "
"@emph{optionally} be associated with a symbol (e.g., @code{car})  that "
"serves as the function name.  @xref{Function Names}.  When a function has "
"been given a name, we usually also refer to that symbol as a ``function'' "
"(e.g., we refer to ``the function @code{car}'').  In this manual, the "
"distinction between a function name and the function object itself is "
"usually unimportant, but we will take note wherever it is relevant."
msgstr "ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しかしLispでは、厳密な意味において、関数は名前をもちません。関数はオブジェクトであり、関数の名前の役割を果たすシンボルに関連づけることができますが(たとえば@code{car})、それは@emph{オプション}です。@ref{Function Names}を参照してください。関数が名前を与えられたとき、通常はそのシンボルを``関数''として参照します(たとえば、関数@code{car}のように参照します)。このマニュアルでは、関数名と関数オブジェクト自身との間の区別は、通常は重要ではありませんが、それが意味をもつような場合は注記します。"

#. type: Plain text
#: functions.texi.orig:60
msgid ""
"Certain function-like objects, called @dfn{special forms} and @dfn{macros}, "
"also accept arguments to carry out computations.  However, as explained "
"below, these are not considered functions in Emacs Lisp."
msgstr "@dfn{スペシャルフォーム(special form)}、@dfn{マクロ(macro)}と呼ばれる、関数likeなオブジェクトがいくつかあり、それらも引数を受け受け、計算を担います。しかし以下で説明するように、Emacs Lispではこれらは関数とは考えられません。"

#. type: Plain text
#: functions.texi.orig:62
msgid "Here are important terms for functions and function-like objects:"
msgstr "以下は関数および関数likeなオブジェクトにたいする、重要な条件です:"

#. type: cindex
#: functions.texi.orig:64 functions.texi.orig:188
#, no-wrap
msgid "lambda expression"
msgstr "lambda expression"

#. type: table
#: functions.texi.orig:67
msgid ""
"A function (in the strict sense, i.e., a function object) which is written "
"in Lisp.  These are described in the following section."
msgstr "Lispで記述された関数(厳密には関数オブジェクト)です。これらについては、以降のセクションで説明します。"

#. type: ifnottex
#: functions.texi.orig:69
msgid "@xref{Lambda Expressions}."
msgstr "@ref{Lambda Expressions}を参照してください。"

#. type: cindex
#: functions.texi.orig:71 functions.texi.orig:72
#, no-wrap
msgid "primitive"
msgstr "primitive"

#. type: cindex
#: functions.texi.orig:73
#, no-wrap
msgid "subr"
msgstr "subr"

#. type: cindex
#: functions.texi.orig:74
#, no-wrap
msgid "built-in function"
msgstr "built-in function"

#. type: table
#: functions.texi.orig:80
msgid ""
"A function which is callable from Lisp but is actually written in C@.  "
"Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.  "
"Examples include functions like @code{car} and @code{append}.  In addition, "
"all special forms (see below) are also considered primitives."
msgstr "Lispから呼び出すことができますが、実際にはCで記述されています。プリミティブは、@dfn{ビルトイン関数(built-in functions)}や、@dfn{サブルーチン(subr)}といった呼ばれかたもします。それらの例には関数likeな@code{car}や@code{append}が含まれます。加えて、すべてのスペシャルフォーム(以下参照)もプリミティブと考えられます。"

#. type: table
#: functions.texi.orig:87
msgid ""
"Usually, a function is implemented as a primitive because it is a "
"fundamental part of Lisp (e.g., @code{car}), or because it provides a "
"low-level interface to operating system services, or because it needs to run "
"fast.  Unlike functions defined in Lisp, primitives can be modified or added "
"only by changing the C sources and recompiling Emacs.  See @ref{Writing "
"Emacs Primitives}."
msgstr "関数はLispの基礎となる部分(たとえば@code{car})であり、オペレーティングシステムのサービスにたいして値レベルのインターフェースを与え、高速に実行される必要があるため、通常はプリミティブとして実装されています。Lispで定義された関数とは異なり、プリミティブの修正や追加には、Cソースの変更とEmacsのリコンパイルが必要です。@ref{Writing Emacs Primitives}を参照してください。"

#. type: item
#: functions.texi.orig:88
#, no-wrap
msgid "special form"
msgstr "special form"

#. type: table
#: functions.texi.orig:94
msgid ""
"A primitive that is like a function but does not evaluate all of its "
"arguments in the usual way.  It may evaluate only some of the arguments, or "
"may evaluate them in an unusual order, or several times.  Examples include "
"@code{if}, @code{and}, and @code{while}.  @xref{Special Forms}."
msgstr "プリミティブは関数と似ていますが、すべての引数が通常の方法で評価はされません。いくつかの引数だけが評価されるかもしれず、通常ではない順序で、複数回評価されるかもしれません。プリミティブの例には、@code{if}、@code{and}、@code{while}が含まれます。@ref{Special Forms}を参照してください。"

#. type: cindex
#: functions.texi.orig:95 functions.texi.orig:96
#, no-wrap
msgid "macro"
msgstr "macro"

#. type: table
#: functions.texi.orig:102
msgid ""
"A construct defined in Lisp, which differs from a function in that it "
"translates a Lisp expression into another expression which is to be "
"evaluated instead of the original expression.  Macros enable Lisp "
"programmers to do the sorts of things that special forms can do.  "
"@xref{Macros}."
msgstr "あるLisp式を、オリジナルの式のかわりに評価される別の式に変換する、関数とは別のLispで定義された構造です。マクロは、スペシャルフォームが行う一連のことを、Lispプログラマーが行うのを可能にします。@ref{Macros}を参照してください。"

#. type: cindex
#: functions.texi.orig:103 functions.texi.orig:104
#, no-wrap
msgid "command"
msgstr "command"

#. type: table
#: functions.texi.orig:112
msgid ""
"An object which can be invoked via the @code{command-execute} primitive, "
"usually due to the user typing in a key sequence @dfn{bound} to that "
"command.  @xref{Interactive Call}.  A command is usually a function; if the "
"function is written in Lisp, it is made into a command by an "
"@code{interactive} form in the function definition (@pxref{Defining "
"Commands}).  Commands that are functions can also be called from Lisp "
"expressions, just like other functions."
msgstr "@code{command-execute}プリミティブを通じて呼び出すことができるオブジェクトで、通常はそのコマンドに@dfn{バインド}されたキーシーケンスを、ユーザーがタイプすることにより呼び出されます。@ref{Interactive Call}を参照してください。コマンドは通常、関数です。その関数がLispで記述されている場合は、関数の定義内の@code{interactive}フォームによりコマンドとなります(@ref{Defining Commands}を参照してください)。関数であるコマンドは、他の関数と同様、Lisp式から呼び出すこともできます。"

#. type: table
#: functions.texi.orig:118
msgid ""
"Keyboard macros (strings and vectors) are commands also, even though they "
"are not functions.  @xref{Keyboard Macros}.  We say that a symbol is a "
"command if its function cell contains a command (@pxref{Symbol Components}); "
"such a @dfn{named command} can be invoked with @kbd{M-x}."
msgstr "キーボードマクロ(文字列およびベクター)は関数ではありませんが、これらもコマンドです。@ref{Keyboard Macros}を参照してください。シンボルの関数セルにコマンドが含まれている場合、わたしたちはそのシンボルをコマンドと言います(@ref{Symbol Components}を参照してください)。そのような@dfn{名前つきコマンド(named command)}は、@kbd{M-x}で呼び出すことができます。"

#. type: cindex
#: functions.texi.orig:119 functions.texi.orig:1113
#, no-wrap
msgid "closure"
msgstr "closure"

#. type: table
#: functions.texi.orig:123
msgid ""
"A function object that is much like a lambda expression, except that it also "
"encloses an ``environment'' of lexical variable bindings.  @xref{Closures}."
msgstr "ラムダ式とよく似た関数オブジェクトですが、クロージャーはレキシカル変数バインディングの``環境''にも囲まれています。@ref{Closures}を参照してください。"

#. type: item
#: functions.texi.orig:124
#, no-wrap
msgid "byte-code function"
msgstr "byte-code function"

#. type: table
#: functions.texi.orig:127
msgid ""
"A function that has been compiled by the byte compiler.  @xref{Byte-Code "
"Type}."
msgstr "バイトコンパイラーによりコンパイルされた関数です。@ref{Byte-Code Type}を参照してください。"

#. type: cindex
#: functions.texi.orig:128 functions.texi.orig:129
#, no-wrap
msgid "autoload object"
msgstr "autoload object"

#. type: table
#: functions.texi.orig:133
msgid ""
"A place-holder for a real function.  If the autoload object is called, Emacs "
"loads the file containing the definition of the real function, and then "
"calls the real function.  @xref{Autoload}."
msgstr "実際の関数のプレースホルダーです。autoloadオブジェクトが呼び出された場合、Emacsは実際の関数の定義を含むファイルをロードした後、実際の関数を呼び出します。@ref{Autoload}を参照してください。"

#. type: Plain text
#: functions.texi.orig:137
msgid ""
"You can use the function @code{functionp} to test if an object is a "
"function:"
msgstr "関数@code{functionp}を使用して、あるオブジェクトが関数かどうかテストできます:"

#. type: defun
#: functions.texi.orig:138
#, no-wrap
msgid "functionp object"
msgstr "functionp object"

#. type: defun
#: functions.texi.orig:143
msgid ""
"This function returns @code{t} if @var{object} is any kind of function, "
"i.e., can be passed to @code{funcall}.  Note that @code{functionp} returns "
"@code{t} for symbols that are function names, and returns @code{nil} for "
"special forms."
msgstr "この関数は@var{object}が任意の種類の関数(たとえば@code{funcall}に渡すことができる)の場合は、@code{t}をreturnします。@code{functionp}は関数を名づけるシンボルにたいしては@code{t}、スペシャルフォームにたいしては@code{nil}をreturnすることに注意してください。"

#. type: Plain text
#: functions.texi.orig:148
msgid ""
"Unlike @code{functionp}, the next three functions do @emph{not} treat a "
"symbol as its function definition."
msgstr "@code{functionp}とは異なり、以下の3つの関数は、シンボルをそれの関数定義としては扱い@emph{ません}。"

#. type: defun
#: functions.texi.orig:149
#, no-wrap
msgid "subrp object"
msgstr "subrp object"

#. type: defun
#: functions.texi.orig:152
msgid ""
"This function returns @code{t} if @var{object} is a built-in function (i.e., "
"a Lisp primitive)."
msgstr "この関数は、@var{object}がビルトイン関数(たとえばLispプリミティブ)の場合は、@code{t}をreturnします。"

#. type: group
#: functions.texi.orig:157
#, no-wrap
msgid ""
"(subrp 'message)            ; @r{@code{message} is a symbol,}\n"
"     @result{} nil                 ;   @r{not a subr object.}\n"
msgstr ""
"(subrp 'message)            ; @r{@code{message}はシンボルであり、}\n"
"     @result{} nil                 ;   @r{subrオブジェクトではない。}\n"

#. type: group
#: functions.texi.orig:161
#, no-wrap
msgid ""
"(subrp (symbol-function 'message))\n"
"     @result{} t\n"
msgstr ""
"(subrp (symbol-function 'message))\n"
"     @result{} t\n"

#. type: defun
#: functions.texi.orig:165
#, no-wrap
msgid "byte-code-function-p object"
msgstr "byte-code-function-p object"

#. type: defun
#: functions.texi.orig:168
msgid ""
"This function returns @code{t} if @var{object} is a byte-code function.  For "
"example:"
msgstr "この関数は、@var{object}がバイトコード関数の場合は、@code{t}をreturnします。たとえば:"

#. type: group
#: functions.texi.orig:173
#, no-wrap
msgid ""
"(byte-code-function-p (symbol-function 'next-line))\n"
"     @result{} t\n"
msgstr ""
"(byte-code-function-p (symbol-function 'next-line))\n"
"     @result{} t\n"

#. type: defun
#: functions.texi.orig:177
#, no-wrap
msgid "subr-arity subr"
msgstr "subr-arity subr"

#. type: defun
#: functions.texi.orig:184
msgid ""
"This function provides information about the argument list of a primitive, "
"@var{subr}.  The returned value is a pair @code{(@var{min} . @var{max})}.  "
"@var{min} is the minimum number of args.  @var{max} is the maximum number or "
"the symbol @code{many}, for a function with @code{&rest} arguments, or the "
"symbol @code{unevalled} if @var{subr} is a special form."
msgstr "この関数はプリミティブ@var{subr}の引数リストについての情報を提供します。retrun値は、@code{(@var{min} . @var{max})}というペアーです。@var{min}は引数の最小数です。@var{max}は最大数、または引数@code{&rest}を伴う関数にたいしてはシンボル@code{many}、@var{subr}がスペシャルフォームの場合はシンボル@code{unevalled}です。"

#. type: Plain text
#: functions.texi.orig:192
msgid ""
"A lambda expression is a function object written in Lisp.  Here is an "
"example:"
msgstr "ラムダ式(lambda expression)は、Lispで記述された関数オブジェクトです。以下は例です:"

#. type: example
#: functions.texi.orig:197
#, no-wrap
msgid ""
"(lambda (x)\n"
"  \"Return the hyperbolic cosine of X.\"\n"
"  (* 0.5 (+ (exp x) (exp (- x)))))\n"
msgstr ""
"(lambda (x)\n"
"  \"Xの双曲線コサインをreturnする。\"\n"
"  (* 0.5 (+ (exp x) (exp (- x)))))\n"

#. type: Plain text
#: functions.texi.orig:202
msgid ""
"In Emacs Lisp, such a list is a valid expression which evaluates to a "
"function object."
msgstr "Emacs Lispでは、このようなリストは、関数オブジェクトに評価される、有効な式です。"

#. type: Plain text
#: functions.texi.orig:209
msgid ""
"A lambda expression, by itself, has no name; it is an @dfn{anonymous "
"function}.  Although lambda expressions can be used this way "
"(@pxref{Anonymous Functions}), they are more commonly associated with "
"symbols to make @dfn{named functions} (@pxref{Function Names}).  Before "
"going into these details, the following subsections describe the components "
"of a lambda expression and what they do."
msgstr "ラムダ式自身は名前をもたない、@dfn{無名関数(anonymous function)}です。ラムダ式をこの方法で使用できますが(@ref{Anonymous Functions}を参照してください)、@dfn{名前付き関数(named functions)}を作成するためにシンボルに関連付けられる方が一般的です(@pxref{Function Names})。これらの詳細に触れる前に、以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。"

#. type: node
#: functions.texi.orig:215 functions.texi.orig:217
#, no-wrap
msgid "Lambda Components"
msgstr "Lambda Components"

#. type: menuentry
#: functions.texi.orig:215
msgid "The parts of a lambda expression."
msgstr "ラムダ式のパーツ。"

#. type: node
#: functions.texi.orig:215 functions.texi.orig:260
#, no-wrap
msgid "Simple Lambda"
msgstr "Simple Lambda"

#. type: menuentry
#: functions.texi.orig:215
msgid "A simple example."
msgstr "シンプルな例。"

#. type: node
#: functions.texi.orig:215 functions.texi.orig:310
#, no-wrap
msgid "Argument List"
msgstr "Argument List"

#. type: menuentry
#: functions.texi.orig:215
msgid "Details and special features of argument lists."
msgstr "引数リストの詳細と特別な機能。"

#. type: node
#: functions.texi.orig:215 functions.texi.orig:415
#, no-wrap
msgid "Function Documentation"
msgstr "Function Documentation"

#. type: menuentry
#: functions.texi.orig:215
msgid "How to put documentation in a function."
msgstr "関数内にドキュメントを記述する方法。"

#. type: subsection
#: functions.texi.orig:218
#, no-wrap
msgid "Components of a Lambda Expression"
msgstr "Components of a Lambda Expression"

#. type: Plain text
#: functions.texi.orig:221
msgid "A lambda expression is a list that looks like this:"
msgstr "ラムダ式は、以下のようなリストです:"

#. type: example
#: functions.texi.orig:227
#, no-wrap
msgid ""
"(lambda (@var{arg-variables}@dots{})\n"
"  [@var{documentation-string}]\n"
"  [@var{interactive-declaration}]\n"
"  @var{body-forms}@dots{})\n"
msgstr ""
"(lambda (@var{arg-variables}@dots{})\n"
"  [@var{documentation-string}]\n"
"  [@var{interactive-declaration}]\n"
"  @var{body-forms}@dots{})\n"

#. type: cindex
#: functions.texi.orig:229
#, no-wrap
msgid "lambda list"
msgstr "lambda list"

#. type: Plain text
#: functions.texi.orig:235
msgid ""
"The first element of a lambda expression is always the symbol "
"@code{lambda}.  This indicates that the list represents a function.  The "
"reason functions are defined to start with @code{lambda} is so that other "
"lists, intended for other uses, will not accidentally be valid as functions."
msgstr "ラムダ式の1番目の要素は常にシンボル@code{lambda}です。これは、そのリストが関数を表すことを示します。@code{lambda}で関数定義を開始する理由は、他の目的のたまえの使用が意図された他のリストが、意図せず関数として評価されないようにするためです。"

#. type: Plain text
#: functions.texi.orig:241
msgid ""
"The second element is a list of symbols---the argument variable names.  This "
"is called the @dfn{lambda list}.  When a Lisp function is called, the "
"argument values are matched up against the variables in the lambda list, "
"which are given local bindings with the values provided.  @xref{Local "
"Variables}."
msgstr "2番目の要素は、シンボル --- 引数変数名のリストです。これは@dfn{ラムダリスト(lambda list)}と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストは、与えられた値にたいするローカルバインディングが付与されます。@ref{Local Variables}を参照してください。"

#. type: Plain text
#: functions.texi.orig:245
msgid ""
"The documentation string is a Lisp string object placed within the function "
"definition to describe the function for the Emacs help facilities.  "
"@xref{Function Documentation}."
msgstr "ドキュメント文字列(documentation string)はEmacs Lispのヘルプ機能にたいしてその、関数を説明する、関数定義に配されたLisp文字列オブジェクトです。@ref{Function Documentation}を参照してください。"

#. type: Plain text
#: functions.texi.orig:253
msgid ""
"The interactive declaration is a list of the form @code{(interactive "
"@var{code-string})}.  This declares how to provide arguments if the function "
"is used interactively.  Functions with this declaration are called "
"@dfn{commands}; they can be called using @kbd{M-x} or bound to a key.  "
"Functions not intended to be called in this way should not have interactive "
"declarations.  @xref{Defining Commands}, for how to write an interactive "
"declaration."
msgstr "インタラクティブ宣言(interactive declaration)は、@code{(interactive @var{code-string})}という形式のリストです。これは、この関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、@dfn{コマンド(command)}と呼ばれます。コマンドは@kbd{M-x}を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、@xref{Defining Commands}を参照してください。"

#. type: cindex
#: functions.texi.orig:254
#, no-wrap
msgid "body of function"
msgstr "body of function"

#. type: Plain text
#: functions.texi.orig:259
msgid ""
"The rest of the elements are the @dfn{body} of the function: the Lisp code "
"to do the work of the function (or, as a Lisp programmer would say, ``a list "
"of Lisp forms to evaluate'').  The value returned by the function is the "
"value returned by the last element of the body."
msgstr "残りの要素は、その関数の@dfn{body(本体)} --- その関数が処理を行うためのLispコード(Lispプログラマーは``評価されるLispフォームのリスト''と言うでしょう)です。この関数からreturnされる値は、bodyの最後の要素によりreturnされる値です。"

#. type: subsection
#: functions.texi.orig:261
#, no-wrap
msgid "A Simple Lambda Expression Example"
msgstr "A Simple Lambda Expression Example"

#. type: Plain text
#: functions.texi.orig:264
msgid "Consider the following example:"
msgstr "以下の例を考えてみてください:"

#. type: example
#: functions.texi.orig:267
#, no-wrap
msgid "(lambda (a b c) (+ a b c))\n"
msgstr "(lambda (a b c) (+ a b c))\n"

#. type: Plain text
#: functions.texi.orig:271
msgid "We can call this function by passing it to @code{funcall}, like this:"
msgstr "以下のように、@code{funcall}に渡すことにより、この関数を呼び出すことができます:"

#. type: group
#: functions.texi.orig:276
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 2 3)\n"
msgstr ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 2 3)\n"

#. type: Plain text
#: functions.texi.orig:284
msgid ""
"This call evaluates the body of the lambda expression with the variable "
"@code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.  "
"Evaluation of the body adds these three numbers, producing the result 6; "
"therefore, this call to the function returns the value 6."
msgstr "この呼び出しは、変数@code{a}に1、@code{b}に2、@code{c}に3をバインドして、ラムダ式のbodyを評価します。bodyの評価により、これら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより、6がreturnされます。"

#. type: Plain text
#: functions.texi.orig:287
msgid ""
"Note that the arguments can be the results of other function calls, as in "
"this example:"
msgstr "以下のように、引数は他の関数の結果であってもよいことに注意してください:"

#. type: group
#: functions.texi.orig:292
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 (* 2 3) (- 5 4))\n"
msgstr ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 (* 2 3) (- 5 4))\n"

#. type: Plain text
#: functions.texi.orig:299
msgid ""
"This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5 4)} "
"from left to right.  Then it applies the lambda expression to the argument "
"values 1, 6 and 1 to produce the value 8."
msgstr "これは引数@code{1}、@code{(* 2 3)}、@code{(- 5 4)}を左から右に評価します。その後、ラムダ式に引数1、6、1を適用して、値8が生成されます。"

#. type: Plain text
#: functions.texi.orig:309
msgid ""
"As these examples show, you can use a form with a lambda expression as its "
"@sc{car} to make local variables and give them values.  In the old days of "
"Lisp, this technique was the only way to bind and initialize local "
"variables.  But nowadays, it is clearer to use the special form @code{let} "
"for this purpose (@pxref{Local Variables}).  Lambda expressions are mainly "
"used as anonymous functions for passing as arguments to other functions "
"(@pxref{Anonymous Functions}), or stored as symbol function definitions to "
"produce named functions (@pxref{Function Names})."
msgstr "これらの例が示すように、ローカル変数を作成して、それらに値を与えるフォームとして、@sc{car}がラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在では、この目的にはフォーム@code{let}を使用するほうが明解です(@ref{Local Variables}を参照してください)。ラムダ式は主に、他の関数の引数として渡される無名関数(@ref{Anonymous Functions}を参照してください)として、あるいは名前つき関数(@ref{Function Names}を参照してください)を生成するためにシンボルの関数定義に格納するために使用されます。"

#. type: subsection
#: functions.texi.orig:311
#, no-wrap
msgid "Other Features of Argument Lists"
msgstr "Other Features of Argument Lists"

#. type: kindex
#: functions.texi.orig:312
#, no-wrap
msgid "wrong-number-of-arguments"
msgstr "wrong-number-of-arguments"

#. type: cindex
#: functions.texi.orig:313
#, no-wrap
msgid "argument binding"
msgstr "argument binding"

#. type: cindex
#: functions.texi.orig:314
#, no-wrap
msgid "binding arguments"
msgstr "binding arguments"

#. type: cindex
#: functions.texi.orig:315
#, no-wrap
msgid "argument lists, features"
msgstr "argument lists, features"

#. type: Plain text
#: functions.texi.orig:321
msgid ""
"Our simple sample function, @code{(lambda (a b c) (+ a b c))}, specifies "
"three argument variables, so it must be called with three arguments: if you "
"try to call it with only two arguments or four arguments, you get a "
"@code{wrong-number-of-arguments} error."
msgstr "シンプルなサンプル関数@code{(lambda (a b c) (+ a b c))}は、3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合は、@code{wrong-number-of-arguments}エラーとなります。"

#. type: Plain text
#: functions.texi.orig:329
msgid ""
"It is often convenient to write a function that allows certain arguments to "
"be omitted.  For example, the function @code{substring} accepts three "
"arguments---a string, the start index and the end index---but the third "
"argument defaults to the @var{length} of the string if you omit it.  It is "
"also convenient for certain functions to accept an indefinite number of "
"arguments, as the functions @code{list} and @code{+} do."
msgstr "特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数@code{substring}は3つの引数 --- 文字列、開始インデックス、終了インデックス --- を受け取りますが、3つ目の引数を省略した場合、デフォルトでその文字列の@var{length}となります。関数@code{list}や@code{+}が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。"

#. type: cindex
#: functions.texi.orig:330
#, no-wrap
msgid "optional arguments"
msgstr "optional arguments"

#. type: cindex
#: functions.texi.orig:331
#, no-wrap
msgid "rest arguments"
msgstr "rest arguments"

#. type: kindex
#: functions.texi.orig:332
#, no-wrap
msgid "&optional"
msgstr "&optional"

#. type: kindex
#: functions.texi.orig:333
#, no-wrap
msgid "&rest"
msgstr "&rest"

#. type: Plain text
#: functions.texi.orig:338
msgid ""
"To specify optional arguments that may be omitted when a function is called, "
"simply include the keyword @code{&optional} before the optional arguments.  "
"To specify a list of zero or more extra arguments, include the keyword "
"@code{&rest} before one final argument."
msgstr "関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード@code{&optional}を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード@code{&rest}を含めます。"

#. type: Plain text
#: functions.texi.orig:340
msgid "Thus, the complete syntax for an argument list is as follows:"
msgstr "したがって、引数リストの完全な構文は以下のようになります:"

#. type: group
#: functions.texi.orig:346
#, no-wrap
msgid ""
"(@var{required-vars}@dots{}\n"
" @r{[}&optional @var{optional-vars}@dots{}@r{]}\n"
" @r{[}&rest @var{rest-var}@r{]})\n"
msgstr ""
"(@var{required-vars}@dots{}\n"
" @r{[}&optional @var{optional-vars}@dots{}@r{]}\n"
" @r{[}&rest @var{rest-var}@r{]})\n"

#. type: Plain text
#: functions.texi.orig:352
msgid ""
"The square brackets indicate that the @code{&optional} and @code{&rest} "
"clauses, and the variables that follow them, are optional."
msgstr "角カッコ(square bracket)は、@code{&optional}と@code{&rest}、およびそれらに続く変数が省略できることを示します。"

#. type: Plain text
#: functions.texi.orig:358
msgid ""
"A call to the function requires one actual argument for each of the "
"@var{required-vars}.  There may be actual arguments for zero or more of the "
"@var{optional-vars}, and there cannot be any actual arguments beyond that "
"unless the lambda list uses @code{&rest}.  In that case, there may be any "
"number of extra actual arguments."
msgstr "この関数の呼び出しには、@var{required-vars}のそれぞれにたいして、実際の引数が要求されます。0個以上の@var{optional-vars}にたいして実際の引数があるかもしれませんが、ラムダ式が@code{&rest}を使用していなければ、その個数を超えて実際の引数を記述することはできません。@code{&rest}が記述されている場合、追加で任意個の実際の引数があるかもしれません。"

#. type: Plain text
#: functions.texi.orig:366
msgid ""
"If actual arguments for the optional and rest variables are omitted, then "
"they always default to @code{nil}.  There is no way for the function to "
"distinguish between an explicit argument of @code{nil} and an omitted "
"argument.  However, the body of the function is free to consider @code{nil} "
"an abbreviation for some other meaningful value.  This is what "
"@code{substring} does; @code{nil} as the third argument to @code{substring} "
"means to use the length of the string supplied."
msgstr "optionaやrest変数にたいして実際の引数が省略された場合、それらのデフォルトは常に@code{nil}になります。関数にたいして引数に明示的に@code{nil}が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、@code{nil}を他の有意な値が省略されたと判断することは自由です。これは@code{substring}が行っていることです。@code{substring}の3つ目の引数が@code{nil}の場合、それは文字列の長さを使用することを意味します。"

#. type: cindex
#: functions.texi.orig:367
#, no-wrap
msgid "CL note---default optional arg"
msgstr "CL note---default optional arg"

#. type: quotation
#: functions.texi.orig:373
msgid ""
"@b{Common Lisp note:} Common Lisp allows the function to specify what "
"default value to use when an optional argument is omitted; Emacs Lisp always "
"uses @code{nil}.  Emacs Lisp does not support ``supplied-p'' variables that "
"tell you whether an argument was explicitly passed."
msgstr "@b{Common Lispに関する注意:} Common Lispでは、オプションの引数が省略されたときに使用するデフォルト値を指定できます。Emacs Lispは、引数が明示的に渡されたかを調べる、``supplied-p''変数はサポートしません。"

#. type: Plain text
#: functions.texi.orig:376
msgid "For example, an argument list that looks like this:"
msgstr "例えば、引数リストは以下のようになります:"

#. type: example
#: functions.texi.orig:379
#, no-wrap
msgid "(a b &optional c d &rest e)\n"
msgstr "(a b &optional c d &rest e)\n"

#. type: Plain text
#: functions.texi.orig:389
msgid ""
"binds @code{a} and @code{b} to the first two actual arguments, which are "
"required.  If one or two more arguments are provided, @code{c} and @code{d} "
"are bound to them respectively; any arguments after the first four are "
"collected into a list and @code{e} is bound to that list.  If there are only "
"two arguments, @code{c} is @code{nil}; if two or three arguments, @code{d} "
"is @code{nil}; if four arguments or fewer, @code{e} is @code{nil}."
msgstr "これは@code{a}と@code{b}は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合、それらは順番に@code{c}と@code{d}にバインドされます。1つ目から4つ目の引数の後の引数は、リストにまとめられて、@code{e}にそのリストがバインドされます。2つしか引数が指定されなかった場合、@code{c}は@code{nil}になります。2つまたは3つの引数の場合、@code{d}は@code{nil}です。引数が4つ以下の場合、@code{e}は@code{nil}になります。"

#. type: Plain text
#: functions.texi.orig:398
msgid ""
"There is no way to have required arguments following optional ones---it "
"would not make sense.  To see why this must be so, suppose that @code{c} in "
"the example were optional and @code{d} were required.  Suppose three actual "
"arguments are given; which variable would the third argument be for? Would "
"it be used for the @var{c}, or for @var{d}? One can argue for both "
"possibilities.  Similarly, it makes no sense to have any more arguments "
"(either required or optional)  after a @code{&rest} argument."
msgstr "オプションの引数の後ろに必須の引数を指定する方法はありません --- これは意味を成さないからです。なぜそうなるかは、この例で@code{c}がオプションで@code{d}が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか? この引数は@var{c}なのでしょうか、それとも@var{d}に使用されるのでしょうか? 両方の場合が考えられます。同様に、@code{&rest}引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。"

#. type: Plain text
#: functions.texi.orig:400
msgid "Here are some examples of argument lists and proper calls:"
msgstr "以下に引数リストと、それを正しく呼び出す例をいくつか示します:"

#. type: example
#: functions.texi.orig:413
#, no-wrap
msgid ""
"(funcall (lambda (n) (1+ n))        ; @r{One required:}\n"
"         1)                         ; @r{requires exactly one argument.}\n"
"     @result{} 2\n"
"(funcall (lambda (n &optional n1)   ; @r{One required and one optional:}\n"
"           (if n1 (+ n n1) (1+ n))) ; @r{1 or 2 arguments.}\n"
"         1 2)\n"
"     @result{} 3\n"
"(funcall (lambda (n &rest ns)       ; @r{One required and one rest:}\n"
"           (+ n (apply '+ ns)))     ; @r{1 or more arguments.}\n"
"         1 2 3 4 5)\n"
"     @result{} 15\n"
msgstr ""
"(funcall (lambda (n) (1+ n))        ; @r{1つの必須:}\n"
"         1)                         ; @r{これは正確に1つの引数を要求する。}\n"
"     @result{} 2\n"
"(funcall (lambda (n &optional n1)   ; @r{1つは必須で、1つはオプション:}\n"
"           (if n1 (+ n n1) (1+ n))) ; @r{1つまたは2つの引数。}\n"
"         1 2)\n"
"     @result{} 3\n"
"(funcall (lambda (n &rest ns)       ; @r{1つは必須で、後は残り:}\n"
"           (+ n (apply '+ ns)))     ; @r{1つ以上の引数。}\n"
"         1 2 3 4 5)\n"
"     @result{} 15\n"

#. type: subsection
#: functions.texi.orig:416
#, no-wrap
msgid "Documentation Strings of Functions"
msgstr "Documentation Strings of Functions"

#. type: cindex
#: functions.texi.orig:417
#, no-wrap
msgid "documentation of function"
msgstr "documentation of function"

#. type: Plain text
#: functions.texi.orig:425
msgid ""
"A lambda expression may optionally have a @dfn{documentation string} just "
"after the lambda list.  This string does not affect execution of the "
"function; it is a kind of comment, but a systematized comment which actually "
"appears inside the Lisp world and can be used by the Emacs help facilities.  "
"@xref{Documentation}, for how the documentation string is accessed."
msgstr "ラムダ式は、ラムダリストの食後に、オプションで@dfn{ドキュメント文字列(documentation string)}をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですが、Lisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、@ref{Documentation}を参照してください。"

#. type: Plain text
#: functions.texi.orig:430
msgid ""
"It is a good idea to provide documentation strings for all the functions in "
"your program, even those that are called only from within your program.  "
"Documentation strings are like comments, except that they are easier to "
"access."
msgstr "たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。"

#. type: Plain text
#: functions.texi.orig:434
msgid ""
"The first line of the documentation string should stand on its own, because "
"@code{apropos} displays just this first line.  It should consist of one or "
"two complete sentences that summarize the function's purpose."
msgstr "ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら@code{apropos}は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する、1つまたは2つの完全なセンテンスで構成されるべきです。"

#. type: Plain text
#: functions.texi.orig:443
msgid ""
"The start of the documentation string is usually indented in the source "
"file, but since these spaces come before the starting double-quote, they are "
"not part of the string.  Some people make a practice of indenting any "
"additional lines of the string so that the text lines up in the program "
"source.  @emph{That is a mistake.} The indentation of the following lines is "
"inside the string; what looks nice in the source code will look ugly when "
"displayed by the help commands."
msgstr "ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。@emph{これは、間違いです。}後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。"

#. type: Plain text
#: functions.texi.orig:451
msgid ""
"You may wonder how the documentation string could be optional, since there "
"are required components of the function that follow it (the body).  Since "
"evaluation of a string returns that string, without any side effects, it has "
"no effect if it is not the last form in the body.  Thus, in practice, there "
"is no confusion between the first form of the body and the documentation "
"string; if the only body form is a string then it serves both as the return "
"value and as the documentation."
msgstr "ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれません。なぜなら、ドキュメント文字列の後には必須となる関数の構成要素であるbodyが続くからです。文字列を評価するとその文字列自身がれつｒｎされるので、それがbody内の最後のフォームでない限りなんの効果もありません。したがって、実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません。bodyの唯一のフォームが文字列の場合、それはreturn値とドキュメントの両方の役目を果たします。"

#. type: Plain text
#: functions.texi.orig:455
msgid ""
"The last line of the documentation string can specify calling conventions "
"different from the actual function arguments.  Write text like this:"
msgstr "ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します"

#. type: example
#: functions.texi.orig:458
#, no-wrap
msgid "\\(fn @var{arglist})\n"
msgstr "\\(fn @var{arglist})\n"

#. type: Plain text
#: functions.texi.orig:466
msgid ""
"following a blank line, at the beginning of the line, with no newline "
"following it inside the documentation string.  (The @samp{\\} is used to "
"avoid confusing the Emacs motion commands.)  The calling convention "
"specified in this way appears in help messages in place of the one derived "
"from the actual arguments of the function."
msgstr "ただし、このテキストの前に空行があり、テキスト自身が行頭から記述されていて、ドキュメント文字列内でこのテキストの後に改行が続かない場合です(@samp{\\}はEmacsの移動コマンドが混乱するのを避けるために使用されます)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。"

#. type: Plain text
#: functions.texi.orig:470
msgid ""
"This feature is particularly useful for macro definitions, since the "
"arguments written in a macro definition often do not correspond to the way "
"users think of the parts of the macro call."
msgstr "マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法と合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。"

#. type: section
#: functions.texi.orig:472
#, no-wrap
msgid "Naming a Function"
msgstr "Naming a Function"

#. type: cindex
#: functions.texi.orig:473
#, no-wrap
msgid "function definition"
msgstr "function definition"

#. type: cindex
#: functions.texi.orig:474
#, no-wrap
msgid "named function"
msgstr "named function"

#. type: cindex
#: functions.texi.orig:475
#, no-wrap
msgid "function name"
msgstr "function name"

#. type: Plain text
#: functions.texi.orig:482
msgid ""
"A symbol can serve as the name of a function.  This happens when the "
"symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a function "
"object (e.g., a lambda expression).  Then the symbol itself becomes a valid, "
"callable function, equivalent to the function object in its function cell."
msgstr "シンボルは関数の名前となることができます。これは、そのシンボルの@dfn{関数セル(function cell}: @ref{Symbol Components}を参照してください)が、関数オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価になります。"

#. type: Plain text
#: functions.texi.orig:489
msgid ""
"The contents of the function cell are also called the symbol's @dfn{function "
"definition}.  The procedure of using a symbol's function definition in place "
"of the symbol is called @dfn{symbol function indirection}; see @ref{Function "
"Indirection}.  If you have not given a symbol a function definition, its "
"function cell is said to be @dfn{void}, and it cannot be used as a function."
msgstr "関数セルの内容は、そのシンボルの@dfn{関数定義(function definition)}と呼ぶこともできます。そのシンボルのかわりに、シンボルの関数定義を使う手続きのことを@dfn{シンボル関数インダイレクション(symbol function indirection)}と呼びます。@ref{Function Indirection}を参照してください。与えられたシンボルに関数定義がない場合、シンボルの関数セルは@dfn{void}と呼ばれ、それを関数として使用することはできません。"

#. type: Plain text
#: functions.texi.orig:495
msgid ""
"In practice, nearly all functions have names, and are referred to by their "
"names.  You can create a named Lisp function by defining a lambda expression "
"and putting it in a function cell (@pxref{Function Cells}).  However, it is "
"more common to use the @code{defun} special form, described in the next "
"section."
msgstr "実際のところ、ほとんどすべての関数は名前をもち、その名前により参照されます。ラムダ式を定義することにより名前つきのLisp関数を作成、それを関数セル(@ref{Function Cells}を参照してください)に置くことができます。しかし、さらに一般的なのは@code{defun}スペシャルフォーム(次のセクションで説明します)を使う方法です。"

#. type: ifnottex
#: functions.texi.orig:497
msgid "@xref{Defining Functions}."
msgstr "@ref{Defining Functions}を参照してください。"

#. type: Plain text
#: functions.texi.orig:505
msgid ""
"We give functions names because it is convenient to refer to them by their "
"names in Lisp expressions.  Also, a named Lisp function can easily refer to "
"itself---it can be recursive.  Furthermore, primitives can only be referred "
"to textually by their names, since primitive function objects "
"(@pxref{Primitive Function Type}) have no read syntax."
msgstr "わたしたちは関数名を与えるのは、Lisp式内で関数を名前で参照するのが便利だからです。また、名前つきの関数は簡単に自分自身を ---再帰的(recursive)に参照することができます。さらに、プリミティブはテキスト的な名前だけで参照することができます。なぜならプリミティブ関数は入力構文(read syntax)をもたないオブジェクトだからです(@ref{Primitive Function Type}を参照してください)。"

#. type: Plain text
#: functions.texi.orig:511
msgid ""
"A function need not have a unique name.  A given function object "
"@emph{usually} appears in the function cell of only one symbol, but this is "
"just a convention.  It is easy to store it in several symbols using "
"@code{fset}; then each of the symbols is a valid name for the same function."
msgstr "関数は一意な名前をもつ必要はありません。与えられた関数オブジェクトは、@emph{通常}は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的なものです。@code{fset}を使用して、関数を複数のシンボルに格納するのは簡単です。それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。"

#. type: Plain text
#: functions.texi.orig:516
msgid ""
"Note that a symbol used as a function name may also be used as a variable; "
"these two uses of a symbol are independent and do not conflict.  (This is "
"not the case in some dialects of Lisp, like Scheme.)"
msgstr "関数として使用されているシンボルを、変数としても利用できることに注意してください。シンボルのこれら2つの利用法は独立しており、競合はしません(これはSchemaのような他のいくつかのLisp方言には当てはまりません)。"

#. type: cindex
#: functions.texi.orig:519
#, no-wrap
msgid "defining a function"
msgstr "defining a function"

#. type: Plain text
#: functions.texi.orig:524
msgid ""
"We usually give a name to a function when it is first created.  This is "
"called @dfn{defining a function}, and it is done with the @code{defun} "
"macro."
msgstr "わたしたちは通常、関数を最初に作成したときに名前を与えます。これは@dfn{関数の定義(defining a function)}と呼ばれ、@code{defun}マクロにより行われます。"

#. type: defmac
#: functions.texi.orig:525
#, no-wrap
msgid "defun name args [doc] [declare] [interactive] body@dots{}"
msgstr "defun name args [doc] [declare] [interactive] body@dots{}"

#. type: defmac
#: functions.texi.orig:530
msgid ""
"@code{defun} is the usual way to define new Lisp functions.  It defines the "
"symbol @var{name} as a function with argument list @var{args} and body forms "
"given by @var{body}.  Neither @var{name} nor @var{args} should be quoted."
msgstr "@code{defun}は新たなLisp関数を定義する通常の方法です。これは、引数リスト@var{args}、および@var{body}により与えられるbodyフォームとともに、シンボル@var{name}を関数として定義します。@var{name}と@var{args}を、クォートする必要はありません。"

#. type: defmac
#: functions.texi.orig:537
msgid ""
"@var{doc}, if present, should be a string specifying the function's "
"documentation string (@pxref{Function Documentation}).  @var{declare}, if "
"present, should be a @code{declare} form specifying function metadata "
"(@pxref{Declare Form}).  @var{interactive}, if present, should be an "
"@code{interactive} form specifying how the function is to be called "
"interactively (@pxref{Interactive Call})."
msgstr "@var{doc}が与えられた場合、それはその関数のドキュメント文字列を指定する文字列であるべきです(@ref{Function Documentation}を参照してください)。@var{declare}が与えられた場合、それは関数のメタデータを指定する、@code{declare}フォームであるべきです(@ref{Declare Form}を参照してください)。@var{interactive}が与えられた場合、それは関数が対話的に呼び出される方法を指定する@code{interactive}フォームであるべきです(@ref{Interactive Call}を参照してください)。"

#. type: defmac
#: functions.texi.orig:539
msgid "The return value of @code{defun} is undefined."
msgstr "@code{defun}のreturn値は定義されていません。"

#. type: defmac
#: functions.texi.orig:541
msgid "Here are some examples:"
msgstr "以下にいくつか例を示します:"

#. type: group
#: functions.texi.orig:547
#, no-wrap
msgid ""
"(defun foo () 5)\n"
"(foo)\n"
"     @result{} 5\n"
msgstr ""
"(defun foo () 5)\n"
"(foo)\n"
"     @result{} 5\n"

#. type: group
#: functions.texi.orig:554
#, no-wrap
msgid ""
"(defun bar (a &optional b &rest c)\n"
"    (list a b c))\n"
"(bar 1 2 3 4 5)\n"
"     @result{} (1 2 (3 4 5))\n"
msgstr ""
"(defun bar (a &optional b &rest c)\n"
"    (list a b c))\n"
"(bar 1 2 3 4 5)\n"
"     @result{} (1 2 (3 4 5))\n"

#. type: group
#: functions.texi.orig:558
#, no-wrap
msgid ""
"(bar 1)\n"
"     @result{} (1 nil nil)\n"
msgstr ""
"(bar 1)\n"
"     @result{} (1 nil nil)\n"

#. type: group
#: functions.texi.orig:562
#, no-wrap
msgid ""
"(bar)\n"
"@error{} Wrong number of arguments.\n"
msgstr ""
"(bar)\n"
"@error{} Wrong number of arguments.\n"

#. type: group
#: functions.texi.orig:572
#, no-wrap
msgid ""
"(defun capitalize-backwards ()\n"
"  \"Upcase the last letter of the word at point.\"\n"
"  (interactive)\n"
"  (backward-word 1)\n"
"  (forward-word 1)\n"
"  (backward-char 1)\n"
"  (capitalize-word 1))\n"
msgstr ""
"(defun capitalize-backwards ()\n"
"  \"Upcase the last letter of the word at point.\"\n"
"  (interactive)\n"
"  (backward-word 1)\n"
"  (forward-word 1)\n"
"  (backward-char 1)\n"
"  (capitalize-word 1))\n"

#. type: defmac
#: functions.texi.orig:581
msgid ""
"Be careful not to redefine existing functions unintentionally.  @code{defun} "
"redefines even primitive functions such as @code{car} without any hesitation "
"or notification.  Emacs does not prevent you from doing this, because "
"redefining a function is sometimes done deliberately, and there is no way to "
"distinguish deliberate redefinition from unintentional redefinition."
msgstr "意図せず既存の関数を再定義しないように、注意してください。@code{defun}は@code{car}のようなプリミティブ関数でさえ、躊躇なく問い合わせもなしに再定義します。Emacsががががこれを妨げることはありません。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はないからです。"

#. type: cindex
#: functions.texi.orig:583
#, no-wrap
msgid "function aliases"
msgstr "function aliases"

#. type: cindex
#: functions.texi.orig:584
#, no-wrap
msgid "alias, for functions"
msgstr "alias, for functions"

#. type: defun
#: functions.texi.orig:585
#, no-wrap
msgid "defalias name definition &optional doc"
msgstr "defalias name definition &optional doc"

#. type: anchor{#1}
#: functions.texi.orig:590
msgid "Definition of defalias"
msgstr "Definition of defalias"

#. type: defun
#: functions.texi.orig:590
msgid ""
"This function defines the symbol @var{name} as a function, with definition "
"@var{definition} (which can be any valid Lisp function).  Its return value "
"is @emph{undefined}."
msgstr "この関数は、定義@var{definition}(任意の有効なLisp関数)とともに、シンボル@var{name}を関数として定義します。この関数のreturn値は@emph{未定義}です。"

#. type: defun
#: functions.texi.orig:594
msgid ""
"If @var{doc} is non-@code{nil}, it becomes the function documentation of "
"@var{name}.  Otherwise, any documentation provided by @var{definition} is "
"used."
msgstr "@var{doc}が非@code{nil}の場合、それは関数@var{name}のドキュメントになります。それ以外は、@var{definition}により提供されるドキュメントが使用されます。"

#. type: cindex
#: functions.texi.orig:595
#, no-wrap
msgid "defalias-fset-function property"
msgstr "defalias-fset-function property"

#. type: defun
#: functions.texi.orig:599
msgid ""
"Internally, @code{defalias} normally uses @code{fset} to set the "
"definition.  If @var{name} has a @code{defalias-fset-function} property, "
"however, the associated value is used as a function to call in place of "
"@code{fset}."
msgstr "内部的には、@code{defalias}は通常、定義のセットに@code{fset}を使用します。しかし@var{name}が@code{defalias-fset-function}プロパティーをもつ場合、@code{fset}を呼び出すかわりに、それに割り当てられた値が使用されます。"

#. type: defun
#: functions.texi.orig:605
msgid ""
"The proper place to use @code{defalias} is where a specific function name is "
"being defined---especially where that name appears explicitly in the source "
"file being loaded.  This is because @code{defalias} records which file "
"defined the function, just like @code{defun} (@pxref{Unloading})."
msgstr "@code{defalias}を使う正しい場所は、特定の関数名がまさに定義される場所 --- 特にソースファイルがロードされるとき明示的にその名前が出現する場所です。これは@code{defalias}が、@code{defun}と同じように、どれが関数を定義するファイルなのか記録するからです(@ref{Unloading}を参照してください)。"

#. type: defun
#: functions.texi.orig:609
msgid ""
"By contrast, in programs that manipulate function definitions for other "
"purposes, it is better to use @code{fset}, which does not keep such "
"records.  @xref{Function Cells}."
msgstr "それとは対象的に、他の目的のために関数を操作するプログラムでは、そのような記録を保持しない@code{fset}を使用するほうがよいでしょう。@ref{Function Cells}を参照してください。"

#. type: Plain text
#: functions.texi.orig:621
msgid ""
"You cannot create a new primitive function with @code{defun} or "
"@code{defalias}, but you can use them to change the function definition of "
"any symbol, even one such as @code{car} or @code{x-popup-menu} whose normal "
"definition is a primitive.  However, this is risky: for instance, it is next "
"to impossible to redefine @code{car} without breaking Lisp completely.  "
"Redefining an obscure function such as @code{x-popup-menu} is less "
"dangerous, but it still may not work as you expect.  If there are calls to "
"the primitive from C code, they call the primitive's C definition directly, "
"so changing the symbol's definition will have no effect on them."
msgstr "@code{defun}や@code{defalias}で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである@code{car}や@code{x-popup-menu}のような関数でさえ変更することができます。しかし、これは危険なことです。たとえば、Lispの完全性を損なうことなく、@code{car}を再定義するのはほとんど不可能だからです。それほど有名ではない@code{x-popup-menu}のような関数の再定義では、危険は減るものの、それでも期待したとおりに機能しないかもしれません。Cコードにこのプリミティブの呼び出しがある場合、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更しても、それらに影響はありません。"

#. type: Plain text
#: functions.texi.orig:625
msgid ""
"See also @code{defsubst}, which defines a function like @code{defun} and "
"tells the Lisp compiler to perform inline expansion on it.  @xref{Inline "
"Functions}."
msgstr "@code{defsubst}も参照してください。これは@code{defun}のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。@ref{Inline Functions}を参照してください。"

#. type: cindex
#: functions.texi.orig:628
#, no-wrap
msgid "function invocation"
msgstr "function invocation"

#. type: cindex
#: functions.texi.orig:629
#, no-wrap
msgid "calling a function"
msgstr "calling a function"

#. type: Plain text
#: functions.texi.orig:634
msgid ""
"Defining functions is only half the battle.  Functions don't do anything "
"until you @dfn{call} them, i.e., tell them to run.  Calling a function is "
"also known as @dfn{invocation}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:639
msgid ""
"The most common way of invoking a function is by evaluating a list.  For "
"example, evaluating the list @code{(concat \"a\" \"b\")} calls the function "
"@code{concat} with arguments @code{\"a\"} and @code{\"b\"}.  "
"@xref{Evaluation}, for a description of evaluation."
msgstr ""

#. type: Plain text
#: functions.texi.orig:646
msgid ""
"When you write a list as an expression in your program, you specify which "
"function to call, and how many arguments to give it, in the text of the "
"program.  Usually that's just what you want.  Occasionally you need to "
"compute at run time which function to call.  To do that, use the function "
"@code{funcall}.  When you also need to determine at run time how many "
"arguments to pass, use @code{apply}."
msgstr ""

#. type: defun
#: functions.texi.orig:647
#, no-wrap
msgid "funcall function &rest arguments"
msgstr ""

#. type: defun
#: functions.texi.orig:650
msgid ""
"@code{funcall} calls @var{function} with @var{arguments}, and returns "
"whatever @var{function} returns."
msgstr ""

#. type: defun
#: functions.texi.orig:660
msgid ""
"Since @code{funcall} is a function, all of its arguments, including "
"@var{function}, are evaluated before @code{funcall} is called.  This means "
"that you can use any expression to obtain the function to be called.  It "
"also means that @code{funcall} does not see the expressions you write for "
"the @var{arguments}, only their values.  These values are @emph{not} "
"evaluated a second time in the act of calling @var{function}; the operation "
"of @code{funcall} is like the normal procedure for calling a function, once "
"its arguments have already been evaluated."
msgstr ""

#. type: defun
#: functions.texi.orig:666
msgid ""
"The argument @var{function} must be either a Lisp function or a primitive "
"function.  Special forms and macros are not allowed, because they make sense "
"only when given the ``unevaluated'' argument expressions.  @code{funcall} "
"cannot provide these because, as we saw above, it never knows them in the "
"first place."
msgstr ""

#. type: group
#: functions.texi.orig:671 functions.texi.orig:706
#, no-wrap
msgid ""
"(setq f 'list)\n"
"     @result{} list\n"
msgstr ""

#. type: group
#: functions.texi.orig:675
#, no-wrap
msgid ""
"(funcall f 'x 'y 'z)\n"
"     @result{} (x y z)\n"
msgstr ""

#. type: group
#: functions.texi.orig:679
#, no-wrap
msgid ""
"(funcall f 'x 'y '(z))\n"
"     @result{} (x y (z))\n"
msgstr ""

#. type: group
#: functions.texi.orig:683
#, no-wrap
msgid ""
"(funcall 'and t nil)\n"
"@error{} Invalid function: #<subr and>\n"
msgstr ""

#. type: defun
#: functions.texi.orig:687
msgid "Compare these examples with the examples of @code{apply}."
msgstr ""

#. type: defun
#: functions.texi.orig:689
#, no-wrap
msgid "apply function &rest arguments"
msgstr ""

#. type: defun
#: functions.texi.orig:696
msgid ""
"@code{apply} calls @var{function} with @var{arguments}, just like "
"@code{funcall} but with one difference: the last of @var{arguments} is a "
"list of objects, which are passed to @var{function} as separate arguments, "
"rather than a single list.  We say that @code{apply} @dfn{spreads} this list "
"so that each individual element becomes an argument."
msgstr ""

#. type: defun
#: functions.texi.orig:701
msgid ""
"@code{apply} returns the result of calling @var{function}.  As with "
"@code{funcall}, @var{function} must either be a Lisp function or a primitive "
"function; special forms and macros do not make sense in @code{apply}."
msgstr ""

#. type: group
#: functions.texi.orig:710
#, no-wrap
msgid ""
"(apply f 'x 'y 'z)\n"
"@error{} Wrong type argument: listp, z\n"
msgstr ""

#. type: group
#: functions.texi.orig:714
#, no-wrap
msgid ""
"(apply '+ 1 2 '(3 4))\n"
"     @result{} 10\n"
msgstr ""

#. type: group
#: functions.texi.orig:718
#, no-wrap
msgid ""
"(apply '+ '(1 2 3 4))\n"
"     @result{} 10\n"
msgstr ""

#. type: group
#: functions.texi.orig:723
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""

#. type: defun
#: functions.texi.orig:728
msgid ""
"For an interesting example of using @code{apply}, see @ref{Definition of "
"mapcar}."
msgstr ""

#. type: cindex
#: functions.texi.orig:730
#, no-wrap
msgid "partial application of functions"
msgstr ""

#. type: cindex
#: functions.texi.orig:731
#, no-wrap
msgid "currying"
msgstr ""

#. type: Plain text
#: functions.texi.orig:743
msgid ""
"Sometimes it is useful to fix some of the function's arguments at certain "
"values, and leave the rest of arguments for when the function is actually "
"called.  The act of fixing some of the function's arguments is called "
"@dfn{partial application} of the function@footnote{ This is related to, but "
"different from @dfn{currying}, which transforms a function that takes "
"multiple arguments in such a way that it can be called as a chain of "
"functions, each one with a single argument.}.  The result is a new function "
"that accepts the rest of arguments and calls the original function with all "
"the arguments combined."
msgstr ""

#. type: Plain text
#: functions.texi.orig:745
msgid "Here's how to do partial application in Emacs Lisp:"
msgstr ""

#. type: defun
#: functions.texi.orig:746
#, no-wrap
msgid "apply-partially func &rest args"
msgstr ""

#. type: defun
#: functions.texi.orig:753
msgid ""
"This function returns a new function which, when called, will call "
"@var{func} with the list of arguments composed from @var{args} and "
"additional arguments specified at the time of the call.  If @var{func} "
"accepts @var{n} arguments, then a call to @code{apply-partially} with "
"@w{@code{@var{m} < @var{n}}} arguments will produce a new function of "
"@w{@code{@var{n} - @var{m}}} arguments."
msgstr ""

#. type: defun
#: functions.texi.orig:757
msgid ""
"Here's how we could define the built-in function @code{1+}, if it didn't "
"exist, using @code{apply-partially} and @code{+}, another built-in function:"
msgstr ""

#. type: group
#: functions.texi.orig:762
#, no-wrap
msgid ""
"(defalias '1+ (apply-partially '+ 1)\n"
"  \"Increment argument by one.\")\n"
msgstr ""

#. type: group
#: functions.texi.orig:766
#, no-wrap
msgid ""
"(1+ 10)\n"
"     @result{} 11\n"
msgstr ""

#. type: cindex
#: functions.texi.orig:770
#, no-wrap
msgid "functionals"
msgstr ""

#. type: Plain text
#: functions.texi.orig:775
msgid ""
"It is common for Lisp functions to accept functions as arguments or find "
"them in data structures (especially in hook variables and property lists) "
"and call them using @code{funcall} or @code{apply}.  Functions that accept "
"function arguments are often called @dfn{functionals}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:779
msgid ""
"Sometimes, when you call a functional, it is useful to supply a no-op "
"function as the argument.  Here are two different kinds of no-op function:"
msgstr ""

#. type: defun
#: functions.texi.orig:780
#, no-wrap
msgid "identity arg"
msgstr ""

#. type: defun
#: functions.texi.orig:782
msgid "This function returns @var{arg} and has no side effects."
msgstr ""

#. type: defun
#: functions.texi.orig:784
#, no-wrap
msgid "ignore &rest args"
msgstr ""

#. type: defun
#: functions.texi.orig:786
msgid "This function ignores any arguments and returns @code{nil}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:792
msgid ""
"Some functions are user-visible @dfn{commands}, which can be called "
"interactively (usually by a key sequence).  It is possible to invoke such a "
"command exactly as though it was called interactively, by using the "
"@code{call-interactively} function.  @xref{Interactive Call}."
msgstr ""

#. type: cindex
#: functions.texi.orig:795
#, no-wrap
msgid "mapping functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:805
msgid ""
"A @dfn{mapping function} applies a given function (@emph{not} a special form "
"or macro) to each element of a list or other collection.  Emacs Lisp has "
"several such functions; this section describes @code{mapcar}, @code{mapc}, "
"and @code{mapconcat}, which map over a list.  @xref{Definition of mapatoms}, "
"for the function @code{mapatoms} which maps over the symbols in an obarray.  "
"@xref{Definition of maphash}, for the function @code{maphash} which maps "
"over key/value associations in a hash table."
msgstr ""

#. type: Plain text
#: functions.texi.orig:810
msgid ""
"These mapping functions do not allow char-tables because a char-table is a "
"sparse array whose nominal range of indices is very large.  To map over a "
"char-table in a way that deals properly with its sparse nature, use the "
"function @code{map-char-table} (@pxref{Char-Tables})."
msgstr ""

#. type: defun
#: functions.texi.orig:811
#, no-wrap
msgid "mapcar function sequence"
msgstr ""

#. type: anchor{#1}
#: functions.texi.orig:815
msgid "Definition of mapcar"
msgstr ""

#. type: defun
#: functions.texi.orig:815
msgid ""
"@code{mapcar} applies @var{function} to each element of @var{sequence} in "
"turn, and returns a list of the results."
msgstr ""

#. type: defun
#: functions.texi.orig:820
msgid ""
"The argument @var{sequence} can be any kind of sequence except a char-table; "
"that is, a list, a vector, a bool-vector, or a string.  The result is always "
"a list.  The length of the result is the same as the length of "
"@var{sequence}.  For example:"
msgstr ""

#. type: group
#: functions.texi.orig:829
#, no-wrap
msgid ""
"(mapcar 'car '((a b) (c d) (e f)))\n"
"     @result{} (a c e)\n"
"(mapcar '1+ [1 2 3])\n"
"     @result{} (2 3 4)\n"
"(mapcar 'string \"abc\")\n"
"     @result{} (\"a\" \"b\" \"c\")\n"
msgstr ""

#. type: group
#: functions.texi.orig:834
#, no-wrap
msgid ""
";; @r{Call each function in @code{my-hooks}.}\n"
"(mapcar 'funcall my-hooks)\n"
msgstr ""

#. type: group
#: functions.texi.orig:847
#, no-wrap
msgid ""
"(defun mapcar* (function &rest args)\n"
"  \"Apply FUNCTION to successive cars of all ARGS.\n"
"Return the list of results.\"\n"
"  ;; @r{If no list is exhausted,}\n"
"  (if (not (memq nil args))\n"
"      ;; @r{apply function to @sc{car}s.}\n"
"      (cons (apply function (mapcar 'car args))\n"
"            (apply 'mapcar* function\n"
"                   ;; @r{Recurse for rest of elements.}\n"
"                   (mapcar 'cdr args)))))\n"
msgstr ""

#. type: group
#: functions.texi.orig:852
#, no-wrap
msgid ""
"(mapcar* 'cons '(a b c) '(1 2 3 4))\n"
"     @result{} ((a . 1) (b . 2) (c . 3))\n"
msgstr ""

#. type: defun
#: functions.texi.orig:856
#, no-wrap
msgid "mapc function sequence"
msgstr ""

#. type: defun
#: functions.texi.orig:860
msgid ""
"@code{mapc} is like @code{mapcar} except that @var{function} is used for "
"side-effects only---the values it returns are ignored, not collected into a "
"list.  @code{mapc} always returns @var{sequence}."
msgstr ""

#. type: defun
#: functions.texi.orig:862
#, no-wrap
msgid "mapconcat function sequence separator"
msgstr ""

#. type: defun
#: functions.texi.orig:868
msgid ""
"@code{mapconcat} applies @var{function} to each element of @var{sequence}: "
"the results, which must be strings, are concatenated.  Between each pair of "
"result strings, @code{mapconcat} inserts the string @var{separator}.  "
"Usually @var{separator} contains a space or comma or other suitable "
"punctuation."
msgstr ""

#. type: defun
#: functions.texi.orig:873
msgid ""
"The argument @var{function} must be a function that can take one argument "
"and return a string.  The argument @var{sequence} can be any kind of "
"sequence except a char-table; that is, a list, a vector, a bool-vector, or a "
"string."
msgstr ""

#. type: group
#: functions.texi.orig:880
#, no-wrap
msgid ""
"(mapconcat 'symbol-name\n"
"           '(The cat in the hat)\n"
"           \" \")\n"
"     @result{} \"The cat in the hat\"\n"
msgstr ""

#. type: group
#: functions.texi.orig:887
#, no-wrap
msgid ""
"(mapconcat (function (lambda (x) (format \"%c\" (1+ x))))\n"
"           \"HAL-8000\"\n"
"           \"\")\n"
"     @result{} \"IBM.9111\"\n"
msgstr ""

#. type: cindex
#: functions.texi.orig:893
#, no-wrap
msgid "anonymous function"
msgstr ""

#. type: Plain text
#: functions.texi.orig:904
msgid ""
"Although functions are usually defined with @code{defun} and given names at "
"the same time, it is sometimes convenient to use an explicit lambda "
"expression---an @dfn{anonymous function}.  Anonymous functions are valid "
"wherever function names are.  They are often assigned as variable values, or "
"as arguments to functions; for instance, you might pass one as the "
"@var{function} argument to @code{mapcar}, which applies that function to "
"each element of a list (@pxref{Mapping Functions}).  @xref{describe-symbols "
"example}, for a realistic example of this."
msgstr ""

#. type: Plain text
#: functions.texi.orig:909
msgid ""
"When defining a lambda expression that is to be used as an anonymous "
"function, you can in principle use any method to construct the list.  But "
"typically you should use the @code{lambda} macro, or the @code{function} "
"special form, or the @code{#'} read syntax:"
msgstr ""

#. type: defmac
#: functions.texi.orig:910
#, no-wrap
msgid "lambda args [doc] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: functions.texi.orig:914
msgid ""
"This macro returns an anonymous function with argument list @var{args}, "
"documentation string @var{doc} (if any), interactive spec @var{interactive} "
"(if any), and body forms given by @var{body}."
msgstr ""

#. type: defmac
#: functions.texi.orig:918
msgid ""
"In effect, this macro makes @code{lambda} forms ``self-quoting'': evaluating "
"a form whose @sc{car} is @code{lambda} yields the form itself:"
msgstr ""

#. type: example
#: functions.texi.orig:922
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"     @result{} (lambda (x) (* x x))\n"
msgstr ""

#. type: defmac
#: functions.texi.orig:927
msgid ""
"The @code{lambda} form has one other effect: it tells the Emacs evaluator "
"and byte-compiler that its argument is a function, by using @code{function} "
"as a subroutine (see below)."
msgstr ""

#. type: defspec
#: functions.texi.orig:929
#, no-wrap
msgid "function function-object"
msgstr ""

#. type: cindex
#: functions.texi.orig:930
#, no-wrap
msgid "function quoting"
msgstr ""

#. type: defspec
#: functions.texi.orig:937
msgid ""
"This special form returns @var{function-object} without evaluating it.  In "
"this, it is similar to @code{quote} (@pxref{Quoting}).  But unlike "
"@code{quote}, it also serves as a note to the Emacs evaluator and "
"byte-compiler that @var{function-object} is intended to be used as a "
"function.  Assuming @var{function-object} is a valid lambda expression, this "
"has two effects:"
msgstr ""

#. type: itemize
#: functions.texi.orig:942
msgid ""
"When the code is byte-compiled, @var{function-object} is compiled into a "
"byte-code function object (@pxref{Byte Compilation})."
msgstr ""

#. type: itemize
#: functions.texi.orig:946
msgid ""
"When lexical binding is enabled, @var{function-object} is converted into a "
"closure.  @xref{Closures}."
msgstr ""

#. type: cindex
#: functions.texi.orig:949
#, no-wrap
msgid "@samp{#'} syntax"
msgstr ""

#. type: Plain text
#: functions.texi.orig:952
msgid ""
"The read syntax @code{#'} is a short-hand for using @code{function}.  The "
"following forms are all equivalent:"
msgstr ""

#. type: example
#: functions.texi.orig:957
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"(function (lambda (x) (* x x)))\n"
"#'(lambda (x) (* x x))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:963
msgid ""
"In the following example, we define a @code{change-property} function that "
"takes a function as its third argument, followed by a @code{double-property} "
"function that makes use of @code{change-property} by passing it an anonymous "
"function:"
msgstr ""

#. type: group
#: functions.texi.orig:969
#, no-wrap
msgid ""
"(defun change-property (symbol prop function)\n"
"  (let ((value (get symbol prop)))\n"
"    (put symbol prop (funcall function value))))\n"
msgstr ""

#. type: group
#: functions.texi.orig:974
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop (lambda (x) (* 2 x))))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:979
msgid "Note that we do not quote the @code{lambda} form."
msgstr ""

#. type: Plain text
#: functions.texi.orig:983
msgid ""
"If you compile the above code, the anonymous function is also compiled.  "
"This would not happen if, say, you had constructed the anonymous function by "
"quoting it as a list:"
msgstr ""

#. type: group
#: functions.texi.orig:989
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop '(lambda (x) (* 2 x))))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:997
msgid ""
"In that case, the anonymous function is kept as a lambda expression in the "
"compiled code.  The byte-compiler cannot assume this list is a function, "
"even though it looks like one, since it does not know that "
"@code{change-property} intends to use it as a function."
msgstr ""

#. type: section
#: functions.texi.orig:999
#, no-wrap
msgid "Accessing Function Cell Contents"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1004
msgid ""
"The @dfn{function definition} of a symbol is the object stored in the "
"function cell of the symbol.  The functions described here access, test, and "
"set the function cell of symbols."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1007
msgid ""
"See also the function @code{indirect-function}.  @xref{Definition of "
"indirect-function}."
msgstr ""

#. type: defun
#: functions.texi.orig:1008
#, no-wrap
msgid "symbol-function symbol"
msgstr ""

#. type: kindex
#: functions.texi.orig:1009
#, no-wrap
msgid "void-function"
msgstr ""

#. type: defun
#: functions.texi.orig:1012
msgid ""
"This returns the object in the function cell of @var{symbol}.  It does not "
"check that the returned object is a legitimate function."
msgstr ""

#. type: defun
#: functions.texi.orig:1016
msgid ""
"If the function cell is void, the return value is @code{nil}.  To "
"distinguish between a function cell that is void and one set to @code{nil}, "
"use @code{fboundp} (see below)."
msgstr ""

#. type: group
#: functions.texi.orig:1022
#, no-wrap
msgid ""
"(defun bar (n) (+ n 2))\n"
"(symbol-function 'bar)\n"
"     @result{} (lambda (n) (+ n 2))\n"
msgstr ""

#. type: group
#: functions.texi.orig:1026
#, no-wrap
msgid ""
"(fset 'baz 'bar)\n"
"     @result{} bar\n"
msgstr ""

#. type: group
#: functions.texi.orig:1030
#, no-wrap
msgid ""
"(symbol-function 'baz)\n"
"     @result{} bar\n"
msgstr ""

#. type: cindex
#: functions.texi.orig:1034
#, no-wrap
msgid "void function cell"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1039
msgid ""
"If you have never given a symbol any function definition, we say that that "
"symbol's function cell is @dfn{void}.  In other words, the function cell "
"does not have any Lisp object in it.  If you try to call the symbol as a "
"function, Emacs signals a @code{void-function} error."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1045
msgid ""
"Note that void is not the same as @code{nil} or the symbol @code{void}.  The "
"symbols @code{nil} and @code{void} are Lisp objects, and can be stored into "
"a function cell just as any other object can be (and they can be valid "
"functions if you define them in turn with @code{defun}).  A void function "
"cell contains no object whatsoever."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1049
msgid ""
"You can test the voidness of a symbol's function definition with "
"@code{fboundp}.  After you have given a symbol a function definition, you "
"can make it void once more using @code{fmakunbound}."
msgstr ""

#. type: defun
#: functions.texi.orig:1050
#, no-wrap
msgid "fboundp symbol"
msgstr ""

#. type: defun
#: functions.texi.orig:1054
msgid ""
"This function returns @code{t} if the symbol has an object in its function "
"cell, @code{nil} otherwise.  It does not check that the object is a "
"legitimate function."
msgstr ""

#. type: defun
#: functions.texi.orig:1056
#, no-wrap
msgid "fmakunbound symbol"
msgstr ""

#. type: defun
#: functions.texi.orig:1061
msgid ""
"This function makes @var{symbol}'s function cell void, so that a subsequent "
"attempt to access this cell will cause a @code{void-function} error.  It "
"returns @var{symbol}.  (See also @code{makunbound}, in @ref{Void "
"Variables}.)"
msgstr ""

#. type: group
#: functions.texi.orig:1067
#, no-wrap
msgid ""
"(defun foo (x) x)\n"
"(foo 1)\n"
"     @result{}1\n"
msgstr ""

#. type: group
#: functions.texi.orig:1071
#, no-wrap
msgid ""
"(fmakunbound 'foo)\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: functions.texi.orig:1075
#, no-wrap
msgid ""
"(foo 1)\n"
"@error{} Symbol's function definition is void: foo\n"
msgstr ""

#. type: defun
#: functions.texi.orig:1079
#, no-wrap
msgid "fset symbol definition"
msgstr ""

#. type: defun
#: functions.texi.orig:1085
msgid ""
"This function stores @var{definition} in the function cell of @var{symbol}.  "
"The result is @var{definition}.  Normally @var{definition} should be a "
"function or the name of a function, but this is not checked.  The argument "
"@var{symbol} is an ordinary evaluated argument."
msgstr ""

#. type: defun
#: functions.texi.orig:1090
msgid ""
"The primary use of this function is as a subroutine by constructs that "
"define or alter functions, like @code{defun} or @code{advice-add} "
"(@pxref{Advising Functions}).  You can also use it to give a symbol a "
"function definition that is not a function, e.g., a keyboard macro "
"(@pxref{Keyboard Macros}):"
msgstr ""

#. type: example
#: functions.texi.orig:1095
#, no-wrap
msgid ""
";; @r{Define a named keyboard macro.}\n"
"(fset 'kill-two-lines \"\\^u2\\^k\")\n"
"     @result{} \"\\^u2\\^k\"\n"
msgstr ""

#. type: defun
#: functions.texi.orig:1100
msgid ""
"It you wish to use @code{fset} to make an alternate name for a function, "
"consider using @code{defalias} instead.  @xref{Definition of defalias}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1112
msgid ""
"As explained in @ref{Variable Scoping}, Emacs can optionally enable lexical "
"binding of variables.  When lexical binding is enabled, any named function "
"that you create (e.g., with @code{defun}), as well as any anonymous function "
"that you create using the @code{lambda} macro or the @code{function} special "
"form or the @code{#'} syntax (@pxref{Anonymous Functions}), is automatically "
"converted into a @dfn{closure}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1120
msgid ""
"A closure is a function that also carries a record of the lexical "
"environment that existed when the function was defined.  When it is invoked, "
"any lexical variable references within its definition use the retained "
"lexical environment.  In all other respects, closures behave much like "
"ordinary functions; in particular, they can be called in the same way as "
"ordinary functions."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1122
msgid "@xref{Lexical Binding}, for an example of using a closure."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1127
msgid ""
"Currently, an Emacs Lisp closure object is represented by a list with the "
"symbol @code{closure} as the first element, a list representing the lexical "
"environment as the second element, and the argument list and body forms as "
"the remaining elements:"
msgstr ""

#. type: example
#: functions.texi.orig:1132
#, no-wrap
msgid ""
";; @r{lexical binding is enabled.}\n"
"(lambda (x) (* x x))\n"
"     @result{} (closure (t) (x) (* x x))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1139
msgid ""
"However, the fact that the internal structure of a closure is ``exposed'' to "
"the rest of the Lisp world is considered an internal implementation detail.  "
"For this reason, we recommend against directly examining or altering the "
"structure of closure objects."
msgstr ""

#. type: section
#: functions.texi.orig:1141
#, no-wrap
msgid "Advising Emacs Lisp Functions"
msgstr ""

#. type: cindex
#: functions.texi.orig:1142
#, no-wrap
msgid "advising functions"
msgstr ""

#. type: cindex
#: functions.texi.orig:1143
#, no-wrap
msgid "piece of advice"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1152
msgid ""
"When you need to modify a function defined in another library, or when you "
"need to modify a hook like @code{@var{foo}-function}, a process filter, or "
"basically any variable or object field which holds a function value, you can "
"use the appropriate setter function, such as @code{fset} or @code{defun} for "
"named functions, @code{setq} for hook variables, or "
"@code{set-process-filter} for process filters, but those are often too "
"blunt, completely throwing away the previous value."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1156
msgid ""
"The @dfn{advice} feature lets you add to the existing definition of a "
"function, by @dfn{advising the function}.  This is a cleaner method than "
"redefining the whole function."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1162
msgid ""
"Emacs's advice system provides two sets of primitives for that: the core "
"set, for function values held in variables and object fields (with the "
"corresponding primitives being @code{add-function} and "
"@code{remove-function}) and another set layered on top of it for named "
"functions (with the main primitives being @code{advice-add} and "
"@code{advice-remove})."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1165
msgid ""
"For example, in order to trace the calls to the process filter of a process "
"@var{proc}, you could use:"
msgstr ""

#. type: example
#: functions.texi.orig:1169
#, no-wrap
msgid ""
"(defun my-tracing-function (proc string)\n"
"  (message \"Proc %S received %S\" proc string))\n"
"\n"
msgstr ""

#. type: example
#: functions.texi.orig:1171
#, no-wrap
msgid "(add-function :before (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1177
msgid ""
"This will cause the process's output to be passed to "
"@code{my-tracing-function} before being passed to the original process "
"filter.  @code{my-tracing-function} receives the same arguments as the "
"original function.  When you're done with it, you can revert to the untraced "
"behavior with:"
msgstr ""

#. type: example
#: functions.texi.orig:1180
#, no-wrap
msgid "(remove-function (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1184
msgid ""
"Similarly, if you want to trace the execution of the function named "
"@code{display-buffer}, you could use:"
msgstr ""

#. type: example
#: functions.texi.orig:1191
#, no-wrap
msgid ""
"(defun his-tracing-function (orig-fun &rest args)\n"
"  (message \"display-buffer called with args %S\" args)\n"
"  (let ((res (apply orig-fun args)))\n"
"    (message \"display-buffer returned %S\" res)\n"
"    res))\n"
"\n"
msgstr ""

#. type: example
#: functions.texi.orig:1193
#, no-wrap
msgid "(advice-add 'display-buffer :around #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1200
msgid ""
"Here, @code{his-tracing-function} is called instead of the original function "
"and receives the original function (additionally to that function's "
"arguments)  as argument, so it can call it if and when it needs to.  When "
"you're tired of seeing this output, you can revert to the untraced behavior "
"with:"
msgstr ""

#. type: example
#: functions.texi.orig:1203
#, no-wrap
msgid "(advice-remove 'display-buffer #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1208
msgid ""
"The arguments @code{:before} and @code{:around} used in the above examples "
"specify how the two functions are composed, since there are many different "
"ways to do it.  The added function is also called an @emph{advice}."
msgstr ""

#. type: node
#: functions.texi.orig:1214 functions.texi.orig:1216
#, no-wrap
msgid "Core Advising Primitives"
msgstr ""

#. type: menuentry
#: functions.texi.orig:1214
msgid "Primitives to manipulate advice."
msgstr ""

#. type: subsection
#: functions.texi.orig:1214 functions.texi.orig:1315 functions.texi.orig:1316
#, no-wrap
msgid "Advising Named Functions"
msgstr ""

#. type: menuentry
#: functions.texi.orig:1214
msgid "Advising named functions."
msgstr ""

#. type: node
#: functions.texi.orig:1214 functions.texi.orig:1388
#, no-wrap
msgid "Advice combinators"
msgstr ""

#. type: menuentry
#: functions.texi.orig:1214
msgid "Ways to compose advices."
msgstr ""

#. type: node
#: functions.texi.orig:1214 functions.texi.orig:1501
#, no-wrap
msgid "Porting old advices"
msgstr ""

#. type: menuentry
#: functions.texi.orig:1214
msgid "Adapting code using the old defadvice."
msgstr ""

#. type: subsection
#: functions.texi.orig:1217
#, no-wrap
msgid "Primitives to manipulate advices"
msgstr ""

#. type: cindex
#: functions.texi.orig:1218
#, no-wrap
msgid "advice, add and remove"
msgstr ""

#. type: defmac
#: functions.texi.orig:1220
#, no-wrap
msgid "add-function where place function &optional props"
msgstr ""

#. type: defmac
#: functions.texi.orig:1223
msgid ""
"This macro is the handy way to add the advice @var{function} to the function "
"stored in @var{place} (@pxref{Generalized Variables})."
msgstr ""

#. type: defmac
#: functions.texi.orig:1228
msgid ""
"@var{where} determines how @var{function} is composed with the existing "
"function, e.g. whether @var{function} should be called before, or after the "
"original function.  @xref{Advice combinators}, for the list of available "
"ways to compose the two functions."
msgstr ""

#. type: defmac
#: functions.texi.orig:1237
msgid ""
"When modifying a variable (whose name will usually end with "
"@code{-function}), you can choose whether @var{function} is used globally or "
"only in the current buffer: if @var{place} is just a symbol, then "
"@var{function} is added to the global value of @var{place}.  Whereas if "
"@var{place} is of the form @code{(local @var{symbol})}, where @var{symbol} "
"is an expression which returns the variable name, then @var{function} will "
"only be added in the current buffer.  Finally, if you want to modify a "
"lexical variable, you will have to use @code{(var @var{variable})}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1241
msgid ""
"Every function added with @code{add-function} can be accompanied by an "
"association list of properties @var{props}.  Currently only two of those "
"properties have a special meaning:"
msgstr ""

#. type: item
#: functions.texi.orig:1243
#, no-wrap
msgid "name"
msgstr ""

#. type: table
#: functions.texi.orig:1247
msgid ""
"This gives a name to the advice, which @code{remove-function} can use to "
"identify which function to remove.  Typically used when @var{function} is an "
"anonymous function."
msgstr ""

#. type: item
#: functions.texi.orig:1248
#, no-wrap
msgid "depth"
msgstr ""

#. type: table
#: functions.texi.orig:1254
msgid ""
"This specifies how to order the advices, in case several advices are "
"present.  By default, the depth is 0.  A depth of 100 indicates that this "
"advice should be kept as deep as possible, whereas a depth of -100 indicates "
"that it should stay as the outermost advice.  When two advices specify the "
"same depth, the most recently added advice will be outermost."
msgstr ""

#. type: table
#: functions.texi.orig:1265
msgid ""
"For a @code{:before} advice, being outermost means that this advice will be "
"run first, before any other advice, whereas being innermost means that it "
"will run right before the original function, with no other advice run "
"between itself and the original function.  Similarly, for an @code{:after} "
"advice innermost means that it will run right after the original function, "
"with no other advice run in between, whereas outermost means that it will be "
"run very last after all other advices.  An innermost @code{:override} advice "
"will only override the original function and other advices will apply to it, "
"whereas an outermost @code{:override} advice will override not only the "
"original function but all other advices applied to it as well."
msgstr ""

#. type: defmac
#: functions.texi.orig:1275
msgid ""
"If @var{function} is not interactive, then the combined function will "
"inherit the interactive spec, if any, of the original function.  Else, the "
"combined function will be interactive and will use the interactive spec of "
"@var{function}.  One exception: if the interactive spec of @var{function} is "
"a function (rather than an expression or a string), then the interactive "
"spec of the combined function will be a call to that function with as sole "
"argument the interactive spec of the original function.  To interpret the "
"spec received as argument, use @code{advice-eval-interactive-spec}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1281
msgid ""
"Note: The interactive spec of @var{function} will apply to the combined "
"function and should hence obey the calling convention of the combined "
"function rather than that of @var{function}.  In many cases, it makes no "
"difference since they are identical, but it does matter for @code{:around}, "
"@code{:filter-args}, and @code{filter-return}, where @var{function}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1283
#, no-wrap
msgid "remove-function place function"
msgstr ""

#. type: defmac
#: functions.texi.orig:1287
msgid ""
"This macro removes @var{function} from the function stored in @var{place}.  "
"This only works if @var{function} was added to @var{place} using "
"@code{add-function}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1293
msgid ""
"@var{function} is compared with functions added to @var{place} using "
"@code{equal}, to try and make it work also with lambda expressions.  It is "
"additionally compared also with the @code{name} property of the functions "
"added to @var{place}, which can be more reliable than comparing lambda "
"expressions using @code{equal}."
msgstr ""

#. type: defun
#: functions.texi.orig:1295
#, no-wrap
msgid "advice-function-member-p advice function-def"
msgstr ""

#. type: defun
#: functions.texi.orig:1299
msgid ""
"Return non-@code{nil} if @var{advice} is already in @var{function-def}.  "
"Like for @code{remove-function} above, instead of @var{advice} being the "
"actual function, it can also be the @code{name} of the piece of advice."
msgstr ""

#. type: defun
#: functions.texi.orig:1301
#, no-wrap
msgid "advice-function-mapc f function-def"
msgstr ""

#. type: defun
#: functions.texi.orig:1305
msgid ""
"Call the function @var{f} for every advice that was added to "
"@var{function-def}.  @var{f} is called with two arguments: the advice "
"function and its properties."
msgstr ""

#. type: defun
#: functions.texi.orig:1307
#, no-wrap
msgid "advice-eval-interactive-spec spec"
msgstr ""

#. type: defun
#: functions.texi.orig:1313
msgid ""
"Evaluate the interactive @var{spec} just like an interactive call to a "
"function with such a spec would, and then return the corresponding list of "
"arguments that was built.  E.g. @code{(advice-eval-interactive-spec "
"\"r\\nP\")} will return a list of three elements, containing the boundaries "
"of the region and the current prefix argument."
msgstr ""

#. type: cindex
#: functions.texi.orig:1317
#, no-wrap
msgid "advising named functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1321
msgid ""
"A common use of advice is for named functions and macros.  You could just "
"use @code{add-function} as in:"
msgstr ""

#. type: example
#: functions.texi.orig:1324
#, no-wrap
msgid "(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1333
msgid ""
"But you should use @code{advice-add} and @code{advice-remove} for that "
"instead.  This separate set of functions to manipulate pieces of advice "
"applied to named functions, offers the following extra features compared to "
"@code{add-function}: they know how to deal with macros and autoloaded "
"functions, they let @code{describe-function} preserve the original docstring "
"as well as document the added advice, and they let you add and remove "
"advices before a function is even defined."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1341
msgid ""
"@code{advice-add} can be useful for altering the behavior of existing calls "
"to an existing function without having to redefine the whole function.  "
"However, it can be a source of bugs, since existing callers to the function "
"may assume the old behavior, and work incorrectly when the behavior is "
"changed by advice.  Advice can also cause confusion in debugging, if the "
"person doing the debugging does not notice or remember that the function has "
"been modified by advice."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1351
msgid ""
"For these reasons, advice should be reserved for the cases where you cannot "
"modify a function's behavior in any other way.  If it is possible to do the "
"same thing via a hook, that is preferable (@pxref{Hooks}).  If you simply "
"want to change what a particular key does, it may be better to write a new "
"command, and remap the old command's key bindings to the new one "
"(@pxref{Remapping Commands}).  In particular, Emacs's own source files "
"should not put advice on functions in Emacs.  (There are currently a few "
"exceptions to this convention, but we aim to correct them.)"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1356
msgid ""
"Special forms (@pxref{Special Forms}) cannot be advised, however macros can "
"be advised, in much the same way as functions.  Of course, this will not "
"affect code that has already been macro-expanded, so you need to make sure "
"the advice is installed before the macro is expanded."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1364
msgid ""
"It is possible to advise a primitive (@pxref{What Is a Function}), but one "
"should typically @emph{not} do so, for two reasons.  Firstly, some "
"primitives are used by the advice mechanism, and advising them could cause "
"an infinite recursion.  Secondly, many primitives are called directly from "
"C, and such calls ignore advice; hence, one ends up in a confusing situation "
"where some calls (occurring from Lisp code) obey the advice and other calls "
"(from C code) do not."
msgstr ""

#. type: defun
#: functions.texi.orig:1365
#, no-wrap
msgid "advice-add symbol where function &optional props"
msgstr ""

#. type: defun
#: functions.texi.orig:1369
msgid ""
"Add the advice @var{function} to the named function @var{symbol}.  "
"@var{where} and @var{props} have the same meaning as for @code{add-function} "
"(@pxref{Core Advising Primitives})."
msgstr ""

#. type: defun
#: functions.texi.orig:1371
#, no-wrap
msgid "advice-remove symbol function"
msgstr ""

#. type: defun
#: functions.texi.orig:1374
msgid ""
"Remove the advice @var{function} from the named function @var{symbol}.  "
"@var{function} can also be the @code{name} of an advice."
msgstr ""

#. type: defun
#: functions.texi.orig:1376
#, no-wrap
msgid "advice-member-p function symbol"
msgstr ""

#. type: defun
#: functions.texi.orig:1380
msgid ""
"Return non-@code{nil} if the advice @var{function} is already in the named "
"function @var{symbol}.  @var{function} can also be the @code{name} of an "
"advice."
msgstr ""

#. type: defun
#: functions.texi.orig:1382
#, no-wrap
msgid "advice-mapc function symbol"
msgstr ""

#. type: defun
#: functions.texi.orig:1386
msgid ""
"Call @var{function} for every advice that was added to the named function "
"@var{symbol}.  @var{function} is called with two arguments: the advice "
"function and its properties."
msgstr ""

#. type: subsection
#: functions.texi.orig:1389
#, no-wrap
msgid "Ways to compose advices"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1394
msgid ""
"Here are the different possible values for the @var{where} argument of "
"@code{add-function} and @code{advice-add}, specifying how the advice "
"@var{function} and the original function should be composed."
msgstr ""

#. type: item
#: functions.texi.orig:1396
#, no-wrap
msgid ":before"
msgstr ""

#. type: table
#: functions.texi.orig:1401
msgid ""
"Call @var{function} before the old function.  Both functions receive the "
"same arguments, and the return value of the composition is the return value "
"of the old function.  More specifically, the composition of the two "
"functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1403
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1407
msgid ""
"@code{(add-function :before @var{funvar} @var{function})} is comparable for "
"single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for "
"normal hooks."
msgstr ""

#. type: item
#: functions.texi.orig:1408
#, no-wrap
msgid ":after"
msgstr ""

#. type: table
#: functions.texi.orig:1413
msgid ""
"Call @var{function} after the old function.  Both functions receive the same "
"arguments, and the return value of the composition is the return value of "
"the old function.  More specifically, the composition of the two functions "
"behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1415
#, no-wrap
msgid "(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1419
msgid ""
"@code{(add-function :after @var{funvar} @var{function})} is comparable for "
"single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} for normal hooks."
msgstr ""

#. type: item
#: functions.texi.orig:1420
#, no-wrap
msgid ":override"
msgstr ""

#. type: table
#: functions.texi.orig:1423
msgid ""
"This completely replaces the old function with the new one.  The old "
"function can of course be recovered if you later call "
"@code{remove-function}."
msgstr ""

#. type: item
#: functions.texi.orig:1424
#, no-wrap
msgid ":around"
msgstr ""

#. type: table
#: functions.texi.orig:1431
msgid ""
"Call @var{function} instead of the old function, but provide the old "
"function as an extra argument to @var{function}.  This is the most flexible "
"composition.  For example, it lets you call the old function with different "
"arguments, or many times, or within a let-binding, or you can sometimes "
"delegate the work to the old function and sometimes override it completely.  "
"More specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1433
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} @var{oldfun} r))\n"
msgstr ""

#. type: item
#: functions.texi.orig:1435
#, no-wrap
msgid ":before-while"
msgstr ""

#. type: table
#: functions.texi.orig:1441
msgid ""
"Call @var{function} before the old function and don't call the old function "
"if @var{function} returns @code{nil}.  Both functions receive the same "
"arguments, and the return value of the composition is the return value of "
"the old function.  More specifically, the composition of the two functions "
"behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1443
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1447
msgid ""
"@code{(add-function :before-while @var{funvar} @var{function})} is "
"comparable for single-function hooks to @code{(add-hook '@var{hookvar} "
"@var{function})} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-failure}."
msgstr ""

#. type: item
#: functions.texi.orig:1448
#, no-wrap
msgid ":before-until"
msgstr ""

#. type: table
#: functions.texi.orig:1452
msgid ""
"Call @var{function} before the old function and only call the old function "
"if @var{function} returns @code{nil}.  More specifically, the composition of "
"the two functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1454
#, no-wrap
msgid "(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1458
msgid ""
"@code{(add-function :before-until @var{funvar} @var{function})} is "
"comparable for single-function hooks to @code{(add-hook '@var{hookvar} "
"@var{function})} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-success}."
msgstr ""

#. type: item
#: functions.texi.orig:1459
#, no-wrap
msgid ":after-while"
msgstr ""

#. type: table
#: functions.texi.orig:1464
msgid ""
"Call @var{function} after the old function and only if the old function "
"returned non-@code{nil}.  Both functions receive the same arguments, and the "
"return value of the composition is the return value of @var{function}.  More "
"specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1466
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1471
msgid ""
"@code{(add-function :after-while @var{funvar} @var{function})} is comparable "
"for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-failure}."
msgstr ""

#. type: item
#: functions.texi.orig:1472
#, no-wrap
msgid ":after-until"
msgstr ""

#. type: table
#: functions.texi.orig:1476
msgid ""
"Call @var{function} after the old function and only if the old function "
"returned @code{nil}.  More specifically, the composition of the two "
"functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1478
#, no-wrap
msgid "(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: functions.texi.orig:1483
msgid ""
"@code{(add-function :after-until @var{funvar} @var{function})} is comparable "
"for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-success}."
msgstr ""

#. type: item
#: functions.texi.orig:1484
#, no-wrap
msgid ":filter-args"
msgstr ""

#. type: table
#: functions.texi.orig:1488
msgid ""
"Call @var{function} first and use the result (which should be a list) as the "
"new arguments to pass to the old function.  More specifically, the "
"composition of the two functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1490
#, no-wrap
msgid "(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))\n"
msgstr ""

#. type: item
#: functions.texi.orig:1492
#, no-wrap
msgid ":filter-return"
msgstr ""

#. type: table
#: functions.texi.orig:1495
msgid ""
"Call the old function first and pass the result to @var{function}.  More "
"specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: functions.texi.orig:1497
#, no-wrap
msgid "(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))\n"
msgstr ""

#. type: subsection
#: functions.texi.orig:1502
#, no-wrap
msgid "Adapting code using the old defadvice"
msgstr ""

#. type: cindex
#: functions.texi.orig:1503
#, no-wrap
msgid "old advices, porting"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1508
msgid ""
"A lot of code uses the old @code{defadvice} mechanism, which is largely made "
"obsolete by the new @code{advice-add}, whose implementation and semantics is "
"significantly simpler."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1510
msgid "An old advice such as:"
msgstr ""

#. type: example
#: functions.texi.orig:1520
#, no-wrap
msgid ""
"(defadvice previous-line (before next-line-at-end\n"
"                                 (&optional arg try-vscroll))\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1523
msgid "could be translated in the new advice mechanism into a plain function:"
msgstr ""

#. type: example
#: functions.texi.orig:1532
#, no-wrap
msgid ""
"(defun previous-line--next-line-at-end (&optional arg try-vscroll)\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1536
msgid ""
"Obviously, this does not actually modify @code{previous-line}.  For that the "
"old advice needed:"
msgstr ""

#. type: example
#: functions.texi.orig:1538
#, no-wrap
msgid "(ad-activate 'previous-line)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1540
msgid "whereas the new advice mechanism needs:"
msgstr ""

#. type: example
#: functions.texi.orig:1542
#, no-wrap
msgid "(advice-add 'previous-line :before #'previous-line--next-line-at-end)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1549
msgid ""
"Note that @code{ad-activate} had a global effect: it activated all pieces of "
"advice enabled for that specified function.  If you wanted to only activate "
"or deactivate a particular advice, you needed to @emph{enable} or "
"@emph{disable} that advice with @code{ad-enable-advice} and "
"@code{ad-disable-advice}.  The new mechanism does away with this "
"distinction."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1551
msgid "An around advice such as:"
msgstr ""

#. type: example
#: functions.texi.orig:1558
#, no-wrap
msgid ""
"(defadvice foo (around foo-around)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    ad-do-it))\n"
"(ad-activate 'foo)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1561
msgid "could translate into:"
msgstr ""

#. type: example
#: functions.texi.orig:1568
#, no-wrap
msgid ""
"(defun foo--foo-around (orig-fun &rest args)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    (apply orig-fun args)))\n"
"(advice-add 'foo :around #'foo--foo-around)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1578
msgid ""
"Regarding the advice's @emph{class}, note that the new @code{:before} is not "
"quite equivalent to the old @code{before}, because in the old advice you "
"could modify the function's arguments (e.g., with @code{ad-set-arg}), and "
"that would affect the argument values seen by the original function, whereas "
"in the new @code{:before}, modifying an argument via @code{setq} in the "
"advice has no effect on the arguments seen by the original function.  When "
"porting a @code{before} advice which relied on this behavior, you'll need to "
"turn it into a new @code{:around} or @code{:filter-args} advice instead."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1583
msgid ""
"Similarly an old @code{after} advice could modify the returned value by "
"changing @code{ad-return-value}, whereas a new @code{:after} advice cannot, "
"so when porting such an old @code{after} advice, you'll need to turn it into "
"a new @code{:around} or @code{:filter-return} advice instead."
msgstr ""

#. type: section
#: functions.texi.orig:1585
#, no-wrap
msgid "Declaring Functions Obsolete"
msgstr ""

#. type: cindex
#: functions.texi.orig:1586
#, no-wrap
msgid "obsolete functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1594
msgid ""
"You can mark a named function as @dfn{obsolete}, meaning that it may be "
"removed at some point in the future.  This causes Emacs to warn that the "
"function is obsolete whenever it byte-compiles code containing that "
"function, and whenever it displays the documentation for that function.  In "
"all other respects, an obsolete function behaves like any other function."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1599
msgid ""
"The easiest way to mark a function as obsolete is to put a @code{(declare "
"(obsolete @dots{}))} form in the function's @code{defun} definition.  "
"@xref{Declare Form}.  Alternatively, you can use the @code{make-obsolete} "
"function, described below."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1605
msgid ""
"A macro (@pxref{Macros}) can also be marked obsolete with "
"@code{make-obsolete}; this has the same effects as for a function.  An alias "
"for a function or macro can also be marked as obsolete; this makes the alias "
"itself obsolete, not the function or macro which it resolves to."
msgstr ""

#. type: defun
#: functions.texi.orig:1606
#, no-wrap
msgid "make-obsolete obsolete-name current-name &optional when"
msgstr ""

#. type: defun
#: functions.texi.orig:1610
msgid ""
"This function marks @var{obsolete-name} as obsolete.  @var{obsolete-name} "
"should be a symbol naming a function or macro, or an alias for a function or "
"macro."
msgstr ""

#. type: defun
#: functions.texi.orig:1619
msgid ""
"If @var{current-name} is a symbol, the warning message says to use "
"@var{current-name} instead of @var{obsolete-name}.  @var{current-name} does "
"not need to be an alias for @var{obsolete-name}; it can be a different "
"function with similar functionality.  @var{current-name} can also be a "
"string, which serves as the warning message.  The message should begin in "
"lower case, and end with a period.  It can also be @code{nil}, in which case "
"the warning message provides no additional details."
msgstr ""

#. type: defun
#: functions.texi.orig:1622
msgid ""
"If provided, @var{when} should be a string indicating when the function was "
"first made obsolete---for example, a date or a release number."
msgstr ""

#. type: defmac
#: functions.texi.orig:1624
#, no-wrap
msgid "define-obsolete-function-alias obsolete-name current-name &optional when doc"
msgstr ""

#. type: defmac
#: functions.texi.orig:1628
msgid ""
"This convenience macro marks the function @var{obsolete-name} obsolete and "
"also defines it as an alias for the function @var{current-name}.  It is "
"equivalent to the following:"
msgstr ""

#. type: example
#: functions.texi.orig:1632
#, no-wrap
msgid ""
"(defalias @var{obsolete-name} @var{current-name} @var{doc})\n"
"(make-obsolete @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1637
msgid ""
"In addition, you can mark a certain a particular calling convention for a "
"function as obsolete:"
msgstr ""

#. type: defun
#: functions.texi.orig:1638
#, no-wrap
msgid "set-advertised-calling-convention function signature when"
msgstr ""

#. type: defun
#: functions.texi.orig:1646
msgid ""
"This function specifies the argument list @var{signature} as the correct way "
"to call @var{function}.  This causes the Emacs byte compiler to issue a "
"warning whenever it comes across an Emacs Lisp program that calls "
"@var{function} any other way (however, it will still allow the code to be "
"byte compiled).  @var{when} should be a string indicating when the variable "
"was first made obsolete (usually a version number string)."
msgstr ""

#. type: defun
#: functions.texi.orig:1649
msgid ""
"For instance, in old versions of Emacs the @code{sit-for} function accepted "
"three arguments, like this"
msgstr ""

#. type: example
#: functions.texi.orig:1652
#, no-wrap
msgid "  (sit-for seconds milliseconds nodisp)\n"
msgstr ""

#. type: defun
#: functions.texi.orig:1657
msgid ""
"However, calling @code{sit-for} this way is considered obsolete "
"(@pxref{Waiting}).  The old calling convention is deprecated like this:"
msgstr ""

#. type: example
#: functions.texi.orig:1661
#, no-wrap
msgid ""
"(set-advertised-calling-convention\n"
"  'sit-for '(seconds &optional nodisp) \"22.1\")\n"
msgstr ""

#. type: cindex
#: functions.texi.orig:1666
#, no-wrap
msgid "inline functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1673
msgid ""
"An @dfn{inline function} is a function that works just like an ordinary "
"function, except for one thing: when you byte-compile a call to the function "
"(@pxref{Byte Compilation}), the function's definition is expanded into the "
"caller.  To define an inline function, use @code{defsubst} instead of "
"@code{defun}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1674
#, no-wrap
msgid "defsubst name args [doc] [declare] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: functions.texi.orig:1677
msgid ""
"This macro defines an inline function.  Its syntax is exactly the same as "
"@code{defun} (@pxref{Defining Functions})."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1683
msgid ""
"Making a function inline often makes its function calls run faster.  But it "
"also has disadvantages.  For one thing, it reduces flexibility; if you "
"change the definition of the function, calls already inlined still use the "
"old definition until you recompile them."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1688
msgid ""
"Another disadvantage is that making a large function inline can increase the "
"size of compiled code both in files and in memory.  Since the speed "
"advantage of inline functions is greatest for small functions, you generally "
"should not make large functions inline."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1695
msgid ""
"Also, inline functions do not behave well with respect to debugging, "
"tracing, and advising (@pxref{Advising Functions}).  Since ease of debugging "
"and the flexibility of redefining functions are important features of Emacs, "
"you should not make a function inline, even if it's small, unless its speed "
"is really crucial, and you've timed the code to verify that using "
"@code{defun} actually has performance problems."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1705
msgid ""
"It's possible to define a macro to expand into the same code that an inline "
"function would execute (@pxref{Macros}).  But the macro would be limited to "
"direct use in expressions---a macro cannot be called with @code{apply}, "
"@code{mapcar} and so on.  Also, it takes some work to convert an ordinary "
"function into a macro.  To convert it into an inline function is easy; just "
"replace @code{defun} with @code{defsubst}.  Since each argument of an inline "
"function is evaluated exactly once, you needn't worry about how many times "
"the body uses the arguments, as you do for macros."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1708
msgid ""
"After an inline function is defined, its inline expansion can be performed "
"later on in the same file, just like macros."
msgstr ""

#. type: section
#: functions.texi.orig:1710
#, no-wrap
msgid "The @code{declare} Form"
msgstr ""

#. type: findex
#: functions.texi.orig:1711
#, no-wrap
msgid "declare"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1717
msgid ""
"@code{declare} is a special macro which can be used to add ``meta'' "
"properties to a function or macro: for example, marking it as obsolete, or "
"giving its forms a special @key{TAB} indentation convention in Emacs Lisp "
"mode."
msgstr ""

#. type: anchor{#1}
#: functions.texi.orig:1719
msgid "Definition of declare"
msgstr ""

#. type: defmac
#: functions.texi.orig:1719
#, no-wrap
msgid "declare specs@dots{}"
msgstr ""

#. type: defmac
#: functions.texi.orig:1728
msgid ""
"This macro ignores its arguments and evaluates to @code{nil}; it has no "
"run-time effect.  However, when a @code{declare} form occurs in the "
"@var{declare} argument of a @code{defun} or @code{defsubst} function "
"definition (@pxref{Defining Functions}) or a @code{defmacro} macro "
"definition (@pxref{Defining Macros}), it appends the properties specified by "
"@var{specs} to the function or macro.  This work is specially performed by "
"@code{defun}, @code{defsubst}, and @code{defmacro}."
msgstr ""

#. type: defmac
#: functions.texi.orig:1732
msgid ""
"Each element in @var{specs} should have the form @code{(@var{property} "
"@var{args}@dots{})}, which should not be quoted.  These have the following "
"effects:"
msgstr ""

#. type: item
#: functions.texi.orig:1734
#, no-wrap
msgid "(advertised-calling-convention @var{signature} @var{when})"
msgstr ""

#. type: table
#: functions.texi.orig:1739
msgid ""
"This acts like a call to @code{set-advertised-calling-convention} "
"(@pxref{Obsolete Functions}); @var{signature} specifies the correct argument "
"list for calling the function or macro, and @var{when} should be a string "
"indicating when the old argument list was first made obsolete."
msgstr ""

#. type: item
#: functions.texi.orig:1740
#, no-wrap
msgid "(debug @var{edebug-form-spec})"
msgstr ""

#. type: table
#: functions.texi.orig:1743
msgid ""
"This is valid for macros only.  When stepping through the macro with Edebug, "
"use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}."
msgstr ""

#. type: item
#: functions.texi.orig:1744
#, no-wrap
msgid "(doc-string @var{n})"
msgstr ""

#. type: table
#: functions.texi.orig:1749
msgid ""
"This is used when defining a function or macro which itself will be used to "
"define entities like functions, macros, or variables.  It indicates that the "
"@var{n}th argument, if any, should be considered as a documentation string."
msgstr ""

#. type: item
#: functions.texi.orig:1750
#, no-wrap
msgid "(indent @var{indent-spec})"
msgstr ""

#. type: table
#: functions.texi.orig:1754
msgid ""
"Indent calls to this function or macro according to @var{indent-spec}.  This "
"is typically used for macros, though it works for functions too.  "
"@xref{Indenting Macros}."
msgstr ""

#. type: item
#: functions.texi.orig:1755
#, no-wrap
msgid "(obsolete @var{current-name} @var{when})"
msgstr ""

#. type: table
#: functions.texi.orig:1763
msgid ""
"Mark the function or macro as obsolete, similar to a call to "
"@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name} "
"should be a symbol (in which case the warning message says to use that "
"instead), a string (specifying the warning message), or @code{nil} (in which "
"case the warning message gives no extra details).  @var{when} should be a "
"string indicating when the function or macro was first made obsolete."
msgstr ""

#. type: item
#: functions.texi.orig:1764
#, no-wrap
msgid "(compiler-macro @var{expander})"
msgstr ""

#. type: table
#: functions.texi.orig:1776
msgid ""
"This can only be used for functions, and tells the compiler to use "
"@var{expander} as an optimization function.  When encountering a call to the "
"function, of the form @code{(@var{function} @var{args}@dots{})}, the macro "
"expander will call @var{expander} with that form as well as with "
"@var{args}@dots{}, and @var{expander} can either return a new expression to "
"use instead of the function call, or it can return just the form unchanged, "
"to indicate that the function call should be left alone.  @var{expander} can "
"be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in "
"which case @var{arg} will hold the original function call expression, and "
"the (unevaluated) arguments to the function can be accessed using the "
"function's formal arguments."
msgstr ""

#. type: item
#: functions.texi.orig:1777
#, no-wrap
msgid "(gv-expander @var{expander})"
msgstr ""

#. type: table
#: functions.texi.orig:1783
msgid ""
"Declare @var{expander} to be the function to handle calls to the macro (or "
"function) as a generalized variable, similarly to "
"@code{gv-define-expander}.  @var{expander} can be a symbol or it can be of "
"the form @code{(lambda (@var{arg}) @var{body})} in which case that function "
"will additionally have access to the macro (or function)'s arguments."
msgstr ""

#. type: item
#: functions.texi.orig:1784
#, no-wrap
msgid "(gv-setter @var{setter})"
msgstr ""

#. type: table
#: functions.texi.orig:1791
msgid ""
"Declare @var{setter} to be the function to handle calls to the macro (or "
"function) as a generalized variable.  @var{setter} can be a symbol in which "
"case it will be passed to @code{gv-define-simple-setter}, or it can be of "
"the form @code{(lambda (@var{arg}) @var{body})} in which case that function "
"will additionally have access to the macro (or function)'s arguments and it "
"will passed to @code{gv-define-setter}."
msgstr ""

#. type: section
#: functions.texi.orig:1797
#, no-wrap
msgid "Telling the Compiler that a Function is Defined"
msgstr ""

#. type: cindex
#: functions.texi.orig:1798
#, no-wrap
msgid "function declaration"
msgstr ""

#. type: cindex
#: functions.texi.orig:1799
#, no-wrap
msgid "declaring functions"
msgstr ""

#. type: findex
#: functions.texi.orig:1800
#, no-wrap
msgid "declare-function"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1807
msgid ""
"Byte-compiling a file often produces warnings about functions that the "
"compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this "
"indicates a real problem, but usually the functions in question are defined "
"in other files which would be loaded if that code is run.  For example, "
"byte-compiling @file{fortran.el} used to warn:"
msgstr ""

#. type: example
#: functions.texi.orig:1812
#, no-wrap
msgid ""
"In end of data:\n"
"fortran.el:2152:1:Warning: the function `gud-find-c-expr' is not\n"
"    known to be defined.\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1821
msgid ""
"In fact, @code{gud-find-c-expr} is only used in the function that Fortran "
"mode uses for the local value of @code{gud-find-expr-function}, which is a "
"callback from GUD; if it is called, the GUD functions will be loaded.  When "
"you know that such a warning does not indicate a real problem, it is good to "
"suppress the warning.  That makes new warnings which might mean real "
"problems more visible.  You do that with @code{declare-function}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1824
msgid ""
"All you need to do is add a @code{declare-function} statement before the "
"first use of the function in question:"
msgstr ""

#. type: example
#: functions.texi.orig:1827
#, no-wrap
msgid "(declare-function gud-find-c-expr \"gud.el\" nil)\n"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1832
msgid ""
"This says that @code{gud-find-c-expr} is defined in @file{gud.el} (the "
"@samp{.el} can be omitted).  The compiler takes for granted that that file "
"really defines the function, and does not check."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1839
msgid ""
"The optional third argument specifies the argument list of "
"@code{gud-find-c-expr}.  In this case, it takes no arguments (@code{nil} is "
"different from not specifying a value).  In other cases, this might be "
"something like @code{(file &optional overwrite)}.  You don't have to specify "
"the argument list, but if you do the byte compiler can check that the calls "
"match the declaration."
msgstr ""

#. type: defmac
#: functions.texi.orig:1840
#, no-wrap
msgid "declare-function function file &optional arglist fileonly"
msgstr ""

#. type: defmac
#: functions.texi.orig:1845
msgid ""
"Tell the byte compiler to assume that @var{function} is defined, with "
"arguments @var{arglist}, and that the definition should come from the file "
"@var{file}.  @var{fileonly} non-@code{nil} means only check that @var{file} "
"exists, not that it actually defines @var{function}."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1852
msgid ""
"To verify that these functions really are declared where "
"@code{declare-function} says they are, use @code{check-declare-file} to "
"check all @code{declare-function} calls in one source file, or use "
"@code{check-declare-directory} check all the files in and under a certain "
"directory."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1857
msgid ""
"These commands find the file that ought to contain a function's definition "
"using @code{locate-library}; if that finds no file, they expand the "
"definition file name relative to the directory of the file that contains the "
"@code{declare-function} call."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1862
msgid ""
"You can also say that a function is a primitive by specifying a file name "
"ending in @samp{.c} or @samp{.m}.  This is useful only when you call a "
"primitive that is defined only on certain systems.  Most primitives are "
"always defined, so they will never give you a warning."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1867
msgid ""
"Sometimes a file will optionally use functions from an external package.  If "
"you prefix the filename in the @code{declare-function} statement with "
"@samp{ext:}, then it will be checked if it is found, otherwise skipped "
"without error."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1876
msgid ""
"There are some function definitions that @samp{check-declare} does not "
"understand (e.g., @code{defstruct} and some other macros).  In such cases, "
"you can pass a non-@code{nil} @var{fileonly} argument to "
"@code{declare-function}, meaning to only check that the file exists, not "
"that it actually defines the function.  Note that to do this without having "
"to specify an argument list, you should set the @var{arglist} argument to "
"@code{t} (because @code{nil} means an empty argument list, as opposed to an "
"unspecified one)."
msgstr ""

#. type: section
#: functions.texi.orig:1878
#, no-wrap
msgid "Determining whether a Function is Safe to Call"
msgstr ""

#. type: cindex
#: functions.texi.orig:1879
#, no-wrap
msgid "function safety"
msgstr ""

#. type: cindex
#: functions.texi.orig:1880
#, no-wrap
msgid "safety of functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1888
msgid ""
"Some major modes, such as SES, call functions that are stored in user "
"files.  (@inforef{Top, ,ses}, for more information on SES@.)  User files "
"sometimes have poor pedigrees---you can get a spreadsheet from someone "
"you've just met, or you can get one through email from someone you've never "
"met.  So it is risky to call a function whose source code is stored in a "
"user file until you have determined that it is safe."
msgstr ""

#. type: defun
#: functions.texi.orig:1889
#, no-wrap
msgid "unsafep form &optional unsafep-vars"
msgstr ""

#. type: defun
#: functions.texi.orig:1896
msgid ""
"Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or returns "
"a list that describes why it might be unsafe.  The argument "
"@var{unsafep-vars} is a list of symbols known to have temporary bindings at "
"this point; it is mainly used for internal recursive calls.  The current "
"buffer is an implicit argument, which provides a list of buffer-local "
"bindings."
msgstr ""

#. type: Plain text
#: functions.texi.orig:1907
msgid ""
"Being quick and simple, @code{unsafep} does a very light analysis and "
"rejects many Lisp expressions that are actually safe.  There are no known "
"cases where @code{unsafep} returns @code{nil} for an unsafe expression.  "
"However, a ``safe'' Lisp expression can return a string with a "
"@code{display} property, containing an associated Lisp expression to be "
"executed after the string is inserted into a buffer.  This associated "
"expression can be a virus.  In order to be safe, you must delete properties "
"from all strings calculated by user code before inserting them into buffers."
msgstr ""

#. type: item
#: functions.texi.orig:1915
#, no-wrap
msgid "Safe expression"
msgstr ""

#. type: itemize
#: functions.texi.orig:1919
#, no-wrap
msgid "An atom or quoted thing.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1922
#, no-wrap
msgid ""
"A call to a safe function (see below), if all its arguments are\n"
"safe expressions.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1927
#, no-wrap
msgid ""
"One of the special forms @code{and}, @code{catch}, @code{cond},\n"
"@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},\n"
"@code{while}, and @code{unwind-protect}], if all its arguments are\n"
"safe.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1932
#, no-wrap
msgid ""
"A form that creates temporary bindings (@code{condition-case},\n"
"@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or\n"
"@code{let*}), if all args are safe and the symbols to be bound are not\n"
"explicitly risky (see @pxref{File Local Variables}).\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1937
#, no-wrap
msgid ""
"An assignment using @code{add-to-list}, @code{setq}, @code{push}, or\n"
"@code{pop}, if all args are safe and the symbols to be assigned are\n"
"not explicitly risky and they already have temporary or buffer-local\n"
"bindings.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1940
#, no-wrap
msgid ""
"One of [apply, mapc, mapcar, mapconcat] if the first argument is a\n"
"safe explicit lambda and the other args are safe expressions.\n"
msgstr ""

#. type: item
#: functions.texi.orig:1942
#, no-wrap
msgid "Safe function"
msgstr ""

#. type: itemize
#: functions.texi.orig:1946
#, no-wrap
msgid "A lambda containing safe expressions.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1948
#, no-wrap
msgid "A symbol on the list @code{safe-functions}, so the user says it's safe.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1950
#, no-wrap
msgid "A symbol with a non-@code{nil} @code{side-effect-free} property.\n"
msgstr ""

#. type: itemize
#: functions.texi.orig:1955
#, no-wrap
msgid ""
"A symbol with a non-@code{nil} @code{safe-function} property.  The\n"
"value @code{t} indicates a function that is safe but has innocuous\n"
"side effects.  Other values will someday indicate functions with\n"
"classes of side effects that are not always safe.\n"
msgstr ""

#. type: table
#: functions.texi.orig:1961
#, no-wrap
msgid ""
"The @code{side-effect-free} and @code{safe-function} properties are\n"
"provided for built-in functions and for low-level functions and macros\n"
"defined in @file{subr.el}.  You can assign these properties for the\n"
"functions you write.\n"
msgstr ""

#. type: section
#: functions.texi.orig:1965
#, no-wrap
msgid "Other Topics Related to Functions"
msgstr ""

#. type: Plain text
#: functions.texi.orig:1970
msgid ""
"Here is a table of several functions that do things related to function "
"calling and function definitions.  They are documented elsewhere, but we "
"provide cross references here."
msgstr ""

#. type: item
#: functions.texi.orig:1972
#, no-wrap
msgid "apply"
msgstr ""

#. type: table
#: functions.texi.orig:1974 functions.texi.orig:1995 functions.texi.orig:2001
msgid "See @ref{Calling Functions}."
msgstr ""

#. type: item
#: functions.texi.orig:1975
#, no-wrap
msgid "autoload"
msgstr ""

#. type: table
#: functions.texi.orig:1977
msgid "See @ref{Autoload}."
msgstr ""

#. type: item
#: functions.texi.orig:1978
#, no-wrap
msgid "call-interactively"
msgstr ""

#. type: table
#: functions.texi.orig:1980 functions.texi.orig:1986
msgid "See @ref{Interactive Call}."
msgstr ""

#. type: item
#: functions.texi.orig:1981
#, no-wrap
msgid "called-interactively-p"
msgstr ""

#. type: table
#: functions.texi.orig:1983 functions.texi.orig:2010
msgid "See @ref{Distinguish Interactive}."
msgstr ""

#. type: item
#: functions.texi.orig:1984
#, no-wrap
msgid "commandp"
msgstr ""

#. type: item
#: functions.texi.orig:1987
#, no-wrap
msgid "documentation"
msgstr ""

#. type: table
#: functions.texi.orig:1989
msgid "See @ref{Accessing Documentation}."
msgstr ""

#. type: item
#: functions.texi.orig:1990
#, no-wrap
msgid "eval"
msgstr ""

#. type: table
#: functions.texi.orig:1992
msgid "See @ref{Eval}."
msgstr ""

#. type: item
#: functions.texi.orig:1993
#, no-wrap
msgid "funcall"
msgstr ""

#. type: item
#: functions.texi.orig:1996
#, no-wrap
msgid "function"
msgstr ""

#. type: table
#: functions.texi.orig:1998
msgid "See @ref{Anonymous Functions}."
msgstr ""

#. type: item
#: functions.texi.orig:1999
#, no-wrap
msgid "ignore"
msgstr ""

#. type: item
#: functions.texi.orig:2002
#, no-wrap
msgid "indirect-function"
msgstr ""

#. type: table
#: functions.texi.orig:2004
msgid "See @ref{Function Indirection}."
msgstr ""

#. type: item
#: functions.texi.orig:2005
#, no-wrap
msgid "interactive"
msgstr ""

#. type: table
#: functions.texi.orig:2007
msgid "See @ref{Using Interactive}."
msgstr ""

#. type: item
#: functions.texi.orig:2008
#, no-wrap
msgid "interactive-p"
msgstr ""

#. type: item
#: functions.texi.orig:2011
#, no-wrap
msgid "mapatoms"
msgstr ""

#. type: table
#: functions.texi.orig:2013
msgid "See @ref{Creating Symbols}."
msgstr ""

#. type: item
#: functions.texi.orig:2014
#, no-wrap
msgid "mapcar"
msgstr ""

#. type: table
#: functions.texi.orig:2016 functions.texi.orig:2022
msgid "See @ref{Mapping Functions}."
msgstr ""

#. type: item
#: functions.texi.orig:2017
#, no-wrap
msgid "map-char-table"
msgstr ""

#. type: table
#: functions.texi.orig:2019
msgid "See @ref{Char-Tables}."
msgstr ""

#. type: item
#: functions.texi.orig:2020
#, no-wrap
msgid "mapconcat"
msgstr ""

#. type: item
#: functions.texi.orig:2023
#, no-wrap
msgid "undefined"
msgstr ""

#. type: table
#: functions.texi.orig:2025
msgid "See @ref{Functions for Key Lookup}."
msgstr ""
