@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Keymaps
@chapter Keymaps
@cindex keymap

  入力イベントのコマンドバインディングは、@dfn{キーマップ(keymap)}と呼ばれるデータ構造に記録されます。キーマップ内の各エントリーは個別のイベント型(他のキーマップ、またはコマンド)に関連づけ(または@dfn{バインド})されます。イベント型がキーマップにバインドされる場合、そのキーマップは次の入力イベントを調べるために使用されます。これはコマンドが見つかるまで継続されます。このプロセス全体を@dfn{キールックアップ(key
lookup: キー照合)}と呼びます。

@menu
* Key Sequences::            Lispオブジェクトとしてのキーシーケンス。
* Keymap Basics::            キーマップの基本概念。
* Format of Keymaps::        キーマップはLispオブジェクトとしてどのように見えるか。
* Creating Keymaps::         キーマップを作成、コピーする関数。
* Inheritance and Keymaps::  キーマップが他のキーマップのバインディングを継承する方法。
* Prefix Keys::              キーマップの定義としてキーを定義する。
* Active Keymaps::           Emacsがアクティブなキーマップでキーバインディングを探す方法。
* Searching Keymaps::        アクティブなマップ検索のLisp処理概要。
* Controlling Active Maps::  各バッファーは標準(グローバル)のバインディングをオーバーライドするためのキーマップをもつ。マイナーマイナーもそれらをオーバーライドできる。
* Key Lookup::               1つのキーマップからあえうキーのバインディングを探す。
* Functions for Key Lookup::  キールックアップを要求する方法。
* Changing Key Bindings::    キーマップ内でのキーの再定義。
* Remapping Commands::       キーマップはあるコマンドを他のコマンドに変換できる。
* Translation Keymaps::      イベントシーケンスを変換するキーマップ。
* Key Binding Commands::     キーの再定義にたいするインタラクティブなインターフェイス。
* Scanning Keymaps::         ヘルプをプリントするためにすべてのキーマップを走査する。
* Menu Keymaps::             キーマップとしてキーマップを定義する。
@end menu

@node Key Sequences
@section Key Sequences
@cindex key
@cindex keystroke
@cindex key sequence

  @dfn{キーシーケンス(key
sequence)}、短くは@dfn{キー(key)}とは、1つの単位を形成する1つ以上の入力イベントのシーケンスです。入力イベントには文字、ファンクションキー、マウスアクション、または@code{iconify-frame}のようなEmacs外部のシステムイベントが含まれます(@ref{Input
Events}を参照)。キーシーケンスにたいするEmacs
Lispの表現は文字列かベクターです。特に明記しない限り、引数としてキーシーケンスを受け取るEmacs
Lisp関数は両方の表現を処理することができます。

  文字列表現では、たとえば、@code{"a"}は@kbd{a}、@code{"2"}は@kbd{2}を表すといったように、英数字はその文字自身を意味します。コントロール文字イベントは部分文字列@code{"\C-"}、メタ文字は@code{"\M-"}によりプレフィクスされます。たとえば@code{"\C-x"}はキー@kbd{C-x}を表します。それらに加えて、@key{TAB}、@key{RET}、@key{ESC}、@key{DEL}などのイベントはそれぞれ@code{"\t"}、@code{"\r"}、@code{"\e"}、@code{"\d"}で表されます。複雑なキーシーケンスの文字列表現は、イベント成分の文字列表現を結合したものです。したがって@code{"\C-xl"}はキーシーケンス@kbd{C-x
l}を表します。

  キーシーケンスにはファンクションキー、マウスボタンイベント、システムイベント、または@kbd{C-=}や@kbd{H-a}のような文字列で表現できない非@acronym{ASCII}文字が含まれます。これらはベクターとして表現される必要があります。

  ベクター表現ではベクターの各要素は1つの入力イベントをイベントのLisp形式で表します。@ref{Input
Events}を参照してください。たとえば、ベクター@code{[?\C-x ?l]}はキーシーケンス@kbd{C-x l}を表します。

  キーシーケンスを文字列やベクターによる表現で記述する例は、@ref{Init Rebinding,,, emacs, The GNU Emacs
Manual}を参照してください。

@defun kbd keyseq-text
この関数はテキスト@var{keyseq-text}(文字列定数)をキーシーケンス(文字列かベクターの定数)に変換する。@var{keyseq-text}の内容は@kbd{C-x
C-k @key{RET}}(@code{kmacro-edit-macro})
コマンドにより呼び出されたバッファー内と同じ構文を使用するべきであ特にファンクションキーの名前は@samp{<@dots{}>}で囲まなければならない。@ref{Edit
Keyboard Macro,,, emacs, The GNU Emacs Manual}を参照のこと。

@example
(kbd "C-x") @result{} "\C-x"
(kbd "C-x C-f") @result{} "\C-x\C-f"
(kbd "C-x 4 C-f") @result{} "\C-x4\C-f"
(kbd "X") @result{} "X"
(kbd "RET") @result{} "\^M"
(kbd "C-c SPC") @result{} "\C-c@ "
(kbd "<f1> SPC") @result{} [f1 32]
(kbd "C-M-<down>") @result{} [C-M-down]
@end example
@end defun

@node Keymap Basics
@section Keymap Basics
@cindex key binding
@cindex binding of a key
@cindex complete key
@cindex undefined key

  キーマップは、さまざまなキーシーケンスにたいして@dfn{キーバインディング(key binding)}を指定するLispデータ構造です。

  1つのキーマップが、個々のイベントにたいする定義を直接指定します。
A single keymap directly specifies definitions for individual events.
単一のイベントでキーシーケンスが構成されるとき、そのキーシーケンスのキーマップ内でのバインディングは、そのイベントにたいするそのキーマップの定義です。それより長いキーシーケンスのバインディングは対話的プロセスにより見つけ出されます。まず、最初のイベント(これ自身がキーマップでなければならない)の定義を探します。次にそのキーマップ内で2つ目のイベントを探すといったように、そのキーシーケンス内のすべてのイベントが処理されるまで、これを続けます。

  あるキーシーケンスのバインディングがキーマップであるような場合、わたしたちはそのキーシーケンスを@dfn{プレフィクスキー(prefix
key)}と呼び、それ以外の場合は(それ以上イベントを追加できないので)@dfn{コンプリートキー(complete
keyl}と呼んでいます。バインディングが@code{nil}の場合、わたしたちはそのキーを@dfn{未定義(undefined)}と呼びます。@kbd{C-c}、@kbd{C-x}、@kbd{C-x
4}などはプレフィクスキーの例です。@kbd{X}、@key{RET}、@kbd{C-x 4
C-f}などは定義されたコンプリートキーの例です。@kbd{C-x C-g}や@kbd{C-c
3}などは未定義なコンプリートキーの例です。詳細は@ref{Prefix Keys}を参照してください。

  キーシーケンスのバインディングを見つけ出すルールは、(最後のイベントの前までに見つかる)中間的なバインディングがすべてキーマップであると仮定します。もしそうでなければ、そのイベントシーケンスは単位を形成せず、実際の単一キーシーケンスではありません。他の言い方をすると、任意の有効なキーシーケンスから1つ以上のイベントを取り除くと、常にプレフィクスキーにならなければなりません。たとえば@kbd{C-f
C-n}はキーシーケンスではありません。@kbd{C-f}はプレフィクスキーではないので、@kbd{C-f}で始まるこれより長いシーケンスは、キーシーケンスであり得ないのです。

  利用可能な複数イベントキーシーケンスのセットは、プレフィクスキーにたいするバインディングに依存します。したがって、これはキーマップが異なれば異なるかもしれず、バインディングが変更されたとき変更されるかもしれません。しかし、単一イベントキーシーケンスは適格性において任意のプレフィクスキーに依存しないので、常に単一のキーシーケンスです。

  常に複数のプライマリーキーマップ(primary keymap:
主キーマップ)がアクティブであり、これらはキーバインディングを見つけるために使用されます。すべてのバッファーで共有される@dfn{グローバルキーマップ(global
map)}というキーマップが存在します。@dfn{ローカルキーマップ(local
keymap)}は通常、特定のメジャーモードに関連します。そして0個以上の@dfn{マイナーモードキーマップ(minor mode
keymap)}はカレントで有効なマイナーモードに属します(すべてのマイナーモードがキーマップをもつわけでなない)。ローカルキーマップは、対応するグローバルバインディングをshadow(優先される)します。マイナーモードキーマップは、ローカルキーマップとグローバルキーマップの両方をshadowします。詳細は、@ref{Active
Keymaps}を参照してください。

@node Format of Keymaps
@section Format of Keymaps
@cindex format of keymaps
@cindex keymap format
@cindex full keymap
@cindex sparse keymap

  キーマップはそれぞれ、@sc{car}がシンボル@code{keymap}であるようなリストです。このリストの残りの要素は、そのキーマップのキーバインディングを定義します。関数定義がキーマップであるようなシンボルもキーマップです。あるオブジェクトがキーマップかどうかテストするには、関数@code{keymapp}(以下参照)を使用してください。

  キーマップを開始するシンボル@code{keymap}の後には、いくつかの種類の要素が出現します:

@table @code
@item (@var{type} .@: @var{binding})
これは型@var{type}のイベントにたいする1つのバインディングを指定する。通常のバインディングはそれぞれ、常に文字かシンボルであるような特定の@dfn{イベント型(event
type)}のイベントに適用される。@ref{Classifying
Events}を参照のこと。この種のバインディングでは、@var{binding}はコマンドである。

@item (@var{type} @var{item-name} .@: @var{binding})
これは、メニュー内で@var{item-name}として表示されるシンプルなメニューアイテムでもあるようなバインディングを指定する。@ref{Simple
Menu Items}を参照のこと。

@item (@var{type} @var{item-name} @var{help-string} .@: @var{binding})
これは、ヘルプ文字列@var{help-string}のシンプルなメニューアイテムである。

@item (@var{type} menu-item .@: @var{details})
これは、拡張されたメニューアイテムでもあるようなバインディングを指定する。これは他の機能も使用できる。@ref{Extended Menu
Items}を参照のこと。

@item (t .@: @var{binding})
@cindex default key binding
これは@dfn{デフォルトキーバインディング(default key
binding)}を指定する。キーマップの他の要素でバインドされないイベントは、バインディングとして@var{binding}が与えられる。デフォルトバインディングにより、利用可能なすべてのイベント型を列挙することなくバインドできる。デフォルトバインディングをもつキーマップは、明示的に@code{nil}にバインドされるイベント(以下参照)を除き、より低い優先度にあるすべてのキーマップをマスクする。

@item @var{char-table}
キーマップのある要素が文字テーブル(char-table)の場合、それは修飾ビットなしのすべての文字イベントにたいするバインディングを保持するとみなされる。
If an element of a keymap is a it counts as holding bindings for all
character events with no modifier bits (@pxref{modifier bits}):
要素@var{n}は、コード@var{n}の文字にたいするバインディングである。これは多量のバインディングを記録するための、コンパクトな方法である。そのような文字テーブルのキーマップは、@dfn{fullキーマップ(full
keymap: 完全なキーマップ)}と呼ばれる。それにたいし他のキーマップは@dfn{sparseキーマップ(sparse keymaps:
疎なキーマップ)}と呼ばれる。

@item @var{string}
@cindex keymap prompt string
@cindex overall prompt string
@cindex prompt string of keymap
キーにたいするバインディングを指定する要素は別として、キーマップは要素として文字列ももつことができる。これは@dfn{overallプロンプト文字列(overall
prompt string: 全般的なプロンプト文字列)}と呼ばれ、メニューとしてキーマップを使用することを可能にする。@ref{Defining
Menus}を参照のこと。

@item (keymap @dots{})
キーマップのある要素それ自身がキーマップの場合、それは外側のキーマップ内でこれが内側のキーマップとしてinline指定されているかのようにみなされる。これは@code{make-composed-keymap}内で行なわれるような多重継承にたいして使用される。
@end table

バインディングが@code{nil}の場合、それは定義の構成要素ではありませんが、デフォルトバインディングや親キーマップ内のバインディングに優先されます。一方、@code{nil}のバインディングは、より低い優先度のキーマップを@emph{オーバーライドしません}したがって、ローカルマップで@code{nil}のバインディングが与えられた場合、Emacsはグローバルマップのバインディングを使用します。

@cindex meta characters lookup
  キーマップはメタ文字にたいするバインディングを直接記録しません。かわりに、メタ文字は１文字目が@key{ESC}(または何であれ@code{meta-prefix-char}のカレント値)の、2文字のキーシーケンスをルックアップするものとみなされます。したがって、キー@kbd{M-a}は内部的に@kbd{@key{ESC}
a}で表され、そのグローバルバインディングは、@code{esc-map}内の@kbd{a}にたいするスロットで見つけることができます(@ref{Prefix
Keys}を参照)。

  この変換は文字にたいしてのみ適用され、ファンクションキーや他の入力イベントには適用されないので、@kbd{M-@key{end}}は@kbd{@key{ESC}
@key{end}}と何も関係ありません。

  以下に例としてLispモードにたいするローカルキーマップ(sparseキーマップ)を挙げます。以下では@key{DEL}、@kbd{C-c
C-z}、@kbd{C-M-q}、@kbd{C-M-x}にたいするバインディングを定義しています(実際の値はメニューバインディングも含みますが、簡潔にするためここでは省略しています)。

@example
@group
lisp-mode-map
@result{}
@end group
@group
(keymap
 (3 keymap
    ;; @kbd{C-c C-z}
    (26 . run-lisp))
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-x}は@kbd{@key{ESC} C-x}として扱われる}
     (24 . lisp-send-defun))
@end group
@group
 ;; @r{この部分は@code{lisp-mode-shared-map}から継承}
 keymap
 ;; @key{DEL}
 (127 . backward-delete-char-untabify)
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-q}は@kbd{@key{ESC} C-q}として扱われる}
     (17 . indent-sexp)))
@end group
@end example

@defun keymapp object
この関数は、@var{object}がキーマップなら@code{t}、それ以外は@code{nil}をリターンする。より正確には、この関数はリストにたいしてその@sc{car}が@code{keymap}か、あるいはシンボルにたいしてその関数定義が@code{keymapp}かをテストする。

@example
@group
(keymapp '(keymap))
    @result{} t
@end group
@group
(fset 'foo '(keymap))
(keymapp 'foo)
    @result{} t
@end group
@group
(keymapp (current-global-map))
    @result{} t
@end group
@end example
@end defun

@node Creating Keymaps
@section Creating Keymaps
@cindex creating keymaps

  以下はキーマップを作成する関数です。

@defun make-sparse-keymap &optional prompt
この関数はエントリーをもたない新たなsparseキーマップを作成して、それをリターンする(sparseキーマップは、あなたが通常望む類のキーマップのこと)。@code{make-keymap}とは異なり、新たなキーマップは文字テーブルを含まず、何のイベントもバインドしない。

@example
@group
(make-sparse-keymap)
    @result{} (keymap)
@end group
@end example

@var{prompt}を指定した場合、それはキーマップにたいするoverallプロンプト文字列になる。これはメニューキーマップ(@ref{Defining
Menus}を参照)にたいしてのみ指定すべきである。overallプロンプト文字列をともなうキーマップがアクティブな場合は、次の入力イベントのルックアップにたいしてマウスメニューとキーボードメニューを常に提示する。これはコマンドループにたいして毎回キーボードメニューを提示するので、overallプロンプト文字列をメインマップ、メジャーモードマップ、マイナーモードマップに指定しないこと。
@end defun

@defun make-keymap &optional prompt
この関数は、新たなfullキーマップを作成して、それをリターンする。このキーマップは修飾されないすべての文字にたいするスロットをもつ文字テーブル(@ref{Char-Tables}を参照)を含む。この新たなキーマップは、初期状態ではすべての文字、およびその他の種類のイベントが@code{nil}にバインドされている。引数@var{prompt}は、@code{make-sparse-keymap}のようにプロンプト文字列を指定する。

@c This example seems kind of pointless, but I guess it serves
@c to contrast the result with make-sparse-keymap above.
@example
@group
(make-keymap)
    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])
@end group
@end example

fullキーマップは、多くのスロットを保持するときはsparseキーマップより効果的であり、少ししかスロットを保持しないときはsparseキーマップのほうが適している。
@end defun

@defun copy-keymap keymap
@c Emacs 19 feature
この関数は、@var{keymap}のコピーをリターンする。@var{keymap}内でバインディングとして直接出現するすべてのキーマップも、すべてのレベルまで再帰的にコピーされる。しかし、ある文字の定義が関数定義にキーマップをもつ関数のときは、再帰的なコピーは行われず、新たにコピーされたキーマップには同じシンボルがコピーされる。

@example
@group
(setq map (copy-keymap (current-local-map)))
@result{} (keymap
@end group
@group
     ;; @r{(これはメタ文字を実装する)}
     (27 keymap
         (83 . center-paragraph)
         (115 . center-line))
     (9 . tab-to-tab-stop))
@end group

@group
(eq map (current-local-map))
    @result{} nil
@end group
@group
(equal map (current-local-map))
    @result{} t
@end group
@end example
@end defun

@node Inheritance and Keymaps
@section Inheritance and Keymaps
@cindex keymap inheritance
@cindex inheritance, keymap

  キーマップは、他のキーマップを継承することができ、この継承元のキーマップを@dfn{親キーマップ(parent
keymap)}と呼びます。そのようなキーマップは、以下のようなキーマップです:

@example
(keymap @var{elements}@dots{} . @var{parent-keymap})
@end example

@noindent
これの効果は、このキーマップがキールックアップ時に@var{parent-keymap}のすべてのバインディングを継承するが、それらにバインディングを追加したり、@var{elements}でオーバーライドできるということです。

@code{define-key}や他のキーバインディング関数を使用して@var{parent-keymap}内のバインディングを変更した場合、変更されたバインディングは@var{elements}で作られたバインディングにshadowされない限り、継承されたキーマップ内で可視になります。逆は真ではありません。@code{define-key}を使用して継承されたキーマップ内のバインディングを変更した場合、これらの変更は@var{elements}内に記録されますが、@var{parent-keymap}に影響はありません。

親キーマップからキーマップを構築するには、@code{set-keymap-parent}を使用するのが正しい方法です。親キーマップから直接キーマップを構築するコードがある場合は、かわりに@code{set-keymap-parent}を使用するようにプログラムを変更してください。

@defun keymap-parent keymap
これは、@var{keymap}の親キーマップをリターンする。@var{keymap}に親キーマップがない場合、@code{keymap-parent}は@code{nil}をリターンする。
@end defun

@defun set-keymap-parent keymap parent
これは@var{keymap}の親キーマップを@var{parent}にセットして、@var{parent}をリターンする。@var{parent}が@code{nil}の場合、この関数は@var{keymap}に親キーマップを与えない。

@var{keymap}がサブマップ(プレフィクスキーにたいするバインディング)をもつ場合は、それらも新たな親キーマップを受け取り、それらのプレフィクスキーにたいして@var{parent}が何を指定するかが反映される。
@end defun

   以下は@code{text-mode-map}から継承してキーマップを作成する方法を示す例です:

@example
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  map)
@end example

  非sparseキーマップも親キーマップをもつことができますが、便利とは言えません。非sparseキーマップは、修飾ビットをもたないすべての数値文字コードにたいするバインディングとして、たとえそれが@code{nil}であっても常に何かを指定するので、これらの文字のバインディングが親キーマップから継承されることは決してないのです。

@cindex keymap inheritance from multiple maps
  複数のマップからキーマップを継承したいときがあるかもしれません。これにたいしては、関数@code{make-composed-keymap}が使用できます。

@defun make-composed-keymap maps &optional parent
この関数は、既存のキーマップから構成される新たなキーマップをリターンする。また、オプションで親キーマップ@var{parent}から継承する。@var{maps}には単一のキーマップ、または複数のキーマップのリストを指定できる。リターンされた新たなマップ内でキーをルックアップするとき、Emacsは@var{maps}内のキーマップを順に検索してから@var{parent}内を検索する。この検索は最初のマッチで停止される。@var{maps}のどれか1つのキーマップ内の@code{nil}バインディングは、@var{parent}内の任意のバインディングをオーバーライドするが、@var{maps}にないキーマップの非@code{nil}バインディングはオーバーライドしない。
@end defun

@noindent For example, here is how Emacs sets the parent of
【FIXME】たとえば、以下は@code{button-buffer-map}と@code{special-mode-map}の両方を継承する@code{help-mode-map}のようなキーマップの親キーマップをEmacsがセットする方法です:

@example
(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map
      (make-composed-keymap button-buffer-map special-mode-map))
    ... map) ... )
@end example


@node Prefix Keys
@section Prefix Keys
@cindex prefix key

  @dfn{プレフィクスキー(prefix
key)}とは、バインディングがキーマップであるようなキーシーケンスです。このキーマップは、プレフィクスキーを拡張するキーシーケンスが何を行うか定義します。たとえば、@kbd{C-x}はプレフィクスキーであり、これはキーマップを使用し、そのキーマップは変数@code{ctl-x-map}にも格納されています。このキーマップは@kbd{C-x}で始まるキーシーケンスにたいするバインディングを定義します。

  標準的なEmacsのプレフィクスキーのいくつかは、Lisp変数でも見い出すことができるキーマップを使用していますl:

@itemize @bullet
@item
@vindex esc-map
@findex ESC-prefix
@code{esc-map}は、プレフィクスキー@key{ESC}にたいするグローバルキーマップである。したがって、すべてのメタ文字にたいする定義は、このキーマップで見つけることができる。このマップは、@code{ESC-prefix}の関数定義でもある。

@item
@cindex @kbd{C-h}
@code{help-map}は、プレフィクスキー@kbd{C-h}にたいするグローバルキーマップである。

@item
@cindex @kbd{C-c}
@vindex mode-specific-map
@code{mode-specific-map}は、プレフィクスキー@kbd{C-c}にたいするグローバルキーマップである。このマップは実際にはモード特有(mode-specific)ではなくグローバルであるが、このプレフィクスキーは主にモード特有なバインディングに使用されるので、@kbd{C-h
b}(@code{display-bindings})の出力内の@kbd{C-c}に関する情報で、この名前は有意義な情報を提供する。

@item
@cindex @kbd{C-x}
@vindex ctl-x-map
@findex Control-X-prefix
@code{ctl-x-map}は、プレフィクスキー@kbd{C-x}にたいして使用されるグローバルキーマップである。このマップは、シンボル@code{Control-X-prefix}の関数セルを通して見つけることができる。

@item
@cindex @kbd{C-x @key{RET}}
@vindex mule-keymap
@code{mule-keymap}は、プレフィクスキー@kbd{C-x @key{RET}} にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 4}
@vindex ctl-x-4-map
@code{ctl-x-4-map}は、プレフィクスキー@kbd{C-x 4}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 5}
@vindex ctl-x-5-map
@code{ctl-x-5-map}は、プレフィクスキー@kbd{C-x 5}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 6}
@vindex 2C-mode-map
@code{2C-mode-map}は、プレフィクスキー@kbd{C-x 6}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x v}
@vindex vc-prefix-map
@code{vc-prefix-map}は、プレフィクスキー@kbd{C-x v}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-g}
@vindex goto-map
@code{goto-map}は、プレフィクスキー@kbd{M-g}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-s}
@vindex search-map
@code{search-map}は、プレフィクスキー@kbd{M-s}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-o}
@vindex facemenu-keymap
@code{facemenu-keymap}は、プレフィクスキー@kbd{M-o}にたいして使用されるグローバルキーマップである。

@item
Emacsの他のプレフィクスキーには@kbd{C-x @@}、@kbd{C-x a i}、@kbd{C-x
@key{ESC}}、@kbd{@key{ESC} @key{ESC}}がある。これらは、特別な名前をもたないキーマップを使用する。
@end itemize

  プレフィクスキーのキーマップバインディングは、プレフィクスキーに続くイベントをルックアップするために使用されます。(これは、関数定義がキーマップであるようなシンボルかもしれません。効果は同じですが、シンボルはプレフィクスキーにたいする名前の役割を果たします。)
したがって、@kbd{C-x}のバインディングはシンボル@code{Control-X-prefix}であり、このシンボルの関数セルが@kbd{C-x}コマンドにたいするキーマップを保持します(@code{ctl-x-map}の値も同じキーマップです)。

  プレフィクスキー定義は、任意のアクティブなキーマップ内に置くことができます。プレフィクスキーとしての@kbd{C-c}、@kbd{C-x}、@kbd{C-h}、@key{ESC}の定義はグローバルマップ内にもあるので、これらのプレフィクスキーは常に使用できます。メジャーモードとマイナーモードは、ローカルマップやマイナーモードのマップ内にプレフィクスキー定義を置くことにより、キーをプレフィクスキーとして再定義できます。
@ref{Active Keymaps}を参照してください。

  あるキーが複数のアクティブなマップ内でプレフィクスキーとして定義されている場合、それぞれの定義がマージされて効果をもちます。まずマイナーモードキーマップ内で定義されたコマンド、次にローカルマップのプレフィクス定義されたコマンド、そしてグローバルマップのコマンドが続きます。

  以下の例では、ローカルキーマップ内で@kbd{C-p}を@kbd{C-x}と等価なプレフィクスキーにしています。すると、@kbd{C-p
C-f}にたいするバインディングは、@kbd{C-x C-f}と同様に関数@code{find-file}になります。キーシーケンス@kbd{C-p
6}は、すべてのアクティブなキーマップで見つけることができません。

@example
@group
(use-local-map (make-sparse-keymap))
    @result{} nil
@end group
@group
(local-set-key "\C-p" ctl-x-map)
    @result{} nil
@end group
@group
(key-binding "\C-p\C-f")
    @result{} find-file
@end group

@group
(key-binding "\C-p6")
    @result{} nil
@end group
@end example

@defun define-prefix-command symbol &optional mapvar prompt
@cindex prefix command
@anchor{Definition of define-prefix-command}
この関数は、プレフィクスキーのバインディングとして使用するために、@var{symbol}を用意する。これはsparseキーマップを作成して、それを@var{symbol}の関数定義として格納する。その後は@var{symbol}にキーシーケンスをバインディングすると、そのキーシーケンスはプレフィクスキーになるだろう。リターン値は@code{symbol}である。

この関数は、値がそのキーマップであるような変数としても@var{symbol}をセットする。しかし@var{mapvar}が非@code{nil}の場合は、かわりに@var{mapvar}を変数としてセットする。

@var{prompt}が非@code{nil}の場合、これはそのキーマップにたいするoverallプロンプト文字列になる。プロンプト文字列はメニューキーマップにたいして与えられるべきである(@ref{Defining
Menus}を参照)。
@end defun

@node Active Keymaps
@section Active Keymaps
@cindex active keymap

  Emacsは多くのキーマップを含んでいますが、常にいくつかのキーマップだけが@dfn{アクティブ}です。Emacsがユーザー入力を受け取ったとき、それは入力イベントに変換されて(@ref{Translation
Keymaps}を参照)、アクティブなキーマップ内でキーバインディングが照合されます。

  アクティブなキーマップは通常、(1) @code{keymap}プロパティにより指定されるキーマップ、(2) 有効なマイナーモードのキーマップ、(3)
カレントバッファーのローカルキーマップ、(4)
グローバルキーマップの順です。Emacsは入力キーシーケンスそれぞれにたいして、これらすべてのキーマップ内を検索します。

  これらの``通常''のキーマップのうち最優先されるのは、もしあればポイント位置の@code{keymap}テキストにより指定されるキーマップ、またはoverallプロパティです。(マウス入力イベントにたいしては、Emacsはポイント位置のかわりにイベント位置を使用する。
@iftex
詳細は次のセクションを参照のこと。)
@end iftex
@ifnottex
@ref{Searching Keymaps}を参照のこと。)
@end ifnottex

  次に優先されるのは、有効なマイナーモードにより指定されるキーマップです。もしあれば、これらのキーマップは変数@code{emulation-mode-map-alists}、@code{minor-mode-overriding-map-alist}、@code{minor-mode-map-alist}により指定されます。@ref{Controlling
Active Maps}を参照してください。

@cindex local keymap
  次に優先されるのは、バッファーの@dfn{ローカルキーマップ(local
keymap)}で、これにはそのバッファー特有なキーバインディングが含まれます。ミニバッファーもローカルキーマップをもちます(@ref{Intro to
Minibuffers}を参照)。ポイント位置に@code{local-map}テキスト、またはoverlayプロパティがある場合、それはバッファーのデフォルトローカルキーマップのかわりに使用するローカルキーマップを指定します。

@cindex major mode keymap
  ローカルキーマップは通常はそのバッファーのメジャーモードによりセットされます。同じメジャーモードをもつすべてのバッファーは、同じローカルキーマップを共有します。したがって、あるバッファーでローカルキーマップを変更するために@code{local-set-key}(@ref{Key
Binding Commands}を参照)を呼び出した場合、それは同じメジャーモードをもつ他のバッファーのローカルキーマップにも影響を与えます。

@cindex global keymap
  最後は、@kbd{C-f}のようなカレントバッファーとは関係なく定義されるキーバインディングを含む、@dfn{グローバルキーマップ(global
keymap)}です。kこのキーマップは常にアクティブであり、変数@code{global-map}にバインドされています。

  これら``通常''のキーマップとは別に、Emacsはプログラムが他のキーマップをアクティブにするための特別な手段を提供します。1つ目は、グローバルキーマップ以外の通常アクティブなキーマップを置き換えるキーマップを指定する変数@code{overriding-local-map}です。2つ目は、他の@emph{すべて}のキーマップより優先されるキーマップを指定する、端末ローカル変数@code{overriding-terminal-local-map}です。この端末ローカル変数は通常、modal(訳注:
他のキーマップを選択できない状態)かつ一時的なキーバインディングに使用されます(ここの変数にたいして関数@code{set-transient-map}は便利なインターフェイスを提供する)。詳細は、@ref{Controlling
Active Maps}を参照のこと。

  これらを使用するのがキーマップをアクティブにする唯一の方法ではありません。キーマップは、@code{read-key-sequence}によるイベントの変換のような、他の用途にも使用されます。@ref{Translation
Keymaps}を参照してください。

  いくつかの標準的なキーマップのリストは、@ref{Standard Keymaps}を参照してください。

@defun current-active-maps &optional olp position
これは、カレントの状況下でコマンドループによりキーシーケンスをルックアップするために使用される、アクティブなキーマップのリストをリターンする。これは通常、@code{overriding-local-map}と@code{overriding-terminal-local-map}を無視するが、@var{olp}が非@code{nil}の場合には、それらのキーマップにも注意を払う。オプションで@var{position}に@code{event-start}によりリターンされるイベント位置、またはバッファー位置を指定でき、@code{key-binding}で説明されているようにキーマップを変更するかもしれない。
@end defun

@defun key-binding key &optional accept-defaults no-remap position
この関数は、カレントのアクティブキーマップで@var{key}にたいするバインディングをリターンする。そのキーマップ内で@var{key}が未定義の場合、結果は@code{nil}になる。

引数@var{accept-defaults}は、@code{lookup-key}(@ref{Functions for Key
Lookup}を参照)のようにデフォルトバインディングをチェックするかを制御する。

コマンドがリマップ(remap: 再マップ。@ref{Remapping
Commands}を参照)されたとき、@code{key-binding}は通常、実際に実行されるであろうリマップされたコマンドをリターンするように、コマンドのリマップを行う。しかし、@var{no-remap}が非@code{nil}の場合、@code{key-binding}はリマップを無視して、@var{key}にたいして直接指定されたバインディングをリターンする。

@var{key}がマウスイベント(もしかしたらプレフィクスイベントが先行するかもしれない)で始まる場合、照合されるマップはそのイベントの位置を元に決定される。それ以外では、それらのマップはポイント値に基づき決定される。しかし、@var{position}を指定することにより、これらをオーバーライドできる。@var{position}が非@code{nil}の場合、それはバッファー位置か@code{event-start}の値のようなイベント位置のいずれかである。その場合、照合されるマップは@var{position}に基づき決定される。

@var{key}が文字列とベクターのいずれでもない場合、Emacsはエラーをシグナルする。

@example
@group
(key-binding "\C-x\C-f")
    @result{} find-file
@end group
@end example
@end defun

@node Searching Keymaps
@section Searching the Active Keymaps
@cindex searching active keymaps for keys

以下は、macsがアクティブなキーマップを検索する方法を示す、Lisp処理概要です:

@lisp
(or (if overriding-terminal-local-map
        (@var{find-in} overriding-terminal-local-map))
    (if overriding-local-map
        (@var{find-in} overriding-local-map)
      (or (@var{find-in} (get-char-property (point) 'keymap))
          (@var{find-in-any} emulation-mode-map-alists)
          (@var{find-in-any} minor-mode-overriding-map-alist)
          (@var{find-in-any} minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (@var{find-in} (get-char-property (point) 'local-map))
            (@var{find-in} (current-local-map)))))
    (@var{find-in} (current-global-map)))
@end lisp

@noindent
ここで、@var{find-in}と@var{find-in-any}はそれぞれ、1つのキーマップとキーマップのalistを検索する仮の関数です。関数@code{set-transient-map}が@code{overriding-terminal-local-map}(@ref{Controlling
Active Maps}を参照)をセットすることにより機能する点に注意してください。

  上記の処理概要では、キーシーケンスがマウスイベント(@ref{Mouse
Events}を参照)で始まる場合、ポイント位置のかわりにそのイベント位置、カレントバッファーのかわりにそのイベントのバッファーが使用されます。これは特に、プロパティ@code{keymap}および@code{local-map}をルックアップする方法に影響を与えます。@code{display}、@code{before-string}、@code{after-string}プロパティ(@ref{Special
Properties}を参照)が埋め込まれていて、@code{keymap}または@code{local-map}プロパティが非@code{nil}の文字列上でマウスイベントが発生した場合、それは基調となるバッファーテキストの対応するプロパティをオーバーライドします(バッファーテキストにより指定されたプロパティは無視される)。

  アクティブなキーマップの1つでキーバインディングが見つかり、そのバインディングがコマンドの場合、検索は終了し、そのコマンドが実行されます。しかし、そのバインディングが値をもつ変数、または文字列の場合、Emacsは入力キーシーケンスをその変数の値、または文字列で置き換えて、アクティブなキーマップの検索を再開します。
@ref{Key Lookup}を参照してください。

  最終的に見つかったコマンドもリマップされるかもしれません。@ref{Remapping Commands}を参照してください。

@node Controlling Active Maps
@section Controlling the Active Keymaps
@cindex active keymap, controlling

@defvar global-map
この変数は、Emacsキーボード入力をコマンドにマップするデフォルトのグローバルキーマップを含む。通常は、このキーマップがグローバルキーマップである。デフォルトグローバルキーマップは、@code{self-insert-command}をすべてのプリント文字にバインドするfullキーマップである。

これはグローバルキーマップ内のバインディングを変更する通常の手段だが、この変数に開始時のキーマップ以外の値を割り当てるべきではない。
@end defvar

@defun current-global-map
この関数は、カレントのグローバルキーマップをリターンする。デフォルトグローバルキーマップとカレントグローバルキーマップのいずれも変更していない場合は、@code{global-map}と同じ値になる。リターン値はコピーではなく参照である。これに@code{define-key}などの関数を使用すると、グローバルバインディングが変更されるだろう。

@example
@group
(current-global-map)
@result{} (keymap [set-mark-command beginning-of-line @dots{}
            delete-backward-char])
@end group
@end example
@end defun

@defun current-local-map
この関数はカレントバッファーのローカルキーマップをリターンする。ローカルキーマップがない場合は@code{nil}をリターンする。以下の例では、(Lisp
Interactionモードを使用する)@file{*scratch*}バッファーにたいするキーマップは、@key{ESC}(@acronym{ASCII}コード27)にたいするエントリーが別のsparseキーマップであるようなsparseキーマップである。

@example
@group
(current-local-map)
@result{} (keymap
    (10 . eval-print-last-sexp)
    (9 . lisp-indent-line)
    (127 . backward-delete-char-untabify)
@end group
@group
    (27 keymap
        (24 . eval-defun)
        (17 . indent-sexp)))
@end group
@end example
@end defun

@code{current-local-map}はローカルキーマップのコピーではなく参照をリターンする。これに@code{define-key}などの関数を使用すると、ローカルバインディングが変更されるだろう。

@defun current-minor-mode-maps
この関数は、カレントで有効なメジャーモードのキーマップリストをリターンする。
@end defun

@defun use-global-map keymap
この関数は、@var{keymap}を新たなカレントグローバルキーマップにする。これは@code{nil}をリターンする。

グローバルキーマップの変更は、異例である。
@end defun

@defun use-local-map keymap
この関数は、@var{keymap}をカレントバッファーの新たなローカルキーマップにする。@var{keymap}が@code{nil}の場合、そのバッファーはローカルキーマップをもたない。@code{use-local-map}は@code{nil}をリターンする。ほとんどのメジャーモードコマンドは、この関数を使用する。
@end defun

@defvar minor-mode-map-alist
@anchor{Definition of minor-mode-map-alist}
この変数は、アクティブかどうかに関わらず、特定の変数の値にたいするキーマップを示すalistである。要素は、以下のようになる:

@example
(@var{variable} . @var{keymap})
@end example

キーマップ@var{keymap}は、
@var{variable}が非@code{nil}値をもつときはアクティブである。通常、@var{variable}はメジャーモードを有効、または無効にする変数である。@ref{Keymaps
and Minor Modes}を参照のこと。

@code{minor-mode-map-alist}の要素が、@code{minor-mode-alist}の要素と異なる構造をもつことに注意されたい。マップは要素の@sc{cdr}でなければならず、そうでなければ2つ目の要素にマップリストは用いられないだろう。@sc{cdr}はキーマップ(リスト)、または関数定義がキーマップであるようなシンボルである。

1つ以上のマイナーモードキーマップがアクティブなとき、@code{minor-mode-map-alist}内で前のキーマップが優先される。しかし、互いが干渉しないようにマイナーモードをデザインすべきである。これを正しく行えば、順序は問題にならない。

マイナーモードについての詳細な情報は、@ref{Keymaps and Minor
Modes}を参照のこと。@code{minor-mode-key-binding}(@pxref{Functions for Key
Lookup}を参照)も確認されたい。
@end defvar

@defvar minor-mode-overriding-map-alist
この変数は、メジャーモードによる特定のマイナーモードにたいするキーバインディングのオーバーライドを可能にする。このalistの要素は、@code{minor-mode-map-alist}の要素のように、@code{(@var{variable}
. @var{keymap})}のような形式である。

ある変数が@code{minor-mode-overriding-map-alist}の要素として出現する場合、その要素により指定されるマップは、@code{minor-mode-map-alist}内の同じ変数にたいして指定される任意のマップを完全に置き換える。

すべてのバッファーにおいて、@code{minor-mode-overriding-map-alist}は自動的にバッファーローカルである。
@end defvar

@defvar overriding-local-map
この変数が非@code{nil}の場合は、バッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、マイナーモードキーマップのかわりに使用されるするキーマップを保持する。このキーマップが指定された場合、カレントグローバルキーマップ以外のアクティブだった他のすべてのマップがオーバーライドされる。
@end defvar

@defvar overriding-terminal-local-map
この変数が非@code{nil}の場合は、@code{overriding-local-map}、バッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、およびすべてのマイナーモードキーマップのかわりに使用されるキーマップを保持する。

この変数は、カレント端末にたいして常にローカルであり、バッファーローカルにできない。@ref{Multiple
Terminals}を参照のこと。これはインクリメンタル検索モードの実装に使用される。
@end defvar

@defvar overriding-local-map-menu-flag
この変数が非@code{nil}の場合は、@code{overriding-local-map}または@code{overriding-terminal-local-map}の値がメニューバーの表示に影響し得る。デフォルト値は@code{nil}なので、これらのマップ変数なメニューバーに影響をもたない。

これら2つのマップ変数は、たとえこれらの変数がメニューバー表示に影響し得るを与えない場合でも、メニューバーを使用してエンターされたキーシーケンスの実行には影響を与えることに注意されたい。したがって、もしメニューバーキーシーケンスが到着したら、そのキーシーケンスをルックアップ・実行する前に変数をクリアーすべきである。この変数を使用するモードは通常、何らかの方法でこれを行っている。これらのモードは通常``読み戻し(unread)''とexitにより処理されないイベントに応答する。
@end defvar

@defvar special-event-map
この変数は、スペシャルイベントにたいするキーマップを保持する。あるイベント型がこのキーマップ内でバインディングをもつ場合、それはスペシャルであり、そのイベントにたいするバインディングは@code{read-event}により直接実行される。@ref{Special
Events}を参照のこと。
@end defvar

@defvar emulation-mode-map-alists
この変数は、エミュレーションモードにたいして使用するキーマップalistのリストを保持する。この変数は、複数マイナーモードキーマップを使用するモードとパッケージを意図している。リストの各要素は@code{minor-mode-map-alist}と同じフォーマットと意味をもつキーマップalistか、そのようなalist形式の変数バインディングをもつシンボルである。それぞれのalist内の``アクティブ''なキーマップは、@code{minor-mode-map-alist}と@code{minor-mode-overriding-map-alist}の前に使用される。
@end defvar

@cindex transient keymap
@defun set-transient-map keymap &optional keep
この関数は@dfn{一時的(transient)}なキーマップとして@var{keymap}を追加する。一時的なキーマップは1つ以上の後続するキーにたいして、他のキーマップより優先される。

通常、@var{keymap}は直後のキーをルックアップするために、1回だけ使用される。しかし、オプション引数@var{pred}が@code{t}の場合、そのマップはユーザーが@var{keymap}内で定義されたキーをタイプするまでアクのままとなる。@var{keymap}内にないキーをユーザーがタイプしたとき、一時的キーマップは非アクティブとなり、そのキーにたいして通常のキールックアップが継続される。

@var{pred}には関数も指定できる。。この場合、@var{keymap}がアクティブの間は、各コマンドの実行に優先して、その関数が引数なしで呼び出される。@var{keymap}がアクティブの間、関数は非@code{nil}をリターンすべきである。

この関数は、他のすべてのアクティブなキーマップに優先される変数@code{overriding-terminal-local-map}にたいして、@code{keymap}を追加、または削除することにより機能する(@ref{Searching
Keymaps}を参照)。
@end defun

@node Key Lookup
@section Key Lookup
@cindex key lookup
@cindex keymap entry

  @dfn{キールックアップ(key lookup:
キー照合)}とは、与えられたキーマップからキーシーケンスのバインディングを見つけ出すことです。そのバインディングの使用や実行は、キールックアップの一部ではありません。

  キールックアップは、キーシーケンス内の各イベントのイベント型だけを使用し、そのイベントの残りは無視します。実際のところ、キールックアップに使用されるキーシーケンスは、マウスイベントをイベント全体(リスト)のかわりにイベント型のみ(シンボル)を用いるでしょう。@ref{Input
Events}を参照してください。そのような``キーシーケンス''は、@code{command-execute}による実行には不十分ですが、キーのルックアップやリバインドには十分です。

  キーシーケンスが複数イベントから構成されるとき、キールックアップはイベントを順に処理します。最初のイベントのバインディングが見つかったとき、それはキーマップでなければなりません。そのキーマップ内で2つ目のイベントを見つけ出し、そのキーシーケンス内のすべてのイベントが消費されるまで、このプロセスを続けます(故に、最後のイベントにたいして見つかったイベントはキーマップかどうかわからない)。したがって、キールックアッププロセスは、キーマップ内で単一イベントを見つけ出す、よりシンプルなプロセスで定義されます。これが行なわれる方法は、キーマップ内でそのイベントに関連するオブジェクトの型に依存します。

  キーマップ内のイベント型ルックアップによる値発見を説明するために、@dfn{キーマップエントリー(keymap
entry)}という用語を導入しましょう。(これにはメニューアイテムにたいするキーマップ内のアイテム文字列や、他の余計な要素は含まれません。なぜなら、@code{lookup-key}や他のキーマップルックアップ関数が、リターン値にそれらを含まないからです。)
任意のLispオブジェクトがキーマップエントリーとしてキーマップに格納されるかもしれませんが、すべてがキールックアップに意味をもつわけではありません。以下のテーブルは、キーマップエントリーで重要な型です:

@table @asis
@item @code{nil}
@cindex @code{nil} in keymap
@code{nil}は、それまでにルックアップに使用されたイベントが、未定義キーを形成することを意味する。最終的にキーマップがイベント型を調べるのに失敗して、デフォルトバインディングも存在しないときは、そのイベント型のバインディングが@code{nil}であるのと同じである。

@item @var{command}
@cindex command in keymap
それまでにルックアップに使用されたイベントがコンプリートキーを形成し、そのバインディングは@var{command}である。@ref{What Is a
Function}を参照のこと。

@item @var{array}
@cindex string in keymap
array(文字列かベクター)は、キーボードマクロである。それまでにルックアップに使用されたイベントはコンプリートキーを形成し、そのバインディングはarrayである。詳細は@ref{Keyboard
Macros}を参照のこと。

@item @var{keymap}
@cindex keymap in keymap
それまでにルックアップに使用されたイベントはプレフィクスキーを形成する。そのキーシーケンスの次のイベントは、@var{keymap}内でルックアップされる。

@item @var{list}
@cindex list in keymap
listの意味は、そのリストが何を含んでいるかに依存する:

@itemize @bullet
@item
@var{list}の@sc{car}がシンボル@code{keymap}の場合、そのリストはキーマップであり、キーマップとして扱われる(上記参照)。

@item
@cindex @code{lambda} in keymap
@var{list}の@sc{car}が@code{lambda}の場合、そのリストはラムダ式である。これは関数とみなされ、そのように扱われる(上記参照)。キーバインディングとして正しく実行されるために、この関数はコマンドでなければならず、@code{interactive}指定をもたなければならない。@ref{Defining
Commands}を参照のこと。

@item
@var{list}の@sc{car}がキーマップで@sc{cdr}がイベント型の場合、これは@dfn{インダイレクトエントリー(indirect
entry: 間接エントリー)}である:

@example
(@var{othermap} . @var{othertype})
@end example

キールックアップはインダイレクトエントリーに遭遇したときは、かわりに@var{othermap}内で@var{othertype}のバインディングをルックアップして、それを使用する。

この機能により、あるキーを他のキーにたいするalistとして定義することが可能になる。たとえば、@sc{car}が@code{esc-map}と呼ばれるキーマップで、@sc{cdr}が32(@key{SPC}のコード)の場合は、``それが何であろうと@kbd{Meta-@key{SPC}}のグローバルバインディングを使用する''ことを意味する。
@end itemize

@item @var{symbol}
@cindex symbol in keymap
@var{symbol}の関数定義が@var{symbol}のかわりに使用される。もし関数定義もシンボルの場合は、任意の回数このプロセスが繰り返される。これは最終的にキーマップであるようなオブジェクト、コマンド、またはキーボードマクロに行き着くはずである。それがキーマップかコマンドの場合はリストも許されるが、シンボルを通じて見つけ出された場合、インダイレクトエントリーは理解されない。

キーマップおよびキーボードマクロ(文字列かベクター)は有効な関数ではないので、関数定義にキーマップ、文字列、ベクターをもつシンボルは、関数としては無効であることに注意されたい。しかし、キーバインディングとしては有効である。その定義がキーボードマクロの場合、そのシンボルは@code{command-execute}(@ref{Interactive
Call}を参照)の引数としても有効である。

@cindex @code{undefined} in keymap
シンボル@code{undefined}は特記するに値する。これはそのキーを未定義として扱うことを意味する。厳密に言うと、そのキーは定義されているが、そのバインディングがコマンド@code{undefined}なのである。しかし、このコマンドは未定義キーにたいして自動的に行われるのと同じことを行う。これは(@code{ding}を呼び出して)bellを鳴らすが、エラーはシグナルしない。

@cindex preventing prefix key
@code{undefined}は、グローバルキーバインディングをオーバーライドして、そのキーをローカルに``未定義''にするために使用される。@code{nil}にローカルにバインドしても、グローバルバインディングをオーバーライドしないであろうから、これを行うのに失敗するだろう。

@item @var{anything else}
オブジェクトの他の型が見つかった場合、それまでにルックアップで使用されたイベントはコンプリートキーを形成し、そのオブジェクトがバインディングになるが、そのバインディングはコマンドとして実行不可能である。
@end table

  要約すると、キーマップエントリーはキーマップ、コマンド、キーボードマクロ、あるいはそれらに導出されるシンボル、インダイレクトエントリー、あるいは@code{nil}のいずれかです。

@node Functions for Key Lookup
@section Functions for Key Lookup

  以下は、キールックアップに関連する関数および変数です。

@defun lookup-key keymap key &optional accept-defaults
この関数は、@var{keymap}内の@var{key}の定義をリターンする。このチャプターで説明されている、キーをルックアップする他のすべての関数が@code{lookup-key}を使用する。以下は例である:

@example
@group
(lookup-key (current-global-map) "\C-x\C-f")
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) (kbd "C-x C-f"))
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) "\C-x\C-f12345")
    @result{} 2
@end group
@end example

文字列、またはベクターの@var{key}が、@var{keymap}内で指定されるプレフィクスキーとして有効なキーシーケンスでない場合、それは最後に余計なイベントをもつ、単一のキーシーケンスに適合しない、``長過ぎる''キーのはずである。その場合のリターン値は数となり、この数はコンプリートキーを構成する@var{key}の前にあるイベントの数である。

@c Emacs 19 feature
@var{accept-defaults}が非@code{nil}の場合、@code{lookup-key}は@var{key}内の特定のイベントにたいするバインディングと同様に、デフォルトバインディングも考慮する。それ以外では、@code{lookup-key}は特定の@var{key}のシーケンスにたいするバインディングだけを報告し、明示的に指定したとき以外はデフォルトバインディングを無視する。(これを行うには、@var{key}の要素として@code{t}を与える。@ref{Format
of Keymaps}を参照のこと。)

@var{key}がメタ文字(ファンクションキーではない)を含む場合その文字は暗黙に@code{meta-prefix-char}の値と対応する非メタ文字からなる、2文字シーケンスに置き換えられる。したがって、以下に1つ目の例は、2つ目の例に変換されて処理される。

@example
@group
(lookup-key (current-global-map) "\M-f")
    @result{} forward-word
@end group
@group
(lookup-key (current-global-map) "\ef")
    @result{} forward-word
@end group
@end example

@code{read-key-sequence}とは異なり、この関数は指定されたイベントの情報を破棄する変更(@ref{Key Sequence
Input}を参照)を行わない。特に、この関数はアルファベット文字を小文字に変更せず、ドラッグイベントをクリックイベントに変更しない。
@end defun

@deffn Command undefined
キーを未定義にするために、キーマップ内で使用される。これは@code{ding}を呼び出すが、エラーを起こさない。
@end deffn

@defun local-key-binding key &optional accept-defaults
この関数は、カレントのローカルキーマップ内の、@var{key}にたいするバインディングをリターンする。カレントのローカルキーマップ内で未定義の場合は、@code{nil}をリターンする。

@c Emacs 19 feature
引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@defun global-key-binding key &optional accept-defaults
この関数は、カレントのグローバルキーマップ内で、コマンド@var{key}にたいするバインディングをリターンする。カレントのグローバルキーマップ内で未定義の場合は、@code{nil}をリターンする。

@c Emacs 19 feature
引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@c Emacs 19 feature
@defun minor-mode-key-binding key &optional accept-defaults
この関数は、アクティブなマイナーモードの@var{key}のバインディングを、リストでリターンする。より正確には、この関数は@code{(@var{modename}
.
@var{binding})}のとうなペアーのalistをリターンする。ここで@var{modename}なそのマイナーモードを有効にする変数、@var{binding}はそのモードでの@var{key}のバインディングである。@var{key}がマイナーモードバインディングをみたない場合、値は@code{nil}である。

最初に見つかったバインディングがプレフィクス定義(キーマップ、またはキーマップとして定義されたシンボル)でない場合は、他のマイナーモード由来のすべての後続するバインディングは、完全にshadowされるため省略される。同様に、このリストはプレフィクスバインディングに後続する非プレフィクスバインディングは省略される。

引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@defopt meta-prefix-char
@cindex @key{ESC}
この変数はメタ/プレフィクス文字コードである。これはメタ文字をキーマップ内でルックアップできるように、2文字シーケンスに変換する。有用な結果を得るために、値はプレフィクスイベント(@ref{Prefix
Keys}を参照)であること。デフォルト値は27で、これは@key{ESC}にたいする@acronym{ASCII}コードである。

@code{meta-prefix-char}の値が27であるような限り、キールックアップは通常@code{backward-word}コマンドとして定義される@kbd{M-b}を、@kbd{@key{ESC}
b}に変換する。しかし、@code{meta-prefix-char}を24(@kbd{C-x}のコード)にセットした場合、Emacsは@kbd{M-b}を@kbd{C-x
b}に変換するだろうが、これの標準のバインディングは@code{switch-to-buffer}コマンドである。以下に何が起こるかを示す(実際にこれを行ってはならない!):

@smallexample
@group
meta-prefix-char                    ; @r{デフォルト値}
     @result{} 27
@end group
@group
(key-binding "\M-b")
     @result{} backward-word
@end group
@group
?\C-x                               ; @r{文字.の}
     @result{} 24                          ; @r{プリント表現}
@end group
@group
(setq meta-prefix-char 24)
     @result{} 24
@end group
@group
(key-binding "\M-b")
     @result{} switch-to-buffer            ; @r{今や@kbd{M-b}をタイプすると}
                                    ;   @r{@kbd{C-x b}をタイプしたようになる}

(setq meta-prefix-char 27)          ; @r{混乱を避ける!}
     @result{} 27                          ; @r{デフォルト値をリストア!}
@end group
@end smallexample

この単一イベントから２イベントへの変換は文字にたいしてのみ発生し、他の種類の入力イベントには発生しない。したがって、ファンクションキー@kbd{M-@key{F1}}は@kbd{@key{ESC}
@key{F1}}に変換されない。
@end defopt

@node Changing Key Bindings
@section Changing Key Bindings
@cindex changing key bindings
@cindex rebinding

  キーのリバインド(rebind:
再バインド、再束縛)は、キーマップ内でそのキーのバインディングエントリーを変更することにより行います。グローバルキーマップ内のバインディングを変更した場合、その変更は(たとえローカルバインディングによりグローバルバインディングをshadowしているバッファーでは直接影響しないとしても)すべてのバッファーに影響します。カレントバッファーのローカルマップを変更した場合は、通常は同じメジャーモードを使用するすべてのバッファーに影響します。関数@code{global-set-key}および@code{local-set-key}は、これらの操作のための使いやすいインターフェイスです(@ref{Key
Binding
Commands}を参照)。より汎用的な関数@code{define-key}を使用することもできます。その場合は、変更するマップを明示的に指定しなければなりません。

  Lispプログラムでリバインドするキーシーケンスを選択するときは、さまざまなキーの使用についてのEmacsの慣習にしたがうようお願いします(@ref{Key
Binding Conventions}を参照)。

@cindex meta character key constants
@cindex control character key constants
  リバインドするキーシーケンスの記述では、コントロール文字とメタ文字にたいして、特別なエスケープシーケンスを使用すると良いでしょう(@ref{String
Type}を参照)。構文@samp{\C-}は後続する文字がコントロール文字でることを意味し、@samp{\M-}は後続する文字がメタ文字であることを意味します。したがって、文字列@code{"\M-x"}は1つの@kbd{M-x}、@code{"\C-f"}は1つの@kbd{C-f}、@code{"\M-\C-x"}および@code{"\C-\M-x"}は1つの@kbd{C-M-x}として読み取られます。ベクター内でも、このエスケープシーケンス、および文字列では使用できない他のエスケープシーケンスを使用できます。1例は@samp{[?\C-\H-x
home]}です。@ref{Character Type}を参照してください。

  キー定義、およびルックアップ関数は、ベクターであるようなキーシーケンス内のイベント型にたいして、別の構文を受け入れます。修飾名に基本イベント(文字かファンクションキー名)を付加したものを含むリストを使用できます。たとえば、@code{(control
?a)}は@code{?\C-a}、@code{(hyper control
left)}は@code{C-H-left}と等価です。このようなリストの利点の1つは、コンパイル済みファイル内に修飾ビットの正確な数値コードが出現しないことです。

  以下の関数は、@var{keymap}がキーマップでない場合、および@var{key}がキーシーケンスを表す文字列やベクターでない場合はエラーをシグナルします。リストであるようなイベントにたいする略記として、イベント型(シンボル)を使用できます。@code{kbd}関数(@ref{Key
Sequences}を参照)は、キーシーケンスを指定するための便利な方法です。

@defun define-key keymap key binding
この関数は、@var{keymap}内で@var{key}にたいするバインディングをセットする(@var{key}が長さ2以上のイベントの場合、その変更は実際は@var{keymap}から辿られる他のキーマップで行なわれる)。引数@var{binding}には任意のLispオブジェクトを指定できるが、意味があるのは特定のオブジェクトだけである(意味のある型のリストは、@ref{Key
Lookup}を参照のこと)。@code{define-key}のリターン値は@var{binding}である。

@var{key}が@code{[t]}の場合、これは@var{keymap}内でデフォルトバインディングをセットする。イベントが自身のバインディングをもたないとき、そのキーマップ内にデフォルトバインディングが存在するなら、Emacsコマンドループはそれを使用する。

@cindex invalid prefix key error
@cindex key sequence error
@var{key}のすべてのプレフィクスは、プレフィクスキー(キーマップにバインドされる)、または未定義でなけらばならず、それ以外はエラーがシグナルされる。@var{key}のいくつかのプレフィクスが未定義の場合は、@code{define-key}はそれをプレフィクスキーとして定義するので、残りの@var{key}は指定されたように定義できる。

前に@var{keymap}内で@var{key}にたいするバインディングが存在しなかった場合は、新たなバインディングが@var{keymap}の先頭に追加される。キーマップ内のバインディングの順序はキーボード入力にたいし影響を与えないが、メニューキーマップにたいしては問題となる(@ref{Menu
Keymaps}を参照)。
@end defun

  以下は、sparseキーマップを作成して、その中にバインディングをいくつか作成する例である:

@smallexample
@group
(setq map (make-sparse-keymap))
    @result{} (keymap)
@end group
@group
(define-key map "\C-f" 'forward-char)
    @result{} forward-char
@end group
@group
map
    @result{} (keymap (6 . forward-char))
@end group

@group
;; @r{@kbd{C-x}にたいしsparseサブマップを作成し、
;; その中で@kbd{f}をバインドする}
(define-key map (kbd "C-x f") 'forward-word)
    @result{} forward-word
@end group
@group
map
@result{} (keymap
    (24 keymap                ; @kbd{C-x}
        (102 . forward-word)) ;      @kbd{f}
    (6 . forward-char))       ; @kbd{C-f}
@end group

@group
;; @r{@kbd{C-p}を@code{ctl-x-map}にバインド}
(define-key map (kbd "C-p") ctl-x-map)
;; @code{ctl-x-map}
@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]
@end group

@group
;; @r{@code{ctl-x-map}内で@kbd{C-f}を@code{foo}にバインド}
(define-key map (kbd "C-p C-f") 'foo)
@result{} 'foo
@end group
@group
map
@result{} (keymap     ; @r{@code{ctl-x-map}内の@code{foo}に注目}
    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])
    (24 keymap
        (102 . forward-word))
    (6 . forward-char))
@end group
@end smallexample

@noindent
@kbd{C-p
C-f}にたいする新たなバインディングの格納は、実際には@code{ctl-x-map}内のエントリーを変更することにより機能し、これはデフォルトグローバルマップ内の@kbd{C-p
C-f}と@kbd{C-x C-f}の両方のバインディングを変更する効果をもつことに注意されたい。

  関数@code{substitute-key-definition}は、キーマップから特定のバインディングをもつキーをスキャンして、それらを異なるバインディングにリバインドする。より明快で、多くの場合は同じ結果を生成できる他の機能として、あるコマンドから別のコマンドへのリマップがあります(@ref{Remapping
Commands}を参照)。

@defun substitute-key-definition olddef newdef keymap &optional oldmap
@cindex replace bindings
この関数は、@var{keymap}内で@var{olddef}にバインドされるすべてのキーについて、@var{olddef}を@var{newdef}に置き換える。別の言い方をすると、@var{olddef}が出現する箇所すべてを@var{newdef}に置き換える。この関数は@code{nil}をリターンする。

たとえば、以下をEmacsの標準バインディングで行うと、@kbd{C-x C-f}を再定義する:

@smallexample
@group
(substitute-key-definition
 'find-file 'find-file-read-only (current-global-map))
@end group
@end smallexample

@c Emacs 19 feature
@var{oldmap}が非@code{nil}の場合は、どのキーをリバインドするかを@var{oldmap}内のバインディングが決定するよう、@code{substitute-key-definition}の動作を変更する。リバインディングは依然として@var{oldmap}ではなく、@var{keymap}で発生する。したがって、他のマップ内のバインディングの制御下で、マップを変更することができる。たとえば、

@smallexample
(substitute-key-definition
  'delete-backward-char 'my-funny-delete
  my-map global-map)
@end smallexample

@noindent
これは、標準的な削除コマンドにグローバルにバインドされたキーにたいして、@code{my-map}内の特別な削除コマンドを設定する。

以下は、キーマップの置き換え(substitution)の前後を示す例である:

@smallexample
@group
(setq map '(keymap
            (?1 . olddef-1)
            (?2 . olddef-2)
            (?3 . olddef-1)))
@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
@end group

@group
(substitute-key-definition 'olddef-1 'newdef map)
@result{} nil
@end group
@group
map
@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
@end group
@end smallexample
@end defun

@defun suppress-keymap keymap &optional nodigits
@cindex @code{self-insert-command} override
この関数は、@code{self-insert-command}をコマンド@code{undefined}にリマップ(@ref{Remapping
Commands}を参照)することにより、fullキーマップのコンテンツを変更する。これは、すべてのプリント文字を未定義にする効果をもすので、通常のテキスト挿入は不可能になる。@code{suppress-keymap}は@code{nil}をリターンする。

@var{nodigits}が@code{nil}の場合、@code{suppress-keymap}は数字が@code{digit-argument}、@kbd{-}が@code{negative-argument}を実行するように定義する。それ以外は、残りのプリント文字と同じように、それらの文字も未定義にする。

@cindex yank suppression
@cindex @code{quoted-insert} suppression
@code{suppress-keymap}関数は、@code{yank}や@code{quoted-insert}のようなコマンドを抑制(suppress)しないので、バッファーの変更は可能である。バッファーの変更を防ぐには、バッファーを読み取り専用(read-only)にする(@ref{Read
Only Buffers}を参照)。

この関数は@var{keymap}を変更するので、通常は新たに作成したキーマップにたいして使用するだろう。するだろう。他の目的のために使用されている既存のキーマップに操作を行うと、恐らくトラブルの原因となる。たとえば、@code{global-map}の抑制は、Emacsの使用をほとんど不可能に

この関数は、テキストの挿入が望ましくないメジャーモードの、ローカルキーマップ初期科に使用され得る。しかし、そのようなモードは通常は@code{special-mode}(@ref{Basic
Major
Modes}を参照)から継承される。この場合、そのモードのキーマップは既に抑制済みの@code{special-mode-map}から自動的に受け継がれる。以下に@code{special-mode-map}が定義される方法を示す:

@smallexample
@group
(defvar special-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (define-key map "q" 'quit-window)
    @dots{}
    map))
@end group
@end smallexample
@end defun

@node Remapping Commands
@section Remapping Commands
@cindex remapping commands

  あるコマンドから他のコマンドへの@dfn{リマップ(remap)}には、特別な種類のキーバインディングが使用できます。この機能を使用するためには、ダミーイベント@code{remap}で始まり、その後にリマップしたいコマンド名が続くようなキーシーケンスにたいするキーバインディングを作成します。そして、そのバインディングにたいしては、新たな定義(通常はコマンド名だが、キーバインディングにたいして有効な他の任意の定義を指定可能)を指定します。

  たとえば、Myモードというモードが、@code{kill-line}のかわりに呼び出される@code{my-kill-line}という特別なコマンドを提供するとします。これを設定するには、このモードのキーマップに以下のようなリマッピングが含まれるはずです:

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
@end smallexample

@noindent
その後は、@code{my-mode-map}がアクティブなときは常に、ユーザーが@kbd{C-k}(@code{kill-line}についてデフォルトのグローバルキーシーケンス)をタイプすると、Emacsはかわりに@code{my-kill-line}を実行するでしょう。

  リマップはアクティブなキーマップでのみ行なわれることに注意してください。たとえば、@code{ctl-x-map}のようなプレフィクスキーマップ内にリマッピングを置いても、そのようなキーマップはそれ自体がアクティブでないので、通常は効果がありません。それに加えて、リマップは1レベルを通じてのみ機能します。以下の例では、

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)
@end smallexample

@noindent
これは@code{kill-line}を@code{my-other-kill-line}にリマップ@emph{しません}。かわりに、通常のキーバインディングが@code{kill-line}を指定する場合は、それが@code{my-kill-line}にリマップされます。通常のバインディングが@code{my-kill-line}を指定した場合は、@code{my-other-kill-line}にリマップされます。

コマンドのリマップをアンドゥするには、以下のようにそれを@code{nil}にリマップします：

@smallexample
(define-key my-mode-map [remap kill-line] nil)
@end smallexample

@defun command-remapping command &optional position keymaps
この関数は、カレントアクティブキーマップにより与えられる、@var{command}(シンボル)にたいするリマッピングをリターンする。@var{command}がリマップされていない(これは普通の状況である)、またはシンボル以外の場合、この関数は@code{nil}をリターンする。@code{position}は、@code{key-binding}の場合と同様、使用するキーマップを決定するために、オプションバッファー位置、またはイベント位置をオプションで指定できる。

オプション引数@code{keymaps}が非@code{nil}の場合、それは検索するキーマップのリストを指定する。この引数は、@code{position}が非@code{nil}の場合は無視される。
@end defun

@node Translation Keymaps
@section Keymaps for Translating Sequences of Events
@cindex translation keymap
@cindex keymaps for translating events

  @code{read-key-sequence}関数がキーシーケンス(@ref{Key Sequence
Input}を参照)を読み取るときは、特定のイベントシーケンスを他のものに変換(translate)するために、@dfn{変換キーマップ(translation
keymaps)}を使用します。@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}(優先順)は変換キーマップです。

  変換キーマップは、他のキーマップと同じ構造をもちますが、使われ方は異なります。変換キーマップは、キーシーケンスを読み取るときに、コンプリートキーシーケンスにたいするバインディングではなく、キーシーケンスに行う変換を指定します。キーシーケンスが読み取られると、それらのキーシーケンスは変換キーマップにたいしてチェックされます。ある変換キーマップが@var{k}をベクター@var{v}に``バインド''する場合、キーシーケンス内の@emph{どこか}にサブシーケンスとして@var{k}が出現すると、それは@var{v}ないのでイベントに置き換えられます。

  たとえば、キーパッドキー@key{PF1}が押下されたとき、VT100端末は@kbd{@key{ESC} O
P}を送信します。そのような端末では、Emacsはそのイベントシーケンスを単一イベント@code{pf1}に変換しなければなりません。これは、@code{input-decode-map}内で@kbd{@key{ESC}
O P}を@code{[pf1]}に``バインド''することにより行われます。したがって、その端末上で@kbd{C-c
@key{PF1}}をタイプしたとき、端末は文字シーケンス@kbd{C-c @key{ESC} O
P}を発行し、@code{read-key-sequence}がそれを@kbd{C-c @key{PF1}}に変換してベクター@code{[?\C-c
pf1]}としてリターンします。

  変換キーマップは、(@code{keyboard-coding-system}で指定された入力コーディングシステムを通じて)Emacsがキーボード入力をデコードした直後だけ効果をもちます。@ref{Terminal
I/O Encoding}を参照してください。

@defvar input-decode-map
この変数は、通常の文字端末上のファンクションキーから送信された文字シーケンスを記述するキーマップを保持する。

@code{input-decode-map}の値は、通常はその端末のTerminfoかTermcapのエントリーに応じて、自動的にセットアップされるが、Lispの端末仕様ファイルの助けが必要なときもある。Emacsには、多くの一般的な端末の端末仕様ファイルが同梱されている。これらのファイルの主な目的は、TermcapやTerminfoから推定できないエントリーを@code{input-decode-map}内に作成することである。@ref{Terminal-Specific}を参照のこと。
@end defvar

@defvar local-function-key-map
この変数は、@code{input-decode-map}と同じようにキーマップを保持するが、通常優先される解釈候補(alternative
interpretation)に変換されるべきキーシーケンスを記述するキーマップを保持する。このキーマップは@code{input-decode-map}の後、@code{key-translation-map}の前に適用される。

@code{local-function-key-map}内のエントリーは、マイナーモード、ローカルキーマップ、グローバルキーマップによるバインディングと衝突する場合は無視される。つまり、元のキーシーケンスが他にバインディングをもたない場合だけ、リマッピングが適用される。

@code{local-function-key-map}が@code{function-key-map}を継承するが、@code{function-key-map}を直接使用すべきではない。
@end defvar

@defvar key-translation-map
この変数は、入力イベントを他のイベントに変換するために、@code{input-decode-map}と同じように使用される、別のキーマップを保持する。@code{input-decode-map}との違いは、@code{local-function-key-map}の前ではなく、後に機能する点である。このキーマップは、@code{local-function-key-map}による変換結果を受け取る。

@code{input-decode-map}と同様、ただし@code{local-function-key-map}とは異なり、このキーマップは入力キーシーケンスが通常のバインディングをもつかどうかかに関わらず適用される。しかし、このキーマップによりキーバインディングがオーバーライドされても、@code{key-translation-map}では実際のキーバインディングが効果をもち得ることに注意されたい。確かに、実際のキーバインディングは@code{local-function-key-map}をオーバーライドし、したがって@code{key-translation-map}が受け取るキーシーケンスは変更されるだろう。明確にするためには、このような類の状況は避けたほうがよい。

@code{key-translation-map}は、通常は@code{self-insert-command}にバインディングされるような通常文字を含めて、ユーザーがある文字を他の文字にマップすることを意図している。
@end defvar

@cindex key translation function
キーシーケンスのかわりにキーの``変換''として関数を使用することにより、シンプルなエイリアスより多くのことに@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}を使用できます。その場合、この関数はそのキーの変換を計算するために呼び出されます。

キー変換関数は、引数を1つ受け取ります。この引数は@code{read-key-sequence}内で指定されるプロンプトです。キーシーケンスがエディターコマンドループに読み取られる場合は、@code{nil}です。ほとんどの場合、プロンプト値は無視できます。

関数が自身で入力を読み取る場合、その関数は後続のイベントを変更する効果をもつことができます。たとえば、以下は@kbd{C-c
h}をハイパー文字に後続する文字とするために定義する方法の例です:

@example
@group
(defun hyperify (prompt)
  (let ((e (read-event)))
    (vector (if (numberp e)
                (logior (lsh 1 24) e)
              (if (memq 'hyper (event-modifiers e))
                  e
                (add-event-modifier "H-" e))))))

(defun add-event-modifier (string e)
  (let ((symbol (if (symbolp e) e (car e))))
    (setq symbol (intern (concat string
                                 (symbol-name symbol))))
    (if (symbolp e)
        symbol
      (cons symbol (cdr e)))))

(define-key local-function-key-map "\C-ch" 'hyperify)
@end group
@end example

@subsection Interaction with normal keymaps

そのキーシーケンスがコマンドにバインドされたとき、またはさらにイベントを追加してもコマンドにバインドされるシーケンスにすることができないとEmacsが判断したときに、キーシーケンスの終わりが検出されます。

これは、元のキーシーケンスがバインディングをもつかどうかに関わらず、@code{input-decode-map}および@code{key-translation-map}を適用するとき、そのようなバインディングが変換の開始を妨げることを意味します。たとえば、前述のVT100の例に戻って、グローバルマップに@kbd{C-c
@key{ESC}}を追加してみましょう。すると、ユーザーが@kbd{C-c @key{PF1}}をタイプしたとき、Emacsは@kbd{C-c
@key{ESC} O P}を@kbd{C-c @key{PF1}}に変換するのに失敗するでしょう。これは、Emacsが@kbd{C-x
@key{ESC}}の直後に読み取りを停止して、@kbd{O P}は読み取られずに残るからです。この場合、ユーザーが実際に@kbd{C-c
@key{ESC}}をタイプした場合、ユーザーが実際に@kbd{@key{ESC}}を押下したのか、あるいは@kbd{@key{PF1}}を押下したのか判断するために、Emacsが待つべきではないのです。

この理由により、キーシーケンスの終わりがキー変換のプレフィクスであるようなキーシーケンスをコマンドにバインドするのは、避けたほうがよいでしょう。そのような問題を起こす主なサフィックス、およびプレフィクスは@kbd{@key{ESC}}、@kbd{M-O}(実際は@kbd{@key{ESC}
O})、@kbd{M-[}(実際は@kbd{@key{ESC} [})です。

@node Key Binding Commands
@section Commands for Binding Keys

  This section describes some convenient interactive interfaces for changing
key bindings.  They work by calling @code{define-key}.

  People often use @code{global-set-key} in their init files (@pxref{Init
File}) for simple customization.  For example,

@smallexample
(global-set-key (kbd "C-x C-\\") 'next-line)
@end smallexample

@noindent
or

@smallexample
(global-set-key [?\C-x ?\C-\\] 'next-line)
@end smallexample

@noindent
or

@smallexample
(global-set-key [(control ?x) (control ?\\)] 'next-line)
@end smallexample

@noindent
redefines @kbd{C-x C-\} to move down a line.

@smallexample
(global-set-key [M-mouse-1] 'mouse-set-point)
@end smallexample

@noindent
redefines the first (leftmost) mouse button, entered with the Meta key, to
set point where you click.

@cindex non-@acronym{ASCII} text in keybindings
  Be careful when using non-@acronym{ASCII} text characters in Lisp
specifications of keys to bind.  If these are read as multibyte text, as
they usually will be in a Lisp file (@pxref{Loading Non-ASCII}), you must
type the keys as multibyte too.  For instance, if you use this:

@smallexample
(global-set-key "@"o" 'my-function) ; bind o-umlaut
@end smallexample

@noindent
or

@smallexample
(global-set-key ?@"o 'my-function) ; bind o-umlaut
@end smallexample

@noindent
and your language environment is multibyte Latin-1, these commands actually
bind the multibyte character with code 246, not the byte code 246
(@kbd{M-v}) sent by a Latin-1 terminal.  In order to use this binding, you
need to teach Emacs how to decode the keyboard by using an appropriate input
method (@pxref{Input Methods, , Input Methods, emacs, The GNU Emacs
Manual}).

@deffn Command global-set-key key binding
This function sets the binding of @var{key} in the current global map to
@var{binding}.

@smallexample
@group
(global-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-global-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command global-unset-key key
@cindex unbinding keys
This function removes the binding of @var{key} from the current global map.

One use of this function is in preparation for defining a longer key that
uses @var{key} as a prefix---which would not be allowed if @var{key} has a
non-prefix binding.  For example:

@smallexample
@group
(global-unset-key "\C-l")
    @result{} nil
@end group
@group
(global-set-key "\C-l\C-l" 'redraw-display)
    @result{} nil
@end group
@end smallexample

This function is equivalent to using @code{define-key} as follows:

@smallexample
@group
(global-unset-key @var{key})
@equiv{}
(define-key (current-global-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@deffn Command local-set-key key binding
This function sets the binding of @var{key} in the current local keymap to
@var{binding}.

@smallexample
@group
(local-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-local-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command local-unset-key key
This function removes the binding of @var{key} from the current local map.

@smallexample
@group
(local-unset-key @var{key})
@equiv{}
(define-key (current-local-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@node Scanning Keymaps
@section Scanning Keymaps
@cindex scanning keymaps
@cindex keymaps, scanning

  This section describes functions used to scan all the current keymaps for
the sake of printing help information.

@defun accessible-keymaps keymap &optional prefix
This function returns a list of all the keymaps that can be reached (via
zero or more prefix keys) from @var{keymap}.  The value is an association
list with elements of the form @code{(@var{key} .@: @var{map})}, where
@var{key} is a prefix key whose definition in @var{keymap} is @var{map}.

The elements of the alist are ordered so that the @var{key} increases in
length.  The first element is always @code{([] .@: @var{keymap})}, because
the specified keymap is accessible from itself with a prefix of no events.

If @var{prefix} is given, it should be a prefix key sequence; then
@code{accessible-keymaps} includes only the submaps whose prefixes start
with @var{prefix}.  These elements look just as they do in the value of
@code{(accessible-keymaps)}; the only difference is that some elements are
omitted.

In the example below, the returned alist indicates that the key @key{ESC},
which is displayed as @samp{^[}, is a prefix key whose definition is the
sparse keymap @code{(keymap (83 .@: center-paragraph)  (115 .@: foo))}.

@smallexample
@group
(accessible-keymaps (current-local-map))
@result{}(([] keymap
      (27 keymap   ; @r{Note this keymap for @key{ESC} is repeated below.}
          (83 . center-paragraph)
          (115 . center-line))
      (9 . tab-to-tab-stop))
@end group

@group
   ("^[" keymap
    (83 . center-paragraph)
    (115 . foo)))
@end group
@end smallexample

In the following example, @kbd{C-h} is a prefix key that uses a sparse
keymap starting with @code{(keymap (118 . describe-variable)@dots{})}.
Another prefix, @kbd{C-x 4}, uses a keymap which is also the value of the
variable @code{ctl-x-4-map}.  The event @code{mode-line} is one of several
dummy events used as prefixes for mouse actions in special parts of a
window.

@smallexample
@group
(accessible-keymaps (current-global-map))
@result{} (([] keymap [set-mark-command beginning-of-line @dots{}
                   delete-backward-char])
@end group
@group
    ("^H" keymap (118 . describe-variable) @dots{}
     (8 . help-for-help))
@end group
@group
    ("^X" keymap [x-flush-mouse-queue @dots{}
     backward-kill-sentence])
@end group
@group
    ("^[" keymap [mark-sexp backward-sexp @dots{}
     backward-kill-word])
@end group
    ("^X4" keymap (15 . display-buffer) @dots{})
@group
    ([mode-line] keymap
     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))
@end group
@end smallexample

@noindent
These are not all the keymaps you would see in actuality.
@end defun

@defun map-keymap function keymap
The function @code{map-keymap} calls @var{function} once for each binding in
@var{keymap}.  It passes two arguments, the event type and the value of the
binding.  If @var{keymap} has a parent, the parent's bindings are included
as well.  This works recursively: if the parent has itself a parent, then
the grandparent's bindings are also included and so on.

This function is the cleanest way to examine all the bindings in a keymap.
@end defun

@defun where-is-internal command &optional keymap firstonly noindirect no-remap
This function is a subroutine used by the @code{where-is} command
(@pxref{Help, , Help, emacs,The GNU Emacs Manual}).  It returns a list of
all key sequences (of any length) that are bound to @var{command} in a set
of keymaps.

The argument @var{command} can be any object; it is compared with all keymap
entries using @code{eq}.

If @var{keymap} is @code{nil}, then the maps used are the current active
keymaps, disregarding @code{overriding-local-map} (that is, pretending its
value is @code{nil}).  If @var{keymap} is a keymap, then the maps searched
are @var{keymap} and the global keymap.  If @var{keymap} is a list of
keymaps, only those keymaps are searched.

Usually it's best to use @code{overriding-local-map} as the expression for
@var{keymap}.  Then @code{where-is-internal} searches precisely the keymaps
that are active.  To search only the global map, pass the value
@code{(keymap)} (an empty keymap) as @var{keymap}.

If @var{firstonly} is @code{non-ascii}, then the value is a single vector
representing the first key sequence found, rather than a list of all
possible key sequences.  If @var{firstonly} is @code{t}, then the value is
the first key sequence, except that key sequences consisting entirely of
@acronym{ASCII} characters (or meta variants of @acronym{ASCII} characters)
are preferred to all other key sequences and that the return value can never
be a menu binding.

If @var{noindirect} is non-@code{nil}, @code{where-is-internal} doesn't
follow indirect keymap bindings.  This makes it possible to search for an
indirect definition itself.

The fifth argument, @var{no-remap}, determines how this function treats
command remappings (@pxref{Remapping Commands}).  There are two cases of
interest:

@table @asis
@item If a command @var{other-command} is remapped to @var{command}:
If @var{no-remap} is @code{nil}, find the bindings for @var{other-command}
and treat them as though they are also bindings for @var{command}.  If
@var{no-remap} is non-@code{nil}, include the vector @code{[remap
@var{other-command}]} in the list of possible key sequences, instead of
finding those bindings.

@item If @var{command} is remapped to @var{other-command}:
If @var{no-remap} is @code{nil}, return the bindings for @var{other-command}
rather than @var{command}.  If @var{no-remap} is non-@code{nil}, return the
bindings for @var{command}, ignoring the fact that it is remapped.
@end table
@end defun

@deffn Command describe-bindings &optional prefix buffer-or-name
This function creates a listing of all current key bindings, and displays it
in a buffer named @file{*Help*}.  The text is grouped by modes---minor modes
first, then the major mode, then global bindings.

If @var{prefix} is non-@code{nil}, it should be a prefix key; then the
listing includes only keys that start with @var{prefix}.

When several characters with consecutive @acronym{ASCII} codes have the same
definition, they are shown together, as
@samp{@var{firstchar}..@var{lastchar}}.  In this instance, you need to know
the @acronym{ASCII} codes to understand which characters this means.  For
example, in the default global map, the characters @samp{@key{SPC} ..@: ~}
are described by a single line.  @key{SPC} is @acronym{ASCII} 32, @kbd{~} is
@acronym{ASCII} 126, and the characters between them include all the normal
printing characters, (e.g., letters, digits, punctuation, etc.@:); all these
characters are bound to @code{self-insert-command}.

If @var{buffer-or-name} is non-@code{nil}, it should be a buffer or a buffer
name.  Then @code{describe-bindings} lists that buffer's bindings, instead
of the current buffer's.
@end deffn

@node Menu Keymaps
@section Menu Keymaps
@cindex menu keymaps

A keymap can operate as a menu as well as defining bindings for keyboard
keys and mouse buttons.  Menus are usually actuated with the mouse, but they
can function with the keyboard also.  If a menu keymap is active for the
next input event, that activates the keyboard menu feature.

@menu
* Defining Menus::           How to make a keymap that defines a menu.
* Mouse Menus::              How users actuate the menu with the mouse.
* Keyboard Menus::           How users actuate the menu with the keyboard.
* Menu Example::             Making a simple menu.
* Menu Bar::                 How to customize the menu bar.
* Tool Bar::                 A tool bar is a row of images.
* Modifying Menus::          How to add new items to a menu.
* Easy Menu::                A convenience macro for making menus.
@end menu

@node Defining Menus
@subsection Defining Menus
@cindex defining menus
@cindex menu prompt string
@cindex prompt string (of menu)
@cindex menu item

A keymap acts as a menu if it has an @dfn{overall prompt string}, which is a
string that appears as an element of the keymap.  (@xref{Format of
Keymaps}.)  The string should describe the purpose of the menu's commands.
Emacs displays the overall prompt string as the menu title in some cases,
depending on the toolkit (if any) used for displaying menus.@footnote{It is
required for menus which do not use a toolkit, e.g., on a text terminal.}
Keyboard menus also display the overall prompt string.

The easiest way to construct a keymap with a prompt string is to specify the
string as an argument when you call @code{make-keymap},
@code{make-sparse-keymap} (@pxref{Creating Keymaps}), or
@code{define-prefix-command} (@pxref{Definition of define-prefix-command}).
If you do not want the keymap to operate as a menu, don't specify a prompt
string for it.

@defun keymap-prompt keymap
This function returns the overall prompt string of @var{keymap}, or
@code{nil} if it has none.
@end defun

The menu's items are the bindings in the keymap.  Each binding associates an
event type to a definition, but the event types have no significance for the
menu appearance.  (Usually we use pseudo-events, symbols that the keyboard
cannot generate, as the event types for menu item bindings.)  The menu is
generated entirely from the bindings that correspond in the keymap to these
events.

The order of items in the menu is the same as the order of bindings in the
keymap.  Since @code{define-key} puts new bindings at the front, you should
define the menu items starting at the bottom of the menu and moving to the
top, if you care about the order.  When you add an item to an existing menu,
you can specify its position in the menu using @code{define-key-after}
(@pxref{Modifying Menus}).

@menu
* Simple Menu Items::        A simple kind of menu key binding.
* Extended Menu Items::      More complex menu item definitions.
* Menu Separators::          Drawing a horizontal line through a menu.
* Alias Menu Items::         Using command aliases in menu items.
@end menu

@node Simple Menu Items
@subsubsection Simple Menu Items

  The simpler (and original) way to define a menu item is to bind some event
type (it doesn't matter what event type) to a binding like this:

@example
(@var{item-string} . @var{real-binding})
@end example

@noindent
The @sc{car}, @var{item-string}, is the string to be displayed in the menu.
It should be short---preferably one to three words.  It should describe the
action of the command it corresponds to.  Note that not all graphical
toolkits can display non-@acronym{ASCII} text in menus (it will work for
keyboard menus and will work to a large extent with the GTK+ toolkit).

  You can also supply a second string, called the help string, as follows:

@example
(@var{item-string} @var{help} . @var{real-binding})
@end example

@noindent
@var{help} specifies a ``help-echo'' string to display while the mouse is on
that item in the same way as @code{help-echo} text properties (@pxref{Help
display}).

  As far as @code{define-key} is concerned, @var{item-string} and
@var{help-string} are part of the event's binding.  However,
@code{lookup-key} returns just @var{real-binding}, and only
@var{real-binding} is used for executing the key.

  If @var{real-binding} is @code{nil}, then @var{item-string} appears in the
menu but cannot be selected.

  If @var{real-binding} is a symbol and has a non-@code{nil}
@code{menu-enable} property, that property is an expression that controls
whether the menu item is enabled.  Every time the keymap is used to display
a menu, Emacs evaluates the expression, and it enables the menu item only if
the expression's value is non-@code{nil}.  When a menu item is disabled, it
is displayed in a ``fuzzy'' fashion, and cannot be selected.

  The menu bar does not recalculate which items are enabled every time you
look at a menu.  This is because the X toolkit requires the whole tree of
menus in advance.  To force recalculation of the menu bar, call
@code{force-mode-line-update} (@pxref{Mode Line Format}).

@node Extended Menu Items
@subsubsection Extended Menu Items
@kindex menu-item
@cindex extended menu item

  An extended-format menu item is a more flexible and also cleaner alternative
to the simple format.  You define an event type with a binding that's a list
starting with the symbol @code{menu-item}.  For a non-selectable string, the
binding looks like this:

@example
(menu-item @var{item-name})
@end example

@noindent
A string starting with two or more dashes specifies a separator line; see
@ref{Menu Separators}.

  To define a real menu item which can be selected, the extended format
binding looks like this:

@example
(menu-item @var{item-name} @var{real-binding}
    . @var{item-property-list})
@end example

@noindent
Here, @var{item-name} is an expression which evaluates to the menu item
string.  Thus, the string need not be a constant.  The third element,
@var{real-binding}, is the command to execute.  The tail of the list,
@var{item-property-list}, has the form of a property list which contains
other information.

  Here is a table of the properties that are supported:

@table @code
@item :enable @var{form}
The result of evaluating @var{form} determines whether the item is enabled
(non-@code{nil} means yes).  If the item is not enabled, you can't really
click on it.

@item :visible @var{form}
The result of evaluating @var{form} determines whether the item should
actually appear in the menu (non-@code{nil} means yes).  If the item does
not appear, then the menu is displayed as if this item were not defined at
all.

@item :help @var{help}
The value of this property, @var{help}, specifies a ``help-echo'' string to
display while the mouse is on that item.  This is displayed in the same way
as @code{help-echo} text properties (@pxref{Help display}).  Note that this
must be a constant string, unlike the @code{help-echo} property for text and
overlays.

@item :button (@var{type} . @var{selected})
This property provides a way to define radio buttons and toggle buttons.
The @sc{car}, @var{type}, says which: it should be @code{:toggle} or
@code{:radio}.  The @sc{cdr}, @var{selected}, should be a form; the result
of evaluating it says whether this button is currently selected.

A @dfn{toggle} is a menu item which is labeled as either ``on'' or ``off''
according to the value of @var{selected}.  The command itself should toggle
@var{selected}, setting it to @code{t} if it is @code{nil}, and to
@code{nil} if it is @code{t}.  Here is how the menu item to toggle the
@code{debug-on-error} flag is defined:

@example
(menu-item "Debug on Error" toggle-debug-on-error
           :button (:toggle
                    . (and (boundp 'debug-on-error)
                           debug-on-error)))
@end example

@noindent
This works because @code{toggle-debug-on-error} is defined as a command
which toggles the variable @code{debug-on-error}.

@dfn{Radio buttons} are a group of menu items, in which at any time one and
only one is ``selected''.  There should be a variable whose value says which
one is selected at any time.  The @var{selected} form for each radio button
in the group should check whether the variable has the right value for
selecting that button.  Clicking on the button should set the variable so
that the button you clicked on becomes selected.

@item :key-sequence @var{key-sequence}
This property specifies which key sequence is likely to be bound to the same
command invoked by this menu item.  If you specify the right key sequence,
that makes preparing the menu for display run much faster.

If you specify the wrong key sequence, it has no effect; before Emacs
displays @var{key-sequence} in the menu, it verifies that @var{key-sequence}
is really equivalent to this menu item.

@item :key-sequence nil
This property indicates that there is normally no key binding which is
equivalent to this menu item.  Using this property saves time in preparing
the menu for display, because Emacs does not need to search the keymaps for
a keyboard equivalent for this menu item.

However, if the user has rebound this item's definition to a key sequence,
Emacs ignores the @code{:keys} property and finds the keyboard equivalent
anyway.

@item :keys @var{string}
This property specifies that @var{string} is the string to display as the
keyboard equivalent for this menu item.  You can use the @samp{\\[...]}
documentation construct in @var{string}.

@item :filter @var{filter-fn}
This property provides a way to compute the menu item dynamically.  The
property value @var{filter-fn} should be a function of one argument; when it
is called, its argument will be @var{real-binding}.  The function should
return the binding to use instead.

Emacs can call this function at any time that it does redisplay or operates
on menu data structures, so you should write it so it can safely be called
at any time.
@end table

@node Menu Separators
@subsubsection Menu Separators
@cindex menu separators

  A menu separator is a kind of menu item that doesn't display any
text---instead, it divides the menu into subparts with a horizontal line.  A
separator looks like this in the menu keymap:

@example
(menu-item @var{separator-type})
@end example

@noindent
where @var{separator-type} is a string starting with two or more dashes.

  In the simplest case, @var{separator-type} consists of only dashes.  That
specifies the default kind of separator.  (For compatibility, @code{""} and
@code{-} also count as separators.)

  Certain other values of @var{separator-type} specify a different style of
separator.  Here is a table of them:

@table @code
@item "--no-line"
@itemx "--space"
An extra vertical space, with no actual line.

@item "--single-line"
A single line in the menu's foreground color.

@item "--double-line"
A double line in the menu's foreground color.

@item "--single-dashed-line"
A single dashed line in the menu's foreground color.

@item "--double-dashed-line"
A double dashed line in the menu's foreground color.

@item "--shadow-etched-in"
A single line with a 3D sunken appearance.  This is the default, used
separators consisting of dashes only.

@item "--shadow-etched-out"
A single line with a 3D raised appearance.

@item "--shadow-etched-in-dash"
A single dashed line with a 3D sunken appearance.

@item "--shadow-etched-out-dash"
A single dashed line with a 3D raised appearance.

@item "--shadow-double-etched-in"
Two lines with a 3D sunken appearance.

@item "--shadow-double-etched-out"
Two lines with a 3D raised appearance.

@item "--shadow-double-etched-in-dash"
Two dashed lines with a 3D sunken appearance.

@item "--shadow-double-etched-out-dash"
Two dashed lines with a 3D raised appearance.
@end table

  You can also give these names in another style, adding a colon after the
double-dash and replacing each single dash with capitalization of the
following word.  Thus, @code{"--:singleLine"}, is equivalent to
@code{"--single-line"}.

  You can use a longer form to specify keywords such as @code{:enable} and
@code{:visible} for a menu separator:

@code{(menu-item @var{separator-type} nil . @var{item-property-list})}

For example:

@example
(menu-item "--" nil :visible (boundp 'foo))
@end example

  Some systems and display toolkits don't really handle all of these separator
types.  If you use a type that isn't supported, the menu displays a similar
kind of separator that is supported.

@node Alias Menu Items
@subsubsection Alias Menu Items

  Sometimes it is useful to make menu items that use the ``same'' command but
with different enable conditions.  The best way to do this in Emacs now is
with extended menu items; before that feature existed, it could be done by
defining alias commands and using them in menu items.  Here's an example
that makes two aliases for @code{read-only-mode} and gives them different
enable conditions:

@example
(defalias 'make-read-only 'read-only-mode)
(put 'make-read-only 'menu-enable '(not buffer-read-only))
(defalias 'make-writable 'read-only-mode)
(put 'make-writable 'menu-enable 'buffer-read-only)
@end example

When using aliases in menus, often it is useful to display the equivalent
key bindings for the ``real'' command name, not the aliases (which typically
don't have any key bindings except for the menu itself).  To request this,
give the alias symbol a non-@code{nil} @code{menu-alias} property.  Thus,

@example
(put 'make-read-only 'menu-alias t)
(put 'make-writable 'menu-alias t)
@end example

@noindent
causes menu items for @code{make-read-only} and @code{make-writable} to show
the keyboard bindings for @code{read-only-mode}.

@node Mouse Menus
@subsection Menus and the Mouse

  The usual way to make a menu keymap produce a menu is to make it the
definition of a prefix key.  (A Lisp program can explicitly pop up a menu
and receive the user's choice---see @ref{Pop-Up Menus}.)

  If the prefix key ends with a mouse event, Emacs handles the menu keymap by
popping up a visible menu, so that the user can select a choice with the
mouse.  When the user clicks on a menu item, the event generated is whatever
character or symbol has the binding that brought about that menu item.  (A
menu item may generate a series of events if the menu has multiple levels or
comes from the menu bar.)

  It's often best to use a button-down event to trigger the menu.  Then the
user can select a menu item by releasing the button.

@cindex submenu
  If the menu keymap contains a binding to a nested keymap, the nested keymap
specifies a @dfn{submenu}.  There will be a menu item, labeled by the nested
keymap's item string, and clicking on this item automatically pops up the
specified submenu.  As a special exception, if the menu keymap contains a
single nested keymap and no other menu items, the menu shows the contents of
the nested keymap directly, not as a submenu.

  However, if Emacs is compiled without X toolkit support, or on text
terminals, submenus are not supported.  Each nested keymap is shown as a
menu item, but clicking on it does not automatically pop up the submenu.  If
you wish to imitate the effect of submenus, you can do that by giving a
nested keymap an item string which starts with @samp{@@}.  This causes Emacs
to display the nested keymap using a separate @dfn{menu pane}; the rest of
the item string after the @samp{@@} is the pane label.  If Emacs is compiled
without X toolkit support, or if a menu is displayed on a text terminal,
menu panes are not used; in that case, a @samp{@@} at the beginning of an
item string is omitted when the menu label is displayed, and has no other
effect.

@node Keyboard Menus
@subsection Menus and the Keyboard

  When a prefix key ending with a keyboard event (a character or function key)
has a definition that is a menu keymap, the keymap operates as a keyboard
menu; the user specifies the next event by choosing a menu item with the
keyboard.

  Emacs displays the keyboard menu with the map's overall prompt string,
followed by the alternatives (the item strings of the map's bindings), in
the echo area.  If the bindings don't all fit at once, the user can type
@key{SPC} to see the next line of alternatives.  Successive uses of
@key{SPC} eventually get to the end of the menu and then cycle around to the
beginning.  (The variable @code{menu-prompt-more-char} specifies which
character is used for this; @key{SPC} is the default.)

  When the user has found the desired alternative from the menu, he or she
should type the corresponding character---the one whose binding is that
alternative.

@defvar menu-prompt-more-char
This variable specifies the character to use to ask to see the next line of
a menu.  Its initial value is 32, the code for @key{SPC}.
@end defvar

@node Menu Example
@subsection Menu Example
@cindex menu definition example

  Here is a complete example of defining a menu keymap.  It is the definition
of the @samp{Replace} submenu in the @samp{Edit} menu in the menu bar, and
it uses the extended menu item format (@pxref{Extended Menu Items}).  First
we create the keymap, and give it a name:

@smallexample
(defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))
@end smallexample

@noindent
Next we define the menu items:

@smallexample
(define-key menu-bar-replace-menu [tags-repl-continue]
  '(menu-item "Continue Replace" tags-loop-continue
              :help "Continue last tags replace operation"))
(define-key menu-bar-replace-menu [tags-repl]
  '(menu-item "Replace in tagged files" tags-query-replace
              :help "Interactively replace a regexp in all tagged files"))
(define-key menu-bar-replace-menu [separator-replace-tags]
  '(menu-item "--"))
;; @r{@dots{}}
@end smallexample

@noindent
Note the symbols which the bindings are ``made for''; these appear inside
square brackets, in the key sequence being defined.  In some cases, this
symbol is the same as the command name; sometimes it is different.  These
symbols are treated as ``function keys'', but they are not real function
keys on the keyboard.  They do not affect the functioning of the menu
itself, but they are ``echoed'' in the echo area when the user selects from
the menu, and they appear in the output of @code{where-is} and
@code{apropos}.

  The menu in this example is intended for use with the mouse.  If a menu is
intended for use with the keyboard, that is, if it is bound to a key
sequence ending with a keyboard event, then the menu items should be bound
to characters or ``real'' function keys, that can be typed with the
keyboard.

  The binding whose definition is @code{("--")} is a separator line.  Like a
real menu item, the separator has a key symbol, in this case
@code{separator-replace-tags}.  If one menu has two separators, they must
have two different key symbols.

  Here is how we make this menu appear as an item in the parent menu:

@example
(define-key menu-bar-edit-menu [replace]
  (list 'menu-item "Replace" menu-bar-replace-menu))
@end example

@noindent
Note that this incorporates the submenu keymap, which is the value of the
variable @code{menu-bar-replace-menu}, rather than the symbol
@code{menu-bar-replace-menu} itself.  Using that symbol in the parent menu
item would be meaningless because @code{menu-bar-replace-menu} is not a
command.

  If you wanted to attach the same replace menu to a mouse click, you can do
it this way:

@example
(define-key global-map [C-S-down-mouse-1]
   menu-bar-replace-menu)
@end example

@node Menu Bar
@subsection The Menu Bar
@cindex menu bar

  Emacs usually shows a @dfn{menu bar} at the top of each frame.  @xref{Menu
Bars,,,emacs, The GNU Emacs Manual}.  Menu bar items are subcommands of the
fake ``function key'' @code{menu-bar}, as defined in the active keymaps.

  To add an item to the menu bar, invent a fake ``function key'' of your own
(let's call it @var{key}), and make a binding for the key sequence
@code{[menu-bar @var{key}]}.  Most often, the binding is a menu keymap, so
that pressing a button on the menu bar item leads to another menu.

  When more than one active keymap defines the same ``function key'' for the
menu bar, the item appears just once.  If the user clicks on that menu bar
item, it brings up a single, combined menu containing all the subcommands of
that item---the global subcommands, the local subcommands, and the minor
mode subcommands.

  The variable @code{overriding-local-map} is normally ignored when
determining the menu bar contents.  That is, the menu bar is computed from
the keymaps that would be active if @code{overriding-local-map} were
@code{nil}.  @xref{Active Keymaps}.

  Here's an example of setting up a menu bar item:

@example
@group
;; @r{Make a menu keymap (with a prompt string)}
;; @r{and make it the menu bar item's definition.}
(define-key global-map [menu-bar words]
  (cons "Words" (make-sparse-keymap "Words")))
@end group

@group
;; @r{Define specific subcommands in this menu.}
(define-key global-map
  [menu-bar words forward]
  '("Forward word" . forward-word))
@end group
@group
(define-key global-map
  [menu-bar words backward]
  '("Backward word" . backward-word))
@end group
@end example

  A local keymap can cancel a menu bar item made by the global keymap by
rebinding the same fake function key with @code{undefined} as the binding.
For example, this is how Dired suppresses the @samp{Edit} menu bar item:

@example
(define-key dired-mode-map [menu-bar edit] 'undefined)
@end example

@noindent
Here, @code{edit} is the fake function key used by the global map for the
@samp{Edit} menu bar item.  The main reason to suppress a global menu bar
item is to regain space for mode-specific items.

@defvar menu-bar-final-items
Normally the menu bar shows global items followed by items defined by the
local maps.

This variable holds a list of fake function keys for items to display at the
end of the menu bar rather than in normal sequence.  The default value is
@code{(help-menu)}; thus, the @samp{Help} menu item normally appears at the
end of the menu bar, following local menu items.
@end defvar

@defvar menu-bar-update-hook
This normal hook is run by redisplay to update the menu bar contents, before
redisplaying the menu bar.  You can use it to update menus whose contents
should vary.  Since this hook is run frequently, we advise you to ensure
that the functions it calls do not take much time in the usual case.
@end defvar

Next to every menu bar item, Emacs displays a key binding that runs the same
command (if such a key binding exists).  This serves as a convenient hint
for users who do not know the key binding.  If a command has multiple
bindings, Emacs normally displays the first one it finds.  You can specify
one particular key binding by assigning an @code{:advertised-binding} symbol
property to the command.  @xref{Keys in Documentation}.

@node Tool Bar
@subsection Tool bars
@cindex tool bar

  A @dfn{tool bar} is a row of clickable icons at the top of a frame, just
below the menu bar.  @xref{Tool Bars,,,emacs, The GNU Emacs Manual}.  Emacs
normally shows a tool bar on graphical displays.

  On each frame, the frame parameter @code{tool-bar-lines} controls how many
lines' worth of height to reserve for the tool bar.  A zero value suppresses
the tool bar.  If the value is nonzero, and @code{auto-resize-tool-bars} is
non-@code{nil}, the tool bar expands and contracts automatically as needed
to hold the specified contents.  If the value is @code{grow-only}, the tool
bar expands automatically, but does not contract automatically.

  The tool bar contents are controlled by a menu keymap attached to a fake
``function key'' called @code{tool-bar} (much like the way the menu bar is
controlled).  So you define a tool bar item using @code{define-key}, like
this:

@example
(define-key global-map [tool-bar @var{key}] @var{item})
@end example

@noindent
where @var{key} is a fake ``function key'' to distinguish this item from
other items, and @var{item} is a menu item key binding (@pxref{Extended Menu
Items}), which says how to display this item and how it behaves.

  The usual menu keymap item properties, @code{:visible}, @code{:enable},
@code{:button}, and @code{:filter}, are useful in tool bar bindings and have
their normal meanings.  The @var{real-binding} in the item must be a
command, not a keymap; in other words, it does not work to define a tool bar
icon as a prefix key.

  The @code{:help} property specifies a ``help-echo'' string to display while
the mouse is on that item.  This is displayed in the same way as
@code{help-echo} text properties (@pxref{Help display}).

  In addition, you should use the @code{:image} property; this is how you
specify the image to display in the tool bar:

@table @code
@item :image @var{image}
@var{images} is either a single image specification or a vector of four
image specifications.  If you use a vector of four, one of them is used,
depending on circumstances:

@table @asis
@item item 0
Used when the item is enabled and selected.
@item item 1
Used when the item is enabled and deselected.
@item item 2
Used when the item is disabled and selected.
@item item 3
Used when the item is disabled and deselected.
@end table
@end table

The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled
and/or deselected images are autocomputed from item 0.

If @var{image} is a single image specification, Emacs draws the tool bar
button in disabled state by applying an edge-detection algorithm to the
image.

The @code{:rtl} property specifies an alternative image to use for
right-to-left languages.  Only the GTK+ version of Emacs supports this at
present.

Like the menu bar, the tool bar can display separators (@pxref{Menu
Separators}).  Tool bar separators are vertical rather than horizontal,
though, and only a single style is supported.  They are represented in the
tool bar keymap by @code{(menu-item "--")} entries; properties like
@code{:visible} are not supported for tool bar separators.  Separators are
rendered natively in GTK+ and Nextstep tool bars; in the other cases, they
are rendered using an image of a vertical line.

The default tool bar is defined so that items specific to editing do not
appear for major modes whose command symbol has a @code{mode-class} property
of @code{special} (@pxref{Major Mode Conventions}).  Major modes may add
items to the global bar by binding @code{[tool-bar @var{foo}]} in their
local map.  It makes sense for some major modes to replace the default tool
bar items completely, since not many can be accommodated conveniently, and
the default bindings make this easy by using an indirection through
@code{tool-bar-map}.

@defvar tool-bar-map
By default, the global map binds @code{[tool-bar]} as follows:

@example
(global-set-key [tool-bar]
                `(menu-item ,(purecopy "tool bar") ignore
                            :filter tool-bar-make-keymap))
@end example

@noindent
The function @code{tool-bar-make-keymap}, in turn, derives the actual tool
bar map dynamically from the value of the variable @code{tool-bar-map}.
Hence, you should normally adjust the default (global) tool bar by changing
that map.  Some major modes, such as Info mode, completely replace the
global tool bar by making @code{tool-bar-map} buffer-local and setting it to
a different keymap.
@end defvar

There are two convenience functions for defining tool bar items, as follows.

@defun tool-bar-add-item icon def key &rest props
This function adds an item to the tool bar by modifying
@code{tool-bar-map}.  The image to use is defined by @var{icon}, which is
the base name of an XPM, XBM or PBM image file to be located by
@code{find-image}.  Given a value @samp{"exit"}, say, @file{exit.xpm},
@file{exit.pbm} and @file{exit.xbm} would be searched for in that order on a
color display.  On a monochrome display, the search order is @samp{.pbm},
@samp{.xbm} and @samp{.xpm}.  The binding to use is the command @var{def},
and @var{key} is the fake function key symbol in the prefix keymap.  The
remaining arguments @var{props} are additional property list elements to add
to the menu item specification.

To define items in some local map, bind @code{tool-bar-map} with @code{let}
around calls of this function:
@example
(defvar foo-tool-bar-map
  (let ((tool-bar-map (make-sparse-keymap)))
    (tool-bar-add-item @dots{})
    @dots{}
    tool-bar-map))
@end example
@end defun

@defun tool-bar-add-item-from-menu command icon &optional map &rest props
This function is a convenience for defining tool bar items which are
consistent with existing menu bar bindings.  The binding of @var{command} is
looked up in the menu bar in @var{map} (default @code{global-map}) and
modified to add an image specification for @var{icon}, which is found in the
same way as by @code{tool-bar-add-item}.  The resulting binding is then
placed in @code{tool-bar-map}, so use this function only for global tool bar
items.

@var{map} must contain an appropriate keymap bound to @code{[menu-bar]}.
The remaining arguments @var{props} are additional property list elements to
add to the menu item specification.
@end defun

@defun tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props
This function is used for making non-global tool bar items.  Use it like
@code{tool-bar-add-item-from-menu} except that @var{in-map} specifies the
local map to make the definition in.  The argument @var{from-map} is like
the @var{map} argument of @code{tool-bar-add-item-from-menu}.
@end defun

@defvar auto-resize-tool-bars
If this variable is non-@code{nil}, the tool bar automatically resizes to
show all defined tool bar items---but not larger than a quarter of the
frame's height.

If the value is @code{grow-only}, the tool bar expands automatically, but
does not contract automatically.  To contract the tool bar, the user has to
redraw the frame by entering @kbd{C-l}.

If Emacs is built with GTK or Nextstep, the tool bar can only show one line,
so this variable has no effect.
@end defvar

@defvar auto-raise-tool-bar-buttons
If this variable is non-@code{nil}, tool bar items display in raised form
when the mouse moves over them.
@end defvar

@defvar tool-bar-button-margin
This variable specifies an extra margin to add around tool bar items.  The
value is an integer, a number of pixels.  The default is 4.
@end defvar

@defvar tool-bar-button-relief
This variable specifies the shadow width for tool bar items.  The value is
an integer, a number of pixels.  The default is 1.
@end defvar

@defvar tool-bar-border
This variable specifies the height of the border drawn below the tool bar
area.  An integer specifies height as a number of pixels.  If the value is
one of @code{internal-border-width} (the default) or @code{border-width},
the tool bar border height corresponds to the corresponding frame parameter.
@end defvar

  You can define a special meaning for clicking on a tool bar item with the
shift, control, meta, etc., modifiers.  You do this by setting up additional
items that relate to the original item through the fake function keys.
Specifically, the additional items should use the modified versions of the
same fake function key used to name the original item.

  Thus, if the original item was defined this way,

@example
(define-key global-map [tool-bar shell]
  '(menu-item "Shell" shell
              :image (image :type xpm :file "shell.xpm")))
@end example

@noindent
then here is how you can define clicking on the same tool bar image with the
shift modifier:

@example
(define-key global-map [tool-bar S-shell] 'some-command)
@end example

@xref{Function Keys}, for more information about how to add modifiers to
function keys.

@node Modifying Menus
@subsection Modifying Menus
@cindex menu modification

  When you insert a new item in an existing menu, you probably want to put it
in a particular place among the menu's existing items.  If you use
@code{define-key} to add the item, it normally goes at the front of the
menu.  To put it elsewhere in the menu, use @code{define-key-after}:

@defun define-key-after map key binding &optional after
Define a binding in @var{map} for @var{key}, with value @var{binding}, just
like @code{define-key}, but position the binding in @var{map} after the
binding for the event @var{after}.  The argument @var{key} should be of
length one---a vector or string with just one element.  But @var{after}
should be a single event type---a symbol or a character, not a sequence.
The new binding goes after the binding for @var{after}.  If @var{after} is
@code{t} or is omitted, then the new binding goes last, at the end of the
keymap.  However, new bindings are added before any inherited keymap.

Here is an example:

@example
(define-key-after my-menu [drink]
  '("Drink" . drink-command) 'eat)
@end example

@noindent
makes a binding for the fake function key @key{DRINK} and puts it right
after the binding for @key{EAT}.

Here is how to insert an item called @samp{Work} in the @samp{Signals} menu
of Shell mode, after the item @code{break}:

@example
(define-key-after
  (lookup-key shell-mode-map [menu-bar signals])
  [work] '("Work" . work-command) 'break)
@end example
@end defun

@node Easy Menu
@subsection Easy Menu

  The following macro provides a convenient way to define pop-up menus and/or
menu bar menus.

@defmac easy-menu-define symbol maps doc menu
This macro defines a pop-up menu and/or menu bar submenu, whose contents are
given by @var{menu}.

If @var{symbol} is non-@code{nil}, it should be a symbol; then this macro
defines @var{symbol} as a function for popping up the menu (@pxref{Pop-Up
Menus}), with @var{doc} as its documentation string.  @var{symbol} should
not be quoted.

Regardless of the value of @var{symbol}, if @var{maps} is a keymap, the menu
is added to that keymap, as a top-level menu for the menu bar (@pxref{Menu
Bar}).  It can also be a list of keymaps, in which case the menu is added
separately to each of those keymaps.

The first element of @var{menu} must be a string, which serves as the menu
label.  It may be followed by any number of the following keyword-argument
pairs:

@table @code
@item :filter @var{function}
@var{function} must be a function which, if called with one argument---the
list of the other menu items---returns the actual items to be displayed in
the menu.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the menu is
made invisible.  @code{:included} is an alias for @code{:visible}.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the menu is
not selectable.  @code{:enable} is an alias for @code{:active}.
@end table

The remaining elements in @var{menu} are menu items.

A menu item can be a vector of three elements, @code{[@var{name}
@var{callback} @var{enable}]}.  @var{name} is the menu item name (a
string).  @var{callback} is a command to run, or an expression to evaluate,
when the item is chosen.  @var{enable} is an expression; if it evaluates to
@code{nil}, the item is disabled for selection.

Alternatively, a menu item may have the form:

@smallexample
   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]
@end smallexample

@noindent
where @var{name} and @var{callback} have the same meanings as above, and
each optional @var{keyword} and @var{arg} pair should be one of the
following:

@table @code
@item :keys @var{keys}
@var{keys} is a keyboard equivalent to the menu item (a string).  This is
normally not needed, as keyboard equivalents are computed automatically.
@var{keys} is expanded with @code{substitute-command-keys} before it is
displayed (@pxref{Keys in Documentation}).

@item :key-sequence @var{keys}
@var{keys} is a hint for speeding up Emacs's first display of the menu.  It
should be @code{nil} if you know that the menu item has no keyboard
equivalent; otherwise it should be a string or vector specifying a keyboard
equivalent for the menu item.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the item is
make unselectable..  @code{:enable} is an alias for @code{:active}.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the item is
made invisible.  @code{:included} is an alias for @code{:visible}.

@item :label @var{form}
@var{form} is an expression that is evaluated to obtain a value which serves
as the menu item's label (the default is @var{name}).

@item :suffix @var{form}
@var{form} is an expression that is dynamically evaluated and whose value is
concatenated with the menu entry's label.

@item :style @var{style}
@var{style} is a symbol describing the type of menu item; it should be
@code{toggle} (a checkbox), or @code{radio} (a radio button), or anything
else (meaning an ordinary menu item).

@item :selected @var{selected}
@var{selected} is an expression; the checkbox or radio button is selected
whenever the expression's value is non-@code{nil}.

@item :help @var{help}
@var{help} is a string describing the menu item.
@end table

Alternatively, a menu item can be a string.  Then that string appears in the
menu as unselectable text.  A string consisting of dashes is displayed as a
separator (@pxref{Menu Separators}).

Alternatively, a menu item can be a list with the same format as
@var{menu}.  This is a submenu.
@end defmac

Here is an example of using @code{easy-menu-define} to define a menu similar
to the one defined in the example in @ref{Menu Bar}:

@example
(easy-menu-define words-menu global-map
  "Menu for word navigation commands."
  '("Words"
     ["Forward word" forward-word]
     ["Backward word" backward-word]))
@end example
