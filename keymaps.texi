@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Keymaps
@chapter Keymaps
@cindex keymap

  入力イベントのコマンドバインディングは、@dfn{キーマップ(keymap)}と呼ばれるデータ構造に記録されます。キーマップ内の各エントリーは個別のイベント型(他のキーマップ、またはコマンド)に関連づけ(または@dfn{バインド})されます。イベント型がキーマップにバインドされる場合、そのキーマップは次の入力イベントを調べるために使用されます。これはコマンドが見つかるまで継続されます。このプロセス全体を@dfn{キールックアップ(key
lookup: キー照合)}と呼びます。

@menu
* Key Sequences::            Lispオブジェクトとしてのキーシーケンス。
* Keymap Basics::            キーマップの基本概念。
* Format of Keymaps::        キーマップはLispオブジェクトとしてどのように見えるか。
* Creating Keymaps::         キーマップを作成、コピーする関数。
* Inheritance and Keymaps::  キーマップが他のキーマップのバインディングを継承する方法。
* Prefix Keys::              キーマップの定義としてキーを定義する。
* Active Keymaps::           Emacsがアクティブなキーマップでキーバインディングを探す方法。
* Searching Keymaps::        アクティブなマップ検索のLisp処理概要。
* Controlling Active Maps::  各バッファーは標準(グローバル)のバインディングをオーバーライドするためのキーマップをもつ。マイナーマイナーもそれらをオーバーライドできる。
* Key Lookup::               1つのキーマップからあえうキーのバインディングを探す。
* Functions for Key Lookup::  キールックアップを要求する方法。
* Changing Key Bindings::    キーマップ内でのキーの再定義。
* Remapping Commands::       キーマップはあるコマンドを他のコマンドに変換できる。
* Translation Keymaps::      イベントシーケンスを変換するキーマップ。
* Key Binding Commands::     キーの再定義にたいするインタラクティブなインターフェイス。
* Scanning Keymaps::         ヘルプをプリントするためにすべてのキーマップを走査する。
* Menu Keymaps::             キーマップとしてキーマップを定義する。
@end menu

@node Key Sequences
@section Key Sequences
@cindex key
@cindex keystroke
@cindex key sequence

  @dfn{キーシーケンス(key
sequence)}、短くは@dfn{キー(key)}とは、1つの単位を形成する1つ以上の入力イベントのシーケンスです。入力イベントには文字、ファンクションキー、マウスアクション、または@code{iconify-frame}のようなEmacs外部のシステムイベントが含まれます(@ref{Input
Events}を参照)。キーシーケンスにたいするEmacs
Lispの表現は文字列かベクターです。特に明記しない限り、引数としてキーシーケンスを受け取るEmacs
Lisp関数は両方の表現を処理することができます。

  文字列表現では、たとえば、@code{"a"}は@kbd{a}、@code{"2"}は@kbd{2}を表すといったように、英数字はその文字自身を意味します。コントロール文字イベントは部分文字列@code{"\C-"}、メタ文字は@code{"\M-"}によりプレフィクスされます。たとえば@code{"\C-x"}はキー@kbd{C-x}を表します。それらに加えて、@key{TAB}、@key{RET}、@key{ESC}、@key{DEL}などのイベントはそれぞれ@code{"\t"}、@code{"\r"}、@code{"\e"}、@code{"\d"}で表されます。複雑なキーシーケンスの文字列表現は、イベント成分の文字列表現を結合したものです。したがって@code{"\C-xl"}はキーシーケンス@kbd{C-x
l}を表します。

  キーシーケンスにはファンクションキー、マウスボタンイベント、システムイベント、または@kbd{C-=}や@kbd{H-a}のような文字列で表現できない非@acronym{ASCII}文字が含まれます。これらはベクターとして表現される必要があります。

  ベクター表現ではベクターの各要素は1つの入力イベントをイベントのLisp形式で表します。@ref{Input
Events}を参照してください。たとえば、ベクター@code{[?\C-x ?l]}はキーシーケンス@kbd{C-x l}を表します。

  キーシーケンスを文字列やベクターによる表現で記述する例は、@ref{Init Rebinding,,, emacs, The GNU Emacs
Manual}を参照してください。

@defun kbd keyseq-text
この関数はテキスト@var{keyseq-text}(文字列定数)をキーシーケンス(文字列かベクターの定数)に変換する。@var{keyseq-text}の内容は@kbd{C-x
C-k @key{RET}}(@code{kmacro-edit-macro})
コマンドにより呼び出されたバッファー内と同じ構文を使用するべきであ特にファンクションキーの名前は@samp{<@dots{}>}で囲まなければならない。@ref{Edit
Keyboard Macro,,, emacs, The GNU Emacs Manual}を参照のこと。

@example
(kbd "C-x") @result{} "\C-x"
(kbd "C-x C-f") @result{} "\C-x\C-f"
(kbd "C-x 4 C-f") @result{} "\C-x4\C-f"
(kbd "X") @result{} "X"
(kbd "RET") @result{} "\^M"
(kbd "C-c SPC") @result{} "\C-c@ "
(kbd "<f1> SPC") @result{} [f1 32]
(kbd "C-M-<down>") @result{} [C-M-down]
@end example
@end defun

@node Keymap Basics
@section Keymap Basics
@cindex key binding
@cindex binding of a key
@cindex complete key
@cindex undefined key

  キーマップは、さまざまなキーシーケンスにたいして@dfn{キーバインディング(key binding)}を指定するLispデータ構造です。

  1つのキーマップが、個々のイベントにたいする定義を直接指定します。
A single keymap directly specifies definitions for individual events.
単一のイベントでキーシーケンスが構成されるとき、そのキーシーケンスのキーマップ内でのバインディングは、そのイベントにたいするそのキーマップの定義です。それより長いキーシーケンスのバインディングは対話的プロセスにより見つけ出されます。まず、最初のイベント(これ自身がキーマップでなければならない)の定義を探します。次にそのキーマップ内で2つ目のイベントを探すといったように、そのキーシーケンス内のすべてのイベントが処理されるまで、これを続けます。

  あるキーシーケンスのバインディングがキーマップであるような場合、わたしたちはそのキーシーケンスを@dfn{プレフィクスキー(prefix
key)}と呼び、それ以外の場合は(それ以上イベントを追加できないので)@dfn{コンプリートキー(complete
keyl}と呼んでいます。バインディングが@code{nil}の場合、わたしたちはそのキーを@dfn{未定義(undefined)}と呼びます。@kbd{C-c}、@kbd{C-x}、@kbd{C-x
4}などはプレフィクスキーの例です。@kbd{X}、@key{RET}、@kbd{C-x 4
C-f}などは定義されたコンプリートキーの例です。@kbd{C-x C-g}や@kbd{C-c
3}などは未定義なコンプリートキーの例です。詳細は@ref{Prefix Keys}を参照してください。

  キーシーケンスのバインディングを見つけ出すルールは、(最後のイベントの前までに見つかる)中間的なバインディングがすべてキーマップであると仮定します。もしそうでなければ、そのイベントシーケンスは単位を形成せず、実際の単一キーシーケンスではありません。他の言い方をすると、任意の有効なキーシーケンスから1つ以上のイベントを取り除くと、常にプレフィクスキーにならなければなりません。たとえば@kbd{C-f
C-n}はキーシーケンスではありません。@kbd{C-f}はプレフィクスキーではないので、@kbd{C-f}で始まるこれより長いシーケンスは、キーシーケンスであり得ないのです。

  利用可能な複数イベントキーシーケンスのセットは、プレフィクスキーにたいするバインディングに依存します。したがって、これはキーマップが異なれば異なるかもしれず、バインディングが変更されたとき変更されるかもしれません。しかし、単一イベントキーシーケンスは適格性において任意のプレフィクスキーに依存しないので、常に単一のキーシーケンスです。

  常に複数のプライマリーキーマップ(primary keymap:
主キーマップ)がアクティブであり、これらはキーバインディングを見つけるために使用されます。すべてのバッファーで共有される@dfn{グローバルキーマップ(global
map)}というキーマップが存在します。@dfn{ローカルキーマップ(local
keymap)}は通常、特定のメジャーモードに関連します。そして0個以上の@dfn{マイナーモードキーマップ(minor mode
keymap)}はカレントで有効なマイナーモードに属します(すべてのマイナーモードがキーマップをもつわけでなない)。ローカルキーマップは、対応するグローバルバインディングをshadow(優先される)します。マイナーモードキーマップは、ローカルキーマップとグローバルキーマップの両方をshadowします。詳細は、@ref{Active
Keymaps}を参照してください。

@node Format of Keymaps
@section Format of Keymaps
@cindex format of keymaps
@cindex keymap format
@cindex full keymap
@cindex sparse keymap

  キーマップはそれぞれ、@sc{car}がシンボル@code{keymap}であるようなリストです。このリストの残りの要素は、そのキーマップのキーバインディングを定義します。関数定義がキーマップであるようなシンボルもキーマップです。あるオブジェクトがキーマップかどうかテストするには、関数@code{keymapp}(以下参照)を使用してください。

  キーマップを開始するシンボル@code{keymap}の後には、いくつかの種類の要素が出現します:

@table @code
@item (@var{type} .@: @var{binding})
これは型@var{type}のイベントにたいする1つのバインディングを指定する。通常のバインディングはそれぞれ、常に文字かシンボルであるような特定の@dfn{イベント型(event
type)}のイベントに適用される。@ref{Classifying
Events}を参照のこと。この種のバインディングでは、@var{binding}はコマンドである。

@item (@var{type} @var{item-name} .@: @var{binding})
これは、メニュー内で@var{item-name}として表示されるシンプルなメニューアイテムでもあるようなバインディングを指定する。@ref{Simple
Menu Items}を参照のこと。

@item (@var{type} @var{item-name} @var{help-string} .@: @var{binding})
これは、ヘルプ文字列@var{help-string}のシンプルなメニューアイテムである。

@item (@var{type} menu-item .@: @var{details})
これは、拡張されたメニューアイテムでもあるようなバインディングを指定する。これは他の機能も使用できる。@ref{Extended Menu
Items}を参照のこと。

@item (t .@: @var{binding})
@cindex default key binding
これは@dfn{デフォルトキーバインディング(default key
binding)}を指定する。キーマップの他の要素でバインドされないイベントは、バインディングとして@var{binding}が与えられる。デフォルトバインディングにより、利用可能なすべてのイベント型を列挙することなくバインドできる。デフォルトバインディングをもつキーマップは、明示的に@code{nil}にバインドされるイベント(以下参照)を除き、より低い優先度にあるすべてのキーマップをマスクする。

@item @var{char-table}
キーマップのある要素が文字テーブル(char-table)の場合、それは修飾ビットなしのすべての文字イベントにたいするバインディングを保持するとみなされる。
If an element of a keymap is a it counts as holding bindings for all
character events with no modifier bits (@pxref{modifier bits}):
要素@var{n}は、コード@var{n}の文字にたいするバインディングである。これは多量のバインディングを記録するための、コンパクトな方法である。そのような文字テーブルのキーマップは、@dfn{fullキーマップ(full
keymap: 完全なキーマップ)}と呼ばれる。それにたいし他のキーマップは@dfn{sparseキーマップ(sparse keymaps:
疎なキーマップ)}と呼ばれる。

@item @var{string}
@cindex keymap prompt string
@cindex overall prompt string
@cindex prompt string of keymap
キーにたいするバインディングを指定する要素は別として、キーマップは要素として文字列ももつことができる。これは@dfn{overallプロンプト文字列(overall
prompt string: 全般的なプロンプト文字列)}と呼ばれ、メニューとしてキーマップを使用することを可能にする。@ref{Defining
Menus}を参照のこと。

@item (keymap @dots{})
キーマップのある要素それ自身がキーマップの場合、それは外側のキーマップ内でこれが内側のキーマップとしてinline指定されているかのようにみなされる。これは@code{make-composed-keymap}内で行なわれるような多重継承にたいして使用される。
@end table

バインディングが@code{nil}の場合、それは定義の構成要素ではありませんが、デフォルトバインディングや親キーマップ内のバインディングに優先されます。一方、@code{nil}のバインディングは、より低い優先度のキーマップを@emph{オーバーライドしません}したがって、ローカルマップで@code{nil}のバインディングが与えられた場合、Emacsはグローバルマップのバインディングを使用します。

@cindex meta characters lookup
  キーマップはメタ文字にたいするバインディングを直接記録しません。かわりに、メタ文字は１文字目が@key{ESC}(または何であれ@code{meta-prefix-char}のカレント値)の、2文字のキーシーケンスをルックアップするものとみなされます。したがって、キー@kbd{M-a}は内部的に@kbd{@key{ESC}
a}で表され、そのグローバルバインディングは、@code{esc-map}内の@kbd{a}にたいするスロットで見つけることができます(@ref{Prefix
Keys}を参照)。

  この変換は文字にたいしてのみ適用され、ファンクションキーや他の入力イベントには適用されないので、@kbd{M-@key{end}}は@kbd{@key{ESC}
@key{end}}と何も関係ありません。

  以下に例としてLispモードにたいするローカルキーマップ(sparseキーマップ)を挙げます。以下では@key{DEL}、@kbd{C-c
C-z}、@kbd{C-M-q}、@kbd{C-M-x}にたいするバインディングを定義しています(実際の値はメニューバインディングも含みますが、簡潔にするためここでは省略しています)。

@example
@group
lisp-mode-map
@result{}
@end group
@group
(keymap
 (3 keymap
    ;; @kbd{C-c C-z}
    (26 . run-lisp))
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-x}は@kbd{@key{ESC} C-x}として扱われる}
     (24 . lisp-send-defun))
@end group
@group
 ;; @r{この部分は@code{lisp-mode-shared-map}から継承}
 keymap
 ;; @key{DEL}
 (127 . backward-delete-char-untabify)
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-q}は@kbd{@key{ESC} C-q}として扱われる}
     (17 . indent-sexp)))
@end group
@end example

@defun keymapp object
この関数は、@var{object}がキーマップなら@code{t}、それ以外は@code{nil}をリターンする。より正確には、この関数はリストにたいしてその@sc{car}が@code{keymap}か、あるいはシンボルにたいしてその関数定義が@code{keymapp}かをテストする。

@example
@group
(keymapp '(keymap))
    @result{} t
@end group
@group
(fset 'foo '(keymap))
(keymapp 'foo)
    @result{} t
@end group
@group
(keymapp (current-global-map))
    @result{} t
@end group
@end example
@end defun

@node Creating Keymaps
@section Creating Keymaps
@cindex creating keymaps

  以下はキーマップを作成する関数です。

@defun make-sparse-keymap &optional prompt
この関数はエントリーをもたない新たなsparseキーマップを作成して、それをリターンする(sparseキーマップは、あなたが通常望む類のキーマップのこと)。@code{make-keymap}とは異なり、新たなキーマップは文字テーブルを含まず、何のイベントもバインドしない。

@example
@group
(make-sparse-keymap)
    @result{} (keymap)
@end group
@end example

@var{prompt}を指定した場合、それはキーマップにたいするoverallプロンプト文字列になる。これはメニューキーマップ(@ref{Defining
Menus}を参照)にたいしてのみ指定すべきである。overallプロンプト文字列をともなうキーマップがアクティブな場合は、次の入力イベントのルックアップにたいしてマウスメニューとキーボードメニューを常に提示する。これはコマンドループにたいして毎回キーボードメニューを提示するので、overallプロンプト文字列をメインマップ、メジャーモードマップ、マイナーモードマップに指定しないこと。
@end defun

@defun make-keymap &optional prompt
この関数は、新たなfullキーマップを作成して、それをリターンする。このキーマップは修飾されないすべての文字にたいするスロットをもつ文字テーブル(@ref{Char-Tables}を参照)を含む。この新たなキーマップは、初期状態ではすべての文字、およびその他の種類のイベントが@code{nil}にバインドされている。引数@var{prompt}は、@code{make-sparse-keymap}のようにプロンプト文字列を指定する。

@c This example seems kind of pointless, but I guess it serves
@c to contrast the result with make-sparse-keymap above.
@example
@group
(make-keymap)
    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])
@end group
@end example

fullキーマップは、多くのスロットを保持するときはsparseキーマップより効果的であり、少ししかスロットを保持しないときはsparseキーマップのほうが適している。
@end defun

@defun copy-keymap keymap
@c Emacs 19 feature
この関数は、@var{keymap}のコピーをリターンする。@var{keymap}内でバインディングとして直接出現するすべてのキーマップも、すべてのレベルまで再帰的にコピーされる。しかし、ある文字の定義が関数定義にキーマップをもつ関数のときは、再帰的なコピーは行われず、新たにコピーされたキーマップには同じシンボルがコピーされる。

@example
@group
(setq map (copy-keymap (current-local-map)))
@result{} (keymap
@end group
@group
     ;; @r{(これはメタ文字を実装する)}
     (27 keymap
         (83 . center-paragraph)
         (115 . center-line))
     (9 . tab-to-tab-stop))
@end group

@group
(eq map (current-local-map))
    @result{} nil
@end group
@group
(equal map (current-local-map))
    @result{} t
@end group
@end example
@end defun

@node Inheritance and Keymaps
@section Inheritance and Keymaps
@cindex keymap inheritance
@cindex inheritance, keymap

  キーマップは、他のキーマップを継承することができ、この継承元のキーマップを@dfn{親キーマップ(parent
keymap)}と呼びます。そのようなキーマップは、以下のようなキーマップです:

@example
(keymap @var{elements}@dots{} . @var{parent-keymap})
@end example

@noindent
これの効果は、このキーマップがキールックアップ時に@var{parent-keymap}のすべてのバインディングを継承するが、それらにバインディングを追加したり、@var{elements}でオーバーライドできるということです。

@code{define-key}や他のキーバインディング関数を使用して@var{parent-keymap}内のバインディングを変更した場合、変更されたバインディングは@var{elements}で作られたバインディングにshadowされない限り、継承されたキーマップ内で可視になります。逆は真ではありません。@code{define-key}を使用して継承されたキーマップ内のバインディングを変更した場合、これらの変更は@var{elements}内に記録されますが、@var{parent-keymap}に影響はありません。

親キーマップからキーマップを構築するには、@code{set-keymap-parent}を使用するのが正しい方法です。親キーマップから直接キーマップを構築するコードがある場合は、かわりに@code{set-keymap-parent}を使用するようにプログラムを変更してください。

@defun keymap-parent keymap
これは、@var{keymap}の親キーマップをリターンする。@var{keymap}に親キーマップがない場合、@code{keymap-parent}は@code{nil}をリターンする。
@end defun

@defun set-keymap-parent keymap parent
これは@var{keymap}の親キーマップを@var{parent}にセットして、@var{parent}をリターンする。@var{parent}が@code{nil}の場合、この関数は@var{keymap}に親キーマップを与えない。

@var{keymap}がサブマップ(プレフィクスキーにたいするバインディング)をもつ場合は、それらも新たな親キーマップを受け取り、それらのプレフィクスキーにたいして@var{parent}が何を指定するかが反映される。
@end defun

   以下は@code{text-mode-map}から継承してキーマップを作成する方法を示す例です:

@example
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  map)
@end example

  非sparseキーマップも親キーマップをもつことができますが、便利とは言えません。非sparseキーマップは、修飾ビットをもたないすべての数値文字コードにたいするバインディングとして、たとえそれが@code{nil}であっても常に何かを指定するので、これらの文字のバインディングが親キーマップから継承されることは決してないのです。

@cindex keymap inheritance from multiple maps
  複数のマップからキーマップを継承したいときがあるかもしれません。これにたいしては、関数@code{make-composed-keymap}が使用できます。

@defun make-composed-keymap maps &optional parent
この関数は、既存のキーマップから構成される新たなキーマップをリターンする。また、オプションで親キーマップ@var{parent}から継承する。@var{maps}には単一のキーマップ、または複数のキーマップのリストを指定できる。リターンされた新たなマップ内でキーをルックアップするとき、Emacsは@var{maps}内のキーマップを順に検索してから@var{parent}内を検索する。この検索は最初のマッチで停止される。@var{maps}のどれか1つのキーマップ内の@code{nil}バインディングは、@var{parent}内の任意のバインディングをオーバーライドするが、@var{maps}にないキーマップの非@code{nil}バインディングはオーバーライドしない。
@end defun

@noindent For example, here is how Emacs sets the parent of
【FIXME】たとえば、以下は@code{button-buffer-map}と@code{special-mode-map}の両方を継承する@code{help-mode-map}のようなキーマップの親キーマップをEmacsがセットする方法です:

@example
(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map
      (make-composed-keymap button-buffer-map special-mode-map))
    ... map) ... )
@end example


@node Prefix Keys
@section Prefix Keys
@cindex prefix key

  @dfn{プレフィクスキー(prefix
key)}とは、バインディングがキーマップであるようなキーシーケンスです。このキーマップは、プレフィクスキーを拡張するキーシーケンスが何を行うか定義します。たとえば、@kbd{C-x}はプレフィクスキーであり、これはキーマップを使用し、そのキーマップは変数@code{ctl-x-map}にも格納されています。このキーマップは@kbd{C-x}で始まるキーシーケンスにたいするバインディングを定義します。

  標準的なEmacsのプレフィクスキーのいくつかは、Lisp変数でも見い出すことができるキーマップを使用していますl:

@itemize @bullet
@item
@vindex esc-map
@findex ESC-prefix
@code{esc-map}は、プレフィクスキー@key{ESC}にたいするグローバルキーマップである。したがって、すべてのメタ文字にたいする定義は、このキーマップで見つけることができる。このマップは、@code{ESC-prefix}の関数定義でもある。

@item
@cindex @kbd{C-h}
@code{help-map}は、プレフィクスキー@kbd{C-h}にたいするグローバルキーマップである。

@item
@cindex @kbd{C-c}
@vindex mode-specific-map
@code{mode-specific-map}は、プレフィクスキー@kbd{C-c}にたいするグローバルキーマップである。このマップは実際にはモード特有(mode-specific)ではなくグローバルであるが、このプレフィクスキーは主にモード特有なバインディングに使用されるので、@kbd{C-h
b}(@code{display-bindings})の出力内の@kbd{C-c}に関する情報で、この名前は有意義な情報を提供する。

@item
@cindex @kbd{C-x}
@vindex ctl-x-map
@findex Control-X-prefix
@code{ctl-x-map}は、プレフィクスキー@kbd{C-x}にたいして使用されるグローバルキーマップである。このマップは、シンボル@code{Control-X-prefix}の関数セルを通して見つけることができる。

@item
@cindex @kbd{C-x @key{RET}}
@vindex mule-keymap
@code{mule-keymap}は、プレフィクスキー@kbd{C-x @key{RET}} にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 4}
@vindex ctl-x-4-map
@code{ctl-x-4-map}は、プレフィクスキー@kbd{C-x 4}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 5}
@vindex ctl-x-5-map
@code{ctl-x-5-map}は、プレフィクスキー@kbd{C-x 5}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x 6}
@vindex 2C-mode-map
@code{2C-mode-map}は、プレフィクスキー@kbd{C-x 6}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{C-x v}
@vindex vc-prefix-map
@code{vc-prefix-map}は、プレフィクスキー@kbd{C-x v}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-g}
@vindex goto-map
@code{goto-map}は、プレフィクスキー@kbd{M-g}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-s}
@vindex search-map
@code{search-map}は、プレフィクスキー@kbd{M-s}にたいして使用されるグローバルキーマップである。

@item
@cindex @kbd{M-o}
@vindex facemenu-keymap
@code{facemenu-keymap}は、プレフィクスキー@kbd{M-o}にたいして使用されるグローバルキーマップである。

@item
Emacsの他のプレフィクスキーには@kbd{C-x @@}、@kbd{C-x a i}、@kbd{C-x
@key{ESC}}、@kbd{@key{ESC} @key{ESC}}がある。これらは、特別な名前をもたないキーマップを使用する。
@end itemize

  プレフィクスキーのキーマップバインディングは、プレフィクスキーに続くイベントをルックアップするために使用されます。(これは、関数定義がキーマップであるようなシンボルかもしれません。効果は同じですが、シンボルはプレフィクスキーにたいする名前の役割を果たします。)
したがって、@kbd{C-x}のバインディングはシンボル@code{Control-X-prefix}であり、このシンボルの関数セルが@kbd{C-x}コマンドにたいするキーマップを保持します(@code{ctl-x-map}の値も同じキーマップです)。

  プレフィクスキー定義は、任意のアクティブなキーマップ内に置くことができます。プレフィクスキーとしての@kbd{C-c}、@kbd{C-x}、@kbd{C-h}、@key{ESC}の定義はグローバルマップ内にもあるので、これらのプレフィクスキーは常に使用できます。メジャーモードとマイナーモードは、ローカルマップやマイナーモードのマップ内にプレフィクスキー定義を置くことにより、キーをプレフィクスキーとして再定義できます。
@ref{Active Keymaps}を参照してください。

  あるキーが複数のアクティブなマップ内でプレフィクスキーとして定義されている場合、それぞれの定義がマージされて効果をもちます。まずマイナーモードキーマップ内で定義されたコマンド、次にローカルマップのプレフィクス定義されたコマンド、そしてグローバルマップのコマンドが続きます。

  以下の例では、ローカルキーマップ内で@kbd{C-p}を@kbd{C-x}と等価なプレフィクスキーにしています。すると、@kbd{C-p
C-f}にたいするバインディングは、@kbd{C-x C-f}と同様に関数@code{find-file}になります。キーシーケンス@kbd{C-p
6}は、すべてのアクティブなキーマップで見つけることができません。

@example
@group
(use-local-map (make-sparse-keymap))
    @result{} nil
@end group
@group
(local-set-key "\C-p" ctl-x-map)
    @result{} nil
@end group
@group
(key-binding "\C-p\C-f")
    @result{} find-file
@end group

@group
(key-binding "\C-p6")
    @result{} nil
@end group
@end example

@defun define-prefix-command symbol &optional mapvar prompt
@cindex prefix command
@anchor{Definition of define-prefix-command}
この関数は、プレフィクスキーのバインディングとして使用するために、@var{symbol}を用意する。これはsparseキーマップを作成して、それを@var{symbol}の関数定義として格納する。その後は@var{symbol}にキーシーケンスをバインディングすると、そのキーシーケンスはプレフィクスキーになるだろう。リターン値は@code{symbol}である。

この関数は、値がそのキーマップであるような変数としても@var{symbol}をセットする。しかし@var{mapvar}が非@code{nil}の場合は、かわりに@var{mapvar}を変数としてセットする。

@var{prompt}が非@code{nil}の場合、これはそのキーマップにたいするoverallプロンプト文字列になる。プロンプト文字列はメニューキーマップにたいして与えられるべきである(@ref{Defining
Menus}を参照)。
@end defun

@node Active Keymaps
@section Active Keymaps
@cindex active keymap

  Emacsは多くのキーマップを含んでいますが、常にいくつかのキーマップだけが@dfn{アクティブ}です。Emacsがユーザー入力を受け取ったとき、それは入力イベントに変換されて(@ref{Translation
Keymaps}を参照)、アクティブなキーマップ内でキーバインディングが照合されます。

  アクティブなキーマップは通常、(1) @code{keymap}プロパティにより指定されるキーマップ、(2) 有効なマイナーモードのキーマップ、(3)
カレントバッファーのローカルキーマップ、(4)
グローバルキーマップの順です。Emacsは入力キーシーケンスそれぞれにたいして、これらすべてのキーマップ内を検索します。

  これらの``通常''のキーマップのうち最優先されるのは、もしあればポイント位置の@code{keymap}テキストにより指定されるキーマップ、またはoverallプロパティです。(マウス入力イベントにたいしては、Emacsはポイント位置のかわりにイベント位置を使用する。
@iftex
詳細は次のセクションを参照のこと。)
@end iftex
@ifnottex
@ref{Searching Keymaps}を参照のこと。)
@end ifnottex

  次に優先されるのは、有効なマイナーモードにより指定されるキーマップです。もしあれば、これらのキーマップは変数@code{emulation-mode-map-alists}、@code{minor-mode-overriding-map-alist}、@code{minor-mode-map-alist}により指定されます。@ref{Controlling
Active Maps}を参照してください。

@cindex local keymap
  次に優先されるのは、バッファーの@dfn{ローカルキーマップ(local
keymap)}で、これにはそのバッファー特有なキーバインディングが含まれます。ミニバッファーもローカルキーマップをもちます(@ref{Intro to
Minibuffers}を参照)。ポイント位置に@code{local-map}テキスト、またはoverlayプロパティがある場合、それはバッファーのデフォルトローカルキーマップのかわりに使用するローカルキーマップを指定します。

@cindex major mode keymap
  ローカルキーマップは通常はそのバッファーのメジャーモードによりセットされます。同じメジャーモードをもつすべてのバッファーは、同じローカルキーマップを共有します。したがって、あるバッファーでローカルキーマップを変更するために@code{local-set-key}(@ref{Key
Binding Commands}を参照)を呼び出した場合、それは同じメジャーモードをもつ他のバッファーのローカルキーマップにも影響を与えます。

@cindex global keymap
  最後は、@kbd{C-f}のようなカレントバッファーとは関係なく定義されるキーバインディングを含む、@dfn{グローバルキーマップ(global
keymap)}です。kこのキーマップは常にアクティブであり、変数@code{global-map}にバインドされています。

  これら``通常''のキーマップとは別に、Emacsはプログラムが他のキーマップをアクティブにするための特別な手段を提供します。1つ目は、グローバルキーマップ以外の通常アクティブなキーマップを置き換えるキーマップを指定する変数@code{overriding-local-map}です。2つ目は、他の@emph{すべて}のキーマップより優先されるキーマップを指定する、端末ローカル変数@code{overriding-terminal-local-map}です。この端末ローカル変数は通常、modal(訳注:
他のキーマップを選択できない状態)かつ一時的なキーバインディングに使用されます(ここの変数にたいして関数@code{set-transient-map}は便利なインターフェイスを提供する)。詳細は、@ref{Controlling
Active Maps}を参照のこと。

  これらを使用するのがキーマップをアクティブにする唯一の方法ではありません。キーマップは、@code{read-key-sequence}によるイベントの変換のような、他の用途にも使用されます。@ref{Translation
Keymaps}を参照してください。

  いくつかの標準的なキーマップのリストは、@ref{Standard Keymaps}を参照してください。

@defun current-active-maps &optional olp position
これは、カレントの状況下でコマンドループによりキーシーケンスをルックアップするために使用される、アクティブなキーマップのリストをリターンする。これは通常、@code{overriding-local-map}と@code{overriding-terminal-local-map}を無視するが、@var{olp}が非@code{nil}の場合には、それらのキーマップにも注意を払う。オプションで@var{position}に@code{event-start}によりリターンされるイベント位置、またはバッファー位置を指定でき、@code{key-binding}で説明されているようにキーマップを変更するかもしれない。
@end defun

@defun key-binding key &optional accept-defaults no-remap position
この関数は、カレントのアクティブキーマップで@var{key}にたいするバインディングをリターンする。そのキーマップ内で@var{key}が未定義の場合、結果は@code{nil}になる。

引数@var{accept-defaults}は、@code{lookup-key}(@ref{Functions for Key
Lookup}を参照)のようにデフォルトバインディングをチェックするかを制御する。

コマンドがリマップ(remap: 再マップ。@ref{Remapping
Commands}を参照)されたとき、@code{key-binding}は通常、実際に実行されるであろうリマップされたコマンドをリターンするように、コマンドのリマップを行う。しかし、@var{no-remap}が非@code{nil}の場合、@code{key-binding}はリマップを無視して、@var{key}にたいして直接指定されたバインディングをリターンする。

@var{key}がマウスイベント(もしかしたらプレフィクスイベントが先行するかもしれない)で始まる場合、照合されるマップはそのイベントの位置を元に決定される。それ以外では、それらのマップはポイント値に基づき決定される。しかし、@var{position}を指定することにより、これらをオーバーライドできる。@var{position}が非@code{nil}の場合、それはバッファー位置か@code{event-start}の値のようなイベント位置のいずれかである。その場合、照合されるマップは@var{position}に基づき決定される。

@var{key}が文字列とベクターのいずれでもない場合、Emacsはエラーをシグナルする。

@example
@group
(key-binding "\C-x\C-f")
    @result{} find-file
@end group
@end example
@end defun

@node Searching Keymaps
@section Searching the Active Keymaps
@cindex searching active keymaps for keys

以下は、macsがアクティブなキーマップを検索する方法を示す、Lisp処理概要です:

@lisp
(or (if overriding-terminal-local-map
        (@var{find-in} overriding-terminal-local-map))
    (if overriding-local-map
        (@var{find-in} overriding-local-map)
      (or (@var{find-in} (get-char-property (point) 'keymap))
          (@var{find-in-any} emulation-mode-map-alists)
          (@var{find-in-any} minor-mode-overriding-map-alist)
          (@var{find-in-any} minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (@var{find-in} (get-char-property (point) 'local-map))
            (@var{find-in} (current-local-map)))))
    (@var{find-in} (current-global-map)))
@end lisp

@noindent
ここで、@var{find-in}と@var{find-in-any}はそれぞれ、1つのキーマップとキーマップのalistを検索する仮の関数です。関数@code{set-transient-map}が@code{overriding-terminal-local-map}(@ref{Controlling
Active Maps}を参照)をセットすることにより機能する点に注意してください。

  上記の処理概要では、キーシーケンスがマウスイベント(@ref{Mouse
Events}を参照)で始まる場合、ポイント位置のかわりにそのイベント位置、カレントバッファーのかわりにそのイベントのバッファーが使用されます。これは特に、プロパティ@code{keymap}および@code{local-map}をルックアップする方法に影響を与えます。@code{display}、@code{before-string}、@code{after-string}プロパティ(@ref{Special
Properties}を参照)が埋め込まれていて、@code{keymap}または@code{local-map}プロパティが非@code{nil}の文字列上でマウスイベントが発生した場合、それは基調となるバッファーテキストの対応するプロパティをオーバーライドします(バッファーテキストにより指定されたプロパティは無視される)。

  アクティブなキーマップの1つでキーバインディングが見つかり、そのバインディングがコマンドの場合、検索は終了し、そのコマンドが実行されます。しかし、そのバインディングが値をもつ変数、または文字列の場合、Emacsは入力キーシーケンスをその変数の値、または文字列で置き換えて、アクティブなキーマップの検索を再開します。
@ref{Key Lookup}を参照してください。

  最終的に見つかったコマンドもリマップされるかもしれません。@ref{Remapping Commands}を参照してください。

@node Controlling Active Maps
@section Controlling the Active Keymaps
@cindex active keymap, controlling

@defvar global-map
この変数は、Emacsキーボード入力をコマンドにマップするデフォルトのグローバルキーマップを含む。通常は、このキーマップがグローバルキーマップである。デフォルトグローバルキーマップは、@code{self-insert-command}をすべてのプリント文字にバインドするfullキーマップである。

これはグローバルキーマップ内のバインディングを変更する通常の手段だが、この変数に開始時のキーマップ以外の値を割り当てるべきではない。
@end defvar

@defun current-global-map
この関数は、カレントのグローバルキーマップをリターンする。デフォルトグローバルキーマップとカレントグローバルキーマップのいずれも変更していない場合は、@code{global-map}と同じ値になる。リターン値はコピーではなく参照である。これに@code{define-key}などの関数を使用すると、グローバルバインディングが変更されるだろう。

@example
@group
(current-global-map)
@result{} (keymap [set-mark-command beginning-of-line @dots{}
            delete-backward-char])
@end group
@end example
@end defun

@defun current-local-map
この関数はカレントバッファーのローカルキーマップをリターンする。ローカルキーマップがない場合は@code{nil}をリターンする。以下の例では、(Lisp
Interactionモードを使用する)@file{*scratch*}バッファーにたいするキーマップは、@key{ESC}(@acronym{ASCII}コード27)にたいするエントリーが別のsparseキーマップであるようなsparseキーマップである。

@example
@group
(current-local-map)
@result{} (keymap
    (10 . eval-print-last-sexp)
    (9 . lisp-indent-line)
    (127 . backward-delete-char-untabify)
@end group
@group
    (27 keymap
        (24 . eval-defun)
        (17 . indent-sexp)))
@end group
@end example
@end defun

@code{current-local-map}はローカルキーマップのコピーではなく参照をリターンする。これに@code{define-key}などの関数を使用すると、ローカルバインディングが変更されるだろう。

@defun current-minor-mode-maps
この関数は、カレントで有効なメジャーモードのキーマップリストをリターンする。
@end defun

@defun use-global-map keymap
この関数は、@var{keymap}を新たなカレントグローバルキーマップにする。これは@code{nil}をリターンする。

グローバルキーマップの変更は、異例である。
@end defun

@defun use-local-map keymap
この関数は、@var{keymap}をカレントバッファーの新たなローカルキーマップにする。@var{keymap}が@code{nil}の場合、そのバッファーはローカルキーマップをもたない。@code{use-local-map}は@code{nil}をリターンする。ほとんどのメジャーモードコマンドは、この関数を使用する。
@end defun

@defvar minor-mode-map-alist
@anchor{Definition of minor-mode-map-alist}
この変数は、アクティブかどうかに関わらず、特定の変数の値にたいするキーマップを示すalistである。要素は、以下のようになる:

@example
(@var{variable} . @var{keymap})
@end example

キーマップ@var{keymap}は、
@var{variable}が非@code{nil}値をもつときはアクティブである。通常、@var{variable}はメジャーモードを有効、または無効にする変数である。@ref{Keymaps
and Minor Modes}を参照のこと。

@code{minor-mode-map-alist}の要素が、@code{minor-mode-alist}の要素と異なる構造をもつことに注意されたい。マップは要素の@sc{cdr}でなければならず、そうでなければ2つ目の要素にマップリストは用いられないだろう。@sc{cdr}はキーマップ(リスト)、または関数定義がキーマップであるようなシンボルである。

1つ以上のマイナーモードキーマップがアクティブなとき、@code{minor-mode-map-alist}内で前のキーマップが優先される。しかし、互いが干渉しないようにマイナーモードをデザインすべきである。これを正しく行えば、順序は問題にならない。

マイナーモードについての詳細な情報は、@ref{Keymaps and Minor
Modes}を参照のこと。@code{minor-mode-key-binding}(@pxref{Functions for Key
Lookup}を参照)も確認されたい。
@end defvar

@defvar minor-mode-overriding-map-alist
この変数は、メジャーモードによる特定のマイナーモードにたいするキーバインディングのオーバーライドを可能にする。このalistの要素は、@code{minor-mode-map-alist}の要素のように、@code{(@var{variable}
. @var{keymap})}のような形式である。

ある変数が@code{minor-mode-overriding-map-alist}の要素として出現する場合、その要素により指定されるマップは、@code{minor-mode-map-alist}内の同じ変数にたいして指定される任意のマップを完全に置き換える。

すべてのバッファーにおいて、@code{minor-mode-overriding-map-alist}は自動的にバッファーローカルである。
@end defvar

@defvar overriding-local-map
この変数が非@code{nil}の場合は、バッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、マイナーモードキーマップのかわりに使用されるするキーマップを保持する。このキーマップが指定された場合、カレントグローバルキーマップ以外のアクティブだった他のすべてのマップがオーバーライドされる。
@end defvar

@defvar overriding-terminal-local-map
この変数が非@code{nil}の場合は、@code{overriding-local-map}、バッファーのローカルキーマップ、テキストプロパティまたはoverlayによるキーマップ、およびすべてのマイナーモードキーマップのかわりに使用されるキーマップを保持する。

この変数は、カレント端末にたいして常にローカルであり、バッファーローカルにできない。@ref{Multiple
Terminals}を参照のこと。これはインクリメンタル検索モードの実装に使用される。
@end defvar

@defvar overriding-local-map-menu-flag
この変数が非@code{nil}の場合は、@code{overriding-local-map}または@code{overriding-terminal-local-map}の値がメニューバーの表示に影響し得る。デフォルト値は@code{nil}なので、これらのマップ変数なメニューバーに影響をもたない。

これら2つのマップ変数は、たとえこれらの変数がメニューバー表示に影響し得るを与えない場合でも、メニューバーを使用してエンターされたキーシーケンスの実行には影響を与えることに注意されたい。したがって、もしメニューバーキーシーケンスが到着したら、そのキーシーケンスをルックアップ・実行する前に変数をクリアーすべきである。この変数を使用するモードは通常、何らかの方法でこれを行っている。これらのモードは通常``読み戻し(unread)''とexitにより処理されないイベントに応答する。
@end defvar

@defvar special-event-map
この変数は、スペシャルイベントにたいするキーマップを保持する。あるイベント型がこのキーマップ内でバインディングをもつ場合、それはスペシャルであり、そのイベントにたいするバインディングは@code{read-event}により直接実行される。@ref{Special
Events}を参照のこと。
@end defvar

@defvar emulation-mode-map-alists
この変数は、エミュレーションモードにたいして使用するキーマップalistのリストを保持する。この変数は、複数マイナーモードキーマップを使用するモードとパッケージを意図している。リストの各要素は@code{minor-mode-map-alist}と同じフォーマットと意味をもつキーマップalistか、そのようなalist形式の変数バインディングをもつシンボルである。それぞれのalist内の``アクティブ''なキーマップは、@code{minor-mode-map-alist}と@code{minor-mode-overriding-map-alist}の前に使用される。
@end defvar

@cindex transient keymap
@defun set-transient-map keymap &optional keep
この関数は@dfn{一時的(transient)}なキーマップとして@var{keymap}を追加する。一時的なキーマップは1つ以上の後続するキーにたいして、他のキーマップより優先される。

通常、@var{keymap}は直後のキーをルックアップするために、1回だけ使用される。しかし、オプション引数@var{pred}が@code{t}の場合、そのマップはユーザーが@var{keymap}内で定義されたキーをタイプするまでアクのままとなる。@var{keymap}内にないキーをユーザーがタイプしたとき、一時的キーマップは非アクティブとなり、そのキーにたいして通常のキールックアップが継続される。

@var{pred}には関数も指定できる。。この場合、@var{keymap}がアクティブの間は、各コマンドの実行に優先して、その関数が引数なしで呼び出される。@var{keymap}がアクティブの間、関数は非@code{nil}をリターンすべきである。

この関数は、他のすべてのアクティブなキーマップに優先される変数@code{overriding-terminal-local-map}にたいして、@code{keymap}を追加、または削除することにより機能する(@ref{Searching
Keymaps}を参照)。
@end defun

@node Key Lookup
@section Key Lookup
@cindex key lookup
@cindex keymap entry

  @dfn{キールックアップ(key lookup:
キー照合)}とは、与えられたキーマップからキーシーケンスのバインディングを見つけ出すことです。そのバインディングの使用や実行は、キールックアップの一部ではありません。

  キールックアップは、キーシーケンス内の各イベントのイベント型だけを使用し、そのイベントの残りは無視します。実際のところ、キールックアップに使用されるキーシーケンスは、マウスイベントをイベント全体(リスト)のかわりにイベント型のみ(シンボル)を用いるでしょう。@ref{Input
Events}を参照してください。そのような``キーシーケンス''は、@code{command-execute}による実行には不十分ですが、キーのルックアップやリバインドには十分です。

  キーシーケンスが複数イベントから構成されるとき、キールックアップはイベントを順に処理します。最初のイベントのバインディングが見つかったとき、それはキーマップでなければなりません。そのキーマップ内で2つ目のイベントを見つけ出し、そのキーシーケンス内のすべてのイベントが消費されるまで、このプロセスを続けます(故に、最後のイベントにたいして見つかったイベントはキーマップかどうかわからない)。したがって、キールックアッププロセスは、キーマップ内で単一イベントを見つけ出す、よりシンプルなプロセスで定義されます。これが行なわれる方法は、キーマップ内でそのイベントに関連するオブジェクトの型に依存します。

  キーマップ内のイベント型ルックアップによる値発見を説明するために、@dfn{キーマップエントリー(keymap
entry)}という用語を導入しましょう。(これにはメニューアイテムにたいするキーマップ内のアイテム文字列や、他の余計な要素は含まれません。なぜなら、@code{lookup-key}や他のキーマップルックアップ関数が、リターン値にそれらを含まないからです。)
任意のLispオブジェクトがキーマップエントリーとしてキーマップに格納されるかもしれませんが、すべてがキールックアップに意味をもつわけではありません。以下のテーブルは、キーマップエントリーで重要な型です:

@table @asis
@item @code{nil}
@cindex @code{nil} in keymap
@code{nil}は、それまでにルックアップに使用されたイベントが、未定義キーを形成することを意味する。最終的にキーマップがイベント型を調べるのに失敗して、デフォルトバインディングも存在しないときは、そのイベント型のバインディングが@code{nil}であるのと同じである。

@item @var{command}
@cindex command in keymap
それまでにルックアップに使用されたイベントがコンプリートキーを形成し、そのバインディングは@var{command}である。@ref{What Is a
Function}を参照のこと。

@item @var{array}
@cindex string in keymap
array(文字列かベクター)は、キーボードマクロである。それまでにルックアップに使用されたイベントはコンプリートキーを形成し、そのバインディングはarrayである。詳細は@ref{Keyboard
Macros}を参照のこと。

@item @var{keymap}
@cindex keymap in keymap
それまでにルックアップに使用されたイベントはプレフィクスキーを形成する。そのキーシーケンスの次のイベントは、@var{keymap}内でルックアップされる。

@item @var{list}
@cindex list in keymap
listの意味は、そのリストが何を含んでいるかに依存する:

@itemize @bullet
@item
@var{list}の@sc{car}がシンボル@code{keymap}の場合、そのリストはキーマップであり、キーマップとして扱われる(上記参照)。

@item
@cindex @code{lambda} in keymap
@var{list}の@sc{car}が@code{lambda}の場合、そのリストはラムダ式である。これは関数とみなされ、そのように扱われる(上記参照)。キーバインディングとして正しく実行されるために、この関数はコマンドでなければならず、@code{interactive}指定をもたなければならない。@ref{Defining
Commands}を参照のこと。

@item
@var{list}の@sc{car}がキーマップで@sc{cdr}がイベント型の場合、これは@dfn{インダイレクトエントリー(indirect
entry: 間接エントリー)}である:

@example
(@var{othermap} . @var{othertype})
@end example

キールックアップはインダイレクトエントリーに遭遇したときは、かわりに@var{othermap}内で@var{othertype}のバインディングをルックアップして、それを使用する。

この機能により、あるキーを他のキーにたいするalistとして定義することが可能になる。たとえば、@sc{car}が@code{esc-map}と呼ばれるキーマップで、@sc{cdr}が32(@key{SPC}のコード)の場合は、``それが何であろうと@kbd{Meta-@key{SPC}}のグローバルバインディングを使用する''ことを意味する。
@end itemize

@item @var{symbol}
@cindex symbol in keymap
@var{symbol}の関数定義が@var{symbol}のかわりに使用される。もし関数定義もシンボルの場合は、任意の回数このプロセスが繰り返される。これは最終的にキーマップであるようなオブジェクト、コマンド、またはキーボードマクロに行き着くはずである。それがキーマップかコマンドの場合はリストも許されるが、シンボルを通じて見つけ出された場合、インダイレクトエントリーは理解されない。

キーマップおよびキーボードマクロ(文字列かベクター)は有効な関数ではないので、関数定義にキーマップ、文字列、ベクターをもつシンボルは、関数としては無効であることに注意されたい。しかし、キーバインディングとしては有効である。その定義がキーボードマクロの場合、そのシンボルは@code{command-execute}(@ref{Interactive
Call}を参照)の引数としても有効である。

@cindex @code{undefined} in keymap
シンボル@code{undefined}は特記するに値する。これはそのキーを未定義として扱うことを意味する。厳密に言うと、そのキーは定義されているが、そのバインディングがコマンド@code{undefined}なのである。しかし、このコマンドは未定義キーにたいして自動的に行われるのと同じことを行う。これは(@code{ding}を呼び出して)bellを鳴らすが、エラーはシグナルしない。

@cindex preventing prefix key
@code{undefined}は、グローバルキーバインディングをオーバーライドして、そのキーをローカルに``未定義''にするために使用される。@code{nil}にローカルにバインドしても、グローバルバインディングをオーバーライドしないであろうから、これを行うのに失敗するだろう。

@item @var{anything else}
オブジェクトの他の型が見つかった場合、それまでにルックアップで使用されたイベントはコンプリートキーを形成し、そのオブジェクトがバインディングになるが、そのバインディングはコマンドとして実行不可能である。
@end table

  要約すると、キーマップエントリーはキーマップ、コマンド、キーボードマクロ、あるいはそれらに導出されるシンボル、インダイレクトエントリー、あるいは@code{nil}のいずれかです。

@node Functions for Key Lookup
@section Functions for Key Lookup

  以下は、キールックアップに関連する関数および変数です。

@defun lookup-key keymap key &optional accept-defaults
この関数は、@var{keymap}内の@var{key}の定義をリターンする。このチャプターで説明されている、キーをルックアップする他のすべての関数が@code{lookup-key}を使用する。以下は例である:

@example
@group
(lookup-key (current-global-map) "\C-x\C-f")
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) (kbd "C-x C-f"))
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) "\C-x\C-f12345")
    @result{} 2
@end group
@end example

文字列、またはベクターの@var{key}が、@var{keymap}内で指定されるプレフィクスキーとして有効なキーシーケンスでない場合、それは最後に余計なイベントをもつ、単一のキーシーケンスに適合しない、``長過ぎる''キーのはずである。その場合のリターン値は数となり、この数はコンプリートキーを構成する@var{key}の前にあるイベントの数である。

@c Emacs 19 feature
@var{accept-defaults}が非@code{nil}の場合、@code{lookup-key}は@var{key}内の特定のイベントにたいするバインディングと同様に、デフォルトバインディングも考慮する。それ以外では、@code{lookup-key}は特定の@var{key}のシーケンスにたいするバインディングだけを報告し、明示的に指定したとき以外はデフォルトバインディングを無視する。(これを行うには、@var{key}の要素として@code{t}を与える。@ref{Format
of Keymaps}を参照のこと。)

@var{key}がメタ文字(ファンクションキーではない)を含む場合その文字は暗黙に@code{meta-prefix-char}の値と対応する非メタ文字からなる、2文字シーケンスに置き換えられる。したがって、以下に1つ目の例は、2つ目の例に変換されて処理される。

@example
@group
(lookup-key (current-global-map) "\M-f")
    @result{} forward-word
@end group
@group
(lookup-key (current-global-map) "\ef")
    @result{} forward-word
@end group
@end example

@code{read-key-sequence}とは異なり、この関数は指定されたイベントの情報を破棄する変更(@ref{Key Sequence
Input}を参照)を行わない。特に、この関数はアルファベット文字を小文字に変更せず、ドラッグイベントをクリックイベントに変更しない。
@end defun

@deffn Command undefined
キーを未定義にするために、キーマップ内で使用される。これは@code{ding}を呼び出すが、エラーを起こさない。
@end deffn

@defun local-key-binding key &optional accept-defaults
この関数は、カレントのローカルキーマップ内の、@var{key}にたいするバインディングをリターンする。カレントのローカルキーマップ内で未定義の場合は、@code{nil}をリターンする。

@c Emacs 19 feature
引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@defun global-key-binding key &optional accept-defaults
この関数は、カレントのグローバルキーマップ内で、コマンド@var{key}にたいするバインディングをリターンする。カレントのグローバルキーマップ内で未定義の場合は、@code{nil}をリターンする。

@c Emacs 19 feature
引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@c Emacs 19 feature
@defun minor-mode-key-binding key &optional accept-defaults
この関数は、アクティブなマイナーモードの@var{key}のバインディングを、リストでリターンする。より正確には、この関数は@code{(@var{modename}
.
@var{binding})}のとうなペアーのalistをリターンする。ここで@var{modename}なそのマイナーモードを有効にする変数、@var{binding}はそのモードでの@var{key}のバインディングである。@var{key}がマイナーモードバインディングをみたない場合、値は@code{nil}である。

最初に見つかったバインディングがプレフィクス定義(キーマップ、またはキーマップとして定義されたシンボル)でない場合は、他のマイナーモード由来のすべての後続するバインディングは、完全にshadowされるため省略される。同様に、このリストはプレフィクスバインディングに後続する非プレフィクスバインディングは省略される。

引数@var{accept-defaults}は、@code{lookup-key}(上記)と同じように、デフォルトバインディングのチェックを制御する。
@end defun

@defopt meta-prefix-char
@cindex @key{ESC}
この変数はメタ/プレフィクス文字コードである。これはメタ文字をキーマップ内でルックアップできるように、2文字シーケンスに変換する。有用な結果を得るために、値はプレフィクスイベント(@ref{Prefix
Keys}を参照)であること。デフォルト値は27で、これは@key{ESC}にたいする@acronym{ASCII}コードである。

@code{meta-prefix-char}の値が27であるような限り、キールックアップは通常@code{backward-word}コマンドとして定義される@kbd{M-b}を、@kbd{@key{ESC}
b}に変換する。しかし、@code{meta-prefix-char}を24(@kbd{C-x}のコード)にセットした場合、Emacsは@kbd{M-b}を@kbd{C-x
b}に変換するだろうが、これの標準のバインディングは@code{switch-to-buffer}コマンドである。以下に何が起こるかを示す(実際にこれを行ってはならない!):

@smallexample
@group
meta-prefix-char                    ; @r{デフォルト値}
     @result{} 27
@end group
@group
(key-binding "\M-b")
     @result{} backward-word
@end group
@group
?\C-x                               ; @r{文字.の}
     @result{} 24                          ; @r{プリント表現}
@end group
@group
(setq meta-prefix-char 24)
     @result{} 24
@end group
@group
(key-binding "\M-b")
     @result{} switch-to-buffer            ; @r{今や@kbd{M-b}をタイプすると}
                                    ;   @r{@kbd{C-x b}をタイプしたようになる}

(setq meta-prefix-char 27)          ; @r{混乱を避ける!}
     @result{} 27                          ; @r{デフォルト値をリストア!}
@end group
@end smallexample

この単一イベントから２イベントへの変換は文字にたいしてのみ発生し、他の種類の入力イベントには発生しない。したがって、ファンクションキー@kbd{M-@key{F1}}は@kbd{@key{ESC}
@key{F1}}に変換されない。
@end defopt

@node Changing Key Bindings
@section Changing Key Bindings
@cindex changing key bindings
@cindex rebinding

  キーのリバインド(rebind:
再バインド、再束縛)は、キーマップ内でそのキーのバインディングエントリーを変更することにより行います。グローバルキーマップ内のバインディングを変更した場合、その変更は(たとえローカルバインディングによりグローバルバインディングをshadowしているバッファーでは直接影響しないとしても)すべてのバッファーに影響します。カレントバッファーのローカルマップを変更した場合は、通常は同じメジャーモードを使用するすべてのバッファーに影響します。関数@code{global-set-key}および@code{local-set-key}は、これらの操作のための使いやすいインターフェイスです(@ref{Key
Binding
Commands}を参照)。より汎用的な関数@code{define-key}を使用することもできます。その場合は、変更するマップを明示的に指定しなければなりません。

  Lispプログラムでリバインドするキーシーケンスを選択するときは、さまざまなキーの使用についてのEmacsの慣習にしたがうようお願いします(@ref{Key
Binding Conventions}を参照)。

@cindex meta character key constants
@cindex control character key constants
  リバインドするキーシーケンスの記述では、コントロール文字とメタ文字にたいして、特別なエスケープシーケンスを使用すると良いでしょう(@ref{String
Type}を参照)。構文@samp{\C-}は後続する文字がコントロール文字でることを意味し、@samp{\M-}は後続する文字がメタ文字であることを意味します。したがって、文字列@code{"\M-x"}は1つの@kbd{M-x}、@code{"\C-f"}は1つの@kbd{C-f}、@code{"\M-\C-x"}および@code{"\C-\M-x"}は1つの@kbd{C-M-x}として読み取られます。ベクター内でも、このエスケープシーケンス、および文字列では使用できない他のエスケープシーケンスを使用できます。1例は@samp{[?\C-\H-x
home]}です。@ref{Character Type}を参照してください。

  キー定義、およびルックアップ関数は、ベクターであるようなキーシーケンス内のイベント型にたいして、別の構文を受け入れます。修飾名に基本イベント(文字かファンクションキー名)を付加したものを含むリストを使用できます。たとえば、@code{(control
?a)}は@code{?\C-a}、@code{(hyper control
left)}は@code{C-H-left}と等価です。このようなリストの利点の1つは、コンパイル済みファイル内に修飾ビットの正確な数値コードが出現しないことです。

  以下の関数は、@var{keymap}がキーマップでない場合、および@var{key}がキーシーケンスを表す文字列やベクターでない場合はエラーをシグナルします。リストであるようなイベントにたいする略記として、イベント型(シンボル)を使用できます。@code{kbd}関数(@ref{Key
Sequences}を参照)は、キーシーケンスを指定するための便利な方法です。

@defun define-key keymap key binding
この関数は、@var{keymap}内で@var{key}にたいするバインディングをセットする(@var{key}が長さ2以上のイベントの場合、その変更は実際は@var{keymap}から辿られる他のキーマップで行なわれる)。引数@var{binding}には任意のLispオブジェクトを指定できるが、意味があるのは特定のオブジェクトだけである(意味のある型のリストは、@ref{Key
Lookup}を参照のこと)。@code{define-key}のリターン値は@var{binding}である。

@var{key}が@code{[t]}の場合、これは@var{keymap}内でデフォルトバインディングをセットする。イベントが自身のバインディングをもたないとき、そのキーマップ内にデフォルトバインディングが存在するなら、Emacsコマンドループはそれを使用する。

@cindex invalid prefix key error
@cindex key sequence error
@var{key}のすべてのプレフィクスは、プレフィクスキー(キーマップにバインドされる)、または未定義でなけらばならず、それ以外はエラーがシグナルされる。@var{key}のいくつかのプレフィクスが未定義の場合は、@code{define-key}はそれをプレフィクスキーとして定義するので、残りの@var{key}は指定されたように定義できる。

前に@var{keymap}内で@var{key}にたいするバインディングが存在しなかった場合は、新たなバインディングが@var{keymap}の先頭に追加される。キーマップ内のバインディングの順序はキーボード入力にたいし影響を与えないが、メニューキーマップにたいしては問題となる(@ref{Menu
Keymaps}を参照)。
@end defun

  以下は、sparseキーマップを作成して、その中にバインディングをいくつか作成する例である:

@smallexample
@group
(setq map (make-sparse-keymap))
    @result{} (keymap)
@end group
@group
(define-key map "\C-f" 'forward-char)
    @result{} forward-char
@end group
@group
map
    @result{} (keymap (6 . forward-char))
@end group

@group
;; @r{@kbd{C-x}にたいしsparseサブマップを作成し、
;; その中で@kbd{f}をバインドする}
(define-key map (kbd "C-x f") 'forward-word)
    @result{} forward-word
@end group
@group
map
@result{} (keymap
    (24 keymap                ; @kbd{C-x}
        (102 . forward-word)) ;      @kbd{f}
    (6 . forward-char))       ; @kbd{C-f}
@end group

@group
;; @r{@kbd{C-p}を@code{ctl-x-map}にバインド}
(define-key map (kbd "C-p") ctl-x-map)
;; @code{ctl-x-map}
@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]
@end group

@group
;; @r{@code{ctl-x-map}内で@kbd{C-f}を@code{foo}にバインド}
(define-key map (kbd "C-p C-f") 'foo)
@result{} 'foo
@end group
@group
map
@result{} (keymap     ; @r{@code{ctl-x-map}内の@code{foo}に注目}
    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])
    (24 keymap
        (102 . forward-word))
    (6 . forward-char))
@end group
@end smallexample

@noindent
@kbd{C-p
C-f}にたいする新たなバインディングの格納は、実際には@code{ctl-x-map}内のエントリーを変更することにより機能し、これはデフォルトグローバルマップ内の@kbd{C-p
C-f}と@kbd{C-x C-f}の両方のバインディングを変更する効果をもつことに注意されたい。

  関数@code{substitute-key-definition}は、キーマップから特定のバインディングをもつキーをスキャンして、それらを異なるバインディングにリバインドする。より明快で、多くの場合は同じ結果を生成できる他の機能として、あるコマンドから別のコマンドへのリマップがあります(@ref{Remapping
Commands}を参照)。

@defun substitute-key-definition olddef newdef keymap &optional oldmap
@cindex replace bindings
この関数は、@var{keymap}内で@var{olddef}にバインドされるすべてのキーについて、@var{olddef}を@var{newdef}に置き換える。別の言い方をすると、@var{olddef}が出現する箇所すべてを@var{newdef}に置き換える。この関数は@code{nil}をリターンする。

たとえば、以下をEmacsの標準バインディングで行うと、@kbd{C-x C-f}を再定義する:

@smallexample
@group
(substitute-key-definition
 'find-file 'find-file-read-only (current-global-map))
@end group
@end smallexample

@c Emacs 19 feature
@var{oldmap}が非@code{nil}の場合は、どのキーをリバインドするかを@var{oldmap}内のバインディングが決定するよう、@code{substitute-key-definition}の動作を変更する。リバインディングは依然として@var{oldmap}ではなく、@var{keymap}で発生する。したがって、他のマップ内のバインディングの制御下で、マップを変更することができる。たとえば、

@smallexample
(substitute-key-definition
  'delete-backward-char 'my-funny-delete
  my-map global-map)
@end smallexample

@noindent
これは、標準的な削除コマンドにグローバルにバインドされたキーにたいして、@code{my-map}内の特別な削除コマンドを設定する。

以下は、キーマップの置き換え(substitution)の前後を示す例である:

@smallexample
@group
(setq map '(keymap
            (?1 . olddef-1)
            (?2 . olddef-2)
            (?3 . olddef-1)))
@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
@end group

@group
(substitute-key-definition 'olddef-1 'newdef map)
@result{} nil
@end group
@group
map
@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
@end group
@end smallexample
@end defun

@defun suppress-keymap keymap &optional nodigits
@cindex @code{self-insert-command} override
この関数は、@code{self-insert-command}をコマンド@code{undefined}にリマップ(@ref{Remapping
Commands}を参照)することにより、fullキーマップのコンテンツを変更する。これは、すべてのプリント文字を未定義にする効果をもすので、通常のテキスト挿入は不可能になる。@code{suppress-keymap}は@code{nil}をリターンする。

@var{nodigits}が@code{nil}の場合、@code{suppress-keymap}は数字が@code{digit-argument}、@kbd{-}が@code{negative-argument}を実行するように定義する。それ以外は、残りのプリント文字と同じように、それらの文字も未定義にする。

@cindex yank suppression
@cindex @code{quoted-insert} suppression
@code{suppress-keymap}関数は、@code{yank}や@code{quoted-insert}のようなコマンドを抑制(suppress)しないので、バッファーの変更は可能である。バッファーの変更を防ぐには、バッファーを読み取り専用(read-only)にする(@ref{Read
Only Buffers}を参照)。

この関数は@var{keymap}を変更するので、通常は新たに作成したキーマップにたいして使用するだろう。するだろう。他の目的のために使用されている既存のキーマップに操作を行うと、恐らくトラブルの原因となる。たとえば、@code{global-map}の抑制は、Emacsの使用をほとんど不可能に

この関数は、テキストの挿入が望ましくないメジャーモードの、ローカルキーマップ初期科に使用され得る。しかし、そのようなモードは通常は@code{special-mode}(@ref{Basic
Major
Modes}を参照)から継承される。この場合、そのモードのキーマップは既に抑制済みの@code{special-mode-map}から自動的に受け継がれる。以下に@code{special-mode-map}が定義される方法を示す:

@smallexample
@group
(defvar special-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (define-key map "q" 'quit-window)
    @dots{}
    map))
@end group
@end smallexample
@end defun

@node Remapping Commands
@section Remapping Commands
@cindex remapping commands

  あるコマンドから他のコマンドへの@dfn{リマップ(remap)}には、特別な種類のキーバインディングが使用できます。この機能を使用するためには、ダミーイベント@code{remap}で始まり、その後にリマップしたいコマンド名が続くようなキーシーケンスにたいするキーバインディングを作成します。そして、そのバインディングにたいしては、新たな定義(通常はコマンド名だが、キーバインディングにたいして有効な他の任意の定義を指定可能)を指定します。

  たとえば、Myモードというモードが、@code{kill-line}のかわりに呼び出される@code{my-kill-line}という特別なコマンドを提供するとします。これを設定するには、このモードのキーマップに以下のようなリマッピングが含まれるはずです:

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
@end smallexample

@noindent
その後は、@code{my-mode-map}がアクティブなときは常に、ユーザーが@kbd{C-k}(@code{kill-line}についてデフォルトのグローバルキーシーケンス)をタイプすると、Emacsはかわりに@code{my-kill-line}を実行するでしょう。

  リマップはアクティブなキーマップでのみ行なわれることに注意してください。たとえば、@code{ctl-x-map}のようなプレフィクスキーマップ内にリマッピングを置いても、そのようなキーマップはそれ自体がアクティブでないので、通常は効果がありません。それに加えて、リマップは1レベルを通じてのみ機能します。以下の例では、

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)
@end smallexample

@noindent
これは@code{kill-line}を@code{my-other-kill-line}にリマップ@emph{しません}。かわりに、通常のキーバインディングが@code{kill-line}を指定する場合は、それが@code{my-kill-line}にリマップされます。通常のバインディングが@code{my-kill-line}を指定した場合は、@code{my-other-kill-line}にリマップされます。

コマンドのリマップをアンドゥするには、以下のようにそれを@code{nil}にリマップします：

@smallexample
(define-key my-mode-map [remap kill-line] nil)
@end smallexample

@defun command-remapping command &optional position keymaps
この関数は、カレントアクティブキーマップにより与えられる、@var{command}(シンボル)にたいするリマッピングをリターンする。@var{command}がリマップされていない(これは普通の状況である)、またはシンボル以外の場合、この関数は@code{nil}をリターンする。@code{position}は、@code{key-binding}の場合と同様、使用するキーマップを決定するために、オプションバッファー位置、またはイベント位置をオプションで指定できる。

オプション引数@code{keymaps}が非@code{nil}の場合、それは検索するキーマップのリストを指定する。この引数は、@code{position}が非@code{nil}の場合は無視される。
@end defun

@node Translation Keymaps
@section Keymaps for Translating Sequences of Events
@cindex translation keymap
@cindex keymaps for translating events

  @code{read-key-sequence}関数がキーシーケンス(@ref{Key Sequence
Input}を参照)を読み取るときは、特定のイベントシーケンスを他のものに変換(translate)するために、@dfn{変換キーマップ(translation
keymaps)}を使用します。@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}(優先順)は変換キーマップです。

  変換キーマップは、他のキーマップと同じ構造をもちますが、使われ方は異なります。変換キーマップは、キーシーケンスを読み取るときに、コンプリートキーシーケンスにたいするバインディングではなく、キーシーケンスに行う変換を指定します。キーシーケンスが読み取られると、それらのキーシーケンスは変換キーマップにたいしてチェックされます。ある変換キーマップが@var{k}をベクター@var{v}に``バインド''する場合、キーシーケンス内の@emph{どこか}にサブシーケンスとして@var{k}が出現すると、それは@var{v}ないのでイベントに置き換えられます。

  たとえば、キーパッドキー@key{PF1}が押下されたとき、VT100端末は@kbd{@key{ESC} O
P}を送信します。そのような端末では、Emacsはそのイベントシーケンスを単一イベント@code{pf1}に変換しなければなりません。これは、@code{input-decode-map}内で@kbd{@key{ESC}
O P}を@code{[pf1]}に``バインド''することにより行われます。したがって、その端末上で@kbd{C-c
@key{PF1}}をタイプしたとき、端末は文字シーケンス@kbd{C-c @key{ESC} O
P}を発行し、@code{read-key-sequence}がそれを@kbd{C-c @key{PF1}}に変換してベクター@code{[?\C-c
pf1]}としてリターンします。

  変換キーマップは、(@code{keyboard-coding-system}で指定された入力コーディングシステムを通じて)Emacsがキーボード入力をデコードした直後だけ効果をもちます。@ref{Terminal
I/O Encoding}を参照してください。

@defvar input-decode-map
この変数は、通常の文字端末上のファンクションキーから送信された文字シーケンスを記述するキーマップを保持する。

@code{input-decode-map}の値は、通常はその端末のTerminfoかTermcapのエントリーに応じて、自動的にセットアップされるが、Lispの端末仕様ファイルの助けが必要なときもある。Emacsには、多くの一般的な端末の端末仕様ファイルが同梱されている。これらのファイルの主な目的は、TermcapやTerminfoから推定できないエントリーを@code{input-decode-map}内に作成することである。@ref{Terminal-Specific}を参照のこと。
@end defvar

@defvar local-function-key-map
この変数は、@code{input-decode-map}と同じようにキーマップを保持するが、通常優先される解釈候補(alternative
interpretation)に変換されるべきキーシーケンスを記述するキーマップを保持する。このキーマップは@code{input-decode-map}の後、@code{key-translation-map}の前に適用される。

@code{local-function-key-map}内のエントリーは、マイナーモード、ローカルキーマップ、グローバルキーマップによるバインディングと衝突する場合は無視される。つまり、元のキーシーケンスが他にバインディングをもたない場合だけ、リマッピングが適用される。

@code{local-function-key-map}が@code{function-key-map}を継承するが、@code{function-key-map}を直接使用すべきではない。
@end defvar

@defvar key-translation-map
この変数は、入力イベントを他のイベントに変換するために、@code{input-decode-map}と同じように使用される、別のキーマップを保持する。@code{input-decode-map}との違いは、@code{local-function-key-map}の前ではなく、後に機能する点である。このキーマップは、@code{local-function-key-map}による変換結果を受け取る。

@code{input-decode-map}と同様、ただし@code{local-function-key-map}とは異なり、このキーマップは入力キーシーケンスが通常のバインディングをもつかどうかかに関わらず適用される。しかし、このキーマップによりキーバインディングがオーバーライドされても、@code{key-translation-map}では実際のキーバインディングが効果をもち得ることに注意されたい。確かに、実際のキーバインディングは@code{local-function-key-map}をオーバーライドし、したがって@code{key-translation-map}が受け取るキーシーケンスは変更されるだろう。明確にするためには、このような類の状況は避けたほうがよい。

@code{key-translation-map}は、通常は@code{self-insert-command}にバインディングされるような通常文字を含めて、ユーザーがある文字を他の文字にマップすることを意図している。
@end defvar

@cindex key translation function
キーシーケンスのかわりにキーの``変換''として関数を使用することにより、シンプルなエイリアスより多くのことに@code{input-decode-map}、@code{local-function-key-map}、@code{key-translation-map}を使用できます。その場合、この関数はそのキーの変換を計算するために呼び出されます。

キー変換関数は、引数を1つ受け取ります。この引数は@code{read-key-sequence}内で指定されるプロンプトです。キーシーケンスがエディターコマンドループに読み取られる場合は、@code{nil}です。ほとんどの場合、プロンプト値は無視できます。

関数が自身で入力を読み取る場合、その関数は後続のイベントを変更する効果をもつことができます。たとえば、以下は@kbd{C-c
h}をハイパー文字に後続する文字とするために定義する方法の例です:

@example
@group
(defun hyperify (prompt)
  (let ((e (read-event)))
    (vector (if (numberp e)
                (logior (lsh 1 24) e)
              (if (memq 'hyper (event-modifiers e))
                  e
                (add-event-modifier "H-" e))))))

(defun add-event-modifier (string e)
  (let ((symbol (if (symbolp e) e (car e))))
    (setq symbol (intern (concat string
                                 (symbol-name symbol))))
    (if (symbolp e)
        symbol
      (cons symbol (cdr e)))))

(define-key local-function-key-map "\C-ch" 'hyperify)
@end group
@end example

@subsection Interaction with normal keymaps

そのキーシーケンスがコマンドにバインドされたとき、またはさらにイベントを追加してもコマンドにバインドされるシーケンスにすることができないとEmacsが判断したときに、キーシーケンスの終わりが検出されます。

これは、元のキーシーケンスがバインディングをもつかどうかに関わらず、@code{input-decode-map}および@code{key-translation-map}を適用するとき、そのようなバインディングが変換の開始を妨げることを意味します。たとえば、前述のVT100の例に戻って、グローバルマップに@kbd{C-c
@key{ESC}}を追加してみましょう。すると、ユーザーが@kbd{C-c @key{PF1}}をタイプしたとき、Emacsは@kbd{C-c
@key{ESC} O P}を@kbd{C-c @key{PF1}}に変換するのに失敗するでしょう。これは、Emacsが@kbd{C-x
@key{ESC}}の直後に読み取りを停止して、@kbd{O P}は読み取られずに残るからです。この場合、ユーザーが実際に@kbd{C-c
@key{ESC}}をタイプした場合、ユーザーが実際に@kbd{@key{ESC}}を押下したのか、あるいは@kbd{@key{PF1}}を押下したのか判断するために、Emacsが待つべきではないのです。

この理由により、キーシーケンスの終わりがキー変換のプレフィクスであるようなキーシーケンスをコマンドにバインドするのは、避けたほうがよいでしょう。そのような問題を起こす主なサフィックス、およびプレフィクスは@kbd{@key{ESC}}、@kbd{M-O}(実際は@kbd{@key{ESC}
O})、@kbd{M-[}(実際は@kbd{@key{ESC} [})です。

@node Key Binding Commands
@section Commands for Binding Keys

  このセクションでは、キーバインディングを変更するための便利な対話的インターフェイスを説明します。これらは@code{define-key}を呼び出すことにより機能します。

  ユーザーはinitファイルにたいしてシンプルなカスタマイズを行うとき、しばしば@code{global-set-key}を使用します。たとえば、

@smallexample
(global-set-key (kbd "C-x C-\\") 'next-line)
@end smallexample

@noindent
または

@smallexample
(global-set-key [?\C-x ?\C-\\] 'next-line)
@end smallexample

@noindent
または

@smallexample
(global-set-key [(control ?x) (control ?\\)] 'next-line)
@end smallexample

@noindent
は、次の行に移動するように@kbd{C-x C-\}を再定義します。

@smallexample
(global-set-key [M-mouse-1] 'mouse-set-point)
@end smallexample

@noindent
は、メタキーを押してマウスの第一ボタン(左ボタン)をクリックすると、クリックした箇所にポイントをセットするように再定義します。

@cindex non-@acronym{ASCII} text in keybindings
  バインドするキーのLisp指定に非@acronym{ASCII}文字のテキストを使用するときは、注意してください。マルチバイトとして読み取られたテキストがある場合には、Lispファイル内でマルチバイトテキストが読み取られるときのように(@pxref{Loading
Non-ASCII})、マルチバイトとしてキーをタイプしなければなりません。たとえば、

@smallexample
(global-set-key "@"o" 'my-function) ; bind o-umlaut
@end smallexample

@noindent
または

@smallexample
(global-set-key ?@"o 'my-function) ; bind o-umlaut
@end smallexample

@noindent
をLatin-1のマルチバイト環境で使用した場合、これらのコマンドはLatin-1端末より送信されたバイトコード246(@kbd{M-v})ではなく、コード246のマルチバイト文字に実際にバインドされます。このバインディングを使用するためには、適切な入力メソッド(@ref{Input
Methods, , Input Methods, emacs, The GNU Emacs
Manual}を参照)を使用して、キーボードをデコードする方法をEmacsに教える必要があります。

@deffn Command global-set-key key binding
この関数は、カレントグローバルマップ内で、@var{key}のバインディングを@var{binding}にセットする。

@smallexample
@group
(global-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-global-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command global-unset-key key
@cindex unbinding keys
この関数は、カレントグローバルマップから、@var{key}のバインディングを削除する。

プレフィクスとして@var{key}を使用する、長いキーの定義の準備に使用するのも、この関数の1つの使い方である。@var{key}が非プレフィクスのようなバインディングをもつ場合、この使い方は許されないだろう。たとえば、

@smallexample
@group
(global-unset-key "\C-l")
    @result{} nil
@end group
@group
(global-set-key "\C-l\C-l" 'redraw-display)
    @result{} nil
@end group
@end smallexample

この関数は、以下のように@code{define-key}を使用するのと等しい:

@smallexample
@group
(global-unset-key @var{key})
@equiv{}
(define-key (current-global-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@deffn Command local-set-key key binding
この関数は、カレントローカルキーマップ内の@var{key}のバインディングを、@var{binding}にセットする。

@smallexample
@group
(local-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-local-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command local-unset-key key
この関数は、カレントローカルキーマップから、@var{key}のバインディングを削除する。

@smallexample
@group
(local-unset-key @var{key})
@equiv{}
(define-key (current-local-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@node Scanning Keymaps
@section Scanning Keymaps
@cindex scanning keymaps
@cindex keymaps, scanning

  このセクションでは、すべてのカレントキーマップをスキャンして、ヘルプ情報をプリントするために使用される関数を説明します。

@defun accessible-keymaps keymap &optional prefix
この関数は、(0個以上のプレフィクスキーを通じて)@var{keymap}から到達可能な、すべてのキーマップのリストをリターンする。リターン値は@code{(@var{key}
.@:
@var{map})}のような形式の要素をもつ連想配列(alist)である。ここで、@var{key}は@var{keymap}内での定義が@var{map}であるようなプレフィクスキーである。

alistの要素は、@var{key}の長さにたいして昇順にソートされている。1つ目の要素は、常に@code{([] .@:
@var{keymap})}である。これは、指定されたキーマップがイベントなしのプレフィクスにより、自分自身からアクセス可能だからである。

@var{prefix}が与えられた場合、それはプレフィクスキーシーケンスである。その場合には、@var{prefix}で始まるプレフィクスキーをもつサブマップだけが@code{accessible-keymaps}に含まれる。これらの要素の意味は、@code{(accessible-keymaps)}の値の場合と同様であり、いくつかの要素が省略されている点だけが異なる。

以下の例では、リターンされるalistにより、@samp{^[}と表示されるキー@key{ESC}がプレフィクスキーであり、その定義がsparseキーマップ@code{(keymap
(83 .@: center-paragraph)  (115 .@: foo))}であること示される。

@smallexample
@group
(accessible-keymaps (current-local-map))
@result{}(([] keymap
      (27 keymap   ; @r{以降@key{ESC}にたいするこのキーマップが繰り返されることに注意}
          (83 . center-paragraph)
          (115 . center-line))
      (9 . tab-to-tab-stop))
@end group

@group
   ("^[" keymap
    (83 . center-paragraph)
    (115 . foo)))
@end group
@end smallexample

また以下の例では、@kbd{C-h}は@code{(keymap (118
.
describe-variable)@dots{})}で始まるsparseキーマップを使用するプレフィクスキーである。他のプレフィクス@kbd{C-x
4}は、変数@code{ctl-x-4-map}の値でもあるキーマップを使用する。イベント@code{mode-line}は、ウィンドウの特別な箇所でのマウスイベントにたいするプレフィクスとして使用される、いくつかのダミーイベントのうちの1つである。

@smallexample
@group
(accessible-keymaps (current-global-map))
@result{} (([] keymap [set-mark-command beginning-of-line @dots{}
                   delete-backward-char])
@end group
@group
    ("^H" keymap (118 . describe-variable) @dots{}
     (8 . help-for-help))
@end group
@group
    ("^X" keymap [x-flush-mouse-queue @dots{}
     backward-kill-sentence])
@end group
@group
    ("^[" keymap [mark-sexp backward-sexp @dots{}
     backward-kill-word])
@end group
    ("^X4" keymap (15 . display-buffer) @dots{})
@group
    ([mode-line] keymap
     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))
@end group
@end smallexample

@noindent
これらは実際に目にするであろうキーマップのすべてではない。
@end defun

@defun map-keymap function keymap
関数@code{map-keymap}は、@var{keymap}内のバインディングそれぞれにたいして1回@var{function}を呼び出す。呼び出す際の引数はイベント型と、そのバインディングの値の2つである。@var{keymap}に親キーマップがある場合は、その親キーマップのバインディングも含まれる。これは再帰的に機能する。つまり、その親キーマップ自身が親キーマップをもつ場合は、それのバインディングも含まれる、といった具合である。

これは、キーマップ内のすべてのバインディングを検証する、もっとも明快な方法である。
@end defun

@defun where-is-internal command &optional keymap firstonly noindirect no-remap
この関数は、@code{where-is}コマンド(@ref{Help, , Help, emacs,The GNU Emacs
Manual}を参照)により使用されるサブルーチンである。これは、キーマップのセット内で@var{command}にバインドされる、(任意の長さの)キーシーケンスすべてのリストをリターンする。

引数@var{command}には、任意のオブジェクトを指定できる。このオブジェクトは、すべてのキーマップエントリーにたいし、@code{eq}を使用して比較される。

@var{keymap}が@code{nil}の場合、@code{overriding-local-map}の値とは無関係に(@code{overriding-local-map}の値が@code{nil}であると装い)、カレントアクティブキーマップをマップとして使用する。@var{keymap}がキーマップの場合は、@var{keymap}とグローバルキーマップが検索されるマップとなる。@var{keymap}がキーマップのリストの場合は、それらのキーマップだけが検索される。

@var{keymap}にたいする式としては、通常は@code{overriding-local-map}を使用するのが最善である。その場合、@code{where-is-internal}は正にアクティブなキーマップを検索する。グローバルマップだけを検索するには、@var{keymap}の値に@code{(keymap)}(空のキーマップ)を渡せばよい。

@var{firstonly}が@code{non-ascii}の場合、値はすべての可能なキーシーケンスのリストではなく、最初に見つかったキーシーケンスを表す単一のベクターとなる。@var{firstonly}が@code{t}の場合、値は最初のキーシーケンスだが、全体が@acronym{ASCII}文字(またはメタ修飾された@acronym{ASCII}文字)で構成されるキーシーケンスが、他のすべてのキーシーケンスに優先され、リターン値がメニューバインディングになることは決してない。

@var{noindirect}が非@code{nil}の場合、@code{where-is-internal}はインダイレクトキーマップ(indirect
keymap: 間接キーマップ)のバインディングを追跡しない。これにより、インダイレクト定義自体にたいして検索が可能になる。

5つ目の引数@var{no-remap}は、この関数がコマンドリマッピング(@ref{Remapping
Commands}を参照)を扱う方法を決定する。興味深いケースが2つある:

@table @asis
@item コマンド@var{other-command}が@var{command}にリマップされる場合:
If @var{no-remap} is @code{nil}, find the bindings for @var{other-command}
and treat them as though they are also bindings for @var{command}.  If
@var{no-remap} is non-@code{nil}, include the vector @code{[remap
@var{other-command}]} in the list of possible key sequences, instead of
finding those bindings.

@item If @var{command} is remapped to @var{other-command}:
@var{no-remap}が@code{nil}の場合は、@var{command}ではなく@var{other-command}にたいするバインディングをリターンする。@var{no-remap}が非@code{nil}の場合は、リマップされていることを無視して、@var{command}にたいするバインディングをリターンする。
@end table
@end defun

@deffn Command describe-bindings &optional prefix buffer-or-name
この関数は、すべてのカレントキーバインディングのリストを作成して、@file{*Help*}という名前のバッファーにそれを表示する。テキストはモードごとにグループ化され、順番はマイナーモード、メジャーモード、グローバルバインディングの順である。

@var{prefix}が非@code{nil}の場合、それはプレフィクスキーである。その場合、リストに含まれるのは@var{prefix}で始まるキーだけになる。

複数の連続する@acronym{ASCII}コードが同じ定義をもつとき、それらは@samp{@var{firstchar}..@var{lastchar}}のようにまとめて表示される。この場合、それがどの文字に該当するかを理解するためには、その@acronym{ASCII}コードを知っている必要がある。たとえば、デフォルトグローバルマップでは、文字@samp{@key{SPC}
..@:
~}は1行で記述される。@key{SPC}は@acronym{ASCII}の32，@kbd{~}は@acronym{ASCII}の126で、その間のすべての文字には、通常のプリント文字(アルファベット文字、数字、句読点など)が含まれる。これらの文字はすべて、@code{self-insert-command}にバインドされる。

@var{buffer-or-name}が非@code{nil}の場合、それはバッファー、またはバッファー名である。その場合、@code{describe-bindings}はカレントバッファーのかわりに、そのバッファーのバインディングをリストする。
@end deffn

@node Menu Keymaps
@section Menu Keymaps
@cindex menu keymaps

キーマップは、キーボードキーやマウスボタンにたいするバインディング定義と同様に、メニューとして操作することができます。メニューは、通常はマウスにより操作されますが、キーボードでも機能させことができます。次の入力イベントにたいしてメニューキーマップがアクティブな場合は、キーボードメニュー機能がアクティブになります。

@menu
* Defining Menus::           メニューを定義するキーマップを作成する方法。
* Mouse Menus::              ユーザーがマウスでメニューを操作する方法。
* Keyboard Menus::           ユーザーがキーボードでメニューを操作する方法。
* Menu Example::             シンプルなメニューの作成。
* Menu Bar::                 メニューバーのカスタマイズ方法。
* Tool Bar::                 イメージ行のツールバー。
* Modifying Menus::          メニューへ新たなアイテムを追加する方法。
* Easy Menu::                メニュー作成のための便利なマクロ。
@end menu

@node Defining Menus
@subsection Defining Menus
@cindex defining menus
@cindex menu prompt string
@cindex prompt string (of menu)
@cindex menu item

キーマップが@dfn{overallプロンプト文字列(overall prompt
string)}をもつ場合、そのキーマップはメニューとして動作します。overallプロンプト文字列とは、キーマップの要素として表される文字列です(@ref{Format
of
Keymaps}を参照)。この文字列には、メニューコマンドの目的を記述します。Emacsは、(もしあれば)メニュー表示に使用されるツールキットに応じ、メニュータイトルとしてoverallメニュー文字列を表示します@footnote{これはテキスト端末ののような、ツールキットを使用しないメニューにたいして要求されます。}。キーボードメニューもoverallプロンプト文字列を表示します。

プロンプト文字列をもつキーマップを構築するもっとも簡単な方法は、@code{make-keymap}、@code{make-sparse-keymap}(@ref{Creating
Keymaps}を参照)、@code{define-prefix-command}(@ref{Definition of
define-prefix-command}を参照)を呼び出すときに引数で文字列を指定する方法です。キーマップをメニューとして操作したくない場合は、これらの関数にたいしてプロンプト文字列を指定しないでください。

@defun keymap-prompt keymap
この関数は、@var{keymap}のoverallプロンプト文字列を、もしなければ@code{nil}をリターンする。
@end defun

メニューのアイテムは、そのキーマップ内のバインディングです。各バインディングはイベント型と定義を関連付けますが、イベント型はメニューの外見に何の意味ももちません(通常は、イベント型としてキーボードが生成できない擬似イベントのシンボルをメニューアイテムのバインディングに使用する)。メニュー全体は、これらのイベントにたいするキーマップ内のバインディングから生成されます。

メニュー内のアイテムの順序は、キーマップ内のバインディングの順序と同じです。@code{define-key}は新たなバインディングを先頭に置くので、メニューアイテムの順序が重要な場合は、メニューの最後から先頭へメニューアイテムを定義する必要があります。既存のメニューにアイテムを追加するときは、@code{define-key-after}を使用してメニュー内の位置を指定できます(@ref{Modifying
Menus}を参照)。

@menu
* Simple Menu Items::        単純なメニューのキーバインディング。
* Extended Menu Items::      複雑なメニューアイテムの定義。
* Menu Separators::          メニューに水平ラインを描画する。
* Alias Menu Items::         メニューアイテムにコマンドエイリアスを使用する。
@end menu

@node Simple Menu Items
@subsubsection Simple Menu Items

  メニューアイテムを定義する単純(かつ初歩的)な方法は、何らかのイベント型(何のイベント型かは問題にならない)を以下のようにバインドすることです:

@example
(@var{item-string} . @var{real-binding})
@end example

@noindent
@sc{car}の@var{item-string}は、メニュー内で表示される文字列です。これは短いほうがよく、1から3の単語が望ましいでしょう。この文字列は、対応するコマンドの動作を説明します。すべてのグラフィカルツールキットが非@acronym{ASCII}テキストを表示できる訳ではないことに注意してください(キーボードメニューとGTK+ツールキットの大部分では機能するだろう)。

  以下のように、ヘルプ文字列と呼ばれる2つ目の文字列を与えることもできます:

@example
(@var{item-string} @var{help} . @var{real-binding})
@end example

@noindent
@var{help}は、マウスがそのアイテム上にあるときに、@code{help-echo}テキストプロパティ(@ref{Help
display}を参照)と同じ方法で表示される``help-echo''文字列を指定します。

  @code{define-key}に関する限り、@var{item-string}と@var{help-string}は、そのイベントのバインディングの一部です。しかし、@code{lookup-key}は単に@var{real-binding}だけをリターンし、そのキーの実行には@var{real-binding}だけが使用されます。

  @var{real-binding}が@code{nil}の場合、メニューに@var{item-string}は表示されまづが、選択できなくなります。

  @var{real-binding}がシンボルで、@code{menu-enable}プロパティが非@code{nil}の場合、そのプロパティはメニューアイテムが有効か無効かを制御する式です。メニュー表示にキーマップが使用されるたびに、Emacsはその式を評価して、式の値が非@code{nil}の場合だけ、そのメニューのメニューアイテムを有効にします。メニューアイテム無効なとき、そのアイテムは``fuzzy''形式で表示され、選択できなくなります。

  メニューバーはメニューを調べる際に、どのアイテムが有効なのか再計算しません。これは、Xツールキットが事前にメニュー全体を要求するからです。メニューバーの再計算を強制するには、@code{force-mode-line-update}を呼び出してください(@ref{Mode
Line Format}を参照)。

@node Extended Menu Items
@subsubsection Extended Menu Items
@kindex menu-item
@cindex extended menu item

  メニューアイテムの拡張フォーマットは、単純なフォーマットに比べて、より柔軟かつ明快です。拡張フォーマットでは、メニューアイテムにバインドのイベント型に、シンボル@code{menu-item}で始まるシンボルのリストを指定します。選択できない文字列にたいしては、以下のようなバインディングになります:

@example
(menu-item @var{item-name})
@end example

@noindent
2つ以上のダッシュで始まる文字列は、リストのセパレーターを指定します。@ref{Menu Separators}を参照してください。

  選択可能な実際のメニューアイテムを定義するには、以下のような拡張フォーマットでバインドします:

@example
(menu-item @var{item-name} @var{real-binding}
    . @var{item-property-list})
@end example

@noindent
ここで、@var{item-name}はメニューアイテム文字列を評価する式です。つまり、文字列は底数である必要はありません。3つ目の引数@var{real-binding}は、実行するコマンドです。リストの最後の要素@var{item-property-list}は、プロパティリストの形式をもつ、その他の情報を含みます。

  以下は、サポートされるプロパティのテーブルです:

@table @code
@item :enable @var{form}
@var{form}の評価結果は、そのアイテムを有効にするかどうかを決定する(非@code{nil}の場合は有効)。アイテムが無効な場合は、実際にクリックできない。

@item :visible @var{form}
@var{form}の評価結果は、そのアイテムを実際にメニューに表示するかどうかを決定する(非@code{nil}の場合は表示)。アイテムが非表示の場合は、そのアイテムが定義されていないかのようにメニューが表示される。

@item :help @var{help}
このプロパティ@var{help}の値は、そのアイテム上にマウスがある間表示する``help-echo''文字列を指定する。この文字列は、@code{help-echo}テキストプロパティ(@ref{Help
display}を参照)と同じ方法で表示される。これは、テキストやoverlayにたいする@code{help-echo}プロパティと異なり、文字列定数でなければならないことに注意されたい。

@item :button (@var{type} . @var{selected})
このプロパティは、ラジオボタンおよびトグルボタンを定義する手段を提供する。@sc{car}の@var{type}は、@code{:toggle}か@code{:radio}のいずれかを指定する。@sc{cdr}の@var{selected}はフォームで、評価結果によりそのボタンがカレントで選択されているかどうかを指定する。

@dfn{トグル(toggle)}は、@var{selected}の値に応じて``on''か``off''のいずれかがラベルされるメニューアイテムである。コマンド自身は、@var{selected}が@code{nil}なら@code{t}に、@code{t}なら@code{nil}に@var{selected}を切り替える(toggle)こと。以下は、@code{debug-on-error}フラグが定義されているときに、メニューアイテムをトグルする方法の例である:

@example
(menu-item "Debug on Error" toggle-debug-on-error
           :button (:toggle
                    . (and (boundp 'debug-on-error)
                           debug-on-error)))
@end example

@noindent
これは、@code{toggle-debug-on-error}が変数@code{debug-on-error}をトグルするコマンドとして定義されていることにより機能する。

@dfn{ラジオボタン}とは、メニューアイテムのグループであり、常にただ1つのメニューアイテムだけが``選択される(selected)''。そのためには、どのメニューアイテムが選択されているかを示す変数が存在する必要がある。グループ内の各ラジオボタンにたいする@var{selected}フォームは、そのボタンを選択するために、その変数が正しい値をもつかどうかをチェックする。そして、ボタンのクリックにより変数をセットして、クリックされたボタンが選択される。

@item :key-sequence @var{key-sequence}
このプロパティは、そのメニューアイテムにより呼び出されるのと同じコマンドにバインドされるかもしれないキーシーケンスを指定する。正しいキーシーケンスを指定した場合は、メニュー表示の準備がより高速になる。

間違ったキーシーケンスを指定した場合は、何の効果もない。Emacsは、メニュー内の@var{key-sequence}を表示する前に、実際にその@var{key-sequence}がそのメニューアイテムと等価なのか検証する。

@item :key-sequence nil
このプロパティは、そのメニューアイテムには等価なキーバインディングが通常は存在しないことを示す。このプロパティを使用することにより、Emacsはそのメニューアイテムにたいして等価なキーボード入力をキーマップから検索する必要がなくなるので、メニュー表示の準備時間が短縮される。

しかし、ユーザーがそのアイテムの定義をキーシーケンスにリバインドした場合、Emacsは@code{:keys}プロパティを無視して、結局は等価なキーボード入力を見つけ出す。

@item :keys @var{string}
このプロパティは、そのメニューにたいする等価なキーボード入力として表示される文字列@var{string}を指定する。@var{string}内では、ドキュメント構成@samp{\\[...]}を使用できる。

@item :filter @var{filter-fn}
このプロパティは、メニューアイテムを直接計算する手段を提供する。このプロパティの値@var{filter-fn}は、引数が1つの関数で、呼び出し時の引数は@var{real-binding}である。この関数は、かわりに使用するバインディングをリターンするべきである。

Emacsは、メニューデータ構造を再表示、または操作する任意のタイミングでこの関数を呼び出し得るので、いつ呼び出されても安全なように関数を記述すべきである。
@end table

@node Menu Separators
@subsubsection Menu Separators
@cindex menu separators

  メニューセパレーターは、テキストを表示するかわりに、水平ラインでメニューをサブパーツに分割する、メニューアイテムの一種です。メニューキーマップ内で、セパレーターは以下のように見えます:

@example
(menu-item @var{separator-type})
@end example

@noindent
ここで、@var{separator-type}は2つ以上のダッシュで始まる文字列です。

  もっとも単純なケースでは、ダッシュだけで@var{separator-type}が構成されます。これはデフォルトのセパレーターを指定します(互換性のため、@code{""}と@code{-}もセパレーターとみなされる)。

  @var{separator-type}にたいする他の特定の値は、異なるスタイルのセパレーターを指定します。以下はそれらのテーブルです:

@table @code
@item "--no-line"
@itemx "--space"
実際のラインではない、余分な垂直スペース。

@item "--single-line"
メニューのforegroundカラーの一重ライン。

@item "--double-line"
メニューのforegroundカラーの二重ライン。

@item "--single-dashed-line"
メニューのforegroundカラーの一重ダッシュライン。

@item "--double-dashed-line"
メニューのforegroundカラーの二重ダッシュライン。

@item "--shadow-etched-in"
3Dの窪んだ外観(3D sunken appearance)をもつ一重ライン。これはダッシュだけで構成されるセパレーターに使用されるデフォルトである。

@item "--shadow-etched-out"
3Dの浮き上がった外観(3D raised appearance)をもつ一重ライン。

@item "--shadow-etched-in-dash"
3Dの窪んだ外観(3D sunken appearance)をもつ一重ダッシュライン。

@item "--shadow-etched-out-dash"
3Dの浮き上がった外観(3D raised appearance)をもつ一重ダッシュライン。

@item "--shadow-double-etched-in"
3Dの窪んだ外観をもつ二重ライン。

@item "--shadow-double-etched-out"
3Dの浮き上がった外観をもつ二重ライン。

@item "--shadow-double-etched-in-dash"
3Dの窪んだ外観をもつ二重ダッシュライン。

@item "--shadow-double-etched-out-dash"
3Dの浮き上がった外観をもつ二重ダッシュライン。
@end table

  2連ダッシュの後にコロンを追加して、1連ダッシュの後の単語の先頭の文字を大文字にすることにより、別のスタイルで名前を与えることもできます。つまり、@code{"--:singleLine"}は@code{"--single-line"}と等価です。

  メニューセパレーターにたいして@code{:enable}や@code{:visible}のようなキーワードを指定するために、長い形式を使用できます。

@code{(menu-item @var{separator-type} nil . @var{item-property-list})}

たとえば:

@example
(menu-item "--" nil :visible (boundp 'foo))
@end example

  いくつかのシステムおよびディスプレイツールキットは、これらすべてのセパレータータイプを実際に処理しません。サポートされないタイプのセパレーターを使用した場合、メニューはサポートされている似た種別のセパレーターを表示します。

@node Alias Menu Items
@subsubsection Alias Menu Items

  ``同じ''コマンドを使用するが、有効条件が異なるメニューアイテムを作成すると便利な場合が時折あります。Emacsでこれを行う最善の方法は、拡張メニューアイテム(extended
menu
item)です。この機能が存在する以前は、エイリアスコマンドを定義して、それらをメニューアイテムで使用することによりこれを行っていました。以下は、@code{read-only-mode}にたいする2つのエイリアスを作成して、それらに異なる有効条件を与える例です:

@example
(defalias 'make-read-only 'read-only-mode)
(put 'make-read-only 'menu-enable '(not buffer-read-only))
(defalias 'make-writable 'read-only-mode)
(put 'make-writable 'menu-enable 'buffer-read-only)
@end example

メニュー内でエイリアスを使用するときは、エイリアスではなく``実際''のコマンド名にたいする等価なキーバインディングを表示するのが便利な場合が多々あります(エイリアスはメニュー自身を除きキーバインディングを通常はもたない)。これを要求するには、エイリアスシンボルに@code{menu-alias}プロパティに非@code{nil}を与えます。したがって、

@example
(put 'make-read-only 'menu-alias t)
(put 'make-writable 'menu-alias t)
@end example

@noindent
は、@code{make-read-only}と@code{make-writable}にたいするメニューアイテムに、@code{read-only-mode}のキーバインディングを表示します。

@node Mouse Menus
@subsection Menus and the Mouse

  メニューキーマップがメニューを生成する通常の方法は、それをプレフィクスキーの定義とすることです。(Lispプログラムは明示的にメニューをポップアップして、ユーザーの選択を受け取ることができる。@ref{Pop-Up
Menus}を参照のこと。)

  プレフィクスキーがマウスイベントで終わる場合、ユーザーがマウスで選択できるように、Emacsは可視なメニューをポップアップすることによりメニューキーマップを処理します。ユーザーがメニューアイテムをクリックしたときは、そのメニューアイテムによりもたらされるバインディングの文字、またはシンボルが何であれ、イベントが生成されます(メニューが複数レベルをもつ場合やメニューバー由来の場合、メニューアイテムは1連のイベントを生成するかもしれない)。

  メニューのトリガーにbutton-downイベントを使用するのが最善な場合もしばしばあります。その場合、ユーザーはマウスボタンをリリースすることにより、メニューアイテムを選択できます。

@cindex submenu
  メニューキーマップがネストされたキーマップにたいするバインディングを含む場合、そのネストされたキーマップは@dfn{サブメニュー(submenu)}を指定します。それにはネストされたキーマップのアイテム文字列によりラベル付けされたメニューアイテムがあり、そのアイテムをクリックすることにより、指定されたサブメニューが自動的にポップアップされます。特別な例外として、メニューキーマップが単一のネストされたキーマップを含み、それ以外のメニューアイテムを含まない場合、そのメニューはネストされたキーマップの内容を、サブメニューとしてではなく、直接メニューに表示します。

  しかし、XツールキットのサポートなしでEmacsをコンパイルした場合、またはテキスト端末の場合、サブメニューはサポートされません。ネストされたキーマップはメニューアイテムとして表示されますが、それをクリックしても、サブメニューは自動的にポップアップされません。サブメニューの効果を模倣したい場合は、ネストされたキーマップに@samp{@@}で始まるアイテム文字列を与えることにより、これを行うことができます。これにより、Emacsは別個の@dfn{メニューペイン(menu
pane)}を使用してネストされたキーマップを表示します。@samp{@@}の後の残りのアイテム文字列は、そのペインのラベルです。XツールキットのサポートなしでEmacsをコンパイルした場合、またはメニューがテキスト端末で表示されている場合、メニューペインは使用されません。この場合、アイテム文字列の先頭の@samp{@@}は、メニューラベル表示時には省略され、他に効果はありません。

@node Keyboard Menus
@subsection Menus and the Keyboard

  キーボードイベント(文字かファンクションキー)で終わるプレフィクスキーがメニューキーマップであるような定義をもつとき、そのキーマップはキーボードメニューのように動作します。ユーザーは、キーボードでメニューアイテムを選択して、次のイベントを指定します。

  Emacsは、エコーエリアにキーボードメニュー、そのマップのoverallプロンプト文字列、その後に候補(そのマップのバインディングのアイテム文字列)を表示します。そのバインディングを一度に全部表示できない場合、ユーザーは@key{SPC}をタイプして、候補の次の行を確認できます。連続して@key{SPC}を使用するとメニューの最後に達し、その後は先頭へ巡回します。(変数@code{menu-prompt-more-char}はこのために使用する文字を指定する。デフォルトは@key{SPC}。)

  ユーザーがメニューから望ましい候補を見つけたら、バインディングがその候補であるような、対応する文字をタイプする必要があります。

@defvar menu-prompt-more-char
この変数は、メニューの次の行を確認するために使用する文字を指定する。初期値は32で、これは@key{SPC}のコードである。
@end defvar

@node Menu Example
@subsection Menu Example
@cindex menu definition example

  以下は、メニューキーマップを定義する、完全な例です。これは、メニューバー内の@samp{Edit}メニューにサブメニュー@samp{Replace}を定義して、その定義内で拡張メニューフォーマット(@ref{Extended
Menu Items}を参照)を使用します。例ではまずキーマップを作成して、それに名前をつけます:

@smallexample
(defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))
@end smallexample

@noindent
次にメニューアイテムを定義します:

@smallexample
(define-key menu-bar-replace-menu [tags-repl-continue]
  '(menu-item "Continue Replace" tags-loop-continue
              :help "Continue last tags replace operation"))
(define-key menu-bar-replace-menu [tags-repl]
  '(menu-item "Replace in tagged files" tags-query-replace
              :help "Interactively replace a regexp in all tagged files"))
(define-key menu-bar-replace-menu [separator-replace-tags]
  '(menu-item "--"))
;; @r{@dots{}}
@end smallexample

@noindent
バインディングがそのシンボルのために``作成された''ことに注意してください。これらのシンボルは、定義されるキーシーケンス内の角カッコ内に記述されます。このシンボルはコマンド名と同じときもあれば、異なることもあります。これらのシンボルは``ファンクションキー''として扱われますが、これらはキーボード上の実際のファンクションキーではありません。これらはメニュー自体の機能に影響しませんが、ユーザーがメニューから選択したときにエコーエリアに``エコー''され、@code{where-is}と@code{apropos}の出力に現れます。

  この例のメニューは、マウスによる使用を意図しています。もしキーボードの使用を意図したメニュー、つまりキーボードイベントで終了するキーシーケンスにバインドされたメニューの場合、メニューアイテムはキーボードでタイプできる文字、または``実際''のファンクションキーにバインドされるべきです。

  定義が@code{("--")}のバインディングは、セパレーターラインです。実際のメニューアイテムと同様、セパレーターはキーシンボルをもち、この例では@code{separator-replace-tags}です。1つのメニューが2つのセパレーターをもつ場合、それらは2つの異なるキーシンボルをもたなければなりません。

  以下では、親メニュー内のアイテムとしてこのメニューがどのように表示されるかを記述しています:

@example
(define-key menu-bar-edit-menu [replace]
  (list 'menu-item "Replace" menu-bar-replace-menu))
@end example

@noindent
これは、シンボル@code{menu-bar-replace-menu}自体ではなく、変数@code{menu-bar-replace-menu}の値であるサブメニューキーマップを組み込むことに注意してください。@code{menu-bar-replace-menu}はコマンドではないので、親メニューアイテムにそのシンボルを使用するのは無意味です。

  同じreplaceメニューをマウスクリックに割り当てたい場合は、以下のようにこれを行うことができます:

@example
(define-key global-map [C-S-down-mouse-1]
   menu-bar-replace-menu)
@end example

@node Menu Bar
@subsection The Menu Bar
@cindex menu bar

  Emacsは通常、各フレームの最上部に@dfn{メニューバー(menu bar)}を表示します。@ref{Menu Bars,,,emacs, The
GNU Emacs
Manual}を参照してください。メニューバーのアイテムは、アクティブキーマップ内で定義される偽りの``ファンクションキー''@code{menu-bar}のサブコマンドです。

  メニューバーにアイテムを追加するには、自分で偽りの``ファンクションキー''(これを@var{key}と呼ぶことにしましょう)を創作して、キーシーケンス@code{[menu-bar
@var{key}]}にたいするキーバインディングを作成します。ほとんどの場合において、そのバインディングはメニューキーマップなので、メニューバーアイテム上でボタンを押下すると、他のメニューに導かれます。

  メニューバーにたいして同じ``ファンクションキー''を定義するアクティブなキーマップが1つ以上存在するとき、そのアイテムは1回だけ出現します。ユーザーがメニューバーのそのアイテムをクリックした場合、そのアイテムのすべてのサブコマンド---
グローバルサブコマンド、ローカルサブコマンド、マイナーモードサブコマンドが組み合わされた単一のメニューを表示します。

  変数@code{overriding-local-map}は通常、メニューバーのコンテンツを決定する際は無視されます。つまり、メニューバーは@code{overriding-local-map}が@code{nil}の場合にアクティブになるであろうキーマップから計算されます。@ref{Active
Keymaps}を参照してください。

  以下は、メニューバーのアイテムをセットアップする例です:

@example
@group
;; @r{(プロンプト文字列とともに)メニューキーマップを作成して}
;; @r{それをメニューバーアイテムの定義にする}
(define-key global-map [menu-bar words]
  (cons "Words" (make-sparse-keymap "Words")))
@end group

@group
;; @r{メニュー内に具体的なサブコマンドを定義する}
(define-key global-map
  [menu-bar words forward]
  '("Forward word" . forward-word))
@end group
@group
(define-key global-map
  [menu-bar words backward]
  '("Backward word" . backward-word))
@end group
@end example

  ローカルキーマップは、グローバルキーマップにより作成されたメニューバーアイテムにたいして、同じ偽ファンクションキーを@code{undefined}にリバインドしてキャンセルすることができます。たとえば、以下はDiredが@samp{Edit}メニューバーアイテムを抑制する方法です:

@example
(define-key dired-mode-map [menu-bar edit] 'undefined)
@end example

@noindent
ここで、@code{edit}は@samp{Edit}メニューバーアイテムにたいしてグローバルキーマップにより使用される偽ファンクションキーです。グローバルメニューバーアイテムを抑制する主な理由は、モード特有のアイテムのためのスペースを確保するためです。

@defvar menu-bar-final-items
通常メニューバーナーグローバルアイテムの後にローカルマップにより定義されるアイテムを表示する。

この変数は、通常の順番による位置ではなく、メニューの最後に表示するアイテムのための偽ファンクションキーのリストを保持する。デフォルト値は@code{(help-menu)}である。したがって、@samp{Help}メニューアイテムはメニューバーの最後、ローカルメニューアイテムの後に表示される。
@end defvar

@defvar menu-bar-update-hook
このノーマルフックは、メニューバーの再表示の前に、メニューバーのコンテンツを更新するための再表示により実行される。コンテンツを変化させる必要があるメニューの更新に使用できる。このフックは頻繁に実行されるので、フックが呼び出す関数は、通常の場合は長い時間を要さないことを確実にするよう助言する。
@end defvar

Emacsは、すべてのメニューバーアイテムの隣に、(もしそのようなキーバインディングが存在するなら)同じコマンドを実行するキーバインディングを表示します。これは、キーバインディングを知らないユーザーにたいして便利なヒントを与える役目をもちます。コマンドが複数のバインディングをもつ場合、通常Emacsは最初に見つけたバインディングを表示します。コマンドのシンボルプロパティ@code{:advertised-binding}に割り当てることにより、特定のキーバインディングを指定できます。@ref{Keys
in Documentation}を参照してください。

@node Tool Bar
@subsection Tool bars
@cindex tool bar

  @dfn{ツールバー(tool bar)}とは、フレームの最上部、メニューバー直下にある、クリック可能なアイコンの行のことです。@ref{Tool
Bars,,,emacs, The GNU Emacs
Manual}を参照してください。Emacsは通常、グラフィカルなディスプレイ上でツールバーを表示します。

  各フレームでは、ツールバーに何行分の高さを割り当てるかを、フレームパラメーター@code{tool-bar-lines}が制御します。値0は、ツールバーを抑制します。値が非0で、@code{auto-resize-tool-bars}が非@code{nil}の場合、指定されたコンテンツを維持するのに必要な分、ツールバーは拡大縮小されます。値が@code{grow-only}の場合、ツールバーは自動的に拡大されますが、自動的に縮小はされません。

  ツールバーのコンテンツは、(メニューバーが制御されるのと似た方法により)@code{tool-bar}と呼ばれる偽りの``ファンクションキー''に割り当てられたメニューキーマップにより制御されます。したがって、以下のように@code{define-key}を使用して、ツールバーアイテムを定義します。

@example
(define-key global-map [tool-bar @var{key}] @var{item})
@end example

@noindent
ここで@var{key}は、そのアイテムを他のアイテムと区別する偽``ファンクションキー''で、@var{item}はそのアイテムを表示する方法とアイテムの振る舞いを示すメニューアイテムキーバインディングです(@ref{Extended
Menu Items}を参照)。

  メニューキーマップの通常のプロパティ@code{:visible}、@code{:enable}、@code{:button}、@code{:filter}はツールバーバインディングでも役に立ち、いずれのプロパティも通常通りの意味をもちます。アイテム内の@var{real-binding}は、キーマップではなくコマンドでなければなりません。別の言い方をすると、これはツールバーアイコンをプレフィクスキーとして定義するようには機能しないということです。

  @code{:help}プロパティは、そのアイテム上にマウスがある間表示する、``help-echo''文字列を指定します。これは、テキストプロパティ@code{help-echo}と同じ方法で表示されます(@ref{Help
display}を参照)。

  これらに加えて、@code{:image}プロパティも使用するべきでしょう。これは、ツールバー内にイメージを表示するには、このプロパティを使用します。

@table @code
@item :image @var{image}
@var{images}は単一イメージ様式(single image specification)、または4ベクターイメージ様式(vector of
four image specifications)で指定する。4ベクターを使用する場合、状況に応じてそれらのうち1つが使用される:

@table @asis
@item item 0
アイテムが有効かつ選択されているとき使用される。
@item item 1
アイテムが有効かつ未選択のとき使用される。
@item item 2
アイテムが無効かつ選択されているとき使用される。
@item item 3
アイテムが無効かつ未選択のとき使用される。
@end table
@end table

GTK+およびNSバージョンのEmacsは、無効、および/または未選択のイメージをitem0から自動的に計算するので、item1からitem3は無視されます。

@var{image}が単一イメージ様式の場合、Emacsはそのイメージにエッジ検出アルゴリズム(edge-detection
algorithm)を適用することにより、ツールバーの無効な状態のボタンを描画します。

@code{:rtl}プロパティには、右から左に記述する言語のためのイメージ候補を指定します。現在のところ、これをサポートするのはGTK+バージョンのEmacsだけです。

メニューバーと同様、ツールバーはセパレーター(@ref{Menu
Separators}を参照)を表示できます。ツールバーのセパレーターは水平ラインではなく垂直ラインであり、1つのスタイルだけがサポートされます。これらは、ツールバーキーマップ内では@code{(menu-item
"--")}エントリーで表されます。ツールバーのセパレーターでは、@code{:visible}のようなプロパティはサポートされません。GTK+とNextstepのツールバーでは、セパレーターはネイティブに描画されます。それ以外では、セパレーターは垂直ラインイメージを使用して描画されます。

デフォルトツールバーは、コマンドシンボルの@code{mode-class}プロパティに@code{special}をもつメジャーモードにたいしては、編集に特化したアイテムは表示されないよう定義されています(@ref{Major
Mode Conventions}を参照)。メジャーモードは、ローカルマップ内でバインディング@code{[tool-bar
@var{foo}]}によって、グローバルバーにアイテムを追加するかもしれません。デフォルトツールバーの多くを適宜流用するのができないかもしれないため、デフォルトツールバーを完全に置き換えることは、いくつかのメジャーモードにとっては意味があります。デフォルトバインディングで@code{tool-bar-map}を通じてインダイレクトすることにより、これを簡単に行うことができます。

@defvar tool-bar-map
デフォルトでは、グローバルマップは@code{[tool-bar]}を以下のようにバインドする:

@example
(global-set-key [tool-bar]
                `(menu-item ,(purecopy "tool bar") ignore
                            :filter tool-bar-make-keymap))
@end example

@noindent
関数@code{tool-bar-make-keymap}は、変数@code{tool-bar-map}の値より、順に実際のツールバーマップをダイナミックに継承する。したがって、通常はそのマップを変更することにより、デフォルト(グローバル)ツールバーを調整すべきである。Infoモードのようないくつかのメジャーモードは、@code{tool-bar-map}をバッファーローカルにして、それに異なるキーマップをセットすることにより、グローバルツールバーを完全に置き換える。
@end defvar

以下のような、ツールバーアイテムを定義するのに便利な関数があります。

@defun tool-bar-add-item icon def key &rest props
この関数は、@code{tool-bar-map}を変更することにより、ツールバーにアイテムを追加する。使用するイメージは@var{icon}により定義され、これは@code{find-image}に配置されたXPM、XBM、PBMのイメージファイルの拡張子を除いたファイル名(basename)である。たとえばカラーディスプレイ上では、値に@samp{"exit"}を与えると@file{exit.xpm}、@file{exit.pbm}、@file{exit.xbm}の順に検索されるだろう。モノクロディスプレイでは、検索は@samp{.pbm}、@samp{.xbm}、@samp{.xpm}の順になる。使用するバインディングはコマンド@var{def}で、@var{key}はプレフィクスキーマップ内の偽ファンクションキーである。残りの引数@var{props}は、メニューアイテム仕様に追加する、追加のプロパティリスト要素である。

あるローカルマップ内にアイテムを定義するためには、この関数呼び出しの周囲の@code{let}で@code{tool-bar-map}をバインドする:
@example
(defvar foo-tool-bar-map
  (let ((tool-bar-map (make-sparse-keymap)))
    (tool-bar-add-item @dots{})
    @dots{}
    tool-bar-map))
@end example
@end defun

@defun tool-bar-add-item-from-menu command icon &optional map &rest props
この関数は、既存のメニューバインディングと矛盾しないツールバーアイテムの定義に有用である。@var{command}のバインディングは@var{map}(デフォルトは@code{global-map})内よりルックアップ(lookup:
照合)され、@var{icon}にたいするイメージ仕様は@code{tool-bar-add-item}と同じ方法で見つけ出される。結果のバインディングは@code{tool-bar-map}に配されるので、この関数の使用はグローバルツールバーアイテムに限定される。

@var{map}には、@code{[menu-bar]}にバインドされた適切なキーマップが含まれていなければならない。残りの引数@var{props}は、メニューアイテム仕様に追加する、追加のプロパティリスト要素である。
@end defun

@defun tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props
この関数は、非グローバルツールバーアイテムの作成に使用される。@var{in-map}に定義を作成するローカルマップを指定する以外は、@code{tool-bar-add-item-from-menu}と同じように使用する。引数@var{from-map}は、@code{tool-bar-add-item-from-menu}の@var{map}と同様である。
@end defun

@defvar auto-resize-tool-bars
この変数が非@code{nil}の場合、定義されたすべてのツールバーアイテムを表示するために、ツールバーは自動的にリサイズ ---
ただし、そのフレーム高さの1/4を超えてリサイズされることはない。

値が@code{grow-only}の場合、ツールバーは自動的に拡張されるが、自動的に縮小はされない。ツールバーを縮小するために、ユーザーは@kbd{C-l}をエンターしてフレームを再描画する必要がある。

GTK、またはNextstepとともにEmacsがビルドされた場合、ツールバーが表示できるのは1行だけであり、この変数は効果がない。
@end defvar

@defvar auto-raise-tool-bar-buttons
この変数が非@code{nil}の場合、ツールバーアイテムの上をマウスが通過したとき、浮き上がった形式(raised form)で表示される。
@end defvar

@defvar tool-bar-button-margin
この変数は、ツールバーアイテムの周囲に追加する余白(extra margin)を指定する。値はピクセル数を整数で指定し、デフォルトは4である。
@end defvar

@defvar tool-bar-button-relief
この変数は、ツールバーアイテムの影(shadow)を指定する。値はピクセル数を整数で指定し、デフォルトは1である。
@end defvar

@defvar tool-bar-border
この変数は、ツールバーエリアの下に描画するボーダー高さを指定する。値が整数の場合は、高さのピクセル数である。値が@code{internal-border-width}(デフォルト)か@code{border-width}のいずれの場合、ツールバーのボーダー高さは、そのフレームの対応するパラメーターとなる。
@end defvar

  シフト、メタ等の修飾キーを押下した状態でのツールバーアイテムのクリックにたいして、特別な意味を付与できます。偽りのファンクションキーを通じて、元のアイテムに関連する追加アイテムをセットアップすることにより、これを行うことができます。より具体的には、追加アイテムは、元のアイテムの命名に使用されたのと同じ偽ファンクションキーの修飾されたバージョンを使用するべきです。

  つまり、元のアイテムが以下のように定義されている場合、

@example
(define-key global-map [tool-bar shell]
  '(menu-item "Shell" shell
              :image (image :type xpm :file "shell.xpm")))
@end example

@noindent
シフト修飾とともに同じツールバーイメージをクリックしたときは、以下のような方法で定義することができます:

@example
(define-key global-map [tool-bar S-shell] 'some-command)
@end example

ファンクションキーにたいして修飾を追加する方法についての詳細な情報は、@ref{Function Keys}を参照してください。

@node Modifying Menus
@subsection Modifying Menus
@cindex menu modification

  既存のメニューに新たなアイテムを挿入するときは、そのメニューの既存のアイテムの中の特定の位置にアイテムを追加したいと思うかもしれません。@code{define-key}を使用してアイテムを追加した場合は通常、そのアイテムはメニューの先頭に追加されます。メニュー内の他の位置にアイテムを追加するには、@code{define-key-after}を使用します:

@defun define-key-after map key binding &optional after
@code{define-key}と同じように、@var{map}内に@var{key}にたいする値@var{binding}のバインディングを定義するが、@var{map}内でそのバインディングの位置は、イベント@var{after}にたいするバインディングの後になる。引数@var{key}は長さ1
--- 1要素だけのベクターか文字列にすべきである。しかし@var{after}は単一のイベント型 ---
シーケンスではないシンボルか文字にすべきである。新たなバインディングは、@var{after}にたいするバインディングの後に追加される。@var{after}が@code{t}、または省略された場合、新たなバインディングはそのキーマップの最後に追加される。しかし、新たなバインディングは、すべての継承されたキーマップの前に追加される。

以下に例を示す:

@example
(define-key-after my-menu [drink]
  '("Drink" . drink-command) 'eat)
@end example

@noindent
これは、偽ファンクションキー@key{DRINK}にたいするバインディングを作成して、@key{EAT}にたいするバインディングの直後に追加する。

以下に、Shellモードの@samp{Signals}メニュー内のアイテム@code{break}の後に、@samp{Work}と呼ばれるアイテムを追加する方法を示す:

@example
(define-key-after
  (lookup-key shell-mode-map [menu-bar signals])
  [work] '("Work" . work-command) 'break)
@end example
@end defun

@node Easy Menu
@subsection Easy Menu

  The following macro provides a convenient way to define pop-up menus and/or
menu bar menus.

@defmac easy-menu-define symbol maps doc menu
This macro defines a pop-up menu and/or menu bar submenu, whose contents are
given by @var{menu}.

If @var{symbol} is non-@code{nil}, it should be a symbol; then this macro
defines @var{symbol} as a function for popping up the menu (@pxref{Pop-Up
Menus}), with @var{doc} as its documentation string.  @var{symbol} should
not be quoted.

Regardless of the value of @var{symbol}, if @var{maps} is a keymap, the menu
is added to that keymap, as a top-level menu for the menu bar (@pxref{Menu
Bar}).  It can also be a list of keymaps, in which case the menu is added
separately to each of those keymaps.

The first element of @var{menu} must be a string, which serves as the menu
label.  It may be followed by any number of the following keyword-argument
pairs:

@table @code
@item :filter @var{function}
@var{function} must be a function which, if called with one argument---the
list of the other menu items---returns the actual items to be displayed in
the menu.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the menu is
made invisible.  @code{:included} is an alias for @code{:visible}.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the menu is
not selectable.  @code{:enable} is an alias for @code{:active}.
@end table

The remaining elements in @var{menu} are menu items.

A menu item can be a vector of three elements, @code{[@var{name}
@var{callback} @var{enable}]}.  @var{name} is the menu item name (a
string).  @var{callback} is a command to run, or an expression to evaluate,
when the item is chosen.  @var{enable} is an expression; if it evaluates to
@code{nil}, the item is disabled for selection.

Alternatively, a menu item may have the form:

@smallexample
   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]
@end smallexample

@noindent
where @var{name} and @var{callback} have the same meanings as above, and
each optional @var{keyword} and @var{arg} pair should be one of the
following:

@table @code
@item :keys @var{keys}
@var{keys} is a keyboard equivalent to the menu item (a string).  This is
normally not needed, as keyboard equivalents are computed automatically.
@var{keys} is expanded with @code{substitute-command-keys} before it is
displayed (@pxref{Keys in Documentation}).

@item :key-sequence @var{keys}
@var{keys} is a hint for speeding up Emacs's first display of the menu.  It
should be @code{nil} if you know that the menu item has no keyboard
equivalent; otherwise it should be a string or vector specifying a keyboard
equivalent for the menu item.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the item is
make unselectable..  @code{:enable} is an alias for @code{:active}.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the item is
made invisible.  @code{:included} is an alias for @code{:visible}.

@item :label @var{form}
@var{form} is an expression that is evaluated to obtain a value which serves
as the menu item's label (the default is @var{name}).

@item :suffix @var{form}
@var{form} is an expression that is dynamically evaluated and whose value is
concatenated with the menu entry's label.

@item :style @var{style}
@var{style} is a symbol describing the type of menu item; it should be
@code{toggle} (a checkbox), or @code{radio} (a radio button), or anything
else (meaning an ordinary menu item).

@item :selected @var{selected}
@var{selected} is an expression; the checkbox or radio button is selected
whenever the expression's value is non-@code{nil}.

@item :help @var{help}
@var{help} is a string describing the menu item.
@end table

Alternatively, a menu item can be a string.  Then that string appears in the
menu as unselectable text.  A string consisting of dashes is displayed as a
separator (@pxref{Menu Separators}).

Alternatively, a menu item can be a list with the same format as
@var{menu}.  This is a submenu.
@end defmac

Here is an example of using @code{easy-menu-define} to define a menu similar
to the one defined in the example in @ref{Menu Bar}:

@example
(easy-menu-define words-menu global-map
  "Menu for word navigation commands."
  '("Words"
     ["Forward word" forward-word]
     ["Backward word" backward-word]))
@end example
