@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lists
@chapter リスト
@cindex lists
@cindex element (of list)

  @dfn{リスト(list)}は0個以上の要素(任意のLispオブジェクト)のシーケンスを表します。リストとベクターの重要な違いは、、2つ以上のリストが、構造の一部を共有できることです。加えて、リスト全体をコピーすることなく、要素の挿入、削除ができます。

@menu
* Cons Cells::               コンスセルからリストが作られる方法。
* List-related Predicates::  このオブジェクトはリストか? 
                               2つのリストを比較する。
* List Elements::            リストの一部を抽出する。
* Building Lists::           リスト構造の作成。
* List Variables::           変数に保存されたリストにたいする変更。
* Modifying Lists::          既存のリストに新しい要素を保存する。
* Sets And Lists::           リストは有限な数学集合を表現できる。
* Association Lists::        リストは有限な関係またはマッピングを表現できます。
* Property Lists::           要素ペアのリスト。
@end menu

@node Cons Cells
@section リストとコンスセル
@cindex lists and cons cells

  Lispでのリストは基本データ型ではありません。リストは@dfn{コンスセル(cons cells)}から構築されます(@ref{Cons Cell
Type}を参照してください)。コンスセルは、順序つきペアを表現するデータオブジェクトです。つまり、コンスセルは2つのスロットをもち、それぞれのスロットはLispオブジェクトを@dfn{保持(holds)}、または@dfn{参照(refers
to)}します。1つのスロットは@sc{car}、もう1つは@sc{cdr}です(これらの名前は歴史的なものです。@ref{Cons Cell
Type}を参照してください)。@sc{cdr}は``could-er(クダー)''と発音されます。

  わたしたちは、コンスセルの@sc{car}スロットに現在保持されているオブジェクトが何であれ、``このコンスセルの@sc{car}は、...''のような言い方をします。これは@sc{cdr}の場合も同様です。

  リストとは、``互いにつながった(chained
together)''一連のコンスセルであり、各セルは次のセルを参照します。リストの各要素にたいして、それぞれ1つのコンスセルがあります。慣例により、コンスセルの@sc{car}はリストの要素を保持し、@sc{cdr}はリストをチェーンするのに使用されます(@sc{car}と@sc{cdr}の間の非対称性は完全に慣例的なものです。コンスセルのレベルでは、@sc{car}スロットと@sc{cdr}スロットは同じようなプロパティーをもちます)。したがって、リスト内の各コンスセルの@sc{cdr}スロットは、次のコンスセルを参照します。

@cindex true list
  これも慣例的なものですが、リスト内の最後のコンスセルの@sc{cdr}は@code{nil}です。わたしたちは、このような@code{nil}で終端された構造を、@dfn{真リスト(true
list)}と呼びます。Emacs
Lispでは、シンボル@code{nil}は、シンボルであり、要素なしのリストでもあります。便宜上、シンボル@code{nil}は、その@sc{cdr}(および@sc{car})に@code{nil}をもつと考えます。

  したがって真リストの@sc{cdr}は、常に真リストです。空でない真リストの@sc{cdr}は、1番目の要素以外を含む真リストです。

@cindex dotted list
@cindex circular list
  リストの最後のコンスセルの@sc{cdr}が@code{nil}以外の何らかの値の場合、このリストのプリント表現はドットペア表記(dotted pair
notation。@ref{Dotted Pair
Notation}を参照してください)を使用するので、わたしたちはこの構造を@dfn{ドットリスト(dotted
list)}と呼びます。他の可能性もあります。あるコンスセルの@sc{cdr}が、そのリストのそれより前にある要素を指すかもしれません。わたしたちは、この構造を@dfn{循環リスト(circular
list)}と呼びます。

  ある目的にたいしては、そのリストが真リストか、循環リストなのか、ドットリストなのかが問題にならない場合もあります。そのプログラムが、リストを充分に下って最後のコンスセルの@sc{cdr}を確認しようとしないなら、これは問題になりません。しかし、リストを処理するの関数のいくつかは、真リストを要求し、ドットリストの場合はエラーをシグナルします。リストの最後を探そうと試みる関数のほとんどは、循環リストを与えると無限ループに突入します。

@cindex list structure
  ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルで構成される任意の構造を、@dfn{リスト構造(list
structure)}と呼びます。

@node List-related Predicates
@section リストのための述語
@cindex predicates for lists
@cindex list predicates

  以下の述語は、あるLispオブジェクトがアトムなのか、コンスセルなのか、それともリストなのか、またはオブジェクトが@code{nil}かどうかテストします(これらの述語の多くは、他の述語で定義することもできますが、多用されるので、定義する価値があるのです)。

@defun consp object
この関数は、@var{object}がコンスセルの場合は@code{t}、それ以外は@code{nil}をreturnします。たとえ@code{nil}はリスト@emph{です}が、コンスセルではありません。
@end defun

@defun atom object
この関数は、@var{object}がアトムの場合は@code{t}、それ以外は@code{nil}をreturnします。シンボル@code{nil}はアトムであり、リストでもあります。そのようなLispオブジェクトは@code{nil}だけです。

@example
(atom @var{object}) @equiv{} (not (consp @var{object}))
@end example
@end defun

@defun listp object
この関数は、@var{object}がコンスセルか@code{nil}の場合は@code{t}をreturnします。それ以外は@code{nil}をreturnします。

@example
@group
(listp '(1))
     @result{} t
@end group
@group
(listp '())
     @result{} t
@end group
@end example
@end defun

@defun nlistp object
この関数は@code{listp}の反対です。@var{object}がリストでない場合は@code{t}をreturnします。それ以外は@code{nil}をreturnします。

@example
(listp @var{object}) @equiv{} (not (nlistp @var{object}))
@end example
@end defun

@defun null object
この関数は、@var{object}が@code{nil}の場合は@code{t}、それ以外は@code{nil}をreturnします。この関数は@code{not}と等価ですが、明解にするために、@var{object}をリストだと考えるときは@code{null}、真偽値だと考えるときは@code{not}を使用します(@ref{Combining
Conditions}の@code{not}を参照してください)。

@example
@group
(null '(1))
     @result{} nil
@end group
@group
(null '())
     @result{} t
@end group
@end example
@end defun


@node List Elements
@section リスト要素へのアクセス
@cindex list elements

@defun car cons-cell
この関数は、コンスセル@var{cons-cell}の1番目のスロットにより参照される値をreturnします。他の言い方をすると、この関数は@var{cons-cell}の@sc{car}をreturnします。

特別なケースとして、@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をreturnします。したがって、リストはすべて引数として有効です。引数がコンスセルでも@code{nil}でもない場合、エラーがシグナルされます。

@example
@group
(car '(a b c))
     @result{} a
@end group
@group
(car '())
     @result{} nil
@end group
@end example
@end defun

@defun cdr cons-cell
この関数は、コンスセル@var{cons-cell}の2番目のスロットにより参照される値をreturnします。他の言い方をすると、この関数は@var{cons-cell}の@sc{cdr}をreturnします。

特別なケースとして、@var{cons-cell}が@code{nil}の場合、この関数は@code{nil}をreturnします。したがって、リストはすべて引数として有効です。引数がコンスセルでも@code{nil}でもない場合、エラーがシグナルされます。

@example
@group
(cdr '(a b c))
     @result{} (b c)
@end group
@group
(cdr '())
     @result{} nil
@end group
@end example
@end defun

@defun car-safe object
この関数により、他のデータ型によるエラーを起こさずに、コンスセルの@sc{car}を取得できます。この関数は、@var{object}がコンスセルの場合は@var{object}の@sc{car}、それ以外は@code{nil}をreturnします。この関数は、@var{object}がリスとでないときはエラーをシグナルする@code{car}とは対象的です。

@example
@group
(car-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (car x)
    nil))
@end group
@end example
@end defun

@defun cdr-safe object
この関数により、他のデータ型によるエラーを起こさずに、コンスセルの@sc{cdr}を取得できます。この関数は、@var{object}がコンスセルの場合は@var{object}の@sc{cdr}、それ以外は@code{nil}をreturnします。この関数は、@var{object}がリスとでないときはエラーをシグナルする@code{cdr}とは対象的です。

@example
@group
(cdr-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (cdr x)
    nil))
@end group
@end example
@end defun

@defmac pop listname
このマクロはリストの@sc{car}を調べて、それをリストから取り去るのを1度に行なう便利な方法を提供します。この関数は@var{listname}に格納されたリストにたいして処理を行ないます。この関数はリストから1番目の要素を削除して、@sc{cdr}を@var{listname}に保存し、その後で削除した要素をreturnします。

1番単純なケースは、リストに名前をつけるためのクォートされていないシンボルの場合です。この場合、このマクロは@w{@code{(prog1 (car
listname) (setq listname (cdr listname)))}}と等価です。

@example
x
     @result{} (a b c)
(pop x)
     @result{} a
x
     @result{} (b c)
@end example

より一般的なのは、@var{listname}が汎変数(generalized
variable)の場合です。この場合、このマクロは@code{setf}を使用して@var{listname}に保存します。@ref{Generalized
Variables}を参照してください。

リストに要素を追加する@code{push}マクロについては、@ref{List Variables}を参照してください。
@end defmac

@defun nth n list
@anchor{Definition of nth}
この関数は、@var{list}の@var{n}番目の要素をreturnします。要素は0から数えられるので、@var{list}の@sc{car}は要素0になります。@var{list}の長さが@var{n}以下の場合、値は@code{nil}です。

@c Behavior for -ve n undefined since 2013/08; see bug#15059.
@ignore
If @var{n} is negative, @code{nth} returns the first element of @var{list}.
@end ignore

@example
@group
(nth 2 '(1 2 3 4))
     @result{} 3
@end group
@group
(nth 10 '(1 2 3 4))
     @result{} nil

(nth n x) @equiv{} (car (nthcdr n x))
@end group
@end example

関数@code{elt}は似ていますが、これは任意の種類のシーケンスに適用されます。歴史的な理由により、この関数は逆の順序で引数を受け取ります。@ref{Sequence
Functions}を参照してください。
@end defun

@defun nthcdr n list
この関数は、@var{list}の@var{n}番目の@sc{cdr}をreturnします。他の言い方をすると、この関数は@var{list}の最初の@var{n}個のリンクをスキップしてから、それ以降をreturnします。

@c "or negative" removed 2013/08; see bug#15059.
@var{n}が0の場合、@code{nthcdr}は@var{list}全体をreturnします。@var{list}の長さが@var{n}以下の場合、@code{nthcdr}は@code{nil}をreturnします。

@example
@group
(nthcdr 1 '(1 2 3 4))
     @result{} (2 3 4)
@end group
@group
(nthcdr 10 '(1 2 3 4))
     @result{} nil
@end group
@group
(nthcdr 0 '(1 2 3 4))
     @result{} (1 2 3 4)
@end group
@end example
@end defun

@defun last list &optional n
この関数は、@var{list}の最後のリンクをreturnします。このリンクの@code{car}は、このリストの最後の要素です。@var{list}がnullの場合、@code{nil}がreturnされます。@var{n}が非@code{nil}の場合、@var{n}番目から最後までのリンクがreturnされます。@var{n}が@var{list}の長さより大きい場合は、@var{list}全体がreturnされます。
@end defun

@defun safe-length list
@anchor{Definition of safe-length}
この関数は、エラーや無限ループの危険なしで、@var{list}の長さをreturnします。この関数は一般的に、リスト内のコンスセルの個数をreturnします。しかし循環リストでは、単に上限値が値となるため、非常に大きくなる場合があります。

@var{list}が@code{nil}でもコンスセルでもない場合、@code{safe-length}は0をreturnします。
@end defun

  循環リストを考慮しなくてもよい場合に、リストの長さを計算するもっとも一般的な方法は、@code{length}を使うことです。@ref{Sequence
Functions}を参照してください。

@defun caar cons-cell
これは、@code{(car (car @var{cons-cell}))}と同じです。
@end defun

@defun cadr cons-cell
これは、@code{(car (cdr @var{cons-cell}))}または@code{(nth 1
@var{cons-cell})}と同じです。
@end defun

@defun cdar cons-cell
これは、@code{(cdr (car @var{cons-cell}))}と同じです。
@end defun

@defun cddr cons-cell
これは、@code{(cdr (cdr @var{cons-cell}))}または@code{(nthcdr 2
@var{cons-cell})}と同じです。
@end defun

@defun butlast x &optional n
この関数は、リスト@var{x}から、最後の要素、または最後の@var{n}個の要素を削除してreturnします。@var{n}が0より大きい場合、この関数はリストのコピーを作成するので、元のリストに影響はありません。一般的に、@code{(append
(butlast @var{x} @var{n})  (last @var{x}
@var{n}))}は、@var{x}と等しいリストをreturnします。
@end defun

@defun nbutlast x &optional n
この関数は、リストのコピーを作成するのではなく、@code{cdr}を適切な要素に変更することにより破壊的に機能するバージョンの@code{butlast}です。
@end defun

@node Building Lists
@section コンスセルおよびリストの構築
@cindex cons cells
@cindex building lists

  リストはLispの核にあるので、リストを構築する多くの関数があります。@code{cons}はリストを構築する基本的な関数です。しかしEmacsのソースコードでは、@code{cons}より@code{list}のほうが多く使用されているのは興味深いことです。

@defun cons object1 object2
この関数は、新しいリスト構造を構築するための、もっとも基本的な関数です。この関数は、@var{object1}を@sc{car}、@var{object2}を@sc{cdr}とする、新しいコンスセルを作成して、それから新しいコンスセルをreturnします。引数@var{object1}と@var{object2}は、任意のLispオブジェクトを指定できますが、ほとんどの場合、@var{object2}はリストです。

@example
@group
(cons 1 '(2))
     @result{} (1 2)
@end group
@group
(cons 1 '())
     @result{} (1)
@end group
@group
(cons 1 2)
     @result{} (1 . 2)
@end group
@end example

@cindex consing
リストの先頭に1つの要素を追加するために、@code{cons}がよく使用されます。これは、@dfn{リストに要素をコンスする}と言います。@footnote{リストの最後に要素を追加するための、これと完全に同等な方法はありません。@var{listname}をコピーすることにより、新しいリストを作成してから、@var{newelt}をそのリストの最後に追加する、@code{(append
@var{listname} (list
@var{newelt}))}を使用することができます。すべての@sc{cdr}を辿って、終端の@code{nil}を置き換える、@code{(nconc
@var{listname} (list
@var{newelt}))}を使用することもできます。コピーも変更も行なわずに、リストの先頭に要素を追加する@code{cons}と比較してみてください。}たとえば:

@example
(setq list (cons newelt list))
@end example

この例で使用されている@code{list}という名前の変数と、以下で説明する@code{list}という名前の関数は、競合しないことに注意してください。任意のシンボルは、両方の役割を果たすことができます。
@end defun

@defun list &rest objects
この関数は、@var{objects}を要素とするリストを作成します。結果となるリストは、常に@code{nil}終端されます。@var{objects}を指定しない場合、空リストがreturnされます。

@example
@group
(list 1 2 3 4 5)
     @result{} (1 2 3 4 5)
@end group
@group
(list 1 2 '(3 4 5) 'foo)
     @result{} (1 2 (3 4 5) foo)
@end group
@group
(list)
     @result{} nil
@end group
@end example
@end defun

@defun make-list length object
この関数は、各要素が@var{object}の、@var{length}個の要素からなるリストを作成します。@code{make-list}と@code{make-string}(@ref{Creating
Strings}を参照してください)を比較してみてください。

@example
@group
(make-list 3 'pigs)
     @result{} (pigs pigs pigs)
@end group
@group
(make-list 0 'pigs)
     @result{} nil
@end group
@group
(setq l (make-list 3 '(a b)))
     @result{} ((a b) (a b) (a b))
(eq (car l) (cadr l))
     @result{} t
@end group
@end example
@end defun

@defun append &rest sequences
@cindex copying lists
この関数は、@var{sequences}のすべての要素を服務リストをreturnします。@var{sequences}には、リスト、ベクター、ブールベクター、文字列も指定できますが、通常は最後にリストを指定するべきです。最後の引数を除くすべての引数はコピーされるので、変更される引数はありません(コピーを行なわずにリストを結合する方法については、@ref{Rearrangement}の@code{nconc}を参照してください)。

より一般的には、@code{append}にたいする最後の引数は、任意のLispオブジェクトかもしれません。最後の引数は、コピーまたは変換されません。最後の引数は、新しいリストの最後のコンスセルの@sc{cdr}になります。最後の引数もリストならば、このリストの要素は、実質的には結果リストの要素になります。最後の要素がリストでない場合、最後の@sc{cdr}が(真リストで要求される)@code{nil}ではないので、結果はドットリストになります。
@end defun

  以下は@code{append}を使用した例です:

@example
@group
(setq trees '(pine oak))
     @result{} (pine oak)
(setq more-trees (append '(maple birch) trees))
     @result{} (maple birch pine oak)
@end group

@group
trees
     @result{} (pine oak)
more-trees
     @result{} (maple birch pine oak)
@end group
@group
(eq trees (cdr (cdr more-trees)))
     @result{} t
@end group
@end example

  @code{append}がどのように機能するか、ボックスダイアグラムで見ることができます。変数@code{trees}はリスト@code{(pine
oak)}にセットされ、それから変数@code{more-trees}にリスト@code{(maple birch pine
oak)}がセットされます。しかし変数@code{trees}は継続して元のリストを参照します:

@smallexample
@group
more-trees                trees
|                           |
|     --- ---      --- ---   -> --- ---      --- ---
 --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
      --- ---      --- ---      --- ---      --- ---
       |            |            |            |
       |            |            |            |
        --> maple    -->birch     --> pine     --> oak
@end group
@end smallexample

  空のシーケンスは、@code{append}によりreturnされる値に寄与しません。この結果、最後の引数に@code{nil}を指定すると、それより前の引数のコピーを強制することになります。

@example
@group
trees
     @result{} (pine oak)
@end group
@group
(setq wood (append trees nil))
     @result{} (pine oak)
@end group
@group
wood
     @result{} (pine oak)
@end group
@group
(eq wood trees)
     @result{} nil
@end group
@end example

@noindent
これは関数@code{copy-sequence}が導入される以前は、リストをコピーする通常の方法でした。@ref{Sequences Arrays
Vectors}を参照してください。

  以下は、@code{append}の引数としてベクターと文字列を使用する例です:

@example
@group
(append [a b] "cd" nil)
     @result{} (a b 99 100)
@end group
@end example

  @code{apply} (@ref{Calling
Functions}を参照してください)の助けを借りることにより、リストのリストの中の、すべてのリストをappendできます。

@example
@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

  @var{sequences}が与えられない場合、@code{nil}がreturnされます:

@example
@group
(append)
     @result{} nil
@end group
@end example

  以下は、最後の引数がリストでない場合の例です:

@example
(append '(x y) 'z)
     @result{} (x y . z)
(append '(x y) [z])
     @result{} (x y . [z])
@end example

@noindent
2番目の例は、最後の引数はシーケンスですがリスとではない場合で、このシーケンスの要素は、結果リストの要素にはなりません。かわりに、最後の引数がリストでないときと同様、シーケンスが最後の@sc{cdr}になります。

@defun reverse list
この関数は、要素は@var{list}の要素ですが、順序が逆の新しいリストを作成します。元の引数@var{list}は、変更@emph{されません}。

@example
@group
(setq x '(1 2 3 4))
     @result{} (1 2 3 4)
@end group
@group
(reverse x)
     @result{} (4 3 2 1)
x
     @result{} (1 2 3 4)
@end group
@end example
@end defun

@defun copy-tree tree &optional vecp
この関数はツリー@code{tree}のコピーをreturnします。@var{tree}がコンスセルの場合、同じ@sc{car}と@sc{cdr}をもつ新しいコンスセルを作成してから、同じ方法により@sc{car}と@sc{cdr}を再帰的にコピーします。

通常、@var{tree}がコンスセル以外の場合、@code{copy-tree}は単に@var{tree}をreturnします。しかし、@var{vecp}が非@code{nil}の場合、この関数はベクターでもコピーします(そしてベクターの要素を再帰的に処理します)。
@end defun

@defun number-sequence from &optional to separation
これは、@var{from}から@var{separation}づつインクリメントして、@var{to}の直前で終わる、数字のリストをreturnします。@var{separation}には正または負の数を指定でき、デフォルトは1です。@var{to}が@code{nil}、または数的に@var{from}と等しい場合、値は1要素のリスト@code{(@var{from})}になります。@var{separation}が正で@var{to}が@var{from}より小さい場合、または@var{separation}が負で@var{to}が@var{from}より大きい場合、これらの引数は空のシーケンスを指示することになるので、値は@code{nil}になります。

@var{separation}が0で、@var{to}が@code{nil}でもなく、数的に@var{from}とも等しくない場合、これらの引数は無限シーケンスを指示することになるので、エラーがシグナルされます。

引数はすべて数字です。浮動少数の計算は正確ではないので、浮動少数の引数には用心する必要があります。たとえばマシンに依存して、@code{(number-sequence
0.4 0.8 0.2)}が3要素のリストをreturnするのに、@code{(number-sequence 0.4 0.6
0.2)}が1要素のリスト@code{(0.4)}をreturnすることがよく起こります。リストの@var{n}番目の要素は、厳密に@code{(+
@var{from} (* @var{n}
@var{separation}))}という式により計算されます。したがって、リストに確実に@var{to}が含まれるようにするには、この式に適切な型の@var{to}を渡すことができます。別の方法として、@var{to}を少しだけ大きな値(@var{separation}が負の場合は、少しだけ小さな値)に置き換えることもできます。

いくつか例を示します:

@example
(number-sequence 4 9)
     @result{} (4 5 6 7 8 9)
(number-sequence 9 4 -1)
     @result{} (9 8 7 6 5 4)
(number-sequence 9 4 -2)
     @result{} (9 7 5)
(number-sequence 8)
     @result{} (8)
(number-sequence 8 5)
     @result{} nil
(number-sequence 5 8 -1)
     @result{} nil
(number-sequence 1.5 6 2)
     @result{} (1.5 3.5 5.5)
@end example
@end defun

@node List Variables
@section リスト変数の変更
@cindex modify a list
@cindex list modification

  これらの関数、および1つのマクロは、変数に格納されたリストを変更する便利な方法を提供します。

@defmac push element listname
このマクロは、@sc{car}が@var{element}で、@sc{cdr}が@var{listname}で指定されたリストであるような新しいリストを作成して、そのリストを@var{listname}に保存します。単純なのは、@var{listname}はリストに名前をつけるクォートされていないシンボルのときで、この場合マクロは@w{@code{(setq
@var{listname} (cons @var{element} @var{listname}))}}と等価です。

@example
(setq l '(a b))
     @result{} (a b)
(push 'c l)
     @result{} (c a b)
l
     @result{} (c a b)
@end example

より一般的なのは、@code{listname}が汎変数の場合です。この場合、このマクロは@w{@code{(setf @var{listname}
(cons @var{element} @var{listname}))}}と等価です。@ref{Generalized
Variables}を参照してください。

リストから1番目の要素を取り出す@code{pop}マクロについては、@ref{List Elements}を参照してください。
@end defmac

  以下の2つの関数は、変数の値であるリストを変更します。

@defun add-to-list symbol element &optional append compare-fn
この関数は、@var{element}が@var{symbol}の値のメンバーでない場合は、@var{symbol}に@var{element}をコンスすることにより、変数@var{symbol}をセットします。この関数は、リストが更新されているかに関わらず、結果のリストをreturnします@var{symbol}の値は、呼び出し前にすでにリストであることが望ましいです。@var{element}がリストの既存メンバーか比較するために、@code{add-to-list}は@var{compare-fn}を使用します。@var{compare-fn}が@code{nil}の場合は、@code{equal}を使用します。

@var{element}が追加される場合は通常、@var{symbol}の前に追加されますが、オプションの引数@var{append}が非@code{nil}の場合は、最後に追加されます。

引数@var{symbol}は、暗黙にクォートされません。@code{setq}とは異なり、@code{add-to-list}は@code{set}のような通常の関数です。クォートしたい場合は自分で引数をクォートします。
@end defun

以下は@code{add-to-list}を使用する方法をシナリオで示します:

@example
(setq foo '(a b))
     @result{} (a b)

(add-to-list 'foo 'c)     ;; @r{@code{c}を追加。}
     @result{} (c a b)

(add-to-list 'foo 'b)     ;; @r{効果なし。}
     @result{} (c a b)

foo                       ;; @r{@code{foo}が変更された。}
     @result{} (c a b)
@end example

  以下は@code{(add-to-list '@var{var} @var{value})}と等価な式です:

@example
(or (member @var{value} @var{var})
    (setq @var{var} (cons @var{value} @var{var})))
@end example

@defun add-to-ordered-list symbol element &optional order
この関数は、古い値(リストでなければなりません)の@var{order}で指定された位置に、@var{element}を挿入することにより、変数@var{symbol}をセットします。@var{element}がすでにこのリストのメンバーである場合、リスト内の要素の位置は@var{order}にしたがって調整されます。メンバーかどうかは、@code{eq}を使用してテストされます。この関数は、更新されているかどうかに関わらず、結果のリストをreturnします。

@var{order}は通常、数字(正数か浮動小数)で、リストの要素は、その数字の昇順で並べられます。

@var{order}を省略または@code{nil}にすることもできます。これにより、リストに@var{element}がすでに存在する場合、@var{element}の数字順序は変更されません。それ以外では、@var{element}は数字順序をもちません。リストの数字順序をもたない要素は、リストの最後に配され、特別な順序はつきません。

@var{order}に他の値を指定した場合、@var{element}がすでに数字順序をもつときは数字順序が削除されます。それ以外は、@code{nil}と同じです。

引数@var{symbol}は、暗黙にクォートされません。@code{add-to-ordered-list}は、@code{setq}などとは異なり、@code{set}のような通常の関数です。必要な場合は引数を自分でクォートしてください。

順序の情報は、@var{symbol}の@code{list-order}プロパティーのハッシュテーブルに保存されます。
@end defun

以下に@code{add-to-ordered-list}を使用する方法をシナリオで示します:

@example
(setq foo '())
     @result{} nil

(add-to-ordered-list 'foo 'a 1)     ;; @r{@code{a}を追加。}
     @result{} (a)

(add-to-ordered-list 'foo 'c 3)     ;; @r{@code{c}を追加。}
     @result{} (a c)

(add-to-ordered-list 'foo 'b 2)     ;; @r{@code{b}を追加。}
     @result{} (a b c)

(add-to-ordered-list 'foo 'b 4)     ;; @r{@code{b}を移動。}
     @result{} (a c b)

(add-to-ordered-list 'foo 'd)       ;; @r{@code{d}を後に追加。}
     @result{} (a c b d)

(add-to-ordered-list 'foo 'e)       ;; @r{@code{e}を追加。}
     @result{} (a c b e d)

foo                       ;; @r{@code{foo}が変更された。}
     @result{} (a c b e d)
@end example

@node Modifying Lists
@section 既存のリスト構造の変更
@cindex destructive list operations

  基本関数@code{setcar}および@code{setcdr}により、コンスセルの@sc{car}および@sc{cdr}の内容を変更できます。わたしたちは、これらが既存のリスト構造を変更することから、これらを``破壊的''処理と呼びます。

@cindex CL note---@code{rplaca} vs @code{setcar}
@quotation
@findex rplaca
@findex rplacd
@b{Common Lispに関する注意: }Common
Lispはリスト構造の変更に@code{rplaca}および@code{rplacd}を使用します。これらは@code{setcar}や@code{setcdr}と同じ方法でリスト構造を変更しますが、@code{setcar}と@code{setcdr}は新しい@sc{car}または@sc{cdr}をreturnするのにたいし、Common
Lispの関数はコンスセルをreturnします。
@end quotation

@menu
* Setcar::                   リスト内の要素の置き換え。
* Setcdr::                   リストの根幹部分の置き換え。これは要素の追加や削除に使用される。
* Rearrangement::            リスト内の要素の再配置、リストの合成。
@end menu

@node Setcar
@subsection @code{setcar}によるリスト要素の変更
@cindex replace list element
@cindex list, replace element

  コンスセルの@sc{car}の変更は、@code{setcar}により行なわれます。リストにたいして使用された場合、@code{setcar}はリストの1つの要素を、他の要素に置き換えます。

@defun setcar cons object
この関数は、以前の@sc{car}を置き換えて、@var{cons}の新しい@sc{car}に@var{object}を格納します。他の言い方をすると、この関数は@var{cons}の@sc{car}スロットを、@var{object}を参照するように変更します。この関数は値@var{object}をreturnします。たとえば:

@example
@group
(setq x '(1 2))
     @result{} (1 2)
@end group
@group
(setcar x 4)
     @result{} 4
@end group
@group
x
     @result{} (4 2)
@end group
@end example
@end defun

  コンスセルが、複数のリストが共有された構造の一部の場合、コンスに新しい@sc{car}を格納することにより、これら共有されたリストの各1つの要素を変更します。以下は例です:

@example
@group
;; @r{部分的に共有された2つのリストを作成。}
(setq x1 '(a b c))
     @result{} (a b c)
(setq x2 (cons 'z (cdr x1)))
     @result{} (z b c)
@end group

@group
;; @r{共有されたリンクの@sc{car}を置き換え。}
(setcar (cdr x1) 'foo)
     @result{} foo
x1                           ; @r{両方のリストが変更された。}
     @result{} (a foo c)
x2
     @result{} (z foo c)
@end group

@group
;; @r{共有されていないリンクの@sc{car}を置き換え。}
(setcar x1 'baz)
     @result{} baz
x1                           ; @r{1つのリストだけが変更された。}
     @result{} (baz foo c)
x2
     @result{} (z foo c)
@end group
@end example

  なぜ@code{b}を置き換えると両方が変更されるのかを説明するために、変数@code{x1}と@code{x2}の2つのリストによる共有構造を視覚化してみましょう:

@example
@group
        --- ---        --- ---      --- ---
x1---> |   |   |----> |   |   |--> |   |   |--> nil
        --- ---        --- ---      --- ---
         |        -->   |            |
         |       |      |            |
          --> a  |       --> b        --> c
                 |
       --- ---   |
x2--> |   |   |--
       --- ---
        |
        |
         --> z
@end group
@end example

  同じ関係を別のボックス図で示すと、以下のようになります:

@example
@group
x1:
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   a   |   o------->|   b   |   o------->|   c   |  nil |
|       |      |  -->|       |      |     |       |      |
 --------------  |    --------------       --------------
                 |
x2:              |
 --------------  |
| car   | cdr  | |
|   z   |   o----
|       |      |
 --------------
@end group
@end example

@node Setcdr
@subsection リストのCDRの変更
@cindex replace part of list

  @sc{cdr}を変更するもっとも低レベルの基本関数は、@code{setcdr}です:

@defun setcdr cons object
この関数は前の@sc{cdr}を置き換えて、@var{cons}の新しい@sc{cdr}に@var{object}を格納します。他の言い方をすると、この関数は@var{cons}の@sc{cdr}を、@var{object}を参照するように変更します。この関数は値@var{object}をreturnします。
@end defun

  以下はリストの@sc{cdr}を、他のリストに置き換える例です。1番目の要素以外のすべての要素は、別のシーケンスまたは要素のために取り除かれます。1番目の要素はリストの@sc{car}なので変更されず、@sc{cdr}を通じて到達することもできないからです。

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(setcdr x '(4))
     @result{} (4)
@end group
@group
x
     @result{} (1 4)
@end group
@end example

  リスト内のコンスセルの@sc{cdr}を変更することにより、リストの途中から要素を削除できます。たとえば以下では、1番目のコンスセルの@sc{cdr}を変更することにより、2番目の要素@code{b}を、リスト@code{(a
b c)}から削除します。

@example
@group
(setq x1 '(a b c))
     @result{} (a b c)
(setcdr x1 (cdr (cdr x1)))
     @result{} (c)
x1
     @result{} (a c)
@end group
@end example

  以下に結果をボックス表記で示します:

@smallexample
@group
                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
|   a   |   o-----   |   b   |   o-------->|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------
@end group
@end smallexample

@noindent
以前は要素@code{b}を保持していた2番目のコンスセルは、依然として存在して、その@sc{car}も@code{b}のままですが、すでにこのリストの一部を形成していません。

  @sc{cdr}を変更して、新しい要素を挿入するのも、同じくらい簡単です:

@example
@group
(setq x1 '(a b c))
     @result{} (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     @result{} (d b c)
x1
     @result{} (a d b c)
@end group
@end example

  以下に結果をボックス表記で示します:

@smallexample
@group
 --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     -->|   d   |   o------
        |       |       |
         ---------------
@end group
@end smallexample

@node Rearrangement
@subsection リストを再配置する関数
@cindex rearrangement of lists
@cindex reordering, of elements in lists
@cindex modification of lists

  以下では、リストの構成要素であるコンスセルの@sc{cdr}を変更することにより、リストを``破壊的''に再配置する関数をいくつか示します。これらの関数が``破壊的''だという理由は、これらの関数が引数として渡された元のリストを処理して、return値となる新しいリストを形成するために、リストのコンスセルを再リンクするからです。

@ifnottex
  コンスセルを変更する他の関数については、@ref{Sets And Lists}の@code{delq}を参照してください。
@end ifnottex
@iftex
   以降のセクションで説明する関数@code{delq}は、破壊的にリストを操作する、別の例です。
@end iftex

@defun nconc &rest lists
@cindex concatenating lists
@cindex joining lists
この関数は、@var{lists}の要素すべてを含むリストをreturnします。@code{append} (@ref{Building
Lists}を参照してください)とは異なり、@var{lists}はコピー@emph{されません}。かわりに@var{lists}の各リストの最後の@sc{cdr}が、次のリストを参照するように変更されます。@var{lists}の最後のリストは、変更されません。たとえば:

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x '(4 5))
     @result{} (1 2 3 4 5)
@end group
@group
x
     @result{} (1 2 3 4 5)
@end group
@end example

   @code{nconc}の最後の引数は変更されないので、上記の例のように、@code{'(4
5)}のような定数リストを使用するのが理に適っています。また、同じ理由により、最後の引数がリスとである必要はありません。

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x 'z)
     @result{} (1 2 3 . z)
@end group
@group
x
     @result{} (1 2 3 . z)
@end group
@end example

しかし、(最後を除くすべての)他の引数はリストでなければなりません。

一般的な落とし穴としては、@code{nconc}にたいしてクォートされたリスト定数を、最後以外の引数として使用したときです。これを行なう場合、実行するごとにプログラムはリスト定数を変更するでしょう!
何が起こるのかを以下に示します:

@smallexample
@group
(defun add-foo (x)            ; @r{この関数では@code{foo}}
  (nconc '(foo) x))           ;   @r{を引数の前に追加させたい。}
@end group

@group
(symbol-function 'add-foo)
     @result{} (lambda (x) (nconc (quote (foo)) x))
@end group

@group
(setq xx (add-foo '(1 2)))    ; @r{動いているように見える。}
     @result{} (foo 1 2)
@end group
@group
(setq xy (add-foo '(3 4)))    ; @r{何が起きているのか?}
     @result{} (foo 1 2 3 4)
@end group
@group
(eq xx xy)
     @result{} t
@end group

@group
(symbol-function 'add-foo)
     @result{} (lambda (x) (nconc (quote (foo 1 2 3 4) x)))
@end group
@end smallexample
@end defun

@defun nreverse list
@cindex reversing a list
  この関数は、@var{list}の要素の順番を逆転します。@code{reverse}とは異なり、@code{nreverse}はリストを形成する@sc{cdr}内のコンスセルを逆転することにより、引数を変更します。@var{list}の最後に使用されているコンスセルは、最初のコンスセルになります。

  たとえば:

@example
@group
(setq x '(a b c))
     @result{} (a b c)
@end group
@group
x
     @result{} (a b c)
(nreverse x)
     @result{} (c b a)
@end group
@group
;; @r{最初のコンスセルが最後になった。}
x
     @result{} (a)
@end group
@end example

  わたしたちは通常、混乱を避けるために、@code{nreverse}の結果を、元のリストを保持していたのと同じ変数に格納します:

@example
(setq x (nreverse x))
@end example

  以下は、@code{(a b c)}を視覚的に表した、@code{nreverse}の例です:

@smallexample
@group
@r{元のリストの先頭:}                         @r{逆転されたリスト:}
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
@end group
@end smallexample
@end defun

@defun sort list predicate
@cindex stable sort
@cindex sorting lists
この関数は、@var{list}を安定的(しかし破壊的)にソートして、ソートされたリストをreturnします。この関数は@var{predicate}を使用して要素を比較します。安定ソート(stable
sort)では、同じソートキーをもつ要素が、ソートの前後で相対的に同じ順序が維持されます。安定性は、異なる条件によりソートするために要素を並び替えるために、連続したソートが使用されるときに重要です。

引数@var{predicate}は、2つの引数をとる関数でなければなりません。この関数は@var{list}の2つの要素を引数として呼び出されます。昇順のソートを得るための@var{predicate}は、1番目の引数が、2番目の引数より``小さい''ときは非@code{nil}、それ以外は@code{nil}をreturnするようにします。

比較関数@var{predicate}は、少なくとも単独の@code{sort}呼び出しにおいて、任意の与えられた引数にたいして信頼できる結果を与えなければありません。比較関数は@dfn{非対称的(antisymmetric)}
--- つまり@var{a}が@var{b}より小さいとき、@var{b}は@var{a}より小さくない ---
でなければなりません。比較関数は@dfn{推移的(transitive)} ---
つまり@var{a}が@var{b}より小さく、@var{b}が@var{c}より小さい場合、@var{c}は@var{a}より小さい ---
でなければなりません。これらの要求を満たさない比較関数を使用した場合、@code{sort}の結果は予測できません。

@code{sort}の破壊的な側面は、@sc{cdr}を変更することにより、@var{list}を形成するコンスセルを再配置することです。非破壊的なソート関数の場合は、ソートされた要素を格納するために、あたらしいコンスセルを作成します。元のリストを破壊せずにソートされたコピーを作成したい場合は、@code{copy-sequence}で最初にコピーしてから、それをソートします。

ソートは@var{list}内のコンスセルの@sc{car}は変更しません。@var{list}内で@sc{car}に要素@code{a}を保持していたコンスセル、ソート後にも@code{a}を保持しますが、@sc{cdr}は変更されるので、ソート後の位置は異なります。たとえば:

@example
@group
(setq nums '(1 3 2 6 5 4 0))
     @result{} (1 3 2 6 5 4 0)
@end group
@group
(sort nums '<)
     @result{} (0 1 2 3 4 5 6)
@end group
@group
nums
     @result{} (1 2 3 4 5 6)
@end group
@end example

@noindent
@strong{警告}:
@code{nums}のリストには0が含まれていないことに注意してください。これは前と同じコンスセルですが、リストの1番目ではなくなります。引数を保持するように形成された変数が、ソートされたリストでも保持されると仮定しないでください!
かわりに@code{sort}の結果を保存して、それを使用してください。元のリストを保持していた変数に、結果を書き戻すことはよく行なわれます。

@example
(setq nums (sort nums '<))
@end example

ソート処理を行なう他の関数については、@ref{Sorting}を参照してください。@code{sort}の有用な例は、@ref{Accessing
Documentation}の@code{documentation}を参照してください。
@end defun

@node Sets And Lists
@section 集合としてのリストの使用
@cindex lists as sets
@cindex sets

  リストは順序なしの数学的集合 --- リスト内に要素があれば集合の要素の値とされ、リスト内の順序は無視される ---
を表すことができます。2つの集合を結合(union)するには、(重複する要素を気にしない場合は)@code{append}を使用します。@code{equal}である重複を取り除くには、@code{delete-dups}を使用します。集合にたいする他の有用な関数には、@code{memq}や@code{delq}、およびこれらの@code{equal}バージョンである@code{member}と@code{delete}が含まれます。

@cindex CL note---lack @code{union}, @code{intersection}
@quotation
@b{Common Lispに関する注意:} 集合を処理するために、Common
Lispには(要素の重複がない)関数@code{union}があります。これらの関数は標準のGNU Emacs
Lispにはありませんが、@file{cl-lib}はこれらを提供します。@ref{Lists as Sets,,, cl, Common Lisp
Extensions}を参照してください。
@end quotation

@defun memq object list
@cindex membership in a list
この関数は、@var{object}が@var{list}のメンバーかどうかをテストします。メンバーの場合、@code{memq}は@var{object}で最初に見つかった要素から開始されるリストをreturnします。メンバーでない場合は、@code{nil}をreturnします。@code{memq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に、@code{eq}を使用することを示します。たとえば:

@example
@group
(memq 'b '(a b c b a))
     @result{} (b c b a)
@end group
@group
(memq '(2) '((1) (2)))    ; @r{@code{(2)}と@code{(2)}は@code{eq}ではない。}
     @result{} nil
@end group
@end example
@end defun

@defun delq object list
@cindex deleting list elements
この関数@var{list}からは@var{object}と@code{eq}なすべての要素を破壊的に取り除いて、結果のリストをreturnします。@code{delq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に、@code{eq}を使用することを示します(@code{memq}や@code{remq}と同様)。

@code{delq}を呼び出すときは通常、元のリストを保持していた変数にreturn値を割り当てて使用する必要があります(理由は以下参照)。
@end defun

@code{delq}関数がリストの銭湯にある要素を削除する場合は、単にリストを読み進めて、この要素の後から開始される部分リストをreturnします。つまり:

@example
@group
(delq 'a '(a b c)) @equiv{} (cdr '(a b c))
@end group
@end example

@noindent
リストの途中にある要素を削除するときは、必要な@sc{cdr}(@ref{Setcdr}を参照してください)を変更することにより削除します。

@example
@group
(setq sample-list '(a b c (4)))
     @result{} (a b c (4))
@end group
@group
(delq 'a sample-list)
     @result{} (b c (4))
@end group
@group
sample-list
     @result{} (a b c (4))
@end group
@group
(delq 'c sample-list)
     @result{} (a b (4))
@end group
@group
sample-list
     @result{} (a b (4))
@end group
@end example

@code{(delq 'a sample-list)}は何も取り除きませんが(これは単に短いリストをreturnします)、@code{(delq 'c
sample-list)}は3番目の要素を取り除いて、@code{sample-list}を変更することに注意してください。引数@var{list}を保持するように形成された変数が、実行後にもっと少ない要素になる、または元のリストを保持すると仮定しないでください!
かわりに@code{delq}の結果を保存して、それを使用してください。元のリストを保持していた変数に、結果を書き戻すことはよく行なわれます。

@example
(setq flowers (delq 'rose flowers))
@end example

以下の例では、@code{delq}が比較しようとしている@code{(4)}と、@code{sample-list}内の@code{(4)}は、@code{eq}ではありません:

@example
@group
(delq '(4) sample-list)
     @result{} (a c (4))
@end group
@end example

与えられた値と@code{equal}な要素を削除したい場合は、@code{delete}(以下参照)を使用してください。

@defun remq object list
この関数は、@var{object}と@code{eq}なすべての要素が除かれた、@var{list}のコピーをreturnします。@code{remq}の文字@samp{q}は、この関数が@var{object}とリスト内の要素の比較に、@code{eq}を使用することを示します。

@example
@group
(setq sample-list '(a b c a b c))
     @result{} (a b c a b c)
@end group
@group
(remq 'a sample-list)
     @result{} (b c b c)
@end group
@group
sample-list
     @result{} (a b c a b c)
@end group
@end example
@end defun

@defun memql object list
関数@code{memql}は、@code{eql}(浮動少数の要素は値で比較される)を使用してメンバーと@code{eql}を比較することにより、@var{object}が@var{list}のメンバーかどうかをテストします。@var{object}がメンバーの場合、@code{memql}は@var{list}内で最初に見つかった要素から開始されるリストをreturnします。それ以外は@code{nil}をreturnします。

これを@code{memq}と比較してみましょう:

@example
@group
(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2}と@code{1.2}は@code{eql}。}
     @result{} (1.2 1.3)
@end group
@group
(memq 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2}と@code{1.2}は@code{eq}ではない。}
     @result{} nil
@end group
@end example
@end defun

以下の3つの関数は@code{memq}、@code{delq}、@code{remq}と似ていますが、要素の比較に@code{eq}ではなく、@code{equal}を使用します。@ref{Equality
Predicates}を参照してください。

@defun member object list
関数@code{member}は、メンバーと@var{object}を@code{equal}を使用して比較して、@var{object}が@var{list}のメンバーかどうかをテストします。@var{object}がメンバーの場合、@code{member}は@var{list}で最初に見つかったところから開始されるリストをreturnします。それ以外は@code{nil}を参照してください。

これを@code{memq}と比較してみましょう:

@example
@group
(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are @code{equal}.}
     @result{} ((2))
@end group
@group
(memq '(2) '((1) (2)))    ; @r{@code{(2)}と@code{(2)}は@code{eq}ではない。}
     @result{} nil
@end group
@group
;; @r{同じ内容の2つの文字列は@code{equal}。}
(member "foo" '("foo" "bar"))
     @result{} ("foo" "bar")
@end group
@end example
@end defun

@defun delete object sequence
この関数は、@var{sequence}から@var{object}と@code{equal}な要素を取り除いて、結果のシーケンスをreturnします。

@var{sequence}がリストの場合、@code{delete}が@code{delq}に対応するように、@code{member}は@code{memq}に対応します。つまり、この関数は@code{member}と同様、要素と@var{object}の比較に@code{equal}を使用します。マッチする要素が見つかったら、@code{delq}が行なうように、その要素を取り除きます。@code{delq}と同様、通常は元のリストを保持していた変数にreturn値を割り当てて使用します。

@code{sequence}がベクターまたは文字列の場合、@code{delete}は@code{object}と@code{equal}なすべての要素を取り除いた、@code{sequence}のコピーをreturnします。

たとえば:

@example
@group
(setq l '((2) (1) (2)))
(delete '(2) l)
     @result{} ((1))
l
     @result{} ((2) (1))
;; @r{@code{l}の変更に信頼性を要するときは}
;; @r{@code{(setq l (delete '(2) l))}と記述する。}
@end group
@group
(setq l '((2) (1) (2)))
(delete '(1) l)
     @result{} ((2) (2))
l
     @result{} ((2) (2))
;; @r{このケースでは@code{l}のセットの有無に違いはない}
;; @r{しかし他のケースに倣ってセットするべき。}
@end group
@group
(delete '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@defun remove object sequence
この関数は、@code{delete}に対応する非破壊的な関数です。この関数は、@code{object}と@code{equal}な要素を取り除いた、@code{sequence}(リスト、ベクター、文字列)のコピーをreturnします。たとえば:

@example
@group
(remove '(2) '((2) (1) (2)))
     @result{} ((1))
@end group
@group
(remove '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@quotation
@b{Common Lispに関する注意:} GNU Emacs
Lispの関数@code{member}、@code{delete}、@code{remove}は、Common
Lispではなく、Maclispを継承しています。Common Lispでは、比較に@code{equal}を使用しません。
@end quotation

@defun member-ignore-case object list
この関数は、@code{member}と同様ですが、@var{object}が文字列で、大文字小文字とテキスト表現の違いを無視します。文字の大文字と小文字は等しいものとして扱われ、比較に先立ちユニバイト文字列はマルチバイト文字列に変換されます。
@end defun

@defun delete-dups list
この関数は、@var{list}からすべての@code{equal}な重複を、破壊的に取り除いて。、結果を@var{list}に保管して、それをreturnします。@var{list}内の要素に@code{equal}な要素がいくつかある場合、@code{delete-dups}は最初の要素を残します。
@end defun

  変数に格納されたリストに要素を追加したり、それを集合として使用する方法については、@ref{List
Variables}の関数@code{add-to-list}も参照してください。

@node Association Lists
@section 連想リスト
@cindex association list
@cindex alist

  @dfn{連想配列(association
list。短くはalist)}は、キーと値のマッピングを記録します。これは@dfn{連想(associations)}と呼ばれるコンスセルのリストです。各コンスセルにおいて、@sc{car}は@dfn{キー(key)}で、@sc{cdr}は@dfn{連想値(associated
value)}になります。@footnote{ここでの``キー(key)''の使い方は、用語``キーシーケンス(key
sequence)''とは関係ありません。キーはテーブルにあるアイテムを探すために使用される値という意味です。この場合、テーブルはalistでありalistはアイテムに関連付けられます。}

  以下はalistの例です。キー@code{pine}は、値@code{cones}に関連付けられます。キー@code{oak}は、@code{acorns}に関連付けられます。キー@code{maple}は、@code{seeds}に関連付けられます。

@example
@group
((pine . cones)
 (oak . acorns)
 (maple . seeds))
@end group
@end example

  alist内の値とキーには、任意のLispオブジェクトを指定できます。たとえば以下のalist0では、シンボル@code{a}は数字@code{1}に、文字列@code{"b"}は@emph{リスト}@code{(2
3)}(alist要素の@sc{cdr})に関連付けられます。

@example
((a . 1) ("b" 2 3))
@end example

  要素の@sc{cdr}の@sc{car}に連想値を格納するようにalistデザインするほうがよい場合があります。以下は、そのようなalistです。

@example
((rose red) (lily white) (buttercup yellow))
@end example

@noindent
この例では、@code{red}が@code{rose}に関連付けられる値だと考えます。この種のalistの利点は、@sc{cdr}の@sc{cdr}の中に、他の関連する情報
--- 他のアイテムのリストでさえ ---
を格納することができることです。不利な点は、与えられた値を含む要素を見つけるために@code{rassq}(以下参照)を使用できないことです。これらを検討することが重要でない場合には、任意の与えられたalistにたいして一貫している限り、選択は好みの問題といえます。

  上記で示したのと同じalistは、要素の@sc{cdr}に連想値をもつと考えることができます。この場合、@code{rose}に関連付けられる値は、リスト@code{(red)}になるでしょう。

  連想リストは、新しい連想を簡単にリストの先頭に追加できるので、スタックに保持したいような情報を記録するのによく使用されます。連想リストから与えられたキーにたいする連想を検索する場合、それが複数ある場合は、最初に見つかったものがreturnされます。

  Emacs
Lispでは、連想リストがコンスセルではない場合、それはエラーでは@emph{ありません}。alist検索関数は、単にそのような要素を無視します。多くの他のバージョンのLいspでは、このような場合はエラーをシグナルします。

  いくつかの観点において、プロパティーリストは連想リストと似ていることに注意してください。それぞれのキーが1度だけ出現するような場合、プロパティーリストは連想リストと同様に振る舞います。プロパティーリストと連想リストの比較については、@ref{Property
Lists}を参照してください。

@defun assoc key alist
この関数は、alist要素にたいして@var{key}を比較するのに@code{equal}を使用して、@var{alist}内から@var{key}をもつ最初の連想をreturnします。@sc{car}が@var{key}と@code{equal}の連想が@var{alist}にない場合、この関数は@code{nil}をreturnします。たとえば:

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
     @result{} ((pine . cones) (oak . acorns) (maple . seeds))
(assoc 'oak trees)
     @result{} (oak . acorns)
(cdr (assoc 'oak trees))
     @result{} acorns
(assoc 'birch trees)
     @result{} nil
@end smallexample

以下はキーと値がシンボルでない場合の例です:

@smallexample
(setq needles-per-cluster
      '((2 "Austrian Pine" "Red Pine")
        (3 "Pitch Pine")
        (5 "White Pine")))

(cdr (assoc 3 needles-per-cluster))
     @result{} ("Pitch Pine")
(cdr (assoc 2 needles-per-cluster))
     @result{} ("Austrian Pine" "Red Pine")
@end smallexample
@end defun

  関数@code{assoc-string}は@code{assoc}と似ていますが、文字列間の特定の違いを無視する点が異なります。@ref{Text
Comparison}を参照してください。

@defun rassoc value alist
この関数は、@var{alist}の中から、値@var{value}をもつ最初の連想をreturnします。@sc{cdr}が@var{value}と@code{equal}の連想が@var{alist}にない場合、この関数は@code{nil}をreturnします。

@code{rassoc}は@code{assoc}と似ていますが、@sc{car}ではなく、@var{alist}の連想の@sc{cdr}を比較します。この関数を、与えられた値に対応するキーを探す、``reverse
@code{assoc}''と考えることができます。
@end defun

@defun assq key alist
この関数は、@var{alist}から@var{key}をもつ最初の連想をreturnする点は@code{assoc}と同様ですが、比較に@code{equal}ではなく@code{eq}を使用します。@sc{car}が@var{key}と@code{eq}な連想が@var{alist}内に存在しない場合、@code{assq}は@code{nil}をreturnします。@code{eq}は@code{equal}より早く、ほとんどのalistはキーにシンボルを使用するので、この関数は@code{assoc}より多用されます。@ref{Equality
Predicates}を参照してください。

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
     @result{} ((pine . cones) (oak . acorns) (maple . seeds))
(assq 'pine trees)
     @result{} (pine . cones)
@end smallexample

反対に、キーがシンボルではないalistでは通常、@code{assq}は有用ではありません:

@smallexample
(setq leaves
      '(("simple leaves" . oak)
        ("compound leaves" . horsechestnut)))

(assq "simple leaves" leaves)
     @result{} nil
(assoc "simple leaves" leaves)
     @result{} ("simple leaves" . oak)
@end smallexample
@end defun

@defun rassq value alist
この関数は、@var{alist}内から値@var{value}をもつ最初の連想をreturnします。@var{alist}内に@sc{cdr}が@var{value}と@code{eq}な連想が存在しない場合は、@code{nil}をreturnします。

@code{rassq}は@code{assq}と似ていますが、@sc{car}ではなく、@var{alist}の各連想の@sc{cdr}を比較します。この関数を、与えられた値に対応するキーを探す、``reverse
@code{assq}''と考えることができます。

たとえば:

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

(rassq 'acorns trees)
     @result{} (oak . acorns)
(rassq 'spores trees)
     @result{} nil
@end smallexample

@code{rassq}は、要素の@sc{cdr}の@sc{car}に保管された値の検索はできません:

@smallexample
(setq colors '((rose red) (lily white) (buttercup yellow)))

(rassq 'white colors)
     @result{} nil
@end smallexample

この場合、連想@code{(lily
white)}の@sc{cdr}は@code{white}ではなく、リスト@code{(white)}です。これは連想をドットペア表記で記述すると明確になります:

@smallexample
(lily white) @equiv{} (lily . (white))
@end smallexample
@end defun

@defun assoc-default key alist &optional test default
この関数は、@var{key}にたいするマッチを@var{alist}から検索します。@var{alist}の各要素にたいして、この関数は、@var{key}と要素(アトムの場合)、または要素の@sc{car}(コンスの場合)を比較します。比較は@var{test}に2つの引数
--- 要素(または要素の@sc{car})と@var{key} ---
を与えて呼び出すことにより行なわれます。引数はこの順番で渡されるので、正規表現(@ref{Regexp
Search}を参照してください)を含むalistでは、@code{string-match}を使用することにより有益な結果を得ることができます。@var{test}が省略されているか@code{nil}の場合は、比較に@code{equal}が使用されます。

alistの要素がこの条件により@var{key}とマッチした場合、@code{assoc-default}はこの要素の値をreturnします。要素がコンスの場合、値は要素の@sc{cdr}です。それ以外の場合、return値は@var{default}です。

@var{key}にマッチする要素がalistに存在しない場合、@code{assoc-default}は@code{nil}をreturnします。
@end defun

@defun copy-alist alist
@cindex copying alists
この関数は、深さ2がレベルの@var{alist}のコピーをreturnします。この関数は各連想の新しいコピーを作成するので、元のalistを変更せずに、新しいalistを変更できます。

@smallexample
@group
(setq needles-per-cluster
      '((2 . ("Austrian Pine" "Red Pine"))
        (3 . ("Pitch Pine"))
@end group
        (5 . ("White Pine"))))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(setq copy (copy-alist needles-per-cluster))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(eq needles-per-cluster copy)
     @result{} nil
(equal needles-per-cluster copy)
     @result{} t
(eq (car needles-per-cluster) (car copy))
     @result{} nil
(cdr (car (cdr needles-per-cluster)))
     @result{} ("Pitch Pine")
@group
(eq (cdr (car (cdr needles-per-cluster)))
    (cdr (car (cdr copy))))
     @result{} t
@end group
@end smallexample

  以下の例は、どのようにして@code{copy-alist}が他に影響を与えずにコピーの連想を変更可能なのかを示します:

@smallexample
@group
(setcdr (assq 3 copy) '("Martian Vacuum Pine"))
(cdr (assq 3 needles-per-cluster))
     @result{} ("Pitch Pine")
@end group
@end smallexample
@end defun

@defun assq-delete-all key alist
この関数は、@var{alist}から、(@code{delq}を使用した場合は、そのような要素を1つずつ削除するのにたいして)@sc{car}が@var{key}と@code{eq}な要素すべてを削除します。この関数は短くなったalistをreturnし、@var{alist}の元のリスト構造を変更することもよくあります。正しい結果を得るために、@var{alist}に保存された値ではなく、@code{assq-delete-all}のreturn値を使用してください。

@example
(setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))
(assq-delete-all 'foo alist)
     @result{} ((bar 2) (lose 4))
alist
     @result{} ((foo 1) (bar 2) (lose 4))
@end example
@end defun

@defun rassq-delete-all value alist
この関数は、@var{alist}から@sc{cdr}が@var{value}と@code{eq}なすべての要素を削除します。この関数は短くなったリストをreturnし、@var{alist}の元のリスト構造を変更することもよくあります。@code{rassq-delete-all}は@code{assq-delete-all}と似ていますが、@sc{car}ではなく@var{alist}の各連想の@sc{cdr}を比較します。
@end defun

@node Property Lists
@section プロパティリスト
@cindex property list
@cindex plist

  @dfn{プロパティーリスト(property
list。短くはplist)}は、ペアになった要素のリストです。各ペアはプロパティー名(通常はシンボル)とプロパティー値を対応づけます。以下はプロパティーリストの例です:

@example
(pine cones numbers (1 2 3) color "blue")
@end example

@noindent
このプロパティーリストは、@code{pine}を@code{cones}、@code{numbers}を@code{(1 2
3)}、@code{color}を@code{"blue"}に関連づけます。プロパティー名とプロパティー値には任意のLispオブジェクトを指定できますが、通常プロパティー名は(この例のように)シンボルです。

  いくつかのコンテキストでプロパティーリストが使用されます。たとえば、関数@code{put-text-property}はプロパティーリストを引数にとり、文字列またはバッファー内のテキストにたいして、テキストプロパティーと、テキストに適用するプロパティー値を指定します。@ref{Text
Properties}を参照してください。

  プロパティーリストが頻繁に使用される他の例は、シンボルプロパティーの保管です。すべてのシンボルは、シンボルに関する様々な情報を記録するために、プロパティーのリストを処理します。これらのプロパティーはプロパティーリストの形式で保管されます。@ref{Symbol
Properties}を参照してください。

@menu
* Plists and Alists::        プロパティーリストと連想リストの利点の比較。
* Plist Access::             他の場所に保管されたプロパティーリストへのアクセス。
@end menu

@node Plists and Alists
@subsection プロパティリストと連想リスト
@cindex plist vs. alist
@cindex alist vs. plist

@cindex property lists vs association lists
  連想リスト(@ref{Association
Lists}を参照してください)は、プロパティーリストとよく似ています。連想リストとは対照的に、プロパティー名は一意でなければならないので、プロパティーリスト内でペアの順序に意味はありません。

  様々なLisp関数や変数に情報を付加するためには、連想リストよりプロパティーリストの方が適しています。プログラムでこのような情報すべてを1つの連想リストに保持する場合、特定のLisp関数や変数にたいする連想をチェックする度に、リスト全体を検索する必要が生じ、それにより遅くなる可能性があります。対照的に、関数名や変数自体のプロパティーリストに同じ情報を保持すれば、検索ごとにそのプロパティーリストの長さだけを検索するようになり、通常はこちらの方が短い時間で済みます。変数のドキュメントが@code{variable-documentation}という名前のプロパティーに記録されているのは、これが理由です。同様にバイトコンパイラーも、特別に扱う必要がある関数を記録するためにプロパティーを使用します。

  連想リストにも独自の利点があります。アプリケーションに依存しますが、プロパティーを更新するより、連想リストの先頭に連想を追加する方が速いでしょう。シンボルにたいするすべてのプロパティーは同じプロパティーリストに保管されるので、プロパティー名を異なる用途のために使用すると衝突の可能性があります(この理由により、そのプログラムで通常の変数や関数の名前につけるプレフィクスをプロパティー名の先頭につけることにより、一意と思われるプロパティー名を選ぶのはよいアイデアです)。連想リストは、連想をリストの先頭にpushし、後にある連想は無視されるので、スタックと同様に使用できます。これはプロパティーリストでは不可能です。

@node Plist Access
@subsection プロパティリストと外部シンボル
@cindex plist access
@cindex accessing plist properties

  以下の関数はプロパティーリストを操作するために使用されます。これらの関数はすべて、プロパティー名の比較に@code{eq}を使用します。

@defun plist-get plist property
この関数は、プロパティーリスト@var{plist}に保管された、プロパティー@var{property}の値をreturnします。この関数には、変形された(malformed)@var{plist}引数を指定できます。@var{plist}で@var{property}が見つからなかった場合、この関数は@code{nil}をreturnします。たとえば、

@example
(plist-get '(foo 4) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'bad)
     @result{} nil
(plist-get '(foo 4 bad) 'bar)
     @result{} nil
@end example
@end defun

@defun plist-put plist property value
この関数は、プロパティーリスト@var{plist}に、プロパティー@var{property}の値として、@var{value}を保管します。この関数は@var{plist}を破壊的に変更するかもしれず、元のリスト構造を変更せずに新しいリストを構築することもあります。この関数は変更されたプロパティーリストをreturnするので、@var{plist}を取得した場所に書き戻すことができます。たとえば、

@example
(setq my-plist '(bar t foo 4))
     @result{} (bar t foo 4)
(setq my-plist (plist-put my-plist 'foo 69))
     @result{} (bar t foo 69)
(setq my-plist (plist-put my-plist 'quux '(a)))
     @result{} (bar t foo 69 quux (a))
@end example
@end defun

@defun lax-plist-get plist property
@code{plist-get}と同様ですが、プロパティーの比較に@code{eq}ではなく@code{equal}を使用します。
@end defun

@defun lax-plist-put plist property value
@code{plist-put}と同様ですが、プロパティーの比較に@code{eq}ではなく@code{equal}を使用します。
@end defun

@defun plist-member plist property
この関数は与えられた@var{property}が@var{plist}に含まれる場合は、非@code{nil}をreturnします。@code{plist-get}とは異なり、この関数は存在しないプロパティーと、値が@code{nil}のプロパティーを区別できます。実際にreturnされる値は、@code{car}が@var{property}で始まる、@var{plist}の後尾部分です。
@end defun
