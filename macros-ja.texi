@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998, 2001-2015 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node Macros
@chapter Macros
@cindex macros

  @dfn{マクロ(macros)}は、新たな制御構造や、他の言語機能の定義を可能にします。マクロは関数のように定義されますが、値の計算方法を指定するかわりに、値を計算する別のLisp式を計算する方法を指示します。わたしたちはこの式のことをマクロの@dfn{展開形(expansion)}と呼んでいます。

  マクロは、関数が行うように引数の値を処理するのではなく、引数のために未評価の式を処理することにより、これを行うことができます。したがってマクロは、これらの引数式またはその一部をを含む式を構築することができます。

  マクロを使用して通常の関数が行えることを行う場合、単にそれが速度面の理由ならば、かわりにインライン関数の使用を考慮してください。@ref{Inline
Functions}を参照してください。

@menu
* Simple Macro::             基本的な例。
* Expansion::                いつ、なぜ、どのようにしてマクロが展開されるか。
* Compiling Macros::         コンパイラーによりマクロが展開される方法。
* Defining Macros::          マクロ定義を記述する方法。
* Problems with Macros::     マクロ引数を何回も評価しないこと。ユーザーの変数を隠さないこと。
* Indenting Macros::         マクロ呼び出しのインデント方法の指定。
@end menu

@node Simple Macro
@section A Simple Example of a Macro

  Cの@code{++}演算子のように、変数の値をインクリメントするためのLisp構造を定義したいとします。@code{(inc
x)}のように記述すると、@code{(setq x (1+ x))}という効果を得たいとします。以下はこれを行うマクロ定義です:

@findex inc
@example
@group
(defmacro inc (var)
   (list 'setq var (list '1+ var)))
@end group
@end example

  これを@code{(inc x)}のように呼び出すと、引数@var{var}はシンボル@code{x}になります ---
関数のときのように@code{x}の@emph{値}では@emph{ありません}。このマクロのbodyはこれを展開の構築に使用して、展開形は@code{(setq
x (1+ x))}になります。マクロが1度この展開形をreturnすると。Lispはそれを評価するので、@code{x}はインクリメントされます。

@defun macrop object
この術後は、その引数がマクロかどうかテストして、もしマクロなら@code{t}、それ以外は@code{nil}をreturnします。
@end defun

@node Expansion
@section Expansion of a Macro Call
@cindex expansion of macros
@cindex macro call

  マクロ呼び出しは、関数の呼び出しと同じ外観をもち、マクロの名前で始まるリストで表されます。そのリストの残りの要素は、マクロの引数になります。

  マクロ呼び出しの評価は、1つの重大な違いを除き、関数の評価と同じように開始されます。重要な違いとは、そのマクロの引数はマクロ呼び出し内で実際の式として現れます。これらの引数はマクロ定義に与えられる前には評価されません。対象的に、関数の引数は、その関数の呼び出しリストの要素を評価した結果です。

  こうして得た引数を使用して、Lispは関数呼び出しのように、マクロ定義を呼び出します。マクロの引数変数はマクロ呼び出しの引数値にバインドされるか、a
@code{&rest}引数の場合は引数地のリストになります。そして、そのマクロのbodyが実行されて、関数bodyが行うように、マクロbodyの値をreturnsします。

  マクロと関数の2つ目の重要な違いは、マクロのbodyからreturnされる値が、代替となるLisp式であることで、これはマクロの@dfn{展開(expansion)}としても知られます。Lispインタープリターは、マクロから展開形が戻されると、すぐにその展開形の評価を行います。

  展開形は通常の方法で評価されるので、もしかしたらその展開形は他のマクロの呼び出しを含むかもしれません。一般的ではありませんが、もしかすると同じマクロを呼び出すかもしれません。

  EmacsはコンパイルされていないLispファイルをロードするときに、マクロの展開を試みることに注意してください。これは常に利用可能ではありませんが、もし可能なら、それ以降の実行の速度を改善します。@ref{How
Programs Do Loading}を参照してください。

  @code{macroexpand}を呼び出すことにより、与えられたマクロ呼び出しにたいする展開形を確認することができます。

@defun macroexpand form &optional environment
@cindex macro expansion
この関数は、それがマクロ呼び出しの場合は、@var{form}を展開します。結果が他のマクロ呼び出しの場合は、結果がマクロ呼び出しでなくなるまで、順番に展開を行います。これは@code{macroexpand}からreturnされる値になります。@var{form}がマクロ呼び出しで開始されない場合、与えられた@var{form}をそのままreturnします。

@code{macroexpand}は、(たとえいくつかのiマクロ定義がそれを行っているとしても)@var{form}の部分式(subexpression)を調べないことに注意してください。たとえ部分式自身がマクロ呼び出しの場合でも、@code{macroexpand}はそれらを展開しません。

関数@code{macroexpand}は、インライン関数の呼び出しを展開しません。なぜならインライン関数の呼び出しは、通常の関数呼び出しと比較して理解が難しい訳ではないので、通常はそれを行う必要がないからです。

@var{environment}が与えられた場合、それはそのとき定義されているマクロをシャドーするマクロのalistを指定します。バイトコンパイルはこの機能を使用します。

@example
@group
(defmacro inc (var)
    (list 'setq var (list '1+ var)))
@end group

@group
(macroexpand '(inc r))
     @result{} (setq r (1+ r))
@end group

@group
(defmacro inc2 (var1 var2)
    (list 'progn (list 'inc var1) (list 'inc var2)))
@end group

@group
(macroexpand '(inc2 r s))
     @result{} (progn (inc r) (inc s))  ; @r{ここでは@code{inc}は展開されない。}
@end group
@end example
@end defun


@defun macroexpand-all form &optional environment
@code{macroexpand-all}は@code{macroexpand}と同様、マクロを展開しますが、ドップレベルだけではなく、@var{form}内のすべてのマクロを探して展開します。展開されたマクロがない場合、return値は、@var{form}と@code{eq}になります。

上記@code{macroexpand}で使用した例を@code{macroexpand-all}に用いると、@code{macroexpand-all}が@code{inc}に埋め込まれた呼び出しの展開を@emph{行う}ことを確認できます:

@example
(macroexpand-all '(inc2 r s))
     @result{} (progn (setq r (1+ r)) (setq s (1+ s)))
@end example

@end defun

@node Compiling Macros
@section Macros and Byte Compilation
@cindex byte-compiling macros

  なぜわざわざマクロにたいする展開形を計算して、その後に展開形を評価する手間をかけるのか、不思議に思うかもしれません。なぜマクロbodyは直接望ましい結果を生成しないのでしょうか?
それはコンパイルする必要があるからです。

  コンパイルされるLispプログラム内にマクロ呼び出しがあるとき、Lispコンパイラーはインタープリターが行うようにマクロ定義を呼び出して、展開形を受け取ります。しかし展開形を評価するかわりに、コンパイラーは展開形が直接プログラム内にあるかのようにコンパイルを行います。結果として、コンパイルされたコードはそのマクロにたいする値と副作用を生成しますが、実行速度は完全にコンパイルされた行されたときと同じになります。もしマクロbody自身が値と副作用を計算したら。このようには機能しません
--- コンパイル時に計算されることになり、それは有用ではありません。

  マクロ呼び出しのコンパイルが機能するためには、マクロを呼び出すコードがコンパイルされるとき、そのマクロがLisp内ですでに定義されていなければなりません。コンパイラーには、これを行うのを助ける特別な機能があります。コンパイルされるファイルが@code{defmacro}フォームを含む場合、そのファイルの残りの部分をコンパイルするために、そのマクロが一時的に定義されます。

  ファイルをバイトコンパイルすると、ファイル内のトップレベルにある任意の@code{require}呼び出しも実行されるので、それらを定義しているファイルをrequireすることにより、コンパイルの間、必要なマクロ定義が利用できることが確実になります(@ref{Named
Features}を参照してください)。誰かがコンパイルされたプログラムを@emph{実行}するときに、マクロ定義ファイルのロードをしないようにするには、@code{require}呼び出しの周囲に@code{eval-when-compile}を記述します(@ref{Eval
During Compile}を参照してください)。

@node Defining Macros
@section Defining Macros
@cindex defining macros
@cindex macro, how to define

  Lispのマクロオブジェクトは、@sc{car}が@code{macro}で、@sc{cdr}が関数のリストです。マクロの展開形は、マクロ呼び出しから、@emph{評価されていない}引数のリストに、(@code{apply}を使って)関数を適用することにより機能します。

  無名関数のように無名Lispマクロを使用することも可能ですが、無名マクロを@code{mapcar}のようなファンクショナルに渡すことに意味がないので、これが行われることはありません。実際のところ、すべてのLispマクロは名前をもち、ほとんど常に@code{defmacro}マクロで定義されます。

@defmac defmacro name args [doc] [declare] body@dots{}
@code{defmacro}はシンボル@var{name}(クォートはしない)を、以下のようなマクロ押して定義します:

@example
(macro lambda @var{args} . @var{body})
@end example

(このリストの@sc{cdr}はラムダ式であることに注意してください。)
このマクロオブジェクトは、@var{name}の関数セルに格納されます。@var{args}の意味は関数の場合と同じで、キーワード@code{&rest}および@code{&optional}が使用されることもあります(@ref{Argument
List}を参照してください)。@var{name}と@var{args}はどちらも、クォートされるべきではありません。@code{defmacro}のreturn値は未定義です。

@var{doc}が与えられた場合、それはマクロのドキュメント文字列を指定する文字列です。@var{declare}が与えられた場合、それはマクロのメタデータを指定する@code{declare}フォームです(@ref{Declare
Form}を参照してください)。マクロを対話的に呼び出すことはできないので、インタラクティブ宣言をもつことはできないことに注意してください。
@end defmac

  マクロが、定数部と非定数部の混合体から構築される巨大なリスト構造を必要とする場合があります。これを簡単に行うためには、@samp{`}構文(@ref{Backquote}を参照してください)を使用します。たとえば:

@example
@example
@group
(defmacro t-becomes-nil (variable)
  `(if (eq ,variable t)
       (setq ,variable nil)))
@end group

@group
(t-becomes-nil foo)
     @equiv{} (if (eq foo t) (setq foo nil))
@end group
@end example
@end example

  マクロ定義のbodyには、そのマクロに関する追加のプロパティーを指定する、@code{declare}フォームを含めることができます。@ref{Declare
Form}を参照してください。

@node Problems with Macros
@section Common Problems Using Macros
@cindex macro caveats

  マクロ展開が、直感に反する結果となることがあり得ます。このセクションでは、問題になりかねない重要な結果と、問題を避けるためにしたがうべきルールをいくつか説明します。

@menu
* Wrong Time::               マクロ内ではなく展開形で作業を行う。
* Argument Evaluation::      展開形は各マクロ引数を1度評価すること。
* Surprising Local Vars::    展開形でのローカル変数バインディングには特に注意を要する。
* Eval During Expansion::    評価せずに展開形の中に配置すること。
* Repeated Expansion::       展開が行われる回数への依存を避ける。
@end menu

@node Wrong Time
@subsection Wrong Time

  マクロを記述する際のもっとも一般的な問題は、展開形の中ではなく、マクロ展開中に、早まって実際に何らかの作業を行ってしまうことがあります。たとえば、実際のパッケージが以下のマクロ定義をもつとします:

@example
(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      (set-buffer-multibyte arg)))
@end example

この誤ったマクロ定義は、解釈(interpret)されるときは正常に機能しますが、コンパイル時に失敗します。このマクロ定義はコンパイル時に@code{set-buffer-multibyte}を呼び出してしまいますが、それは間違っています。その後でコンパイルされたパッケージを実行しても何も行いません。プログラマーが実際に望むのは、以下の定義です:

@example
(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      `(set-buffer-multibyte ,arg)))
@end example

@noindent
このマクロは、もし適切なら@code{set-buffer-multibyte}の呼び出しに展開され、それはコンパイルされたプログラム実行時に実行されるでしょう。

@node Argument Evaluation
@subsection Evaluating Macro Arguments Repeatedly

  マクロを定義する場合、展開形が実行されるときに引数が何回評価されるか注意を払わなければなりません。以下の(繰り返し処理を用意にする)マクロで、この問題を示してみましょう。このマクロで``for''によるループ構造を記述できます。

@findex for
@example
@group
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (list 'let (list (list var init))
        (cons 'while
              (cons (list '<= var final)
                    (append body (list (list 'inc var)))))))
@end group

@group
(for i from 1 to 3 do
   (setq square (* i i))
   (princ (format "\n%d %d" i square)))
@expansion{}
@end group
@group
(let ((i 1))
  (while (<= i 3)
    (setq square (* i i))
    (princ (format "\n%d %d" i square))
    (inc i)))
@end group
@group

     @print{}1       1
     @print{}2       4
     @print{}3       9
@result{} nil
@end group
@end example

@noindent
マクロ内の引数@code{from}、@code{to}、@code{do}は、``構文糖(syntactic
sugar)''であり、完全に無視されます。このアイデアは、マクロ呼び出し中で(@code{from}, @code{to}, and
@code{do}のような)余計な単語を、これらの位置に記述できるようにするというものです。

以下は、バッククォートの使用により、より単純化された等価の定義です:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  `(let ((,var ,init))
     (while (<= ,var ,final)
       ,@@body
       (inc ,var))))
@end group
@end example

この定義のフォームは両方(バッククォートのあるものと、ないもの)とも、各繰り返しにおいて毎回@var{final}が評価されるという欠点をもちます。@var{final}が定数のときには、問題はありません。しかし、これがより複雑な、たとえば@code{(long-complex-calculation
x)}のようなフォームの場合、実効速度は顕著に低下し得ます。@var{final}が副作用をもつ場合には、複数回実行すると、おそらく正しくなくなります。

@cindex macro argument evaluation
うまく設計されたマクロ定義は、繰り返し評価することがそのマクロの意図された目的でない限り、引数を正確に1回評価を行う展開形を生成することにより、この問題を避けるためにステップを費やします。以下は@code{for}マクロの正しい展開形です:

@example
@group
(let ((i 1)
      (max 3))
  (while (<= i max)
    (setq square (* i i))
    (princ (format "%d      %d" i square))
    (inc i)))
@end group
@end example

以下はこの展開形を生成するためのマクロ定義です:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
  `(let ((,var ,init)
         (max ,final))
     (while (<= ,var max)
       ,@@body
       (inc ,var))))
@end group
@end example

  残念なことに、この訂正により、以下のセクションで説明する、別の問題が発生します。

@node Surprising Local Vars
@subsection Local Variables in Macro Expansions

@ifnottex
  前のセクションでは、@code{for}の定義を、展開形がマクロ引数を正しい回数評価するように訂正しました:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
@end group
@group
  `(let ((,var ,init)
         (max ,final))
     (while (<= ,var max)
       ,@@body
       (inc ,var))))
@end group
@end example
@end ifnottex

  @code{for}の新しい定義には、新たな問題があります。この定義は、ユーザーが意識していない、@code{max}という名前のローカル変数を導入しています。これは、以下の例で示すようなトラブルを招きます:

@example
@group
(let ((max 0))
  (for x from 0 to 10 do
    (let ((this (frob x)))
      (if (< max this)
          (setq max this)))))
@end group
@end example

@noindent
@code{for}のbodyの内部の@code{max}への参照は、@code{max}のユーサーバインディングの参照を意図したものですが、実際には@code{for}により作られたバインディングにアクセスします。

これを修正する方法は、@code{max}のかわりにinternされていない(uninterned)シンボルを使用することです(@ref{Creating
Symbols}を参照してください)。internされていないシンボルは他のシンボルと同じようにバインドして参照することができますが、@code{for}により作成されるので、わたしたちはすでにユーザーのプログラムに存在するはずがないことを知ることができます。これはinternされていないので、プログラムの後続の部分でそれを配置する方法はありません。これは@code{for}により配置された場所をのぞき、他の場所で配置されることはありません。以下はこの方法で機能する@code{for}の定義です:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Execute a simple for loop: (for i from 1 to 10 do (print i))."
  (let ((tempvar (make-symbol "max")))
    `(let ((,var ,init)
           (,tempvar ,final))
       (while (<= ,var ,tempvar)
         ,@@body
         (inc ,var)))))
@end group
@end example

@noindent
作成されたinternされていないシンボルの名前は@code{max}で、これを通常のinternされたシンボル@code{max}のかわりに、式内のその位置に記述します。

@node Eval During Expansion
@subsection Evaluating Macro Arguments in Expansion

  マクロ定義自体が、@code{eval}(@ref{Eval}を参照してください)の呼び出しなどによりマクロ引数式を評価した場合には、別の問題が発生します。その引数がユーザーの変数を参照する場合、ユーザーがマクロ引数と同じな前で変数をしようとした場合に問題となるでしょう。マクロのbodyないでは、マクロ引数のバインディングは、その変数のもっともローカルなバインディングなので、そのフォーム内部の任意の参照は、それを参照するように評価されます。以下は例です:

@example
@group
(defmacro foo (a)
  (list 'setq (eval a) t))
@end group
@group
(setq x 'b)
(foo x) @expansion{} (setq b t)
     @result{} t                  ; @r{@code{b}がセットされる。}
;; @r{but}
(setq a 'c)
(foo a) @expansion{} (setq a t)
     @result{} t                  ; @r{しかし、これは@code{c}ではなく@code{a}がセットされる。}

@end group
@end example

  ユーザーの変数の名前が@code{a}か@code{x}かということで、違いが生じています。これは@code{a}が、マクロの引数変数@code{a}と競合しているからです。

  マクロ定義内での@code{eval}の呼び出しにまつわる別の問題は、それがおそらくコンパイル時にあなたが意図したことを行わないだろうということです。バイトコンパイラーは、そのプログラム自身の(あなたが@code{eval}でアクセスしたいと望む)計算は発生せず、ローカル変数バインディングも存在しないプログラムのコンパイル時にマクロ定義を実行します。

  この問題を避けるためには、@strong{マクロ展開形の計算では引数式を評価しないでください}。かわりにその式をマクロ展開形の中に置き換えれば、その値は展開形の実行の一部として計算されます。これは、このチャプターの他の例が機能する方法です。

@node Repeated Expansion
@subsection How Many Times is the Macro Expanded?

  マクロ呼び出しは逐次解釈される関数で毎回マクロ呼び出しが展開されるが、コンパイルされた関数では(コンパイル時に)1回だけしか展開されないという事実にもとづく問題が、時折発生します。そのマクロ定義が副作用をもつ場合、それらのマクロは、そのマクロが難解展開されたかにより、異なる動作をとるでしょう。

  したがって、あなたが何をしているか本当に判っていないのであれば、マクロ展開形の計算での副作用は避けるべきです。

  避けることのできない特殊な副作用が1つあります。それはLispオブジェクトの構築です。ほとんどすべてのマクロ展開形には、リストの構築が含まれます。リスト構築はほとんどのマクロの核心部分です。これは通常は安全です。用心しなければならないケースが1つだけあります。それは構築するオブジェクトが、マクロ展開形の中でクォートされた定数の一部となるときです。

  そのマクロが1回だけ --- コンパイル時 ---
しか展開されない場合、そのオブジェクトの構築もコンパイル時の1回です。しかし逐次実行では、そのマクロはマクロ呼び出しが実行されるたびに展開され、これは毎回新たなオブジェクトが構築されることを意味します。

  クリーンなLispコードのほとんどでは、この違いは問題になりません。しかし、マクロ定義によるオブジェクト構築の副作用を処理する場合には、問題になるかもしれません。したがって問題を避けるために、@strong{マクロ定義によるオブジェクト構築の副作用を避けてください}。以下は副作用により問題が起こる例です:

@lisp
@group
(defmacro empty-object ()
  (list 'quote (cons nil nil)))
@end group

@group
(defun initialize (condition)
  (let ((object (empty-object)))
    (if condition
        (setcar object condition))
    object))
@end group
@end lisp

@noindent
@code{initialize}が解釈された場合、@code{initialize}が呼び出されるたびに、新しいリスト@code{(nil)}が構築されます。したがって、各呼び出しの間において、副作用は存続しません。しかし@code{initialize}がコンパイルされた場合、マクロ@code{empty-object}はコンパイル時に展開され、これは1つの``定数''@code{(nil)}を生成し、この定数は@code{initialize}の毎回の呼び出しで、再利用・変更されます。

このような異常な状態を避ける1つの方法は、@code{empty-object}を、メモリー割り当て構造ではなく、一種の奇妙な変数と考えることです。@code{'(nil)}のような定数にたいして@code{setcar}を使うことはないでしょうから、当然@code{(empty-object)}にも使うことはないでしょう。

@node Indenting Macros
@section Indenting Macros

  マクロ定義では、マクロ呼び出しを@key{TAB}がどのようにインデントすべきか指定するために、@code{declare}フォーム(@ref{Defining
Macros}を参照してください)を使うことができます。インデント指定は以下のように記述します:

@example
(declare (indent @var{indent-spec}))
@end example

@noindent
以下は利用できる@var{indent-spec}です:

@table @asis
@item @code{nil}
これはプロパティーを指定しない場合と同じ --- 標準的なインデントパターンを使用します。
@item @code{defun}
この関数を@samp{def}構造 --- 2番目の行が@dfn{body}の開始 --- と同様に扱います。
@item 整数: @var{number}
関数の最初の@var{number}個の引数は@dfn{区別}され、残りは式のbodyと判断されます。その式の中の行は、最初の引数が区別されているかどうかにしたがってインデントされます。引数がbodyの一部である場合、その行はこの式の先頭の
開きカッコ(open-parenthesis)よりも@code{lisp-body-indent}だけ多い列にインデントされます。引数が
区別されていて、1つ目または2つ目の引数である場合は、@emph{2倍}余分にインデントされます。引数が区別されていて1つ目あるいは2つ目の引数でない場合、その行は標準パターンによってインデントされます。
@item シンボル: @var{symbol}
@var{symbol}は関数名です。その関数はこの式のインデントを計算するために呼び出される関数です。この関数は2つの引数をとります:

@table @asis
@item @var{pos}
その行のインデントが開始される位置です。
@item @var{state}
その行の開始まで解析されたとき、@code{parse-partial-sexp}(インデントとネスト深さの計算のためのLispプリミティブ)によりreturnされる値です。
@end table

@noindent
これは、数(その行のインデントの列数)、またはそのような数がcarであるようなリストをreturnすべきです。数とリストの違いは、数の場合、同じネスト深さの後続のすべての行はこの数と同じインデントとなります。リストの場合、後続の行は異なるインデントを呼び出すかもしれません。これは、@kbd{C-M-q}によりインデントが計算されるときに違いがでます。値が数の場合、@kbd{C-M-q}はリストの終わりまでの後続の行のインデントを、再計算する必要はありません。
@end table
