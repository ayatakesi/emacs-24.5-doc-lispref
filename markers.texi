@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Markers
@chapter Markers
@cindex markers

  @dfn{マーカー(marker)}とは、あるバッファー内で取り囲んでいるテキストにたいして相対的な位置を指定するために使用されるオブジェクトです。テキストが挿入または削除されると常に、マーカーは自動的にそのバッファーの先頭からのオフセットを自動的に変更して、自身の左右にある文字の間に留まります。

@menu
* Overview of Markers::      マーカー構成要素と再配置方法。
* Predicates on Markers::    オブジェクトがマーカーか否かのテスト。
* Creating Markers::         空マーカーや特定箇所のマーカーの作成。
* Information from Markers::  マーカーのバッファーや文字位置を探す。
* Marker Insertion Types::   マーカーが指す位置への挿入時にマーカーを再配置する2つの方法。
* Moving Markers::           新たなバッファーや位置にマーカーを移動する。
* The Mark::                 マーカーによる"マーク"の実装方法。
* The Region::               "リージョン"へのアクセス方法。
@end menu

@node Overview of Markers
@section Overview of Markers

  マーカーは、バッファーとそのバッファー内の位置を指定します。マーカーは、位置を要求する関数内において、位置を表すために整数と同じようにして使用することができます。その場合、そのマーカーのバッファーは、通常は無視されます。この方法で使用されるマーカーは通常、その関数が処理するバッファー内の位置を指しますが、それは完全にプログラマーの責任です。位置についての完全な説明は、@ref{Positions}を参照してください。

  マーカーはマーカー位置(marker position)、マーカーバッファー(marker buffer)、挿入タイプ(insertion
type)という3つの属性をもちます。マーカー位置は、そのバッファー内の位置としてのマーカーと、(その時点において)等しい整数です。しかし、マーカー位置はマーカー生存期間中に変化し得るものであり、頻繁に変化されます。バッファー内でのテキストの挿入や削除で、マーカーは再配置されます。マーカー前後の2文字以外の場所で挿入や削除がおこなわれても、マーカー位置はその2文字間に留まるというのが、このアイデアです。再配置により、マーカーと等価な整数は変更されます。

@cindex marker relocation
  マーカー位置周辺のテキストを削除することにより、そのマーカーは削除されたテキストの直前および直後にある文字の間に残されます。マーカー位置へのテキスト挿入では、マーカーは通常は新たなテキストの前か後のいずれかに置かれます。その挿入が@code{insert-before-markers}(@ref{Insertion}を参照)で行われたものでなければ、どちらに置かれるかはマーカーの@dfn{挿入タイプ}(@ref{Marker
Insertion Types}を参照)に依存します。

@cindex marker garbage collection
  バッファーでの挿入と削除では、すべてのマーカーをチェックして、必要ならそれらを再配置しなければなりません。これは、多数のマーカーをもつバッファーでの処理を遅くします。それ以上マーカーが不必要なのが確信できる場合には、存在しない場所も指さないようにマーカーを設定することは、この理由によりよいアイデアといえるでしょう。それ以上アクセスされる可能性がないマーカーは、最終的には削除されます(@ref{Garbage
Collection}を参照)。

@cindex markers as numbers
  マーカー位置にたいして算術演算を行うことは一般的なので、それらの演算子のほとんど(@code{+}や@code{-}を含む)が、引数としてマーカーに渡すことができます。そのような場合には、マーカーはカレント位置を意味します。

以下ではマーカー渡す作成とセットを行い、ポイントをマーカーに移動しています:

@example
@group
;; @r{最初はどこも指さない新たなマーカーを作成:}
(setq m1 (make-marker))
     @result{} #<marker in no buffer>
@end group

@group
;; @r{カレントバッファーの99と100番目の}
;;   @r{文字間を指すよう@code{m1}をセット:}
(set-marker m1 100)
     @result{} #<marker at 100 in markers.texi>
@end group

@group
;; @r{ここでバッファー先頭に1文字挿入:}
(goto-char (point-min))
     @result{} 1
(insert "Q")
     @result{} nil
@end group

@group
;; @r{@code{m1}は適切に更新された}
m1
     @result{} #<marker at 101 in markers.texi>
@end group

@group
;; @r{同じ位置を指す2つのマーカーは}
;;   @r{@code{equal}だが@code{eq}に非ず}
(setq m2 (copy-marker m1))
     @result{} #<marker at 101 in markers.texi>
(eq m1 m2)
     @result{} nil
(equal m1 m2)
     @result{} t
@end group

@group
;; @r{マーカー使用終了時、存在しない場所を指すようセット}
(set-marker m1 nil)
     @result{} #<marker in no buffer>
@end group
@end example

@node Predicates on Markers
@section Predicates on Markers
@cindex predicates for markers
@cindex markers, predicates for

  あるオブジェクトがマーカーなのか、それとも整数かマーカーのいずれかであるか確認するために、テストを行うことができます。後者のテストは、マーカーと整数の両方にたいして機能する算術関数において有用です。

@defun markerp object
この関数は、@var{object}がマーカーなら@code{nil}、それ以外は@code{t}をリターンする。多くの関数はマーカーか整数のいずれかを受け入れるだろうが、整数はマーカーと異なることに注意。
@end defun

@defun integer-or-marker-p object
この関数は、@var{object}が整数またはマーカーなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@defun number-or-marker-p object
この関数は、@var{object}が数値(整数か浮動小数点数のいずれか)またはマーカーなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@node Creating Markers
@section Functions that Create Markers
@cindex creating markers
@cindex marker creation

  マーカーを新たに作成する際は、存在しない場所、ポイントの現在位置、バッファーのアクセス可能範囲の先頭や終端、または別の与えられたマーカーと同じ箇所を指すようにすることができます。

以下の4つの関数はすべて、挿入タイプ@code{nil}のマーカーをリターンします。@ref{Marker Insertion
Types}を参照してください。

@defun make-marker
この関数は、どこも指さないマーカーを新たに作成してリターンする。

@example
@group
(make-marker)
     @result{} #<marker in no buffer>
@end group
@end example
@end defun

@defun point-marker
この関数は、カレントバッファーのポイント現在位置を指すマーカーを新たに作成してリターンする。@xref{Point}を参照のこと。例は以下の@code{copy-marker}を参照されたい。
@end defun

@defun point-min-marker
この関数は、バッファーのアクセス可能範囲の先頭を指すマーカーを新たに作成してリターンする。ナローイングが効力をもたなければ、これはバッファーの先頭になるだろう。@ref{Narrowing}を参照のこと。
@end defun

@defun point-max-marker
この関数は、バッファーのアクセス可能範囲の終端を指すマーカーを新たに作成してリターンする。ナローイングが効力をもたなければ、これはバッファーの終端になるだろう。@ref{Narrowing}を参照のこと。

以下に、このチャプターのテキストのソースファイルのバージョンを含むバッファーにたいして、この関数および@code{point-min-marker}を使用した例を示す。

@example
@group
(point-min-marker)
     @result{} #<marker at 1 in markers.texi>
(point-max-marker)
     @result{} #<marker at 24080 in markers.texi>
@end group

@group
(narrow-to-region 100 200)
     @result{} nil
@end group
@group
(point-min-marker)
     @result{} #<marker at 100 in markers.texi>
@end group
@group
(point-max-marker)
     @result{} #<marker at 200 in markers.texi>
@end group
@end example
@end defun

@defun copy-marker &optional marker-or-integer insertion-type
引数としてマーカーを渡されると、@code{copy-marker}は@var{marker-or-integer}が行うようにして、同じバッファーの同じ位置を指すマーカーを新たに作成してリターンする。整数を渡された場合、@code{copy-marker}はカレントバッファーの位置@var{marker-or-integer}を指すマーカーを新たに作成してリターンする。

新たなマーカーの挿入タイプは、引数@var{insertion-type}により指定される。@ref{Marker Insertion
Types}を参照のこと。

@c This behavior used to be documented until 2013/08.
@ignore
If passed an integer argument less than 1, @code{copy-marker} returns a
new marker that points to the beginning of the current buffer.  If
passed an integer argument greater than the length of the buffer,
@code{copy-marker} returns a new marker that points to the end of the
buffer.
@end ignore

@example
@group
(copy-marker 0)
     @result{} #<marker at 1 in markers.texi>
@end group

@group
(copy-marker 90000)
     @result{} #<marker at 24080 in markers.texi>
@end group
@end example

@var{marker}がマーカーと整数のいずれでもない場合は、エラーがシグナルされる。
@end defun

  2つのマーカーは、それらが同じバッファーの同じ位置、またはどちらも存在しない場所を指す場合は、(@code{eq}ではないものの)@code{equal}とみなされます。

@example
@group
(setq p (point-marker))
     @result{} #<marker at 2139 in markers.texi>
@end group

@group
(setq q (copy-marker p))
     @result{} #<marker at 2139 in markers.texi>
@end group

@group
(eq p q)
     @result{} nil
@end group

@group
(equal p q)
     @result{} t
@end group
@end example

@node Information from Markers
@section Information from Markers
@cindex marker information

  このセクションでは、マーカーオブジェクトの構成要素にアクセスする関数を説明します。

@defun marker-position marker
この関数は、@var{marker}が指す位置、または存在しない場所なら@code{nil}をリターンする。
@end defun

@defun marker-buffer marker
この関数は、@var{marker}がその内部を指すバッファー、存在しない場所を指す場合は@code{nil}をリターンする。

@c FIXME: The `buffer' argument of `set-marker' already defaults to
@c the current buffer, why use `(current-buffer)' explicitly here?
@example
@group
(setq m (make-marker))
     @result{} #<marker in no buffer>
@end group
@group
(marker-position m)
     @result{} nil
@end group
@group
(marker-buffer m)
     @result{} nil
@end group

@group
(set-marker m 3770 (current-buffer))
     @result{} #<marker at 3770 in markers.texi>
@end group
@group
(marker-buffer m)
     @result{} #<buffer markers.texi>
@end group
@group
(marker-position m)
     @result{} 3770
@end group
@end example
@end defun

@node Marker Insertion Types
@section Marker Insertion Types

@cindex insertion type of a marker
  マーカーが指す位置に直接テキストを挿入する際、そのマーカーを再配置するために利用可能な手段が2つあります。そのマーカーはは挿入されたテキストの前、あるいは後を指すことができます。マーカーの@dfn{挿入タイプ(insertion
type)}を指定することにより、マーカーがどちらを行うか指定できます。@code{insert-before-markers}を使用する場合は、マーカーの挿入タイプを無視して、常にマーカーが挿入されたテキストの後を指すよう再配置されることに注意してください。

@defun set-marker-insertion-type marker type
この関数は、マーカー@var{marker}の挿入タイプを、@var{type}にセットする。@var{type}が@code{t}の場合、テキスト挿入時に@var{marker}はその位置まで進められるだろう。@var{type}が@code{nil}なら、テキスト挿入時に@var{marker}はそこまで進められない。
@end defun

@defun marker-insertion-type marker
この関数は、@var{marker}のカレント挿入タイプを報告する。
@end defun

挿入タイプを指定するための引数を受け取らない、マーカーを作成する関数のほとんどは、挿入タイプ@code{nil}のマーカーを作成しします。また、マークがもつデフォルトの挿入タイプも@code{nil}です。

@node Moving Markers
@section Moving Marker Positions
@cindex moving markers
@cindex marker, how to move position

  This section describes how to change the position of an existing marker.
When you do this, be sure you know whether the marker is used outside of
your program, and, if so, what effects will result from moving
it---otherwise, confusing things may happen in other parts of Emacs.

@defun set-marker marker position &optional buffer
This function moves @var{marker} to @var{position} in @var{buffer}.  If
@var{buffer} is not provided, it defaults to the current buffer.

@c This behavior used to be documented until 2013/08.
@ignore
If @var{position} is less than 1, @code{set-marker} moves @var{marker}
to the beginning of the buffer.  If @var{position} is greater than the
size of the buffer (@pxref{Point}), @code{set-marker} moves marker to
the end of the buffer.
@end ignore
If @var{position} is @code{nil} or a marker that points nowhere, then
@var{marker} is set to point nowhere.

The value returned is @var{marker}.

@example
@group
(setq m (point-marker))
     @result{} #<marker at 4714 in markers.texi>
@end group
@group
(set-marker m 55)
     @result{} #<marker at 55 in markers.texi>
@end group
@group
(setq b (get-buffer "foo"))
     @result{} #<buffer foo>
@end group
@group
(set-marker m 0 b)
     @result{} #<marker at 1 in foo>
@end group
@end example
@end defun

@defun move-marker marker position &optional buffer
This is another name for @code{set-marker}.
@end defun

@node The Mark
@section The Mark
@cindex mark, the
@c @cindex the mark?

  Each buffer has a special marker, which is designated @dfn{the mark}.  When
a buffer is newly created, this marker exists but does not point anywhere;
this means that the mark ``doesn't exist'' in that buffer yet.  Subsequent
commands can set the mark.

  The mark specifies a position to bound a range of text for many commands,
such as @code{kill-region} and @code{indent-rigidly}.  These commands
typically act on the text between point and the mark, which is called the
@dfn{region}.  If you are writing a command that operates on the region,
don't examine the mark directly; instead, use @code{interactive} with the
@samp{r} specification.  This provides the values of point and the mark as
arguments to the command in an interactive call, but permits other Lisp
programs to specify arguments explicitly.  @xref{Interactive Codes}.

  Some commands set the mark as a side-effect.  Commands should do this only
if it has a potential use to the user, and never for their own internal
purposes.  For example, the @code{replace-regexp} command sets the mark to
the value of point before doing any replacements, because this enables the
user to move back there conveniently after the replace is finished.

  Once the mark ``exists'' in a buffer, it normally never ceases to exist.
However, it may become @dfn{inactive}, if Transient Mark mode is enabled.
The buffer-local variable @code{mark-active}, if non-@code{nil}, means that
the mark is active.  A command can call the function @code{deactivate-mark}
to deactivate the mark directly, or it can request deactivation of the mark
upon return to the editor command loop by setting the variable
@code{deactivate-mark} to a non-@code{nil} value.

  If Transient Mark mode is enabled, certain editing commands that normally
apply to text near point, apply instead to the region when the mark is
active.  This is the main motivation for using Transient Mark mode.
(Another is that this enables highlighting of the region when the mark is
active.  @xref{Display}.)

@cindex mark ring
  In addition to the mark, each buffer has a @dfn{mark ring} which is a list
of markers containing previous values of the mark.  When editing commands
change the mark, they should normally save the old value of the mark on the
mark ring.  The variable @code{mark-ring-max} specifies the maximum number
of entries in the mark ring; once the list becomes this long, adding a new
element deletes the last element.

  There is also a separate global mark ring, but that is used only in a few
particular user-level commands, and is not relevant to Lisp programming.  So
we do not describe it here.

@defun mark &optional force
@cindex current buffer mark
This function returns the current buffer's mark position as an integer, or
@code{nil} if no mark has ever been set in this buffer.

If Transient Mark mode is enabled, and @code{mark-even-if-inactive} is
@code{nil}, @code{mark} signals an error if the mark is inactive.  However,
if @var{force} is non-@code{nil}, then @code{mark} disregards inactivity of
the mark, and returns the mark position (or @code{nil})  anyway.
@end defun

@defun mark-marker
This function returns the marker that represents the current buffer's mark.
It is not a copy, it is the marker used internally.  Therefore, changing
this marker's position will directly affect the buffer's mark.  Don't do
that unless that is the effect you want.

@example
@group
(setq m (mark-marker))
     @result{} #<marker at 3420 in markers.texi>
@end group
@group
(set-marker m 100)
     @result{} #<marker at 100 in markers.texi>
@end group
@group
(mark-marker)
     @result{} #<marker at 100 in markers.texi>
@end group
@end example

Like any marker, this marker can be set to point at any buffer you like.  If
you make it point at any buffer other than the one of which it is the mark,
it will yield perfectly consistent, but rather odd, results.  We recommend
that you not do it!
@end defun

@defun set-mark position
This function sets the mark to @var{position}, and activates the mark.  The
old value of the mark is @emph{not} pushed onto the mark ring.

@strong{Please note:} Use this function only if you want the user to see
that the mark has moved, and you want the previous mark position to be
lost.  Normally, when a new mark is set, the old one should go on the
@code{mark-ring}.  For this reason, most applications should use
@code{push-mark} and @code{pop-mark}, not @code{set-mark}.

Novice Emacs Lisp programmers often try to use the mark for the wrong
purposes.  The mark saves a location for the user's convenience.  An editing
command should not alter the mark unless altering the mark is part of the
user-level functionality of the command.  (And, in that case, this effect
should be documented.)  To remember a location for internal use in the Lisp
program, store it in a Lisp variable.  For example:

@example
@group
(let ((beg (point)))
  (forward-line 1)
  (delete-region beg (point))).
@end group
@end example
@end defun

@defun push-mark &optional position nomsg activate
@c Doesn't seem relevant.
@c @code{push-mark} returns @code{nil}.
This function sets the current buffer's mark to @var{position}, and pushes a
copy of the previous mark onto @code{mark-ring}.  If @var{position} is
@code{nil}, then the value of point is used.

The function @code{push-mark} normally @emph{does not} activate the mark.
To do that, specify @code{t} for the argument @var{activate}.

A @samp{Mark set} message is displayed unless @var{nomsg} is non-@code{nil}.
@end defun

@defun pop-mark
@c
@c Seems even less relevant.
@c The return value is not meaningful.
This function pops off the top element of @code{mark-ring} and makes that
mark become the buffer's actual mark.  This does not move point in the
buffer, and it does nothing if @code{mark-ring} is empty.  It deactivates
the mark.
@end defun

@defopt transient-mark-mode
This variable, if non-@code{nil}, enables Transient Mark mode.  In Transient
Mark mode, every buffer-modifying primitive sets @code{deactivate-mark}.  As
a consequence, most commands that modify the buffer also deactivate the
mark.

When Transient Mark mode is enabled and the mark is active, many commands
that normally apply to the text near point instead apply to the region.
Such commands should use the function @code{use-region-p} to test whether
they should operate on the region.  @xref{The Region}.

Lisp programs can set @code{transient-mark-mode} to non-@code{nil},
non-@code{t} values to enable Transient Mark mode temporarily.  If the value
is @code{lambda}, Transient Mark mode is automatically turned off after any
action, such as buffer modification, that would normally deactivate the
mark.  If the value is @w{@code{(only . @var{oldval})}}, then
@code{transient-mark-mode} is set to the value @var{oldval} after any
subsequent command that moves point and is not shift-translated (@pxref{Key
Sequence Input, shift-translation}), or after any other action that would
normally deactivate the mark.
@end defopt

@defopt mark-even-if-inactive
If this is non-@code{nil}, Lisp programs and the Emacs user can use the mark
even when it is inactive.  This option affects the behavior of Transient
Mark mode.  When the option is non-@code{nil}, deactivation of the mark
turns off region highlighting, but commands that use the mark behave as if
the mark were still active.
@end defopt

@defvar deactivate-mark
If an editor command sets this variable non-@code{nil}, then the editor
command loop deactivates the mark after the command returns (if Transient
Mark mode is enabled).  All the primitives that change the buffer set
@code{deactivate-mark}, to deactivate the mark when the command is finished.

To write Lisp code that modifies the buffer without causing deactivation of
the mark at the end of the command, bind @code{deactivate-mark} to
@code{nil} around the code that does the modification.  For example:

@example
(let (deactivate-mark)
  (insert " "))
@end example
@end defvar

@defun deactivate-mark &optional force
If Transient Mark mode is enabled or @var{force} is non-@code{nil}, this
function deactivates the mark and runs the normal hook
@code{deactivate-mark-hook}.  Otherwise, it does nothing.
@end defun

@defvar mark-active
The mark is active when this variable is non-@code{nil}.  This variable is
always buffer-local in each buffer.  Do @emph{not} use the value of this
variable to decide whether a command that normally operates on text near
point should operate on the region instead.  Use the function
@code{use-region-p} for that (@pxref{The Region}).
@end defvar

@defvar activate-mark-hook
@defvarx deactivate-mark-hook
These normal hooks are run, respectively, when the mark becomes active and
when it becomes inactive.  The hook @code{activate-mark-hook} is also run at
the end of the command loop if the mark is active and it is possible that
the region may have changed.
@ignore
This piece of command_loop_1, run unless deactivating the mark:
  if (current_buffer != prev_buffer || MODIFF != prev_modiff)
    {
      Lisp_Object hook = intern ("activate-mark-hook");
      Frun_hooks (1, &hook);
    }
@end ignore
@end defvar

@defun handle-shift-selection
This function implements the ``shift-selection'' behavior of point-motion
commands.  @xref{Shift Selection,,, emacs, The GNU Emacs Manual}.  It is
called automatically by the Emacs command loop whenever a command with a
@samp{^} character in its @code{interactive} spec is invoked, before the
command itself is executed (@pxref{Interactive Codes, ^}).

If @code{shift-select-mode} is non-@code{nil} and the current command was
invoked via shift translation (@pxref{Key Sequence Input,
shift-translation}), this function sets the mark and temporarily activates
the region, unless the region was already temporarily activated in this
way.  Otherwise, if the region has been activated temporarily, it
deactivates the mark and restores the variable @code{transient-mark-mode} to
its earlier value.
@end defun

@defvar mark-ring
The value of this buffer-local variable is the list of saved former marks of
the current buffer, most recent first.

@example
@group
mark-ring
@result{} (#<marker at 11050 in markers.texi>
    #<marker at 10832 in markers.texi>
    @dots{})
@end group
@end example
@end defvar

@defopt mark-ring-max
The value of this variable is the maximum size of @code{mark-ring}.  If more
marks than this are pushed onto the @code{mark-ring}, @code{push-mark}
discards an old mark when it adds a new one.
@end defopt

@c There is also global-mark-ring-max, but this chapter explicitly
@c does not talk about the global mark.

@node The Region
@section The Region
@c The index entry must be just ``region'' to make it the first hit
@c when the user types ``i region RET'', because otherwise the Info
@c reader will present substring matches in alphabetical order,
@c putting this one near the end, with something utterly unrelated as
@c the first hit.
@cindex region

  The text between point and the mark is known as @dfn{the region}.  Various
functions operate on text delimited by point and the mark, but only those
functions specifically related to the region itself are described here.

The next two functions signal an error if the mark does not point anywhere.
If Transient Mark mode is enabled and @code{mark-even-if-inactive} is
@code{nil}, they also signal an error if the mark is inactive.

@defun region-beginning
This function returns the position of the beginning of the region (as an
integer).  This is the position of either point or the mark, whichever is
smaller.
@end defun

@defun region-end
This function returns the position of the end of the region (as an
integer).  This is the position of either point or the mark, whichever is
larger.
@end defun

@c FIXME: Mention it in tips.texi?
  Instead of using @code{region-beginning} and @code{region-end}, a command
designed to operate on a region should normally use @code{interactive} with
the @samp{r} specification to find the beginning and end of the region.
This lets other Lisp programs specify the bounds explicitly as arguments.
@xref{Interactive Codes}.

@defun use-region-p
This function returns @code{t} if Transient Mark mode is enabled, the mark
is active, and there is a valid region in the buffer.  This function is
intended to be used by commands that operate on the region, instead of on
text near point, when the mark is active.

@cindex empty region
@vindex use-empty-active-region
A region is valid if it has a non-zero size, or if the user option
@code{use-empty-active-region} is non-@code{nil} (by default, it is
@code{nil}).  The function @code{region-active-p} is similar to
@code{use-region-p}, but considers all regions as valid.  In most cases, you
should not use @code{region-active-p}, since if the region is empty it is
often more appropriate to operate on point.
@end defun

