@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Modes
@chapter Major and Minor Modes
@cindex mode

  @dfn{モード(mode)}とは、Emacsをカスタマイズする定義のセットであり、編集時にオン/オフを切り替えることができます。モードには2つの種類があります。@dfn{メジャーモード(major
modes)}とは、互いに排他なモードであり、特定の種類のテキストの編集にたいして使用されます。@dfn{マイナーモード(minor
modes)}とは、ユーザーが個別に有効にすることができる機能を提供します。

  このチャプターでは、メジャーモード、およびマイナーモードを記述する方法、モードラインにそれらを示す方法、そしてそれらのモードがユーザーが提供するフックを実行する方法について説明します。キーマップ(keymaps)や構文テーブル(syntax
tables)のような関連するトピックについては@ref{Keymaps}および@ref{Syntax Tables}を参照してください。

@menu
* Hooks::                    フックの使い方と、フックを提供するコードの記述方法。
* Major Modes::              メジャーモードの定義。
* Minor Modes::              マイナーモードの定義。
* Mode Line Format::         モードラインに表示されるテキストのカスタマイズ。
* Imenu::                    バッファーで作成された定義のメニューを提供する。
* Font Lock Mode::           モードが構文に応じてテキストをハイライトする方法。
* Auto-Indentation::         メジャーモードにたいするインデントをEmacsに伝える方法。
* Desktop Save Mode::        Emacsセッション間でモードがバッファー状態を保存する方法。
@end menu

@node Hooks
@section Hooks
@cindex hooks

  @dfn{フック(hook)}とは、既存のプログラムから特定のタイミングで呼び出される関数(複数可)を格納することができる変数のことです。Emacsはカスタマイズ用にフックを提供します。ほとんどの場合は、initファイル内(@ref{Init
File}を参照)でフックをセットアップしますが、Lispプログラムもフックをセットできます。標準的なフック変数のリストは、@ref{Standard
Hooks}を参照してください。

@cindex normal hook
  Emacsのほとんどのフックは、@dfn{ノーマルフック(normal
hooks)}です。これらの変数は、引数なしで呼び出される、関数のリストを含んでいます。慣習により、フック名が@samp{-hook}で終わるフックは、そのフックがノーマルフックであることを意味します。わたしたちは、一貫した方法でフックを使用できるよう、すべてのフックが可能な限りノーマルフックとなるよう努力しています。

  すべてのメジャーモードコマンドは、初期化の最終ステップの1つとして、@dfn{モードフック(mode
hook)}と呼ばれるノーマルフックを実行するとみなされます。これにより、そのモードによりすでに作成されたバッファーローカル変数割り当てをオーバーライドすることにより、ユーザーがそのモードの動作をカスタマイズするのが簡単になります。ほとんどのマイナーモード関数も、最後にモードフックを実行します。しかし、フックは他のコンテキストでも使用されます。たとえばフック@code{suspend-hook}は、Emacsが自身をサスペンド(@ref{Suspending
Emacs}を参照)する直前に実行されます。

  フックにフック関数を追加するには、@code{add-hook}(@ref{Setting
Hooks}を参照)を呼び出す方法が推奨です。フック関数は、@code{funcall}(@ref{What Is a
Function}を参照)が受け入れる任意の種類の関数を指定できます。ほとんどのフック変数の初期値はvoidです。@code{add-hook}は、これを扱う方法を知っています。@code{add-hook}により、グローバルフック、またはバッファーローカルフックのどちらを追加することも可能です。

@cindex abnormal hook
  フック変数の名前が@samp{-hook}で終わらない場合は、それが恐らく@dfn{アブノーマルフック(abnormal
hook)}であることを示しています。こええは、フック関数が引数とともに呼ぶ出されること、または何らかの方法により、そのリターン値が使用されることを意味します。その関数の呼び出し方は、フックのドキュメントに記載されています。アブノーマルフックとして関数を追加するために@code{add-hook}を使用できますが、その関数はフック呼び出しの慣習にしたがって記述しななければなりません。慣習により、アブノーマルフックの名前は@samp{-functions}で終わります。

@cindex single-function hook
変数の名前が@samp{-function}で終わる場合、その値は関数のリストではなく単一の関数です。@code{add-hook}を、@emph{単一関数フック}のように修正して使用することはできないので、かわりに@code{add-function}を使用します(@ref{Advising
Functions}を参照)。

@menu
* Running Hooks::            フックの実行方法。
* Setting Hooks::            関数をフックに登録、削除する方法。
@end menu

@node Running Hooks
@subsection Running Hooks

  このセクションでは、ノーマルフックを実行するために使用される、@code{run-hooks}について説明します。また、さまざまな種類のアブノーマルフックを実行する関数についても説明します。

@defun run-hooks &rest hookvars
この関数は、引数として1つ以上のノーマルフック変数名をとり、各フックを順に実行する。引数はそれぞれ、ノーマルフック変数であるようなシンボルであること。これらの引数は、指定された順に処理される。

フック変数の値が非@code{nil}の場合、その値は関数のリストであること。@code{run-hooks}は、すべての関数を引数なしで1つずつ呼び出す。

フック変数の値には、単一の関数(ラムダ式、またはシンボルの関数定義)も指定でき、その場合@code{run-hooks}はそれを喚び出す。しかし、この使い方は時代遅れである。

フック変数がバッファーローカルな場合、グローバル変数のかわりにそのバッファーローカル変数が使用される。しかし、そのバッファーローカル変数が要素@code{t}を含む場合は、そのグローバルフック変数も同様に実行されるだろう。
@end defun

@defun run-hook-with-args hook &rest args
この関数は、@var{hook}内のすべての関数に、1つの引数@var{args}を渡して喚び出すことにより、アブノーマルフックを実行する。
@end defun

@defun run-hook-with-args-until-failure hook &rest args
この関数は、各フック関数を順に呼び出すことによりアブノーマルフック関数を実行し、それらのうち1つが@code{nil}をリターンして``失敗''したときは停止する。それぞれのフック関数は、引数に@var{args}を渡される。この関数は、フック関数の1つが失敗して停止した場合は@code{nil}、それ以外は非@code{nil}値をリターンする。
@end defun

@defun run-hook-with-args-until-success hook &rest args
この関数は、各フック関数を順に呼び出すことによりアブノーマルフック関数を実行し、それらのうち1つが非@code{nil}値をリターンして``成功''したときは停止する。それぞれのフック関数は、引数に@var{args}を渡される。この関数は、フック関数の1つが失敗して停止した場合はその値を、それ以外は@code{nil}をリターンする。
@end defun

@node Setting Hooks
@subsection Setting Hooks

  以下は、Lisp Interactionモードのときに、モードフックを使用してAuto Fillモードをオンに切り替える例です:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
この関数は、フック変数に関数@var{function}を追加する手軽な方法である。ノーマルフックと同じように、アブノーマルフックにたいしてもこの関数を使用できる。@var{function}には、正しい数の引数を受け付ける任意のLisp関数を指定できる。たとえば、

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
は、@code{text-mode-hook}と呼ばれるフックに@code{my-text-hook-function}を追加する。

@var{hook}内に@var{function}がすでに存在する場合(比較には@code{equal}を使用)、@code{add-hook}は2回目の追加を行わない。

@var{function}のプロパティ@code{permanent-local-hook}が非@code{nil}の場合、@code{kill-all-local-variables}(またはメジャーモードを変更しても)、そのフック変数のローカル値から関数を削除しない。

ノーマルフックにたいして、フック関数は実行される順序に無関係であるようにデザインされるべきである。順序への依存は、トラブルを招く。とはいえ、その順序は予測可能である。通常、@var{function}はフックリストの先頭に追加されるので、(他の@code{add-hook}呼び出しがなければ)それは最初に実行される。オプション引数@var{append}が非@code{nil}の場合、新たなフック関数はフックリストの最後に追加され、実行されるのも最後になる。

@code{add-hook}は、@var{hook}がvoidのとき、または値が単一の関数の場合、値を関数リストにセットまたは変更して、それらを扱うことができる。

@var{local}が非@code{nil}の場合、それはグローバルフックリストではなくバッファーローカルフックリストに@var{function}を追加する。これはフックをバッファーローカルにして、そのバッファーローカルな値に@code{t}を追加する。バッファーローカルな値への@code{t}の追加は、ローカル値と同じようにデフォルト値でもフック関数を実行するためのフラグである。
@end defun

@defun remove-hook hook function &optional local
この関数は、フック変数@var{hook}から@var{function}を削除する。これは、@code{equal}を使用して@var{function}と@var{hook}要素を比較するので、その比較はシンボルとラムダ式の両方で機能する。

@var{local}が非@code{nil}の場合、それはグローバルフックリストではなく、バッファーローカルフックリストから@var{function}を削除する。
@end defun

@node Major Modes
@section Major Modes
@cindex major mode

@cindex major mode command
  メジャーモードは特定の種類のテキスト編集にEmacsを特化します。すべてのバッファーは1度に1つのメジャーモードをもちます。すべてのメジャーモードは、@dfn{メジャーモードコマンド(major
mode
command)}に関連付けられ、そのコマンド名は@samp{-mode}で終わるべきです。このコマンドは、ローカルキーマップのようなさまざまなバッファーローカル変数をセットすることにより、カレントバッファーないでそのモードに切り替える配慮をします。@ref{Major
Mode Conventions}を参照してください。

  @dfn{Fundamentalモード}と呼ばれるはもっとも特化されていないメジャーモードであり、モード特有な定義や変数セッティングをもちません。

@deffn Command fundamental-mode
これは、Fundamentalモードにたいするメジャーモードコマンドである。他のモードコマンドと異なり、このモードはカスタマイズしてはならないことになっているので、モードフックは何も実行@emph{されない}(@ref{Major
Mode Conventions}を参照)。
@end deffn

  メジャーモードを記述するもっとも簡単な方法は、マクロ@code{define-derived-mode}を使用する方法です。これは、既存のメジャーモードを変形して、新たなモードをセットアップします。@ref{Derived
Modes}を参照してください。@code{define-derived-mode}は多くのコーディング規約を自動的に強要するので、たとえ新たなモードが他のモードから明示的に派生されない場合でも、わたしたちは@code{define-derived-mode}の使用を推奨します。派生元とするための一般的なモードについては、@ref{Basic
Major Modes}を参照してください。

  標準的なGNU
EmacsのLispディレクトリーツリーには、いくつかのメジャーモードが@file{text-mode.el}、@file{texinfo.el}、@file{lisp-mode.el}、@file{rmail.el}のようなファイルとして含まれています。モードの記述方法を確認するために、これらのライブラリーを学ぶことができます。

@defopt major-mode
この変数のバッファーローカル値は、カレントのメジャーモードにたいするシンボルを保持する。この変数のデフォルト値は、新たなバッファーにたいするデフォルトのメジャーモードを保持する。標準的なデフォルト値は、@code{fundamental-mode}である。

デフォルト値が@code{nil}の場合、@kbd{C-x
b}(@code{switch-to-buffer})のようなコマンドを通じてEmacsが新たなバッファーを作成したとき、新たなバッファーは以前カレントだったバッファーのメジャーモードになる。例外として、以前のバッファーのメジャーモードのシンボルプロパティ@code{mode-class}が値@code{special}をもつ場合、新たなバッファーはFundamentalモードになる(@ref{Major
Mode Conventions}を参照)。
@end defopt

@menu
* Major Mode Conventions::   キーマップなどにたいするコーディング規約。
* Auto Major Mode::          Emacsが自動的にメジャーモードを選択する方法。
* Mode Help::                モードの使用方法の探し方。
* Derived Modes::            他のメジャーモードにもとづき新たなメジャーモードを定義する。
* Basic Major Modes::        他のモードからよく派生元とさｒｗるモード。
* Mode Hooks::               メジャーモード関数の最後に実行されるフック。
* Tabulated List Mode::      表形式データを含むバッファーにたいする親モード。
* Generic Modes::            コメント構文とFont 
                               Lockモードをサポートするシンプルなメジャーモードの定義。
* Example Major Modes::      TextモードとLispモード。
@end menu

@node Major Mode Conventions
@subsection Major Mode Conventions
@cindex major mode conventions
@cindex conventions for writing major modes

  メジャーモードにたいするすべてのコードはさまざまなコーディング規約にしたがうべきであり、それらの規約にはローカルキーマップおよび構文テーブルの初期化、関数名や変数名、フックにたいする規約が含まれます。

  @code{define-derived-mode}マクロを使用した場合は、これらの規約を自動的に配慮します。@ref{Derived
Modes}を参照してください。Fundamentalモードは、Emacsのデフォルト状態を表すモードなにで、これらの規約が当てはまらないことに注意してください。

  以下の規約リストは、ほんの一部です。一般的に、すべてのメジャーモードは、Emacs全体が首尾一貫するよう、他のEmacsメジャーモードとの一貫性を目指すべきです。ここで、この問題を洗い出すすべての想定される要点をリストするのは不可能です。Emacs開発者が、自身の開発するメジャーモードが通常の規約を逸脱する領域を示す場合は、互換性を保つようにしてください。

@itemize @bullet
@item
名前が@samp{-mode}で終わるようにメジャーモードコマンドを定義する。引数なしで呼び出されたとき、このコマンドはキーマップ、構文テーブル、既存バッファーのバッファーローカル変数をセットアップして、カレントバッファーを新たなモードに切り替えるべきである。そのバッファーのコンテンツを変更するべきではない。

@item
そのモードで利用できる特別なコマンドを説明するドキュメント文字列を記述する。@ref{Mode Help}を参照のこと。

そのユーザー自身のキーバインディングに自動的に適合してヘルプが表示されるように、ドキュメント文字列に特別なドキュメントサブストリング@samp{\[@var{command}]}、@samp{\@{@var{keymap}@}}、@samp{\<@var{keymap}>}を含めるとよいかもしれない。@ref{Keys
in Documentation}を参照のこと。

@item
メジャーモードコマンドは、@code{kill-all-local-variables}を呼び出すことにより開始するべきである。これは、ノーマルフック@code{change-major-mode-hook}を実行してから、前のメジャーモードで効力のあったバッファーローカル変数を解放する。@ref{Creating
Buffer-Local}を参照のこと。

@item
メジャーモードコマンドは、変数@code{major-mode}にメジャーモードコマンドのシンボルをセットするべきである。これは、@code{describe-mode}がプリントするドキュメントを探す手掛かりとなる。

@item
メジャーモードコマンドは、変数@code{mode-name}にそのモードの``愛称(pretty
name)''をセットするべきである(これは通常は文字列だが、他の利用可能な形式は、@ref{Mode Line
Data}を参照のこと)。このモード名は、モードラインに表示される。

@item
@cindex functions in modes
すべてのグローバル名は同じネームスペースにあるので、モードの一部であるようなすべてのグローバルな変数、定数、関数は、メジャーモード名(メジャーモード名が長いようなら短縮名)で始まる名前をもつべきである。@ref{Coding
Conventions}を参照のこと。

@item
プログラム言語のような、ある種の構造型テキストを編集するためのメジャーモードでは、その構造に応じたテキストのインデントはおそらく有用であろう。したがって、そのようなモードは@code{indent-line-function}に適切な関数をセットするとともに、インデント用のその他の変数をカスタマイズすべきだろう。

@item
@cindex keymaps in modes
メジャーモードは通常、そのモードにあるすべてのバッファーのローカルキーマップとして使用される、自モード身のキーマップをもつべきである。メジャーモードコマンドは、そのローカルマップをインストールするために、@code{use-local-map}を呼び出すべきである。詳細は、@ref{Active
Keymaps}を参照のこと。

このキーマップは、@code{@var{modename}-mode-map}という名前のグローバル変数に永続的に格納されるべきである。通常、そのモードを定義するライブラリーは、この変数をセットする。

モード用のキーマップ変数をセットアップするコードの記述する方法に関するアドバイスは、@ref{Tips for Defining}を参照のこと。

@item
メジャーモードのキーマップ内でバインドされるキーシーケンスは、通常は@kbd{C-c}で始まり、その後にコントロール文字、数字、@kbd{@{}、@kbd{@}}、@kbd{<}、@kbd{>}、@kbd{:}、@kbd{;}が続くべきである。その他の記号文字(punctuation
characters)はマイナーモードに、通常のアルファベット文字はユーザーのために予約されている。

メジャーモードは@kbd{M-n}、@kbd{M-p}、@kbd{M-s}などのキーもリバインドできる。@kbd{M-n}と@kbd{M-p}にたいするバインディングは、通常は
``前方あるいは後方への移動''を意味するような類のものであるべきだが、これは必ずしもカーソル移動を意味する必要はない。

そのモードにより適した方法でテキストに``同じ処理''を行うコマンドを提供する場合に、メジャーモードが標準的なキーシーケンスをリバインドするのは正当性がある。たとえば、プログラム言語を編集するためのメジャーモードは、その言語にとって``関数の先頭に移動する''がより良く機能する方法で、@kbd{C-M-a}を再定義するかもしれない。

ある標準的なキーシーケンスの標準的な意味が、そのモードではほとんど役に立たないような場合にも、メジャーモードが標準的なキーシーケンスをリバインドする正当性がある。たとえば、ミニバッファーモードは、@kbd{M-r}の標準的な意味はミニバッファーではほとんど使用されないので、このキーシーケンスをリバインドする。テキストの自己挿入を許さないDiredやRmailのようなメジャーモードは、アルファベット文字や、その他のプリント文字を特別なコマンドに再定義する正当性がある。

@item
テキストを編集するメジャーモードは、改行の挿入以外の何かに@key{RET}を定義すべきではない。しかし、ユーザーが直接テキストを編集しない、DiredやInfoのような特別なモードにたいしては、完全に異なることを行うように@key{RET}を再定義しても構わない。

@item
メジャーモードは、たとえばAuto-Fillモードを有効にするか等の、主にユーザーの好みに関するオプションを変更すべきではない。それらのオプションは、ユーザーに選択に任せること。ただし、@emph{もし}ユーザーがAuto-Fillモードを使用すると決定した場合には、それが便利に機能するように、他の変数をカスタマイズすべきである。

@item
@cindex syntax tables in modes
モードは自身の構文テーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身の構文テーブルをもつ場合は、@code{@var{modename}-mode-syntax-table}という名前の変数にそれを格納すべきである。@ref{Syntax
Tables}を参照のこと。

@item
コメントにたいして構文をもつ言語を扱うモードは、コメント構文を定義する変数をセットすべきである。@ref{Options for Comments,,
Options Controlling Comments, emacs, The GNU Emacs Manual}を参照のこと。

@item
@cindex abbrev tables in modes
モードは自身のabbrevテーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身のabbrevテーブルをもつ場合は、@code{@var{modename}-mode-abbrev-table}という名前の変数にそれを格納すべきである。メジャーモードコマンドが自身で何らかのabbrevを定義する場合は、@code{define-abbrev}の@var{system-flag}引数に@code{t}を渡すべきである。@ref{Defining
Abbrevs}を参照のこと。

@item
モードは、変数@code{font-lock-defaults}にバッファーローカルな値をセットすることにより、Font
Lockモードにたいしてハイライトする方法を指定すべきである(@ref{Font Lock Mode}を参照)。

@item
モードが定義するすべてのフェイスは、もし可能なら既存のEmacsフェイスを継承すべきである。@ref{Basic Faces}と@ref{Faces
for Font Lock}を参照のこと。

@item
モードは変数@code{imenu-generic-expression}、変数@code{imenu-prev-index-position-function}
and
@code{imenu-extract-index-name-function}、または変数@code{imenu-create-index-function}にバッファーローカルな値をセットすることにより、Imenuがバッファー内の定義、またはセクションを探す方法を指定すべきである(@ref{Imenu}を参照)。

@item
モードは、@code{eldoc-documentation-function}にローカル値を指定して、ElDocモードがそのモードを処理する方法を指定できる。

@item
モードは、スペシャルフック@code{completion-at-point-functions}に1つ以上のバッファーローカルエントリーを追加することにより、さまざまなキーワードの補完方法を指定できる。@ref{Completion
in Buffers}を参照のこと。

@item
@cindex buffer-local variables in modes
Emacsのカスタマイズ変数にたいしてバッファーローカルなバインディングを作成するには、@code{make-variable-buffer-local}ではなく、メジャーモードコマンド内で@code{make-local-variable}を使用すること。関数、@code{make-variable-buffer-local}は、それ以降にカスタマイズ変数をセットするすべてのバッファーにたいしてその変数をローカルにし、そのモードを使用しないバッファーにたいしても影響があるだろう。そのようなグローバルな効果は、モードにとって好ましくない。@ref{Buffer-Local
Variables}を参照のこと。

稀な例外として、Lispパッケージ内で@code{make-variable-buffer-local}を使用する唯一の正当な方法は、そのパッケージ内でのみ使用される変数にたいして使用をする場合である。他のパッケージにより使用される変数にたいしてこの関数を使用すると、干渉が起こるだろう。

@item
@cindex mode hook
@cindex major mode hook
すべてのメジャーモードは、@code{@var{modename}-mode-hook}という名前のノーマルな@dfn{モードフック(mode
hook)}をもつべきである。メジャーモードコマンドが一番最後に行うべきことは、@code{run-mode-hooks}の呼び出しである。これは、ノーマルフック@code{change-major-mode-after-body-hook}、モードフック、その後に@code{after-change-major-mode-hook}を実行する。@ref{Mode
Hooks}を参照のこと。

@item
メジャーモードコマンドは、@dfn{親モード(parent
mode)}と呼ばれる他のいくつかのメジャーモードを呼び出すことにより開始されるかもしれず、それらのセッティングのいくつかを変更するかもしれない。これを行うモードは、@dfn{派生モード(derived
mode)}と呼ばれる。派生モードを定義する推奨方法は、@code{define-derived-mode}マクロの使用であるが、これは必須ではない。そのようなモードは、@code{delay-mode-hooks}フォーム内で親のモードコマンドを呼び出すべきである(@code{define-derived-mode}は自動的にこれを行う)。@ref{Derived
Modes}、および@ref{Mode Hooks}を参照のこと。

@item
ユーザーが、そのモードのバッファーから他のモードのバッファーに切り替える際に特別な何かを行う必要がある場合、モードは@code{change-major-mode-hook}にたいしてバッファーローカル値をセットアップできる(@ref{Creating
Buffer-Local}を参照)。

@item
そのモードが、(ユーザーがキーボードでタイプしたテキストや、外部ファイルのテキストではなく)モード自身が生成する特別に用意されたテキストにたいしてのみ適す場合、メジャーモードコマンドのシンボルは、以下のように@code{mode-class}という名前のプロパティに値@code{special}をputすべきである:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
これはEmacsにたいして、カレントバッファーがFunnyモードのときに新たなバッファーを作成したとき、たとえ@code{major-mode}のデフォルト値が@code{nil}であっても、そのバッファーをFunnyモードにしないよう指示する。デフォルトでは、@code{major-mode}にたいする値@code{nil}は、新たなバッファー作成時にカレントバッファーのメジャーモードを使用することを意味するが(@ref{Auto
Major
Mode}を参照)、@code{special}なモードにたいしてはかわりにFundamentalモードが使用される。Dired、Rmail、Buffer
Listのようなモードは、この機能を使用する。

関数@code{view-buffer}は、mode-classがspecialであるようなバッファーではViewモードを有効にしない。そのようなモードは、通常は自身でViewに相当するバインディングを提供するからである。

@code{define-derived-mode}マクロは、親モードがspecialの場合は、自動的に派生モードをspecialにマークする。親モードでspecialモードが有用なら、それを継承したモードでもであろう。@ref{Basic
Major Modes}を参照のこと。

@item
新たなモードを、識別可能な特定のファイルにたいするデフォルトとしたい場合は、そのようなファイル名にたいしてそのモードを選択するために、@code{auto-mode-alist}に要素を追加する。autoload用にモードコマンドを定義する場合は、@code{autoload}を呼び出すのと同じファイル内にその要素を追加すべきである。モードコマンドにたいしてautoload
cookieを使用する場合は、その要素を追加するフォームにたいしてもautoload cookieを使用できる(@ref{autoload
cookie}を参照)。モードコマンドをautoloadしない場合は、モード定義を含むファイル内で要素を追加すれば十分である。

@item
@cindex mode loading
悪影響を与えることなく1回以上評価されるように、モード定義はファイル内のトップレベルのフォームとして記述すべきである。たとえば、すでに値をもつ変数が再初期化されないように、モードに関連した変数をセットするときは、@code{defvar}か@code{defcustom}を使用する(@ref{Defining
Variables}を参照)。

@end itemize

@node Auto Major Mode
@subsection How Emacs Chooses a Major Mode
@cindex major mode, automatic selection

  ファイルをvisitするとき、ファイル名やファイル自体の内容などの情報を元に、Emacsはそのバッファーにたいするメジャーモードを選択します。また、ファイルのテキスト内で指定されたローカル変数も処理します。

@deffn Command normal-mode &optional find-file
この関数は、カレントバッファーにたいして適切なメジャーモードと、バッファーローカル変数のバインディングを設定する。これはまず@code{set-auto-mode}(以下参照)を呼び出し、その後に@code{hack-local-variables}を実行してパース処理を行って、そのファイルのローカル変数(@ref{File
Local Variables}を参照)を適切にバインド、または評価する。

@code{normal-mode}の@var{find-file}引数が非@code{nil}の場合、@code{normal-mode}は@code{find-file}関数が自身を呼び出したとみなす。この場合、@code{normal-mode}はそのファイル内の@samp{-*-}行の、またはファイルの最後にあるローカル変数を処理するかもしれない。これを行うかどうかは、変数@code{enable-local-variables}が制御する。ファイルのローカル変数セクションの構文は、@xref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照のこと。

インタラクティブに@code{normal-mode}を実行した場合、引数@var{find-file}は通常@code{nil}である。この場合、@code{normal-mode}は無条件に任意のファイルローカル変数を処理する。

この関数は、メジャーモードを選択するために@code{set-auto-mode}を呼び出す。この関数がモードを特定しない場合、そのバッファーの@code{major-mode}(以下参照)のデフォルト値により決定されるメジャーモードに留まる。

@cindex file mode specification error
@code{normal-mode}は、メジャーモードコマンド呼び出しの周囲に@code{condition-case}を使用するので、エラーはcatchされて、@samp{File
mode specification error}とともに、元のエラーメッセージがその後に報告される。
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
  この関数は、カレントバッファーにたいして適切なメジャーモードを選択する。この選択は、関数自身の(優先順位による)決定にもとづく。優先順位は、@w{@samp{-*-}}行、ファイル終端近傍の任意の@samp{mode:}ローカル変数、@w{@samp{#!}}行(@code{interpreter-mode-alist}を使用)、バッファーの先頭のテキスト(@code{magic-mode-alist}を使用)、最後がvisitされるファイル名(@code{auto-mode-alist}を使用)の順である。@ref{Choosing
Modes, , How Major Modes are Chosen, emacs, The GNU Emacs
Manual}を参照のこと。@code{enable-local-variables}が@code{nil}の場合、@code{set-auto-mode}は@w{@samp{-*-}}行、およびファイル終端近傍にたいして、modeタグのチェックを何もしない。

@vindex inhibit-local-variables-regexps
モード特定のためにファイル内容をスキャンするのがふさわしくないファイルタイプがいくつかある。たとえば、tarアーカイブファイルの終わり付近に、特定のファイルにたいしてモードを指定するローカル変数セクションをもつアーカイブメンバーファイルが、たまたま含まれているかもしれない。これは、そのファイルを含むtarファイルに適用されるべきではないだろう。同様に、tiffイメージファイルが、@w{@samp{-*-}}パターンにマッチするように見える行を、最初の行に偶然含むかもしれない。これらの理由により、これらのファイル拡張子はどちらも@code{inhibit-local-variables-regexps}リストのメンバーになっている。Emacsが、(モード指定に限らず)ファイルから任意の種類のローカル変数を検索することを防ぐには、このリストにパターンを追加する。

@var{keep-mode-if-same}が非@code{nil}の場合は、すでにそのバッファーが適切なメジャーモードをもつとき、この関数はモードコマンドを呼び出さない。たとえば@code{set-visited-file-name}は、ユーザーがセットしたかもしれないバッファーローカル変数をkillするのを防ぐために、これを@code{t}にセットする。
@end defun

@defun set-buffer-major-mode buffer
この関数は、@var{buffer}のメジャーモードを、@code{major-mode}のデフォルト値にセットする。@code{major-mode}が@code{nil}の場合は、(それが適切なら)カレントバッファーのメジャーモードを使用する。例外として、@var{buffer}の名前が@file{*scratch*}の場合は、モードを@code{initial-major-mode}にセットする。

バッファーを作成する低レベルのプリミティブはこの関数を使用しないが、@code{switch-to-buffer}や@code{find-file-noselect}のような中位レベルのコマンドは、バッファーを作成するときは、常にこの関数を使用する。
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
この変数の値は、@file{*scratch*}バッファーの初期のメジャーモードを決定する。値は、メジャーモードコマンドであるようなシンボルであること。デフォルト値は@code{lisp-interaction-mode}である。
@end defopt

@defvar interpreter-mode-alist
この変数は、@samp{#!}行内のコマンドインタープリターを指定するスクリプトにたいして使用するメジャーモードを指定する。変数の値は、@code{(@var{regexp}
.
@var{mode})}の形式の要素をもつalistである。これは、そのファイルが@code{\\`@var{regexp}\\'}にマッチするインタープリターを指定する場合は、@var{mode}を使用することを意味する。たとえば、デフォルト要素の1つは@code{("python[0-9.]*"
. python-mode)}である。
@end defvar

@defvar magic-mode-alist
この変数の値は、@code{(@var{regexp}
@var{function})}という形式の要素をもつalistである。ここで、@var{regexp}は正規表現、@var{function}は関数、または@code{nil}である。ファイルをvisitした後に、バッファーの先頭のテキストが@var{regexp}にマッチした場合、@var{function}が非@code{nil}なら@code{set-auto-mode}は@var{function}を呼び出す。@var{function}が@code{nil}の場合は、@code{auto-mode-alist}がモードを決定する。
@end defvar

@defvar magic-fallback-mode-alist
これは@code{magic-mode-alist}と同様に機能するが、そのファイルにたいして@code{auto-mode-alist}がモードを指定しない場合だけ処理される点が異なる。
@end defvar

@defvar auto-mode-alist
この変数は、ファイル名パターン(正規表現)と対応するメジャーモードコマンドの連想配列を含む。通常、ファイル名パターンは、@samp{.el}や@samp{.c}のようなサフィックスをテストするが、必須ではない。このalistの通常の要素は@code{(@var{regexp}
.  @var{mode-function})}のようになる。

たとえば、

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

バージョン番号およびバックアップ用サフィックスをもつファイルをvisitしたとき、それらは@code{file-name-sans-versions}(@ref{File
Name Components}を参照)を使用して展開されたファイル名(@ref{File Name
Expansion}を参照)から取り除かれて@var{regexp}とマッチされて、@code{set-auto-mode}は対応する@var{mode-function}を呼び出す。この機能により、ほとんどのファイルにたいしてEmacsが適切なメジャーモードを選択することが可能になる。

@code{auto-mode-alist}の要素が@code{(@var{regexp} @var{function}
t)}という形式の場合は、@var{function}を呼び出した後、Emacsは前回マッチしなかったファイル名部分にたいしてマッチするために、再度@code{auto-mode-alist}を検索する。この機能は、圧縮されたパッケージにたいして有用である。@code{("\\.gz\\'"
@var{function}
t)}という形式のエントリーは、ファイルを解凍してから、@samp{.gz}抜きのファイル名にたいして適切なモードに解凍されたファイルを配す。

以下は@code{auto-mode-alist}の先頭に、複数のパターンペアーを追加する方法の例である(あなたは、initファイル内でこの種の式を使ったことがあるかもしれない)。

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{ドットで始まる(ディレクトリー名付きの)ファイル名}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{ドットのないファイル名}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{@samp{.C}で終わるファイル名}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@subsection Getting Help about a Major Mode
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode

  @code{describe-mode}関数は、メジャーモードに関する情報を提供します。これは通常、@kbd{C-h
m}にバインドされています。この関数は、変数@code{major-mode}(@ref{Major
Modes}を参照)の値を使用します。すべてのメジャーモードがこの変数をセットする必要があるのは、これが理由です。

@deffn Command describe-mode &optional buffer
このコマンドは、カレントバッファーのメジャーモードとマイナーモードのドキュメントを表示する。この関数は、メジャーモードおよびマイナーモードのコマンドのドキュメント文字列を取得するために、@code{documentation}関数を使用する(@ref{Accessing
Documentation}を参照)。

@var{buffer}引数に非@code{nil}を指定してLispから呼び出された場合、この関数はカレントバッファーではなく、そのバッファーのメジャーモードとマイナーモードのドキュメントを表示する。
@end deffn

@node Derived Modes
@subsection Defining Derived Modes
@cindex derived mode

  新しいメジャーモードを定義する推奨された方法は、@code{define-derived-mode}を使用して既存のメジャーモードから派生させる方法です。それほど近いモードが存在しない場合は@code{text-mode}、@code{special-mode}、または@code{prog-mode}から継承するべきです。@ref{Basic
Major
Modes}を参照してください。これらがどれも適切でない場合は、@code{fundamental-mode}から継承することができます(@ref{Major
Modes}を参照)。

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
このマクロは、@var{variant}をメジャーモードコマンドとして定義し、@var{name}をモード名の文字列形式とする。@var{variant}と@var{parent}は、クォートされていないシンボルであること。

新たなコマンド@var{variant}は、関数@var{parent}を呼び出すよう定義され、その後その親モードの特定の性質をオーバーライドする。

@itemize @bullet
@item
新たなモードは、@code{@var{variant}-map}という名前の、自身のsparseキーマップ(疎キーマップ)をもつ。@code{define-derived-mode}は、@code{@var{variant}-map}がすでにセットされていて、かつすでに親をもつ場合を除き、親モードのキーマップを新たなマップの親キーマップにする。

@item
新たなモードは、自身の構文テーブル(syntax
table)をもち、それは変数@code{@var{variant}-syntax-table}に保持される。ただし、@code{:syntax-table}キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。@code{define-derived-mode}は、@code{@var{variant}-syntax-table}がすでにセットされていて、かつ標準的な構文テーブルよ異なる親をもつ場合を除き、ペアレントモードの構文テーブルを@code{@var{variant}-syntax-table}の親とする。

@item
新たなモードは、自身のabbrevテーブル(略語テーブル)をもち、それは変数@code{@var{variant}-abbrev-table}に保持される。ただし、@code{:abbrev-table}キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。

@item
新たなモードは、自身のモードフック@code{@var{variant}-hook}をもつ。これは、このフックを実行した後に、最後に@code{run-mode-hooks}により、自身の祖先のモードのフックを実行する。
@end itemize

これらに加えて、@var{body}で@var{parent}のその他の性質をオーバーライドする方法を指定できます。コマンド@var{variant}はー、通常のオーバーライドをセットアップした後、そのモードのフックを実行する直前に@var{body}内のフォームを評価します。

@var{parent}が非@code{nil}の@code{mode-class}シンボルプロパティをもつ場合、@code{define-derived-mode}は@var{variant}の@code{mode-class}プロパティに、同じ値をセットします。これは、たとえば@var{parent}がspecialモードの場合は、@var{variant}もspecialモードになることを保証します(@ref{Major
Mode Conventions}を参照)。

@var{parent}にたいして@code{nil}を指定することもできます。これにより、新たなモードは親をもたなくなります。その後、@code{define-derived-mode}は上述のように振る舞いますが、当然@var{parent}につながるすべてのアクションは省略されます。

引数@var{docstring}は、新たなモードにたいするドキュメント文字列を指定します。@code{define-derived-mode}は、このドキュメント文字列の最後にそのモードフックに関する一般的な情報と、その後にそのモードのキーマップを追加します。@var{docstring}を省略した場合は、@code{define-derived-mode}がドキュメント文字列を生成します。

@var{keyword-args}は、キーワードと値のペアーです。値は評価されます。現在、以下のキーワードがサポートされています:

@table @code
@item :syntax-table
新たなモードにたいする構文テーブルを明示的に指定するために、これを使用できる。@code{nil}値を指定した場合、新たなモードは@var{parent}と同じ構文テーブル、@var{parent}も@code{nil}の場合は標準的な構文テーブルを使用する(これは、@code{nil}値の非キーワード引数は引数を指定しないのと同じという通常の慣習には@emph{したがわない}ことに注意されたい)。

@item :abbrev-table
新たなモードにたいするabbrevテーブルを明示的に指定するために、これを使用できる。@code{nil}値を指定した場合、新たなモードは@var{parent}と同じabbrevテーブル、@var{parent}も@code{nil}の場合は、@code{fundamental-mode-abbrev-table}を使用する(繰り返すが、@code{nil}値はこのキーワードを指定しないことでは@emph{ない})。

@item :group
これが指定された場合、値はそのモードにたいするカスタマイズグループ(customization
group)であること(すべてのメジャーモードがカスタマイズグループをもつ訳ではない)。(まだ実験的かつ未公表だが)現在のところ、これを使用するのは@code{customize-mode}コマンドだけである。@code{define-derived-mode}は、指定されたカスタマイズグループを自動的に定義@emph{しない}。
@end table

以下は架空の例である:

@example
(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "ハイパーテキスト用のメジャーモード
\\@{hypertext-mode-map@}"
  (setq case-fold-search nil))

(define-key hypertext-mode-map
  [down-mouse-3] 'do-hyper-link)
@end example

@code{define-derived-mode}が自動的に行うので、この定義内に@code{interactive}指定を記述してはならない。
@end defmac

@defun derived-mode-p &rest modes
この関数は、シンボル@var{modes}で与えられたメジャーモードのいずれかから、カレントメジャーモードが派生された場合は非@code{nil}をリターンする。
@end defun

@node Basic Major Modes
@subsection Basic Major Modes

  Fundamentalモードは別として、他のメジャーモードの一般的な派生元となるメジャーモードが3つあります。それはTextモード、Progモード、およびSpecialです。Textモードはその本来もつ機能から有用なモードです(たとえば@file{.txt}ファイルの編集など)。一方、ProgモードとSpecialモードは主にそのようなモード以外のモードの派生元として存在します。

@vindex prog-mode-hook
  新たなモードは、直接または間接を問わず、可能な限りれら3つのモードから派生させるべきです。その理由の1つは、関連のあるモードファミリー全体(たとえばすべてのプログラミング言語のモード)にたいして、ユーザーが単一のモードフックをカスタマイズできる空からです。

@deffn Command text-mode
Textモードは、人間の言語を編集するためのメジャーモードである。このモードは、文字@samp{"}および@samp{\}を区切り文字構文(punctuation
syntax: @ref{Syntax Class
Table}を参照)としてもち、@kbd{M-@key{TAB}}を@code{ispell-complete-word}にバインドする(@ref{Spelling,,,
emacs, The GNU Emacs Manual}を参照)。

Textモードから派生されたメジャーモードの例として、HTMLモードがある。@ref{HTML Mode,,SGML and HTML Modes,
emacs, The GNU Emacs Manual}を参照のこと。
@end deffn

@deffn Command prog-mode
Progモードは、プログラミング言語のソースコードを含むバッファーにたいする、基本的なメジャーモードである。Emacsビルトインのプログラミング言語用メジャーモードは、このモードから派生されている。

Progモードは、@code{parse-sexp-ignore-comments}を@code{t}(@ref{Motion via
Parsing}を参照)にバインドし、@code{bidi-paragraph-direction}を@code{left-to-right}(@ref{Bidirectional
Display}を参照)にバインドする。
@end deffn

@deffn Command special-mode
Specialモードは、ファイルから直接ではなく、Emacsにより特別(specially)に生成されたテキストを含むバッファーにたいする、基本的なメジャーモードである。Specialモードから派生されたメジャーモードは、@code{mode-class}プロパティに@code{special}ーが与えられる(@ref{Major
Mode Conventions}を参照)。

Specialモードは、バッファーを読み取り専用にセットする。このモードのキーマップは、いくつかの一般的なバインディングを定義し、それには@code{quit-window}にたいする@kbd{q}、@code{revert-buffer}(@ref{Reverting}を参照)にたいする@kbd{g}が含まれる。

Specialから派生されたメジャーモードの例としてはBuffer Menuモードがあり、これは@file{*Buffer
List*}バッファーにより使用される。@ref{List Buffers,,Listing Existing Buffers, emacs, The
GNU Emacs Manual}を参照のこと。
@end deffn

  これらに加えて、表形式データのバッファーにたいするモードはTabulated
Listモードから継承できます。このモードは、Specialモードから順に派生されているモードです。@ref{Tabulated List
Mode}を参照してください。

@node Mode Hooks
@subsection Mode Hooks

  すべてのメジャーモードコマンドは、モード独自のノーマルフック@code{change-major-mode-after-body-hook}、そのモードのモードフック、ノーマルフック@code{after-change-major-mode-hook}を実行することにより終了すべきです。これは、@code{run-mode-hooks}を呼び出すことにより行われます。もしそのモードが派生モードなら、自身のbody内で他のメジャーモード(親モード)を呼び出す場合は、親モードが自身でこれらのフックを実行しないように、@code{delay-mode-hooks}の中でこれを行うべきです。そのかわりに、派生モードは親のモードフックも実行する、@code{run-mode-hooks}を呼び出すのです。@ref{Major
Mode Conventions}を参照してください。

  Emacs 22より前のバージョンのEmacsには、@code{delay-mode-hooks}がありません。また、Emacs
24より前のバージョンには、@code{change-major-mode-after-body-hook}がありません。ユーザー実装のメジャーモードが@code{run-mode-hooks}を使用せず、これらの新しい機能を使用するようにアップデートされていないときは、これらのメジャーモードは以下の慣習に完全にしたがわないでしょう。それらのモードは、親のモードフックをあまりに早く実行したり、@code{after-change-major-mode-hook}の実行に失敗するかもしれません。そのようなメジャーモードに遭遇した場合は、以下の慣習にしたがって修正をお願いします。

  @code{define-derived-mode}を使用してメジャーモードを定義したときは、自動的にこれらの慣習にしたがうことが確実になります。@code{define-derived-mode}を使用せずにメジャーモードを``手動''で定義した場合は、これらの慣習を自動的に処理するように、以下の関数を使用してください。

@defun run-mode-hooks &rest hookvars
メジャーモード、この関数を使用してそれらのモードフックを実行すべきである。これは@code{run-hooks}(@ref{Hooks}を参照)と似ているが、@code{change-major-mode-after-body-hook}と@code{after-change-major-mode-hook}も実行する。

この関数が、@code{delay-mode-hooks}フォーム実行中に呼び出されたときは、それらのフックを即座には実行しない。かわりに、次の@code{run-mode-hooks}呼び出しでそれらを実行するようにアレンジする。
@end defun

@defmac delay-mode-hooks body@dots{}
あるメジャーモードコマンドが他のメジャーモードコマンドを呼び出すとき、それは@code{delay-mode-hooks}の内部で行われるべきである。

このマクロは@var{body}を実行するが、@var{body}実行中はすべての@code{run-mode-hooks}呼び出しにたいして、それらのフックの実行を遅延するよう指示する。それらのフックは、実際には@code{delay-mode-hooks}構造の最後の後、次の@code{run-mode-hooks}呼び出しの間に実行されるだろう。
@end defmac

@defvar change-major-mode-after-body-hook
これは、@code{run-mode-hooks}により実行されるノーマルフックである。これは、そのモードのフックの前に実行される。
@end defvar

@defvar after-change-major-mode-hook
これは、@code{run-mode-hooks}により実行されるノーマルフックである。これは、すべての適切に記述されたメジャーモードコマンドの一番最後に実行される。
@end defvar

@node Tabulated List Mode
@subsection Tabulated List mode
@cindex Tabulated List mode

  Tabulated
Listモードとは、表形式データ(@dfn{エントリー}から構成されるデータであり、各エントリーはそれぞれテキストの1行を占め、エントリーの内容は列に分割されるようなデータ)を表示するためのメジャーモードです。Tabulated
Listモードは、行列の見栄えよくプリントする機能、および各列の値に応じて行をソートする機能を提供します。これは、Specialモードから派生されたモードです(@ref{Basic
Major Modes}を参照)。

  Tabulated Listモードは、より特化したメジャーモードの親モードとして使用されることを意図しています。例としては、Process
Menuモード(@ref{Process Information}を参照)や、Package Menuモード(@ref{Package Menu,,,
emacs, The GNU Emacs Manual}を参照)が含まれます。

@findex tabulated-list-mode
  このような派生されたモードは、@code{tabulated-list-mode}を2つ目の引数に指定して、通常の方法で@code{define-derived-mode}を使用するべきです(@ref{Derived
Modes}を参照)。@code{define-derived-mode}フォームのbodyは、以下にドキュメントされている変数に値を割り当てることにより、表形式データのフォーマットを指定するべきです。その後、ヘッダー行を初期化するために関数@code{tabulated-list-init-header}を呼び出すべきです。

  派生されたモードは、@dfn{リスティングコマンド}も定義するべきです。これはモードコマンドではなく、(@kbd{M-x
list-processes}のように)ユーザーが呼び出すコマンドです。リスティングコマンドは、バッファーを作成または切り替えて、派生モードをオンにして、表形式データを指定し、最後にそのバッファーを事前設定(populate)するために@code{tabulated-list-print}を呼び出すべきです。

@defvar tabulated-list-format
このバッファーローカル変数は、表形式データのフォーマットを指定する。値はベクターで、ベクターの各要素はデータ列を表すリスト@code{(@var{name}
@var{width} @var{sort})}である。ここで

@itemize
@item
@var{name}は列の名前(文字列)。

@item
@var{width}は列にたいして予約される文字数幅(整数)。最終列は各行の終端までなので意味がない。

@item
@var{sort}は列によりエントリーをソートする方法を指定する。@code{nil}の場合、その列はソートに使用できない。@code{t}の場合は、列の文字列値を比較することによりソートされる。それ以外の場合は、@code{tabulated-list-entries}の要素と同じ形式の2つの引数をとる、@code{sort}にたいする述語関数(predicate
function)であること。
@end itemize
@end defvar

@defvar tabulated-list-entries
このバッファーローカル変数は、Tabulated Listバッファー内に表示されるエントリーを指定する。値にはリスト、または関数のいずれかであること。

値がリストの場合、各リスト要素は1つのエントリーに対応し、@w{@code{(@var{id}
@var{contents})}}という形式であること。ここで

@itemize
@item
@var{id}は@code{nil}、またはエントリーを識別するLispオブジェクト。Lispオブジェクトの場合には、エントリーを再ソートした際、カーソルは``同じ''エントリー上に留まる。比較は@code{equal}で行われる。

@item
@var{contents}は、@code{tabulated-list-format}と要素数が同じベクター。ベクター要素は文字列、またはリスト。文字列の場合は、バッファーにそのまま挿入される。リスト@code{(@var{label}
.
@var{properties})}の場合には、@var{label}と@var{properties}を引数として@code{insert-text-button}を呼び出すことにより、テキストボタンを挿入することを意味する(@ref{Making
Buttons}を参照)。

これらの文字列には、改行を含めるべきではない。
@end itemize

それ以外の場合、値は引数なしで呼び出され上記形式のリストをリターンする関数であること。
@end defvar

@defvar tabulated-list-revert-hook
このノーマルフックはTabulated
Listバッファーのリバートに先立ち実行される。派生モードは、@code{tabulated-list-entries}を再計算するために、このフックに関数を追加できる。
@end defvar

@defvar tabulated-list-printer
この変数の値は、ポイント位置にエントリー(エントリーを終端する改行を含む)を挿入するために呼び出される関数である。この関数は、@code{tabulated-list-entries}と同じ意味をもつ2つの引数@var{id}と@var{contents}を受け取る。デフォルト値は、エントリーをそのまま挿入する関数である。より複雑な方法によりTabulated
Listモードを使用するモードは、別の関数を指定できる。
@end defvar

@defvar tabulated-list-sort-key
この変数の値は、Tabulated
Listバッファーにたいするカレントのソートキーを指定する。@code{nil}の場合、ソートは行われていない。それ以外では、@code{(@var{name}
.
@var{flip})}という形式の値をもつ。ここで@var{name}は@code{tabulated-list-format}内の列目の1つとマッチする文字列、@var{flip}が非@code{nil}の場合は逆順でのソートを意味する。
@end defvar

@defun tabulated-list-init-header
この関数は、Tabulated
Listバッファーにたいする@code{header-line-format}を計算してセットし、列ヘッダー上でのクリックでソートを可能にするキーマップをヘッダー行に割り当てる。

Tabulated
Listから派生したモードは、上記の変数(特に@code{tabulated-list-format}をセットした後のみ)をセットした後にこれを呼び出すべきである。
@end defun

@defun tabulated-list-print &optional remember-pos
この関数は、カレントバッファーにエントリーを準備(populate)する。これはリスティングコマンドとして呼び出されるべきである。この関数は、バッファーを消去して@code{tabulated-list-entries}で指定されるエントリーを@code{tabulated-list-sort-key}にしたがってソートした後、各エントリーを挿入するために@code{tabulated-list-printer}で指定される関数を呼び出す。

オプション引数@var{remember-pos}が非@code{nil}の場合、この関数はカレント行で@var{id}要素を探して、もしあればすべてのエントリーを(再)挿入して、その後へそのエントリーの移動を試みる。
@end defun

@node Generic Modes
@subsection Generic Modes
@cindex generic mode

  @dfn{genericモード (generic mode:汎用モード))}とは、コメント構文にたいする基本的なサポートとFont
Lockモードをもつ、シンプルなメジャーモードです。genericモードを定義するには、マクロ@code{define-generic-mode}を使用します。@code{define-generic-mode}の使い方の例は、ファイル@file{generic-x.el}を参照してください。

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
このマクロは、@var{mode}(クォートされていないシンボル)という名前のgenericモードコマンドを定義する。オプション引数@var{docstring}は、そのモードコマンドにたいするドキュメント文字列である。これを与えない場合は、@code{define-generic-mode}がデフォルトのドキュメント文字列を生成する。

引数@var{comment-list}は、要素が文字、2文字以下の文字列、またはコンスセルである。文字か文字列の場合には、そのモードの構文テーブル内で``コメント開始識別子''としてセットアップされる。エントリーがコンスセルの場合、@sc{car}は``コメント開始識別子''、@sc{cdr}は``コメント終了識別子''としてセットアップされる(行末によりコメントを終端させたい場合は、後者に@code{nil}を使用する)。構文テーブルのメカニズムには、実際にコメントの開始および終了識別子に関する制限があることに注意されたい。
@ref{Syntax Tables}を参照のこと。

引数@var{keyword-list}は、@code{font-lock-keyword-face}でハイライトするキーワードのリストである。キーワードは文字列であること。一方、@var{font-lock-list}はハイライトするための追加の式リストである。このリストの各要素は、@code{font-lock-keywords}の要素と同じ形式をもつべきである。@ref{Search-based
Fontification}を参照のこと。

引数@var{auto-mode-list}は、変数@code{auto-mode-alist}に追加する正規表現のリストである。これらの式は、マクロ呼び出しの展開時ではなく、@code{define-generic-mode}の実行時に追加される。

最後に@var{function-list}は、追加セットアップのためにモードコマンドに呼び出される関数のリストである。これらの関数は、モードフック変数@code{@var{mode}-hook}の実行の直前に呼び出される。
@end defmac

@node Example Major Modes
@subsection Major Mode Examples

  Textモードは、Fundamentalを除き、おそらくもっともシンプルなモードです。上述した慣習の多くを説明するために、以下に@file{text-mode.el}の抜粋を示します:

@smallexample
@group
;; @r{このモード用に構文テーブルを作成}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; M-cで`hello'が`hello'でなく`Hello'になるよう`p'を追加
    (modify-syntax-entry ?' "w p" st)
    st)
  "`text-mode'で使用される構文テーブル")
@end group

;; @r{このモード用にキーマップを作成}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "`text-mode'のキーマップ
`mail-mode'、`outline-mode'、`indented-text-mode'のような
他の多くのモードはこのマップ内で定義した全コマンドを継承する")
@end group
@end smallexample

  そして、実際にモードコマンドが定義される方法です:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "人間が読むために記述されたテキストを編集するためのメジャーモード
このモードではパラグラフを区切るのはブランク行か空白行だけである
したがって適応型フィル(adaptive filling)の全恩恵を受けられる
 (変数`adaptive-fill-mode'を参照のこと)
\\@{text-mode-map@}
Textモードのオンによりノーマルフック`text-mode-hook'が実行される"
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(@code{indent-relative}がデフォルト値の現在では、最後の行は冗長なので、将来のバージョンで削除するつもりです。)

@cindex @file{lisp-mode.el}
  3つのLisp用モード(Lispモード、Emacs Lispモード、Lisp
Interactionモード)は、Textモードより多くの機能をもち、それにふさわしくコードもより複雑です。そのようなモードの記述方法を説明するために、@file{lisp-mode.el}の抜粋を示します。

  以下は、Lispモードの構文テーブルとabbrevテーブルを定義する方法です:

@cindex syntax table example
@smallexample
@group
;; @r{モード固有のテーブル変数の作成}
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "`lisp-mode'で使用される構文テーブル")
@end group
@end smallexample

  Lisp用の3つのモードは、コードの多くを共有します。たとえば、以下の関数呼び出しにより、さまざまな変数がセットされます:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  @dots{}
@end group
@end smallexample

@noindent
その中でも特に、以下の関数はLispコメントを処理するために、変数@code{comment-start}をセットアップします:

@smallexample
@group
  (make-local-variable 'comment-start)
  (setq comment-start ";")
  @dots{}
@end group
@end smallexample

  これら異なるLisp用モードは、微妙に異なるキーマップをもちます。たとえば、Lispモードは@kbd{C-c
C-z}を@code{run-lisp}にバインドしますが、他のLisp用モードはこれを行いません。とはいえ、すべてのLisp用モードに共通なコマンドがいくつかあります。以下のコードは、それらの共通コマンドをセットアップします:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "すべてのLisp用モードでコマンドを共有するためのキーマップ")
@end group
@end smallexample

@noindent
そして、以下がLispモードのためのキーマップをセットアップするコードです:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
@end group
@end smallexample

@noindent
最後は、Lispモードのためのメジャーモードコマンドです:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "GNU Emacs Lisp以外のLispコードを編集するためのメジャーモード
コマンド:
後方に移動させるかのようにタブをスペースに削除変換する。
パラグラフ区切りはブランク行。コメント開始はセミコロン。

\\@{lisp-mode-map@}
`run-lisp'はinferior Lispジョブの開始と既存ジョブ
から戻るための両方に使われるかもしれないことに注意
@end group

@group
このモードへのエントリーにより、
`lisp-mode-hook'の値が非nilならそれを呼び出す"
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@section Minor Modes
@cindex minor mode

  @dfn{マイナーモード(minor
mode)}は、メジャーモードの選択とは無関係にユーザーが有効、あるいは無効にする可能性のある、オプション機能を使用を提供します。マイナーモードは個別に、あるいは組み合わせて有効にできます。

  ほとんどのマイナーモードは、メジャーモードとは独立した機能を実装し、それゆえにほとんどのメジャーモードとともに使用することができます。たとえば、Auto
Fillモードはテキスト挿入を許す任意のメジャーモードとともに機能します。しかし少数ながら、特定のメジャーモードに特化した少数のマイナーモードもあります。たとえば、Diff
Auto Refineモードは、Diffモードとともに使用されることだけを意図したマイナーモードです。

  理想的には、マイナーモードは他のマイナーモードの効果と無関係に、期待する効果をもつべきです。これは、任意の順序でマイナーモードをアクティブ、あるいは非アクティブにしても可能なはずです。

@defvar minor-mode-list
この変数の値は、すべてのマイナーモードコマンドのリストである。
@end defvar

@menu
* Minor Mode Conventions::   マイナーモードを記述するためのTips。
* Keymaps and Minor Modes::  マイナーモードが自身のキーマップをもつための方法。
* Defining Minor Modes::     マイナーモードを定義するための便利な機能。
@end menu

@node Minor Mode Conventions
@subsection Conventions for Writing Minor Modes
@cindex minor mode conventions
@cindex conventions for writing minor modes

  メジャーモードにあるように、マイナーモードの記述にも慣習があります。以下で、その慣習について説明します。これらの慣習にしたがうには、マクロ@code{define-minor-mode}を使用するのがもっとも簡単な方法です。@ref{Defining
Minor Modes}を参照してください。

@itemize @bullet
@item
@cindex mode variable
名前が@samp{-mode}で終わる変数を定義する。これを@dfn{モード変数(mode
variable)}と呼ぶ。マイナーモードコマンドは、この変数をセットすべきである。値は、そのモードが無効な場合は@code{nil}、有効な場合は非@code{nil}になるだろう。そのマイナーモードがバッファーローカルなら、この変数もバッファーローカルであること。

この変数は、モードラインにマイナーモードの名前を表示するために、@code{minor-mode-alist}と結合して使用される。これは、@code{minor-mode-map-alist}を通じて、そのマイナーモードのキーマップがアクティブかどうかも判定する(@ref{Controlling
Active Maps}を参照)。個々のコマンドやフックも、この変数の値をチェックできる。

@item
モード変数と同じ名前をもつ、@dfn{モードコマンド(mode
command)}と呼ばれるコマンドを定義する。このコマンドの役目は、モード変数の値のセットに加えて、そのモードの機能を使用を実際に有効、または無効にするために必要な、その他すべてを行うことである。

モードコマンドは、1つのオプション引数を受け入れるべきである。プレフィクス引数なしでinteractiveに呼び出された場合は、モードをトグルする(toggle:
切り替える。たとえば無効なら有効に、有効なら無効にする)こと。プレフィクス引数とともにinteractiveに呼び出された場合、その引数が正であればモードを有効に、それ以外は無効にすべきである。

モードコマンドが、Lispから(つまりからの非interactiveに)呼び出された場合は、引数が省略、または@code{nil}の場合はモードを有効にすべきである。引数がシンボル@code{toggle}の場合はモードをトグルし、それ以外の場合は、上述の数引数とともにinteractiveに呼び出されたときと同じ方法により、その引数を扱うべきである。

以下は、この挙動の実装方法を示す例である(@code{define-minor-mode}マクロが生成するコードも、これに類似する)。

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable (if (eq arg 'toggle)
                  (not foo-mode) ; @r{このモードのモード変数}
                (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

この、やや複雑な挙動の理由は、ユーザーが簡単かつinteractiveにマイナーモードをトグルでき、以下のようにモードフック内で簡単にマイナーモードを有効にできるからである:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
@code{foo-mode}モードコマンドは、引数なしでLispから呼び出されたときは、無条件にそのマイナーモードを有効にするので、これは@code{foo-mode}がすでに有効でもそうでなくても正しく振る舞う。モードフック内でマイナーモードを無効にする場合は、少々醜くなる:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
しかし、これは頻繁には行われない。

@item
モードラインにマイナーモードを標示したい場合は、それぞれのマイナーモードにたいして、要素を@code{minor-mode-alist}に追加する(@ref{Definition
of minor-mode-alist}を参照)。この要素は以下の形式のリストであること:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

ここで、@var{mode-variable}はマイナーモードの有効化を制御する変数であり、@var{string}はモードラインに標示するための、スペースで始まる短い文字列である。一度に複数モードの文字列がスペースを占めるので、これらの文字列は短くなければならない。

@code{minor-mode-alist}に要素を追加する際は、重複を避けるために、既存要素のチェックに@code{assq}を使用すること。たとえば:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
または、以下のように@code{add-to-list}(@ref{List Variables}を参照)を使用すること:

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  これらに加えて、メジャーモードにたいする慣習のいくつかは、マイナーモードにたいしても同様に適用されます。それらの慣習はグローバルシンボルの名前、初期化関数の最後でのフックの使用、キーマップおよびその他のテーブルの使用です。

  マイナーモードは、可能ならばCustom(@ref{Customization}を参照)を通じての有効化および無効化をサポートするべきです。これを行うには、モード変数はは通常は@code{:type
'boolean}とともに@code{defcustom}で定義されるべきです。その変数をセットするだけではモードの有効化に不足なら、モードコマンドを呼び出すことによりモードを有効にする@code{:set}メソッドも指定するべきです。そして、その変数のドキュメント文字列にCustomを通じて変数をセットしなければ効果がないことを注記してください。さらに、その定義をautoload
cookie(@ref{autoload
cookie}を参照)でマークして、その変数のカスタマイズによりモードを定義するライブラリーがロードされるように@code{:require}を指定します。たとえば:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "msb-modeをトグルする
この変数を直接セットしても効果がない
\\[customize]か関数`msb-mode'を使用すること"
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@subsection Keymaps and Minor Modes

  マイナーモードはそれぞれ自身のキーマップをもつことができ、そのモードが有効になるとそのキーマップがアクティブになります。マイナーモード用のキーマップをセットアップするには、@code{minor-mode-map-alist}というalistに要素を追加します。@ref{Definition
of minor-mode-map-alist}を参照してください。

@cindex @code{self-insert-command}, minor modes
  特定の自己挿入文字にたいして、自己挿入と同様に他の何かを行うように振る舞いを変更するのは、マイナーモードキーマップの1つの使い方です。(@code{self-insert-command}をカスタマイズする別の方法は、@code{post-self-insert-hook}を通じて行う方法です。これ以外の@code{self-insert-command}カスタマイズ用機能は特別なケースに限定されていて、abbrevモードとAuto
Fillモードのためにデザインされています。@code{self-insert-command}にたいする標準定義を、あなた独自の定義に置き換えることを試みてはなりません。エディターコマンドループは、この関数を特別に処理します。)

マイナーモードは、コマンドを@kbd{C-c}とその後の区切り文字より構成されるキーシーケンスにバインドするかもしれません。しかし、@kbd{C-c}とその後の@kbd{@{@}<>:;}のいずれかの文字、またはコントロール文字、数字より構成されるシーケンスは、メジャーモード用に予約されています。また、@kbd{C-c
@var{letter}}はユーザー用に予約されています。@ref{Key Binding Conventions}を参照してください。

@node Defining Minor Modes
@subsection Defining Minor Modes

  マクロ@code{define-minor-mode}は、1つの自己完結した定義内にモードを実装する便利な方法を提供します。

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
このマクロは、名前が@var{mode}(シンボル)の新たなマイナーモードを定義する。これは、ドキュメント文字列として@var{doc}をもつ、マイナーモードをトグルするための、@var{mode}という名前のコマンドを定義する。

トグルコマンドは１つのオプション(プレフィクス)引数をとる。引数なしでinteractiveに呼び出された場合は、そのモードのオンとオフをトグルする。正のプレフィクス引数はモードを有効にし、それ以外のプレフィクス引数はモードを無効にする。Lispから呼び出した場合、引数が@code{toggle}の場合はモードをトグルし、引数が省略もしくは@code{nil}の場合はモードを有効にする。これはたとえば、メジャーモードフック内でマイナーモードを有効にするのを簡便にする。@var{doc}が@code{nil}の場合、このマクロは上記を説明するデフォルトのドキュメント文字列を提供する。

デフォルトでは、これはモードを有効にすると@code{t}、無効にすると@code{nil}にセットされる、@var{mode}という名前の変数も定義する。この変数は、@var{init-value}に初期化される。通常では(以下参照)、この値は@code{nil}でなければならない。

文字列@var{lighter}は、モード有効時にモードライン内に何を表示するか指定する。これが@code{nil}の場合は、このモードはモードライン内に表示されない。

オプション引数@var{keymap}は、そのマイナーモードにたいするキーマップを指定する。非@code{nil}の場合、それは(値がキーマップであるような)変数の名前、キーマップ、または以下の形式のalistであること

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
ここで、それぞれの@var{key-sequence}と@var{definition}は、@code{define-key}に渡すのに適した引数である(@ref{Changing
Key
Bindings}を参照)。@var{keymap}はキーマップまたはalistであり、これは変数@code{@var{mode}-map}も定義する。

上記の3つの引数@var{init-value}、@var{lighter}、@var{keymap}は、@var{keyword-args}が使用されたときは、(部分的に)省略できる。@var{keyword-args}は、キーワードとその後の対応する値により構成され、いくつかのキーワードは特別な意味をもつ:

@table @code
@item :group @var{group}
生成されるすべての@code{defcustom}フォームで使用されるカスタムグループ名。@var{mode}(後の@samp{-mode}がある場合はそれを除く)にたいするデフォルトである。@strong{警告:}
そのグループを定義するため@code{defgroup}を正しく記述していない場合は、このデフォルトグループ名を使用してはならない。@ref{Group
Definitions}を参照のこと。

@item :global @var{global}
非@code{nil}の場合、これはそのマイナーモードがバッファーローカルでなくグローバルであることを指定する。デフォルトは@code{nil}。

マイナーモードをグローバルにしたときの効果の1つは、@var{mode}変数がカスタマイズ変数になることである。Customizeインターフェイスを通じてこの変数をトグルするとモードがオン、またはオフになり、変数の値は将来のEmacsセッション用に保存できるようになる(@ref{Saving
Customizations,,, emacs, The GNU Emacs
Manual}を参照)。保存された変数が機能するためには、Emacsが開始されるたびに@code{define-minor-mode}フォームが確実に評価されるようにすべきである。Emacsの一部ではないパッケージにたいしては、@code{:require}キーワードを指定するのが、これを行う一番簡単な方法である。

@item :init-value @var{init-value}
これは、@var{init-value}引数を指定するのと等しい。

@item :lighter @var{lighter}
これは、@var{lighter}引数を指定するのと等しい。

@item :keymap @var{keymap}
これは、@var{keymap}引数を指定するのと等しい。

@item :variable @var{place}
これは、そのモードの状態を格納するために使用される、デフォルトの変数@var{mode}を置き換える。これを指定した場合、@var{mode}変数は定義されず、すべての@var{init-value}引数は使用されない。@var{place}は異なる名前の変数(あなた自身が定義しなければならない)、または@code{setf}関数とともに使用され得るすべてのもの(@ref{Generalized
Variables}を参照)。@var{place}にはコンス@code{(@var{get}
.
@var{set})}も指定できる。ここで、@var{get}はカレント状態をリターンする式であり、@var{set}はそれをセットする1つの引数(状態)をとる関数である。

@item :after-hook @var{after-hook}
これは、モードフック実行後に評価される、単一のLispフォームを定義する。これはクォートすべきでない。
@end table

その他のすべてのキーワード引数は、変数@var{mode}にたいして生成された@code{defcustom}に直接渡される。

@var{mode}という名前のコマンドは、最初に@var{mode}という名前の変数をセットする等の標準的な動作を処理した後に、もしあれば@var{body}フォームを実行する。それからモードフック変数@code{@var{mode}-hook}を実行し、@code{:after-hook}内のフォームを評価して終了する。
@end defmac

  @var{init-value}の値は@code{nil}でなければなりません。ただし、(1)Emacsによりそのモードが事前ロードされている、または(2)たとえユーザーが要求しなくともモードを有効にするためにロードするのが容易な場合を除きます。たとえば、他の何かが有効でなければそのモードの効果がなく、常にそのタイミングでロードされるような場合は、デフォルトでそのモードを有効にすることに害はありません。しかし、この状況は通常はあり得ません。通常は、@var{init-value}の値は@code{nil}でなければならないのです。

@findex easy-mmode-define-minor-mode
  @code{easy-mmode-define-minor-mode}という名前は、このマクロにたいするエイリアスです。

  以下は、@code{define-minor-mode}の使い方の例です:

@smallexample
(define-minor-mode hungry-mode
  "Hungryモードをトグルする。
引数なしでinteractiveに呼び出すとモードをトグルする。
正のプレフィクス引数でモードを有効に、その他のプレフィクス引数で
無効にする。Lispから呼び出す場合、引数を省略、またはnilなら
モードを有効に、`toggle'なら状態をトグルする。

Hungryモードが有効なときは、C-DELキーは、
最後を除く先行するすべての空白を飲み込む。
コマンド \\[hungry-electric-delete] を参照のこと。"
 ;; 初期値
 nil
 ;; モードラインの標示
 " Hungry"
 ;; マイナーモードのバインディング
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
これは、``Hungry
mode''という名前のマイナーモード、モードをトグルする@code{hungry-mode}という名前のコマンド、モードが有効かどうかを示す@code{hungry-mode}という名前の変数、モードが有効なときそのキーマップを保持する@code{hungry-mode-map}という名前の変数を定義します。これは、@kbd{C-@key{DEL}}にたいするキーバインディングでキーマップを初期化します。また、変数@code{hungry-mode}をカスタムグループ@code{hunger}に置きます。@var{body}フォームはありません
--- 多くのマイナーモードは必要としません。

  以下は、これを記述する等価な方法です:

@smallexample
(define-minor-mode hungry-mode
  "Hungryモードをトグルする。
...省略..."
 ;; 初期値
 :init-value nil
 ;; モードラインへのインジケーター
 :lighter " Hungry"
 ;; マイナーモードのバインディング
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
これは、@var{global-mode}という名前をグローバルにトグルする。この意味は、@var{mode}という名前のバッファーローカルなマイナーモードを、すべてのバッファーで有効、または無効にするということである。あるバッファー内でそのマイナーモードをオンにするには、関数@var{turn-on}を使用する。マイナーモードをオフにするには、@minus{}1を引数として@var{mode}を呼び出す。

モードをグローバルに有効にすると、それ以降ファイルをvisitすることにより作成されるバッファー、Fundamental以外のメジャーモードを使用するバッファーにも影響がある。しかし、Fundamentalで作成される新たなバッファーは検知しない。

これは、Customizeインターフェイス内でそのマイナーモードのオン/オフを切り替える、カスタムオプション@var{global-mode}(@ref{Customization})を定義する。@code{define-minor-mode}と同様に、たとえば@code{:require}を与える等により、毎回のEmacs開始時に確実に@code{define-globalized-minor-mode}フォームが評価されるようにすべきである。

グローバルマイナーモードのモード変数にたいしてカスタムグループを指定するには、@var{keyword-args}内で@code{:group
@var{group}}を使用する。

一般的には、グローバル化されたマイナーモードを定義するときは、ユーザーがバッファーごとにモードを使用(または無効に)できるように、非グローバル版も定義すべきである。ことにより、特定のメジャーモード内でそのモードのフックを使用することにより、グローバル有効化されたマイナーモードを無効にすることができるようになる。
@end defmac


@node Mode Line Format
@section Mode Line Format
@cindex mode line

  Emacsの各ウィンドウ(ミニバッファーウィンドウを除く)には通常、最下部にモードラインがあり、そのウィンドウ内に表示されたバッファーについてステータス情報がモードラインに表示されます。モードラインには、バッファー名、関連するファイル、再帰編集の深さ、およびメジャーモードやマイナーモードなどのような、そのバッファーに関する情報が含まれています。ウィンドウは@dfn{ヘッダーライン(header
line)}をもつこともでき、これはモードラインによく似ていますが、ウィンドウの最上部に表示されます。

  このセクションでは、モードラインおよびヘッダーラインのコンテンツの制御の仕方について説明します。このチャプターにモードラインを含めた理由は、モードラインに表示される情報の多くが、有効化されたメジャーモードとマイナーモードに関係があるからです。

@menu
* Base: Mode Line Basics.    モードライン制御の基本概念。
* Data: Mode Line Data.      モードラインを制御するデータ構造。
* Top: Mode Line Top.        トップレベル変数、mode-line-format。
* Mode Line Variables::      そのデータ構造で使用される変数。
* %-Constructs::             モードラインへの情報の配置。
* Properties in Mode::       モードライン内でのテキストプロパティの使用。
* Header Lines::             モードラインに類似した最上部のライン。
* Emulating Mode Line::      モードラインのようにテキストをフォーマットする。
@end menu

@node Mode Line Basics
@subsection Mode Line Basics

  それぞれのモードラインのコンテンツは、バッファーローカル変数@code{mode-line-format}により指定されます(@ref{Mode
Line Top}を参照)。この変数は@dfn{モードライン構成(mode line
construct)}を保持します。これは、そのバッファーのモードラインに何を表示するかを制御するテンプレートです。@code{header-line-format}の値は、同じ方法によりそのバッファーのヘッダーラインを指定します。同一のバッファーにたいするすべてのウィンドウは、同じ@code{mode-line-format}と@code{header-line-format}を使用します。

  効率的な理由により、Emacsは各ウィンドウのモードラインとヘッダーラインを、連続して再評価しません。たとえばウィンドウ設定(window
configuration)の変更、バッファーの切り替え、バッファーのナローイング(narrowing)またはワイドニング(widening)、スクロール、バッファーの変更等、それを呼び出す状況が出現したときに、Emacsは再評価を行います。@code{mode-line-format}や@code{header-line-format}(@ref{Mode
Line
Variables}を参照)により参照される任意の変数、またはテキストが表示される方法に影響を与えるデータ構造(@ref{Display}を参照)を変更した場合は、表示を更新するために関数@code{force-mode-line-update}を使用するべきです。

@defun force-mode-line-update &optional all
この関数は、次の再表示サイクルの間に、すべての関連する変数の最新の値にもとづき、カレントバッファーのモードラインとヘッダーラインの更新をEmacsに強制する。オプション引数@var{all}が非@code{nil}の場合は、すべてのモードラインとヘッダーラインの更新を強制する。

この関数は、メニューバーとフレームタイトルの更新も強制する。
@end defun

  選択されたウィンドウのモードラインは、通常はフェイス@code{mode-line}を使用して異なるカラーで表示されます。かわりに、他のウィンドウのモードラインは、フェイス@code{mode-line-inactive}で表示されます。@ref{Faces}を参照してください。

@node Mode Line Data
@subsection The Data Structure of the Mode Line
@cindex mode line construct

  モードラインのコンテンツは、@dfn{モードライン構成(mode line
construct)}と呼ばれるデータ構造により制御されます。モードライン構成はリスト、シンボル、数字を保持するバッファーローカル変数により構成されます。それぞれのデータ型は、以下で説明するようにモードラインの外見にたいして特別な意味をもちます。フレームタイトル(@ref{Frame
Titles}を参照)とヘッダーライン(@ref{Header Lines}を参照)にたいしても、同じデータ構造が使用されます。

  固定文字列のようにシンプルなモードライン構成の場合もありますが、通常はモードライン構成のテキストを構築するために、固定文字列と変数の値を組み合わせる方法を指定します。これらの変数の多くは、その変数自体がその値によりモードライン構成を定義する変数です。

  以下は、モードライン構成における、さまざまなデータ型の意味です:

@table @code
@cindex percent symbol in mode line
@item @var{string}
モードライン構成においての文字列は、文字列内に@dfn{@code{%}構成(@code{%}-constructs)}を含む以外は、そのまま表現される。これらは、他のデータによる置換を意味する。@ref{%-Constructs}を参照のこと。

文字列の一部が@code{face}プロパティをもつ場合は、バッファー内でそれらが表示されるときと同じように、テキスト表示を制御する。@code{face}プロパティをもたない文字は、デフォルトのフェイス@code{mode-line}、または@code{mode-line-inactive}で表示される(@ref{Standard
Faces,,, emacs, The GNU Emacs
Manual}を参照)。@var{string}内の@code{help-echo}プロパティと@code{keymap}プロパティは、特別な意味をもつ。@ref{Properties
in Mode}を参照のこと。

@item @var{symbol}
モードライン構成においてのシンボルは、その値を意味する。モードライン構成としては、@var{symbol}の値は@var{symbol}の位置に使用される。しかし、シンボル@code{t}と@code{nil}は、値がvoidであるようなシンボルとして無視される。

例外が1つある。@var{symbol}の値が文字列の場合、それはそのまま表示され、@code{%}構成は認識されない。

@var{symbol}が``危険''とマークされていない(非@code{nil}の@code{risky-local-variable}プロパティをもつ)場合は、@var{symbol}の値中で指定されたテキストプロパティはすべて無視される。これには、@var{symbol}の値中の文字列のテキストプロパティ、同様に文字列内の@code{:eval}フォームと@code{:propertize}フォームがすべて含まれる。(これはセキュリティー上の理由による。危険とマークされていない変数は、ユーザーへの問い合わせなしでファイル変数から自動的にセットされ得る。)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
最初の要素が文字列またはリストであるようなリストは、すべての要素を再帰的に処理して、その結果を結合することを意味する。これは、モードライン構成において、もっとも一般的なフォームである。

@item (:eval @var{form})
最初の要素がシンボル@code{:eval}であるようなリストは、@var{form}を評価して、その結果を表示する文字列として使用するよう指示する。この評価がファイルをロードできないことを確認すること。ファイルをロードすると、無限再帰が発生するかもしれない。

@item (:propertize @var{elt} @var{props}@dots{})
最初の要素がシンボル@code{:propertize}であるようなリストは、モードライン構成@var{elt}を再帰的に処理して、@var{props}により指定されるテキストプロパティに結果を加えるよう指示する。引数@var{props}は、0個以上の@var{text-property}と@var{value}のペアーで構成されるべきである。

@item (@var{symbol} @var{then} @var{else})
最初の要素がキーワード以外のシンボルであるようなリストは、条件文を指定する。その意味は、@var{symbol}の値に依存する。@var{symbol}が非@code{nil}値をもつ場合は、モードライン構成として、2つ目の要素@var{then}が再帰的に処理され、それ以外は3つ目の要素@var{else}が再帰的に処理される。@var{else}は省略でき、その場合@var{symbol}の値が@code{nil}かvoidならば、モードライン構成は何も表示しない。

@item (@var{width} @var{rest}@dots{})
最初の要素が整数であるようなリストは、@var{rest}の結果の切り詰め、またはパディングを指定する。残りの要素@var{rest}は、モードライン構成として再帰的に処理され、互いに結合される。@var{width}が正の場合、結果の幅が@var{width}より少ないときは、右側にスペースがパディングされる。@var{width}が負の場合、結果の幅が@minus{}@var{width}より大きいときは、右側が切り詰められる。

たとえば、ウィンドウ最上部からのバッファー位置をパーセント表示するには、@code{(-3 "%p")}のようなリストを使用すればよい。
@end table

@node Mode Line Top
@subsection The Top Level of Mode Line Control

  変数@code{mode-line-format}は、モードラインの全体的な制御を行います。

@defopt mode-line-format
この変数の値は、モードラインのコンテンツを制御するモードライン構成である。これは、すべてのバッファーにおいて、常にバッファーローカルである。

あるバッファー内でこの変数に@code{nil}をセットした場合、そのバッファーはモードラインをもたない(高さが1行しかないウィンドウも、モードラインを表示しない)。
@end defopt

  @code{mode-line-format}のデフォルト値は、@code{mode-line-position}や@code{mode-line-modes}(これは@code{mode-name}と@code{minor-mode-alist}の値を組み込む)のような、他の変数の値を使用するようデザインされています。@code{mode-line-format}自体を変更する必要があるモードは、ほとんどありません。ほとんどの用途にたいしては、@code{mode-line-format}が直接、または間接的に参照する、いくつかの変数を修正すれば十分です。

  @code{mode-line-format}l自体の変更を行った場合、新たな値は他の様式でコンテンツを複製したり情報を表示するのではなく、デフォルト値(@ref{Mode
Line
Variables}を参照)に現れるのと同じ変数を使用するべきです。この方法を使用すれば、ユーザーや(@code{display-time}やメジャーモードのような)Lispプログラムにより行われたカスタマイズは、それらの変数への変更を通じて、効力を保ちます。

  以下は、Shellモードにたいして有用かもしれない、架空の@code{mode-line-format}の例です(実際には、Shellモードは@code{mode-line-format}をセットしない):

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{これはリスト作成中に評価されることに注意。}
   ;; @r{これは単なる文字列のモードライン構成を作成する。}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(変数@code{line-number-mode}、@code{column-number-mode}、@code{which-func-mode}は特定のマイナーモードを有効にする。通例どおり、これらの変数名は、マイナーモードコマンド名でもある。)

@node Mode Line Variables
@subsection Variables Used in the Mode Line

  このセクションでは、@code{mode-line-format}の標準的な値として、モードラインテキストに組み込まれる変数を説明します。これらの変数は、本質的には特別なものではありません。@code{mode-line-format}が使用する変数を他の変数に変更すれば、それらはモードライン上で同様の効果をもちます。しかし、Emacsのさまざまな部分は、それらの変数がモードラインを制御するという認識の元、それらの変数をセットします。したがって、事実上モードラインがそれらの変数を使用するのは必須なのです。

@defvar mode-line-mule-info
この変数は、言語環境(language environment)、バッファーコーディングシステム、カレント入力メソッド(current input
method)に関する情報のモードライン構成の値を保持する。@ref{Non-ASCII Characters}を参照のこと。
@end defvar

@defvar mode-line-modified
この変数は、カレントバッファーが変更されたかどうかを表示する、モードライン構成の値を保持する。デフォルト値ではバッファーが変更されていれば@samp{**}、バッファーが変更されていなければ@samp{--}、バッファーが読み取り専用なら@samp{%%}、読み取り専用だが変更されているときは@samp{%*}を表示する。

この変数を変更しても、モードラインは強制的に更新されない。
@end defvar

@defvar mode-line-frame-identification
この変数は、カレントフレームを識別する。デフォルト値では、複製フレームを表示可能なウィンドウシステムを使用している場合は@code{"
"}、一度に1つのフレームだけを表示する通常の端末では@code{"-%F "}を表示する。
@end defvar

@defvar mode-line-buffer-identification
この変数は、そのウィンドウ内で表示されているバッファーを識別する。デフォルト値では、少なくとも12列になるようスペースパディングされたバッファー名を表示する。
@end defvar

@defopt mode-line-position
この変数は、バッファー内での位置を標示する。デフォルト値ではバッファーのパーセントを表示し、オプションでバッファーサイズ、行番号、列番号を表示する。
@end defopt

@defvar vc-mode
変数@code{vc-mode}は、各バッファーにたいしてバッファーローカルであり、そのバッファーがvisitしているファイルがバージョンコントロールで保守されているかどうかと、保守されている場合はバージョンコントロールシステムの種別を表示する。新しいモードラインに表示される文字列、バージョンコントロールされていない場合は@code{nil}である。
@end defvar

@defopt mode-line-modes
この変数は、そのバッファーのメジャーモードとマイナーモードを表示する。デフォルト値では再帰編集レベル(recursive editing
level)、プロセス状態の情報、ナローイング(narrowing)効果の有無を表示する。
@end defopt

@defvar mode-line-remote
この変数は、カレントバッファーにたいする@code{default-directory}がリモートかどうかを表示するために使用される。
@end defvar

@defvar mode-line-client
この変数は、@code{emacsclient}フレームを識別するために使用される。
@end defvar

  以下の3つの変数は、@code{mode-line-modes}内で使用されます:

@defvar mode-name
このバッファーローカル変数は、カレントバッファーのメジャーモードの``愛称(pretty
name)''を保持する。モード名がモードラインに表示されるように、それぞれのメジャーモードは、この変数をセットすべきである。値は文字列である必要はなく、モードライン構成内で有効な任意のデータ型(@ref{Mode
Line
Data}を参照)を使用できる。モードライン内でモード名を識別する文字列の計算には、@code{format-mode-line}を使用する(@ref{Emulating
Mode Line}を参照)。
@end defvar

@defvar mode-line-process
このバッファーローカル変数には、そのモードにおいて、サブプロセスとの通信にたいするプロセス状態のモードライン情報が含まれる。これはメジャーモード名の直後(間のスペースはない)に表示される。たとえば、@file{*shell*}バッファーでの値は@code{(":%s")}であり、これは@samp{(Shell:run)}のように、メジャーモードとともにその状態を表示する。通常、この変数は@code{nil}である。
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
この変数は、マイナーモードがアクティブかをモードラインに示す方法を指定する要素をもつ、連想リスト(association
list)を保持する。@code{minor-mode-alist}の各要素は、2要素のリストであること:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example

より一般的には、@var{mode-line-string}は任意のモードライン構成であり得る。@var{minor-mode-variable}の値が非@code{nil}の場合はモードラインに表示され、それ以外では表示されない。一緒に実行されないよう、これらの文字列はスペースで始まるべきである。慣例的に、特定のモードにたいする@var{minor-mode-variable}は、そのマイナーモードがアクティブになった際には、非@code{nil}値にセットされる。

@code{minor-mode-alist}自体はバッファーローカルではない。このalist内で参照される各変数は、そのマイナーモードをバッファーごとに個別に有効にできる場合は、バッファーローカルであること。
@end defvar

@defvar global-mode-string
この変数は、モードライン内でマイナーモード@code{which-func-mode}がセットされている場合はその直後、セットされていなければ@code{mode-line-modes}の後に表示されるモードライン構成を保持する(デフォルト)。コマンド@code{display-time}は、時間とロードの情報を含む文字列を保持する変数@code{display-time-string}を参照する、@code{global-mode-string}をセットする。

@samp{%M}構成は、@code{global-mode-string}の値を置き換えるが、この変数は@code{mode-line-format}からモードラインにincludeされるので、時代遅れである。
@end defvar

以下は、@code{mode-line-format}のデフォルト値の簡略化バージョンです。実際のデフォルト値には、追加のテキストプロパティ指定も含まれます。

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Constructs in the Mode Line

  モードライン構成として使用される文字列は、さまざまな種類のデータを置き換えるために、@code{%}構成を使用できます。以下は、定義済みの@code{%}構成と意味のリストです。

  @samp{%%}以外の構成では、フィールドの最小幅を指定するために、@samp{%}の後に10進整数を追加できます。幅がそれより小さい場合、そのフィールドは最小幅にパディングされます。純粋に数値的な構成(@samp{c}、@samp{i}、@samp{I}、@samp{l})は左側、それ以外は右側にスペースを追加してパディングされます。

@table @code
@item %b
@code{buffer-name}関数により取得されるカレントバッファー名。@ref{Buffer Names}を参照のこと。

@item %c
ポイント位置のカレント列番号。

@item %e
EmacsがLispオブジェクトにたいしてメモリー不足になりそうなときは、それを伝える簡略なメッセージを示す。それ以外の場合は空である。

@item %f
@code{buffer-file-name}関数により取得される、visitしているファイル名。@ref{Buffer File
Name}を参照のこと。

@item %F
選択されたフレームのタイトル(ウィンドウシステム上のみ)、または名前。@ref{Basic Parameters}を参照のこと。

@item %i
カレントバッファーのアクセス可能な範囲のサイズ。基本的には@code{(- (point-max) (point-min))}。

@item %I
@samp{%i}と同様だが、10^3は@samp{k}、10^6は@samp{M}、10^9は@samp{G}を使用して省略することにより、より読みやすい方法でサイズをプリントする。

@item %l
ポイント位置のカレント行番号。そのバッファーのアクセス可能な範囲内でカウントされる。

@item %n
ナローイングが有効なときは@samp{Narrow}、それ以外は何も表示しない(@ref{Narrowing}の@code{narrow-to-region}を参照されたい)。

@item %p
ウィンドウの@strong{最上部}より上にあるバッファーテキストのパーセント表示、または@samp{Top}、@samp{Bottom}、@samp{All}のいずれか。デフォルトのモードライン構成は、これを3文字に切り詰めることに注意されたい。

@item %P
ウィンドウの@strong{最下部}より上にあるバッファーテキスト(ウィンドウ内の可視なテキストと、最上部の上にあるテキスト)のパーセント表示、およびバッファーの最上部がスクリーン上で可視な場合は、それに加えて@samp{Top}。または@samp{Bottom}か@samp{All}。

@item %s
@code{process-status}により取得される、カレントバッファーに属するサブプロセスの状態。@ref{Process
Information}を参照のこと。

@item %z
キーボード、端末、およびバッファーコーディングシステムのニーモニック。

@item %Z
@samp{%z}と同様だが、EOL形式(end-of-line format: 改行形式)を含む。

@item %*
バッファーが読み取り専用(@code{buffer-read-only}を参照)の場合は@samp{%}、@*
変更されている場合(@code{buffer-modified-p}を参照)は@samp{*}、@* それ以外は@samp{-}。@ref{Buffer
Modification}を参照のこと。

@item %+
バッファーが変更されている場合(@code{buffer-modified-p}を参照)は@samp{*}@*
バッファーが読み取り専用(@code{buffer-read-only}を参照)の場合は@samp{%}、@*
それ以外は@samp{-}。これは、読み取り専用バッファーの変更にたいしてのみ@samp{%*}と異なる。@ref{Buffer
Modification}を参照のこと。

@item %&
バッファーが変更されている場合は@samp{*}、それ以外は@samp{-}。

@item %[
再帰編集レベルの深さを標示する(ミニバッファーレベルは勘定しない)。1つの編集レベルが@samp{[}。@ref{Recursive
Editing}を参照のこと。

@item %]
1つの編集レベルが@samp{]}(ミニバッファーレベルは勘定しない)。

@item %-
モードラインの残りを充填するのに十分なダッシュ。

@item %%
文字@samp{%}。@code{%}構成が許される文字列内に、リテラル@samp{%}を含めるには、この方法を使用する。
@end table

以下の2つの@code{%}構成はまだサポートされていますが、同じ結果を変数@code{mode-name}と@code{global-mode-string}で取得できるので、これらは時代遅れです。

@table @code
@item %m
@code{mode-name}の値。

@item %M
@code{global-mode-string}の値。
@end table

@node Properties in Mode
@subsection Properties in the Mode Line
@cindex text properties in the mode line

  モードライン内では、特定のテキストプロパティが意味をもちます。@code{face}プロパティは、テキストの外見に影響します。@code{help-echo}プロパティはそのテキストのヘルプ文字列に関連し、@code{keymap}によりテキストをマウスに感応させることができます。

  モードライン内のテキストにたいしてテキストプロパティを指定するには、4つの方法があります:

@enumerate
@item
モードラインデータ構造内に、テキストプロパティをもつ文字列を直接配する。

@item
@samp{%12b}のような、モードライン%構成に、テキストプロパティを配する。その場合、%構成を展開すると、同じテキストプロパティをもつことになる。

@item
@var{props}で指定されるテキストプロパティを@var{elt}に与えるために、@code{(:propertize @var{elt}
@var{props}@dots{})}構成を使用する。

@item
@var{form}がテキストプロパティをもつ文字列に評価されるように、モードラインデータ構造内に@code{:eval
@var{form}}を含むリストを使用する。
@end enumerate

  キーマップを指定するために、@code{keymap}プロパティを使用できます。このキーマップは、マウスクリックにたいしてのみ、実際の効果をもちます。モードライン内にポイントを移動させるのは不可能なので、文字キーやファンクションキーをこれにバインドしても、効果はありません。

  モードラインが、@code{risky-local-variable}が非@code{nil}であるようなプロパティをもつ変数を参照する場合、その変数の値により与える、または指定されるテキストプロパティは、すべて無視されます。これは、そのようなプロパティは呼び出される関数を指定するかもしれず、その関数はファイルローカル変数が由来かもしれないからです。

@node Header Lines
@subsection Window Header Lines
@cindex header line (of a window)
@cindex window header line

  ウィンドウは、最下部にモードラインをもつことができるのと同じように、最上部に@dfn{ヘッダーライン(header
line)}をもつことができます。ヘッダーライン機能は、それが@code{header-line-format}により制御されることを除けば、モードラインと同じように機能します。

@defvar header-line-format
すべてのバッファーにたいしてローカルなこの変数は、そのバッファーを表示するバッファーにたいして、ヘッダーラインを表示する方法を指定する。この変数の値のフォーマットは、@code{mode-line-format}にたいするフォーマットと同じである(@ref{Mode
Line Data}を参照)。通常、この変数は@code{nil}なので、通常のバッファーはヘッダーラインをもたない。
@end defvar

@defun window-header-line-height &optional window
この関数は、@var{window}のヘッダーラインの高さを、ピクセルでリターンする。@var{window}は生きたウィンドウでなければならず、デフォルトは選択されたウィンドウである。
@end defun

  高さが1行しかないウィンドウは、決してヘッダーラインを表示しません。また、高さが2行しかないウィンドウは、一度にモードラインとヘッダーラインを表示できません。そのようなウィンドウがモードラインをもつ場合、ヘッダーラインは表示されません。

@node Emulating Mode Line
@subsection Emulating Mode Line Formatting

  関数@code{format-mode-line}を使用して、特定のモードライン構成にもとづきモードライン、またはヘッダーラインに表示されるテキストを計算できます。

@defun format-mode-line format &optional face window buffer
この関数は、あたかも@var{window}にたいしてモードラインを生成するかのように、@var{format}に応じてテキスト行をフォーマットするが、さらにそのテキストを文字列としてリターンする。引数@var{window}のデフォルトは、選択されたウィンドウである。@var{buffer}が非@code{nil}の場合、使用されるすべての情報は@var{buffer}から取得される。デフォルトでは、@var{window}のバッファーから取得される。

文字列の値は通常、モードラインがもつであろうフェイス、キーマップ等に対応するテキストプロパティをもつ。@var{format}により指定された@code{face}プロパティのないすべての文字は、@var{face}により決定されるデフォルト値を取得する。@var{face}が@code{t}の場合は、@var{window}が選択されていれば@code{mode-line}、それ以外は@code{mode-line-inactive}であることを意味する。@var{face}が@code{nil}、または省略された場合は、デフォルトのフェイスを意味する。@var{face}が整数の場合、この関数はテキストプロパティをもたない値をリターンするだろう。

@var{face}の値として、他の有効なフェイスを指定することもできる。指定された場合、それは@var{format}でフェイスを指定されていない文字の@code{face}プロパティのフェイスを提供する。

@var{face}として@code{mode-line}、@code{mode-line-inactive}、@code{header-line}を使用することにより、フォーマットされた文字列のリターンに加えて、対応するフェイスのカレント定義を使用して、実際にモードラインやヘッダーラインが再描画されるだろうということに注意されたい(他のフェイスでは、再描画は行われない)。

たとえば、@code{(format-mode-line
header-line-format)}は選択されたウィンドウに表示されるテキスト(ヘッダーラインがない場合は@code{""})をリターンするだろう。@code{(format-mode-line
header-line-format
'header-line)}は、各文字がヘッダーライン内でもつであろうフェイスをもつ、同じテキストをリターンし、加えてヘッダーラインの再描画も行う。
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu}とは、バッファー内の定義やセクションをすべてリストするメニューをユーザー選択することにより、バッファー内の該当箇所に直接移動する機能です。Imenuは、定義(またはバッファーのその他の名前つき範囲)の名前とその定義のバッファー内での位置をリストする、バッファーインデックスを構築して、ユーザーがそれを選択すればポイントをおこに移動できるようにして機能します。メジャーモードは、@code{imenu-add-to-menubar}を使用して、メニューバーアイテムを追加することができます。

@deffn Command imenu-add-to-menubar name
この関数は、@var{name}という名前のImenuを実行するためのローカルメニューバーを定義する。
@end deffn

  Imenuを使用ためのユーザーレベルコマンドは、Emacsマニュアル内で説明されています(@ref{Imenu,, Imenu, emacs, the
Emacs
Manual}を参照)。このセクションでは、特定のメジャーモードにたいして、定義や名前つき範囲を見つける、Imenuメソッドのカスタマイズ方法を説明します。

  変数@code{imenu-generic-expression}をセットするのが通常の、そしてもっともシンプルな方法です:

@defvar imenu-generic-expression
この変数が非@code{nil}の場合、それはImenuにたいして定義を探すための正規表現を指定するリストである。シンプルな@code{imenu-generic-expression}の要素は、以下のようになる:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

ここで、@var{menu-title}が非@code{nil}の場合、それはこの要素にたいするマッチが、バッファーインデックスのサブメニューとなることを告げる。@var{menu-title}自体は、そのサブメニューにたいして名前を指定する。@var{menu-title}が@code{nil},の場合は、この要素にたいするマッチは、直接トップレベルのバッファーインデックスとなる。

このリストの2つ目の要素@var{regexp}は、正規表現である(@ref{Regular
Expressions}を参照)。これは、バッファー内でこれにマッチするものは定義、あるいはバッファーインデックス内に記載すべき何かであると判断される。3つ目の要素@var{index}は、0以上の整数の場合は、@var{regexp}内の部分式(subexpression)が定義名にマッチすることを示します。

以下のような要素もある:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

この要素にたいする各マッチはインデックスアイテムを作成し、ユーザーによりそのインデックスアイテムが選択されたとき、アイテム名、バッファー位置、および@var{arguments}から構成される引数で、@var{function}を呼び出す。

Emacs Lispモードにたいしては、@code{imenu-generic-expression}は以下のようになるだろう:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-case-fold-search
この変数は、@code{imenu-generic-expression}の値中の正規表現マッチが、大文字小文字を区別するかどうかを制御する。@code{t},(デフォルト)の場合は、大文字小文字の違いを無視することを意味する。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-syntax-alist
この変数は、@code{imenu-generic-expression}処理中に、カレントバッファーの構文テーブルをオーバーライドして使用する、構文テーブル変更用のalistである。このalistの各要素は、以下の形式をもつべきである:

@example
(@var{characters} . @var{syntax-description})
@end example

@sc{car}の@var{characters}には、文字または文字列を指定できる。この要素は、その文字、または文字列が@var{syntax-description}により指定される構文でありことを示し、@code{modify-syntax-entry}に渡される(@ref{Syntax
Table Functions}を参照)。

典型的には、この機能は通常はシンボル構文(symbol syntax)をもつ文字にたいして単語構文(word
syntax)を与えるために使用され、それにより@code{imenu-generic-expression}が単純になり、マッチングのスピードも向上する。たとえば、Fortranモードは以下のようにこれを使用する:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

@code{imenu-generic-expression}の正規表現は、@samp{\\(\\sw\\|\\s_\\)+}のかわりに、@samp{\\sw+}を使用できる。このテクニックは、モードの名前として許されるより短い、頭文字に名前を制限する必要があるときは、不便かもしれないことに注意されたい。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

  あるメジャーモードにたいしてImenuをカスタマイズする別の方法には、@code{imenu-prev-index-position-function}と@code{imenu-extract-index-name-function}があります:

@defvar imenu-prev-index-position-function
この変数が非@code{nil}の場合、その値はポイント位置からバッファーを後方にスキャンして、バッファーインデックスに配すべき、次の``定義''を探すための関数であること。そして、ポイントより前に他の``定義''が見つからなければ、@code{nil}をリターンすべきである。見つかった場合は、``definition''を見つけた場所にポイントを残し、任意の非@code{nil}値をリターンすべきである。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-extract-index-name-function
この変数が非@code{nil}の場合、その値はポイントが定義中にある(@code{imenu-prev-index-position-function}関数がポイントを残す場所)という想定の元、その定義の名前をリターンする関数であること。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

  メジャーモードにたいしてImenuをカスタマイズするための最後の方法は、変数@code{imenu-create-index-function}のセットです:

@defvar imenu-create-index-function
この変数は、バッファーインデックスを作成するために使用する関数を指定する。この関数は、引数がをとらず、カレントバッファーにたいするインデックスalist(index
alist)をリターンすべきである。この関数は@code{save-excursion}内で呼び出されるので、どこにポイントを残しても違いはない。

このインデックスalistは、3つのタイプの要素をもつことができる。以下は、シンプル要素(simple element)の例である:

@example
(@var{index-name} . @var{index-position})
@end example

シンプル要素の選択は、そのバッファー内の位置@var{index-position}に移動する効果をもつ。スペシャル要素(special
element)は、以下のようなものである:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

スペシャル要素の選択により、以下が処理される:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

ネストされたサブalist要素(nested sub-alist element)は、以下のようなものである:

@example
(@var{menu-title} . @var{sub-alist})
@end example

これは、@var{sub-alist}により指定される、サブメニュー@var{menu-title}を作成する。

@code{imenu-create-index-function}のデフォルト値は、@code{imenu-default-create-index-function}である。この関数は、インデックスalistを生成するために、@code{imenu-prev-index-position-function}の値と、@code{imenu-extract-index-name-function}の値を呼び出す。しかし、これら2つ変数のいずれかが@code{nil}の場合、デフォルト関数はかわりに@code{imenu-generic-expression}を使用する。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@node Font Lock Mode
@section Font Lock Mode
@cindex Font Lock mode

  @dfn{Font Lockモード}とは、バッファーの特定の部分にたいして、それらの構文的役割(syntactic
role)にもとづき、自動的に@code{face}プロパティをアタッチする、バッファーローカルなマイナーモードです。このモードがバッファーをパースする方法は、そのメジャーモードに依存します。ほとんどのメジャーモードは、どのコンテキストでどのフェイスを使用するかにたいして、構文的条件(syntactic
criteria)を定義します。このセクションでは、特定のメジャーモードにたいして、Font Lockをカスタマイズする方法を説明します。

  Font Lockモードは、2つの方法によりハイライトするテキストを探します。それは構文テーブル(syntax
table)にもとづく構文解析と、(通常は正規表現にたいする)検索です。最初に構文的フォント表示(syntactic
fontification)が発生します。これはコメントと文字列定数を見つけて、それらをハイライトします。検索ベースのフォント表示が発生するのは、2番目です。

@menu
* Font Lock Basics::         Font Lockカスタマイズの概要。
* Search-based Fontification::  正規表現にもとづくフォント表示。
* Customizing Keywords::     検索ベースフォント表示のカスタマイズ。
* Other Font Lock Variables::  追加のカスタマイズ機能。
* Levels of Font Lock::      多なりとも少ユーザーが選択できるように、それぞれのモードは代替レベルを定義できる。
* Precalculated Fontification::  バッファーコンテンツを生成するLispプログラムが、どのようにしてそれをフォント表示する方法も指定できるか。
* Faces for Font Lock::      Font 
                               Lockにたいする具体的な特殊フェイス。
* Syntactic Font Lock::      構文テーブルにもとづくフォント表示。
* Multiline Font Lock::      Font 
                               Lockに複数行構成の正しいハイライトを強制する方法。
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

  Font
Lockモードがテキストをハイライトする方法を制御する変数が、いくつかあります。しかし、メジャーモードは、これらの変数を直接セットするべきではありません。かわりに、メジャーモードはバッファーローカル変数として、@code{font-lock-defaults}をセットするべきです。Font
Lockモードが有効なときは、他のすべての変数をセットするために、この変数に割り当てられた値が使用されます。

@defvar font-lock-defaults
この変数は、そのモード内のテキストをフォント表示する方法を指定するために、メジャーモードによりセットされる。この変数は、セットした際に自動的にバッファーローカルになる。変数の値が@code{nil}の場合、Font
Lockモードはハイライトを行わず、バッファー内のテキストに明示的にフェイスを割り当てるために、@samp{Faces}メニュー(メニューバーの@samp{Edit}の下の@samp{Text
Properties})を使用できる。

非@code{nil}の場合、値は以下のようであること:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} [@var{syntax-begin} @var{other-vars}@dots{}]]]])
@end example

1つ目の要素@var{keywords}は、検索ベースのフォント表示を制御する@code{font-lock-keywords}の値を、間接的に指定する。値にはシンボル、変数、または@code{font-lock-keywords}にたいして使用するリストが値であるような関数を指定できる。また、それぞれのシンボルがフォント表示の可能なレベルであるような、いくつかのシンボルからなるリストも指定できる。この場合、1つ目のシンボルはフォント表示の@samp{モードデフォルト(mode
default)}レベル、次のシンボルはフォント表示のレベル1、その次はレベル2、のようになる。通常、@samp{モードデフォルト}レベルはレベル1と等しい。これは、@code{font-lock-maximum-decoration}が@code{nil}値をもつとき使用される。@ref{Levels
of Font Lock}を参照のこと。

2つ目の要素@var{keywords-only}は、変数@code{font-lock-keywords-only}の値を指定する。これが省略、または@code{nil}の場合は、(文字列とコメントの)構文的フォント表示も行われる。非@code{nil}の場合は、構文的フォント表示は行われない。@ref{Syntactic
Font Lock}を参照のこと。

3つ目の要素@var{case-fold}は、@code{font-lock-keywords-case-fold-search}の値を指定する。非@code{nil}の場合、検索ベースフォント表示の間、Font
Lockモードは大文字小文字の違いを無視する。

4つ目の要素@var{syntax-alist}が非@code{nil}の場合、それは@code{(@var{char-or-string}
.
@var{string})}という形式のコンスセルのリストであること。これらは、構文的フォント表示にたいする構文テーブルのセットアップに使用される。結果となる構文テーブルは、@code{font-lock-syntax-table}に格納される。@var{syntax-alist}が省略、または@code{nil}の場合、構文的フォント表示は@code{syntax-table}関数によりリターンされる構文テーブルを使用する。@ref{Syntax
Table Functions}を参照のこと。

5つ目の要素@var{syntax-begin}は、@code{font-lock-beginning-of-syntax-function}の値を指定する。この変数は@code{nil}にセットして、かわりに@code{syntax-begin-function}の使用を推奨する。

(もしあれば)残りすべての要素は、まとめて@var{other-vars}と呼ばれる。これらの要素はすべて、@code{(@var{variable}
.
@var{value})}という形式をもつべきである。これは、@var{variable}をバッファーローカルにしてから、それに@var{value}をセットすることを意味する。これら@var{other-vars}を使用して、最初の5つの要素による制御とは別に、フォント表示に影響する他の変数をセットできる。@ref{Other
Font Lock Variables}を参照のこと。
@end defvar

  モードが@code{font-lock-face}プロパティ追加により明示的にテキストをフォント表示する場合は、自動的なフォント表示すべてをオフにするために、@code{font-lock-defaults}に@code{(nil
t)}を指定できます。しかし、これは必須ではありません。@code{font-lock-face}を使用して何かをフォント表示して、それ以外の部分のテキストを自動的にフォント表示するようにセットアップするのは可能です。

@node Search-based Fontification
@subsection Search-based Fontification

  検索ベースフォント表示を直接制御する変数は、@code{font-lock-keywords}です。この変数は通常、@code{font-lock-defaults}内の要素@var{keywords}を通じて指定されます。

@defvar font-lock-keywords
この変数の値は、ハイライトするキーワードのリストである。Lispプログラムは、この変数を直接セッすべきでない。通常は、@code{font-lock-defaults}内の要素@var{keywords}を使用して、Font
Lockモードが自動的に値をセットする。この値は、関数@code{font-lock-add-keywords}および@code{font-lock-remove-keywords}を使用して、変更されることもあり得る(@ref{Customizing
Keywords}を参照)。
@end defvar

  @code{font-lock-keywords}の各要素は、特定のケースに該当するテキストを見つける方法、およびそれらをハイライトする方法を指定します。Font
Lockモードは、@code{font-lock-keywords}の要素をちくじ処理してマッチを探して、すべてのマッチを処理します。通常は、テキストの一部はすでに一度はフォント表示されており、同じテキスト内で連続するマッチによるこれをオーバーライドはできません。しかし、@var{subexp-highlighter}の要素@var{override}を使用して、異なる挙動を指定できます。

  @code{font-lock-keywords}の各要素は、以下の形式のいずれかをもつべきです:

@table @code
@item @var{regexp}
@code{font-lock-keyword-face}を使用して、@var{regexp}にたいするすべてのマッチをハイライトする。たとえば、

@example
;; @r{@code{font-lock-keyword-face}を使用して}
;; @r{単語@samp{foo}をハイライトする}
"\\<foo\\>"
@end example

これらの正規表現を作成するときは、慎重に行うこと。下手に記述されたパターンにより、スピードが劇的に低下し得る!
関数@code{regexp-opt}(@ref{Regexp
Functions}を参照)は、いくつかのキーワードとマッチするために最適な正規表現の計算に有用である。

@item @var{function}
@var{function}を呼び出すことによりテキストを探し、@code{font-lock-keyword-face}を使用して見つかったマッチをハイライトする。

@var{function}は、呼び出される際に1つの引数(検索のリミット)を受け取る。検索はポイント位置から開始し、そのリミットを超えた検索は行うべきではない。これは、検索が成功した場合は非@code{nil}をリターンして、見つかったマッチを表すマッチデータをセットすべきである。@code{nil}のリターンは、検索の失敗を示す。

フォント表示は、前の呼び出しでポイントが残された位置から、同じリミットを用いて@var{function}を呼び出し、@var{function}が失敗するまで@var{function}を繰り返し呼び出すだろう。検索が失敗しても、何らかの特別な方法により、@var{function}がポイントをリセットする必要はない。

@item (@var{matcher} . @var{subexp})
この種の要素では、@var{matcher}は上述のregexpかfunctionのいずれかである。@sc{cdr}の@var{subexp}は、(@var{matcher}がマッチするテキスト全体のかわりに)@var{matcher}のどの部分式(subexpression)がハイライトされるべきかを指定する。

@example
;; @r{@code{font-lock-keyword-face}Hを使用して}
;; @r{@samp{bar}が@samp{fubar}の一部のときに}
;; @r{ハイライトする}
("fu\\(bar\\)" . 1)
@end example

正規表現@var{matcher}の生成に@code{regexp-opt}を使用する場合は、@var{subexp}にたいする値の計算に@code{regexp-opt-depth}(@ref{Regexp
Functions}を参照)を使用できる。

@item (@var{matcher} . @var{facespec})
この種の要素では、@var{facespec}の値がハイライトに使用するフェイスを指定する。もっともシンプルな例では、@var{facespec}は値がフェイス名であるようなはLisp変数(シンボル)である。

@example
;; @r{@code{fubar-face}の値のフェイスを使用して}
;; @r{@samp{fubar}をハイライトする}
("fubar" . fubar-face)
@end example

しかし、@var{facespec}は以下のような形式のリストに評価されてもよい:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
これは、マッチしたテキストにフェイス@var{face}を指定し、さまざまなテキストプロパティをputする。これを行う場合は、この方法により@code{font-lock-extra-managed-props}に値をセットする、他のテキストプロパティ名を確実に追加すること。そうすれば、それらのプロパティが妥当性を失ったとき、それらのプロパティもクリアーされるだろう。これらのプロパティをクリアーする関数を、変数@code{font-lock-unfontify-region-function}にセットすることもできる。@ref{Other
Font Lock Variables}を参照のこと。

@item (@var{matcher} . @var{subexp-highlighter})
この種の要素では、@var{subexp-highlighter}は@var{matcher}により見つかったマッチをハイライトする方法を指定するリストである。これは、以下の形式をもつ。

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

@sc{car}の@var{subexp}は、マッチのどの部分式をフォント表示するかを指定する整数である(0はマッチしたテキスト全体を意味する)。これの2つ目の要素@var{facespec}は、上述したような値がフェイスを指定するような式である。

@var{subexp-highlighter}内の残りの値@var{override}と@var{laxmatch}は、オプションのフラグである。@var{override}が@code{t}の場合、この要素は前の@code{font-lock-keywords}の要素により作成された既存のフォント表示をオーバーライドできる。値が@code{keep}の場合は、すでに他の要素によりフォント表示されていない文字がフォント表示される。値が@code{prepend}の場合は、@var{facespec}により指定されたフェイスが、@code{font-lock-face}プロパティの先頭に追加される。値が@code{append}の場合は、そのフェイスが@code{font-lock-face}プロパティの最後に追加される。

@var{laxmatch}が非@code{nil}の場合、それは@var{matcher}内で番号付けされた部分式@var{subexp}が存在しなくても、エラーにならないことを意味する。当然、番号付けされた部分式@var{subexp}のフォント表示は発生しない。しかし、他の部分式(と他のregexp)のフォント表示は継続されるだろう。@var{laxmatch}が@code{nil}で、指定された部分式が存在しない場合は、エラーがシグナルされて検索ベースのフォント表示は終了する。

以下はこのタイプの要素と、それが何を行うかの例である:

@smallexample
;; @r{@code{foo-bar-face}を使用して、たとえハイライト済みでも}
;; @r{@samp{foo}と@samp{bar}をハイライトする}
;; @r{@code{foo-bar-face}は値がフェイスであるような変数であること}
("foo\\|bar" 0 foo-bar-face t)

;; @r{@code{fubar-face}の値のフェイスを使用して}
;; @r{関数@code{fubar-match}が見つけた各マッチの}
;; @r{最初の部分式をハイライトする}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
この種の要素では、@var{anchored-highlighter}は@var{matcher}が見つけたマッチに後続するテキストをハイライトする方法を指定する。つまり、@var{matcher}が見つけたマッチは、@var{anchored-highlighter}により指定されるその先の検索にたいする、アンカー(anchor)として機能する。@var{anchored-highlighter}は、以下の形式のリストである:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

ここで、@var{anchored-matcher}は@var{matcher}と同様、正規表現か関数である。@var{matcher}にたいするマッチを見つけた後に、ポイントはそのマッチの終端に移動する。そこで、Font
Lockはフォーム@var{pre-form}を評価する。それから@var{anchored-matcher}にたいするマッチを検索し、@var{subexp-highlighters}を使用して、それらのマッチをハイライトする。@var{subexp-highlighter}については上記を参照のこと。最後にFont
Lockは@var{post-form}を評価する。

フォーム@var{pre-form}および@var{post-form}は、@var{anchored-matcher}使用時の事前の初期化、事後のクリーンアップに使用され得る。通常、@var{pre-form}は@var{anchored-matcher}を開始する前に、@var{matcher}のマッチに関連する何らかの位置にポイントを移動するために使用される。@var{post-form}は、@var{matcher}を再開する前に、ポイントを戻すために使用されるかもしれない。

@var{pre-form}を評価した後、Font
Lockはその行の終端の先にたいして、@var{anchored-matcher}の検索を行わない。しかし、@var{pre-form}が@var{pre-form}評価後のポイント位置より大きいバッファー位置をリターンした場合には、かわりに@var{pre-form}によりリターンされた位置が検索リミットとして使用される。一般的に、その行の終端より大きい位置をリターンするのは、よいアイデアではない。別の言い方をすると、@var{anchored-matcher}検索は複数行にわたる(span
lines)べきではないと言えよう。

たとえば、

@smallexample
;; @r{@code{item-face}の値を使用して}
;; @r{単語@samp{anchor}に(同一行内で)}
;; @r{後続する単語@samp{item}をハイライトする}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

ここで、@var{pre-form}と@var{post-form}は@code{nil}である。したがって、@samp{item}にたいする検索は@samp{anchor}にたいするマッチの終端から開始され、後続する@samp{anchor}インスタンスにたいする検索は、@samp{item}にたいする検索が終了した位置から再開される。

@item (@var{matcher} @var{highlighters}@dots{})
この種の要素は、単一の@var{matcher}にたいして、複数の@var{highlighter}リストを指定する。@var{highlighter}リストには、上述した@var{subexp-highlighter}、または@var{anchored-highlighter}のいずれかを指定できる。

たとえば、

@smallexample
;; @r{@code{anchor-face}の値内に現れる単語@samp{anchor}、}
;; @r{および、(同じ行の)後続の@code{item-face}の}
;; @r{ 値内に現れる単語@samp{item}をハイライトする}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
ここで@var{form}は、バッファー内でこの@code{font-lock-keywords}の値が最初に使用されるときに評価される式である。この値は、上述のこのテーブルで説明した、いずれかの形式をもつべきである。
@end table

@strong{警告:}
複数行にわたるテキストにたいするマッチさせるために、@code{font-lock-keywords}の要素をデザインしてはならない。これは確実に機能するとは言えない。詳細は、@ref{Multiline
Font Lock}を参照のこと。

検索ベースのフォント表示が大文字小文字を区別すべきかどうかを告げる@code{font-lock-keywords-case-fold-search}の値を指定するために、@code{font-lock-defaults}内で@var{case-fold}を使用できる。

@defvar font-lock-keywords-case-fold-search
非@code{nil}は、@code{font-lock-keywords}のための正規表現マッチングが、大文字小文字を区別すべきではないことを意味する。
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  メジャーモードにたいして検索ベースフォント表示ルールを追加するために@code{font-lock-add-keywords}、削除には@code{font-lock-remove-keywords}を使用することができます。

@defun font-lock-add-keywords mode keywords &optional how
この関数は、カレントバッファー、またはメジャーモード@var{mode}にたいして、ハイライトする@var{keywords}を追加する。引数@var{keywords}は、変数@code{font-lock-keywords}と同じ形式のリストであること。

@var{mode}が、@code{c-mode}のような、あるメジャーモードのコマンド名であるようなシンボルの場合には、その@var{mode}内でFont
Lockモードを有効にすることにより、@var{keywords}が@code{font-lock-keywords}に追加される効果がある。非@code{nil}値の@var{mode}による呼び出しは、@file{~/.emacs}ファイル内でのみ正しい。

@var{mode}が@code{nil}の場合、この関数はカレントバッファーの@code{font-lock-keywords}に@var{keywords}を追加する。この方法での@code{font-lock-add-keywords}呼び出しは、通常はモードフック関数内で使用される。

デフォルトでは、@var{keywords}は@code{font-lock-keywords}の先頭に追加される。オプション引数@var{how}が@code{set}の場合、それらは@code{font-lock-keywords}の値の置換に使用される。@var{how}がそれ以外の非@code{nil}値の場合、これらは@code{font-lock-keywords}の最後に追加される。

追加のハイライトパターンの使用を可能にする、特別なサポートを提供するモードがいくつかある。それらの例については、変数@code{c-font-lock-extra-types}、@code{c++-font-lock-extra-types}、@code{java-font-lock-extra-types}を参照のこと。

@strong{警告:}
メジャーモードコマンドは、モードフックを除き、いかなる状況においても、直接間接を問わず@code{font-lock-add-keywords}を呼び出してはならない(これを行うと、いくつかのマイナーモードは不正な振る舞いを起こしかねない)。メジャーモードコマンドは、@code{font-lock-keywords}をセットすることにより、検索ベースフォント表示のルールをセットアップすべきである。
@end defun

@defun font-lock-remove-keywords mode keywords
この関数は、カレントバッファー、またはメジャーモード@var{mode}にたいして、@code{font-lock-keywords}から@var{keywords}を削除する。@code{font-lock-add-keywords}の場合と同様、@var{mode}はメジャーモードコマンド名か@code{nil}であること。@code{font-lock-add-keywords}にたいするすべての制約と条件は、この関数にも適用される。
@end defun

  たとえば、以下はCモードに2つのフォント表示パターンを追加するコードの例である。フォント表示の1つは、たとえコメント内であろうとも単語@samp{FIXME}をフォント表示し、もう1つは@samp{and}、@samp{or}、@samp{not}をキーワードとしてフォント表示する。

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
この例は、正にCモードだけに効果がある。Cモード、@emph{および}その派生モードにたいして同じパターンを追加するには、かわりに以下を行う:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

  このセクションでは、@code{font-lock-defaults}内の@var{other-vars}を用いて、メジャーモードがセットできる追加の変数について説明します(@ref{Font
Lock Basics}を参照)。

@defvar font-lock-mark-block-function
この変数が非@code{nil}の場合、それはコマンド@kbd{M-o
M-o}(@code{font-lock-fontify-block})で再フォント表示するテキスト範囲を選択するために、引数なしで呼び出される関数であること。

この関数は、結果を報告するために、選択されたテキスト範囲にリージョンを配すべきである。正しい結果を与えるのに十分、かつ再フォント表示が低速にならない程度のテキスト範囲を選択するのがよい。プログラミングのモードにたいしては@code{mark-defun}、テキストを扱うモードにたいしては@code{mark-paragraph}が典型的な値である。
@end defvar

@defvar font-lock-extra-managed-props
この変数は、(@code{font-lock-face}以外の)Font
Lockにより管理される追加プロパティを指定する。これらの追加プロパティは、通常は@code{font-lock-face}プロパティだけを管理する、@code{font-lock-default-unfontify-region}により使用される。他のプロパティも同様にFont
Lockに管理させたい場合は、このリストに追加するのと同じように、@code{font-lock-keywords}内の@var{facespec}内でもこれらを指定しなければならない。@ref{Search-based
Fontification}を参照のこと。
@end defvar

@defvar font-lock-fontify-buffer-function
そのバッファーをフォント表示するために使用する関数。デフォルト値は@code{font-lock-default-fontify-buffer}。
@end defvar

@defvar font-lock-unfontify-buffer-function
そのバッファーを非フォント表示するために使用する関数。デフォルト値は@code{font-lock-default-unfontify-buffer}。
@end defvar

@defvar font-lock-fontify-region-function
リージョンをフォント表示するための関数。この関数は、リージョンの開始と終了の2つを引数にとり、オプションで3つ目の引数@var{verbose}をとるべきである。@var{verbose}が非@code{nil}の場合、その関数はステータスメッセージをプリントすべきである。デフォルト値は@code{font-lock-default-fontify-region}。
@end defvar

@defvar font-lock-unfontify-region-function
リージョンを非フォント表示するための関数。この関数は、リージョンの開始と終了の2つを引数にとるべきである。デフォルト値は@code{font-lock-default-unfontify-region}。
@end defvar

@defun jit-lock-register function &optional contextual
この関数は、カレントバッファーの一部をフォント表示/非表示する必要がある任意のタイミングで、Font
LockモードがLisp関数@var{function}を実行することを宣言する。これは、デフォルトのフォント表示関数が呼び出される前に、フォント表示/非表示するリージョンを指定する2つの引数@var{start}と@var{end}で@var{function}を呼び出す。

オプション引数@var{contextual}が非@code{nil}の場合は、行が更新されたときに限らず、そのバッファーの構文的に関連する部分を常にフォント表示するよう、Font
Lockモードに強制する。この引数は、通常は省略できる。
@end defun

@defun jit-lock-unregister function
以前に@code{jit-lock-register}を使用して、フォント表示関数として@var{function}を登録した場合は、その関数を未登録にする。
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  フォント表示にたいして3つの異なるレベルを提供するモードが、いくつかあります。@code{font-lock-defaults}内の@var{keywords}にたいしてシンボルのリストを使用することにより、複数のレベルを定義できます。このリストのシンボルはそれぞれ、フォント表示の1レベルを指定します。これらのレベルの選択は、通常は@code{font-lock-maximum-decoration}をセットすることにより、ユーザーの責任で行われます(@ref{Font
Lock,,, emacs, the GNU Emacs
Manual}を参照)。選択されたレベルのシンボルの値は、@code{font-lock-keywords}の初期化に使用されます。

  フォント表示レベルの定義方法に関する慣習を以下に挙げます:

@itemize @bullet
@item
レベル1:
関数宣言、(includeやimportのような)ファイルディレクティブ、文字列、コメントをハイライトする。これは、もっとも重要かつトップレベルのコンポーネントだけをフォント表示すれば高速になるという発想である。

@item
レベル2:
レベル1に加えて、すべての言語のキーワード(キーワードと同様に作用する型名を含む)、および名前付き定数値をハイライトする。これは、(構文的、または意味的な)すべてのキーワードは適切にフォント表示されるべきという発想である。

@item
レベル3: レベル2に加えて、関数内で定義されるシンボル、変数宣言、およびすべてのビルトイン関数名にたいして、それがどこに出現しようとハイライトする。
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  @code{list-buffers}や@code{occur}のようないくつかのメジャーモードは、バッファーのテキストをプログラム的に構築します。これらにたいしてFont
Lockモードをサポートするには、そのバッファーにテキストを挿入するタイミングで、テキストのフェイスを指定するのが、もっとも簡単な方法です。

  これは、スペシャルテキストプロパティ@code{font-lock-face}(@ref{Special
Properties}を参照)により、テキスト内にフェイスを指定することにより行われます。Font
Lockモードが有効になったとき、このプロパティは@code{face}と同じように、表示を制御します。Font
Lockモードが無効になると、@code{font-lock-face}は表示に効果をもちません。

  モードが、通常のFont
Lockメカニズムとともに、あるテキストにたいして@code{font-lock-face}を使用しても問題はありません。しかし、そのモードが通常のFont
Lockメカニズムを使用しない場合は、変数@code{font-lock-face}をセットするべきではありません。

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Font
Lockモードは、ハイライトに任意のフェイスを使用できますが、Emacsは、特にFontLockがテキストのハイライトに使用するいくつかのフェイスを定義しています。これらの@dfn{Font
Lockフェイス(Font Lock
faces)}を、以下にリストします。これらのフェイスは、FontLockモードの外部における構文的なハイライトでメジャーモードが使用することもできます(@ref{Major
Mode Conventions}を参照)。

  以下の各シンボルは、フェイス名であり、かつデフォルト値がシンボル自身であるような変数でもあります。つまり、@code{font-lock-comment-face}のデフォルト値は@code{font-lock-comment-face}です。

  リストは、そのフェイスの典型的な使い方の説明とともに、``重要性''が大きい順にソートされています。あるモードの構文的カテゴリーが、以下の使い方の説明にうまく適合しない場合、この並び順をガイドとして使用することにより、フェイスを割り当てることができるでしょう。

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
Emacs
Lispの@samp{;;;###autoload}、Cの@samp{#error}のような、特有な構文、またはその他のテキスト意味を大きく変更する構文にたいして使用される。

@item font-lock-function-name-face
@vindex font-lock-function-name-face
定義、または宣言される関数の名前にたいして使用される。

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
定義、または宣言される変数の名前にたいして使用される。

@item font-lock-keyword-face
@vindex font-lock-keyword-face
Cの@samp{for}や@samp{if}のように、特別な構文的意味をもつキーワードにたいして使用される。

@item font-lock-comment-face
@vindex font-lock-comment-face
コメントにたいして使用される。

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
Cの@samp{/*}と@samp{*/}のような、コメント区切りにたいして使用される。ほとんどの端末では、このフェイスは@code{font-lock-comment-face}を継承する。

@item font-lock-type-face
@vindex font-lock-type-face
ユーザー定義データ型にたいして使用される。

@item font-lock-constant-face
@vindex font-lock-constant-face
Cの@samp{NULL}のような、定数の名前にたいして使用される。

@item font-lock-builtin-face
@vindex font-lock-builtin-face
ビルトイン関数の名前にたいして使用される。

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
プロセッサーコマンドにたいして使用される。デフォルトでは、@code{font-lock-builtin-face}を継承する。

@item font-lock-string-face
@vindex font-lock-string-face
文字列定数にたいして使用される。

@item font-lock-doc-face
@vindex font-lock-doc-face
コード内のドキュメント文字列にたいして使用される。デフォルトでは、@code{font-lock-string-face}を継承する。

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
見逃されやすい否定文字にたいして使用される。
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

構文的フォント表示(syntactic
fontification)は、構文的に関連性のあるテキストを探してハイライトするために、構文テーブル(syntax table:
@ref{Syntax
Tables}を参照)を使用します。有効な場合は、検索ベースフォント表示に先立ち実行されます。以下で説明する変数@code{font-lock-syntactic-face-function},は、どの構文的構造をハイライトするかを決定します。構文的フォント表示に影響を与える変数が、いくつかあります。@code{font-lock-defaults}のために、それらをセットするべきです(@ref{Font
Lock Basics}を参照)。

  Font
Lockモードが一連のテキストにたいして構文的フォント表示を処理するときは、常に@code{syntax-propertize-function}で指定される関数を最初に呼び出します。メジャーモードは、特別なケースでは@code{syntax-table}テキストプロパティを適用してバッファーの構文テーブルをオーバーライドするために、これを使用することができます。@ref{Syntax
Properties}を参照してください。

@defvar font-lock-keywords-only
この変数の値が非@code{nil}の場合、Font
Lockは構文的フォント表示を行わず、@code{font-lock-keywords}にもとづく検索ベースフォント表示だけを行う。これは通常、@code{font-lock-defaults}内の@var{keywords-only}要素にもとづき、Font
Lockモードによりセットされる。
@end defvar

@defvar font-lock-syntax-table
この変数は、コメントと文字列のフォント表示に使用するための構文テーブルを保持する。これは通常、@code{font-lock-defaults}内の@var{syntax-alist}要素にもとづき、Font
Lockモードによりセットされる。この値が@code{nil}の場合、構文的フォント表示は、バッファーの構文テーブル(関数@code{syntax-table}がリターンする構文テーブル。@pxref{Syntax
Table Functions}を参照)を使用する。
@end defvar

@defvar font-lock-beginning-of-syntax-function
この変数が非@code{nil}の場合、それは構文的に``トップレベル''で、かつ文字列やコメントの外部であるような位置に戻すようにポイントを移動する関数であること。この値は通常、@code{font-lock-defaults}内の@var{other-vars}要素を通じてセットされる。これが@code{nil}の場合、Font
Lockはコメント、文字列、sexpの外部に戻って移動するために@code{syntax-begin-function}を使用する(@ref{Position
Parse}を参照)。

この変数は、半ば時代遅れであり、通常はかわりに@code{syntax-begin-function}をセットすることを推奨する。これの用途の1つは、たとえば異なる種類の文字列やコメントを異なるようにハイライトする等、構文的フォント表示の振る舞いの調整する場合である。

指定された関数は、引数なしで呼び出される。この関数は、周囲の構文的ブロックの先頭にポイントを残すべきである。典型的な値は@code{beginning-of-line}(行頭が構文的ブロック外部であることが既知の場合に使用)、プログラミングのモードにたいしては@code{beginning-of-defun}、テキストを扱うモードにたいしては@code{backward-paragraph}が使用される。
@end defvar

@defvar font-lock-syntactic-face-function
この変数が非@code{nil}の場合、それは与えられた構文的要素にどのフェイスを使用するかを決定する関数であること。この値は通常、@code{font-lock-defaults}内の@var{other-vars}要素を通じてセットされる。

この関数は1つの引数で呼び出され、@code{parse-partial-sexp}がリターンするポイントの状態をパースして、フェイスをリターンすべきである。コメントにたいしては@code{font-lock-comment-face}、文字列にたいしては@code{font-lock-string-face}が、リターンされるデフォルト値である(@ref{Faces
for Font Lock}を参照)。
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  通常は、@code{font-lock-keywords}の要素は複数行にわたるマッチを行うべきではありません。それらの動作に信頼性はありません。なぜなら、Font
Lockは通常はバッファーのごく一部をスキャンするので、そのスキャンが開始される行境界をまたがる複数行構造を見逃しかねないからです(スキャンは通常、行頭から開始される)。

  ある要素にたいして、複数行構造にたいするマッチを正しく機能させるには、2つの観点があります。それは@emph{識別(identification)}の補正と、@emph{再ハイライト(rehighlighting)}の補正です。1つ目は、Font
Lockがすべての複数行構造を探すことを意味します。2つ目は、複数行構造が変更されたとき、たとえば以前は複数行構造の一部だったテキストが、複数行構造から除外されたときに、関連するすべてのテキストをFont
Lockに正しく再ハイライトさせることを意味します。これら2つの観点は密接に関連しており、一方を機能させることがもう一方を機能させるようなことが多々あります。しかし、信頼性のある結果を得るためには、これら2つの観点双方にたいして、明示的に注意しなければなりません。

  複数行構造の識別を確実に補正するには、3つの方法があります:

@itemize
@item
スキャンされるテキストが複数行構造の途中で開始、または終了することがないように@emph{識別}を行いスキャンを拡張する関数を、@code{font-lock-extend-region-functions}に追加する。
@item
同様に、スキャンされるテキストが複数行構造の途中で開始、または終了することがないようスキャンを拡張するために、@code{font-lock-fontify-region-function}フックを使用する。
@item
複数行構造がバッファーに挿入されたとき(または挿入後、Font
Lockがハイライトを試みる前の任意のタイミングで)、何らかの方法によりそれを正しく認識して、Font
Lockが複数行構造の途中で開始、または終了しないよう指示する@code{font-lock-multiline}でそれをマークする。
@end itemize

  複数行構造の再ハイライトを行うには、3つの方法があります:

@itemize
@item
その構造にたいして、正しく@code{font-lock-multiline}を配する。これにより、その構造の一部が変更された場合は、構造全体が再ハイライトされるだろう。あるケースにおいては、それを参照する@code{font-lock-multiline}変数をセットすることにより、これを自動的に行うことができる。
@item
@code{jit-lock-contextually}を確実にセットして、それが行う処理に委ねる。これにより、実際の変更に続いて構造の一部だけが、若干の遅延の後に再ハイライトされるだろう。これは、複数行構造のさまざまな箇所のハイライトが、後続行のテキストに依存しない場合のみ機能する。@code{jit-lock-contextually}はデフォルトでアクティブなので、これは魅力的な解決策になり得る。
@item
その構造上に、正しく@code{jit-lock-defer-multiline}を配する。これは、@code{jit-lock-contextually}が使用された場合のみ機能し、再ハイライト前に同様の遅延を伴うが、@code{font-lock-multiline}のように後続行に依存する箇所のハイライトも処理する。
@end itemize

@menu
* Font Lock Multiline::      テキストプロパティで複数行塊をマークする。
* Region to Refontify::      バッファー変更後にどのリージョンを再フォント表示するかを制御する。
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  複数行構造のFont
Lockを確実に再ハイライトする方法の1つは、それらをテキストプロパティ@code{font-lock-multiline}にputする方法です。複数行構造の一部であるようなテキストにたいしては、このプロパティが存在し、値が非@code{nil}であるべきです。

  Font
Lockがテキスト範囲をハイライトしようとする際は、それらが@code{font-lock-multiline}プロパティでマークされたテキストにならないように、まず必要に応じて範囲の境界を拡張します。それから、その範囲のすべての@code{font-lock-multiline}を削除して、ハイライトします。ハイライト指定(大抵は@code{font-lock-keywords})は、適宜このプロパティを毎回再インストールしなければなりません。

  @strong{警告:}
ハイライトが低速になるので、大きなテキスト範囲にたいして@code{font-lock-multiline}を使用してはならない。

@defvar font-lock-multiline
@code{font-lock-multiline}変数が@code{t}にセットされている場合、Font
Lockは自動的に複数行構造にたいして@code{font-lock-multiline}プロパティの追加を試みる。しかし、これによりFont
Lockが幾分遅くなるので、普遍的解ではない。これは、何らかの複数行構造を見逃したり、必要なものより多く、または少なくプロパティをセットするかもしれない。

@var{matcher}が関数であるような要素は、たとえ少量のサブパート(subpart)だけがハイライトされるような場合でも、submatch
0(訳注:正規表現の後方参照においてsubmatch
0はマッチした文字列全体を指す)が関連する複数行構造全体を確実に網羅するようにすべきである。単に手動で@code{font-lock-multiline}を追加するのが容易な場合も多々ある。
@end defvar

  @code{font-lock-multiline}プロパティは、正しい再フォント表示を確実に行うことを意図しています。これは、新たな複数行構造を自動的に認識しません。Font
Lockの処理を要するものにたいする認識は、一度に処理を行うのに十分な大きさのchunkにたいして行われます。これは多くの場合にアクシデントにより発生し得るかもしれないので、複数行構造が不可解に機能するような印象を与えるかもしれません。変数@code{font-lock-multiline}を非@code{nil}にセットした場合、発見されたこれらの構造にたいするハイライトは、変数をセットした後は正しく更新されるので、さらにこの印象が強くなるでしょう。しかし、これは信頼性をもって機能しません。

  信頼性を保ち複数行構造を見つけるためには、Font
Lockが調べる前にテキストの@code{font-lock-multiline}プロパティを手動で配すか、@code{font-lock-fontify-region-function}を使用しなければなりません。

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  バッファーが変更されたとき、Font
Lockが再フォント表示するリージョンは、デフォルトではその変更に関連する、最小の行全体からなるシーケンスです。これはほとんどの場合は良好に機能しますが、うまく機能しないとき(たとえば、その変更がそれより前の行のテキストの構文的な意味を変更してしまうとき)もあります。

  以下の変数をセットすることにより、再フォント表示するリージョンを拡張(または縮小さえ)することができます:

@defvar font-lock-extend-after-change-region-function
このバッファーローカル変数は@code{nil}、またはFont
Lockモードにたいしてスキャンしてフォント表示すべきリージョンを決定するために呼び出される関数である。

この関数には、標準的な@var{beg}と@var{end}、および@code{after-change-functions}の@var{old-len}(@ref{Change
Hooks}を参照)という、3つのパラメーターが渡される。この関数はフォント表示するリージョンのバッファー位置の開始と終了(この順で)からなるコンスセル、または@code{nil}(標準的な方法でリージョンを選択することを意味する)のいずれかをリターンすべきである。この関数は、ポイント位置、match-data、カレントのナローイングを保つ必要がある。これがリターンするリージョンは、行の途中で開始、または終了するかもしれない。

この関数はバッファーを変更するたびに呼び出されるので、有意に高速であること。
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

プログラミング言語のメジャーモードにとって、自動的なインデントの提供は、重要な機能です。これには2つのパートがあります。1つ目は正しい行のインデントが何か、そして2つ目はいつ行を再インデントするかの判断です。デフォルトでは、@code{electric-indent-chars}に含まれる文字(デフォルトでは改行のみ)をタイプしたとき、Emacsは常に行を再インデントします。メジャーモードは、その言語の構文に合わせて、@code{electric-indent-chars}に文字を追加できます。

正しいインデントの決定は、@code{indent-line-function}によりEmacs内で制御されます(@ref{Mode-Specific
Indent}を参照)。いくつかのモードでは、@emph{右}へのインデントは信頼性がないことが知られています。これは通常、複数のインデントが有効だが、それぞれが異なる意味をもつので、インデント自体が重要だからです。そのような場合、そのモードは行が常にユーザーの望み通り再インデントされないことを念押しするために、@code{electric-indent-inhibit}をセットするべきです。

よいインデント関数の記述は難しく、その広範な領域において、未だ黒魔術の域を脱していません。メジャーモード作者の多くは、単純なケース(たとえば前のテキスト行のインデントとの比較)にたいして機能する、単純な関数の記述からスタートすることでしょう。実際には行ベースではないほとんどのプログラミング言語にたいして、これは貧弱なスケールになりがちです。そのような関数にたいして、より多様な状況を処理するような改良を行うと、関数はより一層複雑になり、最終的な結果は誰にも触れようとする気を起こさせない、巨大で複雑な保守不可能のインデント関数になる傾向があります。

よいインデント関数は通常、その言語の構文に応じて、実際にテキストをパースする必要があるでしょう。幸運なことに、このテキストパースはコンパイラーが要するほど詳細である必要はないでしょうが、その一方でインデントコードに埋め込まれたパーサーは、構文的に不正なコードにたいして、コンパイラーより幾分寛容な振る舞いを求められるでしょう。

保守可能なよいインデント関数は、通常2つのカテゴリーに落ち着きます。どちらも何らかの``安全''な開始ポイントから、関心のある位置まで前方にパースを行うか、あるいは後方へパースを行います。この2つの方法は、どちらも一方が他方に明快に優る選択ではありません。後方へのパースは、プログラミング言語が前方にパースされるようデザインされているため、前方へのパースに比べて難しいことが多々ありますが、インデントという目的においては``安全''な開始ポイントを推測する必要がないという利点があり、一般的にある行のインデントの判断のために分析を要するのは最小限のテキストだけという特性に恵まれているので、前の無関係なコード片内にある、何らかの構文エラーの影響をインデントが受けにくくなる傾向があります。一方で前方へのパースは、通常はより簡単であり、一度のパースで、リージョン全体を効果的に再インデントすることが可能になるという利点があります。

インデント関数をスクラッチから記述するよりも、既存のインデント関数の試用と再利用、または一般的なインデントエンジンに委ねるほうが優る場合が、しばしばあります。しかし、そのようなエンジンは悲しむべきほど少数しかありません。CCモードのインデントコード(C、C++、Java、Awk、およびその類のモードが使用)は年月を経てより一般化されてきているので、あなたの言語にこれらの言語と何らかの相似点があるなら、このエンジンの使用を試みるかもしれません。もう一方のSMIEはLispのsexp精神によるアプローチを採用して、それを非Lisp言語に適応します。

@menu
* SMIE::                     SMIE: Simple Minded Indentation 
                               Engine(純真なインデントエンジン)
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIEは、一般的な操作とインデントを提供するエンジンです。これは``演算子順位文法(operator precedence
grammar)''を使用する、非常にシンプルなパーサーにもとづいたエンジンであり、メジャーモードがLispのS式ベースの操作を非Lisp言語に拡張するのを助け、同様にシンプルに使用できるにも関わらず、信頼できる自動インデントを提供します。

演算子順位文法は、コンパイラー内で使用されるより一般的なパーサーと比較すると、非常に原始的なパーステクノロジーです。このパーサーには次のような特徴があります。このパーサーのパース能力は非常に限定的で、大概は構文エラーを検出できません。しかし、アルゴリズム的に前方パースと同様に後方パースを効果的に行うことが可能です。実際にそれはSMIEが後方パースにもとづくインデントを使用でき、@code{forward-sexp}と@code{backward-sexp}の両方の機能を提供できるとともに、特別な努力を要さずに構文的に不正なコードにたいして自然に機能するであろうことを意味します。欠点は、ほとんどのプログラミング言語は、少なくとも何らかの特別なトリック(@ref{SMIE
Tricks}を参照)で再分類しなければ、SMIEを使用して正しくパースできないことも意味するからです。

@menu
* SMIE setup::               SMIEのセットアップと機能。
* Operator Precedence Grammars::  非常にシンプルなパース技術。
* SMIE Grammar::             言語の文法を定義する。
* SMIE Lexer::               トークンの定義。
* SMIE Tricks::              パーサー制限の回避策。
* SMIE Indentation::         インデントルールの指定。
* SMIE Indentation Helpers::  インデントルールにたいするヘルパー関数。
* SMIE Indentation Example::  インデントルールの例。
* SMIE Customization::       インデントのカスタマイズ。
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

SMIEは、構造的な操作と、コードの構造的構造にもとづくその他さまざまな機能、特に自動インデントにたいするワンストップショップ(一カ所で必要な全ての買い物ができること、またはそのような場所)であることを意図しています。メインのエントリーポイントは@code{smie-setup}で、これは通常メジャーモードセットアップの間に呼び出される関数です。

@defun smie-setup grammar rules-function &rest keywords
SMIEの操作とインデントをセットアップする。@var{grammar}は@code{smie-prec2->grammar}により生成される文法テーブル(grammar
table)、@var{rules-function}は@code{smie-rules-function}で使用されるインデントルールのセット、@var{keywords}は追加の引数であり以下のキーワードを含むことができる:
@itemize
@item
@code{:forward-token} @var{fun}: 使用する前方lexer(lexer=lexical analyzer:
字句解析プログラム)を指定する。
@item
@code{:backward-token} @var{fun}: 使用する後方lexerを指定する。
@end itemize
@end defun

この関数を呼び出せば、@code{forward-sexp}、@code{backward-sexp}、@code{transpose-sexps}のようなコマンドが、すでに構文テーブルにより処理されている単なるカッコのペアー以外の、構造的な要素を正しく扱うことができるようになります。たとえば、与えられた文法が十分に明快ならば、@code{transpose-sexps}はその言語の優先順位のルールを考慮して、@code{+}演算子の2つの引数を正しく入れ替えることができます。

`smie-setup'の呼び出しもまた、TABによるインデントを期待通り機能させ、@code{begin...end}のような要素に適用するために@code{blink-matching-paren}を拡張し、そのメジャーモードのキーマップ内でバインドできるいくつかのコマンドを提供するのに十分です。

@deffn Command smie-close-block
このコマンドは、もっとも最近オープンされた(まだクローズされていない)ブロックをクローズする。
@end deffn

@deffn Command smie-down-list &optional arg
このコマンドは@code{down-list}と似ているが、@code{begin...end}のようなカッコ以外のネストされたトークンにも注意を払う。
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

SMIEの演算子順位文法は、各トークンにたいしてシンプルに左優先(left-precedence)と右優先(right-precedence)という順位ペアーを与えます。トークン@code{T1}の右優先が、トークン@code{T2}の左優先より小さい場合は、@code{T1
< T2}であると言うことにしましょう。これを解読するには、@code{<}をカッコの一種だとみなすのがよい方法です。@code{... T1
something T2 ...}を見つけたら、これは@code{... T1 something) T2 ...}ではなく@code{... T1
(something T2 ...}とパースされるべきです。@code{... T1 something) T2
...}と解釈するのは、@code{T1 > T2}を見つけた場合でしょう。@code{T1 =
T2}を見つけた場合、それはトークンT2とその後のトークンT1が同じ構文構成にあり、通常は@code{"begin" =
"end"}を得ます。このような優先順位のペアーは、2項演算子(infix
operator)、カッコのようなネストされたトークン、およびその他多くのケースにたいして左結合(left-associativity)や右結合(right-associativity)を表現するのに十分です。

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
この関数は、@emph{prec2}文法@var{table}を引数にとり、@code{smie-setup}で使用するのに適したalistをリターンする。@emph{prec2}文法@var{table}は、それ自体が以下の関数のいずれかによりビルドされることを意図している。
@end defun

@defun smie-merge-prec2s &rest tables
この関数は、複数の@emph{prec2}文法@var{tables}を、新たな@emph{prec2}テーブルにマージする。
@end defun

@defun smie-precs->prec2 precs
この関数は、順位テーブル@var{precs}から@emph{prec2}テーブルをビルドする。@var{precs}は優先順(たとえば@code{"+"}は@code{"*"}より前にくる)にソートされたリストで、要素は@code{(@var{assoc}
@var{op}
...)}の形式であること。ここで、@var{op}は演算子として振る舞うトークン、@var{assoc}はそれらの結合法則であり、@code{left}、@code{right}、@code{assoc}、@code{nonassoc}のいずれかである。与えられた要素内のすべての演算子は、同じ優先レベルと結合法則を共有する。
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
この関数により、BNF記法を使用した文法を指定することができる。これは、その文法の@var{bnf}表記と、同様に競合解決ルール@var{resolvers}を受け取り、@emph{prec2}テーブルをリターンする。

@var{bnf}は@code{(@var{nonterm} @var{rhs1} @var{rhs2}
...)}という形式の非終端定義で、各@var{rhs}は終端記号(トークンとも呼ばれる)、または非終端記号の(空でない)リストである。

すべての文法が許される訳ではない:
@itemize
@item
@var{rhs}に空のリストは指定できない(いずれにせよSMIEは空文字列にマッチさせるためにすべての非終端記号を許すので、空リストが必要になることは決してない)。
@item
@var{rhs}の後に連続する2つの非終端記号は指定できない。非終端記号の各ペアーは終端記号(もしくはトークン)で区切られる必要がある。これは、演算子順位文法の基本的な制約である。
@end itemize

さらに、競合が発生し得る:
@itemize
@item
リターンされる@emph{prec2}テーブルはトークンのペアー間の制約を保持し、与えられた任意のペアーはT1 < T2、T1 = T2、T1 >
T2のいずれかのうち、ただ1つの制約を与えることができる。
@item
トークンは、@code{opener}(開きカッコに似た何か)、@code{closer}(閉じカッコのようなもの)、またはこれら2つのいずれでもない@code{neither}(2項演算子や@code{"else"}のようなinnerトークン)である。
@end itemize

順位の競合は、@var{resolvers}を通じて解決され得る。これは@emph{precs}テーブル(@code{smie-precs->prec2}を参照)のリストである。それぞれの順位競合にたいして、これらの@code{precs}テーブルが特定の制約を指定している場合は、かわりにこの制約により競合が解決され、それ以外は競合する制約のうち任意の1つが報告され、他は単に無視される。
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

ある言語にたいしてSMIE文法を定義する通常の方法は、順位のテーブルを保持する新たなグローバル変数を定義して、BNFルールのセットを与える方法です。たとえば、小規模なPascal風言語の文法定義は、以下のようになるでしょう:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
注意すべき点がいくつかあります:

@itemize
@item
上記の文法は、関数呼び出しの構文に明示的に言及していない。SMIEは識別子、対応がとれたカッコ(balanced
parentheses)、または@code{begin
... end}ブロックのようなsexpの任意のシーケンスが、どこに、どのように出現しても、自動的にそれを許容するだろう。
@item
文法カテゴリー@code{id}は、右側に何ももたない。これは、@code{id}が空文字列だけにマッチ可能なことを意味しない。なぜなら上述のように、任意のsexpシーケンスは、どこに、どのような方法でも出現するからである。
@item
BNF文法では非終端記号が連続して出現し得ないので、終端記号として作用するトークンを正しく扱うのが困難なので、上述の文法では、SMIEが容易に扱える@code{";"}を、@emph{セパレーター(separator)}ステートメントのかわりとして扱っている。
@item
シーケンス内で使用される、(上記の@code{","}や@code{";"}のような)セパレーターは、BNFルールでは@code{(foo (foo
"separator" foo) ...)}のように定義するのが最善である。これは、順位の競合を生成するが、明示的に@code{(assoc
"separator")}を与えることにより解決される、
@item
SMIEは、構文テーブル(syntax table)内でカッコ構文(paren
syntax)をもつようにマークされたー任意の文字をペアーにするだろうから、@code{("(" exps
")")}ルールにカッコをペアーにする必要はなかった。(@code{exps}の定義と併せて)このルールはかわりに、@code{","}がカッコの外に出現すべきではないことを明確にする。
@item
競合解決のための@emph{precs}テーブルは、単一のテーブルより複数のテーブルをもつほうが、可能な場合は文法のBNF部分が関連する順位を指定できるので、優れている。
@item
@code{left}または@code{right}を選択すること優るという明白な理由がない場合は、通常は@code{assoc}を使用して演算子を結合演算子(associative)とマークするほうが優れている。この理由により、上述の@code{"+"}と@code{"*"}は、たとえその言語がそれらを形式上は左結合(left
associative)と定義していても、@code{assoc}として定義されている。
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

SMIEには、事前定義された字句解析プログラムが付属しており、それは次の方法で構文テーブルを使用します:
文字の任意のシーケンスは、トークンとみなせる単語構文(word syntax)、またはシンボル構文(symbol
syntax)をもち、句読点構文(punctuation
syntax)をもつ任意の文字シーケンスもトークンとみなされます。このデフォルトのlexerは、開始ポイントとして適している場合が多々ありますが、任意の与えられた言語にたいして、実際に正しいことは稀です。たとえば、これは@code{"2,+3"}が3つのトークン@code{"2"}、@code{",+"}、@code{"3"}から構成されていると判断するでしょう。

あなたの言語のlexerルールをSMIEにたいして説明するためには、次のトークンをfetchする関数と、前のトークンをfetchする関数の、2つの関数が必要になります。これらの関数は通常、最初に空白文字とコメントをスキップして、その後に次のテキストchunk(塊)を調べて、それが特別なトークンか確認します。これは通常、バッファーから単に抽出された文字列ですが、あなたが望む他の何かでも構いません。たとえば:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

これらのlexerがカッコの前にあるとき、空文字列をリターンする方法に注目してください。これは、SMIEが構文テーブル内で定義されているカッコにたいして、自動的に配慮するからです。より厳密には、lexerが@code{nil}、または空文字列をリターンした場合、SMIEは構文テーブルにしたがい、対応するテキストをsexpとして処理します。

@node SMIE Tricks
@subsubsection Living With a Weak Parser

SMIEが使用するパーステクニックは、異なるコンテキストでトークンが異なる振る舞いをすることを許しません。ほとんどのプログラミング言語にたいして、これは順位の競合によりBNF文法を変換するとき明らかになります。

その文法を若干異なるように表現することにより、これらの競合を回避できる場合があります。たとえばModula-2にたいしては、以下のようなBNF文法をもつのが自然に思えるかもしれません:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

しかし、これは@code{"ELSE"}にたいする競合を生み出すでしょう。その一方でIFルールは、(他の多くのものの中でも特に)@code{"ELSE"
=
"END"}を暗示します。しかしその一方では、@code{"ELSE"}は@code{cases}内に出現しますが、@code{cases}は@code{"END"}の左に出現するので、わたしたちは@code{"ELSE"
> "END"}も得ることになります。これは、以下を使用して解決できます:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
または
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

文法を書き換えによる競合の解決には欠点があります。なぜなら、SMIEはその文法がコードの論理的構造を反映すると仮定するからです。そのため、BNFと意図する抽象的構文木の関係を密接に保つことが望まれます。

注意深く考慮した後に、これらの競合は深刻ではなく、@code{smie-bnf->prec2}の@var{resolvers}引数を通じて解決する決心する場合もあるでしょう。これは通常、その文法が単に不明瞭だからです。その文法により記述されるプログラムセットは競合の影響を受けませんが、それらのプログラムにたいする唯一の方法はパースだけです。@code{'((assoc
"|"))}のようなリゾルバ(resolver:
解決するもの)を追加したいと望むような場合、通常それはセパレーターと2項結合演算子にたいするケースです。これが発生し得る他のケースは、@code{'((assoc
"else" "then"))}を使用するような場合における、古典的な@emph{ぶら下がりelse問題dangling else
problem}です。これは実際に競合があり解決不能だが、実際のところ問題が発生しそうにないケースにたいしても、発生し得ます。

最後に、多くのケースでは、すべての文法再構築努力にも関わらず、いくつかの競合が残るでしょう。しかし失望しないでください。パーサーをより賢くすることはできませんが、あなたの望むようにlexerをスマートにすることは可能です。その方法は、競合が発生したら競合を引き起こしたトークンを調べて、それらのうちの1つを2つ以上の異なるトークンに分割する方法です。たとえば、トークン@code{"begin"}にたいする互換性のない2つの使用を文法が区別する必要があり、見つかった@code{"begin"}の種類により、lexerに異なるトークン(たとえば@code{"begin-fun"}と@code{"begin-plain"})をリターンさせる場合です。これはlexerにたいして、異なるケースを区別する処理を強い、そのためにlexerは特別な手がかりを見つけるために、周囲のテキストを調べる必要があるでしょう。

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

提供された文法にもとづき、他に特別なことを行わなくても、SMIEは自動的なインデントを提供できるでしょう。しかし実際には、このデフォルトのインデントスタイルでは、恐らく十分ではありません。多くの異なる状況において、これを微調整したいと思うかもしれません。

SMIEのインデントは、インデントルールは可能な限りローカルであるべきという考えにもとづきます。@emph{バーチャルインデント(virtual
indentation)}という考えによって、この目的を達成します。これは、特定のプログラムポイント(program
point)は行頭にバーチャルインデントがある場合は、それをもつだろう、という発想です。もちろん、そのプログラムポイントが正に行頭にある場合は、そのプログラムポイントのバーチャルインデントは、プログラムポイントのカレントのインデントです。しかしそうでない場合は、SMIEがそのポイントのバーチャルインデントを計算するために、インデントアルゴリズムを使用します。ところで実際には、あるプログラムポイントのバーチャルインデントは、その前に改行を挿入した場合にプログラムポイントがもつであろうインデントと等しい必要はありません。これが機能する方法を確認するためには、Cにおける@code{@{}の後のSMIEのインデントルールは、@code{@{}がインデントする行自体にあるか、あるいは前の行の終端にあるかを配慮しないことが挙げられます。かわりに、これらの異なるケースは、@code{@{}の前のインデントを決定するインデントルール内で処理されます。

他の重要な考え方として、@emph{parent}の概念があります。あるトークン@emph{parent}は、周囲にある直近の構文構造の代表トークン(head
token)です。たとえば、@code{else}のparentは、それが属する@code{if}であり、@code{if}のparentは周囲を取り囲む構造の先導トークン(lead
token)です。コマンド@code{backward-sexp}は、あるトークンからトークンのparentにジャンプしますが、注意点がいくつかあります。@emph{opener}(@code{if}のような、ある構造を開始するトークン)にたいしては、他のトークンではそのトークンの後のポイントから開始する必要があるのにたいして、opnerではそのトークンの前のポイントから開始する必要があります。@code{backward-sexp}はparentトークンがそのトークンの@emph{opener}の場合はparentトークンの前のポイントで停止し、それ以外ではparentトークンの後のポイントで停止します。

SMIEのインデントルールは、2つの引数@var{method}と@var{arg}をとる関数により指定されます。ここで@var{arg}の値と期待されるリターン値は、@var{method}に依存します。

@var{method}は、以下のいずれかを指定できます:
@itemize
@item
@code{:after}:
この場合、@var{arg}はトークンであり、関数は@var{arg}の後に使用するインデントにたいする@var{offset}をリターンすべきである。
@item
@code{:before}:
この場合、@var{arg}はトークンであり、関数は@var{arg}自体に使用するインデントの@var{offset}をリターンすべきである。
@item
@code{:elem}:
この場合、関数は関数の引数に使用するインデントのオフセット(@var{arg}が@code{arg}の場合)、または基本的のインデントステップ(@var{arg}が@code{basic}の場合)、のいずれかをリターンすべきである。
@item
@code{:list-intro}:
この場合、@var{arg}はトークンであり、関数はそのトークンの後が単一の式ではなく、(任意のトークンにより区切られない)式のリストが続く場合は非@code{nil}をリターンすべきである。
@end itemize

@var{arg}がトークンのとき、関数はそのトークンの直前のポイントで呼び出されます。リターン値@code{nil}は常にデフォルトの振る舞いへのフォールバックを意味するので、関数は期待した引数でないときは@code{nil}をリターンするべきです。

@var{offset}は、以下のいずれかを指定できます:
@itemize
@item
@code{nil}: デフォルトのインデントルールを使用する。
@item
@code{(column . @var{column})}: 列@var{column}にインデントする。
@item
@var{number}: 基本トークン(base token:
@code{:after}にたいするカレントトークンであり、かつ@code{:before}にたいしてparentであるようなトークン)にたいして相対的な、@var{number}によるオフセット。
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

SMIEは、インデントを決定する関数内で使用するために特別にデザインされた、さまざまな関数を提供します(これらの関数のうちのいくつかは、異なるコンテキスト内で使用された場合は中断する)。これらの関数はすべて、プレフィックス@code{smie-rule-}で始まります。

@defun smie-rule-bolp
カレントトークンが行の先頭にある場合は、非@code{nil}をリターンする。
@end defun

@defun smie-rule-hanging-p
カレントトークンが@emph{hanging(ぶら下がり)}の場合は、非@code{nil}をリターンする。トークンがその行の最後のトークンであり、他のトークンが先行する場合、そのトークンは@emph{hanging}である。行に単独のトークンはhangingではない。
@end defun

@defun smie-rule-next-p &rest tokens
次のトークンが@var{tokens}内にある場合は、非@code{nil}をリターンする。
@end defun

@defun smie-rule-prev-p &rest tokens
前のトークンが@var{tokens}内にある場合は、非@code{nil}をリターンする。
@end defun

@defun smie-rule-parent-p &rest parents
カレントトークンのparentが@var{parents}内にある場合は、非@code{nil}をリターンする。
@end defun

@defun smie-rule-sibling-p
カレントトークンのparentが実際はsibling(兄弟)の場合は、非@code{nil}をリターンする。たとえば@code{","}のparentが直前の@code{","}のような場合が該当する。
@end defun

@defun smie-rule-parent &optional offset
カレントトークンをparentとアライン(align:
桁揃え)するための適切なオフセットをリターンする。@var{offset}が非@code{nil}の場合、それは追加オフセットとして適用される整数であること。
@end defun

@defun smie-rule-separator method
@emph{セパレーター(separator)}としてカレントトークンをインデントする。

ここでの@emph{セパレーター}は、周囲を取り囲む何らかの構文構造内でさまざまな要素を区切ることを唯一の目的とするトークンであり、それ自体は何も意味をもたないトークン(通常は抽象構文木内でノードとして存在しない)を意味する。

このようなトークンは結合構文をもち、その構文的parentと密に結び付けられることが期待される。典型的な例としては引数リスト内の@code{","}(カッコで括られた内部)、または命令文シーケンス内の@code{";"}(@code{@{...@}}や@code{begin...end}で括られたブロックの内部)が挙げられる。

@var{method}は、`smie-rules-function'に渡されるメソッド名であること。
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Here is an example of an indentation function:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
注意すべき点がいくつかあります:

@itemize
@item
The first case indicates the basic indentation increment to use.  If
@code{sample-indent-basic} is @code{nil}, then SMIE uses the global setting
@code{smie-indent-basic}.  The major mode could have set
@code{smie-indent-basic} buffer-locally instead, but that is discouraged.

@item
The rule for the token @code{","} make SMIE try to be more clever when the
comma separator is placed at the beginning of lines.  It tries to outdent
the separator so as to align the code after the comma; for example:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
The rule for indentation after @code{":="} exists because otherwise SMIE
would treat @code{":="} as an infix operator and would align the right
argument with the left one.

@item
The rule for indentation before @code{"begin"} is an example of the use of
virtual indentation: This rule is used only when @code{"begin"} is hanging,
which can happen only when @code{"begin"} is not at the beginning of a
line.  So this is not used when indenting @code{"begin"} itself but only
when indenting something relative to this @code{"begin"}.  Concretely, this
rule changes the indentation from:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
to
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"} as a
single unit, so as to align a sequence of tests rather than indent each test
further to the right.  This function does this only in the case where the
@code{"if"} is not placed on a separate line, hence the
@code{smie-rule-bolp} test.

If we know that the @code{"else"} is always aligned with its @code{"if"} and
is always at the beginning of a line, we can use a more efficient rule:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

The advantage of this formulation is that it reuses the indentation of the
previous @code{"else"}, rather than going all the way back to the first
@code{"if"} of the sequence.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this on a
per-mode basis (using the option @code{smie-config}), or a per-file basis
(using the function @code{smie-config-local} in a file-local variable
specification).

@defopt smie-config
This option lets you customize indentation on a per-mode basis.  It is an
alist with elements of the form @code{(@var{mode} . @var{rules})}.  For the
precise form of rules, see the variable's documentation; but you may find it
easier to use the command @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
This command tries to work out appropriate settings to produce your
preferred style of indentation.  Simply call the command while visiting a
file that is indented with your style.
@end deffn

@deffn Command smie-config-save
Call this command after using @code{smie-config-guess}, to save your
settings for future sessions.
@end deffn

@deffn Command smie-config-show-indent &optional move
This command displays the rules that are used to indent the current line.
@end deffn

@deffn Command smie-config-set-indent
This command adds a local rule to adjust the indentation of the current
line.
@end deffn

@defun smie-config-local rules
This function adds @var{rules} as indentation rules for the current buffer.
These add to any mode-specific rules defined by the @code{smie-config}
option.  To specify custom indentation rules for a specific file, add an
entry to the file's local variables of the form: @code{eval:
(smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

@dfn{Desktop Save Mode} is a feature to save the state of Emacs from one
session to another.  The user-level commands for using Desktop Save Mode are
described in the GNU Emacs Manual (@pxref{Saving Emacs Sessions,,, emacs,
the GNU Emacs Manual}).  Modes whose buffers visit a file, don't have to do
anything to use this feature.

For buffers not visiting a file to have their state saved, the major mode
must bind the buffer local variable @code{desktop-save-buffer} to a
non-@code{nil} value.

@defvar desktop-save-buffer
If this buffer-local variable is non-@code{nil}, the buffer will have its
state saved in the desktop file at desktop save.  If the value is a
function, it is called at desktop save with argument @var{desktop-dirname},
and its value is saved in the desktop file along with the state of the
buffer for which it was called.  When file names are returned as part of the
auxiliary information, they should be formatted using the call

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

For buffers not visiting a file to be restored, the major mode must define a
function to do the job, and that function must be listed in the alist
@code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Alist with elements

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

The function @var{restore-buffer-function} will be called with argument list

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

and it should return the restored buffer.  Here @var{desktop-buffer-misc} is
the value returned by the function optionally bound to
@code{desktop-save-buffer}.
@end defvar
