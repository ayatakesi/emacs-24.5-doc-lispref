@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Modes
@chapter Major and Minor Modes
@cindex mode

  @dfn{モード(mode)}とは、Emacsをカスタマイズする定義のセットであり、編集時にオン/オフを切り替えることができます。モードには2つの種類があります。@dfn{メジャーモード(major
modes)}とは、互いに排他なモードであり、特定の種類のテキストの編集にたいして使用されます。@dfn{マイナーモード(minor
modes)}とは、ユーザーが個別に有効にすることができる機能を提供します。

  このチャプターでは、メジャーモード、およびマイナーモードを記述する方法、モードラインにそれらを示す方法、そしてそれらのモードがユーザーが提供するフックを実行する方法について説明します。キーマップ(keymaps)や構文テーブル(syntax
tables)のような関連するトピックについては@ref{Keymaps}および@ref{Syntax Tables}を参照してください。

@menu
* Hooks::                    フックの使い方と、フックを提供するコードの記述方法。
* Major Modes::              メジャーモードの定義。
* Minor Modes::              マイナーモードの定義。
* Mode Line Format::         モードラインに表示されるテキストのカスタマイズ。
* Imenu::                    バッファーで作成された定義のメニューを提供する。
* Font Lock Mode::           モードが構文に応じてテキストをハイライトする方法。
* Auto-Indentation::         メジャーモードにたいするインデントをEmacsに伝える方法。
* Desktop Save Mode::        Emacsセッション間でモードがバッファー状態を保存する方法。
@end menu

@node Hooks
@section Hooks
@cindex hooks

  @dfn{フック(hook)}とは、既存のプログラムから特定のタイミングで呼び出される関数(複数可)を格納することができる変数のことです。Emacsはカスタマイズ用にフックを提供します。ほとんどの場合は、initファイル内(@ref{Init
File}を参照)でフックをセットアップしますが、Lispプログラムもフックをセットできます。標準的なフック変数のリストは、@ref{Standard
Hooks}を参照してください。

@cindex normal hook
  Emacsのほとんどのフックは、@dfn{ノーマルフック(normal
hooks)}です。これらの変数は、引数なしで呼び出される、関数のリストを含んでいます。慣習により、フック名が@samp{-hook}で終わるフックは、そのフックがノーマルフックであることを意味します。わたしたちは、一貫した方法でフックを使用できるよう、すべてのフックが可能な限りノーマルフックとなるよう努力しています。

  すべてのメジャーモードコマンドは、初期化の最終ステップの1つとして、@dfn{モードフック(mode
hook)}と呼ばれるノーマルフックを実行するとみなされます。これにより、そのモードによりすでに作成されたバッファーローカル変数割り当てをオーバーライドすることにより、ユーザーがそのモードの動作をカスタマイズするのが簡単になります。ほとんどのマイナーモード関数も、最後にモードフックを実行します。しかし、フックは他のコンテキストでも使用されます。たとえばフック@code{suspend-hook}は、Emacsが自身をサスペンド(@ref{Suspending
Emacs}を参照)する直前に実行されます。

  フックにフック関数を追加するには、@code{add-hook}(@ref{Setting
Hooks}を参照)を呼び出す方法が推奨です。フック関数は、@code{funcall}(@ref{What Is a
Function}を参照)が受け入れる任意の種類の関数を指定できます。ほとんどのフック変数の初期値はvoidです。@code{add-hook}は、これを扱う方法を知っています。@code{add-hook}により、グローバルフック、またはバッファーローカルフックのどちらを追加することも可能です。

@cindex abnormal hook
  フック変数の名前が@samp{-hook}で終わらない場合は、それが恐らく@dfn{アブノーマルフック(abnormal
hook)}であることを示しています。こええは、フック関数が引数とともに呼ぶ出されること、または何らかの方法により、そのリターン値が使用されることを意味します。その関数の呼び出し方は、フックのドキュメントに記載されています。アブノーマルフックとして関数を追加するために@code{add-hook}を使用できますが、その関数はフック呼び出しの慣習にしたがって記述しななければなりません。慣習により、アブノーマルフックの名前は@samp{-functions}で終わります。

@cindex single-function hook
変数の名前が@samp{-function}で終わる場合、その値は関数のリストではなく単一の関数です。@code{add-hook}を、@emph{単一関数フック}のように修正して使用することはできないので、かわりに@code{add-function}を使用します(@ref{Advising
Functions}を参照)。

@menu
* Running Hooks::            フックの実行方法。
* Setting Hooks::            関数をフックに登録、削除する方法。
@end menu

@node Running Hooks
@subsection Running Hooks

  このセクションでは、ノーマルフックを実行するために使用される、@code{run-hooks}について説明します。また、さまざまな種類のアブノーマルフックを実行する関数についても説明します。

@defun run-hooks &rest hookvars
この関数は、引数として1つ以上のノーマルフック変数名をとり、各フックを順に実行する。引数はそれぞれ、ノーマルフック変数であるようなシンボルであること。これらの引数は、指定された順に処理される。

フック変数の値が非@code{nil}の場合、その値は関数のリストであること。@code{run-hooks}は、すべての関数を引数なしで1つずつ呼び出す。

フック変数の値には、単一の関数(ラムダ式、またはシンボルの関数定義)も指定でき、その場合@code{run-hooks}はそれを喚び出す。しかし、この使い方は時代遅れである。

フック変数がバッファーローカルな場合、グローバル変数のかわりにそのバッファーローカル変数が使用される。しかし、そのバッファーローカル変数が要素@code{t}を含む場合は、そのグローバルフック変数も同様に実行されるだろう。
@end defun

@defun run-hook-with-args hook &rest args
この関数は、@var{hook}内のすべての関数に、1つの引数@var{args}を渡して喚び出すことにより、アブノーマルフックを実行する。
@end defun

@defun run-hook-with-args-until-failure hook &rest args
この関数は、各フック関数を順に呼び出すことによりアブノーマルフック関数を実行し、それらのうち1つが@code{nil}をリターンして``失敗''したときは停止する。それぞれのフック関数は、引数に@var{args}を渡される。この関数は、フック関数の1つが失敗して停止した場合は@code{nil}、それ以外は非@code{nil}値をリターンする。
@end defun

@defun run-hook-with-args-until-success hook &rest args
この関数は、各フック関数を順に呼び出すことによりアブノーマルフック関数を実行し、それらのうち1つが非@code{nil}値をリターンして``成功''したときは停止する。それぞれのフック関数は、引数に@var{args}を渡される。この関数は、フック関数の1つが失敗して停止した場合はその値を、それ以外は@code{nil}をリターンする。
@end defun

@node Setting Hooks
@subsection Setting Hooks

  以下は、Lisp Interactionモードのときに、モードフックを使用してAuto Fillモードをオンに切り替える例です:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
この関数は、フック変数に関数@var{function}を追加する手軽な方法である。ノーマルフックと同じように、アブノーマルフックにたいしてもこの関数を使用できる。@var{function}には、正しい数の引数を受け付ける任意のLisp関数を指定できる。たとえば、

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
は、@code{text-mode-hook}と呼ばれるフックに@code{my-text-hook-function}を追加する。

@var{hook}内に@var{function}がすでに存在する場合(比較には@code{equal}を使用)、@code{add-hook}は2回目の追加を行わない。

@var{function}のプロパティ@code{permanent-local-hook}が非@code{nil}の場合、@code{kill-all-local-variables}(またはメジャーモードを変更しても)、そのフック変数のローカル値から関数を削除しない。

ノーマルフックにたいして、フック関数は実行される順序に無関係であるようにデザインされるべきである。順序への依存は、トラブルを招く。とはいえ、その順序は予測可能である。通常、@var{function}はフックリストの先頭に追加されるので、(他の@code{add-hook}呼び出しがなければ)それは最初に実行される。オプション引数@var{append}が非@code{nil}の場合、新たなフック関数はフックリストの最後に追加され、実行されるのも最後になる。

@code{add-hook}は、@var{hook}がvoidのとき、または値が単一の関数の場合、値を関数リストにセットまたは変更して、それらを扱うことができる。

@var{local}が非@code{nil}の場合、それはグローバルフックリストではなくバッファーローカルフックリストに@var{function}を追加する。これはフックをバッファーローカルにして、そのバッファーローカルな値に@code{t}を追加する。バッファーローカルな値への@code{t}の追加は、ローカル値と同じようにデフォルト値でもフック関数を実行するためのフラグである。
@end defun

@defun remove-hook hook function &optional local
この関数は、フック変数@var{hook}から@var{function}を削除する。これは、@code{equal}を使用して@var{function}と@var{hook}要素を比較するので、その比較はシンボルとラムダ式の両方で機能する。

@var{local}が非@code{nil}の場合、それはグローバルフックリストではなく、バッファーローカルフックリストから@var{function}を削除する。
@end defun

@node Major Modes
@section Major Modes
@cindex major mode

@cindex major mode command
  メジャーモードは特定の種類のテキスト編集にEmacsを特化します。すべてのバッファーは1度に1つのメジャーモードをもちます。すべてのメジャーモードは、@dfn{メジャーモードコマンド(major
mode
command)}に関連付けられ、そのコマンド名は@samp{-mode}で終わるべきです。このコマンドは、ローカルキーマップのようなさまざまなバッファーローカル変数をセットすることにより、カレントバッファーないでそのモードに切り替える配慮をします。@ref{Major
Mode Conventions}を参照してください。

  @dfn{Fundamentalモード}と呼ばれるはもっとも特化されていないメジャーモードであり、モード特有な定義や変数セッティングをもちません。

@deffn Command fundamental-mode
これは、Fundamentalモードにたいするメジャーモードコマンドである。他のモードコマンドと異なり、このモードはカスタマイズしてはならないことになっているので、モードフックは何も実行@emph{されない}(@ref{Major
Mode Conventions}を参照)。
@end deffn

  メジャーモードを記述するもっとも簡単な方法は、マクロ@code{define-derived-mode}を使用する方法です。これは、既存のメジャーモードを変形して、新たなモードをセットアップします。@ref{Derived
Modes}を参照してください。@code{define-derived-mode}は多くのコーディング規約を自動的に強要するので、たとえ新たなモードが他のモードから明示的に派生されない場合でも、わたしたちは@code{define-derived-mode}の使用を推奨します。派生元とするための一般的なモードについては、@ref{Basic
Major Modes}を参照してください。

  標準的なGNU
EmacsのLispディレクトリーツリーには、いくつかのメジャーモードが@file{text-mode.el}、@file{texinfo.el}、@file{lisp-mode.el}、@file{rmail.el}のようなファイルとして含まれています。モードの記述方法を確認するために、これらのライブラリーを学ぶことができます。

@defopt major-mode
この変数のバッファーローカル値は、カレントのメジャーモードにたいするシンボルを保持する。この変数のデフォルト値は、新たなバッファーにたいするデフォルトのメジャーモードを保持する。標準的なデフォルト値は、@code{fundamental-mode}である。

デフォルト値が@code{nil}の場合、@kbd{C-x
b}(@code{switch-to-buffer})のようなコマンドを通じてEmacsが新たなバッファーを作成したとき、新たなバッファーは以前カレントだったバッファーのメジャーモードになる。例外として、以前のバッファーのメジャーモードのシンボルプロパティ@code{mode-class}が値@code{special}をもつ場合、新たなバッファーはFundamentalモードになる(@ref{Major
Mode Conventions}を参照)。
@end defopt

@menu
* Major Mode Conventions::   キーマップなどにたいするコーディング規約。
* Auto Major Mode::          Emacsが自動的にメジャーモードを選択する方法。
* Mode Help::                モードの使用方法の探し方。
* Derived Modes::            他のメジャーモードにもとづき新たなメジャーモードを定義する。
* Basic Major Modes::        他のモードからよく派生元とさｒｗるモード。
* Mode Hooks::               メジャーモード関数の最後に実行されるフック。
* Tabulated List Mode::      表形式データを含むバッファーにたいする親モード。
* Generic Modes::            コメント構文とFont 
                               Lockモードをサポートするシンプルなメジャーモードの定義。
* Example Major Modes::      TextモードとLispモード。
@end menu

@node Major Mode Conventions
@subsection Major Mode Conventions
@cindex major mode conventions
@cindex conventions for writing major modes

  メジャーモードにたいするすべてのコードはさまざまなコーディング規約にしたがうべきであり、それらの規約にはローカルキーマップおよび構文テーブルの初期化、関数名や変数名、フックにたいする規約が含まれます。

  @code{define-derived-mode}マクロを使用した場合は、これらの規約を自動的に配慮します。@ref{Derived
Modes}を参照してください。Fundamentalモードは、Emacsのデフォルト状態を表すモードなにで、これらの規約が当てはまらないことに注意してください。

  以下の規約リストは、ほんの一部です。一般的に、すべてのメジャーモードは、Emacs全体が首尾一貫するよう、他のEmacsメジャーモードとの一貫性を目指すべきです。ここで、この問題を洗い出すすべての想定される要点をリストするのは不可能です。Emacs開発者が、自身の開発するメジャーモードが通常の規約を逸脱する領域を示す場合は、互換性を保つようにしてください。

@itemize @bullet
@item
名前が@samp{-mode}で終わるようにメジャーモードコマンドを定義する。引数なしで呼び出されたとき、このコマンドはキーマップ、構文テーブル、既存バッファーのバッファーローカル変数をセットアップして、カレントバッファーを新たなモードに切り替えるべきである。そのバッファーのコンテンツを変更するべきではない。

@item
そのモードで利用できる特別なコマンドを説明するドキュメント文字列を記述する。@ref{Mode Help}を参照のこと。

そのユーザー自身のキーバインディングに自動的に適合してヘルプが表示されるように、ドキュメント文字列に特別なドキュメントサブストリング@samp{\[@var{command}]}、@samp{\@{@var{keymap}@}}、@samp{\<@var{keymap}>}を含めるとよいかもしれない。@ref{Keys
in Documentation}を参照のこと。

@item
メジャーモードコマンドは、@code{kill-all-local-variables}を呼び出すことにより開始するべきである。これは、ノーマルフック@code{change-major-mode-hook}を実行してから、前のメジャーモードで効力のあったバッファーローカル変数を解放する。@ref{Creating
Buffer-Local}を参照のこと。

@item
メジャーモードコマンドは、変数@code{major-mode}にメジャーモードコマンドのシンボルをセットするべきである。これは、@code{describe-mode}がプリントするドキュメントを探す手掛かりとなる。

@item
メジャーモードコマンドは、変数@code{mode-name}にそのモードの``愛称(pretty
name)''をセットするべきである(これは通常は文字列だが、他の利用可能な形式は、@ref{Mode Line
Data}を参照のこと)。このモード名は、モードラインに表示される。

@item
@cindex functions in modes
すべてのグローバル名は同じネームスペースにあるので、モードの一部であるようなすべてのグローバルな変数、定数、関数は、メジャーモード名(メジャーモード名が長いようなら短縮名)で始まる名前をもつべきである。@ref{Coding
Conventions}を参照のこと。

@item
プログラム言語のような、ある種の構造型テキストを編集するためのメジャーモードでは、その構造に応じたテキストのインデントはおそらく有用であろう。したがって、そのようなモードは@code{indent-line-function}に適切な関数をセットするとともに、インデント用のその他の変数をカスタマイズすべきだろう。

@item
@cindex keymaps in modes
メジャーモードは通常、そのモードにあるすべてのバッファーのローカルキーマップとして使用される、自モード身のキーマップをもつべきである。メジャーモードコマンドは、そのローカルマップをインストールするために、@code{use-local-map}を呼び出すべきである。詳細は、@ref{Active
Keymaps}を参照のこと。

このキーマップは、@code{@var{modename}-mode-map}という名前のグローバル変数に永続的に格納されるべきである。通常、そのモードを定義するライブラリーは、この変数をセットする。

モード用のキーマップ変数をセットアップするコードの記述する方法に関するアドバイスは、@ref{Tips for Defining}を参照のこと。

@item
メジャーモードのキーマップ内でバインドされるキーシーケンスは、通常は@kbd{C-c}で始まり、その後にコントロール文字、数字、@kbd{@{}、@kbd{@}}、@kbd{<}、@kbd{>}、@kbd{:}、@kbd{;}が続くべきである。その他の記号文字(punctuation
characters)はマイナーモードに、通常のアルファベット文字はユーザーのために予約されている。

メジャーモードは@kbd{M-n}、@kbd{M-p}、@kbd{M-s}などのキーもリバインドできる。@kbd{M-n}と@kbd{M-p}にたいするバインディングは、通常は
``前方あるいは後方への移動''を意味するような類のものであるべきだが、これは必ずしもカーソル移動を意味する必要はない。

そのモードにより適した方法でテキストに``同じ処理''を行うコマンドを提供する場合に、メジャーモードが標準的なキーシーケンスをリバインドするのは正当性がある。たとえば、プログラム言語を編集するためのメジャーモードは、その言語にとって``関数の先頭に移動する''がより良く機能する方法で、@kbd{C-M-a}を再定義するかもしれない。

ある標準的なキーシーケンスの標準的な意味が、そのモードではほとんど役に立たないような場合にも、メジャーモードが標準的なキーシーケンスをリバインドする正当性がある。たとえば、ミニバッファーモードは、@kbd{M-r}の標準的な意味はミニバッファーではほとんど使用されないので、このキーシーケンスをリバインドする。テキストの自己挿入を許さないDiredやRmailのようなメジャーモードは、アルファベット文字や、その他のプリント文字を特別なコマンドに再定義する正当性がある。

@item
テキストを編集するメジャーモードは、改行の挿入以外の何かに@key{RET}を定義すべきではない。しかし、ユーザーが直接テキストを編集しない、DiredやInfoのような特別なモードにたいしては、完全に異なることを行うように@key{RET}を再定義しても構わない。

@item
メジャーモードは、たとえばAuto-Fillモードを有効にするか等の、主にユーザーの好みに関するオプションを変更すべきではない。それらのオプションは、ユーザーに選択に任せること。ただし、@emph{もし}ユーザーがAuto-Fillモードを使用すると決定した場合には、それが便利に機能するように、他の変数をカスタマイズすべきである。

@item
@cindex syntax tables in modes
モードは自身の構文テーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身の構文テーブルをもつ場合は、@code{@var{modename}-mode-syntax-table}という名前の変数にそれを格納すべきである。@ref{Syntax
Tables}を参照のこと。

@item
コメントにたいして構文をもつ言語を扱うモードは、コメント構文を定義する変数をセットすべきである。@ref{Options for Comments,,
Options Controlling Comments, emacs, The GNU Emacs Manual}を参照のこと。

@item
@cindex abbrev tables in modes
モードは自身のabbrevテーブルをもつかもしれず、他の関連するモードと構文テーブルを共有するかもするかもしれない。モードが自身のabbrevテーブルをもつ場合は、@code{@var{modename}-mode-abbrev-table}という名前の変数にそれを格納すべきである。メジャーモードコマンドが自身で何らかのabbrevを定義する場合は、@code{define-abbrev}の@var{system-flag}引数に@code{t}を渡すべきである。@ref{Defining
Abbrevs}を参照のこと。

@item
モードは、変数@code{font-lock-defaults}にバッファーローカルな値をセットすることにより、Font
Lockモードにたいしてハイライトする方法を指定すべきである(@ref{Font Lock Mode}を参照)。

@item
モードが定義するすべてのフェイスは、もし可能なら既存のEmacsフェイスを継承すべきである。@ref{Basic Faces}と@ref{Faces
for Font Lock}を参照のこと。

@item
モードは変数@code{imenu-generic-expression}、変数@code{imenu-prev-index-position-function}
and
@code{imenu-extract-index-name-function}、または変数@code{imenu-create-index-function}にバッファーローカルな値をセットすることにより、Imenuがバッファー内の定義、またはセクションを探す方法を指定すべきである(@ref{Imenu}を参照)。

@item
モードは、@code{eldoc-documentation-function}にローカル値を指定して、ElDocモードがそのモードを処理する方法を指定できる。

@item
モードは、スペシャルフック@code{completion-at-point-functions}に1つ以上のバッファーローカルエントリーを追加することにより、さまざまなキーワードの補完方法を指定できる。@ref{Completion
in Buffers}を参照のこと。

@item
@cindex buffer-local variables in modes
Emacsのカスタマイズ変数にたいしてバッファーローカルなバインディングを作成するには、@code{make-variable-buffer-local}ではなく、メジャーモードコマンド内で@code{make-local-variable}を使用すること。関数、@code{make-variable-buffer-local}は、それ以降にカスタマイズ変数をセットするすべてのバッファーにたいしてその変数をローカルにし、そのモードを使用しないバッファーにたいしても影響があるだろう。そのようなグローバルな効果は、モードにとって好ましくない。@ref{Buffer-Local
Variables}を参照のこと。

稀な例外として、Lispパッケージ内で@code{make-variable-buffer-local}を使用する唯一の正当な方法は、そのパッケージ内でのみ使用される変数にたいして使用をする場合である。他のパッケージにより使用される変数にたいしてこの関数を使用すると、干渉が起こるだろう。

@item
@cindex mode hook
@cindex major mode hook
すべてのメジャーモードは、@code{@var{modename}-mode-hook}という名前のノーマルな@dfn{モードフック(mode
hook)}をもつべきである。メジャーモードコマンドが一番最後に行うべきことは、@code{run-mode-hooks}の呼び出しである。これは、ノーマルフック@code{change-major-mode-after-body-hook}、モードフック、その後に@code{after-change-major-mode-hook}を実行する。@ref{Mode
Hooks}を参照のこと。

@item
メジャーモードコマンドは、@dfn{親モード(parent
mode)}と呼ばれる他のいくつかのメジャーモードを呼び出すことにより開始されるかもしれず、それらのセッティングのいくつかを変更するかもしれない。これを行うモードは、@dfn{派生モード(derived
mode)}と呼ばれる。派生モードを定義する推奨方法は、@code{define-derived-mode}マクロの使用であるが、これは必須ではない。そのようなモードは、@code{delay-mode-hooks}フォーム内で親のモードコマンドを呼び出すべきである(@code{define-derived-mode}は自動的にこれを行う)。@ref{Derived
Modes}、および@ref{Mode Hooks}を参照のこと。

@item
ユーザーが、そのモードのバッファーから他のモードのバッファーに切り替える際に特別な何かを行う必要がある場合、モードは@code{change-major-mode-hook}にたいしてバッファーローカル値をセットアップできる(@ref{Creating
Buffer-Local}を参照)。

@item
そのモードが、(ユーザーがキーボードでタイプしたテキストや、外部ファイルのテキストではなく)モード自身が生成する特別に用意されたテキストにたいしてのみ適す場合、メジャーモードコマンドのシンボルは、以下のように@code{mode-class}という名前のプロパティに値@code{special}をputすべきである:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
これはEmacsにたいして、カレントバッファーがFunnyモードのときに新たなバッファーを作成したとき、たとえ@code{major-mode}のデフォルト値が@code{nil}であっても、そのバッファーをFunnyモードにしないよう指示する。デフォルトでは、@code{major-mode}にたいする値@code{nil}は、新たなバッファー作成時にカレントバッファーのメジャーモードを使用することを意味するが(@ref{Auto
Major
Mode}を参照)、@code{special}なモードにたいしてはかわりにFundamentalモードが使用される。Dired、Rmail、Buffer
Listのようなモードは、この機能を使用する。

関数@code{view-buffer}は、mode-classがspecialであるようなバッファーではViewモードを有効にしない。そのようなモードは、通常は自身でViewに相当するバインディングを提供するからである。

@code{define-derived-mode}マクロは、親モードがspecialの場合は、自動的に派生モードをspecialにマークする。親モードでspecialモードが有用なら、それを継承したモードでもであろう。@ref{Basic
Major Modes}を参照のこと。

@item
新たなモードを、識別可能な特定のファイルにたいするデフォルトとしたい場合は、そのようなファイル名にたいしてそのモードを選択するために、@code{auto-mode-alist}に要素を追加する。autoload用にモードコマンドを定義する場合は、@code{autoload}を呼び出すのと同じファイル内にその要素を追加すべきである。モードコマンドにたいしてautoload
cookieを使用する場合は、その要素を追加するフォームにたいしてもautoload cookieを使用できる(@ref{autoload
cookie}を参照)。モードコマンドをautoloadしない場合は、モード定義を含むファイル内で要素を追加すれば十分である。

@item
@cindex mode loading
悪影響を与えることなく1回以上評価されるように、モード定義はファイル内のトップレベルのフォームとして記述すべきである。たとえば、すでに値をもつ変数が再初期化されないように、モードに関連した変数をセットするときは、@code{defvar}か@code{defcustom}を使用する(@ref{Defining
Variables}を参照)。

@end itemize

@node Auto Major Mode
@subsection How Emacs Chooses a Major Mode
@cindex major mode, automatic selection

  ファイルをvisitするとき、ファイル名やファイル自体の内容などの情報を元に、Emacsはそのバッファーにたいするメジャーモードを選択します。また、ファイルのテキスト内で指定されたローカル変数も処理します。

@deffn Command normal-mode &optional find-file
この関数は、カレントバッファーにたいして適切なメジャーモードと、バッファーローカル変数のバインディングを設定する。これはまず@code{set-auto-mode}(以下参照)を呼び出し、その後に@code{hack-local-variables}を実行してパース処理を行って、そのファイルのローカル変数(@ref{File
Local Variables}を参照)を適切にバインド、または評価する。

@code{normal-mode}の@var{find-file}引数が非@code{nil}の場合、@code{normal-mode}は@code{find-file}関数が自身を呼び出したとみなす。この場合、@code{normal-mode}はそのファイル内の@samp{-*-}行の、またはファイルの最後にあるローカル変数を処理するかもしれない。これを行うかどうかは、変数@code{enable-local-variables}が制御する。ファイルのローカル変数セクションの構文は、@xref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照のこと。

インタラクティブに@code{normal-mode}を実行した場合、引数@var{find-file}は通常@code{nil}である。この場合、@code{normal-mode}は無条件に任意のファイルローカル変数を処理する。

この関数は、メジャーモードを選択するために@code{set-auto-mode}を呼び出す。この関数がモードを特定しない場合、そのバッファーの@code{major-mode}(以下参照)のデフォルト値により決定されるメジャーモードに留まる。

@cindex file mode specification error
@code{normal-mode}は、メジャーモードコマンド呼び出しの周囲に@code{condition-case}を使用するので、エラーはcatchされて、@samp{File
mode specification error}とともに、元のエラーメッセージがその後に報告される。
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
  この関数は、カレントバッファーにたいして適切なメジャーモードを選択する。この選択は、関数自身の(優先順位による)決定にもとづく。優先順位は、@w{@samp{-*-}}行、ファイル終端近傍の任意の@samp{mode:}ローカル変数、@w{@samp{#!}}行(@code{interpreter-mode-alist}を使用)、バッファーの先頭のテキスト(@code{magic-mode-alist}を使用)、最後がvisitされるファイル名(@code{auto-mode-alist}を使用)の順である。@ref{Choosing
Modes, , How Major Modes are Chosen, emacs, The GNU Emacs
Manual}を参照のこと。@code{enable-local-variables}が@code{nil}の場合、@code{set-auto-mode}は@w{@samp{-*-}}行、およびファイル終端近傍にたいして、modeタグのチェックを何もしない。

@vindex inhibit-local-variables-regexps
モード特定のためにファイル内容をスキャンするのがふさわしくないファイルタイプがいくつかある。たとえば、tarアーカイブファイルの終わり付近に、特定のファイルにたいしてモードを指定するローカル変数セクションをもつアーカイブメンバーファイルが、たまたま含まれているかもしれない。これは、そのファイルを含むtarファイルに適用されるべきではないだろう。同様に、tiffイメージファイルが、@w{@samp{-*-}}パターンにマッチするように見える行を、最初の行に偶然含むかもしれない。これらの理由により、これらのファイル拡張子はどちらも@code{inhibit-local-variables-regexps}リストのメンバーになっている。Emacsが、(モード指定に限らず)ファイルから任意の種類のローカル変数を検索することを防ぐには、このリストにパターンを追加する。

@var{keep-mode-if-same}が非@code{nil}の場合は、すでにそのバッファーが適切なメジャーモードをもつとき、この関数はモードコマンドを呼び出さない。たとえば@code{set-visited-file-name}は、ユーザーがセットしたかもしれないバッファーローカル変数をkillするのを防ぐために、これを@code{t}にセットする。
@end defun

@defun set-buffer-major-mode buffer
この関数は、@var{buffer}のメジャーモードを、@code{major-mode}のデフォルト値にセットする。@code{major-mode}が@code{nil}の場合は、(それが適切なら)カレントバッファーのメジャーモードを使用する。例外として、@var{buffer}の名前が@file{*scratch*}の場合は、モードを@code{initial-major-mode}にセットする。

バッファーを作成する低レベルのプリミティブはこの関数を使用しないが、@code{switch-to-buffer}や@code{find-file-noselect}のような中位レベルのコマンドは、バッファーを作成するときは、常にこの関数を使用する。
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
この変数の値は、@file{*scratch*}バッファーの初期のメジャーモードを決定する。値は、メジャーモードコマンドであるようなシンボルであること。デフォルト値は@code{lisp-interaction-mode}である。
@end defopt

@defvar interpreter-mode-alist
この変数は、@samp{#!}行内のコマンドインタープリターを指定するスクリプトにたいして使用するメジャーモードを指定する。変数の値は、@code{(@var{regexp}
.
@var{mode})}の形式の要素をもつalistである。これは、そのファイルが@code{\\`@var{regexp}\\'}にマッチするインタープリターを指定する場合は、@var{mode}を使用することを意味する。たとえば、デフォルト要素の1つは@code{("python[0-9.]*"
. python-mode)}である。
@end defvar

@defvar magic-mode-alist
この変数の値は、@code{(@var{regexp}
@var{function})}という形式の要素をもつalistである。ここで、@var{regexp}は正規表現、@var{function}は関数、または@code{nil}である。ファイルをvisitした後に、バッファーの先頭のテキストが@var{regexp}にマッチした場合、@var{function}が非@code{nil}なら@code{set-auto-mode}は@var{function}を呼び出す。@var{function}が@code{nil}の場合は、@code{auto-mode-alist}がモードを決定する。
@end defvar

@defvar magic-fallback-mode-alist
これは@code{magic-mode-alist}と同様に機能するが、そのファイルにたいして@code{auto-mode-alist}がモードを指定しない場合だけ処理される点が異なる。
@end defvar

@defvar auto-mode-alist
この変数は、ファイル名パターン(正規表現)と対応するメジャーモードコマンドの連想配列を含む。通常、ファイル名パターンは、@samp{.el}や@samp{.c}のようなサフィックスをテストするが、必須ではない。このalistの通常の要素は@code{(@var{regexp}
.  @var{mode-function})}のようになる。

たとえば、

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

バージョン番号およびバックアップ用サフィックスをもつファイルをvisitしたとき、それらは@code{file-name-sans-versions}(@ref{File
Name Components}を参照)を使用して展開されたファイル名(@ref{File Name
Expansion}を参照)から取り除かれて@var{regexp}とマッチされて、@code{set-auto-mode}は対応する@var{mode-function}を呼び出す。この機能により、ほとんどのファイルにたいしてEmacsが適切なメジャーモードを選択することが可能になる。

@code{auto-mode-alist}の要素が@code{(@var{regexp} @var{function}
t)}という形式の場合は、@var{function}を呼び出した後、Emacsは前回マッチしなかったファイル名部分にたいしてマッチするために、再度@code{auto-mode-alist}を検索する。この機能は、圧縮されたパッケージにたいして有用である。@code{("\\.gz\\'"
@var{function}
t)}という形式のエントリーは、ファイルを解凍してから、@samp{.gz}抜きのファイル名にたいして適切なモードに解凍されたファイルを配す。

以下は@code{auto-mode-alist}の先頭に、複数のパターンペアーを追加する方法の例である(あなたは、initファイル内でこの種の式を使ったことがあるかもしれない)。

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{ドットで始まる(ディレクトリー名付きの)ファイル名}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{ドットのないファイル名}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{@samp{.C}で終わるファイル名}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@subsection Getting Help about a Major Mode
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode

  @code{describe-mode}関数は、メジャーモードに関する情報を提供します。これは通常、@kbd{C-h
m}にバインドされています。この関数は、変数@code{major-mode}(@ref{Major
Modes}を参照)の値を使用します。すべてのメジャーモードがこの変数をセットする必要があるのは、これが理由です。

@deffn Command describe-mode &optional buffer
このコマンドは、カレントバッファーのメジャーモードとマイナーモードのドキュメントを表示する。この関数は、メジャーモードおよびマイナーモードのコマンドのドキュメント文字列を取得するために、@code{documentation}関数を使用する(@ref{Accessing
Documentation}を参照)。

@var{buffer}引数に非@code{nil}を指定してLispから呼び出された場合、この関数はカレントバッファーではなく、そのバッファーのメジャーモードとマイナーモードのドキュメントを表示する。
@end deffn

@node Derived Modes
@subsection Defining Derived Modes
@cindex derived mode

  新しいメジャーモードを定義する推奨された方法は、@code{define-derived-mode}を使用して既存のメジャーモードから派生させる方法です。それほど近いモードが存在しない場合は@code{text-mode}、@code{special-mode}、または@code{prog-mode}から継承するべきです。@ref{Basic
Major
Modes}を参照してください。これらがどれも適切でない場合は、@code{fundamental-mode}から継承することができます(@ref{Major
Modes}を参照)。

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
このマクロは、@var{variant}をメジャーモードコマンドとして定義し、@var{name}をモード名の文字列形式とする。@var{variant}と@var{parent}は、クォートされていないシンボルであること。

新たなコマンド@var{variant}は、関数@var{parent}を呼び出すよう定義され、その後その親モードの特定の性質をオーバーライドする。

@itemize @bullet
@item
新たなモードは、@code{@var{variant}-map}という名前の、自身のsparseキーマップ(疎キーマップ)をもつ。@code{define-derived-mode}は、@code{@var{variant}-map}がすでにセットされていて、かつすでに親をもつ場合を除き、親モードのキーマップを新たなマップの親キーマップにする。

@item
新たなモードは、自身の構文テーブル(syntax
table)をもち、それは変数@code{@var{variant}-syntax-table}に保持される。ただし、@code{:syntax-table}キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。@code{define-derived-mode}は、@code{@var{variant}-syntax-table}がすでにセットされていて、かつ標準的な構文テーブルよ異なる親をもつ場合を除き、ペアレントモードの構文テーブルを@code{@var{variant}-syntax-table}の親とする。

@item
新たなモードは、自身のabbrevテーブル(略語テーブル)をもち、それは変数@code{@var{variant}-abbrev-table}に保持される。ただし、@code{:abbrev-table}キーワード(以下参照)を使用して、これをオーバーライドした場合は異なる。

@item
新たなモードは、自身のモードフック@code{@var{variant}-hook}をもつ。これは、このフックを実行した後に、最後に@code{run-mode-hooks}により、自身の祖先のモードのフックを実行する。
@end itemize

これらに加えて、@var{body}で@var{parent}のその他の性質をオーバーライドする方法を指定できます。コマンド@var{variant}はー、通常のオーバーライドをセットアップした後、そのモードのフックを実行する直前に@var{body}内のフォームを評価します。

@var{parent}が非@code{nil}の@code{mode-class}シンボルプロパティをもつ場合、@code{define-derived-mode}は@var{variant}の@code{mode-class}プロパティに、同じ値をセットします。これは、たとえば@var{parent}がspecialモードの場合は、@var{variant}もspecialモードになることを保証します(@ref{Major
Mode Conventions}を参照)。

@var{parent}にたいして@code{nil}を指定することもできます。これにより、新たなモードは親をもたなくなります。その後、@code{define-derived-mode}は上述のように振る舞いますが、当然@var{parent}につながるすべてのアクションは省略されます。

引数@var{docstring}は、新たなモードにたいするドキュメント文字列を指定します。@code{define-derived-mode}は、このドキュメント文字列の最後にそのモードフックに関する一般的な情報と、その後にそのモードのキーマップを追加します。@var{docstring}を省略した場合は、@code{define-derived-mode}がドキュメント文字列を生成します。

@var{keyword-args}は、キーワードと値のペアーです。値は評価されます。現在、以下のキーワードがサポートされています:

@table @code
@item :syntax-table
新たなモードにたいする構文テーブルを明示的に指定するために、これを使用できる。@code{nil}値を指定した場合、新たなモードは@var{parent}と同じ構文テーブル、@var{parent}も@code{nil}の場合は標準的な構文テーブルを使用する(これは、@code{nil}値の非キーワード引数は引数を指定しないのと同じという通常の慣習には@emph{したがわない}ことに注意されたい)。

@item :abbrev-table
新たなモードにたいするabbrevテーブルを明示的に指定するために、これを使用できる。@code{nil}値を指定した場合、新たなモードは@var{parent}と同じabbrevテーブル、@var{parent}も@code{nil}の場合は、@code{fundamental-mode-abbrev-table}を使用する(繰り返すが、@code{nil}値はこのキーワードを指定しないことでは@emph{ない})。

@item :group
これが指定された場合、値はそのモードにたいするカスタマイズグループ(customization
group)であること(すべてのメジャーモードがカスタマイズグループをもつ訳ではない)。(まだ実験的かつ未公表だが)現在のところ、これを使用するのは@code{customize-mode}コマンドだけである。@code{define-derived-mode}は、指定されたカスタマイズグループを自動的に定義@emph{しない}。
@end table

以下は架空の例である:

@example
(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "ハイパーテキスト用のメジャーモード
\\@{hypertext-mode-map@}"
  (setq case-fold-search nil))

(define-key hypertext-mode-map
  [down-mouse-3] 'do-hyper-link)
@end example

@code{define-derived-mode}が自動的に行うので、この定義内に@code{interactive}指定を記述してはならない。
@end defmac

@defun derived-mode-p &rest modes
この関数は、シンボル@var{modes}で与えられたメジャーモードのいずれかから、カレントメジャーモードが派生された場合は非@code{nil}をリターンする。
@end defun

@node Basic Major Modes
@subsection Basic Major Modes

  Fundamentalモードは別として、他のメジャーモードの一般的な派生元となるメジャーモードが3つあります。それはTextモード、Progモード、およびSpecialです。Textモードはその本来もつ機能から有用なモードです(たとえば@file{.txt}ファイルの編集など)。一方、ProgモードとSpecialモードは主にそのようなモード以外のモードの派生元として存在します。

@vindex prog-mode-hook
  新たなモードは、直接または間接を問わず、可能な限りれら3つのモードから派生させるべきです。その理由の1つは、関連のあるモードファミリー全体(たとえばすべてのプログラミング言語のモード)にたいして、ユーザーが単一のモードフックをカスタマイズできる空からです。

@deffn Command text-mode
Textモードは、人間の言語を編集するためのメジャーモードである。このモードは、文字@samp{"}および@samp{\}を区切り文字構文(punctuation
syntax: @ref{Syntax Class
Table}を参照)としてもち、@kbd{M-@key{TAB}}を@code{ispell-complete-word}にバインドする(@ref{Spelling,,,
emacs, The GNU Emacs Manual}を参照)。

Textモードから派生されたメジャーモードの例として、HTMLモードがある。@ref{HTML Mode,,SGML and HTML Modes,
emacs, The GNU Emacs Manual}を参照のこと。
@end deffn

@deffn Command prog-mode
Progモードは、プログラミング言語のソースコードを含むバッファーにたいする、基本的なメジャーモードである。Emacsビルトインのプログラミング言語用メジャーモードは、このモードから派生されている。

Progモードは、@code{parse-sexp-ignore-comments}を@code{t}(@ref{Motion via
Parsing}を参照)にバインドし、@code{bidi-paragraph-direction}を@code{left-to-right}(@ref{Bidirectional
Display}を参照)にバインドする。
@end deffn

@deffn Command special-mode
Specialモードは、ファイルから直接ではなく、Emacsにより特別(specially)に生成されたテキストを含むバッファーにたいする、基本的なメジャーモードである。Specialモードから派生されたメジャーモードは、@code{mode-class}プロパティに@code{special}ーが与えられる(@ref{Major
Mode Conventions}を参照)。

Specialモードは、バッファーを読み取り専用にセットする。このモードのキーマップは、いくつかの一般的なバインディングを定義し、それには@code{quit-window}にたいする@kbd{q}、@code{revert-buffer}(@ref{Reverting}を参照)にたいする@kbd{g}が含まれる。

Specialから派生されたメジャーモードの例としてはBuffer Menuモードがあり、これは@file{*Buffer
List*}バッファーにより使用される。@ref{List Buffers,,Listing Existing Buffers, emacs, The
GNU Emacs Manual}を参照のこと。
@end deffn

  これらに加えて、表形式データのバッファーにたいするモードはTabulated
Listモードから継承できます。このモードは、Specialモードから順に派生されているモードです。@ref{Tabulated List
Mode}を参照してください。

@node Mode Hooks
@subsection Mode Hooks

  すべてのメジャーモードコマンドは、モード独自のノーマルフック@code{change-major-mode-after-body-hook}、そのモードのモードフック、ノーマルフック@code{after-change-major-mode-hook}を実行することにより終了すべきです。これは、@code{run-mode-hooks}を呼び出すことにより行われます。もしそのモードが派生モードなら、自身のbody内で他のメジャーモード(親モード)を呼び出す場合は、親モードが自身でこれらのフックを実行しないように、@code{delay-mode-hooks}の中でこれを行うべきです。そのかわりに、派生モードは親のモードフックも実行する、@code{run-mode-hooks}を呼び出すのです。@ref{Major
Mode Conventions}を参照してください。

  Emacs 22より前のバージョンのEmacsには、@code{delay-mode-hooks}がありません。また、Emacs
24より前のバージョンには、@code{change-major-mode-after-body-hook}がありません。ユーザー実装のメジャーモードが@code{run-mode-hooks}を使用せず、これらの新しい機能を使用するようにアップデートされていないときは、これらのメジャーモードは以下の慣習に完全にしたがわないでしょう。それらのモードは、親のモードフックをあまりに早く実行したり、@code{after-change-major-mode-hook}の実行に失敗するかもしれません。そのようなメジャーモードに遭遇した場合は、以下の慣習にしたがって修正をお願いします。

  @code{define-derived-mode}を使用してメジャーモードを定義したときは、自動的にこれらの慣習にしたがうことが確実になります。@code{define-derived-mode}を使用せずにメジャーモードを``手動''で定義した場合は、これらの慣習を自動的に処理するように、以下の関数を使用してください。

@defun run-mode-hooks &rest hookvars
メジャーモード、この関数を使用してそれらのモードフックを実行すべきである。これは@code{run-hooks}(@ref{Hooks}を参照)と似ているが、@code{change-major-mode-after-body-hook}と@code{after-change-major-mode-hook}も実行する。

この関数が、@code{delay-mode-hooks}フォーム実行中に呼び出されたときは、それらのフックを即座には実行しない。かわりに、次の@code{run-mode-hooks}呼び出しでそれらを実行するようにアレンジする。
@end defun

@defmac delay-mode-hooks body@dots{}
あるメジャーモードコマンドが他のメジャーモードコマンドを呼び出すとき、それは@code{delay-mode-hooks}の内部で行われるべきである。

このマクロは@var{body}を実行するが、@var{body}実行中はすべての@code{run-mode-hooks}呼び出しにたいして、それらのフックの実行を遅延するよう指示する。それらのフックは、実際には@code{delay-mode-hooks}構造の最後の後、次の@code{run-mode-hooks}呼び出しの間に実行されるだろう。
@end defmac

@defvar change-major-mode-after-body-hook
これは、@code{run-mode-hooks}により実行されるノーマルフックである。これは、そのモードのフックの前に実行される。
@end defvar

@defvar after-change-major-mode-hook
これは、@code{run-mode-hooks}により実行されるノーマルフックである。これは、すべての適切に記述されたメジャーモードコマンドの一番最後に実行される。
@end defvar

@node Tabulated List Mode
@subsection Tabulated List mode
@cindex Tabulated List mode

  Tabulated
Listモードとは、表形式データ(@dfn{エントリー}から構成されるデータであり、各エントリーはそれぞれテキストの1行を占め、エントリーの内容は列に分割されるようなデータ)を表示するためのメジャーモードです。Tabulated
Listモードは、行列の見栄えよくプリントする機能、および各列の値に応じて行をソートする機能を提供します。これは、Specialモードから派生されたモードです(@ref{Basic
Major Modes}を参照)。

  Tabulated Listモードは、より特化したメジャーモードの親モードとして使用されることを意図しています。例としては、Process
Menuモード(@ref{Process Information}を参照)や、Package Menuモード(@ref{Package Menu,,,
emacs, The GNU Emacs Manual}を参照)が含まれます。

@findex tabulated-list-mode
  このような派生されたモードは、@code{tabulated-list-mode}を2つ目の引数に指定して、通常の方法で@code{define-derived-mode}を使用するべきです(@ref{Derived
Modes}を参照)。@code{define-derived-mode}フォームのbodyは、以下にドキュメントされている変数に値を割り当てることにより、表形式データのフォーマットを指定するべきです。その後、ヘッダー行を初期化するために関数@code{tabulated-list-init-header}を呼び出すべきです。

  派生されたモードは、@dfn{リスティングコマンド}も定義するべきです。これはモードコマンドではなく、(@kbd{M-x
list-processes}のように)ユーザーが呼び出すコマンドです。リスティングコマンドは、バッファーを作成または切り替えて、派生モードをオンにして、表形式データを指定し、最後にそのバッファーを事前設定(populate)するために@code{tabulated-list-print}を呼び出すべきです。

@defvar tabulated-list-format
このバッファーローカル変数は、表形式データのフォーマットを指定する。値はベクターで、ベクターの各要素はデータ列を表すリスト@code{(@var{name}
@var{width} @var{sort})}である。ここで

@itemize
@item
@var{name}は列の名前(文字列)。

@item
@var{width}は列にたいして予約される文字数幅(整数)。最終列は各行の終端までなので意味がない。

@item
@var{sort}は列によりエントリーをソートする方法を指定する。@code{nil}の場合、その列はソートに使用できない。@code{t}の場合は、列の文字列値を比較することによりソートされる。それ以外の場合は、@code{tabulated-list-entries}の要素と同じ形式の2つの引数をとる、@code{sort}にたいする述語関数(predicate
function)であること。
@end itemize
@end defvar

@defvar tabulated-list-entries
このバッファーローカル変数は、Tabulated Listバッファー内に表示されるエントリーを指定する。値にはリスト、または関数のいずれかであること。

値がリストの場合、各リスト要素は1つのエントリーに対応し、@w{@code{(@var{id}
@var{contents})}}という形式であること。ここで

@itemize
@item
@var{id}は@code{nil}、またはエントリーを識別するLispオブジェクト。Lispオブジェクトの場合には、エントリーを再ソートした際、カーソルは``同じ''エントリー上に留まる。比較は@code{equal}で行われる。

@item
@var{contents}は、@code{tabulated-list-format}と要素数が同じベクター。ベクター要素は文字列、またはリスト。文字列の場合は、バッファーにそのまま挿入される。リスト@code{(@var{label}
.
@var{properties})}の場合には、@var{label}と@var{properties}を引数として@code{insert-text-button}を呼び出すことにより、テキストボタンを挿入することを意味する(@ref{Making
Buttons}を参照)。

これらの文字列には、改行を含めるべきではない。
@end itemize

それ以外の場合、値は引数なしで呼び出され上記形式のリストをリターンする関数であること。
@end defvar

@defvar tabulated-list-revert-hook
このノーマルフックはTabulated
Listバッファーのリバートに先立ち実行される。派生モードは、@code{tabulated-list-entries}を再計算するために、このフックに関数を追加できる。
@end defvar

@defvar tabulated-list-printer
この変数の値は、ポイント位置にエントリー(エントリーを終端する改行を含む)を挿入するために呼び出される関数である。この関数は、@code{tabulated-list-entries}と同じ意味をもつ2つの引数@var{id}と@var{contents}を受け取る。デフォルト値は、エントリーをそのまま挿入する関数である。より複雑な方法によりTabulated
Listモードを使用するモードは、別の関数を指定できる。
@end defvar

@defvar tabulated-list-sort-key
この変数の値は、Tabulated
Listバッファーにたいするカレントのソートキーを指定する。@code{nil}の場合、ソートは行われていない。それ以外では、@code{(@var{name}
.
@var{flip})}という形式の値をもつ。ここで@var{name}は@code{tabulated-list-format}内の列目の1つとマッチする文字列、@var{flip}が非@code{nil}の場合は逆順でのソートを意味する。
@end defvar

@defun tabulated-list-init-header
この関数は、Tabulated
Listバッファーにたいする@code{header-line-format}を計算してセットし、列ヘッダー上でのクリックでソートを可能にするキーマップをヘッダー行に割り当てる。

Tabulated
Listから派生したモードは、上記の変数(特に@code{tabulated-list-format}をセットした後のみ)をセットした後にこれを呼び出すべきである。
@end defun

@defun tabulated-list-print &optional remember-pos
この関数は、カレントバッファーにエントリーを準備(populate)する。これはリスティングコマンドとして呼び出されるべきである。この関数は、バッファーを消去して@code{tabulated-list-entries}で指定されるエントリーを@code{tabulated-list-sort-key}にしたがってソートした後、各エントリーを挿入するために@code{tabulated-list-printer}で指定される関数を呼び出す。

オプション引数@var{remember-pos}が非@code{nil}の場合、この関数はカレント行で@var{id}要素を探して、もしあればすべてのエントリーを(再)挿入して、その後へそのエントリーの移動を試みる。
@end defun

@node Generic Modes
@subsection Generic Modes
@cindex generic mode

  @dfn{genericモード (generic mode:汎用モード))}とは、コメント構文にたいする基本的なサポートとFont
Lockモードをもつ、シンプルなメジャーモードです。genericモードを定義するには、マクロ@code{define-generic-mode}を使用します。@code{define-generic-mode}の使い方の例は、ファイル@file{generic-x.el}を参照してください。

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
このマクロは、@var{mode}(クォートされていないシンボル)という名前のgenericモードコマンドを定義する。オプション引数@var{docstring}は、そのモードコマンドにたいするドキュメント文字列である。これを与えない場合は、@code{define-generic-mode}がデフォルトのドキュメント文字列を生成する。

引数@var{comment-list}は、要素が文字、2文字以下の文字列、またはコンスセルである。文字か文字列の場合には、そのモードの構文テーブル内で``コメント開始識別子''としてセットアップされる。エントリーがコンスセルの場合、@sc{car}は``コメント開始識別子''、@sc{cdr}は``コメント終了識別子''としてセットアップされる(行末によりコメントを終端させたい場合は、後者に@code{nil}を使用する)。構文テーブルのメカニズムには、実際にコメントの開始および終了識別子に関する制限があることに注意されたい。
@ref{Syntax Tables}を参照のこと。

引数@var{keyword-list}は、@code{font-lock-keyword-face}でハイライトするキーワードのリストである。キーワードは文字列であること。一方、@var{font-lock-list}はハイライトするための追加の式リストである。このリストの各要素は、@code{font-lock-keywords}の要素と同じ形式をもつべきである。@ref{Search-based
Fontification}を参照のこと。

引数@var{auto-mode-list}は、変数@code{auto-mode-alist}に追加する正規表現のリストである。これらの式は、マクロ呼び出しの展開時ではなく、@code{define-generic-mode}の実行時に追加される。

最後に@var{function-list}は、追加セットアップのためにモードコマンドに呼び出される関数のリストである。これらの関数は、モードフック変数@code{@var{mode}-hook}の実行の直前に呼び出される。
@end defmac

@node Example Major Modes
@subsection Major Mode Examples

  Textモードは、Fundamentalを除き、おそらくもっともシンプルなモードです。上述した慣習の多くを説明するために、以下に@file{text-mode.el}の抜粋を示します:

@smallexample
@group
;; @r{このモード用に構文テーブルを作成}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; M-cで`hello'が`hello'でなく`Hello'になるよう`p'を追加
    (modify-syntax-entry ?' "w p" st)
    st)
  "`text-mode'で使用される構文テーブル")
@end group

;; @r{このモード用にキーマップを作成}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "`text-mode'のキーマップ
`mail-mode'、`outline-mode'、`indented-text-mode'のような
他の多くのモードはこのマップ内で定義した全コマンドを継承する")
@end group
@end smallexample

  そして、実際にモードコマンドが定義される方法です:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "人間が読むために記述されたテキストを編集するためのメジャーモード
このモードではパラグラフを区切るのはブランク行か空白行だけである
したがって適応型フィル(adaptive filling)の全恩恵を受けられる
 (変数`adaptive-fill-mode'を参照のこと)
\\@{text-mode-map@}
Textモードのオンによりノーマルフック`text-mode-hook'が実行される"
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(@code{indent-relative}がデフォルト値の現在では、最後の行は冗長なので、将来のバージョンで削除するつもりです。)

@cindex @file{lisp-mode.el}
  3つのLisp用モード(Lispモード、Emacs Lispモード、Lisp
Interactionモード)は、Textモードより多くの機能をもち、それにふさわしくコードもより複雑です。そのようなモードの記述方法を説明するために、@file{lisp-mode.el}の抜粋を示します。

  以下は、Lispモードの構文テーブルとabbrevテーブルを定義する方法です:

@cindex syntax table example
@smallexample
@group
;; @r{モード固有のテーブル変数の作成}
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "`lisp-mode'で使用される構文テーブル")
@end group
@end smallexample

  Lisp用の3つのモードは、コードの多くを共有します。たとえば、以下の関数呼び出しにより、さまざまな変数がセットされます:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  @dots{}
@end group
@end smallexample

@noindent
その中でも特に、以下の関数はLispコメントを処理するために、変数@code{comment-start}をセットアップします:

@smallexample
@group
  (make-local-variable 'comment-start)
  (setq comment-start ";")
  @dots{}
@end group
@end smallexample

  これら異なるLisp用モードは、微妙に異なるキーマップをもちます。たとえば、Lispモードは@kbd{C-c
C-z}を@code{run-lisp}にバインドしますが、他のLisp用モードはこれを行いません。とはいえ、すべてのLisp用モードに共通なコマンドがいくつかあります。以下のコードは、それらの共通コマンドをセットアップします:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "すべてのLisp用モードでコマンドを共有するためのキーマップ")
@end group
@end smallexample

@noindent
そして、以下がLispモードのためのキーマップをセットアップするコードです:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
@end group
@end smallexample

@noindent
最後は、Lispモードのためのメジャーモードコマンドです:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "GNU Emacs Lisp以外のLispコードを編集するためのメジャーモード
コマンド:
後方に移動させるかのようにタブをスペースに削除変換する。
パラグラフ区切りはブランク行。コメント開始はセミコロン。

\\@{lisp-mode-map@}
`run-lisp'はinferior Lispジョブの開始と既存ジョブ
から戻るための両方に使われるかもしれないことに注意
@end group

@group
このモードへのエントリーにより、
`lisp-mode-hook'の値が非nilならそれを呼び出す"
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@section Minor Modes
@cindex minor mode

  @dfn{マイナーモード(minor
mode)}は、メジャーモードの選択とは無関係にユーザーが有効、あるいは無効にする可能性のある、オプション機能を使用を提供します。マイナーモードは個別に、あるいは組み合わせて有効にできます。

  ほとんどのマイナーモードは、メジャーモードとは独立した機能を実装し、それゆえにほとんどのメジャーモードとともに使用することができます。たとえば、Auto
Fillモードはテキスト挿入を許す任意のメジャーモードとともに機能します。しかし少数ながら、特定のメジャーモードに特化した少数のマイナーモードもあります。たとえば、Diff
Auto Refineモードは、Diffモードとともに使用されることだけを意図したマイナーモードです。

  理想的には、マイナーモードは他のマイナーモードの効果と無関係に、期待する効果をもつべきです。これは、任意の順序でマイナーモードをアクティブ、あるいは非アクティブにしても可能なはずです。

@defvar minor-mode-list
この変数の値は、すべてのマイナーモードコマンドのリストである。
@end defvar

@menu
* Minor Mode Conventions::   マイナーモードを記述するためのTips。
* Keymaps and Minor Modes::  マイナーモードが自身のキーマップをもつための方法。
* Defining Minor Modes::     マイナーモードを定義するための便利な機能。
@end menu

@node Minor Mode Conventions
@subsection Conventions for Writing Minor Modes
@cindex minor mode conventions
@cindex conventions for writing minor modes

  メジャーモードにあるように、マイナーモードの記述にも慣習があります。以下で、その慣習について説明します。これらの慣習にしたがうには、マクロ@code{define-minor-mode}を使用するのがもっとも簡単な方法です。@ref{Defining
Minor Modes}を参照してください。

@itemize @bullet
@item
@cindex mode variable
名前が@samp{-mode}で終わる変数を定義する。これを@dfn{モード変数(mode
variable)}と呼ぶ。マイナーモードコマンドは、この変数をセットすべきである。値は、そのモードが無効な場合は@code{nil}、有効な場合は非@code{nil}になるだろう。そのマイナーモードがバッファーローカルなら、この変数もバッファーローカルであること。

この変数は、モードラインにマイナーモードの名前を表示するために、@code{minor-mode-alist}と結合して使用される。これは、@code{minor-mode-map-alist}を通じて、そのマイナーモードのキーマップがアクティブかどうかも判定する(@ref{Controlling
Active Maps}を参照)。個々のコマンドやフックも、この変数の値をチェックできる。

@item
モード変数と同じ名前をもつ、@dfn{モードコマンド(mode
command)}と呼ばれるコマンドを定義する。このコマンドの役目は、モード変数の値のセットに加えて、そのモードの機能を使用を実際に有効、または無効にするために必要な、その他すべてを行うことである。

モードコマンドは、1つのオプション引数を受け入れるべきである。プレフィクス引数なしでinteractiveに呼び出された場合は、モードをトグルする(toggle:
切り替える。たとえば無効なら有効に、有効なら無効にする)こと。プレフィクス引数とともにinteractiveに呼び出された場合、その引数が正であればモードを有効に、それ以外は無効にすべきである。

モードコマンドが、Lispから(つまりからの非interactiveに)呼び出された場合は、引数が省略、または@code{nil}の場合はモードを有効にすべきである。引数がシンボル@code{toggle}の場合はモードをトグルし、それ以外の場合は、上述の数引数とともにinteractiveに呼び出されたときと同じ方法により、その引数を扱うべきである。

以下は、この挙動の実装方法を示す例である(@code{define-minor-mode}マクロが生成するコードも、これに類似する)。

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable (if (eq arg 'toggle)
                  (not foo-mode) ; @r{このモードのモード変数}
                (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

この、やや複雑な挙動の理由は、ユーザーが簡単かつinteractiveにマイナーモードをトグルでき、以下のようにモードフック内で簡単にマイナーモードを有効にできるからである:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
@code{foo-mode}モードコマンドは、引数なしでLispから呼び出されたときは、無条件にそのマイナーモードを有効にするので、これは@code{foo-mode}がすでに有効でもそうでなくても正しく振る舞う。モードフック内でマイナーモードを無効にする場合は、少々醜くなる:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
しかし、これは頻繁には行われない。

@item
モードラインにマイナーモードを標示したい場合は、それぞれのマイナーモードにたいして、要素を@code{minor-mode-alist}に追加する(@ref{Definition
of minor-mode-alist}を参照)。この要素は以下の形式のリストであること:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

ここで、@var{mode-variable}はマイナーモードの有効化を制御する変数であり、@var{string}はモードラインに標示するための、スペースで始まる短い文字列である。一度に複数モードの文字列がスペースを占めるので、これらの文字列は短くなければならない。

@code{minor-mode-alist}に要素を追加する際は、重複を避けるために、既存要素のチェックに@code{assq}を使用すること。たとえば:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
または、以下のように@code{add-to-list}(@ref{List Variables}を参照)を使用すること:

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  これらに加えて、メジャーモードにたいする慣習のいくつかは、マイナーモードにたいしても同様に適用されます。それらの慣習はグローバルシンボルの名前、初期化関数の最後でのフックの使用、キーマップおよびその他のテーブルの使用です。

  マイナーモードは、可能ならばCustom(@ref{Customization}を参照)を通じての有効化および無効化をサポートするべきです。これを行うには、モード変数はは通常は@code{:type
'boolean}とともに@code{defcustom}で定義されるべきです。その変数をセットするだけではモードの有効化に不足なら、モードコマンドを呼び出すことによりモードを有効にする@code{:set}メソッドも指定するべきです。そして、その変数のドキュメント文字列にCustomを通じて変数をセットしなければ効果がないことを注記してください。さらに、その定義をautoload
cookie(@ref{autoload
cookie}を参照)でマークして、その変数のカスタマイズによりモードを定義するライブラリーがロードされるように@code{:require}を指定します。たとえば:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "msb-modeをトグルする
この変数を直接セットしても効果がない
\\[customize]か関数`msb-mode'を使用すること"
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@subsection Keymaps and Minor Modes

  マイナーモードはそれぞれ自身のキーマップをもつことができ、そのモードが有効になるとそのキーマップがアクティブになります。マイナーモード用のキーマップをセットアップするには、@code{minor-mode-map-alist}というalistに要素を追加します。@ref{Definition
of minor-mode-map-alist}を参照してください。

@cindex @code{self-insert-command}, minor modes
  特定の自己挿入文字にたいして、自己挿入と同様に他の何かを行うように振る舞いを変更するのは、マイナーモードキーマップの1つの使い方です。(@code{self-insert-command}をカスタマイズする別の方法は、@code{post-self-insert-hook}を通じて行う方法です。これ以外の@code{self-insert-command}カスタマイズ用機能は特別なケースに限定されていて、abbrevモードとAuto
Fillモードのためにデザインされています。@code{self-insert-command}にたいする標準定義を、あなた独自の定義に置き換えることを試みてはなりません。エディターコマンドループは、この関数を特別に処理します。)

マイナーモードは、コマンドを@kbd{C-c}とその後の区切り文字より構成されるキーシーケンスにバインドするかもしれません。しかし、@kbd{C-c}とその後の@kbd{@{@}<>:;}のいずれかの文字、またはコントロール文字、数字より構成されるシーケンスは、メジャーモード用に予約されています。また、@kbd{C-c
@var{letter}}はユーザー用に予約されています。@ref{Key Binding Conventions}を参照してください。

@node Defining Minor Modes
@subsection Defining Minor Modes

  マクロ@code{define-minor-mode}は、1つの自己完結した定義内にモードを実装する便利な方法を提供します。

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
このマクロは、名前が@var{mode}(シンボル)の新たなマイナーモードを定義する。これは、ドキュメント文字列として@var{doc}をもつ、マイナーモードをトグルするための、@var{mode}という名前のコマンドを定義する。

トグルコマンドは１つのオプション(プレフィクス)引数をとる。引数なしでinteractiveに呼び出された場合は、そのモードのオンとオフをトグルする。正のプレフィクス引数はモードを有効にし、それ以外のプレフィクス引数はモードを無効にする。Lispから呼び出した場合、引数が@code{toggle}の場合はモードをトグルし、引数が省略もしくは@code{nil}の場合はモードを有効にする。これはたとえば、メジャーモードフック内でマイナーモードを有効にするのを簡便にする。@var{doc}が@code{nil}の場合、このマクロは上記を説明するデフォルトのドキュメント文字列を提供する。

デフォルトでは、これはモードを有効にすると@code{t}、無効にすると@code{nil}にセットされる、@var{mode}という名前の変数も定義する。この変数は、@var{init-value}に初期化される。通常では(以下参照)、この値は@code{nil}でなければならない。

文字列@var{lighter}は、モード有効時にモードライン内に何を表示するか指定する。これが@code{nil}の場合は、このモードはモードライン内に表示されない。

オプション引数@var{keymap}は、そのマイナーモードにたいするキーマップを指定する。非@code{nil}の場合、それは(値がキーマップであるような)変数の名前、キーマップ、または以下の形式のalistであること

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
ここで、それぞれの@var{key-sequence}と@var{definition}は、@code{define-key}に渡すのに適した引数である(@ref{Changing
Key
Bindings}を参照)。@var{keymap}はキーマップまたはalistであり、これは変数@code{@var{mode}-map}も定義する。

上記の3つの引数@var{init-value}、@var{lighter}、@var{keymap}は、@var{keyword-args}が使用されたときは、(部分的に)省略できる。@var{keyword-args}は、キーワードとその後の対応する値により構成され、いくつかのキーワードは特別な意味をもつ:

@table @code
@item :group @var{group}
生成されるすべての@code{defcustom}フォームで使用されるカスタムグループ名。@var{mode}(後の@samp{-mode}がある場合はそれを除く)にたいするデフォルトである。@strong{警告:}
そのグループを定義するため@code{defgroup}を正しく記述していない場合は、このデフォルトグループ名を使用してはならない。@ref{Group
Definitions}を参照のこと。

@item :global @var{global}
非@code{nil}の場合、これはそのマイナーモードがバッファーローカルでなくグローバルであることを指定する。デフォルトは@code{nil}。

マイナーモードをグローバルにしたときの効果の1つは、@var{mode}変数がカスタマイズ変数になることである。Customizeインターフェイスを通じてこの変数をトグルするとモードがオン、またはオフになり、変数の値は将来のEmacsセッション用に保存できるようになる(@ref{Saving
Customizations,,, emacs, The GNU Emacs
Manual}を参照)。保存された変数が機能するためには、Emacsが開始されるたびに@code{define-minor-mode}フォームが確実に評価されるようにすべきである。Emacsの一部ではないパッケージにたいしては、@code{:require}キーワードを指定するのが、これを行う一番簡単な方法である。

@item :init-value @var{init-value}
これは、@var{init-value}引数を指定するのと等しい。

@item :lighter @var{lighter}
これは、@var{lighter}引数を指定するのと等しい。

@item :keymap @var{keymap}
これは、@var{keymap}引数を指定するのと等しい。

@item :variable @var{place}
これは、そのモードの状態を格納するために使用される、デフォルトの変数@var{mode}を置き換える。これを指定した場合、@var{mode}変数は定義されず、すべての@var{init-value}引数は使用されない。@var{place}は異なる名前の変数(あなた自身が定義しなければならない)、または@code{setf}関数とともに使用され得るすべてのもの(@ref{Generalized
Variables}を参照)。@var{place}にはコンス@code{(@var{get}
.
@var{set})}も指定できる。ここで、@var{get}はカレント状態をリターンする式であり、@var{set}はそれをセットする1つの引数(状態)をとる関数である。

@item :after-hook @var{after-hook}
これは、モードフック実行後に評価される、単一のLispフォームを定義する。これはクォートすべきでない。
@end table

その他のすべてのキーワード引数は、変数@var{mode}にたいして生成された@code{defcustom}に直接渡される。

@var{mode}という名前のコマンドは、最初に@var{mode}という名前の変数をセットする等の標準的な動作を処理した後に、もしあれば@var{body}フォームを実行する。それからモードフック変数@code{@var{mode}-hook}を実行し、@code{:after-hook}内のフォームを評価して終了する。
@end defmac

  @var{init-value}の値は@code{nil}でなければなりません。ただし、(1)Emacsによりそのモードが事前ロードされている、または(2)たとえユーザーが要求しなくともモードを有効にするためにロードするのが容易な場合を除きます。たとえば、他の何かが有効でなければそのモードの効果がなく、常にそのタイミングでロードされるような場合は、デフォルトでそのモードを有効にすることに害はありません。しかし、この状況は通常はあり得ません。通常は、@var{init-value}の値は@code{nil}でなければならないのです。

@findex easy-mmode-define-minor-mode
  @code{easy-mmode-define-minor-mode}という名前は、このマクロにたいするエイリアスです。

  以下は、@code{define-minor-mode}の使い方の例です:

@smallexample
(define-minor-mode hungry-mode
  "Hungryモードをトグルする。
引数なしでinteractiveに呼び出すとモードをトグルする。
正のプレフィクス引数でモードを有効に、その他のプレフィクス引数で
無効にする。Lispから呼び出す場合、引数を省略、またはnilなら
モードを有効に、`toggle'なら状態をトグルする。

Hungryモードが有効なときは、C-DELキーは、
最後を除く先行するすべての空白を飲み込む。
コマンド \\[hungry-electric-delete] を参照のこと。"
 ;; 初期値
 nil
 ;; モードラインの標示
 " Hungry"
 ;; マイナーモードのバインディング
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
これは、``Hungry
mode''という名前のマイナーモード、モードをトグルする@code{hungry-mode}という名前のコマンド、モードが有効かどうかを示す@code{hungry-mode}という名前の変数、モードが有効なときそのキーマップを保持する@code{hungry-mode-map}という名前の変数を定義します。これは、@kbd{C-@key{DEL}}にたいするキーバインディングでキーマップを初期化します。また、変数@code{hungry-mode}をカスタムグループ@code{hunger}に置きます。@var{body}フォームはありません
--- 多くのマイナーモードは必要としません。

  以下は、これを記述する等価な方法です:

@smallexample
(define-minor-mode hungry-mode
  "Hungryモードをトグルする。
...省略..."
 ;; 初期値
 :init-value nil
 ;; モードラインへのインジケーター
 :lighter " Hungry"
 ;; マイナーモードのバインディング
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
これは、@var{global-mode}という名前をグローバルにトグルする。この意味は、@var{mode}という名前のバッファーローカルなマイナーモードを、すべてのバッファーで有効、または無効にするということである。あるバッファー内でそのマイナーモードをオンにするには、関数@var{turn-on}を使用する。マイナーモードをオフにするには、@minus{}1を引数として@var{mode}を呼び出す。

モードをグローバルに有効にすると、それ以降ファイルをvisitすることにより作成されるバッファー、Fundamental以外のメジャーモードを使用するバッファーにも影響がある。しかし、Fundamentalで作成される新たなバッファーは検知しない。

これは、Customizeインターフェイス内でそのマイナーモードのオン/オフを切り替える、カスタムオプション@var{global-mode}(@ref{Customization})を定義する。@code{define-minor-mode}と同様に、たとえば@code{:require}を与える等により、毎回のEmacs開始時に確実に@code{define-globalized-minor-mode}フォームが評価されるようにすべきである。

グローバルマイナーモードのモード変数にたいしてカスタムグループを指定するには、@var{keyword-args}内で@code{:group
@var{group}}を使用する。

一般的には、グローバル化されたマイナーモードを定義するときは、ユーザーがバッファーごとにモードを使用(または無効に)できるように、非グローバル版も定義すべきである。ことにより、特定のメジャーモード内でそのモードのフックを使用することにより、グローバル有効化されたマイナーモードを無効にすることができるようになる。
@end defmac


@node Mode Line Format
@section Mode Line Format
@cindex mode line

  Emacsの各ウィンドウ(ミニバッファーウィンドウを除く)には通常、最下部にモードラインがあり、そのウィンドウ内に表示されたバッファーについてステータス情報がモードラインに表示されます。モードラインには、バッファー名、関連するファイル、再帰編集の深さ、およびメジャーモードやマイナーモードなどのような、そのバッファーに関する情報が含まれています。ウィンドウは@dfn{ヘッダーライン(header
line)}をもつこともでき、これはモードラインによく似ていますが、ウィンドウの最上部に表示されます。

  このセクションでは、モードラインおよびヘッダーラインのコンテンツの制御の仕方について説明します。このチャプターにモードラインを含めた理由は、モードラインに表示される情報の多くが、有効化されたメジャーモードとマイナーモードに関係があるからです。

@menu
* Base: Mode Line Basics.    モードライン制御の基本概念。
* Data: Mode Line Data.      モードラインを制御するデータ構造。
* Top: Mode Line Top.        トップレベル変数、mode-line-format。
* Mode Line Variables::      そのデータ構造で使用される変数。
* %-Constructs::             モードラインへの情報の配置。
* Properties in Mode::       モードライン内でのテキストプロパティの使用。
* Header Lines::             モードラインに類似した最上部のライン。
* Emulating Mode Line::      モードラインのようにテキストをフォーマットする。
@end menu

@node Mode Line Basics
@subsection Mode Line Basics

  それぞれのモードラインのコンテンツは、バッファーローカル変数@code{mode-line-format}により指定されます(@ref{Mode
Line Top}を参照)。この変数は@dfn{モードライン構成(mode line
construct)}を保持します。これは、そのバッファーのモードラインに何を表示するかを制御するテンプレートです。@code{header-line-format}の値は、同じ方法によりそのバッファーのヘッダーラインを指定します。同一のバッファーにたいするすべてのウィンドウは、同じ@code{mode-line-format}と@code{header-line-format}を使用します。

  効率的な理由により、Emacsは各ウィンドウのモードラインとヘッダーラインを、連続して再評価しません。たとえばウィンドウ設定(window
configuration)の変更、バッファーの切り替え、バッファーのナローイング(narrowing)またはワイドニング(widening)、スクロール、バッファーの変更等、それを呼び出す状況が出現したときに、Emacsは再評価を行います。@code{mode-line-format}や@code{header-line-format}(@ref{Mode
Line
Variables}を参照)により参照される任意の変数、またはテキストが表示される方法に影響を与えるデータ構造(@ref{Display}を参照)を変更した場合は、表示を更新するために関数@code{force-mode-line-update}を使用するべきです。

@defun force-mode-line-update &optional all
この関数は、次の再表示サイクルの間に、すべての関連する変数の最新の値にもとづき、カレントバッファーのモードラインとヘッダーラインの更新をEmacsに強制する。オプション引数@var{all}が非@code{nil}の場合は、すべてのモードラインとヘッダーラインの更新を強制する。

この関数は、メニューバーとフレームタイトルの更新も強制する。
@end defun

  選択されたウィンドウのモードラインは、通常はフェイス@code{mode-line}を使用して異なるカラーで表示されます。かわりに、他のウィンドウのモードラインは、フェイス@code{mode-line-inactive}で表示されます。@ref{Faces}を参照してください。

@node Mode Line Data
@subsection The Data Structure of the Mode Line
@cindex mode line construct

  モードラインのコンテンツは、@dfn{モードライン構成(mode line
construct)}と呼ばれるデータ構造により制御されます。モードライン構成はリスト、シンボル、数字を保持するバッファーローカル変数により構成されます。それぞれのデータ型は、以下で説明するようにモードラインの外見にたいして特別な意味をもちます。フレームタイトル(@ref{Frame
Titles}を参照)とヘッダーライン(@ref{Header Lines}を参照)にたいしても、同じデータ構造が使用されます。

  固定文字列のようにシンプルなモードライン構成の場合もありますが、通常はモードライン構成のテキストを構築するために、固定文字列と変数の値を組み合わせる方法を指定します。これらの変数の多くは、その変数自体がその値によりモードライン構成を定義する変数です。

  以下は、モードライン構成における、さまざまなデータ型の意味です:

@table @code
@cindex percent symbol in mode line
@item @var{string}
モードライン構成においての文字列は、文字列内に@dfn{@code{%}構成(@code{%}-constructs)}を含む以外は、そのまま表現される。これらは、他のデータによる置換を意味する。@ref{%-Constructs}を参照のこと。

文字列の一部が@code{face}プロパティをもつ場合は、バッファー内でそれらが表示されるときと同じように、テキスト表示を制御する。@code{face}プロパティをもたない文字は、デフォルトのフェイス@code{mode-line}、または@code{mode-line-inactive}で表示される(@ref{Standard
Faces,,, emacs, The GNU Emacs
Manual}を参照)。@var{string}内の@code{help-echo}プロパティと@code{keymap}プロパティは、特別な意味をもつ。@ref{Properties
in Mode}を参照のこと。

@item @var{symbol}
モードライン構成においてのシンボルは、その値を意味する。モードライン構成としては、@var{symbol}の値は@var{symbol}の位置に使用される。しかし、シンボル@code{t}と@code{nil}は、値がvoidであるようなシンボルとして無視される。

例外が1つある。@var{symbol}の値が文字列の場合、それはそのまま表示され、@code{%}構成は認識されない。

@var{symbol}が``危険''とマークされていない(非@code{nil}の@code{risky-local-variable}プロパティをもつ)場合は、@var{symbol}の値中で指定されたテキストプロパティはすべて無視される。これには、@var{symbol}の値中の文字列のテキストプロパティ、同様に文字列内の@code{:eval}フォームと@code{:propertize}フォームがすべて含まれる。(これはセキュリティー上の理由による。危険とマークされていない変数は、ユーザーへの問い合わせなしでファイル変数から自動的にセットされ得る。)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
最初の要素が文字列またはリストであるようなリストは、すべての要素を再帰的に処理して、その結果を結合することを意味する。これは、モードライン構成において、もっとも一般的なフォームである。

@item (:eval @var{form})
最初の要素がシンボル@code{:eval}であるようなリストは、@var{form}を評価して、その結果を表示する文字列として使用するよう指示する。この評価がファイルをロードできないことを確認すること。ファイルをロードすると、無限再帰が発生するかもしれない。

@item (:propertize @var{elt} @var{props}@dots{})
最初の要素がシンボル@code{:propertize}であるようなリストは、モードライン構成@var{elt}を再帰的に処理して、@var{props}により指定されるテキストプロパティに結果を加えるよう指示する。引数@var{props}は、0個以上の@var{text-property}と@var{value}のペアーで構成されるべきである。

@item (@var{symbol} @var{then} @var{else})
最初の要素がキーワード以外のシンボルであるようなリストは、条件文を指定する。その意味は、@var{symbol}の値に依存する。@var{symbol}が非@code{nil}値をもつ場合は、モードライン構成として、2つ目の要素@var{then}が再帰的に処理され、それ以外は3つ目の要素@var{else}が再帰的に処理される。@var{else}は省略でき、その場合@var{symbol}の値が@code{nil}かvoidならば、モードライン構成は何も表示しない。

@item (@var{width} @var{rest}@dots{})
最初の要素が整数であるようなリストは、@var{rest}の結果の切り詰め、またはパディングを指定する。残りの要素@var{rest}は、モードライン構成として再帰的に処理され、互いに結合される。@var{width}が正の場合、結果の幅が@var{width}より少ないときは、右側にスペースがパディングされる。@var{width}が負の場合、結果の幅が@minus{}@var{width}より大きいときは、右側が切り詰められる。

たとえば、ウィンドウ最上部からのバッファー位置をパーセント表示するには、@code{(-3 "%p")}のようなリストを使用すればよい。
@end table

@node Mode Line Top
@subsection The Top Level of Mode Line Control

  変数@code{mode-line-format}は、モードラインの全体的な制御を行います。

@defopt mode-line-format
この変数の値は、モードラインのコンテンツを制御するモードライン構成である。これは、すべてのバッファーにおいて、常にバッファーローカルである。

あるバッファー内でこの変数に@code{nil}をセットした場合、そのバッファーはモードラインをもたない(高さが1行しかないウィンドウも、モードラインを表示しない)。
@end defopt

  @code{mode-line-format}のデフォルト値は、@code{mode-line-position}や@code{mode-line-modes}(これは@code{mode-name}と@code{minor-mode-alist}の値を組み込む)のような、他の変数の値を使用するようデザインされています。@code{mode-line-format}自体を変更する必要があるモードは、ほとんどありません。ほとんどの用途にたいしては、@code{mode-line-format}が直接、または間接的に参照する、いくつかの変数を修正すれば十分です。

  @code{mode-line-format}l自体の変更を行った場合、新たな値は他の様式でコンテンツを複製したり情報を表示するのではなく、デフォルト値(@ref{Mode
Line
Variables}を参照)に現れるのと同じ変数を使用するべきです。この方法を使用すれば、ユーザーや(@code{display-time}やメジャーモードのような)Lispプログラムにより行われたカスタマイズは、それらの変数への変更を通じて、効力を保ちます。

  以下は、Shellモードにたいして有用かもしれない、架空の@code{mode-line-format}の例です(実際には、Shellモードは@code{mode-line-format}をセットしない):

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{これはリスト作成中に評価されることに注意。}
   ;; @r{これは単なる文字列のモードライン構成を作成する。}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(変数@code{line-number-mode}、@code{column-number-mode}、@code{which-func-mode}は特定のマイナーモードを有効にする。通例どおり、これらの変数名は、マイナーモードコマンド名でもある。)

@node Mode Line Variables
@subsection Variables Used in the Mode Line

  このセクションでは、@code{mode-line-format}の標準的な値として、モードラインテキストに組み込まれる変数を説明します。これらの変数は、本質的には特別なものではありません。@code{mode-line-format}が使用する変数を他の変数に変更すれば、それらはモードライン上で同様の効果をもちます。しかし、Emacsのさまざまな部分は、それらの変数がモードラインを制御するという認識の元、それらの変数をセットします。したがって、事実上モードラインがそれらの変数を使用するのは必須なのです。

@defvar mode-line-mule-info
この変数は、言語環境(language environment)、バッファーコーディングシステム、カレント入力メソッド(current input
method)に関する情報のモードライン構成の値を保持する。@ref{Non-ASCII Characters}を参照のこと。
@end defvar

@defvar mode-line-modified
この変数は、カレントバッファーが変更されたかどうかを表示する、モードライン構成の値を保持する。デフォルト値ではバッファーが変更されていれば@samp{**}、バッファーが変更されていなければ@samp{--}、バッファーが読み取り専用なら@samp{%%}、読み取り専用だが変更されているときは@samp{%*}を表示する。

この変数を変更しても、モードラインは強制的に更新されない。
@end defvar

@defvar mode-line-frame-identification
この変数は、カレントフレームを識別する。デフォルト値では、複製フレームを表示可能なウィンドウシステムを使用している場合は@code{"
"}、一度に1つのフレームだけを表示する通常の端末では@code{"-%F "}を表示する。
@end defvar

@defvar mode-line-buffer-identification
この変数は、そのウィンドウ内で表示されているバッファーを識別する。デフォルト値では、少なくとも12列になるようスペースパディングされたバッファー名を表示する。
@end defvar

@defopt mode-line-position
この変数は、バッファー内での位置を標示する。デフォルト値ではバッファーのパーセントを表示し、オプションでバッファーサイズ、行番号、列番号を表示する。
@end defopt

@defvar vc-mode
変数@code{vc-mode}は、各バッファーにたいしてバッファーローカルであり、そのバッファーがvisitしているファイルがバージョンコントロールで保守されているかどうかと、保守されている場合はバージョンコントロールシステムの種別を表示する。新しいモードラインに表示される文字列、バージョンコントロールされていない場合は@code{nil}である。
@end defvar

@defopt mode-line-modes
この変数は、そのバッファーのメジャーモードとマイナーモードを表示する。デフォルト値では再帰編集レベル(recursive editing
level)、プロセス状態の情報、ナローイング(narrowing)効果の有無を表示する。
@end defopt

@defvar mode-line-remote
この変数は、カレントバッファーにたいする@code{default-directory}がリモートかどうかを表示するために使用される。
@end defvar

@defvar mode-line-client
この変数は、@code{emacsclient}フレームを識別するために使用される。
@end defvar

  以下の3つの変数は、@code{mode-line-modes}内で使用されます:

@defvar mode-name
このバッファーローカル変数は、カレントバッファーのメジャーモードの``愛称(pretty
name)''を保持する。モード名がモードラインに表示されるように、それぞれのメジャーモードは、この変数をセットすべきである。値は文字列である必要はなく、モードライン構成内で有効な任意のデータ型(@ref{Mode
Line
Data}を参照)を使用できる。モードライン内でモード名を識別する文字列の計算には、@code{format-mode-line}を使用する(@ref{Emulating
Mode Line}を参照)。
@end defvar

@defvar mode-line-process
このバッファーローカル変数には、そのモードにおいて、サブプロセスとの通信にたいするプロセス状態のモードライン情報が含まれる。これはメジャーモード名の直後(間のスペースはない)に表示される。たとえば、@file{*shell*}バッファーでの値は@code{(":%s")}であり、これは@samp{(Shell:run)}のように、メジャーモードとともにその状態を表示する。通常、この変数は@code{nil}である。
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
この変数は、マイナーモードがアクティブかをモードラインに示す方法を指定する要素をもつ、連想リスト(association
list)を保持する。@code{minor-mode-alist}の各要素は、2要素のリストであること:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example

より一般的には、@var{mode-line-string}は任意のモードライン構成であり得る。@var{minor-mode-variable}の値が非@code{nil}の場合はモードラインに表示され、それ以外では表示されない。一緒に実行されないよう、これらの文字列はスペースで始まるべきである。慣例的に、特定のモードにたいする@var{minor-mode-variable}は、そのマイナーモードがアクティブになった際には、非@code{nil}値にセットされる。

@code{minor-mode-alist}自体はバッファーローカルではない。このalist内で参照される各変数は、そのマイナーモードをバッファーごとに個別に有効にできる場合は、バッファーローカルであること。
@end defvar

@defvar global-mode-string
この変数は、モードライン内でマイナーモード@code{which-func-mode}がセットされている場合はその直後、セットされていなければ@code{mode-line-modes}の後に表示されるモードライン構成を保持する(デフォルト)。コマンド@code{display-time}は、時間とロードの情報を含む文字列を保持する変数@code{display-time-string}を参照する、@code{global-mode-string}をセットする。

@samp{%M}構成は、@code{global-mode-string}の値を置き換えるが、この変数は@code{mode-line-format}からモードラインにincludeされるので、時代遅れである。
@end defvar

以下は、@code{mode-line-format}のデフォルト値の簡略化バージョンです。実際のデフォルト値には、追加のテキストプロパティ指定も含まれます。

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Constructs in the Mode Line

  モードライン構成として使用される文字列は、さまざまな種類のデータを置き換えるために、@code{%}構成を使用できます。以下は、定義済みの@code{%}構成と意味のリストです。

  @samp{%%}以外の構成では、フィールドの最小幅を指定するために、@samp{%}の後に10進整数を追加できます。幅がそれより小さい場合、そのフィールドは最小幅にパディングされます。純粋に数値的な構成(@samp{c}、@samp{i}、@samp{I}、@samp{l})は左側、それ以外は右側にスペースを追加してパディングされます。

@table @code
@item %b
@code{buffer-name}関数により取得されるカレントバッファー名。@ref{Buffer Names}を参照のこと。

@item %c
ポイント位置のカレント列番号。

@item %e
EmacsがLispオブジェクトにたいしてメモリー不足になりそうなときは、それを伝える簡略なメッセージを示す。それ以外の場合は空である。

@item %f
@code{buffer-file-name}関数により取得される、visitしているファイル名。@ref{Buffer File
Name}を参照のこと。

@item %F
選択されたフレームのタイトル(ウィンドウシステム上のみ)、または名前。@ref{Basic Parameters}を参照のこと。

@item %i
カレントバッファーのアクセス可能な範囲のサイズ。基本的には@code{(- (point-max) (point-min))}。

@item %I
@samp{%i}と同様だが、10^3は@samp{k}、10^6は@samp{M}、10^9は@samp{G}を使用して省略することにより、より読みやすい方法でサイズをプリントする。

@item %l
ポイント位置のカレント行番号。そのバッファーのアクセス可能な範囲内でカウントされる。

@item %n
ナローイングが有効なときは@samp{Narrow}、それ以外は何も表示しない(@ref{Narrowing}の@code{narrow-to-region}を参照されたい)。

@item %p
ウィンドウの@strong{最上部}より上にあるバッファーテキストのパーセント表示、または@samp{Top}、@samp{Bottom}、@samp{All}のいずれか。デフォルトのモードライン構成は、これを3文字に切り詰めることに注意されたい。

@item %P
ウィンドウの@strong{最下部}より上にあるバッファーテキスト(ウィンドウ内の可視なテキストと、最上部の上にあるテキスト)のパーセント表示、およびバッファーの最上部がスクリーン上で可視な場合は、それに加えて@samp{Top}。または@samp{Bottom}か@samp{All}。

@item %s
@code{process-status}により取得される、カレントバッファーに属するサブプロセスの状態。@ref{Process
Information}を参照のこと。

@item %z
キーボード、端末、およびバッファーコーディングシステムのニーモニック。

@item %Z
@samp{%z}と同様だが、EOL形式(end-of-line format: 改行形式)を含む。

@item %*
バッファーが読み取り専用(@code{buffer-read-only}を参照)の場合は@samp{%}、@*
変更されている場合(@code{buffer-modified-p}を参照)は@samp{*}、@* それ以外は@samp{-}。@ref{Buffer
Modification}を参照のこと。

@item %+
バッファーが変更されている場合(@code{buffer-modified-p}を参照)は@samp{*}@*
バッファーが読み取り専用(@code{buffer-read-only}を参照)の場合は@samp{%}、@*
それ以外は@samp{-}。これは、読み取り専用バッファーの変更にたいしてのみ@samp{%*}と異なる。@ref{Buffer
Modification}を参照のこと。

@item %&
バッファーが変更されている場合は@samp{*}、それ以外は@samp{-}。

@item %[
再帰編集レベルの深さを標示する(ミニバッファーレベルは勘定しない)。1つの編集レベルが@samp{[}。@ref{Recursive
Editing}を参照のこと。

@item %]
1つの編集レベルが@samp{]}(ミニバッファーレベルは勘定しない)。

@item %-
モードラインの残りを充填するのに十分なダッシュ。

@item %%
文字@samp{%}。@code{%}構成が許される文字列内に、リテラル@samp{%}を含めるには、この方法を使用する。
@end table

以下の2つの@code{%}構成はまだサポートされていますが、同じ結果を変数@code{mode-name}と@code{global-mode-string}で取得できるので、これらは時代遅れです。

@table @code
@item %m
@code{mode-name}の値。

@item %M
@code{global-mode-string}の値。
@end table

@node Properties in Mode
@subsection Properties in the Mode Line
@cindex text properties in the mode line

  モードライン内では、特定のテキストプロパティが意味をもちます。@code{face}プロパティは、テキストの外見に影響します。@code{help-echo}プロパティはそのテキストのヘルプ文字列に関連し、@code{keymap}によりテキストをマウスに感応させることができます。

  モードライン内のテキストにたいしてテキストプロパティを指定するには、4つの方法があります:

@enumerate
@item
モードラインデータ構造内に、テキストプロパティをもつ文字列を直接配する。

@item
@samp{%12b}のような、モードライン%構成に、テキストプロパティを配する。その場合、%構成を展開すると、同じテキストプロパティをもつことになる。

@item
@var{props}で指定されるテキストプロパティを@var{elt}に与えるために、@code{(:propertize @var{elt}
@var{props}@dots{})}構成を使用する。

@item
@var{form}がテキストプロパティをもつ文字列に評価されるように、モードラインデータ構造内に@code{:eval
@var{form}}を含むリストを使用する。
@end enumerate

  キーマップを指定するために、@code{keymap}プロパティを使用できます。このキーマップは、マウスクリックにたいしてのみ、実際の効果をもちます。モードライン内にポイントを移動させるのは不可能なので、文字キーやファンクションキーをこれにバインドしても、効果はありません。

  モードラインが、@code{risky-local-variable}が非@code{nil}であるようなプロパティをもつ変数を参照する場合、その変数の値により与える、または指定されるテキストプロパティは、すべて無視されます。これは、そのようなプロパティは呼び出される関数を指定するかもしれず、その関数はファイルローカル変数が由来かもしれないからです。

@node Header Lines
@subsection Window Header Lines
@cindex header line (of a window)
@cindex window header line

  ウィンドウは、最下部にモードラインをもつことができるのと同じように、最上部に@dfn{ヘッダーライン(header
line)}をもつことができます。ヘッダーライン機能は、それが@code{header-line-format}により制御されることを除けば、モードラインと同じように機能します。

@defvar header-line-format
すべてのバッファーにたいしてローカルなこの変数は、そのバッファーを表示するバッファーにたいして、ヘッダーラインを表示する方法を指定する。この変数の値のフォーマットは、@code{mode-line-format}にたいするフォーマットと同じである(@ref{Mode
Line Data}を参照)。通常、この変数は@code{nil}なので、通常のバッファーはヘッダーラインをもたない。
@end defvar

@defun window-header-line-height &optional window
この関数は、@var{window}のヘッダーラインの高さを、ピクセルでリターンする。@var{window}は生きたウィンドウでなければならず、デフォルトは選択されたウィンドウである。
@end defun

  高さが1行しかないウィンドウは、決してヘッダーラインを表示しません。また、高さが2行しかないウィンドウは、一度にモードラインとヘッダーラインを表示できません。そのようなウィンドウがモードラインをもつ場合、ヘッダーラインは表示されません。

@node Emulating Mode Line
@subsection Emulating Mode Line Formatting

  関数@code{format-mode-line}を使用して、特定のモードライン構成にもとづきモードライン、またはヘッダーラインに表示されるテキストを計算できます。

@defun format-mode-line format &optional face window buffer
この関数は、あたかも@var{window}にたいしてモードラインを生成するかのように、@var{format}に応じてテキスト行をフォーマットするが、さらにそのテキストを文字列としてリターンする。引数@var{window}のデフォルトは、選択されたウィンドウである。@var{buffer}が非@code{nil}の場合、使用されるすべての情報は@var{buffer}から取得される。デフォルトでは、@var{window}のバッファーから取得される。

文字列の値は通常、モードラインがもつであろうフェイス、キーマップ等に対応するテキストプロパティをもつ。@var{format}により指定された@code{face}プロパティのないすべての文字は、@var{face}により決定されるデフォルト値を取得する。@var{face}が@code{t}の場合は、@var{window}が選択されていれば@code{mode-line}、それ以外は@code{mode-line-inactive}であることを意味する。@var{face}が@code{nil}、または省略された場合は、デフォルトのフェイスを意味する。@var{face}が整数の場合、この関数はテキストプロパティをもたない値をリターンするだろう。

@var{face}の値として、他の有効なフェイスを指定することもできる。指定された場合、それは@var{format}でフェイスを指定されていない文字の@code{face}プロパティのフェイスを提供する。

@var{face}として@code{mode-line}、@code{mode-line-inactive}、@code{header-line}を使用することにより、フォーマットされた文字列のリターンに加えて、対応するフェイスのカレント定義を使用して、実際にモードラインやヘッダーラインが再描画されるだろうということに注意されたい(他のフェイスでは、再描画は行われない)。

たとえば、@code{(format-mode-line
header-line-format)}は選択されたウィンドウに表示されるテキスト(ヘッダーラインがない場合は@code{""})をリターンするだろう。@code{(format-mode-line
header-line-format
'header-line)}は、各文字がヘッダーライン内でもつであろうフェイスをもつ、同じテキストをリターンし、加えてヘッダーラインの再描画も行う。
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu}とは、バッファー内の定義やセクションをすべてリストするメニューをユーザー選択することにより、バッファー内の該当箇所に直接移動する機能です。Imenuは、定義(またはバッファーのその他の名前つき範囲)の名前とその定義のバッファー内での位置をリストする、バッファーインデックスを構築して、ユーザーがそれを選択すればポイントをおこに移動できるようにして機能します。メジャーモードは、@code{imenu-add-to-menubar}を使用して、メニューバーアイテムを追加することができます。

@deffn Command imenu-add-to-menubar name
この関数は、@var{name}という名前のImenuを実行するためのローカルメニューバーを定義する。
@end deffn

  Imenuを使用ためのユーザーレベルコマンドは、Emacsマニュアル内で説明されています(@ref{Imenu,, Imenu, emacs, the
Emacs
Manual}を参照)。このセクションでは、特定のメジャーモードにたいして、定義や名前つき範囲を見つける、Imenuメソッドのカスタマイズ方法を説明します。

  変数@code{imenu-generic-expression}をセットするのが通常の、そしてもっともシンプルな方法です:

@defvar imenu-generic-expression
この変数が非@code{nil}の場合、それはImenuにたいして定義を探すための正規表現を指定するリストである。シンプルな@code{imenu-generic-expression}の要素は、以下のようになる:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

ここで、@var{menu-title}が非@code{nil}の場合、それはこの要素にたいするマッチが、バッファーインデックスのサブメニューとなることを告げる。@var{menu-title}自体は、そのサブメニューにたいして名前を指定する。@var{menu-title}が@code{nil},の場合は、この要素にたいするマッチは、直接トップレベルのバッファーインデックスとなる。

このリストの2つ目の要素@var{regexp}は、正規表現である(@ref{Regular
Expressions}を参照)。これは、バッファー内でこれにマッチするものは定義、あるいはバッファーインデックス内に記載すべき何かであると判断される。3つ目の要素@var{index}は、0以上の整数の場合は、@var{regexp}内の部分式(subexpression)が定義名にマッチすることを示します。

以下のような要素もある:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

この要素にたいする各マッチはインデックスアイテムを作成し、ユーザーによりそのインデックスアイテムが選択されたとき、アイテム名、バッファー位置、および@var{arguments}から構成される引数で、@var{function}を呼び出す。

Emacs Lispモードにたいしては、@code{imenu-generic-expression}は以下のようになるだろう:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-case-fold-search
この変数は、@code{imenu-generic-expression}の値中の正規表現マッチが、大文字小文字を区別するかどうかを制御する。@code{t},(デフォルト)の場合は、大文字小文字の違いを無視することを意味する。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-syntax-alist
この変数は、@code{imenu-generic-expression}処理中に、カレントバッファーの構文テーブルをオーバーライドして使用する、構文テーブル変更用のalistである。このalistの各要素は、以下の形式をもつべきである:

@example
(@var{characters} . @var{syntax-description})
@end example

@sc{car}の@var{characters}には、文字または文字列を指定できる。この要素は、その文字、または文字列が@var{syntax-description}により指定される構文でありことを示し、@code{modify-syntax-entry}に渡される(@ref{Syntax
Table Functions}を参照)。

典型的には、この機能は通常はシンボル構文(symbol syntax)をもつ文字にたいして単語構文(word
syntax)を与えるために使用され、それにより@code{imenu-generic-expression}が単純になり、マッチングのスピードも向上する。たとえば、Fortranモードは以下のようにこれを使用する:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

@code{imenu-generic-expression}の正規表現は、@samp{\\(\\sw\\|\\s_\\)+}のかわりに、@samp{\\sw+}を使用できる。このテクニックは、モードの名前として許されるより短い、頭文字に名前を制限する必要があるときは、不便かもしれないことに注意されたい。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

  あるメジャーモードにたいしてImenuをカスタマイズする別の方法には、@code{imenu-prev-index-position-function}と@code{imenu-extract-index-name-function}があります:

@defvar imenu-prev-index-position-function
この変数が非@code{nil}の場合、その値はポイント位置からバッファーを後方にスキャンして、バッファーインデックスに配すべき、次の``定義''を探すための関数であること。そして、ポイントより前に他の``定義''が見つからなければ、@code{nil}をリターンすべきである。見つかった場合は、``definition''を見つけた場所にポイントを残し、任意の非@code{nil}値をリターンすべきである。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@defvar imenu-extract-index-name-function
この変数が非@code{nil}の場合、その値はポイントが定義中にある(@code{imenu-prev-index-position-function}関数がポイントを残す場所)という想定の元、その定義の名前をリターンする関数であること。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

  メジャーモードにたいしてImenuをカスタマイズするための最後の方法は、変数@code{imenu-create-index-function}のセットです:

@defvar imenu-create-index-function
この変数は、バッファーインデックスを作成するために使用する関数を指定する。この関数は、引数がをとらず、カレントバッファーにたいするインデックスalist(index
alist)をリターンすべきである。この関数は@code{save-excursion}内で呼び出されるので、どこにポイントを残しても違いはない。

このインデックスalistは、3つのタイプの要素をもつことができる。以下は、シンプル要素(simple element)の例である:

@example
(@var{index-name} . @var{index-position})
@end example

シンプル要素の選択は、そのバッファー内の位置@var{index-position}に移動する効果をもつ。スペシャル要素(special
element)は、以下のようなものである:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

スペシャル要素の選択により、以下が処理される:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

ネストされたサブalist要素(nested sub-alist element)は、以下のようなものである:

@example
(@var{menu-title} . @var{sub-alist})
@end example

これは、@var{sub-alist}により指定される、サブメニュー@var{menu-title}を作成する。

@code{imenu-create-index-function}のデフォルト値は、@code{imenu-default-create-index-function}である。この関数は、インデックスalistを生成するために、@code{imenu-prev-index-position-function}の値と、@code{imenu-extract-index-name-function}の値を呼び出す。しかし、これら2つ変数のいずれかが@code{nil}の場合、デフォルト関数はかわりに@code{imenu-generic-expression}を使用する。

この変数をセットすることにより、カレントバッファーにたいしてバッファーローカルになる。
@end defvar

@node Font Lock Mode
@section Font Lock Mode
@cindex Font Lock mode

  @dfn{Font Lockモード}とは、バッファーの特定の部分にたいして、それらの構文的役割(syntactic
role)にもとづき、自動的に@code{face}プロパティをアタッチする、バッファーローカルなマイナーモードです。このモードがバッファーをパースする方法は、そのメジャーモードに依存します。ほとんどのメジャーモードは、どのコンテキストでどのフェイスを使用するかにたいして、構文的条件(syntactic
criteria)を定義します。このセクションでは、特定のメジャーモードにたいして、Font Lockをカスタマイズする方法を説明します。

  Font Lockモードは、2つの方法によりハイライトするテキストを探します。それは構文テーブル(syntax
table)にもとづく構文解析と、(通常は正規表現にたいする)検索です。最初に構文的フォント表示(syntactic
fontification)が発生します。これはコメントと文字列定数を見つけて、それらをハイライトします。検索ベースのフォント表示が発生するのは、2番目です。

@menu
* Font Lock Basics::         Font Lockカスタマイズの概要。
* Search-based Fontification::  正規表現にもとづくフォント表示。
* Customizing Keywords::     検索ベースフォント表示のカスタマイズ。
* Other Font Lock Variables::  追加のカスタマイズ機能。
* Levels of Font Lock::      多なりとも少ユーザーが選択できるように、それぞれのモードは代替レベルを定義できる。
* Precalculated Fontification::  バッファーコンテンツを生成するLispプログラムが、どのようにしてそれをフォント表示する方法も指定できるか。
* Faces for Font Lock::      Font 
                               Lockにたいする具体的な特殊フェイス。
* Syntactic Font Lock::      構文テーブルにもとづくフォント表示。
* Multiline Font Lock::      Font 
                               Lockに複数行構成の正しいハイライトを強制する方法。
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

  Font
Lockモードがテキストをハイライトする方法を制御する変数が、いくつかあります。しかし、メジャーモードは、これらの変数を直接セットするべきではありません。かわりに、メジャーモードはバッファーローカル変数として、@code{font-lock-defaults}をセットするべきです。Font
Lockモードが有効なときは、他のすべての変数をセットするために、この変数に割り当てられた値が使用されます。

@defvar font-lock-defaults
この変数は、そのモード内のテキストをフォント表示する方法を指定するために、メジャーモードによりセットされる。この変数は、セットした際に自動的にバッファーローカルになる。変数の値が@code{nil}の場合、Font
Lockモードはハイライトを行わず、バッファー内のテキストに明示的にフェイスを割り当てるために、@samp{Faces}メニュー(メニューバーの@samp{Edit}の下の@samp{Text
Properties})を使用できる。

非@code{nil}の場合、値は以下のようであること:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} [@var{syntax-begin} @var{other-vars}@dots{}]]]])
@end example

1つ目の要素@var{keywords}は、検索ベースのフォント表示を制御する@code{font-lock-keywords}の値を、間接的に指定する。値にはシンボル、変数、または@code{font-lock-keywords}にたいして使用するリストが値であるような関数を指定できる。また、それぞれのシンボルがフォント表示の可能なレベルであるような、いくつかのシンボルからなるリストも指定できる。この場合、1つ目のシンボルはフォント表示の@samp{モードデフォルト(mode
default)}レベル、次のシンボルはフォント表示のレベル1、その次はレベル2、のようになる。通常、@samp{モードデフォルト}レベルはレベル1と等しい。これは、@code{font-lock-maximum-decoration}が@code{nil}値をもつとき使用される。@ref{Levels
of Font Lock}を参照のこと。

2つ目の要素@var{keywords-only}は、変数@code{font-lock-keywords-only}の値を指定する。これが省略、または@code{nil}の場合は、(文字列とコメントの)構文的フォント表示も行われる。非@code{nil}の場合は、構文的フォント表示は行われない。@ref{Syntactic
Font Lock}を参照のこと。

3つ目の要素@var{case-fold}は、@code{font-lock-keywords-case-fold-search}の値を指定する。非@code{nil}の場合、検索ベースフォント表示の間、Font
Lockモードは大文字小文字の違いを無視する。

4つ目の要素@var{syntax-alist}が非@code{nil}の場合、それは@code{(@var{char-or-string}
.
@var{string})}という形式のコンスセルのリストであること。これらは、構文的フォント表示にたいする構文テーブルのセットアップに使用される。結果となる構文テーブルは、@code{font-lock-syntax-table}に格納される。@var{syntax-alist}が省略、または@code{nil}の場合、構文的フォント表示は@code{syntax-table}関数によりリターンされる構文テーブルを使用する。@ref{Syntax
Table Functions}を参照のこと。

5つ目の要素@var{syntax-begin}は、@code{font-lock-beginning-of-syntax-function}の値を指定する。この変数は@code{nil}にセットして、かわりに@code{syntax-begin-function}の使用を推奨する。

(もしあれば)残りすべての要素は、まとめて@var{other-vars}と呼ばれる。これらの要素はすべて、@code{(@var{variable}
.
@var{value})}という形式をもつべきである。これは、@var{variable}をバッファーローカルにしてから、それに@var{value}をセットすることを意味する。これら@var{other-vars}を使用して、最初の5つの要素による制御とは別に、フォント表示に影響する他の変数をセットできる。@ref{Other
Font Lock Variables}を参照のこと。
@end defvar

  モードが@code{font-lock-face}プロパティ追加により明示的にテキストをフォント表示する場合は、自動的なフォント表示すべてをオフにするために、@code{font-lock-defaults}に@code{(nil
t)}を指定できます。しかし、これは必須ではありません。@code{font-lock-face}を使用して何かをフォント表示して、それ以外の部分のテキストを自動的にフォント表示するようにセットアップするのは可能です。

@node Search-based Fontification
@subsection Search-based Fontification

  検索ベースフォント表示を直接制御する変数は、@code{font-lock-keywords}です。この変数は通常、@code{font-lock-defaults}内の要素@var{keywords}を通じて指定されます。

@defvar font-lock-keywords
この変数の値は、ハイライトするキーワードのリストである。Lispプログラムは、この変数を直接セッすべきでない。通常は、@code{font-lock-defaults}内の要素@var{keywords}を使用して、Font
Lockモードが自動的に値をセットする。この値は、関数@code{font-lock-add-keywords}および@code{font-lock-remove-keywords}を使用して、変更されることもあり得る(@ref{Customizing
Keywords}を参照)。
@end defvar

  @code{font-lock-keywords}の各要素は、特定のケースに該当するテキストを見つける方法、およびそれらをハイライトする方法を指定します。Font
Lockモードは、@code{font-lock-keywords}の要素をちくじ処理してマッチを探して、すべてのマッチを処理します。通常は、テキストの一部はすでに一度はフォント表示されており、同じテキスト内で連続するマッチによるこれをオーバーライドはできません。しかし、@var{subexp-highlighter}の要素@var{override}を使用して、異なる挙動を指定できます。

  @code{font-lock-keywords}の各要素は、以下の形式のいずれかをもつべきです:

@table @code
@item @var{regexp}
@code{font-lock-keyword-face}を使用して、@var{regexp}にたいするすべてのマッチをハイライトする。たとえば、

@example
;; @r{@code{font-lock-keyword-face}を使用して}
;; @r{単語@samp{foo}をハイライトする}
"\\<foo\\>"
@end example

これらの正規表現を作成するときは、慎重に行うこと。下手に記述されたパターンにより、スピードが劇的に低下し得る!
関数@code{regexp-opt}(@ref{Regexp
Functions}を参照)は、いくつかのキーワードとマッチするために最適な正規表現の計算に有用である。

@item @var{function}
@var{function}を呼び出すことによりテキストを探し、@code{font-lock-keyword-face}を使用して見つかったマッチをハイライトする。

@var{function}は、呼び出される際に1つの引数(検索のリミット)を受け取る。検索はポイント位置から開始し、そのリミットを超えた検索は行うべきではない。これは、検索が成功した場合は非@code{nil}をリターンして、見つかったマッチを表すマッチデータをセットすべきである。@code{nil}のリターンは、検索の失敗を示す。

フォント表示は、前の呼び出しでポイントが残された位置から、同じリミットを用いて@var{function}を呼び出し、@var{function}が失敗するまで@var{function}を繰り返し呼び出すだろう。検索が失敗しても、何らかの特別な方法により、@var{function}がポイントをリセットする必要はない。

@item (@var{matcher} . @var{subexp})
この種の要素では、@var{matcher}は上述のregexpかfunctionのいずれかである。@sc{cdr}の@var{subexp}は、(@var{matcher}がマッチするテキスト全体のかわりに)@var{matcher}のどの部分式(subexpression)がハイライトされるべきかを指定する。

@example
;; @r{@code{font-lock-keyword-face}Hを使用して}
;; @r{@samp{bar}が@samp{fubar}の一部のときに}
;; @r{ハイライトする}
("fu\\(bar\\)" . 1)
@end example

正規表現@var{matcher}の生成に@code{regexp-opt}を使用する場合は、@var{subexp}にたいする値の計算に@code{regexp-opt-depth}(@ref{Regexp
Functions}を参照)を使用できる。

@item (@var{matcher} . @var{facespec})
この種の要素では、@var{facespec}の値がハイライトに使用するフェイスを指定する。もっともシンプルな例では、@var{facespec}は値がフェイス名であるようなはLisp変数(シンボル)である。

@example
;; @r{@code{fubar-face}の値のフェイスを使用して}
;; @r{@samp{fubar}をハイライトする}
("fubar" . fubar-face)
@end example

しかし、@var{facespec}は以下のような形式のリストに評価されてもよい:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
これは、マッチしたテキストにフェイス@var{face}を指定し、さまざまなテキストプロパティをputする。これを行う場合は、この方法により@code{font-lock-extra-managed-props}に値をセットする、他のテキストプロパティ名を確実に追加すること。そうすれば、それらのプロパティが妥当性を失ったとき、それらのプロパティもクリアーされるだろう。これらのプロパティをクリアーする関数を、変数@code{font-lock-unfontify-region-function}にセットすることもできる。@ref{Other
Font Lock Variables}を参照のこと。

@item (@var{matcher} . @var{subexp-highlighter})
この種の要素では、@var{subexp-highlighter}は@var{matcher}により見つかったマッチをハイライトする方法を指定するリストである。これは、以下の形式をもつ。

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

@sc{car}の@var{subexp}は、マッチのどの部分式をフォント表示するかを指定する整数である(0はマッチしたテキスト全体を意味する)。これの2つ目の要素@var{facespec}は、上述したような値がフェイスを指定するような式である。

@var{subexp-highlighter}内の残りの値@var{override}と@var{laxmatch}は、オプションのフラグである。@var{override}が@code{t}の場合、この要素は前の@code{font-lock-keywords}の要素により作成された既存のフォント表示をオーバーライドできる。値が@code{keep}の場合は、すでに他の要素によりフォント表示されていない文字がフォント表示される。値が@code{prepend}の場合は、@var{facespec}により指定されたフェイスが、@code{font-lock-face}プロパティの先頭に追加される。値が@code{append}の場合は、そのフェイスが@code{font-lock-face}プロパティの最後に追加される。

@var{laxmatch}が非@code{nil}の場合、それは@var{matcher}内で番号付けされた部分式@var{subexp}が存在しなくても、エラーにならないことを意味する。当然、番号付けされた部分式@var{subexp}のフォント表示は発生しない。しかし、他の部分式(と他のregexp)のフォント表示は継続されるだろう。@var{laxmatch}が@code{nil}で、指定された部分式が存在しない場合は、エラーがシグナルされて検索ベースのフォント表示は終了する。

以下はこのタイプの要素と、それが何を行うかの例である:

@smallexample
;; @r{@code{foo-bar-face}を使用して、たとえハイライト済みでも}
;; @r{@samp{foo}と@samp{bar}をハイライトする}
;; @r{@code{foo-bar-face}は値がフェイスであるような変数であること}
("foo\\|bar" 0 foo-bar-face t)

;; @r{@code{fubar-face}の値のフェイスを使用して}
;; @r{関数@code{fubar-match}が見つけた各マッチの}
;; @r{最初の部分式をハイライトする}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
この種の要素では、@var{anchored-highlighter}は@var{matcher}が見つけたマッチに後続するテキストをハイライトする方法を指定する。つまり、@var{matcher}が見つけたマッチは、@var{anchored-highlighter}により指定されるその先の検索にたいする、アンカー(anchor)として機能する。@var{anchored-highlighter}は、以下の形式のリストである:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

ここで、@var{anchored-matcher}は@var{matcher}と同様、正規表現か関数である。@var{matcher}にたいするマッチを見つけた後に、ポイントはそのマッチの終端に移動する。そこで、Font
Lockはフォーム@var{pre-form}を評価する。それから@var{anchored-matcher}にたいするマッチを検索し、@var{subexp-highlighters}を使用して、それらのマッチをハイライトする。@var{subexp-highlighter}については上記を参照のこと。最後にFont
Lockは@var{post-form}を評価する。

フォーム@var{pre-form}および@var{post-form}は、@var{anchored-matcher}使用時の事前の初期化、事後のクリーンアップに使用され得る。通常、@var{pre-form}は@var{anchored-matcher}を開始する前に、@var{matcher}のマッチに関連する何らかの位置にポイントを移動するために使用される。@var{post-form}は、@var{matcher}を再開する前に、ポイントを戻すために使用されるかもしれない。

@var{pre-form}を評価した後、Font
Lockはその行の終端の先にたいして、@var{anchored-matcher}の検索を行わない。しかし、@var{pre-form}が@var{pre-form}評価後のポイント位置より大きいバッファー位置をリターンした場合には、かわりに@var{pre-form}によりリターンされた位置が検索リミットとして使用される。一般的に、その行の終端より大きい位置をリターンするのは、よいアイデアではない。別の言い方をすると、@var{anchored-matcher}検索は複数行にわたる(span
lines)べきではないと言えよう。

たとえば、

@smallexample
;; @r{@code{item-face}の値を使用して}
;; @r{単語@samp{anchor}に(同一行内で)}
;; @r{後続する単語@samp{item}をハイライトする}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

ここで、@var{pre-form}と@var{post-form}は@code{nil}である。したがって、@samp{item}にたいする検索は@samp{anchor}にたいするマッチの終端から開始され、後続する@samp{anchor}インスタンスにたいする検索は、@samp{item}にたいする検索が終了した位置から再開される。

@item (@var{matcher} @var{highlighters}@dots{})
この種の要素は、単一の@var{matcher}にたいして、複数の@var{highlighter}リストを指定する。@var{highlighter}リストには、上述した@var{subexp-highlighter}、または@var{anchored-highlighter}のいずれかを指定できる。

たとえば、

@smallexample
;; @r{@code{anchor-face}の値内に現れる単語@samp{anchor}、}
;; @r{および、(同じ行の)後続の@code{item-face}の}
;; @r{ 値内に現れる単語@samp{item}をハイライトする}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
ここで@var{form}は、バッファー内でこの@code{font-lock-keywords}の値が最初に使用されるときに評価される式である。この値は、上述のこのテーブルで説明した、いずれかの形式をもつべきである。
@end table

@strong{警告:}
複数行にわたるテキストにたいするマッチさせるために、@code{font-lock-keywords}の要素をデザインしてはならない。これは確実に機能するとは言えない。詳細は、@ref{Multiline
Font Lock}を参照のこと。

検索ベースのフォント表示が大文字小文字を区別すべきかどうかを告げる@code{font-lock-keywords-case-fold-search}の値を指定するために、@code{font-lock-defaults}内で@var{case-fold}を使用できる。

@defvar font-lock-keywords-case-fold-search
非@code{nil}は、@code{font-lock-keywords}のための正規表現マッチングが、大文字小文字を区別すべきではないことを意味する。
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  メジャーモードにたいして検索ベースフォント表示ルールを追加するために@code{font-lock-add-keywords}、削除には@code{font-lock-remove-keywords}を使用することができます。

@defun font-lock-add-keywords mode keywords &optional how
この関数は、カレントバッファー、またはメジャーモード@var{mode}にたいして、ハイライトする@var{keywords}を追加する。引数@var{keywords}は、変数@code{font-lock-keywords}と同じ形式のリストであること。

@var{mode}が、@code{c-mode}のような、あるメジャーモードのコマンド名であるようなシンボルの場合には、その@var{mode}内でFont
Lockモードを有効にすることにより、@var{keywords}が@code{font-lock-keywords}に追加される効果がある。非@code{nil}値の@var{mode}による呼び出しは、@file{~/.emacs}ファイル内でのみ正しい。

@var{mode}が@code{nil}の場合、この関数はカレントバッファーの@code{font-lock-keywords}に@var{keywords}を追加する。この方法での@code{font-lock-add-keywords}呼び出しは、通常はモードフック関数内で使用される。

デフォルトでは、@var{keywords}は@code{font-lock-keywords}の先頭に追加される。オプション引数@var{how}が@code{set}の場合、それらは@code{font-lock-keywords}の値の置換に使用される。@var{how}がそれ以外の非@code{nil}値の場合、これらは@code{font-lock-keywords}の最後に追加される。

追加のハイライトパターンの使用を可能にする、特別なサポートを提供するモードがいくつかある。それらの例については、変数@code{c-font-lock-extra-types}、@code{c++-font-lock-extra-types}、@code{java-font-lock-extra-types}を参照のこと。

@strong{警告:}
メジャーモードコマンドは、モードフックを除き、いかなる状況においても、直接間接を問わず@code{font-lock-add-keywords}を呼び出してはならない(これを行うと、いくつかのマイナーモードは不正な振る舞いを起こしかねない)。メジャーモードコマンドは、@code{font-lock-keywords}をセットすることにより、検索ベースフォント表示のルールをセットアップすべきである。
@end defun

@defun font-lock-remove-keywords mode keywords
この関数は、カレントバッファー、またはメジャーモード@var{mode}にたいして、@code{font-lock-keywords}から@var{keywords}を削除する。@code{font-lock-add-keywords}の場合と同様、@var{mode}はメジャーモードコマンド名か@code{nil}であること。@code{font-lock-add-keywords}にたいするすべての制約と条件は、この関数にも適用される。
@end defun

  たとえば、以下はCモードに2つのフォント表示パターンを追加するコードの例である。フォント表示の1つは、たとえコメント内であろうとも単語@samp{FIXME}をフォント表示し、もう1つは@samp{and}、@samp{or}、@samp{not}をキーワードとしてフォント表示する。

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
この例は、正にCモードだけに効果がある。Cモード、@emph{および}その派生モードにたいして同じパターンを追加するには、かわりに以下を行う:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

  このセクションでは、@code{font-lock-defaults}内の@var{other-vars}を用いて、メジャーモードがセットできる追加の変数について説明します(@ref{Font
Lock Basics}を参照)。

@defvar font-lock-mark-block-function
この変数が非@code{nil}の場合、それはコマンド@kbd{M-o
M-o}(@code{font-lock-fontify-block})で再フォント表示するテキスト範囲を選択するために、引数なしで呼び出される関数であること。

この関数は、結果を報告するために、選択されたテキスト範囲にリージョンを配すべきである。正しい結果を与えるのに十分、かつ再フォント表示が低速にならない程度のテキスト範囲を選択するのがよい。プログラミングのモードにたいしては@code{mark-defun}、テキストを扱うモードにたいしては@code{mark-paragraph}が典型的な値である。
@end defvar

@defvar font-lock-extra-managed-props
この変数は、(@code{font-lock-face}以外の)Font
Lockにより管理される追加プロパティを指定する。これらの追加プロパティは、通常は@code{font-lock-face}プロパティだけを管理する、@code{font-lock-default-unfontify-region}により使用される。他のプロパティも同様にFont
Lockに管理させたい場合は、このリストに追加するのと同じように、@code{font-lock-keywords}内の@var{facespec}内でもこれらを指定しなければならない。@ref{Search-based
Fontification}を参照のこと。
@end defvar

@defvar font-lock-fontify-buffer-function
そのバッファーをフォント表示するために使用する関数。デフォルト値は@code{font-lock-default-fontify-buffer}。
@end defvar

@defvar font-lock-unfontify-buffer-function
そのバッファーを非フォント表示するために使用する関数。デフォルト値は@code{font-lock-default-unfontify-buffer}。
@end defvar

@defvar font-lock-fontify-region-function
リージョンをフォント表示するための関数。この関数は、リージョンの開始と終了の2つを引数にとり、オプションで3つ目の引数@var{verbose}をとるべきである。@var{verbose}が非@code{nil}の場合、その関数はステータスメッセージをプリントすべきである。デフォルト値は@code{font-lock-default-fontify-region}。
@end defvar

@defvar font-lock-unfontify-region-function
リージョンを非フォント表示するための関数。この関数は、リージョンの開始と終了の2つを引数にとるべきである。デフォルト値は@code{font-lock-default-unfontify-region}。
@end defvar

@defun jit-lock-register function &optional contextual
この関数は、カレントバッファーの一部をフォント表示/非表示する必要がある任意のタイミングで、Font
LockモードがLisp関数@var{function}を実行することを宣言する。これは、デフォルトのフォント表示関数が呼び出される前に、フォント表示/非表示するリージョンを指定する2つの引数@var{start}と@var{end}で@var{function}を呼び出す。

オプション引数@var{contextual}が非@code{nil}の場合は、行が更新されたときに限らず、そのバッファーの構文的に関連する部分を常にフォント表示するよう、Font
Lockモードに強制する。この引数は、通常は省略できる。
@end defun

@defun jit-lock-unregister function
以前に@code{jit-lock-register}を使用して、フォント表示関数として@var{function}を登録した場合は、その関数を未登録にする。
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  フォント表示にたいして3つの異なるレベルを提供するモードが、いくつかあります。@code{font-lock-defaults}内の@var{keywords}にたいしてシンボルのリストを使用することにより、複数のレベルを定義できます。このリストのシンボルはそれぞれ、フォント表示の1レベルを指定します。これらのレベルの選択は、通常は@code{font-lock-maximum-decoration}をセットすることにより、ユーザーの責任で行われます(@ref{Font
Lock,,, emacs, the GNU Emacs
Manual}を参照)。選択されたレベルのシンボルの値は、@code{font-lock-keywords}の初期化に使用されます。

  フォント表示レベルの定義方法に関する慣習を以下に挙げます:

@itemize @bullet
@item
レベル1:
関数宣言、(includeやimportのような)ファイルディレクティブ、文字列、コメントをハイライトする。これは、もっとも重要かつトップレベルのコンポーネントだけをフォント表示すれば高速になるという発想である。

@item
レベル2:
レベル1に加えて、すべての言語のキーワード(キーワードと同様に作用する型名を含む)、および名前付き定数値をハイライトする。これは、(構文的、または意味的な)すべてのキーワードは適切にフォント表示されるべきという発想である。

@item
レベル3: レベル2に加えて、関数内で定義されるシンボル、変数宣言、およびすべてのビルトイン関数名にたいして、それがどこに出現しようとハイライトする。
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  @code{list-buffers}や@code{occur}のようないくつかのメジャーモードは、バッファーのテキストをプログラム的に構築します。これらにたいしてFont
Lockモードをサポートするには、そのバッファーにテキストを挿入するタイミングで、テキストのフェイスを指定するのが、もっとも簡単な方法です。

  これは、スペシャルテキストプロパティ@code{font-lock-face}(@ref{Special
Properties}を参照)により、テキスト内にフェイスを指定することにより行われます。Font
Lockモードが有効になったとき、このプロパティは@code{face}と同じように、表示を制御します。Font
Lockモードが無効になると、@code{font-lock-face}は表示に効果をもちません。

  モードが、通常のFont
Lockメカニズムとともに、あるテキストにたいして@code{font-lock-face}を使用しても問題はありません。しかし、そのモードが通常のFont
Lockメカニズムを使用しない場合は、変数@code{font-lock-face}をセットするべきではありません。

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Font
Lockモードは、ハイライトに任意のフェイスを使用できますが、Emacsは、特にFontLockがテキストのハイライトに使用するいくつかのフェイスを定義しています。これらの@dfn{Font
Lockフェイス(Font Lock
faces)}を、以下にリストします。これらのフェイスは、FontLockモードの外部における構文的なハイライトでメジャーモードが使用することもできます(@ref{Major
Mode Conventions}を参照)。

  以下の各シンボルは、フェイス名であり、かつデフォルト値がシンボル自身であるような変数でもあります。つまり、@code{font-lock-comment-face}のデフォルト値は@code{font-lock-comment-face}です。

  リストは、そのフェイスの典型的な使い方の説明とともに、``重要性''が大きい順にソートされています。あるモードの構文的カテゴリーが、以下の使い方の説明にうまく適合しない場合、この並び順をガイドとして使用することにより、フェイスを割り当てることができるでしょう。

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
Emacs
Lispの@samp{;;;###autoload}、Cの@samp{#error}のような、特有な構文、またはその他のテキスト意味を大きく変更する構文にたいして使用される。

@item font-lock-function-name-face
@vindex font-lock-function-name-face
定義、または宣言される関数の名前にたいして使用される。

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
定義、または宣言される変数の名前にたいして使用される。

@item font-lock-keyword-face
@vindex font-lock-keyword-face
Cの@samp{for}や@samp{if}のように、特別な構文的意味をもつキーワードにたいして使用される。

@item font-lock-comment-face
@vindex font-lock-comment-face
コメントにたいして使用される。

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
Cの@samp{/*}と@samp{*/}のような、コメント区切りにたいして使用される。ほとんどの端末では、このフェイスは@code{font-lock-comment-face}を継承する。

@item font-lock-type-face
@vindex font-lock-type-face
ユーザー定義データ型にたいして使用される。

@item font-lock-constant-face
@vindex font-lock-constant-face
Cの@samp{NULL}のような、定数の名前にたいして使用される。

@item font-lock-builtin-face
@vindex font-lock-builtin-face
ビルトイン関数の名前にたいして使用される。

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
プロセッサーコマンドにたいして使用される。デフォルトでは、@code{font-lock-builtin-face}を継承する。

@item font-lock-string-face
@vindex font-lock-string-face
文字列定数にたいして使用される。

@item font-lock-doc-face
@vindex font-lock-doc-face
コード内のドキュメント文字列にたいして使用される。デフォルトでは、@code{font-lock-string-face}を継承する。

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
見逃されやすい否定文字にたいして使用される。
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

Syntactic fontification uses a syntax table (@pxref{Syntax Tables}) to find
and highlight syntactically relevant text.  If enabled, it runs prior to
search-based fontification.  The variable
@code{font-lock-syntactic-face-function}, documented below, determines which
syntactic constructs to highlight.  There are several variables that affect
syntactic fontification; you should set them by means of
@code{font-lock-defaults} (@pxref{Font Lock Basics}).

  Whenever Font Lock mode performs syntactic fontification on a stretch of
text, it first calls the function specified by
@code{syntax-propertize-function}.  Major modes can use this to apply
@code{syntax-table} text properties to override the buffer's syntax table in
special cases.  @xref{Syntax Properties}.

@defvar font-lock-keywords-only
If the value of this variable is non-@code{nil}, Font Lock does not do
syntactic fontification, only search-based fontification based on
@code{font-lock-keywords}.  It is normally set by Font Lock mode based on
the @var{keywords-only} element in @code{font-lock-defaults}.
@end defvar

@defvar font-lock-syntax-table
This variable holds the syntax table to use for fontification of comments
and strings.  It is normally set by Font Lock mode based on the
@var{syntax-alist} element in @code{font-lock-defaults}.  If this value is
@code{nil}, syntactic fontification uses the buffer's syntax table (the
value returned by the function @code{syntax-table}; @pxref{Syntax Table
Functions}).
@end defvar

@defvar font-lock-beginning-of-syntax-function
If this variable is non-@code{nil}, it should be a function to move point
back to a position that is syntactically at ``top level'' and outside of
strings or comments.  The value is normally set through an @var{other-vars}
element in @code{font-lock-defaults}.  If it is @code{nil}, Font Lock uses
@code{syntax-begin-function} to move back outside of any comment, string, or
sexp (@pxref{Position Parse}).

This variable is semi-obsolete; we usually recommend setting
@code{syntax-begin-function} instead.  One of its uses is to tune the
behavior of syntactic fontification, e.g., to ensure that different kinds of
strings or comments are highlighted differently.

The specified function is called with no arguments.  It should leave point
at the beginning of any enclosing syntactic block.  Typical values are
@code{beginning-of-line} (used when the start of the line is known to be
outside a syntactic block), or @code{beginning-of-defun} for programming
modes, or @code{backward-paragraph} for textual modes.
@end defvar

@defvar font-lock-syntactic-face-function
If this variable is non-@code{nil}, it should be a function to determine
which face to use for a given syntactic element (a string or a comment).
The value is normally set through an @var{other-vars} element in
@code{font-lock-defaults}.

The function is called with one argument, the parse state at point returned
by @code{parse-partial-sexp}, and should return a face.  The default value
returns @code{font-lock-comment-face} for comments and
@code{font-lock-string-face} for strings (@pxref{Faces for Font Lock}).
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  Normally, elements of @code{font-lock-keywords} should not match across
multiple lines; that doesn't work reliably, because Font Lock usually scans
just part of the buffer, and it can miss a multi-line construct that crosses
the line boundary where the scan starts.  (The scan normally starts at the
beginning of a line.)

  Making elements that match multiline constructs work properly has two
aspects: correct @emph{identification} and correct @emph{rehighlighting}.
The first means that Font Lock finds all multiline constructs.  The second
means that Font Lock will correctly rehighlight all the relevant text when a
multiline construct is changed---for example, if some of the text that was
previously part of a multiline construct ceases to be part of it.  The two
aspects are closely related, and often getting one of them to work will
appear to make the other also work.  However, for reliable results you must
attend explicitly to both aspects.

  There are three ways to ensure correct identification of multiline
constructs:

@itemize
@item
Add a function to @code{font-lock-extend-region-functions} that does the
@emph{identification} and extends the scan so that the scanned text never
starts or ends in the middle of a multiline construct.
@item
Use the @code{font-lock-fontify-region-function} hook similarly to extend
the scan so that the scanned text never starts or ends in the middle of a
multiline construct.
@item
Somehow identify the multiline construct right when it gets inserted into
the buffer (or at any point after that but before font-lock tries to
highlight it), and mark it with a @code{font-lock-multiline} which will
instruct font-lock not to start or end the scan in the middle of the
construct.
@end itemize

  There are three ways to do rehighlighting of multiline constructs:

@itemize
@item
Place a @code{font-lock-multiline} property on the construct.  This will
rehighlight the whole construct if any part of it is changed.  In some cases
you can do this automatically by setting the @code{font-lock-multiline}
variable, which see.
@item
Make sure @code{jit-lock-contextually} is set and rely on it doing its job.
This will only rehighlight the part of the construct that follows the actual
change, and will do it after a short delay.  This only works if the
highlighting of the various parts of your multiline construct never depends
on text in subsequent lines.  Since @code{jit-lock-contextually} is
activated by default, this can be an attractive solution.
@item
Place a @code{jit-lock-defer-multiline} property on the construct.  This
works only if @code{jit-lock-contextually} is used, and with the same delay
before rehighlighting, but like @code{font-lock-multiline}, it also handles
the case where highlighting depends on subsequent lines.
@end itemize

@menu
* Font Lock Multiline::      Marking multiline chunks with a text property.
* Region to Refontify::      Controlling which region gets refontified after 
                               a buffer change.
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  One way to ensure reliable rehighlighting of multiline Font Lock constructs
is to put on them the text property @code{font-lock-multiline}.  It should
be present and non-@code{nil} for text that is part of a multiline
construct.

  When Font Lock is about to highlight a range of text, it first extends the
boundaries of the range as necessary so that they do not fall within text
marked with the @code{font-lock-multiline} property.  Then it removes any
@code{font-lock-multiline} properties from the range, and highlights it.
The highlighting specification (mostly @code{font-lock-keywords}) must
reinstall this property each time, whenever it is appropriate.

  @strong{Warning:} don't use the @code{font-lock-multiline} property on large
ranges of text, because that will make rehighlighting slow.

@defvar font-lock-multiline
If the @code{font-lock-multiline} variable is set to @code{t}, Font Lock
will try to add the @code{font-lock-multiline} property automatically on
multiline constructs.  This is not a universal solution, however, since it
slows down Font Lock somewhat.  It can miss some multiline constructs, or
make the property larger or smaller than necessary.

For elements whose @var{matcher} is a function, the function should ensure
that submatch 0 covers the whole relevant multiline construct, even if only
a small subpart will be highlighted.  It is often just as easy to add the
@code{font-lock-multiline} property by hand.
@end defvar

  The @code{font-lock-multiline} property is meant to ensure proper
refontification; it does not automatically identify new multiline
constructs.  Identifying the requires that Font Lock mode operate on large
enough chunks at a time.  This will happen by accident on many cases, which
may give the impression that multiline constructs magically work.  If you
set the @code{font-lock-multiline} variable non-@code{nil}, this impression
will be even stronger, since the highlighting of those constructs which are
found will be properly updated from then on.  But that does not work
reliably.

  To find multiline constructs reliably, you must either manually place the
@code{font-lock-multiline} property on the text before Font Lock mode looks
at it, or use @code{font-lock-fontify-region-function}.

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  When a buffer is changed, the region that Font Lock refontifies is by
default the smallest sequence of whole lines that spans the change.  While
this works well most of the time, sometimes it doesn't---for example, when a
change alters the syntactic meaning of text on an earlier line.

  You can enlarge (or even reduce) the region to refontify by setting the
following variable:

@defvar font-lock-extend-after-change-region-function
This buffer-local variable is either @code{nil} or a function for Font Lock
mode to call to determine the region to scan and fontify.

The function is given three parameters, the standard @var{beg}, @var{end},
and @var{old-len} from @code{after-change-functions} (@pxref{Change
Hooks}).  It should return either a cons of the beginning and end buffer
positions (in that order) of the region to fontify, or @code{nil} (which
means choose the region in the standard way).  This function needs to
preserve point, the match-data, and the current restriction.  The region it
returns may start or end in the middle of a line.

Since this function is called after every buffer change, it should be
reasonably fast.
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

For programming languages, an important feature of a major mode is to
provide automatic indentation.  There are two parts: one is to decide what
is the right indentation of a line, and the other is to decide when to
reindent a line.  By default, Emacs reindents a line whenever you type a
character in @code{electric-indent-chars}, which by default only includes
Newline.  Major modes can add chars to @code{electric-indent-chars}
according to the syntax of the language.

Deciding what is the right indentation is controlled in Emacs by
@code{indent-line-function} (@pxref{Mode-Specific Indent}).  For some modes,
the @emph{right} indentation cannot be known reliably, typically because
indentation is significant so several indentations are valid but with
different meanings.  In that case, the mode should set
@code{electric-indent-inhibit} to make sure the line is not constantly
re-indented against the user's wishes.

Writing a good indentation function can be difficult and to a large extent
it is still a black art.  Many major mode authors will start by writing a
simple indentation function that works for simple cases, for example by
comparing with the indentation of the previous text line.  For most
programming languages that are not really line-based, this tends to scale
very poorly: improving such a function to let it handle more diverse
situations tends to become more and more difficult, resulting in the end
with a large, complex, unmaintainable indentation function which nobody
dares to touch.

A good indentation function will usually need to actually parse the text,
according to the syntax of the language.  Luckily, it is not necessary to
parse the text in as much detail as would be needed for a compiler, but on
the other hand, the parser embedded in the indentation code will want to be
somewhat friendly to syntactically incorrect code.

Good maintainable indentation functions usually fall into two categories:
either parsing forward from some ``safe'' starting point until the position
of interest, or parsing backward from the position of interest.  Neither of
the two is a clearly better choice than the other: parsing backward is often
more difficult than parsing forward because programming languages are
designed to be parsed forward, but for the purpose of indentation it has the
advantage of not needing to guess a ``safe'' starting point, and it
generally enjoys the property that only a minimum of text will be analyzed
to decide the indentation of a line, so indentation will tend to be less
affected by syntax errors in some earlier unrelated piece of code.  Parsing
forward on the other hand is usually easier and has the advantage of making
it possible to reindent efficiently a whole region at a time, with a single
parse.

Rather than write your own indentation function from scratch, it is often
preferable to try and reuse some existing ones or to rely on a generic
indentation engine.  There are sadly few such engines.  The CC-mode
indentation code (used with C, C++, Java, Awk and a few other such modes)
has been made more generic over the years, so if your language seems
somewhat similar to one of those languages, you might try to use that
engine.  Another one is SMIE which takes an approach in the spirit of Lisp
sexps and adapts it to non-Lisp languages.

@menu
* SMIE::                     A simple minded indentation engine.
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIE is a package that provides a generic navigation and indentation
engine.  Based on a very simple parser using an ``operator precedence
grammar'', it lets major modes extend the sexp-based navigation of Lisp to
non-Lisp languages as well as provide a simple to use but reliable
auto-indentation.

Operator precedence grammar is a very primitive technology for parsing
compared to some of the more common techniques used in compilers.  It has
the following characteristics: its parsing power is very limited, and it is
largely unable to detect syntax errors, but it has the advantage of being
algorithmically efficient and able to parse forward just as well as
backward.  In practice that means that SMIE can use it for indentation based
on backward parsing, that it can provide both @code{forward-sexp} and
@code{backward-sexp} functionality, and that it will naturally work on
syntactically incorrect code without any extra effort.  The downside is that
it also means that most programming languages cannot be parsed correctly
using SMIE, at least not without resorting to some special tricks
(@pxref{SMIE Tricks}).

@menu
* SMIE setup::               SMIE setup and features.
* Operator Precedence Grammars::  A very simple parsing technique.
* SMIE Grammar::             Defining the grammar of a language.
* SMIE Lexer::               Defining tokens.
* SMIE Tricks::              Working around the parser's limitations.
* SMIE Indentation::         Specifying indentation rules.
* SMIE Indentation Helpers::  Helper functions for indentation rules.
* SMIE Indentation Example::  Sample indentation rules.
* SMIE Customization::       Customizing indentation.
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

SMIE is meant to be a one-stop shop for structural navigation and various
other features which rely on the syntactic structure of code, in particular
automatic indentation.  The main entry point is @code{smie-setup} which is a
function typically called while setting up a major mode.

@defun smie-setup grammar rules-function &rest keywords
Setup SMIE navigation and indentation.  @var{grammar} is a grammar table
generated by @code{smie-prec2->grammar}.  @var{rules-function} is a set of
indentation rules for use on @code{smie-rules-function}.  @var{keywords} are
additional arguments, which can include the following keywords:
@itemize
@item
@code{:forward-token} @var{fun}: Specify the forward lexer to use.
@item
@code{:backward-token} @var{fun}: Specify the backward lexer to use.
@end itemize
@end defun

Calling this function is sufficient to make commands such as
@code{forward-sexp}, @code{backward-sexp}, and @code{transpose-sexps} be
able to properly handle structural elements other than just the paired
parentheses already handled by syntax tables.  For example, if the provided
grammar is precise enough, @code{transpose-sexps} can correctly transpose
the two arguments of a @code{+} operator, taking into account the precedence
rules of the language.

Calling `smie-setup' is also sufficient to make TAB indentation work in the
expected way, extends @code{blink-matching-paren} to apply to elements like
@code{begin...end}, and provides some commands that you can bind in the
major mode keymap.

@deffn Command smie-close-block
This command closes the most recently opened (and not yet closed) block.
@end deffn

@deffn Command smie-down-list &optional arg
This command is like @code{down-list} but it also pays attention to nesting
of tokens other than parentheses, such as @code{begin...end}.
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

SMIE's precedence grammars simply give to each token a pair of precedences:
the left-precedence and the right-precedence.  We say @code{T1 < T2} if the
right-precedence of token @code{T1} is less than the left-precedence of
token @code{T2}.  A good way to read this @code{<} is as a kind of
parenthesis: if we find @code{... T1 something T2 ...} then that should be
parsed as @code{... T1 (something T2 ...} rather than as @code{... T1
something) T2 ...}.  The latter interpretation would be the case if we had
@code{T1 > T2}.  If we have @code{T1 = T2}, it means that token T2 follows
token T1 in the same syntactic construction, so typically we have
@code{"begin" = "end"}.  Such pairs of precedences are sufficient to express
left-associativity or right-associativity of infix operators, nesting of
tokens like parentheses and many other cases.

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
This function takes a @emph{prec2} grammar @var{table} and returns an alist
suitable for use in @code{smie-setup}.  The @emph{prec2} @var{table} is
itself meant to be built by one of the functions below.
@end defun

@defun smie-merge-prec2s &rest tables
This function takes several @emph{prec2} @var{tables} and merges them into a
new @emph{prec2} table.
@end defun

@defun smie-precs->prec2 precs
This function builds a @emph{prec2} table from a table of precedences
@var{precs}.  @var{precs} should be a list, sorted by precedence (for
example @code{"+"} will come before @code{"*"}), of elements of the form
@code{(@var{assoc} @var{op} ...)}, where each @var{op} is a token that acts
as an operator; @var{assoc} is their associativity, which can be either
@code{left}, @code{right}, @code{assoc}, or @code{nonassoc}.  All operators
in a given element share the same precedence level and associativity.
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
This function lets you specify the grammar using a BNF notation.  It accepts
a @var{bnf} description of the grammar along with a set of conflict
resolution rules @var{resolvers}, and returns a @emph{prec2} table.

@var{bnf} is a list of nonterminal definitions of the form
@code{(@var{nonterm} @var{rhs1} @var{rhs2} ...)} where each @var{rhs} is a
(non-empty) list of terminals (aka tokens) or non-terminals.

Not all grammars are accepted:
@itemize
@item
An @var{rhs} cannot be an empty list (an empty list is never needed, since
SMIE allows all non-terminals to match the empty string anyway).
@item
An @var{rhs} cannot have 2 consecutive non-terminals: each pair of
non-terminals needs to be separated by a terminal (aka token).  This is a
fundamental limitation of operator precedence grammars.
@end itemize

Additionally, conflicts can occur:
@itemize
@item
The returned @emph{prec2} table holds constraints between pairs of tokens,
and for any given pair only one constraint can be present: T1 < T2, T1 = T2,
or T1 > T2.
@item
A token can be an @code{opener} (something similar to an open-paren), a
@code{closer} (like a close-paren), or @code{neither} of the two (e.g., an
infix operator, or an inner token like @code{"else"}).
@end itemize

Precedence conflicts can be resolved via @var{resolvers}, which is a list of
@emph{precs} tables (see @code{smie-precs->prec2}): for each precedence
conflict, if those @code{precs} tables specify a particular constraint, then
the conflict is resolved by using this constraint instead, else a conflict
is reported and one of the conflicting constraints is picked arbitrarily and
the others are simply ignored.
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

The usual way to define the SMIE grammar of a language is by defining a new
global variable that holds the precedence table by giving a set of BNF
rules.  For example, the grammar definition for a small Pascal-like language
could look like:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
A few things to note:

@itemize
@item
The above grammar does not explicitly mention the syntax of function calls:
SMIE will automatically allow any sequence of sexps, such as identifiers,
balanced parentheses, or @code{begin ... end} blocks to appear anywhere
anyway.
@item
The grammar category @code{id} has no right hand side: this does not mean
that it can match only the empty string, since as mentioned any sequence of
sexps can appear anywhere anyway.
@item
Because non terminals cannot appear consecutively in the BNF grammar, it is
difficult to correctly handle tokens that act as terminators, so the above
grammar treats @code{";"} as a statement @emph{separator} instead, which
SMIE can handle very well.
@item
Separators used in sequences (such as @code{","} and @code{";"} above)  are
best defined with BNF rules such as @code{(foo (foo "separator" foo) ...)}
which generate precedence conflicts which are then resolved by giving them
an explicit @code{(assoc "separator")}.
@item
The @code{("(" exps ")")} rule was not needed to pair up parens, since SMIE
will pair up any characters that are marked as having paren syntax in the
syntax table.  What this rule does instead (together with the definition of
@code{exps}) is to make it clear that @code{","} should not appear outside
of parentheses.
@item
Rather than have a single @emph{precs} table to resolve conflicts, it is
preferable to have several tables, so as to let the BNF part of the grammar
specify relative precedences where possible.
@item
Unless there is a very good reason to prefer @code{left} or @code{right}, it
is usually preferable to mark operators as associative, using @code{assoc}.
For that reason @code{"+"} and @code{"*"} are defined above as @code{assoc},
although the language defines them formally as left associative.
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

SMIE comes with a predefined lexical analyzer which uses syntax tables in
the following way: any sequence of characters that have word or symbol
syntax is considered a token, and so is any sequence of characters that have
punctuation syntax.  This default lexer is often a good starting point but
is rarely actually correct for any given language.  For example, it will
consider @code{"2,+3"} to be composed of 3 tokens: @code{"2"}, @code{",+"},
and @code{"3"}.

To describe the lexing rules of your language to SMIE, you need 2 functions,
one to fetch the next token, and another to fetch the previous token.  Those
functions will usually first skip whitespace and comments and then look at
the next chunk of text to see if it is a special token.  If so it should
skip the token and return a description of this token.  Usually this is
simply the string extracted from the buffer, but it can be anything you
want.  For example:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

Notice how those lexers return the empty string when in front of
parentheses.  This is because SMIE automatically takes care of the
parentheses defined in the syntax table.  More specifically if the lexer
returns @code{nil} or an empty string, SMIE tries to handle the
corresponding text as a sexp according to syntax tables.

@node SMIE Tricks
@subsubsection Living With a Weak Parser

The parsing technique used by SMIE does not allow tokens to behave
differently in different contexts.  For most programming languages, this
manifests itself by precedence conflicts when converting the BNF grammar.

Sometimes, those conflicts can be worked around by expressing the grammar
slightly differently.  For example, for Modula-2 it might seem natural to
have a BNF grammar that looks like this:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

But this will create conflicts for @code{"ELSE"}: on the one hand, the IF
rule implies (among many other things) that @code{"ELSE" = "END"}; but on
the other hand, since @code{"ELSE"} appears within @code{cases}, which
appears left of @code{"END"}, we also have @code{"ELSE" > "END"}.  We can
solve the conflict either by using:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
or
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

Reworking the grammar to try and solve conflicts has its downsides, tho,
because SMIE assumes that the grammar reflects the logical structure of the
code, so it is preferable to keep the BNF closer to the intended abstract
syntax tree.

Other times, after careful consideration you may conclude that those
conflicts are not serious and simply resolve them via the @var{resolvers}
argument of @code{smie-bnf->prec2}.  Usually this is because the grammar is
simply ambiguous: the conflict does not affect the set of programs described
by the grammar, but only the way those programs are parsed.  This is
typically the case for separators and associative infix operators, where you
want to add a resolver like @code{'((assoc "|"))}.  Another case where this
can happen is for the classic @emph{dangling else} problem, where you will
use @code{'((assoc "else" "then"))}.  It can also happen for cases where the
conflict is real and cannot really be resolved, but it is unlikely to pose a
problem in practice.

Finally, in many cases some conflicts will remain despite all efforts to
restructure the grammar.  Do not despair: while the parser cannot be made
more clever, you can make the lexer as smart as you want.  So, the solution
is then to look at the tokens involved in the conflict and to split one of
those tokens into 2 (or more) different tokens.  E.g., if the grammar needs
to distinguish between two incompatible uses of the token @code{"begin"},
make the lexer return different tokens (say @code{"begin-fun"} and
@code{"begin-plain"}) depending on which kind of @code{"begin"} it finds.
This pushes the work of distinguishing the different cases to the lexer,
which will thus have to look at the surrounding text to find ad-hoc clues.

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

Based on the provided grammar, SMIE will be able to provide automatic
indentation without any extra effort.  But in practice, this default
indentation style will probably not be good enough.  You will want to tweak
it in many different cases.

SMIE indentation is based on the idea that indentation rules should be as
local as possible.  To this end, it relies on the idea of @emph{virtual}
indentation, which is the indentation that a particular program point would
have if it were at the beginning of a line.  Of course, if that program
point is indeed at the beginning of a line, its virtual indentation is its
current indentation.  But if not, then SMIE uses the indentation algorithm
to compute the virtual indentation of that point.  Now in practice, the
virtual indentation of a program point does not have to be identical to the
indentation it would have if we inserted a newline before it.  To see how
this works, the SMIE rule for indentation after a @code{@{} in C does not
care whether the @code{@{} is standing on a line of its own or is at the end
of the preceding line.  Instead, these different cases are handled in the
indentation rule that decides how to indent before a @code{@{}.

Another important concept is the notion of @emph{parent}: The @emph{parent}
of a token, is the head token of the nearest enclosing syntactic construct.
For example, the parent of an @code{else} is the @code{if} to which it
belongs, and the parent of an @code{if}, in turn, is the lead token of the
surrounding construct.  The command @code{backward-sexp} jumps from a token
to its parent, but there are some caveats: for @emph{openers} (tokens which
start a construct, like @code{if}), you need to start with point before the
token, while for others you need to start with point after the token.
@code{backward-sexp} stops with point before the parent token if that is the
@emph{opener} of the token of interest, and otherwise it stops with point
after the parent token.

SMIE indentation rules are specified using a function that takes two
arguments @var{method} and @var{arg} where the meaning of @var{arg} and the
expected return value depend on @var{method}.

@var{method} can be:
@itemize
@item
@code{:after}, in which case @var{arg} is a token and the function should
return the @var{offset} to use for indentation after @var{arg}.
@item
@code{:before}, in which case @var{arg} is a token and the function should
return the @var{offset} to use to indent @var{arg} itself.
@item
@code{:elem}, in which case the function should return either the offset to
use to indent function arguments (if @var{arg} is the symbol @code{arg}) or
the basic indentation step (if @var{arg} is the symbol @code{basic}).
@item
@code{:list-intro}, in which case @var{arg} is a token and the function
should return non-@code{nil} if the token is followed by a list of
expressions (not separated by any token) rather than an expression.
@end itemize

When @var{arg} is a token, the function is called with point just before
that token.  A return value of @code{nil} always means to fallback on the
default behavior, so the function should return @code{nil} for arguments it
does not expect.

@var{offset} can be:
@itemize
@item
@code{nil}: use the default indentation rule.
@item
@code{(column . @var{column})}: indent to column @var{column}.
@item
@var{number}: offset by @var{number}, relative to a base token which is the
current token for @code{:after} and its parent for @code{:before}.
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

SMIE provides various functions designed specifically for use in the
indentation rules function (several of those functions break if used in
another context).  These functions all start with the prefix
@code{smie-rule-}.

@defun smie-rule-bolp
Return non-@code{nil} if the current token is the first on the line.
@end defun

@defun smie-rule-hanging-p
Return non-@code{nil} if the current token is @emph{hanging}.  A token is
@emph{hanging} if it is the last token on the line and if it is preceded by
other tokens: a lone token on a line is not hanging.
@end defun

@defun smie-rule-next-p &rest tokens
Return non-@code{nil} if the next token is among @var{tokens}.
@end defun

@defun smie-rule-prev-p &rest tokens
Return non-@code{nil} if the previous token is among @var{tokens}.
@end defun

@defun smie-rule-parent-p &rest parents
Return non-@code{nil} if the current token's parent is among @var{parents}.
@end defun

@defun smie-rule-sibling-p
Return non-@code{nil} if the current token's parent is actually a sibling.
This is the case for example when the parent of a @code{","} is just the
previous @code{","}.
@end defun

@defun smie-rule-parent &optional offset
Return the proper offset to align the current token with the parent.  If
non-@code{nil}, @var{offset} should be an integer giving an additional
offset to apply.
@end defun

@defun smie-rule-separator method
Indent current token as a @emph{separator}.

By @emph{separator}, we mean here a token whose sole purpose is to separate
various elements within some enclosing syntactic construct, and which does
not have any semantic significance in itself (i.e., it would typically not
exist as a node in an abstract syntax tree).

Such a token is expected to have an associative syntax and be closely tied
to its syntactic parent.  Typical examples are @code{","} in lists of
arguments (enclosed inside parentheses), or @code{";"} in sequences of
instructions (enclosed in a @code{@{...@}} or @code{begin...end} block).

@var{method} should be the method name that was passed to
`smie-rules-function'.
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Here is an example of an indentation function:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
A few things to note:

@itemize
@item
The first case indicates the basic indentation increment to use.  If
@code{sample-indent-basic} is @code{nil}, then SMIE uses the global setting
@code{smie-indent-basic}.  The major mode could have set
@code{smie-indent-basic} buffer-locally instead, but that is discouraged.

@item
The rule for the token @code{","} make SMIE try to be more clever when the
comma separator is placed at the beginning of lines.  It tries to outdent
the separator so as to align the code after the comma; for example:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
The rule for indentation after @code{":="} exists because otherwise SMIE
would treat @code{":="} as an infix operator and would align the right
argument with the left one.

@item
The rule for indentation before @code{"begin"} is an example of the use of
virtual indentation: This rule is used only when @code{"begin"} is hanging,
which can happen only when @code{"begin"} is not at the beginning of a
line.  So this is not used when indenting @code{"begin"} itself but only
when indenting something relative to this @code{"begin"}.  Concretely, this
rule changes the indentation from:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
to
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"} as a
single unit, so as to align a sequence of tests rather than indent each test
further to the right.  This function does this only in the case where the
@code{"if"} is not placed on a separate line, hence the
@code{smie-rule-bolp} test.

If we know that the @code{"else"} is always aligned with its @code{"if"} and
is always at the beginning of a line, we can use a more efficient rule:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

The advantage of this formulation is that it reuses the indentation of the
previous @code{"else"}, rather than going all the way back to the first
@code{"if"} of the sequence.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this on a
per-mode basis (using the option @code{smie-config}), or a per-file basis
(using the function @code{smie-config-local} in a file-local variable
specification).

@defopt smie-config
This option lets you customize indentation on a per-mode basis.  It is an
alist with elements of the form @code{(@var{mode} . @var{rules})}.  For the
precise form of rules, see the variable's documentation; but you may find it
easier to use the command @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
This command tries to work out appropriate settings to produce your
preferred style of indentation.  Simply call the command while visiting a
file that is indented with your style.
@end deffn

@deffn Command smie-config-save
Call this command after using @code{smie-config-guess}, to save your
settings for future sessions.
@end deffn

@deffn Command smie-config-show-indent &optional move
This command displays the rules that are used to indent the current line.
@end deffn

@deffn Command smie-config-set-indent
This command adds a local rule to adjust the indentation of the current
line.
@end deffn

@defun smie-config-local rules
This function adds @var{rules} as indentation rules for the current buffer.
These add to any mode-specific rules defined by the @code{smie-config}
option.  To specify custom indentation rules for a specific file, add an
entry to the file's local variables of the form: @code{eval:
(smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

@dfn{Desktop Save Mode} is a feature to save the state of Emacs from one
session to another.  The user-level commands for using Desktop Save Mode are
described in the GNU Emacs Manual (@pxref{Saving Emacs Sessions,,, emacs,
the GNU Emacs Manual}).  Modes whose buffers visit a file, don't have to do
anything to use this feature.

For buffers not visiting a file to have their state saved, the major mode
must bind the buffer local variable @code{desktop-save-buffer} to a
non-@code{nil} value.

@defvar desktop-save-buffer
If this buffer-local variable is non-@code{nil}, the buffer will have its
state saved in the desktop file at desktop save.  If the value is a
function, it is called at desktop save with argument @var{desktop-dirname},
and its value is saved in the desktop file along with the state of the
buffer for which it was called.  When file names are returned as part of the
auxiliary information, they should be formatted using the call

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

For buffers not visiting a file to be restored, the major mode must define a
function to do the job, and that function must be listed in the alist
@code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Alist with elements

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

The function @var{restore-buffer-function} will be called with argument list

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

and it should return the restored buffer.  Here @var{desktop-buffer-misc} is
the value returned by the function optionally bound to
@code{desktop-save-buffer}.
@end defvar
