# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-26 13:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: numbers.texi.orig:6 numbers.texi.orig:7
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:8
#, no-wrap
msgid "integers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:9
#, no-wrap
msgid "numbers"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:20
msgid ""
"GNU Emacs supports two numeric data types: @dfn{integers} and "
"@dfn{floating-point numbers}.  Integers are whole numbers such as @minus{}3, "
"0, 7, 13, and 511.  Floating-point numbers are numbers with fractional "
"parts, such as @minus{}4.5, 0.0, and 2.71828.  They can also be expressed in "
"exponential notation: @samp{1.5e2} is the same as @samp{150.0}; here, "
"@samp{e2} stands for ten to the second power, and that is multiplied by "
"1.5.  Integer computations are exact, though they may overflow.  "
"Floating-point computations often involve rounding errors, as the numbers "
"have a fixed amount of precision."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:34 numbers.texi.orig:35
#, no-wrap
msgid "Integer Basics"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Representation and range of integers."
msgstr ""

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:196
#, no-wrap
msgid "Float Basics"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Representation and range of floating point."
msgstr ""

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:291
#, no-wrap
msgid "Predicates on Numbers"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Testing for numbers."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:335 numbers.texi.orig:336
#, no-wrap
msgid "Comparison of Numbers"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Equality and inequality predicates."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:452 numbers.texi.orig:453
#, no-wrap
msgid "Numeric Conversions"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Converting float to integer and vice versa."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:547 numbers.texi.orig:548
#, no-wrap
msgid "Arithmetic Operations"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "How to add, subtract, multiply and divide."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:768 numbers.texi.orig:769
#, no-wrap
msgid "Rounding Operations"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Explicitly rounding floating-point numbers."
msgstr ""

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:800
#, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Logical and, or, not, shifting."
msgstr ""

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:1100
#, no-wrap
msgid "Math Functions"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Trig, exponential and logarithmic functions."
msgstr ""

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:1204 numbers.texi.orig:1205
#, no-wrap
msgid "Random Numbers"
msgstr ""

#. type: menuentry
#: numbers.texi.orig:32
msgid "Obtaining random integers, predictable or not."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:39
msgid ""
"The range of values for an integer depends on the machine.  The minimum "
"range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:41 numbers.texi.orig:178
msgid "@minus{}2**29"
msgstr ""

#. type: tex
#: numbers.texi.orig:44 numbers.texi.orig:181
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:46
msgid "to"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:48
msgid "2**29 @minus{} 1),"
msgstr ""

#. type: tex
#: numbers.texi.orig:51
#, no-wrap
msgid "@math{2^{29}-1}),\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:54
msgid ""
"but many machines provide a wider range.  Many examples in this chapter "
"assume the minimum integer width of 30 bits."
msgstr ""

#. type: cindex
#: numbers.texi.orig:54
#, no-wrap
msgid "overflow"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:59
msgid ""
"The Lisp reader reads an integer as a sequence of digits with optional "
"initial sign and optional final period.  An integer that is out of the Emacs "
"range is treated as a floating-point number."
msgstr ""

#. type: example
#: numbers.texi.orig:69
#, no-wrap
msgid ""
" 1               ; @r{The integer 1.}\n"
" 1.              ; @r{The integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
"-1               ; @r{The integer @minus{}1.}\n"
" 9000000000000000000\n"
"                 ; @r{The floating-point number 9e18.}\n"
" 0               ; @r{The integer 0.}\n"
"-0               ; @r{The integer 0.}\n"
msgstr ""

#. type: cindex
#: numbers.texi.orig:71
#, no-wrap
msgid "integers in specific radix"
msgstr ""

#. type: cindex
#: numbers.texi.orig:72
#, no-wrap
msgid "radix for reading an integer"
msgstr ""

#. type: cindex
#: numbers.texi.orig:73
#, no-wrap
msgid "base for reading an integer"
msgstr ""

#. type: cindex
#: numbers.texi.orig:74
#, no-wrap
msgid "hex numbers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:75
#, no-wrap
msgid "octal numbers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:76
#, no-wrap
msgid "reading numbers in hex, octal, and binary"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:85
msgid ""
"The syntax for integers in bases other than 10 uses @samp{#} followed by a "
"letter that specifies the radix: @samp{b} for binary, @samp{o} for octal, "
"@samp{x} for hex, or @samp{@var{radix}r} to specify radix @var{radix}.  Case "
"is not significant for the letter that specifies the radix.  Thus, "
"@samp{#b@var{integer}} reads @var{integer} in binary, and "
"@samp{#@var{radix}r@var{integer}} reads @var{integer} in radix @var{radix}.  "
"Allowed values of @var{radix} run from 2 to 36.  For example:"
msgstr ""

#. type: example
#: numbers.texi.orig:91
#, no-wrap
msgid ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:96
msgid ""
"To understand how various functions work on integers, especially the bitwise "
"operators (@pxref{Bitwise Operations}), it is often helpful to view the "
"numbers in their binary form."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:98
msgid "In 30-bit binary, the decimal integer 5 looks like this:"
msgstr ""

#. type: example
#: numbers.texi.orig:101
#, no-wrap
msgid "0000...000101 (30 bits total)\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:107
msgid ""
"(The @samp{...} stands for enough bits to fill out a 30-bit word; in this "
"case, @samp{...} stands for twenty 0 bits.  Later examples also use the "
"@samp{...} notation to make binary integers easier to read.)"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:109
msgid "The integer @minus{}1 looks like this:"
msgstr ""

#. type: example
#: numbers.texi.orig:112
#, no-wrap
msgid "1111...111111 (30 bits total)\n"
msgstr ""

#. type: cindex
#: numbers.texi.orig:115
#, no-wrap
msgid "two's complement"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:118
msgid ""
"@minus{}1 is represented as 30 ones.  (This is called @dfn{two's complement} "
"notation.)"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:122
msgid ""
"Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.  In "
"binary, the decimal integer 4 is 100.  Consequently, @minus{}5 looks like "
"this:"
msgstr ""

#. type: example
#: numbers.texi.orig:125
#, no-wrap
msgid "1111...111011 (30 bits total)\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:129
msgid ""
"In this implementation, the largest 30-bit binary integer is 536,870,911 in "
"decimal.  In binary, it looks like this:"
msgstr ""

#. type: example
#: numbers.texi.orig:132
#, no-wrap
msgid "0111...111111 (30 bits total)\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:137
msgid ""
"Since the arithmetic functions do not check whether integers go outside "
"their range, when you add 1 to 536,870,911, the value is the negative "
"integer @minus{}536,870,912:"
msgstr ""

#. type: example
#: numbers.texi.orig:142
#, no-wrap
msgid ""
"(+ 1 536870911)\n"
"     @result{} -536870912\n"
"     @result{} 1000...000000 (30 bits total)\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:149
msgid ""
"Many of the functions described in this chapter accept markers for arguments "
"in place of numbers.  (@xref{Markers}.)  Since the actual arguments to such "
"functions may be either numbers or markers, we often give these arguments "
"the name @var{number-or-marker}.  When the argument value is a marker, its "
"position value is used and its buffer is ignored."
msgstr ""

#. type: cindex
#: numbers.texi.orig:150
#, no-wrap
msgid "largest Lisp integer"
msgstr ""

#. type: cindex
#: numbers.texi.orig:151
#, no-wrap
msgid "maximum Lisp integer"
msgstr ""

#. type: defvar
#: numbers.texi.orig:152
#, no-wrap
msgid "most-positive-fixnum"
msgstr ""

#. type: defvar
#: numbers.texi.orig:155
msgid ""
"The value of this variable is the largest integer that Emacs Lisp can "
"handle.  Typical values are"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:157
msgid "2**29 @minus{} 1"
msgstr ""

#. type: tex
#: numbers.texi.orig:160
#, no-wrap
msgid "@math{2^{29}-1}\n"
msgstr ""

#. type: defvar
#: numbers.texi.orig:162 numbers.texi.orig:183
msgid "on 32-bit and"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:164
msgid "2**61 @minus{} 1"
msgstr ""

#. type: tex
#: numbers.texi.orig:167
#, no-wrap
msgid "@math{2^{61}-1}\n"
msgstr ""

#. type: defvar
#: numbers.texi.orig:169 numbers.texi.orig:190
msgid "on 64-bit platforms."
msgstr ""

#. type: cindex
#: numbers.texi.orig:171
#, no-wrap
msgid "smallest Lisp integer"
msgstr ""

#. type: cindex
#: numbers.texi.orig:172
#, no-wrap
msgid "minimum Lisp integer"
msgstr ""

#. type: defvar
#: numbers.texi.orig:173
#, no-wrap
msgid "most-negative-fixnum"
msgstr ""

#. type: defvar
#: numbers.texi.orig:176
msgid ""
"The value of this variable is the smallest integer that Emacs Lisp can "
"handle.  It is negative.  Typical values are"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:185
msgid "@minus{}2**61"
msgstr ""

#. type: tex
#: numbers.texi.orig:188
#, no-wrap
msgid "@math{-2^{61}}\n"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:195
msgid ""
"In Emacs Lisp, text characters are represented by integers.  Any integer "
"between zero and the value of @code{(max-char)}, inclusive, is considered to "
"be valid as a character.  @xref{Character Codes}."
msgstr ""

#. type: section
#: numbers.texi.orig:197
#, no-wrap
msgid "Floating-Point Basics"
msgstr ""

#. type: cindex
#: numbers.texi.orig:199
#, no-wrap
msgid "@acronym{IEEE} floating point"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:205
msgid ""
"Floating-point numbers are useful for representing numbers that are not "
"integral.  The range of floating-point numbers is the same as the range of "
"the C data type @code{double} on the machine you are using.  On all "
"computers currently supported by Emacs, this is double-precision "
"@acronym{IEEE} floating point."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:214
msgid ""
"The read syntax for floating-point numbers requires either a decimal point, "
"an exponent, or both.  Optional signs (@samp{+} or @samp{-})  precede the "
"number and its exponent.  For example, @samp{1500.0}, @samp{+15e2}, "
"@samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are five ways of "
"writing a floating-point number whose value is 1500.  They are all "
"equivalent.  Like Common Lisp, Emacs Lisp requires at least one digit after "
"any decimal point in a floating-point number; @samp{1500.} is an integer, "
"not a floating-point number."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:220
msgid ""
"Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero with "
"respect to @code{equal} and @code{=}.  This follows the @acronym{IEEE} "
"floating-point standard, which says @code{-0.0} and @code{0.0} are "
"numerically equal even though other operations can distinguish them."
msgstr ""

#. type: cindex
#: numbers.texi.orig:221
#, no-wrap
msgid "positive infinity"
msgstr ""

#. type: cindex
#: numbers.texi.orig:222
#, no-wrap
msgid "negative infinity"
msgstr ""

#. type: item
#: numbers.texi.orig:223 numbers.texi.orig:236
#, no-wrap
msgid "infinity"
msgstr ""

#. type: cindex
#: numbers.texi.orig:224
#, no-wrap
msgid "NaN"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:232
msgid ""
"The @acronym{IEEE} floating-point standard supports positive infinity and "
"negative infinity as floating-point values.  It also provides for a class of "
"values called NaN or ``not-a-number''; numerical functions return such "
"values in cases where there is no correct answer.  For example, @code{(/ 0.0 "
"0.0)} returns a NaN@.  Although NaN values carry a sign, for practical "
"purposes there is no other significant difference between different NaN "
"values in Emacs Lisp."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:234
msgid "Here are read syntaxes for these special floating-point values:"
msgstr ""

#. type: table
#: numbers.texi.orig:238
msgid "@samp{1.0e+INF} and @samp{-1.0e+INF}"
msgstr ""

#. type: item
#: numbers.texi.orig:238
#, no-wrap
msgid "not-a-number"
msgstr ""

#. type: table
#: numbers.texi.orig:240
msgid "@samp{0.0e+NaN} and @samp{-0.0e+NaN}"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:244
msgid "The following functions are specialized for handling floating-point numbers:"
msgstr ""

#. type: defun
#: numbers.texi.orig:245
#, no-wrap
msgid "isnan x"
msgstr ""

#. type: defun
#: numbers.texi.orig:248
msgid ""
"This predicate returns @code{t} if its floating-point argument is a NaN, "
"@code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:250
#, no-wrap
msgid "frexp x"
msgstr ""

#. type: defun
#: numbers.texi.orig:254
msgid ""
"This function returns a cons cell @code{(@var{s} . @var{e})}, where @var{s} "
"and @var{e} are respectively the significand and exponent of the "
"floating-point number @var{x}."
msgstr ""

#. type: defun
#: numbers.texi.orig:257
msgid ""
"If @var{x} is finite, then @var{s} is a floating-point number between 0.5 "
"(inclusive) and 1.0 (exclusive), @var{e} is an integer, and"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:259
msgid "@var{x} = @var{s} * 2**@var{e}."
msgstr ""

#. type: tex
#: numbers.texi.orig:262
#, no-wrap
msgid "@math{x = s 2^e}.\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:266
msgid ""
"If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.  If "
"@var{x} is a NaN, then @var{s} is also a NaN.  If @var{x} is zero, then "
"@var{e} is 0."
msgstr ""

#. type: defun
#: numbers.texi.orig:268
#, no-wrap
msgid "ldexp sig &optional exp"
msgstr ""

#. type: defun
#: numbers.texi.orig:271
msgid ""
"This function returns a floating-point number corresponding to the "
"significand @var{sig} and exponent @var{exp}."
msgstr ""

#. type: defun
#: numbers.texi.orig:273
#, no-wrap
msgid "copysign x1 x2"
msgstr ""

#. type: defun
#: numbers.texi.orig:276
msgid ""
"This function copies the sign of @var{x2} to the value of @var{x1}, and "
"returns the result.  @var{x1} and @var{x2} must be floating point."
msgstr ""

#. type: defun
#: numbers.texi.orig:278
#, no-wrap
msgid "logb x"
msgstr ""

#. type: defun
#: numbers.texi.orig:282
msgid ""
"This function returns the binary exponent of @var{x}.  More precisely, the "
"value is the logarithm base 2 of @math{|x|}, rounded down to an integer."
msgstr ""

#. type: example
#: numbers.texi.orig:288
#, no-wrap
msgid ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
msgstr ""

#. type: section
#: numbers.texi.orig:292
#, no-wrap
msgid "Type Predicates for Numbers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:293
#, no-wrap
msgid "predicates for numbers"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:301
msgid ""
"The functions in this section test for numbers, or for a specific type of "
"number.  The functions @code{integerp} and @code{floatp} can take any type "
"of Lisp object as argument (they would not be of much use otherwise), but "
"the @code{zerop} predicate requires a number as its argument.  See also "
"@code{integer-or-marker-p} and @code{number-or-marker-p}, in @ref{Predicates "
"on Markers}."
msgstr ""

#. type: defun
#: numbers.texi.orig:302
#, no-wrap
msgid "floatp object"
msgstr ""

#. type: defun
#: numbers.texi.orig:305
msgid ""
"This predicate tests whether its argument is floating point and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:307
#, no-wrap
msgid "integerp object"
msgstr ""

#. type: defun
#: numbers.texi.orig:310
msgid ""
"This predicate tests whether its argument is an integer, and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:312
#, no-wrap
msgid "numberp object"
msgstr ""

#. type: defun
#: numbers.texi.orig:315
msgid ""
"This predicate tests whether its argument is a number (either integer or "
"floating point), and returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:317
#, no-wrap
msgid "natnump object"
msgstr ""

#. type: cindex
#: numbers.texi.orig:318
#, no-wrap
msgid "natural numbers"
msgstr ""

#. type: defun
#: numbers.texi.orig:323
msgid ""
"This predicate (whose name comes from the phrase ``natural number'')  tests "
"to see whether its argument is a nonnegative integer, and returns @code{t} "
"if so, @code{nil} otherwise.  0 is considered non-negative."
msgstr ""

#. type: findex
#: numbers.texi.orig:324
#, no-wrap
msgid "wholenump"
msgstr ""

#. type: defun
#: numbers.texi.orig:326
msgid "@code{wholenump} is a synonym for @code{natnump}."
msgstr ""

#. type: defun
#: numbers.texi.orig:328
#, no-wrap
msgid "zerop number"
msgstr ""

#. type: defun
#: numbers.texi.orig:331
msgid ""
"This predicate tests whether its argument is zero, and returns @code{t} if "
"so, @code{nil} otherwise.  The argument must be a number."
msgstr ""

#. type: defun
#: numbers.texi.orig:333
msgid "@code{(zerop x)} is equivalent to @code{(= x 0)}."
msgstr ""

#. type: cindex
#: numbers.texi.orig:337
#, no-wrap
msgid "number comparison"
msgstr ""

#. type: cindex
#: numbers.texi.orig:338
#, no-wrap
msgid "comparing numbers"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:346
msgid ""
"To test numbers for numerical equality, you should normally use @code{=}, "
"not @code{eq}.  There can be many distinct floating-point objects with the "
"same numeric value.  If you use @code{eq} to compare them, then you test "
"whether two values are the same @emph{object}.  By contrast, @code{=} "
"compares only the numeric values of the objects."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:355
msgid ""
"In Emacs Lisp, each integer is a unique Lisp object.  Therefore, @code{eq} "
"is equivalent to @code{=} where integers are concerned.  It is sometimes "
"convenient to use @code{eq} for comparing an unknown value with an integer, "
"because @code{eq} does not report an error if the unknown value is not a "
"number---it accepts arguments of any type.  By contrast, @code{=} signals an "
"error if the arguments are not numbers or markers.  However, it is better "
"programming practice to use @code{=} if you can, even for comparing "
"integers."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:361
msgid ""
"Sometimes it is useful to compare numbers with @code{equal}, which treats "
"two numbers as equal if they have the same data type (both integers, or both "
"floating point) and the same value.  By contrast, @code{=} can treat an "
"integer and a floating-point number as equal.  @xref{Equality Predicates}."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:366
msgid ""
"There is another wrinkle: because floating-point arithmetic is not exact, it "
"is often a bad idea to check for equality of floating-point values.  Usually "
"it is better to test for approximate equality.  Here's a function to do "
"this:"
msgstr ""

#. type: example
#: numbers.texi.orig:374
#, no-wrap
msgid ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"
msgstr ""

#. type: cindex
#: numbers.texi.orig:376
#, no-wrap
msgid "CL note---integers vrs @code{eq}"
msgstr ""

#. type: quotation
#: numbers.texi.orig:383
msgid ""
"@b{Common Lisp note:} Comparing numbers in Common Lisp always requires "
"@code{=} because Common Lisp implements multi-word integers, and two "
"distinct integer objects can have the same numeric value.  Emacs Lisp can "
"have just one integer object for any given value because it has a limited "
"range of integers."
msgstr ""

#. type: defun
#: numbers.texi.orig:385
#, no-wrap
msgid "= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:388
msgid ""
"This function tests whether all its arguments are numerically equal, and "
"returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:390
#, no-wrap
msgid "eql value1 value2"
msgstr ""

#. type: defun
#: numbers.texi.orig:395
msgid ""
"This function acts like @code{eq} except when both arguments are numbers.  "
"It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} "
"returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both "
"return @code{t}."
msgstr ""

#. type: defun
#: numbers.texi.orig:397
#, no-wrap
msgid "/= number-or-marker1 number-or-marker2"
msgstr ""

#. type: defun
#: numbers.texi.orig:400
msgid ""
"This function tests whether its arguments are numerically equal, and returns "
"@code{t} if they are not, and @code{nil} if they are."
msgstr ""

#. type: defun
#: numbers.texi.orig:402
#, no-wrap
msgid "<  number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:405
msgid ""
"This function tests whether each argument is strictly less than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:407
#, no-wrap
msgid "<= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:410
msgid ""
"This function tests whether each argument is less than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:412
#, no-wrap
msgid "> number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:415
msgid ""
"This function tests whether each argument is strictly greater than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:417
#, no-wrap
msgid ">= number-or-marker &rest number-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:420
msgid ""
"This function tests whether each argument is greater than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: numbers.texi.orig:422
#, no-wrap
msgid "max number-or-marker &rest numbers-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:426
msgid ""
"This function returns the largest of its arguments.  If any of the arguments "
"is floating point, the value is returned as floating point, even if it was "
"given as an integer."
msgstr ""

#. type: example
#: numbers.texi.orig:434
#, no-wrap
msgid ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3.0\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:437
#, no-wrap
msgid "min number-or-marker &rest numbers-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:441
msgid ""
"This function returns the smallest of its arguments.  If any of the "
"arguments is floating point, the value is returned as floating point, even "
"if it was given as an integer."
msgstr ""

#. type: example
#: numbers.texi.orig:445
#, no-wrap
msgid ""
"(min -4 1)\n"
"     @result{} -4\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:448
#, no-wrap
msgid "abs number"
msgstr ""

#. type: defun
#: numbers.texi.orig:450
msgid "This function returns the absolute value of @var{number}."
msgstr ""

#. type: cindex
#: numbers.texi.orig:454
#, no-wrap
msgid "rounding in conversions"
msgstr ""

#. type: cindex
#: numbers.texi.orig:455
#, no-wrap
msgid "number conversions"
msgstr ""

#. type: cindex
#: numbers.texi.orig:456
#, no-wrap
msgid "converting numbers"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:459
msgid "To convert an integer to floating point, use the function @code{float}."
msgstr ""

#. type: defun
#: numbers.texi.orig:460
#, no-wrap
msgid "float number"
msgstr ""

#. type: defun
#: numbers.texi.orig:464
msgid ""
"This returns @var{number} converted to floating point.  If @var{number} is "
"already floating point, @code{float} returns it unchanged."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:476
msgid ""
"There are four functions to convert floating-point numbers to integers; they "
"differ in how they round.  All accept an argument @var{number} and an "
"optional argument @var{divisor}.  Both arguments may be integers or "
"floating-point numbers.  @var{divisor} may also be @code{nil}.  If "
"@var{divisor} is @code{nil} or omitted, these functions convert @var{number} "
"to an integer, or return it unchanged if it already is an integer.  If "
"@var{divisor} is non-@code{nil}, they divide @var{number} by @var{divisor} "
"and convert the result to an integer.  If @var{divisor} is zero (whether "
"integer or floating point), Emacs signals an @code{arith-error} error."
msgstr ""

#. type: defun
#: numbers.texi.orig:477
#, no-wrap
msgid "truncate number &optional divisor"
msgstr ""

#. type: defun
#: numbers.texi.orig:480
msgid "This returns @var{number}, converted to an integer by rounding towards zero."
msgstr ""

#. type: example
#: numbers.texi.orig:490
#, no-wrap
msgid ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:493
#, no-wrap
msgid "floor number &optional divisor"
msgstr ""

#. type: defun
#: numbers.texi.orig:496
msgid ""
"This returns @var{number}, converted to an integer by rounding downward "
"(towards negative infinity)."
msgstr ""

#. type: defun
#: numbers.texi.orig:499
msgid ""
"If @var{divisor} is specified, this uses the kind of division operation that "
"corresponds to @code{mod}, rounding downward."
msgstr ""

#. type: example
#: numbers.texi.orig:511
#, no-wrap
msgid ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:514
#, no-wrap
msgid "ceiling number &optional divisor"
msgstr ""

#. type: defun
#: numbers.texi.orig:517
msgid ""
"This returns @var{number}, converted to an integer by rounding upward "
"(towards positive infinity)."
msgstr ""

#. type: example
#: numbers.texi.orig:527
#, no-wrap
msgid ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:530
#, no-wrap
msgid "round number &optional divisor"
msgstr ""

#. type: defun
#: numbers.texi.orig:534
msgid ""
"This returns @var{number}, converted to an integer by rounding towards the "
"nearest integer.  Rounding a value equidistant between two integers returns "
"the even integer."
msgstr ""

#. type: example
#: numbers.texi.orig:544
#, no-wrap
msgid ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"
msgstr ""

#. type: cindex
#: numbers.texi.orig:549
#, no-wrap
msgid "arithmetic operations"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:557
msgid ""
"Emacs Lisp provides the traditional four arithmetic operations (addition, "
"subtraction, multiplication, and division), as well as remainder and modulus "
"functions, and functions to add or subtract 1.  Except for @code{%}, each of "
"these functions accepts both integer and floating-point arguments, and "
"returns a floating-point number if any argument is floating point."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:561
msgid ""
"Emacs Lisp arithmetic functions do not check for integer overflow.  Thus "
"@code{(1+ 536870911)} may evaluate to @minus{}536870912, depending on your "
"hardware."
msgstr ""

#. type: defun
#: numbers.texi.orig:562
#, no-wrap
msgid "1+ number-or-marker"
msgstr ""

#. type: defun
#: numbers.texi.orig:565
msgid "This function returns @var{number-or-marker} plus 1.  For example,"
msgstr ""

#. type: example
#: numbers.texi.orig:571
#, no-wrap
msgid ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:575
msgid ""
"This function is not analogous to the C operator @code{++}---it does not "
"increment a variable.  It just computes a sum.  Thus, if we continue,"
msgstr ""

#. type: example
#: numbers.texi.orig:579
#, no-wrap
msgid ""
"foo\n"
"     @result{} 4\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:583
msgid "If you want to increment the variable, you must use @code{setq}, like this:"
msgstr ""

#. type: example
#: numbers.texi.orig:587
#, no-wrap
msgid ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:590
#, no-wrap
msgid "1- number-or-marker"
msgstr ""

#. type: defun
#: numbers.texi.orig:592
msgid "This function returns @var{number-or-marker} minus 1."
msgstr ""

#. type: defun
#: numbers.texi.orig:594
#, no-wrap
msgid "+ &rest numbers-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:597
msgid ""
"This function adds its arguments together.  When given no arguments, "
"@code{+} returns 0."
msgstr ""

#. type: example
#: numbers.texi.orig:605
#, no-wrap
msgid ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:608
#, no-wrap
msgid "- &optional number-or-marker &rest more-numbers-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:614
msgid ""
"The @code{-} function serves two purposes: negation and subtraction.  When "
"@code{-} has a single argument, the value is the negative of the argument.  "
"When there are multiple arguments, @code{-} subtracts each of the "
"@var{more-numbers-or-markers} from @var{number-or-marker}, cumulatively.  If "
"there are no arguments, the result is 0."
msgstr ""

#. type: example
#: numbers.texi.orig:622
#, no-wrap
msgid ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:625
#, no-wrap
msgid "* &rest numbers-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:628
msgid ""
"This function multiplies its arguments together, and returns the product.  "
"When given no arguments, @code{*} returns 1."
msgstr ""

#. type: example
#: numbers.texi.orig:636
#, no-wrap
msgid ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:639
#, no-wrap
msgid "/ dividend divisor &rest divisors"
msgstr ""

#. type: defun
#: numbers.texi.orig:644
msgid ""
"This function divides @var{dividend} by @var{divisor} and returns the "
"quotient.  If there are additional arguments @var{divisors}, then it divides "
"@var{dividend} by each divisor in turn.  Each argument may be a number or a "
"marker."
msgstr ""

#. type: defun
#: numbers.texi.orig:647
msgid ""
"If all the arguments are integers, the result is an integer, obtained by "
"rounding the quotient towards zero after each division."
msgstr ""

#. type: group
#: numbers.texi.orig:652
#, no-wrap
msgid ""
"(/ 6 2)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: numbers.texi.orig:656
#, no-wrap
msgid ""
"(/ 5 2)\n"
"     @result{} 2\n"
msgstr ""

#. type: group
#: numbers.texi.orig:660
#, no-wrap
msgid ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: numbers.texi.orig:664
#, no-wrap
msgid ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: numbers.texi.orig:668
#, no-wrap
msgid ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"
msgstr ""

#. type: group
#: numbers.texi.orig:672
#, no-wrap
msgid ""
"(/ 25 3 2)\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: numbers.texi.orig:676
#, no-wrap
msgid ""
"(/ -17 6)\n"
"     @result{} -2\n"
msgstr ""

#. type: cindex
#: numbers.texi.orig:679
#, no-wrap
msgid "@code{arith-error} in division"
msgstr ""

#. type: defun
#: numbers.texi.orig:684
msgid ""
"If you divide an integer by the integer 0, Emacs signals an "
"@code{arith-error} error (@pxref{Errors}).  Floating-point division of a "
"nonzero number by zero yields either positive or negative infinity "
"(@pxref{Float Basics})."
msgstr ""

#. type: defun
#: numbers.texi.orig:686
#, no-wrap
msgid "% dividend divisor"
msgstr ""

#. type: cindex
#: numbers.texi.orig:687
#, no-wrap
msgid "remainder"
msgstr ""

#. type: defun
#: numbers.texi.orig:690
msgid ""
"This function returns the integer remainder after division of @var{dividend} "
"by @var{divisor}.  The arguments must be integers or markers."
msgstr ""

#. type: defun
#: numbers.texi.orig:692
msgid "For any two integers @var{dividend} and @var{divisor},"
msgstr ""

#. type: group
#: numbers.texi.orig:697
#, no-wrap
msgid ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:702
msgid "always equals @var{dividend} if @var{divisor} is nonzero."
msgstr ""

#. type: example
#: numbers.texi.orig:712
#, no-wrap
msgid ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:715
#, no-wrap
msgid "mod dividend divisor"
msgstr ""

#. type: cindex
#: numbers.texi.orig:716
#, no-wrap
msgid "modulus"
msgstr ""

#. type: defun
#: numbers.texi.orig:721
msgid ""
"This function returns the value of @var{dividend} modulo @var{divisor}; in "
"other words, the remainder after division of @var{dividend} by "
"@var{divisor}, but with the same sign as @var{divisor}.  The arguments must "
"be numbers or markers."
msgstr ""

#. type: defun
#: numbers.texi.orig:725
msgid ""
"Unlike @code{%}, @code{mod} permits floating-point arguments; it rounds the "
"quotient downward (towards minus infinity) to an integer, and uses that "
"quotient to compute the remainder."
msgstr ""

#. type: defun
#: numbers.texi.orig:728
msgid ""
"If @var{divisor} is zero, @code{mod} signals an @code{arith-error} error if "
"both arguments are integers, and returns a NaN otherwise."
msgstr ""

#. type: group
#: numbers.texi.orig:733
#, no-wrap
msgid ""
"(mod 9 4)\n"
"     @result{} 1\n"
msgstr ""

#. type: group
#: numbers.texi.orig:737
#, no-wrap
msgid ""
"(mod -9 4)\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: numbers.texi.orig:741
#, no-wrap
msgid ""
"(mod 9 -4)\n"
"     @result{} -3\n"
msgstr ""

#. type: group
#: numbers.texi.orig:745
#, no-wrap
msgid ""
"(mod -9 -4)\n"
"     @result{} -1\n"
msgstr ""

#. type: group
#: numbers.texi.orig:749
#, no-wrap
msgid ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:753
msgid "For any two numbers @var{dividend} and @var{divisor},"
msgstr ""

#. type: group
#: numbers.texi.orig:758
#, no-wrap
msgid ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:766
msgid ""
"always equals @var{dividend}, subject to rounding error if either argument "
"is floating point and to an @code{arith-error} if @var{dividend} is an "
"integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric "
"Conversions}."
msgstr ""

#. type: cindex
#: numbers.texi.orig:770
#, no-wrap
msgid "rounding without conversion"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:778
msgid ""
"The functions @code{ffloor}, @code{fceiling}, @code{fround}, and "
"@code{ftruncate} take a floating-point argument and return a floating-point "
"result whose value is a nearby integer.  @code{ffloor} returns the nearest "
"integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, "
"the nearest integer in the direction towards zero; @code{fround}, the "
"nearest integer."
msgstr ""

#. type: defun
#: numbers.texi.orig:779
#, no-wrap
msgid "ffloor float"
msgstr ""

#. type: defun
#: numbers.texi.orig:782
msgid ""
"This function rounds @var{float} to the next lower integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: numbers.texi.orig:784
#, no-wrap
msgid "fceiling float"
msgstr ""

#. type: defun
#: numbers.texi.orig:787
msgid ""
"This function rounds @var{float} to the next higher integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: numbers.texi.orig:789
#, no-wrap
msgid "ftruncate float"
msgstr ""

#. type: defun
#: numbers.texi.orig:792
msgid ""
"This function rounds @var{float} towards zero to an integral value, and "
"returns that value as a floating-point number."
msgstr ""

#. type: defun
#: numbers.texi.orig:794
#, no-wrap
msgid "fround float"
msgstr ""

#. type: defun
#: numbers.texi.orig:798
msgid ""
"This function rounds @var{float} to the nearest integral value, and returns "
"that value as a floating-point number.  Rounding a value equidistant between "
"two integers returns the even integer."
msgstr ""

#. type: section
#: numbers.texi.orig:801
#, no-wrap
msgid "Bitwise Operations on Integers"
msgstr ""

#. type: cindex
#: numbers.texi.orig:802
#, no-wrap
msgid "bitwise arithmetic"
msgstr ""

#. type: cindex
#: numbers.texi.orig:803
#, no-wrap
msgid "logical arithmetic"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:810
msgid ""
"In a computer, an integer is represented as a binary number, a sequence of "
"@dfn{bits} (digits which are either zero or one).  A bitwise operation acts "
"on the individual bits of such a sequence.  For example, @dfn{shifting} "
"moves the whole sequence left or right one or more places, reproducing the "
"same pattern ``moved over''."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:812
msgid "The bitwise operations in Emacs Lisp apply only to integers."
msgstr ""

#. type: defun
#: numbers.texi.orig:813
#, no-wrap
msgid "lsh integer1 count"
msgstr ""

#. type: cindex
#: numbers.texi.orig:814
#, no-wrap
msgid "logical shift"
msgstr ""

#. type: defun
#: numbers.texi.orig:821
msgid ""
"@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the "
"bits in @var{integer1} to the left @var{count} places, or to the right if "
"@var{count} is negative, bringing zeros into the vacated bits.  If "
"@var{count} is negative, @code{lsh} shifts zeros into the leftmost "
"(most-significant) bit, producing a positive result even if @var{integer1} "
"is negative.  Contrast this with @code{ash}, below."
msgstr ""

#. type: defun
#: numbers.texi.orig:825
msgid ""
"Here are two examples of @code{lsh}, shifting a pattern of bits one place to "
"the left.  We show only the low-order eight bits of the binary pattern; the "
"rest are all zero."
msgstr ""

#. type: group
#: numbers.texi.orig:832
#, no-wrap
msgid ""
"(lsh 5 1)\n"
"     @result{} 10\n"
";; @r{Decimal 5 becomes decimal 10.}\n"
"00000101 @result{} 00001010\n"
"\n"
msgstr ""

#. type: group
#: numbers.texi.orig:837
#, no-wrap
msgid ""
"(lsh 7 1)\n"
"     @result{} 14\n"
";; @r{Decimal 7 becomes decimal 14.}\n"
"00000111 @result{} 00001110\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:844
msgid ""
"As the examples illustrate, shifting the pattern of bits one place to the "
"left produces a number that is twice the value of the previous number."
msgstr ""

#. type: defun
#: numbers.texi.orig:847
msgid ""
"Shifting a pattern of bits two places to the left produces results like this "
"(with 8-bit binary numbers):"
msgstr ""

#. type: group
#: numbers.texi.orig:854
#, no-wrap
msgid ""
"(lsh 3 2)\n"
"     @result{} 12\n"
";; @r{Decimal 3 becomes decimal 12.}\n"
"00000011 @result{} 00001100\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:858
msgid "On the other hand, shifting one place to the right looks like this:"
msgstr ""

#. type: group
#: numbers.texi.orig:865
#, no-wrap
msgid ""
"(lsh 6 -1)\n"
"     @result{} 3\n"
";; @r{Decimal 6 becomes decimal 3.}\n"
"00000110 @result{} 00000011\n"
msgstr ""

#. type: group
#: numbers.texi.orig:872
#, no-wrap
msgid ""
"(lsh 5 -1)\n"
"     @result{} 2\n"
";; @r{Decimal 5 becomes decimal 2.}\n"
"00000101 @result{} 00000010\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:878
msgid ""
"As the example illustrates, shifting one place to the right divides the "
"value of a positive integer by two, rounding downward."
msgstr ""

#. type: defun
#: numbers.texi.orig:883
msgid ""
"The function @code{lsh}, like all Emacs Lisp arithmetic functions, does not "
"check for overflow, so shifting left can discard significant bits and change "
"the sign of the number.  For example, left shifting 536,870,911 produces "
"@minus{}2 in the 30-bit implementation:"
msgstr ""

#. type: example
#: numbers.texi.orig:887
#, no-wrap
msgid ""
"(lsh 536870911 1)          ; @r{left shift}\n"
"     @result{} -2\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:890
msgid "In binary, the argument looks like this:"
msgstr ""

#. type: group
#: numbers.texi.orig:895
#, no-wrap
msgid ""
";; @r{Decimal 536,870,911}\n"
"0111...111111 (30 bits total)\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:900
msgid "which becomes the following when left shifted:"
msgstr ""

#. type: group
#: numbers.texi.orig:905
#, no-wrap
msgid ""
";; @r{Decimal @minus{}2}\n"
"1111...111110 (30 bits total)\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:909
#, no-wrap
msgid "ash integer1 count"
msgstr ""

#. type: cindex
#: numbers.texi.orig:910
#, no-wrap
msgid "arithmetic shift"
msgstr ""

#. type: defun
#: numbers.texi.orig:914
msgid ""
"@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the "
"left @var{count} places, or to the right if @var{count} is negative."
msgstr ""

#. type: defun
#: numbers.texi.orig:919
msgid ""
"@code{ash} gives the same results as @code{lsh} except when @var{integer1} "
"and @var{count} are both negative.  In that case, @code{ash} puts ones in "
"the empty bit positions on the left, while @code{lsh} puts zeros in those "
"bit positions."
msgstr ""

#. type: defun
#: numbers.texi.orig:922
msgid ""
"Thus, with @code{ash}, shifting the pattern of bits one place to the right "
"looks like this:"
msgstr ""

#. type: group
#: numbers.texi.orig:930
#, no-wrap
msgid ""
"(ash -6 -1) @result{} -3\n"
";; @r{Decimal @minus{}6 becomes decimal @minus{}3.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"1111...111101 (30 bits total)\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:935
msgid ""
"In contrast, shifting the pattern of bits one place to the right with "
"@code{lsh} looks like this:"
msgstr ""

#. type: group
#: numbers.texi.orig:943
#, no-wrap
msgid ""
"(lsh -6 -1) @result{} 536870909\n"
";; @r{Decimal @minus{}6 becomes decimal 536,870,909.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"0111...111101 (30 bits total)\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:947
msgid "Here are other examples:"
msgstr ""

#. type: group
#: numbers.texi.orig:953
#, no-wrap
msgid ""
"                   ;  @r{       30-bit binary values}\n"
"\n"
msgstr ""

#. type: group
#: numbers.texi.orig:956
#, no-wrap
msgid ""
"(lsh 5 2)          ;   5  =  @r{0000...000101}\n"
"     @result{} 20         ;      =  @r{0000...010100}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:964
#, no-wrap
msgid ""
"(ash 5 2)\n"
"     @result{} 20\n"
"(lsh -5 2)         ;  -5  =  @r{1111...111011}\n"
"     @result{} -20        ;      =  @r{1111...101100}\n"
"(ash -5 2)\n"
"     @result{} -20\n"
msgstr ""

#. type: group
#: numbers.texi.orig:968
#, no-wrap
msgid ""
"(lsh 5 -2)         ;   5  =  @r{0000...000101}\n"
"     @result{} 1          ;      =  @r{0000...000001}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:972
#, no-wrap
msgid ""
"(ash 5 -2)\n"
"     @result{} 1\n"
msgstr ""

#. type: group
#: numbers.texi.orig:977
#, no-wrap
msgid ""
"(lsh -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} 268435454\n"
"                   ;      =  @r{0011...111110}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:981
#, no-wrap
msgid ""
"(ash -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} -2         ;      =  @r{1111...111110}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:985
#, no-wrap
msgid "logand &rest ints-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:990
msgid ""
"This function returns the ``logical and'' of the arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in all "
"the arguments.  (``Set'' means that the value of the bit is 1 rather than "
"0.)"
msgstr ""

#. type: defun
#: numbers.texi.orig:997
msgid ""
"For example, using 4-bit binary numbers, the ``logical and'' of 13 and 12 is "
"12: 1101 combined with 1100 produces 1100.  In both the binary numbers, the "
"leftmost two bits are set (i.e., they are 1's), so the leftmost two bits of "
"the returned value are set.  However, for the rightmost two bits, each is "
"zero in at least one of the arguments, so the rightmost two bits of the "
"returned value are 0's."
msgstr ""

#. type: defun
#: numbers.texi.orig:1000
msgid "Therefore,"
msgstr ""

#. type: group
#: numbers.texi.orig:1005
#, no-wrap
msgid ""
"(logand 13 12)\n"
"     @result{} 12\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1012
msgid ""
"If @code{logand} is not passed any argument, it returns a value of "
"@minus{}1.  This number is an identity element for @code{logand} because its "
"binary representation consists entirely of ones.  If @code{logand} is passed "
"just one argument, it returns that argument."
msgstr ""

#. type: group
#: numbers.texi.orig:1016 numbers.texi.orig:1046 numbers.texi.orig:1071
#, no-wrap
msgid ""
"                   ; @r{       30-bit binary values}\n"
"\n"
msgstr ""

#. type: group
#: numbers.texi.orig:1020
#, no-wrap
msgid ""
"(logand 14 13)     ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"     @result{} 12         ; 12  =  @r{0000...001100}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:1027
#, no-wrap
msgid ""
"(logand 14 13 4)   ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"                   ;  4  =  @r{0000...000100}\n"
"     @result{} 4          ;  4  =  @r{0000...000100}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:1032
#, no-wrap
msgid ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{1111...111111}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1036
#, no-wrap
msgid "logior &rest ints-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:1042
msgid ""
"This function returns the ``inclusive or'' of its arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in at "
"least one of the arguments.  If there are no arguments, the result is zero, "
"which is an identity element for this operation.  If @code{logior} is passed "
"just one argument, it returns that argument."
msgstr ""

#. type: group
#: numbers.texi.orig:1050
#, no-wrap
msgid ""
"(logior 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 13         ; 13  =  @r{0000...001101}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:1057
#, no-wrap
msgid ""
"(logior 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 15         ; 15  =  @r{0000...001111}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1061
#, no-wrap
msgid "logxor &rest ints-or-markers"
msgstr ""

#. type: defun
#: numbers.texi.orig:1067
msgid ""
"This function returns the ``exclusive or'' of its arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in an odd "
"number of the arguments.  If there are no arguments, the result is 0, which "
"is an identity element for this operation.  If @code{logxor} is passed just "
"one argument, it returns that argument."
msgstr ""

#. type: group
#: numbers.texi.orig:1075
#, no-wrap
msgid ""
"(logxor 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 9          ;  9  =  @r{0000...001001}\n"
msgstr ""

#. type: group
#: numbers.texi.orig:1082
#, no-wrap
msgid ""
"(logxor 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 14         ; 14  =  @r{0000...001110}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1086
#, no-wrap
msgid "lognot integer"
msgstr ""

#. type: defun
#: numbers.texi.orig:1090
msgid ""
"This function returns the logical complement of its argument: the @var{n}th "
"bit is one in the result if, and only if, the @var{n}th bit is zero in "
"@var{integer}, and vice-versa."
msgstr ""

#. type: example
#: numbers.texi.orig:1097
#, no-wrap
msgid ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{0000...000101} (30 bits total)\n"
";; @r{becomes}\n"
";; -6  =  @r{1111...111010} (30 bits total)\n"
msgstr ""

#. type: section
#: numbers.texi.orig:1101
#, no-wrap
msgid "Standard Mathematical Functions"
msgstr ""

#. type: cindex
#: numbers.texi.orig:1102
#, no-wrap
msgid "transcendental functions"
msgstr ""

#. type: cindex
#: numbers.texi.orig:1103
#, no-wrap
msgid "mathematical functions"
msgstr ""

#. type: cindex
#: numbers.texi.orig:1104
#, no-wrap
msgid "floating-point functions"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:1108
msgid ""
"These mathematical functions allow integers as well as floating-point "
"numbers as arguments."
msgstr ""

#. type: defun
#: numbers.texi.orig:1109
#, no-wrap
msgid "sin arg"
msgstr ""

#. type: defunx
#: numbers.texi.orig:1110
#, no-wrap
msgid "cos arg"
msgstr ""

#. type: defunx
#: numbers.texi.orig:1111
#, no-wrap
msgid "tan arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1114
msgid ""
"These are the basic trigonometric functions, with argument @var{arg} "
"measured in radians."
msgstr ""

#. type: defun
#: numbers.texi.orig:1116
#, no-wrap
msgid "asin arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1118
msgid "The value of @code{(asin @var{arg})} is a number between"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:1120 numbers.texi.orig:1151
msgid "@minus{}pi/2"
msgstr ""

#. type: tex
#: numbers.texi.orig:1123 numbers.texi.orig:1154
#, no-wrap
msgid "@math{-\\pi/2}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1125 numbers.texi.orig:1156
msgid "and"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:1127 numbers.texi.orig:1158
msgid "pi/2"
msgstr ""

#. type: tex
#: numbers.texi.orig:1130 numbers.texi.orig:1161
#, no-wrap
msgid "@math{\\pi/2}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1133
msgid ""
"(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range (outside "
"[@minus{}1, 1]), @code{asin} returns a NaN."
msgstr ""

#. type: defun
#: numbers.texi.orig:1135
#, no-wrap
msgid "acos arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1137
msgid "The value of @code{(acos @var{arg})} is a number between 0 and"
msgstr ""

#. type: ifnottex
#: numbers.texi.orig:1139
msgid "pi"
msgstr ""

#. type: tex
#: numbers.texi.orig:1142
#, no-wrap
msgid "@math{\\pi}\n"
msgstr ""

#. type: defun
#: numbers.texi.orig:1145
msgid ""
"(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range "
"(outside [@minus{}1, 1]), @code{acos} returns a NaN."
msgstr ""

#. type: defun
#: numbers.texi.orig:1147
#, no-wrap
msgid "atan y &optional x"
msgstr ""

#. type: defun
#: numbers.texi.orig:1149
msgid "The value of @code{(atan @var{y})} is a number between"
msgstr ""

#. type: defun
#: numbers.texi.orig:1166
msgid ""
"(exclusive) whose tangent is @var{y}.  If the optional second argument "
"@var{x} is given, the value of @code{(atan y x)} is the angle in radians "
"between the vector @code{[@var{x}, @var{y}]} and the @code{X} axis."
msgstr ""

#. type: defun
#: numbers.texi.orig:1168
#, no-wrap
msgid "exp arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1171
msgid ""
"This is the exponential function; it returns @math{e} to the power "
"@var{arg}."
msgstr ""

#. type: defun
#: numbers.texi.orig:1173
#, no-wrap
msgid "log arg &optional base"
msgstr ""

#. type: defun
#: numbers.texi.orig:1178
msgid ""
"This function returns the logarithm of @var{arg}, with base @var{base}.  If "
"you don't specify @var{base}, the natural base @math{e} is used.  If "
"@var{arg} or @var{base} is negative, @code{log} returns a NaN."
msgstr ""

#. type: defun
#: numbers.texi.orig:1180
#, no-wrap
msgid "expt x y"
msgstr ""

#. type: defun
#: numbers.texi.orig:1186
msgid ""
"This function returns @var{x} raised to power @var{y}.  If both arguments "
"are integers and @var{y} is positive, the result is an integer; in this "
"case, overflow causes truncation, so watch out.  If @var{x} is a finite "
"negative number and @var{y} is a finite non-integer, @code{expt} returns a "
"NaN."
msgstr ""

#. type: defun
#: numbers.texi.orig:1188
#, no-wrap
msgid "sqrt arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1191
msgid ""
"This returns the square root of @var{arg}.  If @var{arg} is finite and less "
"than zero, @code{sqrt} returns a NaN."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:1195
msgid "In addition, Emacs defines the following common mathematical constants:"
msgstr ""

#. type: defvar
#: numbers.texi.orig:1196
#, no-wrap
msgid "float-e"
msgstr ""

#. type: defvar
#: numbers.texi.orig:1198
msgid "The mathematical constant @math{e} (2.71828@dots{})."
msgstr ""

#. type: defvar
#: numbers.texi.orig:1200
#, no-wrap
msgid "float-pi"
msgstr ""

#. type: defvar
#: numbers.texi.orig:1202
msgid "The mathematical constant @math{pi} (3.14159@dots{})."
msgstr ""

#. type: cindex
#: numbers.texi.orig:1206
#, no-wrap
msgid "random numbers"
msgstr ""

#. type: Plain text
#: numbers.texi.orig:1214
msgid ""
"A deterministic computer program cannot generate true random numbers.  For "
"most purposes, @dfn{pseudo-random numbers} suffice.  A series of "
"pseudo-random numbers is generated in a deterministic fashion.  The numbers "
"are not truly random, but they have certain properties that mimic a random "
"series.  For example, all possible values occur equally often in a "
"pseudo-random series."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:1220
msgid ""
"Pseudo-random numbers are generated from a ``seed''.  Starting from any "
"given seed, the @code{random} function always generates the same sequence of "
"numbers.  By default, Emacs initializes the random seed at startup, in such "
"a way that the sequence of values of @code{random} (with overwhelming "
"likelihood) differs in each Emacs run."
msgstr ""

#. type: Plain text
#: numbers.texi.orig:1228
msgid ""
"Sometimes you want the random number sequence to be repeatable.  For "
"example, when debugging a program whose behavior depends on the random "
"number sequence, it is helpful to get the same behavior in each program "
"run.  To make the sequence repeat, execute @code{(random \"\")}.  This sets "
"the seed to a constant value for your particular Emacs executable (though it "
"may differ for other Emacs builds).  You can use other strings to choose "
"various seed values."
msgstr ""

#. type: defun
#: numbers.texi.orig:1229
#, no-wrap
msgid "random &optional limit"
msgstr ""

#. type: defun
#: numbers.texi.orig:1232
msgid ""
"This function returns a pseudo-random integer.  Repeated calls return a "
"series of pseudo-random integers."
msgstr ""

#. type: defun
#: numbers.texi.orig:1238
msgid ""
"If @var{limit} is a positive integer, the value is chosen to be nonnegative "
"and less than @var{limit}.  Otherwise, the value might be any integer "
"representable in Lisp, i.e., an integer between @code{most-negative-fixnum} "
"and @code{most-positive-fixnum} (@pxref{Integer Basics})."
msgstr ""

#. type: defun
#: numbers.texi.orig:1241
msgid ""
"If @var{limit} is @code{t}, it means to choose a new seed as if Emacs were "
"restarting."
msgstr ""

#. type: defun
#: numbers.texi.orig:1244
msgid ""
"If @var{limit} is a string, it means to choose a new seed based on the "
"string's contents."
msgstr ""
