# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-09 21:07+0900\n"
"PO-Revision-Date: 2016-06-12 16:06+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: numbers.texi.orig:6 numbers.texi.orig:7
#, no-wrap
msgid "Numbers"
msgstr "Numbers"

#. type: cindex
#: numbers.texi.orig:8
#, no-wrap
msgid "integers"
msgstr "integers"

#. type: cindex
#: numbers.texi.orig:9
#, no-wrap
msgid "numbers"
msgstr "numbers"

#. type: Plain text
#: numbers.texi.orig:20
msgid ""
"GNU Emacs supports two numeric data types: @dfn{integers} and "
"@dfn{floating-point numbers}.  Integers are whole numbers such as @minus{}3, "
"0, 7, 13, and 511.  Floating-point numbers are numbers with fractional "
"parts, such as @minus{}4.5, 0.0, and 2.71828.  They can also be expressed in "
"exponential notation: @samp{1.5e2} is the same as @samp{150.0}; here, "
"@samp{e2} stands for ten to the second power, and that is multiplied by "
"1.5.  Integer computations are exact, though they may overflow.  "
"Floating-point computations often involve rounding errors, as the numbers "
"have a fixed amount of precision."
msgstr "GNU Emacsは2つの数値データ型 --- @dfn{整数(integers)}と@dfn{浮動小数点数(floating-point numbers)}をサポートします。整数は@minus{}3、0、7、13、511などの整数です。浮動小数点数は@minus{}4.5、0.0、2.71828などの小数部をもちます・これらは指数記数法でも表現できます --- @samp{1.5e2}は@samp{150.0}と同じです。ここで@samp{e2}は10の2乗をあらわし、それに1.5を乗じるという意味です。整数計算は正確であり、オーバーフローするときもあります。浮動小数点数の計算においては、数値は固定された精度をもつため、、しばしば丸め誤差(rounding errors)を引き起こします。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:34 numbers.texi.orig:35
#, no-wrap
msgid "Integer Basics"
msgstr "Integer Basics"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Representation and range of integers."
msgstr "整数の表現と範囲。"

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:196
#, no-wrap
msgid "Float Basics"
msgstr "Float Basics"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Representation and range of floating point."
msgstr "浮動少数の表現と範囲。"

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:291
#, no-wrap
msgid "Predicates on Numbers"
msgstr "Predicates on Numbers"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Testing for numbers."
msgstr "数にたいするテスト。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:335 numbers.texi.orig:336
#, no-wrap
msgid "Comparison of Numbers"
msgstr "Comparison of Numbers"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Equality and inequality predicates."
msgstr "同一性と非同一性の述語。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:452 numbers.texi.orig:453
#, no-wrap
msgid "Numeric Conversions"
msgstr "Numeric Conversions"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Converting float to integer and vice versa."
msgstr "手動小数点数から整数、または疎の逆の変換。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:547 numbers.texi.orig:548
#, no-wrap
msgid "Arithmetic Operations"
msgstr "Arithmetic Operations"

#. type: menuentry
#: numbers.texi.orig:32
msgid "How to add, subtract, multiply and divide."
msgstr "加減乗除の方法。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:768 numbers.texi.orig:769
#, no-wrap
msgid "Rounding Operations"
msgstr "Rounding Operations"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Explicitly rounding floating-point numbers."
msgstr "浮動小数点数の明示的な丸め。"

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:800
#, no-wrap
msgid "Bitwise Operations"
msgstr "Bitwise Operations"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Logical and, or, not, shifting."
msgstr "論理的なadd、or、not、shift。"

#. type: node
#: numbers.texi.orig:32 numbers.texi.orig:1100
#, no-wrap
msgid "Math Functions"
msgstr "Math Functions"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Trig, exponential and logarithmic functions."
msgstr "三角法、指数、対数関数。"

#. type: section
#: numbers.texi.orig:32 numbers.texi.orig:1204 numbers.texi.orig:1205
#, no-wrap
msgid "Random Numbers"
msgstr "Random Numbers"

#. type: menuentry
#: numbers.texi.orig:32
msgid "Obtaining random integers, predictable or not."
msgstr "予測可能または不可能な乱数の取得。"

#. type: Plain text
#: numbers.texi.orig:39
msgid ""
"The range of values for an integer depends on the machine.  The minimum "
"range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr "整数の値の範囲はマシンに依存します。最小の範囲は@minus{}536,870,912から536,870,911(30ビット長の"

#. type: ifnottex
#: numbers.texi.orig:41 numbers.texi.orig:178
msgid "@minus{}2**29"
msgstr "@minus{}2**29"

#. type: tex
#: numbers.texi.orig:44 numbers.texi.orig:181
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr "@math{-2^{29}}\n"

#. type: Plain text
#: numbers.texi.orig:46
msgid "to"
msgstr "から"

#. type: ifnottex
#: numbers.texi.orig:48
msgid "2**29 @minus{} 1),"
msgstr "2**29 @minus{} 1)"

#. type: tex
#: numbers.texi.orig:51
#, no-wrap
msgid "@math{2^{29}-1}),\n"
msgstr "@math{2^{29}-1})\n"

#. type: Plain text
#: numbers.texi.orig:54
msgid ""
"but many machines provide a wider range.  Many examples in this chapter "
"assume the minimum integer width of 30 bits."
msgstr "ですが、多くのマシンはこれより広い範囲を提供します。このチャプターの例の多くは、最小の整数は30ビット長であると仮定します。"

#. type: cindex
#: numbers.texi.orig:54
#, no-wrap
msgid "overflow"
msgstr "overflow"

#. type: Plain text
#: numbers.texi.orig:59
msgid ""
"The Lisp reader reads an integer as a sequence of digits with optional "
"initial sign and optional final period.  An integer that is out of the Emacs "
"range is treated as a floating-point number."
msgstr "Lispリーダーは、(オプションで最初の符号記号と、最後のピリオドをともなう)数字のシーケンスとして整数を読み取ります。Emacsの範囲を超える整数は、浮動小数点数として扱われます。"

#. type: example
#: numbers.texi.orig:69
#, no-wrap
msgid ""
" 1               ; @r{The integer 1.}\n"
" 1.              ; @r{The integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
"-1               ; @r{The integer @minus{}1.}\n"
" 9000000000000000000\n"
"                 ; @r{The floating-point number 9e18.}\n"
" 0               ; @r{The integer 0.}\n"
"-0               ; @r{The integer 0.}\n"
msgstr ""
" 1               ; @r{整数1。}\n"
" 1.              ; @r{整数1。}\n"
"+1               ; @r{これも整数1。}\n"
"-1               ; @r{整数@minus{}1。}\n"
" 9000000000000000000\n"
"                 ; @r{浮動小数点数9e18.}\n"
" 0               ; @r{整数0}\n"
"-0               ; @r{整数0}\n"

#. type: cindex
#: numbers.texi.orig:71
#, no-wrap
msgid "integers in specific radix"
msgstr "integers in specific radix"

#. type: cindex
#: numbers.texi.orig:72
#, no-wrap
msgid "radix for reading an integer"
msgstr "radix for reading an integer"

#. type: cindex
#: numbers.texi.orig:73
#, no-wrap
msgid "base for reading an integer"
msgstr "base for reading an integer"

#. type: cindex
#: numbers.texi.orig:74
#, no-wrap
msgid "hex numbers"
msgstr "hex numbers"

#. type: cindex
#: numbers.texi.orig:75
#, no-wrap
msgid "octal numbers"
msgstr "octal numbers"

#. type: cindex
#: numbers.texi.orig:76
#, no-wrap
msgid "reading numbers in hex, octal, and binary"
msgstr "reading numbers in hex, octal, and binary"

#. type: Plain text
#: numbers.texi.orig:85
msgid ""
"The syntax for integers in bases other than 10 uses @samp{#} followed by a "
"letter that specifies the radix: @samp{b} for binary, @samp{o} for octal, "
"@samp{x} for hex, or @samp{@var{radix}r} to specify radix @var{radix}.  Case "
"is not significant for the letter that specifies the radix.  Thus, "
"@samp{#b@var{integer}} reads @var{integer} in binary, and "
"@samp{#@var{radix}r@var{integer}} reads @var{integer} in radix @var{radix}.  "
"Allowed values of @var{radix} run from 2 to 36.  For example:"
msgstr "基数が10以外の整数の構文は、@samp{#}の後に基数を指定する文字 --- 2進は@samp{b}、8進は@samp{o}、16進は@samp{x}、@samp{@var{radix}r}は基数@var{radix} --- を記述します。基数を指定する文字の大文字小文字は区別されません。したがって@samp{#b@var{integer}}は@var{integer}を2進として読み取り、@samp{#@var{radix}r@var{integer}}は@var{integer}を基数@var{radix}として読み取ります。@var{radix}に指定できる値は2から36です。たとえば:"

#. type: example
#: numbers.texi.orig:91
#, no-wrap
msgid ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"
msgstr ""
"#b101100 @result{} 44\n"
"#o54 @result{} 44\n"
"#x2c @result{} 44\n"
"#24r1k @result{} 44\n"

#. type: Plain text
#: numbers.texi.orig:96
msgid ""
"To understand how various functions work on integers, especially the bitwise "
"operators (@pxref{Bitwise Operations}), it is often helpful to view the "
"numbers in their binary form."
msgstr "整数にたいして処理を行なうさまざまな関数、特にビット演算(@ref{Bitwise Operations}を参照してください)を理解するためには、数を2進形式で見ることが助けになることがしばしばあります。"

#. type: Plain text
#: numbers.texi.orig:98
msgid "In 30-bit binary, the decimal integer 5 looks like this:"
msgstr "30ビットの2進では、10進数の整数5は以下のようになります:"

#. type: example
#: numbers.texi.orig:101
#, no-wrap
msgid "0000...000101 (30 bits total)\n"
msgstr "0000...000101 (全部で30ビット)\n"

#. type: Plain text
#: numbers.texi.orig:107
msgid ""
"(The @samp{...} stands for enough bits to fill out a 30-bit word; in this "
"case, @samp{...} stands for twenty 0 bits.  Later examples also use the "
"@samp{...} notation to make binary integers easier to read.)"
msgstr "(@samp{...}は30ビットのワードを満たすのに充分なビットを意味し、この場合の@samp{...}は12個の0ビットを意味します。以下の例でも、2進の整数を読みやすくするために、@samp{...}の表記を使用します)"

#. type: Plain text
#: numbers.texi.orig:109
msgid "The integer @minus{}1 looks like this:"
msgstr "整数の@minus{}1は、以下のようになります:"

#. type: example
#: numbers.texi.orig:112
#, no-wrap
msgid "1111...111111 (30 bits total)\n"
msgstr "1111...111111 (全部で30ビット)\n"

#. type: cindex
#: numbers.texi.orig:115
#, no-wrap
msgid "two's complement"
msgstr "two's complement"

#. type: Plain text
#: numbers.texi.orig:118
msgid ""
"@minus{}1 is represented as 30 ones.  (This is called @dfn{two's complement} "
"notation.)"
msgstr "@minus{}1は30個の1で表現されます(これは@dfn{2の補数}表記と呼ばれます)。"

#. type: Plain text
#: numbers.texi.orig:122
msgid ""
"Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.  In "
"binary, the decimal integer 4 is 100.  Consequently, @minus{}5 looks like "
"this:"
msgstr "@minus{}1から4を減じることにより、負の整数@minus{}5が得られます。10進の整数4は、2進では100です。したがって、@minus{}5は以下のようになります:"

#. type: example
#: numbers.texi.orig:125
#, no-wrap
msgid "1111...111011 (30 bits total)\n"
msgstr "1111...111011 (全部で30ビット)\n"

#. type: Plain text
#: numbers.texi.orig:129
msgid ""
"In this implementation, the largest 30-bit binary integer is 536,870,911 in "
"decimal.  In binary, it looks like this:"
msgstr "この実装では、0ビットの2進の最大は、10進の536,870,911です。これは2進では以下のようになります:"

#. type: example
#: numbers.texi.orig:132
#, no-wrap
msgid "0111...111111 (30 bits total)\n"
msgstr "0111...111111 (全部で30ビット)\n"

#. type: Plain text
#: numbers.texi.orig:137
msgid ""
"Since the arithmetic functions do not check whether integers go outside "
"their range, when you add 1 to 536,870,911, the value is the negative "
"integer @minus{}536,870,912:"
msgstr "算術関数は整数が範囲の外かをチェックしないので、536,870,911に1を加えると、その値は負の整数@minus{}536,870,912になります:"

#. type: example
#: numbers.texi.orig:142
#, no-wrap
msgid ""
"(+ 1 536870911)\n"
"     @result{} -536870912\n"
"     @result{} 1000...000000 (30 bits total)\n"
msgstr ""
"(+ 1 536870911)\n"
"     @result{} -536870912\n"
"     @result{} 1000...000000 (全部で30ビット)\n"

#. type: Plain text
#: numbers.texi.orig:149
msgid ""
"Many of the functions described in this chapter accept markers for arguments "
"in place of numbers.  (@xref{Markers}.)  Since the actual arguments to such "
"functions may be either numbers or markers, we often give these arguments "
"the name @var{number-or-marker}.  When the argument value is a marker, its "
"position value is used and its buffer is ignored."
msgstr "このチャプターで説明する多くの関数は、数字の位置として引数にマーカー(@ref{Markers}を参照してください)を受け取ります。そのような関数にたいする実際の引数は数字かマーカーなので、わたしたちはこれらの引数に@var{number-or-marker}という名前を与えることがあります。引数の値がマーカーの場合、マーカーの位置が使用され、マーカーのバッファーは無視されます。"

#. type: cindex
#: numbers.texi.orig:150
#, no-wrap
msgid "largest Lisp integer"
msgstr "largest Lisp integer"

#. type: cindex
#: numbers.texi.orig:151
#, no-wrap
msgid "maximum Lisp integer"
msgstr "maximum Lisp integer"

#. type: defvar
#: numbers.texi.orig:152
#, no-wrap
msgid "most-positive-fixnum"
msgstr "most-positive-fixnum"

#. type: defvar
#: numbers.texi.orig:155
msgid ""
"The value of this variable is the largest integer that Emacs Lisp can "
"handle.  Typical values are"
msgstr "この変数の値は、Emacs Lispが扱える整数の最大値です。典型的な値は32ビットでは"

#. type: ifnottex
#: numbers.texi.orig:157
msgid "2**29 @minus{} 1"
msgstr "2**29 @minus{} 1"

#. type: tex
#: numbers.texi.orig:160
#, no-wrap
msgid "@math{2^{29}-1}\n"
msgstr "@math{2^{29}-1}\n"

#. type: defvar
#: numbers.texi.orig:162 numbers.texi.orig:183
msgid "on 32-bit and"
msgstr "、64ビットでは"

#. type: ifnottex
#: numbers.texi.orig:164
msgid "2**61 @minus{} 1"
msgstr "2**61 @minus{} 1"

#. type: tex
#: numbers.texi.orig:167
#, no-wrap
msgid "@math{2^{61}-1}\n"
msgstr "@math{2^{61}-1}\n"

#. type: defvar
#: numbers.texi.orig:169 numbers.texi.orig:190
msgid "on 64-bit platforms."
msgstr "です。"

#. type: cindex
#: numbers.texi.orig:171
#, no-wrap
msgid "smallest Lisp integer"
msgstr "smallest Lisp integer"

#. type: cindex
#: numbers.texi.orig:172
#, no-wrap
msgid "minimum Lisp integer"
msgstr "minimum Lisp integer"

#. type: defvar
#: numbers.texi.orig:173
#, no-wrap
msgid "most-negative-fixnum"
msgstr "most-negative-fixnum"

#. type: defvar
#: numbers.texi.orig:176
msgid ""
"The value of this variable is the smallest integer that Emacs Lisp can "
"handle.  It is negative.  Typical values are"
msgstr "この変数の値は、Emacs Lispが扱える最小の整数です。これは負の整数です。典型的な値は32ビットでは"

#. type: ifnottex
#: numbers.texi.orig:185
msgid "@minus{}2**61"
msgstr "@minus{}2**61、"

#. type: tex
#: numbers.texi.orig:188
#, no-wrap
msgid "@math{-2^{61}}\n"
msgstr "@math{-2^{61}}、\n"

#. type: Plain text
#: numbers.texi.orig:195
msgid ""
"In Emacs Lisp, text characters are represented by integers.  Any integer "
"between zero and the value of @code{(max-char)}, inclusive, is considered to "
"be valid as a character.  @xref{Character Codes}."
msgstr "Emacs Lispでは、テキスト文字は整数により表現されます。0から@code{(max-char)}までの整数は、有効な文字として判断されます。@ref{Character Codes}を参照してください。"

#. type: section
#: numbers.texi.orig:197
#, no-wrap
msgid "Floating-Point Basics"
msgstr "Floating-Point Basics"

#. type: cindex
#: numbers.texi.orig:199
#, no-wrap
msgid "@acronym{IEEE} floating point"
msgstr "@acronym{IEEE} floating point"

#. type: Plain text
#: numbers.texi.orig:205
msgid ""
"Floating-point numbers are useful for representing numbers that are not "
"integral.  The range of floating-point numbers is the same as the range of "
"the C data type @code{double} on the machine you are using.  On all "
"computers currently supported by Emacs, this is double-precision "
"@acronym{IEEE} floating point."
msgstr "浮動小数点数は整数ではない数を表現するのに便利です。浮動小数点数の範囲は、使用しているマシンでのCデータ型の@code{double}と同じ範囲です。現在Emacsでサポートされているすべてのコンピューターでは、これは倍精度の@acronym{IEEE}浮動小数点数です。"

#. type: Plain text
#: numbers.texi.orig:214
msgid ""
"The read syntax for floating-point numbers requires either a decimal point, "
"an exponent, or both.  Optional signs (@samp{+} or @samp{-})  precede the "
"number and its exponent.  For example, @samp{1500.0}, @samp{+15e2}, "
"@samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are five ways of "
"writing a floating-point number whose value is 1500.  They are all "
"equivalent.  Like Common Lisp, Emacs Lisp requires at least one digit after "
"any decimal point in a floating-point number; @samp{1500.} is an integer, "
"not a floating-point number."
msgstr "浮動小数点数にたいする入力構文は、小数点と指数のどちらか1つ、または両方が必要とします。オプションの符号(@samp{+}か@samp{-})は、その数字と指数の前に記述します。たとえば、@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は、値が1500の浮動小数点数を記述する5つの方法です。これらはすべて等価です。Common Lispと同様、Emacs Lispは、浮動小数点数の小数点の後に、少なくとも1つの数字を必要とします。@samp{1500.}は整数であり、浮動小数点数ではありません。"

#. type: Plain text
#: numbers.texi.orig:220
msgid ""
"Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero with "
"respect to @code{equal} and @code{=}.  This follows the @acronym{IEEE} "
"floating-point standard, which says @code{-0.0} and @code{0.0} are "
"numerically equal even though other operations can distinguish them."
msgstr "Emacs Lispは@code{-0.0}を、@code{equal}と@code{=}に関して、通常の0と数学的に同じものとして扱います。これは、(他の処理がこれらを区別するとしても、@code{-0.0}と@code{0.0}は数学的に等しいとする)@acronym{IEEE}浮動小数点数規格にしたがっています。"

#. type: cindex
#: numbers.texi.orig:221
#, no-wrap
msgid "positive infinity"
msgstr "positive infinity"

#. type: cindex
#: numbers.texi.orig:222
#, no-wrap
msgid "negative infinity"
msgstr "negative infinity"

#. type: item
#: numbers.texi.orig:223 numbers.texi.orig:236
#, no-wrap
msgid "infinity"
msgstr "infinity"

#. type: cindex
#: numbers.texi.orig:224
#, no-wrap
msgid "NaN"
msgstr "NaN"

#. type: Plain text
#: numbers.texi.orig:232
msgid ""
"The @acronym{IEEE} floating-point standard supports positive infinity and "
"negative infinity as floating-point values.  It also provides for a class of "
"values called NaN or ``not-a-number''; numerical functions return such "
"values in cases where there is no correct answer.  For example, @code{(/ 0.0 "
"0.0)} returns a NaN@.  Although NaN values carry a sign, for practical "
"purposes there is no other significant difference between different NaN "
"values in Emacs Lisp."
msgstr "@acronym{IEEE}浮動小数点数規格は、浮動小数点数として、正の無限大と、負の無限大をサポートします。この規格はNaNまたは``not-a-number(数字ではない)''と呼ばれる値クラスも提供します。数学関数は、正しい答えが存在しないような場合に、このような値をreturnします。たとえば@code{(/ 0.0 0.0)}はNaNをreturnします。NaN値に符号がついていたとしても、実用的な目的にたいして、Emacs Lispにおける異なるNaN値に、意味のある違いはありません。"

#. type: Plain text
#: numbers.texi.orig:234
msgid "Here are read syntaxes for these special floating-point values:"
msgstr "以下は、これらの特別な浮動小数点数にたいする入力構文です:"

#. type: table
#: numbers.texi.orig:238
msgid "@samp{1.0e+INF} and @samp{-1.0e+INF}"
msgstr "@samp{1.0e+INF}と@samp{-1.0e+INF}"

#. type: item
#: numbers.texi.orig:238
#, no-wrap
msgid "not-a-number"
msgstr "not-a-number"

#. type: table
#: numbers.texi.orig:240
msgid "@samp{0.0e+NaN} and @samp{-0.0e+NaN}"
msgstr "@samp{0.0e+NaN}と@samp{-0.0e+NaN}"

#. type: Plain text
#: numbers.texi.orig:244
msgid "The following functions are specialized for handling floating-point numbers:"
msgstr "以下の関数は浮動小数点数を扱うために特化したものです:"

#. type: defun
#: numbers.texi.orig:245
#, no-wrap
msgid "isnan x"
msgstr "isnan x"

#. type: defun
#: numbers.texi.orig:248
msgid ""
"This predicate returns @code{t} if its floating-point argument is a NaN, "
"@code{nil} otherwise."
msgstr "この述語は浮動小数引数がNaNのときは@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:250
#, no-wrap
msgid "frexp x"
msgstr "frexp x"

#. type: defun
#: numbers.texi.orig:254
msgid ""
"This function returns a cons cell @code{(@var{s} . @var{e})}, where @var{s} "
"and @var{e} are respectively the significand and exponent of the "
"floating-point number @var{x}."
msgstr "この関数はコンスセル@code{(@var{s} . @var{e})}をreturnします。ここで@var{s}と@var{e}は、浮動小数点数のsignificand(浮動小数点数を2の指数表現したときの仮引数)と指数です。"

#. type: defun
#: numbers.texi.orig:257
msgid ""
"If @var{x} is finite, then @var{s} is a floating-point number between 0.5 "
"(inclusive) and 1.0 (exclusive), @var{e} is an integer, and"
msgstr "@var{x}が有限の場合、@var{s}は0.5以上1.0未満の浮動小数点数で、@var{e}は整数で、"

#. type: ifnottex
#: numbers.texi.orig:259
msgid "@var{x} = @var{s} * 2**@var{e}."
msgstr "@var{x} = @var{s} * 2**@var{e}です。"

#. type: tex
#: numbers.texi.orig:262
#, no-wrap
msgid "@math{x = s 2^e}.\n"
msgstr "@math{x = s 2^e}です。\n"

#. type: defun
#: numbers.texi.orig:266
msgid ""
"If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.  If "
"@var{x} is a NaN, then @var{s} is also a NaN.  If @var{x} is zero, then "
"@var{e} is 0."
msgstr "@var{x}が0または無限の場合、@var{s}は@var{x}と等しくなります。@var{x}がNaNの場合は、@var{s}もNaNです。@var{x}が0の場合、@var{e}は0です。"

#. type: defun
#: numbers.texi.orig:268
#, no-wrap
msgid "ldexp sig &optional exp"
msgstr "ldexp sig &optional exp"

#. type: defun
#: numbers.texi.orig:271
msgid ""
"This function returns a floating-point number corresponding to the "
"significand @var{sig} and exponent @var{exp}."
msgstr "この関数は、significandが@var{sig}、指数が@var{exp}の浮動小数点数をreturnします。"

#. type: defun
#: numbers.texi.orig:273
#, no-wrap
msgid "copysign x1 x2"
msgstr "copysign x1 x2"

#. type: defun
#: numbers.texi.orig:276
msgid ""
"This function copies the sign of @var{x2} to the value of @var{x1}, and "
"returns the result.  @var{x1} and @var{x2} must be floating point."
msgstr "koの関数は@var{x2}の、@var{x1}の値にコピーして、その結果をreturnします。@var{x1}と@var{x2}は浮動小数でなければなりません。"

#. type: defun
#: numbers.texi.orig:278
#, no-wrap
msgid "logb x"
msgstr "logb x"

#. type: defun
#: numbers.texi.orig:282
msgid ""
"This function returns the binary exponent of @var{x}.  More precisely, the "
"value is the logarithm base 2 of @math{|x|}, rounded down to an integer."
msgstr "この関数は@var{x}の2進指数をreturnします。より正確にいうと、この値は@math{|x|}の2を底とする対数を、整数に切り下げたものです。"

#. type: example
#: numbers.texi.orig:288
#, no-wrap
msgid ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"
msgstr ""
"(logb 10)\n"
"     @result{} 3\n"
"(logb 10.0e20)\n"
"     @result{} 69\n"

#. type: section
#: numbers.texi.orig:292
#, no-wrap
msgid "Type Predicates for Numbers"
msgstr "Type Predicates for Numbers"

#. type: cindex
#: numbers.texi.orig:293
#, no-wrap
msgid "predicates for numbers"
msgstr "predicates for numbers"

#. type: Plain text
#: numbers.texi.orig:301
msgid ""
"The functions in this section test for numbers, or for a specific type of "
"number.  The functions @code{integerp} and @code{floatp} can take any type "
"of Lisp object as argument (they would not be of much use otherwise), but "
"the @code{zerop} predicate requires a number as its argument.  See also "
"@code{integer-or-marker-p} and @code{number-or-marker-p}, in @ref{Predicates "
"on Markers}."
msgstr "このセクションの関数は、数または数の特定の型にたいしてテストを行ないます。関数@code{integerp}および@code{floatp}は、引き数として任意のLispオブジェクト型をとることができます(そうでないと、あまり使用する機会がありません)。しかし、述語@code{zerop}は、引き数として数を要求します。@ref{Predicates on Markers}の@code{integer-or-marker-p}と@code{number-or-marker-p}も参照してください。"

#. type: defun
#: numbers.texi.orig:302
#, no-wrap
msgid "floatp object"
msgstr "floatp object"

#. type: defun
#: numbers.texi.orig:305
msgid ""
"This predicate tests whether its argument is floating point and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr "この述語は、引数が浮動小数かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:307
#, no-wrap
msgid "integerp object"
msgstr "integerp object"

#. type: defun
#: numbers.texi.orig:310
msgid ""
"This predicate tests whether its argument is an integer, and returns "
"@code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が整数かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:312
#, no-wrap
msgid "numberp object"
msgstr "numberp object"

#. type: defun
#: numbers.texi.orig:315
msgid ""
"This predicate tests whether its argument is a number (either integer or "
"floating point), and returns @code{t} if so, @code{nil} otherwise."
msgstr "この述語は引数が数(整数か浮動小数)かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:317
#, no-wrap
msgid "natnump object"
msgstr "natnump object"

#. type: cindex
#: numbers.texi.orig:318
#, no-wrap
msgid "natural numbers"
msgstr "natural numbers"

#. type: defun
#: numbers.texi.orig:323
msgid ""
"This predicate (whose name comes from the phrase ``natural number'')  tests "
"to see whether its argument is a nonnegative integer, and returns @code{t} "
"if so, @code{nil} otherwise.  0 is considered non-negative."
msgstr "この述語(名前は``natural number(自然数)''が由来です)は、引数が正の整数かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。0は整数と判断されます。"

#. type: findex
#: numbers.texi.orig:324
#, no-wrap
msgid "wholenump"
msgstr "wholenump"

#. type: defun
#: numbers.texi.orig:326
msgid "@code{wholenump} is a synonym for @code{natnump}."
msgstr "@code{wholenump}は、@code{natnump}にたいするシノニムです。"

#. type: defun
#: numbers.texi.orig:328
#, no-wrap
msgid "zerop number"
msgstr "zerop number"

#. type: defun
#: numbers.texi.orig:331
msgid ""
"This predicate tests whether its argument is zero, and returns @code{t} if "
"so, @code{nil} otherwise.  The argument must be a number."
msgstr "この述語は、引数が0かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。引数は数でなければなりません。"

#. type: defun
#: numbers.texi.orig:333
msgid "@code{(zerop x)} is equivalent to @code{(= x 0)}."
msgstr "@code{(zerop x)}は、@code{(= x 0)}と等価です。"

#. type: cindex
#: numbers.texi.orig:337
#, no-wrap
msgid "number comparison"
msgstr "number comparison"

#. type: cindex
#: numbers.texi.orig:338
#, no-wrap
msgid "comparing numbers"
msgstr "comparing numbers"

#. type: Plain text
#: numbers.texi.orig:346
msgid ""
"To test numbers for numerical equality, you should normally use @code{=}, "
"not @code{eq}.  There can be many distinct floating-point objects with the "
"same numeric value.  If you use @code{eq} to compare them, then you test "
"whether two values are the same @emph{object}.  By contrast, @code{=} "
"compares only the numeric values of the objects."
msgstr "数が数値的に等しいかテストするためには、@code{eq}ではなく、通常は@code{=}を使用するべきです。同じ数値をもつ、多くの浮動小数オブジェクトが存在するかもしれません。これらを比較するのに@code{eq}を使用する場合、これは2つの値が同じオブジェクトかどうかをテストすることになります。対照的に、@code{=}はオブジェクトの数値的な値だけを比較します。"

#. type: Plain text
#: numbers.texi.orig:355
msgid ""
"In Emacs Lisp, each integer is a unique Lisp object.  Therefore, @code{eq} "
"is equivalent to @code{=} where integers are concerned.  It is sometimes "
"convenient to use @code{eq} for comparing an unknown value with an integer, "
"because @code{eq} does not report an error if the unknown value is not a "
"number---it accepts arguments of any type.  By contrast, @code{=} signals an "
"error if the arguments are not numbers or markers.  However, it is better "
"programming practice to use @code{=} if you can, even for comparing "
"integers."
msgstr "Emacs Lispでは、それぞれの整数はは、一意なLispオブジェクトです。したがって、整数に関しては、@code{eq}は@code{=}と同じです。未知の整数の値を比較するのに、@code{eq}を使用するのが便利な場合があります。なぜなら未知の値が数字でない場合でも、@code{eq}はエラーを報告しません。対照的に、引数が数でもマーカーでもない場合、@code{=}はエラーをシグナルします。しかし、整数の比較においてさえ、使用できる場合は@code{=}を使用するのが、よいプログラミング習慣です。"

#. type: Plain text
#: numbers.texi.orig:361
msgid ""
"Sometimes it is useful to compare numbers with @code{equal}, which treats "
"two numbers as equal if they have the same data type (both integers, or both "
"floating point) and the same value.  By contrast, @code{=} can treat an "
"integer and a floating-point number as equal.  @xref{Equality Predicates}."
msgstr "数の比較において、2つの数が同じデータ型(どちらも整数、またはどちらも浮動小数)で、同じ値の場合は等しい数として扱う、@code{equal}のほうが便利なときもあります。対照的に、@code{=}は、整数と浮動小数点数を等しい数と扱うことができます。@ref{Equality Predicates}を参照してください。"

#. type: Plain text
#: numbers.texi.orig:366
msgid ""
"There is another wrinkle: because floating-point arithmetic is not exact, it "
"is often a bad idea to check for equality of floating-point values.  Usually "
"it is better to test for approximate equality.  Here's a function to do "
"this:"
msgstr "他の欠点もあります。浮動小数演算は正確ではないので、浮動小数値を比較するのが悪いアイデアのときが、しばしばあります。通常は、近似的に等しいことをテストするほうがよいでしょう。以下はこれを行なう関数です:"

#. type: example
#: numbers.texi.orig:374
#, no-wrap
msgid ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"
msgstr ""
"(defvar fuzz-factor 1.0e-6)\n"
"(defun approx-equal (x y)\n"
"  (or (= x y)\n"
"      (< (/ (abs (- x y))\n"
"            (max (abs x) (abs y)))\n"
"         fuzz-factor)))\n"

#. type: cindex
#: numbers.texi.orig:376
#, no-wrap
msgid "CL note---integers vrs @code{eq}"
msgstr "CL note---integers vrs @code{eq}"

#. type: quotation
#: numbers.texi.orig:383
msgid ""
"@b{Common Lisp note:} Comparing numbers in Common Lisp always requires "
"@code{=} because Common Lisp implements multi-word integers, and two "
"distinct integer objects can have the same numeric value.  Emacs Lisp can "
"have just one integer object for any given value because it has a limited "
"range of integers."
msgstr "@b{Common Lispに関する注意: }Common Lispは複数ワード整数を実装していて、2つの別の整数オブジェクトが、同じ数値的な値をもつことができるので、Common Lispでの数の比較は、常に@code{=}が要求されます。Emacs Lispの整数は範囲が制限されているため、与えられた値に対応する整数オブジェクトは、1つだけです。"

#. type: defun
#: numbers.texi.orig:385
#, no-wrap
msgid "= number-or-marker &rest number-or-markers"
msgstr "= number-or-marker &rest number-or-markers"

#. type: defun
#: numbers.texi.orig:388
msgid ""
"This function tests whether all its arguments are numerically equal, and "
"returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、すべての引数が数値的に等しいかどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:390
#, no-wrap
msgid "eql value1 value2"
msgstr "eql value1 value2"

#. type: defun
#: numbers.texi.orig:395
msgid ""
"This function acts like @code{eq} except when both arguments are numbers.  "
"It compares numbers by type and numeric value, so that @code{(eql 1.0 1)} "
"returns @code{nil}, but @code{(eql 1.0 1.0)} and @code{(eql 1 1)} both "
"return @code{t}."
msgstr "この関数は@code{eq}と同様に振る舞いますが、引数が両方とも数のときは例外です。これは数を型と数値的な値により比較するので、@code{(eql 1.0 1)}は@code{nil}をreturnしますが、@code{(eql 1.0 1.0)}と@code{(eql 1 1)}は@code{t}をreturnします。"

#. type: defun
#: numbers.texi.orig:397
#, no-wrap
msgid "/= number-or-marker1 number-or-marker2"
msgstr "/= number-or-marker1 number-or-marker2"

#. type: defun
#: numbers.texi.orig:400
msgid ""
"This function tests whether its arguments are numerically equal, and returns "
"@code{t} if they are not, and @code{nil} if they are."
msgstr "この関数は引数が数値的に等しいかどうかをテストして、もし異なる場合は@code{t}、等しい場合は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:402
#, no-wrap
msgid "<  number-or-marker &rest number-or-markers"
msgstr "<  number-or-marker &rest number-or-markers"

#. type: defun
#: numbers.texi.orig:405
msgid ""
"This function tests whether each argument is strictly less than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数がそれぞれ、その後の引数より小さいかどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:407
#, no-wrap
msgid "<= number-or-marker &rest number-or-markers"
msgstr "<= number-or-marker &rest number-or-markers"

#. type: defun
#: numbers.texi.orig:410
msgid ""
"This function tests whether each argument is less than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数がそれぞれ、その後の引数以下かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:412
#, no-wrap
msgid "> number-or-marker &rest number-or-markers"
msgstr "> number-or-marker &rest number-or-markers"

#. type: defun
#: numbers.texi.orig:415
msgid ""
"This function tests whether each argument is strictly greater than the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数がそれぞれ、その後の引数より大きいかどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:417
#, no-wrap
msgid ">= number-or-marker &rest number-or-markers"
msgstr ">= number-or-marker &rest number-or-markers"

#. type: defun
#: numbers.texi.orig:420
msgid ""
"This function tests whether each argument is greater than or equal to the "
"following argument.  It returns @code{t} if so, @code{nil} otherwise."
msgstr "この関数は、各引数がそれぞれ、その後の引数以上かどうかをテストして、もしそうなら@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: numbers.texi.orig:422
#, no-wrap
msgid "max number-or-marker &rest numbers-or-markers"
msgstr "max number-or-marker &rest numbers-or-markers"

#. type: defun
#: numbers.texi.orig:426
msgid ""
"This function returns the largest of its arguments.  If any of the arguments "
"is floating point, the value is returned as floating point, even if it was "
"given as an integer."
msgstr "この関数は引数の最大をreturnします。引数のどれかが浮動小数の場合は、たとえ最大が整数であっても、浮動小数として値がreturnされます。"

#. type: example
#: numbers.texi.orig:434
#, no-wrap
msgid ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3.0\n"
msgstr ""
"(max 20)\n"
"     @result{} 20\n"
"(max 1 2.5)\n"
"     @result{} 2.5\n"
"(max 1 3 2.5)\n"
"     @result{} 3.0\n"

#. type: defun
#: numbers.texi.orig:437
#, no-wrap
msgid "min number-or-marker &rest numbers-or-markers"
msgstr "min number-or-marker &rest numbers-or-markers"

#. type: defun
#: numbers.texi.orig:441
msgid ""
"This function returns the smallest of its arguments.  If any of the "
"arguments is floating point, the value is returned as floating point, even "
"if it was given as an integer."
msgstr "この関数は引数の最小をreturnします。引数のどれかが浮動小数の場合は、たとえ最小が整数であっても、浮動小数として値がreturnされます。"

#. type: example
#: numbers.texi.orig:445
#, no-wrap
msgid ""
"(min -4 1)\n"
"     @result{} -4\n"
msgstr ""
"(min -4 1)\n"
"     @result{} -4\n"

#. type: defun
#: numbers.texi.orig:448
#, no-wrap
msgid "abs number"
msgstr "abs number"

#. type: defun
#: numbers.texi.orig:450
msgid "This function returns the absolute value of @var{number}."
msgstr "この関数は@var{number}の絶対値をreturnします。"

#. type: cindex
#: numbers.texi.orig:454
#, no-wrap
msgid "rounding in conversions"
msgstr "rounding in conversions"

#. type: cindex
#: numbers.texi.orig:455
#, no-wrap
msgid "number conversions"
msgstr "number conversions"

#. type: cindex
#: numbers.texi.orig:456
#, no-wrap
msgid "converting numbers"
msgstr "converting numbers"

#. type: Plain text
#: numbers.texi.orig:459
msgid "To convert an integer to floating point, use the function @code{float}."
msgstr "整数を浮動少数に変換するには、関数@code{float}を使用します。"

#. type: defun
#: numbers.texi.orig:460
#, no-wrap
msgid "float number"
msgstr "float number"

#. type: defun
#: numbers.texi.orig:464
msgid ""
"This returns @var{number} converted to floating point.  If @var{number} is "
"already floating point, @code{float} returns it unchanged."
msgstr "これは浮動小数に変換された@var{number}をreturnします。すでに@var{number}が浮動小数の場合、@code{float}はそれを変更せずにreturnします。"

#. type: Plain text
#: numbers.texi.orig:476
msgid ""
"There are four functions to convert floating-point numbers to integers; they "
"differ in how they round.  All accept an argument @var{number} and an "
"optional argument @var{divisor}.  Both arguments may be integers or "
"floating-point numbers.  @var{divisor} may also be @code{nil}.  If "
"@var{divisor} is @code{nil} or omitted, these functions convert @var{number} "
"to an integer, or return it unchanged if it already is an integer.  If "
"@var{divisor} is non-@code{nil}, they divide @var{number} by @var{divisor} "
"and convert the result to an integer.  If @var{divisor} is zero (whether "
"integer or floating point), Emacs signals an @code{arith-error} error."
msgstr "浮動小数点数を整数に変換する関数が4つあります。これらは浮動小数点数を丸める方法がことなります。これらはすべて引数@var{number}と、オプション引数として@var{divisor}を受け取ります。引数は両方とも整数または浮動小数点数です。@var{divisor}が@code{nil}のこともあります。@var{divisor}が@code{nil}または省略された場合、これらの関数は@var{number}を整数に変換するか、それが既に整数の場合は変更せずにreturnします。@var{divisor}が非@code{nil}の場合、これらの関数は@var{number}を@var{divisor}で除してから、その結果を整数に変換します。@var{divisor}が(整数か浮動小数かに関わらず)0の場合、Emacsは@code{arith-error}エラーをシグナルします。"

#. type: defun
#: numbers.texi.orig:477
#, no-wrap
msgid "truncate number &optional divisor"
msgstr "truncate number &optional divisor"

#. type: defun
#: numbers.texi.orig:480
msgid "This returns @var{number}, converted to an integer by rounding towards zero."
msgstr "これは0に向かって丸めることにより整数に変換した@var{number}をreturnします。"

#. type: example
#: numbers.texi.orig:490
#, no-wrap
msgid ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(truncate 1.2)\n"
"     @result{} 1\n"
"(truncate 1.7)\n"
"     @result{} 1\n"
"(truncate -1.2)\n"
"     @result{} -1\n"
"(truncate -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: numbers.texi.orig:493
#, no-wrap
msgid "floor number &optional divisor"
msgstr "floor number &optional divisor"

#. type: defun
#: numbers.texi.orig:496
msgid ""
"This returns @var{number}, converted to an integer by rounding downward "
"(towards negative infinity)."
msgstr "これは、下方(負の無限大に向かって)に丸めることにより整数に変換した@var{number}をreturnします。"

#. type: defun
#: numbers.texi.orig:499
msgid ""
"If @var{divisor} is specified, this uses the kind of division operation that "
"corresponds to @code{mod}, rounding downward."
msgstr "@var{divisor}が指定された場合、@code{mod}に相当する種類の除算演算を使用して、下方に丸めを行ないます。"

#. type: example
#: numbers.texi.orig:511
#, no-wrap
msgid ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"
msgstr ""
"(floor 1.2)\n"
"     @result{} 1\n"
"(floor 1.7)\n"
"     @result{} 1\n"
"(floor -1.2)\n"
"     @result{} -2\n"
"(floor -1.7)\n"
"     @result{} -2\n"
"(floor 5.99 3)\n"
"     @result{} 1\n"

#. type: defun
#: numbers.texi.orig:514
#, no-wrap
msgid "ceiling number &optional divisor"
msgstr "ceiling number &optional divisor"

#. type: defun
#: numbers.texi.orig:517
msgid ""
"This returns @var{number}, converted to an integer by rounding upward "
"(towards positive infinity)."
msgstr "これは、上方(正の無限大に向かって)に丸めることにより整数に変換した@var{number}をreturnします。"

#. type: example
#: numbers.texi.orig:527
#, no-wrap
msgid ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"
msgstr ""
"(ceiling 1.2)\n"
"     @result{} 2\n"
"(ceiling 1.7)\n"
"     @result{} 2\n"
"(ceiling -1.2)\n"
"     @result{} -1\n"
"(ceiling -1.7)\n"
"     @result{} -1\n"

#. type: defun
#: numbers.texi.orig:530
#, no-wrap
msgid "round number &optional divisor"
msgstr "round number &optional divisor"

#. type: defun
#: numbers.texi.orig:534
msgid ""
"This returns @var{number}, converted to an integer by rounding towards the "
"nearest integer.  Rounding a value equidistant between two integers returns "
"the even integer."
msgstr "これは、もっとも近い整数に向かって丸めることにより整数に変換した@var{number}をreturnします。2つの整数から等距離にある値の丸めでは、偶数の整数をreturnします。"

#. type: example
#: numbers.texi.orig:544
#, no-wrap
msgid ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"
msgstr ""
"(round 1.2)\n"
"     @result{} 1\n"
"(round 1.7)\n"
"     @result{} 2\n"
"(round -1.2)\n"
"     @result{} -1\n"
"(round -1.7)\n"
"     @result{} -2\n"

#. type: cindex
#: numbers.texi.orig:549
#, no-wrap
msgid "arithmetic operations"
msgstr "arithmetic operations"

#. type: Plain text
#: numbers.texi.orig:557
msgid ""
"Emacs Lisp provides the traditional four arithmetic operations (addition, "
"subtraction, multiplication, and division), as well as remainder and modulus "
"functions, and functions to add or subtract 1.  Except for @code{%}, each of "
"these functions accepts both integer and floating-point arguments, and "
"returns a floating-point number if any argument is floating point."
msgstr "Emacs Lispは伝統的な4つの算術演算(加減乗除)、同様に剰余とmodulusの関数、および1加算、1減算の関数を提供します。@code{%}を除き、これらの各関数は引き数として整数か浮動小数を受け取り、浮動小数の引数がある場合は、浮動小数点数をreturnします。"

#. type: Plain text
#: numbers.texi.orig:561
msgid ""
"Emacs Lisp arithmetic functions do not check for integer overflow.  Thus "
"@code{(1+ 536870911)} may evaluate to @minus{}536870912, depending on your "
"hardware."
msgstr "Emacs Lispの算術関数は整数のオーバーフローをチェックしません。したがって@code{(1+ 536870911)}は@minus{}536870912に評価されるかもしれず、それはハードウェアーに依存します。"

#. type: defun
#: numbers.texi.orig:562
#, no-wrap
msgid "1+ number-or-marker"
msgstr "1+ number-or-marker"

#. type: defun
#: numbers.texi.orig:565
msgid "This function returns @var{number-or-marker} plus 1.  For example,"
msgstr "この関数は@var{number-or-marker} + 1をreturnします。例えば、"

#. type: example
#: numbers.texi.orig:571
#, no-wrap
msgid ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"
msgstr ""
"(setq foo 4)\n"
"     @result{} 4\n"
"(1+ foo)\n"
"     @result{} 5\n"

#. type: defun
#: numbers.texi.orig:575
msgid ""
"This function is not analogous to the C operator @code{++}---it does not "
"increment a variable.  It just computes a sum.  Thus, if we continue,"
msgstr "この関数はCの演算子@code{++}とは類似しません --- この関数は変数をインクリメントしません。この関数は和を計算するだけです、したがって以下を続けて評価すると、"

#. type: example
#: numbers.texi.orig:579
#, no-wrap
msgid ""
"foo\n"
"     @result{} 4\n"
msgstr ""
"foo\n"
"     @result{} 4\n"

#. type: defun
#: numbers.texi.orig:583
msgid "If you want to increment the variable, you must use @code{setq}, like this:"
msgstr "変数をインクリメントしたい場合は、以下のように@code{setq}を使用しなければなりません:"

#. type: example
#: numbers.texi.orig:587
#, no-wrap
msgid ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"
msgstr ""
"(setq foo (1+ foo))\n"
"     @result{} 5\n"

#. type: defun
#: numbers.texi.orig:590
#, no-wrap
msgid "1- number-or-marker"
msgstr "1- number-or-marker"

#. type: defun
#: numbers.texi.orig:592
msgid "This function returns @var{number-or-marker} minus 1."
msgstr "この関数は@var{number-or-marker} @minus{} 1をreturnします。"

#. type: defun
#: numbers.texi.orig:594
#, no-wrap
msgid "+ &rest numbers-or-markers"
msgstr "+ &rest numbers-or-markers"

#. type: defun
#: numbers.texi.orig:597
msgid ""
"This function adds its arguments together.  When given no arguments, "
"@code{+} returns 0."
msgstr "この関数は引数すべてを加算します。引数を与えない場合、@code{+}は0をreturnします。"

#. type: example
#: numbers.texi.orig:605
#, no-wrap
msgid ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"
msgstr ""
"(+)\n"
"     @result{} 0\n"
"(+ 1)\n"
"     @result{} 1\n"
"(+ 1 2 3 4)\n"
"     @result{} 10\n"

#. type: defun
#: numbers.texi.orig:608
#, no-wrap
msgid "- &optional number-or-marker &rest more-numbers-or-markers"
msgstr "- &optional number-or-marker &rest more-numbers-or-markers"

#. type: defun
#: numbers.texi.orig:614
msgid ""
"The @code{-} function serves two purposes: negation and subtraction.  When "
"@code{-} has a single argument, the value is the negative of the argument.  "
"When there are multiple arguments, @code{-} subtracts each of the "
"@var{more-numbers-or-markers} from @var{number-or-marker}, cumulatively.  If "
"there are no arguments, the result is 0."
msgstr "@code{-}関数は2つの目的 --- 符号反転と減算 ---を果たします。@code{-}に1つの引数を与えた場合、値は引数の符号を反転したものになります。複数の引数がある場合、@var{number-or-marker}から@var{more-numbers-or-markers}までの各値を蓄積的に減算します。引数がない場合、結果は0です。"

#. type: example
#: numbers.texi.orig:622
#, no-wrap
msgid ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"
msgstr ""
"(- 10 1 2 3 4)\n"
"     @result{} 0\n"
"(- 10)\n"
"     @result{} -10\n"
"(-)\n"
"     @result{} 0\n"

#. type: defun
#: numbers.texi.orig:625
#, no-wrap
msgid "* &rest numbers-or-markers"
msgstr "* &rest numbers-or-markers"

#. type: defun
#: numbers.texi.orig:628
msgid ""
"This function multiplies its arguments together, and returns the product.  "
"When given no arguments, @code{*} returns 1."
msgstr "この関数はすべての引数を乗じて、積をreturnします。引数がない場合、@code{*}は1をreturnします。"

#. type: example
#: numbers.texi.orig:636
#, no-wrap
msgid ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"
msgstr ""
"(*)\n"
"     @result{} 1\n"
"(* 1)\n"
"     @result{} 1\n"
"(* 1 2 3 4)\n"
"     @result{} 24\n"

#. type: defun
#: numbers.texi.orig:639
#, no-wrap
msgid "/ dividend divisor &rest divisors"
msgstr "/ dividend divisor &rest divisors"

#. type: defun
#: numbers.texi.orig:644
msgid ""
"This function divides @var{dividend} by @var{divisor} and returns the "
"quotient.  If there are additional arguments @var{divisors}, then it divides "
"@var{dividend} by each divisor in turn.  Each argument may be a number or a "
"marker."
msgstr "この関数は@var{dividend}を@var{divisor}で除し、商をreturnします。追加の引数@var{divisors}がある場合、その後さらに@var{dividend}を@var{divisors}で順に除します。各引数は数かマーカーです。"

#. type: defun
#: numbers.texi.orig:647
msgid ""
"If all the arguments are integers, the result is an integer, obtained by "
"rounding the quotient towards zero after each division."
msgstr "すべての引数が整数の場合、結果は各除算の後に商を0へ向かって丸めることにより得られる整数になります。"

#. type: group
#: numbers.texi.orig:652
#, no-wrap
msgid ""
"(/ 6 2)\n"
"     @result{} 3\n"
msgstr ""
"(/ 6 2)\n"
"     @result{} 3\n"

#. type: group
#: numbers.texi.orig:656
#, no-wrap
msgid ""
"(/ 5 2)\n"
"     @result{} 2\n"
msgstr ""
"(/ 5 2)\n"
"     @result{} 2\n"

#. type: group
#: numbers.texi.orig:660
#, no-wrap
msgid ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2)\n"
"     @result{} 2.5\n"

#. type: group
#: numbers.texi.orig:664
#, no-wrap
msgid ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: numbers.texi.orig:668
#, no-wrap
msgid ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"
msgstr ""
"(/ 5.0 2.0)\n"
"     @result{} 2.5\n"

#. type: group
#: numbers.texi.orig:672
#, no-wrap
msgid ""
"(/ 25 3 2)\n"
"     @result{} 4\n"
msgstr ""
"(/ 25 3 2)\n"
"     @result{} 4\n"

#. type: group
#: numbers.texi.orig:676
#, no-wrap
msgid ""
"(/ -17 6)\n"
"     @result{} -2\n"
msgstr ""
"(/ -17 6)\n"
"     @result{} -2\n"

#. type: cindex
#: numbers.texi.orig:679
#, no-wrap
msgid "@code{arith-error} in division"
msgstr "@code{arith-error} in division"

#. type: defun
#: numbers.texi.orig:684
msgid ""
"If you divide an integer by the integer 0, Emacs signals an "
"@code{arith-error} error (@pxref{Errors}).  Floating-point division of a "
"nonzero number by zero yields either positive or negative infinity "
"(@pxref{Float Basics})."
msgstr "整数を整数0で除すると、Emacsは@code{arith-error}エラー(@ref{Errors}を参照してください)をシグナルします。浮動小数の除算においては、0でない数を0で除することにより、正の無限大または負の無限大を得ます(@ref{Float Basics}を参照してください)。"

#. type: defun
#: numbers.texi.orig:686
#, no-wrap
msgid "% dividend divisor"
msgstr "% dividend divisor"

#. type: cindex
#: numbers.texi.orig:687
#, no-wrap
msgid "remainder"
msgstr "remainder"

#. type: defun
#: numbers.texi.orig:690
msgid ""
"This function returns the integer remainder after division of @var{dividend} "
"by @var{divisor}.  The arguments must be integers or markers."
msgstr "この関数は、@var{dividend}を@var{divisor}で除した後、その剰余を整数でreturnします。引数は整数かマーカーでなければなりません。"

#. type: defun
#: numbers.texi.orig:692
msgid "For any two integers @var{dividend} and @var{divisor},"
msgstr "任意の2つの整数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: numbers.texi.orig:697
#, no-wrap
msgid ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (% @var{dividend} @var{divisor})\n"
"   (* (/ @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: numbers.texi.orig:702
msgid "always equals @var{dividend} if @var{divisor} is nonzero."
msgstr "は、@var{divisor}が非0の場合は常に@var{dividend}と等しくなります。"

#. type: example
#: numbers.texi.orig:712
#, no-wrap
msgid ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(% 9 4)\n"
"     @result{} 1\n"
"(% -9 4)\n"
"     @result{} -1\n"
"(% 9 -4)\n"
"     @result{} 1\n"
"(% -9 -4)\n"
"     @result{} -1\n"

#. type: defun
#: numbers.texi.orig:715
#, no-wrap
msgid "mod dividend divisor"
msgstr "mod dividend divisor"

#. type: cindex
#: numbers.texi.orig:716
#, no-wrap
msgid "modulus"
msgstr "modulus"

#. type: defun
#: numbers.texi.orig:721
msgid ""
"This function returns the value of @var{dividend} modulo @var{divisor}; in "
"other words, the remainder after division of @var{dividend} by "
"@var{divisor}, but with the same sign as @var{divisor}.  The arguments must "
"be numbers or markers."
msgstr "この関数は@var{dividend}の@var{divisor}にたいするmodulo、言い換えると@var{dividend}を@var{divisor}で除した後の剰余(ただし符号は@var{divisor}と同じ)えおreturnします。引数は数かマーカーでなければなりません。"

#. type: defun
#: numbers.texi.orig:725
msgid ""
"Unlike @code{%}, @code{mod} permits floating-point arguments; it rounds the "
"quotient downward (towards minus infinity) to an integer, and uses that "
"quotient to compute the remainder."
msgstr "@code{%}とは異なり、@code{mod}は浮動小数の引数を許容します。これは商を整数に下方(負の無限大に向かって)へ丸めて、剰余を計算するのにこの商を使用します。"

#. type: defun
#: numbers.texi.orig:728
msgid ""
"If @var{divisor} is zero, @code{mod} signals an @code{arith-error} error if "
"both arguments are integers, and returns a NaN otherwise."
msgstr "@var{divisor}が0のとき@code{mod}は、両方の引数が整数の場合は@code{arith-error}エラーをシグナルし、それ以外はNaNをreturnします。"

#. type: group
#: numbers.texi.orig:733
#, no-wrap
msgid ""
"(mod 9 4)\n"
"     @result{} 1\n"
msgstr ""
"(mod 9 4)\n"
"     @result{} 1\n"

#. type: group
#: numbers.texi.orig:737
#, no-wrap
msgid ""
"(mod -9 4)\n"
"     @result{} 3\n"
msgstr ""
"(mod -9 4)\n"
"     @result{} 3\n"

#. type: group
#: numbers.texi.orig:741
#, no-wrap
msgid ""
"(mod 9 -4)\n"
"     @result{} -3\n"
msgstr ""
"(mod 9 -4)\n"
"     @result{} -3\n"

#. type: group
#: numbers.texi.orig:745
#, no-wrap
msgid ""
"(mod -9 -4)\n"
"     @result{} -1\n"
msgstr ""
"(mod -9 -4)\n"
"     @result{} -1\n"

#. type: group
#: numbers.texi.orig:749
#, no-wrap
msgid ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"
msgstr ""
"(mod 5.5 2.5)\n"
"     @result{} .5\n"

#. type: defun
#: numbers.texi.orig:753
msgid "For any two numbers @var{dividend} and @var{divisor},"
msgstr "任意の2つの数@var{dividend}と@var{divisor}にたいして、"

#. type: group
#: numbers.texi.orig:758
#, no-wrap
msgid ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"
msgstr ""
"(+ (mod @var{dividend} @var{divisor})\n"
"   (* (floor @var{dividend} @var{divisor}) @var{divisor}))\n"

#. type: defun
#: numbers.texi.orig:766
msgid ""
"always equals @var{dividend}, subject to rounding error if either argument "
"is floating point and to an @code{arith-error} if @var{dividend} is an "
"integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric "
"Conversions}."
msgstr "は常に@var{dividend}になります(ただし引数のどちらかが浮動小数の場合は丸め誤差の範囲内で等しく、@var{dividend}が整数で@var{divisor}が0の場合は@code{arith-error}となります)。@code{floor}については、@ref{Numeric Conversions}を参照してください。"

#. type: cindex
#: numbers.texi.orig:770
#, no-wrap
msgid "rounding without conversion"
msgstr "rounding without conversion"

#. type: Plain text
#: numbers.texi.orig:778
msgid ""
"The functions @code{ffloor}, @code{fceiling}, @code{fround}, and "
"@code{ftruncate} take a floating-point argument and return a floating-point "
"result whose value is a nearby integer.  @code{ffloor} returns the nearest "
"integer below; @code{fceiling}, the nearest integer above; @code{ftruncate}, "
"the nearest integer in the direction towards zero; @code{fround}, the "
"nearest integer."
msgstr "関数@code{ffloor}、@code{fceiling}、@code{fround}、@code{ftruncate}は、浮動小数の引数をとり、値が近くの整数であるような浮動少数をreturnします。@code{ffloor}は一番近い下方の整数、@code{fceiling}は一番近い上方の整数、@code{ftruncate}は0に向かう方向で一番近い整数、@code{fround}は一番近い整数をreturnします。"

#. type: defun
#: numbers.texi.orig:779
#, no-wrap
msgid "ffloor float"
msgstr "ffloor float"

#. type: defun
#: numbers.texi.orig:782
msgid ""
"This function rounds @var{float} to the next lower integral value, and "
"returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に小さい整数値に丸めて、その値を浮動小数点数としてreturnします。"

#. type: defun
#: numbers.texi.orig:784
#, no-wrap
msgid "fceiling float"
msgstr "fceiling float"

#. type: defun
#: numbers.texi.orig:787
msgid ""
"This function rounds @var{float} to the next higher integral value, and "
"returns that value as a floating-point number."
msgstr "この関数は@var{float}を次に大きい整数値に丸めて、その値を浮動小数点数としてreturnします。"

#. type: defun
#: numbers.texi.orig:789
#, no-wrap
msgid "ftruncate float"
msgstr "ftruncate float"

#. type: defun
#: numbers.texi.orig:792
msgid ""
"This function rounds @var{float} towards zero to an integral value, and "
"returns that value as a floating-point number."
msgstr "この関数は@var{float}を0方向の整数値に丸めて、その値を浮動小数点数としてreturnします。"

#. type: defun
#: numbers.texi.orig:794
#, no-wrap
msgid "fround float"
msgstr "fround float"

#. type: defun
#: numbers.texi.orig:798
msgid ""
"This function rounds @var{float} to the nearest integral value, and returns "
"that value as a floating-point number.  Rounding a value equidistant between "
"two integers returns the even integer."
msgstr "この関数は@var{float}を一番近い整数値に丸めて、その値を浮動小数点数としてreturnします。2つの整数値との距離が等しい値にたいする丸めでは、偶数の整数をreturnします。"

#. type: section
#: numbers.texi.orig:801
#, no-wrap
msgid "Bitwise Operations on Integers"
msgstr "Bitwise Operations on Integers"

#. type: cindex
#: numbers.texi.orig:802
#, no-wrap
msgid "bitwise arithmetic"
msgstr "bitwise arithmetic"

#. type: cindex
#: numbers.texi.orig:803
#, no-wrap
msgid "logical arithmetic"
msgstr "logical arithmetic"

#. type: Plain text
#: numbers.texi.orig:810
msgid ""
"In a computer, an integer is represented as a binary number, a sequence of "
"@dfn{bits} (digits which are either zero or one).  A bitwise operation acts "
"on the individual bits of such a sequence.  For example, @dfn{shifting} "
"moves the whole sequence left or right one or more places, reproducing the "
"same pattern ``moved over''."
msgstr "コンピューターの中では、整数は@dfn{ビット(bit: 0か1の数字)}のシーケンスである、2進数で表されます。ビット演算は、そのようなシーケンスの中の個々のビットに作用します。たとえば、@dfn{シフト(shifting)}はシーケンス全体を1つ以上左または右に移動して、``移動された''のと同じパターンを再生します。"

#. type: Plain text
#: numbers.texi.orig:812
msgid "The bitwise operations in Emacs Lisp apply only to integers."
msgstr "Emacs Lispのビット演算は、整数だけに適用されます。"

#. type: defun
#: numbers.texi.orig:813
#, no-wrap
msgid "lsh integer1 count"
msgstr "lsh integer1 count"

#. type: cindex
#: numbers.texi.orig:814
#, no-wrap
msgid "logical shift"
msgstr "logical shift"

#. type: defun
#: numbers.texi.orig:821
msgid ""
"@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the "
"bits in @var{integer1} to the left @var{count} places, or to the right if "
"@var{count} is negative, bringing zeros into the vacated bits.  If "
"@var{count} is negative, @code{lsh} shifts zeros into the leftmost "
"(most-significant) bit, producing a positive result even if @var{integer1} "
"is negative.  Contrast this with @code{ash}, below."
msgstr "@code{lsh}は@dfn{logical shift}の略で、@var{integer1}のビットを左に@var{count}個シフトします。@var{count}が負の場合は右にシフトし、シフトにより空きになったビットには0がセットされます。@var{count} isが負の場合、@code{lsh}は左端(最上位)に0をシフトするので、@var{integer1}が負の場合でも、正の結果が生成されます。これと対照的なのが、以下で説明する@code{ash}です。"

#. type: defun
#: numbers.texi.orig:825
msgid ""
"Here are two examples of @code{lsh}, shifting a pattern of bits one place to "
"the left.  We show only the low-order eight bits of the binary pattern; the "
"rest are all zero."
msgstr "以下に、@code{lsh}でビットパターンの位置を1つ左にシフトする例を2つ紹介します。ここでは下位8ビットの2進パターンだけを表示しており、残りのビットはすべて0です。"

#. type: group
#: numbers.texi.orig:832
#, no-wrap
msgid ""
"(lsh 5 1)\n"
"     @result{} 10\n"
";; @r{Decimal 5 becomes decimal 10.}\n"
"00000101 @result{} 00001010\n"
"\n"
msgstr ""
"(lsh 5 1)\n"
"     @result{} 10\n"
";; @r{10進の5は、10進の10になります。}\n"
"00000101 @result{} 00001010\n"
"\n"

#. type: group
#: numbers.texi.orig:837
#, no-wrap
msgid ""
"(lsh 7 1)\n"
"     @result{} 14\n"
";; @r{Decimal 7 becomes decimal 14.}\n"
"00000111 @result{} 00001110\n"
msgstr ""
"(lsh 7 1)\n"
"     @result{} 14\n"
";; @r{10進の7は、10進の14になります。}\n"
"00000111 @result{} 00001110\n"

#. type: defun
#: numbers.texi.orig:844
msgid ""
"As the examples illustrate, shifting the pattern of bits one place to the "
"left produces a number that is twice the value of the previous number."
msgstr "この例が説明するように、ビットパターンを左に1シフトすると、生成される数は、元の数の2倍になります。"

#. type: defun
#: numbers.texi.orig:847
msgid ""
"Shifting a pattern of bits two places to the left produces results like this "
"(with 8-bit binary numbers):"
msgstr "ビットパターンを左に2シフトすると、以下(8ビット2進数)の結果が生成されます:"

#. type: group
#: numbers.texi.orig:854
#, no-wrap
msgid ""
"(lsh 3 2)\n"
"     @result{} 12\n"
";; @r{Decimal 3 becomes decimal 12.}\n"
"00000011 @result{} 00001100\n"
msgstr ""
"(lsh 3 2)\n"
"     @result{} 12\n"
";; @r{10進の3は、10進の12になります。}\n"
"00000011 @result{} 00001100\n"

#. type: defun
#: numbers.texi.orig:858
msgid "On the other hand, shifting one place to the right looks like this:"
msgstr "一方、右に1シフトすると、以下のようになります:"

#. type: group
#: numbers.texi.orig:865
#, no-wrap
msgid ""
"(lsh 6 -1)\n"
"     @result{} 3\n"
";; @r{Decimal 6 becomes decimal 3.}\n"
"00000110 @result{} 00000011\n"
msgstr ""
"(lsh 6 -1)\n"
"     @result{} 3\n"
";; @r{10進の6は10進の3になります。}\n"
"00000110 @result{} 00000011\n"

#. type: group
#: numbers.texi.orig:872
#, no-wrap
msgid ""
"(lsh 5 -1)\n"
"     @result{} 2\n"
";; @r{Decimal 5 becomes decimal 2.}\n"
"00000101 @result{} 00000010\n"
msgstr ""
"(lsh 5 -1)\n"
"     @result{} 2\n"
";; @r{10進の5は、10進の2になります。}\n"
"00000101 @result{} 00000010\n"

#. type: defun
#: numbers.texi.orig:878
msgid ""
"As the example illustrates, shifting one place to the right divides the "
"value of a positive integer by two, rounding downward."
msgstr "例が明かにするように、右に1シフトすることにより、正の整数の値が2で除され、下方に丸められます。"

#. type: defun
#: numbers.texi.orig:883
msgid ""
"The function @code{lsh}, like all Emacs Lisp arithmetic functions, does not "
"check for overflow, so shifting left can discard significant bits and change "
"the sign of the number.  For example, left shifting 536,870,911 produces "
"@minus{}2 in the 30-bit implementation:"
msgstr "関数@code{lsh}は、他のEmacs Lisp算術関数と同様、オーバーフローをチェックしないので、左にシフトすることにより上位ビットが捨てられ、その数の符号が変化するかもしれません。たとえば30ビットの実装では、536,870,911を左にシフトすると、@minus{}2が生成されます。"

#. type: example
#: numbers.texi.orig:887
#, no-wrap
msgid ""
"(lsh 536870911 1)          ; @r{left shift}\n"
"     @result{} -2\n"
msgstr ""
"(lsh 536870911 1)          ; @r{左シフト}\n"
"     @result{} -2\n"

#. type: defun
#: numbers.texi.orig:890
msgid "In binary, the argument looks like this:"
msgstr "2進では、この引数は以下のようになります:"

#. type: group
#: numbers.texi.orig:895
#, no-wrap
msgid ""
";; @r{Decimal 536,870,911}\n"
"0111...111111 (30 bits total)\n"
msgstr ""
";; @r{10進の536,870,911}\n"
"0111...111111 (全部で30ビット)\n"

#. type: defun
#: numbers.texi.orig:900
msgid "which becomes the following when left shifted:"
msgstr "これを左にシフトすると、以下のようになります:"

#. type: group
#: numbers.texi.orig:905
#, no-wrap
msgid ""
";; @r{Decimal @minus{}2}\n"
"1111...111110 (30 bits total)\n"
msgstr ""
";; @r{10進の@minus{}2}\n"
"1111...111110 (全部で30ビット)\n"

#. type: defun
#: numbers.texi.orig:909
#, no-wrap
msgid "ash integer1 count"
msgstr "ash integer1 count"

#. type: cindex
#: numbers.texi.orig:910
#, no-wrap
msgid "arithmetic shift"
msgstr "arithmetic shift"

#. type: defun
#: numbers.texi.orig:914
msgid ""
"@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1} to the "
"left @var{count} places, or to the right if @var{count} is negative."
msgstr "@code{ash} (@dfn{算術シフト(arithmetic shift)})は、@var{integer1}の中のビット位置を左に@var{count}シフトします。@var{count}が負の場合は右にシフトします。"

#. type: defun
#: numbers.texi.orig:919
msgid ""
"@code{ash} gives the same results as @code{lsh} except when @var{integer1} "
"and @var{count} are both negative.  In that case, @code{ash} puts ones in "
"the empty bit positions on the left, while @code{lsh} puts zeros in those "
"bit positions."
msgstr "@code{ash}は@code{lsh}と同じ結果を与えますが、例外は@var{integer1}と@var{count}がとみに負の場合です。この場合、@code{lsh}は左にできる空きビットに0を置きますが、@code{ash}は1を置きます。"

#. type: defun
#: numbers.texi.orig:922
msgid ""
"Thus, with @code{ash}, shifting the pattern of bits one place to the right "
"looks like this:"
msgstr "したがって@code{ash}でビットパターンの位置を右に1シフトすると、以下のようになります:"

#. type: group
#: numbers.texi.orig:930
#, no-wrap
msgid ""
"(ash -6 -1) @result{} -3\n"
";; @r{Decimal @minus{}6 becomes decimal @minus{}3.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"1111...111101 (30 bits total)\n"
msgstr ""
"(ash -6 -1) @result{} -3\n"
";; @r{10進の@minus{}6は、10進の@minus{}3になります}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"1111...111101 (30 bits total)\n"

#. type: defun
#: numbers.texi.orig:935
msgid ""
"In contrast, shifting the pattern of bits one place to the right with "
"@code{lsh} looks like this:"
msgstr "対照的に、@code{lsh}でビットパターンの位置を1右にシフトすると、以下のようになります:"

#. type: group
#: numbers.texi.orig:943
#, no-wrap
msgid ""
"(lsh -6 -1) @result{} 536870909\n"
";; @r{Decimal @minus{}6 becomes decimal 536,870,909.}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"0111...111101 (30 bits total)\n"
msgstr ""
"(lsh -6 -1) @result{} 536870909\n"
";; @r{10進の@minus{}6は、10進の536,870,909になります。}\n"
"1111...111010 (30 bits total)\n"
"     @result{}\n"
"0111...111101 (30 bits total)\n"

#. type: defun
#: numbers.texi.orig:947
msgid "Here are other examples:"
msgstr "他にも例を示します:"

#. type: group
#: numbers.texi.orig:953
#, no-wrap
msgid ""
"                   ;  @r{       30-bit binary values}\n"
"\n"
msgstr "                   ;  @r{       30ビットの2進数}\n\n"

#. type: group
#: numbers.texi.orig:956
#, no-wrap
msgid ""
"(lsh 5 2)          ;   5  =  @r{0000...000101}\n"
"     @result{} 20         ;      =  @r{0000...010100}\n"
msgstr ""
"(lsh 5 2)          ;   5  =  @r{0000...000101}\n"
"     @result{} 20         ;      =  @r{0000...010100}\n"

#. type: group
#: numbers.texi.orig:964
#, no-wrap
msgid ""
"(ash 5 2)\n"
"     @result{} 20\n"
"(lsh -5 2)         ;  -5  =  @r{1111...111011}\n"
"     @result{} -20        ;      =  @r{1111...101100}\n"
"(ash -5 2)\n"
"     @result{} -20\n"
msgstr ""
"(ash 5 2)\n"
"     @result{} 20\n"
"(lsh -5 2)         ;  -5  =  @r{1111...111011}\n"
"     @result{} -20        ;      =  @r{1111...101100}\n"
"(ash -5 2)\n"
"     @result{} -20\n"

#. type: group
#: numbers.texi.orig:968
#, no-wrap
msgid ""
"(lsh 5 -2)         ;   5  =  @r{0000...000101}\n"
"     @result{} 1          ;      =  @r{0000...000001}\n"
msgstr ""
"(lsh 5 -2)         ;   5  =  @r{0000...000101}\n"
"     @result{} 1          ;      =  @r{0000...000001}\n"

#. type: group
#: numbers.texi.orig:972
#, no-wrap
msgid ""
"(ash 5 -2)\n"
"     @result{} 1\n"
msgstr ""
"(ash 5 -2)\n"
"     @result{} 1\n"

#. type: group
#: numbers.texi.orig:977
#, no-wrap
msgid ""
"(lsh -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} 268435454\n"
"                   ;      =  @r{0011...111110}\n"
msgstr ""
"(lsh -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} 268435454\n"
"                   ;      =  @r{0011...111110}\n"

#. type: group
#: numbers.texi.orig:981
#, no-wrap
msgid ""
"(ash -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} -2         ;      =  @r{1111...111110}\n"
msgstr ""
"(ash -5 -2)        ;  -5  =  @r{1111...111011}\n"
"     @result{} -2         ;      =  @r{1111...111110}\n"

#. type: defun
#: numbers.texi.orig:985
#, no-wrap
msgid "logand &rest ints-or-markers"
msgstr "logand &rest ints-or-markers"

#. type: defun
#: numbers.texi.orig:990
msgid ""
"This function returns the ``logical and'' of the arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in all "
"the arguments.  (``Set'' means that the value of the bit is 1 rather than "
"0.)"
msgstr "この関数は、引数の``論理積(logical and)''をreturnします。すべての引数の@var{n}番目のビットがセットされている場合に限り、結果の@var{n}番目のビットがセットされます(``セット''とは、そのビットの値が0ではなく1であることを意味します)。"

#. type: defun
#: numbers.texi.orig:997
msgid ""
"For example, using 4-bit binary numbers, the ``logical and'' of 13 and 12 is "
"12: 1101 combined with 1100 produces 1100.  In both the binary numbers, the "
"leftmost two bits are set (i.e., they are 1's), so the leftmost two bits of "
"the returned value are set.  However, for the rightmost two bits, each is "
"zero in at least one of the arguments, so the rightmost two bits of the "
"returned value are 0's."
msgstr "たとえば、13と12の``論理積''は --- 4ビット2進数を使用すると1101と1100の論理積は1100を生成します。この2進数では両方とも、左の2ビットがセット(つまり1)されているので、returnされる値の左2ビットがセットされます。しかし右の2ビットにたいしては、少なくとも1つの引数でそのビットが0なので、returnされる値の右2ビットは0になります。"

#. type: defun
#: numbers.texi.orig:1000
msgid "Therefore,"
msgstr "したがって、"

#. type: group
#: numbers.texi.orig:1005
#, no-wrap
msgid ""
"(logand 13 12)\n"
"     @result{} 12\n"
msgstr ""
"(logand 13 12)\n"
"     @result{} 12\n"

#. type: defun
#: numbers.texi.orig:1012
msgid ""
"If @code{logand} is not passed any argument, it returns a value of "
"@minus{}1.  This number is an identity element for @code{logand} because its "
"binary representation consists entirely of ones.  If @code{logand} is passed "
"just one argument, it returns that argument."
msgstr "@code{logand}に何の引数も綿さない場合は、値@minus{}1がreturnされます。@minus{}1を2進数で表すとすべてのビットが1なので、@minus{}1は@code{logand}にたいする単位元(identity element)です。"

#. type: group
#: numbers.texi.orig:1016 numbers.texi.orig:1046 numbers.texi.orig:1071
#, no-wrap
msgid ""
"                   ; @r{       30-bit binary values}\n"
"\n"
msgstr "                   ; @r{       30ビット2進数}\n\n"

#. type: group
#: numbers.texi.orig:1020
#, no-wrap
msgid ""
"(logand 14 13)     ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"     @result{} 12         ; 12  =  @r{0000...001100}\n"
msgstr ""
"(logand 14 13)     ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"     @result{} 12         ; 12  =  @r{0000...001100}\n"

#. type: group
#: numbers.texi.orig:1027
#, no-wrap
msgid ""
"(logand 14 13 4)   ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"                   ;  4  =  @r{0000...000100}\n"
"     @result{} 4          ;  4  =  @r{0000...000100}\n"
msgstr ""
"(logand 14 13 4)   ; 14  =  @r{0000...001110}\n"
"                   ; 13  =  @r{0000...001101}\n"
"                   ;  4  =  @r{0000...000100}\n"
"     @result{} 4          ;  4  =  @r{0000...000100}\n"

#. type: group
#: numbers.texi.orig:1032
#, no-wrap
msgid ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{1111...111111}\n"
msgstr ""
"(logand)\n"
"     @result{} -1         ; -1  =  @r{1111...111111}\n"

#. type: defun
#: numbers.texi.orig:1036
#, no-wrap
msgid "logior &rest ints-or-markers"
msgstr "logior &rest ints-or-markers"

#. type: defun
#: numbers.texi.orig:1042
msgid ""
"This function returns the ``inclusive or'' of its arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in at "
"least one of the arguments.  If there are no arguments, the result is zero, "
"which is an identity element for this operation.  If @code{logior} is passed "
"just one argument, it returns that argument."
msgstr "この関数は、引数の``論理和(inclusive or)''をreturnします。少なくとも1つの引数で@var{n}番目のビットがセットされていれば、結果の@var{n}番目のビットがセットされます。引数を与えない場合の結果は、この処理にたいする単位元である0です。@code{logior}に渡す引数が1つだけの場合、その引数がreturnされます。"

#. type: group
#: numbers.texi.orig:1050
#, no-wrap
msgid ""
"(logior 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 13         ; 13  =  @r{0000...001101}\n"
msgstr ""
"(logior 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 13         ; 13  =  @r{0000...001101}\n"

#. type: group
#: numbers.texi.orig:1057
#, no-wrap
msgid ""
"(logior 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 15         ; 15  =  @r{0000...001111}\n"
msgstr ""
"(logior 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 15         ; 15  =  @r{0000...001111}\n"

#. type: defun
#: numbers.texi.orig:1061
#, no-wrap
msgid "logxor &rest ints-or-markers"
msgstr "logxor &rest ints-or-markers"

#. type: defun
#: numbers.texi.orig:1067
msgid ""
"This function returns the ``exclusive or'' of its arguments: the @var{n}th "
"bit is set in the result if, and only if, the @var{n}th bit is set in an odd "
"number of the arguments.  If there are no arguments, the result is 0, which "
"is an identity element for this operation.  If @code{logxor} is passed just "
"one argument, it returns that argument."
msgstr "この関数は、引数の``排他的論理和(exclusive or)''をreturnします。@var{n}番目のビットがセットされている引数の数が奇数個の場合だけ、結果の@var{n}番目のビットがセットされます。引数を与えない場合の結果は、この処理の単位元である0となります。@code{logxor}に渡す引数が1つだけの場合、その引数がreturnされます。"

#. type: group
#: numbers.texi.orig:1075
#, no-wrap
msgid ""
"(logxor 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 9          ;  9  =  @r{0000...001001}\n"
msgstr ""
"(logxor 12 5)      ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"     @result{} 9          ;  9  =  @r{0000...001001}\n"

#. type: group
#: numbers.texi.orig:1082
#, no-wrap
msgid ""
"(logxor 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 14         ; 14  =  @r{0000...001110}\n"
msgstr ""
"(logxor 12 5 7)    ; 12  =  @r{0000...001100}\n"
"                   ;  5  =  @r{0000...000101}\n"
"                   ;  7  =  @r{0000...000111}\n"
"     @result{} 14         ; 14  =  @r{0000...001110}\n"

#. type: defun
#: numbers.texi.orig:1086
#, no-wrap
msgid "lognot integer"
msgstr "lognot integer"

#. type: defun
#: numbers.texi.orig:1090
msgid ""
"This function returns the logical complement of its argument: the @var{n}th "
"bit is one in the result if, and only if, the @var{n}th bit is zero in "
"@var{integer}, and vice-versa."
msgstr "この関数は引数の論理的な補数(logical complement)をreturnします。@var{integer}の@var{n}番目のビットが0の場合に限り、結果の@var{n}番目のビットが1になります。逆も成り立ちます。"

#. type: example
#: numbers.texi.orig:1097
#, no-wrap
msgid ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{0000...000101} (30 bits total)\n"
";; @r{becomes}\n"
";; -6  =  @r{1111...111010} (30 bits total)\n"
msgstr ""
"(lognot 5)\n"
"     @result{} -6\n"
";;  5  =  @r{0000...000101} (全部で30ビット)\n"
";; @r{becomes}\n"
";; -6  =  @r{1111...111010} (全部で30ビット)\n"

#. type: section
#: numbers.texi.orig:1101
#, no-wrap
msgid "Standard Mathematical Functions"
msgstr "Standard Mathematical Functions"

#. type: cindex
#: numbers.texi.orig:1102
#, no-wrap
msgid "transcendental functions"
msgstr "transcendental functions"

#. type: cindex
#: numbers.texi.orig:1103
#, no-wrap
msgid "mathematical functions"
msgstr "mathematical functions"

#. type: cindex
#: numbers.texi.orig:1104
#, no-wrap
msgid "floating-point functions"
msgstr "floating-point functions"

#. type: Plain text
#: numbers.texi.orig:1108
msgid ""
"These mathematical functions allow integers as well as floating-point "
"numbers as arguments."
msgstr "これらの数学的関数は、引き数として整数と同様に浮動小数点数も許容します。"

#. type: defun
#: numbers.texi.orig:1109
#, no-wrap
msgid "sin arg"
msgstr "sin arg"

#. type: defunx
#: numbers.texi.orig:1110
#, no-wrap
msgid "cos arg"
msgstr "cos arg"

#. type: defunx
#: numbers.texi.orig:1111
#, no-wrap
msgid "tan arg"
msgstr "tan arg"

#. type: defun
#: numbers.texi.orig:1114
msgid ""
"These are the basic trigonometric functions, with argument @var{arg} "
"measured in radians."
msgstr "これらは三角関数です、引数@var{arg}はラジアン単位です。"

#. type: defun
#: numbers.texi.orig:1116
#, no-wrap
msgid "asin arg"
msgstr "asin arg"

#. type: defun
#: numbers.texi.orig:1118
msgid "The value of @code{(asin @var{arg})} is a number between"
msgstr "@code{(asin @var{arg})}の値は、sinの値が@var{arg}となるような"

#. type: ifnottex
#: numbers.texi.orig:1120 numbers.texi.orig:1151
msgid "@minus{}pi/2"
msgstr "@minus{}pi/2"

#. type: tex
#: numbers.texi.orig:1123 numbers.texi.orig:1154
#, no-wrap
msgid "@math{-\\pi/2}\n"
msgstr "@math{-\\pi/2}\n"

#. type: defun
#: numbers.texi.orig:1125 numbers.texi.orig:1156
msgid "and"
msgstr "から"

#. type: ifnottex
#: numbers.texi.orig:1127 numbers.texi.orig:1158
msgid "pi/2"
msgstr "pi/2"

#. type: tex
#: numbers.texi.orig:1130 numbers.texi.orig:1161
#, no-wrap
msgid "@math{\\pi/2}\n"
msgstr "@math{\\pi/2}\n"

#. type: defun
#: numbers.texi.orig:1133
msgid ""
"(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range (outside "
"[@minus{}1, 1]), @code{asin} returns a NaN."
msgstr "(境界値を含む)の数です。@var{arg}が範囲外([@minus{}1, 1]の外)の場合、@code{asin}はNaNをreturnします。"

#. type: defun
#: numbers.texi.orig:1135
#, no-wrap
msgid "acos arg"
msgstr ""

#. type: defun
#: numbers.texi.orig:1137
msgid "The value of @code{(acos @var{arg})} is a number between 0 and"
msgstr "@code{(acos @var{arg})}の値は、cosの値が@var{arg}となるような、0から"

#. type: ifnottex
#: numbers.texi.orig:1139
msgid "pi"
msgstr "pi"

#. type: tex
#: numbers.texi.orig:1142
#, no-wrap
msgid "@math{\\pi}\n"
msgstr "@math{\\pi}\n"

#. type: defun
#: numbers.texi.orig:1145
msgid ""
"(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range "
"(outside [@minus{}1, 1]), @code{acos} returns a NaN."
msgstr "(境界値を含む)の数です。argが範囲外([-1, 1]の外)の場合、@code{acos}はNaNをreturnします。"

#. type: defun
#: numbers.texi.orig:1147
#, no-wrap
msgid "atan y &optional x"
msgstr "atan y &optional x"

#. type: defun
#: numbers.texi.orig:1149
msgid "The value of @code{(atan @var{y})} is a number between"
msgstr "@code{(atan @var{y})}の値は、tanの値が@var{y}となるような、"

#. type: defun
#: numbers.texi.orig:1166
msgid ""
"(exclusive) whose tangent is @var{y}.  If the optional second argument "
"@var{x} is given, the value of @code{(atan y x)} is the angle in radians "
"between the vector @code{[@var{x}, @var{y}]} and the @code{X} axis."
msgstr "(境界値を含まない)の数です。オプションの第2引数@var{x}が与えられた場合、@code{(atan y x)}の値はベクトル@code{[@var{x}, @var{y}]}と@code{X}軸が成す角度のラジアン値です。"

#. type: defun
#: numbers.texi.orig:1168
#, no-wrap
msgid "exp arg"
msgstr "exp arg"

#. type: defun
#: numbers.texi.orig:1171
msgid ""
"This is the exponential function; it returns @math{e} to the power "
"@var{arg}."
msgstr "これは指数関数です。この関数は@math{e}の指数@var{arg}をreturnします。"

#. type: defun
#: numbers.texi.orig:1173
#, no-wrap
msgid "log arg &optional base"
msgstr "log arg &optional base"

#. type: defun
#: numbers.texi.orig:1178
msgid ""
"This function returns the logarithm of @var{arg}, with base @var{base}.  If "
"you don't specify @var{base}, the natural base @math{e} is used.  If "
"@var{arg} or @var{base} is negative, @code{log} returns a NaN."
msgstr "この関数は底を@var{base}とする@var{arg}の対数をreturnします。@var{base}を指定しない場合、自然底(natural base)@math{e}が使用されます。@var{arg}またh@var{base}が負の場合、@code{log}はNaNをreturnします。"

#. type: defun
#: numbers.texi.orig:1180
#, no-wrap
msgid "expt x y"
msgstr "expt x y"

#. type: defun
#: numbers.texi.orig:1186
msgid ""
"This function returns @var{x} raised to power @var{y}.  If both arguments "
"are integers and @var{y} is positive, the result is an integer; in this "
"case, overflow causes truncation, so watch out.  If @var{x} is a finite "
"negative number and @var{y} is a finite non-integer, @code{expt} returns a "
"NaN."
msgstr "この関数は@var{x}に@var{y}を乗じてreturnします。引数が両方とも整数で、@var{y}が正の場合、結果は整数になります。この場合オーバーフローによる切り捨てが発生するので、注意してください。@var{x}が有限の負数で、@var{y}が有限の非整数の場合、@code{expt}はNaNをreturnします。"

#. type: defun
#: numbers.texi.orig:1188
#, no-wrap
msgid "sqrt arg"
msgstr "sqrt arg"

#. type: defun
#: numbers.texi.orig:1191
msgid ""
"This returns the square root of @var{arg}.  If @var{arg} is finite and less "
"than zero, @code{sqrt} returns a NaN."
msgstr "これは@var{arg}の平方根をreturnします。@var{arg}が有限で0より小さい場合、@code{sqrt}はNaNをreturnします。"

#. type: Plain text
#: numbers.texi.orig:1195
msgid "In addition, Emacs defines the following common mathematical constants:"
msgstr "加えて、Emacsは以下の数学的な定数を定義します:"

#. type: defvar
#: numbers.texi.orig:1196
#, no-wrap
msgid "float-e"
msgstr "float-e"

#. type: defvar
#: numbers.texi.orig:1198
msgid "The mathematical constant @math{e} (2.71828@dots{})."
msgstr "自然対数@math{e}(2.71828@dots{})。"

#. type: defvar
#: numbers.texi.orig:1200
#, no-wrap
msgid "float-pi"
msgstr ""

#. type: defvar
#: numbers.texi.orig:1202
msgid "The mathematical constant @math{pi} (3.14159@dots{})."
msgstr "円周率@math{pi}(3.14159@dots{})。"

#. type: cindex
#: numbers.texi.orig:1206
#, no-wrap
msgid "random numbers"
msgstr "random numbers"

#. type: Plain text
#: numbers.texi.orig:1214
msgid ""
"A deterministic computer program cannot generate true random numbers.  For "
"most purposes, @dfn{pseudo-random numbers} suffice.  A series of "
"pseudo-random numbers is generated in a deterministic fashion.  The numbers "
"are not truly random, but they have certain properties that mimic a random "
"series.  For example, all possible values occur equally often in a "
"pseudo-random series."
msgstr "決定論的なコンピュータープログラムでは、真の乱数を生成することはできません。しかしほとんどの目的には、@dfn{疑似乱数(pseudo-random numbers)}で充分です。一連の疑似乱数は、決定論的な手法により生成されます。真の乱数ではありませんが、それらにはランダム列を模する特別な性質があります。たとえば疑似ランダム系では、すべての可能な値は、均等に発生します。"

#. type: Plain text
#: numbers.texi.orig:1220
msgid ""
"Pseudo-random numbers are generated from a ``seed''.  Starting from any "
"given seed, the @code{random} function always generates the same sequence of "
"numbers.  By default, Emacs initializes the random seed at startup, in such "
"a way that the sequence of values of @code{random} (with overwhelming "
"likelihood) differs in each Emacs run."
msgstr "疑似乱数は``シード(seed: 種)''から生成されます。与えられた任意のシードから開始することにより、@code{random}関数は常に同じ数列を生成します。デフォルトでは、Emacsは開始時に乱数シードを初期化することにより、それぞれのEmacsの実行において、@code{random}の値シーケンスは(ほとんど確実に)異なります。"

#. type: Plain text
#: numbers.texi.orig:1228
msgid ""
"Sometimes you want the random number sequence to be repeatable.  For "
"example, when debugging a program whose behavior depends on the random "
"number sequence, it is helpful to get the same behavior in each program "
"run.  To make the sequence repeat, execute @code{(random \"\")}.  This sets "
"the seed to a constant value for your particular Emacs executable (though it "
"may differ for other Emacs builds).  You can use other strings to choose "
"various seed values."
msgstr "再現可能な乱数シーケンスが欲しい場合もあります。たとえば乱数シーケンスに依存するプログラムをデバッグする場合、プログラムの各実行において同じ挙動を得ることが助けになります。再現可能なシーケンスを作成するには、@code{(random \"\")}を実行します。これは特定のEmacsの実行可能ファイルにたいして、シードに定数値をセットします(しかし、この実行可能ファイルは、その他のEmacsビルドと異なるものになるでしょう)。シード値として、他のさまざまな文字列を使用することができます。"

#. type: defun
#: numbers.texi.orig:1229
#, no-wrap
msgid "random &optional limit"
msgstr "random &optional limit"

#. type: defun
#: numbers.texi.orig:1232
msgid ""
"This function returns a pseudo-random integer.  Repeated calls return a "
"series of pseudo-random integers."
msgstr "この関数は疑似乱数の整数をreturnします。繰り返し呼び出すと、一連の疑似乱数の整数をreturnします。"

#. type: defun
#: numbers.texi.orig:1238
msgid ""
"If @var{limit} is a positive integer, the value is chosen to be nonnegative "
"and less than @var{limit}.  Otherwise, the value might be any integer "
"representable in Lisp, i.e., an integer between @code{most-negative-fixnum} "
"and @code{most-positive-fixnum} (@pxref{Integer Basics})."
msgstr "@var{limit}が正の整数の場合、値は負ではない@var{limit}未満の値から選択されます。それ以外では、値は@code{most-negative-fixnum}から@code{most-positive-fixnum}の間の、Lispで表現可能な任意の整数(@ref{Integer Basics}を参照してください)になるでしょう。"

#. type: defun
#: numbers.texi.orig:1241
msgid ""
"If @var{limit} is @code{t}, it means to choose a new seed as if Emacs were "
"restarting."
msgstr "@var{limit}が@code{t}の場合は、Emacsを再起動したときに、新しいシードを選択することを意味します。"

#. type: defun
#: numbers.texi.orig:1244
msgid ""
"If @var{limit} is a string, it means to choose a new seed based on the "
"string's contents."
msgstr "@var{limit}が文字列の場合、その文字列定数にもとづいた新しいシードを選択することを意味します。"
