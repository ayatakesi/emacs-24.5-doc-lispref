@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lisp Data Types
@chapter Lispのデータ型
@cindex object
@cindex Lisp object
@cindex type
@cindex data type

  Lispの@dfn{オブジェクト(object)}とは、Lispおプログラムにより操作されるデータです。@dfn{型(type)}や@dfn{データ型(data
type)}は、可能なオブジェクトの集合を意味します。

  すべてのオブジェクトは少なくとも1つの型に属します。同じ型のオブジェクトは、同様な構造をもち、通常は同じコンテキストで使用されます。型は重複でき、オブジェクトは複数の型に属することができます。結果として、あるオブジェクトが特定の型に属するかどうかを尋ねることはできますが、オブジェクトが``その''型だけに属するかどうかは決定できません。

@cindex primitive type
  多くはありませんがEmacsにはいくつかの基本オブジェクト型が組み込まれています。これらの型は、他のすべての型を構成するもとであり、@dfn{基本型(primitive
types)}と呼ばれます。すべてのオブジェクトはただ1つの基本型に属します。これらの型には、@dfn{整数(integer)}、@dfn{浮動小数点数(float)}、@dfn{コンス(cons)}、@dfn{シンボル(symbol)}、@dfn{文字列(string)}、@dfn{ベクター(vector)}、@dfn{ハッシュテーブル(hash-table)}、@dfn{サブルーチン(subr)}、@dfn{バイトコード関数(byte-code
function)}、および@dfn{buffer}のような編集に関連した特別な型(@ref{Editing
Types}を参照してください)が含まれます。

  基本型にはそれぞれ、オブジェクトがその型のメンバーかどうかのチェックを行なう、対応するLisp関数があります。

  他の多くの言語とは異なり、Lispのオブジェクトは@dfn{自己記述(self-typing)}的です。オブジェクトの基本型は、オブジェクト自体に暗に含まれます。たとえばオブジェクトがベクターの場合、それを数字として扱うことはできません。Lispはベクターが数字でないことを知っているのです。

  多くの言語では、プログラマーは各変数にたいしてデータ型を宣言しなければならず、コンパイラーは型を知っていますが、データの中に型はありません。Emacs
Lispには、このような型宣言はありません。Lisp変数は任意の型の値をもつことができ、変数に保存した値と型を記憶します(実際には、特定の型の値だけをもつことができる少数のEmacs
Lisp変数があります。@ref{Variables with Restricted Values}を参照してください)。

  このチャプターでは、GNU Emacs Lispの各標準型の意味、プリント表現(printed representation)、入力構文(read
syntax)を説明します。これらのデータ型を使用する方法についての詳細は、以降のチャプターを参照してください。

@menu
* Printed Representation::   Lispオブジェクトがテキストとして表現される方法。
* Comments::                 コメントとコメント書式の慣例。
* Programming Types::        すべてのLispシステムに存在する型。
* Editing Types::            Emacs固有の型。
* Circular Objects::         循環構造にたいする入力構文。
* Type Predicates::          型に関連するテスト。
* Equality Predicates::      2つのオブジェクトが等しいかのテスト。
@end menu

@node Printed Representation
@section プリント表現と読み取り構文
@cindex printed representation
@cindex read syntax

  オブジェクトのプリント表現(printed
representation)とは、オブジェクトにたいしてLispプリンター(関数@code{prin1})が生成する出力のフォーマットです。すべてのデータ型は一意なプリント表現をもちます。オブジェクトの@dfn{入力構文(read
syntax)}とは、オブジェクトにたいしてLispリーダー(関数@code{read})が受け取る入力のフォーマットです。これは一意である必要はありません。多くの種類のオブジェクトが複数の構文をもちます。@ref{Read
and Print}を参照してください。

@cindex hash notation
  ほとんどの場合、オブジェクトのプリント表記が、入力構文としても使用されます。しかしLispプログラム内の定数とすることに意味が無いいくつかの型には、入力構文がありません。これらのオブジェクトは@dfn{ハッシュ表記(hash
notation)}でプリントされ、@samp{#<}、説明的な文字列(典型的には型名にオブジェクトの名前を続けたもの)、@samp{>}で構成される文字列です。たとえば:

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@noindent
ハッシュ表気は読み取ることができないので、Lispリーダーは@samp{#<}に遭遇すると、常にエラー@code{invalid-read-syntax}をシグナルします。
@kindex invalid-read-syntax

  他の言語では、式はテキストであり、これ以外の形式はありません。Lispでは、第一に式はLispオブジェクトであって、オブジェクトの入力構文であるテキストは副次的なものに過ぎません。たいてい、この違いを強調する必要はありませんが、このことを心に留めておかないと、たまに混乱することがあるでしょう。

  インタラクティブに式を評価するとき、Lispインタープリターは最初にそれのテキスト表現を読み取り、Lispオブジェクトを生成してから、そのオブジェクトを評価します(@ref{Evaluation}を参照してください)。しかし評価と読み取りは、別の処理です。読み取りによりテキストにより表現されたLispオブジェクトを読み取り、Lispオブジェクトがreturnされます。後でオブジェクトは評価されるかもしれないし、評価されないかもしれません。オブジェクトを読み取るための基本的な関数@code{read}の説明は、@ref{Input
Functions}を参照してください。

@node Comments
@section コメント
@cindex comments
@cindex @samp{;} in comment

  @dfn{コメント(comment)}hqあ、プログラム中に記述されたテキストであり、そのプログラムを読む人間ためだけに存在し、プログラムの意味には何の影響ももちません。Lispでは、それが文字列や文字定数にある場合をのぞき、セミコロン(@samp{;})でコメントが開始されます。行の終端までがコメントになります。Lispリーダーはコメントを破棄します。コメントはLispシステム内でプログラムを表すLispオブジェクトの一部にはなりません。

  @samp{#@@@var{count}}構成は、次の@var{count}個の文字をスキップします。これはプログラムにより生成されたバイナリーデータを含むコメントにたいして有用です。Emacs
Lisp倍とコンパイラーは、出力ファイルにこれを使用します(@ref{Byte
Compilation}を参照してください)。しかしソースファイル用ではありません。

  コメントのフォーマットにたいする慣例は、@ref{Comment Tips}を参照してください。

@node Programming Types
@section プログラミングの型
@cindex programming types

  Emacs
Lispには2種類の一般的な型があります。1つはLispプログラミングに関わるもので、もう1つは編集に関わるものです。前者はさまざまな形で多くのLisp実装に存在します。後者はEmacs
Lispに固有です。

@menu
* Integer Type::             小数部のない数字。
* Floating-Point Type::      広い範囲をもつ、小数部をもつ数字。
* Character Type::           文字、数字、コントロール文字にたいする表現。
* Symbol Type::              関数、変数、プロパティーリストを参照する、一意に識別される多目的オブジェクト。
* Sequence Type::            リストと配列はどちらもシーケンスに分類される。
* Cons Cell Type::           コンスセル、および(コンスセルにより作られる)リスト。
* Array Type::               配列には文字列とベクターが含まれる。
* String Type::              (効率的な)文字の配列。
* Vector Type::              1次元の配列。
* Char-Table Type::          文字によりインデックスされる1次元の疎な配列。
* Bool-Vector Type::         @code{t}と@code{nil}からなる、1次元の配列。
* Hash Table Type::          とても高速な参照用のテーブル。
* Function Type::            他の場所から呼び出せる実行可能なコードの断片。
* Macro Type::               より基本的だが少し見栄えの悪い、式を他の式に展開する手法。
* Primitive Function Type::  Lispから呼び出せる、Cで記述された関数。
* Byte-Code Type::           Lispで記述されてからコンパイルされた関数。
* Autoload Type::            頻繁に使用されない関数を自動的にロードするために使用される型。
@end menu

@node Integer Type
@subsection 整数型

  整数の値の範囲はマシンに依存します、最小のレンジは@minus{}536,870,912から536,870,911(30ビットでは
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
から
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
ですが、多くのマシンはこれより広い範囲を提供します。Emacs
Lispの数学関数は整数のオーバーフローをチェックしません。したがってEmacsのh整数が30ビットの場合、@code{(1+
536870911)}は@minus{}536,870,912になります。

  整数にたいする入力構文は、(10を基数とする)数字のシーケンスで、オプションで先頭に符号、最後にピリオドがつきます。Lispインタープリターにより生成されるプリント表記には、先頭の
@samp{+}や、最後の@samp{.}はありません。

@example
@group
-1               ; @r{整数の@minus{}1.}
1                ; @r{整数の1.}
1.               ; @r{これも整数の1.}
+1               ; @r{これも整数の1.}
@end group
@end example

@noindent
特別な例外として、数字シーケンスが有効なオブジェクトとしては大きすぎる、または小さすぎる整数を指定する場合、Lispリーダーはそれを浮動小数点数(@ref{Floating-Point
Type}を参照してください)として読み取ります。たとえば、Emacsの整数が30ビットの場合、@code{536870912}は浮動小数点数の@code{536870912.0}として読み取られます。

  詳細は、@ref{Numbers}を参照してください。

@node Floating-Point Type
@subsection 浮動小数点数型

  浮動小数点数は、コンピューターにおける科学表記に相当するものです。浮動小数点数を10の指数をともなう有理数として考えることができます。正確な有効桁数と可能な指数は、マシン固有です。Emacsは値の保存にCデータ型の@code{double}を使用し、内部的には10の指数ではなく、2の指数として記録します。

  浮動小数点数のプリント表現には、(後に最低1つの数字をともなう)小数点と、指数のどちらか一方、または両方が必要です。たとえば@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は、いずれも浮動小数点数の1500を記述し、これらはすべて等価です。

  詳細は、@ref{Numbers}を参照してください。

@node Character Type
@subsection 文字型
@cindex @acronym{ASCII} character codes

  Emacs
Lispでの@dfn{文字(character)}は、整数以外の何者でもありません。他の言い方をすると、文字は文字コードで表現されます。たとえば文字@kbd{A}は、@w{整数の65}として表現されます。

  プログラムで文字を個別に使用するのは稀であり、文字のシーケンスとして構成される@emph{文字列(strings)}として扱われるのがより一般的です。@ref{String
Type}を参照してください。

  文字列やバッファーの中の文字は、現在のところ0から4194303の範囲 --- つまり22ビットに制限されています(@ref{Character
Codes}を参照してください)。0から127のコードは@acronym{ASCII}コードで、残りは非@acronym{ASCII}です(@ref{Non-ASCII
Characters}を参照してください)。キーボード入力を表す文字は、Control、Meta、Shiftなどの修飾キーをエンコードするために、より広い範囲をもちます。

  メッセージのために、文字にたいして人間が読むことができるテキストによる説明を生成する特別な関数が存在します。@ref{Describing
Characters}を参照してください。

@menu
* Basic Char Syntax::        標準的な文字の構文。
* General Escape Syntax::    文字をコードにより指定する方法。
* Ctl-Char Syntax::          コントロール文字の構文。
* Meta-Char Syntax::         メタ文字の構文。
* Other Char Bits::          ハイパー、スーパー、アルト文字の構文。
@end menu

@node Basic Char Syntax
@subsubsection 基本的な文字構文
@cindex read syntax for characters
@cindex printed representation for characters
@cindex syntax for characters
@cindex @samp{?} in character constant
@cindex question mark in character constant

  文字は実際には整数なので、文字のプリント表現は10進数です。文字にたいする入力構文も利用可能ですが、Lispプログラムでこの方法により文字を記述するのは、明解なプログラミングではありません。文字にたいしては、Emacs
Lispが提供する、特別な入力構文を@emph{常に}使用するべきです。これらの構文フォーマットはクエスチョンマークで開始されます。

  英数字にたいする通常の入力構文は、クエスチョンマークと、その後にその文字を記述します。したがって文字@kbd{A}にたいしては@samp{?A}、文字@kbd{B}にたいしては@samp{?B}、文字@kbd{a}にたいしては@samp{?a}となります。

  たとえば:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  句読点文字にも同じ構文を使用できますが、Lispコードを編集するためのEmacsコマンドが混乱しないように、@samp{\}を追加するのがよい場合がしばしばあります。たとえば開きカッコを記述するために@samp{?\(}と記述します。その文字が@samp{\}の場合、それをクォートするために、@samp{?\\}のように2つ目の@samp{\}を使用しなければ@emph{なりません}。

@cindex whitespace
@cindex bell character
@cindex @samp{\a}
@cindex backspace
@cindex @samp{\b}
@cindex tab (ASCII character)
@cindex @samp{\t}
@cindex vertical tab
@cindex @samp{\v}
@cindex formfeed
@cindex @samp{\f}
@cindex newline
@cindex @samp{\n}
@cindex return (ASCII character)
@cindex @samp{\r}
@cindex escape (ASCII character)
@cindex @samp{\e}
@cindex space (ASCII character)
@cindex @samp{\s}
  control-g、backspace、tab、newline、vertical
tab、formfeed、space、return、del、escapeはそれぞれ@samp{?\a}、@samp{?\b}、@samp{?\t}、@samp{?\n}、@samp{?\v}、@samp{?\f}、@samp{?\s}、@samp{?\r}、@samp{?\d}、@samp{?\e}と表すことができます(後にダッシュのついた@samp{?\s}は違う意味をもちます
--- これは後続の文字にたいして``super''の修飾を適用します)。したがって、

@example
?\a @result{} 7                 ; @r{control-g, @kbd{C-g}}
?\b @result{} 8                 ; @r{backspace, @key{BS}, @kbd{C-h}}
?\t @result{} 9                 ; @r{tab, @key{TAB}, @kbd{C-i}}
?\n @result{} 10                ; @r{newline, @kbd{C-j}}
?\v @result{} 11                ; @r{vertical tab, @kbd{C-k}}
?\f @result{} 12                ; @r{formfeed character, @kbd{C-l}}
?\r @result{} 13                ; @r{carriage return, @key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{escape character, @key{ESC}, @kbd{C-[}}
?\s @result{} 32                ; @r{space character, @key{SPC}}
?\\ @result{} 92                ; @r{backslash character, @kbd{\}}
?\d @result{} 127               ; @r{delete character, @key{DEL}}
@end example

@cindex escape sequence
  バックスラッシュが``エスケープ文字(escape
character)''の役割を果たすので、これらのバックスラッシュで始まるシーケンスは@dfn{エスケープシーケンス(escape
sequences)}とも呼ばれます。この用語法は、文字@key{ESC}とは関係ありません。@samp{\s}は文字定数としての使用を意図しており、文字定数の内部では、単にスペースを記述します。

  エスケープという特別な意味を与えずに、任意の文字の前にバックスラッシュの使用することは許されており、害もありませんしたがって@samp{?\+}は@samp{?+}と等価です。ほとんどの文字の前にバックスラッシュを追加することに理由はありません。しかし、Lispコードを編集するEmacsコマンドが混乱するのを避けるために、文字@samp{()\|;'`"#.,}の前にはバックスラッシュを追加するべきです。space、tab、newline、formfeedのような空白文字の前にもバックスラッシュを追加できます。しかし、tabやspaceのような実際の空白文字のかわりに、@samp{\t}や@samp{\s}のような可読性のあるエスケープシーケンスを使用するほうが明解です(スペースを後にともなうバックスラッシュを記述する場合、後続のテキストと区別するために、文字定数の後に余分なスペースを記述するべきです)。

@node General Escape Syntax
@subsubsection 一般的なエスケープ構文

  特に重要なコントロール文字にたいする特別なエスケープシーケンスに加えて、Emacsは非@acronym{ASCII}テキスト文字の指定に使用できる、何種類かのエスケープ構文を提供します。

@cindex @samp{\} in character constant
@cindex backslash in character constants
@cindex unicode character escape
  最初に、文字をUnicodeの値で指定することができます。@code{?\u@var{nnnn}}はUnicodeのコードポイント@samp{U+@var{nnnn}}の文字を表します。ここで@var{nnnn}は、(慣例により)正確に4桁の16進数です。バックスラッシュは、後続の文字がエスケープシーケンスを形成することを示し、@samp{u}はUnicodeエスケープシーケンスを指定します。

  @code{U+@var{ffff}}より大きなコードポイントをもつUnicode文字を指定するために、若干異なる構文が存在します。@code{?\U00@var{nnnnnn}}はコードポイント@samp{U+@var{nnnnnn}}の文字を表します。ここで@var{nnnnnn}は6桁の16進数です。Unicode
Standardは@samp{U+@var{10ffff}}までのコードポイントだけを定義するので、これより大きいコードポイントを指定すると、Emacsはエラーをシグナルします。

  次に、文字を16進の文字コードで指定できます。16進エスケープシーケンスは、バックスラッシュ、@samp{x}、および16進の文字コードにより構成されます。したがって@samp{?\x41}は文字@kbd{A}、@samp{?\x1}は文字@kbd{C-a}、@code{?\xe0}は
@iftex
文字@samp{@`a}を表します。
@end iftex
@ifnottex
grave accentつきの文字@samp{a}を表します。
@end ifnottex
任意の数の16進数を使用できるので、この方法により任意の文字コードを表すことができます。

@cindex octal character code
  最後に、8進の文字コードにより文字を指定できます。8進エスケープシーケンスは、3桁までの8進数字をともなうバックスラッシュにより形成されます。したがって@samp{?\101}は文字@kbd{A}、@samp{?\001}は文字@kbd{C-a}、@code{?\002}は文字@kbd{C-b}を表します。この方法で指定できるのは、8進コード777までの文字だけです。

  これらのエスケープシーケンスは、文字列内でも使用されます。@ref{Non-ASCII in Strings}を参照してください。

@node Ctl-Char Syntax
@subsubsection コントロール文字構文

@cindex control characters
  他の入力構文を使用してコントロール文字を表すことができます。これは後にバックスラッシュ、カレット、対応する非コントロール文字(大文字か小文字)をともなうクエスチョンマークから構成されます。たとえば@samp{?\^I}と@samp{?\^i}はどちらも、値が9である文字@kbd{C-i}にたいする、有効な入力構文です。

  @samp{^}のかわりに、@samp{C-}を使用することもできます。したがって@samp{?\C-i}は、@samp{?\^I}や@samp{?\^i}と等価です。

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  文字列やバッファーの中では、@acronym{ASCII}のコントロール文字だけが許されますが、キーボード入力にたいしては@samp{C-}により任意の文字をコントロール文字にすることができます。これらの非@acronym{ASCII}のコントロール文字にたいするコントロール文字には
@tex
非コントロール文字にたいするコードと同様に、@math{2^{26}}
@end tex
@ifnottex
非コントロール文字にたいするコードと同様に、2**26
@end ifnottex
ビットが含まれます。通常のテキスト端末には、非@acronym{ASCII}コントロール文字を生成する方法がありませんが、Xおよび他のウィンドウシステムを使用することにより、簡単に生成することができます。

  歴史的な理由により、Emacsは@key{DEL}文字を、@kbd{?}のコントロール文字として扱います:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
結果として、Xでは有意な入力文字である@kbd{Control-?}文字を、@samp{\C-}を使用して表現することは今のところできません。さまざまなLispファイルがこの方法により@key{DEL}を参照するため、これを変更するのは簡単ではありません。

  コントロール文字の表現はファイルや文字列のなかで見ることができますが、わたしたちは@samp{^}構文を推奨します。キーボード入力にたいするコントロール文字に好ましいのは、@samp{C-}構文です。どちらを使用するかはプログラムの意味に影響しませんが、プログラムを読む人の理解を助けるでしょう。

@node Meta-Char Syntax
@subsubsection メタ文字構文

@cindex meta characters
  @dfn{メタ文字(meta character)}とは、@key{META}修飾キーとともにタイプされた文字です。そのような文字を表す整数には
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
のビットがセットされています。基本的な文字コードの広い範囲を利用可能にするために、メタや他の修飾にたいして上位ビットを使用します。

  文字列では、メタ文字を示す@acronym{ASCII}文字に、
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings
of Events}を参照してください。

  メタ文字の入力構文には@samp{\M-}を使用します。たとえば@samp{?\M-A}は@kbd{M-A}を意味します。8進文字コード(以下参照)や、@samp{\C-}、その他の文字にたいする他の構文とともに@samp{\M-}を使用できます。したがって、@kbd{M-A}は@samp{?\M-A}や@samp{?\M-\101}と記述できます。同様に、@kbd{C-M-b}は@samp{?\M-\C-b}、@samp{?\C-\M-b}、@samp{?\M-\002}と記述することができます。

@node Other Char Bits
@subsubsection その他の文字修飾ビット

  グラフィック文字(graphic
character)の大文字小文字は、文字コードで示されます。たとえば@acronym{ASCII}では、文字@samp{a}と文字@samp{A}は区別されます。しかし@acronym{ASCII}にはコントロール文字が大文字なのか小文字なのかを表現する方法がありません。コントロール文字がタイプされたときシフトキーが使用されたかを示すために、Emacsは
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
のビットを使用します。この区別は、X端末や、他の特別な端末を使用しているときだけ可能です。通常のテキスト端末は、これらの違いを報告しません。シフトをあらわすビットのためのLisp構文は@samp{\S-}です。したがって@samp{?\C-\S-o}や@samp{?\C-\S-O}は、shifted-control-o文字を表します。

@cindex hyper characters
@cindex super characters
@cindex alt characters
  Xウィンドウシステムは文字にセットできる、他に3つ@anchor{modifier bits}修飾ビット ---
@dfn{hyper}、@dfn{super}、@dfn{alt}を定義します。これらのビットにたいする構文は、@samp{\H-}、@samp{\s-}、@samp{\A-}です(これらのプレフィクスでは、大文字小文字は意味があります)。したがって@samp{?\H-\M-\A-x}は@kbd{Alt-Hyper-Meta-x}を表します(@samp{-}が後にない@samp{\s}は、スペース文字を表すことに注意してください)。
@tex
数値としては、ビット値@math{2^{22}}はalt、@math{2^{23}}はsuper、@math{2^{24}}はhyperです。
@end tex
@ifnottex
数値的には、ビット値2**22はalt、2**23はsuper、2**24はhyperです。
@end ifnottex

@node Symbol Type
@subsection シンボル型

  GNU Emacs
Lispでの@dfn{シンボル(symbol)}とは、名前をもつオブジェクトです。シンボル名は、そのシンボルのプリント表現としての役割があります。Lispの通常の使用では、1つのobarray(@ref{Creating
Symbols}を参照してください)により、シンボル名は一意です --- 2つのシンボルが同じ名前をもつことはありません。

  シンボルは、変数、関数名としての役割や、プロパティーリストを保持する役割をもつことができます。他のすべてのLispオブジェクトから区別するためだけの役割をもつ場合もあり、データ構造内にそのようなシンボルが存在することは、確実に認識されるでしょう。与えられたコンテキストにおいて、通常はこれらのうちの1つの使用だけが意図されます。しかし3つすべての方法で、1つのシンボルを独立して使用することもできます。

  名前がコロン(@samp{:})で開始されるシンボルは、@dfn{キーワードシンボル(keyword
symbol)}と呼ばれます。これらのシンボルは自動的に定数として振る舞い、通常は未知のシンボルと、いくつかの特定の候補を比較することだけに使用されます。@ref{Constant
Variables}を参照してください。

@cindex @samp{\} in symbols
@cindex backslash in symbols
  シンボル名にはどんな文字でも含めることができます。ほとんどのシンボル名は英字、数字、@samp{-+=*/}などの句読点文字で記述されます。このような名前には、特別な句読点文字は必要ありません。名前が数字のように見えない限りは、名前にはどのような文字も使用できます(名前が数字のように見える場合は、名前の先頭に@samp{\}を記述して、強制的にシンボルとして解釈させます)。文字@samp{_~!@@$%^&:<>@{@}?}はあまり使用されませんが、これらも特別な句読点文字を必要としません。他の文字も、バックスラッシュでエスケープすることにより、シンボル名に含めることができます。しかし、文字列内でのバックスラッシュの使用とは対照的に、シンボル名でのバックスラッシュは、バックスラッシュの後の1文字をエスケープするだけです。たとえば文字列内では、@samp{\t}はタブ文字を表します。しかしシンボル名の中では、@samp{\t}は英字@samp{t}をクォートするに過ぎません。
名前にタブ文字をもつシンボルを記述するには、(バックスラッシュを前置した)実際のタブを使用しなければなりません。しかし、そのようなことを行なうことは、めったにありません。

@cindex CL note---case of letters
@quotation
@b{Common Lispに関する注意:}Common
Lispでは、明示的にエスケープされない限り、小文字は常に大文字に``フォールドされ(folded)''ます。Emacs
Lispでは大文字と小文字は区別されます。
@end quotation

  以下はシンボル名の例です。4番目の例の中の@samp{+}は、シンボルが数字として読み取られるのを防ぐために、エスケープされていることに注意してください。6番目の例では、名前の残りの部分により数字としては不正なので、エスケープの必要はありません。

@example
@group
foo                 ; @r{@samp{foo}という名前のシンボル。}
FOO                 ; @r{@samp{foo}とは別の、@samp{FOO}という名前のシンボル。}
@end group
@group
1+                  ; @r{@samp{1+}という名前のシンボル}
                    ;   @r{(整数の@samp{+1}ではありません)。}
@end group
@group
\+1                 ; @r{@samp{+1}という名前のシンボル}
                    ;   @r{(とても読みやすい名前とはいえません)。}
@end group
@group
@c the @'s in this next line use up three characters, hence the
@c apparent misalignment of the comment.
\(*\ 1\ 2\)         ; @r{@samp{(* 1 2)}という名前のシンボル(悪い名前)。}
+-*/_~!@@$%^&=:<>@{@}  ; @r{@samp{+-*/_~!@@$%^&=:<>@{@}}という名前のシンボル。}
                    ;   @r{これらの文字はエスケープする必要はありません。}
@end group
@end example

@cindex @samp{##} read syntax
@ifinfo
@c This uses ``colon'' instead of a literal `:' because Info cannot
@c cope with a `:' in a menu
@cindex @samp{#@var{colon}} read syntax
@end ifinfo
@ifnotinfo
@cindex @samp{#:} read syntax
@end ifnotinfo
  シンボル名がプリント表現としての役割をもつというルールの例外として、@samp{##}があります。これは、名前が空文字列の、internされたシンボルのプリント表現です。さらに@samp{#:@var{foo}}は、internされていない@var{foo}という名前のシンボルにたいするプリント表現です(通常、Lispリーダーはすべてのシンボルをinternします。@ref{Creating
Symbols}を参照してください)。

@node Sequence Type
@subsection シーケンス型

  @dfn{シーケンス(sequence)}とは、要素の順序セットを表現する、Lispオブジェクトです。Emacs Lispには、2種類のシーケンス
--- @dfn{リスト(lists)}と@dfn{配列(arrays)}があります。

  リストはもっとも一般的に使用されるシーケンスです。リストは任意の型の要素を保持でき、要素の追加・削除により簡単に長さを変更できます。リストについては、次のサブセクションを参照してください。

  配列は固定長のシーケンスです。配列はさらに文字列(strings)、ベクター(vectors)、文字テーブル(char-tables)、ブールベクター(bool-vectors)に細分されます。ベクターは任意の型の要素を保持できますが、文字列の要素は文字でなければならず、ブールベクターの要素は@code{t}か@code{nil}でなければなりません。文字テーブルはベクターと似ていますが、有効な文字によりインデックスづけされる点が異なります。文字列内の文字は、バッファー内の文字のようにテキストプロパティーをもつことができます(@ref{Text
Properties}を参照してください)。しかしベクターは、その要素が文字のときでも、テキストプロパティーをサポートしません。

  リスト、文字列、およびその他の配列型も、重要な類似点を共有します。たとえば、それらはすべて長さ@var{l}をもち、要素は0から@var{l}@minus{}1でインデックスづけされます。いくつかの関数はシーケンス関数と呼ばれ、これらは任意の種類のシーケンスを許容します。たとえば、関数@code{length}は、任意の種類のシーケンスの長さを報告します。@ref{Sequences
Arrays Vectors}を参照してください。

  シーケンスは読み取りにより常に新たに作成されるので、同じシーケンスを2回読み取るのは、一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト@code{()}は、常に同じオブジェクト@code{nil}を表します。

@node Cons Cell Type
@subsection コンスセルとリスト型
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{コンスセル(cons
cell)}は、@sc{car}スロット、@sc{cdr}スロットと呼ばれる2つのスロットから構成されるオブジェクトです。各スロットは、任意のLispオブジェクトを@dfn{保持}できます。そのとき@sc{car}スロットに保持されるオブジェクトが何であれ、わたしたちは``このコンスセルの@sc{car}''のような言い方をします。これは@sc{cdr}の場合も同様です。

@cindex list structure
  @dfn{リスト(list)}は、コンスセルの連続するシリーズで、各コンスセルの@sc{cdr}スロットは、次のコンスセル、または空リストを保持します。空リストは実際にはシンボル@code{nil}です。詳細については、@ref{Lists}を参照してください。ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルにより構成される任意の構造を、@dfn{リスト構造(list
structure)}という用語で参照します。

@cindex linked list
@quotation
Cプログラマーにたいする注意: Lispのリストはコンスセルにより構築される、@dfn{リンクリスト(linked
list)}として機能します。Lispではポインターは暗黙的なので、わたしたちはコンスセルのスロットが、値を``保持(hold)''するのか、それとも値を``指す(point)''のかを区別しません。
@end quotation

@cindex atoms
  コンスセルはLispの中心なので、``コンスセルではないオブジェクト''にたいする単語もあります。これらのオブジェクトは@dfn{アトム(atoms)}と呼ばれます。

@cindex parenthesis
@cindex @samp{(@dots{})} in lists
  リストにたいする入力構文とプリント表現は等しく、それは左カッコ、任意の数の要素、右カコから構成されます。以下はリストの例です:

@example
(A 2 "A")            ; @r{3要素のリスト。}
()                   ; @r{要素がないリスト(空リスト)。}
nil                  ; @r{要素がないリスト(空リスト)。}
("A ()")             ; @r{1要素のリスト: 文字列@code{"A ()"}。}
(A ())               ; @r{2要素のリスト: @code{A}と空リスト。}
(A nil)              ; @r{同上}
((A B C))            ; @r{1要素のリスト}
                     ;   @r{(この要素は、3要素のリスト)。}
@end example

   読み取りにおいては、カッコの内側は、リストの要素になります。つまり、コンスセルは各要素から作成されます。コンスセルの@sc{car}スロットは要素を保持し、@sc{cdr}スロットはリスト内の次のコンスセル(このコンスセルはリスト内の次の要素を保持します)を参照します。最後のコンスセルの@sc{cdr}スロットは、@code{nil}を保持するようにセットされます。

  @sc{car}、@sc{cdr}という名称は、Lispの歴史に由来します。オリジナルのLisp実装は@w{IBM
704}コンピューターで実行されていました。ワードを2つの部分、つまり``address''と呼ばれる部分と、``decrement''と呼ばれる部分に分割していて、その際@sc{car}はaddress部から内容を取り出す命令で、@sc{cdr}はdecrement部から内容を取り出す命令でした。対照的に``cons
cells''は、これらを作成する関数@code{cons}から命名されました。この関数は関数の目的、すなわちセルを作る(construction of
cells)という目的から命名されました。

@menu
* Box Diagrams::             リストを絵で書いたら。
* Dotted Pair Notation::     コンスセルの一般的な構文。
* Association List Type::    特別に構成されるリスト。
@end menu

@node Box Diagrams
@subsubsection ボックスダイアグラムとしてのリストの描写
@cindex box diagrams, for lists
@cindex diagrams, boxed, for lists

  コンスセルを表現するドミノのような1対のボックスによる図により、リストを説明することができます(Lispリーダーがこのような図を読み取ることはできません。人間およびコンピューターが理解できるテキスト表記と異なり、ボックスの図は人間だけが理解できます)。この図は3要素のリスト@code{(rose
violet buttercup)}を表したものです:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example

  この図では、ボックスは任意のLispオブジェクトへの参照を保持できるスロットを表します。ボックスのペアはコンスセルを表します。矢印はLispオブジェクト(アトム、または他のコンスセル)への参照を表します。

  この例では、1番目のボックスは1番目のコンスセルで、それの@sc{car}は@code{rose}(シンボル)を参照または``保持(holds)''します。2番目のボックスは1番目のコンスセルの@sc{cdr}を保持し、次のボックスペア、すなわち2番目のコンスセルを参照します。2番目のコンスセルの@sc{car}は@code{violet}で、@sc{cdr}は3番目のコンスセルです。(最後の)3番目のコンスセルの@sc{cdr}は、@code{nil}です。

  同じリスト@code{(rose violet buttercup)}を、違うやり方で描いた別の図で表してみましょう:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} as a list
@cindex empty list
  要素がないリストは@dfn{空リスト(empty
list)}で、これはシンボル@code{nil}と同じです。別の言い方をすると、@code{nil}はシンボルであり、リストでもあります。

  以下は、リスト@code{(A ())}、または等価な@code{(A nil)}をボックスと矢印で描いたものです:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  以下はもっと複雑な例です。これは、1番目の要素が2等疎のリスとである、3要素のリスト@code{((pine needles) oak
maple)}を表します:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles
@end group
@end example

  同じリストを2番目のボックス表記で表すと、以下のようになります:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| oak   |   o------->| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| pine  |   o------->| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection ドットペア表記
@cindex dotted pair notation
@cindex @samp{.} in lists

  @dfn{ドットペア表記(dotted pair
notation)}は@sc{car}と@sc{cdr}が明示的に表されたコンスセルにたいする、一般的な構文です。この構文では、@code{(@var{a}
.@:
@var{b})}は、@sc{car}がオブジェクト@var{a}で、@sc{cdr}がオブジェクト@var{b}という意味になります。@sc{cdr}がリスとである必要がないので、ドットペア表記は、より一般的なリスト構文です。しかしキスと構文が機能するでような場合には、より扱いにくくなります。ドットペア表記では、リスト@samp{(1
2 3)}は、@samp{(1 .  (2 . (3
.
nil)))}と記述されます。@code{nil}で終端されたリストにたいしては、どちらの表記法も使用できますが、リスト表記の方が、通常は明解で便利です。リストをプリントする場合、コンスセルの@sc{cdr}がリスとでないときだけ、ドットペア表記が使用されます。

  以下はボックスを使用してドットペア表記を表した例です。この例はペア@code{(rose . violet)}を表します。

@example
@group
    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose
@end group
@end example

  最後の@sc{cdr}が非@code{nil}のコンスセルのチェーンを表すために、ドットペア表記とリスト表記を組み合わせることができます。リストの最後の要素の後にドットを記述して、その後に最後のコンスセルの@sc{cdr}を記述します。たとえば、@code{(rose
violet . buttercup)}は、@code{(rose . (violet
. buttercup))}と等価です。オブジェクトは以下のようになります:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  構文@code{(rose .@: violet .@:
buttercup)}は無効です。なぜならこれが意味することは何もないからです。何かあるにしても、@code{violet}のために@sc{cdr}がすでに使用されているコンスセルの@sc{cdr}に@code{buttercup}を置く、ということになります。

  リスト@code{(rose violet)}は@code{(rose . (violet))}と等価であり、以下のようになります:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  同様に3要素のリスト@code{(rose violet buttercup)}は、@code{(rose . (violet
. (buttercup)))}と等価です。
@ifnottex
これは以下のようになります:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection 連想リスト型

  @dfn{連想リスト(association
list)}または@dfn{alist}は、要素がコンスセルであるように特別に構成されたリストです。各要素においては、@sc{car}が@dfn{キー(key)}で、@sc{cdr}が@dfn{連想値(associated
value)}であると考えます(連想値が@sc{cdr}の@sc{car}に保存される場合もあります)。リストの先頭に連想値を追加したり削除するのが簡単なので、連想リストはスタック(stack)にしばしば使用されます。

  たとえば、

@example
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
@end example

@noindent
これは変数@code{alist-of-colors}に3葉疎のalistをセットします。最初の要素では、@code{rose}がキーで、@code{red}が値になります。

  alistと、alistに関数についての詳細な説明は、@ref{Association
Lists}を参照してください。テーブルを照合する、(多くのキーの操作を、より速く行なう)他の手段については、@ref{Hash
Tables}を参照してください。

@node Array Type
@subsection 配列型

  @dfn{配列(array)}は、他のLispオブジェクトを保持または参照する、任意の数のスロットから構成され、メモリーの連続ブロックに配列されます。配列の任意の要素へのアクセス時間は、大体同じです。対照的に、リストの要素にたいするアクセスは、リスト内でのその要素の位置に比例した時間を要します(リストの最後の要素にアクセスするには、リストの最初の要素にアクセスするより、長い時間を要します)。

  Emacsは文字列(strings)、ベクター(vectors)、ブールベクター(bool-vectors)、文字テーブル(char-tables)という、4種の配列を定義します。

  文字列は文字の配列で、ベクターは任意のオブジェクトの配列です。ブールベクターは@code{t}か@code{nil}だけを保持できます。この種の配列は、もっとも大きい整数までの、任意の長さをもつことができます。文字テーブルは、任意の有効な文字コードによりインデックスづけされる疎な配列で、任意のオブジェクトを保持することができます。

  配列の最初の要素はインデックス0、2番目の要素はインデックス1、...となります。これは0基準@dfn{zero-origin}のインデックスづけと呼ばれます。たとえば、4要素の配列は、インデックス0、1、2、3をもちます。利用できる最大のインデックス値は、配列の長さより1小さくなります。1度配列が作成されると、長さは固定されます。

  Emacs
Lispのすべての配列は、1次元です(他のほとんどのプログラミング言語は多次元配列をサポートしますが、これらは必須ではありません。ネストされた1次元配列により同じ効果を得ることができます)。各種の配列のは、独自の入力構文をもちます。詳細は以降のセクションを参照してください。

  配列型はシーケンス型のサブセットであり、文字列型、ベクター型、ブールベクター型、文字テーブル型が含まれます。

@node String Type
@subsection 文字列型

  @dfn{文字列(string)}とは、文字の配列です。Emacsがテキストエディターであることから予想できるように、文字列は、たとえばLispシンボルの名前、ユーザーへのメッセージ、バッファーから抽出されたテキストの表現など、多くの目的のために使用されます。Lispの文字列は定数です。文字列を評価すると、それと同じ文字列がreturnされます。

  文字列を操作する関数については、@ref{Strings and Characters}を参照してください。

@menu
* Syntax for Strings::       Lisp文字列を指定する方法。
* Non-ASCII in Strings::     文字列内の国際化文字。
* Nonprinting Characters::   文字列内の印刷不可能なリテラル文字。
* Text Props and Strings::   テキストプロパティーをともなう文字列。
@end menu

@node Syntax for Strings
@subsubsection 文字列の構文

@cindex @samp{"} in strings
@cindex double-quote in strings
@cindex @samp{\} in strings
@cindex backslash in strings
  文字列にたいする入力構文は、@code{"like
this"}のように、ダブルクォート、任意個の文字、もう1つのダブルクォートから構成されます。文字列内にダブルクォートを含める場合は、それの前にバックスラッシュを記述します。したがって、@code{"\""}は1つのダブルクォート文字だけを含む文字列です。同様に、バックスラッシュを含める場合は、@code{"this
\\ is a single embedded backslash"}のように、それの前にもう1つのバックスラッシュを記述します。

@cindex newline in strings
  文字列にたいする入力構文では、改行(newline)は特別ではありません。ダブルクォートの間に改行を記述すれば、その改行は文字列内の文字となります。しかしエスケープされた改行
--- 前に@samp{\}をともなう改行 ---は文字列の一部とはなりません。同様に、エスケープされたスペース@w{@samp{\ 
}}も無視されます。

@example
"It is useful to include newlines
in documentation strings,
but the newline is \
ignored if escaped."
     @result{} "It is useful to include newlines
in documentation strings,
but the newline is ignored if escaped."
@end example

@node Non-ASCII in Strings
@subsubsection 文字列内の非@acronym{ASCII}文字

  Emacdの文字列内の非@acronym{ASCII}文字にたいしては、2つのテキスト表現 ---
マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text
Representations}を参照してください)。大まかに言うと、ユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的に、マルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character
Type}を参照してください)。両方とも、127より上の文字は非@acronym{ASCII}です。

  文字をリテラルとして記述することにより、文字列に非@acronym{ASCII}文字を含めることができます。マルチバイトのバッファーや文字列、あるいはマルチバイトとしてvisitされたファイル等の、マルチバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をマルチバイト文字として読み取り、その文字列を自動的にマルチバイト文字列にします。ユニバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をユニバイト文字として読み取り、その文字列を湯にバイト文字列にします。

  マルチバイト文字列内にリテラルとして文字を記述するかわりに、エスケープシーケンスを使用して文字コードとして記述できます。エスケープシーケンスについての詳細は、@ref{General
Escape Syntax}を参照してください。

  文字列定数内でUnicodeスタイルのエスケープシーケンス@samp{\uNNNN}または@samp{\U00NNNNNN}を使用する場合、(たとえ@acronym{ASCII}文字の場合でも)Emacsは自動的に文字列をマルチバイトとみなします。

  文字列定数内で、16進エスケープシーケンス(@samp{\x@var{n}})、および8進エスケープシーケンス(@samp{\@var{n}})を使用することもできます。@strong{しかし注意してください:
}文字列定数が16進または8進のエスケープシーケンスを含み、それらのエスケープシーケンスすべてがユニバイト文字(256より小)を指定していて、その文字列内に他にリテラルの非@acronym{ASCII}文字またはUnicodeスタイルのエスケープシーケンスが存在しない場合、Emacsは自動的に文字列をユニバイト文字列とみなします。つまり文字列内のすべての非@acronym{ASCII}文字は8ビットのrawバイトとみなされます。

  16進および8進のエスケープシーケンスではエスケープされた文字コードは可変個の数字を含むかもしれないので、それに続く文字で、16進および8進として有効ではない最初の文字は、エスケープシーケンスを終了させます。文字列内の次の文字が16進または8進として解釈できる文字の場合は、@w{@samp{\ 
}}(バックスラッシュとスペース)を記述して、エスケープシーケンスを終了できます。たとえば@w{@samp{\xe0\ }}はgrave
accentつきの@samp{a}という、1文字を表します。文字列内の@w{@samp{\ 
}}は、バックスラッシュー改行と同様です。これは文字列内の文字とはなりませんが、先行する16進エスケープを終了します。

@node Nonprinting Characters
@subsubsection 文字列内の非プリント文字

  リテラル文字と同様に、文字列定数内でバックスラッシュによるエスケープシーケンスを使用できます(ただし文字定数を開始するクエスチョンマークは使用しません)。たとえば、非プリント文字のタブと@kbd{C-a}を含む文字列は、@code{"\t,
\C-a"}のように、それらの間にカンマとスペースを記述します。文字にたいする入力構文の説明は、@ref{Character
Type}を参照してください。

  しかし、バックスラッシュによるエスケープシーケンスとともに記述できるすべての文字が、文字列内で有効というわけではありません。文字列が保持できるコントロール文字は、@acronym{ASCII}コントロール文字だけです。@acronym{ASCII}コントロール文字では、文字列の大文字小文字は区別されません。

  正確に言うと、文字列はメタ文字を保持できません。しかし文字列がキーシーケンスとして使用される場合、文字列内でメタで修飾された@acronym{ASCII}文字を表現するための方法を提供する、特別な慣習があります。文字列定数内でメタ文字を示すために@samp{\M-}構文を使用した場合、これは文字列内の文字の
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
のビットをセットします。その文字列が@code{define-key}または@code{lookup-key}で使用される場合、この数字コードは等価なメタ文字に変換されます。@ref{Character
Type}を参照してください。

  文字列はhyper、super、altで修飾された文字を保持できません。

@node Text Props and Strings
@subsubsection 文字列内のテキストプロパティ

@cindex @samp{#(} read syntax
@cindex text properties, read syntax
  文字列は、その文字自身に加えて、文字のプロパティーも保持することができます。これにより、特別なことをしなくても、文字列とバッファーとの間でテキストをコピーするプログラムが、テキストプロパティーをコピーすることが可能になります。テキストプロパティーが何を意味するかについての説明は、@ref{Text
Properties}を参照してください。テキストプロパティーをもつ文字列は、特別な入力構文とプリント構文を使用します。

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
ここで@var{property-data}は3個でグループ化された、0個以上の要素から構成されます:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
要素@var{beg}および@var{end}は整数で、文字列内のインデックスの範囲を指定します。@var{plist}はその範囲にたいするプロパティーリストです。たとえば、

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
これはテキスト内容が@samp{foo
bar}で、最初の3文字は@code{face}プロパティーに値@code{bold}をもち、最後の3文字は@code{face}プロパティーに値@code{italic}をもつことを表します。(4番目の文字にはテキストプロパティーはないので、プロパティーリストは@code{nil}です。実際には、範囲の中の指定されていない文字はデフォルトではプロパティーをもたないので、範囲のプロパティーリストを@code{nil}と指定する必要ありません)。

@node Vector Type
@subsection ベクター型

  @dfn{ベクター(vector)}は、任意の型の要素からなる1次元の配列です。ベクター内の任意の要素へのアクセスに要す時間は、一定です(リストの場合、要素へのアクセスに要す時間は、リストの先頭からその要素までの距離に比例します)。

  ベクターのプリント表現は、左角カッコ(left square bracket)、要素、右角カッコ(right square
bracket)から構成されます。これは入力構文でもあります。数字や文字列と同様に、ベクターは評価において定数と判断されます。

@example
[1 "two" (three)]      ; @r{3要素のベクター。}
     @result{} [1 "two" (three)]
@end example

  ベクターに作用する関数については、@ref{Vectors}を参照してください。

@node Char-Table Type
@subsection 文字テーブル型

  @dfn{文字テーブル(char-table)}は、任意の型の要素をもつ1次元の配列で、文字コードによりインデックスづけされます。文字テーブルは、文字コードに情報を割り当てることを必要とする多くの処理を簡単にするための、特別な追加の機能をもちます
---
たとえば、文字テーブルは、継承するための親、デフォルト値、特別な目的のために使用する少数の余分なスロットをもつことができます。文字テーブルは、文字セット全体にたいして1つの値を指定することもできます。

@cindex @samp{#^} read syntax
  文字テーブルのプリント表現はベクターと似ていますが、最初に余分な@samp{#^}があります@footnote{``サブ文字テーブル(sub-char-tables)''に使用される@samp{#^^}を目にすることがあるかもしれません。}。

  文字テーブルを操作する特別な関数については、@ref{Char-Tables}を参照してください。文字テーブルの使用には以下が含まれます:

@itemize @bullet
@item
大文字小文字テーブル(@ref{Case Tables}を参照してください)。

@item
文字カテゴリーテーブル(@ref{Categories}を参照してください)。

@item
ディスプレーテーブル(@ref{Display Tables}を参照してください)。

@item
構文テーブル(@ref{Syntax Tables}を参照してください)。
@end itemize

@node Bool-Vector Type
@subsection ブールベクター型

  @dfn{ブールベクター(bool-vector)}は、要素が@code{t}か@code{nil}でなければならない、1次元の配列です。

  ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです
---
文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
@samp{C-g}の2進コードは111、@samp{C-@@}はコード0の文字なので、この結果は道理にかなっています。

  長さが8の倍数でない場合、プリント表現には余分な要素が表示されますが、これらの余分な要素に意味はありません。たとえば以下の例では、最初の3ビットだけが使用されるので、2つのブールベクターは等価です:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection ハッシュテーブル型

    ハッシュテーブルは非常に高速な照合テーブルの一種で、キーを対応する値にマップするalistと似ていますが、より高速です。ハッシュテーブルのプリント表現、以下のようにハッシュテーブルのプロパティーと内容を指定します:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8 data ())
@end example

@noindent
ハッシュテーブルについての詳細な情報は、@ref{Hash Tables}を参照してください。

@node Function Type
@subsection 関数型

  他のプログラミング言語の関数と同様に、Lisp関数は実行可能なコードです。他の言語とは異なり、Lispの関数はLispオブジェクトでもあります。Lispのコンパイルされていない関数はラムダ式
--- つまり1番目の要素がシンボル@code{lambda}であるリストです(@ref{Lambda Expressions}を参照してください)。

  ほとんどのプログラミング言語では、名前のないの関数はありません。Lispでは、関数に本質的な名前はありません。名前がなくても、ラムダ式を関数として呼び出すことができます。これを強調するために、わたしたちはこれを@dfn{無名関数(anonymous
function)}とも呼びます(@ref{Anonymous
Functions}を参照してください)。Lispの名前つき関数は、関数セルに有効な関数がセットされた単なるシンボルです(@ref{Defining
Functions}を参照してください)。

  ほとんどの場合、関数はLispプログラム内のLisp式に名前が記述されたところで呼び出されます。しかし、実行時に関数オブジェクトを構築または取得してから、基本関数@code{funcall}および@code{apply}により呼び出すことができます。@ref{Calling
Functions}を参照してください。

@node Macro Type
@subsection マクロ型

  @dfn{Lispマクロ(Lisp
macro)}は。Lisp言語を拡張する、ユーザー定義の構成です。これはオブジェクトとしてではなく関数のように表現されますが、引数の渡し方の意味が異なります。Lispマクロの形式はリストです。これは、最初の要素が@code{macro}で、(@code{lambda}シンボルを含む)@sc{cdr}がLisp関数オブジェクトであるようなリストです。

  Lispマクロオブジェクトは通常、ビルトインの@code{defmacro}関数で定義されますが、@code{macro}で始まる任意のリストも、Emacsにとってはマクロです。マクロを記述する方法の説明は、@ref{Macros}を参照してください。

  @strong{警告}: Lispマクロとキーボードマクロ(@ref{Keyboard
Macros}を参照してください)は、完全に別物です。修飾なしで``マクロ''という単語を使用したときは、キーボードマクロではなく、Lispマクロのことを指します。

@node Primitive Function Type
@subsection プリミティブ関数型
@cindex primitive function

  @dfn{基本関数(primitive
function)}とは、Cプログラミング言語で記述された、Lispから呼び出せる関数です。基本関数は@dfn{subrs}や@dfn{ビルと陰関数(built-in
functions)}とも呼ばれます(単語``subr''は、``サブルーチン(subroutine)''が由来です)。ほとんどの基本関数、呼び出されたとき、すべての引数を評価します。すべての引数を評価しない基本関数は、@dfn{スペシャルフォーム(special
form)}と呼ばれます(@ref{Special Forms}を参照してください)。

  呼び出す側からすれば、その関数が基本関数かどうかは、問題になりません。しかし、基本関数をLispで記述された関数で再定義した場合は、問題になります。理由は、その基本関数がCコードから直接呼び出されているかもしれないからです。Lispから再定義した関数を呼び出すと、これは新しい定義を使用するでしょうが、Cコードから呼び出すと、ビルトインの定義が使用されるでしょう。したがって、@strong{基本関数の再定義はしないでください}。

  @dfn{関数(function)}という用語により、LispやCで記述された、すべてのEmacs関数を参照します。Lispで記述された関数についての情報は、@ref{Function
Type}を参照してください。

  基本関数に入力構文はなく、サブルーチン名とともにハッシュ表記でプリントします。

@example
@group
(symbol-function 'car)          ; @r{そのシンボルの関数セルに}
                                ;     @r{アクセスします。}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{これは基本関数か?}
     @result{} t                ;    @r{イェース。}
@end group
@end example

@node Byte-Code Type
@subsection バイトコード関数型

@dfn{バイトコード関数オブジェクト(byte-code function
objects)}は、Lispコードをバイトコンパイルすることにより生成されます(@ref{Byte
Compilation}を参照してください)。内部的には、バイトコード関数オブジェクトは、ベクターによく似ています。しかしバイトコード関数オブジェクトが関数呼び出しのように見える場合、評価プロセスにより、このデータ型は特別に処理されます。@ref{Byte-Code
Objects}を参照してください。

バイトコード関数オブジェクトのプリント表現と入力構文は、ベクターのものと似ていますが、開き角カッコ@samp{[}の前に@samp{#}があります。

@node Autoload Type
@subsection autoload型

  @dfn{autoloadオブジェクト(autoload
object)}は、最初の要素がシンボル@code{autoload}のリストです。これはシンボルの関数定義として保存され、実際の定義にたいする代替としての役割をもちます。autoloadオブジェクトは、必要な時にロードされるLispコードファイルのなかで、実際の定義を見つけることができることを宣言します。これにはファイル名と、加えて実際の定義についての他のいくつかの情報が含まれます。

  ファイルがロードされた後、そのシンボルは、autoloadオブジェクトではない、新しい関数定義をもつはずです。新しい定義は、最初からそこにあったかのように呼び出されます。ユーザーの観点からは、関数呼び出しは期待された動作、つまりロードされたファイル内の関数定義を使用します。

  autoloadオブジェクトは通常、シンボルの関数セルにオブジェクトを保存する、関数@code{autoload}により作成されます。詳細は、@ref{Autoload}を参照してください。

@node Editing Types
@section 編集用の型
@cindex editing types

  前のセクションの型は一般的なプログラミングの目的のために使用され、これらのほとんどは、ほとんどのLisp方言で一般的です。Emacs
Lispは、編集に関する目的のために、いくつかの追加のデータ型を提供します。

@menu
* Buffer Type::              編集のための基本オブジェクト。
* Marker Type::              バッファー内の位置。
* Window Type::              バッファーはウィンドウ内に表示する。
* Frame Type::               ウィンドウはフレームを細分化する。
* Terminal Type::            フレームを表示する端末デバイス。
* Window Configuration Type::  フレームが細分化された方法を記録する。
* Frame Configuration Type::  すべてのフレームの状態を記録する。
* Process Type::             背後のOS上で実行されるEmacsのサブプロセス。
* Stream Type::              文字の受信と送信。
* Keymap Type::              キーストロークがどの関数を呼び出すか。
* Overlay Type::             オーバーレイが表示される方法。
* Font Type::                テキストを表示するフォント。
@end menu

@node Buffer Type
@subsection バッファー型

  @dfn{バッファー(buffer)}とは、編集されるテキストを保持するオブジェクトです(@ref{Buffers}を参照してください)。ほとんどのバッファーはディスクファイル(@ref{Files}を参照してください)の内容を保持するので、それらは編集できますが、他の目的のために使用されるものもいくつかあります。ほとんどのバッファーは、ユーザーにより閲覧されることも意図しているので、いつかはウィンドウ内(@ref{Windows}を参照してください)に表示されます。しかしバッファーはウィンドウに表示される必要はありません。バッファーはそれぞれ、@dfn{ポイント(point)}と呼ばれる位置指定をもちます(@ref{Positions}を参照してください)。ほとんどの編集コマンドは、カレントバッファー内のポイントに隣接する内容を処理します。常に1つのバッファーが@dfn{カレントバッファー(current
buffer)}です。

  バッファーの内容は文字列によく似ていますが、バッファーはEmacs
Lispの文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキストを``挿入''するためには、部分文字列の結合が必要で、結果は完全に新しい文字列オブジェクトなのに比べて、バッファーでは既存のバッファーに効率的にテキストを挿入して、バッファーの内容を変更できます。

  標準的なEmacs関数の多くは、カレントバッファー内の文字を操作したりテストするためのものです。このマニュアルには、これらの関数の説明のために、1つのチャプターをあてています(@ref{Text}を参照してください)。

  他のデータ構造のいくつかは、各バッファーに関連付けられています:

@itemize @bullet
@item
ローカル構文テーブル(@ref{Syntax Tables}を参照してください)。

@item
ローカルキーマップ(@ref{Keymaps}を参照してください)。

@item
バッファーローカルな変数バインディングのリスト(@ref{Buffer-Local Variables}を参照してください)。

@item
オーバーレイ(@ref{Overlays}を参照してください)。

@item
バッファー内のテキストにたいするテキストプロパティー(@ref{Text Properties}を参照してください)。
@end itemize

@noindent
ローカルキーマップと変数リストは、具ローマルナバインディングや値を個別にオーバーライドするためのエントリーを含みます。これらは、実際にプログラムを変更することなく、異なるバッファーでのプログラムの振る舞いをカスタマイズするために使用されます。

  バッファーは@dfn{インダイレクト(indirect: 間接)} --- つまり他のバッファーとテキストを共有するが、それぞれ別に表示する ---
かもしれません。@ref{Indirect Buffers}を参照してください。

  バッファーに入力構文はありません。バッファーはバッファー名を含むハッシュ表記でプリントされます。

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@subsection マーカー型

  @dfn{マーカー(marker)}は、特定のバッファー内の位置を表します。したがってマーカーには2つの内容 --- 1つはバッファー、もう1つは位置
---
をもちます。バッファーのテキストの変更では、マーカーが常にバッファー内の同じ2つの文字の間に位置することを確実にするために、必要に応じて自動的に位置の値が再配置されます。

  マーカーは入力構文をもちません。マーカーは、カレントの文字位置と、そのバッファー名を与える、ハッシュ表記でプリントされます。

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

マーカーのテスト、作成、コピー、移動の方法についての情報は、@ref{Markers}を参照してください。

@node Window Type
@subsection ウィンドウ型

  @dfn{ウィンドウ(window)}はEmacsがバッファーを表示するために使用する端末スクリーンの部分を記述します。すべてのウィンドウは関連付けられた1つのバッファーをもち、バッファーの内容はそのウィンドウに表示されます。対照的に、あるバッファーは、1つのウィンドウに表示されるか、ウィンドウに表示されないか、それとも複数のウィンドウに表示されるかもしれません。

  同時に複数のウィンドウが存在するかもしれませんが、常に1つのウィンドウが@dfn{選択されたウィンドウ(selected
window)}になります。Emacsがコマンドにたいして準備できているときに、(通常は)カーソルが表示されるウィンドウが、選択されたウィンドウです。選択されたウィンドウは通常、カレントバッファーを表示しますが、これは必須ではありません。

  スクリーン上でウィンドウはフレームにグループ化されます。各ウィンドウは、ただ1つだけのフレームに属します。@ref{Frame
Type}を参照してください。

  ウィンドウは入力構文をもちません。ウィンドウは、ウィンドウ番号、表示されているバッファー名を与える、ハッシュ表記でプリントされます。与えられたウィンドウに表示されるバッファーは頻繁に変更されるかもしれないので、一意にウィンドウを識別するためにウィンドウ番号が存在します。

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

  ウィンドウに作用する関数の説明は、@ref{Windows}を参照してください。

@node Frame Type
@subsection フレーム型

  @dfn{フレーム(frame)}とは、１つ以上のEmacsウィンドウを含むスクリーン領域です。スクリーン領域を参照するためにEmacsが使用するLispオブジェクトを指す場合も、``フレーム''という用語を使用します。

  フレームは入力構文をもちません。フレームはフレームのタイトル、(フレームを一意に識別するのに便利な)メモリー内のアドレスを与えるハッシュ表記でプリントされます。

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  フレームに作用する関数の説明は、@ref{Frames}を参照してください。

@node Terminal Type
@subsection 端末型
@cindex terminal type

  @dfn{端末(terminal)}は、1つ以上のEmacsフレーム(@ref{Frame
Type}を参照してください)を表示する能力があるデバイスです。

  端末は入力構文をもちません。端末は、その端末の順序番号、TTYデバイスファイル名を与える、ハッシュ表記でプリントされます。

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c FIXME: add an xref to where terminal-related primitives are described.

@node Window Configuration Type
@subsection ウィンドウ構成型
@cindex window layout in a frame

  @dfn{ウィンドウ構成(window
configuration)}は、フレーム内のウィンドウの位置、サイズ、内容についての情報を保持します。これにより後で同じウィンドウ配置を再作成できます。

  ウィンドウ構成は入力構文をもちません。ウィンドウ構成のプリント表現は、@samp{#<window-configuration>}のようになります。ウィンドウ構成に関連するいくつかの関数の説明は、@ref{Window
Configurations}を参照してください。

@node Frame Configuration Type
@subsection フレーム構成型
@cindex screen layout
@cindex window layout, all frames

  @dfn{フレーム構成(frame
configuration)}は、すべてのフレーム内のウィンドウの位置、サイズ、内容についての情報を保持します。これは基本型ではありません ---
実際のところ、これは@sc{car}が@code{frame-configuration}で、@sc{cdr}がalistのリストです。各alist要素は、その要素の@sc{car}に示される1つのフレームを記述します。

  フレーム構成に関連するいくつかの関数の説明は、@ref{Frame Configurations}を参照してください。

@node Process Type
@subsection プロセス型

  単語@dfn{プロセス(process)}は通常、実行中のプログラムを意味します。Emacs自身はこの種のプロセス内で実行されます。しかしEmacs
Lispでは、プロセスとはEmacsプロセスにより作成されたサブプロセスを表す、Lispオブジェクトです。シェル、GDB、ftp、コンパイラーなどのプログラムは、Emacsのサブプロセスとして実行され、Emacsの能力を拡張します。さらに操作を行なうために、Emacsサブプロセスは、Emacsからテキスト入力を受け取り、テキスト出力をEmacsにreturnします。Emacsは、サブプロセスにシグナルを送ることもできます。

  プロセスオブジェクトは入力構文をもちません。プロセスオブジェクトは、プロセス名を与えるハッシュ表記でプリントされます。

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

プロセスの作成、削除、プロセスに関する情報のreturn、入力やシグナルの送信、出力の受信を行なう関数についての情報は、@ref{Processes}を参照してください。

@node Stream Type
@subsection ストリーム型

  @dfn{ストリーム(stream)}とは、文字のソースまたはシンクとして ---
つまり入力として文字を供給したり、出力として文字を受け入れるために使用できるオブジェクトです。多くの異なるタイプ ---
マーカー、バッファー、文字列、関数を、この方法で使用できます。ほとんどの場合、入力ストリーム(文字列ソース)は、キーボード、バッファー、ファイルから文字を受け取り、出力ストリーム(文字シンク)は文字を@file{*Help*}バッファーのようなバッファー、エコーエリアに文字を送ります。

  オブジェクト@code{nil}は、他の意味に加えて、ストリームとして使用されることがあります。@code{nil}は変数@code{standard-input}や@code{standard-output}の値を表します。オブジェクト@code{t}も、入力としてミニバッファー(@ref{Minibuffers}を参照してください)、出力としてエコーエリア(@ref{The
Echo Area}を参照してください)の使用を指定するストリームになります。

  ストリームは特別なプリント表現や入力構文をもたず、何であれ、それらの基本型としてプリントされます。

  パース関数およびプリント関数を含む、ストリームに関連した関数の説明は、@ref{Read and Print}を参照してください。

@node Keymap Type
@subsection キーマップ型

  @dfn{キーマップ(keymap)}は、ユーザーがタイプした文字を、コマンドにマップします。このマップは、ユーザーのコマンド入力が実行される方法を制御します。キーマップは、実際には@sc{car}がシンボル@code{keymap}のリストです。

  キーマップの作成、プレフィクスキーの処理、ローカルキーマップやグローバルキーマップ、キーバインドの変更についての情報は、@ref{Keymaps}を参照してください。

@node Overlay Type
@subsection オーバーレイ型

  @dfn{オーバーレイ(overlay)}は、バッファーの一部に適用するプロパティーを指定します。それぞれのオーバーレイはバッファーの指定された範囲に適用され、プロパティーリスト(プロパティー名と値が交互に記述された要素のリスト)を含みます。オーバーレイプロパティーは、バッファーの指定された一部を、一時的に異なるスタイルで表示するために使用されます。オーバーレイは入力構文をもたず、バッファーメイト範囲の位置を与えるハッシュ表記でプリントされます。

  オーバーレイを作成したり使用する方法についての情報は、@ref{Overlays}を参照してください。

@node Font Type
@subsection フォント型

  @dfn{font}は、グラフィカルな端末上のテキストを表示する方法を指定します。実際には異なる3つのフォント型 ---
@dfn{フォントオブジェクト(font objects)}、@dfn{フォントスペック(font
specs)}、@dfn{フォントエンティティー(font entities)} ---
が存在しますこれらは入力構文をもちません。これらのプリント構文は、@samp{#<font-object>}、@samp{#<font-spec>}、@samp{#<font-entity>}のようになります。これらのLispオブジェクトの説明は、@ref{Low-Level
Font}を参照してください。

@node Circular Objects
@section 循環オブジェクトの読み取り構文
@cindex circular structure, read syntax
@cindex shared structure, read syntax
@cindex @samp{#@var{n}=} read syntax
@cindex @samp{#@var{n}#} read syntax

  複雑なLispオブジェクトにおける共有された構造、または循環する構造を表すために、リーダー構成@samp{#@var{n}=}と@samp{#@var{n}#}を使用することができます。

  後でオブジェクトを参照するには、オブジェクトの前で@code{#@var{n}=}を使用します。その後で、他の場所にある同じオブジェクトを参照するために、@code{#@var{n}#}を使用することができます。ここで@var{n}は任意の整数です。たとえば以下は、1番目の要素が3番目の要素にも繰り替えされるリストを作成する方法です:

@example
(#1=(a) b #1#)
@end example

@noindent
これは、以下のような通常の構文とは異なります

@example
((a) b (a))
@end example

@noindent
これは1番目の要素と3番目の要素がそっくりなリストですが、これらは同じLispオブジェクトではありません。以下で違いを見ることができます:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  ``要素''として自身を含むような、循環する構造を作成するために、同じ構文を使用できます。以下は例です:

@example
#1=(a #1#)
@end example

@noindent
これは、2番目の要素がそのリスト自身であるリストを作成します。これが実際にうまくいくのか、以下で確認できます:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  変数@code{print-circle}を非@code{nil}値にバインドした場合、Lispプリンターは、循環および共有されるLispオブジェクトを記録するこの構文を、生成することができます。@ref{Output
Variables}を参照してください。

@node Type Predicates
@section 型のための述語
@cindex type checking
@kindex wrong-type-argument

  Emacs
Lispインタープリター自身は、関数が呼び出されたときに、その関数に渡された実際の引数にたいする型チェックは行ないません。それが行なえないのは、Lispにおける関数の引数は、他のプログラミング言語のようなデータ型宣言をもたないからです。したがって実際の引数が、その関数が使用できる型に属するかどうかをテストするのは、それぞれの関数に任されています。

  すべてのビルトイン関数は、適切なときに実際の引数の型チェックを行い、引数の型が違う場合は、@code{wrong-type-argument}エラーをシグナルします。たとえば以下は、@code{+}の引数に、@code{+}が扱うことができない引数を渡したとき何が起こるかの例です:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex type predicates
@cindex testing types
  異なる型にたいして異なる処理をプログラムに行なわせる場合は、明示的に型チェックを行なわなければなりません。オブジェクトの型をチェックするもっとも一般的な方法は、@dfn{型述語(type
predicate)}関数の呼び出しです。Emacsはそれぞれの型にたいする型述語をもち、組み合わされた型にたいする述語もあります。

  型述語関数は1つの引数をとり、その引数が適切な型であれば@code{t}、そうでない場合は@code{nil}をreturnします。述語関数にたいする一般的なLisp慣習にしたがい、ほとんどの型述語の名前は、@samp{p}で終わります。

  以下はリストにたいしてチェックを行なう述語@code{listp}と、シンボルにたいしてチェックを行なう述語@code{symbolp}の例です。

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; If X is a symbol, put it on LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; If X is a list, add its elements to LIST.
         (setq list (append x list)))
        (t
         ;; We handle only symbols and lists.
         (error "Invalid argument %s in add-on" x))))
@end example

  以下の表は、事前定義された型述語(アルファベット順)と、さらに情報を得るためのリファレンスです。

@table @code
@item atom
@ref{List-related Predicates, atom}を参照してください。

@item arrayp
@ref{Array Functions, arrayp}を参照してください。

@item bool-vector-p
@ref{Bool-Vectors, bool-vector-p}を参照してください。

@item bufferp
@ref{Buffer Basics, bufferp}を参照してください。

@item byte-code-function-p
@ref{Byte-Code Type, byte-code-function-p}を参照してください。

@item case-table-p
@ref{Case Tables, case-table-p}を参照してください。

@item char-or-string-p
@ref{Predicates for Strings, char-or-string-p}を参照してください。

@item char-table-p
@ref{Char-Tables, char-table-p}を参照してください。

@item commandp
@ref{Interactive Call, commandp}を参照してください。

@item consp
@ref{List-related Predicates, consp}を参照してください。

@item custom-variable-p
@ref{Variable Definitions, custom-variable-p}を参照してください。

@item display-table-p
@ref{Display Tables, display-table-p}を参照してください。

@item floatp
@ref{Predicates on Numbers, floatp}を参照してください。

@item fontp
@ref{Low-Level Font}を参照してください。

@item frame-configuration-p
@ref{Frame Configurations, frame-configuration-p}を参照してください。

@item frame-live-p
@ref{Deleting Frames, frame-live-p}を参照してください。

@item framep
@ref{Frames, framep}を参照してください。

@item functionp
@ref{Functions, functionp}を参照してください。

@item hash-table-p
@ref{Other Hash, hash-table-p}を参照してください。

@item integer-or-marker-p
@ref{Predicates on Markers, integer-or-marker-p}を参照してください。

@item integerp
@ref{Predicates on Numbers, integerp}を参照してください。

@item keymapp
@ref{Creating Keymaps, keymapp}を参照してください。

@item keywordp
@ref{Constant Variables}を参照してください。

@item listp
@ref{List-related Predicates, listp}を参照してください。

@item markerp
@ref{Predicates on Markers, markerp}を参照してください。

@item wholenump
@ref{Predicates on Numbers, wholenump}を参照してください。

@item nlistp
@ref{List-related Predicates, nlistp}を参照してください。

@item numberp
@ref{Predicates on Numbers, numberp}を参照してください。

@item number-or-marker-p
@ref{Predicates on Markers, number-or-marker-p}を参照してください。

@item overlayp
@ref{Overlays, overlayp}を参照してください。

@item processp
@ref{Processes, processp}を参照してください。

@item sequencep
@ref{Sequence Functions, sequencep}を参照してください。

@item stringp
@ref{Predicates for Strings, stringp}を参照してください。

@item subrp
@ref{Function Cells, subrp}を参照してください。

@item symbolp
@ref{Symbols, symbolp}を参照してください。

@item syntax-table-p
@ref{Syntax Tables, syntax-table-p}を参照してください。

@item vectorp
@ref{Vectors, vectorp}を参照してください。

@item window-configuration-p
@ref{Window Configurations, window-configuration-p}を参照してください。

@item window-live-p
@ref{Deleting Windows, window-live-p}を参照してください。

@item windowp
@ref{Basic Windows, windowp}を参照してください。

@item booleanp
@ref{nil and t, booleanp}を参照してください。

@item string-or-null-p
@ref{Predicates for Strings, string-or-null-p}を参照してください。
@end table

  あるオブジェクトがどの型かチェックするもっとも一般的な方法は、関数@code{type-of}の呼び出しです。オブジェクトは、ただ1つだけの基本型に属することを思い出してください。@code{type-of}は、それがどの型(@ref{Lisp
Data
Types}を参照してください)か告げます。しかし@code{type-of}は基本型以外の型については何も知りません。ほとんどの場合、@code{type-of}より型述語を使用するほうが便利でしょう。

@defun type-of object
この関数は@var{object}の基本型を名前とする、シンボルをreturnします。retuen値はシンボル@code{bool-vector}、@code{buffer}、@code{char-table}、@code{compiled-function}、@code{cons}、@code{float}、@code{font-entity}、@code{font-object}、@code{font-spec}、@code{frame}、@code{hash-table}、@code{integer}、@code{marker}、@code{overlay}、@code{process}、@code{string}、@code{subr}、@code{symbol}、@code{vector}、@code{window}、@code{window-configuration}のうちの1つです。

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()}は@code{nil}です。}
     @result{} symbol
(type-of '(x))
     @result{} cons
@end group
@end example
@end defun

@node Equality Predicates
@section 同等性のための述語
@cindex equality

  ここでは、2つのオブジェクトの同一性をテストする関数を説明します。(たとえば文字列などの)特定の型のオブジェクト同士で、内容の同一性をテストするのは、別の関数を使用します。これらの述語にたいしては、そのデータ型を説明する、適切なチャプターを参照してください。

@defun eq object1 object2
この関数は@var{object1}と@var{object2}が同じオブジェクトの場合は@code{t}、それ以外は@code{nil}をreturnします。

@var{object1}と@var{object2}が、同じ値をもつ整数の場合、これらは同じオブジェクトと判断されます(@code{eq}は@code{t}をreturnします)。@var{object1}と@var{object2}が、同じ名前のシンボルの場合、通常は同じオブジェクトです。しかし例外もあります。@ref{Creating
Symbols}を参照してください。(リスト、ベクター文字列などの)他の型にたいしては、同じ内容(または要素)の2つの引数が、両者@code{eq}である必要はありません。これらが同じオブジェクトの場合だけ@code{eq}であり、その場合は、一方の内容を変更すると、もう一方の内容にも同じ変更が反映されます。

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq "" "")
     @result{} t
;; @r{この例外は省スペースのためにEmacs Lispが}
;; @r{ただ1つのマルチバイトの空文字列を作成するためです。}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
@code{make-symbol}関数は、internされていないシンボルをreturnします。これはLisp式内で、その名前を記述したシンボルとは区別されます。同じ名前の、異なるシンボルは、@code{eq}ではありません。@ref{Creating
Symbols}を参照してください。

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example
@end defun

@defun equal object1 object2
この関数は、@var{object1}と@var{object2}が同じ構成要素をもつ場合は@code{t}、それ以外は@code{nil}をreturnします。@code{eq}は引数が同じオブジェクトなのかテストするのにたいして、@code{equal}は同一でない引数の内部を調べて、それらの要素または内容が同一化をテストします。したがって2つのオブジェクトが@code{eq}ならば、それらは@code{equal}です。しかし、その逆は常に真ではありません。

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

文字列の比較は大文字小文字を区別しますが、テキストプロパティーは考慮しません --- これは文字列内の文字だけを比較します。@ref{Text
Properties}を参照してください。テキストプロパティーも比較する場合は、@code{equal-including-properties}を使用します。記述的な理由により、ユニバイト文字列とマルチバイト文字列は、それらが同じ文字シーケンスを含み、それらすべてのコードが0から127(@acronym{ASCII})、または160から255(@code{8ビットグラフィック})の場合に限り、@code{equal}です(@ref{Text
Representations}を参照してください)。

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

しかし2つの別のバッファーは、それらのテキスト内容が同じでも、@code{equal}と判断されることはありません。
@end defun

  @code{equal}のテストは再帰により実装されています。たとえば2つのコンスセル@var{x}と@var{y}を与えると、@code{(equal
@var{x} @var{y})}は、以下の式の両方が@code{t}をreturnする場合に限り、@code{t}をreturnします:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

これは再帰処理なので、循環するリストがあると無限再帰となります(エラーとなります)。

@defun equal-including-properties object1 object2
この関数はすべてのケースにおいて@code{equal}と同様に振る舞いますが、2つの文字列が@code{equal}になるためには、それらが同じテキストプロパティーをもつ必要があります。

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun
