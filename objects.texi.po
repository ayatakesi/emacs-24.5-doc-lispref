# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-03-26 23:02+0900\n"
"PO-Revision-Date: 2016-07-17 16:20+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: objects.texi.orig:6 objects.texi.orig:7
#, no-wrap
msgid "Lisp Data Types"
msgstr "Lisp Data Types"

#. type: cindex
#: objects.texi.orig:8
#, no-wrap
msgid "object"
msgstr "object"

#. type: cindex
#: objects.texi.orig:9
#, no-wrap
msgid "Lisp object"
msgstr "Lisp object"

#. type: cindex
#: objects.texi.orig:10
#, no-wrap
msgid "type"
msgstr "type"

#. type: cindex
#: objects.texi.orig:11
#, no-wrap
msgid "data type"
msgstr "data type"

#. type: Plain text
#: objects.texi.orig:16
msgid ""
"A Lisp @dfn{object} is a piece of data used and manipulated by Lisp "
"programs.  For our purposes, a @dfn{type} or @dfn{data type} is a set of "
"possible objects."
msgstr "Lispの@dfn{オブジェクト(object)}とは、Lispおプログラムにより操作されるデータです。@dfn{型(type)}や@dfn{データ型(data type)}は、可能なオブジェクトの集合を意味します。"

#. type: Plain text
#: objects.texi.orig:22
msgid ""
"Every object belongs to at least one type.  Objects of the same type have "
"similar structures and may usually be used in the same contexts.  Types can "
"overlap, and objects can belong to two or more types.  Consequently, we can "
"ask whether an object belongs to a particular type, but not for ``the'' type "
"of an object."
msgstr "すべてのオブジェクトは少なくとも1つの型に属します。同じ型のオブジェクトは、同様な構造をもち、通常は同じコンテキストで使用されます。型は重複でき、オブジェクトは複数の型に属することができます。結果として、あるオブジェクトが特定の型に属するかどうかを尋ねることはできますが、オブジェクトが``その''型だけに属するかどうかは決定できません。"

#. type: cindex
#: objects.texi.orig:23
#, no-wrap
msgid "primitive type"
msgstr "primitive type"

#. type: Plain text
#: objects.texi.orig:31
msgid ""
"A few fundamental object types are built into Emacs.  These, from which all "
"other types are constructed, are called @dfn{primitive types}.  Each object "
"belongs to one and only one primitive type.  These types include "
"@dfn{integer}, @dfn{float}, @dfn{cons}, @dfn{symbol}, @dfn{string}, "
"@dfn{vector}, @dfn{hash-table}, @dfn{subr}, and @dfn{byte-code function}, "
"plus several special types, such as @dfn{buffer}, that are related to "
"editing.  (@xref{Editing Types}.)"
msgstr "多くはありませんがEmacsにはいくつかの基本オブジェクト型が組み込まれています。これらの型は、他のすべての型を構成するもとであり、@dfn{基本型(primitive types)}と呼ばれます。すべてのオブジェクトはただ1つの基本型に属します。これらの型には、@dfn{整数(integer)}、@dfn{浮動小数点数(float)}、@dfn{コンス(cons)}、@dfn{シンボル(symbol)}、@dfn{文字列(string)}、@dfn{ベクター(vector)}、@dfn{ハッシュテーブル(hash-table)}、@dfn{サブルーチン(subr)}、@dfn{バイトコード関数(byte-code function)}、および@dfn{buffer}のような編集に関連した特別な型(@ref{Editing Types}を参照してください)が含まれます。"

#. type: Plain text
#: objects.texi.orig:34
msgid ""
"Each primitive type has a corresponding Lisp function that checks whether an "
"object is a member of that type."
msgstr "基本型にはそれぞれ、オブジェクトがその型のメンバーかどうかのチェックを行なう、対応するLisp関数があります。"

#. type: Plain text
#: objects.texi.orig:39
msgid ""
"Lisp is unlike many other languages in that its objects are "
"@dfn{self-typing}: the primitive type of each object is implicit in the "
"object itself.  For example, if an object is a vector, nothing can treat it "
"as a number; Lisp knows it is a vector, not a number."
msgstr "他の多くの言語とは異なり、Lispのオブジェクトは@dfn{自己記述(self-typing)}的です。オブジェクトの基本型は、オブジェクト自体に暗に含まれます。たとえばオブジェクトがベクターの場合、それを数字として扱うことはできません。Lispはベクターが数字でないことを知っているのです。"

#. type: Plain text
#: objects.texi.orig:47
msgid ""
"In most languages, the programmer must declare the data type of each "
"variable, and the type is known by the compiler but not represented in the "
"data.  Such type declarations do not exist in Emacs Lisp.  A Lisp variable "
"can have any type of value, and it remembers whatever value you store in it, "
"type and all.  (Actually, a small number of Emacs Lisp variables can only "
"take on values of a certain type.  @xref{Variables with Restricted Values}.)"
msgstr "多くの言語では、プログラマーは各変数にたいしてデータ型を宣言しなければならず、コンパイラーは型を知っていますが、データの中に型はありません。Emacs Lispには、このような型宣言はありません。Lisp変数は任意の型の値をもつことができ、変数に保存した値と型を記憶します(実際には、特定の型の値だけをもつことができる少数のEmacs Lisp変数があります。@ref{Variables with Restricted Values}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:51
msgid ""
"This chapter describes the purpose, printed representation, and read syntax "
"of each of the standard types in GNU Emacs Lisp.  Details on how to use "
"these types can be found in later chapters."
msgstr "このチャプターでは、GNU Emacs Lispの各標準型の意味、プリント表現(printed representation)、入力構文(read syntax)を説明します。これらのデータ型を使用する方法についての詳細は、以降のチャプターを参照してください。"

#. type: node
#: objects.texi.orig:60 objects.texi.orig:62
#, no-wrap
msgid "Printed Representation"
msgstr "Printed Representation"

#. type: menuentry
#: objects.texi.orig:60
msgid "How Lisp objects are represented as text."
msgstr "Lispオブジェクトがテキストとして表現される方法。"

#. type: section
#: objects.texi.orig:60 objects.texi.orig:108 objects.texi.orig:109
#, no-wrap
msgid "Comments"
msgstr "Comments"

#. type: menuentry
#: objects.texi.orig:60
msgid "Comments and their formatting conventions."
msgstr "コメントとコメント書式の慣例。"

#. type: section
#: objects.texi.orig:60 objects.texi.orig:128 objects.texi.orig:129
#, no-wrap
msgid "Programming Types"
msgstr "Programming Types"

#. type: menuentry
#: objects.texi.orig:60
msgid "Types found in all Lisp systems."
msgstr "すべてのLispシステムに存在する型。"

#. type: section
#: objects.texi.orig:60 objects.texi.orig:1364 objects.texi.orig:1365
#, no-wrap
msgid "Editing Types"
msgstr "Editing Types"

#. type: menuentry
#: objects.texi.orig:60
msgid "Types specific to Emacs."
msgstr "Emacs固有の型。"

#. type: node
#: objects.texi.orig:60 objects.texi.orig:1655
#, no-wrap
msgid "Circular Objects"
msgstr "Circular Objects"

#. type: menuentry
#: objects.texi.orig:60
msgid "Read syntax for circular structure."
msgstr "循環構造にたいする入力構文。"

#. type: section
#: objects.texi.orig:60 objects.texi.orig:1718 objects.texi.orig:1719
#, no-wrap
msgid "Type Predicates"
msgstr "Type Predicates"

#. type: menuentry
#: objects.texi.orig:60
msgid "Tests related to types."
msgstr "型に関連するテスト。"

#. type: section
#: objects.texi.orig:60 objects.texi.orig:1933 objects.texi.orig:1934
#, no-wrap
msgid "Equality Predicates"
msgstr "Equality Predicates"

#. type: menuentry
#: objects.texi.orig:60
msgid "Tests of equality between any two objects."
msgstr "2つのオブジェクトが等しいかのテスト。"

#. type: section
#: objects.texi.orig:63
#, no-wrap
msgid "Printed Representation and Read Syntax"
msgstr "Printed Representation and Read Syntax"

#. type: cindex
#: objects.texi.orig:64
#, no-wrap
msgid "printed representation"
msgstr "printed representation"

#. type: cindex
#: objects.texi.orig:65
#, no-wrap
msgid "read syntax"
msgstr "read syntax"

#. type: Plain text
#: objects.texi.orig:74
msgid ""
"The @dfn{printed representation} of an object is the format of the output "
"generated by the Lisp printer (the function @code{prin1}) for that object.  "
"Every data type has a unique printed representation.  The @dfn{read syntax} "
"of an object is the format of the input accepted by the Lisp reader (the "
"function @code{read}) for that object.  This is not necessarily unique; many "
"kinds of object have more than one syntax.  @xref{Read and Print}."
msgstr "オブジェクトのプリント表現(printed representation)とは、オブジェクトにたいしてLispプリンター(関数@code{prin1})が生成する出力のフォーマットです。すべてのデータ型は一意なプリント表現をもちます。オブジェクトの@dfn{入力構文(read syntax)}とは、オブジェクトにたいしてLispリーダー(関数@code{read})が受け取る入力のフォーマットです。これは一意である必要はありません。多くの種類のオブジェクトが複数の構文をもちます。@ref{Read and Print}を参照してください。"

#. type: cindex
#: objects.texi.orig:75
#, no-wrap
msgid "hash notation"
msgstr "hash notation"

#. type: Plain text
#: objects.texi.orig:83
msgid ""
"In most cases, an object's printed representation is also a read syntax for "
"the object.  However, some types have no read syntax, since it does not make "
"sense to enter objects of these types as constants in a Lisp program.  These "
"objects are printed in @dfn{hash notation}, which consists of the characters "
"@samp{#<}, a descriptive string (typically the type name followed by the "
"name of the object), and a closing @samp{>}.  For example:"
msgstr "ほとんどの場合、オブジェクトのプリント表記が、入力構文としても使用されます。しかしLispプログラム内の定数とすることに意味が無いいくつかの型には、入力構文がありません。これらのオブジェクトは@dfn{ハッシュ表記(hash notation)}でプリントされ、@samp{#<}、説明的な文字列(典型的には型名にオブジェクトの名前を続けたもの)、@samp{>}で構成される文字列です。たとえば:"

#. type: group
#: objects.texi.orig:87 objects.texi.orig:1448
#, no-wrap
msgid ""
"(current-buffer)\n"
"     @result{} #<buffer objects.texi>\n"
msgstr ""
"(current-buffer)\n"
"     @result{} #<buffer objects.texi>\n"

#. type: Plain text
#: objects.texi.orig:92
msgid ""
"Hash notation cannot be read at all, so the Lisp reader signals the error "
"@code{invalid-read-syntax} whenever it encounters @samp{#<}."
msgstr "ハッシュ表気は読み取ることができないので、Lispリーダーは@samp{#<}に遭遇すると、常にエラー@code{invalid-read-syntax}をシグナルします。"

#. type: kindex
#: objects.texi.orig:92
#, no-wrap
msgid "invalid-read-syntax"
msgstr "invalid-read-syntax"

#. type: Plain text
#: objects.texi.orig:99
msgid ""
"In other languages, an expression is text; it has no other form.  In Lisp, "
"an expression is primarily a Lisp object and only secondarily the text that "
"is the object's read syntax.  Often there is no need to emphasize this "
"distinction, but you must keep it in the back of your mind, or you will "
"occasionally be very confused."
msgstr "他の言語では、式はテキストであり、これ以外の形式はありません。Lispでは、第一に式はLispオブジェクトであって、オブジェクトの入力構文であるテキストは副次的なものに過ぎません。たいてい、この違いを強調する必要はありませんが、このことを心に留めておかないと、たまに混乱することがあるでしょう。"

#. type: Plain text
#: objects.texi.orig:107
msgid ""
"When you evaluate an expression interactively, the Lisp interpreter first "
"reads the textual representation of it, producing a Lisp object, and then "
"evaluates that object (@pxref{Evaluation}).  However, evaluation and reading "
"are separate activities.  Reading returns the Lisp object represented by the "
"text that is read; the object may or may not be evaluated later.  "
"@xref{Input Functions}, for a description of @code{read}, the basic function "
"for reading objects."
msgstr "インタラクティブに式を評価するとき、Lispインタープリターは最初にそれのテキスト表現を読み取り、Lispオブジェクトを生成してから、そのオブジェクトを評価します(@ref{Evaluation}を参照してください)。しかし評価と読み取りは、別の処理です。読み取りによりテキストにより表現されたLispオブジェクトを読み取り、Lispオブジェクトがreturnされます。後でオブジェクトは評価されるかもしれないし、評価されないかもしれません。オブジェクトを読み取るための基本的な関数@code{read}の説明は、@ref{Input Functions}を参照してください。"

#. type: cindex
#: objects.texi.orig:110
#, no-wrap
msgid "comments"
msgstr "comments"

#. type: cindex
#: objects.texi.orig:111
#, no-wrap
msgid "@samp{;} in comment"
msgstr "@samp{;} in comment"

#. type: Plain text
#: objects.texi.orig:120
msgid ""
"A @dfn{comment} is text that is written in a program only for the sake of "
"humans that read the program, and that has no effect on the meaning of the "
"program.  In Lisp, a semicolon (@samp{;}) starts a comment if it is not "
"within a string or character constant.  The comment continues to the end of "
"line.  The Lisp reader discards comments; they do not become part of the "
"Lisp objects which represent the program within the Lisp system."
msgstr "@dfn{コメント(comment)}hqあ、プログラム中に記述されたテキストであり、そのプログラムを読む人間ためだけに存在し、プログラムの意味には何の影響ももちません。Lispでは、それが文字列や文字定数にある場合をのぞき、セミコロン(@samp{;})でコメントが開始されます。行の終端までがコメントになります。Lispリーダーはコメントを破棄します。コメントはLispシステム内でプログラムを表すLispオブジェクトの一部にはなりません。"

#. type: Plain text
#: objects.texi.orig:125
msgid ""
"The @samp{#@@@var{count}} construct, which skips the next @var{count} "
"characters, is useful for program-generated comments containing binary "
"data.  The Emacs Lisp byte compiler uses this in its output files "
"(@pxref{Byte Compilation}).  It isn't meant for source files, however."
msgstr "@samp{#@@@var{count}}構成は、次の@var{count}個の文字をスキップします。これはプログラムにより生成されたバイナリーデータを含むコメントにたいして有用です。Emacs Lisp倍とコンパイラーは、出力ファイルにこれを使用します(@ref{Byte Compilation}を参照してください)。しかしソースファイル用ではありません。"

#. type: Plain text
#: objects.texi.orig:127
msgid "@xref{Comment Tips}, for conventions for formatting comments."
msgstr "コメントのフォーマットにたいする慣例は、@ref{Comment Tips}を参照してください。"

#. type: cindex
#: objects.texi.orig:130
#, no-wrap
msgid "programming types"
msgstr "programming types"

#. type: Plain text
#: objects.texi.orig:136
msgid ""
"There are two general categories of types in Emacs Lisp: those having to do "
"with Lisp programming, and those having to do with editing.  The former "
"exist in many Lisp implementations, in one form or another.  The latter are "
"unique to Emacs Lisp."
msgstr "Emacs Lispには2種類の一般的な型があります。1つはLispプログラミングに関わるもので、もう1つは編集に関わるものです。前者はさまざまな形で多くのLisp実装に存在します。後者はEmacs Lispに固有です。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:161 objects.texi.orig:162
#, no-wrap
msgid "Integer Type"
msgstr "Integer Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Numbers without fractional parts."
msgstr "小数部のない数字。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:206 objects.texi.orig:207
#, no-wrap
msgid "Floating-Point Type"
msgstr "Floating-Point Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Numbers with fractional parts and with a large range."
msgstr "広い範囲をもつ、小数部をもつ数字。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:224 objects.texi.orig:225
#, no-wrap
msgid "Character Type"
msgstr "Character Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "The representation of letters, numbers and control characters."
msgstr "文字、数字、コントロール文字にたいする表現。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:522 objects.texi.orig:523
#, no-wrap
msgid "Symbol Type"
msgstr "Symbol Type"

#. type: menuentry
#: objects.texi.orig:159
msgid ""
"A multi-use object that refers to a function, variable, or property list, "
"and has a unique identity."
msgstr "関数、変数、プロパティーリストを参照する、一意に識別される多目的オブジェクト。"

#. type: node
#: objects.texi.orig:159 objects.texi.orig:610
#, no-wrap
msgid "Sequence Type"
msgstr "Sequence Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Both lists and arrays are classified as sequences."
msgstr "リストと配列はどちらもシーケンスに分類されます。"

#. type: node
#: objects.texi.orig:159 objects.texi.orig:643
#, no-wrap
msgid "Cons Cell Type"
msgstr "Cons Cell Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Cons cells, and lists (which are made from cons cells)."
msgstr "コンスセル、および(コンスセルにより作られる)リスト。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:936 objects.texi.orig:937
#, no-wrap
msgid "Array Type"
msgstr "Array Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Arrays include strings and vectors."
msgstr "配列には文字列とベクターが含まれます。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:972 objects.texi.orig:973
#, no-wrap
msgid "String Type"
msgstr "String Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "An (efficient) array of characters."
msgstr "(効率的な)文字の配列。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1149 objects.texi.orig:1150
#, no-wrap
msgid "Vector Type"
msgstr "Vector Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "One-dimensional arrays."
msgstr "1次元の配列。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1169 objects.texi.orig:1170
#, no-wrap
msgid "Char-Table Type"
msgstr "Char-Table Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "One-dimensional sparse arrays indexed by characters."
msgstr "文字によりインデックスされる1次元の疎な配列。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1202 objects.texi.orig:1203
#, no-wrap
msgid "Bool-Vector Type"
msgstr "Bool-Vector Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "One-dimensional arrays of @code{t} or @code{nil}."
msgstr "@code{t}と@code{nil}からなる、1次元の配列。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1237 objects.texi.orig:1238
#, no-wrap
msgid "Hash Table Type"
msgstr "Hash Table Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "Super-fast lookup tables."
msgstr "とても高速な参照用のテーブル。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1254 objects.texi.orig:1255
#, no-wrap
msgid "Function Type"
msgstr "Function Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "A piece of executable code you can call from elsewhere."
msgstr "他の場所から呼び出せる実行可能なコードの断片。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1276 objects.texi.orig:1277
#, no-wrap
msgid "Macro Type"
msgstr "Macro Type"

#. type: menuentry
#: objects.texi.orig:159
msgid ""
"A method of expanding an expression into another expression, more "
"fundamental but less pretty."
msgstr "より基本的だが少し見栄えの悪い、式を他の式に展開する手法。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1294 objects.texi.orig:1295
#, no-wrap
msgid "Primitive Function Type"
msgstr "Primitive Function Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "A function written in C, callable from Lisp."
msgstr "Lispから呼び出せる、Cで記述された関数。"

#. type: node
#: objects.texi.orig:159 objects.texi.orig:1331
#, no-wrap
msgid "Byte-Code Type"
msgstr "Byte-Code Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "A function written in Lisp, then compiled."
msgstr "Lispで記述されてからコンパイルされた関数。"

#. type: subsection
#: objects.texi.orig:159 objects.texi.orig:1344 objects.texi.orig:1345
#, no-wrap
msgid "Autoload Type"
msgstr "Autoload Type"

#. type: menuentry
#: objects.texi.orig:159
msgid "A type used for automatically loading seldom-used functions."
msgstr "頻繁に使用されない関数を自動的にロードするために使用される型。"

#. type: Plain text
#: objects.texi.orig:166
msgid ""
"The range of values for an integer depends on the machine.  The minimum "
"range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,"
msgstr "整数の値の範囲はマシンに依存します、最小のレンジは@minus{}536,870,912から536,870,911(30ビットでは"

#. type: ifnottex
#: objects.texi.orig:168
msgid "@minus{}2**29"
msgstr "@minus{}2**29"

#. type: tex
#: objects.texi.orig:171
#, no-wrap
msgid "@math{-2^{29}}\n"
msgstr "@math{-2^{29}}\n"

#. type: Plain text
#: objects.texi.orig:173
msgid "to"
msgstr "から"

#. type: ifnottex
#: objects.texi.orig:175
msgid "2**29 @minus{} 1)"
msgstr "2**29 @minus{} 1)"

#. type: tex
#: objects.texi.orig:178
#, no-wrap
msgid "@math{2^{29}-1})\n"
msgstr "@math{2^{29}-1})\n"

#. type: Plain text
#: objects.texi.orig:182
msgid ""
"but many machines provide a wider range.  Emacs Lisp arithmetic functions do "
"not check for integer overflow.  Thus @code{(1+ 536870911)} is "
"@minus{}536,870,912 if Emacs integers are 30 bits."
msgstr "ですが、多くのマシンはこれより広い範囲を提供します。Emacs Lispの数学関数は整数のオーバーフローをチェックしません。したがってEmacsのh整数が30ビットの場合、@code{(1+ 536870911)}は@minus{}536,870,912になります。"

#. type: Plain text
#: objects.texi.orig:187
msgid ""
"The read syntax for integers is a sequence of (base ten) digits with an "
"optional sign at the beginning and an optional period at the end.  The "
"printed representation produced by the Lisp interpreter never has a leading "
"@samp{+} or a final @samp{.}."
msgstr "整数にたいする入力構文は、(10を基数とする)数字のシーケンスで、オプションで先頭に符号、最後にピリオドがつきます。Lispインタープリターにより生成されるプリント表記には、先頭の @samp{+}や、最後の@samp{.}はありません。"

#. type: group
#: objects.texi.orig:194
#, no-wrap
msgid ""
"-1               ; @r{The integer @minus{}1.}\n"
"1                ; @r{The integer 1.}\n"
"1.               ; @r{Also the integer 1.}\n"
"+1               ; @r{Also the integer 1.}\n"
msgstr ""
"-1               ; @r{整数の@minus{}1.}\n"
"1                ; @r{整数の1.}\n"
"1.               ; @r{これも整数の1.}\n"
"+1               ; @r{これも整数の1.}\n"

#. type: Plain text
#: objects.texi.orig:203
msgid ""
"As a special exception, if a sequence of digits specifies an integer too "
"large or too small to be a valid integer object, the Lisp reader reads it as "
"a floating-point number (@pxref{Floating-Point Type}).  For instance, if "
"Emacs integers are 30 bits, @code{536870912} is read as the floating-point "
"number @code{536870912.0}."
msgstr "特別な例外として、数字シーケンスが有効なオブジェクトとしては大きすぎる、または小さすぎる整数を指定する場合、Lispリーダーはそれを浮動小数点数(@ref{Floating-Point Type}を参照してください)として読み取ります。たとえば、Emacsの整数が30ビットの場合、@code{536870912}は浮動小数点数の@code{536870912.0}として読み取られます。"

#. type: Plain text
#: objects.texi.orig:205 objects.texi.orig:223
msgid "@xref{Numbers}, for more information."
msgstr "詳細は、@ref{Numbers}を参照してください。"

#. type: Plain text
#: objects.texi.orig:215
msgid ""
"Floating-point numbers are the computer equivalent of scientific notation; "
"you can think of a floating-point number as a fraction together with a power "
"of ten.  The precise number of significant figures and the range of possible "
"exponents is machine-specific; Emacs uses the C data type @code{double} to "
"store the value, and internally this records a power of 2 rather than a "
"power of 10."
msgstr "浮動小数点数は、コンピューターにおける科学表記に相当するものです。浮動小数点数を10の指数をともなう有理数として考えることができます。正確な有効桁数と可能な指数は、マシン固有です。Emacsは値の保存にCデータ型の@code{double}を使用し、内部的には10の指数ではなく、2の指数として記録します。"

#. type: Plain text
#: objects.texi.orig:221
msgid ""
"The printed representation for floating-point numbers requires either a "
"decimal point (with at least one digit following), an exponent, or both.  "
"For example, @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2}, "
"@samp{+1500000e-3}, and @samp{.15e4} are five ways of writing a "
"floating-point number whose value is 1500.  They are all equivalent."
msgstr "浮動小数点数のプリント表現には、(後に最低1つの数字をともなう)小数点と、指数のどちらか一方、または両方が必要です。たとえば@samp{1500.0}、@samp{+15e2}、@samp{15.0e+2}、@samp{+1500000e-3}、@samp{.15e4}は、いずれも浮動小数点数の1500を記述し、これらはすべて等価です。"

#. type: cindex
#: objects.texi.orig:226
#, no-wrap
msgid "@acronym{ASCII} character codes"
msgstr "@acronym{ASCII} character codes"

#. type: Plain text
#: objects.texi.orig:231
msgid ""
"A @dfn{character} in Emacs Lisp is nothing more than an integer.  In other "
"words, characters are represented by their character codes.  For example, "
"the character @kbd{A} is represented as the @w{integer 65}."
msgstr "Emacs Lispでの@dfn{文字(character)}は、整数以外の何者でもありません。他の言い方をすると、文字は文字コードで表現されます。たとえば文字@kbd{A}は、@w{整数の65}として表現されます。"

#. type: Plain text
#: objects.texi.orig:235
msgid ""
"Individual characters are used occasionally in programs, but it is more "
"common to work with @emph{strings}, which are sequences composed of "
"characters.  @xref{String Type}."
msgstr "プログラムで文字を個別に使用するのは稀であり、文字のシーケンスとして構成される@emph{文字列(strings)}として扱われるのがより一般的です。@ref{String Type}を参照してください。"

#. type: Plain text
#: objects.texi.orig:242
msgid ""
"Characters in strings and buffers are currently limited to the range of 0 to "
"4194303---twenty two bits (@pxref{Character Codes}).  Codes 0 through 127 "
"are @acronym{ASCII} codes; the rest are non-@acronym{ASCII} "
"(@pxref{Non-ASCII Characters}).  Characters that represent keyboard input "
"have a much wider range, to encode modifier keys such as Control, Meta and "
"Shift."
msgstr "文字列やバッファーの中の文字は、現在のところ0から4194303の範囲 --- つまり22ビットに制限されています(@ref{Character Codes}を参照してください)。0から127のコードは@acronym{ASCII}コードで、残りは非@acronym{ASCII}です(@ref{Non-ASCII Characters}を参照してください)。キーボード入力を表す文字は、Control、Meta、Shiftなどの修飾キーをエンコードするために、より広い範囲をもちます。"

#. type: Plain text
#: objects.texi.orig:246
msgid ""
"There are special functions for producing a human-readable textual "
"description of a character for the sake of messages.  @xref{Describing "
"Characters}."
msgstr "メッセージのために、文字にたいして人間が読むことができるテキストによる説明を生成する特別な関数が存在します。@ref{Describing Characters}を参照してください。"

#. type: subsubsection
#: objects.texi.orig:253 objects.texi.orig:255 objects.texi.orig:256
#, no-wrap
msgid "Basic Char Syntax"
msgstr "Basic Char Syntax"

#. type: menuentry
#: objects.texi.orig:253
msgid "Syntax for regular characters."
msgstr "標準的な文字の構文。"

#. type: subsubsection
#: objects.texi.orig:253 objects.texi.orig:347 objects.texi.orig:348
#, no-wrap
msgid "General Escape Syntax"
msgstr "General Escape Syntax"

#. type: menuentry
#: objects.texi.orig:253
msgid "How to specify characters by their codes."
msgstr "文字をコードにより指定する方法。"

#. type: node
#: objects.texi.orig:253 objects.texi.orig:397
#, no-wrap
msgid "Ctl-Char Syntax"
msgstr "Ctl-Char Syntax"

#. type: menuentry
#: objects.texi.orig:253
msgid "Syntax for control characters."
msgstr "コントロール文字の構文。"

#. type: node
#: objects.texi.orig:253 objects.texi.orig:448
#, no-wrap
msgid "Meta-Char Syntax"
msgstr "Meta-Char Syntax"

#. type: menuentry
#: objects.texi.orig:253
msgid "Syntax for meta-characters."
msgstr "メタ文字の構文。"

#. type: node
#: objects.texi.orig:253 objects.texi.orig:483
#, no-wrap
msgid "Other Char Bits"
msgstr "Other Char Bits"

#. type: menuentry
#: objects.texi.orig:253
msgid "Syntax for hyper-, super-, and alt-characters."
msgstr "ハイパー、スーパー、アルト文字の構文。"

#. type: cindex
#: objects.texi.orig:257
#, no-wrap
msgid "read syntax for characters"
msgstr "read syntax for characters"

#. type: cindex
#: objects.texi.orig:258
#, no-wrap
msgid "printed representation for characters"
msgstr "printed representation for characters"

#. type: cindex
#: objects.texi.orig:259
#, no-wrap
msgid "syntax for characters"
msgstr "syntax for characters"

#. type: cindex
#: objects.texi.orig:260
#, no-wrap
msgid "@samp{?} in character constant"
msgstr "@samp{?} in character constant"

#. type: cindex
#: objects.texi.orig:261
#, no-wrap
msgid "question mark in character constant"
msgstr "question mark in character constant"

#. type: Plain text
#: objects.texi.orig:269
msgid ""
"Since characters are really integers, the printed representation of a "
"character is a decimal number.  This is also a possible read syntax for a "
"character, but writing characters that way in Lisp programs is not clear "
"programming.  You should @emph{always} use the special read syntax formats "
"that Emacs Lisp provides for characters.  These syntax formats start with a "
"question mark."
msgstr "文字は実際には整数なので、文字のプリント表現は10進数です。文字にたいする入力構文も利用可能ですが、Lispプログラムでこの方法により文字を記述するのは、明解なプログラミングではありません。文字にたいしては、Emacs Lispが提供する、特別な入力構文を@emph{常に}使用するべきです。これらの構文フォーマットはクエスチョンマークで開始されます。"

#. type: Plain text
#: objects.texi.orig:274
msgid ""
"The usual read syntax for alphanumeric characters is a question mark "
"followed by the character; thus, @samp{?A} for the character @kbd{A}, "
"@samp{?B} for the character @kbd{B}, and @samp{?a} for the character "
"@kbd{a}."
msgstr "英数字にたいする通常の入力構文は、クエスチョンマークと、その後にその文字を記述します。したがって文字@kbd{A}にたいしては@samp{?A}、文字@kbd{B}にたいしては@samp{?B}、文字@kbd{a}にたいしては@samp{?a}となります。"

#. type: Plain text
#: objects.texi.orig:276
msgid "For example:"
msgstr "たとえば:"

#. type: example
#: objects.texi.orig:279
#, no-wrap
msgid "?Q @result{} 81     ?q @result{} 113\n"
msgstr "?Q @result{} 81     ?q @result{} 113\n"

#. type: Plain text
#: objects.texi.orig:286
msgid ""
"You can use the same syntax for punctuation characters, but it is often a "
"good idea to add a @samp{\\} so that the Emacs commands for editing Lisp "
"code don't get confused.  For example, @samp{?\\(} is the way to write the "
"open-paren character.  If the character is @samp{\\}, you @emph{must} use a "
"second @samp{\\} to quote it: @samp{?\\\\}."
msgstr "句読点文字にも同じ構文を使用できますが、Lispコードを編集するためのEmacsコマンドが混乱しないように、@samp{\\}を追加するのがよい場合がしばしばあります。たとえば開きカッコを記述するために@samp{?\\(}と記述します。その文字が@samp{\\}の場合、それをクォートするために、@samp{?\\\\}のように2つ目の@samp{\\}を使用しなければ@emph{なりません}。"

#. type: cindex
#: objects.texi.orig:287
#, no-wrap
msgid "whitespace"
msgstr "whitespace"

#. type: cindex
#: objects.texi.orig:288
#, no-wrap
msgid "bell character"
msgstr "bell character"

#. type: samp{#1}
#: objects.texi.orig:289
#, no-wrap
msgid "\\a"
msgstr "\\a"

#. type: cindex
#: objects.texi.orig:290
#, no-wrap
msgid "backspace"
msgstr "backspace"

#. type: samp{#1}
#: objects.texi.orig:291
#, no-wrap
msgid "\\b"
msgstr "\\b"

#. type: cindex
#: objects.texi.orig:292
#, no-wrap
msgid "tab (ASCII character)"
msgstr "tab (ASCII character)"

#. type: samp{#1}
#: objects.texi.orig:293
#, no-wrap
msgid "\\t"
msgstr "\\t"

#. type: cindex
#: objects.texi.orig:294
#, no-wrap
msgid "vertical tab"
msgstr "vertical tab"

#. type: samp{#1}
#: objects.texi.orig:295
#, no-wrap
msgid "\\v"
msgstr "\\v"

#. type: cindex
#: objects.texi.orig:296
#, no-wrap
msgid "formfeed"
msgstr "formfeed"

#. type: samp{#1}
#: objects.texi.orig:297
#, no-wrap
msgid "\\f"
msgstr "\\f"

#. type: cindex
#: objects.texi.orig:298
#, no-wrap
msgid "newline"
msgstr "newline"

#. type: samp{#1}
#: objects.texi.orig:299
#, no-wrap
msgid "\\n"
msgstr "\\n"

#. type: cindex
#: objects.texi.orig:300
#, no-wrap
msgid "return (ASCII character)"
msgstr "return (ASCII character)"

#. type: samp{#1}
#: objects.texi.orig:301
#, no-wrap
msgid "\\r"
msgstr "\\r"

#. type: cindex
#: objects.texi.orig:302
#, no-wrap
msgid "escape (ASCII character)"
msgstr "escape (ASCII character)"

#. type: samp{#1}
#: objects.texi.orig:303
#, no-wrap
msgid "\\e"
msgstr "\\e"

#. type: cindex
#: objects.texi.orig:304
#, no-wrap
msgid "space (ASCII character)"
msgstr "space (ASCII character)"

#. type: samp{#1}
#: objects.texi.orig:305
#, no-wrap
msgid "\\s"
msgstr "\\s"

#. type: Plain text
#: objects.texi.orig:312
msgid ""
"You can express the characters control-g, backspace, tab, newline, vertical "
"tab, formfeed, space, return, del, and escape as @samp{?\\a}, @samp{?\\b}, "
"@samp{?\\t}, @samp{?\\n}, @samp{?\\v}, @samp{?\\f}, @samp{?\\s}, "
"@samp{?\\r}, @samp{?\\d}, and @samp{?\\e}, respectively.  (@samp{?\\s} "
"followed by a dash has a different meaning---it applies the ``super'' "
"modifier to the following character.)  Thus,"
msgstr "control-g、backspace、tab、newline、vertical tab、formfeed、space、return、del、escapeはそれぞれ@samp{?\\a}、@samp{?\\b}、@samp{?\\t}、@samp{?\\n}、@samp{?\\v}、@samp{?\\f}、@samp{?\\s}、@samp{?\\r}、@samp{?\\d}、@samp{?\\e}と表すことができます(後にダッシュのついた@samp{?\\s}は違う意味をもちます --- これは後続の文字にたいして``super''の修飾を適用します)。したがって、"

#. type: example
#: objects.texi.orig:325
#, no-wrap
msgid ""
"?\\a @result{} 7                 ; @r{control-g, @kbd{C-g}}\n"
"?\\b @result{} 8                 ; @r{backspace, @key{BS}, @kbd{C-h}}\n"
"?\\t @result{} 9                 ; @r{tab, @key{TAB}, @kbd{C-i}}\n"
"?\\n @result{} 10                ; @r{newline, @kbd{C-j}}\n"
"?\\v @result{} 11                ; @r{vertical tab, @kbd{C-k}}\n"
"?\\f @result{} 12                ; @r{formfeed character, @kbd{C-l}}\n"
"?\\r @result{} 13                ; @r{carriage return, @key{RET}, "
"@kbd{C-m}}\n"
"?\\e @result{} 27                ; @r{escape character, @key{ESC}, "
"@kbd{C-[}}\n"
"?\\s @result{} 32                ; @r{space character, @key{SPC}}\n"
"?\\\\ @result{} 92                ; @r{backslash character, @kbd{\\}}\n"
"?\\d @result{} 127               ; @r{delete character, @key{DEL}}\n"
msgstr ""
"?\\a @result{} 7                 ; @r{control-g, @kbd{C-g}}\n"
"?\\b @result{} 8                 ; @r{backspace, @key{BS}, @kbd{C-h}}\n"
"?\\t @result{} 9                 ; @r{tab, @key{TAB}, @kbd{C-i}}\n"
"?\\n @result{} 10                ; @r{newline, @kbd{C-j}}\n"
"?\\v @result{} 11                ; @r{vertical tab, @kbd{C-k}}\n"
"?\\f @result{} 12                ; @r{formfeed character, @kbd{C-l}}\n"
"?\\r @result{} 13                ; @r{carriage return, @key{RET}, @kbd{C-m}}\n"
"?\\e @result{} 27                ; @r{escape character, @key{ESC}, @kbd{C-[}}\n"
"?\\s @result{} 32                ; @r{space character, @key{SPC}}\n"
"?\\\\ @result{} 92                ; @r{backslash character, @kbd{\\}}\n"
"?\\d @result{} 127               ; @r{delete character, @key{DEL}}\n"

#. type: cindex
#: objects.texi.orig:327
#, no-wrap
msgid "escape sequence"
msgstr "escape sequence"

#. type: Plain text
#: objects.texi.orig:333
msgid ""
"These sequences which start with backslash are also known as @dfn{escape "
"sequences}, because backslash plays the role of an ``escape character''; "
"this terminology has nothing to do with the character @key{ESC}.  @samp{\\s} "
"is meant for use in character constants; in string constants, just write the "
"space."
msgstr "バックスラッシュが``エスケープ文字(escape character)''の役割を果たすので、これらのバックスラッシュで始まるシーケンスは@dfn{エスケープシーケンス(escape sequences)}とも呼ばれます。この用語法は、文字@key{ESC}とは関係ありません。@samp{\\s}は文字定数としての使用を意図しており、文字定数の内部では、単にスペースを記述します。"

#. type: Plain text
#: objects.texi.orig:346
msgid ""
"A backslash is allowed, and harmless, preceding any character without a "
"special escape meaning; thus, @samp{?\\+} is equivalent to @samp{?+}.  There "
"is no reason to add a backslash before most characters.  However, you should "
"add a backslash before any of the characters @samp{()\\|;'`\"#.,} to avoid "
"confusing the Emacs commands for editing Lisp code.  You can also add a "
"backslash before whitespace characters such as space, tab, newline and "
"formfeed.  However, it is cleaner to use one of the easily readable escape "
"sequences, such as @samp{\\t} or @samp{\\s}, instead of an actual whitespace "
"character such as a tab or a space.  (If you do write backslash followed by "
"a space, you should write an extra space after the character constant to "
"separate it from the following text.)"
msgstr "エスケープという特別な意味を与えずに、任意の文字の前にバックスラッシュの使用することは許されており、害もありませんしたがって@samp{?\\+}は@samp{?+}と等価です。ほとんどの文字の前にバックスラッシュを追加することに理由はありません。しかし、Lispコードを編集するEmacsコマンドが混乱するのを避けるために、文字@samp{()\\|;'`\"#.,}の前にはバックスラッシュを追加するべきです。space、tab、newline、formfeedのような空白文字の前にもバックスラッシュを追加できます。しかし、tabやspaceのような実際の空白文字のかわりに、@samp{\\t}や@samp{\\s}のような可読性のあるエスケープシーケンスを使用するほうが明解です(スペースを後にともなうバックスラッシュを記述する場合、後続のテキストと区別するために、文字定数の後に余分なスペースを記述するべきです)。"

#. type: Plain text
#: objects.texi.orig:353
msgid ""
"In addition to the specific escape sequences for special important control "
"characters, Emacs provides several types of escape syntax that you can use "
"to specify non-@acronym{ASCII} text characters."
msgstr "特に重要なコントロール文字にたいする特別なエスケープシーケンスに加えて、Emacsは非@acronym{ASCII}テキスト文字の指定に使用できる、何種類かのエスケープ構文を提供します。"

#. type: cindex
#: objects.texi.orig:354
#, no-wrap
msgid "@samp{\\} in character constant"
msgstr "@samp{\\} in character constant"

#. type: cindex
#: objects.texi.orig:355
#, no-wrap
msgid "backslash in character constants"
msgstr "backslash in character constants"

#. type: cindex
#: objects.texi.orig:356
#, no-wrap
msgid "unicode character escape"
msgstr "unicode character escape"

#. type: Plain text
#: objects.texi.orig:363
msgid ""
"Firstly, you can specify characters by their Unicode values.  "
"@code{?\\u@var{nnnn}} represents a character with Unicode code point "
"@samp{U+@var{nnnn}}, where @var{nnnn} is (by convention) a hexadecimal "
"number with exactly four digits.  The backslash indicates that the "
"subsequent characters form an escape sequence, and the @samp{u} specifies a "
"Unicode escape sequence."
msgstr "最初に、文字をUnicodeの値で指定することができます。@code{?\\u@var{nnnn}}はUnicodeのコードポイント@samp{U+@var{nnnn}}の文字を表します。ここで@var{nnnn}は、(慣例により)正確に4桁の16進数です。バックスラッシュは、後続の文字がエスケープシーケンスを形成することを示し、@samp{u}はUnicodeエスケープシーケンスを指定します。"

#. type: Plain text
#: objects.texi.orig:371
msgid ""
"There is a slightly different syntax for specifying Unicode characters with "
"code points higher than @code{U+@var{ffff}}: @code{?\\U00@var{nnnnnn}} "
"represents the character with code point @samp{U+@var{nnnnnn}}, where "
"@var{nnnnnn} is a six-digit hexadecimal number.  The Unicode Standard only "
"defines code points up to @samp{U+@var{10ffff}}, so if you specify a code "
"point higher than that, Emacs signals an error."
msgstr "@code{U+@var{ffff}}より大きなコードポイントをもつUnicode文字を指定するために、若干異なる構文が存在します。@code{?\\U00@var{nnnnnn}}はコードポイント@samp{U+@var{nnnnnn}}の文字を表します。ここで@var{nnnnnn}は6桁の16進数です。Unicode Standardは@samp{U+@var{10ffff}}までのコードポイントだけを定義するので、これより大きいコードポイントを指定すると、Emacsはエラーをシグナルします。"

#. type: Plain text
#: objects.texi.orig:377
msgid ""
"Secondly, you can specify characters by their hexadecimal character codes.  "
"A hexadecimal escape sequence consists of a backslash, @samp{x}, and the "
"hexadecimal character code.  Thus, @samp{?\\x41} is the character @kbd{A}, "
"@samp{?\\x1} is the character @kbd{C-a}, and @code{?\\xe0} is the character"
msgstr "次に、文字を16進の文字コードで指定できます。16進エスケープシーケンスは、バックスラッシュ、@samp{x}、および16進の文字コードにより構成されます。したがって@samp{?\\x41}は文字@kbd{A}、@samp{?\\x1}は文字@kbd{C-a}、@code{?\\xe0}は"

#. type: iftex
#: objects.texi.orig:379
msgid "@samp{@`a}."
msgstr "文字@samp{@`a}を表します。"

#. type: ifnottex
#: objects.texi.orig:382
msgid "@samp{a} with grave accent."
msgstr "grave accentつきの文字@samp{a}を表します。"

#. type: Plain text
#: objects.texi.orig:385
msgid ""
"You can use any number of hex digits, so you can represent any character "
"code in this way."
msgstr "任意の数の16進数を使用できるので、この方法により任意の文字コードを表すことができます。"

#. type: cindex
#: objects.texi.orig:386
#, no-wrap
msgid "octal character code"
msgstr "octal character code"

#. type: Plain text
#: objects.texi.orig:393
msgid ""
"Thirdly, you can specify characters by their character code in octal.  An "
"octal escape sequence consists of a backslash followed by up to three octal "
"digits; thus, @samp{?\\101} for the character @kbd{A}, @samp{?\\001} for the "
"character @kbd{C-a}, and @code{?\\002} for the character @kbd{C-b}.  Only "
"characters up to octal code 777 can be specified this way."
msgstr "最後に、8進の文字コードにより文字を指定できます。8進エスケープシーケンスは、3桁までの8進数字をともなうバックスラッシュにより形成されます。したがって@samp{?\\101}は文字@kbd{A}、@samp{?\\001}は文字@kbd{C-a}、@code{?\\002}は文字@kbd{C-b}を表します。この方法で指定できるのは、8進コード777までの文字だけです。"

#. type: Plain text
#: objects.texi.orig:396
msgid ""
"These escape sequences may also be used in strings.  @xref{Non-ASCII in "
"Strings}."
msgstr "これらのエスケープシーケンスは、文字列内でも使用されます。@ref{Non-ASCII in Strings}を参照してください。"

#. type: subsubsection
#: objects.texi.orig:398
#, no-wrap
msgid "Control-Character Syntax"
msgstr "Control-Character Syntax"

#. type: cindex
#: objects.texi.orig:400
#, no-wrap
msgid "control characters"
msgstr "control characters"

#. type: Plain text
#: objects.texi.orig:406
msgid ""
"Control characters can be represented using yet another read syntax.  This "
"consists of a question mark followed by a backslash, caret, and the "
"corresponding non-control character, in either upper or lower case.  For "
"example, both @samp{?\\^I} and @samp{?\\^i} are valid read syntax for the "
"character @kbd{C-i}, the character whose value is 9."
msgstr "他の入力構文を使用してコントロール文字を表すことができます。これは後にバックスラッシュ、カレット、対応する非コントロール文字(大文字か小文字)をともなうクエスチョンマークから構成されます。たとえば@samp{?\\^I}と@samp{?\\^i}はどちらも、値が9である文字@kbd{C-i}にたいする、有効な入力構文です。"

#. type: Plain text
#: objects.texi.orig:409
msgid ""
"Instead of the @samp{^}, you can use @samp{C-}; thus, @samp{?\\C-i} is "
"equivalent to @samp{?\\^I} and to @samp{?\\^i}:"
msgstr "@samp{^}のかわりに、@samp{C-}を使用することもできます。したがって@samp{?\\C-i}は、@samp{?\\^I}や@samp{?\\^i}と等価です。"

#. type: example
#: objects.texi.orig:412
#, no-wrap
msgid "?\\^I @result{} 9     ?\\C-I @result{} 9\n"
msgstr "?\\^I @result{} 9     ?\\C-I @result{} 9\n"

#. type: Plain text
#: objects.texi.orig:418
msgid ""
"In strings and buffers, the only control characters allowed are those that "
"exist in @acronym{ASCII}; but for keyboard input purposes, you can turn any "
"character into a control character with @samp{C-}.  The character codes for "
"these non-@acronym{ASCII} control characters include the"
msgstr "文字列やバッファーの中では、@acronym{ASCII}のコントロール文字だけが許されますが、キーボード入力にたいしては@samp{C-}により任意の文字をコントロール文字にすることができます。これらの非@acronym{ASCII}のコントロール文字にたいするコントロール文字には"

#. type: tex
#: objects.texi.orig:420
#, no-wrap
msgid "@math{2^{26}}\n"
msgstr "非コントロール文字にたいするコードと同様に、@math{2^{26}}\n"

#. type: ifnottex
#: objects.texi.orig:423
msgid "2**26"
msgstr "非コントロール文字にたいするコードと同様に、2**26"

#. type: Plain text
#: objects.texi.orig:428
msgid ""
"bit as well as the code for the corresponding non-control character.  "
"Ordinary text terminals have no way of generating non-@acronym{ASCII} "
"control characters, but you can generate them straightforwardly using X and "
"other window systems."
msgstr "ビットが含まれます。通常のテキスト端末には、非@acronym{ASCII}コントロール文字を生成する方法がありませんが、Xおよび他のウィンドウシステムを使用することにより、簡単に生成することができます。"

#. type: Plain text
#: objects.texi.orig:431
msgid ""
"For historical reasons, Emacs treats the @key{DEL} character as the control "
"equivalent of @kbd{?}:"
msgstr "歴史的な理由により、Emacsは@key{DEL}文字を、@kbd{?}のコントロール文字として扱います:"

#. type: example
#: objects.texi.orig:434
#, no-wrap
msgid "?\\^? @result{} 127     ?\\C-? @result{} 127\n"
msgstr "?\\^? @result{} 127     ?\\C-? @result{} 127\n"

#. type: Plain text
#: objects.texi.orig:441
msgid ""
"As a result, it is currently not possible to represent the character "
"@kbd{Control-?}, which is a meaningful input character under X, using "
"@samp{\\C-}.  It is not easy to change this, as various Lisp files refer to "
"@key{DEL} in this way."
msgstr "結果として、Xでは有意な入力文字である@kbd{Control-?}文字を、@samp{\\C-}を使用して表現することは今のところできません。さまざまなLispファイルがこの方法により@key{DEL}を参照するため、これを変更するのは簡単ではありません。"

#. type: Plain text
#: objects.texi.orig:447
msgid ""
"For representing control characters to be found in files or strings, we "
"recommend the @samp{^} syntax; for control characters in keyboard input, we "
"prefer the @samp{C-} syntax.  Which one you use does not affect the meaning "
"of the program, but may guide the understanding of people who read it."
msgstr "コントロール文字の表現はファイルや文字列のなかで見ることができますが、わたしたちは@samp{^}構文を推奨します。キーボード入力にたいするコントロール文字に好ましいのは、@samp{C-}構文です。どちらを使用するかはプログラムの意味に影響しませんが、プログラムを読む人の理解を助けるでしょう。"

#. type: subsubsection
#: objects.texi.orig:449
#, no-wrap
msgid "Meta-Character Syntax"
msgstr "Meta-Character Syntax"

#. type: cindex
#: objects.texi.orig:451
#, no-wrap
msgid "meta characters"
msgstr "meta characters"

#. type: Plain text
#: objects.texi.orig:454
msgid ""
"A @dfn{meta character} is a character typed with the @key{META} modifier "
"key.  The integer that represents such a character has the"
msgstr "@dfn{メタ文字(meta character)}とは、@key{META}修飾キーとともにタイプされた文字です。そのような文字を表す整数には"

#. type: tex
#: objects.texi.orig:456
#, no-wrap
msgid "@math{2^{27}}\n"
msgstr "@math{2^{27}}\n"

#. type: ifnottex
#: objects.texi.orig:459
msgid "2**27"
msgstr "2**27"

#. type: Plain text
#: objects.texi.orig:462
msgid ""
"bit set.  We use high bits for this and other modifiers to make possible a "
"wide range of basic character codes."
msgstr "のビットがセットされています。基本的な文字コードの広い範囲を利用可能にするために、メタや他の修飾にたいして上位ビットを使用します。"

#. type: Plain text
#: objects.texi.orig:464
msgid "In a string, the"
msgstr "文字列では、メタ文字を示す@acronym{ASCII}文字に、"

#. type: tex
#: objects.texi.orig:466 objects.texi.orig:1096
#, no-wrap
msgid "@math{2^{7}}\n"
msgstr "@math{2^{7}}\n"

#. type: ifnottex
#: objects.texi.orig:469 objects.texi.orig:1099
msgid "2**7"
msgstr "2**7"

#. type: Plain text
#: objects.texi.orig:475
msgid ""
"bit attached to an @acronym{ASCII} character indicates a meta character; "
"thus, the meta characters that can fit in a string have codes in the range "
"from 128 to 255, and are the meta versions of the ordinary @acronym{ASCII} "
"characters.  @xref{Strings of Events}, for details about @key{META}-handling "
"in strings."
msgstr "ビットが付加されます。したがって文字列に含めることができるメタ文字のコードは1から255の範囲となり、メタ文字は通常の@acronym{ASCII}文字のメタ修飾されたバージョンとなります。文字列内での@key{META}処理の詳細については、@ref{Strings of Events}を参照してください。"

#. type: Plain text
#: objects.texi.orig:482
msgid ""
"The read syntax for meta characters uses @samp{\\M-}.  For example, "
"@samp{?\\M-A} stands for @kbd{M-A}.  You can use @samp{\\M-} together with "
"octal character codes (see below), with @samp{\\C-}, or with any other "
"syntax for a character.  Thus, you can write @kbd{M-A} as @samp{?\\M-A}, or "
"as @samp{?\\M-\\101}.  Likewise, you can write @kbd{C-M-b} as "
"@samp{?\\M-\\C-b}, @samp{?\\C-\\M-b}, or @samp{?\\M-\\002}."
msgstr "メタ文字の入力構文には@samp{\\M-}を使用します。たとえば@samp{?\\M-A}は@kbd{M-A}を意味します。8進文字コード(以下参照)や、@samp{\\C-}、その他の文字にたいする他の構文とともに@samp{\\M-}を使用できます。したがって、@kbd{M-A}は@samp{?\\M-A}や@samp{?\\M-\\101}と記述できます。同様に、@kbd{C-M-b}は@samp{?\\M-\\C-b}、@samp{?\\C-\\M-b}、@samp{?\\M-\\002}と記述することができます。"

#. type: subsubsection
#: objects.texi.orig:484
#, no-wrap
msgid "Other Character Modifier Bits"
msgstr "Other Character Modifier Bits"

#. type: Plain text
#: objects.texi.orig:490
msgid ""
"The case of a graphic character is indicated by its character code; for "
"example, @acronym{ASCII} distinguishes between the characters @samp{a} and "
"@samp{A}.  But @acronym{ASCII} has no way to represent whether a control "
"character is upper case or lower case.  Emacs uses the"
msgstr "グラフィック文字(graphic character)の大文字小文字は、文字コードで示されます。たとえば@acronym{ASCII}では、文字@samp{a}と文字@samp{A}は区別されます。しかし@acronym{ASCII}にはコントロール文字が大文字なのか小文字なのかを表現する方法がありません。コントロール文字がタイプされたときシフトキーが使用されたかを示すために、Emacsは"

#. type: tex
#: objects.texi.orig:492
#, no-wrap
msgid "@math{2^{25}}\n"
msgstr "@math{2^{25}}\n"

#. type: ifnottex
#: objects.texi.orig:495
msgid "2**25"
msgstr "2**25"

#. type: Plain text
#: objects.texi.orig:502
msgid ""
"bit to indicate that the shift key was used in typing a control character.  "
"This distinction is possible only when you use X terminals or other special "
"terminals; ordinary text terminals do not report the distinction.  The Lisp "
"syntax for the shift bit is @samp{\\S-}; thus, @samp{?\\C-\\S-o} or "
"@samp{?\\C-\\S-O} represents the shifted-control-o character."
msgstr "のビットを使用します。この区別は、X端末や、他の特別な端末を使用しているときだけ可能です。通常のテキスト端末は、これらの違いを報告しません。シフトをあらわすビットのためのLisp構文は@samp{\\S-}です。したがって@samp{?\\C-\\S-o}や@samp{?\\C-\\S-O}は、shifted-control-o文字を表します。"

#. type: cindex
#: objects.texi.orig:503
#, no-wrap
msgid "hyper characters"
msgstr "hyper characters"

#. type: cindex
#: objects.texi.orig:504
#, no-wrap
msgid "super characters"
msgstr "super characters"

#. type: cindex
#: objects.texi.orig:505
#, no-wrap
msgid "alt characters"
msgstr "alt characters"

#. type: Plain text
#: objects.texi.orig:513
msgid ""
"The X Window System defines three other @anchor{modifier bits}modifier bits "
"that can be set in a character: @dfn{hyper}, @dfn{super} and @dfn{alt}.  The "
"syntaxes for these bits are @samp{\\H-}, @samp{\\s-} and @samp{\\A-}.  (Case "
"is significant in these prefixes.)  Thus, @samp{?\\H-\\M-\\A-x} represents "
"@kbd{Alt-Hyper-Meta-x}.  (Note that @samp{\\s} with no following @samp{-} "
"represents the space character.)"
msgstr "Xウィンドウシステムは文字にセットできる、他に3つ@anchor{modifier bits}修飾ビット --- @dfn{hyper}、@dfn{super}、@dfn{alt}を定義します。これらのビットにたいする構文は、@samp{\\H-}、@samp{\\s-}、@samp{\\A-}です(これらのプレフィクスでは、大文字小文字は意味があります)。したがって@samp{?\\H-\\M-\\A-x}は@kbd{Alt-Hyper-Meta-x}を表します(@samp{-}が後にない@samp{\\s}は、スペース文字を表すことに注意してください)。"

#. type: tex
#: objects.texi.orig:516
#, no-wrap
msgid ""
"Numerically, the bit values are @math{2^{22}} for alt, @math{2^{23}}\n"
"for super and @math{2^{24}} for hyper.\n"
msgstr "数値としては、ビット値@math{2^{22}}はalt、@math{2^{23}}はsuper、@math{2^{24}}はhyperです。\n"

#. type: ifnottex
#: objects.texi.orig:520
msgid ""
"Numerically, the bit values are 2**22 for alt, 2**23 for super and 2**24 for "
"hyper."
msgstr "数値的には、ビット値2**22はalt、2**23はsuper、2**24はhyperです。"

#. type: Plain text
#: objects.texi.orig:529
msgid ""
"A @dfn{symbol} in GNU Emacs Lisp is an object with a name.  The symbol name "
"serves as the printed representation of the symbol.  In ordinary Lisp use, "
"with one single obarray (@pxref{Creating Symbols}), a symbol's name is "
"unique---no two symbols have the same name."
msgstr "GNU Emacs Lispでの@dfn{シンボル(symbol)}とは、名前をもつオブジェクトです。シンボル名は、そのシンボルのプリント表現としての役割があります。Lispの通常の使用では、1つのobarray(@ref{Creating Symbols}を参照してください)により、シンボル名は一意です --- 2つのシンボルが同じ名前をもつことはありません。"

#. type: Plain text
#: objects.texi.orig:536
msgid ""
"A symbol can serve as a variable, as a function name, or to hold a property "
"list.  Or it may serve only to be distinct from all other Lisp objects, so "
"that its presence in a data structure may be recognized reliably.  In a "
"given context, usually only one of these uses is intended.  But you can use "
"one symbol in all of these ways, independently."
msgstr "シンボルは、変数、関数名としての役割や、プロパティーリストを保持する役割をもつことができます。他のすべてのLispオブジェクトから区別するためだけの役割をもつ場合もあり、データ構造内にそのようなシンボルが存在することは、確実に認識されるでしょう。与えられたコンテキストにおいて、通常はこれらのうちの1つの使用だけが意図されます。しかし3つすべての方法で、1つのシンボルを独立して使用することもできます。"

#. type: Plain text
#: objects.texi.orig:541
msgid ""
"A symbol whose name starts with a colon (@samp{:}) is called a @dfn{keyword "
"symbol}.  These symbols automatically act as constants, and are normally "
"used only by comparing an unknown symbol with a few specific alternatives.  "
"@xref{Constant Variables}."
msgstr "名前がコロン(@samp{:})で開始されるシンボルは、@dfn{キーワードシンボル(keyword symbol)}と呼ばれます。これらのシンボルは自動的に定数として振る舞い、通常は未知のシンボルと、いくつかの特定の候補を比較することだけに使用されます。@ref{Constant Variables}を参照してください。"

#. type: cindex
#: objects.texi.orig:542
#, no-wrap
msgid "@samp{\\} in symbols"
msgstr "@samp{\\} in symbols"

#. type: cindex
#: objects.texi.orig:543
#, no-wrap
msgid "backslash in symbols"
msgstr "backslash in symbols"

#. type: Plain text
#: objects.texi.orig:559
msgid ""
"A symbol name can contain any characters whatever.  Most symbol names are "
"written with letters, digits, and the punctuation characters @samp{-+=*/}.  "
"Such names require no special punctuation; the characters of the name "
"suffice as long as the name does not look like a number.  (If it does, write "
"a @samp{\\} at the beginning of the name to force interpretation as a "
"symbol.)  The characters @samp{_~!@@$%^&:<>@{@}?} are less often used but "
"also require no special punctuation.  Any other characters may be included "
"in a symbol's name by escaping them with a backslash.  In contrast to its "
"use in strings, however, a backslash in the name of a symbol simply quotes "
"the single character that follows the backslash.  For example, in a string, "
"@samp{\\t} represents a tab character; in the name of a symbol, however, "
"@samp{\\t} merely quotes the letter @samp{t}.  To have a symbol with a tab "
"character in its name, you must actually use a tab (preceded with a "
"backslash).  But it's rare to do such a thing."
msgstr ""
"シンボル名にはどんな文字でも含めることができます。ほとんどのシンボル名は英字、数字、@samp{-+=*/}などの句読点文字で記述されます。このような名前には、特別な句読点文字は必要ありません。名前が数字のように見えない限りは、名前にはどのような文字も使用できます(名前が数字のように見える場合は、名前の先頭に@samp{\\}を記述して、強制的にシンボルとして解釈させます)。文字@samp{_~!@@$%^&:<>@{@}?}はあまり使用されませんが、これらも特別な句読点文字を必要としません。他の文字も、バックスラッシュでエスケープすることにより、シンボル名に含めることができます。しかし、文字列内でのバックスラッシュの使用とは対照的に、シンボル名でのバックスラッシュは、バックスラッシュの後の1文字をエスケープするだけです。たとえば文字列内では、@samp{\\t}はタブ文字を表します。しかしシンボル名の中では、@samp{\\t}は英字@samp{t}をクォートするに過ぎません。\n"
"名前にタブ文字をもつシンボルを記述するには、(バックスラッシュを前置した)実際のタブを使用しなければなりません。しかし、そのようなことを行なうことは、めったにありません。"

#. type: cindex
#: objects.texi.orig:560
#, no-wrap
msgid "CL note---case of letters"
msgstr "CL note---case of letters"

#. type: quotation
#: objects.texi.orig:565
msgid ""
"@b{Common Lisp note:} In Common Lisp, lower case letters are always "
"``folded'' to upper case, unless they are explicitly escaped.  In Emacs "
"Lisp, upper case and lower case letters are distinct."
msgstr "@b{Common Lispに関する注意:}Common Lispでは、明示的にエスケープされない限り、小文字は常に大文字に``フォールドされ(folded)''ます。Emacs Lispでは大文字と小文字は区別されます。"

#. type: Plain text
#: objects.texi.orig:571
msgid ""
"Here are several examples of symbol names.  Note that the @samp{+} in the "
"fourth example is escaped to prevent it from being read as a number.  This "
"is not necessary in the sixth example because the rest of the name makes it "
"invalid as a number."
msgstr "以下はシンボル名の例です。4番目の例の中の@samp{+}は、シンボルが数字として読み取られるのを防ぐために、エスケープされていることに注意してください。6番目の例では、名前の残りの部分により数字としては不正なので、エスケープの必要はありません。"

#. type: group
#: objects.texi.orig:576
#, no-wrap
msgid ""
"foo                 ; @r{A symbol named @samp{foo}.}\n"
"FOO                 ; @r{A symbol named @samp{FOO}, different from "
"@samp{foo}.}\n"
msgstr ""
"foo                 ; @r{@samp{foo}という名前のシンボル。}\n"
"FOO                 ; @r{@samp{foo}とは別の、@samp{FOO}という名前のシンボル。}\n"

#. type: group
#: objects.texi.orig:580
#, no-wrap
msgid ""
"1+                  ; @r{A symbol named @samp{1+}}\n"
"                    ;   @r{(not @samp{+1}, which is an integer).}\n"
msgstr ""
"1+                  ; @r{@samp{1+}という名前のシンボル}\n"
"                    ;   @r{(整数の@samp{+1}ではありません)。}\n"

#. type: group
#: objects.texi.orig:584
#, no-wrap
msgid ""
"\\+1                 ; @r{A symbol named @samp{+1}}\n"
"                    ;   @r{(not a very readable name).}\n"
msgstr ""
"\\+1                 ; @r{@samp{+1}という名前のシンボル}\n"
"                    ;   @r{(とても読みやすい名前とはいえません)。}\n"

#. type: group
#: objects.texi.orig:591
#, no-wrap
msgid ""
"\\(*\\ 1\\ 2\\)         ; @r{A symbol named @samp{(* 1 2)} (a worse "
"name).}\n"
"+-*/_~!@@$%^&=:<>@{@}  ; @r{A symbol named @samp{+-*/_~!@@$%^&=:<>@{@}}.}\n"
"                    ;   @r{These characters need not be escaped.}\n"
msgstr ""
"\\(*\\ 1\\ 2\\)         ; @r{@samp{(* 1 2)}という名前のシンボル(悪い名前)。}\n"
"+-*/_~!@@$%^&=:<>@{@}  ; @r{@samp{+-*/_~!@@$%^&=:<>@{@}}という名前のシンボル。}\n"
"                    ;   @r{これらの文字はエスケープする必要はありません。}\n"

#. type: cindex
#: objects.texi.orig:594
#, no-wrap
msgid "@samp{##} read syntax"
msgstr "@samp{##} read syntax"

#. type: cindex
#: objects.texi.orig:598
#, no-wrap
msgid "@samp{#@var{colon}} read syntax"
msgstr "@samp{#@var{colon}} read syntax"

#. type: cindex
#: objects.texi.orig:601
#, no-wrap
msgid "@samp{#:} read syntax"
msgstr "@samp{#:} read syntax"

#. type: Plain text
#: objects.texi.orig:609
msgid ""
"As an exception to the rule that a symbol's name serves as its printed "
"representation, @samp{##} is the printed representation for an interned "
"symbol whose name is an empty string.  Furthermore, @samp{#:@var{foo}} is "
"the printed representation for an uninterned symbol whose name is "
"@var{foo}.  (Normally, the Lisp reader interns all symbols; @pxref{Creating "
"Symbols}.)"
msgstr "シンボル名がプリント表現としての役割をもつというルールの例外として、@samp{##}があります。これは、名前が空文字列の、internされたシンボルのプリント表現です。さらに@samp{#:@var{foo}}は、internされていない@var{foo}という名前のシンボルにたいするプリント表現です(通常、Lispリーダーはすべてのシンボルをinternします。@ref{Creating Symbols}を参照してください)。"

#. type: subsection
#: objects.texi.orig:611
#, no-wrap
msgid "Sequence Types"
msgstr "Sequence Types"

#. type: Plain text
#: objects.texi.orig:616
msgid ""
"A @dfn{sequence} is a Lisp object that represents an ordered set of "
"elements.  There are two kinds of sequence in Emacs Lisp: @dfn{lists} and "
"@dfn{arrays}."
msgstr "@dfn{シーケンス(sequence)}とは、要素の順序セットを表現する、Lispオブジェクトです。Emacs Lispには、2種類のシーケンス --- @dfn{リスト(lists)}と@dfn{配列(arrays)}があります。"

#. type: Plain text
#: objects.texi.orig:620
msgid ""
"Lists are the most commonly-used sequences.  A list can hold elements of any "
"type, and its length can be easily changed by adding or removing elements.  "
"See the next subsection for more about lists."
msgstr "リストはもっとも一般的に使用されるシーケンスです。リストは任意の型の要素を保持でき、要素の追加・削除により簡単に長さを変更できます。リストについては、次のサブセクションを参照してください。"

#. type: Plain text
#: objects.texi.orig:629
msgid ""
"Arrays are fixed-length sequences.  They are further subdivided into "
"strings, vectors, char-tables and bool-vectors.  Vectors can hold elements "
"of any type, whereas string elements must be characters, and bool-vector "
"elements must be @code{t} or @code{nil}.  Char-tables are like vectors "
"except that they are indexed by any valid character code.  The characters in "
"a string can have text properties like characters in a buffer (@pxref{Text "
"Properties}), but vectors do not support text properties, even when their "
"elements happen to be characters."
msgstr "配列は固定長のシーケンスです。配列はさらに文字列(strings)、ベクター(vectors)、文字テーブル(char-tables)、ブールベクター(bool-vectors)に細分されます。ベクターは任意の型の要素を保持できますが、文字列の要素は文字でなければならず、ブールベクターの要素は@code{t}か@code{nil}でなければなりません。文字テーブルはベクターと似ていますが、有効な文字によりインデックスづけされる点が異なります。文字列内の文字は、バッファー内の文字のようにテキストプロパティーをもつことができます(@ref{Text Properties}を参照してください)。しかしベクターは、その要素が文字のときでも、テキストプロパティーをサポートしません。"

#. type: Plain text
#: objects.texi.orig:636
msgid ""
"Lists, strings and the other array types also share important similarities.  "
"For example, all have a length @var{l}, and all have elements which can be "
"indexed from zero to @var{l} minus one.  Several functions, called sequence "
"functions, accept any kind of sequence.  For example, the function "
"@code{length} reports the length of any kind of sequence.  @xref{Sequences "
"Arrays Vectors}."
msgstr "リスト、文字列、およびその他の配列型も、重要な類似点を共有します。たとえば、それらはすべて長さ@var{l}をもち、要素は0から@var{l}@minus{}1でインデックスづけされます。いくつかの関数はシーケンス関数と呼ばれ、これらは任意の種類のシーケンスを許容します。たとえば、関数@code{length}は、任意の種類のシーケンスの長さを報告します。@ref{Sequences Arrays Vectors}を参照してください。"

#. type: Plain text
#: objects.texi.orig:642
msgid ""
"It is generally impossible to read the same sequence twice, since sequences "
"are always created anew upon reading.  If you read the read syntax for a "
"sequence twice, you get two sequences with equal contents.  There is one "
"exception: the empty list @code{()} always stands for the same object, "
"@code{nil}."
msgstr "シーケンスは読み取りにより常に新たに作成されるので、同じシーケンスを2回読み取るのは、一般的に不可能です。シーケンスにたいする入力構文を2回読み取った場合、内容が等しい2つのシーケンスを得ます。これには1つ例外があります。空リスト@code{()}は、常に同じオブジェクト@code{nil}を表します。"

#. type: subsection
#: objects.texi.orig:644
#, no-wrap
msgid "Cons Cell and List Types"
msgstr "Cons Cell and List Types"

#. type: cindex
#: objects.texi.orig:645
#, no-wrap
msgid "address field of register"
msgstr "address field of register"

#. type: cindex
#: objects.texi.orig:646
#, no-wrap
msgid "decrement field of register"
msgstr "decrement field of register"

#. type: cindex
#: objects.texi.orig:647
#, no-wrap
msgid "pointers"
msgstr "pointers"

#. type: Plain text
#: objects.texi.orig:654
msgid ""
"A @dfn{cons cell} is an object that consists of two slots, called the "
"@sc{car} slot and the @sc{cdr} slot.  Each slot can @dfn{hold} any Lisp "
"object.  We also say that ``the @sc{car} of this cons cell is'' whatever "
"object its @sc{car} slot currently holds, and likewise for the @sc{cdr}."
msgstr "@dfn{コンスセル(cons cell)}は、@sc{car}スロット、@sc{cdr}スロットと呼ばれる2つのスロットから構成されるオブジェクトです。各スロットは、任意のLispオブジェクトを@dfn{保持}できます。そのとき@sc{car}スロットに保持されるオブジェクトが何であれ、わたしたちは``このコンスセルの@sc{car}''のような言い方をします。これは@sc{cdr}の場合も同様です。"

#. type: cindex
#: objects.texi.orig:655
#, no-wrap
msgid "list structure"
msgstr "list structure"

#. type: Plain text
#: objects.texi.orig:662
msgid ""
"A @dfn{list} is a series of cons cells, linked together so that the @sc{cdr} "
"slot of each cons cell holds either the next cons cell or the empty list.  "
"The empty list is actually the symbol @code{nil}.  @xref{Lists}, for "
"details.  Because most cons cells are used as part of lists, we refer to any "
"structure made out of cons cells as a @dfn{list structure}."
msgstr "@dfn{リスト(list)}は、コンスセルの連続するシリーズで、各コンスセルの@sc{cdr}スロットは、次のコンスセル、または空リストを保持します。空リストは実際にはシンボル@code{nil}です。詳細については、@ref{Lists}を参照してください。ほとんどのコンスセルはリストの一部として使用されるので、わたしたちはコンスセルにより構成される任意の構造を、@dfn{リスト構造(list structure)}という用語で参照します。"

#. type: cindex
#: objects.texi.orig:663
#, no-wrap
msgid "linked list"
msgstr "linked list"

#. type: quotation
#: objects.texi.orig:669
msgid ""
"A note to C programmers: a Lisp list thus works as a @dfn{linked list} built "
"up of cons cells.  Because pointers in Lisp are implicit, we do not "
"distinguish between a cons cell slot ``holding'' a value versus ``pointing "
"to'' the value."
msgstr "Cプログラマーにたいする注意: Lispのリストはコンスセルにより構築される、@dfn{リンクリスト(linked list)}として機能します。Lispではポインターは暗黙的なので、わたしたちはコンスセルのスロットが、値を``保持(hold)''するのか、それとも値を``指す(point)''のかを区別しません。"

#. type: cindex
#: objects.texi.orig:671
#, no-wrap
msgid "atoms"
msgstr "atoms"

#. type: Plain text
#: objects.texi.orig:675
msgid ""
"Because cons cells are so central to Lisp, we also have a word for ``an "
"object which is not a cons cell''.  These objects are called @dfn{atoms}."
msgstr "コンスセルはLispの中心なので、``コンスセルではないオブジェクト''にたいする単語もあります。これらのオブジェクトは@dfn{アトム(atoms)}と呼ばれます。"

#. type: cindex
#: objects.texi.orig:676
#, no-wrap
msgid "parenthesis"
msgstr "parenthesis"

#. type: cindex
#: objects.texi.orig:677
#, no-wrap
msgid "@samp{(@dots{})} in lists"
msgstr "@samp{(@dots{})} in lists"

#. type: Plain text
#: objects.texi.orig:681
msgid ""
"The read syntax and printed representation for lists are identical, and "
"consist of a left parenthesis, an arbitrary number of elements, and a right "
"parenthesis.  Here are examples of lists:"
msgstr "リストにたいする入力構文とプリント表現は等しく、それは左カッコ、任意の数の要素、右カコから構成されます。以下はリストの例です:"

#. type: example
#: objects.texi.orig:691
#, no-wrap
msgid ""
"(A 2 \"A\")            ; @r{A list of three elements.}\n"
"()                   ; @r{A list of no elements (the empty list).}\n"
"nil                  ; @r{A list of no elements (the empty list).}\n"
"(\"A ()\")             ; @r{A list of one element: the string @code{\"A "
"()\"}.}\n"
"(A ())               ; @r{A list of two elements: @code{A} and the empty "
"list.}\n"
"(A nil)              ; @r{Equivalent to the previous.}\n"
"((A B C))            ; @r{A list of one element}\n"
"                     ;   @r{(which is a list of three elements).}\n"
msgstr ""
"(A 2 \"A\")            ; @r{3要素のリスト。}\n"
"()                   ; @r{要素がないリスト(空リスト)。}\n"
"nil                  ; @r{要素がないリスト(空リスト)。}\n"
"(\"A ()\")             ; @r{1要素のリスト: 文字列@code{\"A ()\"}。}\n"
"(A ())               ; @r{2要素のリスト: @code{A}と空リスト。}\n"
"(A nil)              ; @r{同上}\n"
"((A B C))            ; @r{1要素のリスト}\n"
"                     ;   @r{(この要素は、3要素のリスト)。}\n"

#. type: Plain text
#: objects.texi.orig:699
msgid ""
"Upon reading, each object inside the parentheses becomes an element of the "
"list.  That is, a cons cell is made for each element.  The @sc{car} slot of "
"the cons cell holds the element, and its @sc{cdr} slot refers to the next "
"cons cell of the list, which holds the next element in the list.  The "
"@sc{cdr} slot of the last cons cell is set to hold @code{nil}."
msgstr "読み取りにおいては、カッコの内側は、リストの要素になります。つまり、コンスセルは各要素から作成されます。コンスセルの@sc{car}スロットは要素を保持し、@sc{cdr}スロットはリスト内の次のコンスセル(このコンスセルはリスト内の次の要素を保持します)を参照します。最後のコンスセルの@sc{cdr}スロットは、@code{nil}を保持するようにセットされます。"

#. type: Plain text
#: objects.texi.orig:708
msgid ""
"The names @sc{car} and @sc{cdr} derive from the history of Lisp.  The "
"original Lisp implementation ran on an @w{IBM 704} computer which divided "
"words into two parts, called the ``address'' part and the ``decrement''; "
"@sc{car} was an instruction to extract the contents of the address part of a "
"register, and @sc{cdr} an instruction to extract the contents of the "
"decrement.  By contrast, ``cons cells'' are named for the function "
"@code{cons} that creates them, which in turn was named for its purpose, the "
"construction of cells."
msgstr "@sc{car}、@sc{cdr}という名称は、Lispの歴史に由来します。オリジナルのLisp実装は@w{IBM 704}コンピューターで実行されていました。ワードを2つの部分、つまり``address''と呼ばれる部分と、``decrement''と呼ばれる部分に分割していて、その際@sc{car}はaddress部から内容を取り出す命令で、@sc{cdr}はdecrement部から内容を取り出す命令でした。対照的に``cons cells''は、これらを作成する関数@code{cons}から命名されました。この関数は関数の目的、すなわちセルを作る(construction of cells)という目的から命名されました。"

#. type: node
#: objects.texi.orig:713 objects.texi.orig:715
#, no-wrap
msgid "Box Diagrams"
msgstr "Box Diagrams"

#. type: menuentry
#: objects.texi.orig:713
msgid "Drawing pictures of lists."
msgstr "リストを絵で書いたら。"

#. type: subsubsection
#: objects.texi.orig:713 objects.texi.orig:824 objects.texi.orig:825
#, no-wrap
msgid "Dotted Pair Notation"
msgstr "Dotted Pair Notation"

#. type: menuentry
#: objects.texi.orig:713
msgid "A general syntax for cons cells."
msgstr "コンスセルの一般的な構文。"

#. type: subsubsection
#: objects.texi.orig:713 objects.texi.orig:910 objects.texi.orig:911
#, no-wrap
msgid "Association List Type"
msgstr "Association List Type"

#. type: menuentry
#: objects.texi.orig:713
msgid "A specially constructed list."
msgstr "特別に構成されるリスト。"

#. type: subsubsection
#: objects.texi.orig:716
#, no-wrap
msgid "Drawing Lists as Box Diagrams"
msgstr "Drawing Lists as Box Diagrams"

#. type: cindex
#: objects.texi.orig:717
#, no-wrap
msgid "box diagrams, for lists"
msgstr "box diagrams, for lists"

#. type: cindex
#: objects.texi.orig:718
#, no-wrap
msgid "diagrams, boxed, for lists"
msgstr "diagrams, boxed, for lists"

#. type: Plain text
#: objects.texi.orig:726
msgid ""
"A list can be illustrated by a diagram in which the cons cells are shown as "
"pairs of boxes, like dominoes.  (The Lisp reader cannot read such an "
"illustration; unlike the textual notation, which can be understood by both "
"humans and computers, the box illustrations can be understood only by "
"humans.)  This picture represents the three-element list @code{(rose violet "
"buttercup)}:"
msgstr "コンスセルを表現するドミノのような1対のボックスによる図により、リストを説明することができます(Lispリーダーがこのような図を読み取ることはできません。人間およびコンピューターが理解できるテキスト表記と異なり、ボックスの図は人間だけが理解できます)。この図は3要素のリスト@code{(rose violet buttercup)}を表したものです:\n"

#. type: group
#: objects.texi.orig:735 objects.texi.orig:906
#, no-wrap
msgid ""
"    --- ---      --- ---      --- ---\n"
"   |   |   |--> |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---      --- ---\n"
"     |            |            |\n"
"     |            |            |\n"
"      --> rose     --> violet   --> buttercup\n"
msgstr ""
"    --- ---      --- ---      --- ---\n"
"   |   |   |--> |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---      --- ---\n"
"     |            |            |\n"
"     |            |            |\n"
"      --> rose     --> violet   --> buttercup\n"

#. type: Plain text
#: objects.texi.orig:742
msgid ""
"In this diagram, each box represents a slot that can hold or refer to any "
"Lisp object.  Each pair of boxes represents a cons cell.  Each arrow "
"represents a reference to a Lisp object, either an atom or another cons "
"cell."
msgstr "この図では、ボックスは任意のLispオブジェクトへの参照を保持できるスロットを表します。ボックスのペアはコンスセルを表します。矢印はLispオブジェクト(アトム、または他のコンスセル)への参照を表します。"

#. type: Plain text
#: objects.texi.orig:749
msgid ""
"In this example, the first box, which holds the @sc{car} of the first cons "
"cell, refers to or ``holds'' @code{rose} (a symbol).  The second box, "
"holding the @sc{cdr} of the first cons cell, refers to the next pair of "
"boxes, the second cons cell.  The @sc{car} of the second cons cell is "
"@code{violet}, and its @sc{cdr} is the third cons cell.  The @sc{cdr} of the "
"third (and last) cons cell is @code{nil}."
msgstr "この例では、1番目のボックスは1番目のコンスセルで、それの@sc{car}は@code{rose}(シンボル)を参照または``保持(holds)''します。2番目のボックスは1番目のコンスセルの@sc{cdr}を保持し、次のボックスペア、すなわち2番目のコンスセルを参照します。2番目のコンスセルの@sc{car}は@code{violet}で、@sc{cdr}は3番目のコンスセルです。(最後の)3番目のコンスセルの@sc{cdr}は、@code{nil}です。"

#. type: Plain text
#: objects.texi.orig:752
msgid ""
"Here is another diagram of the same list, @code{(rose violet buttercup)}, "
"sketched in a different manner:"
msgstr "同じリスト@code{(rose violet buttercup)}を、違うやり方で描いた別の図で表してみましょう:"

#. type: group
#: objects.texi.orig:760
#, no-wrap
msgid ""
" ---------------       ----------------       -------------------\n"
"| car   | cdr   |     | car    | cdr   |     | car       | cdr   |\n"
"| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |\n"
"|       |       |     |        |       |     |           |       |\n"
" ---------------       ----------------       -------------------\n"
msgstr ""
" ---------------       ----------------       -------------------\n"
"| car   | cdr   |     | car    | cdr   |     | car       | cdr   |\n"
"| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |\n"
"|       |       |     |        |       |     |           |       |\n"
" ---------------       ----------------       -------------------\n"

#. type: cindex
#: objects.texi.orig:763
#, no-wrap
msgid "@code{nil} as a list"
msgstr "@code{nil} as a list"

#. type: cindex
#: objects.texi.orig:764
#, no-wrap
msgid "empty list"
msgstr "empty list"

#. type: Plain text
#: objects.texi.orig:768
msgid ""
"A list with no elements in it is the @dfn{empty list}; it is identical to "
"the symbol @code{nil}.  In other words, @code{nil} is both a symbol and a "
"list."
msgstr "要素がないリストは@dfn{空リスト(empty list)}で、これはシンボル@code{nil}と同じです。別の言い方をすると、@code{nil}はシンボルであり、リストでもあります。"

#. type: Plain text
#: objects.texi.orig:771
msgid ""
"Here is the list @code{(A ())}, or equivalently @code{(A nil)}, depicted "
"with boxes and arrows:"
msgstr "以下は、リスト@code{(A ())}、または等価な@code{(A nil)}をボックスと矢印で描いたものです:"

#. type: group
#: objects.texi.orig:780
#, no-wrap
msgid ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> A        --> nil\n"
msgstr ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> A        --> nil\n"

#. type: Plain text
#: objects.texi.orig:786
msgid ""
"Here is a more complex illustration, showing the three-element list, "
"@code{((pine needles) oak maple)}, the first element of which is a "
"two-element list:"
msgstr "以下はもっと複雑な例です。これは、1番目の要素が2等疎のリスとである、3要素のリスト@code{((pine needles) oak maple)}を表します:"

#. type: group
#: objects.texi.orig:802
#, no-wrap
msgid ""
"    --- ---      --- ---      --- ---\n"
"   |   |   |--> |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---      --- ---\n"
"     |            |            |\n"
"     |            |            |\n"
"     |             --> oak      --> maple\n"
"     |\n"
"     |     --- ---      --- ---\n"
"      --> |   |   |--> |   |   |--> nil\n"
"           --- ---      --- ---\n"
"            |            |\n"
"            |            |\n"
"             --> pine     --> needles\n"
msgstr ""
"    --- ---      --- ---      --- ---\n"
"   |   |   |--> |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---      --- ---\n"
"     |            |            |\n"
"     |            |            |\n"
"     |             --> oak      --> maple\n"
"     |\n"
"     |     --- ---      --- ---\n"
"      --> |   |   |--> |   |   |--> nil\n"
"           --- ---      --- ---\n"
"            |            |\n"
"            |            |\n"
"             --> pine     --> needles\n"

#. type: Plain text
#: objects.texi.orig:806
msgid "The same list represented in the second box notation looks like this:"
msgstr "同じリストを2番目のボックス表記で表すと、以下のようになります:"

#. type: group
#: objects.texi.orig:821
#, no-wrap
msgid ""
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   o   |   o------->| oak   |   o------->| maple |  nil |\n"
"|   |   |      |     |       |      |     |       |      |\n"
" -- | ---------       --------------       --------------\n"
"    |\n"
"    |\n"
"    |        --------------       ----------------\n"
"    |       | car   | cdr  |     | car     | cdr  |\n"
"     ------>| pine  |   o------->| needles |  nil |\n"
"            |       |      |     |         |      |\n"
"             --------------       ----------------\n"
msgstr ""
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   o   |   o------->| oak   |   o------->| maple |  nil |\n"
"|   |   |      |     |       |      |     |       |      |\n"
" -- | ---------       --------------       --------------\n"
"    |\n"
"    |\n"
"    |        --------------       ----------------\n"
"    |       | car   | cdr  |     | car     | cdr  |\n"
"     ------>| pine  |   o------->| needles |  nil |\n"
"            |       |      |     |         |      |\n"
"             --------------       ----------------\n"

#. type: cindex
#: objects.texi.orig:826
#, no-wrap
msgid "dotted pair notation"
msgstr "dotted pair notation"

#. type: cindex
#: objects.texi.orig:827
#, no-wrap
msgid "@samp{.} in lists"
msgstr "@samp{.} in lists"

#. type: Plain text
#: objects.texi.orig:841
msgid ""
"@dfn{Dotted pair notation} is a general syntax for cons cells that "
"represents the @sc{car} and @sc{cdr} explicitly.  In this syntax, "
"@code{(@var{a} .@: @var{b})} stands for a cons cell whose @sc{car} is the "
"object @var{a} and whose @sc{cdr} is the object @var{b}.  Dotted pair "
"notation is more general than list syntax because the @sc{cdr} does not have "
"to be a list.  However, it is more cumbersome in cases where list syntax "
"would work.  In dotted pair notation, the list @samp{(1 2 3)} is written as "
"@samp{(1 .  (2 . (3 . nil)))}.  For @code{nil}-terminated lists, you can use "
"either notation, but list notation is usually clearer and more convenient.  "
"When printing a list, the dotted pair notation is only used if the @sc{cdr} "
"of a cons cell is not a list."
msgstr "@dfn{ドットペア表記(dotted pair notation)}は@sc{car}と@sc{cdr}が明示的に表されたコンスセルにたいする、一般的な構文です。この構文では、@code{(@var{a} .@: @var{b})}は、@sc{car}がオブジェクト@var{a}で、@sc{cdr}がオブジェクト@var{b}という意味になります。@sc{cdr}がリスとである必要がないので、ドットペア表記は、より一般的なリスト構文です。しかしキスと構文が機能するでような場合には、より扱いにくくなります。ドットペア表記では、リスト@samp{(1 2 3)}は、@samp{(1 .  (2 . (3 . nil)))}と記述されます。@code{nil}で終端されたリストにたいしては、どちらの表記法も使用できますが、リスト表記の方が、通常は明解で便利です。リストをプリントする場合、コンスセルの@sc{cdr}がリスとでないときだけ、ドットペア表記が使用されます。"

#. type: Plain text
#: objects.texi.orig:844
msgid ""
"Here's an example using boxes to illustrate dotted pair notation.  This "
"example shows the pair @code{(rose . violet)}:"
msgstr "以下はボックスを使用してドットペア表記を表した例です。この例はペア@code{(rose . violet)}を表します。"

#. type: group
#: objects.texi.orig:853
#, no-wrap
msgid ""
"    --- ---\n"
"   |   |   |--> violet\n"
"    --- ---\n"
"     |\n"
"     |\n"
"      --> rose\n"
msgstr ""
"    --- ---\n"
"   |   |   |--> violet\n"
"    --- ---\n"
"     |\n"
"     |\n"
"      --> rose\n"

#. type: Plain text
#: objects.texi.orig:862
msgid ""
"You can combine dotted pair notation with list notation to represent "
"conveniently a chain of cons cells with a non-@code{nil} final @sc{cdr}.  "
"You write a dot after the last element of the list, followed by the @sc{cdr} "
"of the final cons cell.  For example, @code{(rose violet . buttercup)} is "
"equivalent to @code{(rose . (violet . buttercup))}.  The object looks like "
"this:"
msgstr "最後の@sc{cdr}が非@code{nil}のコンスセルのチェーンを表すために、ドットペア表記とリスト表記を組み合わせることができます。リストの最後の要素の後にドットを記述して、その後に最後のコンスセルの@sc{cdr}を記述します。たとえば、@code{(rose violet . buttercup)}は、@code{(rose . (violet . buttercup))}と等価です。オブジェクトは以下のようになります:"

#. type: group
#: objects.texi.orig:871
#, no-wrap
msgid ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> buttercup\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> rose     --> violet\n"
msgstr ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> buttercup\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> rose     --> violet\n"

#. type: Plain text
#: objects.texi.orig:878
msgid ""
"The syntax @code{(rose .@: violet .@: buttercup)} is invalid because there "
"is nothing that it could mean.  If anything, it would say to put "
"@code{buttercup} in the @sc{cdr} of a cons cell whose @sc{cdr} is already "
"used for @code{violet}."
msgstr "構文@code{(rose .@: violet .@: buttercup)}は無効です。なぜならこれが意味することは何もないからです。何かあるにしても、@code{violet}のために@sc{cdr}がすでに使用されているコンスセルの@sc{cdr}に@code{buttercup}を置く、ということになります。"

#. type: Plain text
#: objects.texi.orig:881
msgid ""
"The list @code{(rose violet)} is equivalent to @code{(rose . (violet))}, and "
"looks like this:"
msgstr "リスト@code{(rose violet)}は@code{(rose . (violet))}と等価であり、以下のようになります:"

#. type: group
#: objects.texi.orig:890
#, no-wrap
msgid ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> rose     --> violet\n"
msgstr ""
"    --- ---      --- ---\n"
"   |   |   |--> |   |   |--> nil\n"
"    --- ---      --- ---\n"
"     |            |\n"
"     |            |\n"
"      --> rose     --> violet\n"

#. type: Plain text
#: objects.texi.orig:895
msgid ""
"Similarly, the three-element list @code{(rose violet buttercup)} is "
"equivalent to @code{(rose . (violet . (buttercup)))}."
msgstr "同様に3要素のリスト@code{(rose violet buttercup)}は、@code{(rose . (violet . (buttercup)))}と等価です。"

#. type: ifnottex
#: objects.texi.orig:897
msgid "It looks like this:"
msgstr "これは以下のようになります:"

#. type: Plain text
#: objects.texi.orig:920
msgid ""
"An @dfn{association list} or @dfn{alist} is a specially-constructed list "
"whose elements are cons cells.  In each element, the @sc{car} is considered "
"a @dfn{key}, and the @sc{cdr} is considered an @dfn{associated value}.  (In "
"some cases, the associated value is stored in the @sc{car} of the @sc{cdr}.)  "
"Association lists are often used as stacks, since it is easy to add or "
"remove associations at the front of the list."
msgstr "@dfn{連想リスト(association list)}または@dfn{alist}は、要素がコンスセルであるように特別に構成されたリストです。各要素においては、@sc{car}が@dfn{キー(key)}で、@sc{cdr}が@dfn{連想値(associated value)}であると考えます(連想値が@sc{cdr}の@sc{car}に保存される場合もあります)。リストの先頭に連想値を追加したり削除するのが簡単なので、連想リストはスタック(stack)にしばしば使用されます。"

#. type: Plain text
#: objects.texi.orig:922
msgid "For example,"
msgstr "たとえば、"

#. type: example
#: objects.texi.orig:926
#, no-wrap
msgid ""
"(setq alist-of-colors\n"
"      '((rose . red) (lily . white) (buttercup . yellow)))\n"
msgstr ""
"(setq alist-of-colors\n"
"      '((rose . red) (lily . white) (buttercup . yellow)))\n"

#. type: Plain text
#: objects.texi.orig:931
msgid ""
"sets the variable @code{alist-of-colors} to an alist of three elements.  In "
"the first element, @code{rose} is the key and @code{red} is the value."
msgstr "これは変数@code{alist-of-colors}に3葉疎のalistをセットします。最初の要素では、@code{rose}がキーで、@code{red}が値になります。"

#. type: Plain text
#: objects.texi.orig:935
msgid ""
"@xref{Association Lists}, for a further explanation of alists and for "
"functions that work on alists.  @xref{Hash Tables}, for another kind of "
"lookup table, which is much faster for handling a large number of keys."
msgstr "alistと、alistに関数についての詳細な説明は、@ref{Association Lists}を参照してください。テーブルを照合する、(多くのキーの操作を、より速く行なう)他の手段については、@ref{Hash Tables}を参照してください。"

#. type: Plain text
#: objects.texi.orig:946
msgid ""
"An @dfn{array} is composed of an arbitrary number of slots for holding or "
"referring to other Lisp objects, arranged in a contiguous block of memory.  "
"Accessing any element of an array takes approximately the same amount of "
"time.  In contrast, accessing an element of a list requires time "
"proportional to the position of the element in the list.  (Elements at the "
"end of a list take longer to access than elements at the beginning of a "
"list.)"
msgstr "@dfn{配列(array)}は、他のLispオブジェクトを保持または参照する、任意の数のスロットから構成され、メモリーの連続ブロックに配列されます。配列の任意の要素へのアクセス時間は、大体同じです。対照的に、リストの要素にたいするアクセスは、リスト内でのその要素の位置に比例した時間を要します(リストの最後の要素にアクセスするには、リストの最初の要素にアクセスするより、長い時間を要します)。"

#. type: Plain text
#: objects.texi.orig:949
msgid ""
"Emacs defines four types of array: strings, vectors, bool-vectors, and "
"char-tables."
msgstr "Emacsは文字列(strings)、ベクター(vectors)、ブールベクター(bool-vectors)、文字テーブル(char-tables)という、4種の配列を定義します。"

#. type: Plain text
#: objects.texi.orig:955
msgid ""
"A string is an array of characters and a vector is an array of arbitrary "
"objects.  A bool-vector can hold only @code{t} or @code{nil}.  These kinds "
"of array may have any length up to the largest integer.  Char-tables are "
"sparse arrays indexed by any valid character code; they can hold arbitrary "
"objects."
msgstr "文字列は文字の配列で、ベクターは任意のオブジェクトの配列です。ブールベクターは@code{t}か@code{nil}だけを保持できます。この種の配列は、もっとも大きい整数までの、任意の長さをもつことができます。文字テーブルは、任意の有効な文字コードによりインデックスづけされる疎な配列で、任意のオブジェクトを保持することができます。"

#. type: Plain text
#: objects.texi.orig:961
msgid ""
"The first element of an array has index zero, the second element has index "
"1, and so on.  This is called @dfn{zero-origin} indexing.  For example, an "
"array of four elements has indices 0, 1, 2, @w{and 3}.  The largest possible "
"index value is one less than the length of the array.  Once an array is "
"created, its length is fixed."
msgstr "配列の最初の要素はインデックス0、2番目の要素はインデックス1、...となります。これは0基準@dfn{zero-origin}のインデックスづけと呼ばれます。たとえば、4要素の配列は、インデックス0、1、2、3をもちます。利用できる最大のインデックス値は、配列の長さより1小さくなります。1度配列が作成されると、長さは固定されます。"

#. type: Plain text
#: objects.texi.orig:967
msgid ""
"All Emacs Lisp arrays are one-dimensional.  (Most other programming "
"languages support multidimensional arrays, but they are not essential; you "
"can get the same effect with nested one-dimensional arrays.)  Each type of "
"array has its own read syntax; see the following sections for details."
msgstr "Emacs Lispのすべての配列は、1次元です(他のほとんどのプログラミング言語は多次元配列をサポートしますが、これらは必須ではありません。ネストされた1次元配列により同じ効果を得ることができます)。各種の配列のは、独自の入力構文をもちます。詳細は以降のセクションを参照してください。"

#. type: Plain text
#: objects.texi.orig:971
msgid ""
"The array type is a subset of the sequence type, and contains the string "
"type, the vector type, the bool-vector type, and the char-table type."
msgstr "配列型はシーケンス型のサブセットであり、文字列型、ベクター型、ブールベクター型、文字テーブル型が含まれます。"

#. type: Plain text
#: objects.texi.orig:980
msgid ""
"A @dfn{string} is an array of characters.  Strings are used for many "
"purposes in Emacs, as can be expected in a text editor; for example, as the "
"names of Lisp symbols, as messages for the user, and to represent text "
"extracted from buffers.  Strings in Lisp are constants: evaluation of a "
"string returns the same string."
msgstr "@dfn{文字列(string)}とは、文字の配列です。Emacsがテキストエディターであることから予想できるように、文字列は、たとえばLispシンボルの名前、ユーザーへのメッセージ、バッファーから抽出されたテキストの表現など、多くの目的のために使用されます。Lispの文字列は定数です。文字列を評価すると、それと同じ文字列がreturnされます。"

#. type: Plain text
#: objects.texi.orig:982
msgid "@xref{Strings and Characters}, for functions that operate on strings."
msgstr "文字列を操作する関数については、@ref{Strings and Characters}を参照してください。"

#. type: subsubsection
#: objects.texi.orig:988 objects.texi.orig:990 objects.texi.orig:991
#, no-wrap
msgid "Syntax for Strings"
msgstr "Syntax for Strings"

#. type: menuentry
#: objects.texi.orig:988
msgid "How to specify Lisp strings."
msgstr "Lisp文字列を指定する方法。"

#. type: node
#: objects.texi.orig:988 objects.texi.orig:1023
#, no-wrap
msgid "Non-ASCII in Strings"
msgstr "Non-ASCII in Strings"

#. type: menuentry
#: objects.texi.orig:988
msgid "International characters in strings."
msgstr "文字列内の国際化文字。"

#. type: node
#: objects.texi.orig:988 objects.texi.orig:1074
#, no-wrap
msgid "Nonprinting Characters"
msgstr "Nonprinting Characters"

#. type: menuentry
#: objects.texi.orig:988
msgid "Literal unprintable characters in strings."
msgstr "文字列内の印刷不可能なリテラル文字。"

#. type: node
#: objects.texi.orig:988 objects.texi.orig:1107
#, no-wrap
msgid "Text Props and Strings"
msgstr "Text Props and Strings"

#. type: menuentry
#: objects.texi.orig:988
msgid "Strings with text properties."
msgstr "テキストプロパティーをともなう文字列。"

#. type: cindex
#: objects.texi.orig:993
#, no-wrap
msgid "@samp{\"} in strings"
msgstr "@samp{\"} in strings"

#. type: cindex
#: objects.texi.orig:994
#, no-wrap
msgid "double-quote in strings"
msgstr "double-quote in strings"

#. type: cindex
#: objects.texi.orig:995
#, no-wrap
msgid "@samp{\\} in strings"
msgstr "@samp{\\} in strings"

#. type: cindex
#: objects.texi.orig:996
#, no-wrap
msgid "backslash in strings"
msgstr "backslash in strings"

#. type: Plain text
#: objects.texi.orig:1004
msgid ""
"The read syntax for a string is a double-quote, an arbitrary number of "
"characters, and another double-quote, @code{\"like this\"}.  To include a "
"double-quote in a string, precede it with a backslash; thus, @code{\"\\\"\"} "
"is a string containing just a single double-quote character.  Likewise, you "
"can include a backslash by preceding it with another backslash, like this: "
"@code{\"this \\\\ is a single embedded backslash\"}."
msgstr "文字列にたいする入力構文は、@code{\"like this\"}のように、ダブルクォート、任意個の文字、もう1つのダブルクォートから構成されます。文字列内にダブルクォートを含める場合は、それの前にバックスラッシュを記述します。したがって、@code{\"\\\"\"}は1つのダブルクォート文字だけを含む文字列です。同様に、バックスラッシュを含める場合は、@code{\"this \\\\ is a single embedded backslash\"}のように、それの前にもう1つのバックスラッシュを記述します。"

#. type: cindex
#: objects.texi.orig:1005
#, no-wrap
msgid "newline in strings"
msgstr "newline in strings"

#. type: Plain text
#: objects.texi.orig:1012
msgid ""
"The newline character is not special in the read syntax for strings; if you "
"write a new line between the double-quotes, it becomes a character in the "
"string.  But an escaped newline---one that is preceded by @samp{\\}---does "
"not become part of the string; i.e., the Lisp reader ignores an escaped "
"newline while reading a string.  An escaped space @w{@samp{\\ }} is likewise "
"ignored."
msgstr "文字列にたいする入力構文では、改行(newline)は特別ではありません。ダブルクォートの間に改行を記述すれば、その改行は文字列内の文字となります。しかしエスケープされた改行 --- 前に@samp{\\}をともなう改行 ---は文字列の一部とはなりません。同様に、エスケープされたスペース@w{@samp{\\ }}も無視されます。"

#. type: example
#: objects.texi.orig:1021
#, no-wrap
msgid ""
"\"It is useful to include newlines\n"
"in documentation strings,\n"
"but the newline is \\\n"
"ignored if escaped.\"\n"
"     @result{} \"It is useful to include newlines\n"
"in documentation strings,\n"
"but the newline is ignored if escaped.\"\n"
msgstr ""
"\"It is useful to include newlines\n"
"in documentation strings,\n"
"but the newline is \\\n"
"ignored if escaped.\"\n"
"     @result{} \"It is useful to include newlines\n"
"in documentation strings,\n"
"but the newline is ignored if escaped.\"\n"

#. type: subsubsection
#: objects.texi.orig:1024
#, no-wrap
msgid "Non-@acronym{ASCII} Characters in Strings"
msgstr "Non-@acronym{ASCII} Characters in Strings"

#. type: Plain text
#: objects.texi.orig:1034
msgid ""
"There are two text representations for non-@acronym{ASCII} characters in "
"Emacs strings: multibyte and unibyte (@pxref{Text Representations}).  "
"Roughly speaking, unibyte strings store raw bytes, while multibyte strings "
"store human-readable text.  Each character in a unibyte string is a byte, "
"i.e., its value is between 0 and 255.  By contrast, each character in a "
"multibyte string may have a value between 0 to 4194303 (@pxref{Character "
"Type}).  In both cases, characters above 127 are non-@acronym{ASCII}."
msgstr "Emacdの文字列内の非@acronym{ASCII}文字にたいしては、2つのテキスト表現 --- マルチバイト(multibyte)とユニバイト(unibyte)があります(@ref{Text Representations}を参照してください)。大まかに言うと、ユニバイト文字列にはraw(生)バイトが保存され、マルチバイト文字列には人間が読めるテキストが保存されます。ユニバイト文字列内の各文字はバイトであり、値は0から255となります。対照的に、マルチバイト文字列内の各文字は、0から4194303の値をもつかもしれません(@ref{Character Type}を参照してください)。両方とも、127より上の文字は非@acronym{ASCII}です。"

#. type: Plain text
#: objects.texi.orig:1044
msgid ""
"You can include a non-@acronym{ASCII} character in a string constant by "
"writing it literally.  If the string constant is read from a multibyte "
"source, such as a multibyte buffer or string, or a file that would be "
"visited as multibyte, then Emacs reads each non-@acronym{ASCII} character as "
"a multibyte character and automatically makes the string a multibyte "
"string.  If the string constant is read from a unibyte source, then Emacs "
"reads the non-@acronym{ASCII} character as unibyte, and makes the string "
"unibyte."
msgstr "文字をリテラルとして記述することにより、文字列に非@acronym{ASCII}文字を含めることができます。マルチバイトのバッファーや文字列、あるいはマルチバイトとしてvisitされたファイル等の、マルチバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をマルチバイト文字として読み取り、その文字列を自動的にマルチバイト文字列にします。ユニバイトのソースから文字列定数を読み込む場合、Emacsは非@acronym{ASCII}文字をユニバイト文字として読み取り、その文字列を湯にバイト文字列にします。"

#. type: Plain text
#: objects.texi.orig:1048
msgid ""
"Instead of writing a character literally into a multibyte string, you can "
"write it as its character code using an escape sequence.  @xref{General "
"Escape Syntax}, for details about escape sequences."
msgstr "マルチバイト文字列内にリテラルとして文字を記述するかわりに、エスケープシーケンスを使用して文字コードとして記述できます。エスケープシーケンスについての詳細は、@ref{General Escape Syntax}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1052
msgid ""
"If you use any Unicode-style escape sequence @samp{\\uNNNN} or "
"@samp{\\U00NNNNNN} in a string constant (even for an @acronym{ASCII} "
"character), Emacs automatically assumes that it is multibyte."
msgstr "文字列定数内でUnicodeスタイルのエスケープシーケンス@samp{\\uNNNN}または@samp{\\U00NNNNNN}を使用する場合、(たとえ@acronym{ASCII}文字の場合でも)Emacsは自動的に文字列をマルチバイトとみなします。"

#. type: Plain text
#: objects.texi.orig:1062
msgid ""
"You can also use hexadecimal escape sequences (@samp{\\x@var{n}}) and octal "
"escape sequences (@samp{\\@var{n}}) in string constants.  @strong{But "
"beware:} If a string constant contains hexadecimal or octal escape "
"sequences, and these escape sequences all specify unibyte characters (i.e., "
"less than 256), and there are no other literal non-@acronym{ASCII} "
"characters or Unicode-style escape sequences in the string, then Emacs "
"automatically assumes that it is a unibyte string.  That is to say, it "
"assumes that all non-@acronym{ASCII} characters occurring in the string are "
"8-bit raw bytes."
msgstr "文字列定数内で、16進エスケープシーケンス(@samp{\\x@var{n}})、および8進エスケープシーケンス(@samp{\\@var{n}})を使用することもできます。@strong{しかし注意してください: }文字列定数が16進または8進のエスケープシーケンスを含み、それらのエスケープシーケンスすべてがユニバイト文字(256より小)を指定していて、その文字列内に他にリテラルの非@acronym{ASCII}文字またはUnicodeスタイルのエスケープシーケンスが存在しない場合、Emacsは自動的に文字列をユニバイト文字列とみなします。つまり文字列内のすべての非@acronym{ASCII}文字は8ビットのrawバイトとみなされます。"

#. type: Plain text
#: objects.texi.orig:1073
msgid ""
"In hexadecimal and octal escape sequences, the escaped character code may "
"contain a variable number of digits, so the first subsequent character which "
"is not a valid hexadecimal or octal digit terminates the escape sequence.  "
"If the next character in a string could be interpreted as a hexadecimal or "
"octal digit, write @w{@samp{\\ }} (backslash and space) to terminate the "
"escape sequence.  For example, @w{@samp{\\xe0\\ }} represents one character, "
"@samp{a} with grave accent.  @w{@samp{\\ }} in a string constant is just "
"like backslash-newline; it does not contribute any character to the string, "
"but it does terminate any preceding hex escape."
msgstr "16進および8進のエスケープシーケンスではエスケープされた文字コードは可変個の数字を含むかもしれないので、それに続く文字で、16進および8進として有効ではない最初の文字は、エスケープシーケンスを終了させます。文字列内の次の文字が16進または8進として解釈できる文字の場合は、@w{@samp{\\ }}(バックスラッシュとスペース)を記述して、エスケープシーケンスを終了できます。たとえば@w{@samp{\\xe0\\ }}はgrave accentつきの@samp{a}という、1文字を表します。文字列内の@w{@samp{\\ }}は、バックスラッシュー改行と同様です。これは文字列内の文字とはなりませんが、先行する16進エスケープを終了します。"

#. type: subsubsection
#: objects.texi.orig:1075
#, no-wrap
msgid "Nonprinting Characters in Strings"
msgstr "Nonprinting Characters in Strings"

#. type: Plain text
#: objects.texi.orig:1083
msgid ""
"You can use the same backslash escape-sequences in a string constant as in "
"character literals (but do not use the question mark that begins a character "
"constant).  For example, you can write a string containing the nonprinting "
"characters tab and @kbd{C-a}, with commas and spaces between them, like "
"this: @code{\"\\t, \\C-a\"}.  @xref{Character Type}, for a description of "
"the read syntax for characters."
msgstr "リテラル文字と同様に、文字列定数内でバックスラッシュによるエスケープシーケンスを使用できます(ただし文字定数を開始するクエスチョンマークは使用しません)。たとえば、非プリント文字のタブと@kbd{C-a}を含む文字列は、@code{\"\\t, \\C-a\"}のように、それらの間にカンマとスペースを記述します。文字にたいする入力構文の説明は、@ref{Character Type}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1088
msgid ""
"However, not all of the characters you can write with backslash "
"escape-sequences are valid in strings.  The only control characters that a "
"string can hold are the @acronym{ASCII} control characters.  Strings do not "
"distinguish case in @acronym{ASCII} control characters."
msgstr "しかし、バックスラッシュによるエスケープシーケンスとともに記述できるすべての文字が、文字列内で有効というわけではありません。文字列が保持できるコントロール文字は、@acronym{ASCII}コントロール文字だけです。@acronym{ASCII}コントロール文字では、文字列の大文字小文字は区別されません。"

#. type: Plain text
#: objects.texi.orig:1094
msgid ""
"Properly speaking, strings cannot hold meta characters; but when a string is "
"to be used as a key sequence, there is a special convention that provides a "
"way to represent meta versions of @acronym{ASCII} characters in a string.  "
"If you use the @samp{\\M-} syntax to indicate a meta character in a string "
"constant, this sets the"
msgstr "正確に言うと、文字列はメタ文字を保持できません。しかし文字列がキーシーケンスとして使用される場合、文字列内でメタで修飾された@acronym{ASCII}文字を表現するための方法を提供する、特別な慣習があります。文字列定数内でメタ文字を示すために@samp{\\M-}構文を使用した場合、これは文字列内の文字の"

#. type: Plain text
#: objects.texi.orig:1103
msgid ""
"bit of the character in the string.  If the string is used in "
"@code{define-key} or @code{lookup-key}, this numeric code is translated into "
"the equivalent meta character.  @xref{Character Type}."
msgstr "のビットをセットします。その文字列が@code{define-key}または@code{lookup-key}で使用される場合、この数字コードは等価なメタ文字に変換されます。@ref{Character Type}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1106
msgid "Strings cannot hold characters that have the hyper, super, or alt modifiers."
msgstr "文字列はhyper、super、altで修飾された文字を保持できません。"

#. type: subsubsection
#: objects.texi.orig:1108
#, no-wrap
msgid "Text Properties in Strings"
msgstr "Text Properties in Strings"

#. type: cindex
#: objects.texi.orig:1110
#, no-wrap
msgid "@samp{#(} read syntax"
msgstr "@samp{#(} read syntax"

#. type: cindex
#: objects.texi.orig:1111
#, no-wrap
msgid "text properties, read syntax"
msgstr "text properties, read syntax"

#. type: Plain text
#: objects.texi.orig:1118
msgid ""
"A string can hold properties for the characters it contains, in addition to "
"the characters themselves.  This enables programs that copy text between "
"strings and buffers to copy the text's properties with no special effort.  "
"@xref{Text Properties}, for an explanation of what text properties mean.  "
"Strings with text properties use a special read and print syntax:"
msgstr "文字列は、その文字自身に加えて、文字のプロパティーも保持することができます。これにより、特別なことをしなくても、文字列とバッファーとの間でテキストをコピーするプログラムが、テキストプロパティーをコピーすることが可能になります。テキストプロパティーが何を意味するかについての説明は、@ref{Text Properties}を参照してください。テキストプロパティーをもつ文字列は、特別な入力構文とプリント構文を使用します。"

#. type: example
#: objects.texi.orig:1121
#, no-wrap
msgid "#(\"@var{characters}\" @var{property-data}...)\n"
msgstr "#(\"@var{characters}\" @var{property-data}...)\n"

#. type: Plain text
#: objects.texi.orig:1126
msgid ""
"where @var{property-data} consists of zero or more elements, in groups of "
"three as follows:"
msgstr "ここで@var{property-data}は3個でグループ化された、0個以上の要素から構成されます:"

#. type: example
#: objects.texi.orig:1129
#, no-wrap
msgid "@var{beg} @var{end} @var{plist}\n"
msgstr "@var{beg} @var{end} @var{plist}\n"

#. type: Plain text
#: objects.texi.orig:1135
msgid ""
"The elements @var{beg} and @var{end} are integers, and together specify a "
"range of indices in the string; @var{plist} is the property list for that "
"range.  For example,"
msgstr "要素@var{beg}および@var{end}は整数で、文字列内のインデックスの範囲を指定します。@var{plist}はその範囲にたいするプロパティーリストです。たとえば、"

#. type: example
#: objects.texi.orig:1138
#, no-wrap
msgid "#(\"foo bar\" 0 3 (face bold) 3 4 nil 4 7 (face italic))\n"
msgstr "#(\"foo bar\" 0 3 (face bold) 3 4 nil 4 7 (face italic))\n"

#. type: Plain text
#: objects.texi.orig:1148
msgid ""
"represents a string whose textual contents are @samp{foo bar}, in which the "
"first three characters have a @code{face} property with value @code{bold}, "
"and the last three have a @code{face} property with value @code{italic}.  "
"(The fourth character has no text properties, so its property list is "
"@code{nil}.  It is not actually necessary to mention ranges with @code{nil} "
"as the property list, since any characters not mentioned in any range will "
"default to having no properties.)"
msgstr "これはテキスト内容が@samp{foo bar}で、最初の3文字は@code{face}プロパティーに値@code{bold}をもち、最後の3文字は@code{face}プロパティーに値@code{italic}をもつことを表します。(4番目の文字にはテキストプロパティーはないので、プロパティーリストは@code{nil}です。実際には、範囲の中の指定されていない文字はデフォルトではプロパティーをもたないので、範囲のプロパティーリストを@code{nil}と指定する必要ありません)。"

#. type: Plain text
#: objects.texi.orig:1156
msgid ""
"A @dfn{vector} is a one-dimensional array of elements of any type.  It takes "
"a constant amount of time to access any element of a vector.  (In a list, "
"the access time of an element is proportional to the distance of the element "
"from the beginning of the list.)"
msgstr "@dfn{ベクター(vector)}は、任意の型の要素からなる1次元の配列です。ベクター内の任意の要素へのアクセスに要す時間は、一定です(リストの場合、要素へのアクセスに要す時間は、リストの先頭からその要素までの距離に比例します)。"

#. type: Plain text
#: objects.texi.orig:1161
msgid ""
"The printed representation of a vector consists of a left square bracket, "
"the elements, and a right square bracket.  This is also the read syntax.  "
"Like numbers and strings, vectors are considered constants for evaluation."
msgstr "ベクターのプリント表現は、左角カッコ(left square bracket)、要素、右角カッコ(right square bracket)から構成されます。これは入力構文でもあります。数字や文字列と同様に、ベクターは評価において定数と判断されます。"

#. type: example
#: objects.texi.orig:1165
#, no-wrap
msgid ""
"[1 \"two\" (three)]      ; @r{A vector of three elements.}\n"
"     @result{} [1 \"two\" (three)]\n"
msgstr ""
"[1 \"two\" (three)]      ; @r{3要素のベクター。}\n"
"     @result{} [1 \"two\" (three)]\n"

#. type: Plain text
#: objects.texi.orig:1168
msgid "@xref{Vectors}, for functions that work with vectors."
msgstr "ベクターに作用する関数については、@ref{Vectors}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1179
msgid ""
"A @dfn{char-table} is a one-dimensional array of elements of any type, "
"indexed by character codes.  Char-tables have certain extra features to make "
"them more useful for many jobs that involve assigning information to "
"character codes---for example, a char-table can have a parent to inherit "
"from, a default value, and a small number of extra slots to use for special "
"purposes.  A char-table can also specify a single value for a whole "
"character set."
msgstr "@dfn{文字テーブル(char-table)}は、任意の型の要素をもつ1次元の配列で、文字コードによりインデックスづけされます。文字テーブルは、文字コードに情報を割り当てることを必要とする多くの処理を簡単にするための、特別な追加の機能をもちます --- たとえば、文字テーブルは、継承するための親、デフォルト値、特別な目的のために使用する少数の余分なスロットをもつことができます。文字テーブルは、文字セット全体にたいして1つの値を指定することもできます。"

#. type: cindex
#: objects.texi.orig:1180
#, no-wrap
msgid "@samp{#^} read syntax"
msgstr "@samp{#^} read syntax"

#. type: Plain text
#: objects.texi.orig:1184
msgid ""
"The printed representation of a char-table is like a vector except that "
"there is an extra @samp{#^} at the beginning.@footnote{You may also "
"encounter @samp{#^^}, used for ``sub-char-tables''.}"
msgstr "文字テーブルのプリント表現はベクターと似ていますが、最初に余分な@samp{#^}があります@footnote{``サブ文字テーブル(sub-char-tables)''に使用される@samp{#^^}を目にすることがあるかもしれません。}。"

#. type: Plain text
#: objects.texi.orig:1187
msgid ""
"@xref{Char-Tables}, for special functions to operate on char-tables.  Uses "
"of char-tables include:"
msgstr "文字テーブルを操作する特別な関数については、@ref{Char-Tables}を参照してください。文字テーブルの使用には以下が含まれます:"

#. type: itemize
#: objects.texi.orig:1191
msgid "Case tables (@pxref{Case Tables})."
msgstr "大文字小文字テーブル(@ref{Case Tables}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1194
msgid "Character category tables (@pxref{Categories})."
msgstr "文字カテゴリーテーブル(@ref{Categories}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1197
msgid "Display tables (@pxref{Display Tables})."
msgstr "ディスプレーテーブル(@ref{Display Tables}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1200
msgid "Syntax tables (@pxref{Syntax Tables})."
msgstr "構文テーブル(@ref{Syntax Tables}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1207
msgid ""
"A @dfn{bool-vector} is a one-dimensional array whose elements must be "
"@code{t} or @code{nil}."
msgstr "@dfn{ブールベクター(bool-vector)}は、要素が@code{t}か@code{nil}でなければならない、1次元の配列です。"

#. type: Plain text
#: objects.texi.orig:1215
msgid ""
"The printed representation of a bool-vector is like a string, except that it "
"begins with @samp{#&} followed by the length.  The string constant that "
"follows actually specifies the contents of the bool-vector as a "
"bitmap---each ``character'' in the string contains 8 bits, which specify the "
"next 8 elements of the bool-vector (1 stands for @code{t}, and 0 for "
"@code{nil}).  The least significant bits of the character correspond to the "
"lowest indices in the bool-vector."
msgstr "ブールベクターのプリント表現は文字列と似ていますが、後に長さを記述した@samp{#&}で始まります。これに続く文字列定数は、ビットマップとして実際に内容を指定するブールベクターです --- 文字列定数内のそれぞれの``文字''は8ビットを含み、これはブールベクターの次の8要素を指定します(1は@code{t}、0は@code{nil}です)。文字の最下位ビットブールベクターの最下位のインデックスに対応します。"

#. type: example
#: objects.texi.orig:1221
#, no-wrap
msgid ""
"(make-bool-vector 3 t)\n"
"     @result{} #&3\"^G\"\n"
"(make-bool-vector 3 nil)\n"
"     @result{} #&3\"^@@\"\n"
msgstr ""
"(make-bool-vector 3 t)\n"
"     @result{} #&3\"^G\"\n"
"(make-bool-vector 3 nil)\n"
"     @result{} #&3\"^@@\"\n"

#. type: Plain text
#: objects.texi.orig:1226
msgid ""
"These results make sense, because the binary code for @samp{C-g} is 111 and "
"@samp{C-@@} is the character with code 0."
msgstr "@samp{C-g}の2進コードは111、@samp{C-@@}はコード0の文字なので、この結果は道理にかなっています。"

#. type: Plain text
#: objects.texi.orig:1231
msgid ""
"If the length is not a multiple of 8, the printed representation shows extra "
"elements, but these extras really make no difference.  For instance, in the "
"next example, the two bool-vectors are equal, because only the first 3 bits "
"are used:"
msgstr "長さが8の倍数でない場合、プリント表現には余分な要素が表示されますが、これらの余分な要素に意味はありません。たとえば以下の例では、最初の3ビットだけが使用されるので、2つのブールベクターは等価です:"

#. type: example
#: objects.texi.orig:1235
#, no-wrap
msgid ""
"(equal #&3\"\\377\" #&3\"\\007\")\n"
"     @result{} t\n"
msgstr ""
"(equal #&3\"\\377\" #&3\"\\007\")\n"
"     @result{} t\n"

#. type: Plain text
#: objects.texi.orig:1244
msgid ""
"A hash table is a very fast kind of lookup table, somewhat like an alist in "
"that it maps keys to corresponding values, but much faster.  The printed "
"representation of a hash table specifies its properties and contents, like "
"this:"
msgstr "ハッシュテーブルは非常に高速な照合テーブルの一種で、キーを対応する値にマップするalistと似ていますが、より高速です。ハッシュテーブルのプリント表現、以下のようにハッシュテーブルのプロパティーと内容を指定します:"

#. type: example
#: objects.texi.orig:1249
#, no-wrap
msgid ""
"(make-hash-table)\n"
"     @result{} #s(hash-table size 65 test eql rehash-size 1.5\n"
"                             rehash-threshold 0.8 data ())\n"
msgstr ""
"(make-hash-table)\n"
"     @result{} #s(hash-table size 65 test eql rehash-size 1.5\n"
"                             rehash-threshold 0.8 data ())\n"

#. type: Plain text
#: objects.texi.orig:1253
msgid "@xref{Hash Tables}, for more information about hash tables."
msgstr "ハッシュテーブルについての詳細な情報は、@ref{Hash Tables}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1262
msgid ""
"Lisp functions are executable code, just like functions in other programming "
"languages.  In Lisp, unlike most languages, functions are also Lisp "
"objects.  A non-compiled function in Lisp is a lambda expression: that is, a "
"list whose first element is the symbol @code{lambda} (@pxref{Lambda "
"Expressions})."
msgstr "他のプログラミング言語の関数と同様に、Lisp関数は実行可能なコードです。他の言語とは異なり、Lispの関数はLispオブジェクトでもあります。Lispのコンパイルされていない関数はラムダ式 --- つまり1番目の要素がシンボル@code{lambda}であるリストです(@ref{Lambda Expressions}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1270
msgid ""
"In most programming languages, it is impossible to have a function without a "
"name.  In Lisp, a function has no intrinsic name.  A lambda expression can "
"be called as a function even though it has no name; to emphasize this, we "
"also call it an @dfn{anonymous function} (@pxref{Anonymous Functions}).  A "
"named function in Lisp is just a symbol with a valid function in its "
"function cell (@pxref{Defining Functions})."
msgstr "ほとんどのプログラミング言語では、名前のないの関数はありません。Lispでは、関数に本質的な名前はありません。名前がなくても、ラムダ式を関数として呼び出すことができます。これを強調するために、わたしたちはこれを@dfn{無名関数(anonymous function)}とも呼びます(@ref{Anonymous Functions}を参照してください)。Lispの名前つき関数は、関数セルに有効な関数がセットされた単なるシンボルです(@ref{Defining Functions}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1275
msgid ""
"Most of the time, functions are called when their names are written in Lisp "
"expressions in Lisp programs.  However, you can construct or obtain a "
"function object at run time and then call it with the primitive functions "
"@code{funcall} and @code{apply}.  @xref{Calling Functions}."
msgstr "ほとんどの場合、関数はLispプログラム内のLisp式に名前が記述されたところで呼び出されます。しかし、実行時に関数オブジェクトを構築または取得してから、基本関数@code{funcall}および@code{apply}により呼び出すことができます。@ref{Calling Functions}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1284
msgid ""
"A @dfn{Lisp macro} is a user-defined construct that extends the Lisp "
"language.  It is represented as an object much like a function, but with "
"different argument-passing semantics.  A Lisp macro has the form of a list "
"whose first element is the symbol @code{macro} and whose @sc{cdr} is a Lisp "
"function object, including the @code{lambda} symbol."
msgstr "@dfn{Lispマクロ(Lisp macro)}は。Lisp言語を拡張する、ユーザー定義の構成です。これはオブジェクトとしてではなく関数のように表現されますが、引数の渡し方の意味が異なります。Lispマクロの形式はリストです。これは、最初の要素が@code{macro}で、(@code{lambda}シンボルを含む)@sc{cdr}がLisp関数オブジェクトであるようなリストです。"

#. type: Plain text
#: objects.texi.orig:1289
msgid ""
"Lisp macro objects are usually defined with the built-in @code{defmacro} "
"function, but any list that begins with @code{macro} is a macro as far as "
"Emacs is concerned.  @xref{Macros}, for an explanation of how to write a "
"macro."
msgstr "Lispマクロオブジェクトは通常、ビルトインの@code{defmacro}関数で定義されますが、@code{macro}で始まる任意のリストも、Emacsにとってはマクロです。マクロを記述する方法の説明は、@ref{Macros}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1293
msgid ""
"@strong{Warning}: Lisp macros and keyboard macros (@pxref{Keyboard Macros}) "
"are entirely different things.  When we use the word ``macro'' without "
"qualification, we mean a Lisp macro, not a keyboard macro."
msgstr "@strong{警告}: Lispマクロとキーボードマクロ(@ref{Keyboard Macros}を参照してください)は、完全に別物です。修飾なしで``マクロ''という単語を使用したときは、キーボードマクロではなく、Lispマクロのことを指します。"

#. type: cindex
#: objects.texi.orig:1296
#, no-wrap
msgid "primitive function"
msgstr "primitive function"

#. type: Plain text
#: objects.texi.orig:1305
msgid ""
"A @dfn{primitive function} is a function callable from Lisp but written in "
"the C programming language.  Primitive functions are also called @dfn{subrs} "
"or @dfn{built-in functions}.  (The word ``subr'' is derived from "
"``subroutine''.)  Most primitive functions evaluate all their arguments when "
"they are called.  A primitive function that does not evaluate all its "
"arguments is called a @dfn{special form} (@pxref{Special Forms})."
msgstr "@dfn{基本関数(primitive function)}とは、Cプログラミング言語で記述された、Lispから呼び出せる関数です。基本関数は@dfn{subrs}や@dfn{ビルと陰関数(built-in functions)}とも呼ばれます(単語``subr''は、``サブルーチン(subroutine)''が由来です)。ほとんどの基本関数、呼び出されたとき、すべての引数を評価します。すべての引数を評価しない基本関数は、@dfn{スペシャルフォーム(special form)}と呼ばれます(@ref{Special Forms}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1313
msgid ""
"It does not matter to the caller of a function whether the function is "
"primitive.  However, this does matter if you try to redefine a primitive "
"with a function written in Lisp.  The reason is that the primitive function "
"may be called directly from C code.  Calls to the redefined function from "
"Lisp will use the new definition, but calls from C code may still use the "
"built-in definition.  Therefore, @strong{we discourage redefinition of "
"primitive functions}."
msgstr "呼び出す側からすれば、その関数が基本関数かどうかは、問題になりません。しかし、基本関数をLispで記述された関数で再定義した場合は、問題になります。理由は、その基本関数がCコードから直接呼び出されているかもしれないからです。Lispから再定義した関数を呼び出すと、これは新しい定義を使用するでしょうが、Cコードから呼び出すと、ビルトインの定義が使用されるでしょう。したがって、@strong{基本関数の再定義はしないでください}。"

#. type: Plain text
#: objects.texi.orig:1317
msgid ""
"The term @dfn{function} refers to all Emacs functions, whether written in "
"Lisp or C@.  @xref{Function Type}, for information about the functions "
"written in Lisp."
msgstr "@dfn{関数(function)}という用語により、LispやCで記述された、すべてのEmacs関数を参照します。Lispで記述された関数についての情報は、@ref{Function Type}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1320
msgid ""
"Primitive functions have no read syntax and print in hash notation with the "
"name of the subroutine."
msgstr "基本関数に入力構文はなく、サブルーチン名とともにハッシュ表記でプリントします。"

#. type: group
#: objects.texi.orig:1328
#, no-wrap
msgid ""
"(symbol-function 'car)          ; @r{Access the function cell}\n"
"                                ;   @r{of the symbol.}\n"
"     @result{} #<subr car>\n"
"(subrp (symbol-function 'car))  ; @r{Is this a primitive function?}\n"
"     @result{} t                       ; @r{Yes.}\n"
msgstr ""
"(symbol-function 'car)          ; @r{そのシンボルの関数セルに}\n"
"                                ;     @r{アクセスします。}\n"
"     @result{} #<subr car>\n"
"(subrp (symbol-function 'car))  ; @r{これは基本関数か?}\n"
"     @result{} t                ;    @r{イェース。}\n"

#. type: subsection
#: objects.texi.orig:1332
#, no-wrap
msgid "Byte-Code Function Type"
msgstr "Byte-Code Function Type"

#. type: Plain text
#: objects.texi.orig:1339
msgid ""
"@dfn{Byte-code function objects} are produced by byte-compiling Lisp code "
"(@pxref{Byte Compilation}).  Internally, a byte-code function object is much "
"like a vector; however, the evaluator handles this data type specially when "
"it appears in a function call.  @xref{Byte-Code Objects}."
msgstr "@dfn{バイトコード関数オブジェクト(byte-code function objects)}は、Lispコードをバイトコンパイルすることにより生成されます(@ref{Byte Compilation}を参照してください)。内部的には、バイトコード関数オブジェクトは、ベクターによく似ています。しかしバイトコード関数オブジェクトが関数呼び出しのように見える場合、評価プロセスにより、このデータ型は特別に処理されます。@ref{Byte-Code Objects}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1343
msgid ""
"The printed representation and read syntax for a byte-code function object "
"is like that for a vector, with an additional @samp{#} before the opening "
"@samp{[}."
msgstr "バイトコード関数オブジェクトのプリント表現と入力構文は、ベクターのものと似ていますが、開き角カッコ@samp{[}の前に@samp{#}があります。"

#. type: Plain text
#: objects.texi.orig:1353
msgid ""
"An @dfn{autoload object} is a list whose first element is the symbol "
"@code{autoload}.  It is stored as the function definition of a symbol, where "
"it serves as a placeholder for the real definition.  The autoload object "
"says that the real definition is found in a file of Lisp code that should be "
"loaded when necessary.  It contains the name of the file, plus some other "
"information about the real definition."
msgstr "@dfn{autoloadオブジェクト(autoload object)}は、最初の要素がシンボル@code{autoload}のリストです。これはシンボルの関数定義として保存され、実際の定義にたいする代替としての役割をもちます。autoloadオブジェクトは、必要な時にロードされるLispコードファイルのなかで、実際の定義を見つけることができることを宣言します。これにはファイル名と、加えて実際の定義についての他のいくつかの情報が含まれます。"

#. type: Plain text
#: objects.texi.orig:1359
msgid ""
"After the file has been loaded, the symbol should have a new function "
"definition that is not an autoload object.  The new definition is then "
"called as if it had been there to begin with.  From the user's point of "
"view, the function call works as expected, using the function definition in "
"the loaded file."
msgstr "ファイルがロードされた後、そのシンボルは、autoloadオブジェクトではない、新しい関数定義をもつはずです。新しい定義は、最初からそこにあったかのように呼び出されます。ユーザーの観点からは、関数呼び出しは期待された動作、つまりロードされたファイル内の関数定義を使用します。"

#. type: Plain text
#: objects.texi.orig:1363
msgid ""
"An autoload object is usually created with the function @code{autoload}, "
"which stores the object in the function cell of a symbol.  @xref{Autoload}, "
"for more details."
msgstr "autoloadオブジェクトは通常、シンボルの関数セルにオブジェクトを保存する、関数@code{autoload}により作成されます。詳細は、@ref{Autoload}を参照してください。"

#. type: cindex
#: objects.texi.orig:1366
#, no-wrap
msgid "editing types"
msgstr "editing types"

#. type: Plain text
#: objects.texi.orig:1372
msgid ""
"The types in the previous section are used for general programming purposes, "
"and most of them are common to most Lisp dialects.  Emacs Lisp provides "
"several additional data types for purposes connected with editing."
msgstr "前のセクションの型は一般的なプログラミングの目的のために使用され、これらのほとんどは、ほとんどのLisp方言で一般的です。Emacs Lispは、編集に関する目的のために、いくつかの追加のデータ型を提供します。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1388 objects.texi.orig:1389
#, no-wrap
msgid "Buffer Type"
msgstr "Buffer Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "The basic object of editing."
msgstr "編集のための基本オブジェクト。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1451 objects.texi.orig:1452
#, no-wrap
msgid "Marker Type"
msgstr "Marker Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "A position in a buffer."
msgstr "バッファー内の位置。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1473 objects.texi.orig:1474
#, no-wrap
msgid "Window Type"
msgstr "Window Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Buffers are displayed in windows."
msgstr "バッファーはウィンドウ内に表示されます。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1504 objects.texi.orig:1505
#, no-wrap
msgid "Frame Type"
msgstr "Frame Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Windows subdivide frames."
msgstr "ウィンドウはフレームを細分します。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1524 objects.texi.orig:1525
#, no-wrap
msgid "Terminal Type"
msgstr "Terminal Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "A terminal device displays frames."
msgstr "フレームを表示する端末デバイス。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1543 objects.texi.orig:1544
#, no-wrap
msgid "Window Configuration Type"
msgstr "Window Configuration Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Recording the way a frame is subdivided."
msgstr "フレームが細分化された方法を記録する。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1556 objects.texi.orig:1557
#, no-wrap
msgid "Frame Configuration Type"
msgstr "Frame Configuration Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Recording the status of all frames."
msgstr "すべてのフレームの状態を記録する。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1571 objects.texi.orig:1572
#, no-wrap
msgid "Process Type"
msgstr "Process Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "A subprocess of Emacs running on the underlying OS."
msgstr "背後のOS上で実行されるEmacsのサブプロセス。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1597 objects.texi.orig:1598
#, no-wrap
msgid "Stream Type"
msgstr "Stream Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Receive or send characters."
msgstr "文字の受信と送信。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1621 objects.texi.orig:1622
#, no-wrap
msgid "Keymap Type"
msgstr "Keymap Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "What function a keystroke invokes."
msgstr "キーストロークがどの関数を呼び出すか。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1631 objects.texi.orig:1632
#, no-wrap
msgid "Overlay Type"
msgstr "Overlay Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "How an overlay is represented."
msgstr "オーバーレイが表示される方法。"

#. type: subsection
#: objects.texi.orig:1386 objects.texi.orig:1644 objects.texi.orig:1645
#, no-wrap
msgid "Font Type"
msgstr "Font Type"

#. type: menuentry
#: objects.texi.orig:1386
msgid "Fonts for displaying text."
msgstr "テキストを表示するフォント。"

#. type: Plain text
#: objects.texi.orig:1401
msgid ""
"A @dfn{buffer} is an object that holds text that can be edited "
"(@pxref{Buffers}).  Most buffers hold the contents of a disk file "
"(@pxref{Files}) so they can be edited, but some are used for other "
"purposes.  Most buffers are also meant to be seen by the user, and therefore "
"displayed, at some time, in a window (@pxref{Windows}).  But a buffer need "
"not be displayed in any window.  Each buffer has a designated position "
"called @dfn{point} (@pxref{Positions}); most editing commands act on the "
"contents of the current buffer in the neighborhood of point.  At any time, "
"one buffer is the @dfn{current buffer}."
msgstr "@dfn{バッファー(buffer)}とは、編集されるテキストを保持するオブジェクトです(@ref{Buffers}を参照してください)。ほとんどのバッファーはディスクファイル(@ref{Files}を参照してください)の内容を保持するので、それらは編集できますが、他の目的のために使用されるものもいくつかあります。ほとんどのバッファーは、ユーザーにより閲覧されることも意図しているので、いつかはウィンドウ内(@ref{Windows}を参照してください)に表示されます。しかしバッファーはウィンドウに表示される必要はありません。バッファーはそれぞれ、@dfn{ポイント(point)}と呼ばれる位置指定をもちます(@ref{Positions}を参照してください)。ほとんどの編集コマンドは、カレントバッファー内のポイントに隣接する内容を処理します。常に1つのバッファーが@dfn{カレントバッファー(current buffer)}です。"

#. type: Plain text
#: objects.texi.orig:1408
msgid ""
"The contents of a buffer are much like a string, but buffers are not used "
"like strings in Emacs Lisp, and the available operations are different.  For "
"example, you can insert text efficiently into an existing buffer, altering "
"the buffer's contents, whereas ``inserting'' text into a string requires "
"concatenating substrings, and the result is an entirely new string object."
msgstr "バッファーの内容は文字列によく似ていますが、バッファーはEmacs Lispの文字列と同じようには使用されず、利用可能な操作は異なります。文字列にテキストを``挿入''するためには、部分文字列の結合が必要で、結果は完全に新しい文字列オブジェクトなのに比べて、バッファーでは既存のバッファーに効率的にテキストを挿入して、バッファーの内容を変更できます。"

#. type: Plain text
#: objects.texi.orig:1412
msgid ""
"Many of the standard Emacs functions manipulate or test the characters in "
"the current buffer; a whole chapter in this manual is devoted to describing "
"these functions (@pxref{Text})."
msgstr "標準的なEmacs関数の多くは、カレントバッファー内の文字を操作したりテストするためのものです。このマニュアルには、これらの関数の説明のために、1つのチャプターをあてています(@ref{Text}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1414
msgid "Several other data structures are associated with each buffer:"
msgstr "他のデータ構造のいくつかは、各バッファーに関連付けられています:"

#. type: itemize
#: objects.texi.orig:1418
msgid "a local syntax table (@pxref{Syntax Tables});"
msgstr "ローカル構文テーブル(@ref{Syntax Tables}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1421
msgid "a local keymap (@pxref{Keymaps}); and,"
msgstr "ローカルキーマップ(@ref{Keymaps}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1424
msgid "a list of buffer-local variable bindings (@pxref{Buffer-Local Variables})."
msgstr "バッファーローカルな変数バインディングのリスト(@ref{Buffer-Local Variables}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1427
msgid "overlays (@pxref{Overlays})."
msgstr "オーバーレイ(@ref{Overlays}を参照してください)。"

#. type: itemize
#: objects.texi.orig:1430
msgid "text properties for the text in the buffer (@pxref{Text Properties})."
msgstr "バッファー内のテキストにたいするテキストプロパティー(@ref{Text Properties}を参照してください)。"

#. type: Plain text
#: objects.texi.orig:1437
msgid ""
"The local keymap and variable list contain entries that individually "
"override global bindings or values.  These are used to customize the "
"behavior of programs in different buffers, without actually changing the "
"programs."
msgstr "ローカルキーマップと変数リストは、具ローマルナバインディングや値を個別にオーバーライドするためのエントリーを含みます。これらは、実際にプログラムを変更することなく、異なるバッファーでのプログラムの振る舞いをカスタマイズするために使用されます。"

#. type: Plain text
#: objects.texi.orig:1440
msgid ""
"A buffer may be @dfn{indirect}, which means it shares the text of another "
"buffer, but presents it differently.  @xref{Indirect Buffers}."
msgstr "バッファーは@dfn{インダイレクト(indirect: 間接)} --- つまり他のバッファーとテキストを共有するが、それぞれ別に表示する --- かもしれません。@ref{Indirect Buffers}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1443
msgid ""
"Buffers have no read syntax.  They print in hash notation, showing the "
"buffer name."
msgstr "バッファーに入力構文はありません。バッファーはバッファー名を含むハッシュ表記でプリントされます。"

#. type: Plain text
#: objects.texi.orig:1459
msgid ""
"A @dfn{marker} denotes a position in a specific buffer.  Markers therefore "
"have two components: one for the buffer, and one for the position.  Changes "
"in the buffer's text automatically relocate the position value as necessary "
"to ensure that the marker always points between the same two characters in "
"the buffer."
msgstr "@dfn{マーカー(marker)}は、特定のバッファー内の位置を表します。したがってマーカーには2つの内容 --- 1つはバッファー、もう1つは位置 --- をもちます。バッファーのテキストの変更では、マーカーが常にバッファー内の同じ2つの文字の間に位置することを確実にするために、必要に応じて自動的に位置の値が再配置されます。"

#. type: Plain text
#: objects.texi.orig:1462
msgid ""
"Markers have no read syntax.  They print in hash notation, giving the "
"current character position and the name of the buffer."
msgstr "マーカーは入力構文をもちません。マーカーは、カレントの文字位置と、そのバッファー名を与える、ハッシュ表記でプリントされます。"

#. type: group
#: objects.texi.orig:1467
#, no-wrap
msgid ""
"(point-marker)\n"
"     @result{} #<marker at 10779 in objects.texi>\n"
msgstr ""
"(point-marker)\n"
"     @result{} #<marker at 10779 in objects.texi>\n"

#. type: Plain text
#: objects.texi.orig:1472
msgid ""
"@xref{Markers}, for information on how to test, create, copy, and move "
"markers."
msgstr "マーカーのテスト、作成、コピー、移動の方法についての情報は、@ref{Markers}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1480
msgid ""
"A @dfn{window} describes the portion of the terminal screen that Emacs uses "
"to display a buffer.  Every window has one associated buffer, whose contents "
"appear in the window.  By contrast, a given buffer may appear in one window, "
"no window, or several windows."
msgstr "@dfn{ウィンドウ(window)}はEmacsがバッファーを表示するために使用する端末スクリーンの部分を記述します。すべてのウィンドウは関連付けられた1つのバッファーをもち、バッファーの内容はそのウィンドウに表示されます。対照的に、あるバッファーは、1つのウィンドウに表示されるか、ウィンドウに表示されないか、それとも複数のウィンドウに表示されるかもしれません。"

#. type: Plain text
#: objects.texi.orig:1486
msgid ""
"Though many windows may exist simultaneously, at any time one window is "
"designated the @dfn{selected window}.  This is the window where the cursor "
"is (usually) displayed when Emacs is ready for a command.  The selected "
"window usually displays the current buffer, but this is not necessarily the "
"case."
msgstr "同時に複数のウィンドウが存在するかもしれませんが、常に1つのウィンドウが@dfn{選択されたウィンドウ(selected window)}になります。Emacsがコマンドにたいして準備できているときに、(通常は)カーソルが表示されるウィンドウが、選択されたウィンドウです。選択されたウィンドウは通常、カレントバッファーを表示しますが、これは必須ではありません。"

#. type: Plain text
#: objects.texi.orig:1489
msgid ""
"Windows are grouped on the screen into frames; each window belongs to one "
"and only one frame.  @xref{Frame Type}."
msgstr "スクリーン上でウィンドウはフレームにグループ化されます。各ウィンドウは、ただ1つだけのフレームに属します。@ref{Frame Type}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1494
msgid ""
"Windows have no read syntax.  They print in hash notation, giving the window "
"number and the name of the buffer being displayed.  The window numbers exist "
"to identify windows uniquely, since the buffer displayed in any given window "
"can change frequently."
msgstr "ウィンドウは入力構文をもちません。ウィンドウは、ウィンドウ番号、表示されているバッファー名を与える、ハッシュ表記でプリントされます。与えられたウィンドウに表示されるバッファーは頻繁に変更されるかもしれないので、一意にウィンドウを識別するためにウィンドウ番号が存在します。"

#. type: group
#: objects.texi.orig:1499
#, no-wrap
msgid ""
"(selected-window)\n"
"     @result{} #<window 1 on objects.texi>\n"
msgstr ""
"(selected-window)\n"
"     @result{} #<window 1 on objects.texi>\n"

#. type: Plain text
#: objects.texi.orig:1503
msgid "@xref{Windows}, for a description of the functions that work on windows."
msgstr "ウィンドウに作用する関数の説明は、@ref{Windows}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1510
msgid ""
"A @dfn{frame} is a screen area that contains one or more Emacs windows; we "
"also use the term ``frame'' to refer to the Lisp object that Emacs uses to "
"refer to the screen area."
msgstr "@dfn{フレーム(frame)}とは、１つ以上のEmacsウィンドウを含むスクリーン領域です。スクリーン領域を参照するためにEmacsが使用するLispオブジェクトを指す場合も、``フレーム''という用語を使用します。"

#. type: Plain text
#: objects.texi.orig:1514
msgid ""
"Frames have no read syntax.  They print in hash notation, giving the frame's "
"title, plus its address in core (useful to identify the frame uniquely)."
msgstr "フレームは入力構文をもちません。フレームはフレームのタイトル、(フレームを一意に識別するのに便利な)メモリー内のアドレスを与えるハッシュ表記でプリントされます。"

#. type: group
#: objects.texi.orig:1519
#, no-wrap
msgid ""
"(selected-frame)\n"
"     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>\n"
msgstr ""
"(selected-frame)\n"
"     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>\n"

#. type: Plain text
#: objects.texi.orig:1523
msgid "@xref{Frames}, for a description of the functions that work on frames."
msgstr "フレームに作用する関数の説明は、@ref{Frames}を参照してください。"

#. type: cindex
#: objects.texi.orig:1526
#, no-wrap
msgid "terminal type"
msgstr "terminal type"

#. type: Plain text
#: objects.texi.orig:1530
msgid ""
"A @dfn{terminal} is a device capable of displaying one or more Emacs frames "
"(@pxref{Frame Type})."
msgstr "@dfn{端末(terminal)}は、1つ以上のEmacsフレーム(@ref{Frame Type}を参照してください)を表示する能力があるデバイスです。"

#. type: Plain text
#: objects.texi.orig:1533
msgid ""
"Terminals have no read syntax.  They print in hash notation giving the "
"terminal's ordinal number and its TTY device file name."
msgstr "端末は入力構文をもちません。端末は、その端末の順序番号、TTYデバイスファイル名を与える、ハッシュ表記でプリントされます。"

#. type: group
#: objects.texi.orig:1538
#, no-wrap
msgid ""
"(get-device-terminal nil)\n"
"     @result{} #<terminal 1 on /dev/tty>\n"
msgstr ""
"(get-device-terminal nil)\n"
"     @result{} #<terminal 1 on /dev/tty>\n"

#. type: cindex
#: objects.texi.orig:1545
#, no-wrap
msgid "window layout in a frame"
msgstr "window layout in a frame"

#. type: Plain text
#: objects.texi.orig:1550
msgid ""
"A @dfn{window configuration} stores information about the positions, sizes, "
"and contents of the windows in a frame, so you can recreate the same "
"arrangement of windows later."
msgstr "@dfn{ウィンドウ構成(window configuration)}は、フレーム内のウィンドウの位置、サイズ、内容についての情報を保持します。これにより後で同じウィンドウ配置を再作成できます。"

#. type: Plain text
#: objects.texi.orig:1555
msgid ""
"Window configurations do not have a read syntax; their print syntax looks "
"like @samp{#<window-configuration>}.  @xref{Window Configurations}, for a "
"description of several functions related to window configurations."
msgstr "ウィンドウ構成は入力構文をもちません。ウィンドウ構成のプリント表現は、@samp{#<window-configuration>}のようになります。ウィンドウ構成に関連するいくつかの関数の説明は、@ref{Window Configurations}を参照してください。"

#. type: cindex
#: objects.texi.orig:1558
#, no-wrap
msgid "screen layout"
msgstr "screen layout"

#. type: cindex
#: objects.texi.orig:1559
#, no-wrap
msgid "window layout, all frames"
msgstr "window layout, all frames"

#. type: Plain text
#: objects.texi.orig:1567
msgid ""
"A @dfn{frame configuration} stores information about the positions, sizes, "
"and contents of the windows in all frames.  It is not a primitive type---it "
"is actually a list whose @sc{car} is @code{frame-configuration} and whose "
"@sc{cdr} is an alist.  Each alist element describes one frame, which appears "
"as the @sc{car} of that element."
msgstr "@dfn{フレーム構成(frame configuration)}は、すべてのフレーム内のウィンドウの位置、サイズ、内容についての情報を保持します。これは基本型ではありません --- 実際のところ、これは@sc{car}が@code{frame-configuration}で、@sc{cdr}がalistのリストです。各alist要素は、その要素の@sc{car}に示される1つのフレームを記述します。"

#. type: Plain text
#: objects.texi.orig:1570
msgid ""
"@xref{Frame Configurations}, for a description of several functions related "
"to frame configurations."
msgstr "フレーム構成に関連するいくつかの関数の説明は、@ref{Frame Configurations}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1582
msgid ""
"The word @dfn{process} usually means a running program.  Emacs itself runs "
"in a process of this sort.  However, in Emacs Lisp, a process is a Lisp "
"object that designates a subprocess created by the Emacs process.  Programs "
"such as shells, GDB, ftp, and compilers, running in subprocesses of Emacs, "
"extend the capabilities of Emacs.  An Emacs subprocess takes textual input "
"from Emacs and returns textual output to Emacs for further manipulation.  "
"Emacs can also send signals to the subprocess."
msgstr "単語@dfn{プロセス(process)}は通常、実行中のプログラムを意味します。Emacs自身はこの種のプロセス内で実行されます。しかしEmacs Lispでは、プロセスとはEmacsプロセスにより作成されたサブプロセスを表す、Lispオブジェクトです。シェル、GDB、ftp、コンパイラーなどのプログラムは、Emacsのサブプロセスとして実行され、Emacsの能力を拡張します。さらに操作を行なうために、Emacsサブプロセスは、Emacsからテキスト入力を受け取り、テキスト出力をEmacsにreturnします。Emacsは、サブプロセスにシグナルを送ることもできます。"

#. type: Plain text
#: objects.texi.orig:1585
msgid ""
"Process objects have no read syntax.  They print in hash notation, giving "
"the name of the process:"
msgstr "プロセスオブジェクトは入力構文をもちません。プロセスオブジェクトは、プロセス名を与えるハッシュ表記でプリントされます。"

#. type: group
#: objects.texi.orig:1590
#, no-wrap
msgid ""
"(process-list)\n"
"     @result{} (#<process shell>)\n"
msgstr ""
"(process-list)\n"
"     @result{} (#<process shell>)\n"

#. type: Plain text
#: objects.texi.orig:1596
msgid ""
"@xref{Processes}, for information about functions that create, delete, "
"return information about, send input or signals to, and receive output from "
"processes."
msgstr "プロセスの作成、削除、プロセスに関する情報のreturn、入力やシグナルの送信、出力の受信を行なう関数についての情報は、@ref{Processes}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1607
msgid ""
"A @dfn{stream} is an object that can be used as a source or sink for "
"characters---either to supply characters for input or to accept them as "
"output.  Many different types can be used this way: markers, buffers, "
"strings, and functions.  Most often, input streams (character sources)  "
"obtain characters from the keyboard, a buffer, or a file, and output streams "
"(character sinks) send characters to a buffer, such as a @file{*Help*} "
"buffer, or to the echo area."
msgstr "@dfn{ストリーム(stream)}とは、文字のソースまたはシンクとして --- つまり入力として文字を供給したり、出力として文字を受け入れるために使用できるオブジェクトです。多くの異なるタイプ --- マーカー、バッファー、文字列、関数を、この方法で使用できます。ほとんどの場合、入力ストリーム(文字列ソース)は、キーボード、バッファー、ファイルから文字を受け取り、出力ストリーム(文字シンク)は文字を@file{*Help*}バッファーのようなバッファー、エコーエリアに文字を送ります。"

#. type: Plain text
#: objects.texi.orig:1614
msgid ""
"The object @code{nil}, in addition to its other meanings, may be used as a "
"stream.  It stands for the value of the variable @code{standard-input} or "
"@code{standard-output}.  Also, the object @code{t} as a stream specifies "
"input using the minibuffer (@pxref{Minibuffers}) or output in the echo area "
"(@pxref{The Echo Area})."
msgstr "オブジェクト@code{nil}は、他の意味に加えて、ストリームとして使用されることがあります。@code{nil}は変数@code{standard-input}や@code{standard-output}の値を表します。オブジェクト@code{t}も、入力としてミニバッファー(@ref{Minibuffers}を参照してください)、出力としてエコーエリア(@ref{The Echo Area}を参照してください)の使用を指定するストリームになります。"

#. type: Plain text
#: objects.texi.orig:1617
msgid ""
"Streams have no special printed representation or read syntax, and print as "
"whatever primitive type they are."
msgstr "ストリームは特別なプリント表現や入力構文をもたず、何であれ、それらの基本型としてプリントされます。"

#. type: Plain text
#: objects.texi.orig:1620
msgid ""
"@xref{Read and Print}, for a description of functions related to streams, "
"including parsing and printing functions."
msgstr "パース関数およびプリント関数を含む、ストリームに関連した関数の説明は、@ref{Read and Print}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1627
msgid ""
"A @dfn{keymap} maps keys typed by the user to commands.  This mapping "
"controls how the user's command input is executed.  A keymap is actually a "
"list whose @sc{car} is the symbol @code{keymap}."
msgstr "@dfn{キーマップ(keymap)}は、ユーザーがタイプした文字を、コマンドにマップします。このマップは、ユーザーのコマンド入力が実行される方法を制御します。キーマップは、実際には@sc{car}がシンボル@code{keymap}のリストです。"

#. type: Plain text
#: objects.texi.orig:1630
msgid ""
"@xref{Keymaps}, for information about creating keymaps, handling prefix "
"keys, local as well as global keymaps, and changing key bindings."
msgstr "キーマップの作成、プレフィクスキーの処理、ローカルキーマップやグローバルキーマップ、キーバインドの変更についての情報は、@ref{Keymaps}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1641
msgid ""
"An @dfn{overlay} specifies properties that apply to a part of a buffer.  "
"Each overlay applies to a specified range of the buffer, and contains a "
"property list (a list whose elements are alternating property names and "
"values).  Overlay properties are used to present parts of the buffer "
"temporarily in a different display style.  Overlays have no read syntax, and "
"print in hash notation, giving the buffer name and range of positions."
msgstr "@dfn{オーバーレイ(overlay)}は、バッファーの一部に適用するプロパティーを指定します。それぞれのオーバーレイはバッファーの指定された範囲に適用され、プロパティーリスト(プロパティー名と値が交互に記述された要素のリスト)を含みます。オーバーレイプロパティーは、バッファーの指定された一部を、一時的に異なるスタイルで表示するために使用されます。オーバーレイは入力構文をもたず、バッファーメイト範囲の位置を与えるハッシュ表記でプリントされます。"

#. type: Plain text
#: objects.texi.orig:1643
msgid "@xref{Overlays}, for information on how you can create and use overlays."
msgstr "オーバーレイを作成したり使用する方法についての情報は、@ref{Overlays}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1654
msgid ""
"A @dfn{font} specifies how to display text on a graphical terminal.  There "
"are actually three separate font types---@dfn{font objects}, @dfn{font "
"specs}, and @dfn{font entities}---each of which has slightly different "
"properties.  None of them have a read syntax; their print syntax looks like "
"@samp{#<font-object>}, @samp{#<font-spec>}, and @samp{#<font-entity>} "
"respectively.  @xref{Low-Level Font}, for a description of these Lisp "
"objects."
msgstr "@dfn{font}は、グラフィカルな端末上のテキストを表示する方法を指定します。実際には異なる3つのフォント型 --- @dfn{フォントオブジェクト(font objects)}、@dfn{フォントスペック(font specs)}、@dfn{フォントエンティティー(font entities)} --- が存在しますこれらは入力構文をもちません。これらのプリント構文は、@samp{#<font-object>}、@samp{#<font-spec>}、@samp{#<font-entity>}のようになります。これらのLispオブジェクトの説明は、@ref{Low-Level Font}を参照してください。"

#. type: section
#: objects.texi.orig:1656
#, no-wrap
msgid "Read Syntax for Circular Objects"
msgstr "Read Syntax for Circular Objects"

#. type: cindex
#: objects.texi.orig:1657
#, no-wrap
msgid "circular structure, read syntax"
msgstr "circular structure, read syntax"

#. type: cindex
#: objects.texi.orig:1658
#, no-wrap
msgid "shared structure, read syntax"
msgstr "shared structure, read syntax"

#. type: cindex
#: objects.texi.orig:1659
#, no-wrap
msgid "@samp{#@var{n}=} read syntax"
msgstr "@samp{#@var{n}=} read syntax"

#. type: cindex
#: objects.texi.orig:1660
#, no-wrap
msgid "@samp{#@var{n}#} read syntax"
msgstr "@samp{#@var{n}#} read syntax"

#. type: Plain text
#: objects.texi.orig:1665
msgid ""
"To represent shared or circular structures within a complex of Lisp objects, "
"you can use the reader constructs @samp{#@var{n}=} and @samp{#@var{n}#}."
msgstr "複雑なLispオブジェクトにおける共有された構造、または循環する構造を表すために、リーダー構成@samp{#@var{n}=}と@samp{#@var{n}#}を使用することができます。"

#. type: Plain text
#: objects.texi.orig:1670
msgid ""
"Use @code{#@var{n}=} before an object to label it for later reference; "
"subsequently, you can use @code{#@var{n}#} to refer the same object in "
"another place.  Here, @var{n} is some integer.  For example, here is how to "
"make a list in which the first element recurs as the third element:"
msgstr "後でオブジェクトを参照するには、オブジェクトの前で@code{#@var{n}=}を使用します。その後で、他の場所にある同じオブジェクトを参照するために、@code{#@var{n}#}を使用することができます。ここで@var{n}は任意の整数です。たとえば以下は、1番目の要素が3番目の要素にも繰り替えされるリストを作成する方法です:"

#. type: example
#: objects.texi.orig:1673
#, no-wrap
msgid "(#1=(a) b #1#)\n"
msgstr "(#1=(a) b #1#)\n"

#. type: Plain text
#: objects.texi.orig:1677
msgid "This differs from ordinary syntax such as this"
msgstr "これは、以下のような通常の構文とは異なります"

#. type: example
#: objects.texi.orig:1680
#, no-wrap
msgid "((a) b (a))\n"
msgstr "((a) b (a))\n"

#. type: Plain text
#: objects.texi.orig:1685
msgid ""
"which would result in a list whose first and third elements look alike but "
"are not the same Lisp object.  This shows the difference:"
msgstr "これは1番目の要素と3番目の要素がそっくりなリストですが、これらは同じLispオブジェクトではありません。以下で違いを見ることができます:"

#. type: example
#: objects.texi.orig:1694
#, no-wrap
msgid ""
"(prog1 nil\n"
"  (setq x '(#1=(a) b #1#)))\n"
"(eq (nth 0 x) (nth 2 x))\n"
"     @result{} t\n"
"(setq x '((a) b (a)))\n"
"(eq (nth 0 x) (nth 2 x))\n"
"     @result{} nil\n"
msgstr ""
"(prog1 nil\n"
"  (setq x '(#1=(a) b #1#)))\n"
"(eq (nth 0 x) (nth 2 x))\n"
"     @result{} t\n"
"(setq x '((a) b (a)))\n"
"(eq (nth 0 x) (nth 2 x))\n"
"     @result{} nil\n"

#. type: Plain text
#: objects.texi.orig:1698
msgid ""
"You can also use the same syntax to make a circular structure, which appears "
"as an ``element'' within itself.  Here is an example:"
msgstr "``要素''として自身を含むような、循環する構造を作成するために、同じ構文を使用できます。以下は例です:"

#. type: example
#: objects.texi.orig:1701
#, no-wrap
msgid "#1=(a #1#)\n"
msgstr "#1=(a #1#)\n"

#. type: Plain text
#: objects.texi.orig:1706
msgid ""
"This makes a list whose second element is the list itself.  Here's how you "
"can see that it really works:"
msgstr "これは、2番目の要素がそのリスト自身であるリストを作成します。これが実際にうまくいくのか、以下で確認できます:"

#. type: example
#: objects.texi.orig:1712
#, no-wrap
msgid ""
"(prog1 nil\n"
"  (setq x '#1=(a #1#)))\n"
"(eq x (cadr x))\n"
"     @result{} t\n"
msgstr ""
"(prog1 nil\n"
"  (setq x '#1=(a #1#)))\n"
"(eq x (cadr x))\n"
"     @result{} t\n"

#. type: Plain text
#: objects.texi.orig:1717
msgid ""
"The Lisp printer can produce this syntax to record circular and shared "
"structure in a Lisp object, if you bind the variable @code{print-circle} to "
"a non-@code{nil} value.  @xref{Output Variables}."
msgstr "変数@code{print-circle}を非@code{nil}値にバインドした場合、Lispプリンターは、循環および共有されるLispオブジェクトを記録するこの構文を、生成することができます。@ref{Output Variables}を参照してください。"

#. type: cindex
#: objects.texi.orig:1720
#, no-wrap
msgid "type checking"
msgstr "type checking"

#. type: kindex
#: objects.texi.orig:1721
#, no-wrap
msgid "wrong-type-argument"
msgstr "wrong-type-argument"

#. type: Plain text
#: objects.texi.orig:1729
msgid ""
"The Emacs Lisp interpreter itself does not perform type checking on the "
"actual arguments passed to functions when they are called.  It could not do "
"so, since function arguments in Lisp do not have declared data types, as "
"they do in other programming languages.  It is therefore up to the "
"individual function to test whether each actual argument belongs to a type "
"that the function can use."
msgstr "Emacs Lispインタープリター自身は、関数が呼び出されたときに、その関数に渡された実際の引数にたいする型チェックは行ないません。それが行なえないのは、Lispにおける関数の引数は、他のプログラミング言語のようなデータ型宣言をもたないからです。したがって実際の引数が、その関数が使用できる型に属するかどうかをテストするのは、それぞれの関数に任されています。"

#. type: Plain text
#: objects.texi.orig:1734
msgid ""
"All built-in functions do check the types of their actual arguments when "
"appropriate, and signal a @code{wrong-type-argument} error if an argument is "
"of the wrong type.  For example, here is what happens if you pass an "
"argument to @code{+} that it cannot handle:"
msgstr "すべてのビルトイン関数は、適切なときに実際の引数の型チェックを行い、引数の型が違う場合は、@code{wrong-type-argument}エラーをシグナルします。たとえば以下は、@code{+}の引数に、@code{+}が扱うことができない引数を渡したとき何が起こるかの例です:"

#. type: group
#: objects.texi.orig:1739
#, no-wrap
msgid ""
"(+ 2 'a)\n"
"     @error{} Wrong type argument: number-or-marker-p, a\n"
msgstr ""
"(+ 2 'a)\n"
"     @error{} Wrong type argument: number-or-marker-p, a\n"

#. type: cindex
#: objects.texi.orig:1742
#, no-wrap
msgid "type predicates"
msgstr "type predicates"

#. type: cindex
#: objects.texi.orig:1743
#, no-wrap
msgid "testing types"
msgstr "testing types"

#. type: Plain text
#: objects.texi.orig:1749
msgid ""
"If you want your program to handle different types differently, you must do "
"explicit type checking.  The most common way to check the type of an object "
"is to call a @dfn{type predicate} function.  Emacs has a type predicate for "
"each type, as well as some predicates for combinations of types."
msgstr "異なる型にたいして異なる処理をプログラムに行なわせる場合は、明示的に型チェックを行なわなければなりません。オブジェクトの型をチェックするもっとも一般的な方法は、@dfn{型述語(type predicate)}関数の呼び出しです。Emacsはそれぞれの型にたいする型述語をもち、組み合わされた型にたいする述語もあります。"

#. type: Plain text
#: objects.texi.orig:1754
msgid ""
"A type predicate function takes one argument; it returns @code{t} if the "
"argument belongs to the appropriate type, and @code{nil} otherwise.  "
"Following a general Lisp convention for predicate functions, most type "
"predicates' names end with @samp{p}."
msgstr "型述語関数は1つの引数をとり、その引数が適切な型であれば@code{t}、そうでない場合は@code{nil}をreturnします。述語関数にたいする一般的なLisp慣習にしたがい、ほとんどの型述語の名前は、@samp{p}で終わります。"

#. type: Plain text
#: objects.texi.orig:1757
msgid ""
"Here is an example which uses the predicates @code{listp} to check for a "
"list and @code{symbolp} to check for a symbol."
msgstr "以下はリストにたいしてチェックを行なう述語@code{listp}と、シンボルにたいしてチェックを行なう述語@code{symbolp}の例です。"

#. type: example
#: objects.texi.orig:1769
#, no-wrap
msgid ""
"(defun add-on (x)\n"
"  (cond ((symbolp x)\n"
"         ;; If X is a symbol, put it on LIST.\n"
"         (setq list (cons x list)))\n"
"        ((listp x)\n"
"         ;; If X is a list, add its elements to LIST.\n"
"         (setq list (append x list)))\n"
"        (t\n"
"         ;; We handle only symbols and lists.\n"
"         (error \"Invalid argument %s in add-on\" x))))\n"
msgstr ""
"(defun add-on (x)\n"
"  (cond ((symbolp x)\n"
"         ;; If X is a symbol, put it on LIST.\n"
"         (setq list (cons x list)))\n"
"        ((listp x)\n"
"         ;; If X is a list, add its elements to LIST.\n"
"         (setq list (append x list)))\n"
"        (t\n"
"         ;; We handle only symbols and lists.\n"
"         (error \"Invalid argument %s in add-on\" x))))\n"

#. type: Plain text
#: objects.texi.orig:1773
msgid ""
"Here is a table of predefined type predicates, in alphabetical order, with "
"references to further information."
msgstr "以下の表は、事前定義された型述語(アルファベット順)と、さらに情報を得るためのリファレンスです。"

#. type: item
#: objects.texi.orig:1775
#, no-wrap
msgid "atom"
msgstr "atom"

#. type: table
#: objects.texi.orig:1777
msgid "@xref{List-related Predicates, atom}."
msgstr "@ref{List-related Predicates, atom}を参照してください。"

#. type: item
#: objects.texi.orig:1778
#, no-wrap
msgid "arrayp"
msgstr "arrayp"

#. type: table
#: objects.texi.orig:1780
msgid "@xref{Array Functions, arrayp}."
msgstr "@ref{Array Functions, arrayp}を参照してください。"

#. type: item
#: objects.texi.orig:1781
#, no-wrap
msgid "bool-vector-p"
msgstr "bool-vector-p"

#. type: table
#: objects.texi.orig:1783
msgid "@xref{Bool-Vectors, bool-vector-p}."
msgstr "@ref{Bool-Vectors, bool-vector-p}を参照してください。"

#. type: item
#: objects.texi.orig:1784
#, no-wrap
msgid "bufferp"
msgstr "bufferp"

#. type: table
#: objects.texi.orig:1786
msgid "@xref{Buffer Basics, bufferp}."
msgstr "@ref{Buffer Basics, bufferp}を参照してください。"

#. type: item
#: objects.texi.orig:1787
#, no-wrap
msgid "byte-code-function-p"
msgstr "byte-code-function-p"

#. type: table
#: objects.texi.orig:1789
msgid "@xref{Byte-Code Type, byte-code-function-p}."
msgstr "@ref{Byte-Code Type, byte-code-function-p}を参照してください。"

#. type: item
#: objects.texi.orig:1790
#, no-wrap
msgid "case-table-p"
msgstr "case-table-p"

#. type: table
#: objects.texi.orig:1792
msgid "@xref{Case Tables, case-table-p}."
msgstr "@ref{Case Tables, case-table-p}を参照してください。"

#. type: item
#: objects.texi.orig:1793
#, no-wrap
msgid "char-or-string-p"
msgstr "char-or-string-p"

#. type: table
#: objects.texi.orig:1795
msgid "@xref{Predicates for Strings, char-or-string-p}."
msgstr "@ref{Predicates for Strings, char-or-string-p}を参照してください。"

#. type: item
#: objects.texi.orig:1796
#, no-wrap
msgid "char-table-p"
msgstr "char-table-p"

#. type: table
#: objects.texi.orig:1798
msgid "@xref{Char-Tables, char-table-p}."
msgstr "@ref{Char-Tables, char-table-p}を参照してください。"

#. type: item
#: objects.texi.orig:1799
#, no-wrap
msgid "commandp"
msgstr "commandp"

#. type: table
#: objects.texi.orig:1801
msgid "@xref{Interactive Call, commandp}."
msgstr "@ref{Interactive Call, commandp}を参照してください。"

#. type: item
#: objects.texi.orig:1802
#, no-wrap
msgid "consp"
msgstr "consp"

#. type: table
#: objects.texi.orig:1804
msgid "@xref{List-related Predicates, consp}."
msgstr "@ref{List-related Predicates, consp}を参照してください。"

#. type: item
#: objects.texi.orig:1805
#, no-wrap
msgid "custom-variable-p"
msgstr "custom-variable-p"

#. type: table
#: objects.texi.orig:1807
msgid "@xref{Variable Definitions, custom-variable-p}."
msgstr "@ref{Variable Definitions, custom-variable-p}を参照してください。"

#. type: item
#: objects.texi.orig:1808
#, no-wrap
msgid "display-table-p"
msgstr "display-table-p"

#. type: table
#: objects.texi.orig:1810
msgid "@xref{Display Tables, display-table-p}."
msgstr "@ref{Display Tables, display-table-p}を参照してください。"

#. type: item
#: objects.texi.orig:1811
#, no-wrap
msgid "floatp"
msgstr "floatp"

#. type: table
#: objects.texi.orig:1813
msgid "@xref{Predicates on Numbers, floatp}."
msgstr "@ref{Predicates on Numbers, floatp}を参照してください。"

#. type: item
#: objects.texi.orig:1814
#, no-wrap
msgid "fontp"
msgstr "fontp"

#. type: table
#: objects.texi.orig:1816
msgid "@xref{Low-Level Font}."
msgstr "@ref{Low-Level Font}を参照してください。"

#. type: item
#: objects.texi.orig:1817
#, no-wrap
msgid "frame-configuration-p"
msgstr "frame-configuration-p"

#. type: table
#: objects.texi.orig:1819
msgid "@xref{Frame Configurations, frame-configuration-p}."
msgstr "@ref{Frame Configurations, frame-configuration-p}を参照してください。"

#. type: item
#: objects.texi.orig:1820
#, no-wrap
msgid "frame-live-p"
msgstr "frame-live-p"

#. type: table
#: objects.texi.orig:1822
msgid "@xref{Deleting Frames, frame-live-p}."
msgstr "@ref{Deleting Frames, frame-live-p}を参照してください。"

#. type: item
#: objects.texi.orig:1823
#, no-wrap
msgid "framep"
msgstr "framep"

#. type: table
#: objects.texi.orig:1825
msgid "@xref{Frames, framep}."
msgstr "@ref{Frames, framep}を参照してください。"

#. type: item
#: objects.texi.orig:1826
#, no-wrap
msgid "functionp"
msgstr "functionp"

#. type: table
#: objects.texi.orig:1828
msgid "@xref{Functions, functionp}."
msgstr "@ref{Functions, functionp}を参照してください。"

#. type: item
#: objects.texi.orig:1829
#, no-wrap
msgid "hash-table-p"
msgstr "hash-table-p"

#. type: table
#: objects.texi.orig:1831
msgid "@xref{Other Hash, hash-table-p}."
msgstr "@ref{Other Hash, hash-table-p}を参照してください。"

#. type: item
#: objects.texi.orig:1832
#, no-wrap
msgid "integer-or-marker-p"
msgstr "integer-or-marker-p"

#. type: table
#: objects.texi.orig:1834
msgid "@xref{Predicates on Markers, integer-or-marker-p}."
msgstr "@ref{Predicates on Markers, integer-or-marker-p}を参照してください。"

#. type: item
#: objects.texi.orig:1835
#, no-wrap
msgid "integerp"
msgstr "integerp"

#. type: table
#: objects.texi.orig:1837
msgid "@xref{Predicates on Numbers, integerp}."
msgstr "@ref{Predicates on Numbers, integerp}を参照してください。"

#. type: item
#: objects.texi.orig:1838
#, no-wrap
msgid "keymapp"
msgstr "keymapp"

#. type: table
#: objects.texi.orig:1840
msgid "@xref{Creating Keymaps, keymapp}."
msgstr "@ref{Creating Keymaps, keymapp}を参照してください。"

#. type: item
#: objects.texi.orig:1841
#, no-wrap
msgid "keywordp"
msgstr "keywordp"

#. type: table
#: objects.texi.orig:1843
msgid "@xref{Constant Variables}."
msgstr "@ref{Constant Variables}を参照してください。"

#. type: item
#: objects.texi.orig:1844
#, no-wrap
msgid "listp"
msgstr "listp"

#. type: table
#: objects.texi.orig:1846
msgid "@xref{List-related Predicates, listp}."
msgstr "@ref{List-related Predicates, listp}を参照してください。"

#. type: item
#: objects.texi.orig:1847
#, no-wrap
msgid "markerp"
msgstr "markerp"

#. type: table
#: objects.texi.orig:1849
msgid "@xref{Predicates on Markers, markerp}."
msgstr "@ref{Predicates on Markers, markerp}を参照してください。"

#. type: item
#: objects.texi.orig:1850
#, no-wrap
msgid "wholenump"
msgstr "wholenump"

#. type: table
#: objects.texi.orig:1852
msgid "@xref{Predicates on Numbers, wholenump}."
msgstr "@ref{Predicates on Numbers, wholenump}を参照してください。"

#. type: item
#: objects.texi.orig:1853
#, no-wrap
msgid "nlistp"
msgstr "nlistp"

#. type: table
#: objects.texi.orig:1855
msgid "@xref{List-related Predicates, nlistp}."
msgstr "@ref{List-related Predicates, nlistp}を参照してください。"

#. type: item
#: objects.texi.orig:1856
#, no-wrap
msgid "numberp"
msgstr "numberp"

#. type: table
#: objects.texi.orig:1858
msgid "@xref{Predicates on Numbers, numberp}."
msgstr "@ref{Predicates on Numbers, numberp}を参照してください。"

#. type: item
#: objects.texi.orig:1859
#, no-wrap
msgid "number-or-marker-p"
msgstr "number-or-marker-p"

#. type: table
#: objects.texi.orig:1861
msgid "@xref{Predicates on Markers, number-or-marker-p}."
msgstr "@ref{Predicates on Markers, number-or-marker-p}を参照してください。"

#. type: item
#: objects.texi.orig:1862
#, no-wrap
msgid "overlayp"
msgstr "overlayp"

#. type: table
#: objects.texi.orig:1864
msgid "@xref{Overlays, overlayp}."
msgstr "@ref{Overlays, overlayp}を参照してください。"

#. type: item
#: objects.texi.orig:1865
#, no-wrap
msgid "processp"
msgstr "processp"

#. type: table
#: objects.texi.orig:1867
msgid "@xref{Processes, processp}."
msgstr "@ref{Processes, processp}を参照してください。"

#. type: item
#: objects.texi.orig:1868
#, no-wrap
msgid "sequencep"
msgstr "sequencep"

#. type: table
#: objects.texi.orig:1870
msgid "@xref{Sequence Functions, sequencep}."
msgstr "@ref{Sequence Functions, sequencep}を参照してください。"

#. type: item
#: objects.texi.orig:1871
#, no-wrap
msgid "stringp"
msgstr "stringp"

#. type: table
#: objects.texi.orig:1873
msgid "@xref{Predicates for Strings, stringp}."
msgstr "@ref{Predicates for Strings, stringp}を参照してください。"

#. type: item
#: objects.texi.orig:1874
#, no-wrap
msgid "subrp"
msgstr "subrp"

#. type: table
#: objects.texi.orig:1876
msgid "@xref{Function Cells, subrp}."
msgstr "@ref{Function Cells, subrp}を参照してください。"

#. type: item
#: objects.texi.orig:1877
#, no-wrap
msgid "symbolp"
msgstr "symbolp"

#. type: table
#: objects.texi.orig:1879
msgid "@xref{Symbols, symbolp}."
msgstr "@ref{Symbols, symbolp}を参照してください。"

#. type: item
#: objects.texi.orig:1880
#, no-wrap
msgid "syntax-table-p"
msgstr "syntax-table-p"

#. type: table
#: objects.texi.orig:1882
msgid "@xref{Syntax Tables, syntax-table-p}."
msgstr "@ref{Syntax Tables, syntax-table-p}を参照してください。"

#. type: item
#: objects.texi.orig:1883
#, no-wrap
msgid "vectorp"
msgstr "vectorp"

#. type: table
#: objects.texi.orig:1885
msgid "@xref{Vectors, vectorp}."
msgstr "@ref{Vectors, vectorp}を参照してください。"

#. type: item
#: objects.texi.orig:1886
#, no-wrap
msgid "window-configuration-p"
msgstr "window-configuration-p"

#. type: table
#: objects.texi.orig:1888
msgid "@xref{Window Configurations, window-configuration-p}."
msgstr "@ref{Window Configurations, window-configuration-p}を参照してください。"

#. type: item
#: objects.texi.orig:1889
#, no-wrap
msgid "window-live-p"
msgstr "window-live-p"

#. type: table
#: objects.texi.orig:1891
msgid "@xref{Deleting Windows, window-live-p}."
msgstr "@ref{Deleting Windows, window-live-p}を参照してください。"

#. type: item
#: objects.texi.orig:1892
#, no-wrap
msgid "windowp"
msgstr "windowp"

#. type: table
#: objects.texi.orig:1894
msgid "@xref{Basic Windows, windowp}."
msgstr "@ref{Basic Windows, windowp}を参照してください。"

#. type: item
#: objects.texi.orig:1895
#, no-wrap
msgid "booleanp"
msgstr "booleanp"

#. type: table
#: objects.texi.orig:1897
msgid "@xref{nil and t, booleanp}."
msgstr "@ref{nil and t, booleanp}を参照してください。"

#. type: item
#: objects.texi.orig:1898
#, no-wrap
msgid "string-or-null-p"
msgstr "string-or-null-p"

#. type: table
#: objects.texi.orig:1900
msgid "@xref{Predicates for Strings, string-or-null-p}."
msgstr "@ref{Predicates for Strings, string-or-null-p}を参照してください。"

#. type: Plain text
#: objects.texi.orig:1908
msgid ""
"The most general way to check the type of an object is to call the function "
"@code{type-of}.  Recall that each object belongs to one and only one "
"primitive type; @code{type-of} tells you which one (@pxref{Lisp Data "
"Types}).  But @code{type-of} knows nothing about non-primitive types.  In "
"most cases, it is more convenient to use type predicates than "
"@code{type-of}."
msgstr "あるオブジェクトがどの型かチェックするもっとも一般的な方法は、関数@code{type-of}の呼び出しです。オブジェクトは、ただ1つだけの基本型に属することを思い出してください。@code{type-of}は、それがどの型(@ref{Lisp Data Types}を参照してください)か告げます。しかし@code{type-of}は基本型以外の型については何も知りません。ほとんどの場合、@code{type-of}より型述語を使用するほうが便利でしょう。"

#. type: defun
#: objects.texi.orig:1909
#, no-wrap
msgid "type-of object"
msgstr "type-of object"

#. type: defun
#: objects.texi.orig:1918
msgid ""
"This function returns a symbol naming the primitive type of @var{object}.  "
"The value is one of the symbols @code{bool-vector}, @code{buffer}, "
"@code{char-table}, @code{compiled-function}, @code{cons}, @code{float}, "
"@code{font-entity}, @code{font-object}, @code{font-spec}, @code{frame}, "
"@code{hash-table}, @code{integer}, @code{marker}, @code{overlay}, "
"@code{process}, @code{string}, @code{subr}, @code{symbol}, @code{vector}, "
"@code{window}, or @code{window-configuration}."
msgstr "この関数は@var{object}の基本型を名前とする、シンボルをreturnします。retuen値はシンボル@code{bool-vector}、@code{buffer}、@code{char-table}、@code{compiled-function}、@code{cons}、@code{float}、@code{font-entity}、@code{font-object}、@code{font-spec}、@code{frame}、@code{hash-table}、@code{integer}、@code{marker}、@code{overlay}、@code{process}、@code{string}、@code{subr}、@code{symbol}、@code{vector}、@code{window}、@code{window-configuration}のうちの1つです。"

#. type: example
#: objects.texi.orig:1922
#, no-wrap
msgid ""
"(type-of 1)\n"
"     @result{} integer\n"
msgstr ""
"(type-of 1)\n"
"     @result{} integer\n"

#. type: group
#: objects.texi.orig:1929
#, no-wrap
msgid ""
"(type-of 'nil)\n"
"     @result{} symbol\n"
"(type-of '())    ; @r{@code{()} is @code{nil}.}\n"
"     @result{} symbol\n"
"(type-of '(x))\n"
"     @result{} cons\n"
msgstr ""
"(type-of 'nil)\n"
"     @result{} symbol\n"
"(type-of '())    ; @r{@code{()}は@code{nil}です。}\n"
"     @result{} symbol\n"
"(type-of '(x))\n"
"     @result{} cons\n"

#. type: cindex
#: objects.texi.orig:1935
#, no-wrap
msgid "equality"
msgstr "equality"

#. type: Plain text
#: objects.texi.orig:1941
msgid ""
"Here we describe functions that test for equality between two objects.  "
"Other functions test equality of contents between objects of specific types, "
"e.g., strings.  For these predicates, see the appropriate chapter describing "
"the data type."
msgstr "ここでは、2つのオブジェクトの同一性をテストする関数を説明します。(たとえば文字列などの)特定の型のオブジェクト同士で、内容の同一性をテストするのは、別の関数を使用します。これらの述語にたいしては、そのデータ型を説明する、適切なチャプターを参照してください。"

#. type: defun
#: objects.texi.orig:1942
#, no-wrap
msgid "eq object1 object2"
msgstr "eq object1 object2"

#. type: defun
#: objects.texi.orig:1945
msgid ""
"This function returns @code{t} if @var{object1} and @var{object2} are the "
"same object, and @code{nil} otherwise."
msgstr "この関数は@var{object1}と@var{object2}が同じオブジェクトの場合は@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: objects.texi.orig:1955
msgid ""
"If @var{object1} and @var{object2} are integers with the same value, they "
"are considered to be the same object (i.e., @code{eq} returns @code{t}).  If "
"@var{object1} and @var{object2} are symbols with the same name, they are "
"normally the same object---but see @ref{Creating Symbols} for exceptions.  "
"For other types (e.g., lists, vectors, strings), two arguments with the same "
"contents or elements are not necessarily @code{eq} to each other: they are "
"@code{eq} only if they are the same object, meaning that a change in the "
"contents of one will be reflected by the same change in the contents of the "
"other."
msgstr "@var{object1}と@var{object2}が、同じ値をもつ整数の場合、これらは同じオブジェクトと判断されます(@code{eq}は@code{t}をreturnします)。@var{object1}と@var{object2}が、同じ名前のシンボルの場合、通常は同じオブジェクトです。しかし例外もあります。@ref{Creating Symbols}を参照してください。(リスト、ベクター文字列などの)他の型にたいしては、同じ内容(または要素)の2つの引数が、両者@code{eq}である必要はありません。これらが同じオブジェクトの場合だけ@code{eq}であり、その場合は、一方の内容を変更すると、もう一方の内容にも同じ変更が反映されます。"

#. type: group
#: objects.texi.orig:1960
#, no-wrap
msgid ""
"(eq 'foo 'foo)\n"
"     @result{} t\n"
msgstr ""
"(eq 'foo 'foo)\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:1965
#, no-wrap
msgid ""
"(eq 456 456)\n"
"     @result{} t\n"
msgstr ""
"(eq 456 456)\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:1970 objects.texi.orig:2044
#, no-wrap
msgid ""
"(eq \"asdf\" \"asdf\")\n"
"     @result{} nil\n"
msgstr ""
"(eq \"asdf\" \"asdf\")\n"
"     @result{} nil\n"

#. type: group
#: objects.texi.orig:1977
#, no-wrap
msgid ""
"(eq \"\" \"\")\n"
"     @result{} t\n"
";; @r{This exception occurs because Emacs Lisp}\n"
";; @r{makes just one multibyte empty string, to save space.}\n"
msgstr ""
"(eq \"\" \"\")\n"
"     @result{} t\n"
";; @r{この例外は省スペースのためにEmacs Lispが}\n"
";; @r{ただ1つのマルチバイトの空文字列を作成するためです。}\n"

#. type: group
#: objects.texi.orig:1982 objects.texi.orig:2053
#, no-wrap
msgid ""
"(eq '(1 (2 (3))) '(1 (2 (3))))\n"
"     @result{} nil\n"
msgstr ""
"(eq '(1 (2 (3))) '(1 (2 (3))))\n"
"     @result{} nil\n"

#. type: group
#: objects.texi.orig:1991
#, no-wrap
msgid ""
"(setq foo '(1 (2 (3))))\n"
"     @result{} (1 (2 (3)))\n"
"(eq foo foo)\n"
"     @result{} t\n"
"(eq foo '(1 (2 (3))))\n"
"     @result{} nil\n"
msgstr ""
"(setq foo '(1 (2 (3))))\n"
"     @result{} (1 (2 (3)))\n"
"(eq foo foo)\n"
"     @result{} t\n"
"(eq foo '(1 (2 (3))))\n"
"     @result{} nil\n"

#. type: group
#: objects.texi.orig:1996 objects.texi.orig:2062
#, no-wrap
msgid ""
"(eq [(1 2) 3] [(1 2) 3])\n"
"     @result{} nil\n"
msgstr ""
"(eq [(1 2) 3] [(1 2) 3])\n"
"     @result{} nil\n"

#. type: group
#: objects.texi.orig:2001 objects.texi.orig:2072
#, no-wrap
msgid ""
"(eq (point-marker) (point-marker))\n"
"     @result{} nil\n"
msgstr ""
"(eq (point-marker) (point-marker))\n"
"     @result{} nil\n"

#. type: defun
#: objects.texi.orig:2009
msgid ""
"The @code{make-symbol} function returns an uninterned symbol, distinct from "
"the symbol that is used if you write the name in a Lisp expression.  "
"Distinct symbols with the same name are not @code{eq}.  @xref{Creating "
"Symbols}."
msgstr "@code{make-symbol}関数は、internされていないシンボルをreturnします。これはLisp式内で、その名前を記述したシンボルとは区別されます。同じ名前の、異なるシンボルは、@code{eq}ではありません。@ref{Creating Symbols}を参照してください。"

#. type: group
#: objects.texi.orig:2014
#, no-wrap
msgid ""
"(eq (make-symbol \"foo\") 'foo)\n"
"     @result{} nil\n"
msgstr ""
"(eq (make-symbol \"foo\") 'foo)\n"
"     @result{} nil\n"

#. type: defun
#: objects.texi.orig:2018
#, no-wrap
msgid "equal object1 object2"
msgstr "equal object1 object2"

#. type: defun
#: objects.texi.orig:2025
msgid ""
"This function returns @code{t} if @var{object1} and @var{object2} have equal "
"components, and @code{nil} otherwise.  Whereas @code{eq} tests if its "
"arguments are the same object, @code{equal} looks inside nonidentical "
"arguments to see if their elements or contents are the same.  So, if two "
"objects are @code{eq}, they are @code{equal}, but the converse is not always "
"true."
msgstr "この関数は、@var{object1}と@var{object2}が同じ構成要素をもつ場合は@code{t}、それ以外は@code{nil}をreturnします。@code{eq}は引数が同じオブジェクトなのかテストするのにたいして、@code{equal}は同一でない引数の内部を調べて、それらの要素または内容が同一化をテストします。したがって2つのオブジェクトが@code{eq}ならば、それらは@code{equal}です。しかし、その逆は常に真ではありません。"

#. type: group
#: objects.texi.orig:2030
#, no-wrap
msgid ""
"(equal 'foo 'foo)\n"
"     @result{} t\n"
msgstr ""
"(equal 'foo 'foo)\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2035
#, no-wrap
msgid ""
"(equal 456 456)\n"
"     @result{} t\n"
msgstr ""
"(equal 456 456)\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2040
#, no-wrap
msgid ""
"(equal \"asdf\" \"asdf\")\n"
"     @result{} t\n"
msgstr ""
"(equal \"asdf\" \"asdf\")\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2049
#, no-wrap
msgid ""
"(equal '(1 (2 (3))) '(1 (2 (3))))\n"
"     @result{} t\n"
msgstr ""
"(equal '(1 (2 (3))) '(1 (2 (3))))\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2058
#, no-wrap
msgid ""
"(equal [(1 2) 3] [(1 2) 3])\n"
"     @result{} t\n"
msgstr ""
"(equal [(1 2) 3] [(1 2) 3])\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2067
#, no-wrap
msgid ""
"(equal (point-marker) (point-marker))\n"
"     @result{} t\n"
msgstr ""
"(equal (point-marker) (point-marker))\n"
"     @result{} t\n"

#. type: defun
#: objects.texi.orig:2083
msgid ""
"Comparison of strings is case-sensitive, but does not take account of text "
"properties---it compares only the characters in the strings.  @xref{Text "
"Properties}.  Use @code{equal-including-properties} to also compare text "
"properties.  For technical reasons, a unibyte string and a multibyte string "
"are @code{equal} if and only if they contain the same sequence of character "
"codes and all these codes are either in the range 0 through 127 "
"(@acronym{ASCII}) or 160 through 255 (@code{eight-bit-graphic}).  "
"(@pxref{Text Representations})."
msgstr "文字列の比較は大文字小文字を区別しますが、テキストプロパティーは考慮しません --- これは文字列内の文字だけを比較します。@ref{Text Properties}を参照してください。テキストプロパティーも比較する場合は、@code{equal-including-properties}を使用します。記述的な理由により、ユニバイト文字列とマルチバイト文字列は、それらが同じ文字シーケンスを含み、それらすべてのコードが0から127(@acronym{ASCII})、または160から255(@code{8ビットグラフィック})の場合に限り、@code{equal}です(@ref{Text Representations}を参照してください)。"

#. type: group
#: objects.texi.orig:2088
#, no-wrap
msgid ""
"(equal \"asdf\" \"ASDF\")\n"
"     @result{} nil\n"
msgstr ""
"(equal \"asdf\" \"ASDF\")\n"
"     @result{} nil\n"

#. type: defun
#: objects.texi.orig:2093
msgid ""
"However, two distinct buffers are never considered @code{equal}, even if "
"their textual contents are the same."
msgstr "しかし2つの別のバッファーは、それらのテキスト内容が同じでも、@code{equal}と判断されることはありません。"

#. type: Plain text
#: objects.texi.orig:2099
msgid ""
"The test for equality is implemented recursively; for example, given two "
"cons cells @var{x} and @var{y}, @code{(equal @var{x} @var{y})} returns "
"@code{t} if and only if both the expressions below return @code{t}:"
msgstr "@code{equal}のテストは再帰により実装されています。たとえば2つのコンスセル@var{x}と@var{y}を与えると、@code{(equal @var{x} @var{y})}は、以下の式の両方が@code{t}をreturnする場合に限り、@code{t}をreturnします:"

#. type: example
#: objects.texi.orig:2103
#, no-wrap
msgid ""
"(equal (car @var{x}) (car @var{y}))\n"
"(equal (cdr @var{x}) (cdr @var{y}))\n"
msgstr ""
"(equal (car @var{x}) (car @var{y}))\n"
"(equal (cdr @var{x}) (cdr @var{y}))\n"

#. type: Plain text
#: objects.texi.orig:2107
msgid ""
"Because of this recursive method, circular lists may therefore cause "
"infinite recursion (leading to an error)."
msgstr "これは再帰処理なので、循環するリストがあると無限再帰となります(エラーとなります)。"

#. type: defun
#: objects.texi.orig:2108
#, no-wrap
msgid "equal-including-properties object1 object2"
msgstr "equal-including-properties object1 object2"

#. type: defun
#: objects.texi.orig:2111
msgid ""
"This function behaves like @code{equal} in all cases but also requires that "
"for two strings to be equal, they have the same text properties."
msgstr "この関数はすべてのケースにおいて@code{equal}と同様に振る舞いますが、2つの文字列が@code{equal}になるためには、それらが同じテキストプロパティーをもつ必要があります。"

#. type: group
#: objects.texi.orig:2116
#, no-wrap
msgid ""
"(equal \"asdf\" (propertize \"asdf\" 'asdf t))\n"
"     @result{} t\n"
msgstr ""
"(equal \"asdf\" (propertize \"asdf\" 'asdf t))\n"
"     @result{} t\n"

#. type: group
#: objects.texi.orig:2121
#, no-wrap
msgid ""
"(equal-including-properties \"asdf\"\n"
"                            (propertize \"asdf\" 'asdf t))\n"
"     @result{} nil\n"
msgstr ""
"(equal-including-properties \"asdf\"\n"
"                            (propertize \"asdf\" 'asdf t))\n"
"     @result{} nil\n"
