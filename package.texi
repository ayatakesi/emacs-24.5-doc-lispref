@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 2010-2015 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Packaging
@chapter Preparing Lisp code for distribution
@cindex package
@cindex Lisp package

  Emacsは、Emacs
Lispコードをユーザーに配布するための、標準的な方法を提供します。@dfn{パッケージ(package)}は、ユーザーが簡単にダウンロード、インストール、アンインストール、および更新できるような方法でフォーマットおよび同梱された、1つ以上のファイルのコレクションです。

  以降のセクションではパッケージを作成する方法、およびそれを他の人がダウンロードできるように、@dfn{パッケージアーカイブ(package
archive)}に配置する方法を説明します。パッケージングシステムのユーザーレベル機能の説明は、@ref{Packages,,, emacs, The
GNU Emacs Manual}を参照してください。

@menu
* Packaging Basics::         Emacs Lispパッケージの基本的概念。
* Simple Packages::          単一.elファイルをパッケージする方法。
* Multi-file Packages::      ▼複数ファイルをパッケージする方法。
* Package Archives::         パッケージアーカイブの保守。
@end menu

@node Packaging Basics
@section Packaging Basics
@cindex package attributes
@cindex package name
@cindex package version
@cindex dependencies
@cindex package dependencies

  パッケージは@dfn{シンプルパケージ(simple package)}か@dfn{複数ファイルパッケージ(multi-file
package)}のいずれかです。シンプルパッケージは単一のEmacs
Lispファイル内に格納される一方、複数ファイルパッケージはtarファイル(複数のLispファイルとマニュアルのような非Lispファイルが含まれる可能性がある)に格納されます。

  通常の使い方では、シンプルパッケージと複数ファイルパッケージとの違いは、比較的重要ではありません。Package
Menuインターフェースでは、それらの間に差異はありません。しかし以降のセクションで説明するように、それらを作成する手順は異なります。

  パッケージ(シンプルか複数ファイル)はそれぞれ、特定の@dfn{属性(attributes)}をもっています:

@table @asis
@item Name
短い単語(たとえば@samp{auctex})。これは通常、そのプログラム内でシンボルプレフィクスとしても仕様される(@ref{Coding
Conventions}を参照)。

@item Version
関数@code{version-to-list}が理解できる形式のバージョン番号(たとえば@samp{11.86})。パッケージの各リリースでは、バージョン番号のアップも行うこと。

@item Brief description
そのパッケージがPackage Menuにリストされる際に、これが表示される。理想的には36文字以内で、単一行を占めるべきである。

@item Long description
これは@kbd{C-h
P}(@code{describe-package})により作成されたバッファーに表示され、これの後にそのパッケージの簡単な説明(brief
description)とインストール状態(installation
status)が続く。通常これは複数行に渡り、そのパッケージの能力と、インストール後に使用を開始するための方法を完全に記述すること。

@item Dependencies
そのパッケージが依存する、他のパッケージ(恐らく最低のバージョン番号を含む)。このリストは空でもよく、その場合パッケージには依存パッケージがないことを意味する。それ以外なら、このパッケージをインストールすることにより、その依存パッケージも自動的にインストールされる。依存パッケージのいずれかが見つからなければ、そのパッケージをインストールすることはできない。
@end table

@cindex content directory, package
  コマンド@code{package-install-file}、またはPackage
Menuのいずれかを介したパッケージのインストールでは、@code{package-user-dir}に@file{@var{name}-@var{version}}という名前のサブディレクトリーが作成される。ここで@var{name}はパッケージ名、@var{version}はバージョン番号である(たとえば@file{~/.emacs.d/elpa/auctex-11.86/})。わたしたちはこれを、そのパッケージの@dfn{コンテンツディレクトリー(content
directory)}と呼んでいます。これは、Emacsがパッケージのコンテンツ(シンプルパッケージでは単一のLispファイル、または複数ファイルパッケージから抽出されたファイル)を配置する場所です。

@cindex package autoloads
  その後Emacsは、autoloadマジックコメント(@ref{Autoload}を参照)にたいして、このコンテンツディレクトリー内のすべてのLispファイルを検索します。これらのautoload定義は、コンテンツディレクトリーの@file{@var{name}-autoloads.el}という名前のファイルに保存されます。これらは通常、そのパッケージ内で定義された主要なユーザーコマンドのautoloadに使用されますが、@code{auto-mode-alist}への要素の追加(@ref{Auto
Major
Mode}を参照)等、別のタスクを行うこともできます。パッケージは通常、その中で定義された関数と変数のすべてをautoload@emph{しない}ことに注意してください
---
通常はそのパッケージの使用を開始するために呼び出される一握りのコマンドだけがautoloadされます。それから、Emacsはそのパッケージ内のすべてのLispファイルをバイトコンパイルします。

  インストール後、インストールされたパッケージは@dfn{ロード済み(loaded)}になります。Emacsは@code{load-path}にコンテンツディレクトリーを追加して、@file{@var{name}-autoloads.el}内のautoload定義を評価します。

  Emacsのスタートアップ時は常に、インストール済みパッケージをロードするために、自動的に関数@code{package-initialize}が呼び出されます。これはinitファイルと、(もしあれば)abbrevファイルのロード後、かつ@code{after-init-hook}の実行前に行われます(@ref{Startup
Summary}を参照)。ユーザーオプション@code{package-enable-at-startup}が@code{nil}なら、自動的なパッケージのロードは無効です。

@deffn Command package-initialize &optional no-activate
この関数は、インストール済みパッケージとそれらがロード済みかを記録する、Emacsの内部レコードを初期化する。ユーザーオプション@code{package-load-list}は、どのパッケージをロードするかを指定する。デフォルトでは、すべてのインストール済みパッケージがロードされる。@ref{Package
Installation,,, emacs, The GNU Emacs Manual}を参照のこと。

オプション引数@var{no-activate}が非@code{nil}なら、インストール済みパッケージを実際にロードせずに、このレコードを更新する。これは内部でのみ使用される。
@end deffn

@node Simple Packages
@section Simple Packages
@cindex single file package
@cindex simple package

  シンプルパッケージは単一のEmacs Lispソースファイルで構成されます。このファイルは、Emacs
Lispライブラリーのヘッダー規約に準拠していなればなりません(@ref{Library
Headers}を参照)。以下の例に示すように、そのパッケージの属性は種々のヘッダーから取得されます:

@example
@group
;;; superfrobnicator.el --- Frobnicate and bifurcate flanges

;; Copyright (C) 2011 Free Software Foundation, Inc.
@end group

;; Author: J. R. Hacker <jrh@@example.com>
;; Version: 1.3
;; Package-Requires: ((flange "1.0"))
;; Keywords: multimedia, frobnicate
;; URL: http://example.com/jrhacker/superfrobnicate

@dots{}

;;; Commentary:

;; This package provides a minor mode to frobnicate and/or
;; bifurcate any flanges you desire.  To activate it, just type
@dots{}

;;;###autoload
(define-minor-mode superfrobnicator-mode
@dots{}
@end example

  そのパッケージの名前は1行目のファイル名の拡張子を除いた部分と同じです。ここでは、それは@samp{superfrobnicator}です。

  brief description(簡単な説明)も1行目から取得されます。ここでは、それは@samp{Frobnicate and bifurcate
flanges}(訳注:
@samp{flangeをフロブニケートして二股化する}のフロブニケートとは、ある技術にたいする無目的で非生産的な具体的行為を意味する)です。

  バージョン番号は、もしあれば@samp{Package-Version}ヘッダー、それ以外は@samp{Version}ヘッダーから取得されます。これらのヘッダーのいずれかが、@emph{提供されていなればなりません}。ここのバージョン番号は1.3です。

  そのファイルに@samp{;;; Commentary:}セクションがあれば、そのセクションは長い説明(long
description)として使用されます。(その説明を表示する際、Emacsは@samp{;;;
Commentary:}の行と、コメント内のコメント文字列を省力する。)

  そのファイルに@samp{Package-Requires}ヘッダーがあれば、それはパッケージの依存関係(package
dependencies)として使用されます。上の例では、パッケージはバージョン1.0以上の@samp{flange}パッケージに依存します。@samp{Package-Requires}ヘッダーの説明は、@ref{Library
Headers}を参照してください。このヘッダーが省略された場合、そのパッケージに依存関係はありません。

  ヘッダー@samp{Keywords}と@samp{URL}はオプションですが、含めることを推奨します。コマンド@code{describe-package}は、出力にリンクを追加するためにこれらを使用します。@samp{Keywords}ヘッダーには、@code{finder-known-keywords}リストからの標準的キーワードを少なくとも1つ含めるべきです。

  ファイルには@ref{Packaging
Basics}で説明したように、1つ以上のautoloadマジックコメントも含めるべきです。上の例では、マジックコメントにより@code{superfrobnicator-mode}が自動ロードされます。

  パッケージアーカイブに単一ファイルのパッケージを追加する方法は、@ref{Package Archives}を参照してください。

@node Multi-file Packages
@section Multi-file Packages
@cindex multi-file package

  複数ファイルパッケージは、単一ファイルパッケージより作成の手軽さが少し劣りますが、より多くの機能を提供します。複数ファイルパッケージには複数のEmacs
Lispファイル、Infoマニュアル、および(イメージのような)他のファイルタイプを含めることができます。

  インストールに先立ち、複数パッケージはファイルとしてパッケージアーカイブに含まれます。このtarファイルは@file{@var{name}-@var{version}.tar}という名前でなければなりません。ここで@var{name}はパッケージ名、@var{version}はバージョン番号です。tarのコンテンツは一度解凍されたなら、@dfn{コンテンツディレクトリcontent
directory)}である@file{@var{name}-@var{version}}という名前のディレクトリーにすべて解凍されなければなりません(@ref{Packaging
Basics}を参照)。このコンテンツディレクトリーのサブディレクトリーにも、ファイルが抽出されるかもしれません。

  このコンテンツディレクトリー内のファイルのうち1つは、@file{@var{name}-pkg.el}という名前のファイルでなければなりません。このファイルには、以下で説明する関数@code{define-package}の呼び出しから構成される、単一のLispフォームを含まなければなりません。これは、そのパッケージのバージョン、簡単な説明(brief
description)、必要条件(requirements)を定義します。

  たとえば、複数ファイルパッケージとしてsuperfrobnicatorのバージョン1.3を配布する場合、tarファイルは@file{superfrobnicator-1.3.tar}になります。これのコンテンツは@file{superfrobnicator-1.3}に解凍され、そのうちの1つはファイル@file{superfrobnicator-pkg.el}になるでしょう。

@defun define-package name version &optional docstring requirements
この関数はパッケージを定義する。@var{name}は、そのパッケージの名前(文字列)、@var{version}は関数@code{version-to-list}が理解できる形式のバージョン(文字列)@var{docstring}は簡単な説明(brief
description)。

@var{requirements}は、必要となるパッケージとそれらのバージョン番号。このリスト内の各要素は@code{(@var{dep-name}
@var{dep-version})}という形式であること。ここで@var{dep-name}はその依存するパッケージ名が名前であるようなシンボル、@var{dep-version}は依存するパッケージのバージョン番号(文字列)である。
@end defun

  コンテンツディレクトリーに@file{README}という名前のファイルがあれば、それは長い説明(long description)として使用されます。

  コンテンツディレクトリーに@file{dir}という名前のファイルがあれば、@command{install-info}で作成されるInfoディレクトリーファイル名と▽みなされます。@ref{Invoking
install-info, Invoking install-info, Invoking install-info, texinfo,
Texinfo}を参照してください。関係のあるInfoファイルも、このコンテンツディレクトリー内に解凍される必要があります。この場合、そのパッケージがアクティブ化されたとき、Emacsは自動的に@code{Info-directory-list}にコンテンツディレクトリーを追加します。

  パッケージ内に、@file{.elc}ファイルを含めないでください。これらは、そのパッケージのインストール時に作成されます。ファイルがバイトコンパイルされる順序を制御する方法は存在しないことに注意してください。

  @file{@var{name}-autoloads.el}という名前のファイルを含めてはなりません。このファイルは、そのパッケージのautoload定義のために予約済みです(@ref{Packaging
Basics}を参照)。これはパッケージのインストール時に、そのパッケージ内のすべてのLispファイルからautoloadマジックコメントを検索する際、自動的に作成されます。

  複数パッケージファイルが、(イメージのような)補助的なデータファイルを含む場合、パッケージ内のLispファイルは変数@code{load-file-name}を通じて、それらのファイルを参照できます(@ref{Loading}を参照)。以下は例です:

@smallexample
(defconst superfrobnicator-base (file-name-directory load-file-name))

(defun superfrobnicator-fetch-image (file)
  (expand-file-name file superfrobnicator-base))
@end smallexample

@node Package Archives
@section Creating and Maintaining Package Archives
@cindex package archive

  Via the Package Menu, users may download packages from @dfn{package
archives}.  Such archives are specified by the variable
@code{package-archives}, whose default value contains a single entry: the
archive hosted by the GNU project at @url{http://elpa.gnu.org}.  This
section describes how to set up and maintain a package archive.

@cindex base location, package archive
@defopt package-archives
The value of this variable is an alist of package archives recognized by the
Emacs package manager.

Each alist element corresponds to one archive, and should have the form
@code{(@var{id} . @var{location})}, where @var{id} is the name of the
archive (a string) and @var{location} is its @dfn{base location} (a string).

If the base location starts with @samp{http:}, it is treated as a HTTP URL,
and packages are downloaded from this archive via HTTP (as is the case for
the default GNU archive).

Otherwise, the base location should be a directory name.  In this case,
Emacs retrieves packages from this archive via ordinary file access.  Such
``local'' archives are mainly useful for testing.
@end defopt

  A package archive is simply a directory in which the package files, and
associated files, are stored.  If you want the archive to be reachable via
HTTP, this directory must be accessible to a web server.  How to accomplish
this is beyond the scope of this manual.

  A convenient way to set up and update a package archive is via the
@code{package-x} library.  This is included with Emacs, but not loaded by
default; type @kbd{M-x load-library @key{RET} package-x @key{RET}} to load
it, or add @code{(require 'package-x)} to your init file.  @xref{Lisp
Libraries,, Lisp Libraries, emacs, The GNU Emacs Manual}.  Once loaded, you
can make use of the following:

@defopt package-archive-upload-base
The value of this variable is the base location of a package archive, as a
directory name.  The commands in the @code{package-x} library will use this
base location.

The directory name should be absolute.  You may specify a remote name, such
as @file{/ssh:foo@@example.com:/var/www/packages/}, if the package archive
is on a different machine.  @xref{Remote Files,, Remote Files, emacs, The
GNU Emacs Manual}.
@end defopt

@deffn Command package-upload-file filename
This command prompts for @var{filename}, a file name, and uploads that file
to @code{package-archive-upload-base}.  The file must be either a simple
package (a @file{.el} file) or a multi-file package (a @file{.tar} file);
otherwise, an error is raised.  The package attributes are automatically
extracted, and the archive's contents list is updated with this information.

If @code{package-archive-upload-base} does not specify a valid directory,
the function prompts interactively for one.  If the directory does not
exist, it is created.  The directory need not have any initial contents
(i.e., you can use this command to populate an initially empty archive).
@end deffn

@deffn Command package-upload-buffer
This command is similar to @code{package-upload-file}, but instead of
prompting for a package file, it uploads the contents of the current
buffer.  The current buffer must be visiting a simple package (a @file{.el}
file) or a multi-file package (a @file{.tar} file); otherwise, an error is
raised.
@end deffn

@noindent
After you create an archive, remember that it is not accessible in the
Package Menu interface unless it is in @code{package-archives}.

@cindex package archive security
@cindex package signing
Maintaining a public package archive entails a degree of responsibility.
When Emacs users install packages from your archive, those packages can
cause Emacs to run arbitrary code with the permissions of the installing
user.  (This is true for Emacs code in general, not just for packages.)  So
you should ensure that your archive is well-maintained and keep the hosting
system secure.

  One way to increase the security of your packages is to @dfn{sign} them
using a cryptographic key.  If you have generated a private/public gpg key
pair, you can use gpg to sign the package like this:

@c FIXME EasyPG / package-x way to do this.
@example
gpg -ba -o @var{file}.sig @var{file}
@end example

@noindent
For a single-file package, @var{file} is the package Lisp file; for a
multi-file package, it is the package tar file.  You can also sign the
archive's contents file in the same way.  Make the @file{.sig} files
available in the same location as the packages.  You should also make your
public key available for people to download; e.g., by uploading it to a key
server such as @url{http://pgp.mit.edu/}.  When people install packages from
your archive, they can use your public key to verify the signatures.

A full explanation of these matters is outside the scope of this manual.
For more information on cryptographic keys and signing, @pxref{Top,, GnuPG,
gnupg, The GNU Privacy Guard Manual}.  Emacs comes with an interface to GNU
Privacy Guard, @pxref{Top,, EasyPG, epa, Emacs EasyPG Assistant Manual}.
