@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Processes
@chapter Processes
@cindex child process
@cindex parent process
@cindex subprocess
@cindex process

  オペレーティングシステムの用語では、@dfn{プロセス(process)}とはプログラムを実行できるスペースのことです。Emacsはプロセス内で実行されます。Emacs
Lispプログラムは、別のプログラムをそれら自身のプロセス内で呼び出すことができます。これらは、@dfn{親プロセス(parent
process)}であるEmacsプロセスの@dfn{サブプロセス(subprocesses)}、または@dfn{子プロセス(child
processes)}と呼ばれます。

  Emacsのサブプロセスは@dfn{同期(synchronous)}、または@dfn{非同期(asynchronous)}であり、それはそれらが作成された方法に依存します。同期サブプロセスを作成した際、Lispプログラムは実行を継続する前に、そのサブプロセスの終了を待機します。非同期サブプロセスを作成したときは、それをLispプログラムと並行して実行できます。この種のサブプロセスは、EmacsではLispオブジェクととして表現され、そのオブジェクトも``プロセス''と呼ばれています。Lispプログラムはサブプロセスとのやり取りや、サブプロセスの制御のために、このオブジェクトを使用できます。たとえばシグナル送信、ステータス情報の取得、プロセス出力の受信や、プロセスへ入力を送信することができます。

@defun processp object
この関数は、@var{object}がEmacsのサブプロセスを表すなら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

  カレントEmacsセッションのサブプロセスに加えて、そのマシン上で実行中の他のプロセスにアクセスすることもできます。@ref{System
Processes}を参照してください。

@menu
* Subprocess Creation::      サブプロセスを開始する関数。
* Shell Arguments::          shellに渡すために引数をクォートする。
* Synchronous Processes::    同期サブプロセス使用の詳細。
* Asynchronous Processes::   非同期サブプロセスの起動。
* Deleting Processes::       非同期サブプロセスの削除。
* Process Information::      実行状態および他の属性へのアクセス。
* Input to Processes::       非同期サブプロセスへの入力の送信。
* Signals to Processes::     非同期サブプロセスの停止、継続、割り込み。
* Output from Processes::    非同期サブプロセスからの出力の収集。
* Sentinels::                プロセスの実行状態変更時に実行されるセンチネル。
* Query Before Exit::        exitによりプロセスがkillされる場合に問い合わせるかどうか。
* System Processes::         そのシステム上で実行中の別プロセスへのアクセス。
* Transaction Queues::       サブプロセスとのトランザクションベースのコミュニケション。
* Network::                  ネットワーク接続のopen。
* Network Servers::          Emacsによるネット接続のacceptを可能にするネットワークサーバー。
* Datagrams::                UDPネットワーク接続。
* Low-Level Network::        接続およびサーバーを作成するための、より低レベルだがより汎用的な関数。
* Misc Network::             ネット接続用の追加の関連関数。
* Serial Ports::             シリアルポートでのやり取り。
* Byte Packing::             bindatを使用したバイナリーデータのpackとunpack。
@end menu

@node Subprocess Creation
@section Functions that Create Subprocesses
@cindex create subprocess
@cindex process creation

  内部でプログラムを実行するサブプロセスを作成するために、3つのプリミティブが存在します。1つは@code{start-process}で、これは非同期プロセスを作成して、プロセスオブジェクトをリターンします(@ref{Asynchronous
Processes}を参照)。他の2つは@code{call-process}と@code{call-process-region}で、これらは同期プロセスを作成して、プロセスオブジェクとをリターンしません(@ref{Synchronous
Processes}を参照)。特定のタイプのプロセスを実行するために、これらのプリミティブを利用する、さまざまな高レベル関数が存在します。

  同期プロセスと非同期プロセスについては、以降のセクションで説明します。この3つの関数はすべて類似した様式で呼び出されるので、ここでそれらに共通の引数について説明します。

@cindex execute program
@cindex @env{PATH} environment variable
@cindex @env{HOME} environment variable
  すべての場合において、その関数の@var{program}引数は、実行するプログラムを指定します。ファイルが見つからなかったり、実行できない場合は、エラーがシグナルされます。ファイル名が相対的な場合、検索するディレクトリーのリストは、変数@code{exec-path}に格納されています。Emacsは起動時、環境変数@env{PATH}の値にもとづいて、@code{exec-path}を初期化します。@code{exec-path}内では、標準的なファイル名構成要素@samp{~}、@samp{.}、@samp{..}は通常どおり解釈されますが、環境変数の置換(@samp{$HOME}等)は認識されません。それらの置換を行うには、@code{substitute-in-file-name}を使用してください(@ref{File
Name Expansion}を参照)。このリスト内で@code{nil}は、@code{default-directory}を参照します。

  プログラムの実行では、指定された名前にサフィックスの追加を試みることもできます:

@defopt exec-suffixes
この変数は、指定されたプログラムファイル名への追加を試みるための、サフィックス(文字列)のリストである。指定されたとおりの名前を試みたいなら、このリストに@code{""}を含めること。デフォルト値はシステムに依存する。
@end defopt

  @strong{注意してください:}
引数@var{program}にはプログラム名だけが含まれ、コマンドライン引数を含めることはできない。これらを提供するために、以下で説明する別の引数@var{args}を使用しなければならない。

  サブプロセス作成関数にはそれぞれ、@var{buffer-or-name}引数があります。これはプログラムの標準出力の行き先を指定します。これはバッファーかバッファー名であるべきです。バッファー名なら、もしそのバッファーがまだ作成されていなければ、そのバッファーを作成します。@code{nil}を指定することもでき、その場合はカスタム製のフィルター関数が出力を処理するのでなければ、出力を破棄するよう指示します(@ref{Filter
Functions}、および@ref{Read and
Print}を参照のこと)。通常は、出力がランダムに混在してしまうため、同一バッファーに複数プロセスの出力を送信するのは避けるべきです。同期プロセスにたいしては、バッファーのかわりにファイルに出力を送信できます。

@cindex program arguments
  これら3つのサブプロセス作成関数はすべて、@code{&rest}引数である@var{args}をもっています。@var{args}はすべて文字列でなければならず、それらは個別のコマンドライン引数として、@var{program}に与えられます。これらの文字列は指定されたプログラムに直接渡されるので、文字列内ではワイルドカード文字やその他のshell構成要素は特別な意味をもちません。

@cindex environment variables, subprocesses
  サブプロセスはその環境をEmacsから継承しますが、@code{process-environment}でそれをオーバーラードするよう指定することができます。@ref{System
Environment}を参照してください。サブプロセスは自身のカレントディレクトリーを、@code{default-directory}の値から取得します。

@defvar exec-directory
@pindex movemail
この変数の値は、GNU
Emacsとともに配布され、Emacsにより呼び出されることを意図したプログラムを含むディレクトリーの名前(文字列)である。プログラム@code{movemail}はそのようなプログラムの例であり、Rmailはinboxから新しいメールを読み込むためにこのプログラムを使用する。
@end defvar

@defopt exec-path
この変数の値は、サブプロセス内で実行するためのプログラムを検索するための、ディレクトリーのリストである。要素はそれぞれ、ディレクトリーの名前(文字列)、または@code{nil}のいずれかである。@code{nil}はデフォルトディレクトリー(@code{default-directory}の値)を意味する。
@cindex program directories

@code{exec-path}の値は、@var{program}引数が絶対ファイル名でないとき、@code{call-process}および@code{start-process}により使用される。

一般的には、@code{exec-path}を直接変更するべきではない。かわりにEmacs起動前に、環境変数@env{PATH}が適切にセットされているか確認すること。@env{PATH}とは独立に@code{exec-path}の変更を試みると、混乱した結果へと導かれ得る。
@end defopt

@node Shell Arguments
@section Shell Arguments
@cindex arguments for shell commands
@cindex shell command arguments

  Lispプログラムがshellを実行して、ユーザーが指定したファイル名を含むコマンドを与える必要がある場合が時折あります。これらのプログラムは、任意の有効なファイル名をサポート可能であるはずです。しかしshellは特定の文字を特別に扱い、それらの文字がファイル名に含まれていると、shellを混乱させるでしょう。これらの文字を処理するためには、関数@code{shell-quote-argument}を使用します。

@defun shell-quote-argument argument
この関数は、実際のコンテンツが@var{argument}であるような引数を表す文字列を、shellの構文でリターンする。リターン値をshellコマンドに結合して、実行のためにそれをshellに渡すことにより、信頼性をもって機能するはずである。

この関数が正確に何を行うかは、オペレーティングシステムに依存する。この関数は、そのシステムの標準shellの構文で機能するようデザインされている。非標準のshellを使用する場合は、この関数を再定義する必要があるだろう。

@example
;; @r{この例はGNUおよびUnixシステムでの挙動を示す}
(shell-quote-argument "foo > bar")
     @result{} "foo\\ \\>\\ bar"

;; @r{この例はMS-DOSおよびMS-Windowsでの挙動を示す}
(shell-quote-argument "foo > bar")
     @result{} "\"foo > bar\""
@end example

以下は@code{shell-quote-argument}を使用して、shellコマンドを構築する例である:

@example
(concat "diff -c "
        (shell-quote-argument oldfile)
        " "
        (shell-quote-argument newfile))
@end example
@end defun

@cindex quoting and unquoting command-line arguments
@cindex minibuffer input, and command-line arguments
@cindex @code{call-process}, command-line arguments from minibuffer
@cindex @code{start-process}, command-line arguments from minibuffer
  以下の2つの関数は、コマンドライン引数の文字列のリストを単一の文字列に結合したり、単一の文字列を個別のコマンドライン引数のリストへ分割するために有用です。これらの関数は主に、ミニバッファーでのユーザー入力であるLisp文字列を@code{call-process}や@code{start-process}に渡す文字列引数のリストへ変換したり、そのような引数のリストをミニバッファーやエコーエリアに表示するためのLisp文字列に変換することを意図しています。

@defun split-string-and-unquote string &optional separators
この関数は@code{split-string}(@pxref{Creating
Strings}を参照)が行うように、正規表現@var{separators}にたいするマッチで、@var{string}を部分文字列に分割する。さらに加えて、その部分文字列からクォートを削除する。それから部分文字列のリストを作成して、それをリターンする。

@var{separators}が省略、または@code{nil}の場合のデフォルトは@code{"\\s-+"}で、これは空白文字構文(@ref{Syntax
Class Table}を参照)をもつ1つ以上の文字にマッチする正規表現である。

この関数は、2つのタイプのクォートをサポートする。1つは文字列全体をダブルクォートで囲う@code{"@dots{}"}のようなクォートで、もう1つはバックスラッシュ@samp{\}によるエスケープで文字を個別にクォートするタイプである。後者はLisp文字列内でも使用されるので、この関数はそれらも同様に扱うことができる。
@end defun

@defun combine-and-quote-strings list-of-strings &optional separator
この関数は、@var{list-of-strings}の各文字を必要に応じてクォートして、単一の文字列に結合する。これはさらに各文字ペアーの間に、@var{separator}文字列も挿入する。@var{separator}が省略または@code{nil}の場合のデフォルトは@code{"
"}。リターン値は、その結果の文字列である。

@var{list-of-strings}内のクォートを要する文字列には、部分文字列として@var{separator}を含むものが該当する。文字列のクォートは、それをダブルクォートで@code{"@dots{}"}のように囲う。もっとも単純な例では、個別のコマンドライン引数からコマンドをコンス(cons)する場合は、埋め込まれたブランクを含む文字列はそれぞれクォートされるだろう。
@end defun

@node Synchronous Processes
@section Creating a Synchronous Process
@cindex synchronous subprocess

  @dfn{同期プロセス(synchronous
process)}の作成後、Emacsは継続の前にそのプロセスが終了するのを待機します。GNUやUnix@footnote{他のシステムでは、Emacsは@code{ls}のLispエミュレーションを使用します。@ref{Contents
of
Directories}を参照してください。}でのDiredの起動が、この例です。プロセスは同期的なので、Emacsがそれにたいして何か行おうと試みる前に、ディレクトリーのリスト全体がバッファーに到着します。

  同期サブプロセス終了をEmacsが待機する間、ユーザーは@kbd{C-g}をタイプすることによりquitができます。最初のは@kbd{C-g}は@code{SIGINT}シグナルにより、サブプロセスのkillを試みます。しかしこれはquitする前に、実際にそのサブプロセスが終了されるまで待機します。その間にユーザーがさらに@kbd{C-g}をタイプすると、それは@code{SIGKILL}で即座にサブプロセスをkillしてquitします(別プロセスのkillが機能しないMS-DOSを除く)。@ref{Quitting}を参照してください。

  同期サブプロセス関数は、プロセスがどのように終了したかの識別をリターンします。

  同期サブプロセスからの出力は、ファイルからのテキスト読み込みと同じように、一般的にはコーディングシステムを使用してデコードされます。@code{call-process-region}によりサブプロセスに送信された入力は、ファイルへのテキスト書き込みと同じように、コーディングシステムを使用してエンコードされます。@ref{Coding
Systems}を参照してください。

@defun call-process program &optional infile destination display &rest args
この関数は@var{program}を呼び出して、それが完了するまで待機する。

サブプロセスのカレントワーキングディレクトリーは、@code{default-directory}である。

新たなプロセスの標準入力は、@var{infile}が非@code{nil}ならファイル@code{nil}から、それ以外ならnullデバイスからとなる。引数@var{destination}は、プロセスの出力をどこに送るかを指定する。以下は可能な値である:

@table @asis
@item バッファー
そのバッファーの、ポイントの前に出力を挿入する。これにはプロセスの、標準出力ストリームと標準エラーストリームの両方が含まれる。

@item 文字列
その名前のバッファーの、ポイントの前に出力を挿入する。

@item @code{t}
カレントバッファーの、ポイントの前に出力を挿入する。

@item @code{nil}
出力を破棄する。

@item 0
出力を破棄して、サブプロセス完了を待機することなく、即座に@code{nil}をリターンする。

この場合、プロセスはEmacsと並列に実行可能なので、真に同期的ではない。しかしこの関数リターン後は、本質的にはすみやかにEmacsがサブプロセスを終了するという点から、これを同期的と考えることができる。

MS-DOSは非同期サブプロセスをサポートせず、このオプションは機能しない。

@item @code{(:file @var{file-name})}
指定されたファイルに出力を送信し、ファイルが既に存在すれば上書きする。

@item @code{(@var{real-destination} @var{error-destination})}
標準出力ストリームを、標準エラーストリームと分けて保つ。通常の出力は@var{real-destination}の指定にしたがって扱い、エラー出力は@var{error-destination}にしたがって処分する。@var{error-destination}が@code{nil}ならエラー出力の破棄、@code{t}なら通常の出力と混合することを意味し、文字列ならそれはエラー出力をリダイレクトするファイルの名前である。

エラー出力先に直接バッファーを指定することはできない。ただしエラー出力を一時ファイルに送信して、そのファイルをバッファーに挿入すれば、これを達成できる。
@end table

@var{display}が非@code{nil}なら、@code{call-process}は出力の挿入にしたがって、バッファーを再表示する(しかし出力のデコードに選択されたコーディングシステムが、実データからエンコーディングを推論することを意味する@code{undecided}の場合は、非@acronym{ASCII}に一度遭遇すると再表示が継続不能になることがある。これを修正するのが困難な根本的理由が存在する。@ref{Output
from Processes}を参照されたい)。

それ以外なら関数@code{call-process}は再表示を行わず、通常のイベントに由来するEmacsの再表示時だけ、スクリーン上で結果が可視になります。

残りの引数@var{args}は、そのプログラムにたいしてコマンドライン引数を指定する文字列です。

(待機するよう告げた場合)@code{call-process}がリターンする値は、プロセスが終了した理由を示します。この数字は、そのサブプロセスのexitステータスで0が成功、それ以外のすべての値は失敗を意味します。シグナルによりそのプロセスが終了された場合、@code{call-process}はそれを記述する文字列をリターンします。

以下の例では、カレントバッファーは@samp{foo}です。

@smallexample
@group
(call-process "pwd" nil t)
     @result{} 0

---------- Buffer: foo ----------
/home/lewis/manual
---------- Buffer: foo ----------
@end group

@group
(call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
     @result{} 0

---------- Buffer: bar ----------
lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

---------- Buffer: bar ----------
@end group
@end smallexample

以下は@code{call-process}の使用法の例で、このような使用例は@code{insert-directory}関数の定義内で見ることができます:

@smallexample
@group
(call-process insert-directory-program nil t nil switches
              (if full-directory-p
                  (concat (file-name-as-directory file) ".")
                file))
@end group
@end smallexample
@end defun

@defun process-file program &optional infile buffer display &rest args
この関数は、別プロセス内でファイルを同期的に処理する。これは@code{call-process}と似ているが、サブプロセスのカレントワーキングディレクトリーを指定する、変数@code{default-directory}の値にもとづく、ファイルハンドラーを呼び出すかもしれない。

引数は@code{call-process}の場合とほとんど同様の方法で処理されるが、以下の違いがある:

引数@var{infile}、@var{buffer}、@var{display}の組み合わせと形式.をサポートしないファイルハンドラーがあるかもしれない。たとえば実際に渡された値とは無関係に、@var{display}が@code{nil}であるかのように振る舞うファイルハンドラーがいくつかある。他の例としては、@var{buffer}引数で標準出力とエラー出力を分離するのをサポートしないかもしれないファイルハンドラーがいくつか存在する。

ファイルハンドラーが呼び出されると、1つ目の引数@var{program}にもとづき、実行するプログラムを決定する。たとえばリモートファイルにたいするハンドラーが呼び出されたと考えてみよ。その.場合、プログラムの検索に使用されるパスは、@code{exec-path}とは異なるかもしれない。

2つ目の引数@var{infile}は、ファイルハンドラーを呼び出すかもしれない。そのファイルハンドラーは、@code{process-file}関数自身にたいして選択されたハンドラーと異なり得る(たとえば@code{default-directory}がリモートホスト上にあり、@var{infile}は別のリモートホスト上の場合があり得る。もしくは@code{default-directory}は普通だが、@var{infile}はリモートホスト上にあるかもしれない).

@var{buffer}が@code{(@var{real-destination}
@var{error-destination})}という形式のリストで、@var{error-destination}がファイルの名前なら、@var{infile}と同じ注意が適用される。

残りの引数(@var{args})は、そのままプロセスに渡される。Emacsは、@var{args}内で与えられたファイル名の処理に関与しない。混乱を避けるためには、@var{args}内で絶対ファイル名を使用しないのが最善であり、@code{default-directory}からの相対ファイル名ですべてのファイルを指定するほうがよいだろう。関数@code{file-relative-name}は、そのような相対ファイル名の構築に有用である。
@end defun

@defvar process-file-side-effects
この変数は、@code{process-file}呼び出しがリモートファイルを変更するかどうかを示す。

この変数はデフォルトでは常に、@code{process-file}呼び出しがリモートホスト上の、任意のファイルを潜在的に変更し得ることを意味する@code{t}にセットされる。@code{nil}にセットされた際は、リモートファイル属性のキャッシュにしたがうことにより、ファイルハンドラーの挙動を最適化できる可能性がある。

この変数は決して@code{setq}ではなく、常にletバインディングによってのみ変更されるべきである。
@end defvar

@defun call-process-region start end program &optional delete destination display &rest args
この関数は@var{start}から@var{end}のテキストを、実行中のプロセス@var{program}に、標準入力として送信する。これは@var{delete}が非@code{nil}なら、送信したテキストを削除する。これは出力をカレントバッファーの入力箇所に挿入するために、@var{destination}を@code{t}に指定している際に有用である。

引数@var{destination}と@var{display}は、サブロセスからの出力にたいして何を行うか、および出力の到着にともない表示を更新するかどうかを制御する。詳細は上述の、@code{call-process}の説明を参照されたい。@var{destination}が整数の0なら、@code{call-process-region}は出力を破棄して、サブプロセス完了を待機せずに、即座に@code{nil}をリターンする(これは非同期サブプロセスがサポートされる場合、つまりMS-DOS以外でのみ機能する)。

残りの引数@var{args}は、そのプログラムにたいしてコマンドライン引数を指定する文字列です。

@code{call-process-region}のリターン値は、@code{call-process}の場合と同じである。待機せずにリターンするよう指示した場合は@code{nil}、数字か文字列ならそれはサブプロセスが終了した方法を表す。

以下の例では、バッファー@samp{foo}内の最初の5文字(単語@samp{input})を標準入力として、@code{call-process-region}を使用して@code{cat}ユーティリティを実行する。@code{cat}は自身の標準入力を、標準出力へコピーする。引数@var{destination}が@code{t}なので、その出力はカレントバッファーに挿入される。

@smallexample
@group
---------- Buffer: foo ----------
input@point{}
---------- Buffer: foo ----------
@end group

@group
(call-process-region 1 6 "cat" nil t)
     @result{} 0

---------- Buffer: foo ----------
inputinput@point{}
---------- Buffer: foo ----------
@end group
@end smallexample

  たとえば@code{shell-command-on-region}コマンドは、以下のような方法で@code{call-process-region}を使用する:

@smallexample
@group
(call-process-region
 start end
 shell-file-name      ; @r{プログラム名}
 nil                  ; @r{リージョンを削除しない}
 buffer               ; @r{出力を@code{buffer}に送信}
 nil                  ; @r{出力中に再表示を行わない}
 "-c" command)        ; @r{shellへの引数}
@end group
@end smallexample
@c It actually uses shell-command-switch, but no need to mention that here.
@end defun

@defun call-process-shell-command command &optional infile destination display
この関数はshellコマンド@var{command}を、非同期に実行する。引数は@code{call-process}の場合と同様に処理される。古い呼び出し規約は、@var{display}の後に任意個数の追加引数を許容し、これは@var{command}に結合される。これはまだサポートされるものの、使用しないことを強く推奨する。
@end defun

@defun process-file-shell-command command &optional infile destination display
この関数は@code{call-process-shell-command}と同様だが、内部的に@code{process-file}を使用する点が異なる。@code{default-directory}に依存して、@var{command}はリモートホスト上でも実行可能である。古い呼び出し規約は、@var{display}の後に任意個数の追加引数を許容し、これは@var{command}に結合される。これはまだサポートされるものの、使用しないことを強く推奨する。
@end defun

@defun shell-command-to-string command
この関数はshellコマンドとして@var{command}(文字列)を実行して、そのコマンドの出力を文字列としてリターンする。
@end defun

@c There is also shell-command-on-region, but that is more of a user
@c command, not something to use in programs.

@defun process-lines program &rest args
この関数は@var{program}を実行して完了を待機し、出力を文字列のリストとしてリターンする。リスト内の各文字列は、プログラムのテキスト出力の1つの行を保持する。各行のEOL文字(行末文字)は取り除かれる。@var{program}の後の引数@var{args}は、そのプログラム実行に際し、コマンドライン引数を指定する文字列である。

@var{program}が非0のexitステータスでexitした場合、この関数はエラーをシグナルする。

この関数は@code{call-process}を呼び出すことにより機能し、プログラムの出力は@code{call-process}の場合と同じ方法でデコードされる。
@end defun

@node Asynchronous Processes
@section Creating an Asynchronous Process
@cindex asynchronous subprocess

  このセクションでは、@dfn{非同期プロセス(asynchronous
process)}を作成する方法について説明します。非同期プロセスは作成後、Emacsと並列して実行され、Emacsは以降のセクション(@ref{Input
to Processes}および@ref{Output from
Processes}を参照)で説明する関数を使用してプロセスとコミュニケーションができます。プロセスコミュニケーションは、部分的に非同期なだけであることに注意してください。Emacsは特定の関数を呼び出したときだけプロセスにデータを送信でき、Emacsは入力の待機中または一定の遅延時間の後にのみ、プロセスのデータを受け取ることができます。

@cindex pty
@cindex pipe
  非同期プロセスは@dfn{pty(pseudo-terminal:
疑似端末)}、または@dfn{pipe}の、いずれかを通じて制御されます。ptyかpipeの選択は、変数@code{process-connection-type}(以下参照)の値にもとづき、プロセス作成時に行われます。ptyは通常、Shellモード内のようにユーザーから可視なプロセスに適しています。それはpipeでは不可能な、そのプロセスおよびその子プロセスとの間でジョブ制御(@kbd{C-c}、@kbd{C-z}、...等)が可能だからです。プログラムの内部的な目的のために使用されるサブプロセスにたいしては、pipeのほうが適している場合が多々あります。それはpipeがより効率的であり、ptyが大量の文字(500byte前後)にたいして導入する迷入文字インジェクション(stray
character
injections)にたいして免疫があるのが理由です。さらに多くのしすてむではptyの合計数に制限があり、それを浪費するのは得策ではありません。

@defun start-process name buffer-or-name program &rest args
この関数は新たな非同期サブプロセスを作成して、その中でプログラム@var{program}の実行を開始する。これはLisp内で新たなサブプロセスを意味する、プロセスオブジェクトをリターンする。引数@var{name}は、そのプロセスオブジェクトにたいして、名前を指定する。その名前のプロセスがすでに存在する場合、(@samp{<1>}を追加することにより)一意になるよう、@var{name}を変更する。バッファー@var{buffer-or-name}は、そのプロセスに関連付けられたバッファーである。

@var{program}が@code{nil}なら、Emacsは疑似端末(pty)を新たにオープンして、サブプロセスを新たに作成することなく、ptyの入力と出力を@var{buffer-or-name}に関連付ける。この場合、残りの引数@var{args}は無視される。

残りの引数@var{args}は、サブプロセスにコマンドライン引数を指定する文字列である。

以下の例では、1つ目のプロセスが開始して、100秒間実行(というよりはsleep)される。その間に2つ目のプロセスが開始して、一意性を保つために@samp{my-process<1>}という名前が与えられる。これは1つ目のプロセスが終了する前に、バッファー@samp{foo}の最後にディレクトリーのリストを挿入する。その後、2つ目のプロセスは終了して、その旨のメッセージがバッファーに挿入される。さらに遅れて1つ目のプロセスが終了して、バッファーに別のメッセージが挿入される。

@smallexample
@group
(start-process "my-process" "foo" "sleep" "100")
     @result{} #<process my-process>
@end group

@group
(start-process "my-process" "foo" "ls" "-l" "/bin")
     @result{} #<process my-process<1>>

---------- Buffer: foo ----------
total 8336
-rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
-rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
@dots{}
-rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

Process my-process<1> finished

Process my-process finished
---------- Buffer: foo ----------
@end group
@end smallexample
@end defun

@defun start-file-process name buffer-or-name program &rest args
@code{start-process}と同様、この関数は非同期サブプロセスを開始して、その内部で@var{program}を実行して、そのプロセスオブジェクトをリターンする。

@code{start-process}との違いは、この関数が@code{default-directory}の値にもとづいて、ファイルハンドラーを呼び出すかもしれないという点である。このハンドラーはローカルホスト上、あるいは@code{default-directory}に応じたリモートホスト上で、@var{program}を実行するべきである。後者の場合、@code{default-directory}のローカル部分は、そのプロセスのワーキングディレクトリーになる。

この関数は@var{program}、または@var{program-args}にたいしてファイル名ハンドラーの呼び出しを試みない。

そのファイルハンドラーの実装によっては、リターン結果のプロセスオブジェクトに@code{process-filter}または@code{process-sentinel}を適用することができないかもしれない。@ref{Filter
Functions}および@ref{Sentinels}を参照されたい。

@c FIXME  Can we find a better example (i.e., a more modern function
@c that is actually documented).
いくつかのファイルハンドラーは@code{start-file-process}をサポートしないかもしれない(たとえば@code{ange-ftp-hook-function}関数)。そのような場合、この関数は何も行わずに@code{nil}をリターンする。
@end defun

@defun start-process-shell-command name buffer-or-name command
この関数は@code{start-process}と同様だが、指定されたコマンドの実行にshellを使用する点が異なる。引数@var{command}は、shellコマンド名である。変数@code{shell-file-name}は、どのshellを使用するかを指定する。

@code{start-process}でプログラムを実行せずにshellを通じて実行することの要点は、引数内のワイルドカード展開のようなshell機能を利用可能にするためである。そのためにはコマンド内に任意のユーザー指定引数を含めるなら、任意の特別なshell文字が、shellでの特別な意味を@emph{もたない}ように、まず@code{shell-quote-argument}でそれらをクォートするべきである。@ref{Shell
Arguments}を参照のこと。ユーザー入力にもとづいたコマンド実行時には、当然セキュリティ上の影響も考慮するべきである。
@end defun

@defun start-file-process-shell-command name buffer-or-name command
この関数は@code{start-process-shell-command}と似ているが、内部的に@code{start-file-process}を使用する点が異なる。これにより、@code{default-directory}に応じてリモートホスト上でも、@var{command}を実行できる。
@end defun

@defvar process-connection-type
この変数は、非同期サブプロセスと対話するために使用する、デバイスタイプを制御する。これが非@code{nil}の場合、利用可能ならpty、それ以外ならpipeが使用される。

@code{process-connection-type}の値は、@code{start-process}の呼び出し時に効果を発揮する。そのため、@code{start-process}の呼び出し前後でこの変数をバインドすることにより、サブプロセスとやり取りする方法を指定できる。

@smallexample
@group
(let ((process-connection-type nil))  ; @r{pipeを使用}
  (start-process @dots{}))
@end group
@end smallexample

与えられたサブプロセスが実際にはpipeとptyのどちらを取得したかを判断するには、関数@code{process-tty-name}を使用する(@ref{Process
Information}を参照)。
@end defvar

@node Deleting Processes
@section Deleting Processes
@cindex deleting processes

  @dfn{プロセス削除(deleting a
process)}とは、Emacsをサブプロセスから即座に切断することです。プロセスは終了後に自動的に削除されますが、即座に削除される必要はありません。任意のタイミングで、明示的にプロセスを削除できます。終了したプロセスが自動的に削除される前に明示的に削除しても、それに害はありません。実行中のプロセスの削除は、プロセス(もしあれば子プロセスにも)を終了するためにシグナルを送信して、プロセスセンチネルを呼び出します。@ref{Sentinels}を参照してください。

  プロセスが削除される際、そのプロセスオブジェクト自体は、それを参照する別のLispオブジェクトが存在する限り、継続し続けます。プロセスオブジェクトに作用するすべてのLispプリミティブはプロセスの削除を受け入れますが、I/Oを行ったりシグナルを送信するプリミティブは、エラーを報告するでしょう。プロセスマークは、通常はプロセスからの出力がバッファーに挿入される箇所である、以前と同じ箇所をポイントし続けます。

@defopt delete-exited-processes
この変数は、(@code{exit}呼び出しやシグナルにより)終了したプロセスの、自動的な削除を制御する。これが@code{nil}なら、ユーザーが@code{list-processes}を実行するまでプロセスは存在し続け、それ以外ならexit後に即座に削除される。
@end defopt

@defun delete-process process
この関数は、@code{SIGKILL}シグナルでkillすることにより、プロセスを削除する。引数はプロセス、プロセスの名前、バッファー、バッファーの名前かもしれない(バッファーやバッファー名の場合は、@code{get-buffer-process}がリターンするプロセスを意味する)。実行中のプロセスに@code{delete-process}を呼び出すことにより、プロセスを終了してプロセス状態を更新して、即座にセンチネルを実行する。そのプロセスがすでに終了している場合、@code{delete-process}呼び出しはプロセス状態、または(遅かれ早かれ発生するであろう)プロセスセンチネルの実行に影響を与えない。

@smallexample
@group
(delete-process "*shell*")
     @result{} nil
@end group
@end smallexample
@end defun

@node Process Information
@section Process Information
@cindex process information

  プロセスの状態に関する情報をリターンする関数がいくつかあり。

@deffn Command list-processes &optional query-only buffer
このコマンドは、すべての生きたプロセスのリストを表示する。加えてこれは最後に、状態が@samp{Exited}か@samp{Signaled}だったすべてのプロセスを削除する。このコマンドは@code{nil}をリターンする。

プロセスは、メジャーモードがProcess Menuモードであるような、@file{*Process
List*}という名前(オプション引数@var{buffer}で他の名前を指定していない場合)のバッファーに表示される。

@var{query-only}が非@code{nil}なら、queryフラグが非@code{nil}のプロセスだけをリストする。@ref{Query
Before Exit}を参照のこと。
@end deffn

@defun process-list
この関数は、削除されていないすべてのプロセスのリストをリターンする。

@smallexample
@group
(process-list)
     @result{} (#<process display-time> #<process shell>)
@end group
@end smallexample
@end defun

@defun get-process name
この関数は@var{name}(文字列)というプロセス、存在しなければ@code{nil}をリターンする。

@smallexample
@group
(get-process "shell")
     @result{} #<process shell>
@end group
@end smallexample
@end defun

@defun process-command process
この関数は、@var{process}を開始するために実行されたコマンドをリターンする。これは文字列のリストで、1つ目の文字列は実行されたプログラム、残りの文字列はそのプログラムに与えられた引数である。

@smallexample
@group
(process-command (get-process "shell"))
     @result{} ("bash" "-i")
@end group
@end smallexample
@end defun

@defun process-contact process &optional key

この関数は、ネットワークプロセスまたはシリアルプロセスがセットアップされた方法についての情報をリターンする。
This function returns information about how a network or serial process was
set up.
@var{key}が@code{nil}なら、ネットワークプロセスにたいしては@code{(@var{hostname}
@var{service})}、シリアルプロセスにたいしては@code{(@var{port}
@var{speed})}をリターンする。普通の子プロセスにたいしては、この関数は常に@code{t}をリターンする。

@var{key}が@code{t}なら、値はその接続、サーバー、またはシリアルポートについての完全な状態情報、すなわち@code{make-network-process}または@code{make-serial-process}内で指定されるキーワードと値のリストとなる。ただしいくつかの値については、指定した値のかわりに、カレント状態を表す値となる。

ネットワークプロセスにたいしては、その値が含まれる(完全なリストについては、@code{make-network-process}を参照されたい)。

@table @code
@item :buffer
値にはプロセスのバッファーが割り当てられる。
@item :filter
値にはプロセスのフィルター関数が割り当てられる。
@item :sentinel
値にはプロセスのセンチネル関数が割り当てられる。
@item :remote
接続にたいしては、内部的なフォーマットによる、リモートピアーのアドレス。
@item :local
内部的なフォーマットによる、ローカルアドレス。
@item :service
サーバーにおいては、@var{service}に@code{t}を指定した場合、この値は実際のポート番号。
@end table

@code{make-network-process}内で明示的に指定されていなくても、@code{:local}と@code{:remote}は値に含まれる。

シリアルプロセスについては@code{make-serial-process}、キーのリストについては@code{serial-process-configure}を参照されたい。

@var{key}がキーワードなら、この関数はそのキーワードに対応する値をリターンする。
@end defun

@defun process-id process
この関数は、@var{process}の@acronym{PID}をリターンする。これは同じコンピューター上でカレント時に実行中の他のすべてのプロセスから、プロセス@var{process}を区別するための整数である。プロセスの@acronym{PID}は、そのプロセスの開始時にオペレーティングシステムのカーネルにより選択され、そのプロセスが存在する限り定数として保たれる。
@end defun

@defun process-name process
この関数は@var{process}の名前を、文字列としてリターンする。
@end defun

@defun process-status process-name
この関数は@var{process-name}の状態を、文字列としてリターンする。引数@var{process-name}はプロセス、バッファー、またはプロセス名(文字列)かもしれない。

実際のサブプセスにたいして可能な値は:

@table @code
@item run
実行中のプロセス。
@item stop
停止しているが継続可能なプロセス。
@item exit
exitしたプロセス。
@item signal
致命的なシグナルを受信したプロセス。
@item open
オープンされたネットワーク接続。
@item closed
クローズされたネットワーク接続。一度クローズされた接続は、たとえ同じ場所にたいして新たな接続をオープンすることができたとしても、再度オープンすることはできない。
@item connect
完了を待つ非ブロッキング接続。
@item failed
完了に失敗した非ブロッキング接続。
@item listen
listen中のネットワークサーバー。
@item nil
@var{process-name}が既存のプロセス名でない場合。
@end table

@smallexample
@group
(process-status (get-buffer "*shell*"))
     @result{} run
@end group
@end smallexample

ネットワーク接続にたいしては、@code{process-status}は@code{open}か@code{closed}のシンボルいずれかをリターンする。後者は相手側が接続をクローズしたか、Emacsが@code{delete-process}を行なったことを意味する。
@end defun

@defun process-live-p process
この関数は、@var{process}がアクティブなら、非@code{nil}をリターンする。状態が@code{run}、@code{open}、@code{listen}、@code{connect}、@code{stop}のプロセスはアクティブとみなされる。
@end defun

@defun process-type process
この関数はネットワーク接続またはサーバーにたいしてはシンボル@code{network}、シリアルポート接続にたいしては@code{serial}、実際のサブプロセスにたいしては@code{real}をリターンする。
@end defun

@defun process-exit-status process
この関数は@var{process}のexitステータス、またはプロセスをkillしたシグナル番号をリターンする(いずれかであるかの判定には、@code{process-status}の結果を使用する)。@var{process}がまだ終了していなければ、値は0。
@end defun

@defun process-tty-name process
この関数は@var{process}がEmacsとの対話に使用する端末名、端末のかわりにpipeを使用する場合は@code{nil}をリターンする(@ref{Asynchronous
Processes}の@code{process-connection-type}を参照)。@var{process}がリモートホスト上で実行中のプログラムを表す場合は、プロセスの@code{remote-tty}プロパティとして、リモートホスト上でそのプログラムに使用される端末名が提供される。
@end defun

@defun process-coding-system process
@anchor{Coding systems for a subprocess}
この関数は、@var{process}からの出力のデコードに使用するコーディングシステム、@var{process}への入力のエンコードに使用するコーディングシステムを記述するコンスセル@code{(@var{decode}
. @var{encode})}をリターンする(@ref{Coding Systems}を参照)。
@end defun

@defun set-process-coding-system process &optional decoding-system encoding-system
この関数は、@var{process}にたいする後続の入出力に使用するコーディングシステムを指定する。これはサブプロセスの出力のデコードに@var{decoding-system}、入力のエンコードに@var{encoding-system}を使用するだろう。
@end defun

  すべてのプロセスには、そのプロセスに関連するさまざまな値を格納するために使用できる、プロパティリストもあります。

@defun process-get process propname
この関数は、@var{process}のプロパティ@var{propname}の値をリターンする。
@end defun

@defun process-put process propname value
この関数は、@var{process}のプロパティ@var{propname}の値に@var{value}をセットする。
@end defun

@defun process-plist process
この関数は、@var{process}のプロセスplistをリターンする。
@end defun

@defun set-process-plist process plist
この関数は、@var{process}のプロセスplistに@var{plist}をセットする。
@end defun

@node Input to Processes
@section Sending Input to Processes
@cindex process input

  非同期サブプロセスは、Emacsにより入力が送信されたときに入力を受信し、それはこのセクション内の関数で行われます。これを行うには入力を送信するプロセスと、送信するための入力データを指定しなければなりません。そのデータは、サブプロセスの``標準入力''として表れます。

@c FIXME which?
  オペレーティングシステムには、ptyのバッファーされた入力にたいして制限をもつものがいくつかあります。それらのシステムでは、Emacsは他の文字列の間に定期的かつ強制的に、@acronym{EOF}を送信します。ほとんどのプログラムにたいして、これらの@acronym{EOF}は無害です。

  サブプロセスの入力は通常、テキストをファイルに書き込むときと同じように、サブプロセスが受信する前に、コーディングシステムを使用してエンコードされます。どのコーディングシステムを使用するかを指定するには、@code{set-process-coding-system}を使用できます(@ref{Process
Information}を参照)。それ以外の場合、非@code{nil}なら@code{coding-system-for-write}がコーディングシステムとなり、さもなくばデフォルトのメカニズムがコーディングシステムを決定します(@ref{Default
Coding Systems}を参照)。

  入力バッファーが一杯のため、システムがプロセスからの入力を受け取ることができないことがあります。これが発生したときは、送信関数はしばらく待機して、サブプロセスの出力を受け取り、再度送信を試みます。これは保留となっている更なる入力を読み取り、バッファーに空きを作る機会をサブプロセスに与えます。これはフィルター、センチネル、タイマーの実行も可能にするので、コードを記述する際はそれを考慮してください。

  以下の関数では、@var{process}引数はプロセス、プロセス名、またはバッファー、バッファー名(これは@code{get-buffer-process}で取得されるプロセスを意味する)。@code{nil}は、カレントバッファーのプロセスを意味します。

@defun process-send-string process string
この関数は@var{string}のコンテンツを、標準入力として@var{process}に送信する。たとえばファイルをリストするShellバッファーを作成するには:

@smallexample
@group
(process-send-string "shell<1>" "ls\n")
     @result{} nil
@end group
@end smallexample
@end defun

@defun process-send-region process start end
この関数は@var{start}と@var{end}で定義されるリージョンのテキストを、標準入力として@var{process}に送信する。

@var{start}と@var{end}が、カレントバッファー内の位置を示す整数かマーカーでなければ、エラーがシグナルされる(いずれかの大小は重要ではない)。
@end defun

@defun process-send-eof &optional process
この関数は、@var{process}が入力内の@acronym{EOF}(end-of-file)を見ることを可能にする。@acronym{EOF}は、すべての送信済みテキストの後になる。この関数は@var{process}をリターンする。

@smallexample
@group
(process-send-eof "shell")
     @result{} "shell"
@end group
@end smallexample
@end defun

@defun process-running-child-p &optional process
この関数は、@var{process}が自身の子プロセスに端末の制御を与えたかどうかを告げるだろう。値@code{t}はそれが真であるか、あるいはEmacsがそれを告げることができないことを意味し、@code{nil}はなら偽であることをEmacsは保証します。
@end defun

@node Signals to Processes
@section Sending Signals to Processes
@cindex process signals
@cindex sending signals
@cindex signals

  サブプロセスへの@dfn{シグナル送信(sending a
signal)}は、プロセスの活動に割り込む手段の1つです。異なる複数のシグナルがあり、それぞれが独自の意味をもっています。シグナルのセットとそれらの意味は、オペレーティングシステムにより定義されます。たとえばシグナル@code{SIGINT}は、ユーザーが@kbd{C-c}をタイプしたか、それに類似する何かが発生したことを意味します。

  各シグナルは、サブプロセスに標準的な効果をもちます。ほとんどのシグナルはサブプロセスをkillしますが、かわりに実行を停止(あるいは再開)するものもいくつかあります。ほとんどのシグナルは、オプションでプログラムによりハンドル((処理)することができます。プログラムがそのシグナルをハンドルする場合、その影響についてわたしたちは一般的には何も言うことはできません。

  このセクション内の関数を呼び出すことにより、明示的にシグナルを送信できます。Emacsも、特定のタイミングで自動的にシグナルを送信します。バッファーのkillにより、それに関連するプロセスには@code{SIGHUP}シグナルが送信され、Emacsのkillにより、残されたすべてのプロセスに@code{SIGHUP}シグナルが送信されます(@code{SIGHUP}は通常、ユーザーが``hung
up the phone''、電話を切った、つまり接続を断ったことを示す)。

  シグナル送信関数はそれぞれ@var{process}と@var{current-group}いう、2つのオプション引数を受け取ります。

  引数@var{process}はプロセス、プロセス名、バッファー、バッファー名、または@code{nil}のいずれかでなければなりません。バッファーまたはバッファー名は、@code{get-buffer-process}を通じて得られるプロセスを意味します。@code{nil}は、カレントバッファーに関連付けられたプロセスを意味します。@var{process}がプロセスを識別しなければ、エラーがシグナルされます。

  引数@var{current-group}は、Emacsのサブプロセスとしてジョブ制御shell(job-control
shell)を実行中の場合に、異なる処理を行うためのフラグです。これが非@code{nil}なら、そのシグナルはEmacsがサブプロセスとの対話に使用する端末のカレントプロセスグループに送信されます。そのプロセスがジョブ制御shellなら、これはそのshellのカレントのsubジョブになります。@code{nil}なら、そのシグナルはEmacs自身のサブプロセスのプロセスグループに送信されます。そのプロセスがジョブ制御shellなら、それはshell自身になります。

  サブプロセスとの対話にpipeが使用されている際は、オペレーティングシステムがpipeでの区別をサポートしないので、フラグ@var{current-group}に効果はありません。同じ理由により、pipeが使用されている場合は、ジョブ制御shellは機能しないでしょう。@ref{Asynchronous
Processes}内の@code{process-connection-type}を参照してください。

@defun interrupt-process &optional process current-group
この関数は、シグナル@code{SIGINT}を送信することにより、プロセス@var{process}に割り込む。Emacs外部では、``interrupt
character''(割り込み文字。通常いくつかのシステムでは@kbd{C-c}、それ以外のシステムでは@key{DEL})をタイプすることにより、このシグナルが送信される。引数@var{current-group}が非@code{nil}のときは、Emacsがサブプロセスと対話する端末上で``@kbd{C-c}がタイプされた''と考えることができる。
@end defun

@defun kill-process &optional process current-group
この関数は、シグナル@code{SIGKILL}を送信することにより、プロセス@var{process}をkillする。このシグナルは即座にサブプロセスをkillして、サブプロセスでハンドルすることはできない。
@end defun

@defun quit-process &optional process current-group
@c FIXME?  Never heard of C-b being used for this.  In readline, e.g.,
@c bash, that is backward-word.
この関数は、プロセス@var{process}にシグナル@code{SIGQUIT}を送信する。これはEmacs外部では``quit
character''(通常は@kbd{C-b}か@kbd{C-\})により送信されるシグナルである。
@end defun

@defun stop-process &optional process current-group
この関数は、シグナル@code{SIGTSTP}を送信することにより、プロセス@var{process}を停止する。実行の再開には、@code{continue-process}を使用する。

ジョブ制御をもつシステム上のEmacs外部では、``stop
character''(通常は@kbd{C-z})がこのシグナルを送信する。@var{current-group}が非@code{nil}なら、この関数をサブプロセスとの対話にEmacsが使用する端末上で``@kbd{C-z}がタイプされた''と考えることができる。
@end defun

@defun continue-process &optional process current-group
この関数は、シグナル@code{SIGCONT}を送信することにより、プロセス@var{process}の実行を再開する。これは@var{process}が以前に停止されたものと推定する。
@end defun

@deffn Command signal-process process signal
この関数は、プロセス@var{process}にシグナルを送信する。引数@var{signal}は、どのシグナルを送信するかを指定する。これは整数、または名前がシグナルであるようなシンボルであること。

@var{process}引数にはシステムプロセス@acronym{ID}(整数)を指定できる。これによりEmacsの子プロセス以外のプロセスにシグナルを送信できる。@ref{System
Processes}を参照のこと。
@end deffn

@node Output from Processes
@section Receiving Output from Processes
@cindex process output
@cindex output from processes

  サブプロセスが自身の標準出力に書き込んだ出力は、@dfn{フィルター関数(filter
function)}と呼ばれる関数に渡されます。デフォルトのフィルター関数は単に出力をバッファーに挿入します。このバッファーを、そのプロセスに関連付けられたバッファーと呼びます(@ref{Process
Buffers}を参照)。プロセスがバッファーをもたなければ、デフォルトフィルターは出力を破棄します。

  サブプロセス終了時、Emacsは保留中の出力を読み取り、その後そのサブプロセスからの出力の読み取りを停止します。したがって、そのサブプロセスに生きた子プロセスがあり、まだ出力を生成するような場合、Emacsはその出力を受け取らないでしょう。

  サブプロセスからの出力は、Emacsが待機している間、端末入力読み取り時(関数@code{waiting-for-user-input-p}、@ref{Waiting}の@code{sit-for}と@code{sleep-for}、および@ref{Accepting
Output}の@code{accept-process-output}を参照されたい)のみ到着可能です。これは、並列プログラミングで普遍的に悩みの種である、タイミングエラーの問題を最小化します。たとえば、安全にプロセスを作成して、その後でのみプロセスのバッファーやフィルター関数を指定できます。その間にあるコードが待機するプリミティブを何も呼び出さなければ、完了するまで到着可能な出力はありません。

@defvar process-adaptive-read-buffering
いくつかのシステムでは、Emacsがサブプロセスの出力を読み取る際、出力データを非常に小さいブロックで読み取るため、結果として潜在的に非常に貧弱なパフォーマンスとなることがる。この挙動は、変数@code{process-adaptive-read-buffering}を非@code{nil}値(デフォルト)にセットして拡張することにより改善し得る。これにより、そのようなプロセスからの読み取りを自動的に遅延して、Emacsが読み取りを試みる前に、出力がより生成されるようになる。
@end defvar

  Emacsは通常、疑似端末(pseudo-TTY)内部でサブプロセスをspawnし、かつ疑似端末は出力チャンネルを1つしかもてないので、サブプロセスの標準出力ストリームと標準エラーストリームを区別するのは不可能です。それらのストリームの出力を区別して保ちたい場合は、たとえば適当なshellコマンドを使用して、いずれか1つをファイルにリダイレクトするべきです。

@menu
* Process Buffers::          デフォルトでは、出力はバッファーに送信される。
* Filter Functions::         フィルター関数はプロセスからの出力を受け取る。
* Decoding Output::          フィルターはユニバイトおよびマルチバイトの文字列を取得できる。
* Accepting Output::         プロセスの出力到着まで待機する方法。
@end menu

@node Process Buffers
@subsection Process Buffers

  A process can (and usually does) have an @dfn{associated buffer}, which is
an ordinary Emacs buffer that is used for two purposes: storing the output
from the process, and deciding when to kill the process.  You can also use
the buffer to identify a process to operate on, since in normal practice
only one process is associated with any given buffer.  Many applications of
processes also use the buffer for editing input to be sent to the process,
but this is not built into Emacs Lisp.

  By default, process output is inserted in the associated buffer.  (You can
change this by defining a custom filter function, @pxref{Filter Functions}.)
The position to insert the output is determined by the @code{process-mark},
which is then updated to point to the end of the text just inserted.
Usually, but not always, the @code{process-mark} is at the end of the
buffer.

@findex process-kill-buffer-query-function
  Killing the associated buffer of a process also kills the process.  Emacs
asks for confirmation first, if the process's
@code{process-query-on-exit-flag} is non-@code{nil} (@pxref{Query Before
Exit}).  This confirmation is done by the function
@code{process-kill-buffer-query-function}, which is run from
@code{kill-buffer-query-functions} (@pxref{Killing Buffers}).

@defun process-buffer process
This function returns the associated buffer of the process @var{process}.

@smallexample
@group
(process-buffer (get-process "shell"))
     @result{} #<buffer *shell*>
@end group
@end smallexample
@end defun

@defun process-mark process
This function returns the process marker for @var{process}, which is the
marker that says where to insert output from the process.

If @var{process} does not have a buffer, @code{process-mark} returns a
marker that points nowhere.

The default filter function uses this marker to decide where to insert
process output, and updates it to point after the inserted text.  That is
why successive batches of output are inserted consecutively.

Custom filter functions normally should use this marker in the same
fashion.  For an example of a filter function that uses @code{process-mark},
@pxref{Process Filter Example}.

When the user is expected to enter input in the process buffer for
transmission to the process, the process marker separates the new input from
previous output.
@end defun

@defun set-process-buffer process buffer
This function sets the buffer associated with @var{process} to
@var{buffer}.  If @var{buffer} is @code{nil}, the process becomes associated
with no buffer.
@end defun

@defun get-buffer-process buffer-or-name
This function returns a nondeleted process associated with the buffer
specified by @var{buffer-or-name}.  If there are several processes
associated with it, this function chooses one (currently, the one most
recently created, but don't count on that).  Deletion of a process (see
@code{delete-process}) makes it ineligible for this function to return.

It is usually a bad idea to have more than one process associated with the
same buffer.

@smallexample
@group
(get-buffer-process "*shell*")
     @result{} #<process shell>
@end group
@end smallexample

Killing the process's buffer deletes the process, which kills the subprocess
with a @code{SIGHUP} signal (@pxref{Signals to Processes}).
@end defun

@node Filter Functions
@subsection Process Filter Functions
@cindex filter function
@cindex process filter

  A process @dfn{filter function} is a function that receives the standard
output from the associated process.  @emph{All} output from that process is
passed to the filter.  The default filter simply outputs directly to the
process buffer.

  The filter function can only be called when Emacs is waiting for something,
because process output arrives only at such times.  Emacs waits when reading
terminal input (see the function @code{waiting-for-user-input-p}), in
@code{sit-for} and @code{sleep-for} (@pxref{Waiting}), and in
@code{accept-process-output} (@pxref{Accepting Output}).

  A filter function must accept two arguments: the associated process and a
string, which is output just received from it.  The function is then free to
do whatever it chooses with the output.

@c Note this text is duplicated in the sentinels section.
  Quitting is normally inhibited within a filter function---otherwise, the
effect of typing @kbd{C-g} at command level or to quit a user command would
be unpredictable.  If you want to permit quitting inside a filter function,
bind @code{inhibit-quit} to @code{nil}.  In most cases, the right way to do
this is with the macro @code{with-local-quit}.  @xref{Quitting}.

  If an error happens during execution of a filter function, it is caught
automatically, so that it doesn't stop the execution of whatever program was
running when the filter function was started.  However, if
@code{debug-on-error} is non-@code{nil}, errors are not caught.  This makes
it possible to use the Lisp debugger to debug the filter function.
@xref{Debugger}.

  Many filter functions sometimes (or always) insert the output in the
process's buffer, mimicking the actions of the default filter.  Such filter
functions need to make sure that they save the current buffer, select the
correct buffer (if different) before inserting output, and then restore the
original buffer.  They should also check whether the buffer is still alive,
update the process marker, and in some cases update the value of point.
Here is how to do these things:

@anchor{Process Filter Example}
@smallexample
@group
(defun ordinary-insertion-filter (proc string)
  (when (buffer-live-p (process-buffer proc))
    (with-current-buffer (process-buffer proc)
      (let ((moving (= (point) (process-mark proc))))
@end group
@group
        (save-excursion
          ;; @r{Insert the text, advancing the process marker.}
          (goto-char (process-mark proc))
          (insert string)
          (set-marker (process-mark proc) (point)))
        (if moving (goto-char (process-mark proc)))))))
@end group
@end smallexample

  To make the filter force the process buffer to be visible whenever new text
arrives, you could insert a line like the following just before the
@code{with-current-buffer} construct:

@smallexample
(display-buffer (process-buffer proc))
@end smallexample

  To force point to the end of the new output, no matter where it was
previously, eliminate the variable @code{moving} and call @code{goto-char}
unconditionally.

@ignore
  In earlier Emacs versions, every filter function that did regular
expression searching or matching had to explicitly save and restore the
match data.  Now Emacs does this automatically for filter functions;
they never need to do it explicitly.
@end ignore
  Note that Emacs automatically saves and restores the match data while
executing filter functions.  @xref{Match Data}.

  The output to the filter may come in chunks of any size.  A program that
produces the same output twice in a row may send it as one batch of 200
characters one time, and five batches of 40 characters the next.  If the
filter looks for certain text strings in the subprocess output, make sure to
handle the case where one of these strings is split across two or more
batches of output; one way to do this is to insert the received text into a
temporary buffer, which can then be searched.

@defun set-process-filter process filter
This function gives @var{process} the filter function @var{filter}.  If
@var{filter} is @code{nil}, it gives the process the default filter, which
inserts the process output into the process buffer.
@end defun

@defun process-filter process
This function returns the filter function of @var{process}.
@end defun

In case the process's output needs to be passed to several filters, you can
use @code{add-function} to combine an existing filter with a new one.
@xref{Advising Functions}.

  Here is an example of the use of a filter function:

@smallexample
@group
(defun keep-output (process output)
   (setq kept (cons output kept)))
     @result{} keep-output
@end group
@group
(setq kept nil)
     @result{} nil
@end group
@group
(set-process-filter (get-process "shell") 'keep-output)
     @result{} keep-output
@end group
@group
(process-send-string "shell" "ls ~/other\n")
     @result{} nil
kept
     @result{} ("lewis@@slug:$ "
@end group
@group
"FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
address.txt             backup.psf              kolstad.psf
backup.bib~             david.mss               resume-Dec-86.mss~
backup.err              david.psf               resume-Dec.psf
backup.mss              dland                   syllabus.mss
"
"#backups.mss#          backup.mss~             kolstad.mss
")
@end group
@end smallexample

@ignore @c The code in this example doesn't show the right way to do things.
Here is another, more realistic example, which demonstrates how to use
the process mark to do insertion in the same fashion as the default filter:

@smallexample
@group
;; @r{Insert input in the buffer specified by @code{my-shell-buffer}}
;;   @r{and make sure that buffer is shown in some window.}
(defun my-process-filter (proc str)
  (let ((cur (selected-window))
        (pop-up-windows t))
    (pop-to-buffer my-shell-buffer)
@end group
@group
    (goto-char (point-max))
    (insert str)
    (set-marker (process-mark proc) (point-max))
    (select-window cur)))
@end group
@end smallexample
@end ignore

@node Decoding Output
@subsection Decoding Process Output
@cindex decode process output

  When Emacs writes process output directly into a multibyte buffer, it
decodes the output according to the process output coding system.  If the
coding system is @code{raw-text} or @code{no-conversion}, Emacs converts the
unibyte output to multibyte using @code{string-to-multibyte}, and inserts
the resulting multibyte text.

  You can use @code{set-process-coding-system} to specify which coding system
to use (@pxref{Process Information}).  Otherwise, the coding system comes
from @code{coding-system-for-read}, if that is non-@code{nil}; or else from
the defaulting mechanism (@pxref{Default Coding Systems}).  If the text
output by a process contains null bytes, Emacs by default uses
@code{no-conversion} for it; see @ref{Lisp and Coding Systems,
inhibit-null-byte-detection}, for how to control this behavior.

  @strong{Warning:} Coding systems such as @code{undecided}, which determine
the coding system from the data, do not work entirely reliably with
asynchronous subprocess output.  This is because Emacs has to process
asynchronous subprocess output in batches, as it arrives.  Emacs must try to
detect the proper coding system from one batch at a time, and this does not
always work.  Therefore, if at all possible, specify a coding system that
determines both the character code conversion and the end of line
conversion---that is, one like @code{latin-1-unix}, rather than
@code{undecided} or @code{latin-1}.

@c Let's keep the index entries that were there for
@c set-process-filter-multibyte and process-filter-multibyte-p,
@cindex filter multibyte flag, of process
@cindex process filter multibyte flag
  When Emacs calls a process filter function, it provides the process output
as a multibyte string or as a unibyte string according to the process's
filter coding system.  Emacs decodes the output according to the process
output coding system, which usually produces a multibyte string, except for
coding systems such as @code{binary} and @code{raw-text}.

@node Accepting Output
@subsection Accepting Output from Processes
@cindex accept input from processes

  Output from asynchronous subprocesses normally arrives only while Emacs is
waiting for some sort of external event, such as elapsed time or terminal
input.  Occasionally it is useful in a Lisp program to explicitly permit
output to arrive at a specific point, or even to wait until output arrives
from a process.

@defun accept-process-output &optional process seconds millisec just-this-one
This function allows Emacs to read pending output from processes.  The
output is given to their filter functions.  If @var{process} is
non-@code{nil} then this function does not return until some output has been
received from @var{process}.

The arguments @var{seconds} and @var{millisec} let you specify timeout
periods.  The former specifies a period measured in seconds and the latter
specifies one measured in milliseconds.  The two time periods thus specified
are added together, and @code{accept-process-output} returns after that much
time, whether or not there has been any subprocess output.

The argument @var{millisec} is obsolete (and should not be used), because
@var{seconds} can be floating point to specify waiting a fractional number
of seconds.  If @var{seconds} is 0, the function accepts whatever output is
pending but does not wait.

@c Emacs 22.1 feature
If @var{process} is a process, and the argument @var{just-this-one} is
non-@code{nil}, only output from that process is handled, suspending output
from other processes until some output has been received from that process
or the timeout expires.  If @var{just-this-one} is an integer, also inhibit
running timers.  This feature is generally not recommended, but may be
necessary for specific applications, such as speech synthesis.

The function @code{accept-process-output} returns non-@code{nil} if it did
get some output, or @code{nil} if the timeout expired before output arrived.
@end defun

@node Sentinels
@section Sentinels: Detecting Process Status Changes
@cindex process sentinel
@cindex sentinel (of process)

  A @dfn{process sentinel} is a function that is called whenever the
associated process changes status for any reason, including signals (whether
sent by Emacs or caused by the process's own actions) that terminate, stop,
or continue the process.  The process sentinel is also called if the process
exits.  The sentinel receives two arguments: the process for which the event
occurred, and a string describing the type of event.

  The string describing the event looks like one of the following:

@c FIXME?  Also "killed\n" - see example below?
@itemize @bullet
@item
@code{"finished\n"}.

@item
@code{"exited abnormally with code @var{exitcode}\n"}.

@item
@code{"@var{name-of-signal}\n"}.

@item
@code{"@var{name-of-signal} (core dumped)\n"}.
@end itemize

  A sentinel runs only while Emacs is waiting (e.g., for terminal input, or
for time to elapse, or for process output).  This avoids the timing errors
that could result from running sentinels at random places in the middle of
other Lisp programs.  A program can wait, so that sentinels will run, by
calling @code{sit-for} or @code{sleep-for} (@pxref{Waiting}), or
@code{accept-process-output} (@pxref{Accepting Output}).  Emacs also allows
sentinels to run when the command loop is reading input.
@code{delete-process} calls the sentinel when it terminates a running
process.

  Emacs does not keep a queue of multiple reasons to call the sentinel of one
process; it records just the current status and the fact that there has been
a change.  Therefore two changes in status, coming in quick succession, can
call the sentinel just once.  However, process termination will always run
the sentinel exactly once.  This is because the process status can't change
again after termination.

  Emacs explicitly checks for output from the process before running the
process sentinel.  Once the sentinel runs due to process termination, no
further output can arrive from the process.

  A sentinel that writes the output into the buffer of the process should
check whether the buffer is still alive.  If it tries to insert into a dead
buffer, it will get an error.  If the buffer is dead, @code{(buffer-name
(process-buffer @var{process}))} returns @code{nil}.

@c Note this text is duplicated in the filter functions section.
  Quitting is normally inhibited within a sentinel---otherwise, the effect of
typing @kbd{C-g} at command level or to quit a user command would be
unpredictable.  If you want to permit quitting inside a sentinel, bind
@code{inhibit-quit} to @code{nil}.  In most cases, the right way to do this
is with the macro @code{with-local-quit}.  @xref{Quitting}.

  If an error happens during execution of a sentinel, it is caught
automatically, so that it doesn't stop the execution of whatever programs
was running when the sentinel was started.  However, if
@code{debug-on-error} is non-@code{nil}, errors are not caught.  This makes
it possible to use the Lisp debugger to debug the sentinel.
@xref{Debugger}.

  While a sentinel is running, the process sentinel is temporarily set to
@code{nil} so that the sentinel won't run recursively.  For this reason it
is not possible for a sentinel to specify a new sentinel.

@ignore
  In earlier Emacs versions, every sentinel that did regular expression
searching or matching had to explicitly save and restore the match data.
Now Emacs does this automatically for sentinels; they never need to do
it explicitly.
@end ignore
 Note that Emacs automatically saves and restores the match data while
executing sentinels.  @xref{Match Data}.

@defun set-process-sentinel process sentinel
This function associates @var{sentinel} with @var{process}.  If
@var{sentinel} is @code{nil}, then the process will have the default
sentinel, which inserts a message in the process's buffer when the process
status changes.

Changes in process sentinels take effect immediately---if the sentinel is
slated to be run but has not been called yet, and you specify a new
sentinel, the eventual call to the sentinel will use the new one.

@smallexample
@group
(defun msg-me (process event)
   (princ
     (format "Process: %s had the event `%s'" process event)))
(set-process-sentinel (get-process "shell") 'msg-me)
     @result{} msg-me
@end group
@group
(kill-process (get-process "shell"))
     @print{} Process: #<process shell> had the event `killed'
     @result{} #<process shell>
@end group
@end smallexample
@end defun

@defun process-sentinel process
This function returns the sentinel of @var{process}.
@end defun

In case a process status changes need to be passed to several sentinels, you
can use @code{add-function} to combine an existing sentinel with a new one.
@xref{Advising Functions}.

@defun waiting-for-user-input-p
While a sentinel or filter function is running, this function returns
non-@code{nil} if Emacs was waiting for keyboard input from the user at the
time the sentinel or filter function was called, or @code{nil} if it was
not.
@end defun

@node Query Before Exit
@section Querying Before Exit

  When Emacs exits, it terminates all its subprocesses by sending them the
@code{SIGHUP} signal.  Because subprocesses may be doing valuable work,
Emacs normally asks the user to confirm that it is ok to terminate them.
Each process has a query flag, which, if non-@code{nil}, says that Emacs
should ask for confirmation before exiting and thus killing that process.
The default for the query flag is @code{t}, meaning @emph{do} query.

@defun process-query-on-exit-flag process
This returns the query flag of @var{process}.
@end defun

@defun set-process-query-on-exit-flag process flag
This function sets the query flag of @var{process} to @var{flag}.  It
returns @var{flag}.

Here is an example of using @code{set-process-query-on-exit-flag} on a shell
process to avoid querying:

@smallexample
@group
(set-process-query-on-exit-flag (get-process "shell") nil)
     @result{} nil
@end group
@end smallexample
@end defun

@node System Processes
@section Accessing Other Processes
@cindex system processes

  In addition to accessing and manipulating processes that are subprocesses of
the current Emacs session, Emacs Lisp programs can also access other
processes running on the same machine.  We call these @dfn{system
processes}, to distinguish them from Emacs subprocesses.

  Emacs provides several primitives for accessing system processes.  Not all
platforms support these primitives; on those which don't, these primitives
return @code{nil}.

@defun list-system-processes
This function returns a list of all the processes running on the system.
Each process is identified by its @acronym{PID}, a numerical process ID that
is assigned by the OS and distinguishes the process from all the other
processes running on the same machine at the same time.
@end defun

@defun process-attributes pid
This function returns an alist of attributes for the process specified by
its process ID @var{pid}.  Each association in the alist is of the form
@code{(@var{key} . @var{value})}, where @var{key} designates the attribute
and @var{value} is the value of that attribute.  The various attribute
@var{key}s that this function can return are listed below.  Not all
platforms support all of these attributes; if an attribute is not supported,
its association will not appear in the returned alist.  Values that are
numbers can be either integer or floating point, depending on the magnitude
of the value.

@table @code
@item euid
The effective user ID of the user who invoked the process.  The
corresponding @var{value} is a number.  If the process was invoked by the
same user who runs the current Emacs session, the value is identical to what
@code{user-uid} returns (@pxref{User Identification}).

@item user
User name corresponding to the process's effective user ID, a string.

@item egid
The group ID of the effective user ID, a number.

@item group
Group name corresponding to the effective user's group ID, a string.

@item comm
The name of the command that runs in the process.  This is a string that
usually specifies the name of the executable file of the process, without
the leading directories.  However, some special system processes can report
strings that do not correspond to an executable file of a program.

@item state
The state code of the process.  This is a short string that encodes the
scheduling state of the process.  Here's a list of the most frequently seen
codes:

@table @code
@item "D"
uninterruptible sleep (usually I/O)
@item "R"
running
@item "S"
interruptible sleep (waiting for some event)
@item "T"
stopped, e.g., by a job control signal
@item "Z"
``zombie'': a process that terminated, but was not reaped by its parent
@end table

@noindent
For the full list of the possible states, see the manual page of the
@command{ps} command.

@item ppid
The process ID of the parent process, a number.

@item pgrp
The process group ID of the process, a number.

@item sess
The session ID of the process.  This is a number that is the process ID of
the process's @dfn{session leader}.

@item ttname
A string that is the name of the process's controlling terminal.  On Unix
and GNU systems, this is normally the file name of the corresponding
terminal device, such as @file{/dev/pts65}.

@item tpgid
The numerical process group ID of the foreground process group that uses the
process's terminal.

@item minflt
The number of minor page faults caused by the process since its beginning.
(Minor page faults are those that don't involve reading from disk.)

@item majflt
The number of major page faults caused by the process since its beginning.
(Major page faults require a disk to be read, and are thus more expensive
than minor page faults.)

@item cminflt
@itemx cmajflt
Like @code{minflt} and @code{majflt}, but include the number of page faults
for all the child processes of the given process.

@item utime
Time spent by the process in the user context, for running the application's
code.  The corresponding @var{value} is in the @w{@code{(@var{high}
@var{low} @var{microsec} @var{picosec})}} format, the same format used by
functions @code{current-time} (@pxref{Time of Day, current-time}) and
@code{file-attributes} (@pxref{File Attributes}).

@item stime
Time spent by the process in the system (kernel) context, for processing
system calls.  The corresponding @var{value} is in the same format as for
@code{utime}.

@item time
The sum of @code{utime} and @code{stime}.  The corresponding @var{value} is
in the same format as for @code{utime}.

@item cutime
@itemx cstime
@itemx ctime
Like @code{utime}, @code{stime}, and @code{time}, but include the times of
all the child processes of the given process.

@item pri
The numerical priority of the process.

@item nice
The @dfn{nice value} of the process, a number.  (Processes with smaller nice
values get scheduled more favorably.)

@item thcount
The number of threads in the process.

@item start
The time when the process was started, in the same @code{(@var{high}
@var{low} @var{microsec} @var{picosec})} format used by
@code{file-attributes} and @code{current-time}.

@item etime
The time elapsed since the process started, in the format @code{(@var{high}
@var{low} @var{microsec} @var{picosec})}.

@item vsize
The virtual memory size of the process, measured in kilobytes.

@item rss
The size of the process's @dfn{resident set}, the number of kilobytes
occupied by the process in the machine's physical memory.

@item pcpu
The percentage of the CPU time used by the process since it started.  The
corresponding @var{value} is a floating-point number between 0 and 100.

@item pmem
The percentage of the total physical memory installed on the machine used by
the process's resident set.  The value is a floating-point number between 0
and 100.

@item args
The command-line with which the process was invoked.  This is a string in
which individual command-line arguments are separated by blanks; whitespace
characters that are embedded in the arguments are quoted as appropriate for
the system's shell: escaped by backslash characters on GNU and Unix, and
enclosed in double quote characters on Windows.  Thus, this command-line
string can be directly used in primitives such as @code{shell-command}.
@end table

@end defun


@node Transaction Queues
@section Transaction Queues
@cindex transaction queue

@c That's not very informative.  What is a transaction, and when might
@c I want to use one?
You can use a @dfn{transaction queue} to communicate with a subprocess using
transactions.  First use @code{tq-create} to create a transaction queue
communicating with a specified process.  Then you can call @code{tq-enqueue}
to send a transaction.

@defun tq-create process
This function creates and returns a transaction queue communicating with
@var{process}.  The argument @var{process} should be a subprocess capable of
sending and receiving streams of bytes.  It may be a child process, or it
may be a TCP connection to a server, possibly on another machine.
@end defun

@defun tq-enqueue queue question regexp closure fn &optional delay-question
This function sends a transaction to queue @var{queue}.  Specifying the
queue has the effect of specifying the subprocess to talk to.

The argument @var{question} is the outgoing message that starts the
transaction.  The argument @var{fn} is the function to call when the
corresponding answer comes back; it is called with two arguments:
@var{closure}, and the answer received.

The argument @var{regexp} is a regular expression that should match text at
the end of the entire answer, but nothing before; that's how
@code{tq-enqueue} determines where the answer ends.

If the argument @var{delay-question} is non-@code{nil}, delay sending this
question until the process has finished replying to any previous questions.
This produces more reliable results with some processes.
@ignore

@c Let's not mention it then.
The return value of @code{tq-enqueue} itself is not meaningful.
@end ignore
@end defun

@defun tq-close queue
Shut down transaction queue @var{queue}, waiting for all pending
transactions to complete, and then terminate the connection or child
process.
@end defun

Transaction queues are implemented by means of a filter function.
@xref{Filter Functions}.

@node Network
@section Network Connections
@cindex network connection
@cindex TCP
@cindex UDP

  Emacs Lisp programs can open stream (TCP) and datagram (UDP) network
connections (@pxref{Datagrams}) to other processes on the same machine or
other machines.  A network connection is handled by Lisp much like a
subprocess, and is represented by a process object.  However, the process
you are communicating with is not a child of the Emacs process, has no
process @acronym{ID}, and you can't kill it or send it signals.  All you can
do is send and receive data.  @code{delete-process} closes the connection,
but does not kill the program at the other end; that program must decide
what to do about closure of the connection.

  Lisp programs can listen for connections by creating network servers.  A
network server is also represented by a kind of process object, but unlike a
network connection, the network server never transfers data itself.  When it
receives a connection request, it creates a new network connection to
represent the connection just made.  (The network connection inherits
certain information, including the process plist, from the server.)  The
network server then goes back to listening for more connection requests.

  Network connections and servers are created by calling
@code{make-network-process} with an argument list consisting of
keyword/argument pairs, for example @code{:server t} to create a server
process, or @code{:type 'datagram} to create a datagram connection.
@xref{Low-Level Network}, for details.  You can also use the
@code{open-network-stream} function described below.

  To distinguish the different types of processes, the @code{process-type}
function returns the symbol @code{network} for a network connection or
server, @code{serial} for a serial port connection, or @code{real} for a
real subprocess.

  The @code{process-status} function returns @code{open}, @code{closed},
@code{connect}, or @code{failed} for network connections.  For a network
server, the status is always @code{listen}.  None of those values is
possible for a real subprocess.  @xref{Process Information}.

  You can stop and resume operation of a network process by calling
@code{stop-process} and @code{continue-process}.  For a server process,
being stopped means not accepting new connections.  (Up to 5 connection
requests will be queued for when you resume the server; you can increase
this limit, unless it is imposed by the operating system---see the
@code{:server} keyword of @code{make-network-process}, @ref{Network
Processes}.)  For a network stream connection, being stopped means not
processing input (any arriving input waits until you resume the
connection).  For a datagram connection, some number of packets may be
queued but input may be lost.  You can use the function
@code{process-command} to determine whether a network connection or server
is stopped; a non-@code{nil} value means yes.

@cindex network connection, encrypted
@cindex encrypted network connections
@cindex @acronym{TLS} network connections
@cindex @acronym{STARTTLS} network connections
Emacs can create encrypted network connections, using either built-in or
external support.  The built-in support uses the GnuTLS (``Transport Layer
Security'') library; see @uref{http://www.gnu.org/software/gnutls/, the
GnuTLS project page}.  If your Emacs was compiled with GnuTLS support, the
function @code{gnutls-available-p} is defined and returns non-@code{nil}.
For more details, @pxref{Top,, Overview, emacs-gnutls, The Emacs-GnuTLS
manual}.  The external support uses the @file{starttls.el} library, which
requires a helper utility such as @command{gnutls-cli} to be installed on
the system.  The @code{open-network-stream} function can transparently
handle the details of creating encrypted connections for you, using whatever
support is available.

@defun open-network-stream name buffer host service &rest parameters
This function opens a TCP connection, with optional encryption, and returns
a process object that represents the connection.

The @var{name} argument specifies the name for the process object.  It is
modified as necessary to make it unique.

The @var{buffer} argument is the buffer to associate with the connection.
Output from the connection is inserted in the buffer, unless you specify
your own filter function to handle the output.  If @var{buffer} is
@code{nil}, it means that the connection is not associated with any buffer.

The arguments @var{host} and @var{service} specify where to connect to;
@var{host} is the host name (a string), and @var{service} is the name of a
defined network service (a string) or a port number (an integer).

The remaining arguments @var{parameters} are keyword/argument pairs that are
mainly relevant to encrypted connections:

@table @code

@item :nowait @var{boolean}
If non-@code{nil}, try to make an asynchronous connection.

@item :type @var{type}
The type of connection.  Options are:

@table @code
@item plain
An ordinary, unencrypted connection.
@item tls
@itemx ssl
A @acronym{TLS} (``Transport Layer Security'') connection.
@item nil
@itemx network
Start with a plain connection, and if parameters @samp{:success} and
@samp{:capability-command} are supplied, try to upgrade to an encrypted
connection via @acronym{STARTTLS}.  If that fails, retain the unencrypted
connection.
@item starttls
As for @code{nil}, but if @acronym{STARTTLS} fails drop the connection.
@item shell
A shell connection.
@end table

@item :always-query-capabilities @var{boolean}
If non-@code{nil}, always ask for the server's capabilities, even when doing
a @samp{plain} connection.

@item :capability-command @var{capability-command}
Command string to query the host capabilities.

@item :end-of-command @var{regexp}
@itemx :end-of-capability @var{regexp}
Regular expression matching the end of a command, or the end of the command
@var{capability-command}.  The latter defaults to the former.

@item :starttls-function @var{function}
Function of one argument (the response to @var{capability-command}), which
returns either @code{nil}, or the command to activate @acronym{STARTTLS} if
supported.

@item :success @var{regexp}
Regular expression matching a successful @acronym{STARTTLS} negotiation.

@item :use-starttls-if-possible @var{boolean}
If non-@code{nil}, do opportunistic @acronym{STARTTLS} upgrades even if
Emacs doesn't have built-in @acronym{TLS} support.

@item :client-certificate @var{list-or-t}
Either a list of the form @code{(@var{key-file} @var{cert-file})}, naming
the certificate key file and certificate file itself, or @code{t}, meaning
to query @code{auth-source} for this information (@pxref{Top,,Overview,
auth, The Auth-Source Manual}).  Only used for @acronym{TLS} or
@acronym{STARTTLS}.

@item :return-list @var{cons-or-nil}
The return value of this function.  If omitted or @code{nil}, return a
process object.  Otherwise, a cons of the form @code{(@var{process-object}
. @var{plist})}, where @var{plist} has keywords:

@table @code
@item :greeting @var{string-or-nil}
If non-@code{nil}, the greeting string returned by the host.
@item :capabilities @var{string-or-nil}
If non-@code{nil}, the host's capability string.
@item :type @var{symbol}
The connection type: @samp{plain} or @samp{tls}.
@end table

@end table

@end defun

@node Network Servers
@section Network Servers
@cindex network servers

  You create a server by calling @code{make-network-process} (@pxref{Network
Processes}) with @code{:server t}.  The server will listen for connection
requests from clients.  When it accepts a client connection request, that
creates a new network connection, itself a process object, with the
following parameters:

@itemize @bullet
@item
@c FIXME?  What about IPv6?  Say briefly what the difference is?
The connection's process name is constructed by concatenating the server
process's @var{name} with a client identification string.  The client
identification string for an IPv4 connection looks like
@samp{<@var{a}.@var{b}.@var{c}.@var{d}:@var{p}>}, which represents an
address and port number.  Otherwise, it is a unique number in brackets, as
in @samp{<@var{nnn}>}.  The number is unique for each connection in the
Emacs session.

@item
If the server has a non-default filter, the connection process does not get
a separate process buffer; otherwise, Emacs creates a new buffer for the
purpose.  The buffer name is the server's buffer name or process name,
concatenated with the client identification string.

The server's process buffer value is never used directly, but the log
function can retrieve it and use it to log connections by inserting text
there.

@item
The communication type and the process filter and sentinel are inherited
from those of the server.  The server never directly uses its filter and
sentinel; their sole purpose is to initialize connections made to the
server.

@item
The connection's process contact information is set according to the
client's addressing information (typically an IP address and a port
number).  This information is associated with the @code{process-contact}
keywords @code{:host}, @code{:service}, @code{:remote}.

@item
The connection's local address is set up according to the port number used
for the connection.

@item
The client process's plist is initialized from the server's plist.
@end itemize

@node Datagrams
@section Datagrams
@cindex datagrams

  A @dfn{datagram} connection communicates with individual packets rather than
streams of data.  Each call to @code{process-send} sends one datagram packet
(@pxref{Input to Processes}), and each datagram received results in one call
to the filter function.

  The datagram connection doesn't have to talk with the same remote peer all
the time.  It has a @dfn{remote peer address} which specifies where to send
datagrams to.  Each time an incoming datagram is passed to the filter
function, the peer address is set to the address that datagram came from;
that way, if the filter function sends a datagram, it will go back to that
place.  You can specify the remote peer address when you create the datagram
connection using the @code{:remote} keyword.  You can change it later on by
calling @code{set-process-datagram-address}.

@defun process-datagram-address process
If @var{process} is a datagram connection or server, this function returns
its remote peer address.
@end defun

@defun set-process-datagram-address process address
If @var{process} is a datagram connection or server, this function sets its
remote peer address to @var{address}.
@end defun

@node Low-Level Network
@section Low-Level Network Access

  You can also create network connections by operating at a lower level than
that of @code{open-network-stream}, using @code{make-network-process}.

@menu
* Proc: Network Processes.   Using @code{make-network-process}.
* Options: Network Options.  Further control over network connections.
* Features: Network Feature Testing.  Determining which network features 
                                        work on the machine you are using.
@end menu

@node Network Processes
@subsection @code{make-network-process}

   The basic function for creating network connections and network servers is
@code{make-network-process}.  It can do either of those jobs, depending on
the arguments you give it.

@defun make-network-process &rest args
This function creates a network connection or server and returns the process
object that represents it.  The arguments @var{args} are a list of
keyword/argument pairs.  Omitting a keyword is always equivalent to
specifying it with value @code{nil}, except for @code{:coding},
@code{:filter-multibyte}, and @code{:reuseaddr}.  Here are the meaningful
keywords (those corresponding to network options are listed in the following
section):

@table @asis
@item :name @var{name}
Use the string @var{name} as the process name.  It is modified if necessary
to make it unique.

@item :type @var{type}
Specify the communication type.  A value of @code{nil} specifies a stream
connection (the default); @code{datagram} specifies a datagram connection;
@code{seqpacket} specifies a ``sequenced packet stream'' connection.  Both
connections and servers can be of these types.

@item :server @var{server-flag}
If @var{server-flag} is non-@code{nil}, create a server.  Otherwise, create
a connection.  For a stream type server, @var{server-flag} may be an
integer, which then specifies the length of the queue of pending connections
to the server.  The default queue length is 5.

@item :host @var{host}
Specify the host to connect to.  @var{host} should be a host name or
Internet address, as a string, or the symbol @code{local} to specify the
local host.  If you specify @var{host} for a server, it must specify a valid
address for the local host, and only clients connecting to that address will
be accepted.

@item :service @var{service}
@var{service} specifies a port number to connect to; or, for a server, the
port number to listen on.  It should be a service name that translates to a
port number, or an integer specifying the port number directly.  For a
server, it can also be @code{t}, which means to let the system select an
unused port number.

@item :family @var{family}
@var{family} specifies the address (and protocol) family for communication.
@code{nil} means determine the proper address family automatically for the
given @var{host} and @var{service}.  @code{local} specifies a Unix socket,
in which case @var{host} is ignored.  @code{ipv4} and @code{ipv6} specify to
use IPv4 and IPv6, respectively.

@item :local @var{local-address}
For a server process, @var{local-address} is the address to listen on.  It
overrides @var{family}, @var{host} and @var{service}, so you might as well
not specify them.

@item :remote @var{remote-address}
For a connection, @var{remote-address} is the address to connect to.  It
overrides @var{family}, @var{host} and @var{service}, so you might as well
not specify them.

For a datagram server, @var{remote-address} specifies the initial setting of
the remote datagram address.

The format of @var{local-address} or @var{remote-address} depends on the
address family:

@itemize -
@item
An IPv4 address is represented as a five-element vector of four 8-bit
integers and one 16-bit integer @code{[@var{a} @var{b} @var{c} @var{d}
@var{p}]} corresponding to numeric IPv4 address
@var{a}.@var{b}.@var{c}.@var{d} and port number @var{p}.

@item
An IPv6 address is represented as a nine-element vector of 16-bit integers
@code{[@var{a} @var{b} @var{c} @var{d} @var{e} @var{f} @var{g} @var{h}
@var{p}]} corresponding to numeric IPv6 address
@var{a}:@var{b}:@var{c}:@var{d}:@var{e}:@var{f}:@var{g}:@var{h} and port
number @var{p}.

@item
A local address is represented as a string, which specifies the address in
the local address space.

@item
An ``unsupported family'' address is represented by a cons @code{(@var{f}
. @var{av})}, where @var{f} is the family number and @var{av} is a vector
specifying the socket address using one element per address data byte.  Do
not rely on this format in portable code, as it may depend on implementation
defined constants, data sizes, and data structure alignment.
@end itemize

@item :nowait @var{bool}
If @var{bool} is non-@code{nil} for a stream connection, return without
waiting for the connection to complete.  When the connection succeeds or
fails, Emacs will call the sentinel function, with a second argument
matching @code{"open"} (if successful) or @code{"failed"}.  The default is
to block, so that @code{make-network-process} does not return until the
connection has succeeded or failed.

@item :stop @var{stopped}
If @var{stopped} is non-@code{nil}, start the network connection or server
in the ``stopped'' state.

@item :buffer @var{buffer}
Use @var{buffer} as the process buffer.

@item :coding @var{coding}
Use @var{coding} as the coding system for this process.  To specify
different coding systems for decoding data from the connection and for
encoding data sent to it, specify @code{(@var{decoding} .  @var{encoding})}
for @var{coding}.

If you don't specify this keyword at all, the default is to determine the
coding systems from the data.

@item :noquery @var{query-flag}
Initialize the process query flag to @var{query-flag}.  @xref{Query Before
Exit}.

@item :filter @var{filter}
Initialize the process filter to @var{filter}.

@item :filter-multibyte @var{multibyte}
If @var{multibyte} is non-@code{nil}, strings given to the process filter
are multibyte, otherwise they are unibyte.  The default is the default value
of @code{enable-multibyte-characters}.

@item :sentinel @var{sentinel}
Initialize the process sentinel to @var{sentinel}.

@item :log @var{log}
Initialize the log function of a server process to @var{log}.  The log
function is called each time the server accepts a network connection from a
client.  The arguments passed to the log function are @var{server},
@var{connection}, and @var{message}; where @var{server} is the server
process, @var{connection} is the new process for the connection, and
@var{message} is a string describing what has happened.

@item :plist @var{plist}
Initialize the process plist to @var{plist}.
@end table

The original argument list, modified with the actual connection information,
is available via the @code{process-contact} function.
@end defun

@node Network Options
@subsection Network Options

  The following network options can be specified when you create a network
process.  Except for @code{:reuseaddr}, you can also set or modify these
options later, using @code{set-network-process-option}.

  For a server process, the options specified with @code{make-network-process}
are not inherited by the client connections, so you will need to set the
necessary options for each child connection as it is created.

@table @asis
@item :bindtodevice @var{device-name}
If @var{device-name} is a non-empty string identifying a network interface
name (see @code{network-interface-list}), only handle packets received on
that interface.  If @var{device-name} is @code{nil} (the default), handle
packets received on any interface.

Using this option may require special privileges on some systems.

@item :broadcast @var{broadcast-flag}
If @var{broadcast-flag} is non-@code{nil} for a datagram process, the
process will receive datagram packet sent to a broadcast address, and be
able to send packets to a broadcast address.  This is ignored for a stream
connection.

@item :dontroute @var{dontroute-flag}
If @var{dontroute-flag} is non-@code{nil}, the process can only send to
hosts on the same network as the local host.

@item :keepalive @var{keepalive-flag}
If @var{keepalive-flag} is non-@code{nil} for a stream connection, enable
exchange of low-level keep-alive messages.

@item :linger @var{linger-arg}
If @var{linger-arg} is non-@code{nil}, wait for successful transmission of
all queued packets on the connection before it is deleted (see
@code{delete-process}).  If @var{linger-arg} is an integer, it specifies the
maximum time in seconds to wait for queued packets to be sent before closing
the connection.  The default is @code{nil}, which means to discard unsent
queued packets when the process is deleted.

@c FIXME  Where out-of-band data is ...?
@item :oobinline @var{oobinline-flag}
If @var{oobinline-flag} is non-@code{nil} for a stream connection, receive
out-of-band data in the normal data stream.  Otherwise, ignore out-of-band
data.

@item :priority @var{priority}
Set the priority for packets sent on this connection to the integer
@var{priority}.  The interpretation of this number is protocol specific;
such as setting the TOS (type of service) field on IP packets sent on this
connection.  It may also have system dependent effects, such as selecting a
specific output queue on the network interface.

@item :reuseaddr @var{reuseaddr-flag}
If @var{reuseaddr-flag} is non-@code{nil} (the default) for a stream server
process, allow this server to reuse a specific port number (see
@code{:service}), unless another process on this host is already listening
on that port.  If @var{reuseaddr-flag} is @code{nil}, there may be a period
of time after the last use of that port (by any process on the host) where
it is not possible to make a new server on that port.
@end table

@defun set-network-process-option process option value &optional no-error
This function sets or modifies a network option for network process
@var{process}.  The accepted options and values are as for
@code{make-network-process}.  If @var{no-error} is non-@code{nil}, this
function returns @code{nil} instead of signaling an error if @var{option} is
not a supported option.  If the function successfully completes, it returns
@code{t}.

The current setting of an option is available via the @code{process-contact}
function.
@end defun

@node Network Feature Testing
@subsection Testing Availability of Network Features

  To test for the availability of a given network feature, use @code{featurep}
like this:

@example
(featurep 'make-network-process '(@var{keyword} @var{value}))
@end example

@noindent
The result of this form is @code{t} if it works to specify @var{keyword}
with value @var{value} in @code{make-network-process}.  Here are some of the
@var{keyword}---@var{value} pairs you can test in this way.

@table @code
@item (:nowait t)
Non-@code{nil} if non-blocking connect is supported.
@item (:type datagram)
Non-@code{nil} if datagrams are supported.
@item (:family local)
Non-@code{nil} if local (a.k.a.@: ``UNIX domain'') sockets are supported.
@item (:family ipv6)
Non-@code{nil} if IPv6 is supported.
@item (:service t)
Non-@code{nil} if the system can select the port for a server.
@end table

  To test for the availability of a given network option, use @code{featurep}
like this:

@example
(featurep 'make-network-process '@var{keyword})
@end example

@noindent
The accepted @var{keyword} values are @code{:bindtodevice}, etc.  For the
complete list, @pxref{Network Options}.  This form returns non-@code{nil} if
that particular network option is supported by @code{make-network-process}
(or @code{set-network-process-option}).

@node Misc Network
@section Misc Network Facilities

  These additional functions are useful for creating and operating on network
connections.  Note that they are supported only on some systems.

@defun network-interface-list
This function returns a list describing the network interfaces of the
machine you are using.  The value is an alist whose elements have the form
@code{(@var{name} . @var{address})}.  @var{address} has the same form as the
@var{local-address} and @var{remote-address} arguments to
@code{make-network-process}.
@end defun

@defun network-interface-info ifname
This function returns information about the network interface named
@var{ifname}.  The value is a list of the form @code{(@var{addr} @var{bcast}
@var{netmask} @var{hwaddr} @var{flags})}.

@table @var
@item addr
The Internet protocol address.
@item bcast
The broadcast address.
@item netmask
The network mask.
@item hwaddr
The layer 2 address (Ethernet MAC address, for instance).
@item flags
The current flags of the interface.
@end table
@end defun

@defun format-network-address address &optional omit-port
This function converts the Lisp representation of a network address to a
string.

A five-element vector @code{[@var{a} @var{b} @var{c} @var{d} @var{p}]}
represents an IPv4 address @var{a}.@var{b}.@var{c}.@var{d} and port number
@var{p}.  @code{format-network-address} converts that to the string
@code{"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}"}.

A nine-element vector @code{[@var{a} @var{b} @var{c} @var{d} @var{e} @var{f}
@var{g} @var{h} @var{p}]} represents an IPv6 address along with a port
number.  @code{format-network-address} converts that to the string
@code{"[@var{a}:@var{b}:@var{c}:@var{d}:@var{e}:@var{f}:@var{g}:@var{h}]:@var{p}"}.

If the vector does not include the port number, @var{p}, or if
@var{omit-port} is non-@code{nil}, the result does not include the
@code{:@var{p}} suffix.
@end defun

@node Serial Ports
@section Communicating with Serial Ports
@cindex @file{/dev/tty}
@cindex @file{COM1}
@cindex serial connections

  Emacs can communicate with serial ports.  For interactive use, @kbd{M-x
serial-term} opens a terminal window.  In a Lisp program,
@code{make-serial-process} creates a process object.

  The serial port can be configured at run-time, without having to close and
re-open it.  The function @code{serial-process-configure} lets you change
the speed, bytesize, and other parameters.  In a terminal window created by
@code{serial-term}, you can click on the mode line for configuration.

  A serial connection is represented by a process object, which can be used in
a similar way to a subprocess or network process.  You can send and receive
data, and configure the serial port.  A serial process object has no process
ID, however, and you can't send signals to it, and the status codes are
different from other types of processes.  @code{delete-process} on the
process object or @code{kill-buffer} on the process buffer close the
connection, but this does not affect the device connected to the serial
port.

  The function @code{process-type} returns the symbol @code{serial} for a
process object representing a serial port connection.

  Serial ports are available on GNU/Linux, Unix, and MS Windows systems.

@deffn Command serial-term port speed
Start a terminal-emulator for a serial port in a new buffer.  @var{port} is
the name of the serial port to connect to.  For example, this could be
@file{/dev/ttyS0} on Unix.  On MS Windows, this could be @file{COM1}, or
@file{\\.\COM10} (double the backslashes in Lisp strings).

@c FIXME is 9600 still the most common value, or is it 115200 now?
@c (Same value, 9600, appears below as well.)
@var{speed} is the speed of the serial port in bits per second.  9600 is a
common value.  The buffer is in Term mode; see @ref{Term Mode,,, emacs, The
GNU Emacs Manual}, for the commands to use in that buffer.  You can change
the speed and the configuration in the mode line menu.
@end deffn

@defun make-serial-process &rest args
This function creates a process and a buffer.  Arguments are specified as
keyword/argument pairs.  Here's the list of the meaningful keywords, with
the first two (@var{port} and @var{speed}) being mandatory:

@table @code
@item :port @var{port}
This is the name of the serial port.  On Unix and GNU systems, this is a
file name such as @file{/dev/ttyS0}.  On Windows, this could be @file{COM1},
or @file{\\.\COM10} for ports higher than @file{COM9} (double the
backslashes in Lisp strings).

@item :speed @var{speed}
The speed of the serial port in bits per second.  This function calls
@code{serial-process-configure} to handle the speed; see the following
documentation of that function for more details.

@item :name @var{name}
The name of the process.  If @var{name} is not given, @var{port} will serve
as the process name as well.

@item :buffer @var{buffer}
The buffer to associate with the process.  The value can be either a buffer
or a string that names a buffer.  Process output goes at the end of that
buffer, unless you specify an output stream or filter function to handle the
output.  If @var{buffer} is not given, the process buffer's name is taken
from the value of the @code{:name} keyword.

@item :coding @var{coding}
If @var{coding} is a symbol, it specifies the coding system used for both
reading and writing for this process.  If @var{coding} is a cons
@code{(@var{decoding} . @var{encoding})}, @var{decoding} is used for
reading, and @var{encoding} is used for writing.  If not specified, the
default is to determine the coding systems from the data itself.

@item :noquery @var{query-flag}
Initialize the process query flag to @var{query-flag}.  @xref{Query Before
Exit}.  The flags defaults to @code{nil} if unspecified.

@item :stop @var{bool}
Start process in the ``stopped'' state if @var{bool} is non-@code{nil}.  In
the stopped state, a serial process does not accept incoming data, but you
can send outgoing data.  The stopped state is cleared by
@code{continue-process} and set by @code{stop-process}.

@item :filter @var{filter}
Install @var{filter} as the process filter.

@item :sentinel @var{sentinel}
Install @var{sentinel} as the process sentinel.

@item :plist @var{plist}
Install @var{plist} as the initial plist of the process.

@item :bytesize
@itemx :parity
@itemx :stopbits
@itemx :flowcontrol
These are handled by @code{serial-process-configure}, which is called by
@code{make-serial-process}.
@end table

The original argument list, possibly modified by later configuration, is
available via the function @code{process-contact}.

Here is an example:

@example
(make-serial-process :port "/dev/ttyS0" :speed 9600)
@end example
@end defun

@defun serial-process-configure &rest args
@cindex baud, in serial connections
@cindex bytesize, in serial connections
@cindex parity, in serial connections
@cindex stopbits, in serial connections
@cindex flowcontrol, in serial connections

This function configures a serial port connection.  Arguments are specified
as keyword/argument pairs.  Attributes that are not given are re-initialized
from the process's current configuration (available via the function
@code{process-contact}), or set to reasonable default values.  The following
arguments are defined:

@table @code
@item :process @var{process}
@itemx :name @var{name}
@itemx :buffer @var{buffer}
@itemx :port @var{port}
Any of these arguments can be given to identify the process that is to be
configured.  If none of these arguments is given, the current buffer's
process is used.

@item :speed @var{speed}
The speed of the serial port in bits per second, a.k.a.@: @dfn{baud rate}.
The value can be any number, but most serial ports work only at a few
defined values between 1200 and 115200, with 9600 being the most common
value.  If @var{speed} is @code{nil}, the function ignores all other
arguments and does not configure the port.  This may be useful for special
serial ports such as Bluetooth-to-serial converters, which can only be
configured through @samp{AT} commands sent through the connection.  The
value of @code{nil} for @var{speed} is valid only for connections that were
already opened by a previous call to @code{make-serial-process} or
@code{serial-term}.

@item :bytesize @var{bytesize}
The number of bits per byte, which can be 7 or 8.  If @var{bytesize} is not
given or @code{nil}, it defaults to 8.

@item :parity @var{parity}
The value can be @code{nil} (don't use parity), the symbol @code{odd} (use
odd parity), or the symbol @code{even} (use even parity).  If @var{parity}
is not given, it defaults to no parity.

@item :stopbits @var{stopbits}
The number of stopbits used to terminate a transmission of each byte.
@var{stopbits} can be 1 or 2.  If @var{stopbits} is not given or @code{nil},
it defaults to 1.

@item :flowcontrol @var{flowcontrol}
The type of flow control to use for this connection, which is either
@code{nil} (don't use flow control), the symbol @code{hw} (use RTS/CTS
hardware flow control), or the symbol @code{sw} (use XON/XOFF software flow
control).  If @var{flowcontrol} is not given, it defaults to no flow
control.
@end table

Internally, @code{make-serial-process} calls @code{serial-process-configure}
for the initial configuration of the serial port.
@end defun

@node Byte Packing
@section Packing and Unpacking Byte Arrays
@cindex byte packing and unpacking

@c FIXME?  No multibyte?
@c It doesn't have any autoloads.
  This section describes how to pack and unpack arrays of bytes, usually for
binary network protocols.  These functions convert byte arrays to alists,
and vice versa.  The byte array can be represented as a unibyte string or as
a vector of integers, while the alist associates symbols either with
fixed-size objects or with recursive sub-alists.  To use the functions
referred to in this section, load the @code{bindat} library.

@cindex serializing
@cindex deserializing
@cindex packing
@cindex unpacking
  Conversion from byte arrays to nested alists is also known as
@dfn{deserializing} or @dfn{unpacking}, while going in the opposite
direction is also known as @dfn{serializing} or @dfn{packing}.

@menu
* Bindat Spec::              Describing data layout.
* Bindat Functions::         Doing the unpacking and packing.
* Bindat Examples::          Samples of what bindat.el can do for you!
@end menu

@node Bindat Spec
@subsection Describing Data Layout

  To control unpacking and packing, you write a @dfn{data layout
specification}, a special nested list describing named and typed
@dfn{fields}.  This specification controls the length of each field to be
processed, and how to pack or unpack it.  We normally keep bindat specs in
variables whose names end in @samp{-bindat-spec}; that kind of name is
automatically recognized as ``risky''.

@cindex endianness
@cindex big endian
@cindex little endian
@cindex network byte ordering
  A field's @dfn{type} describes the size (in bytes) of the object that the
field represents and, in the case of multibyte fields, how the bytes are
ordered within the field.  The two possible orderings are ``big endian''
(also known as ``network byte ordering'') and ``little endian''.  For
instance, the number @code{#x23cd} (decimal 9165) in big endian would be the
two bytes @code{#x23} @code{#xcd}; and in little endian, @code{#xcd}
@code{#x23}.  Here are the possible type values:

@table @code
@item u8
@itemx byte
Unsigned byte, with length 1.

@item u16
@itemx word
@itemx short
Unsigned integer in network byte order, with length 2.

@item u24
Unsigned integer in network byte order, with length 3.

@item u32
@itemx dword
@itemx long
Unsigned integer in network byte order, with length 4.  Note: These values
may be limited by Emacs's integer implementation limits.

@item u16r
@itemx u24r
@itemx u32r
Unsigned integer in little endian order, with length 2, 3 and 4,
respectively.

@item str @var{len}
String of length @var{len}.

@item strz @var{len}
Zero-terminated string, in a fixed-size field with length @var{len}.

@item vec @var{len} [@var{type}]
Vector of @var{len} elements of type @var{type}, defaulting to bytes.  The
@var{type} is any of the simple types above, or another vector specified as
a list of the form @code{(vec @var{len} [@var{type}])}.

@item ip
@c FIXME?  IPv6?
Four-byte vector representing an Internet address.  For example: @code{[127
0 0 1]} for localhost.

@item bits @var{len}
List of set bits in @var{len} bytes.  The bytes are taken in big endian
order and the bits are numbered starting with @code{8 * @var{len} @minus{}
1} and ending with zero.  For example: @code{bits 2} unpacks @code{#x28}
@code{#x1c} to @code{(2 3 4 11 13)} and @code{#x1c} @code{#x28} to @code{(3
5 10 11 12)}.

@item (eval @var{form})
@var{form} is a Lisp expression evaluated at the moment the field is
unpacked or packed.  The result of the evaluation should be one of the
above-listed type specifications.
@end table

For a fixed-size field, the length @var{len} is given as an integer
specifying the number of bytes in the field.

When the length of a field is not fixed, it typically depends on the value
of a preceding field.  In this case, the length @var{len} can be given
either as a list @code{(@var{name} ...)} identifying a @dfn{field name} in
the format specified for @code{bindat-get-field} below, or by an expression
@code{(eval @var{form})} where @var{form} should evaluate to an integer,
specifying the field length.

A field specification generally has the form @code{([@var{name}]
@var{handler})}, where @var{name} is optional.  Don't use names that are
symbols meaningful as type specifications (above) or handler specifications
(below), since that would be ambiguous.  @var{name} can be a symbol or an
expression @code{(eval @var{form})}, in which case @var{form} should
evaluate to a symbol.

@var{handler} describes how to unpack or pack the field and can be one of
the following:

@table @code
@item @var{type}
Unpack/pack this field according to the type specification @var{type}.

@item eval @var{form}
Evaluate @var{form}, a Lisp expression, for side-effect only.  If the field
name is specified, the value is bound to that field name.

@item fill @var{len}
Skip @var{len} bytes.  In packing, this leaves them unchanged, which
normally means they remain zero.  In unpacking, this means they are ignored.

@item align @var{len}
Skip to the next multiple of @var{len} bytes.

@item struct @var{spec-name}
Process @var{spec-name} as a sub-specification.  This describes a structure
nested within another structure.

@item union @var{form} (@var{tag} @var{spec})@dots{}
@c ??? I don't see how one would actually  use this.
@c ??? what kind of expression would be useful for @var{form}?
Evaluate @var{form}, a Lisp expression, find the first @var{tag} that
matches it, and process its associated data layout specification
@var{spec}.  Matching can occur in one of three ways:

@itemize
@item
If a @var{tag} has the form @code{(eval @var{expr})}, evaluate @var{expr}
with the variable @code{tag} dynamically bound to the value of @var{form}.
A non-@code{nil} result indicates a match.

@item
@var{tag} matches if it is @code{equal} to the value of @var{form}.

@item
@var{tag} matches unconditionally if it is @code{t}.
@end itemize

@item repeat @var{count} @var{field-specs}@dots{}
Process the @var{field-specs} recursively, in order, then repeat starting
from the first one, processing all the specifications @var{count} times
overall.  The @var{count} is given using the same formats as a field
length---if an @code{eval} form is used, it is evaluated just once.  For
correct operation, each specification in @var{field-specs} must include a
name.
@end table

For the @code{(eval @var{form})} forms used in a bindat specification, the
@var{form} can access and update these dynamically bound variables during
evaluation:

@table @code
@item last
Value of the last field processed.

@item bindat-raw
The data as a byte array.

@item bindat-idx
Current index (within @code{bindat-raw}) for unpacking or packing.

@item struct
The alist containing the structured data that have been unpacked so far, or
the entire structure being packed.  You can use @code{bindat-get-field} to
access specific fields of this structure.

@item count
@itemx index
Inside a @code{repeat} block, these contain the maximum number of
repetitions (as specified by the @var{count} parameter), and the current
repetition number (counting from 0).  Setting @code{count} to zero will
terminate the inner-most repeat block after the current repetition has
completed.
@end table

@node Bindat Functions
@subsection Functions to Unpack and Pack Bytes

  In the following documentation, @var{spec} refers to a data layout
specification, @code{bindat-raw} to a byte array, and @var{struct} to an
alist representing unpacked field data.

@defun bindat-unpack spec bindat-raw &optional bindat-idx
@c FIXME?  Again, no multibyte?
This function unpacks data from the unibyte string or byte array
@code{bindat-raw} according to @var{spec}.  Normally, this starts unpacking
at the beginning of the byte array, but if @var{bindat-idx} is
non-@code{nil}, it specifies a zero-based starting position to use instead.

The value is an alist or nested alist in which each element describes one
unpacked field.
@end defun

@defun bindat-get-field struct &rest name
This function selects a field's data from the nested alist @var{struct}.
Usually @var{struct} was returned by @code{bindat-unpack}.  If @var{name}
corresponds to just one argument, that means to extract a top-level field
value.  Multiple @var{name} arguments specify repeated lookup of
sub-structures.  An integer name acts as an array index.

For example, if @var{name} is @code{(a b 2 c)}, that means to find field
@code{c} in the third element of subfield @code{b} of field @code{a}.  (This
corresponds to @code{struct.a.b[2].c} in C.)
@end defun

  Although packing and unpacking operations change the organization of data
(in memory), they preserve the data's @dfn{total length}, which is the sum
of all the fields' lengths, in bytes.  This value is not generally inherent
in either the specification or alist alone; instead, both pieces of
information contribute to its calculation.  Likewise, the length of a string
or array being unpacked may be longer than the data's total length as
described by the specification.

@defun bindat-length spec struct
This function returns the total length of the data in @var{struct},
according to @var{spec}.
@end defun

@defun bindat-pack spec struct &optional bindat-raw bindat-idx
This function returns a byte array packed according to @var{spec} from the
data in the alist @var{struct}.  It normally creates and fills a new byte
array starting at the beginning.  However, if @var{bindat-raw} is
non-@code{nil}, it specifies a pre-allocated unibyte string or vector to
pack into.  If @var{bindat-idx} is non-@code{nil}, it specifies the starting
offset for packing into @code{bindat-raw}.

When pre-allocating, you should make sure @code{(length @var{bindat-raw})}
meets or exceeds the total length to avoid an out-of-range error.
@end defun

@defun bindat-ip-to-string ip
@c FIXME?  Does it do IPv6?
Convert the Internet address vector @var{ip} to a string in the usual dotted
notation.

@example
(bindat-ip-to-string [127 0 0 1])
     @result{} "127.0.0.1"
@end example
@end defun

@node Bindat Examples
@subsection Examples of Byte Unpacking and Packing
@c FIXME?  This seems a very long example for something that is not used
@c very often.  As of 24.1, gdb-mi.el is the only user of bindat.el in Emacs.
@c Maybe one or both of these examples should just be moved to the
@c commentary of bindat.el.

  Here is a complete example of byte unpacking and packing:

@lisp
(require 'bindat)

(defvar fcookie-index-spec
  '((:version  u32)
    (:count    u32)
    (:longest  u32)
    (:shortest u32)
    (:flags    u32)
    (:delim    u8)
    (:ignored  fill 3)
    (:offset   repeat (:count) (:foo u32)))
  "Description of a fortune cookie index file's contents.")

(defun fcookie (cookies &optional index)
  "Display a random fortune cookie from file COOKIES.
Optional second arg INDEX specifies the associated index
filename, by default \"COOKIES.dat\".  Display cookie text
in buffer \"*Fortune Cookie: BASENAME*\", where BASENAME
is COOKIES without the directory part."
  (interactive "fCookies file: ")
  (let* ((info (with-temp-buffer
                 (insert-file-contents-literally
                  (or index (concat cookies ".dat")))
                 (bindat-unpack fcookie-index-spec
                                (buffer-string))))
         (sel (random (bindat-get-field info :count)))
         (beg (cdar (bindat-get-field info :offset sel)))
         (end (or (cdar (bindat-get-field info
                                          :offset (1+ sel)))
                  (nth 7 (file-attributes cookies)))))
    (switch-to-buffer
     (get-buffer-create
      (format "*Fortune Cookie: %s*"
              (file-name-nondirectory cookies))))
    (erase-buffer)
    (insert-file-contents-literally
     cookies nil beg (- end 3))))

(defun fcookie-create-index (cookies &optional index delim)
  "Scan file COOKIES, and write out its index file.
Optional arg INDEX specifies the index filename, which by
default is \"COOKIES.dat\".  Optional arg DELIM specifies the
unibyte character that, when found on a line of its own in
COOKIES, indicates the border between entries."
  (interactive "fCookies file: ")
  (setq delim (or delim ?%))
  (let ((delim-line (format "\n%c\n" delim))
        (count 0)
        (max 0)
        min p q len offsets)
    (unless (= 3 (string-bytes delim-line))
      (error "Delimiter cannot be represented in one byte"))
    (with-temp-buffer
      (insert-file-contents-literally cookies)
      (while (and (setq p (point))
                  (search-forward delim-line (point-max) t)
                  (setq len (- (point) 3 p)))
        (setq count (1+ count)
              max (max max len)
              min (min (or min max) len)
              offsets (cons (1- p) offsets))))
    (with-temp-buffer
      (set-buffer-multibyte nil)
      (insert
       (bindat-pack
        fcookie-index-spec
        `((:version . 2)
          (:count . ,count)
          (:longest . ,max)
          (:shortest . ,min)
          (:flags . 0)
          (:delim . ,delim)
          (:offset . ,(mapcar (lambda (o)
                                (list (cons :foo o)))
                              (nreverse offsets))))))
      (let ((coding-system-for-write 'raw-text-unix))
        (write-file (or index (concat cookies ".dat")))))))
@end lisp

The following is an example of defining and unpacking a complex structure.
Consider the following C structures:

@example
struct header @{
    unsigned long    dest_ip;
    unsigned long    src_ip;
    unsigned short   dest_port;
    unsigned short   src_port;
@};

struct data @{
    unsigned char    type;
    unsigned char    opcode;
    unsigned short   length;  /* in network byte order  */
    unsigned char    id[8];   /* null-terminated string  */
    unsigned char    data[/* (length + 3) & ~3 */];
@};

struct packet @{
    struct header    header;
    unsigned long    counters[2];  /* in little endian order  */
    unsigned char    items;
    unsigned char    filler[3];
    struct data      item[/* items */];

@};
@end example

The corresponding data layout specification is:

@lisp
(setq header-spec
      '((dest-ip   ip)
        (src-ip    ip)
        (dest-port u16)
        (src-port  u16)))

(setq data-spec
      '((type      u8)
        (opcode    u8)
        (length    u16)  ; network byte order
        (id        strz 8)
        (data      vec (length))
        (align     4)))

(setq packet-spec
      '((header    struct header-spec)
        (counters  vec 2 u32r)   ; little endian order
        (items     u8)
        (fill      3)
        (item      repeat (items)
                   (struct data-spec))))
@end lisp

A binary data representation is:

@lisp
(setq binary-data
      [ 192 168 1 100 192 168 1 101 01 28 21 32
        160 134 1 0 5 1 0 0 2 0 0 0
        2 3 0 5 ?A ?B ?C ?D ?E ?F 0 0 1 2 3 4 5 0 0 0
        1 4 0 7 ?B ?C ?D ?E ?F ?G 0 0 6 7 8 9 10 11 12 0 ])
@end lisp

The corresponding decoded structure is:

@lisp
(setq decoded (bindat-unpack packet-spec binary-data))
     @result{}
((header
  (dest-ip   . [192 168 1 100])
  (src-ip    . [192 168 1 101])
  (dest-port . 284)
  (src-port  . 5408))
 (counters . [100000 261])
 (items . 2)
 (item ((data . [1 2 3 4 5])
        (id . "ABCDEF")
        (length . 5)
        (opcode . 3)
        (type . 2))
       ((data . [6 7 8 9 10 11 12])
        (id . "BCDEFG")
        (length . 7)
        (opcode . 4)
        (type . 1))))
@end lisp

An example of fetching data from this structure:

@lisp
(bindat-get-field decoded 'item 1 'id)
     @result{} "BCDEFG"
@end lisp
