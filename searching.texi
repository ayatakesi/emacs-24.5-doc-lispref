@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter Searching and Matching
@cindex searching

  GNU Emacsは、バッファーから指定されたテキストを検索するために、２つの手段を提供します。それは文字列の正確一致検索(exact string
search)と、正規表現検索(regular expression
search)です。正規表現検索の後、マッチしたテキストが正規表現壱阡にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために、@dfn{マッチデータ(match
data)}を調べることができます。

@menu
* String Search::            正確なマッチの検索。
* Searching and Case::       case-independentまたはcase-significantな検索。
* Regular Expressions::      文字列クラスの記述。
* Regexp Search::            regexpにたいするマッチの検索。
* POSIX Regexps::            最長マッチにたいするPOSIXスタイルのマッチ。
* Match Data::               文字列またはregexp検索後に、テキストがマッチした部分を見つける。
* Search and Replace::       検索と置換を繰り返すコマンド。
* Standard Regexps::         センテンスやページ等を探すために有用なregexp。
@end menu

  @samp{skip-chars@dots{}}関連の関数も、ある種の検索を行います。@ref{Skipping
Characters}を参照してください。文字プロパティ内の変更を検索するには、@ref{Property Search}を参照してください。

@node String Search
@section Searching for Strings
@cindex string search

  バッファー内のテキストを検索するための、プリミティブ関数が存在します。これらはプログラム内での使用を意図したものですが、インタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出した場合は、検索文字列の入力を求め、引数@var{limit}および@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は、@ref{Search,,
Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。

  以下の検索関数は、バッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに、検索文字列を変換します。@ref{Text
Representations}を参照してください。

@deffn Command search-forward string &optional limit noerror repeat
この関数は、@var{string}にたいする正確なマッチを、ポイントから前方に検索する。成功したら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は、@var{noerror}(以下参照)に依存する。

以下の例では、ポイントは最初は行の先頭にある。その後の@code{(search-forward
"fox")}により、ポイントは@samp{fox}の最後の文字の後に移動する:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。

@kindex search-failed
@c I see no prospect of this ever changing, and frankly the current
@c behavior seems better, so there seems no need to mention this.
検索失敗時に何が起こるかは、@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら、@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら、@code{search-forward}は@code{nil}をリターンして、何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して、@code{nil}をリターンする。
@ignore
(It would be more consistent now to return the new position of point
in that case, but some existing programs may depend on a value of
@code{nil}.)
@end ignore

引数@var{noerror}は、マッチに失敗した有効な検索だけに影響する。無効な引数は、@var{noerror}とは無関係にエラーとなる。

@var{repeat}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{repeat}が負の数-@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。
@end deffn

@deffn Command search-backward string &optional limit noerror repeat
この関数は、ポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索では、ポイントはマッチの先頭に残される。
@end deffn

@deffn Command word-search-forward string &optional limit noerror repeat
この関数は、ポイントから前方に@var{string}にたいする``単語(word)''のマッチを検索する。マッチが見つかったら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。

単語マッチは@var{string}を単語のシーケンスとみなし、それらを分ける句読点は無視する。これはバッファーから、同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならないが(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)、句読点やスペース等の細部は無視される(@samp{ball
boy}を検索すると@samp{ball.  Boy!}にマッチする)。

以下の例では、ポイントは最初バッファー先頭にある。検索により、ポイントは@samp{y}と@samp{!}の間に残される。

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチは、その位置を超えてはならない。

@var{noerror}が@code{nil}なら、@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに、@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して、@code{nil}をリターンする。

@var{repeat}が非@code{nil}なら、検索はその回数繰り返される。ポイントは最後のマッチの終端に置かれる。

@findex word-search-regexp
内部的には、@code{word-search-forward}と関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、関数@code{word-search-regexp}を使用する。
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror repeat
このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball
boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。
@end deffn

@deffn Command word-search-backward string &optional limit noerror repeat
この関数は、ポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して、通常はマッチの先頭にポイントを残す点が異なる。
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror repeat
このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。
@end deffn

@node Searching and Case
@section Searching and Case
@cindex searching and case

  デフォルトのEmacs検索では、検索するテキストの大文字と小文字は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。

  この機能が望ましくなければ、変数@code{case-fold-search}を@code{nil}にセットしてください。その場合、すべての文字は大文字小文字の違いを含めて、正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更は、カレントバッファーだけに影響を与えます(@ref{Intro
to
Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは、@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。

  ユーザーレベルのインクリメンタル検索機能では、大文字小文字の区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索は大文字小文字の違いを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索は大文字小文字の違いを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental
Search,,, emacs, The GNU Emacs Manual}を参照してください。

@defopt case-fold-search
このバッファーローカル変数は、検索が大文字小文字の違いを無視するべきかどうかを決定する。この変数が@code{nil}なら、検索は大文字小文字の違いを無視しない。それ以外(とデフォルト)では、大文字小文字のかも無視する。
@end defopt

@defopt case-replace
この変数は、高レベルの置換関数が大文字小文字の違いを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は、置換されるテキストに応じて、置換テキストの大文字小文字を変換することを意味する。

この変数は、それを関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing
Match}を参照のこと。
@end defopt

@node Regular Expressions
@section Regular Expressions
@cindex regular expression
@cindex regexp

  @dfn{正規表現(regular
expression)}、略して@dfn{regexp}は、文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索は、とても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。

@findex re-builder
@cindex regular expressions, developing
  正規表現を対話的に開発するために、@kbd{M-x
re-builder}コマンドを使用できます。このコマンドは、別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともに、ターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。

@menu
* Syntax of Regexps::        正規表現の記述ルール。
* Regexp Example::           正規表現構文の説明。
* Regexp Functions::         正規表現を操作する関数。
@end menu

@node Syntax of Regexps
@subsection Syntax of Regular Expressions
@cindex regexp syntax
@cindex syntax of regular expressions

  正規表現は、少数の文字が特別な構成要素で、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字は、その文字自身だけにマッチする、シンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\}です。将来、新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合、@samp{]}はスペシャル文字です。文字候補の間では、@samp{-}はスペシャル文字です。@samp{[:}と、対応する@samp{:]}は、文字候補内の文字クラスです。正規表現内に出現する他の文字は、@samp{\}が前置されていない限り、通常の文字です。

  たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチし、他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に、@samp{o}は@samp{o}だけにマッチします。

  任意の2つの正規表現@var{a}と@var{b}は、結合することができます。結合した結果は、文字列の先頭からある長さの文字列が@var{a}にマッチし、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。

  単純な例として、文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために、正規表現@samp{f}と@samp{o}を結合できます。

@menu
* Regexp Special::           正規表現内のスペシャル文字。
* Char Classes::             正規表現内で使用される文字クラス。
* Regexp Backslash::         正規表現内のバックスラッシュシーケンス。
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions
@cindex regexp, special characters in

  以下は、正規表現内で特別な文字のリストです:

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
これは、改行を除く1文字にマッチする。結合を使用して、@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。

@item @samp{*}
@cindex @samp{*} in regexp
これは、それ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する、後置演算子である。したがって、@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合もマッチする)。

@samp{*}は常に前置された表現の、@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり、@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。

@cindex backtracking and regular expressions
マッチを行う処理は構成要素@samp{*}を、マッチングにより即座に、見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら、残りのパターンのマッチが可能になるかもしれないという期待のもと、@samp{*}の変更された構成のうちいくつかのマッチを破棄することによる、バックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}であり、マッチ対象に残されているのは@samp{r}だけなので、この試みは失敗する。@samp{a*}にたいする次の代替策は、2つの@samp{a}だけへのマッチである。この選択では、残りのregexpのマッチは成功する。

@strong{警告:}
ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合は、無期限な長時間の実行となり得る。たとえば文字列@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}にたいして正規表現@samp{\(x+y*\)*a}のマッチを試みると、それが最終的に失敗するまでに数時間を要し得る。Emacsはその試みのいずれも機能しないと結論する前に、@samp{x}のグループ家のそれぞれを試みなければならない。さらに悪いことに、@samp{\(x*\)*}は無数の方法でnull文字列にマッチ可能なので、これは無限ループを引き起こす。これらの問題を避けるには、ネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial
explosion)が発生しないことを確実にするために注意深くチェックすること。

@item @samp{+}
@cindex @samp{+} in regexp
これは@samp{*}のような後置演算子だが、これは前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが、文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。

@item @samp{?}
@cindex @samp{?} in regexp
これは@samp{*}のような後置演算子だが、これは前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。申@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが、他にはマッチしない。

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
演算子
@samp{*}、@samp{+}、@samp{?}には``非欲張り(non-greedy)''な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。

たとえば正規表現@samp{c[ad]*a}が文字列@samp{cdaaada}に適用されると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d}である)。

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
これは@samp{[}で始まり@samp{]}で終端される@dfn{文字候補(character
alternative)}である。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字である。

したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけから構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。

開始文字と終了文字の間に@samp{-}を記述することにより、文字候補内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。

@c This wasn't obvious to me, since, e.g., the grep manual "Character
@c Classes and Bracket Expressions" specifically notes the opposite
@c behavior.  But by experiment Emacs seems unaffected by LC_COLLATE
@c in this regard.
@code{case-fold-search}が非@code{nil}なら、@samp{[a-z]}は大文字アルファベットにもマッチする。@samp{[a-z]}のような範囲は、そのlocaleの照合順に影響されず、常に@acronym{ASCII}順のシーケンスを表すことに注意。

さらに通常のregexpスペシャル文字は文字候補内では特別ではないことにも注意されたい。文字候補内部では@samp{]}、@samp{-}、@samp{^}という完全に異なる文字セットが特別に扱われる。

文字候補内に@samp{]}を含めるには、それを最初の文字にしなければならない。たとえば@samp{[]a]}は、@samp{]}と@samp{a}にマッチする。@samp{-}を含めるには、文字候補の最初または最後の文字として@samp{-}を記述するか、範囲の後に置くこと。つまり@samp{[]-]}は@samp{]}と@samp{-}の両方にマッチする。(以下で説明するように、ここでは@samp{\}は特別ではないので、文字候補内に@samp{]}を含めるために@samp{\]}は使用できない)。

文字候補内に@samp{^}を含めるには、先頭以外のいずれかの場所に置くこと。

@c What if it starts with a multibyte and ends with a unibyte?
@c That doesn't seem to match anything...?
ある範囲がユニバイト文字@var{c}で始まり、マルチバイト文字@var{c2}でお話場合、その範囲は2つの部分に分割される。1つはユニバイト文字@samp{@var{c}..?\377}、もう1つはマルチバイト文字@samp{@var{c1}..@var{c2}}である。ここで@var{c1}は@var{c2}が属する文字セットの最初の文字である。

文字候補には、名前付き文字クラスも指定できる(@ref{Char
Classes}を参照)。これはPOSIXの機能である。たとえば@samp{[[:ascii:]]}は、任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので、後者は実際は実現可能ではない。

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^}は@dfn{補完文字候補(complemented character
alternative)}を開始する。これは、指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はアルファベットと数日前@emph{以外}の、すべての文字にマッチする。

@samp{^}は文字クラス内では、先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(別の言い方をすると@samp{-}や@samp{]}は、ここでは特別ではない)。

マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは、対照的である。

文字候補のように、名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は、任意の非@acronym{ASCII}文字にマッチする。@ref{Char
Classes}を参照のこと。

@item @samp{^}
@cindex beginning of line in regexp
バッファーのマッチング時、@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチは、すべて失敗する。つまり@samp{^foo}は、行の先頭に出現する@samp{foo}にマッチする。

バッファーではなく文字列とマッチする際は、@samp{^}は文字列の先頭、または改行文字の後にマッチする。

歴史的な互換性という理由により、@samp{^}は正規表現の先頭、または@samp{\(}、@samp{\(?:}、@samp{\|}の後だけで使用できる。

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は、行末にある1つ以上の@samp{x}からなる文字列にマッチする。

バッファーではなく文字列とマッチする際は、@samp{$}は文字列の終端、または改行文字の前にマッチする。

歴史的な互換性という理由により、@samp{$}は正規表現の先頭、または@samp{\(}、@samp{\(?:}、@samp{\|}の前だけで使用できる。

@item @samp{\}
@cindex @samp{\} in regexp
これは2つの機能をもつ。スペシャル文字(@samp{\}を含む)のクォートと、追加のスペシャル文字の導入である。

@samp{\}はスペシャル文字をクォートするので、@samp{\$}は@samp{$}、@samp{\[}は@samp{[}だけにマッチする正規表現といったようになる。

@samp{\}はLisp文字列(@ref{String Type}を参照)の入力構文(read
syntax)内でも特別な意味をもち、@samp{\}でクォートしなければならないことに注意。たとえば文字@samp{\}にマッチする正規表現は@samp{\\}である。文字@samp{\\}を含むLisp文字列を記述するには、別の@samp{\\}で@samp{\\}をクォートすることをLisp構文は要求する。したがって@samp{\}にマッチする正規表現にたいする入力構文は、@code{"\\\\"}となる。
@end table

@strong{注意してください:}
歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合は、通常の文字として扱われます。たとえば@samp{*foo}は、@samp{*}が作用可能な前置された表現がないので、通常の@samp{*}として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようと、スペシャル文字はすべてクォートしてください。

文字候補内で@samp{\}は何ら特別ではないので、@samp{-}や@samp{]}の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする@samp{[^\]}(Lisp文字列構文では@code{"[^\\]"})内でのように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを前置する正当性があるので、それほど何も明解にはしないでしょう。

実際には、正規表現内に出現する@samp{]}は文字候補に近接しており、それ故にほとんどがスペシャル文字です。しかしリテラルの@samp{[}および@samp{]}の複雑なパターンにたいして、マッチを試みることも時にはあるかもしれません。そのような状況では、文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析するのが必要なときもあるかもしれません。たとえば@samp{[^][]]}は、補完文字候補@samp{[^][]}(角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。

厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後は文字候補になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除き、特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  以下は文字候補内で使用できるクラスと、その意味についてのテーブルです:

@table @samp
@item [:ascii:]
これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。
@item [:alnum:]
これは任意のアルファベットと数字にマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
@item [:alpha:]
これは任意のアルファベットにマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
@item [:blank:]
これはスペースとタブだけにマッチする。
@item [:cntrl:]
これは@acronym{ASCII}制御文字にマッチする。
@item [:digit:]
これは@samp{0}から@samp{9}までにマッチする。つまり@samp{[-+[:digit:]]}は@samp{+}と@samp{-}同様、任意の数にマッチする。
@item [:graph:]
これはグラフィック文字(@acronym{ASCII}制御文字、スペース、delete文字を除くすべての文字)を意味する。
@item [:lower:]
これはカレントの大文字小文字テーブル(@ref{Case
Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら、これは大文字にもマッチする。
@item [:multibyte:]
これは任意のマルチバイト文字にマッチする(@ref{Text Representations}を参照)。
@item [:nonascii:]
これは非@acronym{ASCII}文字にマッチする。
@item [:print:]
これはプリント文字(@acronym{ASCII}制御文字とdelete文字以外のすべての文字)にマッチする。
@item [:punct:]
これは任意の句読点文字(punctuation
character)にマッチする(現在のところマルチバイト文字にたいしては、単語構文以外のすべてにマッチする)。
@item [:space:]
これは空白文字構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。
@item [:unibyte:]
これは任意のユニバイト文字(@ref{Text Representations}を参照)にマッチする。
@item [:upper:]
これはカレントの大文字小文字テーブル(@ref{Case
Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら、これは小文字にもマッチする。
@item [:word:]
これは単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。
@item [:xdigit:]
これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions
@cindex backslash in regular expressions

  ほとんどの場合、@samp{\}の後の任意の文字は、その文字だけにマッチします。しかし、例外もいくつかあります。@samp{\}で始まる特定のシーケンスには、特別な意味をもつものがあります。以下は特別な@samp{\}構成要素のテーブルです。

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
これは選択肢を指定する。2つの正規表現@var{a}と@var{b}、その間にある@samp{\|}により、@var{a}または@var{b}のいずれかにマッチする表現が形成される。

つまり@samp{foo\|bar}は、@samp{foo}か@samp{bar}のいずれかにマッチし、他の文字列にはマッチしない。

@samp{\|}は周囲の適用可能な最大の表現に適用される。@samp{\|}を取り囲む@samp{\( @dots{}
\)}でグループ化することにより、グループ化の効力を制限できる。

複数の@samp{\|}の処理するための、完全なバックトラッキング互換が必要なら、POSIX正規表現関数を使用すること(@ref{POSIX
Regexps}を参照)。

@item \@{@var{m}\@}
これは、前のパターンを正確に@var{m}回繰り返す、後置演算子である。つまり@samp{x\@{5\@}}は文字列@samp{xxxxx}にマッチし、それ以外にはマッチしない。@samp{c[ad]\@{3\@}r}は@samp{caaar}、@samp{cdddr}、@samp{cadar}等にマッチする。

@item \@{@var{m},@var{n}\@}
これは最小で@var{m}回、最大で@var{n}回繰り返す、より一般的な後置演算子である。@var{m}省略時の最小は0、@var{n}省略時の最大は存在しない。

たとえば@samp{c[ad]\@{1,2\@}r}は文字列@samp{car}、@samp{cdr}、@samp{caar}、@samp{cadr}、@samp{cdar}、@samp{cddr}にマッチし、それ以外にはマッチしない。@*@samp{\@{0,1\@}}または@samp{\@{,1\@}}は、@samp{?}と同じ。@*@samp{\@{0,\@}}または@samp{\@{,\@}}は@samp{*}と同じ。@*@samp{\@{1,\@}}は@samp{+}と同じ。

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
これは、以下の3つの目的を果たす役目をもつグループ化構成要素である:

@enumerate
@item
他の操作のために、一連の@samp{\|}選択肢を囲う。つまり正規表現@samp{\(foo\|bar\)x}は、@samp{foox}か@samp{barx}のいずれかにマッチする。

@item
後置演算子@samp{*}、@samp{+}、@samp{?}による複雑な表現を囲う。つまり@samp{ba\(na\)*}は@samp{ba}、@samp{bana}、@samp{banana}、@samp{bananana}、...等、任意の数(0以上の文字列@samp{na}にマッチする。

@item
@samp{\@var{digit}}(以下参照)による将来の参照にたいして、マッチする部分文字列を記録する。
@end enumerate

この最後の目的は、カッコによるグループ化というアイデアによるものではない。これは同じ構成要素@samp{\( @dots{}
\)}である2つ目の目的に割当てられた別の機能だが、実際のところ2つの意味は衝突しない。しかし稀に衝突が発生することがあり、それが内気(shy)なグループの導入をもたらした。

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
これは@dfn{内気なグループ(shy
group)}の構成要素である。内気なグループは通常のグループの最初の2つの役目(他の演算子のネスト制御)を果たすが、これは番号を取得せず@samp{\@var{digit}}でその値を後方参照できない。内気なグループは、通常の内気でないグループを変更することなく自動的に追加できるので、機械的に正規表現を構築するのに、特に適している。

内気なグループ化は、@dfn{非キャプチャリング(non-capturing)}、あるいは@dfn{番号なしグループ(unnumbered
groups)}とも呼ばれる。

@item \(?@var{num}: @dots{} \)
これは@dfn{明示的番号付きグループ(explicitly numbered
group)}の構成要素である。通常のグループ化では、位置をもとに番号が暗黙で取得されるが、これが不便な場合もあるだろう。この構成要素により、特定のグループに番号を強制できる。番号の付与に特別な制限はなく、複数のグループに同じ番号を付与でき、その場合は最後の1つがマッチ(もっとも右のマッチ)が採用される。暗黙的に番号付けされたグループは常に、前のグループより大きい最小の整数となる番号を取得する。

@item \@var{digit}
これはグループ構成要素(@samp{\( @dots{} \)})の、@var{digit}番目にマッチしたテキストと同じテキストにマッチする。

他の言い方をすると、最後のグループの後に、マッチ処理はそのグループによりマッチされたテキストの開始と終了を記憶する。その正規表現の先の箇所で、@samp{\}とその後に@var{digit}を使用すれば、それが何であれ同じテキストにマッチさせることができる。

検索またはマッチングを行う関数に渡される、正規表現全体の中で最初の9つのグループ化構成要素にマッチする文字列には、その正規表現内で開きカッコが出現する順に1から9までの番号が割り当てられる。したがって@samp{\1}から@samp{\9}までを使用して、対応するグループ化構成要素によりマッチされたテキストを参照できる。

たとえば@samp{\(.*\)\1}は、一方がもう一方と等しいような2つの文字列から構成される、改行を含まない任意の文字列にマッチする。@samp{\(.*\)}は前半分にマッチし、これは何でもよいが、それに続く@samp{\1}はそれと同じテキストに正確にマッチしなければならない。

構成要素@samp{\( @dots{}
\)}が2回以上マッチする場合(これはたとえば後に@samp{*}をしたがえるとき発生し得る)は、最後のマッチだけが記録される。

正規表現内の特定のグループ化構成要素がマッチしなかった場合、たとえばそれが使用されない選択肢内にあったり、回数が0回の繰り返しの内部にあるなら、それに対応する@samp{\@var{digit}}構成は何にもマッチしない。人工的な例を用いると、@samp{\(foo\(b*\)\|lose\)\2}は@samp{lose}にマッチできない。外側のグループ内の2つ目の選択肢がマッチするものの、@samp{\2}が未定義となり、何にたいしてもマッチできない。しかし@samp{foobb}にたいしては、1つ目の選択肢が@samp{foob}にマッチし、@samp{\2}が@samp{b}にマッチするので、マッチが可能になる。

@item \w
@cindex @samp{\w} in regexp
これは任意の単語構成文字にマッチする。エディターの構文テーブルが、どの文字が単語構成文字かを決定する。@ref{Syntax
Tables}を参照のこと。

@item \W
@cindex @samp{\W} in regexp
これは任意の非単語構成文字にマッチする。

@item \s@var{code}
@cindex @samp{\s} in regexp
これは、構文が@var{code}であるような任意の文字にマッチする。ここで@var{code}は、構文コードを表す文字である。@samp{w}は単語構成要素、@samp{-}は空白文字、@samp{(}は開きカッコ、等である。空白文字構文を表すには、@samp{-}かスペース文字のいずれかを使用する。構文コードと、それらを意味する文字のリストは、@ref{Syntax
Class Table}を参照されたい。

@item \S@var{code}
@cindex @samp{\S} in regexp
これは、構文が@var{code}でないような任意の文字にマッチする。

@cindex category, regexp search for
@item \c@var{c}
これは、カテゴリーが@var{c}であるような任意の文字にマッチする。ここで@var{c}は、カテゴリーを表す文字である。つまり標準カテゴリーテーブルで、@samp{c}はChinese(中国語)、@samp{g}はGreek(ギリシャ語)の文字となる。@kbd{M-x
describe-categories
@key{RET}}で現在定義済みの全カテゴリーのリストを確認できる。@code{define-category}関数を使用すれば、標準カテゴリーに加えて、カテゴリーを独自に定義することもできる(@ref{Categories}を参照)。

@item \C@var{c}
これは、カテゴリーが@var{c}ではない任意の文字にマッチする。
@end table

  以下は、空文字列にマッチ(つまり文字を何も消費しない)しますが、マッチするかどうかはコンテキストに依存するような正規表現を構築します。これらすべてにたいして、そのバッファーのアクセス可能範囲の先頭と終端は、あたかもそのバッファーの実際の先頭と終端のように扱われます。

@table @samp
@item \`
@cindex @samp{\`} in regexp
これは空文字列、ただしバッファー先頭、またはマッチ対象の文字列の先頭だけにマッチする。

@item \'
@cindex @samp{\'} in regexp
これは空文字列、ただしバッファー終端、またはマッチ対象の文字列の終端だけにマッチする。

@item \=
@cindex @samp{\=} in regexp
これは空文字列、ただしポイント位置だけにマッチする(この構成要素はマッチ対象が文字列なら定義されない)。

@item \b
@cindex @samp{\b} in regexp
これは空文字列、ただし単語の先頭だけにマッチする。つまり@samp{\bfoo\b}は、個別の単語として出現する@samp{foo}だけにマッチする。@samp{\bballs?\b}は、個別の単語として@samp{ball}または@samp{balls}にマッチする。

@samp{\b}は、隣接するテキストが何であるかと無関係に、バッファー(か文字列)の先頭または終端にマッチする。

@item \B
@cindex @samp{\B} in regexp
これは空文字列、単語の先頭や終端、またはバッファー(か文字列)の先頭や終端@emph{以外}にマッチする。

@item \<
@cindex @samp{\<} in regexp
これは空文字列、ただし単語の先頭だけにマッチする。@samp{\<}は、後に単語構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチする。

@item \>
@cindex @samp{\>} in regexp
これは空文字列、ただし単語の終端だけにマッチする。@samp{\<}は、コンテンツが単語構成文字で終わる場合のみ、バッファー(か文字列)の終端にマッチする。

@item \_<
@cindex @samp{\_<} in regexp
これは空文字列、ただしシンボルの先頭だけにマッチする。シンボルとは1つ以上の単語かシンボル構成文字のシーケンスである。@samp{\_<}は、後にシンボル構成文字が続く場合のみ、バッファー(か文字列)の先頭にマッチする。

@item \_>
@cindex @samp{\_>} in regexp
これは空文字列、ただし単語の終端だけにマッチする。@samp{\_>}は、コンテンツがシンボル構成文字で終わる場合のみ、バッファー(か文字列)の終端にマッチする。
@end table

@kindex invalid-regexp
  すべての文字列が、有効な正規表現な訳ではありません。たとえば終端の@samp{]}がない文字選択肢ないで終わる文字列は無効であり、単一の@samp{\}で終わる文字列も同様です。いずれかの検索関数にたいして無効な正規表現が渡されると、@code{invalid-regexp}エラーがシグナルされます。

@node Regexp Example
@subsection Complex Regexp Example

  以下は、後続の空白文字とともにセンテンスの終わりを認識するために、以前のEmacsで使用されていた、複雑な正規表現の例です(現在のEmacsは、関数@code{sentence-end}により構築される、同様だがより複雑なregexpを使用する。@ref{Standard
Regexps}を参照されたい)。

  以下ではまず、(スペースとタブ文字を区別するために)Lisp構文の文字列としてregexpを示し、それを評価した結果を示します。文字列定数の開始と終了は、ダブルクォーテーションです。@samp{\"}は文字列の一部としてのダブルクォーテーション、@samp{\\}は文字列の一部としてのバックスラッシュ、@samp{\t}はタブ、@samp{\n}は改行を意味します。

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
改行とタブは、それら自身として出力されます。

  この正規表現は連続する4つのパートを含み、以下のように解読できます:

@table @code
@item [.?!]
この正規表現の1つ目のパートはピリオド、疑問符、感嘆符の3つのうち、いずれか1つにマッチする文字選択肢である。マッチはこれら3つの文字のいずれかで開始されなければならない(これは旧正規表現と、Emacsが使用する新たなデフォルトregexpが異なる1つのポイントである。新たな値は、後続の空白文字なすでセンテンスを終端する、いくつかの非@acronym{ASCII}文字を許容する)。

@item []\"')@}]*
パターンの2つ目のパートは任意の0個以上の閉じカッコおよびクォーテーションマークで、後にピリオド、疑問符、感嘆符があるかもしれない。@code{\"}は、文字列内でのダブルクォーテーションマークにたいするLisp構文である。最後の@samp{*}は、直前の正規表現(この場合は文字選択肢)の0回以上の繰り返しを示す。

@item \\($\\|@ $\\|\t\\|@ @ \\)
パターンの3つ目のパートは、センテンスの後の空白文字、すなわち行の終端(スペースがあっても可)、タブ、または2つのスペースにマッチする。2連バックスラッシュはカッコと垂直バーを正規表現構文としてマークする。すなわちカッコはグループを句切り、垂直バーは選択肢を区別する。ダラー記号は行の終端へのマッチに使用される。

@item [ \t\n]*
最後に、パターンの最終パートはセンテンスを終端させるために必要とされる以上の、余分な空白文字にマッチする。
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  以下の関数は、正規表現を扱います。

@cindex quote special characters in regexp
@defun regexp-quote string
この関数は、@var{string}だけに正確にマッチするような正規表現をリターンする。@code{looking-at}内でのこの正規表現の使用は、そのバッファー内の次の文字が@var{string}のときだけ成功するだろう。検索関数でのこの正規表現の使用は、検索されるテキストが@var{string}を含むなら成功するだろう。@ref{Regexp
Search}を参照のこと。

これにより、その正規表現を求める関数呼び出し時に、正確な文字列マッチまたは検索を要求できる。

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

正規表現として記述されたコンテキストにおいて、正確な文字列マッチを結合することが、@code{regexp-quote}の1つの使い方である。たとえば以下は空白文で囲まれた、@var{string}の値であるような文字列を検索する:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
@c E.g., see http://debbugs.gnu.org/2816
この関数は、リスト@var{strings}の文字列だけにマッチする、効果的な正規表現をリターンする。これはマッチングや検索を可能な限り高速にする必要があるとき、たとえばFont
Lockモードで有用である@footnote{@code{regexp-opt}の結果が絶対的にもっとも効率的であるという保証はないことに注意してください。手作業でチューニングした正規表現のほうがわずかに効率的であることがときにありますが、これに努力する価値はほとんどないでしょう。}。

オプション引数@var{paren}が非@code{nil}なら、その正規表現は少なくとも1つのカッコによるグループ化構成要素に常に囲まれてリターンされる。@var{paren}が@code{words}なら、その構成要素は追加で@samp{\<}と@samp{\>}で囲まれ、@var{paren}が@code{symbols}なら@samp{\_<}と@samp{\_>}で囲まれる(プログラミング言語のような文字列をマッチングする際は、@code{symbols}が適切な場合が多々ある)。

この単純化された@code{regexp-opt}の定義は、実際の値と等価(だが同程度に効率的ではない)な正規表現を生成する:

@example
(defun regexp-opt (strings &optional paren)
  (let ((open-paren (if paren "\\(" ""))
        (close-paren (if paren "\\)" "")))
    (concat open-paren
            (mapconcat 'regexp-quote strings "\\|")
            close-paren)))
@end example
@end defun

@defun regexp-opt-depth regexp
この関数は、@var{regexp}内のグループ化された構成要素(カッコで囲まれた正規表現)の総数をリターンする。これには内気なグループは含まれない(@ref{Regexp
Backslash}を参照)。
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
この関数は文字リスト@var{chars}内の文字にマッチする正規表現をリターンする。

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@node Regexp Search
@section Regular Expression Searching
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  GNU Emacsでは、インクリメンタル、または非インクリメンタルの両方で、正規表現(@ref{Syntax of
Regexps}を参照)にたいする次マッチを検索できます。インクリメンタル検索コマンドについては、@ref{Regexp Search, ,
Regular Expression Search, emacs, The GNU Emacs
Manual}を参照してください。ここでは、プログラム内で有用な検索関数だけを説明します。重要な関数は@code{re-search-forward}です。

  これらの検索関数は、バッファーがマルチバイトならルチバイトに、ユニバイトならユニバイトに、正規表現を変換します。@ref{Text
Representations}を参照してください。

@deffn Command re-search-forward regexp &optional limit noerror repeat
この関数はカレントバッファー内で、正規表現@var{regexp}にマッチするテキスト文字列を、前方へ検索する。この関数は@var{regexp}にマッチしない任意の量のテキストをスキップして、見つかった最初のマッチの終端にポイントを残す。これはポイントの新たな値をリターンする。

@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これは検索にたいする上限を指定する。その位置を超えるマッチは受け入れられない。

@var{repeat}が与えられたなら、それは正の数でなければならない。検索は、その回数繰り返される。それぞれの繰り返しは、前のマッチの終端から開始される。これら一連の検索すべてが成功したらその検索は成功となり、ポイントを移動してポイントの新たな値をリターンする。それ以外では、検索は失敗となる。検索失敗時に@code{re-search-forward}が何をおこなうかは、@var{noerror}の値に依存する:

@table @asis
@item @code{nil}
@code{search-failed}エラーをシグナルする。
@item @code{t}
何もせず@code{nil}をリターンする。
@item その他
ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して、@code{nil}をリターンする。
@end table

以下の例では、ポイントは最初は@samp{T}の前にある。この検索を評価することにより、その行の終端(@samp{hat}の@samp{t}と改行の間)にポイントは移動する。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror repeat
この関数はカレントバッファー内で、正規表現@var{regexp}にマッチするテキスト文字列を、後方へ検索して、見つかった最初のマッチの先頭にポイントを残す。

この関数は@code{re-search-forward}と似ているが、単なるミラーイメージ(mirror-image:
鏡像)ではない。@code{re-search-forward}は、先頭が開始ポイントと可能な限り近いマッチを探す。@code{re-search-backward}が完全なミラーイメージなら、終端が可能な限り近いマッチを探すだろう。しかし実際は先頭が可能な限り近い(かつ開始ポイントの前で終わる)マッチを探す。これは、与えられた位置にたいする正規表現マッチングが常に正規表現の先頭から終端に機能し、指定された開始位置から開始されるのが理由である。

@code{re-search-forward}の真のミラーイメージには、正規表現を終端から先頭へマッチする特別な機能が要求されるだろう。それを実装するこによる問題に価値はない。
@end deffn

@defun string-match regexp string &optional start
この関数は@var{string}内で、正規表現@var{regexp}にたいする最初のマッチの開始位置のインデックスをリターンする。@var{string}内のそのインデックスから検索は開始される。

たとえば、

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
文字列の最初の文字のインデックスは1、2文字目は2、...となる。

この関数リターン後、そのマッチの先の最初の文字のインデックスは、@code{(match-end 0)}で利用できる。@ref{Match
Data}を参照のこと。

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
この述語関数は@code{string-match}と同じことを行うが、マッチデータの変更を避ける。
@end defun

@defun looking-at regexp
この関数は、カレントバッファー内のポイント直後のテキストが、正規表現@var{regexp}にマッチするかどうかを判断する。``直後''の正確な意味は、その検索が``固定''され、ポイントの後の最初の文字からマッチが開始する場合のみ成功するということである。成功なら結果は@code{t}、それ以外は@code{nil}となる。

この関数はポイントを移動しないが、マッチデータは更新する。@ref{Match
Data}を参照のこと。マッチデータを変更することなくテストする必要があるなら、以下で説明する@code{looking-at-p}を使用すること。

以下の例では、ポイントは@samp{T}の直前にある。それ以外の場所にある場合、結果は@code{nil}となるだろう。

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp &optional limit greedy
この関数は、ポイントの直前(ポイントで終わる)テキストが@var{regexp}とマッチしたら@code{t}、それ以外は@code{nil}をリターンする。

正規表現マッチングは前方だけに機能するので、ポイントで終わるマッチを、ポイントから後方へ検索するように実装された。長い距離を検索する必要がある場合、これは極めて低速になり得る。@var{limit}を指定してその前を検索しないよう告げることにより、要する時間を制限できる。この場合、マッチデータは@var{limit}、またはその後で始まらなければならない。以下は例である:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

@var{greedy}が非@code{nil}なら、この関数は可能な限り後方へマッチを拡張し、前方の1文字がregexpがマッチの一部とならなければ停止する。マッチが拡張されたときは、マッチ開始位置が@var{limit}の前にあっても許される。

@c http://debbugs.gnu.org/5689
一般的に@code{looking-back}は低速なので、可能な限り使用は避けることを推奨する。この理由により、@code{looking-back-p}の追加は計画されていない。
@end defun

@defun looking-at-p regexp
この述語関数は@code{looking-at}と同様に機能するが、マッチデータを更新しない。
@end defun

@defvar search-spaces-regexp
この変数が非@code{nil}なら、それは空白文字を検索する方法を告げる正規表現であること。この場合、検索される正規表現内のすべてのスペース属は、この正規表現を使用することを意味する。しかし@samp{[@dots{}]}、@samp{*}@samp{+}、@samp{?}のような構成要素内のスペースは、@code{search-spaces-regexp}の影響を受けない。

この変数はすべての正規表現検索、およびマッチ構成要素に影響するので、コードの可能な限り狭い範囲にたいして、一時的にバインドするべきである。
@end defvar

@node POSIX Regexps
@section POSIX Regular Expression Searching

@cindex backtracking and POSIX regular expressions
  通常の正規表現関数は、@samp{\|}や繰り返しの構成要素を処理するために必要なときだけバックトラッキングを行いますが、@emph{何らか}のマッチが見つかるまでの間だけ、これを継続します。そして成功した後に、見つかった最初のマッチを報告します。

  このセクションでは、正規表現にたいしてPOSIX標準で指定された完全なバックトラッキングを処理する、他の検索関数を説明します。これらはPOSIXが要求する最長マッチを報告できるように、すべての可能なマッチを試み、すべてのマッチが見つかるまでバックトラッキングを継続します。これは非常に低速なので、本当に最長マッチが必要なときだけ、これらの関数を使用してください。

  POSIXの検索およびマッチ関数は、非欲張りな繰り返し演算子(@ref{Regexp Special,
non-greedy}を参照)を正しくサポートしません。これはPOSIXのバックトラッキングが、非欲張りな繰り返しのセマンチックと競合するからです。

@deffn Command posix-search-forward regexp &optional limit noerror repeat
これは@code{re-search-forward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する、完全なバックトラッキングを行う点が▼異なる。
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror repeat
これは@code{re-search-backward}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する、完全なバックトラッキングを行う点が異なる。
@end deffn

@defun posix-looking-at regexp
これは@code{looking-at}と似ているが、正規表現マッチングにたいしてPOSIX標準が指定する、完全なバックトラッキングを行う。
@end defun

@defun posix-string-match regexp string &optional start
これは@code{string-match}と似ているが、正規表現にたいしてPOSIX標準が指定する、完全なバックトラッキングを行う。
@end defun

@node Match Data
@section The Match Data
@cindex match data

  Emacsは、検索の間に見つかったテキスト片の開始と終了の位置を追跡しています。これは@dfn{マッチデータ(match
data)}と呼ばれます。このマッチデータのおかげで、メールメッセージ内のデータのような複雑なパターンを検索した後、そのパターンの制御下でマッチ部分を抽出できるのです。

  マッチデータには通常、もっとも最近の検索だけが記述されるので、後で参照したい検索と、そのマッチデータの使用の間に、誤って別の検索を行わないように、注意しなければなりません。誤って別の検索を避けるのが不可能な場合は、マッチデータの上書きを防ぐために、その前後でマッチデータの保存とリストアを行わなければなりません。

  上書きを行わないと明記されていない限り、すべての関数は上書きを許されていることに注意してください。結果としてバックグラウンド(@ref{Timers}および@ref{Idle
Timers}を参照されたい)で暗黙に実行される関数は、おそらく明示的にマッチデータの保存とリストアを行うべきでしょう。

@menu
* Replacing Match::          マッチされた部分文字列の置換。
* Simple Match Data::        特定の部分式開始箇所のような、マッチデータの単一アイテムへのアクセス。
* Entire Match Data::        リストとしてマッチデータ全体に一度にアクセスする。
* Saving Match Data::        マッチデータの保存とリストア。
@end menu

@node Replacing Match
@subsection Replacing the Text that Matched
@cindex replace matched text

  This function replaces all or part of the text matched by the last search.
It works by means of the match data.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
This function performs a replacement operation on a buffer or string.

If you did the last search in a buffer, you should omit the @var{string}
argument or specify @code{nil} for it, and make sure that the current buffer
is the one in which you performed the last search.  Then this function edits
the buffer, replacing the matched text with @var{replacement}.  It leaves
point at the end of the replacement text.

If you performed the last search on a string, pass the same string as
@var{string}.  Then this function returns a new string, in which the matched
text is replaced by @var{replacement}.

If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the
replacement text without case conversion; otherwise, it converts the
replacement text depending upon the capitalization of the text to be
replaced.  If the original text is all upper case, this converts the
replacement text to upper case.  If all words of the original text are
capitalized, this capitalizes all the words of the replacement text.  If all
the words are one-letter and they are all upper case, they are treated as
capitalized words rather than all-upper-case words.

If @var{literal} is non-@code{nil}, then @var{replacement} is inserted
exactly as it is, the only alterations being case changes as needed.  If it
is @code{nil} (the default), then the character @samp{\} is treated
specially.  If a @samp{\} appears in @var{replacement}, then it must be part
of one of the following sequences:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
This stands for the entire text being replaced.

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}} in replacement
This stands for the text that matched the @var{n}th subexpression in the
original regexp.  Subexpressions are those expressions grouped inside
@samp{\(@dots{}\)}.  If the @var{n}th subexpression never matched, an empty
string is substituted.

@item @samp{\\}
@cindex @samp{\} in replacement
This stands for a single @samp{\} in the replacement text.

@item @samp{\?}
This stands for itself (for compatibility with @code{replace-regexp} and
related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual}).
@end table

@noindent
Any other character following @samp{\} signals an error.

The substitutions performed by @samp{\&} and @samp{\@var{n}} occur after
case conversion, if any.  Therefore, the strings they substitute are never
case-converted.

If @var{subexp} is non-@code{nil}, that says to replace just subexpression
number @var{subexp} of the regexp that was matched, not the entire match.
For example, after matching @samp{foo \(ba*r\)}, calling
@code{replace-match} with 1 as @var{subexp} means to replace just the text
that matched @samp{\(ba*r\)}.
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
This function returns the text that would be inserted into the buffer by
@code{replace-match}, but without modifying the buffer.  It is useful if you
want to present the user with actual replacement result, with constructs
like @samp{\@var{n}} or @samp{\&} substituted with matched groups.
Arguments @var{replacement} and optional @var{fixedcase}, @var{literal},
@var{string} and @var{subexp} have the same meaning as for
@code{replace-match}.
@end defun

@node Simple Match Data
@subsection Simple Match Data Access

  This section explains how to use the match data to find out what was matched
by the last search or match operation, if it succeeded.

  You can ask about the entire matching text, or about a particular
parenthetical subexpression of a regular expression.  The @var{count}
argument in the functions below specifies which.  If @var{count} is zero,
you are asking about the entire match.  If @var{count} is positive, it
specifies which subexpression you want.

  Recall that the subexpressions of a regular expression are those expressions
grouped with escaped parentheses, @samp{\(@dots{}\)}.  The @var{count}th
subexpression is found by counting occurrences of @samp{\(} from the
beginning of the whole regular expression.  The first subexpression is
numbered 1, the second 2, and so on.  Only regular expressions can have
subexpressions---after a simple string search, the only information
available is about the entire match.

  Every successful search sets the match data.  Therefore, you should query
the match data immediately after searching, before calling any other
function that might perform another search.  Alternatively, you may save and
restore the match data (@pxref{Saving Match Data}) around the call to
functions that could perform another search.  Or use the functions that
explicitly do not modify the match data; e.g., @code{string-match-p}.

@c This is an old comment and presumably there is no prospect of this
@c changing now.  But still the advice stands.
  A search which fails may or may not alter the match data.  In the current
implementation, it does not, but we may change it in the future.  Don't try
to rely on the value of the match data after a failing search.

@defun match-string count &optional in-string
This function returns, as a string, the text matched in the last search or
match operation.  It returns the entire text if @var{count} is zero, or just
the portion corresponding to the @var{count}th parenthetical subexpression,
if @var{count} is positive.

If the last such operation was done against a string with
@code{string-match}, then you should pass the same string as the argument
@var{in-string}.  After a buffer search or match, you should omit
@var{in-string} or pass @code{nil} for it; but you should make sure that the
current buffer when you call @code{match-string} is the one in which you did
the searching or matching.  Failure to follow this advice will lead to
incorrect results.

The value is @code{nil} if @var{count} is out of range, or for a
subexpression inside a @samp{\|} alternative that wasn't used or a
repetition that repeated zero times.
@end defun

@defun match-string-no-properties count &optional in-string
This function is like @code{match-string} except that the result has no text
properties.
@end defun

@defun match-beginning count
This function returns the position of the start of the text matched by the
last regular expression searched for, or a subexpression of it.

If @var{count} is zero, then the value is the position of the start of the
entire match.  Otherwise, @var{count} specifies a subexpression in the
regular expression, and the value of the function is the starting position
of the match for that subexpression.

The value is @code{nil} for a subexpression inside a @samp{\|} alternative
that wasn't used or a repetition that repeated zero times.
@end defun

@defun match-end count
This function is like @code{match-beginning} except that it returns the
position of the end of the match, rather than the position of the beginning.
@end defun

  Here is an example of using the match data, with a comment showing the
positions within the text:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{The beginning of the match}
     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}
@end group

@group
(match-beginning 2)       ; @r{The beginning of the match}
     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}
@end group

@group
(match-end 1)             ; @r{The end of the match}
     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}

(match-end 2)             ; @r{The end of the match}
     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}
@end group
@end example

  Here is another example.  Point is initially located at the beginning of the
line.  Searching moves point to between the space and the word @samp{in}.
The beginning of the entire match is at the 9th character of the buffer
(@samp{T}), and the beginning of the match for the first subexpression is at
the 13th character (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(In this case, the index returned is a buffer position; the first character
of the buffer counts as 1.)

@node Entire Match Data
@subsection Accessing the Entire Match Data

  The functions @code{match-data} and @code{set-match-data} read or write the
entire match data, all at once.

@defun match-data &optional integers reuse reseat
This function returns a list of positions (markers or integers) that record
all the information on the text that the last search matched.  Element zero
is the position of the beginning of the match for the whole expression;
element one is the position of the end of the match for the expression.  The
next two elements are the positions of the beginning and end of the match
for the first subexpression, and so on.  In general, element
@ifnottex
number 2@var{n}
@end ifnottex
@tex
number {\mathsurround=0pt $2n$}
@end tex
corresponds to @code{(match-beginning @var{n})}; and element
@ifnottex
number 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
corresponds to @code{(match-end @var{n})}.

Normally all the elements are markers or @code{nil}, but if @var{integers}
is non-@code{nil}, that means to use integers instead of markers.  (In that
case, the buffer itself is appended as an additional element at the end of
the list, to facilitate complete restoration of the match data.)  If the
last match was done on a string with @code{string-match}, then integers are
always used, since markers can't point into a string.

If @var{reuse} is non-@code{nil}, it should be a list.  In that case,
@code{match-data} stores the match data in @var{reuse}.  That is,
@var{reuse} is destructively modified.  @var{reuse} does not need to have
the right length.  If it is not long enough to contain the match data, it is
extended.  If it is too long, the length of @var{reuse} stays the same, but
the elements that were not used are set to @code{nil}.  The purpose of this
feature is to reduce the need for garbage collection.

If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are
reseated to point to nowhere.

As always, there must be no possibility of intervening searches between the
call to a search function and the call to @code{match-data} that is intended
to access the match data for that search.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
This function sets the match data from the elements of @var{match-list},
which should be a list that was the value of a previous call to
@code{match-data}.  (More precisely, anything that has the same format will
work.)

If @var{match-list} refers to a buffer that doesn't exist, you don't get an
error; that sets the match data in a meaningless but harmless way.

If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list
are reseated to point to nowhere.

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Saving and Restoring the Match Data

  When you call a function that may search, you may need to save and restore
the match data around that call, if you want to preserve the match data from
an earlier search for later use.  Here is an example that shows the problem
that arises if you fail to save the match data:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} does more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

  You can save and restore the match data with @code{save-match-data}:

@defmac save-match-data body@dots{}
This macro executes @var{body}, saving and restoring the match data around
it.  The return value is the value of the last form in @var{body}.
@end defmac

  You could use @code{set-match-data} together with @code{match-data} to
imitate the effect of the special form @code{save-match-data}.  Here is how:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok to change the original match data.}
    (set-match-data data)))
@end group
@end example

  Emacs automatically saves and restores the match data when it runs process
filter functions (@pxref{Filter Functions}) and process sentinels
(@pxref{Sentinels}).

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
(defun restore-match-data (data)
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section Search and Replace
@cindex replacement after search
@cindex searching and replacing

  If you want to find all matches for a regexp in part of the buffer, and
replace them, the best way is to write an explicit loop using
@code{re-search-forward} and @code{replace-match}, like this:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, for a description
of @code{replace-match}.

  However, replacing matches in a string is more complex, especially if you
want to do it efficiently.  So Emacs provides a function to do this.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
This function copies @var{string} and searches it for matches for
@var{regexp}, and replaces them with @var{rep}.  It returns the modified
copy.  If @var{start} is non-@code{nil}, the search for matches starts at
that index in @var{string}, so matches starting before that index are not
changed.

This function uses @code{replace-match} to do the replacement, and it passes
the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along
to @code{replace-match}.

Instead of a string, @var{rep} can be a function.  In that case,
@code{replace-regexp-in-string} calls @var{rep} for each match, passing the
text of the match as its sole argument.  It collects the value @var{rep}
returns and passes that to @code{replace-match} as the replacement string.
The match data at this point are the result of matching @var{regexp} against
a substring of @var{string}.
@end defun

  If you want to write a command along the lines of @code{query-replace}, you
can use @code{perform-replace} to do the work.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end
This function is the guts of @code{query-replace} and related commands.  It
searches for occurrences of @var{from-string} in the text between positions
@var{start} and @var{end} and replaces some or all of them.  If @var{start}
is @code{nil} (or omitted), point is used instead, and the end of the
buffer's accessible portion is used for @var{end}.

If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise,
it asks the user what to do about each one.

If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered
a regular expression; otherwise, it must match literally.  If
@var{delimited-flag} is non-@code{nil}, then only replacements surrounded by
word boundaries are considered.

The argument @var{replacements} specifies what to replace occurrences with.
If it is a string, that string is used.  It can also be a list of strings,
to be used in cyclic order.

If @var{replacements} is a cons cell, @w{@code{(@var{function}
. @var{data})}}, this means to call @var{function} after each match to get
the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it
specifies how many times to use each of the strings in the
@var{replacements} list before advancing cyclically to the next one.

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it
uses the @var{replacements} without altering their case.

Normally, the keymap @code{query-replace-map} defines the possible user
responses for queries.  The argument @var{map}, if non-@code{nil}, specifies
a keymap to use instead of @code{query-replace-map}.

This function uses one of two functions to search for the next occurrence of
@var{from-string}.  These functions are specified by the values of two
variables: @code{replace-re-search-function} and
@code{replace-search-function}.  The former is called when the argument
@var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}.
@end defun

@defvar query-replace-map
This variable holds a special keymap that defines the valid user responses
for @code{perform-replace} and the commands that use it, as well as
@code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:

@itemize @bullet
@item
The ``key bindings'' are not commands, just symbols that are meaningful to
the functions that use this map.

@item
Prefix keys are not supported; each key binding must be for a single-event
key sequence.  This is because the functions don't use
@code{read-key-sequence} to get the input; instead, they read a single event
and look it up ``by hand''.
@end itemize
@end defvar

Here are the meaningful ``bindings'' for @code{query-replace-map}.  Several
of them are meaningful only for @code{query-replace} and friends.

@table @code
@item act
Do take the action being considered---in other words, ``yes''.

@item skip
Do not take action for this question---in other words, ``no''.

@item exit
Answer this question ``no'', and give up on the entire series of questions,
assuming that the answers will be ``no''.

@item exit-prefix
Like @code{exit}, but add the key that was pressed to
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
Answer this question ``yes'', and give up on the entire series of questions,
assuming that subsequent answers will be ``no''.

@item act-and-show
Answer this question ``yes'', but show the results---don't advance yet to
the next question.

@item automatic
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction.

@item backup
Move back to the previous place that a question was asked about.

@item edit
Enter a recursive edit to deal with this question---instead of any other
action that would normally be taken.

@item edit-replacement
Edit the replacement for this question in the minibuffer.

@item delete-and-edit
Delete the text being considered, then enter a recursive edit to replace it.

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
Perform the specified window scroll operation, then ask the same question
again.  Only @code{y-or-n-p} and related functions use this answer.

@item quit
Perform a quit right away.  Only @code{y-or-n-p} and related functions use
this answer.

@item help
Display some help, then ask again.
@end table

@defvar multi-query-replace-map
This variable holds a keymap that extends @code{query-replace-map} by
providing additional keybindings that are useful in multi-buffer
replacements.  The additional ``bindings'' are:

@table @code
@item automatic-all
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction, for all remaining buffers.

@item exit-current
Answer this question ``no'', and give up on the entire series of questions
for the current buffer.  Continue to the next buffer in the sequence.
@end table
@end defvar

@defvar replace-search-function
This variable specifies a function that @code{perform-replace} calls to
search for the next string to replace.  Its default value is
@code{search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{search-forward} (@pxref{String
Search}).
@end defvar

@defvar replace-re-search-function
This variable specifies a function that @code{perform-replace} calls to
search for the next regexp to replace.  Its default value is
@code{re-search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp
Search}).
@end defvar

@node Standard Regexps
@section Standard Regular Expressions Used in Editing
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  This section describes some variables that hold regular expressions used for
certain purposes in editing:

@defopt page-delimiter
This is the regular expression describing line-beginnings that separate
pages.  The default value is @code{"^\014"} (i.e., @code{"^^L"} or
@code{"^\C-l"}); this matches a line that starts with a formfeed character.
@end defopt

  The following two regular expressions should @emph{not} assume the match
always starts at the beginning of a line; they should not use @samp{^} to
anchor the match.  Most often, the paragraph commands do check for a match
only at the beginning of a line, which means that @samp{^} would be
superfluous.  When there is a nonzero left margin, they accept matches that
start after the left margin.  In that case, a @samp{^} would be incorrect.
However, a @samp{^} is harmless in modes where a left margin is never used.

@defopt paragraph-separate
This is the regular expression for recognizing the beginning of a line that
separates paragraphs.  (If you change this, you may have to change
@code{paragraph-start} also.)  The default value is @w{@code{"[@ \t\f]*$"}},
which matches a line that consists entirely of spaces, tabs, and form feeds
(after its left margin).
@end defopt

@defopt paragraph-start
This is the regular expression for recognizing the beginning of a line that
starts @emph{or} separates paragraphs.  The default value is
@w{@code{"\f\\|[ \t]*$"}}, which matches a line containing only whitespace
or starting with a form feed (after its left margin).
@end defopt

@defopt sentence-end
If non-@code{nil}, the value should be a regular expression describing the
end of a sentence, including the whitespace following the sentence.  (All
paragraph boundaries also end sentences, regardless.)

If the value is @code{nil}, as it is by default, then the function
@code{sentence-end} constructs the regexp.  That is why you should always
call the function @code{sentence-end} to obtain the regexp to be used to
recognize the end of a sentence.
@end defopt

@defun sentence-end
This function returns the value of the variable @code{sentence-end}, if
non-@code{nil}.  Otherwise it returns a default value based on the values of
the variables @code{sentence-end-double-space} (@pxref{Definition of
sentence-end-double-space}), @code{sentence-end-without-period}, and
@code{sentence-end-without-space}.
@end defun
