@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter Searching and Matching
@cindex searching

  GNU Emacsは、バッファーから指定されたテキストを検索するために、２つの手段を提供します。それは文字列の正確一致検索(exact string
search)と、正規表現検索(regular expression
search)です。正規表現検索の後、マッチしたテキストが正規表現壱阡にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために、@dfn{マッチデータ(match
data)}を調べることができます。

@menu
* String Search::            正確なマッチの検索。
* Searching and Case::       case-independentまたはcase-significantな検索。
* Regular Expressions::      文字列クラスの記述。
* Regexp Search::            regexpにたいするマッチの検索。
* POSIX Regexps::            最長マッチにたいするPOSIXスタイルのマッチ。
* Match Data::               文字列またはregexp検索後に、テキストがマッチした部分を見つける。
* Search and Replace::       検索と置換を繰り返すコマンド。
* Standard Regexps::         センテンスやページ等を探すために有用なregexp。
@end menu

  @samp{skip-chars@dots{}}関連の関数も、ある種の検索を行います。@ref{Skipping
Characters}を参照してください。文字プロパティ内の変更を検索するには、@ref{Property Search}を参照してください。

@node String Search
@section Searching for Strings
@cindex string search

  バッファー内のテキストを検索するための、プリミティブ関数が存在します。これらはプログラム内での使用を意図したものですが、インタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出した場合は、検索文字列の入力を求め、引数@var{limit}および@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は、@ref{Search,,
Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。

  以下の検索関数は、バッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに、検索文字列を変換します。@ref{Text
Representations}を参照してください。

@deffn Command search-forward string &optional limit noerror repeat
この関数は、@var{string}にたいする正確なマッチを、ポイントから前方に検索する。成功したら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は、@var{noerror}(以下参照)に依存する。

以下の例では、ポイントは最初は行の先頭にある。その後の@code{(search-forward
"fox")}により、ポイントは@samp{fox}の最後の文字の後に移動する:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。

@kindex search-failed
@c I see no prospect of this ever changing, and frankly the current
@c behavior seems better, so there seems no need to mention this.
検索失敗時に何が起こるかは、@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら、@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら、@code{search-forward}は@code{nil}をリターンして、何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して、@code{nil}をリターンする。
@ignore
(It would be more consistent now to return the new position of point
in that case, but some existing programs may depend on a value of
@code{nil}.)
@end ignore

引数@var{noerror}は、マッチに失敗した有効な検索だけに影響する。無効な引数は、@var{noerror}とは無関係にエラーとなる。

@var{repeat}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{repeat}が負の数-@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。
@end deffn

@deffn Command search-backward string &optional limit noerror repeat
この関数は、ポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索では、ポイントはマッチの先頭に残される。
@end deffn

@deffn Command word-search-forward string &optional limit noerror repeat
この関数は、ポイントから前方に@var{string}にたいする``単語(word)''のマッチを検索する。マッチが見つかったら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。

単語マッチは@var{string}を単語のシーケンスとみなし、それらを分ける句読点は無視する。これはバッファーから、同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならないが(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)、句読点やスペース等の細部は無視される(@samp{ball
boy}を検索すると@samp{ball.  Boy!}にマッチする)。

以下の例では、ポイントは最初バッファー先頭にある。検索により、ポイントは@samp{y}と@samp{!}の間に残される。

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチは、その位置を超えてはならない。

@var{noerror}が@code{nil}なら、@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに、@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して、@code{nil}をリターンする。

@var{repeat}が非@code{nil}なら、検索はその回数繰り返される。ポイントは最後のマッチの終端に置かれる。

@findex word-search-regexp
内部的には、@code{word-search-forward}と関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、関数@code{word-search-regexp}を使用する。
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror repeat
このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball
boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。
@end deffn

@deffn Command word-search-backward string &optional limit noerror repeat
この関数は、ポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して、通常はマッチの先頭にポイントを残す点が異なる。
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror repeat
このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。
@end deffn

@node Searching and Case
@section Searching and Case
@cindex searching and case

  デフォルトのEmacs検索では、検索するテキストの大文字と小文字は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。

  この機能が望ましくなければ、変数@code{case-fold-search}を@code{nil}にセットしてください。その場合、すべての文字は大文字小文字の違いを含めて、正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更は、カレントバッファーだけに影響を与えます(@ref{Intro
to
Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは、@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。

  ユーザーレベルのインクリメンタル検索機能では、大文字小文字の区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索は大文字小文字の違いを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索は大文字小文字の違いを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental
Search,,, emacs, The GNU Emacs Manual}を参照してください。

@defopt case-fold-search
このバッファーローカル変数は、検索が大文字小文字の違いを無視するべきかどうかを決定する。この変数が@code{nil}なら、検索は大文字小文字の違いを無視しない。それ以外(とデフォルト)では、大文字小文字のかも無視する。
@end defopt

@defopt case-replace
この変数は、高レベルの置換関数が大文字小文字の違いを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は、置換されるテキストに応じて、置換テキストの大文字小文字を変換することを意味する。

この変数は、それを関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing
Match}を参照のこと。
@end defopt

@node Regular Expressions
@section Regular Expressions
@cindex regular expression
@cindex regexp

  @dfn{正規表現(regular
expression)}、略して@dfn{regexp}は、文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索は、とても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。

@findex re-builder
@cindex regular expressions, developing
  正規表現を対話的に開発するために、@kbd{M-x
re-builder}コマンドを使用できます。このコマンドは、別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともに、ターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。

@menu
* Syntax of Regexps::        正規表現の記述ルール。
* Regexp Example::           正規表現構文の説明。
* Regexp Functions::         正規表現を操作する関数。
@end menu

@node Syntax of Regexps
@subsection Syntax of Regular Expressions
@cindex regexp syntax
@cindex syntax of regular expressions

  正規表現は、少数の文字が特別な構成要素で、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字は、その文字自身だけにマッチする、シンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\}です。将来、新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合、@samp{]}はスペシャル文字です。文字候補の間では、@samp{-}はスペシャル文字です。@samp{[:}と、対応する@samp{:]}は、文字候補内の文字クラスです。正規表現内に出現する他の文字は、@samp{\}が前置されていない限り、通常の文字です。

  たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチし、他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に、@samp{o}は@samp{o}だけにマッチします。

  任意の2つの正規表現@var{a}と@var{b}は、結合することができます。結合した結果は、文字列の先頭からある長さの文字列が@var{a}にマッチし、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。

  単純な例として、文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために、正規表現@samp{f}と@samp{o}を結合できます。

@menu
* Regexp Special::           正規表現内のスペシャル文字。
* Char Classes::             正規表現内で使用される文字クラス。
* Regexp Backslash::         正規表現内のバックスラッシュシーケンス。
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions
@cindex regexp, special characters in

  以下は、正規表現内で特別な文字のリストです:

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
これは、改行を除く1文字にマッチする。結合を使用して、@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。

@item @samp{*}
@cindex @samp{*} in regexp
これは、それ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する、後置演算子である。したがって、@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合もマッチする)。

@samp{*}は常に前置された表現の、@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり、@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。

@cindex backtracking and regular expressions
マッチを行う処理は構成要素@samp{*}を、マッチングにより即座に、見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら、残りのパターンのマッチが可能になるかもしれないという期待のもと、@samp{*}の変更された構成のうちいくつかのマッチを破棄することによる、バックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}であり、マッチ対象に残されているのは@samp{r}だけなので、この試みは失敗する。@samp{a*}にたいする次の代替策は、2つの@samp{a}だけへのマッチである。この選択では、残りのregexpのマッチは成功する。

@strong{警告:}
ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合は、無期限な長時間の実行となり得る。たとえば文字列@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}にたいして正規表現@samp{\(x+y*\)*a}のマッチを試みると、それが最終的に失敗するまでに数時間を要し得る。Emacsはその試みのいずれも機能しないと結論する前に、@samp{x}のグループ家のそれぞれを試みなければならない。さらに悪いことに、@samp{\(x*\)*}は無数の方法でnull文字列にマッチ可能なので、これは無限ループを引き起こす。これらの問題を避けるには、ネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial
explosion)が発生しないことを確実にするために注意深くチェックすること。

@item @samp{+}
@cindex @samp{+} in regexp
これは@samp{*}のような後置演算子だが、これは前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが、文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。

@item @samp{?}
@cindex @samp{?} in regexp
これは@samp{*}のような後置演算子だが、これは前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。申@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが、他にはマッチしない。

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
演算子
@samp{*}、@samp{+}、@samp{?}には``非欲張り(non-greedy)''な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。

たとえば正規表現@samp{c[ad]*a}が文字列@samp{cdaaada}に適用されると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d}である)。

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
これは@samp{[}で始まり@samp{]}で終端される@dfn{文字候補(character
alternative)}である。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字である。

したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけから構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。

開始文字と終了文字の間に@samp{-}を記述することにより、文字候補内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。

@c This wasn't obvious to me, since, e.g., the grep manual "Character
@c Classes and Bracket Expressions" specifically notes the opposite
@c behavior.  But by experiment Emacs seems unaffected by LC_COLLATE
@c in this regard.
@code{case-fold-search}が非@code{nil}なら、@samp{[a-z]}は大文字アルファベットにもマッチする。@samp{[a-z]}のような範囲は、そのlocaleの照合順に影響されず、常に@acronym{ASCII}順のシーケンスを表すことに注意。

さらに通常のregexpスペシャル文字は文字候補内では特別ではないことにも注意されたい。文字候補内部では@samp{]}、@samp{-}、@samp{^}という完全に異なる文字セットが特別に扱われる。

文字候補内に@samp{]}を含めるには、それを最初の文字にしなければならない。たとえば@samp{[]a]}は、@samp{]}と@samp{a}にマッチする。@samp{-}を含めるには、文字候補の最初または最後の文字として@samp{-}を記述するか、範囲の後に置くこと。つまり@samp{[]-]}は@samp{]}と@samp{-}の両方にマッチする。(以下で説明するように、ここでは@samp{\}は特別ではないので、文字候補内に@samp{]}を含めるために@samp{\]}は使用できない)。

文字候補内に@samp{^}を含めるには、先頭以外のいずれかの場所に置くこと。

@c What if it starts with a multibyte and ends with a unibyte?
@c That doesn't seem to match anything...?
ある範囲がユニバイト文字@var{c}で始まり、マルチバイト文字@var{c2}でお話場合、その範囲は2つの部分に分割される。1つはユニバイト文字@samp{@var{c}..?\377}、もう1つはマルチバイト文字@samp{@var{c1}..@var{c2}}である。ここで@var{c1}は@var{c2}が属する文字セットの最初の文字である。

文字候補には、名前付き文字クラスも指定できる(@ref{Char
Classes}を参照)。これはPOSIXの機能である。たとえば@samp{[[:ascii:]]}は、任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので、後者は実際は実現可能ではない。

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^}は@dfn{補完文字候補(complemented character
alternative)}を開始する。これは、指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はアルファベットと数日前@emph{以外}の、すべての文字にマッチする。

@samp{^}は文字クラス内では、先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(別の言い方をすると@samp{-}や@samp{]}は、ここでは特別ではない)。

マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは、対照的である。

文字候補のように、名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は、任意の非@acronym{ASCII}文字にマッチする。@ref{Char
Classes}を参照のこと。

@item @samp{^}
@cindex beginning of line in regexp
バッファーのマッチング時、@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチは、すべて失敗する。つまり@samp{^foo}は、行の先頭に出現する@samp{foo}にマッチする。

バッファーではなく文字列とマッチする際は、@samp{^}は文字列の先頭、または改行文字の後にマッチする。

歴史的な互換性という理由により、@samp{^}は正規表現の先頭、または@samp{\(}、@samp{\(?:}、@samp{\|}の後だけで使用できる。

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は、行末にある1つ以上の@samp{x}からなる文字列にマッチする。

バッファーではなく文字列とマッチする際は、@samp{$}は文字列の終端、または改行文字の前にマッチする。

歴史的な互換性という理由により、@samp{$}は正規表現の先頭、または@samp{\(}、@samp{\(?:}、@samp{\|}の前だけで使用できる。

@item @samp{\}
@cindex @samp{\} in regexp
これは2つの機能をもつ。スペシャル文字(@samp{\}を含む)のクォートと、追加のスペシャル文字の導入である。

@samp{\}はスペシャル文字をクォートするので、@samp{\$}は@samp{$}、@samp{\[}は@samp{[}だけにマッチする正規表現といったようになる。

@samp{\}はLisp文字列(@ref{String Type}を参照)の入力構文(read
syntax)内でも特別な意味をもち、@samp{\}でクォートしなければならないことに注意。たとえば文字@samp{\}にマッチする正規表現は@samp{\\}である。文字@samp{\\}を含むLisp文字列を記述するには、別の@samp{\\}で@samp{\\}をクォートすることをLisp構文は要求する。したがって@samp{\}にマッチする正規表現にたいする入力構文は、@code{"\\\\"}となる。
@end table

@strong{注意してください:}
歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合は、通常の文字として扱われます。たとえば@samp{*foo}は、@samp{*}が作用可能な前置された表現がないので、通常の@samp{*}として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようと、スペシャル文字はすべてクォートしてください。

文字候補内で@samp{\}は何ら特別ではないので、@samp{-}や@samp{]}の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする@samp{[^\]}(Lisp文字列構文では@code{"[^\\]"})内でのように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを前置する正当性があるので、それほど何も明解にはしないでしょう。

実際には、正規表現内に出現する@samp{]}は文字候補に近接しており、それ故にほとんどがスペシャル文字です。しかしリテラルの@samp{[}および@samp{]}の複雑なパターンにたいして、マッチを試みることも時にはあるかもしれません。そのような状況では、文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析するのが必要なときもあるかもしれません。たとえば@samp{[^][]]}は、補完文字候補@samp{[^][]}(角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。

厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後は文字候補になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除き、特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  以下は文字候補内で使用できるクラスと、その意味についてのテーブルです:

@table @samp
@item [:ascii:]
これは任意の@acronym{ASCII}文字(コード0 -- 127)にマッチする。
@item [:alnum:]
これは任意のアルファベットと数字にマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
@item [:alpha:]
これは任意のアルファベットにマッチする(現在のところマルチバイト文字にたいしては、単語構文をもつものすべてにマッチする)。
@item [:blank:]
これはスペースとタブだけにマッチする。
@item [:cntrl:]
これは@acronym{ASCII}制御文字にマッチする。
@item [:digit:]
これは@samp{0}から@samp{9}までにマッチする。つまり@samp{[-+[:digit:]]}は@samp{+}と@samp{-}同様、任意の数にマッチする。
@item [:graph:]
これはグラフィック文字(@acronym{ASCII}制御文字、スペース、delete文字を除くすべての文字を意味する。This matches
graphic characters---everything except  control characters, space, and the
character.
@item [:lower:]
これはカレントの大文字小文字テーブル(@ref{Case
Tables}を参照)で小文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら、これは大文字にもマッチする。
@item [:multibyte:]
これは任意のマルチバイト文字にマッチする(@ref{Text Representations}を参照)。
@item [:nonascii:]
これは非@acronym{ASCII}文字にマッチする。
@item [:print:]
これはプリント文字(@acronym{ASCII}制御文字とdelete文字以外のすべての文字)にマッチする。
@item [:punct:]
これは任意の句読点文字(punctuation
character)にマッチする(現在のところマルチバイト文字にたいしては、単語構文以外のすべてにマッチする)。
@item [:space:]
これは空白文字構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。
@item [:unibyte:]
これは任意のユニバイト文字(@ref{Text Representations}を参照)にマッチする。
@item [:upper:]
これはカレントの大文字小文字テーブル(@ref{Case
Tables}を参照)で大文字と判断される文字すべてにマッチする。@code{case-fold-search}が非@code{nil}なら、これは小文字にもマッチする。
@item [:word:]
これは単語構文(@ref{Syntax Class Table}を参照)をもつ任意の文字にマッチする。
@item [:xdigit:]
これは16進数の数字@samp{0}から@samp{9}、@samp{a}から@samp{f}と@samp{A}から@samp{F}にマッチする。
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions
@cindex backslash in regular expressions

  For the most part, @samp{\} followed by any character matches only that
character.  However, there are several exceptions: certain sequences
starting with @samp{\} that have special meanings.  Here is a table of the
special @samp{\} constructs.

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
specifies an alternative.  Two regular expressions @var{a} and @var{b} with
@samp{\|} in between form an expression that matches anything that either
@var{a} or @var{b} matches.

Thus, @samp{foo\|bar} matches either @samp{foo} or @samp{bar} but no other
string.

@samp{\|} applies to the largest possible surrounding expressions.  Only a
surrounding @samp{\( @dots{} \)} grouping can limit the grouping power of
@samp{\|}.

If you need full backtracking capability to handle multiple uses of
@samp{\|}, use the POSIX regular expression functions (@pxref{POSIX
Regexps}).

@item \@{@var{m}\@}
is a postfix operator that repeats the previous pattern exactly @var{m}
times.  Thus, @samp{x\@{5\@}} matches the string @samp{xxxxx} and nothing
else.  @samp{c[ad]\@{3\@}r} matches string such as @samp{caaar},
@samp{cdddr}, @samp{cadar}, and so on.

@item \@{@var{m},@var{n}\@}
is a more general postfix operator that specifies repetition with a minimum
of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted,
the minimum is 0; if @var{n} is omitted, there is no maximum.

For example, @samp{c[ad]\@{1,2\@}r} matches the strings @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and
nothing else.@* @samp{\@{0,1\@}} or @samp{\@{,1\@}} is equivalent to
@samp{?}.@* @samp{\@{0,\@}} or @samp{\@{,\@}} is equivalent to @samp{*}.@*
@samp{\@{1,\@}} is equivalent to @samp{+}.

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
is a grouping construct that serves three purposes:

@enumerate
@item
To enclose a set of @samp{\|} alternatives for other operations.  Thus, the
regular expression @samp{\(foo\|bar\)x} matches either @samp{foox} or
@samp{barx}.

@item
To enclose a complicated expression for the postfix operators @samp{*},
@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\(na\)*} matches
@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any
number (zero or more) of @samp{na} strings.

@item
To record a matched substring for future reference with @samp{\@var{digit}}
(see below).
@end enumerate

This last application is not a consequence of the idea of a parenthetical
grouping; it is a separate feature that was assigned as a second meaning to
the same @samp{\( @dots{} \)} construct because, in practice, there was
usually no conflict between the two meanings.  But occasionally there is a
conflict, and that led to the introduction of shy groups.

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
is the @dfn{shy group} construct.  A shy group serves the first two purposes
of an ordinary group (controlling the nesting of other operators), but it
does not get a number, so you cannot refer back to its value with
@samp{\@var{digit}}.  Shy groups are particularly useful for
mechanically-constructed regular expressions, because they can be added
automatically without altering the numbering of ordinary, non-shy groups.

Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}.

@item \(?@var{num}: @dots{} \)
is the @dfn{explicitly numbered group} construct.  Normal groups get their
number implicitly, based on their position, which can be inconvenient.  This
construct allows you to force a particular group number.  There is no
particular restriction on the numbering, e.g., you can have several groups
with the same number in which case the last one to match (i.e., the
rightmost match) will win.  Implicitly numbered groups always get the
smallest integer larger than the one of any previous group.

@item \@var{digit}
matches the same text that matched the @var{digit}th occurrence of a
grouping (@samp{\( @dots{} \)}) construct.

In other words, after the end of a group, the matcher remembers the
beginning and end of the text matched by that group.  Later on in the
regular expression you can use @samp{\} followed by @var{digit} to match
that same text, whatever it may have been.

The strings matching the first nine grouping constructs appearing in the
entire regular expression passed to a search or matching function are
assigned numbers 1 through 9 in the order that the open parentheses appear
in the regular expression.  So you can use @samp{\1} through @samp{\9} to
refer to the text matched by the corresponding grouping constructs.

For example, @samp{\(.*\)\1} matches any newline-free string that is
composed of two identical halves.  The @samp{\(.*\)} matches the first half,
which may be anything, but the @samp{\1} that follows must match the same
exact text.

If a @samp{\( @dots{} \)} construct matches more than once (which can
happen, for instance, if it is followed by @samp{*}), only the last match is
recorded.

If a particular grouping construct in the regular expression was never
matched---for instance, if it appears inside of an alternative that wasn't
used, or inside of a repetition that repeated zero times---then the
corresponding @samp{\@var{digit}} construct never matches anything.  To use
an artificial example, @samp{\(foo\(b*\)\|lose\)\2} cannot match
@samp{lose}: the second alternative inside the larger group matches it, but
then @samp{\2} is undefined and can't match anything.  But it can match
@samp{foobb}, because the first alternative matches @samp{foob} and
@samp{\2} matches @samp{b}.

@item \w
@cindex @samp{\w} in regexp
matches any word-constituent character.  The editor syntax table determines
which characters these are.  @xref{Syntax Tables}.

@item \W
@cindex @samp{\W} in regexp
matches any character that is not a word constituent.

@item \s@var{code}
@cindex @samp{\s} in regexp
matches any character whose syntax is @var{code}.  Here @var{code} is a
character that represents a syntax code: thus, @samp{w} for word
constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.
To represent whitespace syntax, use either @samp{-} or a space character.
@xref{Syntax Class Table}, for a list of syntax codes and the characters
that stand for them.

@item \S@var{code}
@cindex @samp{\S} in regexp
matches any character whose syntax is not @var{code}.

@cindex category, regexp search for
@item \c@var{c}
matches any character whose category is @var{c}.  Here @var{c} is a
character that represents a category: thus, @samp{c} for Chinese characters
or @samp{g} for Greek characters in the standard category table.  You can
see the list of all the currently defined categories with @kbd{M-x
describe-categories @key{RET}}.  You can also define your own categories in
addition to the standard ones using the @code{define-category} function
(@pxref{Categories}).

@item \C@var{c}
matches any character whose category is not @var{c}.
@end table

  The following regular expression constructs match the empty string---that
is, they don't use up any characters---but whether they match depends on the
context.  For all, the beginning and end of the accessible portion of the
buffer are treated as if they were the actual beginning and end of the
buffer.

@table @samp
@item \`
@cindex @samp{\`} in regexp
matches the empty string, but only at the beginning of the buffer or string
being matched against.

@item \'
@cindex @samp{\'} in regexp
matches the empty string, but only at the end of the buffer or string being
matched against.

@item \=
@cindex @samp{\=} in regexp
matches the empty string, but only at point.  (This construct is not defined
when matching against a string.)

@item \b
@cindex @samp{\b} in regexp
matches the empty string, but only at the beginning or end of a word.  Thus,
@samp{\bfoo\b} matches any occurrence of @samp{foo} as a separate word.
@samp{\bballs?\b} matches @samp{ball} or @samp{balls} as a separate word.

@samp{\b} matches at the beginning or end of the buffer (or string)
regardless of what text appears next to it.

@item \B
@cindex @samp{\B} in regexp
matches the empty string, but @emph{not} at the beginning or end of a word,
nor at the beginning or end of the buffer (or string).

@item \<
@cindex @samp{\<} in regexp
matches the empty string, but only at the beginning of a word.  @samp{\<}
matches at the beginning of the buffer (or string) only if a
word-constituent character follows.

@item \>
@cindex @samp{\>} in regexp
matches the empty string, but only at the end of a word.  @samp{\>} matches
at the end of the buffer (or string) only if the contents end with a
word-constituent character.

@item \_<
@cindex @samp{\_<} in regexp
matches the empty string, but only at the beginning of a symbol.  A symbol
is a sequence of one or more word or symbol constituent characters.
@samp{\_<} matches at the beginning of the buffer (or string) only if a
symbol-constituent character follows.

@item \_>
@cindex @samp{\_>} in regexp
matches the empty string, but only at the end of a symbol.  @samp{\_>}
matches at the end of the buffer (or string) only if the contents end with a
symbol-constituent character.
@end table

@kindex invalid-regexp
  Not every string is a valid regular expression.  For example, a string that
ends inside a character alternative without a terminating @samp{]} is
invalid, and so is a string that ends with a single @samp{\}.  If an invalid
regular expression is passed to any of the search functions, an
@code{invalid-regexp} error is signaled.

@node Regexp Example
@subsection Complex Regexp Example

  Here is a complicated regexp which was formerly used by Emacs to recognize
the end of a sentence together with any whitespace that follows.  (Nowadays
Emacs uses a similar but more complex default regexp constructed by the
function @code{sentence-end}.  @xref{Standard Regexps}.)

  Below, we show first the regexp as a string in Lisp syntax (to distinguish
spaces from tab characters), and then the result of evaluating it.  The
string constant begins and ends with a double-quote.  @samp{\"} stands for a
double-quote as part of the string, @samp{\\} for a backslash as part of the
string, @samp{\t} for a tab and @samp{\n} for a newline.

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
In the output, tab and newline appear as themselves.

  This regular expression contains four parts in succession and can be
deciphered as follows:

@table @code
@item [.?!]
The first part of the pattern is a character alternative that matches any
one of three characters: period, question mark, and exclamation mark.  The
match must begin with one of these three characters.  (This is one point
where the new default regexp used by Emacs differs from the old.  The new
value also allows some non-@acronym{ASCII} characters that end a sentence
without any following whitespace.)

@item []\"')@}]*
The second part of the pattern matches any closing braces and quotation
marks, zero or more of them, that may follow the period, question mark or
exclamation mark.  The @code{\"} is Lisp syntax for a double-quote in a
string.  The @samp{*} at the end indicates that the immediately preceding
regular expression (a character alternative, in this case) may be repeated
zero or more times.

@item \\($\\|@ $\\|\t\\|@ @ \\)
The third part of the pattern matches the whitespace that follows the end of
a sentence: the end of a line (optionally with a space), or a tab, or two
spaces.  The double backslashes mark the parentheses and vertical bars as
regular expression syntax; the parentheses delimit a group and the vertical
bars separate alternatives.  The dollar sign is used to match the end of a
line.

@item [ \t\n]*
Finally, the last part of the pattern matches any additional whitespace
beyond the minimum needed to end a sentence.
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  These functions operate on regular expressions.

@cindex quote special characters in regexp
@defun regexp-quote string
This function returns a regular expression whose only exact match is
@var{string}.  Using this regular expression in @code{looking-at} will
succeed only if the next characters in the buffer are @var{string}; using it
in a search function will succeed if the text being searched contains
@var{string}.  @xref{Regexp Search}.

This allows you to request an exact string match or search when calling a
function that wants a regular expression.

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

One use of @code{regexp-quote} is to combine an exact string match with
context described as a regular expression.  For example, this searches for
the string that is the value of @var{string}, surrounded by whitespace:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
@c E.g., see http://debbugs.gnu.org/2816
This function returns an efficient regular expression that will match any of
the strings in the list @var{strings}.  This is useful when you need to make
matching or searching as fast as possible---for example, for Font Lock
mode@footnote{Note that @code{regexp-opt} does not guarantee that its result
is absolutely the most efficient form possible.  A hand-tuned regular
expression can sometimes be slightly more efficient, but is almost never
worth the effort.}.

If the optional argument @var{paren} is non-@code{nil}, then the returned
regular expression is always enclosed by at least one parentheses-grouping
construct.  If @var{paren} is @code{words}, then that construct is
additionally surrounded by @samp{\<} and @samp{\>}; alternatively, if
@var{paren} is @code{symbols}, then that construct is additionally
surrounded by @samp{\_<} and @samp{\_>} (@code{symbols} is often appropriate
when matching programming-language keywords and the like).

This simplified definition of @code{regexp-opt} produces a regular
expression which is equivalent to the actual value (but not as efficient):

@example
(defun regexp-opt (strings &optional paren)
  (let ((open-paren (if paren "\\(" ""))
        (close-paren (if paren "\\)" "")))
    (concat open-paren
            (mapconcat 'regexp-quote strings "\\|")
            close-paren)))
@end example
@end defun

@defun regexp-opt-depth regexp
This function returns the total number of grouping constructs (parenthesized
expressions) in @var{regexp}.  This does not include shy groups
(@pxref{Regexp Backslash}).
@end defun

@c Supposedly an internal regexp-opt function, but table.el uses it at least.
@defun regexp-opt-charset chars
This function returns a regular expression matching a character in the list
of characters @var{chars}.

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Internal functions: regexp-opt-group

@node Regexp Search
@section Regular Expression Searching
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  In GNU Emacs, you can search for the next match for a regular expression
(@pxref{Syntax of Regexps}) either incrementally or not.  For incremental
search commands, see @ref{Regexp Search, , Regular Expression Search, emacs,
The GNU Emacs Manual}.  Here we describe only the search functions useful in
programs.  The principal one is @code{re-search-forward}.

  These search functions convert the regular expression to multibyte if the
buffer is multibyte; they convert the regular expression to unibyte if the
buffer is unibyte.  @xref{Text Representations}.

@deffn Command re-search-forward regexp &optional limit noerror repeat
This function searches forward in the current buffer for a string of text
that is matched by the regular expression @var{regexp}.  The function skips
over any amount of text that is not matched by @var{regexp}, and leaves
point at the end of the first match found.  It returns the new value of
point.

If @var{limit} is non-@code{nil}, it must be a position in the current
buffer.  It specifies the upper bound to the search.  No match extending
after that position is accepted.

If @var{repeat} is supplied, it must be a positive number; the search is
repeated that many times; each repetition starts at the end of the previous
match.  If all these successive searches succeed, the search succeeds,
moving point and returning its new value.  Otherwise the search fails.  What
@code{re-search-forward} does when the search fails depends on the value of
@var{noerror}:

@table @asis
@item @code{nil}
Signal a @code{search-failed} error.
@item @code{t}
Do nothing and return @code{nil}.
@item anything else
Move point to @var{limit} (or the end of the accessible portion of the
buffer) and return @code{nil}.
@end table

In the following example, point is initially before the @samp{T}.
Evaluating the search call moves point to the end of that line (between the
@samp{t} of @samp{hat} and the newline).

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror repeat
This function searches backward in the current buffer for a string of text
that is matched by the regular expression @var{regexp}, leaving point at the
beginning of the first text found.

This function is analogous to @code{re-search-forward}, but they are not
simple mirror images.  @code{re-search-forward} finds the match whose
beginning is as close as possible to the starting point.  If
@code{re-search-backward} were a perfect mirror image, it would find the
match whose end is as close as possible.  However, in fact it finds the
match whose beginning is as close as possible (and yet ends before the
starting point).  The reason for this is that matching a regular expression
at a given spot always works from beginning to end, and starts at a
specified beginning position.

A true mirror-image of @code{re-search-forward} would require a special
feature for matching regular expressions from end to beginning.  It's not
worth the trouble of implementing that.
@end deffn

@defun string-match regexp string &optional start
This function returns the index of the start of the first match for the
regular expression @var{regexp} in @var{string}, or @code{nil} if there is
no match.  If @var{start} is non-@code{nil}, the search starts at that index
in @var{string}.

For example,

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
The index of the first character of the string is 0, the index of the second
character is 1, and so on.

After this function returns, the index of the first character beyond the
match is available as @code{(match-end 0)}.  @xref{Match Data}.

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
This predicate function does what @code{string-match} does, but it avoids
modifying the match data.
@end defun

@defun looking-at regexp
This function determines whether the text in the current buffer directly
following point matches the regular expression @var{regexp}.  ``Directly
following'' means precisely that: the search is ``anchored'' and it can
succeed only starting with the first character following point.  The result
is @code{t} if so, @code{nil} otherwise.

This function does not move point, but it does update the match data.
@xref{Match Data}.  If you need to test for a match without modifying the
match data, use @code{looking-at-p}, described below.

In this example, point is located directly before the @samp{T}.  If it were
anywhere else, the result would be @code{nil}.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp &optional limit greedy
This function returns @code{t} if @var{regexp} matches the text immediately
before point (i.e., ending at point), and @code{nil} otherwise.

Because regular expression matching works only going forward, this is
implemented by searching backwards from point for a match that ends at
point.  That can be quite slow if it has to search a long distance.  You can
bound the time required by specifying @var{limit}, which says not to search
before @var{limit}.  In this case, the match that is found must begin at or
after @var{limit}.  Here's an example:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

If @var{greedy} is non-@code{nil}, this function extends the match backwards
as far as possible, stopping when a single additional previous character
cannot be part of a match for regexp.  When the match is extended, its
starting position is allowed to occur before @var{limit}.

@c http://debbugs.gnu.org/5689
As a general recommendation, try to avoid using @code{looking-back} wherever
possible, since it is slow.  For this reason, there are no plans to add a
@code{looking-back-p} function.
@end defun

@defun looking-at-p regexp
This predicate function works like @code{looking-at}, but without updating
the match data.
@end defun

@defvar search-spaces-regexp
If this variable is non-@code{nil}, it should be a regular expression that
says how to search for whitespace.  In that case, any group of spaces in a
regular expression being searched for stands for use of this regular
expression.  However, spaces inside of constructs such as @samp{[@dots{}]}
and @samp{*}, @samp{+}, @samp{?} are not affected by
@code{search-spaces-regexp}.

Since this variable affects all regular expression search and match
constructs, you should bind it temporarily for as small as possible a part
of the code.
@end defvar

@node POSIX Regexps
@section POSIX Regular Expression Searching

@cindex backtracking and POSIX regular expressions
  The usual regular expression functions do backtracking when necessary to
handle the @samp{\|} and repetition constructs, but they continue this only
until they find @emph{some} match.  Then they succeed and report the first
match found.

  This section describes alternative search functions which perform the full
backtracking specified by the POSIX standard for regular expression
matching.  They continue backtracking until they have tried all
possibilities and found all matches, so they can report the longest match,
as required by POSIX@.  This is much slower, so use these functions only
when you really need the longest match.

  The POSIX search and match functions do not properly support the non-greedy
repetition operators (@pxref{Regexp Special, non-greedy}).  This is because
POSIX backtracking conflicts with the semantics of non-greedy repetition.

@deffn Command posix-search-forward regexp &optional limit noerror repeat
This is like @code{re-search-forward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror repeat
This is like @code{re-search-backward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end deffn

@defun posix-looking-at regexp
This is like @code{looking-at} except that it performs the full backtracking
specified by the POSIX standard for regular expression matching.
@end defun

@defun posix-string-match regexp string &optional start
This is like @code{string-match} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@node Match Data
@section The Match Data
@cindex match data

  Emacs keeps track of the start and end positions of the segments of text
found during a search; this is called the @dfn{match data}.  Thanks to the
match data, you can search for a complex pattern, such as a date in a mail
message, and then extract parts of the match under control of the pattern.

  Because the match data normally describe the most recent search only, you
must be careful not to do another search inadvertently between the search
you wish to refer back to and the use of the match data.  If you can't avoid
another intervening search, you must save and restore the match data around
it, to prevent it from being overwritten.

  Notice that all functions are allowed to overwrite the match data unless
they're explicitly documented not to do so.  A consequence is that functions
that are run implicitly in the background (@pxref{Timers}, and @ref{Idle
Timers}) should likely save and restore the match data explicitly.

@menu
* Replacing Match::          Replacing a substring that was matched.
* Simple Match Data::        Accessing single items of match data, such as 
                               where a particular subexpression started.
* Entire Match Data::        Accessing the entire match data at once, as a 
                               list.
* Saving Match Data::        Saving and restoring the match data.
@end menu

@node Replacing Match
@subsection Replacing the Text that Matched
@cindex replace matched text

  This function replaces all or part of the text matched by the last search.
It works by means of the match data.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
This function performs a replacement operation on a buffer or string.

If you did the last search in a buffer, you should omit the @var{string}
argument or specify @code{nil} for it, and make sure that the current buffer
is the one in which you performed the last search.  Then this function edits
the buffer, replacing the matched text with @var{replacement}.  It leaves
point at the end of the replacement text.

If you performed the last search on a string, pass the same string as
@var{string}.  Then this function returns a new string, in which the matched
text is replaced by @var{replacement}.

If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the
replacement text without case conversion; otherwise, it converts the
replacement text depending upon the capitalization of the text to be
replaced.  If the original text is all upper case, this converts the
replacement text to upper case.  If all words of the original text are
capitalized, this capitalizes all the words of the replacement text.  If all
the words are one-letter and they are all upper case, they are treated as
capitalized words rather than all-upper-case words.

If @var{literal} is non-@code{nil}, then @var{replacement} is inserted
exactly as it is, the only alterations being case changes as needed.  If it
is @code{nil} (the default), then the character @samp{\} is treated
specially.  If a @samp{\} appears in @var{replacement}, then it must be part
of one of the following sequences:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
This stands for the entire text being replaced.

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}} in replacement
This stands for the text that matched the @var{n}th subexpression in the
original regexp.  Subexpressions are those expressions grouped inside
@samp{\(@dots{}\)}.  If the @var{n}th subexpression never matched, an empty
string is substituted.

@item @samp{\\}
@cindex @samp{\} in replacement
This stands for a single @samp{\} in the replacement text.

@item @samp{\?}
This stands for itself (for compatibility with @code{replace-regexp} and
related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual}).
@end table

@noindent
Any other character following @samp{\} signals an error.

The substitutions performed by @samp{\&} and @samp{\@var{n}} occur after
case conversion, if any.  Therefore, the strings they substitute are never
case-converted.

If @var{subexp} is non-@code{nil}, that says to replace just subexpression
number @var{subexp} of the regexp that was matched, not the entire match.
For example, after matching @samp{foo \(ba*r\)}, calling
@code{replace-match} with 1 as @var{subexp} means to replace just the text
that matched @samp{\(ba*r\)}.
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
This function returns the text that would be inserted into the buffer by
@code{replace-match}, but without modifying the buffer.  It is useful if you
want to present the user with actual replacement result, with constructs
like @samp{\@var{n}} or @samp{\&} substituted with matched groups.
Arguments @var{replacement} and optional @var{fixedcase}, @var{literal},
@var{string} and @var{subexp} have the same meaning as for
@code{replace-match}.
@end defun

@node Simple Match Data
@subsection Simple Match Data Access

  This section explains how to use the match data to find out what was matched
by the last search or match operation, if it succeeded.

  You can ask about the entire matching text, or about a particular
parenthetical subexpression of a regular expression.  The @var{count}
argument in the functions below specifies which.  If @var{count} is zero,
you are asking about the entire match.  If @var{count} is positive, it
specifies which subexpression you want.

  Recall that the subexpressions of a regular expression are those expressions
grouped with escaped parentheses, @samp{\(@dots{}\)}.  The @var{count}th
subexpression is found by counting occurrences of @samp{\(} from the
beginning of the whole regular expression.  The first subexpression is
numbered 1, the second 2, and so on.  Only regular expressions can have
subexpressions---after a simple string search, the only information
available is about the entire match.

  Every successful search sets the match data.  Therefore, you should query
the match data immediately after searching, before calling any other
function that might perform another search.  Alternatively, you may save and
restore the match data (@pxref{Saving Match Data}) around the call to
functions that could perform another search.  Or use the functions that
explicitly do not modify the match data; e.g., @code{string-match-p}.

@c This is an old comment and presumably there is no prospect of this
@c changing now.  But still the advice stands.
  A search which fails may or may not alter the match data.  In the current
implementation, it does not, but we may change it in the future.  Don't try
to rely on the value of the match data after a failing search.

@defun match-string count &optional in-string
This function returns, as a string, the text matched in the last search or
match operation.  It returns the entire text if @var{count} is zero, or just
the portion corresponding to the @var{count}th parenthetical subexpression,
if @var{count} is positive.

If the last such operation was done against a string with
@code{string-match}, then you should pass the same string as the argument
@var{in-string}.  After a buffer search or match, you should omit
@var{in-string} or pass @code{nil} for it; but you should make sure that the
current buffer when you call @code{match-string} is the one in which you did
the searching or matching.  Failure to follow this advice will lead to
incorrect results.

The value is @code{nil} if @var{count} is out of range, or for a
subexpression inside a @samp{\|} alternative that wasn't used or a
repetition that repeated zero times.
@end defun

@defun match-string-no-properties count &optional in-string
This function is like @code{match-string} except that the result has no text
properties.
@end defun

@defun match-beginning count
This function returns the position of the start of the text matched by the
last regular expression searched for, or a subexpression of it.

If @var{count} is zero, then the value is the position of the start of the
entire match.  Otherwise, @var{count} specifies a subexpression in the
regular expression, and the value of the function is the starting position
of the match for that subexpression.

The value is @code{nil} for a subexpression inside a @samp{\|} alternative
that wasn't used or a repetition that repeated zero times.
@end defun

@defun match-end count
This function is like @code{match-beginning} except that it returns the
position of the end of the match, rather than the position of the beginning.
@end defun

  Here is an example of using the match data, with a comment showing the
positions within the text:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{The beginning of the match}
     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}
@end group

@group
(match-beginning 2)       ; @r{The beginning of the match}
     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}
@end group

@group
(match-end 1)             ; @r{The end of the match}
     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}

(match-end 2)             ; @r{The end of the match}
     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}
@end group
@end example

  Here is another example.  Point is initially located at the beginning of the
line.  Searching moves point to between the space and the word @samp{in}.
The beginning of the entire match is at the 9th character of the buffer
(@samp{T}), and the beginning of the match for the first subexpression is at
the 13th character (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(In this case, the index returned is a buffer position; the first character
of the buffer counts as 1.)

@node Entire Match Data
@subsection Accessing the Entire Match Data

  The functions @code{match-data} and @code{set-match-data} read or write the
entire match data, all at once.

@defun match-data &optional integers reuse reseat
This function returns a list of positions (markers or integers) that record
all the information on the text that the last search matched.  Element zero
is the position of the beginning of the match for the whole expression;
element one is the position of the end of the match for the expression.  The
next two elements are the positions of the beginning and end of the match
for the first subexpression, and so on.  In general, element
@ifnottex
number 2@var{n}
@end ifnottex
@tex
number {\mathsurround=0pt $2n$}
@end tex
corresponds to @code{(match-beginning @var{n})}; and element
@ifnottex
number 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
corresponds to @code{(match-end @var{n})}.

Normally all the elements are markers or @code{nil}, but if @var{integers}
is non-@code{nil}, that means to use integers instead of markers.  (In that
case, the buffer itself is appended as an additional element at the end of
the list, to facilitate complete restoration of the match data.)  If the
last match was done on a string with @code{string-match}, then integers are
always used, since markers can't point into a string.

If @var{reuse} is non-@code{nil}, it should be a list.  In that case,
@code{match-data} stores the match data in @var{reuse}.  That is,
@var{reuse} is destructively modified.  @var{reuse} does not need to have
the right length.  If it is not long enough to contain the match data, it is
extended.  If it is too long, the length of @var{reuse} stays the same, but
the elements that were not used are set to @code{nil}.  The purpose of this
feature is to reduce the need for garbage collection.

If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are
reseated to point to nowhere.

As always, there must be no possibility of intervening searches between the
call to a search function and the call to @code{match-data} that is intended
to access the match data for that search.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
This function sets the match data from the elements of @var{match-list},
which should be a list that was the value of a previous call to
@code{match-data}.  (More precisely, anything that has the same format will
work.)

If @var{match-list} refers to a buffer that doesn't exist, you don't get an
error; that sets the match data in a meaningless but harmless way.

If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list
are reseated to point to nowhere.

@c TODO Make it properly obsolete.
@findex store-match-data
@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Saving and Restoring the Match Data

  When you call a function that may search, you may need to save and restore
the match data around that call, if you want to preserve the match data from
an earlier search for later use.  Here is an example that shows the problem
that arises if you fail to save the match data:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} does more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

  You can save and restore the match data with @code{save-match-data}:

@defmac save-match-data body@dots{}
This macro executes @var{body}, saving and restoring the match data around
it.  The return value is the value of the last form in @var{body}.
@end defmac

  You could use @code{set-match-data} together with @code{match-data} to
imitate the effect of the special form @code{save-match-data}.  Here is how:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok to change the original match data.}
    (set-match-data data)))
@end group
@end example

  Emacs automatically saves and restores the match data when it runs process
filter functions (@pxref{Filter Functions}) and process sentinels
(@pxref{Sentinels}).

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
(defun restore-match-data (data)
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section Search and Replace
@cindex replacement after search
@cindex searching and replacing

  If you want to find all matches for a regexp in part of the buffer, and
replace them, the best way is to write an explicit loop using
@code{re-search-forward} and @code{replace-match}, like this:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, for a description
of @code{replace-match}.

  However, replacing matches in a string is more complex, especially if you
want to do it efficiently.  So Emacs provides a function to do this.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
This function copies @var{string} and searches it for matches for
@var{regexp}, and replaces them with @var{rep}.  It returns the modified
copy.  If @var{start} is non-@code{nil}, the search for matches starts at
that index in @var{string}, so matches starting before that index are not
changed.

This function uses @code{replace-match} to do the replacement, and it passes
the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along
to @code{replace-match}.

Instead of a string, @var{rep} can be a function.  In that case,
@code{replace-regexp-in-string} calls @var{rep} for each match, passing the
text of the match as its sole argument.  It collects the value @var{rep}
returns and passes that to @code{replace-match} as the replacement string.
The match data at this point are the result of matching @var{regexp} against
a substring of @var{string}.
@end defun

  If you want to write a command along the lines of @code{query-replace}, you
can use @code{perform-replace} to do the work.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end
This function is the guts of @code{query-replace} and related commands.  It
searches for occurrences of @var{from-string} in the text between positions
@var{start} and @var{end} and replaces some or all of them.  If @var{start}
is @code{nil} (or omitted), point is used instead, and the end of the
buffer's accessible portion is used for @var{end}.

If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise,
it asks the user what to do about each one.

If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered
a regular expression; otherwise, it must match literally.  If
@var{delimited-flag} is non-@code{nil}, then only replacements surrounded by
word boundaries are considered.

The argument @var{replacements} specifies what to replace occurrences with.
If it is a string, that string is used.  It can also be a list of strings,
to be used in cyclic order.

If @var{replacements} is a cons cell, @w{@code{(@var{function}
. @var{data})}}, this means to call @var{function} after each match to get
the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it
specifies how many times to use each of the strings in the
@var{replacements} list before advancing cyclically to the next one.

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it
uses the @var{replacements} without altering their case.

Normally, the keymap @code{query-replace-map} defines the possible user
responses for queries.  The argument @var{map}, if non-@code{nil}, specifies
a keymap to use instead of @code{query-replace-map}.

This function uses one of two functions to search for the next occurrence of
@var{from-string}.  These functions are specified by the values of two
variables: @code{replace-re-search-function} and
@code{replace-search-function}.  The former is called when the argument
@var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}.
@end defun

@defvar query-replace-map
This variable holds a special keymap that defines the valid user responses
for @code{perform-replace} and the commands that use it, as well as
@code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:

@itemize @bullet
@item
The ``key bindings'' are not commands, just symbols that are meaningful to
the functions that use this map.

@item
Prefix keys are not supported; each key binding must be for a single-event
key sequence.  This is because the functions don't use
@code{read-key-sequence} to get the input; instead, they read a single event
and look it up ``by hand''.
@end itemize
@end defvar

Here are the meaningful ``bindings'' for @code{query-replace-map}.  Several
of them are meaningful only for @code{query-replace} and friends.

@table @code
@item act
Do take the action being considered---in other words, ``yes''.

@item skip
Do not take action for this question---in other words, ``no''.

@item exit
Answer this question ``no'', and give up on the entire series of questions,
assuming that the answers will be ``no''.

@item exit-prefix
Like @code{exit}, but add the key that was pressed to
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
Answer this question ``yes'', and give up on the entire series of questions,
assuming that subsequent answers will be ``no''.

@item act-and-show
Answer this question ``yes'', but show the results---don't advance yet to
the next question.

@item automatic
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction.

@item backup
Move back to the previous place that a question was asked about.

@item edit
Enter a recursive edit to deal with this question---instead of any other
action that would normally be taken.

@item edit-replacement
Edit the replacement for this question in the minibuffer.

@item delete-and-edit
Delete the text being considered, then enter a recursive edit to replace it.

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
Perform the specified window scroll operation, then ask the same question
again.  Only @code{y-or-n-p} and related functions use this answer.

@item quit
Perform a quit right away.  Only @code{y-or-n-p} and related functions use
this answer.

@item help
Display some help, then ask again.
@end table

@defvar multi-query-replace-map
This variable holds a keymap that extends @code{query-replace-map} by
providing additional keybindings that are useful in multi-buffer
replacements.  The additional ``bindings'' are:

@table @code
@item automatic-all
Answer this question and all subsequent questions in the series with
``yes'', without further user interaction, for all remaining buffers.

@item exit-current
Answer this question ``no'', and give up on the entire series of questions
for the current buffer.  Continue to the next buffer in the sequence.
@end table
@end defvar

@defvar replace-search-function
This variable specifies a function that @code{perform-replace} calls to
search for the next string to replace.  Its default value is
@code{search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{search-forward} (@pxref{String
Search}).
@end defvar

@defvar replace-re-search-function
This variable specifies a function that @code{perform-replace} calls to
search for the next regexp to replace.  Its default value is
@code{re-search-forward}.  Any other value should name a function of 3
arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp
Search}).
@end defvar

@node Standard Regexps
@section Standard Regular Expressions Used in Editing
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  This section describes some variables that hold regular expressions used for
certain purposes in editing:

@defopt page-delimiter
This is the regular expression describing line-beginnings that separate
pages.  The default value is @code{"^\014"} (i.e., @code{"^^L"} or
@code{"^\C-l"}); this matches a line that starts with a formfeed character.
@end defopt

  The following two regular expressions should @emph{not} assume the match
always starts at the beginning of a line; they should not use @samp{^} to
anchor the match.  Most often, the paragraph commands do check for a match
only at the beginning of a line, which means that @samp{^} would be
superfluous.  When there is a nonzero left margin, they accept matches that
start after the left margin.  In that case, a @samp{^} would be incorrect.
However, a @samp{^} is harmless in modes where a left margin is never used.

@defopt paragraph-separate
This is the regular expression for recognizing the beginning of a line that
separates paragraphs.  (If you change this, you may have to change
@code{paragraph-start} also.)  The default value is @w{@code{"[@ \t\f]*$"}},
which matches a line that consists entirely of spaces, tabs, and form feeds
(after its left margin).
@end defopt

@defopt paragraph-start
This is the regular expression for recognizing the beginning of a line that
starts @emph{or} separates paragraphs.  The default value is
@w{@code{"\f\\|[ \t]*$"}}, which matches a line containing only whitespace
or starting with a form feed (after its left margin).
@end defopt

@defopt sentence-end
If non-@code{nil}, the value should be a regular expression describing the
end of a sentence, including the whitespace following the sentence.  (All
paragraph boundaries also end sentences, regardless.)

If the value is @code{nil}, as it is by default, then the function
@code{sentence-end} constructs the regexp.  That is why you should always
call the function @code{sentence-end} to obtain the regexp to be used to
recognize the end of a sentence.
@end defopt

@defun sentence-end
This function returns the value of the variable @code{sentence-end}, if
non-@code{nil}.  Otherwise it returns a default value based on the values of
the variables @code{sentence-end-double-space} (@pxref{Definition of
sentence-end-double-space}), @code{sentence-end-without-period}, and
@code{sentence-end-without-space}.
@end defun
