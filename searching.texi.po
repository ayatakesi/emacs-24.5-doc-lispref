# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-01-28 23:27+0900\n"
"PO-Revision-Date: 2019-01-30 20:38+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: searching.texi.orig:6 searching.texi.orig:7
#, no-wrap
msgid "Searching and Matching"
msgstr "Searching and Matching"

#. type: cindex
#: searching.texi.orig:8
#, no-wrap
msgid "searching"
msgstr "searching"

#. type: Plain text
#: searching.texi.orig:15
msgid "GNU Emacs provides two ways to search through a buffer for specified text: exact string searches and regular expression searches.  After a regular expression search, you can examine the @dfn{match data} to determine which text matched the whole regular expression or various portions of it."
msgstr "GNU Emacsは、バッファーから指定されたテキストを検索するために、２つの手段を提供します。それは文字列の正確一致検索(exact string search)と、正規表現検索(regular expression search)です。正規表現検索の後、マッチしたテキストが正規表現壱阡にマッチしたのか、それとも正規表現のさまざまな部分に一致したかを判断するために、@dfn{マッチデータ(match data)}を調べることができます。"

#. type: node
#: searching.texi.orig:26 searching.texi.orig:32
#, no-wrap
msgid "String Search"
msgstr "String Search"

#. type: menuentry
#: searching.texi.orig:26
msgid "Search for an exact match."
msgstr "正確なマッチの検索。"

#. type: section
#: searching.texi.orig:26 searching.texi.orig:189 searching.texi.orig:190
#, no-wrap
msgid "Searching and Case"
msgstr "Searching and Case"

#. type: menuentry
#: searching.texi.orig:26
msgid "Case-independent or case-significant searching."
msgstr "case-independentまたはcase-significantな検索。"

#. type: section
#: searching.texi.orig:26 searching.texi.orig:232 searching.texi.orig:233
#, no-wrap
msgid "Regular Expressions"
msgstr "Regular Expressions"

#. type: menuentry
#: searching.texi.orig:26
msgid "Describing classes of strings."
msgstr "文字列クラスの記述。"

#. type: node
#: searching.texi.orig:26 searching.texi.orig:984
#, no-wrap
msgid "Regexp Search"
msgstr "Regexp Search"

#. type: menuentry
#: searching.texi.orig:26
msgid "Searching for a match for a regexp."
msgstr "regexpにたいするマッチの検索。"

#. type: node
#: searching.texi.orig:26 searching.texi.orig:1202
#, no-wrap
msgid "POSIX Regexps"
msgstr "POSIX Regexps"

#. type: menuentry
#: searching.texi.orig:26
msgid "Searching POSIX-style for the longest match."
msgstr "最長マッチにたいするPOSIXスタイルのマッチ。"

#. type: node
#: searching.texi.orig:26 searching.texi.orig:1247
#, no-wrap
msgid "Match Data"
msgstr "Match Data"

#. type: menuentry
#: searching.texi.orig:26
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr "文字列またはregexp検索後に、テキストがマッチした部分を見つける。"

#. type: section
#: searching.texi.orig:26 searching.texi.orig:1656 searching.texi.orig:1657
#, no-wrap
msgid "Search and Replace"
msgstr "Search and Replace"

#. type: menuentry
#: searching.texi.orig:26
msgid "Commands that loop, searching and replacing."
msgstr "検索と置換を繰り返すコマンド。"

#. type: node
#: searching.texi.orig:26 searching.texi.orig:1860
#, no-wrap
msgid "Standard Regexps"
msgstr "Standard Regexps"

#. type: menuentry
#: searching.texi.orig:26
msgid "Useful regexps for finding sentences, pages,..."
msgstr "センテンスやページ等を探すために有用なregexp。"

#. type: Plain text
#: searching.texi.orig:31
msgid "The @samp{skip-chars@dots{}} functions also perform a kind of searching.  @xref{Skipping Characters}.  To search for changes in character properties, see @ref{Property Search}."
msgstr "@samp{skip-chars@dots{}}関連の関数も、ある種の検索を行います。@ref{Skipping Characters}を参照してください。文字プロパティ内の変更を検索するには、@ref{Property Search}を参照してください。"

#. type: section
#: searching.texi.orig:33
#, no-wrap
msgid "Searching for Strings"
msgstr "Searching for Strings"

#. type: cindex
#: searching.texi.orig:34
#, no-wrap
msgid "string search"
msgstr "string search"

#. type: Plain text
#: searching.texi.orig:42
msgid "These are the primitive functions for searching through the text in a buffer.  They are meant for use in programs, but you may call them interactively.  If you do so, they prompt for the search string; the arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is 1.  For more details on interactive searching, @pxref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}."
msgstr "バッファー内のテキストを検索するための、プリミティブ関数が存在します。これらはプログラム内での使用を意図したものですが、インタラクティブに呼び出すこともできます。これらをインタラクティブに呼び出した場合は、検索文字列の入力を求め、引数@var{limit}および@var{noerror}は@code{nil}、@var{repeat}は1になります。インタラクティブ検索に関するより詳細な情報は、@ref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: searching.texi.orig:46
msgid "These search functions convert the search string to multibyte if the buffer is multibyte; they convert the search string to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr "以下の検索関数は、バッファーがマルチバイトバッファーならマルチバイト、ユニバイトバッファーならユニバイトに、検索文字列を変換します。@ref{Text Representations}を参照してください。"

#. type: deffn
#: searching.texi.orig:47
#, no-wrap
msgid "Command search-forward string &optional limit noerror repeat"
msgstr "Command search-forward string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:52
msgid "This function searches forward from point for an exact match for @var{string}.  If successful, it sets point to the end of the occurrence found, and returns the new value of point.  If no match is found, the value and side effects depend on @var{noerror} (see below)."
msgstr "この関数は、@var{string}にたいする正確なマッチを、ポイントから前方に検索する。成功したら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。マッチが見つからない場合の値と副作用は、@var{noerror}(以下参照)に依存する。"

#. type: deffn
#: searching.texi.orig:56
msgid "In the following example, point is initially at the beginning of the line.  Then @code{(search-forward \"fox\")} moves point after the last letter of @samp{fox}:"
msgstr "以下の例では、ポイントは最初は行の先頭にある。その後の@code{(search-forward \"fox\")}により、ポイントは@samp{fox}の最後の文字の後に移動する:"

#. type: group
#: searching.texi.orig:62
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: searching.texi.orig:67
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"

#. type: group
#: searching.texi.orig:71
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: searching.texi.orig:78
msgid "The argument @var{limit} specifies the bound to the search, and should be a position in the current buffer.  No match extending after that position is accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end of the accessible portion of the buffer."
msgstr "引数@var{limit}は検索の境界を指定し、それはカレントバッファー内の位置であること。その位置を超えるようなマッチは、受け入れられない。@var{limit}が省略または@code{nil}の場合のデフォルトは、そのバッファーのアクセス可能範囲の終端である。"

#. type: kindex
#: searching.texi.orig:79
#, no-wrap
msgid "search-failed"
msgstr "search-failed"

#. type: deffn
#: searching.texi.orig:88
msgid "What happens when the search fails depends on the value of @var{noerror}.  If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then @code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr "検索失敗時に何が起こるかは、@var{noerror}の値に依存する。@var{noerror}が@code{nil}なら、@code{search-failed}はエラーをシグナルする。@var{noerror}が@code{t}なら、@code{search-forward}は@code{nil}をリターンして、何も行わない。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、@code{search-forward}はポイントを境界上限に移動して、@code{nil}をリターンする。"

#. type: deffn
#: searching.texi.orig:97
msgid "The argument @var{noerror} only affects valid searches which fail to find a match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr "引数@var{noerror}は、マッチに失敗した有効な検索だけに影響する。無効な引数は、@var{noerror}とは無関係にエラーとなる。"

#. type: deffn
#: searching.texi.orig:106
msgid "If @var{repeat} is a positive number @var{n}, it serves as a repeat count: the search is repeated @var{n} times, each time starting at the end of the previous time's match.  If these successive searches succeed, the function succeeds, moving point and returning its new value.  Otherwise the search fails, with results depending on the value of @var{noerror}, as described above.  If @var{repeat} is a negative number -@var{n}, it serves as a repeat count of @var{n} for a search in the opposite (backward) direction."
msgstr "@var{repeat}が正の数@var{n}なら、それは繰り返し回数の役目をもつ。検索は@var{n}回繰り返され、前回のマッチの終端から毎回検索が開始される。これらの連続する検索が成功した場合、関数は成功となりポイントを新たな値をリターンする。それ以外は検索失敗となり、上述したように結果は@var{noerror}の値に依存する。@var{repeat}が負の数-@var{n}なら、それは逆方向(後方)への検索の繰り返し回数@var{n}としての役目をもつ。"

#. type: deffn
#: searching.texi.orig:108
#, no-wrap
msgid "Command search-backward string &optional limit noerror repeat"
msgstr "Command search-backward string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:113
msgid "This function searches backward from point for @var{string}.  It is like @code{search-forward}, except that it searches backwards rather than forwards.  Backward searches leave point at the beginning of the match."
msgstr "この関数は、ポイントから後方に@var{string}を検索する。これは@code{search-forward}と似ているが、前方ではなく後方に検索する点が異なる。後方への検索では、ポイントはマッチの先頭に残される。"

#. type: deffn
#: searching.texi.orig:115
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror repeat"
msgstr "Command word-search-forward string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:119
msgid "This function searches forward from point for a ``word'' match for @var{string}.  If it finds a match, it sets point to the end of the match found, and returns the new value of point."
msgstr "この関数は、ポイントから前方に@var{string}にたいする``単語(word)''のマッチを検索する。マッチが見つかったら、見つかったマッチの終端にポイントをセットして、ポイントの新たな値をリターンする。"

#. type: deffn
#: searching.texi.orig:126
msgid "Word matching regards @var{string} as a sequence of words, disregarding punctuation that separates them.  It searches the buffer for the same sequence of words.  Each word must be distinct in the buffer (searching for the word @samp{ball} does not match the word @samp{balls}), but the details of punctuation and spacing are ignored (searching for @samp{ball boy} does match @samp{ball.  Boy!})."
msgstr "単語マッチは@var{string}を単語のシーケンスとみなし、それらを分ける句読点は無視する。これはバッファーから、同じ単語シーケンスを検索する。単語はそれぞれバッファー内で明確に区別されていなければならないが(単語@samp{ball}の検索は単語@samp{balls}にマッチしない)、句読点やスペース等の細部は無視される(@samp{ball boy}を検索すると@samp{ball.  Boy!}にマッチする)。"

#. type: deffn
#: searching.texi.orig:129
msgid "In this example, point is initially at the beginning of the buffer; the search leaves it between the @samp{y} and the @samp{!}."
msgstr "以下の例では、ポイントは最初バッファー先頭にある。検索により、ポイントは@samp{y}と@samp{!}の間に残される。"

#. type: group
#: searching.texi.orig:136
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"

#. type: group
#: searching.texi.orig:141
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"

#. type: group
#: searching.texi.orig:146
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"

#. type: deffn
#: searching.texi.orig:152
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer; it specifies the upper bound to the search.  The match found must not extend after that position."
msgstr "@var{limit}が非@code{nil}なら、それはカレントバッファー内の位置であること。これはその検索の境界上限を指定する。見つかったマッチは、その位置を超えてはならない。"

#. type: deffn
#: searching.texi.orig:158
msgid "If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an error if the search fails.  If @var{noerror} is @code{t}, then it returns @code{nil} instead of signaling an error.  If @var{noerror} is neither @code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the accessible portion of the buffer) and returns @code{nil}."
msgstr "@var{noerror}が@code{nil}なら、@code{word-search-forward}はエラーをシグナルする。@var{noerror}が@code{t}なら、エラーをシグナルするかわりに、@code{nil}をリターンする。@var{noerror}が@code{nil}と@code{t}いずれでもなければ、ポイントを@var{limit}(またはバッファーのアクセス可能範囲の終端)に移動して、@code{nil}をリターンする。"

#. type: deffn
#: searching.texi.orig:161
msgid "If @var{repeat} is non-@code{nil}, then the search is repeated that many times.  Point is positioned at the end of the last match."
msgstr "@var{repeat}が非@code{nil}なら、検索はその回数繰り返される。ポイントは最後のマッチの終端に置かれる。"

#. type: findex
#: searching.texi.orig:162
#, no-wrap
msgid "word-search-regexp"
msgstr "word-search-regexp"

#. type: deffn
#: searching.texi.orig:166
msgid "Internally, @code{word-search-forward} and related functions use the function @code{word-search-regexp} to convert @var{string} to a regular expression that ignores punctuation."
msgstr "内部的には、@code{word-search-forward}と関連する関数は、@var{string}から句読点を無視した正規表現に変換するために、関数@code{word-search-regexp}を使用する。"

#. type: deffn
#: searching.texi.orig:168
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror repeat"
msgstr "Command word-search-forward-lax string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:174
msgid "This command is identical to @code{word-search-forward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace.  For instance, searching for @samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls boy}."
msgstr "このコマンドは@code{word-search-forward}と同じだが、@var{string}が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。たとえば@samp{ball boy}の検索は@samp{ball boyee}にはマッチするが、@samp{balls boy}にはマッチしない。"

#. type: deffn
#: searching.texi.orig:176
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror repeat"
msgstr "Command word-search-backward string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:181
msgid "This function searches backward from point for a word match to @var{string}.  This function is just like @code{word-search-forward} except that it searches backward and normally leaves point at the beginning of the match."
msgstr "この関数は、ポイントから後方へ@var{string}にマッチする単語を検索する。この関数は@code{word-search-forward}と同様だが、後方に検索して、通常はマッチの先頭にポイントを残す点が異なる。"

#. type: deffn
#: searching.texi.orig:183
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror repeat"
msgstr "Command word-search-backward-lax string &optional limit noerror repeat"

#. type: deffn
#: searching.texi.orig:187
msgid "This command is identical to @code{word-search-backward}, except that the beginning or the end of @var{string} need not match a word boundary, unless @var{string} begins or ends in whitespace."
msgstr "このコマンドは@code{word-search-backward}と同じだが、文字列が空白で開始または終了していなければ、@var{string}の先頭または終端が単語境界にマッチする必要がない点が異なる。"

#. type: cindex
#: searching.texi.orig:191
#, no-wrap
msgid "searching and case"
msgstr "searching and case"

#. type: Plain text
#: searching.texi.orig:198
msgid "By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for @samp{FOO}, then @samp{Foo} or @samp{foo} is also considered a match.  This applies to regular expressions, too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or @samp{B}."
msgstr "デフォルトのEmacs検索では、検索するテキストの大文字と小文字は無視されます。検索対象に@samp{FOO}を指定すると、@samp{Foo}や@samp{foo}もマッチとみなされます。これは正規表現にも適用されます。つまり@samp{[aB]}は@samp{a}、@samp{A}、@samp{b}、@samp{B}にもマッチするでしょう。"

#. type: Plain text
#: searching.texi.orig:206
msgid "If you do not want this feature, set the variable @code{case-fold-search} to @code{nil}.  Then all letters must match exactly, including case.  This is a buffer-local variable; altering the variable affects only the current buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the default value.  In Lisp code, you will more typically use @code{let} to bind @code{case-fold-search} to the desired value."
msgstr "この機能が望ましくなければ、変数@code{case-fold-search}を@code{nil}にセットしてください。その場合、すべての文字は大文字小文字の違いを含めて、正確にマッチしなければなりません。これはバッファーローカル変数です。この変数の変更は、カレントバッファーだけに影響を与えます(@ref{Intro to Buffer-Local}を参照)。かわりにデフォルト値を変更することもできます。Lispコードでは、@code{let}を使用して@code{case-fold-search}を望む値にバインドするほうが、より一般的でしょう。"

#. type: Plain text
#: searching.texi.orig:214
msgid "Note that the user-level incremental search feature handles case distinctions differently.  When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive.  But this has nothing to do with the searching functions used in Lisp code.  @xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr "ユーザーレベルのインクリメンタル検索機能では、大文字小文字の区別が異なることに注意してください。検索文字列に含まれるのが小文字だけなら検索は大文字小文字の違いを無視しますが、検索文字列に1つ以上の大文字が含まれれば検索は大文字小文字の違いを区別するようになります。しかしLispコード内で使用される検索関数では、これは何も行いません。@ref{Incremental Search,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defopt
#: searching.texi.orig:215
#, no-wrap
msgid "case-fold-search"
msgstr "case-fold-search"

#. type: defopt
#: searching.texi.orig:219
msgid "This buffer-local variable determines whether searches should ignore case.  If the variable is @code{nil} they do not ignore case; otherwise (and by default) they do ignore case."
msgstr "このバッファーローカル変数は、検索が大文字小文字の違いを無視するべきかどうかを決定する。この変数が@code{nil}なら、検索は大文字小文字の違いを無視しない。それ以外(とデフォルト)では、大文字小文字のかも無視する。"

#. type: defopt
#: searching.texi.orig:221
#, no-wrap
msgid "case-replace"
msgstr "case-replace"

#. type: defopt
#: searching.texi.orig:227
msgid "This variable determines whether the higher-level replacement functions should preserve case.  If the variable is @code{nil}, that means to use the replacement text verbatim.  A non-@code{nil} value means to convert the case of the replacement text according to the text being replaced."
msgstr "この変数は、高レベルの置換関数が大文字小文字の違いを保持するべきかどうかを決定する。この変数が@code{nil}なら、それは置換テキストをそのまま使用することを意味する。非@code{nil}値は、置換されるテキストに応じて、置換テキストの大文字小文字を変換することを意味する。"

#. type: defopt
#: searching.texi.orig:230
msgid "This variable is used by passing it as an argument to the function @code{replace-match}.  @xref{Replacing Match}."
msgstr "この変数は、それを関数@code{replace-match}の引数として渡すことにより使用される。@ref{Replacing Match}を参照のこと。"

#. type: cindex
#: searching.texi.orig:234
#, no-wrap
msgid "regular expression"
msgstr "regular expression"

#. type: cindex
#: searching.texi.orig:235
#, no-wrap
msgid "regexp"
msgstr "regexp"

#. type: Plain text
#: searching.texi.orig:241
msgid "A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that denotes a (possibly infinite) set of strings.  Searching for matches for a regexp is a very powerful operation.  This section explains how to write regexps; the following section says how to search for them."
msgstr "@dfn{正規表現(regular expression)}、略して@dfn{regexp}は、文字列の(もしかしたら無限の)セットを表すパターンのことです。regexpにたいするマッチの検索は、とても強力な処理です。このセクションではregexpの記述方法、それ以降のセクションではそれらを検索する方法を示します。"

#. type: findex
#: searching.texi.orig:242
#, no-wrap
msgid "re-builder"
msgstr "re-builder"

#. type: cindex
#: searching.texi.orig:243
#, no-wrap
msgid "regular expressions, developing"
msgstr "regular expressions, developing"

#. type: Plain text
#: searching.texi.orig:251
msgid "For interactive development of regular expressions, you can use the @kbd{M-x re-builder} command.  It provides a convenient interface for creating regular expressions, by giving immediate visual feedback in a separate buffer.  As you edit the regexp, all its matches in the target buffer are highlighted.  Each parenthesized sub-expression of the regexp is shown in a distinct face, which makes it easier to verify even very complex regexps."
msgstr "正規表現を対話的に開発するために、@kbd{M-x re-builder}コマンドを使用できます。このコマンドは、別のバッファーに即座に視覚的なフィードバックを表示することにより、正規表現を作成するための便利なインターフェースを提供します。regexp編集とともに、ターゲットとなるバッファーのすべてのマッチがハイライトされます。カッコで括られたregexpの部分式(sub-expression)は別のフェイスで表示され、非常に複雑なregexpを簡単に検証することが可能になります。"

#. type: node
#: searching.texi.orig:256 searching.texi.orig:258
#, no-wrap
msgid "Syntax of Regexps"
msgstr "Syntax of Regexps"

#. type: menuentry
#: searching.texi.orig:256
msgid "Rules for writing regular expressions."
msgstr "正規表現の記述ルール。"

#. type: node
#: searching.texi.orig:256 searching.texi.orig:835
#, no-wrap
msgid "Regexp Example"
msgstr "Regexp Example"

#. type: menuentry
#: searching.texi.orig:256
msgid "Illustrates regular expression syntax."
msgstr "正規表現構文の説明。"

#. type: node
#: searching.texi.orig:256 searching.texi.orig:895
#, no-wrap
msgid "Regexp Functions"
msgstr "Regexp Functions"

#. type: menuentry
#: searching.texi.orig:256
msgid "Functions for operating on regular expressions."
msgstr "正規表現を操作する関数。"

#. type: subsection
#: searching.texi.orig:259
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr "Syntax of Regular Expressions"

#. type: cindex
#: searching.texi.orig:260
#, no-wrap
msgid "regexp syntax"
msgstr "regexp syntax"

#. type: cindex
#: searching.texi.orig:261
#, no-wrap
msgid "syntax of regular expressions"
msgstr "syntax of regular expressions"

#. type: Plain text
#: searching.texi.orig:274
msgid "Regular expressions have a syntax in which a few characters are special constructs and the rest are @dfn{ordinary}.  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined in the future.  The character @samp{]} is special if it ends a character alternative (see later).  The character @samp{-} is special inside a character alternative.  A @samp{[:} and balancing @samp{:]} enclose a character class inside a character alternative.  Any other character appearing in a regular expression is ordinary, unless a @samp{\\} precedes it."
msgstr "正規表現は、少数の文字が特別な構成要素で、残りは@dfn{通常}の文字であるような構文をもちます。通常の文字は、その文字自身だけにマッチする、シンプルな正規表現です。特別な文字は@samp{.}、@samp{*}、@samp{+}、@samp{?}、@samp{[}、@samp{^}、@samp{$}、および@samp{\\}です。将来、新たなスペシャル文字が定義されることはないでしょう。文字候補で終わる場合、@samp{]}はスペシャル文字です。文字候補の間では、@samp{-}はスペシャル文字です。@samp{[:}と、対応する@samp{:]}は、文字候補内の文字クラスです。正規表現内に出現する他の文字は、@samp{\\}が前置されていない限り、通常の文字です。"

#. type: Plain text
#: searching.texi.orig:280
msgid "For example, @samp{f} is not a special character, so it is ordinary, and therefore @samp{f} is a regular expression that matches the string @samp{f} and no other string.  (It does @emph{not} match the string @samp{fg}, but it does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular expression that matches only @samp{o}."
msgstr "たとえば@samp{f}はスペシャル文字ではなく通常文字なので、@samp{f}は文字列@samp{f}にマッチし、他の文字にはマッチしない正規表現です(これは文字列@samp{fg}には@emph{マッチしない}が、その文字列の@emph{部分}にマッチする)。同様に、@samp{o}は@samp{o}だけにマッチします。"

#. type: Plain text
#: searching.texi.orig:285
msgid "Any two regular expressions @var{a} and @var{b} can be concatenated.  The result is a regular expression that matches a string if @var{a} matches some amount of the beginning of that string and @var{b} matches the rest of the string."
msgstr "任意の2つの正規表現@var{a}と@var{b}は、結合することができます。結合した結果は、文字列の先頭からある長さの文字列が@var{a}にマッチし、残りの文字列が@var{b}にマッチするような文字列にマッチする正規表現になります。"

#. type: Plain text
#: searching.texi.orig:290
msgid "As a simple example, we can concatenate the regular expressions @samp{f} and @samp{o} to get the regular expression @samp{fo}, which matches only the string @samp{fo}.  Still trivial.  To do something more powerful, you need to use one of the special regular expression constructs."
msgstr "単純な例として、文字列@samp{fo}だけにマッチする正規表現の構成要素@samp{fo}を取得するために、正規表現@samp{f}と@samp{o}を結合できます。"

#. type: node
#: searching.texi.orig:295 searching.texi.orig:297
#, no-wrap
msgid "Regexp Special"
msgstr "Regexp Special"

#. type: menuentry
#: searching.texi.orig:295
msgid "Special characters in regular expressions."
msgstr "正規表現内のスペシャル文字。"

#. type: node
#: searching.texi.orig:295 searching.texi.orig:533
#, no-wrap
msgid "Char Classes"
msgstr "Char Classes"

#. type: menuentry
#: searching.texi.orig:295
msgid "Character classes used in regular expressions."
msgstr "正規表現内で使用される文字クラス。"

#. type: node
#: searching.texi.orig:295 searching.texi.orig:590
#, no-wrap
msgid "Regexp Backslash"
msgstr "Regexp Backslash"

#. type: menuentry
#: searching.texi.orig:295
msgid "Backslash-sequences in regular expressions."
msgstr "正規表現内のバックスラッシュシーケンス。"

#. type: subsubsection
#: searching.texi.orig:298
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr "Special Characters in Regular Expressions"

#. type: cindex
#: searching.texi.orig:299
#, no-wrap
msgid "regexp, special characters in"
msgstr "regexp, special characters in"

#. type: Plain text
#: searching.texi.orig:303
msgid "Here is a list of the characters that are special in a regular expression."
msgstr "以下は、正規表現内で特別な文字のリストです:"

#. type: item
#: searching.texi.orig:306
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr "@samp{.}@: @r{(Period)}"

#. type: cindex
#: searching.texi.orig:307
#, no-wrap
msgid "@samp{.} in regexp"
msgstr "@samp{.} in regexp"

#. type: table
#: searching.texi.orig:312
msgid "is a special character that matches any single character except a newline.  Using concatenation, we can make regular expressions like @samp{a.b}, which matches any three-character string that begins with @samp{a} and ends with @samp{b}."
msgstr "これは、改行を除く1文字にマッチする。結合を使用して、@samp{a.b}のような正規表現を作成できる。これは@samp{a}で始まり@samp{b}で終わる3文字の文字列にマッチする。"

#. type: samp{#1}
#: searching.texi.orig:313
#, no-wrap
msgid "*"
msgstr "*"

#. type: cindex
#: searching.texi.orig:314
#, no-wrap
msgid "@samp{*} in regexp"
msgstr "@samp{*} in regexp"

#. type: table
#: searching.texi.orig:319
msgid "is not a construct by itself; it is a postfix operator that means to match the preceding regular expression repetitively as many times as possible.  Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr "これは、それ自身が構成要素ではない。これは前置された正規表現を可能な限り繰り返したものにマッチすることを意味する、後置演算子である。したがって、@samp{o*}は任意の個数の@samp{o}にマッチする(@samp{o}を含まない場合もマッチする)。"

#. type: table
#: searching.texi.orig:323
msgid "@samp{*} always applies to the @emph{smallest} possible preceding expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating @samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr "@samp{*}は常に前置された表現の、@emph{最小}の表現に適用される。つまり@samp{fo*}は@samp{o}の繰り返しであり、@samp{fo}の繰り返しではない。これは@samp{f}、@samp{fo}、@samp{foo}、...にマッチする。"

#. type: cindex
#: searching.texi.orig:324
#, no-wrap
msgid "backtracking and regular expressions"
msgstr "backtracking and regular expressions"

#. type: table
#: searching.texi.orig:335
msgid "The matcher processes a @samp{*} construct by matching, immediately, as many repetitions as can be found.  Then it continues with the rest of the pattern.  If that fails, backtracking occurs, discarding some of the matches of the @samp{*}-modified construct in the hope that that will make it possible to match the rest of the pattern.  For example, in matching @samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to match all three @samp{a}s; but the rest of the pattern is @samp{ar} and there is only @samp{r} left to match, so this try fails.  The next alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, the rest of the regexp matches successfully."
msgstr "マッチを行う処理は構成要素@samp{*}を、マッチングにより即座に、見つけ得る回数分処理して、その後にパターンの残りを継続する。これが失敗したら、残りのパターンのマッチが可能になるかもしれないという期待のもと、@samp{*}の変更された構成のうちいくつかのマッチを破棄することによる、バックトラッキングが発生する。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチングすると、@samp{a*}はまず3つすべての@samp{a}へのマッチを試みる。しかし残りのパターンは@samp{ar}であり、マッチ対象に残されているのは@samp{r}だけなので、この試みは失敗する。@samp{a*}にたいする次の代替策は、2つの@samp{a}だけへのマッチである。この選択では、残りのregexpのマッチは成功する。"

#. type: table
#: searching.texi.orig:346
msgid "@strong{Warning:} Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching.  For example, trying to match the regular expression @samp{\\(x+y*\\)*a} against the string @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} could take hours before it ultimately fails.  Emacs must try each way of grouping the @samp{x}s before concluding that none of them can work.  Even worse, @samp{\\(x*\\)*} can match the null string in infinitely many ways, so it causes an infinite loop.  To avoid these problems, check nested repetitions carefully, to make sure that they do not cause combinatorial explosions in backtracking."
msgstr "@strong{警告:} ネストされた繰り返し処理は、それらが曖昧なマッチとなるような場合は、無期限な長時間の実行となり得る。たとえば文字列@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}にたいして正規表現@samp{\\(x+y*\\)*a}のマッチを試みると、それが最終的に失敗するまでに数時間を要し得る。Emacsはその試みのいずれも機能しないと結論する前に、@samp{x}のグループ家のそれぞれを試みなければならない。さらに悪いことに、@samp{\\(x*\\)*}は無数の方法でnull文字列にマッチ可能なので、これは無限ループを引き起こす。これらの問題を避けるには、ネストされた繰り返しがバックトラッキングでの組み合わせ爆発(combinatorial explosion)が発生しないことを確実にするために注意深くチェックすること。"

#. type: samp{#1}
#: searching.texi.orig:347
#, no-wrap
msgid "+"
msgstr "+"

#. type: cindex
#: searching.texi.orig:348
#, no-wrap
msgid "@samp{+} in regexp"
msgstr "@samp{+} in regexp"

#. type: table
#: searching.texi.orig:353
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression at least once.  So, for example, @samp{ca+r} matches the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, whereas @samp{ca*r} matches all three strings."
msgstr "これは@samp{*}のような後置演算子だが、これは前置された表現に少なくとも1回マッチしなければならない点が異なる。たとえば@samp{ca+r}は文字列@samp{car}や@samp{caaaar}にマッチするが、文字列@samp{cr}にはマッチせず、その一方で@samp{ca*r}はこれら3つすべての文字列にマッチする。"

#. type: samp{#1}
#: searching.texi.orig:354
#, no-wrap
msgid "?"
msgstr "?"

#. type: cindex
#: searching.texi.orig:355
#, no-wrap
msgid "@samp{?} in regexp"
msgstr "@samp{?} in regexp"

#. type: table
#: searching.texi.orig:359
msgid "is a postfix operator, similar to @samp{*} except that it must match the preceding expression either once or not at all.  For example, @samp{ca?r} matches @samp{car} or @samp{cr}; nothing else."
msgstr "これは@samp{*}のような後置演算子だが、これは前置された表現に1回、またはマッチしないかのいずれかでなければならない点が異なる。申@samp{ca?r}は@samp{car}と@samp{cr}にマッチするが、他にはマッチしない。"

#. type: item
#: searching.texi.orig:360
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr "@samp{*?}, @samp{+?}, @samp{??}"

#. type: cindex
#: searching.texi.orig:361
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr "non-greedy repetition characters in regexp"

#. type: table
#: searching.texi.orig:367
msgid "These are ``non-greedy'' variants of the operators @samp{*}, @samp{+} and @samp{?}.  Where those operators match the largest possible substring (consistent with matching the entire containing expression), the non-greedy variants match the smallest possible substring (consistent with matching the entire containing expression)."
msgstr "演算子 @samp{*}、@samp{+}、@samp{?}には``非欲張り(non-greedy)''な変種が存在する。これらの演算子が可能な最長の部分文字列(含まれる表現全体へのマッチと等しい)とマッチするのにたいして、非欲張りな変種は可能な最短の部分文字列(含まれる表現全体と等しい)にマッチする。"

#. type: table
#: searching.texi.orig:373
msgid "For example, the regular expression @samp{c[ad]*a} when applied to the string @samp{cdaaada} matches the whole string; but the regular expression @samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The smallest possible match here for @samp{[ad]*?} that permits the whole expression to match is @samp{d}.)"
msgstr "たとえば正規表現@samp{c[ad]*a}が文字列@samp{cdaaada}に適用されると文字列全体にマッチするが、正規表現@samp{c[ad]*?a}を同じ文字列に適用すると@samp{cda}だけにマッチする(ここでマッチが許された表現全体にたいする@samp{[ad]*?}の可能な最短マッチは@samp{d}である)。"

#. type: samp{#1}
#: searching.texi.orig:374
#, no-wrap
msgid "[ @dots{} ]"
msgstr "[ @dots{} ]"

#. type: cindex
#: searching.texi.orig:375
#, no-wrap
msgid "character alternative (in regexp)"
msgstr "character alternative (in regexp)"

#. type: cindex
#: searching.texi.orig:376
#, no-wrap
msgid "@samp{[} in regexp"
msgstr "@samp{[} in regexp"

#. type: cindex
#: searching.texi.orig:377
#, no-wrap
msgid "@samp{]} in regexp"
msgstr "@samp{]} in regexp"

#. type: table
#: searching.texi.orig:381
msgid "is a @dfn{character alternative}, which begins with @samp{[} and is terminated by @samp{]}.  In the simplest case, the characters between the two brackets are what this character alternative can match."
msgstr "これは@samp{[}で始まり@samp{]}で終端される@dfn{文字候補(character alternative)}である。もっとも単純なケースでは、この２つのカッコ(brackets)の間にある文字が、この文字候補がマッチ可能な文字である。"

#. type: table
#: searching.texi.orig:386
msgid "Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and @samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s (including the empty string).  It follows that @samp{c[ad]*r} matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr "したがって@samp{[ad]}は1つの@samp{a}と1つの@samp{d}の両方にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}だけから構成された任意の文字列(空文字列を含む)にマッチする。つまり@samp{c[ad]*r}は@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}等にマッチする。"

#. type: table
#: searching.texi.orig:393
msgid "You can also include character ranges in a character alternative, by writing the starting and ending characters with a @samp{-} between them.  Thus, @samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be intermixed freely with individual characters, as in @samp{[a-z$%.]}, which matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or period."
msgstr "開始文字と終了文字の間に@samp{-}を記述することにより、文字候補内に文字範囲を含めることができる。つまり@samp{[a-z]}は小文字の@acronym{ASCII}アルファベット文字にマッチする。範囲は@samp{[a-z$%.]}のように個別の文字と自由に組み合わせることができる。これは任意の@acronym{ASCII}小文字アルファベットと@samp{$}、@samp{%}、またはピリオドとマッチする。"

#. type: table
#: searching.texi.orig:402
msgid "If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches upper-case letters.  Note that a range like @samp{[a-z]} is not affected by the locale's collation sequence, it always represents a sequence in @acronym{ASCII} order."
msgstr "@code{case-fold-search}が非@code{nil}なら、@samp{[a-z]}は大文字アルファベットにもマッチする。@samp{[a-z]}のような範囲は、そのlocaleの照合順に影響されず、常に@acronym{ASCII}順のシーケンスを表すことに注意。"

#. type: table
#: searching.texi.orig:406
msgid "Note also that the usual regexp special characters are not special inside a character alternative.  A completely different set of characters is special inside character alternatives: @samp{]}, @samp{-} and @samp{^}."
msgstr "さらに通常のregexpスペシャル文字は文字候補内では特別ではないことにも注意されたい。文字候補内部では@samp{]}、@samp{-}、@samp{^}という完全に異なる文字セットが特別に扱われる。"

#. type: table
#: searching.texi.orig:414
msgid "To include a @samp{]} in a character alternative, you must make it the first character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.  To include a @samp{-}, write @samp{-} as the first or last character of the character alternative, or put it after a range.  Thus, @samp{[]-]} matches both @samp{]} and @samp{-}.  (As explained below, you cannot use @samp{\\]} to include a @samp{]} inside a character alternative, since @samp{\\} is not special there.)"
msgstr "文字候補内に@samp{]}を含めるには、それを最初の文字にしなければならない。たとえば@samp{[]a]}は、@samp{]}と@samp{a}にマッチする。@samp{-}を含めるには、文字候補の最初または最後の文字として@samp{-}を記述するか、範囲の後に置くこと。つまり@samp{[]-]}は@samp{]}と@samp{-}の両方にマッチする。(以下で説明するように、ここでは@samp{\\}は特別ではないので、文字候補内に@samp{]}を含めるために@samp{\\]}は使用できない)。"

#. type: table
#: searching.texi.orig:417
msgid "To include @samp{^} in a character alternative, put it anywhere but at the beginning."
msgstr "文字候補内に@samp{^}を含めるには、先頭以外のいずれかの場所に置くこと。"

#. type: table
#: searching.texi.orig:425
msgid "If a range starts with a unibyte character @var{c} and ends with a multibyte character @var{c2}, the range is divided into two parts: one spans the unibyte characters @samp{@var{c}..?\\377}, the other the multibyte characters @samp{@var{c1}..@var{c2}}, where @var{c1} is the first character of the charset to which @var{c2} belongs."
msgstr "ある範囲がユニバイト文字@var{c}で始まり、マルチバイト文字@var{c2}でお話場合、その範囲は2つの部分に分割される。1つはユニバイト文字@samp{@var{c}..?\\377}、もう1つはマルチバイト文字@samp{@var{c1}..@var{c2}}である。ここで@var{c1}は@var{c2}が属する文字セットの最初の文字である。"

#. type: table
#: searching.texi.orig:432
msgid "A character alternative can also specify named character classes (@pxref{Char Classes}).  This is a POSIX feature.  For example, @samp{[[:ascii:]]} matches any @acronym{ASCII} character.  Using a character class is equivalent to mentioning each of the characters in that class; but the latter is not feasible in practice, since some classes include thousands of different characters."
msgstr "文字候補には、名前付き文字クラスも指定できる(@ref{Char Classes}を参照)。これはPOSIXの機能である。たとえば@samp{[[:ascii:]]}は、任意の@acronym{ASCII}文字にマッチする。文字クラスの使用は、そのクラス内すべての文字を記述するのと等しい。しかし異なる文字数千を含むクラスもあるので、後者は実際は実現可能ではない。"

#. type: samp{#1}
#: searching.texi.orig:433
#, no-wrap
msgid "[^ @dots{} ]"
msgstr "[^ @dots{} ]"

#. type: cindex
#: searching.texi.orig:434
#, no-wrap
msgid "@samp{^} in regexp"
msgstr "@samp{^} in regexp"

#. type: table
#: searching.texi.orig:439
msgid "@samp{[^} begins a @dfn{complemented character alternative}.  This matches any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all characters @emph{except} letters and digits."
msgstr "@samp{[^}は@dfn{補完文字候補(complemented character alternative)}を開始する。これは、指定された以外の任意の文字とマッチする。つまり@samp{[^a-z0-9A-Z]}はアルファベットと数日前@emph{以外}の、すべての文字にマッチする。"

#. type: table
#: searching.texi.orig:443
msgid "@samp{^} is not special in a character alternative unless it is the first character.  The character following the @samp{^} is treated as if it were first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr "@samp{^}は文字クラス内では、先頭に記述されない限り特別ではない。@samp{^}に続く文字は、あたかもそれが先頭にあるかのように扱われる(別の言い方をすると@samp{-}や@samp{]}は、ここでは特別ではない)。"

#. type: table
#: searching.texi.orig:447
msgid "A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match.  This is in contrast to the handling of regexps in programs such as @code{grep}."
msgstr "マッチしない文字の1つとして改行が記述されていなければ、補完文字候補は改行にマッチできる。これは@code{grep}のようなプログラム内でのregexpの扱いとは、対照的である。"

#. type: table
#: searching.texi.orig:451
msgid "You can specify named character classes, just like in character alternatives.  For instance, @samp{[^[:ascii:]]} matches any non-@acronym{ASCII} character.  @xref{Char Classes}."
msgstr "文字候補のように、名前付き文字クラスを指定できる。たとえば@samp{[^[:ascii:]]}は、任意の非@acronym{ASCII}文字にマッチする。@ref{Char Classes}を参照のこと。"

#. type: samp{#1}
#: searching.texi.orig:452
#, no-wrap
msgid "^"
msgstr "^"

#. type: cindex
#: searching.texi.orig:453
#, no-wrap
msgid "beginning of line in regexp"
msgstr "beginning of line in regexp"

#. type: table
#: searching.texi.orig:459
msgid "When matching a buffer, @samp{^} matches the empty string, but only at the beginning of a line in the text being matched (or the beginning of the accessible portion of the buffer).  Otherwise it fails to match anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a line."
msgstr "バッファーのマッチング時、@samp{^}は空文字列、ただしマッチ対象のテキスト内にある行の先頭(またはバッファーのアクセス可能範囲の先頭)だけにマッチする。それ以外のマッチは、すべて失敗する。つまり@samp{^foo}は、行の先頭に出現する@samp{foo}にマッチする。"

#. type: table
#: searching.texi.orig:462
msgid "When matching a string instead of a buffer, @samp{^} matches at the beginning of the string or after a newline character."
msgstr "バッファーではなく文字列とマッチする際は、@samp{^}は文字列の先頭、または改行文字の後にマッチする。"

#. type: table
#: searching.texi.orig:466
msgid "For historical compatibility reasons, @samp{^} can be used only at the beginning of the regular expression, or after @samp{\\(}, @samp{\\(?:} or @samp{\\|}."
msgstr "歴史的な互換性という理由により、@samp{^}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の後だけで使用できる。"

#. type: samp{#1}
#: searching.texi.orig:467
#, no-wrap
msgid "$"
msgstr "$"

#. type: cindex
#: searching.texi.orig:468
#, no-wrap
msgid "@samp{$} in regexp"
msgstr "@samp{$} in regexp"

#. type: cindex
#: searching.texi.orig:469
#, no-wrap
msgid "end of line in regexp"
msgstr "end of line in regexp"

#. type: table
#: searching.texi.orig:473
msgid "is similar to @samp{^} but matches only at the end of a line (or the end of the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of one @samp{x} or more at the end of a line."
msgstr "これは@samp{^}と似ているが、行の終端(またはバッファーのアクセス可能範囲の終端)だけにマッチする。つまり@samp{x+$}は、行末にある1つ以上の@samp{x}からなる文字列にマッチする。"

#. type: table
#: searching.texi.orig:476
msgid "When matching a string instead of a buffer, @samp{$} matches at the end of the string or before a newline character."
msgstr "バッファーではなく文字列とマッチする際は、@samp{$}は文字列の終端、または改行文字の前にマッチする。"

#. type: table
#: searching.texi.orig:479
msgid "For historical compatibility reasons, @samp{$} can be used only at the end of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr "歴史的な互換性という理由により、@samp{$}は正規表現の先頭、または@samp{\\(}、@samp{\\(?:}、@samp{\\|}の前だけで使用できる。"

#. type: samp{#1}
#: searching.texi.orig:480
#, no-wrap
msgid "\\"
msgstr "\\"

#. type: cindex
#: searching.texi.orig:481
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr "@samp{\\} in regexp"

#. type: table
#: searching.texi.orig:484
msgid "has two functions: it quotes the special characters (including @samp{\\}), and it introduces additional special constructs."
msgstr "これは2つの機能をもつ。スペシャル文字(@samp{\\}を含む)のクォートと、追加のスペシャル文字の導入である。"

#. type: table
#: searching.texi.orig:488
msgid "Because @samp{\\} quotes special characters, @samp{\\$} is a regular expression that matches only @samp{$}, and @samp{\\[} is a regular expression that matches only @samp{[}, and so on."
msgstr "@samp{\\}はスペシャル文字をクォートするので、@samp{\\$}は@samp{$}、@samp{\\[}は@samp{[}だけにマッチする正規表現といったようになる。"

#. type: table
#: searching.texi.orig:496
msgid "Note that @samp{\\} also has special meaning in the read syntax of Lisp strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For example, the regular expression that matches the @samp{\\} character is @samp{\\\\}.  To write a Lisp string that contains the characters @samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another @samp{\\}.  Therefore, the read syntax for a regular expression matching @samp{\\} is @code{\"\\\\\\\\\"}."
msgstr "@samp{\\}はLisp文字列(@ref{String Type}を参照)の入力構文(read syntax)内でも特別な意味をもち、@samp{\\}でクォートしなければならないことに注意。たとえば文字@samp{\\}にマッチする正規表現は@samp{\\\\}である。文字@samp{\\\\}を含むLisp文字列を記述するには、別の@samp{\\\\}で@samp{\\\\}をクォートすることをLisp構文は要求する。したがって@samp{\\}にマッチする正規表現にたいする入力構文は、@code{\"\\\\\\\\\"}となる。"

#. type: Plain text
#: searching.texi.orig:504
msgid "@strong{Please note:} For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense.  For example, @samp{*foo} treats @samp{*} as ordinary since there is no preceding expression on which the @samp{*} can act.  It is poor practice to depend on this behavior; quote the special character anyway, regardless of where it appears."
msgstr "@strong{注意してください:} 歴史的な互換性のために、スペシャル文字はそれらがもつ特別な意味が意味を成さないコンテキスト内にある場合は、通常の文字として扱われます。たとえば@samp{*foo}は、@samp{*}が作用可能な前置された表現がないので、通常の@samp{*}として扱われます。この挙動に依存するのは悪い習慣です。どこにそれが出現しようと、スペシャル文字はすべてクォートしてください。"

#. type: Plain text
#: searching.texi.orig:512
msgid "As a @samp{\\} is not special inside a character alternative, it can never remove the special meaning of @samp{-} or @samp{]}.  So you should not quote these characters when they have no special meaning either.  This would not clarify anything, since backslashes can legitimately precede these characters where they @emph{have} special meaning, as in @samp{[^\\]} (@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single character except a backslash."
msgstr "文字候補内で@samp{\\}は何ら特別ではないので、@samp{-}や@samp{]}の特別な意味を取り除くことは決してありません。特別な意味をもたないような場合でも、これらの文字をクォートするべきではありません。バックスラッシュ以外の任意の1文字にマッチする@samp{[^\\]}(Lisp文字列構文では@code{\"[^\\\\]\"})内でのように、これらの文字が@emph{特別な意味}をもつ箇所では、これらの文字にバックスラッシュを前置する正当性があるので、それほど何も明解にはしないでしょう。"

#. type: Plain text
#: searching.texi.orig:522
msgid "In practice, most @samp{]} that occur in regular expressions close a character alternative and hence are special.  However, occasionally a regular expression may try to match a complex pattern of literal @samp{[} and @samp{]}.  In such situations, it sometimes may be necessary to carefully parse the regexp from the start to determine which square brackets enclose a character alternative.  For example, @samp{[^][]]} consists of the complemented character alternative @samp{[^][]} (which matches any single character that is not a square bracket), followed by a literal @samp{]}."
msgstr "実際には、正規表現内に出現する@samp{]}は文字候補に近接しており、それ故にほとんどがスペシャル文字です。しかしリテラルの@samp{[}および@samp{]}の複雑なパターンにたいして、マッチを試みることも時にはあるかもしれません。そのような状況では、文字候補を囲う角カッコがどれなのかを判断するために、regexpを最初から注意深く解析するのが必要なときもあるかもしれません。たとえば@samp{[^][]]}は、補完文字候補@samp{[^][]}(角カッコ以外の任意の1文字とマッチする)と、その後のリテラルの@samp{]}により構成されます。"

#. type: Plain text
#: searching.texi.orig:532
msgid "The exact rules are that at the beginning of a regexp, @samp{[} is special and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which we are in a character alternative; @samp{[} is no longer special (except when it starts a character class) but @samp{]} is special, unless it immediately follows the special @samp{[} or that @samp{[} followed by a @samp{^}.  This lasts until the next special @samp{]} that does not end a character class.  This ends the character alternative and restores the ordinary syntax of regular expressions; an unquoted @samp{[} is special again and a @samp{]} not."
msgstr "厳密にはregexp先頭の@samp{[}は特別で、@samp{]}は特別ではないというのがルールです。これはクォートされていない最初の@samp{[}で終わり、その後は文字候補になります。(文字クラス開始を除き)@samp{[}はもはや特別ではありませんが、@samp{]}は直後にスペシャル文字@samp{[}があるか、その@samp{[}の後に@samp{^}がある場合を除き、特別です。これは文字クラス終了ではない次のスペシャル文字@samp{]}まで続きます。これは文字候補を終了させて、通常の正規表現の構文をリストアします。クォートされていない@samp{[}は再び特別となり、@samp{]}は特別ではなくなります。"

#. type: subsubsection
#: searching.texi.orig:534
#, no-wrap
msgid "Character Classes"
msgstr ""

#. type: cindex
#: searching.texi.orig:535
#, no-wrap
msgid "character classes in regexp"
msgstr ""

#. type: Plain text
#: searching.texi.orig:539
msgid "Here is a table of the classes you can use in a character alternative, and what they mean:"
msgstr ""

#. type: item
#: searching.texi.orig:541
#, no-wrap
msgid "[:ascii:]"
msgstr ""

#. type: table
#: searching.texi.orig:543
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: item
#: searching.texi.orig:543
#, no-wrap
msgid "[:alnum:]"
msgstr ""

#. type: table
#: searching.texi.orig:546
msgid "This matches any letter or digit.  (At present, for multibyte characters, it matches anything that has word syntax.)"
msgstr ""

#. type: item
#: searching.texi.orig:546
#, no-wrap
msgid "[:alpha:]"
msgstr ""

#. type: table
#: searching.texi.orig:549
msgid "This matches any letter.  (At present, for multibyte characters, it matches anything that has word syntax.)"
msgstr ""

#. type: item
#: searching.texi.orig:549
#, no-wrap
msgid "[:blank:]"
msgstr ""

#. type: table
#: searching.texi.orig:551
msgid "This matches space and tab only."
msgstr ""

#. type: item
#: searching.texi.orig:551
#, no-wrap
msgid "[:cntrl:]"
msgstr ""

#. type: table
#: searching.texi.orig:553
msgid "This matches any @acronym{ASCII} control character."
msgstr ""

#. type: item
#: searching.texi.orig:553
#, no-wrap
msgid "[:digit:]"
msgstr ""

#. type: table
#: searching.texi.orig:556
msgid "This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches any digit, as well as @samp{+} and @samp{-}."
msgstr ""

#. type: item
#: searching.texi.orig:556
#, no-wrap
msgid "[:graph:]"
msgstr ""

#. type: table
#: searching.texi.orig:559
msgid "This matches graphic characters---everything except @acronym{ASCII} control characters, space, and the delete character."
msgstr ""

#. type: item
#: searching.texi.orig:559
#, no-wrap
msgid "[:lower:]"
msgstr ""

#. type: table
#: searching.texi.orig:563
msgid "This matches any lower-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any upper-case letter."
msgstr ""

#. type: item
#: searching.texi.orig:563
#, no-wrap
msgid "[:multibyte:]"
msgstr ""

#. type: table
#: searching.texi.orig:565
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: searching.texi.orig:565
#, no-wrap
msgid "[:nonascii:]"
msgstr ""

#. type: table
#: searching.texi.orig:567
msgid "This matches any non-@acronym{ASCII} character."
msgstr ""

#. type: item
#: searching.texi.orig:567
#, no-wrap
msgid "[:print:]"
msgstr ""

#. type: table
#: searching.texi.orig:570
msgid "This matches printing characters---everything except @acronym{ASCII} control characters and the delete character."
msgstr ""

#. type: item
#: searching.texi.orig:570
#, no-wrap
msgid "[:punct:]"
msgstr ""

#. type: table
#: searching.texi.orig:573
msgid "This matches any punctuation character.  (At present, for multibyte characters, it matches anything that has non-word syntax.)"
msgstr ""

#. type: item
#: searching.texi.orig:573
#, no-wrap
msgid "[:space:]"
msgstr ""

#. type: table
#: searching.texi.orig:576
msgid "This matches any character that has whitespace syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: item
#: searching.texi.orig:576
#, no-wrap
msgid "[:unibyte:]"
msgstr ""

#. type: table
#: searching.texi.orig:578
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: searching.texi.orig:578
#, no-wrap
msgid "[:upper:]"
msgstr ""

#. type: table
#: searching.texi.orig:582
msgid "This matches any upper-case letter, as determined by the current case table (@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this also matches any lower-case letter."
msgstr ""

#. type: item
#: searching.texi.orig:582
#, no-wrap
msgid "[:word:]"
msgstr ""

#. type: table
#: searching.texi.orig:585
msgid "This matches any character that has word syntax (@pxref{Syntax Class Table})."
msgstr ""

#. type: item
#: searching.texi.orig:585
#, no-wrap
msgid "[:xdigit:]"
msgstr ""

#. type: table
#: searching.texi.orig:588
msgid "This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} through @samp{f} and @samp{A} through @samp{F}."
msgstr ""

#. type: subsubsection
#: searching.texi.orig:591
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr ""

#. type: cindex
#: searching.texi.orig:592
#, no-wrap
msgid "backslash in regular expressions"
msgstr ""

#. type: Plain text
#: searching.texi.orig:598
msgid "For the most part, @samp{\\} followed by any character matches only that character.  However, there are several exceptions: certain sequences starting with @samp{\\} that have special meanings.  Here is a table of the special @samp{\\} constructs."
msgstr ""

#. type: item
#: searching.texi.orig:600
#, no-wrap
msgid "\\|"
msgstr ""

#. type: cindex
#: searching.texi.orig:601
#, no-wrap
msgid "@samp{|} in regexp"
msgstr ""

#. type: cindex
#: searching.texi.orig:602
#, no-wrap
msgid "regexp alternative"
msgstr ""

#. type: table
#: searching.texi.orig:607
msgid "specifies an alternative.  Two regular expressions @var{a} and @var{b} with @samp{\\|} in between form an expression that matches anything that either @var{a} or @var{b} matches."
msgstr ""

#. type: table
#: searching.texi.orig:610
msgid "Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other string."
msgstr ""

#. type: table
#: searching.texi.orig:614
msgid "@samp{\\|} applies to the largest possible surrounding expressions.  Only a surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of @samp{\\|}."
msgstr ""

#. type: table
#: searching.texi.orig:618
msgid "If you need full backtracking capability to handle multiple uses of @samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX Regexps})."
msgstr ""

#. type: item
#: searching.texi.orig:619
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr ""

#. type: table
#: searching.texi.orig:624
msgid "is a postfix operator that repeats the previous pattern exactly @var{m} times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, @samp{cdddr}, @samp{cadar}, and so on."
msgstr ""

#. type: item
#: searching.texi.orig:625
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr ""

#. type: table
#: searching.texi.orig:630
msgid "is a more general postfix operator that specifies repetition with a minimum of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, the minimum is 0; if @var{n} is omitted, there is no maximum."
msgstr ""

#. type: table
#: searching.texi.orig:637
msgid "For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, @samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to @samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to @samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr ""

#. type: item
#: searching.texi.orig:638
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr ""

#. type: cindex
#: searching.texi.orig:639
#, no-wrap
msgid "@samp{(} in regexp"
msgstr ""

#. type: cindex
#: searching.texi.orig:640
#, no-wrap
msgid "@samp{)} in regexp"
msgstr ""

#. type: cindex
#: searching.texi.orig:641
#, no-wrap
msgid "regexp grouping"
msgstr ""

#. type: table
#: searching.texi.orig:643
msgid "is a grouping construct that serves three purposes:"
msgstr ""

#. type: enumerate
#: searching.texi.orig:649
msgid "To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or @samp{barx}."
msgstr ""

#. type: enumerate
#: searching.texi.orig:655
msgid "To enclose a complicated expression for the postfix operators @samp{*}, @samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches @samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any number (zero or more) of @samp{na} strings."
msgstr ""

#. type: enumerate
#: searching.texi.orig:659
msgid "To record a matched substring for future reference with @samp{\\@var{digit}} (see below)."
msgstr ""

#. type: table
#: searching.texi.orig:667
msgid "This last application is not a consequence of the idea of a parenthetical grouping; it is a separate feature that was assigned as a second meaning to the same @samp{\\( @dots{} \\)} construct because, in practice, there was usually no conflict between the two meanings.  But occasionally there is a conflict, and that led to the introduction of shy groups."
msgstr ""

#. type: item
#: searching.texi.orig:668
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr ""

#. type: cindex
#: searching.texi.orig:669
#, no-wrap
msgid "shy groups"
msgstr ""

#. type: cindex
#: searching.texi.orig:670
#, no-wrap
msgid "non-capturing group"
msgstr ""

#. type: cindex
#: searching.texi.orig:671
#, no-wrap
msgid "unnumbered group"
msgstr ""

#. type: cindex
#: searching.texi.orig:672
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:680
msgid "is the @dfn{shy group} construct.  A shy group serves the first two purposes of an ordinary group (controlling the nesting of other operators), but it does not get a number, so you cannot refer back to its value with @samp{\\@var{digit}}.  Shy groups are particularly useful for mechanically-constructed regular expressions, because they can be added automatically without altering the numbering of ordinary, non-shy groups."
msgstr ""

#. type: table
#: searching.texi.orig:683
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr ""

#. type: item
#: searching.texi.orig:684
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr ""

#. type: table
#: searching.texi.orig:693
msgid "is the @dfn{explicitly numbered group} construct.  Normal groups get their number implicitly, based on their position, which can be inconvenient.  This construct allows you to force a particular group number.  There is no particular restriction on the numbering, e.g., you can have several groups with the same number in which case the last one to match (i.e., the rightmost match) will win.  Implicitly numbered groups always get the smallest integer larger than the one of any previous group."
msgstr ""

#. type: item
#: searching.texi.orig:694
#, no-wrap
msgid "\\@var{digit}"
msgstr ""

#. type: table
#: searching.texi.orig:697
msgid "matches the same text that matched the @var{digit}th occurrence of a grouping (@samp{\\( @dots{} \\)}) construct."
msgstr ""

#. type: table
#: searching.texi.orig:702
msgid "In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group.  Later on in the regular expression you can use @samp{\\} followed by @var{digit} to match that same text, whatever it may have been."
msgstr ""

#. type: table
#: searching.texi.orig:709
msgid "The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to refer to the text matched by the corresponding grouping constructs."
msgstr ""

#. type: table
#: searching.texi.orig:714
msgid "For example, @samp{\\(.*\\)\\1} matches any newline-free string that is composed of two identical halves.  The @samp{\\(.*\\)} matches the first half, which may be anything, but the @samp{\\1} that follows must match the same exact text."
msgstr ""

#. type: table
#: searching.texi.orig:718
msgid "If a @samp{\\( @dots{} \\)} construct matches more than once (which can happen, for instance, if it is followed by @samp{*}), only the last match is recorded."
msgstr ""

#. type: table
#: searching.texi.orig:728
msgid "If a particular grouping construct in the regular expression was never matched---for instance, if it appears inside of an alternative that wasn't used, or inside of a repetition that repeated zero times---then the corresponding @samp{\\@var{digit}} construct never matches anything.  To use an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match @samp{lose}: the second alternative inside the larger group matches it, but then @samp{\\2} is undefined and can't match anything.  But it can match @samp{foobb}, because the first alternative matches @samp{foob} and @samp{\\2} matches @samp{b}."
msgstr ""

#. type: item
#: searching.texi.orig:729
#, no-wrap
msgid "\\w"
msgstr ""

#. type: cindex
#: searching.texi.orig:730
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:733
msgid "matches any word-constituent character.  The editor syntax table determines which characters these are.  @xref{Syntax Tables}."
msgstr ""

#. type: item
#: searching.texi.orig:734
#, no-wrap
msgid "\\W"
msgstr ""

#. type: cindex
#: searching.texi.orig:735
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:737
msgid "matches any character that is not a word constituent."
msgstr ""

#. type: item
#: searching.texi.orig:738
#, no-wrap
msgid "\\s@var{code}"
msgstr ""

#. type: cindex
#: searching.texi.orig:739
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:746
msgid "matches any character whose syntax is @var{code}.  Here @var{code} is a character that represents a syntax code: thus, @samp{w} for word constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  To represent whitespace syntax, use either @samp{-} or a space character.  @xref{Syntax Class Table}, for a list of syntax codes and the characters that stand for them."
msgstr ""

#. type: item
#: searching.texi.orig:747
#, no-wrap
msgid "\\S@var{code}"
msgstr ""

#. type: cindex
#: searching.texi.orig:748
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:750
msgid "matches any character whose syntax is not @var{code}."
msgstr ""

#. type: cindex
#: searching.texi.orig:751
#, no-wrap
msgid "category, regexp search for"
msgstr ""

#. type: item
#: searching.texi.orig:752
#, no-wrap
msgid "\\c@var{c}"
msgstr ""

#. type: table
#: searching.texi.orig:760
msgid "matches any character whose category is @var{c}.  Here @var{c} is a character that represents a category: thus, @samp{c} for Chinese characters or @samp{g} for Greek characters in the standard category table.  You can see the list of all the currently defined categories with @kbd{M-x describe-categories @key{RET}}.  You can also define your own categories in addition to the standard ones using the @code{define-category} function (@pxref{Categories})."
msgstr ""

#. type: item
#: searching.texi.orig:761
#, no-wrap
msgid "\\C@var{c}"
msgstr ""

#. type: table
#: searching.texi.orig:763
msgid "matches any character whose category is not @var{c}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:770
msgid "The following regular expression constructs match the empty string---that is, they don't use up any characters---but whether they match depends on the context.  For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer."
msgstr ""

#. type: item
#: searching.texi.orig:772
#, no-wrap
msgid "\\`"
msgstr ""

#. type: cindex
#: searching.texi.orig:773
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:776
msgid "matches the empty string, but only at the beginning of the buffer or string being matched against."
msgstr ""

#. type: item
#: searching.texi.orig:777
#, no-wrap
msgid "\\'"
msgstr ""

#. type: cindex
#: searching.texi.orig:778
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:781
msgid "matches the empty string, but only at the end of the buffer or string being matched against."
msgstr ""

#. type: item
#: searching.texi.orig:782
#, no-wrap
msgid "\\="
msgstr ""

#. type: cindex
#: searching.texi.orig:783
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:786
msgid "matches the empty string, but only at point.  (This construct is not defined when matching against a string.)"
msgstr ""

#. type: item
#: searching.texi.orig:787
#, no-wrap
msgid "\\b"
msgstr ""

#. type: cindex
#: searching.texi.orig:788
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:793
msgid "matches the empty string, but only at the beginning or end of a word.  Thus, @samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  @samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr ""

#. type: table
#: searching.texi.orig:796
msgid "@samp{\\b} matches at the beginning or end of the buffer (or string)  regardless of what text appears next to it."
msgstr ""

#. type: item
#: searching.texi.orig:797
#, no-wrap
msgid "\\B"
msgstr ""

#. type: cindex
#: searching.texi.orig:798
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:801
msgid "matches the empty string, but @emph{not} at the beginning or end of a word, nor at the beginning or end of the buffer (or string)."
msgstr ""

#. type: item
#: searching.texi.orig:802
#, no-wrap
msgid "\\<"
msgstr ""

#. type: cindex
#: searching.texi.orig:803
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:807
msgid "matches the empty string, but only at the beginning of a word.  @samp{\\<} matches at the beginning of the buffer (or string) only if a word-constituent character follows."
msgstr ""

#. type: item
#: searching.texi.orig:808
#, no-wrap
msgid "\\>"
msgstr ""

#. type: cindex
#: searching.texi.orig:809
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:813
msgid "matches the empty string, but only at the end of a word.  @samp{\\>} matches at the end of the buffer (or string) only if the contents end with a word-constituent character."
msgstr ""

#. type: item
#: searching.texi.orig:814
#, no-wrap
msgid "\\_<"
msgstr ""

#. type: cindex
#: searching.texi.orig:815
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:820
msgid "matches the empty string, but only at the beginning of a symbol.  A symbol is a sequence of one or more word or symbol constituent characters.  @samp{\\_<} matches at the beginning of the buffer (or string) only if a symbol-constituent character follows."
msgstr ""

#. type: item
#: searching.texi.orig:821
#, no-wrap
msgid "\\_>"
msgstr ""

#. type: cindex
#: searching.texi.orig:822
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr ""

#. type: table
#: searching.texi.orig:826
msgid "matches the empty string, but only at the end of a symbol.  @samp{\\_>} matches at the end of the buffer (or string) only if the contents end with a symbol-constituent character."
msgstr ""

#. type: kindex
#: searching.texi.orig:828
#, no-wrap
msgid "invalid-regexp"
msgstr ""

#. type: Plain text
#: searching.texi.orig:834
msgid "Not every string is a valid regular expression.  For example, a string that ends inside a character alternative without a terminating @samp{]} is invalid, and so is a string that ends with a single @samp{\\}.  If an invalid regular expression is passed to any of the search functions, an @code{invalid-regexp} error is signaled."
msgstr ""

#. type: subsection
#: searching.texi.orig:836
#, no-wrap
msgid "Complex Regexp Example"
msgstr ""

#. type: Plain text
#: searching.texi.orig:843
msgid "Here is a complicated regexp which was formerly used by Emacs to recognize the end of a sentence together with any whitespace that follows.  (Nowadays Emacs uses a similar but more complex default regexp constructed by the function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr ""

#. type: Plain text
#: searching.texi.orig:850
msgid "Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it.  The string constant begins and ends with a double-quote.  @samp{\\\"} stands for a double-quote as part of the string, @samp{\\\\} for a backslash as part of the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr ""

#. type: group
#: searching.texi.orig:856
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:861
msgid "In the output, tab and newline appear as themselves."
msgstr ""

#. type: Plain text
#: searching.texi.orig:864
msgid "This regular expression contains four parts in succession and can be deciphered as follows:"
msgstr ""

#. type: item
#: searching.texi.orig:866
#, no-wrap
msgid "[.?!]"
msgstr ""

#. type: table
#: searching.texi.orig:873
msgid "The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark.  The match must begin with one of these three characters.  (This is one point where the new default regexp used by Emacs differs from the old.  The new value also allows some non-@acronym{ASCII} characters that end a sentence without any following whitespace.)"
msgstr ""

#. type: item
#: searching.texi.orig:874
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr ""

#. type: table
#: searching.texi.orig:881
msgid "The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a string.  The @samp{*} at the end indicates that the immediately preceding regular expression (a character alternative, in this case) may be repeated zero or more times."
msgstr ""

#. type: item
#: searching.texi.orig:882
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr ""

#. type: table
#: searching.texi.orig:889
msgid "The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces.  The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives.  The dollar sign is used to match the end of a line."
msgstr ""

#. type: item
#: searching.texi.orig:890
#, no-wrap
msgid "[ \\t\\n]*"
msgstr ""

#. type: table
#: searching.texi.orig:893
msgid "Finally, the last part of the pattern matches any additional whitespace beyond the minimum needed to end a sentence."
msgstr ""

#. type: subsection
#: searching.texi.orig:896
#, no-wrap
msgid "Regular Expression Functions"
msgstr ""

#. type: Plain text
#: searching.texi.orig:899
msgid "These functions operate on regular expressions."
msgstr ""

#. type: cindex
#: searching.texi.orig:900
#, no-wrap
msgid "quote special characters in regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:901
#, no-wrap
msgid "regexp-quote string"
msgstr ""

#. type: defun
#: searching.texi.orig:907
msgid "This function returns a regular expression whose only exact match is @var{string}.  Using this regular expression in @code{looking-at} will succeed only if the next characters in the buffer are @var{string}; using it in a search function will succeed if the text being searched contains @var{string}.  @xref{Regexp Search}."
msgstr ""

#. type: defun
#: searching.texi.orig:910
msgid "This allows you to request an exact string match or search when calling a function that wants a regular expression."
msgstr ""

#. type: group
#: searching.texi.orig:915
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""

#. type: defun
#: searching.texi.orig:922
msgid "One use of @code{regexp-quote} is to combine an exact string match with context described as a regular expression.  For example, this searches for the string that is the value of @var{string}, surrounded by whitespace:"
msgstr ""

#. type: group
#: searching.texi.orig:927
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""

#. type: cindex
#: searching.texi.orig:931
#, no-wrap
msgid "optimize regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:932
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr ""

#. type: defun
#: searching.texi.orig:941
msgid "This function returns an efficient regular expression that will match any of the strings in the list @var{strings}.  This is useful when you need to make matching or searching as fast as possible---for example, for Font Lock mode@footnote{Note that @code{regexp-opt} does not guarantee that its result is absolutely the most efficient form possible.  A hand-tuned regular expression can sometimes be slightly more efficient, but is almost never worth the effort.}."
msgstr ""

#. type: defun
#: searching.texi.orig:950
msgid "If the optional argument @var{paren} is non-@code{nil}, then the returned regular expression is always enclosed by at least one parentheses-grouping construct.  If @var{paren} is @code{words}, then that construct is additionally surrounded by @samp{\\<} and @samp{\\>}; alternatively, if @var{paren} is @code{symbols}, then that construct is additionally surrounded by @samp{\\_<} and @samp{\\_>} (@code{symbols} is often appropriate when matching programming-language keywords and the like)."
msgstr ""

#. type: defun
#: searching.texi.orig:954
msgid "This simplified definition of @code{regexp-opt} produces a regular expression which is equivalent to the actual value (but not as efficient):"
msgstr ""

#. type: example
#: searching.texi.orig:962
#, no-wrap
msgid ""
"(defun regexp-opt (strings &optional paren)\n"
"  (let ((open-paren (if paren \"\\\\(\" \"\"))\n"
"        (close-paren (if paren \"\\\\)\" \"\")))\n"
"    (concat open-paren\n"
"            (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"            close-paren)))\n"
msgstr ""

#. type: defun
#: searching.texi.orig:965
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:969
msgid "This function returns the total number of grouping constructs (parenthesized expressions) in @var{regexp}.  This does not include shy groups (@pxref{Regexp Backslash})."
msgstr ""

#. type: defun
#: searching.texi.orig:972
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr ""

#. type: defun
#: searching.texi.orig:975
msgid "This function returns a regular expression matching a character in the list of characters @var{chars}."
msgstr ""

#. type: example
#: searching.texi.orig:979
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""

#. type: section
#: searching.texi.orig:985
#, no-wrap
msgid "Regular Expression Searching"
msgstr ""

#. type: cindex
#: searching.texi.orig:986
#, no-wrap
msgid "regular expression searching"
msgstr ""

#. type: cindex
#: searching.texi.orig:987
#, no-wrap
msgid "regexp searching"
msgstr ""

#. type: cindex
#: searching.texi.orig:988
#, no-wrap
msgid "searching for regexp"
msgstr ""

#. type: Plain text
#: searching.texi.orig:996
msgid "In GNU Emacs, you can search for the next match for a regular expression (@pxref{Syntax of Regexps}) either incrementally or not.  For incremental search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}.  Here we describe only the search functions useful in programs.  The principal one is @code{re-search-forward}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1000
msgid "These search functions convert the regular expression to multibyte if the buffer is multibyte; they convert the regular expression to unibyte if the buffer is unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: searching.texi.orig:1001
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror repeat"
msgstr ""

#. type: deffn
#: searching.texi.orig:1007
msgid "This function searches forward in the current buffer for a string of text that is matched by the regular expression @var{regexp}.  The function skips over any amount of text that is not matched by @var{regexp}, and leaves point at the end of the first match found.  It returns the new value of point."
msgstr ""

#. type: deffn
#: searching.texi.orig:1011
msgid "If @var{limit} is non-@code{nil}, it must be a position in the current buffer.  It specifies the upper bound to the search.  No match extending after that position is accepted."
msgstr ""

#. type: deffn
#: searching.texi.orig:1018
msgid "If @var{repeat} is supplied, it must be a positive number; the search is repeated that many times; each repetition starts at the end of the previous match.  If all these successive searches succeed, the search succeeds, moving point and returning its new value.  Otherwise the search fails.  What @code{re-search-forward} does when the search fails depends on the value of @var{noerror}:"
msgstr ""

#. type: code{#1}
#: searching.texi.orig:1020
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: searching.texi.orig:1022
msgid "Signal a @code{search-failed} error."
msgstr ""

#. type: code{#1}
#: searching.texi.orig:1022
#, no-wrap
msgid "t"
msgstr ""

#. type: table
#: searching.texi.orig:1024
msgid "Do nothing and return @code{nil}."
msgstr ""

#. type: item
#: searching.texi.orig:1024
#, no-wrap
msgid "anything else"
msgstr ""

#. type: table
#: searching.texi.orig:1027
msgid "Move point to @var{limit} (or the end of the accessible portion of the buffer) and return @code{nil}."
msgstr ""

#. type: deffn
#: searching.texi.orig:1032
msgid "In the following example, point is initially before the @samp{T}.  Evaluating the search call moves point to the end of that line (between the @samp{t} of @samp{hat} and the newline)."
msgstr ""

#. type: group
#: searching.texi.orig:1039
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: searching.texi.orig:1044
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""

#. type: group
#: searching.texi.orig:1049
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: searching.texi.orig:1053
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror repeat"
msgstr ""

#. type: deffn
#: searching.texi.orig:1057
msgid "This function searches backward in the current buffer for a string of text that is matched by the regular expression @var{regexp}, leaving point at the beginning of the first text found."
msgstr ""

#. type: deffn
#: searching.texi.orig:1067
msgid "This function is analogous to @code{re-search-forward}, but they are not simple mirror images.  @code{re-search-forward} finds the match whose beginning is as close as possible to the starting point.  If @code{re-search-backward} were a perfect mirror image, it would find the match whose end is as close as possible.  However, in fact it finds the match whose beginning is as close as possible (and yet ends before the starting point).  The reason for this is that matching a regular expression at a given spot always works from beginning to end, and starts at a specified beginning position."
msgstr ""

#. type: deffn
#: searching.texi.orig:1071
msgid "A true mirror-image of @code{re-search-forward} would require a special feature for matching regular expressions from end to beginning.  It's not worth the trouble of implementing that."
msgstr ""

#. type: defun
#: searching.texi.orig:1073
#, no-wrap
msgid "string-match regexp string &optional start"
msgstr ""

#. type: defun
#: searching.texi.orig:1078
msgid "This function returns the index of the start of the first match for the regular expression @var{regexp} in @var{string}, or @code{nil} if there is no match.  If @var{start} is non-@code{nil}, the search starts at that index in @var{string}."
msgstr ""

#. type: defun
#: searching.texi.orig:1080
msgid "For example,"
msgstr ""

#. type: group
#: searching.texi.orig:1086
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: searching.texi.orig:1091 searching.texi.orig:1106
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1097
msgid "The index of the first character of the string is 0, the index of the second character is 1, and so on."
msgstr ""

#. type: defun
#: searching.texi.orig:1100
msgid "After this function returns, the index of the first character beyond the match is available as @code{(match-end 0)}.  @xref{Match Data}."
msgstr ""

#. type: group
#: searching.texi.orig:1111
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1115
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr ""

#. type: defun
#: searching.texi.orig:1118
msgid "This predicate function does what @code{string-match} does, but it avoids modifying the match data."
msgstr ""

#. type: defun
#: searching.texi.orig:1120
#, no-wrap
msgid "looking-at regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:1126
msgid "This function determines whether the text in the current buffer directly following point matches the regular expression @var{regexp}.  ``Directly following'' means precisely that: the search is ``anchored'' and it can succeed only starting with the first character following point.  The result is @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: searching.texi.orig:1130
msgid "This function does not move point, but it does update the match data.  @xref{Match Data}.  If you need to test for a match without modifying the match data, use @code{looking-at-p}, described below."
msgstr ""

#. type: defun
#: searching.texi.orig:1133
msgid "In this example, point is located directly before the @samp{T}.  If it were anywhere else, the result would be @code{nil}."
msgstr ""

#. type: group
#: searching.texi.orig:1140 searching.texi.orig:1164
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""

#. type: group
#: searching.texi.orig:1143
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1147
#, no-wrap
msgid "looking-back regexp &optional limit greedy"
msgstr ""

#. type: defun
#: searching.texi.orig:1150
msgid "This function returns @code{t} if @var{regexp} matches the text immediately before point (i.e., ending at point), and @code{nil} otherwise."
msgstr ""

#. type: defun
#: searching.texi.orig:1157
msgid "Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point.  That can be quite slow if it has to search a long distance.  You can bound the time required by specifying @var{limit}, which says not to search before @var{limit}.  In this case, the match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr ""

#. type: group
#: searching.texi.orig:1169
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1177
msgid "If @var{greedy} is non-@code{nil}, this function extends the match backwards as far as possible, stopping when a single additional previous character cannot be part of a match for regexp.  When the match is extended, its starting position is allowed to occur before @var{limit}."
msgstr ""

#. type: defun
#: searching.texi.orig:1182
msgid "As a general recommendation, try to avoid using @code{looking-back} wherever possible, since it is slow.  For this reason, there are no plans to add a @code{looking-back-p} function."
msgstr ""

#. type: defun
#: searching.texi.orig:1184
#, no-wrap
msgid "looking-at-p regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:1187
msgid "This predicate function works like @code{looking-at}, but without updating the match data."
msgstr ""

#. type: defvar
#: searching.texi.orig:1189
#, no-wrap
msgid "search-spaces-regexp"
msgstr ""

#. type: defvar
#: searching.texi.orig:1196
msgid "If this variable is non-@code{nil}, it should be a regular expression that says how to search for whitespace.  In that case, any group of spaces in a regular expression being searched for stands for use of this regular expression.  However, spaces inside of constructs such as @samp{[@dots{}]} and @samp{*}, @samp{+}, @samp{?} are not affected by @code{search-spaces-regexp}."
msgstr ""

#. type: defvar
#: searching.texi.orig:1200
msgid "Since this variable affects all regular expression search and match constructs, you should bind it temporarily for as small as possible a part of the code."
msgstr ""

#. type: section
#: searching.texi.orig:1203
#, no-wrap
msgid "POSIX Regular Expression Searching"
msgstr ""

#. type: cindex
#: searching.texi.orig:1205
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1210
msgid "The usual regular expression functions do backtracking when necessary to handle the @samp{\\|} and repetition constructs, but they continue this only until they find @emph{some} match.  Then they succeed and report the first match found."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1217
msgid "This section describes alternative search functions which perform the full backtracking specified by the POSIX standard for regular expression matching.  They continue backtracking until they have tried all possibilities and found all matches, so they can report the longest match, as required by POSIX@.  This is much slower, so use these functions only when you really need the longest match."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1222
msgid "The POSIX search and match functions do not properly support the non-greedy repetition operators (@pxref{Regexp Special, non-greedy}).  This is because POSIX backtracking conflicts with the semantics of non-greedy repetition."
msgstr ""

#. type: deffn
#: searching.texi.orig:1223
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror repeat"
msgstr ""

#. type: deffn
#: searching.texi.orig:1227
msgid "This is like @code{re-search-forward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: deffn
#: searching.texi.orig:1229
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror repeat"
msgstr ""

#. type: deffn
#: searching.texi.orig:1233
msgid "This is like @code{re-search-backward} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: defun
#: searching.texi.orig:1235
#, no-wrap
msgid "posix-looking-at regexp"
msgstr ""

#. type: defun
#: searching.texi.orig:1239
msgid "This is like @code{looking-at} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: defun
#: searching.texi.orig:1241
#, no-wrap
msgid "posix-string-match regexp string &optional start"
msgstr ""

#. type: defun
#: searching.texi.orig:1245
msgid "This is like @code{string-match} except that it performs the full backtracking specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: section
#: searching.texi.orig:1248
#, no-wrap
msgid "The Match Data"
msgstr ""

#. type: cindex
#: searching.texi.orig:1249
#, no-wrap
msgid "match data"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1256
msgid "Emacs keeps track of the start and end positions of the segments of text found during a search; this is called the @dfn{match data}.  Thanks to the match data, you can search for a complex pattern, such as a date in a mail message, and then extract parts of the match under control of the pattern."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1262
msgid "Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data.  If you can't avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1268
msgid "Notice that all functions are allowed to overwrite the match data unless they're explicitly documented not to do so.  A consequence is that functions that are run implicitly in the background (@pxref{Timers}, and @ref{Idle Timers}) should likely save and restore the match data explicitly."
msgstr ""

#. type: node
#: searching.texi.orig:1275 searching.texi.orig:1277
#, no-wrap
msgid "Replacing Match"
msgstr ""

#. type: menuentry
#: searching.texi.orig:1275
msgid "Replacing a substring that was matched."
msgstr ""

#. type: node
#: searching.texi.orig:1275 searching.texi.orig:1361
#, no-wrap
msgid "Simple Match Data"
msgstr ""

#. type: menuentry
#: searching.texi.orig:1275
msgid "Accessing single items of match data, such as where a particular subexpression started."
msgstr ""

#. type: node
#: searching.texi.orig:1275 searching.texi.orig:1506
#, no-wrap
msgid "Entire Match Data"
msgstr ""

#. type: menuentry
#: searching.texi.orig:1275
msgid "Accessing the entire match data at once, as a list."
msgstr ""

#. type: node
#: searching.texi.orig:1275 searching.texi.orig:1588
#, no-wrap
msgid "Saving Match Data"
msgstr ""

#. type: menuentry
#: searching.texi.orig:1275
msgid "Saving and restoring the match data."
msgstr ""

#. type: subsection
#: searching.texi.orig:1278
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr ""

#. type: cindex
#: searching.texi.orig:1279
#, no-wrap
msgid "replace matched text"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1283
msgid "This function replaces all or part of the text matched by the last search.  It works by means of the match data."
msgstr ""

#. type: cindex
#: searching.texi.orig:1284
#, no-wrap
msgid "case in replacements"
msgstr ""

#. type: defun
#: searching.texi.orig:1285
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr ""

#. type: defun
#: searching.texi.orig:1287
msgid "This function performs a replacement operation on a buffer or string."
msgstr ""

#. type: defun
#: searching.texi.orig:1294
msgid "If you did the last search in a buffer, you should omit the @var{string} argument or specify @code{nil} for it, and make sure that the current buffer is the one in which you performed the last search.  Then this function edits the buffer, replacing the matched text with @var{replacement}.  It leaves point at the end of the replacement text."
msgstr ""

#. type: defun
#: searching.texi.orig:1298
msgid "If you performed the last search on a string, pass the same string as @var{string}.  Then this function returns a new string, in which the matched text is replaced by @var{replacement}."
msgstr ""

#. type: defun
#: searching.texi.orig:1308
msgid "If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the replacement text without case conversion; otherwise, it converts the replacement text depending upon the capitalization of the text to be replaced.  If the original text is all upper case, this converts the replacement text to upper case.  If all words of the original text are capitalized, this capitalizes all the words of the replacement text.  If all the words are one-letter and they are all upper case, they are treated as capitalized words rather than all-upper-case words."
msgstr ""

#. type: defun
#: searching.texi.orig:1314
msgid "If @var{literal} is non-@code{nil}, then @var{replacement} is inserted exactly as it is, the only alterations being case changes as needed.  If it is @code{nil} (the default), then the character @samp{\\} is treated specially.  If a @samp{\\} appears in @var{replacement}, then it must be part of one of the following sequences:"
msgstr ""

#. type: samp{#1}
#: searching.texi.orig:1316
#, no-wrap
msgid "\\&"
msgstr ""

#. type: cindex
#: searching.texi.orig:1317
#, no-wrap
msgid "@samp{&} in replacement"
msgstr ""

#. type: table
#: searching.texi.orig:1319
msgid "This stands for the entire text being replaced."
msgstr ""

#. type: item
#: searching.texi.orig:1320
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr ""

#. type: cindex
#: searching.texi.orig:1321
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr ""

#. type: table
#: searching.texi.orig:1326
msgid "This stands for the text that matched the @var{n}th subexpression in the original regexp.  Subexpressions are those expressions grouped inside @samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an empty string is substituted."
msgstr ""

#. type: samp{#1}
#: searching.texi.orig:1327
#, no-wrap
msgid "\\\\"
msgstr ""

#. type: cindex
#: searching.texi.orig:1328
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr ""

#. type: table
#: searching.texi.orig:1330
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr ""

#. type: samp{#1}
#: searching.texi.orig:1331
#, no-wrap
msgid "\\?"
msgstr ""

#. type: table
#: searching.texi.orig:1335
msgid "This stands for itself (for compatibility with @code{replace-regexp} and related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr ""

#. type: defun
#: searching.texi.orig:1339
msgid "Any other character following @samp{\\} signals an error."
msgstr ""

#. type: defun
#: searching.texi.orig:1343
msgid "The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after case conversion, if any.  Therefore, the strings they substitute are never case-converted."
msgstr ""

#. type: defun
#: searching.texi.orig:1349
msgid "If @var{subexp} is non-@code{nil}, that says to replace just subexpression number @var{subexp} of the regexp that was matched, not the entire match.  For example, after matching @samp{foo \\(ba*r\\)}, calling @code{replace-match} with 1 as @var{subexp} means to replace just the text that matched @samp{\\(ba*r\\)}."
msgstr ""

#. type: defun
#: searching.texi.orig:1351
#, no-wrap
msgid "match-substitute-replacement replacement &optional fixedcase literal string subexp"
msgstr ""

#. type: defun
#: searching.texi.orig:1359
msgid "This function returns the text that would be inserted into the buffer by @code{replace-match}, but without modifying the buffer.  It is useful if you want to present the user with actual replacement result, with constructs like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, @var{string} and @var{subexp} have the same meaning as for @code{replace-match}."
msgstr ""

#. type: subsection
#: searching.texi.orig:1362
#, no-wrap
msgid "Simple Match Data Access"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1366
msgid "This section explains how to use the match data to find out what was matched by the last search or match operation, if it succeeded."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1372
msgid "You can ask about the entire matching text, or about a particular parenthetical subexpression of a regular expression.  The @var{count} argument in the functions below specifies which.  If @var{count} is zero, you are asking about the entire match.  If @var{count} is positive, it specifies which subexpression you want."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1380
msgid "Recall that the subexpressions of a regular expression are those expressions grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th subexpression is found by counting occurrences of @samp{\\(} from the beginning of the whole regular expression.  The first subexpression is numbered 1, the second 2, and so on.  Only regular expressions can have subexpressions---after a simple string search, the only information available is about the entire match."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1388
msgid "Every successful search sets the match data.  Therefore, you should query the match data immediately after searching, before calling any other function that might perform another search.  Alternatively, you may save and restore the match data (@pxref{Saving Match Data}) around the call to functions that could perform another search.  Or use the functions that explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1395
msgid "A search which fails may or may not alter the match data.  In the current implementation, it does not, but we may change it in the future.  Don't try to rely on the value of the match data after a failing search."
msgstr ""

#. type: defun
#: searching.texi.orig:1396
#, no-wrap
msgid "match-string count &optional in-string"
msgstr ""

#. type: defun
#: searching.texi.orig:1401
msgid "This function returns, as a string, the text matched in the last search or match operation.  It returns the entire text if @var{count} is zero, or just the portion corresponding to the @var{count}th parenthetical subexpression, if @var{count} is positive."
msgstr ""

#. type: defun
#: searching.texi.orig:1409
msgid "If the last such operation was done against a string with @code{string-match}, then you should pass the same string as the argument @var{in-string}.  After a buffer search or match, you should omit @var{in-string} or pass @code{nil} for it; but you should make sure that the current buffer when you call @code{match-string} is the one in which you did the searching or matching.  Failure to follow this advice will lead to incorrect results."
msgstr ""

#. type: defun
#: searching.texi.orig:1413
msgid "The value is @code{nil} if @var{count} is out of range, or for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr ""

#. type: defun
#: searching.texi.orig:1415
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr ""

#. type: defun
#: searching.texi.orig:1418
msgid "This function is like @code{match-string} except that the result has no text properties."
msgstr ""

#. type: defun
#: searching.texi.orig:1420
#, no-wrap
msgid "match-beginning count"
msgstr ""

#. type: defun
#: searching.texi.orig:1423
msgid "This function returns the position of the start of the text matched by the last regular expression searched for, or a subexpression of it."
msgstr ""

#. type: defun
#: searching.texi.orig:1428
msgid "If @var{count} is zero, then the value is the position of the start of the entire match.  Otherwise, @var{count} specifies a subexpression in the regular expression, and the value of the function is the starting position of the match for that subexpression."
msgstr ""

#. type: defun
#: searching.texi.orig:1431
msgid "The value is @code{nil} for a subexpression inside a @samp{\\|} alternative that wasn't used or a repetition that repeated zero times."
msgstr ""

#. type: defun
#: searching.texi.orig:1433
#, no-wrap
msgid "match-end count"
msgstr ""

#. type: defun
#: searching.texi.orig:1437
msgid "This function is like @code{match-beginning} except that it returns the position of the end of the match, rather than the position of the beginning."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1441
msgid "Here is an example of using the match data, with a comment showing the positions within the text:"
msgstr ""

#. type: group
#: searching.texi.orig:1448
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: searching.texi.orig:1457
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""

#. type: group
#: searching.texi.orig:1462
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""

#. type: group
#: searching.texi.orig:1467
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""

#. type: group
#: searching.texi.orig:1472
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""

#. type: group
#: searching.texi.orig:1475
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1483
msgid "Here is another example.  Point is initially located at the beginning of the line.  Searching moves point to between the space and the word @samp{in}.  The beginning of the entire match is at the 9th character of the buffer (@samp{T}), and the beginning of the match for the first subexpression is at the 13th character (@samp{c})."
msgstr ""

#. type: group
#: searching.texi.orig:1491
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""

#. type: group
#: searching.texi.orig:1499
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1505
msgid "(In this case, the index returned is a buffer position; the first character of the buffer counts as 1.)"
msgstr ""

#. type: subsection
#: searching.texi.orig:1507
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1511
msgid "The functions @code{match-data} and @code{set-match-data} read or write the entire match data, all at once."
msgstr ""

#. type: defun
#: searching.texi.orig:1512
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr ""

#. type: defun
#: searching.texi.orig:1520
msgid "This function returns a list of positions (markers or integers) that record all the information on the text that the last search matched.  Element zero is the position of the beginning of the match for the whole expression; element one is the position of the end of the match for the expression.  The next two elements are the positions of the beginning and end of the match for the first subexpression, and so on.  In general, element"
msgstr ""

#. type: ifnottex
#: searching.texi.orig:1522
msgid "number 2@var{n}"
msgstr ""

#. type: tex
#: searching.texi.orig:1525
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1528
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr ""

#. type: ifnottex
#: searching.texi.orig:1530
msgid "number 2@var{n} + 1"
msgstr ""

#. type: tex
#: searching.texi.orig:1533
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1535
msgid "corresponds to @code{(match-end @var{n})}."
msgstr ""

#. type: defun
#: searching.texi.orig:1543
msgid "Normally all the elements are markers or @code{nil}, but if @var{integers} is non-@code{nil}, that means to use integers instead of markers.  (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.)  If the last match was done on a string with @code{string-match}, then integers are always used, since markers can't point into a string."
msgstr ""

#. type: defun
#: searching.texi.orig:1552
msgid "If @var{reuse} is non-@code{nil}, it should be a list.  In that case, @code{match-data} stores the match data in @var{reuse}.  That is, @var{reuse} is destructively modified.  @var{reuse} does not need to have the right length.  If it is not long enough to contain the match data, it is extended.  If it is too long, the length of @var{reuse} stays the same, but the elements that were not used are set to @code{nil}.  The purpose of this feature is to reduce the need for garbage collection."
msgstr ""

#. type: defun
#: searching.texi.orig:1555
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are reseated to point to nowhere."
msgstr ""

#. type: defun
#: searching.texi.orig:1559
msgid "As always, there must be no possibility of intervening searches between the call to a search function and the call to @code{match-data} that is intended to access the match data for that search."
msgstr ""

#. type: group
#: searching.texi.orig:1567
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""

#. type: defun
#: searching.texi.orig:1571
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr ""

#. type: defun
#: searching.texi.orig:1576
msgid "This function sets the match data from the elements of @var{match-list}, which should be a list that was the value of a previous call to @code{match-data}.  (More precisely, anything that has the same format will work.)"
msgstr ""

#. type: defun
#: searching.texi.orig:1579
msgid "If @var{match-list} refers to a buffer that doesn't exist, you don't get an error; that sets the match data in a meaningless but harmless way."
msgstr ""

#. type: defun
#: searching.texi.orig:1582
msgid "If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list are reseated to point to nowhere."
msgstr ""

#. type: findex
#: searching.texi.orig:1584
#, no-wrap
msgid "store-match-data"
msgstr ""

#. type: defun
#: searching.texi.orig:1586
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr ""

#. type: subsection
#: searching.texi.orig:1589
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1595
msgid "When you call a function that may search, you may need to save and restore the match data around that call, if you want to preserve the match data from an earlier search for later use.  Here is an example that shows the problem that arises if you fail to save the match data:"
msgstr ""

#. type: group
#: searching.texi.orig:1603
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1607
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr ""

#. type: defmac
#: searching.texi.orig:1608
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr ""

#. type: defmac
#: searching.texi.orig:1612
msgid "This macro executes @var{body}, saving and restoring the match data around it.  The return value is the value of the last form in @var{body}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1617
msgid "You could use @code{set-match-data} together with @code{match-data} to imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr ""

#. type: group
#: searching.texi.orig:1624
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1630
msgid "Emacs automatically saves and restores the match data when it runs process filter functions (@pxref{Filter Functions}) and process sentinels (@pxref{Sentinels})."
msgstr ""

#. type: group
#: searching.texi.orig:1643
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""

#. type: smallexample
#: searching.texi.orig:1647
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""

#. type: group
#: searching.texi.orig:1652
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""

#. type: cindex
#: searching.texi.orig:1658
#, no-wrap
msgid "replacement after search"
msgstr ""

#. type: cindex
#: searching.texi.orig:1659
#, no-wrap
msgid "searching and replacing"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1664
msgid "If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using @code{re-search-forward} and @code{replace-match}, like this:"
msgstr ""

#. type: example
#: searching.texi.orig:1668
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1673
msgid "@xref{Replacing Match,, Replacing the Text that Matched}, for a description of @code{replace-match}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1677
msgid "However, replacing matches in a string is more complex, especially if you want to do it efficiently.  So Emacs provides a function to do this."
msgstr ""

#. type: defun
#: searching.texi.orig:1678
#, no-wrap
msgid "replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start"
msgstr ""

#. type: defun
#: searching.texi.orig:1684
msgid "This function copies @var{string} and searches it for matches for @var{regexp}, and replaces them with @var{rep}.  It returns the modified copy.  If @var{start} is non-@code{nil}, the search for matches starts at that index in @var{string}, so matches starting before that index are not changed."
msgstr ""

#. type: defun
#: searching.texi.orig:1688
msgid "This function uses @code{replace-match} to do the replacement, and it passes the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along to @code{replace-match}."
msgstr ""

#. type: defun
#: searching.texi.orig:1695
msgid "Instead of a string, @var{rep} can be a function.  In that case, @code{replace-regexp-in-string} calls @var{rep} for each match, passing the text of the match as its sole argument.  It collects the value @var{rep} returns and passes that to @code{replace-match} as the replacement string.  The match data at this point are the result of matching @var{regexp} against a substring of @var{string}."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1699
msgid "If you want to write a command along the lines of @code{query-replace}, you can use @code{perform-replace} to do the work."
msgstr ""

#. type: defun
#: searching.texi.orig:1700
#, no-wrap
msgid "perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end"
msgstr ""

#. type: defun
#: searching.texi.orig:1707
msgid "This function is the guts of @code{query-replace} and related commands.  It searches for occurrences of @var{from-string} in the text between positions @var{start} and @var{end} and replaces some or all of them.  If @var{start} is @code{nil} (or omitted), point is used instead, and the end of the buffer's accessible portion is used for @var{end}."
msgstr ""

#. type: defun
#: searching.texi.orig:1710
msgid "If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, it asks the user what to do about each one."
msgstr ""

#. type: defun
#: searching.texi.orig:1715
msgid "If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered a regular expression; otherwise, it must match literally.  If @var{delimited-flag} is non-@code{nil}, then only replacements surrounded by word boundaries are considered."
msgstr ""

#. type: defun
#: searching.texi.orig:1719
msgid "The argument @var{replacements} specifies what to replace occurrences with.  If it is a string, that string is used.  It can also be a list of strings, to be used in cyclic order."
msgstr ""

#. type: defun
#: searching.texi.orig:1724
msgid "If @var{replacements} is a cons cell, @w{@code{(@var{function} . @var{data})}}, this means to call @var{function} after each match to get the replacement text.  This function is called with two arguments: @var{data}, and the number of replacements already made."
msgstr ""

#. type: defun
#: searching.texi.orig:1728
msgid "If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it specifies how many times to use each of the strings in the @var{replacements} list before advancing cyclically to the next one."
msgstr ""

#. type: defun
#: searching.texi.orig:1732
msgid "If @var{from-string} contains upper-case letters, then @code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it uses the @var{replacements} without altering their case."
msgstr ""

#. type: defun
#: searching.texi.orig:1737
msgid "Normally, the keymap @code{query-replace-map} defines the possible user responses for queries.  The argument @var{map}, if non-@code{nil}, specifies a keymap to use instead of @code{query-replace-map}."
msgstr ""

#. type: defun
#: searching.texi.orig:1744
msgid "This function uses one of two functions to search for the next occurrence of @var{from-string}.  These functions are specified by the values of two variables: @code{replace-re-search-function} and @code{replace-search-function}.  The former is called when the argument @var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr ""

#. type: defvar
#: searching.texi.orig:1746
#, no-wrap
msgid "query-replace-map"
msgstr ""

#. type: defvar
#: searching.texi.orig:1751
msgid "This variable holds a special keymap that defines the valid user responses for @code{perform-replace} and the commands that use it, as well as @code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr ""

#. type: itemize
#: searching.texi.orig:1756
msgid "The ``key bindings'' are not commands, just symbols that are meaningful to the functions that use this map."
msgstr ""

#. type: itemize
#: searching.texi.orig:1762
msgid "Prefix keys are not supported; each key binding must be for a single-event key sequence.  This is because the functions don't use @code{read-key-sequence} to get the input; instead, they read a single event and look it up ``by hand''."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1768
msgid "Here are the meaningful ``bindings'' for @code{query-replace-map}.  Several of them are meaningful only for @code{query-replace} and friends."
msgstr ""

#. type: item
#: searching.texi.orig:1770
#, no-wrap
msgid "act"
msgstr ""

#. type: table
#: searching.texi.orig:1772
msgid "Do take the action being considered---in other words, ``yes''."
msgstr ""

#. type: item
#: searching.texi.orig:1773
#, no-wrap
msgid "skip"
msgstr ""

#. type: table
#: searching.texi.orig:1775
msgid "Do not take action for this question---in other words, ``no''."
msgstr ""

#. type: item
#: searching.texi.orig:1776
#, no-wrap
msgid "exit"
msgstr ""

#. type: table
#: searching.texi.orig:1779
msgid "Answer this question ``no'', and give up on the entire series of questions, assuming that the answers will be ``no''."
msgstr ""

#. type: item
#: searching.texi.orig:1780
#, no-wrap
msgid "exit-prefix"
msgstr ""

#. type: table
#: searching.texi.orig:1783
msgid "Like @code{exit}, but add the key that was pressed to @code{unread-command-events} (@pxref{Event Input Misc})."
msgstr ""

#. type: item
#: searching.texi.orig:1784
#, no-wrap
msgid "act-and-exit"
msgstr ""

#. type: table
#: searching.texi.orig:1787
msgid "Answer this question ``yes'', and give up on the entire series of questions, assuming that subsequent answers will be ``no''."
msgstr ""

#. type: item
#: searching.texi.orig:1788
#, no-wrap
msgid "act-and-show"
msgstr ""

#. type: table
#: searching.texi.orig:1791
msgid "Answer this question ``yes'', but show the results---don't advance yet to the next question."
msgstr ""

#. type: item
#: searching.texi.orig:1792
#, no-wrap
msgid "automatic"
msgstr ""

#. type: table
#: searching.texi.orig:1795
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction."
msgstr ""

#. type: item
#: searching.texi.orig:1796
#, no-wrap
msgid "backup"
msgstr ""

#. type: table
#: searching.texi.orig:1798
msgid "Move back to the previous place that a question was asked about."
msgstr ""

#. type: item
#: searching.texi.orig:1799
#, no-wrap
msgid "edit"
msgstr ""

#. type: table
#: searching.texi.orig:1802
msgid "Enter a recursive edit to deal with this question---instead of any other action that would normally be taken."
msgstr ""

#. type: item
#: searching.texi.orig:1803
#, no-wrap
msgid "edit-replacement"
msgstr ""

#. type: table
#: searching.texi.orig:1805
msgid "Edit the replacement for this question in the minibuffer."
msgstr ""

#. type: item
#: searching.texi.orig:1806
#, no-wrap
msgid "delete-and-edit"
msgstr ""

#. type: table
#: searching.texi.orig:1809
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr ""

#. type: item
#: searching.texi.orig:1810
#, no-wrap
msgid "recenter"
msgstr ""

#. type: itemx
#: searching.texi.orig:1811
#, no-wrap
msgid "scroll-up"
msgstr ""

#. type: itemx
#: searching.texi.orig:1812
#, no-wrap
msgid "scroll-down"
msgstr ""

#. type: itemx
#: searching.texi.orig:1813
#, no-wrap
msgid "scroll-other-window"
msgstr ""

#. type: itemx
#: searching.texi.orig:1814
#, no-wrap
msgid "scroll-other-window-down"
msgstr ""

#. type: table
#: searching.texi.orig:1818
msgid "Perform the specified window scroll operation, then ask the same question again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr ""

#. type: item
#: searching.texi.orig:1819
#, no-wrap
msgid "quit"
msgstr ""

#. type: table
#: searching.texi.orig:1822
msgid "Perform a quit right away.  Only @code{y-or-n-p} and related functions use this answer."
msgstr ""

#. type: item
#: searching.texi.orig:1823
#, no-wrap
msgid "help"
msgstr ""

#. type: table
#: searching.texi.orig:1825
msgid "Display some help, then ask again."
msgstr ""

#. type: defvar
#: searching.texi.orig:1827
#, no-wrap
msgid "multi-query-replace-map"
msgstr ""

#. type: defvar
#: searching.texi.orig:1831
msgid "This variable holds a keymap that extends @code{query-replace-map} by providing additional keybindings that are useful in multi-buffer replacements.  The additional ``bindings'' are:"
msgstr ""

#. type: item
#: searching.texi.orig:1833
#, no-wrap
msgid "automatic-all"
msgstr ""

#. type: table
#: searching.texi.orig:1836
msgid "Answer this question and all subsequent questions in the series with ``yes'', without further user interaction, for all remaining buffers."
msgstr ""

#. type: item
#: searching.texi.orig:1837
#, no-wrap
msgid "exit-current"
msgstr ""

#. type: table
#: searching.texi.orig:1841
msgid "Answer this question ``no'', and give up on the entire series of questions for the current buffer.  Continue to the next buffer in the sequence."
msgstr ""

#. type: defvar
#: searching.texi.orig:1844
#, no-wrap
msgid "replace-search-function"
msgstr ""

#. type: defvar
#: searching.texi.orig:1850
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next string to replace.  Its default value is @code{search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{search-forward} (@pxref{String Search})."
msgstr ""

#. type: defvar
#: searching.texi.orig:1852
#, no-wrap
msgid "replace-re-search-function"
msgstr ""

#. type: defvar
#: searching.texi.orig:1858
msgid "This variable specifies a function that @code{perform-replace} calls to search for the next regexp to replace.  Its default value is @code{re-search-forward}.  Any other value should name a function of 3 arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp Search})."
msgstr ""

#. type: section
#: searching.texi.orig:1861
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr ""

#. type: cindex
#: searching.texi.orig:1862
#, no-wrap
msgid "regexps used standardly in editing"
msgstr ""

#. type: cindex
#: searching.texi.orig:1863
#, no-wrap
msgid "standard regexps used in editing"
msgstr ""

#. type: Plain text
#: searching.texi.orig:1867
msgid "This section describes some variables that hold regular expressions used for certain purposes in editing:"
msgstr ""

#. type: defopt
#: searching.texi.orig:1868
#, no-wrap
msgid "page-delimiter"
msgstr ""

#. type: defopt
#: searching.texi.orig:1873
msgid "This is the regular expression describing line-beginnings that separate pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or @code{\"^\\C-l\"}); this matches a line that starts with a formfeed character."
msgstr ""

#. type: Plain text
#: searching.texi.orig:1883
msgid "The following two regular expressions should @emph{not} assume the match always starts at the beginning of a line; they should not use @samp{^} to anchor the match.  Most often, the paragraph commands do check for a match only at the beginning of a line, which means that @samp{^} would be superfluous.  When there is a nonzero left margin, they accept matches that start after the left margin.  In that case, a @samp{^} would be incorrect.  However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr ""

#. type: defopt
#: searching.texi.orig:1884
#, no-wrap
msgid "paragraph-separate"
msgstr ""

#. type: defopt
#: searching.texi.orig:1890
msgid "This is the regular expression for recognizing the beginning of a line that separates paragraphs.  (If you change this, you may have to change @code{paragraph-start} also.)  The default value is @w{@code{\"[@ \\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, and form feeds (after its left margin)."
msgstr ""

#. type: defopt
#: searching.texi.orig:1892
#, no-wrap
msgid "paragraph-start"
msgstr ""

#. type: defopt
#: searching.texi.orig:1897
msgid "This is the regular expression for recognizing the beginning of a line that starts @emph{or} separates paragraphs.  The default value is @w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only whitespace or starting with a form feed (after its left margin)."
msgstr ""

#. type: defun
#: searching.texi.orig:1899 searching.texi.orig:1910
#, no-wrap
msgid "sentence-end"
msgstr ""

#. type: defopt
#: searching.texi.orig:1903
msgid "If non-@code{nil}, the value should be a regular expression describing the end of a sentence, including the whitespace following the sentence.  (All paragraph boundaries also end sentences, regardless.)"
msgstr ""

#. type: defopt
#: searching.texi.orig:1908
msgid "If the value is @code{nil}, as it is by default, then the function @code{sentence-end} constructs the regexp.  That is why you should always call the function @code{sentence-end} to obtain the regexp to be used to recognize the end of a sentence."
msgstr ""

#. type: defun
#: searching.texi.orig:1917
msgid "This function returns the value of the variable @code{sentence-end}, if non-@code{nil}.  Otherwise it returns a default value based on the values of the variables @code{sentence-end-double-space} (@pxref{Definition of sentence-end-double-space}), @code{sentence-end-without-period}, and @code{sentence-end-without-space}."
msgstr ""
