@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Strings and Characters
@chapter Strings and Characters
@cindex strings
@cindex character arrays
@cindex characters
@cindex bytes

  Emacs Lispの文字列は、文字列の順序列(ordered
sequence)を含む配列です。文字列はシンボル、バッファー、ファイルの名前に使用されます。その他にも、ユーザーにたいしてメッセージを送ったりバッファー間でコピーする文字列を保持したり等の、他の多くの目的にたいして使用されます。文字列は特に重要なので、Emacs
Lispは特別に文字列を操作するための、多くの関数をもちます。Emacs Lispプログラムは、個々の文字より、文字列を多用します。

  キーボードの文字イベントの文字列にたいする特別な考慮は、@ref{Strings of Events}を参照してください。

@menu
* Basics: String Basics.     文字列と文字の基本的なプロパティー。
* Predicates for Strings::   オブジェクトが文字列か文字化をテストする。
* Creating Strings::         新しい文字列を割り当てる関数。
* Modifying Strings::        既存の文字列の内容を変更する。
* Text Comparison::          文字または文字列を比較する。
* String Conversion::        文字から文字列、文字から文字列への変換。
* Formatting Strings::       @code{format}: 
                               @code{printf}のEmacsバージョン。
* Case Conversion::          大文字小文字変換関数。
* Case Tables::              大文字小文字変換のカスタマイズ。
@end menu

@node String Basics
@section String and Character Basics

  文字(character)とは、テキスト内の1つの文字を表すLispオブジェクトです。Emacs
Lispでは、文字は単なる整数です。ある整数が文字か文字でないかを区別するのは、それが使用される方法だけです。Emacsでの文字表現についての詳細は、@ref{Character
Codes}を参照してください。

  文字列(string)とは、固定された文字シーケンスです。これは@dfn{配列(array)}と呼ばれるシーケンス型で、配列長が固定で、1度作成したら変更できないことを意味します(@ref{Sequences
Arrays Vectors}を参照してください)。Cとは異なり、Emacs
Lispの文字列は文字コードを判断することにより終端@emph{されません}。

  文字列は配列であり、したがって同様にシーケンスでもあるので、@ref{Sequences Arrays
Vectors}にドキュメントされている一般的な配列関数やシーケンス関数で、文字列を処理できます。たとえば、文字列内の特定の文字にアクセスしたり変更することができますしかし表示された文字列の幅を計算するために、@code{length}を使用するべきでは@emph{ない}ことに注意してください。かわりに@code{string-width}を使用してください(@ref{Size
of Displayed Text}を参照してください)。

  Emacs文字列での非@acronym{ASCII}にたいすテキスト表現は2つ ---
ユニバイト(unibyte)とマルチバイト(multibyte)がありますほとんどのLispプログラミングでは、これら2つの表現を気にする必要はありません。詳細は、@ref{Text
Representations}を参照してください。

  キーシーケンスがユニバイト文字列で表されることがあります。ユニバイト文字列がキーシーケンスの場合、範囲128から255までの文字列要素は、範囲128から255の文字コードではなく、メタ文字(これは非常に大きな整数です)を表します。文字列はhyper、super、altで修飾された文字を保持できません。文字列は@acronym{ASCII}コントロール文字を保持できますが、それは他のコントロール文字です。文字列は@acronym{ASCII}コントロール文字の大文字小文字を区別できません。そのような文字をシーケンスに保存したい場合は、文字列ではなくベクターを使用しなければなりません。キーボード入力文字についての情報は、@ref{Character
Type}を参照してください。

  文字列は正規表現を保持するために便利です。@code{string-match} (@ref{Regexp
Search}を参照してください)を使用して、文字列にたいして正規表現をマッチすることもできます。関数@code{match-string}
(@ref{Simple Match Data}を参照してください)と、@code{replace-match} (@pxref{Replacing
Match})は、文字列にたいして正規表現をマッチした後に、文字列を分解、変更するのに便利です。

  バッファーのように、文字列は文字列内の文字自身と、その文字にたいするテキストプロパティーを含みます。@ref{Text
Properties}を参照してください。文字列からバッファーや他の文字列にテキストをコピーする、すべてのLispプリミティブ(Lisp
primitives)は、コピーされる文字のプロパティーもコピーします。

  文字列を表示したり、バッファーにコピーする関数についての情報は、@ref{Text}を参照してください。文字または文字列の構文についての情報は、@ref{Character
Type}と@ref{String
Type}を参照してください。異なるテキスト表現間で変換したり、文字コードをエンコード、デコードする関数については、@ref{Non-ASCII
Characters}を参照してください。

@node Predicates for Strings
@section Predicates for Strings
@cindex predicates for strings
@cindex string predicates

一般的なシーケンスや配列にたいする述語についての情報は、@ref{Sequences Arrays
Vectors}、および@ref{Arrays}を参照してください。

@defun stringp object
この関数は@var{object}が文字列の場合は@code{t}、それ以外は@code{nil}をreturnします。
@end defun

@defun string-or-null-p object
この関数は、@var{object}が文字列または@code{nil}の場合は@code{t}、それ以外は@code{nil}をreturnします。
@end defun

@defun char-or-string-p object
この関数は、@var{object}が文字列または文字(たとえば整数)の場合は@code{t}、それ以外は@code{nil}をreturnします。
@end defun

@node Creating Strings
@section Creating Strings
@cindex creating strings
@cindex string creation

  以下の関数は、新たに文字列を作成したり、文字列同士を結合して文字列を作成したり、文字列の一部から文字列を作成する関数です。

@defun make-string count character
この関数は、@var{character}を@var{count}回繰り返すことにより作成された文字列をreturnします。@var{count}が負の場合は、エラーをシグナルします。

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

  この関数に対応する他の関数には@code{make-vector}
(@ref{Vectors}を参照してください)、および@code{make-list} (@ref{Building
Lists}を参照してください)が含まれます。
@end defun

@defun string &rest characters
この関数は、文字@var{characters}を含む文字列をreturnします。

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string start &optional end
この関数は、@var{string}から、インデックス@var{start}の文字(その文字を含む)から、@var{end}までの文字(その文字は含まない)の範囲の文字から構成される、新しい文字列をreturnします。文字列の最初の文字がインデックス0になります。

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
上記の例では、@samp{a}のインデックスは0、@samp{b}のインデックスは1、@samp{c}のインデックスは2です。インデックス3 ---
この文字列の4番目の文字 ---
は、部分文字列がコピーされる文字位置までをマークします。したがって文字列@code{"abcdefg"}から、@samp{abc}がコピーされます。

負のかすは、文字列の最後から数えることを意味するので、@minus{}1は文字列の最後の文字のインデックスです。たとえば:

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
この例では、@samp{e}のインデックスは@minus{}3、@samp{f}のインデックスは@minus{}2、@samp{g}のインデックスは@minus{}1です。したがって、@samp{e}と@samp{f}が含まれ、@samp{g}は含まれません。

@var{end}に@code{nil}が使用された場合、それは文字列の長さを意味します。したがって、

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

引数@var{end}を省略した場合、それは@code{nil}を指定したのと同じです。@code{(substring @var{string}
0)}は、@var{string}のすべてをコピーしてreturnします。

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
しかし、この目的のためには@code{copy-sequence}を推奨します(@pxref{Sequence Functions})。

@var{string}からコピーされた文字がテキストプロパティーをもつ場合、そのプロパティーは新しい文字列へもコピーされます。@ref{Text
Properties}を参照してください。

@code{substring}の最初の引数にはベクターも指定できます。たとえば:

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

@var{start}が整数でない場合、または@var{end}が整数でも@code{nil}でもない場合は、@code{wrong-type-argument}エラーがシグナルされます。@var{start}が@var{end}の後の文字を指す場合、または@var{string}にたいして範囲外の整数をどちらかに指定した場合は、@code{args-out-of-range}エラーがシグナルされます。

この関数に対応するのは@code{buffer-substring} (@ref{Buffer
Contents}を参照してください)で、これはカレントバッファー内のテキストの一部を含む文字列をreturnします。文字列の先頭はインデックス0ですが、バッファーの先頭はインデックス1です。
@end defun

@defun substring-no-properties string &optional start end
これは@code{substring}と同じようにL機能しますが、値からすべてのテキストプロパティーを破棄します。@var{start}を省略したり、@code{nil}を指定することができ、この場合0に等しくなります。したがって@w{@code{(substring-no-properties
@var{string})}}は、すべてのテキストプロパティーが削除された@var{string}のコピーをreturnします。
@end defun

@defun concat &rest sequences
@cindex copying strings
@cindex concatenating strings
この関数は、渡された引数内の文字からなる、新しい文字列をreturnします(もしあればテキストプロパティーも)。引数には文字列、数のリスト、数のベクターを指定できます。引数は変更されません。@code{concat}に引数を指定しない場合、空文字列をreturnします。

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
;; @r{@code{nil}hあ空のシーケンス。}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "The " "quick brown " "fox.")
     @result{} "The quick brown fox."
(concat)
     @result{} ""
@end example

@noindent
この関数は常に、任意の既存の文字列にたいして@code{eq}ではない、新しい文字列を構築しますが、結果が空文字列の時は例外です(スペースを省くために、Emacsは空のマルチバイト文字列を1つだけ作成します)。

他の結合関数(concatenation functions)についての情報は、@ref{Mapping
Functions}の@code{mapconcat}、@ref{Vector
Functions}の@code{vconcat}、@ref{Building
Lists}の@code{append}を参照してください。シェルコマンドで使用される文字列の中に、個々のコマンドライン引数を結合するには、@ref{Shell
Arguments, combine-and-quote-strings}を参照してください。
@end defun

@defun split-string string &optional separators omit-nulls trim
この関数は、正規表現@var{separators}(@ref{Regular
Expressions}を参照してください)にもとづいて、@var{string}を部分文字列に分解します。@var{separators}にたいする各マッチは、分割位置を定義します。分割位置の間にある部分文字列を、リストにまとめてreturnします。

@var{omit-nulls}が@code{nil}(または省略)の場合、連続する2つの@var{separators}へのマッチ、または@var{string}の最初か最後にマッチしたときの空文字列が結果に含まれます。@var{omit-nulls}が@code{t}の場合、これらの空文字列は結果から除外されます。

@var{separators}が@code{nil}(または省略)の場合、デフォルトは@code{split-string-default-separators}の値になります。

特別なケースとして、@var{separators}が@code{nil}(または省略)の場合、常に結果から空文字列が除外されます。したがって:

@example
(split-string "  two words ")
     @result{} ("two" "words")
@end example

結果は、ほとんど有用ではないであろう@code{("" "two" "words"
"")}という結果ではありません。このような結果が必要な時は、@var{separators}に明示的な値を使用します:

@example
(split-string "  two words "
              split-string-default-separators)
     @result{} ("" "two" "words" "")
@end example

他にも例を示します:

@example
(split-string "Soup is good food" "o")
     @result{} ("S" "up is g" "" "d f" "" "d")
(split-string "Soup is good food" "o" t)
     @result{} ("S" "up is g" "d f" "d")
(split-string "Soup is good food" "o+")
     @result{} ("S" "up is g" "d f" "d")
@end example

空のマッチはカウントされます。例外は、空でないマッチを使用することにより、すでに文字列の最後に到達しているとき、または@var{string}が空の時で、この場合@code{split-string}は最後の空マッチを探しません。

@example
(split-string "aooob" "o*")
     @result{} ("" "a" "" "b" "")
(split-string "ooaboo" "o*")
     @result{} ("" "" "a" "b" "")
(split-string "" "")
     @result{} ("")
@end example

しかし、@var{separators}が空文字列にマッチできるとき、通常は@var{omit-nulls}は@code{t}にすれば、前の3つの例の不明瞭さは、ほとんど発生しません:

@example
(split-string "Soup is good food" "o*" t)
     @result{} ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "" t)
     @result{} ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
(split-string "" "" t)
     @result{} nil
@end example

空でないマッチより空のマッチを優先するような、一部の``非貪欲(non-greedy)''な値を@var{separators}に指定することにより、幾分奇妙(しかし予見可能)な振る舞いが発生する場合があります。繰り返しますが、そのような値は実際にはまれです:

@example
(split-string "ooo" "o*" t)
     @result{} nil
(split-string "ooo" "\\|o+" t)
     @result{} ("o" "o" "o")
@end example

オプションの引数@var{trim}が非@code{nil}の場合、その値は各部分文字列の最初と最後からトリムするテキストにマッチする正規表現を指定します。トリムにより、その部分文字列が空になるような場合、それは空文字列として扱われます。

文字列を分割して、@code{call-process}や@code{start-process}に適した、個々のコマンドライン引数のリストにする必要がある場合は、@ref{Shell
Arguments, split-string-and-unquote}を参照してください。
@end defun

@defvar split-string-default-separators
@code{split-string}の@var{separators}にたいするデフォルト値です。通常の値は、@w{@code{"[
\f\t\n\r\v]+"}}です。
@end defvar

@node Modifying Strings
@section Modifying Strings
@cindex modifying strings
@cindex string modification

  既存の文字列の内容を変更するもっとも基本的な方法は、@code{aset} (@pxref{Array
Functions})を使用する方法です。@code{(aset @var{string} @var{idx}
@var{char})}は、@var{string}のインデックス@var{idx}に、@var{char}を格納します。それぞれの文字は１文字以上を占有しますが、すでにインデックスの場所にある文字のバイト数が、@var{char}が要するバイト数と異なる場合、@code{aset}はエラーをシグナルします。

  より強力な関数は@code{store-substring}です:

@defun store-substring string idx obj
この関数は、インデックス@var{idx}で開始される位置に@var{obj}を格納することにより、文字列@var{string}の内容の一部を変更します。@var{obj}は文字、または(@var{string}より小さい)文字列です。

既存の文字列の長さを変更するのは不可能なので、@var{string}の実際の長さに@var{obj}が収まらない場合、または@var{string}のその位置に現在ある文字のバイト数が、新しい文字に必要なバイト数と異なる場合はエラーになります。
@end defun

  パスワードを含む文字列をクリアーするときは、@code{clear-string}を使用します:

@defun clear-string string
これは@var{string}をユニバイト文字列として、内容を0にクリアーします。これにより@var{string}の長さも変更されるでしょう。
@end defun

@need 2000
@node Text Comparison
@section Comparison of Characters and Strings
@cindex string equality
@cindex text comparison

@defun char-equal character1 character2
この関数は引数が同じ文字を表す場合は@code{t}、それ以外は@code{nil}をreturnします。@code{case-fold-search}が非@code{nil}の場合、この関数は大文字小文字の違いを無視します。

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@defun string= string1 string2
この関数は、2つの文字列の文字が正確にマッチする場合は、@code{t}をreturnします。引数にシンボルを指定することもでき、この場合はシンボル名が使用されます。@code{case-fold-search}とは無関係に、大文字小文字は常に意味をもちます。

この関数は、@code{equal}で2つの文字列を比較するのと等価です(@ref{Equality
Predicates}を参照してください)。特に、2つの文字列のテキストプロパティーは無視されます。テキストプロパティーだけが異なる文字列を区別する必要がある場合は、@code{equal-including-properties}を使用します。しかし@code{equal}とは異なり、どちらかの引数が文字列でもシンボルでもない場合、@code{string=}はエラーをシグナルします。

@example
(string= "abc" "abc")
     @result{} t
(string= "abc" "ABC")
     @result{} nil
(string= "ab" "ABC")
     @result{} nil
@end example

技術的な理由により、ユニバイト文字列とマルチバイト文字列が@code{equal}なのは、それらが同じ文字コードのシーケンスを含み、それらすべてのコードが0から127(@acronym{ASCII})か、160から255(@code{eight-bit-graphic})のときだけです。しかしユニバイト文字列をマルチバイト文字列に変更する際、コードが160から255の範囲にあるすべての文字はより高いコードに変換され、@acronym{ASCII}文字は変換されないまま残ります。したがってユニバイト文字列と、それを変換したマルチバイト文字列は、その文字列のすべてが@acronym{ASCII}のときだけ@code{equal}です。マルチバイト文字列中で、もし文字コード160から255の文字があったとしても、それは完全に正しいとは言えません。結果として、すべてが@acronym{ASCII}ではないユニバイト文字列とマルチバイト文字列が@code{equal}であるという状況は、もしかしたらEmacs
Lispプロプラマーが直面するかもしれない、とても希少な偽術的に不可解な状況だといえます。@ref{Text
Representations}を参照してください。
@end defun

@defun string-equal string1 string2
@code{string-equal}は@code{string=}に対する別名です。
@end defun

@cindex lexical comparison
@defun string< string1 string2
@c (findex string< causes problems for permuted index!!)
この関数は、2つの文字列を1文字づつ比較します。この関数は、同時に2つの文字列をスキャンして、対応する文字同士がマッチしない最初のペアを探します。2つの文字列内で、小さいほうの文字が@var{string1}の文字の場合、@var{string1}が小さいことになり、この関数は@code{t}をreturnします。小さいほうの文字が@var{string2}の文字の場合、@var{string1}が大きいことになり、この関数は@code{nil}をreturnします。2つの文字列が完全にマッチした場合、値は@code{nil}になります。

文字のペアは、文字コードで比較されます。@acronym{ASCII}文字セットでは、小文字英字は大文字英字より、高い数値をもつことに留意してください。数字および多くの句読点文字は、大文字英字より低い数値をもちます。@acronym{ASCII}文字は、任意の非@acronym{ASCII}文字より小さくなります。ユニバイト非@acronym{ASCII}文字は、任意のマルチバイト非@acronym{ASCII}文字より、常に小さくなります(@ref{Text
Representations}を参照してください)。

@example
@group
(string< "abc" "abd")
     @result{} t
(string< "abd" "abc")
     @result{} nil
(string< "123" "abc")
     @result{} t
@end group
@end example

文字列の長さが異なり、@var{string1}の長さまでマッチする場合、結果は@code{t}になります。@var{string2}の長さまでマッチする場合、結果は@code{nil}になります。文字を含まない文字列は、他の任意の文字列より小さくなります。

@example
@group
(string< "" "abc")
     @result{} t
(string< "ab" "abc")
     @result{} t
(string< "abc" "")
     @result{} nil
(string< "abc" "ab")
     @result{} nil
(string< "" "")
     @result{} nil
@end group
@end example

引数としてシンボルを指定することもでき、この場合はシンボルのプリント名が使用されます。
@end defun

@defun string-lessp string1 string2
@code{string-lessp}は@code{string<}にたいする別名です。
@end defun

@defun string-prefix-p string1 string2 &optional ignore-case
この関数は、@var{string1}が@var{string2}のプレフィクス(接頭辞)の場合(たとえば@var{string2}が@var{string1}で始まる場合)、非@code{nil}をreturnします。オプションの引数@var{ignore-case}が非@code{nil}の場合、比較において大文字小文字の違いは無視されます。
@end defun

@defun string-suffix-p suffix string &optional ignore-case
この関数は、@var{suffix}が@var{string}のサフィックス(接尾辞)の場合(たとえば@var{string}が@var{suffix}で終わる場合)、非@code{nil}をreturnします。オプションの引数@var{ignore-case}が非@code{nil}の場合、比較において大文字小文字の違いは無視されます。
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
この関数は、@var{string1}の指定された部分を、@var{string2}の指定された部分と比較します。@var{string1}の指定された部分とは、インデックス@var{start1}(その文字を含む)から、インデックス@var{end1}(その文字を含まない)までです。@var{start1}に@code{nil}を指定すると文字列の最初という意味になり、@var{end1}に@code{nil}を指定すると文字列の長さを意味します同様に、@var{string2}の指定された部分とは、インデックス@var{start2}からインデックス@var{end2}までです。

文字列は、文字列内の文字の数値により比較されます。たとえば、@var{str1}と@var{str2}は、最初に異なる文字で@var{str1}の文字の数値が小さいときに、``小さい''と判断されます。@var{ignore-case}が非@code{nil}の場合、文字は比較を行なう前に小文字に変換されます。比較のためにユニバイト文字列はマルチバイト文字列に変換されるので(@ref{Text
Representations}を参照してください)、ユニバイト文字列と、それを変換したマルチバイト文字列は、常に等しくなります。

2つの文字列の指定された部分がマッチした場合、値は@code{t}になります。それ以外では、値は整数で、これは何文字が一致して、どちらの文字が小さいかを示します。この値の絶対値は、2つの文字列の先頭から一致した文字数に1加えた値になります。@var{string1}(または指定された部分)のほうが小さい場合、符号は負になります。
@end defun

@defun assoc-string key alist &optional case-fold
この関数は@code{assoc}と同様に機能しますが、@var{key}は文字列かシンボルでなければならず、比較は@code{compare-strings}を使用して行なわれます。テストする前にシンボルは文字列に変換されます。@var{case-fold}が非@code{nil}の場合、大文字小文字の違いは無視されます。@code{assoc}とは異なり、この関数はコンスではない文字列またはシンボルのalist要素もマッチできます。特に、@var{alist}は実際のalistではなく、文字列またはリストでも可能です。@ref{Association
Lists}を参照してください。
@end defun

  バッファー内のテキストを比較する方法として、@ref{Comparing
Text}の関数@code{compare-buffer-substrings}も参照してください。文字列にたいして正規表現のマッチを行なう関数@code{string-match}も、ある種の文字列比較に使用することができます。@ref{Regexp
Search}を参照してください。

@node String Conversion
@section Conversion of Characters and Strings
@cindex conversion of strings

  このセクションでは文字、文字列、整数の間で変換を行なう関数を説明します。@code{format} (@ref{Formatting
Strings}を参照してください)、および@code{prin1-to-string} (@ref{Output
Functions}を参照してください)も、Lispオブジェクトを文字列に変換できます。@code{read-from-string}
(@ref{Input
Functions}を参照してください)は、Lispオブジェクトの文字列表現を、オブジェクトに``変換''できます。関数@code{string-to-multibyte}および@code{string-to-unibyte}は、テキスト表現を文字列に変換します(@ref{Converting
Representations}を参照してください)。

  テキスト文字と一般的なインプットイベントにたいするテキスト説明を生成する関数(@code{single-key-description}および@code{text-char-description})については、@ref{Documentation}を参照してください。これらの関数は主にヘルプメッセージを作成するために使用されます。

@defun number-to-string number
@cindex integer to string
@cindex integer to decimal
この関数は@var{number}の10進プリント表現からなる文字列をreturnします。引数が負の場合、return値はマイナス記号から開始されます。

@example
(number-to-string 256)
     @result{} "256"
@group
(number-to-string -23)
     @result{} "-23"
@end group
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@cindex int-to-string
@code{int-to-string}は、この関数にたいする半ば廃れた(semi-obsolete)エイリアスです。

@ref{Formatting Strings}の関数@code{format}も参照してください。
@end defun

@defun string-to-number string &optional base
@cindex string to number
この関数は@var{string}内の文字の数値的な値をreturnします。@var{base}が非@code{nil}の場合、値は2以上16以下でなければならず、整数はその基数に変換されます。@var{base}が@code{nil}の場合、基数に10が使用されます。浮動少数の変換は基数が10のときだけ機能します。わたしたちは浮動小数点数にたいして他の基数を実装していません。なえならこれには多くの作業が必要で、その割にその機能が有用には思えないからです。@var{string}が整数のように見えるが、その値がLispの整数に収まらないほど大きな値の場合、@code{string-to-number}は浮動小数の結果をreturnします。

解析では@var{string}の先頭にあるスペースとタブはスキップして、それから与えられた基数で数字として解釈できるところまで@var{string}を読み取ります(スペースとタブだけではなく、先頭にある他の空白文字を無視するシステムもあります)。@var{string}を数字として解釈できない場合、この関数は0をreturnします。

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
(string-to-number "1e5")
     @result{} 100000.0
@end example

@findex string-to-int
@code{string-to-int}は、この関数にたいする半ば廃れたエイリアスです。
@end defun

@defun char-to-string character
@cindex character to string
この関数は、1つの文字@var{character}を含む新しい文字列をreturnします。関数@code{string}のほうがより一般的なので、この関数は半ば廃れています。@ref{Creating
Strings}を参照してください。
@end defun

@defun string-to-char string
  この関数は、@var{string}の最初の文字をreturnします。これはほとんど@code{(aref string
0)}と同じで、例外は文字列が空のときに0をreturnすることです(文字列の最初の文字が@acronym{ASCII}コード0のヌル文字のときも、0をreturnします)。この関数は、残すのに充分なほど有用と思えない場合、将来削除されるかもしれません。
@end defun

  以下は、文字列へ／からの変換に使用できる、その他の関数です:

@table @code
@item concat
この関数はベクターまたはリストから文字列に変換します。@ref{Creating Strings}を参照してください。

@item vconcat
この関数は文字列をベクターに変換します。@ref{Vector Functions}を参照してください。

@item append
この関数は文字列をリストに変換します。@ref{Building Lists}を参照してください。

@item byte-to-string
この関数は文字データのバイトをユニバイト文字列に変換します。@ref{Converting Representations}を参照してください。
@end table

@node Formatting Strings
@section Formatting Strings
@cindex formatting strings
@cindex strings, formatting them

  @dfn{フォーマット(formatting)}とは、定数文字列内のなまざまな場所を、計算された値で置き換えることにより、文字列を構築することを意味します。この定数文字列は、他の値がプリントされる方法、同様にどこに表示するかを制御します。これは@dfn{フォーマット文字列(format
string)}と呼ばれます。

  フォーマットは、表示されるメッセージを計算するために便利なことがしばしばあります。実際に、関数@code{message}および@code{error}は、ここで説明する機能と同じフォーマットを提供します。これらの関数と@code{format}の違いは、フォーマットされた結果を使用する方法だけです。

@defun format string &rest objects
この関数は、@var{string}をコピーしてから、対応する@var{objects}をエンコードする、コピー内の任意のフォーマット指定(format
specification)を置換することにより作成される、新しい文字列をreturnします。引数@var{objects}は、フォーマットされる計算された値です。

@var{string}内のフォーマット指定以外の文字は、(もしあれば)テキストプロパティーを含め、出力に直接コピーされます。
@end defun

@cindex @samp{%} in format
@cindex format specification
  フォーマット指定は、@samp{%}で始まる文字シーケンスです。したがって@var{string}内に@samp{%d}があれば、@code{format}はそれを、フォーマットされる値の1つ(引数@var{objects}のうちの1つ)にたいするプリント表現で置き換えます。たとえば:

@example
@group
(format "The value of fill-column is %d." fill-column)
     @result{} "The value of fill-column is 72."
@end group
@end example

  @code{format}は文字@samp{%}をフォーマット指定と解釈するので、@emph{決して}最初の引数に不定な文字列(arbitrary
string)を渡すべきではありません。これは特に何らかのLispコードにより生成された文字列の場合に当てはまります。その文字列が決して文字@samp{%}を含まないと@emph{確信}できないときは、以下で説明するように最初の引数に@code{"%s"}を渡して、不定な文字列を2番目の引数として渡します:

@example
  (format "%s" @var{arbitrary-string})
@end example

  @var{string}に複数のフォーマット指定が含まれる場合、フォーマット指定は@var{objects}から連続して値を引き当てます。つまり、@var{string}内の1番目のフォーマット指定は1番目の値、2番目のフォーマット指定は2番目の値、...を使用します。余分なフォーマット指定(対応する値がない場合)は、エラーとなります。フォーマットされる値が余分にある場合は、無視されます。

  ある種のフォーマット指定は、特定の型の値を要求します。その要求に適合しない値を与えた場合、エラーがシグナルされます。

  以下は有効なフォーマット指定の表です:

@table @samp
@item %s
フォーマット指定を、クォートなし(つまり@code{prin1}ではなく@code{princ}を使用して。@ref{Output
Functions}を参照してください)の、オブジェクトのプリント表現で置き換えます。したがって、文字列は@samp{"}文字なしの、文字列内容だけが表示され、シンボルは@samp{\}文字なしで表されます。

オブジェクトが文字列の場合、文字列のプロパティーは出力にコピーされます。@samp{%s}のテキストプロパティー自身もコピーされますが、オブジェクトのテキストプロパティーが優先されます。

@item %S
フォーマット指定を、クォートあり(つまり@code{prin1}を使用して。@ref{Output
Functions}を参照してください)の、オブジェクトのプリント表現で置き換えます。したがって、文字列は@samp{"}文字で囲まれ、必要となる特別文字の前に@samp{\}文字が表示されます。

@item %o
@cindex integer to octal
フォーマット指定を8進表現の整数で置き換えます。

@item %d
フォーマット指定を10進表現の整数で置き換えます。

@item %x
@itemx %X
@cindex integer to hexadecimal
フォーマット指定を16進表現の整数で置き換えます。@samp{%x}の場合は小文字、@samp{%X}の場合は大文字が使用されます。

@item %c
フォーマット指定を、与えられた値の文字で置き換えます。

@item %e
フォーマット指定を、浮動小数点数の指数表現で置き換えます。

@item %f
フォーマット指定を、浮動小数点数にたいする10進少数表記で置き換えます。

@item %g
フォーマット指定を、指数または10進少数のどちらか短いほうの表記を使用した浮動小数点数で置き換えます。

@item %%
フォーマット指定を1つの@samp{%}で置き換えます。このフォーマット指定は、値を使用しません。たとえば、@code{(format "%% %d"
30)}は@code{"% 30"}をreturnします。
@end table

  他のフォーマット文字は、@samp{Invalid format operation}エラーになります。

  以下にいくつかの例を示します:

@example
@group
(format "The name of this buffer is %s." (buffer-name))
     @result{} "The name of this buffer is strings.texi."

(format "The buffer object prints as %s." (current-buffer))
     @result{} "The buffer object prints as strings.texi."

(format "The octal value of %d is %o,
         and the hex value is %x." 18 18 18)
     @result{} "The octal value of 18 is 22,
         and the hex value is 12."
@end group
@end example

@cindex field width
@cindex padding
  フォーマット指定は@dfn{フィールド幅(width)}をもつことができ、これは@samp{%}とフォーマット指定文字(specification
character)の間の10進の数字です。そのオブジェクトのプリント表現が、このフィールド幅より少ない文字で構成される場合、@code{format}はパディングしてフィールド幅に拡張します。フォーマット指定@samp{%%}では、フィールド幅の指定は無視されます。シールド幅指定により行なわれるパディングは通常、左側にスペースを挿入します。

@example
(format "%5d is padded on the left with spaces" 123)
     @result{} "  123 is padded on the left with spaces"
@end example

@noindent
フィールド幅が小さすぎる場合でも、@code{format}はオブジェクトのプリント表現を切り詰めません。したがって、情報を失う危険を犯すことなく、フィールドの最小幅を指定することができます。以下の2つの例では、@samp{%7s}は最小幅に7を指定します。1番目の例では、@samp{%7s}に挿入される文字列は3文字だけなので、4つのブランクスペースによりパディングされます。2番目の例では、文字列@code{"specification"}は13文字ですが、切り詰めはされません。

@example
@group
(format "The word `%7s' has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word `    foo' has 3 letters in it."
(format "The word `%7s' has %d letters in it."
        "specification" (length "specification"))
     @result{} "The word `specification' has 13 letters in it."
@end group
@end example

@cindex flags in format specifications
  @samp{%}の直後、オプションのフィールド幅指定の前に、@dfn{フラグ文字(flag characters)}を置くこともできます。

  フラグ@samp{+}は、正数の前にプラス符号を挿入するので、数には常に符号がつきます。フラグとしてスペースを指定すると、正数の前に1つのスペースが挿入されます(それ以外は、正数は最初の数字から開始されます)。これらのフラグは、正数と負数が同じ列数を使用することを確実にするのに便利です。これらは@samp{%d}、@samp{%e}、@samp{%f}、@samp{%g}以外では無視され、両方が指定された場合は、@samp{+}が優先されます。

  フラグ@samp{#}は``代替形式(alternate
form)''を指定し。これは使用するフォーマットに依存します。@samp{%o}にたいしては、結果を@samp{0}で開始させます。@samp{%x}と@samp{%X}にたいしては、結果のプレフィクスは@samp{0x}または@samp{0X}になります。@samp{%e}、@samp{%f}、@samp{%g}にたいしては、@samp{#}フラグは、少数部が0のときも小数点が含まれることを意味します。

  フラグ@samp{0}は、スペースの代わりに文字@samp{0}でパディングします。このフラグは@samp{%s}、@samp{%S}、@samp{%c}のような、非数値のフォーマット指定文字では無視されます。もれらのフォーマット指定文字で@samp{0}フラグを指定できますが、それでも@emph{スペース}でパディングされます。

  フラグ@samp{-}はフィールド幅指定により挿入されるパディングに作用し、もしパディングがある場合、左側ではなく右側にパディングされます。@samp{-}と@samp{0}の両方が指定された場合、@samp{0}フラグは無視されます。

@example
@group
(format "%06d is padded on the left with zeros" 123)
     @result{} "000123 is padded on the left with zeros"

(format "%-6d is padded on the right" 123)
     @result{} "123    is padded on the right"

(format "The word `%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word `foo    ' actually has 3 letters in it."
@end group
@end example

@cindex precision in format specifications
  すべてのフォーマット指定文字には、その文字の前(フィールド幅がある場合は、その後)に、オプションで@dfn{精度(precision)}を指定できます。精度は小数点@samp{.}と、その後に桁文字列(digit-string)を指定します。浮動少数のフォーマット指定(@samp{%e}、@samp{%f}、@samp{%g})では、精度は表示する小数点以下の桁数を指定します。0の場合は小数点も省略されます。@samp{%s}と@samp{%S}にたいしては、文字列を精度で指定された幅に切り詰めます。したがって@samp{%.3s}では、@var{object}にたいするプリント表現の最初の3文字だけが表示されます。他のフォーマット指定文字にたいしては、精度は効果がありません。

@node Case Conversion
@section Case Conversion in Lisp
@cindex upper case
@cindex lower case
@cindex character case
@cindex case conversion in Lisp

  大文字小文字変換関数(character case
functions)は、1つの文字または文字列の内容の大文字小文字を変換します。関数は通常、アルファベット文字(英字@samp{A}から@samp{Z}と@samp{a}から@samp{z}、同様に非@acronym{ASCII}の英字)だけを変換し、それ以外の文字は変換しません。大文字小文字テーブル(case
table。@ref{Case Tables}を参照してください)で指定することにより大文字小文字の変換に異なるマッピングを指定できます。

  これらの関数は、引数として渡された文字列は変更しません。

  以下の例では文字@samp{X}と@samp{x}を使用し、これらの@acronym{ASCII}コードは88と120です。

@defun downcase string-or-char
この関数は、@var{string-or-char}(文字か文字列)を小文字に変換します。

@var{string-or-char}が文字列の場合、この関数は引数の大文字を小文字に変換した、新しい文字列をreturnします。@var{string-or-char}が文字の場合、この関数は対応する小文字(正数)をreturnします。元の文字が小文字の場合、または英字でない場合、return値は元の文字と同じです。

@example
(downcase "The cat in the hat")
     @result{} "the cat in the hat"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
この関数は、@var{string-or-char}(文字か文字列)を大文字に変換します。

@var{string-or-char}が文字列の場合、この関数は引数の小文字を大文字に変換した、新しい文字列をreturnします。@var{string-or-char}が文字の場合、この関数は対応する大文字(正数)をreturnします。元の文字が大文字の場合、または英字でない場合、return値は元の文字と同じです。

@example
(upcase "The cat in the hat")
     @result{} "THE CAT IN THE HAT"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@cindex capitalization
この関数は文字列または文字をキャピタライズ(capitalize:
先頭が大文字で残りは小文字)します。この関数は、@var{string-or-char}が文字列の場合、@var{string-or-char}の各単語がキャピタライズされた新しいコピーをreturnします。これは各単語の最初の文字が大文字に変換され、残りは小文字に変換されることを意味します。

単語の定義は、カレント構文テーブル(current syntax table)の単語構成構文クラス(word constituent syntax
class)に割り当てられた、連続する文字の任意シーケンスです(@ref{Syntax Class Table}を参照してください)。

@var{string-or-char}が文字の場合、この関数は@code{upcase}と同じことを行ないます。

@example
@group
(capitalize "The cat in the hat")
     @result{} "The Cat In The Hat"
@end group

@group
(capitalize "THE 77TH-HATTED CAT")
     @result{} "The 77th-Hatted Cat"
@end group

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string-or-char
この関数は、@var{string-or-char}が文字列の場合、@var{string-or-char}の中の単語の頭文字をキャピタライズし、頭文字以外の文字は変更しません。この関数は、@var{string-or-char}の各単語の頭文字が大文字に変換された新しいコピーをreturnします。

単語の定義は、カレント構文テーブル(current syntax table)の単語構成構文クラス(word constituent syntax
class)に割り当てられた、連続する文字の任意シーケンスです(@ref{Syntax Class Table}を参照してください)。

@code{upcase-initials}の引数が文字の場合、@code{upcase-initials}の結果は@code{upcase}と同じになります。

@example
@group
(upcase-initials "The CAT in the hAt")
     @result{} "The CAT In The HAt"
@end group
@end example
@end defun

  文字列を比較する関数(大文字小文字の違いを無視するものや、オプションで大文字小文字の違いを無視できるもの)については、@ref{Text
Comparison}を参照してください。

@node Case Tables
@section The Case Table

  特別な@dfn{大文字小文字テーブル(case
table)}をインストールすることにより、大文字小文字の変換をカスタマイズできます。大文字小文字テーブルは大文字と小文字の間のマッピングを指定します。大文字小文字テーブルはLispオブジェクトにたいする大文字小文字変換関数(前のセクションを参照してください)と、バッファー内のテキストに適用される関数の両方に影響します。それぞれのバッファーには大文字小文字テーブルがあります。新しいバッファーの大文字小文字テーブルを初期化するために使用される、標準の大文字小文字テーブル(standard
case table)もあります。

  大文字小文字テーブルは、サブタイプが@code{case-table}の文字テーブル(char-table。@ref{Char-Tables}を参照してください)です。この文字テーブルは、それぞれの文字を対応する小文字にマップします。大文字小文字テーブルは、関連するテーブルを保持する、3つの追加スロットをもちます:

@table @var
@item upcase
upcase(大文字)テーブルは、それぞれの文字を対応する大文字にマップします。
@item canonicalize
canonicalize(正準化)テーブルは、大文字小文字に関連する文字セットのすべてを、その文字セットの特別なメンバーにマップします。
@item equivalences
equivalence(同値)テーブルは、大の字小文字に関連した文字セットのそれぞれを、そのセットの次の文字にマップします。
@end table

  単純な例では、小文字へのマッピングを指定することだけが必要です。3つの関連するテーブルは、このマッピングから自動的に計算されます。

  大文字と小文字が1対1で対応しない言語もいくつかあります。これらの言語では、2つの異なる小文字が、同じ大文字にマップされます。このような場合、大文字と小文字の両方にたいするマップを指定する必要があります。

  追加の@var{canonicalize}テーブルは、それぞれの文字を、正準化された等価文字にマップします。大文字小文字に関連する任意の2文字は、同じ正準等価文字(canonical
equivalent
character)をもちます。たとえば@samp{a}と@samp{A}は大文字小文字変換に関係があるので、これらの文字は同じ正準等価文字(両方の文字が@samp{a}、または両方の文字が@samp{A})をもつべきです。

  追加の@var{equivalences}テーブルは、各等価クラスの文字(同じ正準等価文字をもつ文字)を循環的にマップします(通常の@acronym{ASCII}では、これは@samp{a}を@samp{A}に@samp{A}を@samp{a}にマップし、他の等価文字セットにたいしても同様にマップします)。

  大文字小文字テーブルを構築する際は、@var{canonicalize}に@code{nil}を指定できます。この場合、Emacsは大文字と小文字のマッピングで、このスロットを充填します。@var{equivalences}にたいして@code{nil}を指定することもできます。この場合、Emacsは@var{canonicalize}から、このスロットを充填します。実際に使用される大文字小文字テーブルでは、これらのコンポーネントは非@code{nil}です。@var{canonicalize}を指定せずに@var{equivalences}を指定しないでください。

  以下は大文字小文字テーブルに作用する関数です:

@defun case-table-p object
この述語は、@var{object}が有効な大文字小文字テーブルの場合は、非@code{nil}をreturnします。
@end defun

@defun set-standard-case-table table
この関数は、@var{table}を標準大文字小文字テーブルにして、これ以降に作成される任意のバッファーにたいしてこのテーブルが使用されます。
@end defun

@defun standard-case-table
これは標準大文字小文字テーブル(standard case table)をreturnします。
@end defun

@defun current-case-table
この関数は、カレントバッファーの大文字小文字テーブルをreturnします。
@end defun

@defun set-case-table table
これはカレントバッファーの大文字小文字テーブルを、@var{table}にセットします。
@end defun

@defmac with-case-table table body@dots{}
@code{with-case-table}マクロはカレント大文字小文字テーブルを保存してから、@var{table}をカレント大文字小文字テーブルにセットし、その後に@var{body}フォームを評価してから、最後に大文字小文字テーブルをリストアします。return値は、@var{body}の最後のフォームの値です。@code{throw}またはエラー(@ref{Nonlocal
Exits}を参照してください)により異常終了した場合でも、大文字小文字テーブルはリストアされます。
@end defmac

  @acronym{ASCII}文字の大文字小文字変換を変更する言語環境(language
environment)がいくつかあります。たとえばTurkishの言語環境では、@acronym{ASCII}文字の@samp{I}にたいする小文字は、Turkishの``dotless
i''です。これは、(@acronym{ASCII}ベースのネットワークプロトコル実装のような)@acronym{ASCII}の通常の大文字小文字変換を要求するコードに干渉する可能性があります。このような場合は、変数@var{ascii-case-table}にたいして@code{with-case-table}マクロを使用します。これにより、変更されていない@acronym{ASCII}文字セットの大文字小文字テーブルが保存されます。

@defvar ascii-case-table
@acronym{ASCII}文字セットにたいする大文字小文字テーブルです。すべての言語環境セッティングにおいて、これを変更するべきではありません。
@end defvar

  以下の3つの関数は、非@acronym{ASCII}文字セットを定義するパッケージにたいして便利なサブルーチンです。これらは@var{case-table}に指定された大文字小文字テーブルを変更します。これは標準構文テーブルも変更します。@ref{Syntax
Tables}を参照してください。通常これらの関数は、標準大文字小文字テーブルを変更するために使用されます。

@defun set-case-syntax-pair uc lc case-table
この関数は、対応する文字のペア(一方は大文字、もう一方は小文字)を指定します。
@end defun

@defun set-case-syntax-delims l r case-table
この関数は文字@var{l}と@var{r}を、大文字小文字不変区切り(case-invariant delimiter)mpマッチングペアにします。
@end defun

@defun set-case-syntax char syntax case-table
この関数は@var{char}を、構文@var{syntax}の、大文字小文字不変(case-invariant)とします。
@end defun

@deffn Command describe-buffer-case-table
このコマンドは、カレントバッファーの大文字小文字テーブルの内容にたいする説明を表示します。
@end deffn
