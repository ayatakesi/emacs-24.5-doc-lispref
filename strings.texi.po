# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-12 16:13+0900\n"
"PO-Revision-Date: 2016-06-15 23:19+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: strings.texi.orig:6 strings.texi.orig:7
#, no-wrap
msgid "Strings and Characters"
msgstr "Strings and Characters"

#. type: cindex
#: strings.texi.orig:8
#, no-wrap
msgid "strings"
msgstr "strings"

#. type: cindex
#: strings.texi.orig:9
#, no-wrap
msgid "character arrays"
msgstr "character arrays"

#. type: cindex
#: strings.texi.orig:10
#, no-wrap
msgid "characters"
msgstr "characters"

#. type: cindex
#: strings.texi.orig:11
#, no-wrap
msgid "bytes"
msgstr "bytes"

#. type: Plain text
#: strings.texi.orig:19
msgid ""
"A string in Emacs Lisp is an array that contains an ordered sequence of "
"characters.  Strings are used as names of symbols, buffers, and files; to "
"send messages to users; to hold text being copied between buffers; and for "
"many other purposes.  Because strings are so important, Emacs Lisp has many "
"functions expressly for manipulating them.  Emacs Lisp programs use strings "
"more often than individual characters."
msgstr "Emacs Lispの文字列は、文字列の順序列(ordered sequence)を含む配列です。文字列はシンボル、バッファー、ファイルの名前に使用されます。その他にも、ユーザーにたいしてメッセージを送ったりバッファー間でコピーする文字列を保持したり等の、他の多くの目的にたいして使用されます。文字列は特に重要なので、Emacs Lispは特別に文字列を操作するための、多くの関数をもちます。Emacs Lispプログラムは、個々の文字より、文字列を多用します。"

#. type: Plain text
#: strings.texi.orig:22
msgid ""
"@xref{Strings of Events}, for special considerations for strings of keyboard "
"character events."
msgstr "キーボードの文字イベントの文字列にたいする特別な考慮は、@ref{Strings of Events}を参照してください。"

#. type: menuentry
#: strings.texi.orig:33
msgid "Basics: String Basics"
msgstr "Basics: String Basics"

#. type: menuentry
#: strings.texi.orig:33
msgid "Basic properties of strings and characters."
msgstr "文字列と文字の基本的なプロパティー。"

#. type: section
#: strings.texi.orig:33 strings.texi.orig:93 strings.texi.orig:94
#, no-wrap
msgid "Predicates for Strings"
msgstr "Predicates for Strings"

#. type: menuentry
#: strings.texi.orig:33
msgid "Testing whether an object is a string or char."
msgstr "オブジェクトが文字列か文字化をテストする。"

#. type: section
#: strings.texi.orig:33 strings.texi.orig:116 strings.texi.orig:117
#, no-wrap
msgid "Creating Strings"
msgstr "Creating Strings"

#. type: menuentry
#: strings.texi.orig:33
msgid "Functions to allocate new strings."
msgstr "新しい文字列を割り当てる関数。"

#. type: section
#: strings.texi.orig:33 strings.texi.orig:372 strings.texi.orig:373
#, no-wrap
msgid "Modifying Strings"
msgstr "Modifying Strings"

#. type: menuentry
#: strings.texi.orig:33
msgid "Altering the contents of an existing string."
msgstr "既存の文字列の内容を変更する。"

#. type: node
#: strings.texi.orig:33 strings.texi.orig:406
#, no-wrap
msgid "Text Comparison"
msgstr "Text Comparison"

#. type: menuentry
#: strings.texi.orig:33
msgid "Comparing characters or strings."
msgstr "文字または文字列を比較する。"

#. type: node
#: strings.texi.orig:33 strings.texi.orig:583
#, no-wrap
msgid "String Conversion"
msgstr "String Conversion"

#. type: menuentry
#: strings.texi.orig:33
msgid "Converting to and from characters and strings."
msgstr "文字から文字列、文字から文字列への変換。"

#. type: section
#: strings.texi.orig:33 strings.texi.orig:695 strings.texi.orig:696
#, no-wrap
msgid "Formatting Strings"
msgstr "Formatting Strings"

#. type: menuentry
#: strings.texi.orig:33
msgid "@code{format}: Emacs's analogue of @code{printf}."
msgstr "@code{format}: @code{printf}のEmacsバージョン。"

#. type: node
#: strings.texi.orig:33 strings.texi.orig:927
#, no-wrap
msgid "Case Conversion"
msgstr "Case Conversion"

#. type: menuentry
#: strings.texi.orig:33
msgid "Case conversion functions."
msgstr "大文字小文字変換関数。"

#. type: node
#: strings.texi.orig:33 strings.texi.orig:1046
#, no-wrap
msgid "Case Tables"
msgstr "Case Tables"

#. type: menuentry
#: strings.texi.orig:33
msgid "Customizing case conversion."
msgstr "大文字小文字変換のカスタマイズ。"

#. type: node
#: strings.texi.orig:35
#, no-wrap
msgid "String Basics"
msgstr "String Basics"

#. type: section
#: strings.texi.orig:36
#, no-wrap
msgid "String and Character Basics"
msgstr "String and Character Basics"

#. type: Plain text
#: strings.texi.orig:43
msgid ""
"A character is a Lisp object which represents a single character of text.  "
"In Emacs Lisp, characters are simply integers; whether an integer is a "
"character or not is determined only by how it is used.  @xref{Character "
"Codes}, for details about character representation in Emacs."
msgstr "文字(character)とは、テキスト内の1つの文字を表すLispオブジェクトです。Emacs Lispでは、文字は単なる整数です。ある整数が文字か文字でないかを区別するのは、それが使用される方法だけです。Emacsでの文字表現についての詳細は、@ref{Character Codes}を参照してください。"

#. type: Plain text
#: strings.texi.orig:49
msgid ""
"A string is a fixed sequence of characters.  It is a type of sequence called "
"a @dfn{array}, meaning that its length is fixed and cannot be altered once "
"it is created (@pxref{Sequences Arrays Vectors}).  Unlike in C, Emacs Lisp "
"strings are @emph{not} terminated by a distinguished character code."
msgstr "文字列(string)とは、固定された文字シーケンスです。これは@dfn{配列(array)}と呼ばれるシーケンス型で、配列長が固定で、1度作成したら変更できないことを意味します(@ref{Sequences Arrays Vectors}を参照してください)。Cとは異なり、Emacs Lispの文字列は文字コードを判断することにより終端@emph{されません}。"

#. type: Plain text
#: strings.texi.orig:58
msgid ""
"Since strings are arrays, and therefore sequences as well, you can operate "
"on them with the general array and sequence functions documented in "
"@ref{Sequences Arrays Vectors}.  For example, you can access or change "
"individual characters in a string using the functions @code{aref} and "
"@code{aset} (@pxref{Array Functions}).  However, note that @code{length} "
"should @emph{not} be used for computing the width of a string on display; "
"use @code{string-width} (@pxref{Size of Displayed Text}) instead."
msgstr "文字列は配列であり、したがって同様にシーケンスでもあるので、@ref{Sequences Arrays Vectors}にドキュメントされている一般的な配列関数やシーケンス関数で、文字列を処理できます。たとえば、文字列内の特定の文字にアクセスしたり変更することができますしかし表示された文字列の幅を計算するために、@code{length}を使用するべきでは@emph{ない}ことに注意してください。かわりに@code{string-width}を使用してください(@ref{Size of Displayed Text}を参照してください)。"

#. type: Plain text
#: strings.texi.orig:63
msgid ""
"There are two text representations for non-@acronym{ASCII} characters in "
"Emacs strings (and in buffers): unibyte and multibyte.  For most Lisp "
"programming, you don't need to be concerned with these two representations.  "
"@xref{Text Representations}, for details."
msgstr "Emacs文字列での非@acronym{ASCII}にたいすテキスト表現は2つ --- ユニバイト(unibyte)とマルチバイト(multibyte)がありますほとんどのLispプログラミングでは、これら2つの表現を気にする必要はありません。詳細は、@ref{Text Representations}を参照してください。"

#. type: Plain text
#: strings.texi.orig:74
msgid ""
"Sometimes key sequences are represented as unibyte strings.  When a unibyte "
"string is a key sequence, string elements in the range 128 to 255 represent "
"meta characters (which are large integers) rather than character codes in "
"the range 128 to 255.  Strings cannot hold characters that have the hyper, "
"super or alt modifiers; they can hold @acronym{ASCII} control characters, "
"but no other control characters.  They do not distinguish case in "
"@acronym{ASCII} control characters.  If you want to store such characters in "
"a sequence, such as a key sequence, you must use a vector instead of a "
"string.  @xref{Character Type}, for more information about keyboard input "
"characters."
msgstr "キーシーケンスがユニバイト文字列で表されることがあります。ユニバイト文字列がキーシーケンスの場合、範囲128から255までの文字列要素は、範囲128から255の文字コードではなく、メタ文字(これは非常に大きな整数です)を表します。文字列はhyper、super、altで修飾された文字を保持できません。文字列は@acronym{ASCII}コントロール文字を保持できますが、それは他のコントロール文字です。文字列は@acronym{ASCII}コントロール文字の大文字小文字を区別できません。そのような文字をシーケンスに保存したい場合は、文字列ではなくベクターを使用しなければなりません。キーボード入力文字についての情報は、@ref{Character Type}を参照してください。"

#. type: Plain text
#: strings.texi.orig:81
msgid ""
"Strings are useful for holding regular expressions.  You can also match "
"regular expressions against strings with @code{string-match} (@pxref{Regexp "
"Search}).  The functions @code{match-string} (@pxref{Simple Match Data}) and "
"@code{replace-match} (@pxref{Replacing Match}) are useful for decomposing "
"and modifying strings after matching regular expressions against them."
msgstr "文字列は正規表現を保持するために便利です。@code{string-match} (@ref{Regexp Search}を参照してください)を使用して、文字列にたいして正規表現をマッチすることもできます。関数@code{match-string} (@ref{Simple Match Data}を参照してください)と、@code{replace-match} (@pxref{Replacing Match})は、文字列にたいして正規表現をマッチした後に、文字列を分解、変更するのに便利です。"

#. type: Plain text
#: strings.texi.orig:86
msgid ""
"Like a buffer, a string can contain text properties for the characters in "
"it, as well as the characters themselves.  @xref{Text Properties}.  All the "
"Lisp primitives that copy text from strings to buffers or other strings also "
"copy the properties of the characters being copied."
msgstr "バッファーのように、文字列は文字列内の文字自身と、その文字にたいするテキストプロパティーを含みます。@ref{Text Properties}を参照してください。文字列からバッファーや他の文字列にテキストをコピーする、すべてのLispプリミティブ(Lisp primitives)は、コピーされる文字のプロパティーもコピーします。"

#. type: Plain text
#: strings.texi.orig:92
msgid ""
"@xref{Text}, for information about functions that display strings or copy "
"them into buffers.  @xref{Character Type}, and @ref{String Type}, for "
"information about the syntax of characters and strings.  @xref{Non-ASCII "
"Characters}, for functions to convert between text representations and to "
"encode and decode character codes."
msgstr "文字列を表示したり、バッファーにコピーする関数についての情報は、@ref{Text}を参照してください。文字または文字列の構文についての情報は、@ref{Character Type}と@ref{String Type}を参照してください。異なるテキスト表現間で変換したり、文字コードをエンコード、デコードする関数については、@ref{Non-ASCII Characters}を参照してください。"

#. type: cindex
#: strings.texi.orig:95
#, no-wrap
msgid "predicates for strings"
msgstr "predicates for strings"

#. type: cindex
#: strings.texi.orig:96
#, no-wrap
msgid "string predicates"
msgstr "string predicates"

#. type: Plain text
#: strings.texi.orig:100
msgid ""
"For more information about general sequence and array predicates, see "
"@ref{Sequences Arrays Vectors}, and @ref{Arrays}."
msgstr "一般的なシーケンスや配列にたいする述語についての情報は、@ref{Sequences Arrays Vectors}、および@ref{Arrays}を参照してください。"

#. type: defun
#: strings.texi.orig:101
#, no-wrap
msgid "stringp object"
msgstr "stringp object"

#. type: defun
#: strings.texi.orig:104
msgid ""
"This function returns @code{t} if @var{object} is a string, @code{nil} "
"otherwise."
msgstr "この関数は@var{object}が文字列の場合は@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: strings.texi.orig:106
#, no-wrap
msgid "string-or-null-p object"
msgstr "string-or-null-p object"

#. type: defun
#: strings.texi.orig:109
msgid ""
"This function returns @code{t} if @var{object} is a string or @code{nil}.  "
"It returns @code{nil} otherwise."
msgstr "この関数は、@var{object}が文字列または@code{nil}の場合は@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: strings.texi.orig:111
#, no-wrap
msgid "char-or-string-p object"
msgstr "char-or-string-p object"

#. type: defun
#: strings.texi.orig:114
msgid ""
"This function returns @code{t} if @var{object} is a string or a character "
"(i.e., an integer), @code{nil} otherwise."
msgstr "この関数は、@var{object}が文字列または文字(たとえば整数)の場合は@code{t}、それ以外は@code{nil}をreturnします。"

#. type: cindex
#: strings.texi.orig:118
#, no-wrap
msgid "creating strings"
msgstr "creating strings"

#. type: cindex
#: strings.texi.orig:119
#, no-wrap
msgid "string creation"
msgstr "string creation"

#. type: Plain text
#: strings.texi.orig:123
msgid ""
"The following functions create strings, either from scratch, or by putting "
"strings together, or by taking them apart."
msgstr "以下の関数は、新たに文字列を作成したり、文字列同士を結合して文字列を作成したり、文字列の一部から文字列を作成する関数です。"

#. type: defun
#: strings.texi.orig:124
#, no-wrap
msgid "make-string count character"
msgstr "make-string count character"

#. type: defun
#: strings.texi.orig:127
msgid ""
"This function returns a string made up of @var{count} repetitions of "
"@var{character}.  If @var{count} is negative, an error is signaled."
msgstr "この関数は、@var{character}を@var{count}回繰り返すことにより作成された文字列をreturnします。@var{count}が負の場合は、エラーをシグナルします。"

#. type: example
#: strings.texi.orig:133
#, no-wrap
msgid ""
"(make-string 5 ?x)\n"
"     @result{} \"xxxxx\"\n"
"(make-string 0 ?x)\n"
"     @result{} \"\"\n"
msgstr ""
"(make-string 5 ?x)\n"
"     @result{} \"xxxxx\"\n"
"(make-string 0 ?x)\n"
"     @result{} \"\"\n"

#. type: defun
#: strings.texi.orig:137
msgid ""
"Other functions to compare with this one include @code{make-vector} "
"(@pxref{Vectors}) and @code{make-list} (@pxref{Building Lists})."
msgstr "この関数に対応する他の関数には@code{make-vector} (@ref{Vectors}を参照してください)、および@code{make-list} (@ref{Building Lists}を参照してください)が含まれます。"

#. type: defun
#: strings.texi.orig:139
#, no-wrap
msgid "string &rest characters"
msgstr "string &rest characters"

#. type: defun
#: strings.texi.orig:141
msgid "This returns a string containing the characters @var{characters}."
msgstr "この関数は、文字@var{characters}を含む文字列をreturnします。"

#. type: example
#: strings.texi.orig:145
#, no-wrap
msgid ""
"(string ?a ?b ?c)\n"
"     @result{} \"abc\"\n"
msgstr ""
"(string ?a ?b ?c)\n"
"     @result{} \"abc\"\n"

#. type: defun
#: strings.texi.orig:148
#, no-wrap
msgid "substring string start &optional end"
msgstr "substring string start &optional end"

#. type: defun
#: strings.texi.orig:153
msgid ""
"This function returns a new string which consists of those characters from "
"@var{string} in the range from (and including) the character at the index "
"@var{start} up to (but excluding) the character at the index @var{end}.  The "
"first character is at index zero."
msgstr "この関数は、@var{string}から、インデックス@var{start}の文字(その文字を含む)から、@var{end}までの文字(その文字は含まない)の範囲の文字から構成される、新しい文字列をreturnします。文字列の最初の文字がインデックス0になります。"

#. type: group
#: strings.texi.orig:158
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0 3)\n"
"     @result{} \"abc\"\n"
msgstr ""
"(substring \"abcdefg\" 0 3)\n"
"     @result{} \"abc\"\n"

#. type: defun
#: strings.texi.orig:167
msgid ""
"In the above example, the index for @samp{a} is 0, the index for @samp{b} is "
"1, and the index for @samp{c} is 2.  The index 3---which is the fourth "
"character in the string---marks the character position up to which the "
"substring is copied.  Thus, @samp{abc} is copied from the string "
"@code{\"abcdefg\"}."
msgstr "上記の例では、@samp{a}のインデックスは0、@samp{b}のインデックスは1、@samp{c}のインデックスは2です。インデックス3 --- この文字列の4番目の文字 --- は、部分文字列がコピーされる文字位置までをマークします。したがって文字列@code{\"abcdefg\"}から、@samp{abc}がコピーされます。"

#. type: defun
#: strings.texi.orig:170
msgid ""
"A negative number counts from the end of the string, so that @minus{}1 "
"signifies the index of the last character of the string.  For example:"
msgstr "負のかすは、文字列の最後から数えることを意味するので、@minus{}1は文字列の最後の文字のインデックスです。たとえば:"

#. type: group
#: strings.texi.orig:175
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 -1)\n"
"     @result{} \"ef\"\n"
msgstr ""
"(substring \"abcdefg\" -3 -1)\n"
"     @result{} \"ef\"\n"

#. type: defun
#: strings.texi.orig:182
msgid ""
"In this example, the index for @samp{e} is @minus{}3, the index for @samp{f} "
"is @minus{}2, and the index for @samp{g} is @minus{}1.  Therefore, @samp{e} "
"and @samp{f} are included, and @samp{g} is excluded."
msgstr "この例では、@samp{e}のインデックスは@minus{}3、@samp{f}のインデックスは@minus{}2、@samp{g}のインデックスは@minus{}1です。したがって、@samp{e}と@samp{f}が含まれ、@samp{g}は含まれません。"

#. type: defun
#: strings.texi.orig:185
msgid ""
"When @code{nil} is used for @var{end}, it stands for the length of the "
"string.  Thus,"
msgstr "@var{end}に@code{nil}が使用された場合、それは文字列の長さを意味します。したがって、"

#. type: group
#: strings.texi.orig:190
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 nil)\n"
"     @result{} \"efg\"\n"
msgstr ""
"(substring \"abcdefg\" -3 nil)\n"
"     @result{} \"efg\"\n"

#. type: defun
#: strings.texi.orig:196
msgid ""
"Omitting the argument @var{end} is equivalent to specifying @code{nil}.  It "
"follows that @code{(substring @var{string} 0)} returns a copy of all of "
"@var{string}."
msgstr "引数@var{end}を省略した場合、それは@code{nil}を指定したのと同じです。@code{(substring @var{string} 0)}は、@var{string}のすべてをコピーしてreturnします。"

#. type: group
#: strings.texi.orig:201
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0)\n"
"     @result{} \"abcdefg\"\n"
msgstr ""
"(substring \"abcdefg\" 0)\n"
"     @result{} \"abcdefg\"\n"

#. type: defun
#: strings.texi.orig:207
msgid ""
"But we recommend @code{copy-sequence} for this purpose (@pxref{Sequence "
"Functions})."
msgstr "しかし、この目的のためには@code{copy-sequence}を推奨します(@pxref{Sequence Functions})。"

#. type: defun
#: strings.texi.orig:210
msgid ""
"If the characters copied from @var{string} have text properties, the "
"properties are copied into the new string also.  @xref{Text Properties}."
msgstr "@var{string}からコピーされた文字がテキストプロパティーをもつ場合、そのプロパティーは新しい文字列へもコピーされます。@ref{Text Properties}を参照してください。"

#. type: defun
#: strings.texi.orig:213
msgid "@code{substring} also accepts a vector for the first argument.  For example:"
msgstr "@code{substring}の最初の引数にはベクターも指定できます。たとえば:"

#. type: example
#: strings.texi.orig:217
#, no-wrap
msgid ""
"(substring [a b (c) \"d\"] 1 3)\n"
"     @result{} [b (c)]\n"
msgstr ""
"(substring [a b (c) \"d\"] 1 3)\n"
"     @result{} [b (c)]\n"

#. type: defun
#: strings.texi.orig:224
msgid ""
"A @code{wrong-type-argument} error is signaled if @var{start} is not an "
"integer or if @var{end} is neither an integer nor @code{nil}.  An "
"@code{args-out-of-range} error is signaled if @var{start} indicates a "
"character following @var{end}, or if either integer is out of range for "
"@var{string}."
msgstr "@var{start}が整数でない場合、または@var{end}が整数でも@code{nil}でもない場合は、@code{wrong-type-argument}エラーがシグナルされます。@var{start}が@var{end}の後の文字を指す場合、または@var{string}にたいして範囲外の整数をどちらかに指定した場合は、@code{args-out-of-range}エラーがシグナルされます。"

#. type: defun
#: strings.texi.orig:229
msgid ""
"Contrast this function with @code{buffer-substring} (@pxref{Buffer "
"Contents}), which returns a string containing a portion of the text in the "
"current buffer.  The beginning of a string is at index 0, but the beginning "
"of a buffer is at index 1."
msgstr "この関数に対応するのは@code{buffer-substring} (@ref{Buffer Contents}を参照してください)で、これはカレントバッファー内のテキストの一部を含む文字列をreturnします。文字列の先頭はインデックス0ですが、バッファーの先頭はインデックス1です。"

#. type: defun
#: strings.texi.orig:231
#, no-wrap
msgid "substring-no-properties string &optional start end"
msgstr "substring-no-properties string &optional start end"

#. type: defun
#: strings.texi.orig:237
msgid ""
"This works like @code{substring} but discards all text properties from the "
"value.  Also, @var{start} may be omitted or @code{nil}, which is equivalent "
"to 0.  Thus, @w{@code{(substring-no-properties @var{string})}} returns a "
"copy of @var{string}, with all text properties removed."
msgstr "これは@code{substring}と同じようにL機能しますが、値からすべてのテキストプロパティーを破棄します。@var{start}を省略したり、@code{nil}を指定することができ、この場合0に等しくなります。したがって@w{@code{(substring-no-properties @var{string})}}は、すべてのテキストプロパティーが削除された@var{string}のコピーをreturnします。"

#. type: defun
#: strings.texi.orig:239
#, no-wrap
msgid "concat &rest sequences"
msgstr "concat &rest sequences"

#. type: cindex
#: strings.texi.orig:240
#, no-wrap
msgid "copying strings"
msgstr "copying strings"

#. type: cindex
#: strings.texi.orig:241
#, no-wrap
msgid "concatenating strings"
msgstr "concatenating strings"

#. type: defun
#: strings.texi.orig:247
msgid ""
"This function returns a new string consisting of the characters in the "
"arguments passed to it (along with their text properties, if any).  The "
"arguments may be strings, lists of numbers, or vectors of numbers; they are "
"not themselves changed.  If @code{concat} receives no arguments, it returns "
"an empty string."
msgstr "この関数は、渡された引数内の文字からなる、新しい文字列をreturnします(もしあればテキストプロパティーも)。引数には文字列、数のリスト、数のベクターを指定できます。引数は変更されません。@code{concat}に引数を指定しない場合、空文字列をreturnします。"

#. type: example
#: strings.texi.orig:260
#, no-wrap
msgid ""
"(concat \"abc\" \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"abc\" (list 120 121) [122])\n"
"     @result{} \"abcxyz\"\n"
";; @r{@code{nil} is an empty sequence.}\n"
"(concat \"abc\" nil \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"The \" \"quick brown \" \"fox.\")\n"
"     @result{} \"The quick brown fox.\"\n"
"(concat)\n"
"     @result{} \"\"\n"
msgstr ""
"(concat \"abc\" \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"abc\" (list 120 121) [122])\n"
"     @result{} \"abcxyz\"\n"
";; @r{@code{nil}hあ空のシーケンス。}\n"
"(concat \"abc\" nil \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"The \" \"quick brown \" \"fox.\")\n"
"     @result{} \"The quick brown fox.\"\n"
"(concat)\n"
"     @result{} \"\"\n"

#. type: defun
#: strings.texi.orig:266
msgid ""
"This function always constructs a new string that is not @code{eq} to any "
"existing string, except when the result is the empty string (to save space, "
"Emacs makes only one empty multibyte string)."
msgstr "この関数は常に、任意の既存の文字列にたいして@code{eq}ではない、新しい文字列を構築しますが、結果が空文字列の時は例外です(スペースを省くために、Emacsは空のマルチバイト文字列を1つだけ作成します)。"

#. type: defun
#: strings.texi.orig:273
msgid ""
"For information about other concatenation functions, see the description of "
"@code{mapconcat} in @ref{Mapping Functions}, @code{vconcat} in @ref{Vector "
"Functions}, and @code{append} in @ref{Building Lists}.  For concatenating "
"individual command-line arguments into a string to be used as a shell "
"command, see @ref{Shell Arguments, combine-and-quote-strings}."
msgstr "他の結合関数(concatenation functions)についての情報は、@ref{Mapping Functions}の@code{mapconcat}、@ref{Vector Functions}の@code{vconcat}、@ref{Building Lists}の@code{append}を参照してください。シェルコマンドで使用される文字列の中に、個々のコマンドライン引数を結合するには、@ref{Shell Arguments, combine-and-quote-strings}を参照してください。"

#. type: defun
#: strings.texi.orig:275
#, no-wrap
msgid "split-string string &optional separators omit-nulls trim"
msgstr "split-string string &optional separators omit-nulls trim"

#. type: defun
#: strings.texi.orig:280
msgid ""
"This function splits @var{string} into substrings based on the regular "
"expression @var{separators} (@pxref{Regular Expressions}).  Each match for "
"@var{separators} defines a splitting point; the substrings between splitting "
"points are made into a list, which is returned."
msgstr "この関数は、正規表現@var{separators}(@ref{Regular Expressions}を参照してください)にもとづいて、@var{string}を部分文字列に分解します。@var{separators}にたいする各マッチは、分割位置を定義します。分割位置の間にある部分文字列を、リストにまとめてreturnします。"

#. type: defun
#: strings.texi.orig:286
msgid ""
"If @var{omit-nulls} is @code{nil} (or omitted), the result contains null "
"strings whenever there are two consecutive matches for @var{separators}, or "
"a match is adjacent to the beginning or end of @var{string}.  If "
"@var{omit-nulls} is @code{t}, these null strings are omitted from the "
"result."
msgstr "@var{omit-nulls}が@code{nil}(または省略)の場合、連続する2つの@var{separators}へのマッチ、または@var{string}の最初か最後にマッチしたときの空文字列が結果に含まれます。@var{omit-nulls}が@code{t}の場合、これらの空文字列は結果から除外されます。"

#. type: defun
#: strings.texi.orig:289
msgid ""
"If @var{separators} is @code{nil} (or omitted), the default is the value of "
"@code{split-string-default-separators}."
msgstr "@var{separators}が@code{nil}(または省略)の場合、デフォルトは@code{split-string-default-separators}の値になります。"

#. type: defun
#: strings.texi.orig:292
msgid ""
"As a special case, when @var{separators} is @code{nil} (or omitted), null "
"strings are always omitted from the result.  Thus:"
msgstr "特別なケースとして、@var{separators}が@code{nil}(または省略)の場合、常に結果から空文字列が除外されます。したがって:"

#. type: example
#: strings.texi.orig:296
#, no-wrap
msgid ""
"(split-string \"  two words \")\n"
"     @result{} (\"two\" \"words\")\n"
msgstr ""
"(split-string \"  two words \")\n"
"     @result{} (\"two\" \"words\")\n"

#. type: defun
#: strings.texi.orig:301
msgid ""
"The result is not @code{(\"\" \"two\" \"words\" \"\")}, which would rarely "
"be useful.  If you need such a result, use an explicit value for "
"@var{separators}:"
msgstr "結果は、ほとんど有用ではないであろう@code{(\"\" \"two\" \"words\" \"\")}という結果ではありません。このような結果が必要な時は、@var{separators}に明示的な値を使用します:"

#. type: example
#: strings.texi.orig:306
#, no-wrap
msgid ""
"(split-string \"  two words \"\n"
"              split-string-default-separators)\n"
"     @result{} (\"\" \"two\" \"words\" \"\")\n"
msgstr ""
"(split-string \"  two words \"\n"
"              split-string-default-separators)\n"
"     @result{} (\"\" \"two\" \"words\" \"\")\n"

#. type: defun
#: strings.texi.orig:309
msgid "More examples:"
msgstr "他にも例を示します:"

#. type: example
#: strings.texi.orig:317
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o\")\n"
"     @result{} (\"S\" \"up is g\" \"\" \"d f\" \"\" \"d\")\n"
"(split-string \"Soup is good food\" \"o\" t)\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
"(split-string \"Soup is good food\" \"o+\")\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
msgstr ""
"(split-string \"Soup is good food\" \"o\")\n"
"     @result{} (\"S\" \"up is g\" \"\" \"d f\" \"\" \"d\")\n"
"(split-string \"Soup is good food\" \"o\" t)\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
"(split-string \"Soup is good food\" \"o+\")\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"

#. type: defun
#: strings.texi.orig:322
msgid ""
"Empty matches do count, except that @code{split-string} will not look for a "
"final empty match when it already reached the end of the string using a "
"non-empty match or when @var{string} is empty:"
msgstr "空のマッチはカウントされます。例外は、空でないマッチを使用することにより、すでに文字列の最後に到達しているとき、または@var{string}が空の時で、この場合@code{split-string}は最後の空マッチを探しません。"

#. type: example
#: strings.texi.orig:330
#, no-wrap
msgid ""
"(split-string \"aooob\" \"o*\")\n"
"     @result{} (\"\" \"a\" \"\" \"b\" \"\")\n"
"(split-string \"ooaboo\" \"o*\")\n"
"     @result{} (\"\" \"\" \"a\" \"b\" \"\")\n"
"(split-string \"\" \"\")\n"
"     @result{} (\"\")\n"
msgstr ""
"(split-string \"aooob\" \"o*\")\n"
"     @result{} (\"\" \"a\" \"\" \"b\" \"\")\n"
"(split-string \"ooaboo\" \"o*\")\n"
"     @result{} (\"\" \"\" \"a\" \"b\" \"\")\n"
"(split-string \"\" \"\")\n"
"     @result{} (\"\")\n"

#. type: defun
#: strings.texi.orig:335
msgid ""
"However, when @var{separators} can match the empty string, @var{omit-nulls} "
"is usually @code{t}, so that the subtleties in the three previous examples "
"are rarely relevant:"
msgstr "しかし、@var{separators}が空文字列にマッチできるとき、通常は@var{omit-nulls}は@code{t}にすれば、前の3つの例の不明瞭さは、ほとんど発生しません:"

#. type: example
#: strings.texi.orig:343
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o*\" t)\n"
"     @result{} (\"S\" \"u\" \"p\" \" \" \"i\" \"s\" \" \" \"g\" \"d\" \" \" "
"\"f\" \"d\")\n"
"(split-string \"Nice doggy!\" \"\" t)\n"
"     @result{} (\"N\" \"i\" \"c\" \"e\" \" \" \"d\" \"o\" \"g\" \"g\" \"y\" "
"\"!\")\n"
"(split-string \"\" \"\" t)\n"
"     @result{} nil\n"
msgstr ""
"(split-string \"Soup is good food\" \"o*\" t)\n"
"     @result{} (\"S\" \"u\" \"p\" \" \" \"i\" \"s\" \" \" \"g\" \"d\" \" \" \"f\" \"d\")\n"
"(split-string \"Nice doggy!\" \"\" t)\n"
"     @result{} (\"N\" \"i\" \"c\" \"e\" \" \" \"d\" \"o\" \"g\" \"g\" \"y\" \"!\")\n"
"(split-string \"\" \"\" t)\n"
"     @result{} nil\n"

#. type: defun
#: strings.texi.orig:349
msgid ""
"Somewhat odd, but predictable, behavior can occur for certain ``non-greedy'' "
"values of @var{separators} that can prefer empty matches over non-empty "
"matches.  Again, such values rarely occur in practice:"
msgstr "空でないマッチより空のマッチを優先するような、一部の``非貪欲(non-greedy)''な値を@var{separators}に指定することにより、幾分奇妙(しかし予見可能)な振る舞いが発生する場合があります。繰り返しますが、そのような値は実際にはまれです:"

#. type: example
#: strings.texi.orig:355
#, no-wrap
msgid ""
"(split-string \"ooo\" \"o*\" t)\n"
"     @result{} nil\n"
"(split-string \"ooo\" \"\\\\|o+\" t)\n"
"     @result{} (\"o\" \"o\" \"o\")\n"
msgstr ""
"(split-string \"ooo\" \"o*\" t)\n"
"     @result{} nil\n"
"(split-string \"ooo\" \"\\\\|o+\" t)\n"
"     @result{} (\"o\" \"o\" \"o\")\n"

#. type: defun
#: strings.texi.orig:361
msgid ""
"If the optional argument @var{trim} is non-@code{nil}, it should be a "
"regular expression to match text to trim from the beginning and end of each "
"substring.  If trimming makes the substring empty, it is treated as null."
msgstr "オプションの引数@var{trim}が非@code{nil}の場合、その値は各部分文字列の最初と最後からトリムするテキストにマッチする正規表現を指定します。トリムにより、その部分文字列が空になるような場合、それは空文字列として扱われます。"

#. type: defun
#: strings.texi.orig:365
msgid ""
"If you need to split a string into a list of individual command-line "
"arguments suitable for @code{call-process} or @code{start-process}, see "
"@ref{Shell Arguments, split-string-and-unquote}."
msgstr "文字列を分割して、@code{call-process}や@code{start-process}に適した、個々のコマンドライン引数のリストにする必要がある場合は、@ref{Shell Arguments, split-string-and-unquote}を参照してください。"

#. type: defvar
#: strings.texi.orig:367
#, no-wrap
msgid "split-string-default-separators"
msgstr "split-string-default-separators"

#. type: defvar
#: strings.texi.orig:370
msgid ""
"The default value of @var{separators} for @code{split-string}.  Its usual "
"value is @w{@code{\"[ \\f\\t\\n\\r\\v]+\"}}."
msgstr "@code{split-string}の@var{separators}にたいするデフォルト値です。通常の値は、@w{@code{\"[ \\f\\t\\n\\r\\v]+\"}}です。"

#. type: cindex
#: strings.texi.orig:374
#, no-wrap
msgid "modifying strings"
msgstr "modifying strings"

#. type: cindex
#: strings.texi.orig:375
#, no-wrap
msgid "string modification"
msgstr "string modification"

#. type: Plain text
#: strings.texi.orig:383
msgid ""
"The most basic way to alter the contents of an existing string is with "
"@code{aset} (@pxref{Array Functions}).  @code{(aset @var{string} @var{idx} "
"@var{char})} stores @var{char} into @var{string} at index @var{idx}.  Each "
"character occupies one or more bytes, and if @var{char} needs a different "
"number of bytes from the character already present at that index, "
"@code{aset} signals an error."
msgstr "既存の文字列の内容を変更するもっとも基本的な方法は、@code{aset} (@pxref{Array Functions})を使用する方法です。@code{(aset @var{string} @var{idx} @var{char})}は、@var{string}のインデックス@var{idx}に、@var{char}を格納します。それぞれの文字は１文字以上を占有しますが、すでにインデックスの場所にある文字のバイト数が、@var{char}が要するバイト数と異なる場合、@code{aset}はエラーをシグナルします。"

#. type: Plain text
#: strings.texi.orig:385
msgid "A more powerful function is @code{store-substring}:"
msgstr "より強力な関数は@code{store-substring}です:"

#. type: defun
#: strings.texi.orig:386
#, no-wrap
msgid "store-substring string idx obj"
msgstr "store-substring string idx obj"

#. type: defun
#: strings.texi.orig:390
msgid ""
"This function alters part of the contents of the string @var{string}, by "
"storing @var{obj} starting at index @var{idx}.  The argument @var{obj} may "
"be either a character or a (smaller) string."
msgstr "この関数は、インデックス@var{idx}で開始される位置に@var{obj}を格納することにより、文字列@var{string}の内容の一部を変更します。@var{obj}は文字、または(@var{string}より小さい)文字列です。"

#. type: defun
#: strings.texi.orig:395
msgid ""
"Since it is impossible to change the length of an existing string, it is an "
"error if @var{obj} doesn't fit within @var{string}'s actual length, or if "
"any new character requires a different number of bytes from the character "
"currently present at that point in @var{string}."
msgstr "既存の文字列の長さを変更するのは不可能なので、@var{string}の実際の長さに@var{obj}が収まらない場合、または@var{string}のその位置に現在ある文字のバイト数が、新しい文字に必要なバイト数と異なる場合はエラーになります。"

#. type: Plain text
#: strings.texi.orig:399
msgid "To clear out a string that contained a password, use @code{clear-string}:"
msgstr "パスワードを含む文字列をクリアーするときは、@code{clear-string}を使用します:"

#. type: defun
#: strings.texi.orig:400
#, no-wrap
msgid "clear-string string"
msgstr "clear-string string"

#. type: defun
#: strings.texi.orig:403
msgid ""
"This makes @var{string} a unibyte string and clears its contents to zeros.  "
"It may also change @var{string}'s length."
msgstr "これは@var{string}をユニバイト文字列として、内容を0にクリアーします。これにより@var{string}の長さも変更されるでしょう。"

#. type: section
#: strings.texi.orig:407
#, no-wrap
msgid "Comparison of Characters and Strings"
msgstr "Comparison of Characters and Strings"

#. type: cindex
#: strings.texi.orig:408
#, no-wrap
msgid "string equality"
msgstr "string equality"

#. type: cindex
#: strings.texi.orig:409
#, no-wrap
msgid "text comparison"
msgstr "text comparison"

#. type: defun
#: strings.texi.orig:411
#, no-wrap
msgid "char-equal character1 character2"
msgstr "char-equal character1 character2"

#. type: defun
#: strings.texi.orig:415
msgid ""
"This function returns @code{t} if the arguments represent the same "
"character, @code{nil} otherwise.  This function ignores differences in case "
"if @code{case-fold-search} is non-@code{nil}."
msgstr "この関数は引数が同じ文字を表す場合は@code{t}、それ以外は@code{nil}をreturnします。@code{case-fold-search}が非@code{nil}の場合、この関数は大文字小文字の違いを無視します。"

#. type: example
#: strings.texi.orig:422
#, no-wrap
msgid ""
"(char-equal ?x ?x)\n"
"     @result{} t\n"
"(let ((case-fold-search nil))\n"
"  (char-equal ?x ?X))\n"
"     @result{} nil\n"
msgstr ""
"(char-equal ?x ?x)\n"
"     @result{} t\n"
"(let ((case-fold-search nil))\n"
"  (char-equal ?x ?X))\n"
"     @result{} nil\n"

#. type: defun
#: strings.texi.orig:425
#, no-wrap
msgid "string= string1 string2"
msgstr "string= string1 string2"

#. type: defun
#: strings.texi.orig:430
msgid ""
"This function returns @code{t} if the characters of the two strings match "
"exactly.  Symbols are also allowed as arguments, in which case the symbol "
"names are used.  Case is always significant, regardless of "
"@code{case-fold-search}."
msgstr "この関数は、2つの文字列の文字が正確にマッチする場合は、@code{t}をreturnします。引数にシンボルを指定することもでき、この場合はシンボル名が使用されます。@code{case-fold-search}とは無関係に、大文字小文字は常に意味をもちます。"

#. type: defun
#: strings.texi.orig:437
msgid ""
"This function is equivalent to @code{equal} for comparing two strings "
"(@pxref{Equality Predicates}).  In particular, the text properties of the "
"two strings are ignored; use @code{equal-including-properties} if you need "
"to distinguish between strings that differ only in their text properties.  "
"However, unlike @code{equal}, if either argument is not a string or symbol, "
"@code{string=} signals an error."
msgstr "この関数は、@code{equal}で2つの文字列を比較するのと等価です(@ref{Equality Predicates}を参照してください)。特に、2つの文字列のテキストプロパティーは無視されます。テキストプロパティーだけが異なる文字列を区別する必要がある場合は、@code{equal-including-properties}を使用します。しかし@code{equal}とは異なり、どちらかの引数が文字列でもシンボルでもない場合、@code{string=}はエラーをシグナルします。"

#. type: example
#: strings.texi.orig:445
#, no-wrap
msgid ""
"(string= \"abc\" \"abc\")\n"
"     @result{} t\n"
"(string= \"abc\" \"ABC\")\n"
"     @result{} nil\n"
"(string= \"ab\" \"ABC\")\n"
"     @result{} nil\n"
msgstr ""
"(string= \"abc\" \"abc\")\n"
"     @result{} t\n"
"(string= \"abc\" \"ABC\")\n"
"     @result{} nil\n"
"(string= \"ab\" \"ABC\")\n"
"     @result{} nil\n"

#. type: defun
#: strings.texi.orig:462
msgid ""
"For technical reasons, a unibyte and a multibyte string are @code{equal} if "
"and only if they contain the same sequence of character codes and all these "
"codes are either in the range 0 through 127 (@acronym{ASCII}) or 160 through "
"255 (@code{eight-bit-graphic}).  However, when a unibyte string is converted "
"to a multibyte string, all characters with codes in the range 160 through "
"255 are converted to characters with higher codes, whereas @acronym{ASCII} "
"characters remain unchanged.  Thus, a unibyte string and its conversion to "
"multibyte are only @code{equal} if the string is all @acronym{ASCII}.  "
"Character codes 160 through 255 are not entirely proper in multibyte text, "
"even though they can occur.  As a consequence, the situation where a unibyte "
"and a multibyte string are @code{equal} without both being all "
"@acronym{ASCII} is a technical oddity that very few Emacs Lisp programmers "
"ever get confronted with.  @xref{Text Representations}."
msgstr "技術的な理由により、ユニバイト文字列とマルチバイト文字列が@code{equal}なのは、それらが同じ文字コードのシーケンスを含み、それらすべてのコードが0から127(@acronym{ASCII})か、160から255(@code{eight-bit-graphic})のときだけです。しかしユニバイト文字列をマルチバイト文字列に変更する際、コードが160から255の範囲にあるすべての文字はより高いコードに変換され、@acronym{ASCII}文字は変換されないまま残ります。したがってユニバイト文字列と、それを変換したマルチバイト文字列は、その文字列のすべてが@acronym{ASCII}のときだけ@code{equal}です。マルチバイト文字列中で、もし文字コード160から255の文字があったとしても、それは完全に正しいとは言えません。結果として、すべてが@acronym{ASCII}ではないユニバイト文字列とマルチバイト文字列が@code{equal}であるという状況は、もしかしたらEmacs Lispプロプラマーが直面するかもしれない、とても希少な偽術的に不可解な状況だといえます。@ref{Text Representations}を参照してください。"

#. type: defun
#: strings.texi.orig:464
#, no-wrap
msgid "string-equal string1 string2"
msgstr "string-equal string1 string2"

#. type: defun
#: strings.texi.orig:466
msgid "@code{string-equal} is another name for @code{string=}."
msgstr "@code{string-equal}は@code{string=}に対する別名です。"

#. type: cindex
#: strings.texi.orig:468
#, no-wrap
msgid "lexical comparison"
msgstr "lexical comparison"

#. type: defun
#: strings.texi.orig:469
#, no-wrap
msgid "string< string1 string2"
msgstr "string< string1 string2"

#. type: defun
#: strings.texi.orig:478
msgid ""
"This function compares two strings a character at a time.  It scans both the "
"strings at the same time to find the first pair of corresponding characters "
"that do not match.  If the lesser character of these two is the character "
"from @var{string1}, then @var{string1} is less, and this function returns "
"@code{t}.  If the lesser character is the one from @var{string2}, then "
"@var{string1} is greater, and this function returns @code{nil}.  If the two "
"strings match entirely, the value is @code{nil}."
msgstr "この関数は、2つの文字列を1文字づつ比較します。この関数は、同時に2つの文字列をスキャンして、対応する文字同士がマッチしない最初のペアを探します。2つの文字列内で、小さいほうの文字が@var{string1}の文字の場合、@var{string1}が小さいことになり、この関数は@code{t}をreturnします。小さいほうの文字が@var{string2}の文字の場合、@var{string1}が大きいことになり、この関数は@code{nil}をreturnします。2つの文字列が完全にマッチした場合、値は@code{nil}になります。"

#. type: defun
#: strings.texi.orig:486
msgid ""
"Pairs of characters are compared according to their character codes.  Keep "
"in mind that lower case letters have higher numeric values in the "
"@acronym{ASCII} character set than their upper case counterparts; digits and "
"many punctuation characters have a lower numeric value than upper case "
"letters.  An @acronym{ASCII} character is less than any non-@acronym{ASCII} "
"character; a unibyte non-@acronym{ASCII} character is always less than any "
"multibyte non-@acronym{ASCII} character (@pxref{Text Representations})."
msgstr "文字のペアは、文字コードで比較されます。@acronym{ASCII}文字セットでは、小文字英字は大文字英字より、高い数値をもつことに留意してください。数字および多くの句読点文字は、大文字英字より低い数値をもちます。@acronym{ASCII}文字は、任意の非@acronym{ASCII}文字より小さくなります。ユニバイト非@acronym{ASCII}文字は、任意のマルチバイト非@acronym{ASCII}文字より、常に小さくなります(@ref{Text Representations}を参照してください)。"

#. type: group
#: strings.texi.orig:495
#, no-wrap
msgid ""
"(string< \"abc\" \"abd\")\n"
"     @result{} t\n"
"(string< \"abd\" \"abc\")\n"
"     @result{} nil\n"
"(string< \"123\" \"abc\")\n"
"     @result{} t\n"
msgstr ""
"(string< \"abc\" \"abd\")\n"
"     @result{} t\n"
"(string< \"abd\" \"abc\")\n"
"     @result{} nil\n"
"(string< \"123\" \"abc\")\n"
"     @result{} t\n"

#. type: defun
#: strings.texi.orig:502
msgid ""
"When the strings have different lengths, and they match up to the length of "
"@var{string1}, then the result is @code{t}.  If they match up to the length "
"of @var{string2}, the result is @code{nil}.  A string of no characters is "
"less than any other string."
msgstr "文字列の長さが異なり、@var{string1}の長さまでマッチする場合、結果は@code{t}になります。@var{string2}の長さまでマッチする場合、結果は@code{nil}になります。文字を含まない文字列は、他の任意の文字列より小さくなります。"

#. type: group
#: strings.texi.orig:515
#, no-wrap
msgid ""
"(string< \"\" \"abc\")\n"
"     @result{} t\n"
"(string< \"ab\" \"abc\")\n"
"     @result{} t\n"
"(string< \"abc\" \"\")\n"
"     @result{} nil\n"
"(string< \"abc\" \"ab\")\n"
"     @result{} nil\n"
"(string< \"\" \"\")\n"
"     @result{} nil\n"
msgstr ""
"(string< \"\" \"abc\")\n"
"     @result{} t\n"
"(string< \"ab\" \"abc\")\n"
"     @result{} t\n"
"(string< \"abc\" \"\")\n"
"     @result{} nil\n"
"(string< \"abc\" \"ab\")\n"
"     @result{} nil\n"
"(string< \"\" \"\")\n"
"     @result{} nil\n"

#. type: defun
#: strings.texi.orig:520
msgid ""
"Symbols are also allowed as arguments, in which case their print names are "
"used."
msgstr "引数としてシンボルを指定することもでき、この場合はシンボルのプリント名が使用されます。"

#. type: defun
#: strings.texi.orig:522
#, no-wrap
msgid "string-lessp string1 string2"
msgstr "string-lessp string1 string2"

#. type: defun
#: strings.texi.orig:524
msgid "@code{string-lessp} is another name for @code{string<}."
msgstr "@code{string-lessp}は@code{string<}にたいする別名です。"

#. type: defun
#: strings.texi.orig:526
#, no-wrap
msgid "string-prefix-p string1 string2 &optional ignore-case"
msgstr "string-prefix-p string1 string2 &optional ignore-case"

#. type: defun
#: strings.texi.orig:531
msgid ""
"This function returns non-@code{nil} if @var{string1} is a prefix of "
"@var{string2}; i.e., if @var{string2} starts with @var{string1}.  If the "
"optional argument @var{ignore-case} is non-@code{nil}, the comparison "
"ignores case differences."
msgstr "この関数は、@var{string1}が@var{string2}のプレフィクス(接頭辞)の場合(たとえば@var{string2}が@var{string1}で始まる場合)、非@code{nil}をreturnします。オプションの引数@var{ignore-case}が非@code{nil}の場合、比較において大文字小文字の違いは無視されます。"

#. type: defun
#: strings.texi.orig:533
#, no-wrap
msgid "string-suffix-p suffix string &optional ignore-case"
msgstr "string-suffix-p suffix string &optional ignore-case"

#. type: defun
#: strings.texi.orig:538
msgid ""
"This function returns non-@code{nil} if @var{suffix} is a suffix of "
"@var{string}; i.e., if @var{string} ends with @var{suffix}.  If the optional "
"argument @var{ignore-case} is non-@code{nil}, the comparison ignores case "
"differences."
msgstr "この関数は、@var{suffix}が@var{string}のサフィックス(接尾辞)の場合(たとえば@var{string}が@var{suffix}で終わる場合)、非@code{nil}をreturnします。オプションの引数@var{ignore-case}が非@code{nil}の場合、比較において大文字小文字の違いは無視されます。"

#. type: defun
#: strings.texi.orig:540
#, no-wrap
msgid ""
"compare-strings string1 start1 end1 string2 start2 end2 &optional "
"ignore-case"
msgstr "compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case"

#. type: defun
#: strings.texi.orig:548
msgid ""
"This function compares a specified part of @var{string1} with a specified "
"part of @var{string2}.  The specified part of @var{string1} runs from index "
"@var{start1} (inclusive) up to index @var{end1} (exclusive); @code{nil} for "
"@var{start1} means the start of the string, while @code{nil} for @var{end1} "
"means the length of the string.  Likewise, the specified part of "
"@var{string2} runs from index @var{start2} up to index @var{end2}."
msgstr "この関数は、@var{string1}の指定された部分を、@var{string2}の指定された部分と比較します。@var{string1}の指定された部分とは、インデックス@var{start1}(その文字を含む)から、インデックス@var{end1}(その文字を含まない)までです。@var{start1}に@code{nil}を指定すると文字列の最初という意味になり、@var{end1}に@code{nil}を指定すると文字列の長さを意味します同様に、@var{string2}の指定された部分とは、インデックス@var{start2}からインデックス@var{end2}までです。"

#. type: defun
#: strings.texi.orig:557
msgid ""
"The strings are compared by the numeric values of their characters.  For "
"instance, @var{str1} is considered ``smaller than'' @var{str2} if its first "
"differing character has a smaller numeric value.  If @var{ignore-case} is "
"non-@code{nil}, characters are converted to lower-case before comparing "
"them.  Unibyte strings are converted to multibyte for comparison "
"(@pxref{Text Representations}), so that a unibyte string and its conversion "
"to multibyte are always regarded as equal."
msgstr "文字列は、文字列内の文字の数値により比較されます。たとえば、@var{str1}と@var{str2}は、最初に異なる文字で@var{str1}の文字の数値が小さいときに、``小さい''と判断されます。@var{ignore-case}が非@code{nil}の場合、文字は比較を行なう前に小文字に変換されます。比較のためにユニバイト文字列はマルチバイト文字列に変換されるので(@ref{Text Representations}を参照してください)、ユニバイト文字列と、それを変換したマルチバイト文字列は、常に等しくなります。"

#. type: defun
#: strings.texi.orig:564
msgid ""
"If the specified portions of the two strings match, the value is @code{t}.  "
"Otherwise, the value is an integer which indicates how many leading "
"characters agree, and which string is less.  Its absolute value is one plus "
"the number of characters that agree at the beginning of the two strings.  "
"The sign is negative if @var{string1} (or its specified portion) is less."
msgstr "2つの文字列の指定された部分がマッチした場合、値は@code{t}になります。それ以外では、値は整数で、これは何文字が一致して、どちらの文字が小さいかを示します。この値の絶対値は、2つの文字列の先頭から一致した文字数に1加えた値になります。@var{string1}(または指定された部分)のほうが小さい場合、符号は負になります。"

#. type: defun
#: strings.texi.orig:566
#, no-wrap
msgid "assoc-string key alist &optional case-fold"
msgstr "assoc-string key alist &optional case-fold"

#. type: defun
#: strings.texi.orig:575
msgid ""
"This function works like @code{assoc}, except that @var{key} must be a "
"string or symbol, and comparison is done using @code{compare-strings}.  "
"Symbols are converted to strings before testing.  If @var{case-fold} is "
"non-@code{nil}, it ignores case differences.  Unlike @code{assoc}, this "
"function can also match elements of the alist that are strings or symbols "
"rather than conses.  In particular, @var{alist} can be a list of strings or "
"symbols rather than an actual alist.  @xref{Association Lists}."
msgstr "この関数は@code{assoc}と同様に機能しますが、@var{key}は文字列かシンボルでなければならず、比較は@code{compare-strings}を使用して行なわれます。テストする前にシンボルは文字列に変換されます。@var{case-fold}が非@code{nil}の場合、大文字小文字の違いは無視されます。@code{assoc}とは異なり、この関数はコンスではない文字列またはシンボルのalist要素もマッチできます。特に、@var{alist}は実際のalistではなく、文字列またはリストでも可能です。@ref{Association Lists}を参照してください。"

#. type: Plain text
#: strings.texi.orig:582
msgid ""
"See also the function @code{compare-buffer-substrings} in @ref{Comparing "
"Text}, for a way to compare text in buffers.  The function "
"@code{string-match}, which matches a regular expression against a string, "
"can be used for a kind of string comparison; see @ref{Regexp Search}."
msgstr "バッファー内のテキストを比較する方法として、@ref{Comparing Text}の関数@code{compare-buffer-substrings}も参照してください。文字列にたいして正規表現のマッチを行なう関数@code{string-match}も、ある種の文字列比較に使用することができます。@ref{Regexp Search}を参照してください。"

#. type: section
#: strings.texi.orig:584
#, no-wrap
msgid "Conversion of Characters and Strings"
msgstr "Conversion of Characters and Strings"

#. type: cindex
#: strings.texi.orig:585
#, no-wrap
msgid "conversion of strings"
msgstr "conversion of strings"

#. type: Plain text
#: strings.texi.orig:595
msgid ""
"This section describes functions for converting between characters, strings "
"and integers.  @code{format} (@pxref{Formatting Strings}) and "
"@code{prin1-to-string} (@pxref{Output Functions}) can also convert Lisp "
"objects into strings.  @code{read-from-string} (@pxref{Input Functions}) can "
"``convert'' a string representation of a Lisp object into an object.  The "
"functions @code{string-to-multibyte} and @code{string-to-unibyte} convert "
"the text representation of a string (@pxref{Converting Representations})."
msgstr "このセクションでは文字、文字列、整数の間で変換を行なう関数を説明します。@code{format} (@ref{Formatting Strings}を参照してください)、および@code{prin1-to-string} (@ref{Output Functions}を参照してください)も、Lispオブジェクトを文字列に変換できます。@code{read-from-string} (@ref{Input Functions}を参照してください)は、Lispオブジェクトの文字列表現を、オブジェクトに``変換''できます。関数@code{string-to-multibyte}および@code{string-to-unibyte}は、テキスト表現を文字列に変換します(@ref{Converting Representations}を参照してください)。"

#. type: Plain text
#: strings.texi.orig:600
msgid ""
"@xref{Documentation}, for functions that produce textual descriptions of "
"text characters and general input events (@code{single-key-description} and "
"@code{text-char-description}).  These are used primarily for making help "
"messages."
msgstr "テキスト文字と一般的なインプットイベントにたいするテキスト説明を生成する関数(@code{single-key-description}および@code{text-char-description})については、@ref{Documentation}を参照してください。これらの関数は主にヘルプメッセージを作成するために使用されます。"

#. type: defun
#: strings.texi.orig:601
#, no-wrap
msgid "number-to-string number"
msgstr "number-to-string number"

#. type: cindex
#: strings.texi.orig:602
#, no-wrap
msgid "integer to string"
msgstr "integer to string"

#. type: cindex
#: strings.texi.orig:603
#, no-wrap
msgid "integer to decimal"
msgstr "integer to decimal"

#. type: defun
#: strings.texi.orig:607
msgid ""
"This function returns a string consisting of the printed base-ten "
"representation of @var{number}.  The returned value starts with a minus sign "
"if the argument is negative."
msgstr "この関数は@var{number}の10進プリント表現からなる文字列をreturnします。引数が負の場合、return値はマイナス記号から開始されます。"

#. type: example
#: strings.texi.orig:611
#, no-wrap
msgid ""
"(number-to-string 256)\n"
"     @result{} \"256\"\n"
msgstr ""
"(number-to-string 256)\n"
"     @result{} \"256\"\n"

#. type: group
#: strings.texi.orig:614
#, no-wrap
msgid ""
"(number-to-string -23)\n"
"     @result{} \"-23\"\n"
msgstr ""
"(number-to-string -23)\n"
"     @result{} \"-23\"\n"

#. type: example
#: strings.texi.orig:617
#, no-wrap
msgid ""
"(number-to-string -23.5)\n"
"     @result{} \"-23.5\"\n"
msgstr ""
"(number-to-string -23.5)\n"
"     @result{} \"-23.5\"\n"

#. type: cindex
#: strings.texi.orig:619
#, no-wrap
msgid "int-to-string"
msgstr "int-to-string"

#. type: defun
#: strings.texi.orig:621
msgid "@code{int-to-string} is a semi-obsolete alias for this function."
msgstr "@code{int-to-string}は、この関数にたいする半ば廃れた(semi-obsolete)エイリアスです。"

#. type: defun
#: strings.texi.orig:623
msgid "See also the function @code{format} in @ref{Formatting Strings}."
msgstr "@ref{Formatting Strings}の関数@code{format}も参照してください。"

#. type: defun
#: strings.texi.orig:625
#, no-wrap
msgid "string-to-number string &optional base"
msgstr "string-to-number string &optional base"

#. type: cindex
#: strings.texi.orig:626
#, no-wrap
msgid "string to number"
msgstr "string to number"

#. type: defun
#: strings.texi.orig:636
msgid ""
"This function returns the numeric value of the characters in @var{string}.  "
"If @var{base} is non-@code{nil}, it must be an integer between 2 and 16 "
"(inclusive), and integers are converted in that base.  If @var{base} is "
"@code{nil}, then base ten is used.  Floating-point conversion only works in "
"base ten; we have not implemented other radices for floating-point numbers, "
"because that would be much more work and does not seem useful.  If "
"@var{string} looks like an integer but its value is too large to fit into a "
"Lisp integer, @code{string-to-number} returns a floating-point result."
msgstr "この関数は@var{string}内の文字の数値的な値をreturnします。@var{base}が非@code{nil}の場合、値は2以上16以下でなければならず、整数はその基数に変換されます。@var{base}が@code{nil}の場合、基数に10が使用されます。浮動少数の変換は基数が10のときだけ機能します。わたしたちは浮動小数点数にたいして他の基数を実装していません。なえならこれには多くの作業が必要で、その割にその機能が有用には思えないからです。@var{string}が整数のように見えるが、その値がLispの整数に収まらないほど大きな値の場合、@code{string-to-number}は浮動小数の結果をreturnします。"

#. type: defun
#: strings.texi.orig:642
msgid ""
"The parsing skips spaces and tabs at the beginning of @var{string}, then "
"reads as much of @var{string} as it can interpret as a number in the given "
"base.  (On some systems it ignores other whitespace at the beginning, not "
"just spaces and tabs.)  If @var{string} cannot be interpreted as a number, "
"this function returns 0."
msgstr "解析では@var{string}の先頭にあるスペースとタブはスキップして、それから与えられた基数で数字として解釈できるところまで@var{string}を読み取ります(スペースとタブだけではなく、先頭にある他の空白文字を無視するシステムもあります)。@var{string}を数字として解釈できない場合、この関数は0をreturnします。"

#. type: example
#: strings.texi.orig:654
#, no-wrap
msgid ""
"(string-to-number \"256\")\n"
"     @result{} 256\n"
"(string-to-number \"25 is a perfect square.\")\n"
"     @result{} 25\n"
"(string-to-number \"X256\")\n"
"     @result{} 0\n"
"(string-to-number \"-4.5\")\n"
"     @result{} -4.5\n"
"(string-to-number \"1e5\")\n"
"     @result{} 100000.0\n"
msgstr ""
"(string-to-number \"256\")\n"
"     @result{} 256\n"
"(string-to-number \"25 is a perfect square.\")\n"
"     @result{} 25\n"
"(string-to-number \"X256\")\n"
"     @result{} 0\n"
"(string-to-number \"-4.5\")\n"
"     @result{} -4.5\n"
"(string-to-number \"1e5\")\n"
"     @result{} 100000.0\n"

#. type: findex
#: strings.texi.orig:656
#, no-wrap
msgid "string-to-int"
msgstr "string-to-int"

#. type: defun
#: strings.texi.orig:658
msgid "@code{string-to-int} is an obsolete alias for this function."
msgstr "@code{string-to-int}は、この関数にたいする半ば廃れたエイリアスです。"

#. type: defun
#: strings.texi.orig:660
#, no-wrap
msgid "char-to-string character"
msgstr "char-to-string character"

#. type: cindex
#: strings.texi.orig:661
#, no-wrap
msgid "character to string"
msgstr "character to string"

#. type: defun
#: strings.texi.orig:665
msgid ""
"This function returns a new string containing one character, "
"@var{character}.  This function is semi-obsolete because the function "
"@code{string} is more general.  @xref{Creating Strings}."
msgstr "この関数は、1つの文字@var{character}を含む新しい文字列をreturnします。関数@code{string}のほうがより一般的なので、この関数は半ば廃れています。@ref{Creating Strings}を参照してください。"

#. type: defun
#: strings.texi.orig:667
#, no-wrap
msgid "string-to-char string"
msgstr "string-to-char string"

#. type: defun
#: strings.texi.orig:674
msgid ""
"This function returns the first character in @var{string}.  This mostly "
"identical to @code{(aref string 0)}, except that it returns 0 if the string "
"is empty.  (The value is also 0 when the first character of @var{string} is "
"the null character, @acronym{ASCII} code 0.)  This function may be "
"eliminated in the future if it does not seem useful enough to retain."
msgstr "この関数は、@var{string}の最初の文字をreturnします。これはほとんど@code{(aref string 0)}と同じで、例外は文字列が空のときに0をreturnすることです(文字列の最初の文字が@acronym{ASCII}コード0のヌル文字のときも、0をreturnします)。この関数は、残すのに充分なほど有用と思えない場合、将来削除されるかもしれません。"

#. type: Plain text
#: strings.texi.orig:677
msgid "Here are some other functions that can convert to or from a string:"
msgstr "以下は、文字列へ／からの変換に使用できる、その他の関数です:"

#. type: item
#: strings.texi.orig:679
#, no-wrap
msgid "concat"
msgstr "concat"

#. type: table
#: strings.texi.orig:682
msgid ""
"This function converts a vector or a list into a string.  @xref{Creating "
"Strings}."
msgstr "この関数はベクターまたはリストから文字列に変換します。@ref{Creating Strings}を参照してください。"

#. type: item
#: strings.texi.orig:683
#, no-wrap
msgid "vconcat"
msgstr "vconcat"

#. type: table
#: strings.texi.orig:686
msgid "This function converts a string into a vector.  @xref{Vector Functions}."
msgstr "この関数は文字列をベクターに変換します。@ref{Vector Functions}を参照してください。"

#. type: item
#: strings.texi.orig:687
#, no-wrap
msgid "append"
msgstr "append"

#. type: table
#: strings.texi.orig:689
msgid "This function converts a string into a list.  @xref{Building Lists}."
msgstr "この関数は文字列をリストに変換します。@ref{Building Lists}を参照してください。"

#. type: item
#: strings.texi.orig:690
#, no-wrap
msgid "byte-to-string"
msgstr "byte-to-string"

#. type: table
#: strings.texi.orig:693
msgid ""
"This function converts a byte of character data into a unibyte string.  "
"@xref{Converting Representations}."
msgstr "この関数は文字データのバイトをユニバイト文字列に変換します。@ref{Converting Representations}を参照してください。"

#. type: cindex
#: strings.texi.orig:697
#, no-wrap
msgid "formatting strings"
msgstr "formatting strings"

#. type: cindex
#: strings.texi.orig:698
#, no-wrap
msgid "strings, formatting them"
msgstr "strings, formatting them"

#. type: Plain text
#: strings.texi.orig:704
msgid ""
"@dfn{Formatting} means constructing a string by substituting computed values "
"at various places in a constant string.  This constant string controls how "
"the other values are printed, as well as where they appear; it is called a "
"@dfn{format string}."
msgstr "@dfn{フォーマット(formatting)}とは、定数文字列内のなまざまな場所を、計算された値で置き換えることにより、文字列を構築することを意味します。この定数文字列は、他の値がプリントされる方法、同様にどこに表示するかを制御します。これは@dfn{フォーマット文字列(format string)}と呼ばれます。"

#. type: Plain text
#: strings.texi.orig:709
msgid ""
"Formatting is often useful for computing messages to be displayed.  In fact, "
"the functions @code{message} and @code{error} provide the same formatting "
"feature described here; they differ from @code{format} only in how they use "
"the result of formatting."
msgstr "フォーマットは、表示されるメッセージを計算するために便利なことがしばしばあります。実際に、関数@code{message}および@code{error}は、ここで説明する機能と同じフォーマットを提供します。これらの関数と@code{format}の違いは、フォーマットされた結果を使用する方法だけです。"

#. type: defun
#: strings.texi.orig:710
#, no-wrap
msgid "format string &rest objects"
msgstr "format string &rest objects"

#. type: defun
#: strings.texi.orig:715
msgid ""
"This function returns a new string that is made by copying @var{string} and "
"then replacing any format specification in the copy with encodings of the "
"corresponding @var{objects}.  The arguments @var{objects} are the computed "
"values to be formatted."
msgstr "この関数は、@var{string}をコピーしてから、対応する@var{objects}をエンコードする、コピー内の任意のフォーマット指定(format specification)を置換することにより作成される、新しい文字列をreturnします。引数@var{objects}は、フォーマットされる計算された値です。"

#. type: defun
#: strings.texi.orig:719
msgid ""
"The characters in @var{string}, other than the format specifications, are "
"copied directly into the output, including their text properties, if any."
msgstr "@var{string}内のフォーマット指定以外の文字は、(もしあれば)テキストプロパティーを含め、出力に直接コピーされます。"

#. type: cindex
#: strings.texi.orig:721
#, no-wrap
msgid "@samp{%} in format"
msgstr "@samp{%} in format"

#. type: cindex
#: strings.texi.orig:722
#, no-wrap
msgid "format specification"
msgstr "format specification"

#. type: Plain text
#: strings.texi.orig:728
msgid ""
"A format specification is a sequence of characters beginning with a "
"@samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the @code{format} "
"function replaces it with the printed representation of one of the values to "
"be formatted (one of the arguments @var{objects}).  For example:"
msgstr "フォーマット指定は、@samp{%}で始まる文字シーケンスです。したがって@var{string}内に@samp{%d}があれば、@code{format}はそれを、フォーマットされる値の1つ(引数@var{objects}のうちの1つ)にたいするプリント表現で置き換えます。たとえば:"

#. type: group
#: strings.texi.orig:733
#, no-wrap
msgid ""
"(format \"The value of fill-column is %d.\" fill-column)\n"
"     @result{} \"The value of fill-column is 72.\"\n"
msgstr ""
"(format \"The value of fill-column is %d.\" fill-column)\n"
"     @result{} \"The value of fill-column is 72.\"\n"

#. type: Plain text
#: strings.texi.orig:742
msgid ""
"Since @code{format} interprets @samp{%} characters as format specifications, "
"you should @emph{never} pass an arbitrary string as the first argument.  "
"This is particularly true when the string is generated by some Lisp code.  "
"Unless the string is @emph{known} to never include any @samp{%} characters, "
"pass @code{\"%s\"}, described below, as the first argument, and the string "
"as the second, like this:"
msgstr "@code{format}は文字@samp{%}をフォーマット指定と解釈するので、@emph{決して}最初の引数に不定な文字列(arbitrary string)を渡すべきではありません。これは特に何らかのLispコードにより生成された文字列の場合に当てはまります。その文字列が決して文字@samp{%}を含まないと@emph{確信}できないときは、以下で説明するように最初の引数に@code{\"%s\"}を渡して、不定な文字列を2番目の引数として渡します:"

#. type: example
#: strings.texi.orig:745
#, no-wrap
msgid "  (format \"%s\" @var{arbitrary-string})\n"
msgstr "  (format \"%s\" @var{arbitrary-string})\n"

#. type: Plain text
#: strings.texi.orig:754
msgid ""
"If @var{string} contains more than one format specification, the format "
"specifications correspond to successive values from @var{objects}.  Thus, "
"the first format specification in @var{string} uses the first such value, "
"the second format specification uses the second such value, and so on.  Any "
"extra format specifications (those for which there are no corresponding "
"values) cause an error.  Any extra values to be formatted are ignored."
msgstr "@var{string}に複数のフォーマット指定が含まれる場合、フォーマット指定は@var{objects}から連続して値を引き当てます。つまり、@var{string}内の1番目のフォーマット指定は1番目の値、2番目のフォーマット指定は2番目の値、...を使用します。余分なフォーマット指定(対応する値がない場合)は、エラーとなります。フォーマットされる値が余分にある場合は、無視されます。"

#. type: Plain text
#: strings.texi.orig:758
msgid ""
"Certain format specifications require values of particular types.  If you "
"supply a value that doesn't fit the requirements, an error is signaled."
msgstr "ある種のフォーマット指定は、特定の型の値を要求します。その要求に適合しない値を与えた場合、エラーがシグナルされます。"

#. type: Plain text
#: strings.texi.orig:760
msgid "Here is a table of valid format specifications:"
msgstr "以下は有効なフォーマット指定の表です:"

#. type: item
#: strings.texi.orig:762
#, no-wrap
msgid "%s"
msgstr "%s"

#. type: table
#: strings.texi.orig:768
msgid ""
"Replace the specification with the printed representation of the object, "
"made without quoting (that is, using @code{princ}, not "
"@code{prin1}---@pxref{Output Functions}).  Thus, strings are represented by "
"their contents alone, with no @samp{\"} characters, and symbols appear "
"without @samp{\\} characters."
msgstr "フォーマット指定を、クォートなし(つまり@code{prin1}ではなく@code{princ}を使用して。@ref{Output Functions}を参照してください)の、オブジェクトのプリント表現で置き換えます。したがって、文字列は@samp{\"}文字なしの、文字列内容だけが表示され、シンボルは@samp{\\}文字なしで表されます。"

#. type: table
#: strings.texi.orig:772
msgid ""
"If the object is a string, its text properties are copied into the output.  "
"The text properties of the @samp{%s} itself are also copied, but those of "
"the object take priority."
msgstr "オブジェクトが文字列の場合、文字列のプロパティーは出力にコピーされます。@samp{%s}のテキストプロパティー自身もコピーされますが、オブジェクトのテキストプロパティーが優先されます。"

#. type: item
#: strings.texi.orig:773
#, no-wrap
msgid "%S"
msgstr "%S"

#. type: table
#: strings.texi.orig:778
msgid ""
"Replace the specification with the printed representation of the object, "
"made with quoting (that is, using @code{prin1}---@pxref{Output Functions}).  "
"Thus, strings are enclosed in @samp{\"} characters, and @samp{\\} characters "
"appear where necessary before special characters."
msgstr "フォーマット指定を、クォートあり(つまり@code{prin1}を使用して。@ref{Output Functions}を参照してください)の、オブジェクトのプリント表現で置き換えます。したがって、文字列は@samp{\"}文字で囲まれ、必要となる特別文字の前に@samp{\\}文字が表示されます。"

#. type: item
#: strings.texi.orig:779
#, no-wrap
msgid "%o"
msgstr "%o"

#. type: cindex
#: strings.texi.orig:780
#, no-wrap
msgid "integer to octal"
msgstr "integer to octal"

#. type: table
#: strings.texi.orig:783
msgid "Replace the specification with the base-eight representation of an integer."
msgstr "フォーマット指定を8進表現の整数で置き換えます。"

#. type: item
#: strings.texi.orig:784
#, no-wrap
msgid "%d"
msgstr "%d"

#. type: table
#: strings.texi.orig:787
msgid "Replace the specification with the base-ten representation of an integer."
msgstr "フォーマット指定を10進表現の整数で置き換えます。"

#. type: item
#: strings.texi.orig:788
#, no-wrap
msgid "%x"
msgstr "%x"

#. type: itemx
#: strings.texi.orig:789
#, no-wrap
msgid "%X"
msgstr "%X"

#. type: cindex
#: strings.texi.orig:790
#, no-wrap
msgid "integer to hexadecimal"
msgstr "integer to hexadecimal"

#. type: table
#: strings.texi.orig:793
msgid ""
"Replace the specification with the base-sixteen representation of an "
"integer.  @samp{%x} uses lower case and @samp{%X} uses upper case."
msgstr "フォーマット指定を16進表現の整数で置き換えます。@samp{%x}の場合は小文字、@samp{%X}の場合は大文字が使用されます。"

#. type: item
#: strings.texi.orig:794
#, no-wrap
msgid "%c"
msgstr "%c"

#. type: table
#: strings.texi.orig:796
msgid "Replace the specification with the character which is the value given."
msgstr "フォーマット指定を、与えられた値の文字で置き換えます。"

#. type: item
#: strings.texi.orig:797
#, no-wrap
msgid "%e"
msgstr "%e"

#. type: table
#: strings.texi.orig:800
msgid ""
"Replace the specification with the exponential notation for a floating-point "
"number."
msgstr "フォーマット指定を、浮動小数点数の指数表現で置き換えます。"

#. type: item
#: strings.texi.orig:801
#, no-wrap
msgid "%f"
msgstr "%f"

#. type: table
#: strings.texi.orig:804
msgid ""
"Replace the specification with the decimal-point notation for a "
"floating-point number."
msgstr "フォーマット指定を、浮動小数点数にたいする10進少数表記で置き換えます。"

#. type: item
#: strings.texi.orig:805
#, no-wrap
msgid "%g"
msgstr "%g"

#. type: table
#: strings.texi.orig:809
msgid ""
"Replace the specification with notation for a floating-point number, using "
"either exponential notation or decimal-point notation, whichever is shorter."
msgstr "フォーマット指定を、指数または10進少数のどちらか短いほうの表記を使用した浮動小数点数で置き換えます。"

#. type: item
#: strings.texi.orig:810
#, no-wrap
msgid "%%"
msgstr "%%"

#. type: table
#: strings.texi.orig:814
msgid ""
"Replace the specification with a single @samp{%}.  This format specification "
"is unusual in that it does not use a value.  For example, @code{(format \"%% "
"%d\" 30)} returns @code{\"% 30\"}."
msgstr "フォーマット指定を1つの@samp{%}で置き換えます。このフォーマット指定は、値を使用しません。たとえば、@code{(format \"%% %d\" 30)}は@code{\"% 30\"}をreturnします。"

#. type: Plain text
#: strings.texi.orig:818
msgid ""
"Any other format character results in an @samp{Invalid format operation} "
"error."
msgstr "他のフォーマット文字は、@samp{Invalid format operation}エラーになります。"

#. type: Plain text
#: strings.texi.orig:820
msgid "Here are several examples:"
msgstr "以下にいくつかの例を示します:"

#. type: group
#: strings.texi.orig:825
#, no-wrap
msgid ""
"(format \"The name of this buffer is %s.\" (buffer-name))\n"
"     @result{} \"The name of this buffer is strings.texi.\"\n"
"\n"
msgstr ""
"(format \"The name of this buffer is %s.\" (buffer-name))\n"
"     @result{} \"The name of this buffer is strings.texi.\"\n"
"\n"

#. type: group
#: strings.texi.orig:828
#, no-wrap
msgid ""
"(format \"The buffer object prints as %s.\" (current-buffer))\n"
"     @result{} \"The buffer object prints as strings.texi.\"\n"
"\n"
msgstr ""
"(format \"The buffer object prints as %s.\" (current-buffer))\n"
"     @result{} \"The buffer object prints as strings.texi.\"\n"
"\n"

#. type: group
#: strings.texi.orig:833
#, no-wrap
msgid ""
"(format \"The octal value of %d is %o,\n"
"         and the hex value is %x.\" 18 18 18)\n"
"     @result{} \"The octal value of 18 is 22,\n"
"         and the hex value is 12.\"\n"
msgstr ""
"(format \"The octal value of %d is %o,\n"
"         and the hex value is %x.\" 18 18 18)\n"
"     @result{} \"The octal value of 18 is 22,\n"
"         and the hex value is 12.\"\n"

#. type: cindex
#: strings.texi.orig:836
#, no-wrap
msgid "field width"
msgstr "field width"

#. type: cindex
#: strings.texi.orig:837
#, no-wrap
msgid "padding"
msgstr "padding"

#. type: Plain text
#: strings.texi.orig:844
msgid ""
"A specification can have a @dfn{width}, which is a decimal number between "
"the @samp{%} and the specification character.  If the printed representation "
"of the object contains fewer characters than this width, @code{format} "
"extends it with padding.  The width specifier is ignored for the @samp{%%} "
"specification.  Any padding introduced by the width specifier normally "
"consists of spaces inserted on the left:"
msgstr "フォーマット指定は@dfn{フィールド幅(width)}をもつことができ、これは@samp{%}とフォーマット指定文字(specification character)の間の10進の数字です。そのオブジェクトのプリント表現が、このフィールド幅より少ない文字で構成される場合、@code{format}はパディングしてフィールド幅に拡張します。フォーマット指定@samp{%%}では、フィールド幅の指定は無視されます。シールド幅指定により行なわれるパディングは通常、左側にスペースを挿入します。"

#. type: example
#: strings.texi.orig:848
#, no-wrap
msgid ""
"(format \"%5d is padded on the left with spaces\" 123)\n"
"     @result{} \"  123 is padded on the left with spaces\"\n"
msgstr ""
"(format \"%5d is padded on the left with spaces\" 123)\n"
"     @result{} \"  123 is padded on the left with spaces\"\n"

#. type: Plain text
#: strings.texi.orig:859
msgid ""
"If the width is too small, @code{format} does not truncate the object's "
"printed representation.  Thus, you can use a width to specify a minimum "
"spacing between columns with no risk of losing information.  In the "
"following three examples, @samp{%7s} specifies a minimum width of 7.  In the "
"first case, the string inserted in place of @samp{%7s} has only 3 letters, "
"and needs 4 blank spaces as padding.  In the second case, the string "
"@code{\"specification\"} is 13 letters wide but is not truncated."
msgstr "フィールド幅が小さすぎる場合でも、@code{format}はオブジェクトのプリント表現を切り詰めません。したがって、情報を失う危険を犯すことなく、フィールドの最小幅を指定することができます。以下の2つの例では、@samp{%7s}は最小幅に7を指定します。1番目の例では、@samp{%7s}に挿入される文字列は3文字だけなので、4つのブランクスペースによりパディングされます。2番目の例では、文字列@code{\"specification\"}は13文字ですが、切り詰めはされません。"

#. type: group
#: strings.texi.orig:868
#, no-wrap
msgid ""
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `    foo' has 3 letters in it.\"\n"
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"specification\" (length \"specification\"))\n"
"     @result{} \"The word `specification' has 13 letters in it.\"\n"
msgstr ""
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `    foo' has 3 letters in it.\"\n"
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"specification\" (length \"specification\"))\n"
"     @result{} \"The word `specification' has 13 letters in it.\"\n"

#. type: cindex
#: strings.texi.orig:871
#, no-wrap
msgid "flags in format specifications"
msgstr "flags in format specifications"

#. type: Plain text
#: strings.texi.orig:874
msgid ""
"Immediately after the @samp{%} and before the optional width specifier, you "
"can also put certain @dfn{flag characters}."
msgstr "@samp{%}の直後、オプションのフィールド幅指定の前に、@dfn{フラグ文字(flag characters)}を置くこともできます。"

#. type: Plain text
#: strings.texi.orig:882
msgid ""
"The flag @samp{+} inserts a plus sign before a positive number, so that it "
"always has a sign.  A space character as flag inserts a space before a "
"positive number.  (Otherwise, positive numbers start with the first digit.)  "
"These flags are useful for ensuring that positive numbers and negative "
"numbers use the same number of columns.  They are ignored except for "
"@samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}, and if both flags are used, "
"@samp{+} takes precedence."
msgstr "フラグ@samp{+}は、正数の前にプラス符号を挿入するので、数には常に符号がつきます。フラグとしてスペースを指定すると、正数の前に1つのスペースが挿入されます(それ以外は、正数は最初の数字から開始されます)。これらのフラグは、正数と負数が同じ列数を使用することを確実にするのに便利です。これらは@samp{%d}、@samp{%e}、@samp{%f}、@samp{%g}以外では無視され、両方が指定された場合は、@samp{+}が優先されます。"

#. type: Plain text
#: strings.texi.orig:889
msgid ""
"The flag @samp{#} specifies an ``alternate form'' which depends on the "
"format in use.  For @samp{%o}, it ensures that the result begins with a "
"@samp{0}.  For @samp{%x} and @samp{%X}, it prefixes the result with "
"@samp{0x} or @samp{0X}.  For @samp{%e}, @samp{%f}, and @samp{%g}, the "
"@samp{#} flag means include a decimal point even if the precision is zero."
msgstr "フラグ@samp{#}は``代替形式(alternate form)''を指定し。これは使用するフォーマットに依存します。@samp{%o}にたいしては、結果を@samp{0}で開始させます。@samp{%x}と@samp{%X}にたいしては、結果のプレフィクスは@samp{0x}または@samp{0X}になります。@samp{%e}、@samp{%f}、@samp{%g}にたいしては、@samp{#}フラグは、少数部が0のときも小数点が含まれることを意味します。"

#. type: Plain text
#: strings.texi.orig:895
msgid ""
"The flag @samp{0} ensures that the padding consists of @samp{0} characters "
"instead of spaces.  This flag is ignored for non-numerical specification "
"characters like @samp{%s}, @samp{%S} and @samp{%c}.  These specification "
"characters accept the @samp{0} flag, but still pad with @emph{spaces}."
msgstr "フラグ@samp{0}は、スペースの代わりに文字@samp{0}でパディングします。このフラグは@samp{%s}、@samp{%S}、@samp{%c}のような、非数値のフォーマット指定文字では無視されます。もれらのフォーマット指定文字で@samp{0}フラグを指定できますが、それでも@emph{スペース}でパディングされます。"

#. type: Plain text
#: strings.texi.orig:900
msgid ""
"The flag @samp{-} causes the padding inserted by the width specifier, if "
"any, to be inserted on the right rather than the left.  If both @samp{-} and "
"@samp{0} are present, the @samp{0} flag is ignored."
msgstr "フラグ@samp{-}はフィールド幅指定により挿入されるパディングに作用し、もしパディングがある場合、左側ではなく右側にパディングされます。@samp{-}と@samp{0}の両方が指定された場合、@samp{0}フラグは無視されます。"

#. type: group
#: strings.texi.orig:905
#, no-wrap
msgid ""
"(format \"%06d is padded on the left with zeros\" 123)\n"
"     @result{} \"000123 is padded on the left with zeros\"\n"
"\n"
msgstr ""
"(format \"%06d is padded on the left with zeros\" 123)\n"
"     @result{} \"000123 is padded on the left with zeros\"\n"
"\n"

#. type: group
#: strings.texi.orig:908
#, no-wrap
msgid ""
"(format \"%-6d is padded on the right\" 123)\n"
"     @result{} \"123    is padded on the right\"\n"
"\n"
msgstr ""
"(format \"%-6d is padded on the right\" 123)\n"
"     @result{} \"123    is padded on the right\"\n"
"\n"

#. type: group
#: strings.texi.orig:912
#, no-wrap
msgid ""
"(format \"The word `%-7s' actually has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `foo    ' actually has 3 letters in it.\"\n"
msgstr ""
"(format \"The word `%-7s' actually has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `foo    ' actually has 3 letters in it.\"\n"

#. type: cindex
#: strings.texi.orig:915
#, no-wrap
msgid "precision in format specifications"
msgstr "precision in format specifications"

#. type: Plain text
#: strings.texi.orig:926
msgid ""
"All the specification characters allow an optional @dfn{precision} before "
"the character (after the width, if present).  The precision is a "
"decimal-point @samp{.} followed by a digit-string.  For the floating-point "
"specifications (@samp{%e}, @samp{%f}, @samp{%g}), the precision specifies "
"how many decimal places to show; if zero, the decimal-point itself is also "
"omitted.  For @samp{%s} and @samp{%S}, the precision truncates the string to "
"the given width, so @samp{%.3s} shows only the first three characters of the "
"representation for @var{object}.  Precision has no effect for other "
"specification characters."
msgstr "すべてのフォーマット指定文字には、その文字の前(フィールド幅がある場合は、その後)に、オプションで@dfn{精度(precision)}を指定できます。精度は小数点@samp{.}と、その後に桁文字列(digit-string)を指定します。浮動少数のフォーマット指定(@samp{%e}、@samp{%f}、@samp{%g})では、精度は表示する小数点以下の桁数を指定します。0の場合は小数点も省略されます。@samp{%s}と@samp{%S}にたいしては、文字列を精度で指定された幅に切り詰めます。したがって@samp{%.3s}では、@var{object}にたいするプリント表現の最初の3文字だけが表示されます。他のフォーマット指定文字にたいしては、精度は効果がありません。"

#. type: section
#: strings.texi.orig:928
#, no-wrap
msgid "Case Conversion in Lisp"
msgstr "Case Conversion in Lisp"

#. type: cindex
#: strings.texi.orig:929
#, no-wrap
msgid "upper case"
msgstr "upper case"

#. type: cindex
#: strings.texi.orig:930
#, no-wrap
msgid "lower case"
msgstr "lower case"

#. type: cindex
#: strings.texi.orig:931
#, no-wrap
msgid "character case"
msgstr "character case"

#. type: cindex
#: strings.texi.orig:932
#, no-wrap
msgid "case conversion in Lisp"
msgstr "case conversion in Lisp"

#. type: Plain text
#: strings.texi.orig:940
msgid ""
"The character case functions change the case of single characters or of the "
"contents of strings.  The functions normally convert only alphabetic "
"characters (the letters @samp{A} through @samp{Z} and @samp{a} through "
"@samp{z}, as well as non-@acronym{ASCII} letters); other characters are not "
"altered.  You can specify a different case conversion mapping by specifying "
"a case table (@pxref{Case Tables})."
msgstr "大文字小文字変換関数(character case functions)は、1つの文字または文字列の内容の大文字小文字を変換します。関数は通常、アルファベット文字(英字@samp{A}から@samp{Z}と@samp{a}から@samp{z}、同様に非@acronym{ASCII}の英字)だけを変換し、それ以外の文字は変換しません。大文字小文字テーブル(case table。@ref{Case Tables}を参照してください)で指定することにより大文字小文字の変換に異なるマッピングを指定できます。"

#. type: Plain text
#: strings.texi.orig:943
msgid ""
"These functions do not modify the strings that are passed to them as "
"arguments."
msgstr "これらの関数は、引数として渡された文字列は変更しません。"

#. type: Plain text
#: strings.texi.orig:946
msgid ""
"The examples below use the characters @samp{X} and @samp{x} which have "
"@acronym{ASCII} codes 88 and 120 respectively."
msgstr "以下の例では文字@samp{X}と@samp{x}を使用し、これらの@acronym{ASCII}コードは88と120です。"

#. type: defun
#: strings.texi.orig:947
#, no-wrap
msgid "downcase string-or-char"
msgstr "downcase string-or-char"

#. type: defun
#: strings.texi.orig:950
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to lower case."
msgstr "この関数は、@var{string-or-char}(文字か文字列)を小文字に変換します。"

#. type: defun
#: strings.texi.orig:957
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is upper case is converted to lower "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding lower case character (an integer); if the original character "
"is lower case, or is not a letter, the return value is equal to the original "
"character."
msgstr "@var{string-or-char}が文字列の場合、この関数は引数の大文字を小文字に変換した、新しい文字列をreturnします。@var{string-or-char}が文字の場合、この関数は対応する小文字(正数)をreturnします。元の文字が小文字の場合、または英字でない場合、return値は元の文字と同じです。"

#. type: example
#: strings.texi.orig:961
#, no-wrap
msgid ""
"(downcase \"The cat in the hat\")\n"
"     @result{} \"the cat in the hat\"\n"
"\n"
msgstr ""
"(downcase \"The cat in the hat\")\n"
"     @result{} \"the cat in the hat\"\n"
"\n"

#. type: example
#: strings.texi.orig:964
#, no-wrap
msgid ""
"(downcase ?X)\n"
"     @result{} 120\n"
msgstr ""
"(downcase ?X)\n"
"     @result{} 120\n"

#. type: defun
#: strings.texi.orig:967
#, no-wrap
msgid "upcase string-or-char"
msgstr "upcase string-or-char"

#. type: defun
#: strings.texi.orig:970
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to upper case."
msgstr "この関数は、@var{string-or-char}(文字か文字列)を大文字に変換します。"

#. type: defun
#: strings.texi.orig:977
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is lower case is converted to upper "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding upper case character (an integer); if the original character "
"is upper case, or is not a letter, the return value is equal to the original "
"character."
msgstr "@var{string-or-char}が文字列の場合、この関数は引数の小文字を大文字に変換した、新しい文字列をreturnします。@var{string-or-char}が文字の場合、この関数は対応する大文字(正数)をreturnします。元の文字が大文字の場合、または英字でない場合、return値は元の文字と同じです。"

#. type: example
#: strings.texi.orig:981
#, no-wrap
msgid ""
"(upcase \"The cat in the hat\")\n"
"     @result{} \"THE CAT IN THE HAT\"\n"
"\n"
msgstr ""
"(upcase \"The cat in the hat\")\n"
"     @result{} \"THE CAT IN THE HAT\"\n"
"\n"

#. type: example
#: strings.texi.orig:984
#, no-wrap
msgid ""
"(upcase ?x)\n"
"     @result{} 88\n"
msgstr ""
"(upcase ?x)\n"
"     @result{} 88\n"

#. type: defun
#: strings.texi.orig:987
#, no-wrap
msgid "capitalize string-or-char"
msgstr "capitalize string-or-char"

#. type: cindex
#: strings.texi.orig:988
#, no-wrap
msgid "capitalization"
msgstr "capitalization"

#. type: defun
#: strings.texi.orig:995
msgid ""
"This function capitalizes strings or characters.  If @var{string-or-char} is "
"a string, the function returns a new string whose contents are a copy of "
"@var{string-or-char} in which each word has been capitalized.  This means "
"that the first character of each word is converted to upper case, and the "
"rest are converted to lower case."
msgstr "この関数は文字列または文字をキャピタライズ(capitalize: 先頭が大文字で残りは小文字)します。この関数は、@var{string-or-char}が文字列の場合、@var{string-or-char}の各単語がキャピタライズされた新しいコピーをreturnします。これは各単語の最初の文字が大文字に変換され、残りは小文字に変換されることを意味します。"

#. type: defun
#: strings.texi.orig:999 strings.texi.orig:1031
msgid ""
"The definition of a word is any sequence of consecutive characters that are "
"assigned to the word constituent syntax class in the current syntax table "
"(@pxref{Syntax Class Table})."
msgstr "単語の定義は、カレント構文テーブル(current syntax table)の単語構成構文クラス(word constituent syntax class)に割り当てられた、連続する文字の任意シーケンスです(@ref{Syntax Class Table}を参照してください)。"

#. type: defun
#: strings.texi.orig:1002
msgid ""
"When @var{string-or-char} is a character, this function does the same thing "
"as @code{upcase}."
msgstr "@var{string-or-char}が文字の場合、この関数は@code{upcase}と同じことを行ないます。"

#. type: group
#: strings.texi.orig:1007
#, no-wrap
msgid ""
"(capitalize \"The cat in the hat\")\n"
"     @result{} \"The Cat In The Hat\"\n"
msgstr ""
"(capitalize \"The cat in the hat\")\n"
"     @result{} \"The Cat In The Hat\"\n"

#. type: group
#: strings.texi.orig:1012
#, no-wrap
msgid ""
"(capitalize \"THE 77TH-HATTED CAT\")\n"
"     @result{} \"The 77th-Hatted Cat\"\n"
msgstr ""
"(capitalize \"THE 77TH-HATTED CAT\")\n"
"     @result{} \"The 77th-Hatted Cat\"\n"

#. type: group
#: strings.texi.orig:1017
#, no-wrap
msgid ""
"(capitalize ?x)\n"
"     @result{} 88\n"
msgstr ""
"(capitalize ?x)\n"
"     @result{} 88\n"

#. type: defun
#: strings.texi.orig:1021
#, no-wrap
msgid "upcase-initials string-or-char"
msgstr "upcase-initials string-or-char"

#. type: defun
#: strings.texi.orig:1027
msgid ""
"If @var{string-or-char} is a string, this function capitalizes the initials "
"of the words in @var{string-or-char}, without altering any letters other "
"than the initials.  It returns a new string whose contents are a copy of "
"@var{string-or-char}, in which each word has had its initial letter "
"converted to upper case."
msgstr "この関数は、@var{string-or-char}が文字列の場合、@var{string-or-char}の中の単語の頭文字をキャピタライズし、頭文字以外の文字は変更しません。この関数は、@var{string-or-char}の各単語の頭文字が大文字に変換された新しいコピーをreturnします。"

#. type: defun
#: strings.texi.orig:1034
msgid ""
"When the argument to @code{upcase-initials} is a character, "
"@code{upcase-initials} has the same result as @code{upcase}."
msgstr "@code{upcase-initials}の引数が文字の場合、@code{upcase-initials}の結果は@code{upcase}と同じになります。"

#. type: group
#: strings.texi.orig:1039
#, no-wrap
msgid ""
"(upcase-initials \"The CAT in the hAt\")\n"
"     @result{} \"The CAT In The HAt\"\n"
msgstr ""
"(upcase-initials \"The CAT in the hAt\")\n"
"     @result{} \"The CAT In The HAt\"\n"

#. type: Plain text
#: strings.texi.orig:1045
msgid ""
"@xref{Text Comparison}, for functions that compare strings; some of them "
"ignore case differences, or can optionally ignore case differences."
msgstr "文字列を比較する関数(大文字小文字の違いを無視するものや、オプションで大文字小文字の違いを無視できるもの)については、@ref{Text Comparison}を参照してください。"

#. type: section
#: strings.texi.orig:1047
#, no-wrap
msgid "The Case Table"
msgstr "The Case Table"

#. type: Plain text
#: strings.texi.orig:1056
msgid ""
"You can customize case conversion by installing a special @dfn{case table}.  "
"A case table specifies the mapping between upper case and lower case "
"letters.  It affects both the case conversion functions for Lisp objects "
"(see the previous section) and those that apply to text in the buffer "
"(@pxref{Case Changes}).  Each buffer has a case table; there is also a "
"standard case table which is used to initialize the case table of new "
"buffers."
msgstr "特別な@dfn{大文字小文字テーブル(case table)}をインストールすることにより、大文字小文字の変換をカスタマイズできます。大文字小文字テーブルは大文字と小文字の間のマッピングを指定します。大文字小文字テーブルはLispオブジェクトにたいする大文字小文字変換関数(前のセクションを参照してください)と、バッファー内のテキストに適用される関数の両方に影響します。それぞれのバッファーには大文字小文字テーブルがあります。新しいバッファーの大文字小文字テーブルを初期化するために使用される、標準の大文字小文字テーブル(standard case table)もあります。"

#. type: Plain text
#: strings.texi.orig:1061
msgid ""
"A case table is a char-table (@pxref{Char-Tables}) whose subtype is "
"@code{case-table}.  This char-table maps each character into the "
"corresponding lower case character.  It has three extra slots, which hold "
"related tables:"
msgstr "大文字小文字テーブルは、サブタイプが@code{case-table}の文字テーブル(char-table。@ref{Char-Tables}を参照してください)です。この文字テーブルは、それぞれの文字を対応する小文字にマップします。大文字小文字テーブルは、関連するテーブルを保持する、3つの追加スロットをもちます:"

#. type: item
#: strings.texi.orig:1063
#, no-wrap
msgid "upcase"
msgstr "upcase"

#. type: table
#: strings.texi.orig:1066
msgid ""
"The upcase table maps each character into the corresponding upper case "
"character."
msgstr "upcase(大文字)テーブルは、それぞれの文字を対応する大文字にマップします。"

#. type: item
#: strings.texi.orig:1066
#, no-wrap
msgid "canonicalize"
msgstr "canonicalize"

#. type: table
#: strings.texi.orig:1069
msgid ""
"The canonicalize table maps all of a set of case-related characters into a "
"particular member of that set."
msgstr "canonicalize(正準化)テーブルは、大文字小文字に関連する文字セットのすべてを、その文字セットの特別なメンバーにマップします。"

#. type: item
#: strings.texi.orig:1069
#, no-wrap
msgid "equivalences"
msgstr "equivalences"

#. type: table
#: strings.texi.orig:1072
msgid ""
"The equivalences table maps each one of a set of case-related characters "
"into the next character in that set."
msgstr "equivalence(同値)テーブルは、大の字小文字に関連した文字セットのそれぞれを、そのセットの次の文字にマップします。"

#. type: Plain text
#: strings.texi.orig:1076
msgid ""
"In simple cases, all you need to specify is the mapping to lower-case; the "
"three related tables will be calculated automatically from that one."
msgstr "単純な例では、小文字へのマッピングを指定することだけが必要です。3つの関連するテーブルは、このマッピングから自動的に計算されます。"

#. type: Plain text
#: strings.texi.orig:1081
msgid ""
"For some languages, upper and lower case letters are not in one-to-one "
"correspondence.  There may be two different lower case letters with the same "
"upper case equivalent.  In these cases, you need to specify the maps for "
"both lower case and upper case."
msgstr "大文字と小文字が1対1で対応しない言語もいくつかあります。これらの言語では、2つの異なる小文字が、同じ大文字にマップされます。このような場合、大文字と小文字の両方にたいするマップを指定する必要があります。"

#. type: Plain text
#: strings.texi.orig:1088
msgid ""
"The extra table @var{canonicalize} maps each character to a canonical "
"equivalent; any two characters that are related by case-conversion have the "
"same canonical equivalent character.  For example, since @samp{a} and "
"@samp{A} are related by case-conversion, they should have the same canonical "
"equivalent character (which should be either @samp{a} for both of them, or "
"@samp{A} for both of them)."
msgstr "追加の@var{canonicalize}テーブルは、それぞれの文字を、正準化された等価文字にマップします。大文字小文字に関連する任意の2文字は、同じ正準等価文字(canonical equivalent character)をもちます。たとえば@samp{a}と@samp{A}は大文字小文字変換に関係があるので、これらの文字は同じ正準等価文字(両方の文字が@samp{a}、または両方の文字が@samp{A})をもつべきです。"

#. type: Plain text
#: strings.texi.orig:1094
msgid ""
"The extra table @var{equivalences} is a map that cyclically permutes each "
"equivalence class (of characters with the same canonical equivalent).  (For "
"ordinary @acronym{ASCII}, this would map @samp{a} into @samp{A} and @samp{A} "
"into @samp{a}, and likewise for each set of equivalent characters.)"
msgstr "追加の@var{equivalences}テーブルは、各等価クラスの文字(同じ正準等価文字をもつ文字)を循環的にマップします(通常の@acronym{ASCII}では、これは@samp{a}を@samp{A}に@samp{A}を@samp{a}にマップし、他の等価文字セットにたいしても同様にマップします)。"

#. type: Plain text
#: strings.texi.orig:1102
msgid ""
"When constructing a case table, you can provide @code{nil} for "
"@var{canonicalize}; then Emacs fills in this slot from the lower case and "
"upper case mappings.  You can also provide @code{nil} for "
"@var{equivalences}; then Emacs fills in this slot from @var{canonicalize}.  "
"In a case table that is actually in use, those components are "
"non-@code{nil}.  Do not try to specify @var{equivalences} without also "
"specifying @var{canonicalize}."
msgstr "大文字小文字テーブルを構築する際は、@var{canonicalize}に@code{nil}を指定できます。この場合、Emacsは大文字と小文字のマッピングで、このスロットを充填します。@var{equivalences}にたいして@code{nil}を指定することもできます。この場合、Emacsは@var{canonicalize}から、このスロットを充填します。実際に使用される大文字小文字テーブルでは、これらのコンポーネントは非@code{nil}です。@var{canonicalize}を指定せずに@var{equivalences}を指定しないでください。"

#. type: Plain text
#: strings.texi.orig:1104
msgid "Here are the functions for working with case tables:"
msgstr "以下は大文字小文字テーブルに作用する関数です:"

#. type: defun
#: strings.texi.orig:1105
#, no-wrap
msgid "case-table-p object"
msgstr "case-table-p object"

#. type: defun
#: strings.texi.orig:1108
msgid "This predicate returns non-@code{nil} if @var{object} is a valid case table."
msgstr "この述語は、@var{object}が有効な大文字小文字テーブルの場合は、非@code{nil}をreturnします。"

#. type: defun
#: strings.texi.orig:1110
#, no-wrap
msgid "set-standard-case-table table"
msgstr "set-standard-case-table table"

#. type: defun
#: strings.texi.orig:1113
msgid ""
"This function makes @var{table} the standard case table, so that it will be "
"used in any buffers created subsequently."
msgstr "この関数は、@var{table}を標準大文字小文字テーブルにして、これ以降に作成される任意のバッファーにたいしてこのテーブルが使用されます。"

#. type: defun
#: strings.texi.orig:1115
#, no-wrap
msgid "standard-case-table"
msgstr "standard-case-table"

#. type: defun
#: strings.texi.orig:1117
msgid "This returns the standard case table."
msgstr "これは標準大文字小文字テーブル(standard case table)をreturnします。"

#. type: defun
#: strings.texi.orig:1119
#, no-wrap
msgid "current-case-table"
msgstr "current-case-table"

#. type: defun
#: strings.texi.orig:1121
msgid "This function returns the current buffer's case table."
msgstr "この関数は、カレントバッファーの大文字小文字テーブルをreturnします。"

#. type: defun
#: strings.texi.orig:1123
#, no-wrap
msgid "set-case-table table"
msgstr "set-case-table table"

#. type: defun
#: strings.texi.orig:1125
msgid "This sets the current buffer's case table to @var{table}."
msgstr "これはカレントバッファーの大文字小文字テーブルを、@var{table}にセットします。"

#. type: defmac
#: strings.texi.orig:1127
#, no-wrap
msgid "with-case-table table body@dots{}"
msgstr "with-case-table table body@dots{}"

#. type: defmac
#: strings.texi.orig:1134
msgid ""
"The @code{with-case-table} macro saves the current case table, makes "
"@var{table} the current case table, evaluates the @var{body} forms, and "
"finally restores the case table.  The return value is the value of the last "
"form in @var{body}.  The case table is restored even in case of an abnormal "
"exit via @code{throw} or error (@pxref{Nonlocal Exits})."
msgstr "@code{with-case-table}マクロはカレント大文字小文字テーブルを保存してから、@var{table}をカレント大文字小文字テーブルにセットし、その後に@var{body}フォームを評価してから、最後に大文字小文字テーブルをリストアします。return値は、@var{body}の最後のフォームの値です。@code{throw}またはエラー(@ref{Nonlocal Exits}を参照してください)により異常終了した場合でも、大文字小文字テーブルはリストアされます。"

#. type: Plain text
#: strings.texi.orig:1145
msgid ""
"Some language environments modify the case conversions of @acronym{ASCII} "
"characters; for example, in the Turkish language environment, the "
"@acronym{ASCII} character @samp{I} is downcased into a Turkish ``dotless "
"i''.  This can interfere with code that requires ordinary @acronym{ASCII} "
"case conversion, such as implementations of @acronym{ASCII}-based network "
"protocols.  In that case, use the @code{with-case-table} macro with the "
"variable @var{ascii-case-table}, which stores the unmodified case table for "
"the @acronym{ASCII} character set."
msgstr "@acronym{ASCII}文字の大文字小文字変換を変更する言語環境(language environment)がいくつかあります。たとえばTurkishの言語環境では、@acronym{ASCII}文字の@samp{I}にたいする小文字は、Turkishの``dotless i''です。これは、(@acronym{ASCII}ベースのネットワークプロトコル実装のような)@acronym{ASCII}の通常の大文字小文字変換を要求するコードに干渉する可能性があります。このような場合は、変数@var{ascii-case-table}にたいして@code{with-case-table}マクロを使用します。これにより、変更されていない@acronym{ASCII}文字セットの大文字小文字テーブルが保存されます。"

#. type: defvar
#: strings.texi.orig:1146
#, no-wrap
msgid "ascii-case-table"
msgstr "ascii-case-table"

#. type: defvar
#: strings.texi.orig:1149
msgid ""
"The case table for the @acronym{ASCII} character set.  This should not be "
"modified by any language environment settings."
msgstr "@acronym{ASCII}文字セットにたいする大文字小文字テーブルです。すべての言語環境セッティングにおいて、これを変更するべきではありません。"

#. type: Plain text
#: strings.texi.orig:1156
msgid ""
"The following three functions are convenient subroutines for packages that "
"define non-@acronym{ASCII} character sets.  They modify the specified case "
"table @var{case-table}; they also modify the standard syntax table.  "
"@xref{Syntax Tables}.  Normally you would use these functions to change the "
"standard case table."
msgstr "以下の3つの関数は、非@acronym{ASCII}文字セットを定義するパッケージにたいして便利なサブルーチンです。これらは@var{case-table}に指定された大文字小文字テーブルを変更します。これは標準構文テーブルも変更します。@ref{Syntax Tables}を参照してください。通常これらの関数は、標準大文字小文字テーブルを変更するために使用されます。"

#. type: defun
#: strings.texi.orig:1157
#, no-wrap
msgid "set-case-syntax-pair uc lc case-table"
msgstr "set-case-syntax-pair uc lc case-table"

#. type: defun
#: strings.texi.orig:1160
msgid ""
"This function specifies a pair of corresponding letters, one upper case and "
"one lower case."
msgstr "この関数は、対応する文字のペア(一方は大文字、もう一方は小文字)を指定します。"

#. type: defun
#: strings.texi.orig:1162
#, no-wrap
msgid "set-case-syntax-delims l r case-table"
msgstr "set-case-syntax-delims l r case-table"

#. type: defun
#: strings.texi.orig:1165
msgid ""
"This function makes characters @var{l} and @var{r} a matching pair of "
"case-invariant delimiters."
msgstr "この関数は文字@var{l}と@var{r}を、大文字小文字不変区切り(case-invariant delimiter)mpマッチングペアにします。"

#. type: defun
#: strings.texi.orig:1167
#, no-wrap
msgid "set-case-syntax char syntax case-table"
msgstr "set-case-syntax char syntax case-table"

#. type: defun
#: strings.texi.orig:1170
msgid "This function makes @var{char} case-invariant, with syntax @var{syntax}."
msgstr "この関数は@var{char}を、構文@var{syntax}の、大文字小文字不変(case-invariant)とします。"

#. type: deffn
#: strings.texi.orig:1172
#, no-wrap
msgid "Command describe-buffer-case-table"
msgstr "Command describe-buffer-case-table"

#. type: deffn
#: strings.texi.orig:1175
msgid ""
"This command displays a description of the contents of the current buffer's "
"case table."
msgstr "このコマンドは、カレントバッファーの大文字小文字テーブルの内容にたいする説明を表示します。"
