# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-26 13:12+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: strings.texi.orig:6 strings.texi.orig:7
#, no-wrap
msgid "Strings and Characters"
msgstr ""

#. type: cindex
#: strings.texi.orig:8
#, no-wrap
msgid "strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:9
#, no-wrap
msgid "character arrays"
msgstr ""

#. type: cindex
#: strings.texi.orig:10
#, no-wrap
msgid "characters"
msgstr ""

#. type: cindex
#: strings.texi.orig:11
#, no-wrap
msgid "bytes"
msgstr ""

#. type: Plain text
#: strings.texi.orig:19
msgid ""
"A string in Emacs Lisp is an array that contains an ordered sequence of "
"characters.  Strings are used as names of symbols, buffers, and files; to "
"send messages to users; to hold text being copied between buffers; and for "
"many other purposes.  Because strings are so important, Emacs Lisp has many "
"functions expressly for manipulating them.  Emacs Lisp programs use strings "
"more often than individual characters."
msgstr ""

#. type: Plain text
#: strings.texi.orig:22
msgid ""
"@xref{Strings of Events}, for special considerations for strings of keyboard "
"character events."
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Basics: String Basics"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Basic properties of strings and characters."
msgstr ""

#. type: section
#: strings.texi.orig:33 strings.texi.orig:93 strings.texi.orig:94
#, no-wrap
msgid "Predicates for Strings"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Testing whether an object is a string or char."
msgstr ""

#. type: section
#: strings.texi.orig:33 strings.texi.orig:116 strings.texi.orig:117
#, no-wrap
msgid "Creating Strings"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Functions to allocate new strings."
msgstr ""

#. type: section
#: strings.texi.orig:33 strings.texi.orig:372 strings.texi.orig:373
#, no-wrap
msgid "Modifying Strings"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Altering the contents of an existing string."
msgstr ""

#. type: node
#: strings.texi.orig:33 strings.texi.orig:406
#, no-wrap
msgid "Text Comparison"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Comparing characters or strings."
msgstr ""

#. type: node
#: strings.texi.orig:33 strings.texi.orig:583
#, no-wrap
msgid "String Conversion"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Converting to and from characters and strings."
msgstr ""

#. type: section
#: strings.texi.orig:33 strings.texi.orig:695 strings.texi.orig:696
#, no-wrap
msgid "Formatting Strings"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "@code{format}: Emacs's analogue of @code{printf}."
msgstr ""

#. type: node
#: strings.texi.orig:33 strings.texi.orig:927
#, no-wrap
msgid "Case Conversion"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Case conversion functions."
msgstr ""

#. type: node
#: strings.texi.orig:33 strings.texi.orig:1046
#, no-wrap
msgid "Case Tables"
msgstr ""

#. type: menuentry
#: strings.texi.orig:33
msgid "Customizing case conversion."
msgstr ""

#. type: node
#: strings.texi.orig:35
#, no-wrap
msgid "String Basics"
msgstr ""

#. type: section
#: strings.texi.orig:36
#, no-wrap
msgid "String and Character Basics"
msgstr ""

#. type: Plain text
#: strings.texi.orig:43
msgid ""
"A character is a Lisp object which represents a single character of text.  "
"In Emacs Lisp, characters are simply integers; whether an integer is a "
"character or not is determined only by how it is used.  @xref{Character "
"Codes}, for details about character representation in Emacs."
msgstr ""

#. type: Plain text
#: strings.texi.orig:49
msgid ""
"A string is a fixed sequence of characters.  It is a type of sequence called "
"a @dfn{array}, meaning that its length is fixed and cannot be altered once "
"it is created (@pxref{Sequences Arrays Vectors}).  Unlike in C, Emacs Lisp "
"strings are @emph{not} terminated by a distinguished character code."
msgstr ""

#. type: Plain text
#: strings.texi.orig:58
msgid ""
"Since strings are arrays, and therefore sequences as well, you can operate "
"on them with the general array and sequence functions documented in "
"@ref{Sequences Arrays Vectors}.  For example, you can access or change "
"individual characters in a string using the functions @code{aref} and "
"@code{aset} (@pxref{Array Functions}).  However, note that @code{length} "
"should @emph{not} be used for computing the width of a string on display; "
"use @code{string-width} (@pxref{Size of Displayed Text}) instead."
msgstr ""

#. type: Plain text
#: strings.texi.orig:63
msgid ""
"There are two text representations for non-@acronym{ASCII} characters in "
"Emacs strings (and in buffers): unibyte and multibyte.  For most Lisp "
"programming, you don't need to be concerned with these two representations.  "
"@xref{Text Representations}, for details."
msgstr ""

#. type: Plain text
#: strings.texi.orig:74
msgid ""
"Sometimes key sequences are represented as unibyte strings.  When a unibyte "
"string is a key sequence, string elements in the range 128 to 255 represent "
"meta characters (which are large integers) rather than character codes in "
"the range 128 to 255.  Strings cannot hold characters that have the hyper, "
"super or alt modifiers; they can hold @acronym{ASCII} control characters, "
"but no other control characters.  They do not distinguish case in "
"@acronym{ASCII} control characters.  If you want to store such characters in "
"a sequence, such as a key sequence, you must use a vector instead of a "
"string.  @xref{Character Type}, for more information about keyboard input "
"characters."
msgstr ""

#. type: Plain text
#: strings.texi.orig:81
msgid ""
"Strings are useful for holding regular expressions.  You can also match "
"regular expressions against strings with @code{string-match} (@pxref{Regexp "
"Search}).  The functions @code{match-string} (@pxref{Simple Match Data}) and "
"@code{replace-match} (@pxref{Replacing Match}) are useful for decomposing "
"and modifying strings after matching regular expressions against them."
msgstr ""

#. type: Plain text
#: strings.texi.orig:86
msgid ""
"Like a buffer, a string can contain text properties for the characters in "
"it, as well as the characters themselves.  @xref{Text Properties}.  All the "
"Lisp primitives that copy text from strings to buffers or other strings also "
"copy the properties of the characters being copied."
msgstr ""

#. type: Plain text
#: strings.texi.orig:92
msgid ""
"@xref{Text}, for information about functions that display strings or copy "
"them into buffers.  @xref{Character Type}, and @ref{String Type}, for "
"information about the syntax of characters and strings.  @xref{Non-ASCII "
"Characters}, for functions to convert between text representations and to "
"encode and decode character codes."
msgstr ""

#. type: cindex
#: strings.texi.orig:95
#, no-wrap
msgid "predicates for strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:96
#, no-wrap
msgid "string predicates"
msgstr ""

#. type: Plain text
#: strings.texi.orig:100
msgid ""
"For more information about general sequence and array predicates, see "
"@ref{Sequences Arrays Vectors}, and @ref{Arrays}."
msgstr ""

#. type: defun
#: strings.texi.orig:101
#, no-wrap
msgid "stringp object"
msgstr ""

#. type: defun
#: strings.texi.orig:104
msgid ""
"This function returns @code{t} if @var{object} is a string, @code{nil} "
"otherwise."
msgstr ""

#. type: defun
#: strings.texi.orig:106
#, no-wrap
msgid "string-or-null-p object"
msgstr ""

#. type: defun
#: strings.texi.orig:109
msgid ""
"This function returns @code{t} if @var{object} is a string or @code{nil}.  "
"It returns @code{nil} otherwise."
msgstr ""

#. type: defun
#: strings.texi.orig:111
#, no-wrap
msgid "char-or-string-p object"
msgstr ""

#. type: defun
#: strings.texi.orig:114
msgid ""
"This function returns @code{t} if @var{object} is a string or a character "
"(i.e., an integer), @code{nil} otherwise."
msgstr ""

#. type: cindex
#: strings.texi.orig:118
#, no-wrap
msgid "creating strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:119
#, no-wrap
msgid "string creation"
msgstr ""

#. type: Plain text
#: strings.texi.orig:123
msgid ""
"The following functions create strings, either from scratch, or by putting "
"strings together, or by taking them apart."
msgstr ""

#. type: defun
#: strings.texi.orig:124
#, no-wrap
msgid "make-string count character"
msgstr ""

#. type: defun
#: strings.texi.orig:127
msgid ""
"This function returns a string made up of @var{count} repetitions of "
"@var{character}.  If @var{count} is negative, an error is signaled."
msgstr ""

#. type: example
#: strings.texi.orig:133
#, no-wrap
msgid ""
"(make-string 5 ?x)\n"
"     @result{} \"xxxxx\"\n"
"(make-string 0 ?x)\n"
"     @result{} \"\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:137
msgid ""
"Other functions to compare with this one include @code{make-vector} "
"(@pxref{Vectors}) and @code{make-list} (@pxref{Building Lists})."
msgstr ""

#. type: defun
#: strings.texi.orig:139
#, no-wrap
msgid "string &rest characters"
msgstr ""

#. type: defun
#: strings.texi.orig:141
msgid "This returns a string containing the characters @var{characters}."
msgstr ""

#. type: example
#: strings.texi.orig:145
#, no-wrap
msgid ""
"(string ?a ?b ?c)\n"
"     @result{} \"abc\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:148
#, no-wrap
msgid "substring string start &optional end"
msgstr ""

#. type: defun
#: strings.texi.orig:153
msgid ""
"This function returns a new string which consists of those characters from "
"@var{string} in the range from (and including) the character at the index "
"@var{start} up to (but excluding) the character at the index @var{end}.  The "
"first character is at index zero."
msgstr ""

#. type: group
#: strings.texi.orig:158
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0 3)\n"
"     @result{} \"abc\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:167
msgid ""
"In the above example, the index for @samp{a} is 0, the index for @samp{b} is "
"1, and the index for @samp{c} is 2.  The index 3---which is the fourth "
"character in the string---marks the character position up to which the "
"substring is copied.  Thus, @samp{abc} is copied from the string "
"@code{\"abcdefg\"}."
msgstr ""

#. type: defun
#: strings.texi.orig:170
msgid ""
"A negative number counts from the end of the string, so that @minus{}1 "
"signifies the index of the last character of the string.  For example:"
msgstr ""

#. type: group
#: strings.texi.orig:175
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 -1)\n"
"     @result{} \"ef\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:182
msgid ""
"In this example, the index for @samp{e} is @minus{}3, the index for @samp{f} "
"is @minus{}2, and the index for @samp{g} is @minus{}1.  Therefore, @samp{e} "
"and @samp{f} are included, and @samp{g} is excluded."
msgstr ""

#. type: defun
#: strings.texi.orig:185
msgid ""
"When @code{nil} is used for @var{end}, it stands for the length of the "
"string.  Thus,"
msgstr ""

#. type: group
#: strings.texi.orig:190
#, no-wrap
msgid ""
"(substring \"abcdefg\" -3 nil)\n"
"     @result{} \"efg\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:196
msgid ""
"Omitting the argument @var{end} is equivalent to specifying @code{nil}.  It "
"follows that @code{(substring @var{string} 0)} returns a copy of all of "
"@var{string}."
msgstr ""

#. type: group
#: strings.texi.orig:201
#, no-wrap
msgid ""
"(substring \"abcdefg\" 0)\n"
"     @result{} \"abcdefg\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:207
msgid ""
"But we recommend @code{copy-sequence} for this purpose (@pxref{Sequence "
"Functions})."
msgstr ""

#. type: defun
#: strings.texi.orig:210
msgid ""
"If the characters copied from @var{string} have text properties, the "
"properties are copied into the new string also.  @xref{Text Properties}."
msgstr ""

#. type: defun
#: strings.texi.orig:213
msgid "@code{substring} also accepts a vector for the first argument.  For example:"
msgstr ""

#. type: example
#: strings.texi.orig:217
#, no-wrap
msgid ""
"(substring [a b (c) \"d\"] 1 3)\n"
"     @result{} [b (c)]\n"
msgstr ""

#. type: defun
#: strings.texi.orig:224
msgid ""
"A @code{wrong-type-argument} error is signaled if @var{start} is not an "
"integer or if @var{end} is neither an integer nor @code{nil}.  An "
"@code{args-out-of-range} error is signaled if @var{start} indicates a "
"character following @var{end}, or if either integer is out of range for "
"@var{string}."
msgstr ""

#. type: defun
#: strings.texi.orig:229
msgid ""
"Contrast this function with @code{buffer-substring} (@pxref{Buffer "
"Contents}), which returns a string containing a portion of the text in the "
"current buffer.  The beginning of a string is at index 0, but the beginning "
"of a buffer is at index 1."
msgstr ""

#. type: defun
#: strings.texi.orig:231
#, no-wrap
msgid "substring-no-properties string &optional start end"
msgstr ""

#. type: defun
#: strings.texi.orig:237
msgid ""
"This works like @code{substring} but discards all text properties from the "
"value.  Also, @var{start} may be omitted or @code{nil}, which is equivalent "
"to 0.  Thus, @w{@code{(substring-no-properties @var{string})}} returns a "
"copy of @var{string}, with all text properties removed."
msgstr ""

#. type: defun
#: strings.texi.orig:239
#, no-wrap
msgid "concat &rest sequences"
msgstr ""

#. type: cindex
#: strings.texi.orig:240
#, no-wrap
msgid "copying strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:241
#, no-wrap
msgid "concatenating strings"
msgstr ""

#. type: defun
#: strings.texi.orig:247
msgid ""
"This function returns a new string consisting of the characters in the "
"arguments passed to it (along with their text properties, if any).  The "
"arguments may be strings, lists of numbers, or vectors of numbers; they are "
"not themselves changed.  If @code{concat} receives no arguments, it returns "
"an empty string."
msgstr ""

#. type: example
#: strings.texi.orig:260
#, no-wrap
msgid ""
"(concat \"abc\" \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"abc\" (list 120 121) [122])\n"
"     @result{} \"abcxyz\"\n"
";; @r{@code{nil} is an empty sequence.}\n"
"(concat \"abc\" nil \"-def\")\n"
"     @result{} \"abc-def\"\n"
"(concat \"The \" \"quick brown \" \"fox.\")\n"
"     @result{} \"The quick brown fox.\"\n"
"(concat)\n"
"     @result{} \"\"\n"
msgstr ""

#. type: defun
#: strings.texi.orig:266
msgid ""
"This function always constructs a new string that is not @code{eq} to any "
"existing string, except when the result is the empty string (to save space, "
"Emacs makes only one empty multibyte string)."
msgstr ""

#. type: defun
#: strings.texi.orig:273
msgid ""
"For information about other concatenation functions, see the description of "
"@code{mapconcat} in @ref{Mapping Functions}, @code{vconcat} in @ref{Vector "
"Functions}, and @code{append} in @ref{Building Lists}.  For concatenating "
"individual command-line arguments into a string to be used as a shell "
"command, see @ref{Shell Arguments, combine-and-quote-strings}."
msgstr ""

#. type: defun
#: strings.texi.orig:275
#, no-wrap
msgid "split-string string &optional separators omit-nulls trim"
msgstr ""

#. type: defun
#: strings.texi.orig:280
msgid ""
"This function splits @var{string} into substrings based on the regular "
"expression @var{separators} (@pxref{Regular Expressions}).  Each match for "
"@var{separators} defines a splitting point; the substrings between splitting "
"points are made into a list, which is returned."
msgstr ""

#. type: defun
#: strings.texi.orig:286
msgid ""
"If @var{omit-nulls} is @code{nil} (or omitted), the result contains null "
"strings whenever there are two consecutive matches for @var{separators}, or "
"a match is adjacent to the beginning or end of @var{string}.  If "
"@var{omit-nulls} is @code{t}, these null strings are omitted from the "
"result."
msgstr ""

#. type: defun
#: strings.texi.orig:289
msgid ""
"If @var{separators} is @code{nil} (or omitted), the default is the value of "
"@code{split-string-default-separators}."
msgstr ""

#. type: defun
#: strings.texi.orig:292
msgid ""
"As a special case, when @var{separators} is @code{nil} (or omitted), null "
"strings are always omitted from the result.  Thus:"
msgstr ""

#. type: example
#: strings.texi.orig:296
#, no-wrap
msgid ""
"(split-string \"  two words \")\n"
"     @result{} (\"two\" \"words\")\n"
msgstr ""

#. type: defun
#: strings.texi.orig:301
msgid ""
"The result is not @code{(\"\" \"two\" \"words\" \"\")}, which would rarely "
"be useful.  If you need such a result, use an explicit value for "
"@var{separators}:"
msgstr ""

#. type: example
#: strings.texi.orig:306
#, no-wrap
msgid ""
"(split-string \"  two words \"\n"
"              split-string-default-separators)\n"
"     @result{} (\"\" \"two\" \"words\" \"\")\n"
msgstr ""

#. type: defun
#: strings.texi.orig:309
msgid "More examples:"
msgstr ""

#. type: example
#: strings.texi.orig:317
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o\")\n"
"     @result{} (\"S\" \"up is g\" \"\" \"d f\" \"\" \"d\")\n"
"(split-string \"Soup is good food\" \"o\" t)\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
"(split-string \"Soup is good food\" \"o+\")\n"
"     @result{} (\"S\" \"up is g\" \"d f\" \"d\")\n"
msgstr ""

#. type: defun
#: strings.texi.orig:322
msgid ""
"Empty matches do count, except that @code{split-string} will not look for a "
"final empty match when it already reached the end of the string using a "
"non-empty match or when @var{string} is empty:"
msgstr ""

#. type: example
#: strings.texi.orig:330
#, no-wrap
msgid ""
"(split-string \"aooob\" \"o*\")\n"
"     @result{} (\"\" \"a\" \"\" \"b\" \"\")\n"
"(split-string \"ooaboo\" \"o*\")\n"
"     @result{} (\"\" \"\" \"a\" \"b\" \"\")\n"
"(split-string \"\" \"\")\n"
"     @result{} (\"\")\n"
msgstr ""

#. type: defun
#: strings.texi.orig:335
msgid ""
"However, when @var{separators} can match the empty string, @var{omit-nulls} "
"is usually @code{t}, so that the subtleties in the three previous examples "
"are rarely relevant:"
msgstr ""

#. type: example
#: strings.texi.orig:343
#, no-wrap
msgid ""
"(split-string \"Soup is good food\" \"o*\" t)\n"
"     @result{} (\"S\" \"u\" \"p\" \" \" \"i\" \"s\" \" \" \"g\" \"d\" \" \" "
"\"f\" \"d\")\n"
"(split-string \"Nice doggy!\" \"\" t)\n"
"     @result{} (\"N\" \"i\" \"c\" \"e\" \" \" \"d\" \"o\" \"g\" \"g\" \"y\" "
"\"!\")\n"
"(split-string \"\" \"\" t)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: strings.texi.orig:349
msgid ""
"Somewhat odd, but predictable, behavior can occur for certain ``non-greedy'' "
"values of @var{separators} that can prefer empty matches over non-empty "
"matches.  Again, such values rarely occur in practice:"
msgstr ""

#. type: example
#: strings.texi.orig:355
#, no-wrap
msgid ""
"(split-string \"ooo\" \"o*\" t)\n"
"     @result{} nil\n"
"(split-string \"ooo\" \"\\\\|o+\" t)\n"
"     @result{} (\"o\" \"o\" \"o\")\n"
msgstr ""

#. type: defun
#: strings.texi.orig:361
msgid ""
"If the optional argument @var{trim} is non-@code{nil}, it should be a "
"regular expression to match text to trim from the beginning and end of each "
"substring.  If trimming makes the substring empty, it is treated as null."
msgstr ""

#. type: defun
#: strings.texi.orig:365
msgid ""
"If you need to split a string into a list of individual command-line "
"arguments suitable for @code{call-process} or @code{start-process}, see "
"@ref{Shell Arguments, split-string-and-unquote}."
msgstr ""

#. type: defvar
#: strings.texi.orig:367
#, no-wrap
msgid "split-string-default-separators"
msgstr ""

#. type: defvar
#: strings.texi.orig:370
msgid ""
"The default value of @var{separators} for @code{split-string}.  Its usual "
"value is @w{@code{\"[ \\f\\t\\n\\r\\v]+\"}}."
msgstr ""

#. type: cindex
#: strings.texi.orig:374
#, no-wrap
msgid "modifying strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:375
#, no-wrap
msgid "string modification"
msgstr ""

#. type: Plain text
#: strings.texi.orig:383
msgid ""
"The most basic way to alter the contents of an existing string is with "
"@code{aset} (@pxref{Array Functions}).  @code{(aset @var{string} @var{idx} "
"@var{char})} stores @var{char} into @var{string} at index @var{idx}.  Each "
"character occupies one or more bytes, and if @var{char} needs a different "
"number of bytes from the character already present at that index, "
"@code{aset} signals an error."
msgstr ""

#. type: Plain text
#: strings.texi.orig:385
msgid "A more powerful function is @code{store-substring}:"
msgstr ""

#. type: defun
#: strings.texi.orig:386
#, no-wrap
msgid "store-substring string idx obj"
msgstr ""

#. type: defun
#: strings.texi.orig:390
msgid ""
"This function alters part of the contents of the string @var{string}, by "
"storing @var{obj} starting at index @var{idx}.  The argument @var{obj} may "
"be either a character or a (smaller) string."
msgstr ""

#. type: defun
#: strings.texi.orig:395
msgid ""
"Since it is impossible to change the length of an existing string, it is an "
"error if @var{obj} doesn't fit within @var{string}'s actual length, or if "
"any new character requires a different number of bytes from the character "
"currently present at that point in @var{string}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:399
msgid "To clear out a string that contained a password, use @code{clear-string}:"
msgstr ""

#. type: defun
#: strings.texi.orig:400
#, no-wrap
msgid "clear-string string"
msgstr ""

#. type: defun
#: strings.texi.orig:403
msgid ""
"This makes @var{string} a unibyte string and clears its contents to zeros.  "
"It may also change @var{string}'s length."
msgstr ""

#. type: section
#: strings.texi.orig:407
#, no-wrap
msgid "Comparison of Characters and Strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:408
#, no-wrap
msgid "string equality"
msgstr ""

#. type: cindex
#: strings.texi.orig:409
#, no-wrap
msgid "text comparison"
msgstr ""

#. type: defun
#: strings.texi.orig:411
#, no-wrap
msgid "char-equal character1 character2"
msgstr ""

#. type: defun
#: strings.texi.orig:415
msgid ""
"This function returns @code{t} if the arguments represent the same "
"character, @code{nil} otherwise.  This function ignores differences in case "
"if @code{case-fold-search} is non-@code{nil}."
msgstr ""

#. type: example
#: strings.texi.orig:422
#, no-wrap
msgid ""
"(char-equal ?x ?x)\n"
"     @result{} t\n"
"(let ((case-fold-search nil))\n"
"  (char-equal ?x ?X))\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: strings.texi.orig:425
#, no-wrap
msgid "string= string1 string2"
msgstr ""

#. type: defun
#: strings.texi.orig:430
msgid ""
"This function returns @code{t} if the characters of the two strings match "
"exactly.  Symbols are also allowed as arguments, in which case the symbol "
"names are used.  Case is always significant, regardless of "
"@code{case-fold-search}."
msgstr ""

#. type: defun
#: strings.texi.orig:437
msgid ""
"This function is equivalent to @code{equal} for comparing two strings "
"(@pxref{Equality Predicates}).  In particular, the text properties of the "
"two strings are ignored; use @code{equal-including-properties} if you need "
"to distinguish between strings that differ only in their text properties.  "
"However, unlike @code{equal}, if either argument is not a string or symbol, "
"@code{string=} signals an error."
msgstr ""

#. type: example
#: strings.texi.orig:445
#, no-wrap
msgid ""
"(string= \"abc\" \"abc\")\n"
"     @result{} t\n"
"(string= \"abc\" \"ABC\")\n"
"     @result{} nil\n"
"(string= \"ab\" \"ABC\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: strings.texi.orig:462
msgid ""
"For technical reasons, a unibyte and a multibyte string are @code{equal} if "
"and only if they contain the same sequence of character codes and all these "
"codes are either in the range 0 through 127 (@acronym{ASCII}) or 160 through "
"255 (@code{eight-bit-graphic}).  However, when a unibyte string is converted "
"to a multibyte string, all characters with codes in the range 160 through "
"255 are converted to characters with higher codes, whereas @acronym{ASCII} "
"characters remain unchanged.  Thus, a unibyte string and its conversion to "
"multibyte are only @code{equal} if the string is all @acronym{ASCII}.  "
"Character codes 160 through 255 are not entirely proper in multibyte text, "
"even though they can occur.  As a consequence, the situation where a unibyte "
"and a multibyte string are @code{equal} without both being all "
"@acronym{ASCII} is a technical oddity that very few Emacs Lisp programmers "
"ever get confronted with.  @xref{Text Representations}."
msgstr ""

#. type: defun
#: strings.texi.orig:464
#, no-wrap
msgid "string-equal string1 string2"
msgstr ""

#. type: defun
#: strings.texi.orig:466
msgid "@code{string-equal} is another name for @code{string=}."
msgstr ""

#. type: cindex
#: strings.texi.orig:468
#, no-wrap
msgid "lexical comparison"
msgstr ""

#. type: defun
#: strings.texi.orig:469
#, no-wrap
msgid "string< string1 string2"
msgstr ""

#. type: defun
#: strings.texi.orig:478
msgid ""
"This function compares two strings a character at a time.  It scans both the "
"strings at the same time to find the first pair of corresponding characters "
"that do not match.  If the lesser character of these two is the character "
"from @var{string1}, then @var{string1} is less, and this function returns "
"@code{t}.  If the lesser character is the one from @var{string2}, then "
"@var{string1} is greater, and this function returns @code{nil}.  If the two "
"strings match entirely, the value is @code{nil}."
msgstr ""

#. type: defun
#: strings.texi.orig:486
msgid ""
"Pairs of characters are compared according to their character codes.  Keep "
"in mind that lower case letters have higher numeric values in the "
"@acronym{ASCII} character set than their upper case counterparts; digits and "
"many punctuation characters have a lower numeric value than upper case "
"letters.  An @acronym{ASCII} character is less than any non-@acronym{ASCII} "
"character; a unibyte non-@acronym{ASCII} character is always less than any "
"multibyte non-@acronym{ASCII} character (@pxref{Text Representations})."
msgstr ""

#. type: group
#: strings.texi.orig:495
#, no-wrap
msgid ""
"(string< \"abc\" \"abd\")\n"
"     @result{} t\n"
"(string< \"abd\" \"abc\")\n"
"     @result{} nil\n"
"(string< \"123\" \"abc\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: strings.texi.orig:502
msgid ""
"When the strings have different lengths, and they match up to the length of "
"@var{string1}, then the result is @code{t}.  If they match up to the length "
"of @var{string2}, the result is @code{nil}.  A string of no characters is "
"less than any other string."
msgstr ""

#. type: group
#: strings.texi.orig:515
#, no-wrap
msgid ""
"(string< \"\" \"abc\")\n"
"     @result{} t\n"
"(string< \"ab\" \"abc\")\n"
"     @result{} t\n"
"(string< \"abc\" \"\")\n"
"     @result{} nil\n"
"(string< \"abc\" \"ab\")\n"
"     @result{} nil\n"
"(string< \"\" \"\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: strings.texi.orig:520
msgid ""
"Symbols are also allowed as arguments, in which case their print names are "
"used."
msgstr ""

#. type: defun
#: strings.texi.orig:522
#, no-wrap
msgid "string-lessp string1 string2"
msgstr ""

#. type: defun
#: strings.texi.orig:524
msgid "@code{string-lessp} is another name for @code{string<}."
msgstr ""

#. type: defun
#: strings.texi.orig:526
#, no-wrap
msgid "string-prefix-p string1 string2 &optional ignore-case"
msgstr ""

#. type: defun
#: strings.texi.orig:531
msgid ""
"This function returns non-@code{nil} if @var{string1} is a prefix of "
"@var{string2}; i.e., if @var{string2} starts with @var{string1}.  If the "
"optional argument @var{ignore-case} is non-@code{nil}, the comparison "
"ignores case differences."
msgstr ""

#. type: defun
#: strings.texi.orig:533
#, no-wrap
msgid "string-suffix-p suffix string &optional ignore-case"
msgstr ""

#. type: defun
#: strings.texi.orig:538
msgid ""
"This function returns non-@code{nil} if @var{suffix} is a suffix of "
"@var{string}; i.e., if @var{string} ends with @var{suffix}.  If the optional "
"argument @var{ignore-case} is non-@code{nil}, the comparison ignores case "
"differences."
msgstr ""

#. type: defun
#: strings.texi.orig:540
#, no-wrap
msgid ""
"compare-strings string1 start1 end1 string2 start2 end2 &optional "
"ignore-case"
msgstr ""

#. type: defun
#: strings.texi.orig:548
msgid ""
"This function compares a specified part of @var{string1} with a specified "
"part of @var{string2}.  The specified part of @var{string1} runs from index "
"@var{start1} (inclusive) up to index @var{end1} (exclusive); @code{nil} for "
"@var{start1} means the start of the string, while @code{nil} for @var{end1} "
"means the length of the string.  Likewise, the specified part of "
"@var{string2} runs from index @var{start2} up to index @var{end2}."
msgstr ""

#. type: defun
#: strings.texi.orig:557
msgid ""
"The strings are compared by the numeric values of their characters.  For "
"instance, @var{str1} is considered ``smaller than'' @var{str2} if its first "
"differing character has a smaller numeric value.  If @var{ignore-case} is "
"non-@code{nil}, characters are converted to lower-case before comparing "
"them.  Unibyte strings are converted to multibyte for comparison "
"(@pxref{Text Representations}), so that a unibyte string and its conversion "
"to multibyte are always regarded as equal."
msgstr ""

#. type: defun
#: strings.texi.orig:564
msgid ""
"If the specified portions of the two strings match, the value is @code{t}.  "
"Otherwise, the value is an integer which indicates how many leading "
"characters agree, and which string is less.  Its absolute value is one plus "
"the number of characters that agree at the beginning of the two strings.  "
"The sign is negative if @var{string1} (or its specified portion) is less."
msgstr ""

#. type: defun
#: strings.texi.orig:566
#, no-wrap
msgid "assoc-string key alist &optional case-fold"
msgstr ""

#. type: defun
#: strings.texi.orig:575
msgid ""
"This function works like @code{assoc}, except that @var{key} must be a "
"string or symbol, and comparison is done using @code{compare-strings}.  "
"Symbols are converted to strings before testing.  If @var{case-fold} is "
"non-@code{nil}, it ignores case differences.  Unlike @code{assoc}, this "
"function can also match elements of the alist that are strings or symbols "
"rather than conses.  In particular, @var{alist} can be a list of strings or "
"symbols rather than an actual alist.  @xref{Association Lists}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:582
msgid ""
"See also the function @code{compare-buffer-substrings} in @ref{Comparing "
"Text}, for a way to compare text in buffers.  The function "
"@code{string-match}, which matches a regular expression against a string, "
"can be used for a kind of string comparison; see @ref{Regexp Search}."
msgstr ""

#. type: section
#: strings.texi.orig:584
#, no-wrap
msgid "Conversion of Characters and Strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:585
#, no-wrap
msgid "conversion of strings"
msgstr ""

#. type: Plain text
#: strings.texi.orig:595
msgid ""
"This section describes functions for converting between characters, strings "
"and integers.  @code{format} (@pxref{Formatting Strings}) and "
"@code{prin1-to-string} (@pxref{Output Functions}) can also convert Lisp "
"objects into strings.  @code{read-from-string} (@pxref{Input Functions}) can "
"``convert'' a string representation of a Lisp object into an object.  The "
"functions @code{string-to-multibyte} and @code{string-to-unibyte} convert "
"the text representation of a string (@pxref{Converting Representations})."
msgstr ""

#. type: Plain text
#: strings.texi.orig:600
msgid ""
"@xref{Documentation}, for functions that produce textual descriptions of "
"text characters and general input events (@code{single-key-description} and "
"@code{text-char-description}).  These are used primarily for making help "
"messages."
msgstr ""

#. type: defun
#: strings.texi.orig:601
#, no-wrap
msgid "number-to-string number"
msgstr ""

#. type: cindex
#: strings.texi.orig:602
#, no-wrap
msgid "integer to string"
msgstr ""

#. type: cindex
#: strings.texi.orig:603
#, no-wrap
msgid "integer to decimal"
msgstr ""

#. type: defun
#: strings.texi.orig:607
msgid ""
"This function returns a string consisting of the printed base-ten "
"representation of @var{number}.  The returned value starts with a minus sign "
"if the argument is negative."
msgstr ""

#. type: example
#: strings.texi.orig:611
#, no-wrap
msgid ""
"(number-to-string 256)\n"
"     @result{} \"256\"\n"
msgstr ""

#. type: group
#: strings.texi.orig:614
#, no-wrap
msgid ""
"(number-to-string -23)\n"
"     @result{} \"-23\"\n"
msgstr ""

#. type: example
#: strings.texi.orig:617
#, no-wrap
msgid ""
"(number-to-string -23.5)\n"
"     @result{} \"-23.5\"\n"
msgstr ""

#. type: cindex
#: strings.texi.orig:619
#, no-wrap
msgid "int-to-string"
msgstr ""

#. type: defun
#: strings.texi.orig:621
msgid "@code{int-to-string} is a semi-obsolete alias for this function."
msgstr ""

#. type: defun
#: strings.texi.orig:623
msgid "See also the function @code{format} in @ref{Formatting Strings}."
msgstr ""

#. type: defun
#: strings.texi.orig:625
#, no-wrap
msgid "string-to-number string &optional base"
msgstr ""

#. type: cindex
#: strings.texi.orig:626
#, no-wrap
msgid "string to number"
msgstr ""

#. type: defun
#: strings.texi.orig:636
msgid ""
"This function returns the numeric value of the characters in @var{string}.  "
"If @var{base} is non-@code{nil}, it must be an integer between 2 and 16 "
"(inclusive), and integers are converted in that base.  If @var{base} is "
"@code{nil}, then base ten is used.  Floating-point conversion only works in "
"base ten; we have not implemented other radices for floating-point numbers, "
"because that would be much more work and does not seem useful.  If "
"@var{string} looks like an integer but its value is too large to fit into a "
"Lisp integer, @code{string-to-number} returns a floating-point result."
msgstr ""

#. type: defun
#: strings.texi.orig:642
msgid ""
"The parsing skips spaces and tabs at the beginning of @var{string}, then "
"reads as much of @var{string} as it can interpret as a number in the given "
"base.  (On some systems it ignores other whitespace at the beginning, not "
"just spaces and tabs.)  If @var{string} cannot be interpreted as a number, "
"this function returns 0."
msgstr ""

#. type: example
#: strings.texi.orig:654
#, no-wrap
msgid ""
"(string-to-number \"256\")\n"
"     @result{} 256\n"
"(string-to-number \"25 is a perfect square.\")\n"
"     @result{} 25\n"
"(string-to-number \"X256\")\n"
"     @result{} 0\n"
"(string-to-number \"-4.5\")\n"
"     @result{} -4.5\n"
"(string-to-number \"1e5\")\n"
"     @result{} 100000.0\n"
msgstr ""

#. type: findex
#: strings.texi.orig:656
#, no-wrap
msgid "string-to-int"
msgstr ""

#. type: defun
#: strings.texi.orig:658
msgid "@code{string-to-int} is an obsolete alias for this function."
msgstr ""

#. type: defun
#: strings.texi.orig:660
#, no-wrap
msgid "char-to-string character"
msgstr ""

#. type: cindex
#: strings.texi.orig:661
#, no-wrap
msgid "character to string"
msgstr ""

#. type: defun
#: strings.texi.orig:665
msgid ""
"This function returns a new string containing one character, "
"@var{character}.  This function is semi-obsolete because the function "
"@code{string} is more general.  @xref{Creating Strings}."
msgstr ""

#. type: defun
#: strings.texi.orig:667
#, no-wrap
msgid "string-to-char string"
msgstr ""

#. type: defun
#: strings.texi.orig:674
msgid ""
"This function returns the first character in @var{string}.  This mostly "
"identical to @code{(aref string 0)}, except that it returns 0 if the string "
"is empty.  (The value is also 0 when the first character of @var{string} is "
"the null character, @acronym{ASCII} code 0.)  This function may be "
"eliminated in the future if it does not seem useful enough to retain."
msgstr ""

#. type: Plain text
#: strings.texi.orig:677
msgid "Here are some other functions that can convert to or from a string:"
msgstr ""

#. type: item
#: strings.texi.orig:679
#, no-wrap
msgid "concat"
msgstr ""

#. type: table
#: strings.texi.orig:682
msgid ""
"This function converts a vector or a list into a string.  @xref{Creating "
"Strings}."
msgstr ""

#. type: item
#: strings.texi.orig:683
#, no-wrap
msgid "vconcat"
msgstr ""

#. type: table
#: strings.texi.orig:686
msgid "This function converts a string into a vector.  @xref{Vector Functions}."
msgstr ""

#. type: item
#: strings.texi.orig:687
#, no-wrap
msgid "append"
msgstr ""

#. type: table
#: strings.texi.orig:689
msgid "This function converts a string into a list.  @xref{Building Lists}."
msgstr ""

#. type: item
#: strings.texi.orig:690
#, no-wrap
msgid "byte-to-string"
msgstr ""

#. type: table
#: strings.texi.orig:693
msgid ""
"This function converts a byte of character data into a unibyte string.  "
"@xref{Converting Representations}."
msgstr ""

#. type: cindex
#: strings.texi.orig:697
#, no-wrap
msgid "formatting strings"
msgstr ""

#. type: cindex
#: strings.texi.orig:698
#, no-wrap
msgid "strings, formatting them"
msgstr ""

#. type: Plain text
#: strings.texi.orig:704
msgid ""
"@dfn{Formatting} means constructing a string by substituting computed values "
"at various places in a constant string.  This constant string controls how "
"the other values are printed, as well as where they appear; it is called a "
"@dfn{format string}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:709
msgid ""
"Formatting is often useful for computing messages to be displayed.  In fact, "
"the functions @code{message} and @code{error} provide the same formatting "
"feature described here; they differ from @code{format} only in how they use "
"the result of formatting."
msgstr ""

#. type: defun
#: strings.texi.orig:710
#, no-wrap
msgid "format string &rest objects"
msgstr ""

#. type: defun
#: strings.texi.orig:715
msgid ""
"This function returns a new string that is made by copying @var{string} and "
"then replacing any format specification in the copy with encodings of the "
"corresponding @var{objects}.  The arguments @var{objects} are the computed "
"values to be formatted."
msgstr ""

#. type: defun
#: strings.texi.orig:719
msgid ""
"The characters in @var{string}, other than the format specifications, are "
"copied directly into the output, including their text properties, if any."
msgstr ""

#. type: cindex
#: strings.texi.orig:721
#, no-wrap
msgid "@samp{%} in format"
msgstr ""

#. type: cindex
#: strings.texi.orig:722
#, no-wrap
msgid "format specification"
msgstr ""

#. type: Plain text
#: strings.texi.orig:728
msgid ""
"A format specification is a sequence of characters beginning with a "
"@samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the @code{format} "
"function replaces it with the printed representation of one of the values to "
"be formatted (one of the arguments @var{objects}).  For example:"
msgstr ""

#. type: group
#: strings.texi.orig:733
#, no-wrap
msgid ""
"(format \"The value of fill-column is %d.\" fill-column)\n"
"     @result{} \"The value of fill-column is 72.\"\n"
msgstr ""

#. type: Plain text
#: strings.texi.orig:742
msgid ""
"Since @code{format} interprets @samp{%} characters as format specifications, "
"you should @emph{never} pass an arbitrary string as the first argument.  "
"This is particularly true when the string is generated by some Lisp code.  "
"Unless the string is @emph{known} to never include any @samp{%} characters, "
"pass @code{\"%s\"}, described below, as the first argument, and the string "
"as the second, like this:"
msgstr ""

#. type: example
#: strings.texi.orig:745
#, no-wrap
msgid "  (format \"%s\" @var{arbitrary-string})\n"
msgstr ""

#. type: Plain text
#: strings.texi.orig:754
msgid ""
"If @var{string} contains more than one format specification, the format "
"specifications correspond to successive values from @var{objects}.  Thus, "
"the first format specification in @var{string} uses the first such value, "
"the second format specification uses the second such value, and so on.  Any "
"extra format specifications (those for which there are no corresponding "
"values) cause an error.  Any extra values to be formatted are ignored."
msgstr ""

#. type: Plain text
#: strings.texi.orig:758
msgid ""
"Certain format specifications require values of particular types.  If you "
"supply a value that doesn't fit the requirements, an error is signaled."
msgstr ""

#. type: Plain text
#: strings.texi.orig:760
msgid "Here is a table of valid format specifications:"
msgstr ""

#. type: item
#: strings.texi.orig:762
#, no-wrap
msgid "%s"
msgstr ""

#. type: table
#: strings.texi.orig:768
msgid ""
"Replace the specification with the printed representation of the object, "
"made without quoting (that is, using @code{princ}, not "
"@code{prin1}---@pxref{Output Functions}).  Thus, strings are represented by "
"their contents alone, with no @samp{\"} characters, and symbols appear "
"without @samp{\\} characters."
msgstr ""

#. type: table
#: strings.texi.orig:772
msgid ""
"If the object is a string, its text properties are copied into the output.  "
"The text properties of the @samp{%s} itself are also copied, but those of "
"the object take priority."
msgstr ""

#. type: item
#: strings.texi.orig:773
#, no-wrap
msgid "%S"
msgstr ""

#. type: table
#: strings.texi.orig:778
msgid ""
"Replace the specification with the printed representation of the object, "
"made with quoting (that is, using @code{prin1}---@pxref{Output Functions}).  "
"Thus, strings are enclosed in @samp{\"} characters, and @samp{\\} characters "
"appear where necessary before special characters."
msgstr ""

#. type: item
#: strings.texi.orig:779
#, no-wrap
msgid "%o"
msgstr ""

#. type: cindex
#: strings.texi.orig:780
#, no-wrap
msgid "integer to octal"
msgstr ""

#. type: table
#: strings.texi.orig:783
msgid "Replace the specification with the base-eight representation of an integer."
msgstr ""

#. type: item
#: strings.texi.orig:784
#, no-wrap
msgid "%d"
msgstr ""

#. type: table
#: strings.texi.orig:787
msgid "Replace the specification with the base-ten representation of an integer."
msgstr ""

#. type: item
#: strings.texi.orig:788
#, no-wrap
msgid "%x"
msgstr ""

#. type: itemx
#: strings.texi.orig:789
#, no-wrap
msgid "%X"
msgstr ""

#. type: cindex
#: strings.texi.orig:790
#, no-wrap
msgid "integer to hexadecimal"
msgstr ""

#. type: table
#: strings.texi.orig:793
msgid ""
"Replace the specification with the base-sixteen representation of an "
"integer.  @samp{%x} uses lower case and @samp{%X} uses upper case."
msgstr ""

#. type: item
#: strings.texi.orig:794
#, no-wrap
msgid "%c"
msgstr ""

#. type: table
#: strings.texi.orig:796
msgid "Replace the specification with the character which is the value given."
msgstr ""

#. type: item
#: strings.texi.orig:797
#, no-wrap
msgid "%e"
msgstr ""

#. type: table
#: strings.texi.orig:800
msgid ""
"Replace the specification with the exponential notation for a floating-point "
"number."
msgstr ""

#. type: item
#: strings.texi.orig:801
#, no-wrap
msgid "%f"
msgstr ""

#. type: table
#: strings.texi.orig:804
msgid ""
"Replace the specification with the decimal-point notation for a "
"floating-point number."
msgstr ""

#. type: item
#: strings.texi.orig:805
#, no-wrap
msgid "%g"
msgstr ""

#. type: table
#: strings.texi.orig:809
msgid ""
"Replace the specification with notation for a floating-point number, using "
"either exponential notation or decimal-point notation, whichever is shorter."
msgstr ""

#. type: item
#: strings.texi.orig:810
#, no-wrap
msgid "%%"
msgstr ""

#. type: table
#: strings.texi.orig:814
msgid ""
"Replace the specification with a single @samp{%}.  This format specification "
"is unusual in that it does not use a value.  For example, @code{(format \"%% "
"%d\" 30)} returns @code{\"% 30\"}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:818
msgid ""
"Any other format character results in an @samp{Invalid format operation} "
"error."
msgstr ""

#. type: Plain text
#: strings.texi.orig:820
msgid "Here are several examples:"
msgstr ""

#. type: group
#: strings.texi.orig:825
#, no-wrap
msgid ""
"(format \"The name of this buffer is %s.\" (buffer-name))\n"
"     @result{} \"The name of this buffer is strings.texi.\"\n"
"\n"
msgstr ""

#. type: group
#: strings.texi.orig:828
#, no-wrap
msgid ""
"(format \"The buffer object prints as %s.\" (current-buffer))\n"
"     @result{} \"The buffer object prints as strings.texi.\"\n"
"\n"
msgstr ""

#. type: group
#: strings.texi.orig:833
#, no-wrap
msgid ""
"(format \"The octal value of %d is %o,\n"
"         and the hex value is %x.\" 18 18 18)\n"
"     @result{} \"The octal value of 18 is 22,\n"
"         and the hex value is 12.\"\n"
msgstr ""

#. type: cindex
#: strings.texi.orig:836
#, no-wrap
msgid "field width"
msgstr ""

#. type: cindex
#: strings.texi.orig:837
#, no-wrap
msgid "padding"
msgstr ""

#. type: Plain text
#: strings.texi.orig:844
msgid ""
"A specification can have a @dfn{width}, which is a decimal number between "
"the @samp{%} and the specification character.  If the printed representation "
"of the object contains fewer characters than this width, @code{format} "
"extends it with padding.  The width specifier is ignored for the @samp{%%} "
"specification.  Any padding introduced by the width specifier normally "
"consists of spaces inserted on the left:"
msgstr ""

#. type: example
#: strings.texi.orig:848
#, no-wrap
msgid ""
"(format \"%5d is padded on the left with spaces\" 123)\n"
"     @result{} \"  123 is padded on the left with spaces\"\n"
msgstr ""

#. type: Plain text
#: strings.texi.orig:859
msgid ""
"If the width is too small, @code{format} does not truncate the object's "
"printed representation.  Thus, you can use a width to specify a minimum "
"spacing between columns with no risk of losing information.  In the "
"following three examples, @samp{%7s} specifies a minimum width of 7.  In the "
"first case, the string inserted in place of @samp{%7s} has only 3 letters, "
"and needs 4 blank spaces as padding.  In the second case, the string "
"@code{\"specification\"} is 13 letters wide but is not truncated."
msgstr ""

#. type: group
#: strings.texi.orig:868
#, no-wrap
msgid ""
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `    foo' has 3 letters in it.\"\n"
"(format \"The word `%7s' has %d letters in it.\"\n"
"        \"specification\" (length \"specification\"))\n"
"     @result{} \"The word `specification' has 13 letters in it.\"\n"
msgstr ""

#. type: cindex
#: strings.texi.orig:871
#, no-wrap
msgid "flags in format specifications"
msgstr ""

#. type: Plain text
#: strings.texi.orig:874
msgid ""
"Immediately after the @samp{%} and before the optional width specifier, you "
"can also put certain @dfn{flag characters}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:882
msgid ""
"The flag @samp{+} inserts a plus sign before a positive number, so that it "
"always has a sign.  A space character as flag inserts a space before a "
"positive number.  (Otherwise, positive numbers start with the first digit.)  "
"These flags are useful for ensuring that positive numbers and negative "
"numbers use the same number of columns.  They are ignored except for "
"@samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}, and if both flags are used, "
"@samp{+} takes precedence."
msgstr ""

#. type: Plain text
#: strings.texi.orig:889
msgid ""
"The flag @samp{#} specifies an ``alternate form'' which depends on the "
"format in use.  For @samp{%o}, it ensures that the result begins with a "
"@samp{0}.  For @samp{%x} and @samp{%X}, it prefixes the result with "
"@samp{0x} or @samp{0X}.  For @samp{%e}, @samp{%f}, and @samp{%g}, the "
"@samp{#} flag means include a decimal point even if the precision is zero."
msgstr ""

#. type: Plain text
#: strings.texi.orig:895
msgid ""
"The flag @samp{0} ensures that the padding consists of @samp{0} characters "
"instead of spaces.  This flag is ignored for non-numerical specification "
"characters like @samp{%s}, @samp{%S} and @samp{%c}.  These specification "
"characters accept the @samp{0} flag, but still pad with @emph{spaces}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:900
msgid ""
"The flag @samp{-} causes the padding inserted by the width specifier, if "
"any, to be inserted on the right rather than the left.  If both @samp{-} and "
"@samp{0} are present, the @samp{0} flag is ignored."
msgstr ""

#. type: group
#: strings.texi.orig:905
#, no-wrap
msgid ""
"(format \"%06d is padded on the left with zeros\" 123)\n"
"     @result{} \"000123 is padded on the left with zeros\"\n"
"\n"
msgstr ""

#. type: group
#: strings.texi.orig:908
#, no-wrap
msgid ""
"(format \"%-6d is padded on the right\" 123)\n"
"     @result{} \"123    is padded on the right\"\n"
"\n"
msgstr ""

#. type: group
#: strings.texi.orig:912
#, no-wrap
msgid ""
"(format \"The word `%-7s' actually has %d letters in it.\"\n"
"        \"foo\" (length \"foo\"))\n"
"     @result{} \"The word `foo    ' actually has 3 letters in it.\"\n"
msgstr ""

#. type: cindex
#: strings.texi.orig:915
#, no-wrap
msgid "precision in format specifications"
msgstr ""

#. type: Plain text
#: strings.texi.orig:926
msgid ""
"All the specification characters allow an optional @dfn{precision} before "
"the character (after the width, if present).  The precision is a "
"decimal-point @samp{.} followed by a digit-string.  For the floating-point "
"specifications (@samp{%e}, @samp{%f}, @samp{%g}), the precision specifies "
"how many decimal places to show; if zero, the decimal-point itself is also "
"omitted.  For @samp{%s} and @samp{%S}, the precision truncates the string to "
"the given width, so @samp{%.3s} shows only the first three characters of the "
"representation for @var{object}.  Precision has no effect for other "
"specification characters."
msgstr ""

#. type: section
#: strings.texi.orig:928
#, no-wrap
msgid "Case Conversion in Lisp"
msgstr ""

#. type: cindex
#: strings.texi.orig:929
#, no-wrap
msgid "upper case"
msgstr ""

#. type: cindex
#: strings.texi.orig:930
#, no-wrap
msgid "lower case"
msgstr ""

#. type: cindex
#: strings.texi.orig:931
#, no-wrap
msgid "character case"
msgstr ""

#. type: cindex
#: strings.texi.orig:932
#, no-wrap
msgid "case conversion in Lisp"
msgstr ""

#. type: Plain text
#: strings.texi.orig:940
msgid ""
"The character case functions change the case of single characters or of the "
"contents of strings.  The functions normally convert only alphabetic "
"characters (the letters @samp{A} through @samp{Z} and @samp{a} through "
"@samp{z}, as well as non-@acronym{ASCII} letters); other characters are not "
"altered.  You can specify a different case conversion mapping by specifying "
"a case table (@pxref{Case Tables})."
msgstr ""

#. type: Plain text
#: strings.texi.orig:943
msgid ""
"These functions do not modify the strings that are passed to them as "
"arguments."
msgstr ""

#. type: Plain text
#: strings.texi.orig:946
msgid ""
"The examples below use the characters @samp{X} and @samp{x} which have "
"@acronym{ASCII} codes 88 and 120 respectively."
msgstr ""

#. type: defun
#: strings.texi.orig:947
#, no-wrap
msgid "downcase string-or-char"
msgstr ""

#. type: defun
#: strings.texi.orig:950
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to lower case."
msgstr ""

#. type: defun
#: strings.texi.orig:957
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is upper case is converted to lower "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding lower case character (an integer); if the original character "
"is lower case, or is not a letter, the return value is equal to the original "
"character."
msgstr ""

#. type: example
#: strings.texi.orig:961
#, no-wrap
msgid ""
"(downcase \"The cat in the hat\")\n"
"     @result{} \"the cat in the hat\"\n"
"\n"
msgstr ""

#. type: example
#: strings.texi.orig:964
#, no-wrap
msgid ""
"(downcase ?X)\n"
"     @result{} 120\n"
msgstr ""

#. type: defun
#: strings.texi.orig:967
#, no-wrap
msgid "upcase string-or-char"
msgstr ""

#. type: defun
#: strings.texi.orig:970
msgid ""
"This function converts @var{string-or-char}, which should be either a "
"character or a string, to upper case."
msgstr ""

#. type: defun
#: strings.texi.orig:977
msgid ""
"When @var{string-or-char} is a string, this function returns a new string in "
"which each letter in the argument that is lower case is converted to upper "
"case.  When @var{string-or-char} is a character, this function returns the "
"corresponding upper case character (an integer); if the original character "
"is upper case, or is not a letter, the return value is equal to the original "
"character."
msgstr ""

#. type: example
#: strings.texi.orig:981
#, no-wrap
msgid ""
"(upcase \"The cat in the hat\")\n"
"     @result{} \"THE CAT IN THE HAT\"\n"
"\n"
msgstr ""

#. type: example
#: strings.texi.orig:984
#, no-wrap
msgid ""
"(upcase ?x)\n"
"     @result{} 88\n"
msgstr ""

#. type: defun
#: strings.texi.orig:987
#, no-wrap
msgid "capitalize string-or-char"
msgstr ""

#. type: cindex
#: strings.texi.orig:988
#, no-wrap
msgid "capitalization"
msgstr ""

#. type: defun
#: strings.texi.orig:995
msgid ""
"This function capitalizes strings or characters.  If @var{string-or-char} is "
"a string, the function returns a new string whose contents are a copy of "
"@var{string-or-char} in which each word has been capitalized.  This means "
"that the first character of each word is converted to upper case, and the "
"rest are converted to lower case."
msgstr ""

#. type: defun
#: strings.texi.orig:999 strings.texi.orig:1031
msgid ""
"The definition of a word is any sequence of consecutive characters that are "
"assigned to the word constituent syntax class in the current syntax table "
"(@pxref{Syntax Class Table})."
msgstr ""

#. type: defun
#: strings.texi.orig:1002
msgid ""
"When @var{string-or-char} is a character, this function does the same thing "
"as @code{upcase}."
msgstr ""

#. type: group
#: strings.texi.orig:1007
#, no-wrap
msgid ""
"(capitalize \"The cat in the hat\")\n"
"     @result{} \"The Cat In The Hat\"\n"
msgstr ""

#. type: group
#: strings.texi.orig:1012
#, no-wrap
msgid ""
"(capitalize \"THE 77TH-HATTED CAT\")\n"
"     @result{} \"The 77th-Hatted Cat\"\n"
msgstr ""

#. type: group
#: strings.texi.orig:1017
#, no-wrap
msgid ""
"(capitalize ?x)\n"
"     @result{} 88\n"
msgstr ""

#. type: defun
#: strings.texi.orig:1021
#, no-wrap
msgid "upcase-initials string-or-char"
msgstr ""

#. type: defun
#: strings.texi.orig:1027
msgid ""
"If @var{string-or-char} is a string, this function capitalizes the initials "
"of the words in @var{string-or-char}, without altering any letters other "
"than the initials.  It returns a new string whose contents are a copy of "
"@var{string-or-char}, in which each word has had its initial letter "
"converted to upper case."
msgstr ""

#. type: defun
#: strings.texi.orig:1034
msgid ""
"When the argument to @code{upcase-initials} is a character, "
"@code{upcase-initials} has the same result as @code{upcase}."
msgstr ""

#. type: group
#: strings.texi.orig:1039
#, no-wrap
msgid ""
"(upcase-initials \"The CAT in the hAt\")\n"
"     @result{} \"The CAT In The HAt\"\n"
msgstr ""

#. type: Plain text
#: strings.texi.orig:1045
msgid ""
"@xref{Text Comparison}, for functions that compare strings; some of them "
"ignore case differences, or can optionally ignore case differences."
msgstr ""

#. type: section
#: strings.texi.orig:1047
#, no-wrap
msgid "The Case Table"
msgstr ""

#. type: Plain text
#: strings.texi.orig:1056
msgid ""
"You can customize case conversion by installing a special @dfn{case table}.  "
"A case table specifies the mapping between upper case and lower case "
"letters.  It affects both the case conversion functions for Lisp objects "
"(see the previous section) and those that apply to text in the buffer "
"(@pxref{Case Changes}).  Each buffer has a case table; there is also a "
"standard case table which is used to initialize the case table of new "
"buffers."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1061
msgid ""
"A case table is a char-table (@pxref{Char-Tables}) whose subtype is "
"@code{case-table}.  This char-table maps each character into the "
"corresponding lower case character.  It has three extra slots, which hold "
"related tables:"
msgstr ""

#. type: item
#: strings.texi.orig:1063
#, no-wrap
msgid "upcase"
msgstr ""

#. type: table
#: strings.texi.orig:1066
msgid ""
"The upcase table maps each character into the corresponding upper case "
"character."
msgstr ""

#. type: item
#: strings.texi.orig:1066
#, no-wrap
msgid "canonicalize"
msgstr ""

#. type: table
#: strings.texi.orig:1069
msgid ""
"The canonicalize table maps all of a set of case-related characters into a "
"particular member of that set."
msgstr ""

#. type: item
#: strings.texi.orig:1069
#, no-wrap
msgid "equivalences"
msgstr ""

#. type: table
#: strings.texi.orig:1072
msgid ""
"The equivalences table maps each one of a set of case-related characters "
"into the next character in that set."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1076
msgid ""
"In simple cases, all you need to specify is the mapping to lower-case; the "
"three related tables will be calculated automatically from that one."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1081
msgid ""
"For some languages, upper and lower case letters are not in one-to-one "
"correspondence.  There may be two different lower case letters with the same "
"upper case equivalent.  In these cases, you need to specify the maps for "
"both lower case and upper case."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1088
msgid ""
"The extra table @var{canonicalize} maps each character to a canonical "
"equivalent; any two characters that are related by case-conversion have the "
"same canonical equivalent character.  For example, since @samp{a} and "
"@samp{A} are related by case-conversion, they should have the same canonical "
"equivalent character (which should be either @samp{a} for both of them, or "
"@samp{A} for both of them)."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1094
msgid ""
"The extra table @var{equivalences} is a map that cyclically permutes each "
"equivalence class (of characters with the same canonical equivalent).  (For "
"ordinary @acronym{ASCII}, this would map @samp{a} into @samp{A} and @samp{A} "
"into @samp{a}, and likewise for each set of equivalent characters.)"
msgstr ""

#. type: Plain text
#: strings.texi.orig:1102
msgid ""
"When constructing a case table, you can provide @code{nil} for "
"@var{canonicalize}; then Emacs fills in this slot from the lower case and "
"upper case mappings.  You can also provide @code{nil} for "
"@var{equivalences}; then Emacs fills in this slot from @var{canonicalize}.  "
"In a case table that is actually in use, those components are "
"non-@code{nil}.  Do not try to specify @var{equivalences} without also "
"specifying @var{canonicalize}."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1104
msgid "Here are the functions for working with case tables:"
msgstr ""

#. type: defun
#: strings.texi.orig:1105
#, no-wrap
msgid "case-table-p object"
msgstr ""

#. type: defun
#: strings.texi.orig:1108
msgid "This predicate returns non-@code{nil} if @var{object} is a valid case table."
msgstr ""

#. type: defun
#: strings.texi.orig:1110
#, no-wrap
msgid "set-standard-case-table table"
msgstr ""

#. type: defun
#: strings.texi.orig:1113
msgid ""
"This function makes @var{table} the standard case table, so that it will be "
"used in any buffers created subsequently."
msgstr ""

#. type: defun
#: strings.texi.orig:1115
#, no-wrap
msgid "standard-case-table"
msgstr ""

#. type: defun
#: strings.texi.orig:1117
msgid "This returns the standard case table."
msgstr ""

#. type: defun
#: strings.texi.orig:1119
#, no-wrap
msgid "current-case-table"
msgstr ""

#. type: defun
#: strings.texi.orig:1121
msgid "This function returns the current buffer's case table."
msgstr ""

#. type: defun
#: strings.texi.orig:1123
#, no-wrap
msgid "set-case-table table"
msgstr ""

#. type: defun
#: strings.texi.orig:1125
msgid "This sets the current buffer's case table to @var{table}."
msgstr ""

#. type: defmac
#: strings.texi.orig:1127
#, no-wrap
msgid "with-case-table table body@dots{}"
msgstr ""

#. type: defmac
#: strings.texi.orig:1134
msgid ""
"The @code{with-case-table} macro saves the current case table, makes "
"@var{table} the current case table, evaluates the @var{body} forms, and "
"finally restores the case table.  The return value is the value of the last "
"form in @var{body}.  The case table is restored even in case of an abnormal "
"exit via @code{throw} or error (@pxref{Nonlocal Exits})."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1145
msgid ""
"Some language environments modify the case conversions of @acronym{ASCII} "
"characters; for example, in the Turkish language environment, the "
"@acronym{ASCII} character @samp{I} is downcased into a Turkish ``dotless "
"i''.  This can interfere with code that requires ordinary @acronym{ASCII} "
"case conversion, such as implementations of @acronym{ASCII}-based network "
"protocols.  In that case, use the @code{with-case-table} macro with the "
"variable @var{ascii-case-table}, which stores the unmodified case table for "
"the @acronym{ASCII} character set."
msgstr ""

#. type: defvar
#: strings.texi.orig:1146
#, no-wrap
msgid "ascii-case-table"
msgstr ""

#. type: defvar
#: strings.texi.orig:1149
msgid ""
"The case table for the @acronym{ASCII} character set.  This should not be "
"modified by any language environment settings."
msgstr ""

#. type: Plain text
#: strings.texi.orig:1156
msgid ""
"The following three functions are convenient subroutines for packages that "
"define non-@acronym{ASCII} character sets.  They modify the specified case "
"table @var{case-table}; they also modify the standard syntax table.  "
"@xref{Syntax Tables}.  Normally you would use these functions to change the "
"standard case table."
msgstr ""

#. type: defun
#: strings.texi.orig:1157
#, no-wrap
msgid "set-case-syntax-pair uc lc case-table"
msgstr ""

#. type: defun
#: strings.texi.orig:1160
msgid ""
"This function specifies a pair of corresponding letters, one upper case and "
"one lower case."
msgstr ""

#. type: defun
#: strings.texi.orig:1162
#, no-wrap
msgid "set-case-syntax-delims l r case-table"
msgstr ""

#. type: defun
#: strings.texi.orig:1165
msgid ""
"This function makes characters @var{l} and @var{r} a matching pair of "
"case-invariant delimiters."
msgstr ""

#. type: defun
#: strings.texi.orig:1167
#, no-wrap
msgid "set-case-syntax char syntax case-table"
msgstr ""

#. type: defun
#: strings.texi.orig:1170
msgid "This function makes @var{char} case-invariant, with syntax @var{syntax}."
msgstr ""

#. type: deffn
#: strings.texi.orig:1172
#, no-wrap
msgid "Command describe-buffer-case-table"
msgstr ""

#. type: deffn
#: strings.texi.orig:1175
msgid ""
"This command displays a description of the contents of the current buffer's "
"case table."
msgstr ""
