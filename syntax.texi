@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Syntax Tables
@chapter Syntax Tables
@cindex parsing buffer text
@cindex syntax table
@cindex text parsing

  @dfn{構文テーブル(syntax
table)}は、バッファー内のそれぞれの文字にたいして、構文的な役割を指定します。単語、シンボル、その他の構文要素の開始と終了の判定に、これを使用できます。この情報はFont
Lockモード(@ref{Font Lock
Mode}を参照)や、種々の複雑な移動コマンド(@ref{Motion}を参照)を含む、多くのEmacs機能により使用されます。

@menu
* Basics: Syntax Basics.     構文テーブルの基本的概念。
* Syntax Descriptors::       文字がクラス分けされる方法。
* Syntax Table Functions::   構文テーブルを作成、調査、変更する方法。
* Syntax Properties::        テキストプロパティによる構文テーブルのオーバーライド。
* Motion and Syntax::        特定の構文による文字間の移動。
* Parsing Expressions::      構文テーブル使用によるバランスのとれた式の解析。
* Syntax Table Internals::   構文テーブルの情報が格納される方法。
* Categories::               文字構文をクラス分けする別の手段。
@end menu

@node Syntax Basics
@section Syntax Table Concepts

  構文テーブルとは、それぞれの文字の@dfn{構文クラス(syntax
class)}や、その他の構文的プロパティを照合するために使用できる、データ構造のことです。構文テーブルは、テキストを横断したスキャンや移動のために、Lispプログラムにより使用されます。

  構文テーブルは、内部的には文字テーブルです(@ref{Char-Tables}を参照)。インデックス@var{c}の要素はコード@var{c}の文字を記述します。値は該当する文字の構文を指定するコンスセルです。詳細は@xref{Syntax
Table
Internals}を参照してください。しかし構文テーブルの内容を変更または調べるために@code{aset}や@code{aref}を使用するかわりに、通常は高レベルな関数@code{char-syntax}や@code{modify-syntax-entry}を使用するべきです。これらについては@ref{Syntax
Table Functions}で説明します。

@defun syntax-table-p object
この関数は@var{object}が構文テーブルなら、@code{t}をリターンする。
@end defun

  バッファーはそれぞれ自身のメジャーモードをもち、それぞれのメジャーモードはさまざまな文字の構文クラスにたいして独自のアイデアをもっています。たとえばLisモードでは文字@samp{;}はコメントの開始ですが、Cモードでは命令文の終端になります。これらのバリエーションをサポートするために、構文テーブルはそれぞれのバッファーにたいしてローカルです。一般的に各メジャーモードは自身の構文テーブルをもち、そのモードを使用するすべてのバッファーにそれがインストールされます。たとえば変数@code{emacs-lisp-mode-syntax-table}はEmacsのLispモードが使用する構文テーブル、@code{c-mode-syntax-table}はCモードが使用する構文テーブルを保持します。あるメジャーモードの構文テーブルを変更すると、そのモードのバッファー、およびその後でそのモードに置かれるすべてのバッファーの構文も同様に変更されます。複数の類似するモードが1つの構文テーブルを共有することが、ときおりあります。構文テーブルをセットアップする方法の例は、@ref{Example
Major Modes}を参照してください。

@cindex standard syntax table
@cindex inheritance, syntax table
  別の構文テーブルから構文テールを@dfn{継承(inherit)}できます。これを@dfn{親構文テーブル(parent syntax
table)}と呼びます。構文テーブルは、ある文字にたいして構文クラス``inherit''を与えることにより、構文クラスを未指定にしておくことができます。そのような文字は、親構文テーブルが指定する構文クラスを取得します(@ref{Syntax
Class Table}を参照)。Emacsは@dfn{標準構文テーブル(standard syntax
table)}を定義します。これはデフォルトとなる親構文テーブルであり、Fundamentalモードが使用する構文テーブルでもあります。

@defun standard-syntax-table
この関数はFundamentalモードが使用する構文テーブルである、標準構文テーブルをリターンする。
@end defun

  Emacs
Lispリーダーは変更不可な独自のビルトイン構文ルールをもつので、構文テーブルは使用しません(いくつかのLispシステムはリード構文を再定義する手段を提供するが、わたしたちは単純化のためこの機能をEmacs
Lisp外部に留める決定をした)。

@node Syntax Descriptors
@section Syntax Descriptors
@cindex syntax class

  @dfn{構文クラス(syntax
class)}の文字は、その文字の構文的な役割を記述します。各構文テーブルは、それぞれの文字の構文クラスを指定します。ある構文テーブルでの文字のクラスと、別のテーブルにおけるその文字のクラスとの間に関連性がある必要はありません。

  構文テーブルはそれぞれニーモニック文字(mnemonic
character)により選別され、クラスを指定する必要がある際にはそのクラスの名前としての役割を果たします。この指定子文字(designator
character)は通常、そのクラスに割当てられることが多々あります。しかしその指定子としての意味は不変であり、その文字がカレントでもつ構文とは独立しています。つまりカレント構文テーブルにおいて実際に文字@samp{\}が構文をもつかどうかに関係なく、指定子文字としての@samp{\}は常に``エスケープ文字(escape
characte)r''を意味します。
@ifnottex
構文クラスとそれらの指定子文字のリストは、@ref{Syntax Class Table}を参照してください。
@end ifnottex

@cindex syntax descriptor
  @dfn{構文記述子(syntax
descriptor)}とは、文字の構文クラスと、その他の構文的なプロパティを記述するLisp文字列のことです。ある文字の構文を変更したい際、それは関数@code{modify-syntax-entry}を呼び出して、その引数に構文記述子を渡すことにより行われます(@ref{Syntax
Table Functions}を参照)。

  構文記述子の1つ目の文字は、構文クラスの指定子文字でなければなりません。2つ目の文字がもしあれば、マッチング文字を指定します(Lispでは@samp{(}にたいするマッチング文字は@samp{)})。スペースはマッチング文字が存在しないことを指定します。その後に続く文字は、追加の構文プロパティを指定します(@ref{Syntax
Flags}を参照)。

  マッチング文字やフラグが必要なければ、(構文クラスを指定する)1つの文字だけで十分です。

  たとえばCモードでの文字@samp{*}の構文記述子は@code{".
23"}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の2つ目の文字、コメント終了記号の1つ目の文字)、@samp{/}にたいするエントリーは@samp{@w{.
14}}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の1つ目の文字、コメント終了記号の2つ目の文字)です。

  Emacsは、低レベルでの構文クラスを記述するために使用される@dfn{raw構文記述子(raw syntax
descriptors)}も定義しています。@ref{Syntax Table Internals}を参照してください。

@menu
* Syntax Class Table::       構文クラスのテーブル。
* Syntax Flags::             各文字が所有できる追加のフラグ。
@end menu

@node Syntax Class Table
@subsection Table of Syntax Classes
@cindex syntax class table

  以下は構文クラス、それらの指定子となる文字とそれらの意味、およびそれらの使用例を示すテーブルです。

@table @asis
@item 空白文字: @samp{@ }、または@samp{-}
シンボルおよび単語を区別する文字。空白文字は通常は他の構文的な意義をもたず、複数の空白文字は構文的には単一の空白文字と等しい。スペース、タブ、フォームフィードは、ほとんどすべてのメジャーモードにおいて空白文字にクラスっ分けされる。

この構文クラスは@w{@samp{@ }}または@samp{-}により指定できる。両指定子は等価である。

@item 単語構成文字: @samp{w}
人間の言語における単語の一部。これらは通常は、プログラム内において変数やコマンドの名前として使用される。通常、すべての大文字と小文字、および数字は単語構成文字である。

@item シンボル構成文字: @samp{_}
単語構成文字とともに変数やコマンドの名前で使用される、追加の文字。例としてはLispモードの文字@samp{$&*+-_<>}が含まれ、これらはたとえ英単語の一部でないとしても、シンボルの名前の一部となり得る。標準Cでは、シンボル内において非単語構成文字で有効な文字はアンダースコア(@samp{_})だけである。

@item 区切り文字: @samp{.}
人間の言語において句読点として使用される文字、またはプログラミング言語でシンボルを別のシンボルと区別するために使用される文字。Emacs
Lispモードのようないくつかのプログラミング言語のモードでは、単語構成文字およびシンボル構成文字のいずれでもないいくつかの文字はすべて、他の用途をもつので、このクラスの文字をもたない。Cモードのような他のプログラミング言語のモードでは、演算子にたいして区切り文字構文が使用される。

@item 開カッコ文字: @samp{(}
@itemx 閉カッコ文字: @samp{)}
文や式を囲うために、異なるペアーとして使用される文字。そのようなグループ化は開カッコで開始され、閉カッコで終了する。開カッコ文字はそれぞれ特定の閉カッコ文字にマッチし、その逆も成り立つ。Emacsqは通常、閉カッコ挿入字に、マッチする開カッコを示す。@ref{Blinking}を参照のこと。

人間の言語、およびCのコードではカッコのペアーは@samp{()}、@samp{[]}、@samp{@{@}}である。Emacs
Lispではリストとベクターにたいする区切り文字(@samp{()}および@samp{[]})は、カッコ文字としてクラス分けされる。

@item 文字列クォート: @samp{"}
文字列定数を区切るために使用される文字。文字列の先頭と終端に、同じ文字列クォート文字が出現する。このようなクォート文字列はネストされない。

Emacsのパース機能は、文字列を単一のトークンとみなす。文字列内では、その文字の通常の構文的な意味は抑制される。

Lispモードはダブルクォーテーション(@samp{"})、および垂直バー(@samp{|})とう、2つの文字列クォート文字をもつ。Emacs
Lispでは@samp{|}は使用しないが、Common
Lispでは使用される。Cも文字列にたいするダブルクォート文字、および文字定数にたいするシングルクォート文字(@samp{'})という、2つのクォート文字をもつ。

人間用のテキストには文字列クォート文字がない。そのクォーテーション内の別の文字の通常の構文的プロパティを、クォーテーションマークがオフに切り替えるのを、わたしたちは望まない。

@item エスケープ構文文字: @samp{\}
文字列や文字定数内で使用されるような、エスケープシーケンスで始まる文字。CとLispの両方で、文字@samp{\}はこのクラスに属する(Cでは文字列内でのみ使用されるが、Cコード中を通じてこのように扱っても問題ないことがわかった)。

@code{words-include-escapes}が非@code{nil}な、このクラスの文字は単語の一部とみなされる。@ref{Word
Motion}を参照のこと。

@item 文字クォート: @samp{/}
その文字の通常の構文的な意義を失うよう、後続の文字をクォートするために使用される文字。これは直後に続く文字だけに影響する点が、エスケープ文字と異なる。

@code{words-include-escapes}が非@code{nil}な、このクラスの文字は単語の一部とみなされる。@ref{Word
Motion}を参照のこと。

このクラスは@TeX{}モードのバックスラッシュにたいして使用される。

@item 区切りペアー: @samp{$}
文字列クォート文字と似ているが、この区切りの間にある文字の構文的なプロパティは抑制されない点が異なる。現在のところ@TeX{}モードだけが区切りペアーを使用する(@samp{$}によりmathモードに出入りする)。

@item 式プレフィクス: @samp{'}
式に隣接して出現した場合に、その式の一部とみなされる、構文的演算子にたいして使用される文字。Lispモードではアポストロフィー@samp{'}(クォートに使用)、カンマ@samp{,}(マクロに使用)、@samp{#}(特定のデータ型にたいするリード構文として使用)が、これらの文字に含まれる。

@item コメント開始文字: @samp{<}
@itemx コメント終了文字: @samp{>}
@cindex comment syntax
さまざまな言語において、コメントを区切るために使用する文字。人間用のテキストはコメント文字をもたない。Lispでは、セミコロン(@samp{;})がコメントの開始で、改行かフォームフィードで終了する。

@item 標準構文の継承: @samp{@@}
この構文クラスは、特定の構文を指定しない。これは、その文字の構文を探すために標準構文テーブルを照合するよう告げる。

@item 汎用コメント区切り: @samp{!}
特殊なコメントを開始または終了させる文字。@emph{任意}の汎用コメント区切りは、@emph{任意}の汎用コメント区切りにマッチするが、コメント開始とコメント終了とはマッチできない。汎用コメント区切りは、汎用コメント区切り同士としかマッチできない。

この構文クラスは主として@code{syntax-table}テキストプロパティ(@ref{Syntax
Properties}を参照)とともに使用することを意図している。任意の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それらが汎用コメント区切りであることを示す@code{syntax-table}プロパティを付与することにより、その範囲がコメントを形成するとマークすることができる。

@item 汎用文字列区切り: @samp{|}
文字列を開始または終了させる文字。@emph{任意}の汎用文字列区切りは、@emph{任意}の汎用文字列区切りにマッチするが、通常の文字列クォート文字とはマッチできない。

この構文クラスは主として@code{syntax-table}テキストプロパティ(@ref{Syntax
Properties}を参照)とともに使用することを意図している。任意の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それらが汎用文字列区切りであることを示す@code{syntax-table}プロパティを付与することにより、その範囲が文字列定数を形成するとマークすることができる。
@end table

@node Syntax Flags
@subsection Syntax Flags
@cindex syntax flags

  構文テーブル内の文字全体にたいして、構文クラスに加えてフラグを指定できます。利用できる8つのフラグがあり、それらは文字@samp{1}、@samp{2}、@samp{3}、@samp{4}、@samp{b}、@samp{c}、@samp{n}、@samp{p}で表されます。

  @samp{p}を除くすべてのフラグは、コメント区切りを記述するために使用されます。数字のフラグは2文字から構成されるコメント区切りにたいして使用されます。これらは、文字の文字クラスに関連付けられた構文的プロパティに加えて、その文字も@emph{同様}にコメントシーケンスの一部となれることを示します。Cモードでは区切り文字であり、@emph{かつ}コメントシーケンス開始(@samp{/*})の2文字目であり、@emph{かつ}コメントシーケンス終了(@samp{*/})の1文字目である@samp{*}のような文字のために、フラグとクラスは互いに独立しています。フラグ@samp{b}、@samp{c}、@samp{n}は対応するコメント区切りを限定するために使用されます。

  以下は文字@var{c}にたいして利用できるフラグと、それらの意味を示すテーブルです:

@itemize @bullet
@item
@samp{1}は、@var{c}が2文字からなるコメント開始シーケンスの開始であることを意味する。

@item
@samp{2}は、@var{c}がそのようなシーケンスの2文字目であることを意味する。

@item
@samp{3}は、@var{c}が2文字からなるコメント終了シーケンスの開始であることを意味する。

@item
@samp{4}は、@var{c}がそのようなシーケンスの2文字目であることを意味する。

@item
@samp{b}は、@var{c}が代替えのコメントスタイル``b''に属するコメント区切りであることを意味する。このフラグは2文字のコメント開始では2文字目、2文字のコメント終了では1文字目にたいしてのみ意味をもつ。

@item
@samp{c}は、@var{c}が代替えのコメントスタイル``c''に属するコメント区切りであることを意味する。2文字からなるコメント区切りにたいしては、そのいずれかが@samp{c}であればスタイル``c''となる。

@item
コメント区切り文字での@samp{n}は、この種のコメントがネスト可能であることを指定する。2文字からなるコメント区切りにたいしては、そのいずれかが@samp{n}であればネスト可能となる。

@cindex comment style
Emacsは任意の構文テーブル1つにたいして、同時に複数のコメントスタイルをサポートする。コメントスタイルはフラグ@samp{b}、@samp{c}、@samp{n}の組み合わせなので、8個の異なるコメントスタイルが可能である。コメント区切りはそれぞれスタイルをもち、同じスタイルのコメント区切りとのみマッチできる。つまりコメントがスタイル``bn''のコメント開始シーケンスで開始されるなら、そのコメントは次のスタイル``bn''のコメント終了シーケンスにマッチするまで拡張されるだろう。

C++にたいして適切なコメント構文は、以下のようになる:

@table @asis
@item @samp{/}
@samp{124}
@item @samp{*}
@samp{23b}
@item newline
@samp{>}
@end table

これは4つのコメント区切りシーケンスを定義する:

@table @asis
@item @samp{/*}
これは2文字目の@samp{*}が@samp{b}フラグをもつので、``b''スタイルのコメント開始シーケンスである。

@item @samp{//}
これは2文字目の@samp{/}が@samp{b}フラグをもたないので、``a''スタイルのコメント開始シーケンスである。

@item @samp{*/}
これは1文字目の@samp{*}が@samp{b}フラグをもつので、``b''スタイルのコメント終了シーケンスである。

@item newline
これは改行▼文字が@samp{b}フラグをもたないので、``a''スタイルのコメント終了シーケンスである。
@end table

@item
@samp{p}はLisp構文にたいして、追加のプレフィクス文字を識別する。これらが式の間に出現した際は、空白文字として扱われる。これらが式の内部に出現したときは、それらの通常の構文クラスに応じて処理される。

関数@code{backward-prefix-chars}はこれらの文字と、同様にメインの構文クラスがプレフィクスであるような文字(@samp{'})を超えて、後方に移動する。@ref{Motion
and Syntax}を参照のこと。
@end itemize

@node Syntax Table Functions
@section Syntax Table Functions

  このセクションでは、構文テーブルを作成、アクセス、変更する関数を説明します。

@defun make-syntax-table &optional table
この関数は、新たに構文テーブルを作成する。@var{table}が非@code{nil}なら、新たな構文テーブルの親は@var{table}、それ以外なら標準構文テーブルが親になる。

新たな構文テーブルでは最初は、すべての文字に構文クラス``inherit''(@samp{@@})が与えられ、それらの構文は親テーブルから継承される(@ref{Syntax
Class Table}を参照)。
@end defun

@defun copy-syntax-table &optional table
この関数は@var{table}のコピーを構築して、それをリターンする。@var{table}が省略または@code{nil}なら、標準構文テーブルのコピーをリターンする。それ以外の場合、@var{table}が構文テーブルでなければエラーをシグナルする。
@end defun

@deffn Command modify-syntax-entry char syntax-descriptor  &optional table
@cindex syntax entry, setting
この関数は@var{syntax-descriptor}に応じて、@var{char}の構文エントリーをセットする。@var{char}は文字、または@code{(@var{min}
.
@var{max})}という形式のコンスセルでなければならない。後者の場合、この関数は@var{min}と@var{max}(両端を含む)の間のすべての文字にたいして、構文エントリーをセットする。

構文は@var{table}(デフォルトはカレントバッファーの構文テーブル)にたいしてのみ変更され、他のすべての構文テーブルにたいしては変更されない。

引数@var{syntax-descriptor}は構文記述子、すなわち1文字目が構文クラス指定子、2文字目以降がオプションでマッチング文字と構文フラグを指定する文字列である。@ref{Syntax
Descriptors}を参照のこと。@var{syntax-descriptor}が有効な構文記述子でなければ、エラーがシグナルされる。

この関数は、常に@code{nil}をリターンする。この文字にたいするテーブル内の古い構文情報は、破棄される。

@example
@group
@exdent @r{▼例:}

;; @r{空白文字クラスのスペースをputする}
(modify-syntax-entry ?\s " ")
     @result{} nil
@end group

@group
;; @r{@samp{$}を開カッコ文字にして、}
;;   @r{@samp{^}を対応する閉カッコにする}
(modify-syntax-entry ?$ "(^")
     @result{} nil
@end group

@group
;; @r{@samp{^}閉カッコ文字にして}
;;   @r{@samp{$}を対応する開カッコにする}
(modify-syntax-entry ?^ ")$")
     @result{} nil
@end group

@group
;; @r{@samp{/}を区切り文字で}
;;   @r{コメント開始シーケンス1文字目、}
;;   @r{かつコメント終了シーケンス2文字目とする}
;;   @r{これはCモードで使用される}
(modify-syntax-entry ?/ ". 14")
     @result{} nil
@end group
@end example
@end deffn

@defun char-syntax character
この関数は、指定子文字(@ref{Syntax Class
Table}を参照)の表現で、@var{character}の構文クラスをリターンする。これはクラス@emph{だけ}をリターンし、マッチング文字や構文フラグはリターンしない。

以下をCモードにたいして適用してみる(@code{char-syntax}がリターンする文字を確認しやすいよう@code{string}を使用する)。

@example
@group
;; スペース文字は空白文字構文クラスをもつ
(string (char-syntax ?\s))
     @result{} " "
@end group

@group
;; スラッシュ文字は区切り文字構文をもつ。
;; コメント開始やコメント終了シーケンスの一部でもある場合、
;; @code{char-syntax}呼び出しはこれを明らかにしないことに注意。
(string (char-syntax ?/))
     @result{} "."
@end group

@group
;; 開カッコ文字は開カッコ構文をもつ。
;; これがまっちんぐ文字@samp{)}をもつことは
;; @code{char-syntax}呼び出しでは明らかにならないことに注意。
(string (char-syntax ?\())
     @result{} "("
@end group
@end example

@end defun

@defun set-syntax-table table
この関数は、カレントバッファーの構文テーブルを@var{table}にする。これは@var{table}をリターンする。
@end defun

@defun syntax-table
この関数はカレント構文テーブル(カレントバッファーのテーブル)をリターンする。
@end defun

@deffn Command describe-syntax &optional buffer
このコマンドは、@var{buffer}(デフォルトはカレントバッファー)の構文テーブルのコンテンツをhelpバッファーに表示する。
@end deffn

@defmac with-syntax-table table body@dots{}
このまくろは@var{table}をカレント構文テーブルとして使用して、@var{body}を実行する。これは古いカレント構文テーブルのリストア後に、@var{body}の最後のフォームの値をリターンする。

各バッファーは独自にカレント構文テーブルをもつので、マクロはこれを入念に行う。@code{with-syntax-table}はマクロ実行開始時、そのときカレントのバッファーが何であれ、カレント構文テーブルを一時的に変更する。他のバッファーは影響を受けない。
@end defmac

@node Syntax Properties
@section Syntax Properties
@kindex syntax-table @r{(text property)}

ある言語の構文を指定するのに構文テーブルが十分に柔軟でないときは、
バッファー内に出現する特定の文字にたいして、テキストプロパティ@code{syntax-table}を適用することにより、構文テーブルをオーバーライドできます。テキストプロパティを適用する方法については、@ref{Text
Properties}を参照してください。

  以下はテキストプロパティ@code{syntax-table}の有効な値です:

@table @asis
@item @var{syntax-table}
プロパティの値が構文テーブルなら、根底となるテキスト文字の構文を決定するカレントバッファーの構文テーブルのかわりに、そのテーブルが使用される。

@item @code{(@var{syntax-code} . @var{matching-char})}
この形式のコンスセルは、根底となるテキスト文字の構文クラスを直接指定する、raw構文テーブル(@ref{Syntax Table
Internals}を参照)である。

@item @code{nil}
このプロパティが@code{nil}なら、その文字の構文はカレント構文テーブルにより通常の方法で決定される。
@end table

@defvar parse-sexp-lookup-properties
これが非@code{nil}なら、@code{forward-sexp}のような構文をスキャンする関数は、syntax-tableテキストプロパティに注意を払い、それ以外ならカレント構文テーブルだけを使用する。
@end defvar

@defvar syntax-propertize-function
この変数が非@code{nil}なら、特定のテキスト範囲にたいして@code{syntax-table}プロパティを適用する関数を格納するべきである。これは、モードに適した方法で@code{syntax-table}プロパティを適用する関数をインストールするために、メジャーモードに使用されることを意図している。

この関数は@code{syntax-ppss}(@ref{Position Parse}を参照)、および構文フォント表示化(@ref{Syntactic
Font Lock}を参照)の間にFont
Lockモードにより呼び出される。これは作用すべきテキスト部分の開始@var{start}と終了@var{end}という、2つの引数で呼び出される。これは@var{end}の前の任意の位置で、@code{syntax-ppss}を呼び出すことが許されている。しかし@code{syntax-ppss-flush-cache}を呼び出すべきではなく、そのため、ある位置で@code{syntax-ppss}を呼び出して、後からバッファー内の前の位置を変更することは許されていない。
@end defvar

@defvar syntax-propertize-extend-region-functions
このアブノーマルフックは@code{syntax-propertize-function}呼び出しに先立ち、構文解析コードにより実行される。これは@code{syntax-propertize-function}に渡すための、安全なバッファーの開始および終了位置を見つける助けをする役割をもつ。たとえばメジャーモードは、複数行の構文構成を識別して、境界が複数行の中間にならないよう、このフックに関数を追加できる。

このフック内の各関数は、引数@var{start}と@var{end}を受け取ること。これは2つのバッファー位置を調整するコンスセル@code{(@var{new-start}
.
@var{new-end})}、調整が必要なければ@code{nil}をリターンするべきである。フック関数は、それらすべてが@code{nil}をリターンするまで、順番に繰り返し実行される。
@end defvar

@node Motion and Syntax
@section Motion and Syntax
@cindex moving across syntax classes
@cindex skipping characters of certain syntax

  This section describes functions for moving across characters that have
certain syntax classes.

@defun skip-syntax-forward syntaxes &optional limit
This function moves point forward across characters having syntax classes
mentioned in @var{syntaxes} (a string of syntax class characters).  It stops
when it encounters the end of the buffer, or position @var{limit} (if
specified), or a character it is not supposed to skip.

If @var{syntaxes} starts with @samp{^}, then the function skips characters
whose syntax is @emph{not} in @var{syntaxes}.

The return value is the distance traveled, which is a nonnegative integer.
@end defun

@defun skip-syntax-backward syntaxes &optional limit
This function moves point backward across characters whose syntax classes
are mentioned in @var{syntaxes}.  It stops when it encounters the beginning
of the buffer, or position @var{limit} (if specified), or a character it is
not supposed to skip.

If @var{syntaxes} starts with @samp{^}, then the function skips characters
whose syntax is @emph{not} in @var{syntaxes}.

The return value indicates the distance traveled.  It is an integer that is
zero or less.
@end defun

@defun backward-prefix-chars
This function moves point backward over any number of characters with
expression prefix syntax.  This includes both characters in the expression
prefix syntax class, and characters with the @samp{p} flag.
@end defun

@node Parsing Expressions
@section Parsing Expressions
@cindex parsing expressions
@cindex scanning expressions

  This section describes functions for parsing and scanning balanced
expressions.  We will refer to such expressions as @dfn{sexps}, following
the terminology of Lisp, even though these functions can act on languages
other than Lisp.  Basically, a sexp is either a balanced parenthetical
grouping, a string, or a ``symbol'' (i.e., a sequence of characters whose
syntax is either word constituent or symbol constituent).  However,
characters in the expression prefix syntax class (@pxref{Syntax Class
Table}) are treated as part of the sexp if they appear next to it.

  The syntax table controls the interpretation of characters, so these
functions can be used for Lisp expressions when in Lisp mode and for C
expressions when in C mode.  @xref{List Motion}, for convenient higher-level
functions for moving over balanced expressions.

  A character's syntax controls how it changes the state of the parser, rather
than describing the state itself.  For example, a string delimiter character
toggles the parser state between ``in-string'' and ``in-code'', but the
syntax of characters does not directly say whether they are inside a
string.  For example (note that 15 is the syntax code for generic string
delimiters),

@example
(put-text-property 1 9 'syntax-table '(15 . nil))
@end example

@noindent
does not tell Emacs that the first eight chars of the current buffer are a
string, but rather that they are all string delimiters.  As a result, Emacs
treats them as four consecutive empty string constants.

@menu
* Motion via Parsing::       Motion functions that work by parsing.
* Position Parse::           Determining the syntactic state of a position.
* Parser State::             How Emacs represents a syntactic state.
* Low-Level Parsing::        Parsing across a specified region.
* Control Parsing::          Parameters that affect parsing.
@end menu

@node Motion via Parsing
@subsection Motion Commands Based on Parsing
@cindex motion based on parsing

  This section describes simple point-motion functions that operate based on
parsing expressions.

@defun scan-lists from count depth
This function scans forward @var{count} balanced parenthetical groupings
from position @var{from}.  It returns the position where the scan stops.  If
@var{count} is negative, the scan moves backwards.

If @var{depth} is nonzero, treat the starting position as being @var{depth}
parentheses deep.  The scanner moves forward or backward through the buffer
until the depth changes to zero @var{count} times.  Hence, a positive value
for @var{depth} has the effect of moving out @var{depth} levels of
parenthesis from the starting position, while a negative @var{depth} has the
effect of moving deeper by @var{-depth} levels of parenthesis.

Scanning ignores comments if @code{parse-sexp-ignore-comments} is
non-@code{nil}.

If the scan reaches the beginning or end of the accessible part of the
buffer before it has scanned over @var{count} parenthetical groupings, the
return value is @code{nil} if the depth at that point is zero; if the depth
is non-zero, a @code{scan-error} error is signaled.
@end defun

@defun scan-sexps from count
This function scans forward @var{count} sexps from position @var{from}.  It
returns the position where the scan stops.  If @var{count} is negative, the
scan moves backwards.

Scanning ignores comments if @code{parse-sexp-ignore-comments} is
non-@code{nil}.

If the scan reaches the beginning or end of (the accessible part of) the
buffer while in the middle of a parenthetical grouping, an error is
signaled.  If it reaches the beginning or end between groupings but before
count is used up, @code{nil} is returned.
@end defun

@defun forward-comment count
This function moves point forward across @var{count} complete comments (that
is, including the starting delimiter and the terminating delimiter if any),
plus any whitespace encountered on the way.  It moves backward if
@var{count} is negative.  If it encounters anything other than a comment or
whitespace, it stops, leaving point at the place where it stopped.  This
includes (for instance) finding the end of a comment when moving forward and
expecting the beginning of one.  The function also stops immediately after
moving over the specified number of complete comments.  If @var{count}
comments are found as expected, with nothing except whitespace between them,
it returns @code{t}; otherwise it returns @code{nil}.

This function cannot tell whether the ``comments'' it traverses are embedded
within a string.  If they look like comments, it treats them as comments.

To move forward over all comments and whitespace following point, use
@code{(forward-comment (buffer-size))}.  @code{(buffer-size)} is a good
argument to use, because the number of comments in the buffer cannot exceed
that many.
@end defun

@node Position Parse
@subsection Finding the Parse State for a Position
@cindex parse state for a position

  For syntactic analysis, such as in indentation, often the useful thing is to
compute the syntactic state corresponding to a given buffer position.  This
function does that conveniently.

@defun syntax-ppss &optional pos
This function returns the parser state that the parser would reach at
position @var{pos} starting from the beginning of the buffer.
@iftex
See the next section for
@end iftex
@ifnottex
@xref{Parser State},
@end ifnottex
for a description of the parser state.

The return value is the same as if you call the low-level parsing function
@code{parse-partial-sexp} to parse from the beginning of the buffer to
@var{pos} (@pxref{Low-Level Parsing}).  However, @code{syntax-ppss} uses a
cache to speed up the computation.  Due to this optimization, the second
value (previous complete subexpression)  and sixth value (minimum
parenthesis depth) in the returned parser state are not meaningful.

This function has a side effect: it adds a buffer-local entry to
@code{before-change-functions} (@pxref{Change Hooks}) for
@code{syntax-ppss-flush-cache} (see below).  This entry keeps the cache
consistent as the buffer is modified.  However, the cache might not be
updated if @code{syntax-ppss} is called while @code{before-change-functions}
is temporarily let-bound, or if the buffer is modified without running the
hook, such as when using @code{inhibit-modification-hooks}.  In those cases,
it is necessary to call @code{syntax-ppss-flush-cache} explicitly.
@end defun

@defun syntax-ppss-flush-cache beg &rest ignored-args
This function flushes the cache used by @code{syntax-ppss}, starting at
position @var{beg}.  The remaining arguments, @var{ignored-args}, are
ignored; this function accepts them so that it can be directly used on hooks
such as @code{before-change-functions} (@pxref{Change Hooks}).
@end defun

  Major modes can make @code{syntax-ppss} run faster by specifying where it
needs to start parsing.

@defvar syntax-begin-function
If this is non-@code{nil}, it should be a function that moves to an earlier
buffer position where the parser state is equivalent to @code{nil}---in
other words, a position outside of any comment, string, or parenthesis.
@code{syntax-ppss} uses it to further optimize its computations, when the
cache gives no help.
@end defvar

@node Parser State
@subsection Parser State
@cindex parser state

  A @dfn{parser state} is a list of ten elements describing the state of the
syntactic parser, after it parses the text between a specified starting
point and a specified end point in the buffer.  Parsing functions such as
@code{syntax-ppss}
@ifnottex
(@pxref{Position Parse})
@end ifnottex
return a parser state as the value.  Some parsing functions accept a parser
state as an argument, for resuming parsing.

  Here are the meanings of the elements of the parser state:

@enumerate 0
@item
The depth in parentheses, counting from 0.  @strong{Warning:} this can be
negative if there are more close parens than open parens between the
parser's starting point and end point.

@item
@cindex innermost containing parentheses
The character position of the start of the innermost parenthetical grouping
containing the stopping point; @code{nil} if none.

@item
@cindex previous complete subexpression
The character position of the start of the last complete subexpression
terminated; @code{nil} if none.

@item
@cindex inside string
Non-@code{nil} if inside a string.  More precisely, this is the character
that will terminate the string, or @code{t} if a generic string delimiter
character should terminate it.

@item
@cindex inside comment
@code{t} if inside a non-nestable comment (of any comment style;
@pxref{Syntax Flags}); or the comment nesting level if inside a comment that
can be nested.

@item
@cindex quote character
@code{t} if the end point is just after a quote character.

@item
The minimum parenthesis depth encountered during this scan.

@item
What kind of comment is active: @code{nil} if not in a comment or in a
comment of style @samp{a}; 1 for a comment of style @samp{b}; 2 for a
comment of style @samp{c}; and @code{syntax-table} for a comment that should
be ended by a generic comment delimiter character.

@item
The string or comment start position.  While inside a comment, this is the
position where the comment began; while inside a string, this is the
position where the string began.  When outside of strings and comments, this
element is @code{nil}.

@item
Internal data for continuing the parsing.  The meaning of this data is
subject to change; it is used if you pass this list as the @var{state}
argument to another call.
@end enumerate

  Elements 1, 2, and 6 are ignored in a state which you pass as an argument to
continue parsing, and elements 8 and 9 are used only in trivial cases.
Those elements are mainly used internally by the parser code.

  One additional piece of useful information is available from a parser state
using this function:

@defun syntax-ppss-toplevel-pos state
This function extracts, from parser state @var{state}, the last position
scanned in the parse which was at top level in grammatical structure.  ``At
top level'' means outside of any parentheses, comments, or strings.

The value is @code{nil} if @var{state} represents a parse which has arrived
at a top level position.
@end defun

@node Low-Level Parsing
@subsection Low-Level Parsing

  The most basic way to use the expression parser is to tell it to start at a
given position with a certain state, and parse up to a specified end
position.

@defun parse-partial-sexp start limit &optional target-depth stop-before state stop-comment
This function parses a sexp in the current buffer starting at @var{start},
not scanning past @var{limit}.  It stops at position @var{limit} or when
certain criteria described below are met, and sets point to the location
where parsing stops.  It returns a parser state
@ifinfo
(@pxref{Parser State})
@end ifinfo
describing the status of the parse at the point where it stops.

@cindex parenthesis depth
If the third argument @var{target-depth} is non-@code{nil}, parsing stops if
the depth in parentheses becomes equal to @var{target-depth}.  The depth
starts at 0, or at whatever is given in @var{state}.

If the fourth argument @var{stop-before} is non-@code{nil}, parsing stops
when it comes to any character that starts a sexp.  If @var{stop-comment} is
non-@code{nil}, parsing stops when it comes to the start of a comment.  If
@var{stop-comment} is the symbol @code{syntax-table}, parsing stops after
the start of a comment or a string, or the end of a comment or a string,
whichever comes first.

If @var{state} is @code{nil}, @var{start} is assumed to be at the top level
of parenthesis structure, such as the beginning of a function definition.
Alternatively, you might wish to resume parsing in the middle of the
structure.  To do this, you must provide a @var{state} argument that
describes the initial status of parsing.  The value returned by a previous
call to @code{parse-partial-sexp} will do nicely.
@end defun

@node Control Parsing
@subsection Parameters to Control Parsing
@cindex parsing, control parameters

@defvar multibyte-syntax-as-symbol
If this variable is non-@code{nil}, @code{scan-sexps} treats all
non-@acronym{ASCII} characters as symbol constituents regardless of what the
syntax table says about them.  (However, text properties can still override
the syntax.)
@end defvar

@defopt parse-sexp-ignore-comments
@cindex skipping comments
If the value is non-@code{nil}, then comments are treated as whitespace by
the functions in this section and by @code{forward-sexp}, @code{scan-lists}
and @code{scan-sexps}.
@end defopt

@vindex parse-sexp-lookup-properties
The behavior of @code{parse-partial-sexp} is also affected by
@code{parse-sexp-lookup-properties} (@pxref{Syntax Properties}).

You can use @code{forward-comment} to move forward or backward over one
comment or several comments.

@node Syntax Table Internals
@section Syntax Table Internals
@cindex syntax table internals

  Syntax tables are implemented as char-tables (@pxref{Char-Tables}), but most
Lisp programs don't work directly with their elements.  Syntax tables do not
store syntax data as syntax descriptors (@pxref{Syntax Descriptors}); they
use an internal format, which is documented in this section.  This internal
format can also be assigned as syntax properties (@pxref{Syntax
Properties}).

@cindex syntax code
@cindex raw syntax descriptor
  Each entry in a syntax table is a @dfn{raw syntax descriptor}: a cons cell
of the form @code{(@var{syntax-code} . @var{matching-char})}.
@var{syntax-code} is an integer which encodes the syntax class and syntax
flags, according to the table below.  @var{matching-char}, if
non-@code{nil}, specifies a matching character (similar to the second
character in a syntax descriptor).

  Here are the syntax codes corresponding to the various syntax classes:

@multitable @columnfractions .2 .3 .2 .3
@item
@i{Code} @tab @i{Class} @tab @i{Code} @tab @i{Class}
@item
0 @tab whitespace @tab 8 @tab paired delimiter
@item
1 @tab punctuation @tab 9 @tab escape
@item
2 @tab word @tab 10 @tab character quote
@item
3 @tab symbol @tab 11 @tab comment-start
@item
4 @tab open parenthesis @tab 12 @tab comment-end
@item
5 @tab close parenthesis @tab 13 @tab inherit
@item
6 @tab expression prefix @tab 14 @tab generic comment
@item
7 @tab string quote @tab 15 @tab generic string
@end multitable

@noindent
For example, in the standard syntax table, the entry for @samp{(} is
@code{(4 . 41)}.  41 is the character code for @samp{)}.

  Syntax flags are encoded in higher order bits, starting 16 bits from the
least significant bit.  This table gives the power of two which corresponds
to each syntax flag.

@multitable @columnfractions .15 .3 .15 .3
@item
@i{Prefix} @tab @i{Flag} @tab @i{Prefix} @tab @i{Flag}
@item
@samp{1} @tab @code{(lsh 1 16)} @tab @samp{p} @tab @code{(lsh 1 20)}
@item
@samp{2} @tab @code{(lsh 1 17)} @tab @samp{b} @tab @code{(lsh 1 21)}
@item
@samp{3} @tab @code{(lsh 1 18)} @tab @samp{n} @tab @code{(lsh 1 22)}
@item
@samp{4} @tab @code{(lsh 1 19)}
@end multitable

@defun string-to-syntax desc
Given a syntax descriptor @var{desc} (a string), this function returns the
corresponding raw syntax descriptor.
@end defun

@defun syntax-after pos
This function returns the raw syntax descriptor for the character in the
buffer after position @var{pos}, taking account of syntax properties as well
as the syntax table.  If @var{pos} is outside the buffer's accessible
portion (@pxref{Narrowing, accessible portion}), the return value is
@code{nil}.
@end defun

@defun syntax-class syntax
This function returns the syntax code for the raw syntax descriptor
@var{syntax}.  More precisely, it takes the raw syntax descriptor's
@var{syntax-code} component, masks off the high 16 bits which record the
syntax flags, and returns the resulting integer.

If @var{syntax} is @code{nil}, the return value is returns @code{nil}.  This
is so that the expression

@example
(syntax-class (syntax-after pos))
@end example

@noindent
evaluates to @code{nil} if @code{pos} is outside the buffer's accessible
portion, without throwing errors or returning an incorrect code.
@end defun

@node Categories
@section Categories
@cindex categories of characters
@cindex character categories

  @dfn{Categories} provide an alternate way of classifying characters
syntactically.  You can define several categories as needed, then
independently assign each character to one or more categories.  Unlike
syntax classes, categories are not mutually exclusive; it is normal for one
character to belong to several categories.

@cindex category table
  Each buffer has a @dfn{category table} which records which categories are
defined and also which characters belong to each category.  Each category
table defines its own categories, but normally these are initialized by
copying from the standard categories table, so that the standard categories
are available in all modes.

  Each category has a name, which is an @acronym{ASCII} printing character in
the range @w{@samp{ }} to @samp{~}.  You specify the name of a category when
you define it with @code{define-category}.

@cindex category set
  The category table is actually a char-table (@pxref{Char-Tables}).  The
element of the category table at index @var{c} is a @dfn{category set}---a
bool-vector---that indicates which categories character @var{c} belongs to.
In this category set, if the element at index @var{cat} is @code{t}, that
means category @var{cat} is a member of the set, and that character @var{c}
belongs to category @var{cat}.

For the next three functions, the optional argument @var{table} defaults to
the current buffer's category table.

@defun define-category char docstring &optional table
This function defines a new category, with name @var{char} and documentation
@var{docstring}, for the category table @var{table}.

Here's an example of defining a new category for characters that have strong
right-to-left directionality (@pxref{Bidirectional Display})  and using it
in a special category table:

@example
(defvar special-category-table-for-bidi
  (let ((category-table (make-category-table))
	(uniprop-table (unicode-property-table-internal 'bidi-class)))
    (define-category ?R "Characters of bidi-class R, AL, or RLO"
                     category-table)
    (map-char-table
     #'(lambda (key val)
	 (if (memq val '(R AL RLO))
	     (modify-category-entry key ?R category-table)))
     uniprop-table)
    category-table))
@end example
@end defun

@defun category-docstring category &optional table
This function returns the documentation string of category @var{category} in
category table @var{table}.

@example
(category-docstring ?a)
     @result{} "ASCII"
(category-docstring ?l)
     @result{} "Latin"
@end example
@end defun

@defun get-unused-category &optional table
This function returns a category name (a character) which is not currently
defined in @var{table}.  If all possible categories are in use in
@var{table}, it returns @code{nil}.
@end defun

@defun category-table
This function returns the current buffer's category table.
@end defun

@defun category-table-p object
This function returns @code{t} if @var{object} is a category table,
otherwise @code{nil}.
@end defun

@defun standard-category-table
This function returns the standard category table.
@end defun

@defun copy-category-table &optional table
This function constructs a copy of @var{table} and returns it.  If
@var{table} is not supplied (or is @code{nil}), it returns a copy of the
standard category table.  Otherwise, an error is signaled if @var{table} is
not a category table.
@end defun

@defun set-category-table table
This function makes @var{table} the category table for the current buffer.
It returns @var{table}.
@end defun

@defun make-category-table
This creates and returns an empty category table.  In an empty category
table, no categories have been allocated, and no characters belong to any
categories.
@end defun

@defun make-category-set categories
This function returns a new category set---a bool-vector---whose initial
contents are the categories listed in the string @var{categories}.  The
elements of @var{categories} should be category names; the new category set
has @code{t} for each of those categories, and @code{nil} for all other
categories.

@example
(make-category-set "al")
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun char-category-set char
This function returns the category set for character @var{char} in the
current buffer's category table.  This is the bool-vector which records
which categories the character @var{char} belongs to.  The function
@code{char-category-set} does not allocate storage, because it returns the
same bool-vector that exists in the category table.

@example
(char-category-set ?a)
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun category-set-mnemonics category-set
This function converts the category set @var{category-set} into a string
containing the characters that designate the categories that are members of
the set.

@example
(category-set-mnemonics (char-category-set ?a))
     @result{} "al"
@end example
@end defun

@defun modify-category-entry char category &optional table reset
This function modifies the category set of @var{char} in category table
@var{table} (which defaults to the current buffer's category table).
@var{char} can be a character, or a cons cell of the form @code{(@var{min}
. @var{max})}; in the latter case, the function modifies the category sets
of all characters in the range between @var{min} and @var{max}, inclusive.

Normally, it modifies a category set by adding @var{category} to it.  But if
@var{reset} is non-@code{nil}, then it deletes @var{category} instead.
@end defun

@deffn Command describe-categories &optional buffer-or-name
This function describes the category specifications in the current category
table.  It inserts the descriptions in a buffer, and then displays that
buffer.  If @var{buffer-or-name} is non-@code{nil}, it describes the
category table of that buffer instead.
@end deffn
