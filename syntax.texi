@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Syntax Tables
@chapter Syntax Tables
@cindex parsing buffer text
@cindex syntax table
@cindex text parsing

  @dfn{構文テーブル(syntax
table)}は、バッファー内のそれぞれの文字にたいして、構文的な役割を指定します。単語、シンボル、その他の構文要素の開始と終了の判定に、これを使用できます。この情報はFont
Lockモード(@ref{Font Lock
Mode}を参照)や、種々の複雑な移動コマンド(@ref{Motion}を参照)を含む、多くのEmacs機能により使用されます。

@menu
* Basics: Syntax Basics.     構文テーブルの基本的概念。
* Syntax Descriptors::       文字がクラス分けされる方法。
* Syntax Table Functions::   構文テーブルを作成、調査、変更する方法。
* Syntax Properties::        テキストプロパティによる構文テーブルのオーバーライド。
* Motion and Syntax::        特定の構文による文字間の移動。
* Parsing Expressions::      構文テーブル使用によるバランスのとれた式の解析。
* Syntax Table Internals::   構文テーブルの情報が格納される方法。
* Categories::               文字構文をクラス分けする別の手段。
@end menu

@node Syntax Basics
@section Syntax Table Concepts

  構文テーブルとは、それぞれの文字の@dfn{構文クラス(syntax
class)}や、その他の構文的プロパティを照合するために使用できる、データ構造のことです。構文テーブルは、テキストを横断したスキャンや移動のために、Lispプログラムにより使用されます。

  構文テーブルは、内部的には文字テーブルです(@ref{Char-Tables}を参照)。インデックス@var{c}の要素はコード@var{c}の文字を記述します。値は該当する文字の構文を指定するコンスセルです。詳細は@xref{Syntax
Table
Internals}を参照してください。しかし構文テーブルの内容を変更または調べるために@code{aset}や@code{aref}を使用するかわりに、通常は高レベルな関数@code{char-syntax}や@code{modify-syntax-entry}を使用するべきです。これらについては@ref{Syntax
Table Functions}で説明します。

@defun syntax-table-p object
この関数は@var{object}が構文テーブルなら、@code{t}をリターンする。
@end defun

  バッファーはそれぞれ自身のメジャーモードをもち、それぞれのメジャーモードはさまざまな文字の構文クラスにたいして独自のアイデアをもっています。たとえばLisモードでは文字@samp{;}はコメントの開始ですが、Cモードでは命令文の終端になります。これらのバリエーションをサポートするために、構文テーブルはそれぞれのバッファーにたいしてローカルです。一般的に各メジャーモードは自身の構文テーブルをもち、そのモードを使用するすべてのバッファーにそれがインストールされます。たとえば変数@code{emacs-lisp-mode-syntax-table}はEmacsのLispモードが使用する構文テーブル、@code{c-mode-syntax-table}はCモードが使用する構文テーブルを保持します。あるメジャーモードの構文テーブルを変更すると、そのモードのバッファー、およびその後でそのモードに置かれるすべてのバッファーの構文も同様に変更されます。複数の類似するモードが1つの構文テーブルを共有することが、ときおりあります。構文テーブルをセットアップする方法の例は、@ref{Example
Major Modes}を参照してください。

@cindex standard syntax table
@cindex inheritance, syntax table
  別の構文テーブルから構文テールを@dfn{継承(inherit)}できます。これを@dfn{親構文テーブル(parent syntax
table)}と呼びます。構文テーブルは、ある文字にたいして構文クラス``inherit''を与えることにより、構文クラスを未指定にしておくことができます。そのような文字は、親構文テーブルが指定する構文クラスを取得します(@ref{Syntax
Class Table}を参照)。Emacsは@dfn{標準構文テーブル(standard syntax
table)}を定義します。これはデフォルトとなる親構文テーブルであり、Fundamentalモードが使用する構文テーブルでもあります。

@defun standard-syntax-table
この関数はFundamentalモードが使用する構文テーブルである、標準構文テーブルをリターンする。
@end defun

  Emacs
Lispリーダーは変更不可な独自のビルトイン構文ルールをもつので、構文テーブルは使用しません(いくつかのLispシステムはリード構文を再定義する手段を提供するが、わたしたちは単純化のためこの機能をEmacs
Lisp外部に留める決定をした)。

@node Syntax Descriptors
@section Syntax Descriptors
@cindex syntax class

  @dfn{構文クラス(syntax
class)}の文字は、その文字の構文的な役割を記述します。各構文テーブルは、それぞれの文字の構文クラスを指定します。ある構文テーブルでの文字のクラスと、別のテーブルにおけるその文字のクラスとの間に関連性がある必要はありません。

  構文テーブルはそれぞれニーモニック文字(mnemonic
character)により選別され、クラスを指定する必要がある際にはそのクラスの名前としての役割を果たします。この指定子文字(designator
character)は通常、そのクラスに割当てられることが多々あります。しかしその指定子としての意味は不変であり、その文字がカレントでもつ構文とは独立しています。つまりカレント構文テーブルにおいて実際に文字@samp{\}が構文をもつかどうかに関係なく、指定子文字としての@samp{\}は常に``エスケープ文字(escape
characte)r''を意味します。
@ifnottex
構文クラスとそれらの指定子文字のリストは、@ref{Syntax Class Table}を参照してください。
@end ifnottex

@cindex syntax descriptor
  @dfn{構文記述子(syntax
descriptor)}とは、文字の構文クラスと、その他の構文的なプロパティを記述するLisp文字列のことです。ある文字の構文を変更したい際、それは関数@code{modify-syntax-entry}を呼び出して、その引数に構文記述子を渡すことにより行われます(@ref{Syntax
Table Functions}を参照)。

  構文記述子の1つ目の文字は、構文クラスの指定子文字でなければなりません。2つ目の文字がもしあれば、マッチング文字を指定します(Lispでは@samp{(}にたいするマッチング文字は@samp{)})。スペースはマッチング文字が存在しないことを指定します。その後に続く文字は、追加の構文プロパティを指定します(@ref{Syntax
Flags}を参照)。

  マッチング文字やフラグが必要なければ、(構文クラスを指定する)1つの文字だけで十分です。

  たとえばCモードでの文字@samp{*}の構文記述子は@code{".
23"}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の2つ目の文字、コメント終了記号の1つ目の文字)、@samp{/}にたいするエントリーは@samp{@w{.
14}}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の1つ目の文字、コメント終了記号の2つ目の文字)です。

  Emacsは、低レベルでの構文クラスを記述するために使用される@dfn{raw構文記述子(raw syntax
descriptors)}も定義しています。@ref{Syntax Table Internals}を参照してください。

@menu
* Syntax Class Table::       構文クラスのテーブル。
* Syntax Flags::             各文字が所有できる追加のフラグ。
@end menu

@node Syntax Class Table
@subsection Table of Syntax Classes
@cindex syntax class table

  以下は構文クラス、それらの指定子となる文字とそれらの意味、およびそれらの使用例を示すテーブルです。

@table @asis
@item 空白文字: @samp{@ }、または@samp{-}
シンボルおよび単語を区別する文字。空白文字は通常は他の構文的な意義をもたず、複数の空白文字は構文的には単一の空白文字と等しい。スペース、タブ、フォームフィードは、ほとんどすべてのメジャーモードにおいて空白文字にクラスっ分けされる。

この構文クラスは@w{@samp{@ }}または@samp{-}により指定できる。両指定子は等価である。

@item 単語構成文字: @samp{w}
人間の言語における単語の一部。これらは通常は、プログラム内において変数やコマンドの名前として使用される。通常、すべての大文字と小文字、および数字は単語構成文字である。

@item シンボル構成文字: @samp{_}
単語構成文字とともに変数やコマンドの名前で使用される、追加の文字。例としてはLispモードの文字@samp{$&*+-_<>}が含まれ、これらはたとえ英単語の一部でないとしても、シンボルの名前の一部となり得る。標準Cでは、シンボル内において非単語構成文字で有効な文字はアンダースコア(@samp{_})だけである。

@item 区切り文字: @samp{.}
人間の言語において句読点として使用される文字、またはプログラミング言語でシンボルを別のシンボルと区別するために使用される文字。Emacs
Lispモードのようないくつかのプログラミング言語のモードでは、単語構成文字およびシンボル構成文字のいずれでもないいくつかの文字はすべて、他の用途をもつので、このクラスの文字をもたない。Cモードのような他のプログラミング言語のモードでは、演算子にたいして区切り文字構文が使用される。

@item 開カッコ文字: @samp{(}
@itemx 閉カッコ文字: @samp{)}
文や式を囲うために、異なるペアーとして使用される文字。そのようなグループ化は開カッコで開始され、閉カッコで終了する。開カッコ文字はそれぞれ特定の閉カッコ文字にマッチし、その逆も成り立つ。Emacsqは通常、閉カッコ挿入字に、マッチする開カッコを示す。@ref{Blinking}を参照のこと。

人間の言語、およびCのコードではカッコのペアーは@samp{()}、@samp{[]}、@samp{@{@}}である。Emacs
Lispではリストとベクターにたいする区切り文字(@samp{()}および@samp{[]})は、カッコ文字としてクラス分けされる。

@item 文字列クォート: @samp{"}
文字列定数を区切るために使用される文字。文字列の先頭と終端に、同じ文字列クォート文字が出現する。このようなクォート文字列はネストされない。

Emacsのパース機能は、文字列を単一のトークンとみなす。文字列内では、その文字の通常の構文的な意味は抑制される。

Lispモードはダブルクォーテーション(@samp{"})、および垂直バー(@samp{|})とう、2つの文字列クォート文字をもつ。Emacs
Lispでは@samp{|}は使用しないが、Common
Lispでは使用される。Cも文字列にたいするダブルクォート文字、および文字定数にたいするシングルクォート文字(@samp{'})という、2つのクォート文字をもつ。

人間用のテキストには文字列クォート文字がない。そのクォーテーション内の別の文字の通常の構文的プロパティを、クォーテーションマークがオフに切り替えるのを、わたしたちは望まない。

@item エスケープ構文文字: @samp{\}
文字列や文字定数内で使用されるような、エスケープシーケンスで始まる文字。CとLispの両方で、文字@samp{\}はこのクラスに属する(Cでは文字列内でのみ使用されるが、Cコード中を通じてこのように扱っても問題ないことがわかった)。

@code{words-include-escapes}が非@code{nil}な、このクラスの文字は単語の一部とみなされる。@ref{Word
Motion}を参照のこと。

@item 文字クォート: @samp{/}
その文字の通常の構文的な意義を失うよう、後続の文字をクォートするために使用される文字。これは直後に続く文字だけに影響する点が、エスケープ文字と異なる。

@code{words-include-escapes}が非@code{nil}な、このクラスの文字は単語の一部とみなされる。@ref{Word
Motion}を参照のこと。

このクラスは@TeX{}モードのバックスラッシュにたいして使用される。

@item 区切りペアー: @samp{$}
文字列クォート文字と似ているが、この区切りの間にある文字の構文的なプロパティは抑制されない点が異なる。現在のところ@TeX{}モードだけが区切りペアーを使用する(@samp{$}によりmathモードに出入りする)。

@item 式プレフィクス: @samp{'}
式に隣接して出現した場合に、その式の一部とみなされる、構文的演算子にたいして使用される文字。Lispモードではアポストロフィー@samp{'}(クォートに使用)、カンマ@samp{,}(マクロに使用)、@samp{#}(特定のデータ型にたいするリード構文として使用)が、これらの文字に含まれる。

@item コメント開始文字: @samp{<}
@itemx コメント終了文字: @samp{>}
@cindex comment syntax
さまざまな言語において、コメントを区切るために使用する文字。人間用のテキストはコメント文字をもたない。Lispでは、セミコロン(@samp{;})がコメントの開始で、改行かフォームフィードで終了する。

@item 標準構文の継承: @samp{@@}
この構文クラスは、特定の構文を指定しない。これは、その文字の構文を探すために標準構文テーブルを照合するよう告げる。

@item 汎用コメント区切り: @samp{!}
特殊なコメントを開始または終了させる文字。@emph{任意}の汎用コメント区切りは、@emph{任意}の汎用コメント区切りにマッチするが、コメント開始とコメント終了とはマッチできない。汎用コメント区切りは、汎用コメント区切り同士としかマッチできない。

この構文クラスは主として@code{syntax-table}テキストプロパティ(@ref{Syntax
Properties}を参照)とともに使用することを意図している。任意の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それらが汎用コメント区切りであることを示す@code{syntax-table}プロパティを付与することにより、その範囲がコメントを形成するとマークすることができる。

@item 汎用文字列区切り: @samp{|}
文字列を開始または終了させる文字。@emph{任意}の汎用文字列区切りは、@emph{任意}の汎用文字列区切りにマッチするが、通常の文字列クォート文字とはマッチできない。

この構文クラスは主として@code{syntax-table}テキストプロパティ(@ref{Syntax
Properties}を参照)とともに使用することを意図している。任意の文字範囲にたいして、その範囲の最初と最後の文字にたいして、それらが汎用文字列区切りであることを示す@code{syntax-table}プロパティを付与することにより、その範囲が文字列定数を形成するとマークすることができる。
@end table

@node Syntax Flags
@subsection Syntax Flags
@cindex syntax flags

  構文テーブル内の文字全体にたいして、構文クラスに加えてフラグを指定できます。利用できる8つのフラグがあり、それらは文字@samp{1}、@samp{2}、@samp{3}、@samp{4}、@samp{b}、@samp{c}、@samp{n}、@samp{p}で表されます。

  @samp{p}を除くすべてのフラグは、コメント区切りを記述するために使用されます。数字のフラグは2文字から構成されるコメント区切りにたいして使用されます。これらは、文字の文字クラスに関連付けられた構文的プロパティに加えて、その文字も@emph{同様}にコメントシーケンスの一部となれることを示します。Cモードでは区切り文字であり、@emph{かつ}コメントシーケンス開始(@samp{/*})の2文字目であり、@emph{かつ}コメントシーケンス終了(@samp{*/})の1文字目である@samp{*}のような文字のために、フラグとクラスは互いに独立しています。フラグ@samp{b}、@samp{c}、@samp{n}は対応するコメント区切りを限定するために使用されます。

  以下は文字@var{c}にたいして利用できるフラグと、それらの意味を示すテーブルです:

@itemize @bullet
@item
@samp{1}は、@var{c}が2文字からなるコメント開始シーケンスの開始であることを意味する。

@item
@samp{2}は、@var{c}がそのようなシーケンスの2文字目であることを意味する。

@item
@samp{3}は、@var{c}が2文字からなるコメント終了シーケンスの開始であることを意味する。

@item
@samp{4}は、@var{c}がそのようなシーケンスの2文字目であることを意味する。

@item
@samp{b}は、@var{c}が代替えのコメントスタイル``b''に属するコメント区切りであることを意味する。このフラグは2文字のコメント開始では2文字目、2文字のコメント終了では1文字目にたいしてのみ意味をもつ。

@item
@samp{c}は、@var{c}が代替えのコメントスタイル``c''に属するコメント区切りであることを意味する。2文字からなるコメント区切りにたいしては、そのいずれかが@samp{c}であればスタイル``c''となる。

@item
コメント区切り文字での@samp{n}は、この種のコメントがネスト可能であることを指定する。2文字からなるコメント区切りにたいしては、そのいずれかが@samp{n}であればネスト可能となる。

@cindex comment style
Emacsは任意の構文テーブル1つにたいして、同時に複数のコメントスタイルをサポートする。コメントスタイルはフラグ@samp{b}、@samp{c}、@samp{n}の組み合わせなので、8個の異なるコメントスタイルが可能である。コメント区切りはそれぞれスタイルをもち、同じスタイルのコメント区切りとのみマッチできる。つまりコメントがスタイル``bn''のコメント開始シーケンスで開始されるなら、そのコメントは次のスタイル``bn''のコメント終了シーケンスにマッチするまで拡張されるだろう。

C++にたいして適切なコメント構文は、以下のようになる:

@table @asis
@item @samp{/}
@samp{124}
@item @samp{*}
@samp{23b}
@item newline
@samp{>}
@end table

これは4つのコメント区切りシーケンスを定義する:

@table @asis
@item @samp{/*}
これは2文字目の@samp{*}が@samp{b}フラグをもつので、``b''スタイルのコメント開始シーケンスである。

@item @samp{//}
これは2文字目の@samp{/}が@samp{b}フラグをもたないので、``a''スタイルのコメント開始シーケンスである。

@item @samp{*/}
これは1文字目の@samp{*}が@samp{b}フラグをもつので、``b''スタイルのコメント終了シーケンスである。

@item newline
これは改行▼文字が@samp{b}フラグをもたないので、``a''スタイルのコメント終了シーケンスである。
@end table

@item
@samp{p}はLisp構文にたいして、追加のプレフィクス文字を識別する。これらが式の間に出現した際は、空白文字として扱われる。これらが式の内部に出現したときは、それらの通常の構文クラスに応じて処理される。

関数@code{backward-prefix-chars}はこれらの文字と、同様にメインの構文クラスがプレフィクスであるような文字(@samp{'})を超えて、後方に移動する。@ref{Motion
and Syntax}を参照のこと。
@end itemize

@node Syntax Table Functions
@section Syntax Table Functions

  このセクションでは、構文テーブルを作成、アクセス、変更する関数を説明します。

@defun make-syntax-table &optional table
この関数は、新たに構文テーブルを作成する。@var{table}が非@code{nil}なら、新たな構文テーブルの親は@var{table}、それ以外なら標準構文テーブルが親になる。

新たな構文テーブルでは最初は、すべての文字に構文クラス``inherit''(@samp{@@})が与えられ、それらの構文は親テーブルから継承される(@ref{Syntax
Class Table}を参照)。
@end defun

@defun copy-syntax-table &optional table
この関数は@var{table}のコピーを構築して、それをリターンする。@var{table}が省略または@code{nil}なら、標準構文テーブルのコピーをリターンする。それ以外の場合、@var{table}が構文テーブルでなければエラーをシグナルする。
@end defun

@deffn Command modify-syntax-entry char syntax-descriptor  &optional table
@cindex syntax entry, setting
この関数は@var{syntax-descriptor}に応じて、@var{char}の構文エントリーをセットする。@var{char}は文字、または@code{(@var{min}
.
@var{max})}という形式のコンスセルでなければならない。後者の場合、この関数は@var{min}と@var{max}(両端を含む)の間のすべての文字にたいして、構文エントリーをセットする。

構文は@var{table}(デフォルトはカレントバッファーの構文テーブル)にたいしてのみ変更され、他のすべての構文テーブルにたいしては変更されない。

引数@var{syntax-descriptor}は構文記述子、すなわち1文字目が構文クラス指定子、2文字目以降がオプションでマッチング文字と構文フラグを指定する文字列である。@ref{Syntax
Descriptors}を参照のこと。@var{syntax-descriptor}が有効な構文記述子でなければ、エラーがシグナルされる。

この関数は、常に@code{nil}をリターンする。この文字にたいするテーブル内の古い構文情報は、破棄される。

@example
@group
@exdent @r{▼例:}

;; @r{空白文字クラスのスペースをputする}
(modify-syntax-entry ?\s " ")
     @result{} nil
@end group

@group
;; @r{@samp{$}を開カッコ文字にして、}
;;   @r{@samp{^}を対応する閉カッコにする}
(modify-syntax-entry ?$ "(^")
     @result{} nil
@end group

@group
;; @r{@samp{^}閉カッコ文字にして}
;;   @r{@samp{$}を対応する開カッコにする}
(modify-syntax-entry ?^ ")$")
     @result{} nil
@end group

@group
;; @r{@samp{/}を区切り文字で}
;;   @r{コメント開始シーケンス1文字目、}
;;   @r{かつコメント終了シーケンス2文字目とする}
;;   @r{これはCモードで使用される}
(modify-syntax-entry ?/ ". 14")
     @result{} nil
@end group
@end example
@end deffn

@defun char-syntax character
この関数は、指定子文字(@ref{Syntax Class
Table}を参照)の表現で、@var{character}の構文クラスをリターンする。これはクラス@emph{だけ}をリターンし、マッチング文字や構文フラグはリターンしない。

以下をCモードにたいして適用してみる(@code{char-syntax}がリターンする文字を確認しやすいよう@code{string}を使用する)。

@example
@group
;; スペース文字は空白文字構文クラスをもつ
(string (char-syntax ?\s))
     @result{} " "
@end group

@group
;; スラッシュ文字は区切り文字構文をもつ。
;; コメント開始やコメント終了シーケンスの一部でもある場合、
;; @code{char-syntax}呼び出しはこれを明らかにしないことに注意。
(string (char-syntax ?/))
     @result{} "."
@end group

@group
;; 開カッコ文字は開カッコ構文をもつ。
;; これがまっちんぐ文字@samp{)}をもつことは
;; @code{char-syntax}呼び出しでは明らかにならないことに注意。
(string (char-syntax ?\())
     @result{} "("
@end group
@end example

@end defun

@defun set-syntax-table table
この関数は、カレントバッファーの構文テーブルを@var{table}にする。これは@var{table}をリターンする。
@end defun

@defun syntax-table
この関数はカレント構文テーブル(カレントバッファーのテーブル)をリターンする。
@end defun

@deffn Command describe-syntax &optional buffer
このコマンドは、@var{buffer}(デフォルトはカレントバッファー)の構文テーブルのコンテンツをhelpバッファーに表示する。
@end deffn

@defmac with-syntax-table table body@dots{}
このまくろは@var{table}をカレント構文テーブルとして使用して、@var{body}を実行する。これは古いカレント構文テーブルのリストア後に、@var{body}の最後のフォームの値をリターンする。

各バッファーは独自にカレント構文テーブルをもつので、マクロはこれを入念に行う。@code{with-syntax-table}はマクロ実行開始時、そのときカレントのバッファーが何であれ、カレント構文テーブルを一時的に変更する。他のバッファーは影響を受けない。
@end defmac

@node Syntax Properties
@section Syntax Properties
@kindex syntax-table @r{(text property)}

ある言語の構文を指定するのに構文テーブルが十分に柔軟でないときは、
バッファー内に出現する特定の文字にたいして、テキストプロパティ@code{syntax-table}を適用することにより、構文テーブルをオーバーライドできます。テキストプロパティを適用する方法については、@ref{Text
Properties}を参照してください。

  以下はテキストプロパティ@code{syntax-table}の有効な値です:

@table @asis
@item @var{syntax-table}
プロパティの値が構文テーブルなら、根底となるテキスト文字の構文を決定するカレントバッファーの構文テーブルのかわりに、そのテーブルが使用される。

@item @code{(@var{syntax-code} . @var{matching-char})}
この形式のコンスセルは、根底となるテキスト文字の構文クラスを直接指定する、raw構文テーブル(@ref{Syntax Table
Internals}を参照)である。

@item @code{nil}
このプロパティが@code{nil}なら、その文字の構文はカレント構文テーブルにより通常の方法で決定される。
@end table

@defvar parse-sexp-lookup-properties
これが非@code{nil}なら、@code{forward-sexp}のような構文をスキャンする関数は、syntax-tableテキストプロパティに注意を払い、それ以外ならカレント構文テーブルだけを使用する。
@end defvar

@defvar syntax-propertize-function
この変数が非@code{nil}なら、特定のテキスト範囲にたいして@code{syntax-table}プロパティを適用する関数を格納するべきである。これは、モードに適した方法で@code{syntax-table}プロパティを適用する関数をインストールするために、メジャーモードに使用されることを意図している。

この関数は@code{syntax-ppss}(@ref{Position Parse}を参照)、および構文フォント表示化(@ref{Syntactic
Font Lock}を参照)の間にFont
Lockモードにより呼び出される。これは作用すべきテキスト部分の開始@var{start}と終了@var{end}という、2つの引数で呼び出される。これは@var{end}の前の任意の位置で、@code{syntax-ppss}を呼び出すことが許されている。しかし@code{syntax-ppss-flush-cache}を呼び出すべきではなく、そのため、ある位置で@code{syntax-ppss}を呼び出して、後からバッファー内の前の位置を変更することは許されていない。
@end defvar

@defvar syntax-propertize-extend-region-functions
このアブノーマルフックは@code{syntax-propertize-function}呼び出しに先立ち、構文解析コードにより実行される。これは@code{syntax-propertize-function}に渡すための、安全なバッファーの開始および終了位置を見つける助けをする役割をもつ。たとえばメジャーモードは、複数行の構文構成を識別して、境界が複数行の中間にならないよう、このフックに関数を追加できる。

このフック内の各関数は、引数@var{start}と@var{end}を受け取ること。これは2つのバッファー位置を調整するコンスセル@code{(@var{new-start}
.
@var{new-end})}、調整が必要なければ@code{nil}をリターンするべきである。フック関数は、それらすべてが@code{nil}をリターンするまで、順番に繰り返し実行される。
@end defvar

@node Motion and Syntax
@section Motion and Syntax
@cindex moving across syntax classes
@cindex skipping characters of certain syntax

  このセクションでは、特定の構文クラスをもつ文字間を横断して移動する関数を説明します。

@defun skip-syntax-forward syntaxes &optional limit
この関数は、@var{syntaxes}で指定された構文クラス(構文クラスの文字列)をもつ文字を横断して、ポイントを前方に移動する。バッファー終端か、(与えられた場合は)位置@var{limit}に到達、またはスキップしない文字に達した際に停止する。

@var{syntaxes}が@samp{^}で始まる場合、この関数は構文が@var{syntaxes}では@emph{ない}文字をスキップする。

リターン値は、移動した距離を表す非負の整数。
@end defun

@defun skip-syntax-backward syntaxes &optional limit
この関数は、@var{syntaxes}で指定された構文クラスをもつ文字を横断して、ポイントを後方に移動する。バッファー先頭か、(与えられた場合は)位置@var{limit}に到達、またはスキップしない文字に達した際に停止する。

@var{syntaxes}が@samp{^}で始まる場合、この関数は構文が@var{syntaxes}では@emph{ない}文字をスキップする。

リターン値は、移動した距離を表す0以下の整数。
@end defun

@defun backward-prefix-chars
この関数は、式プレフィクス構文の任意個数の文字を横断して、後方にポイントを移動する。これには式プレフィクス構文クラスと、フラグ@samp{p}の文字の両方が含まれる。
@end defun

@node Parsing Expressions
@section Parsing Expressions
@cindex parsing expressions
@cindex scanning expressions

  このセクションでは、バランスのとれた式の解析やスキャンを行う関数を説明します。たとえこれらの関数がLisp以外の言語にたいして作用可能であったとしても、Lisp用語にしたがい、そのような式のことは@dfn{sexps}という用語で参照することにします。基本的にsexpは、バランスのとれたカッコによるグループ化、または文字列、``symbol''(構文が単語構成要素かシンボル構成要素である文字シーケンス)のいずれかです。しかし式プレフィクス構文(@ref{Syntax
Class Table}を参照)の文字は、それらがsexpに隣接する場合は、sexpの一部として扱われます。

  構文テーブルは文字の解釈を制御するので、これらの関数はLispモードでのLisp式、CモードでのCの式にたいして使用できます。バランスのとれた式にたいする、有用な高レベル関数については、@ref{List
Motion}を参照してください。

  ある文字の構文は、パーサー自身の状態の記述ではなく、パーサー状態の変更方法を制御します。たとえば文字列区切り文字は、``in-string''と``in-code'',の間でパーサー状態をトグルしますが、文字の構文が直接文字列内部にあるかどうかを告げることはありません。たとえば(15は汎用文字列区切りの構文コードであることに注意)、

@example
(put-text-property 1 9 'syntax-table '(15 . nil))
@end example

@noindent
これはEmacsにたいして、カレントバッファーの最初の8文字が文字列であることを告げますが、それらはすべて文字列区切りです。結果としてEmacsはそれらを、連続する4つの空文字列定数として扱います。

@menu
* Motion via Parsing::       パースにより機能する移動関数。
* Position Parse::           ある位置の構文状態を判断する。
* Parser State::             Emacsが構文状態を表す方法。
* Low-Level Parsing::        指定されたリージョンを横断するパース。
* Control Parsing::          パースに影響するパラメーター。
@end menu

@node Motion via Parsing
@subsection Motion Commands Based on Parsing
@cindex motion based on parsing

  このセクションでは、式のパースにもとづいて処理を行う、シンプルなポイント移動関数を説明します。

@defun scan-lists from count depth
この関数は、位置@var{from}からバランスのとれたカッコのグループを@var{count}個、前方にスキャンする。これはスキャンが停止した位置をリターンする。@var{count}が負なら、スキャンは後方に移動する。

@var{depth}が非0なら、開始位置のカッコのネスト深さを@var{depth}として扱う。スキャナーは、ネスト深さが0になるまで@var{count}回、繰り返し前方または後方に移動する。そのため、正の@var{depth}は開始位置からカッコを@var{depth}レベル抜け出して移動する効果があり、負の@var{depth}はカッコが@var{depth}レベル深くなるよう移動する効果をもつ。

@code{parse-sexp-ignore-comments}が非@code{nil}なら、スキャンはコメントを無視する。

@var{count}個のカッコのグループをスキャンする前に、スキャンがバッファーのアクセス可能範囲の先頭か終端に達した場合、そのポイントのネスト深さが0なら、値@code{nil}をリターンする。ネスト深さが非0なら、@code{scan-error}エラーをシグナルする。
@end defun

@defun scan-sexps from count
この関数は位置@var{from}から、@var{count}個のsexpを前方にスキャンする。これは、スキャンが停止した位置をリターンする。@var{count}が負なら、スキャンは後方へ移動する。

@code{parse-sexp-ignore-comments}が非@code{nil}なら、スキャンはコメントを無視する。

カッコのグループの中間でバッファー(のアクセス可能範囲)の先頭か終端に達した場合は、エラーをシグナルする。@var{count}個を消費する前に、カッコのグループの間でバッファーの先頭か終端に達した場合は、@code{nil}をリターンする。ネスト深さが非0なら、@code{scan-error}エラーをシグナルする。
@end defun

@defun forward-comment count
この関数は、@var{count}個の完全なコメント(すなわち、もしあれば開始区切りと終了区切りを含む)、および途中で遭遇する任意の空白文字を横断して、ポイントを前方に移動する。@var{count}が負なら、後方に移動する。コメントまたは空白文字以外のものに遭遇したら停止して、その停止位置にポイントを残す。これには、(たとえば)前方に移動してコメント開始を調べる際に、コメント終了を探すことも含まれる。この関数は、指定された個数の完全なコメントを横断して移動した後も、即座に停止する。空白以外のものがコメント間に存在せずに、期待どおり@var{count}個のコメントが見つかったら@code{t}を、それ以外は@code{nil}をリターンする。

この関数は、``コメント''を横断する際、それが文字列内に埋め込まれているかどうか区別できない。コメントのように見えれば、それらはコメントとして扱われる。

ポイント後のすべてのコメントと空白文字を飛び越して移動するには、@code{(forward-comment
(buffer-size))}を使用する。バッファー内のコメント数は@code{(buffer-size)}を超えることはできないので、これは引数としての使用に適す。
@end defun

@node Position Parse
@subsection Finding the Parse State for a Position
@cindex parse state for a position

  インデントのような構文分析にとっては、与えられたバッファー位置に応じた構文状態の計算が有用なことが多々あります。それを手軽に行うのが、この関数です。

@defun syntax-ppss &optional pos
この関数は、パーサーがバッファー先頭から開始して位置@var{pos}で停止するだろうという、パーサー状態をリターンする。
@iftex
パーサー状態の説明は、次のセクションを参照のこと
@end iftex
@ifnottex
パーサー状態の説明は、@ref{Parser State}を参照のこと
@end ifnottex
。

リターン値は、バッファー先頭から@var{pos}までパースするために低レベル関数@code{parse-partial-sexp}(@ref{Low-Level
Parsing}を参照)を呼び出した場合と同じようになる。しかし@code{syntax-ppss}は、計算速度向上のために、キャッシュを使用する。この最適化のため、リターンされるパーサー状態のうち2つ目の値(前の完全な部分式)と6つ目の値(最小のカッコ深さ)は意味をもたない。

この関数は、@code{syntax-ppss-flush-cache}(以下参照)にたいして、@code{before-change-functions}(@ref{Change
Hooks}を参照)にバッファーローカルなエントリーを追加するという副作用をもつ。このエントリーは、バッファー変更にたいして、キャッシュの一貫性を保つ。とはいえ、@code{before-change-functions}が一時的にletでバインドされている間に@code{syntax-ppss}が呼び出された場合、または@code{inhibit-modification-hooks}使用時のようにバッファーがフックを実行せずに変更される場合、キャッシュは更新されないかもしれない。そのような場合は、明示的に@code{syntax-ppss-flush-cache}を呼び出す必要がある。
@end defun

@defun syntax-ppss-flush-cache beg &rest ignored-args
この関数は、@code{syntax-ppss}が使用するキャッシュを、位置@var{beg}からフラッシュする。残りの引数@var{ignored-args}は無視される。@code{before-change-functions}(@ref{Change
Hooks}を参照)のような関数で直接使用できるよう、この関数はそれらの引数を受け入れる。
@end defun

  メジャーモードは、パース開始を要する箇所を指定することにより、@code{syntax-ppss}の実行をより高速にできます。

@defvar syntax-begin-function
これが非@code{nil}なら、それはパーサー状態が@code{nil}であるような以前のバッファー位置(別の言い方をすると任意のコメント、文字列、カッコの外部であるような位置)に移動する関数であること。キャッシュが助けとならない際、@code{syntax-ppss}はその計算をおり最適化するためにこれを使用する。
@end defvar

@node Parser State
@subsection Parser State
@cindex parser state

  @dfn{パーサー状態(parser
state)}とは、バッファー内の指定された開始位置と終了位置の間のテキストをパースした後の、構文パーサーの状態を記述する10要素のリストです。@code{syntax-ppss}のようなパース関数
@ifnottex
(@ref{Position Parse}を参照)
@end ifnottex
は、値としてパーサー状態をリターンします。いくつかのパース関数は、パースを再開するために、引数としてパーサー状態を受け取ります。

  以下は、パーサー状態の要素の意味です:

@enumerate 0
@item
0から数えたカッコの深さ。@strong{警告:} パーサーの開始位置と終了位置の間に開カッコより多くの閉カッコがあれば、負になることもある。

@item
@cindex innermost containing parentheses
停止位置を含む最内のカッコグループの開始文字位置。なければ@code{nil}。

@item
@cindex previous complete subexpression
最後の終端された完全な部分式の開始文字位置。なければ@code{nil}。

@item
@cindex inside string
文字列内部なら非@code{nil}。より正確には、文字列を終端させるであろう文字か、汎用文字列区切りが終端すべきような場合は@code{t}となる。

@item
@cindex inside comment
ネスト不可なコメント(または任意のコメントスタイル。@ref{Syntax
Flags}を参照されたい)の内部なら@code{t}、ネスト可なコメントの内部ならコメントのネストレベル。

@item
@cindex quote character
終了位置がクォート文字直後なら@code{t}。

@item
当該スキャン中に遭遇した最小のカッコ深さ。

@item
アクティブなコメントの種類。コメント以外、またはスタイル@samp{a}のコメント内なら@code{nil}、スタイル@samp{b}のコメントなら1、スタイル@samp{c}のコメントなら2、汎用コメント区切り文字で終端されるべきコメントなら@code{syntax-table}。

@item
文字列またはコメントの開始位置。コメント内部ならコメントが始まる位置。文字列内部なら文字列が始まる位置。文字列またはコメントの外部なら、この要素は@code{nil}になる。

@item
パースを継続するための内部データ。このデータのもつ意味は、変更され得る。これは、他の呼び出しの@var{state}引数としてこのリストを渡す場合に使用される。
@end enumerate

  パース継続のために渡す場合、要素1、2、6は無視され、要素8と9は特に重要ではない場面でのみ使用されます。これらの要素は主に、パーサーコードにより内部的に使用されます。

  以下の関数を使用することにより、さらに追加でパーサー状態から有用な情報を利用できます:

@defun syntax-ppss-toplevel-pos state
この関数はパーサー状態@var{state}から、文法構造上トップレベルでのパースにおける、スキャンした最後の位置をリターンする。``トップレベル''とは、すべてのカッコ、コメント、文字列の外部であることを意味する。

@var{state}がトップレベルの位置に到達したパースを表す場合、値は@code{nil}となる。
@end defun

@node Low-Level Parsing
@subsection Low-Level Parsing

  The most basic way to use the expression parser is to tell it to start at a
given position with a certain state, and parse up to a specified end
position.

@defun parse-partial-sexp start limit &optional target-depth stop-before state stop-comment
This function parses a sexp in the current buffer starting at @var{start},
not scanning past @var{limit}.  It stops at position @var{limit} or when
certain criteria described below are met, and sets point to the location
where parsing stops.  It returns a parser state
@ifinfo
(@pxref{Parser State})
@end ifinfo
describing the status of the parse at the point where it stops.

@cindex parenthesis depth
If the third argument @var{target-depth} is non-@code{nil}, parsing stops if
the depth in parentheses becomes equal to @var{target-depth}.  The depth
starts at 0, or at whatever is given in @var{state}.

If the fourth argument @var{stop-before} is non-@code{nil}, parsing stops
when it comes to any character that starts a sexp.  If @var{stop-comment} is
non-@code{nil}, parsing stops when it comes to the start of a comment.  If
@var{stop-comment} is the symbol @code{syntax-table}, parsing stops after
the start of a comment or a string, or the end of a comment or a string,
whichever comes first.

If @var{state} is @code{nil}, @var{start} is assumed to be at the top level
of parenthesis structure, such as the beginning of a function definition.
Alternatively, you might wish to resume parsing in the middle of the
structure.  To do this, you must provide a @var{state} argument that
describes the initial status of parsing.  The value returned by a previous
call to @code{parse-partial-sexp} will do nicely.
@end defun

@node Control Parsing
@subsection Parameters to Control Parsing
@cindex parsing, control parameters

@defvar multibyte-syntax-as-symbol
If this variable is non-@code{nil}, @code{scan-sexps} treats all
non-@acronym{ASCII} characters as symbol constituents regardless of what the
syntax table says about them.  (However, text properties can still override
the syntax.)
@end defvar

@defopt parse-sexp-ignore-comments
@cindex skipping comments
If the value is non-@code{nil}, then comments are treated as whitespace by
the functions in this section and by @code{forward-sexp}, @code{scan-lists}
and @code{scan-sexps}.
@end defopt

@vindex parse-sexp-lookup-properties
The behavior of @code{parse-partial-sexp} is also affected by
@code{parse-sexp-lookup-properties} (@pxref{Syntax Properties}).

You can use @code{forward-comment} to move forward or backward over one
comment or several comments.

@node Syntax Table Internals
@section Syntax Table Internals
@cindex syntax table internals

  Syntax tables are implemented as char-tables (@pxref{Char-Tables}), but most
Lisp programs don't work directly with their elements.  Syntax tables do not
store syntax data as syntax descriptors (@pxref{Syntax Descriptors}); they
use an internal format, which is documented in this section.  This internal
format can also be assigned as syntax properties (@pxref{Syntax
Properties}).

@cindex syntax code
@cindex raw syntax descriptor
  Each entry in a syntax table is a @dfn{raw syntax descriptor}: a cons cell
of the form @code{(@var{syntax-code} . @var{matching-char})}.
@var{syntax-code} is an integer which encodes the syntax class and syntax
flags, according to the table below.  @var{matching-char}, if
non-@code{nil}, specifies a matching character (similar to the second
character in a syntax descriptor).

  Here are the syntax codes corresponding to the various syntax classes:

@multitable @columnfractions .2 .3 .2 .3
@item
@i{Code} @tab @i{Class} @tab @i{Code} @tab @i{Class}
@item
0 @tab whitespace @tab 8 @tab paired delimiter
@item
1 @tab punctuation @tab 9 @tab escape
@item
2 @tab word @tab 10 @tab character quote
@item
3 @tab symbol @tab 11 @tab comment-start
@item
4 @tab open parenthesis @tab 12 @tab comment-end
@item
5 @tab close parenthesis @tab 13 @tab inherit
@item
6 @tab expression prefix @tab 14 @tab generic comment
@item
7 @tab string quote @tab 15 @tab generic string
@end multitable

@noindent
For example, in the standard syntax table, the entry for @samp{(} is
@code{(4 . 41)}.  41 is the character code for @samp{)}.

  Syntax flags are encoded in higher order bits, starting 16 bits from the
least significant bit.  This table gives the power of two which corresponds
to each syntax flag.

@multitable @columnfractions .15 .3 .15 .3
@item
@i{Prefix} @tab @i{Flag} @tab @i{Prefix} @tab @i{Flag}
@item
@samp{1} @tab @code{(lsh 1 16)} @tab @samp{p} @tab @code{(lsh 1 20)}
@item
@samp{2} @tab @code{(lsh 1 17)} @tab @samp{b} @tab @code{(lsh 1 21)}
@item
@samp{3} @tab @code{(lsh 1 18)} @tab @samp{n} @tab @code{(lsh 1 22)}
@item
@samp{4} @tab @code{(lsh 1 19)}
@end multitable

@defun string-to-syntax desc
Given a syntax descriptor @var{desc} (a string), this function returns the
corresponding raw syntax descriptor.
@end defun

@defun syntax-after pos
This function returns the raw syntax descriptor for the character in the
buffer after position @var{pos}, taking account of syntax properties as well
as the syntax table.  If @var{pos} is outside the buffer's accessible
portion (@pxref{Narrowing, accessible portion}), the return value is
@code{nil}.
@end defun

@defun syntax-class syntax
This function returns the syntax code for the raw syntax descriptor
@var{syntax}.  More precisely, it takes the raw syntax descriptor's
@var{syntax-code} component, masks off the high 16 bits which record the
syntax flags, and returns the resulting integer.

If @var{syntax} is @code{nil}, the return value is returns @code{nil}.  This
is so that the expression

@example
(syntax-class (syntax-after pos))
@end example

@noindent
evaluates to @code{nil} if @code{pos} is outside the buffer's accessible
portion, without throwing errors or returning an incorrect code.
@end defun

@node Categories
@section Categories
@cindex categories of characters
@cindex character categories

  @dfn{Categories} provide an alternate way of classifying characters
syntactically.  You can define several categories as needed, then
independently assign each character to one or more categories.  Unlike
syntax classes, categories are not mutually exclusive; it is normal for one
character to belong to several categories.

@cindex category table
  Each buffer has a @dfn{category table} which records which categories are
defined and also which characters belong to each category.  Each category
table defines its own categories, but normally these are initialized by
copying from the standard categories table, so that the standard categories
are available in all modes.

  Each category has a name, which is an @acronym{ASCII} printing character in
the range @w{@samp{ }} to @samp{~}.  You specify the name of a category when
you define it with @code{define-category}.

@cindex category set
  The category table is actually a char-table (@pxref{Char-Tables}).  The
element of the category table at index @var{c} is a @dfn{category set}---a
bool-vector---that indicates which categories character @var{c} belongs to.
In this category set, if the element at index @var{cat} is @code{t}, that
means category @var{cat} is a member of the set, and that character @var{c}
belongs to category @var{cat}.

For the next three functions, the optional argument @var{table} defaults to
the current buffer's category table.

@defun define-category char docstring &optional table
This function defines a new category, with name @var{char} and documentation
@var{docstring}, for the category table @var{table}.

Here's an example of defining a new category for characters that have strong
right-to-left directionality (@pxref{Bidirectional Display})  and using it
in a special category table:

@example
(defvar special-category-table-for-bidi
  (let ((category-table (make-category-table))
	(uniprop-table (unicode-property-table-internal 'bidi-class)))
    (define-category ?R "Characters of bidi-class R, AL, or RLO"
                     category-table)
    (map-char-table
     #'(lambda (key val)
	 (if (memq val '(R AL RLO))
	     (modify-category-entry key ?R category-table)))
     uniprop-table)
    category-table))
@end example
@end defun

@defun category-docstring category &optional table
This function returns the documentation string of category @var{category} in
category table @var{table}.

@example
(category-docstring ?a)
     @result{} "ASCII"
(category-docstring ?l)
     @result{} "Latin"
@end example
@end defun

@defun get-unused-category &optional table
This function returns a category name (a character) which is not currently
defined in @var{table}.  If all possible categories are in use in
@var{table}, it returns @code{nil}.
@end defun

@defun category-table
This function returns the current buffer's category table.
@end defun

@defun category-table-p object
This function returns @code{t} if @var{object} is a category table,
otherwise @code{nil}.
@end defun

@defun standard-category-table
This function returns the standard category table.
@end defun

@defun copy-category-table &optional table
This function constructs a copy of @var{table} and returns it.  If
@var{table} is not supplied (or is @code{nil}), it returns a copy of the
standard category table.  Otherwise, an error is signaled if @var{table} is
not a category table.
@end defun

@defun set-category-table table
This function makes @var{table} the category table for the current buffer.
It returns @var{table}.
@end defun

@defun make-category-table
This creates and returns an empty category table.  In an empty category
table, no categories have been allocated, and no characters belong to any
categories.
@end defun

@defun make-category-set categories
This function returns a new category set---a bool-vector---whose initial
contents are the categories listed in the string @var{categories}.  The
elements of @var{categories} should be category names; the new category set
has @code{t} for each of those categories, and @code{nil} for all other
categories.

@example
(make-category-set "al")
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun char-category-set char
This function returns the category set for character @var{char} in the
current buffer's category table.  This is the bool-vector which records
which categories the character @var{char} belongs to.  The function
@code{char-category-set} does not allocate storage, because it returns the
same bool-vector that exists in the category table.

@example
(char-category-set ?a)
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun category-set-mnemonics category-set
This function converts the category set @var{category-set} into a string
containing the characters that designate the categories that are members of
the set.

@example
(category-set-mnemonics (char-category-set ?a))
     @result{} "al"
@end example
@end defun

@defun modify-category-entry char category &optional table reset
This function modifies the category set of @var{char} in category table
@var{table} (which defaults to the current buffer's category table).
@var{char} can be a character, or a cons cell of the form @code{(@var{min}
. @var{max})}; in the latter case, the function modifies the category sets
of all characters in the range between @var{min} and @var{max}, inclusive.

Normally, it modifies a category set by adding @var{category} to it.  But if
@var{reset} is non-@code{nil}, then it deletes @var{category} instead.
@end defun

@deffn Command describe-categories &optional buffer-or-name
This function describes the category specifications in the current category
table.  It inserts the descriptions in a buffer, and then displays that
buffer.  If @var{buffer-or-name} is non-@code{nil}, it describes the
category table of that buffer instead.
@end deffn
