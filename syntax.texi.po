# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-02-10 18:06+0900\n"
"PO-Revision-Date: 2019-02-11 11:23+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: syntax.texi.orig:6 syntax.texi.orig:7
#, no-wrap
msgid "Syntax Tables"
msgstr "Syntax Tables"

#. type: cindex
#: syntax.texi.orig:8
#, no-wrap
msgid "parsing buffer text"
msgstr "parsing buffer text"

#. type: cindex
#: syntax.texi.orig:9
#, no-wrap
msgid "syntax table"
msgstr "syntax table"

#. type: cindex
#: syntax.texi.orig:10
#, no-wrap
msgid "text parsing"
msgstr "text parsing"

#. type: Plain text
#: syntax.texi.orig:17
msgid "A @dfn{syntax table} specifies the syntactic role of each character in a buffer.  It can be used to determine where words, symbols, and other syntactic constructs begin and end.  This information is used by many Emacs facilities, including Font Lock mode (@pxref{Font Lock Mode}) and the various complex movement commands (@pxref{Motion})."
msgstr "@dfn{構文テーブル(syntax table)}は、バッファー内のそれぞれの文字にたいして、構文的な役割を指定します。単語、シンボル、その他の構文要素の開始と終了の判定に、これを使用できます。この情報はFont Lockモード(@ref{Font Lock Mode}を参照)や、種々の複雑な移動コマンド(@ref{Motion}を参照)を含む、多くのEmacs機能により使用されます。"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Basics: Syntax Basics"
msgstr "Basics: Syntax Basics"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Basic concepts of syntax tables."
msgstr "構文テーブルの基本的概念。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:87 syntax.texi.orig:88
#, no-wrap
msgid "Syntax Descriptors"
msgstr "Syntax Descriptors"

#. type: menuentry
#: syntax.texi.orig:28
msgid "How characters are classified."
msgstr "文字がクラス分けされる方法。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:390 syntax.texi.orig:391
#, no-wrap
msgid "Syntax Table Functions"
msgstr "Syntax Table Functions"

#. type: menuentry
#: syntax.texi.orig:28
msgid "How to create, examine and alter syntax tables."
msgstr "構文テーブルを作成、調査、変更する方法。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:528 syntax.texi.orig:529
#, no-wrap
msgid "Syntax Properties"
msgstr "Syntax Properties"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Overriding syntax with text properties."
msgstr "テキストプロパティによる構文テーブルのオーバーライド。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:593 syntax.texi.orig:594
#, no-wrap
msgid "Motion and Syntax"
msgstr "Motion and Syntax"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Moving over characters with certain syntaxes."
msgstr "特定の構文による文字間の移動。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:634 syntax.texi.orig:635
#, no-wrap
msgid "Parsing Expressions"
msgstr "Parsing Expressions"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Parsing balanced expressions using the syntax table."
msgstr "構文テーブル使用によるバランスのとれた式の解析。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:951 syntax.texi.orig:952
#, no-wrap
msgid "Syntax Table Internals"
msgstr "Syntax Table Internals"

#. type: menuentry
#: syntax.texi.orig:28
msgid "How syntax table information is stored."
msgstr "構文テーブルの情報が格納される方法。"

#. type: section
#: syntax.texi.orig:28 syntax.texi.orig:1048 syntax.texi.orig:1049
#, no-wrap
msgid "Categories"
msgstr "Categories"

#. type: menuentry
#: syntax.texi.orig:28
msgid "Another way of classifying character syntax."
msgstr "文字構文をクラス分けする別の手段。"

#. type: node
#: syntax.texi.orig:30
#, no-wrap
msgid "Syntax Basics"
msgstr "Syntax Basics"

#. type: section
#: syntax.texi.orig:31
#, no-wrap
msgid "Syntax Table Concepts"
msgstr "Syntax Table Concepts"

#. type: Plain text
#: syntax.texi.orig:37
msgid "A syntax table is a data structure which can be used to look up the @dfn{syntax class} and other syntactic properties of each character.  Syntax tables are used by Lisp programs for scanning and moving across text."
msgstr "構文テーブルとは、それぞれの文字の@dfn{構文クラス(syntax class)}や、その他の構文的プロパティを照合するために使用できる、データ構造のことです。構文テーブルは、テキストを横断したスキャンや移動のために、Lispプログラムにより使用されます。"

#. type: Plain text
#: syntax.texi.orig:46
msgid "Internally, a syntax table is a char-table (@pxref{Char-Tables}).  The element at index @var{c} describes the character with code @var{c}; its value is a cons cell which specifies the syntax of the character in question.  @xref{Syntax Table Internals}, for details.  However, instead of using @code{aset} and @code{aref} to modify and inspect syntax table contents, you should usually use the higher-level functions @code{char-syntax} and @code{modify-syntax-entry}, which are described in @ref{Syntax Table Functions}."
msgstr "構文テーブルは、内部的には文字テーブルです(@ref{Char-Tables}を参照)。インデックス@var{c}の要素はコード@var{c}の文字を記述します。値は該当する文字の構文を指定するコンスセルです。詳細は@xref{Syntax Table Internals}を参照してください。しかし構文テーブルの内容を変更または調べるために@code{aset}や@code{aref}を使用するかわりに、通常は高レベルな関数@code{char-syntax}や@code{modify-syntax-entry}を使用するべきです。これらについては@ref{Syntax Table Functions}で説明します。"

#. type: defun
#: syntax.texi.orig:47
#, no-wrap
msgid "syntax-table-p object"
msgstr "syntax-table-p object"

#. type: defun
#: syntax.texi.orig:49
msgid "This function returns @code{t} if @var{object} is a syntax table."
msgstr "この関数は@var{object}が構文テーブルなら、@code{t}をリターンする。"

#. type: Plain text
#: syntax.texi.orig:65
msgid "Each buffer has its own major mode, and each major mode has its own idea of the syntax class of various characters.  For example, in Lisp mode, the character @samp{;} begins a comment, but in C mode, it terminates a statement.  To support these variations, the syntax table is local to each buffer.  Typically, each major mode has its own syntax table, which it installs in all buffers that use that mode.  For example, the variable @code{emacs-lisp-mode-syntax-table} holds the syntax table used by Emacs Lisp mode, and @code{c-mode-syntax-table} holds the syntax table used by C mode.  Changing a major mode's syntax table alters the syntax in all of that mode's buffers, as well as in any buffers subsequently put in that mode.  Occasionally, several similar modes share one syntax table.  @xref{Example Major Modes}, for an example of how to set up a syntax table."
msgstr "バッファーはそれぞれ自身のメジャーモードをもち、それぞれのメジャーモードはさまざまな文字の構文クラスにたいして独自のアイデアをもっています。たとえばLisモードでは文字@samp{;}はコメントの開始ですが、Cモードでは命令文の終端になります。これらのバリエーションをサポートするために、構文テーブルはそれぞれのバッファーにたいしてローカルです。一般的に各メジャーモードは自身の構文テーブルをもち、そのモードを使用するすべてのバッファーにそれがインストールされます。たとえば変数@code{emacs-lisp-mode-syntax-table}はEmacsのLispモードが使用する構文テーブル、@code{c-mode-syntax-table}はCモードが使用する構文テーブルを保持します。あるメジャーモードの構文テーブルを変更すると、そのモードのバッファー、およびその後でそのモードに置かれるすべてのバッファーの構文も同様に変更されます。複数の類似するモードが1つの構文テーブルを共有することが、ときおりあります。構文テーブルをセットアップする方法の例は、@ref{Example Major Modes}を参照してください。"

#. type: cindex
#: syntax.texi.orig:66
#, no-wrap
msgid "standard syntax table"
msgstr "standard syntax table"

#. type: cindex
#: syntax.texi.orig:67
#, no-wrap
msgid "inheritance, syntax table"
msgstr "inheritance, syntax table"

#. type: Plain text
#: syntax.texi.orig:76
msgid "A syntax table can @dfn{inherit} from another syntax table, which is called its @dfn{parent syntax table}.  A syntax table can leave the syntax class of some characters unspecified, by giving them the ``inherit'' syntax class; such a character then acquires the syntax class specified by the parent syntax table (@pxref{Syntax Class Table}).  Emacs defines a @dfn{standard syntax table}, which is the default parent syntax table, and is also the syntax table used by Fundamental mode."
msgstr "別の構文テーブルから構文テールを@dfn{継承(inherit)}できます。これを@dfn{親構文テーブル(parent syntax table)}と呼びます。構文テーブルは、ある文字にたいして構文クラス``inherit''を与えることにより、構文クラスを未指定にしておくことができます。そのような文字は、親構文テーブルが指定する構文クラスを取得します(@ref{Syntax Class Table}を参照)。Emacsは@dfn{標準構文テーブル(standard syntax table)}を定義します。これはデフォルトとなる親構文テーブルであり、Fundamentalモードが使用する構文テーブルでもあります。"

#. type: defun
#: syntax.texi.orig:77
#, no-wrap
msgid "standard-syntax-table"
msgstr "standard-syntax-table"

#. type: defun
#: syntax.texi.orig:80
msgid "This function returns the standard syntax table, which is the syntax table used in Fundamental mode."
msgstr "この関数はFundamentalモードが使用する構文テーブルである、標準構文テーブルをリターンする。"

#. type: Plain text
#: syntax.texi.orig:86
msgid "Syntax tables are not used by the Emacs Lisp reader, which has its own built-in syntactic rules which cannot be changed.  (Some Lisp systems provide ways to redefine the read syntax, but we decided to leave this feature out of Emacs Lisp for simplicity.)"
msgstr "Emacs Lispリーダーは変更不可な独自のビルトイン構文ルールをもつので、構文テーブルは使用しません(いくつかのLispシステムはリード構文を再定義する手段を提供するが、わたしたちは単純化のためこの機能をEmacs Lisp外部に留める決定をした)。"

#. type: cindex
#: syntax.texi.orig:89
#, no-wrap
msgid "syntax class"
msgstr "syntax class"

#. type: Plain text
#: syntax.texi.orig:95
msgid "The @dfn{syntax class} of a character describes its syntactic role.  Each syntax table specifies the syntax class of each character.  There is no necessary relationship between the class of a character in one syntax table and its class in any other table."
msgstr "@dfn{構文クラス(syntax class)}の文字は、その文字の構文的な役割を記述します。各構文テーブルは、それぞれの文字の構文クラスを指定します。ある構文テーブルでの文字のクラスと、別のテーブルにおけるその文字のクラスとの間に関連性がある必要はありません。"

#. type: Plain text
#: syntax.texi.orig:104
msgid "Each syntax class is designated by a mnemonic character, which serves as the name of the class when you need to specify a class.  Usually, this designator character is one that is often assigned that class; however, its meaning as a designator is unvarying and independent of what syntax that character currently has.  Thus, @samp{\\} as a designator character always means ``escape character'' syntax, regardless of whether the @samp{\\} character actually has that syntax in the current syntax table."
msgstr "構文テーブルはそれぞれニーモニック文字(mnemonic character)により選別され、クラスを指定する必要がある際にはそのクラスの名前としての役割を果たします。この指定子文字(designator character)は通常、そのクラスに割当てられることが多々あります。しかしその指定子としての意味は不変であり、その文字がカレントでもつ構文とは独立しています。つまりカレント構文テーブルにおいて実際に文字@samp{\\}が構文をもつかどうかに関係なく、指定子文字としての@samp{\\}は常に``エスケープ文字(escape characte)r''を意味します。"

#. type: ifnottex
#: syntax.texi.orig:107
msgid "@xref{Syntax Class Table}, for a list of syntax classes and their designator characters."
msgstr "構文クラスとそれらの指定子文字のリストは、@ref{Syntax Class Table}を参照してください。"

#. type: cindex
#: syntax.texi.orig:109
#, no-wrap
msgid "syntax descriptor"
msgstr "syntax descriptor"

#. type: Plain text
#: syntax.texi.orig:115
msgid "A @dfn{syntax descriptor} is a Lisp string that describes the syntax class and other syntactic properties of a character.  When you want to modify the syntax of a character, that is done by calling the function @code{modify-syntax-entry} and passing a syntax descriptor as one of its arguments (@pxref{Syntax Table Functions})."
msgstr "@dfn{構文記述子(syntax descriptor)}とは、文字の構文クラスと、その他の構文的なプロパティを記述するLisp文字列のことです。ある文字の構文を変更したい際、それは関数@code{modify-syntax-entry}を呼び出して、その引数に構文記述子を渡すことにより行われます(@ref{Syntax Table Functions}を参照)。"

#. type: Plain text
#: syntax.texi.orig:122
msgid "The first character in a syntax descriptor must be a syntax class designator character.  The second character, if present, specifies a matching character (e.g., in Lisp, the matching character for @samp{(} is @samp{)}); a space specifies that there is no matching character.  Then come characters specifying additional syntax properties (@pxref{Syntax Flags})."
msgstr "構文記述子の1つ目の文字は、構文クラスの指定子文字でなければなりません。2つ目の文字がもしあれば、マッチング文字を指定します(Lispでは@samp{(}にたいするマッチング文字は@samp{)})。スペースはマッチング文字が存在しないことを指定します。その後に続く文字は、追加の構文プロパティを指定します(@ref{Syntax Flags}を参照)。"

#. type: Plain text
#: syntax.texi.orig:125
msgid "If no matching character or flags are needed, only one character (specifying the syntax class) is sufficient."
msgstr "マッチング文字やフラグが必要なければ、(構文クラスを指定する)1つの文字だけで十分です。"

#. type: Plain text
#: syntax.texi.orig:132
msgid "For example, the syntax descriptor for the character @samp{*} in C mode is @code{\". 23\"} (i.e., punctuation, matching character slot unused, second character of a comment-starter, first character of a comment-ender), and the entry for @samp{/} is @samp{@w{. 14}} (i.e., punctuation, matching character slot unused, first character of a comment-starter, second character of a comment-ender)."
msgstr "たとえばCモードでの文字@samp{*}の構文記述子は@code{\". 23\"}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の2つ目の文字、コメント終了記号の1つ目の文字)、@samp{/}にたいするエントリーは@samp{@w{. 14}}(区切り記号、マッチング文字用スロットは未使用、コメント開始記号の1つ目の文字、コメント終了記号の2つ目の文字)です。"

#. type: Plain text
#: syntax.texi.orig:136
msgid "Emacs also defines @dfn{raw syntax descriptors}, which are used to describe syntax classes at a lower level.  @xref{Syntax Table Internals}."
msgstr "Emacsは、低レベルでの構文クラスを記述するために使用される@dfn{raw構文記述子(raw syntax descriptors)}も定義しています。@ref{Syntax Table Internals}を参照してください。"

#. type: node
#: syntax.texi.orig:140 syntax.texi.orig:142
#, no-wrap
msgid "Syntax Class Table"
msgstr "Syntax Class Table"

#. type: menuentry
#: syntax.texi.orig:140
msgid "Table of syntax classes."
msgstr "構文クラスのテーブル。"

#. type: subsection
#: syntax.texi.orig:140 syntax.texi.orig:283 syntax.texi.orig:284
#, no-wrap
msgid "Syntax Flags"
msgstr "Syntax Flags"

#. type: menuentry
#: syntax.texi.orig:140
msgid "Additional flags each character can have."
msgstr "各文字が所有できる追加のフラグ。"

#. type: subsection
#: syntax.texi.orig:143
#, no-wrap
msgid "Table of Syntax Classes"
msgstr ""

#. type: cindex
#: syntax.texi.orig:144
#, no-wrap
msgid "syntax class table"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:148
msgid "Here is a table of syntax classes, the characters that designate them, their meanings, and examples of their use."
msgstr ""

#. type: item
#: syntax.texi.orig:150
#, no-wrap
msgid "Whitespace characters: @samp{@ } or @samp{-}"
msgstr ""

#. type: table
#: syntax.texi.orig:156
msgid "Characters that separate symbols and words from each other.  Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one.  Space, tab, and formfeed are classified as whitespace in almost all major modes."
msgstr ""

#. type: table
#: syntax.texi.orig:159
msgid "This syntax class can be designated by either @w{@samp{@ }} or @samp{-}.  Both designators are equivalent."
msgstr ""

#. type: item
#: syntax.texi.orig:160
#, no-wrap
msgid "Word constituents: @samp{w}"
msgstr ""

#. type: table
#: syntax.texi.orig:164
msgid "Parts of words in human languages.  These are typically used in variable and command names in programs.  All upper- and lower-case letters, and the digits, are typically word constituents."
msgstr ""

#. type: item
#: syntax.texi.orig:165
#, no-wrap
msgid "Symbol constituents: @samp{_}"
msgstr ""

#. type: table
#: syntax.texi.orig:171
msgid "Extra characters used in variable and command names along with word constituents.  Examples include the characters @samp{$&*+-_<>} in Lisp mode, which may be part of a symbol name even though they are not part of English words.  In standard C, the only non-word-constituent character that is valid in symbols is underscore (@samp{_})."
msgstr ""

#. type: item
#: syntax.texi.orig:172
#, no-wrap
msgid "Punctuation characters: @samp{.}"
msgstr ""

#. type: table
#: syntax.texi.orig:179
msgid "Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another.  Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses.  Other programming language modes, such as C mode, use punctuation syntax for operators."
msgstr ""

#. type: item
#: syntax.texi.orig:180
#, no-wrap
msgid "Open parenthesis characters: @samp{(}"
msgstr ""

#. type: itemx
#: syntax.texi.orig:181
#, no-wrap
msgid "Close parenthesis characters: @samp{)}"
msgstr ""

#. type: table
#: syntax.texi.orig:188
msgid "Characters used in dissimilar pairs to surround sentences or expressions.  Such a grouping is begun with an open parenthesis character and terminated with a close.  Each open parenthesis character matches a particular close parenthesis character, and vice versa.  Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis.  @xref{Blinking}."
msgstr ""

#. type: table
#: syntax.texi.orig:193
msgid "In human languages, and in C code, the parenthesis pairs are @samp{()}, @samp{[]}, and @samp{@{@}}.  In Emacs Lisp, the delimiters for lists and vectors (@samp{()} and @samp{[]}) are classified as parenthesis characters."
msgstr ""

#. type: item
#: syntax.texi.orig:194
#, no-wrap
msgid "String quotes: @samp{\"}"
msgstr ""

#. type: table
#: syntax.texi.orig:198
msgid "Characters used to delimit string constants.  The same string quote character appears at the beginning and the end of a string.  Such quoted strings do not nest."
msgstr ""

#. type: table
#: syntax.texi.orig:202
msgid "The parsing facilities of Emacs consider a string as a single token.  The usual syntactic meanings of the characters in the string are suppressed."
msgstr ""

#. type: table
#: syntax.texi.orig:208
msgid "The Lisp modes have two string quote characters: double-quote (@samp{\"})  and vertical bar (@samp{|}).  @samp{|} is not used in Emacs Lisp, but it is used in Common Lisp.  C also has two string quote characters: double-quote for strings, and single-quote (@samp{'}) for character constants."
msgstr ""

#. type: table
#: syntax.texi.orig:212
msgid "Human text has no string quote characters.  We do not want quotation marks to turn off the usual syntactic properties of other characters in the quotation."
msgstr ""

#. type: item
#: syntax.texi.orig:213
#, no-wrap
msgid "Escape-syntax characters: @samp{\\}"
msgstr ""

#. type: table
#: syntax.texi.orig:219
msgid "Characters that start an escape sequence, such as is used in string and character constants.  The character @samp{\\} belongs to this class in both C and Lisp.  (In C, it is used thus only inside strings, but it turns out to cause no trouble to treat it this way throughout C code.)"
msgstr ""

#. type: table
#: syntax.texi.orig:222 syntax.texi.orig:230
msgid "Characters in this class count as part of words if @code{words-include-escapes} is non-@code{nil}.  @xref{Word Motion}."
msgstr ""

#. type: item
#: syntax.texi.orig:223
#, no-wrap
msgid "Character quotes: @samp{/}"
msgstr ""

#. type: table
#: syntax.texi.orig:227
msgid "Characters used to quote the following character so that it loses its normal syntactic meaning.  This differs from an escape character in that only the character immediately following is ever affected."
msgstr ""

#. type: table
#: syntax.texi.orig:232
msgid "This class is used for backslash in @TeX{} mode."
msgstr ""

#. type: item
#: syntax.texi.orig:233
#, no-wrap
msgid "Paired delimiters: @samp{$}"
msgstr ""

#. type: table
#: syntax.texi.orig:238
msgid "Similar to string quote characters, except that the syntactic properties of the characters between the delimiters are not suppressed.  Only @TeX{} mode uses a paired delimiter presently---the @samp{$} that both enters and leaves math mode."
msgstr ""

#. type: item
#: syntax.texi.orig:239
#, no-wrap
msgid "Expression prefixes: @samp{'}"
msgstr ""

#. type: table
#: syntax.texi.orig:245
msgid "Characters used for syntactic operators that are considered as part of an expression if they appear next to one.  In Lisp modes, these characters include the apostrophe, @samp{'} (used for quoting), the comma, @samp{,} (used in macros), and @samp{#} (used in the read syntax for certain data types)."
msgstr ""

#. type: item
#: syntax.texi.orig:246
#, no-wrap
msgid "Comment starters: @samp{<}"
msgstr ""

#. type: itemx
#: syntax.texi.orig:247
#, no-wrap
msgid "Comment enders: @samp{>}"
msgstr ""

#. type: cindex
#: syntax.texi.orig:248
#, no-wrap
msgid "comment syntax"
msgstr ""

#. type: table
#: syntax.texi.orig:252
msgid "Characters used in various languages to delimit comments.  Human text has no comment characters.  In Lisp, the semicolon (@samp{;}) starts a comment and a newline or formfeed ends one."
msgstr ""

#. type: item
#: syntax.texi.orig:253
#, no-wrap
msgid "Inherit standard syntax: @samp{@@}"
msgstr ""

#. type: table
#: syntax.texi.orig:257
msgid "This syntax class does not specify a particular syntax.  It says to look in the standard syntax table to find the syntax of this character."
msgstr ""

#. type: item
#: syntax.texi.orig:258
#, no-wrap
msgid "Generic comment delimiters: @samp{!}"
msgstr ""

#. type: table
#: syntax.texi.orig:263
msgid "Characters that start or end a special kind of comment.  @emph{Any} generic comment delimiter matches @emph{any} generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other."
msgstr ""

#. type: table
#: syntax.texi.orig:269
msgid "This syntax class is primarily meant for use with the @code{syntax-table} text property (@pxref{Syntax Properties}).  You can mark any range of characters as forming a comment, by giving the first and last characters of the range @code{syntax-table} properties identifying them as generic comment delimiters."
msgstr ""

#. type: item
#: syntax.texi.orig:270
#, no-wrap
msgid "Generic string delimiters: @samp{|}"
msgstr ""

#. type: table
#: syntax.texi.orig:275
msgid "Characters that start or end a string.  This class differs from the string quote class in that @emph{any} generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters."
msgstr ""

#. type: table
#: syntax.texi.orig:281
msgid "This syntax class is primarily meant for use with the @code{syntax-table} text property (@pxref{Syntax Properties}).  You can mark any range of characters as forming a string constant, by giving the first and last characters of the range @code{syntax-table} properties identifying them as generic string delimiters."
msgstr ""

#. type: cindex
#: syntax.texi.orig:285
#, no-wrap
msgid "syntax flags"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:291
msgid "In addition to the classes, entries for characters in a syntax table can specify flags.  There are eight possible flags, represented by the characters @samp{1}, @samp{2}, @samp{3}, @samp{4}, @samp{b}, @samp{c}, @samp{n}, and @samp{p}."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:303
msgid "All the flags except @samp{p} are used to describe comment delimiters.  The digit flags are used for comment delimiters made up of 2 characters.  They indicate that a character can @emph{also} be part of a comment sequence, in addition to the syntactic properties associated with its character class.  The flags are independent of the class and each other for the sake of characters such as @samp{*} in C mode, which is a punctuation character, @emph{and} the second character of a start-of-comment sequence (@samp{/*}), @emph{and} the first character of an end-of-comment sequence (@samp{*/}).  The flags @samp{b}, @samp{c}, and @samp{n} are used to qualify the corresponding comment delimiter."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:306
msgid "Here is a table of the possible flags for a character @var{c}, and what they mean:"
msgstr ""

#. type: itemize
#: syntax.texi.orig:311
msgid "@samp{1} means @var{c} is the start of a two-character comment-start sequence."
msgstr ""

#. type: itemize
#: syntax.texi.orig:314
msgid "@samp{2} means @var{c} is the second character of such a sequence."
msgstr ""

#. type: itemize
#: syntax.texi.orig:318
msgid "@samp{3} means @var{c} is the start of a two-character comment-end sequence."
msgstr ""

#. type: itemize
#: syntax.texi.orig:321
msgid "@samp{4} means @var{c} is the second character of such a sequence."
msgstr ""

#. type: itemize
#: syntax.texi.orig:327
msgid "@samp{b} means that @var{c} as a comment delimiter belongs to the alternative ``b'' comment style.  For a two-character comment starter, this flag is only significant on the second char, and for a 2-character comment ender it is only significant on the first char."
msgstr ""

#. type: itemize
#: syntax.texi.orig:332
msgid "@samp{c} means that @var{c} as a comment delimiter belongs to the alternative ``c'' comment style.  For a two-character comment delimiter, @samp{c} on either character makes it of style ``c''."
msgstr ""

#. type: itemize
#: syntax.texi.orig:338
msgid "@samp{n} on a comment delimiter character specifies that this kind of comment can be nested.  For a two-character comment delimiter, @samp{n} on either character makes it nestable."
msgstr ""

#. type: cindex
#: syntax.texi.orig:339
#, no-wrap
msgid "comment style"
msgstr ""

#. type: itemize
#: syntax.texi.orig:347
msgid "Emacs supports several comment styles simultaneously in any one syntax table.  A comment style is a set of flags @samp{b}, @samp{c}, and @samp{n}, so there can be up to 8 different comment styles.  Each comment delimiter has a style and only matches comment delimiters of the same style.  Thus if a comment starts with the comment-start sequence of style ``bn'', it will extend until the next matching comment-end sequence of style ``bn''."
msgstr ""

#. type: itemize
#: syntax.texi.orig:349
msgid "The appropriate comment syntax settings for C++ can be as follows:"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:351
#, no-wrap
msgid "/"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:353
msgid "124"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:353
#, no-wrap
msgid "*"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:355
msgid "23b"
msgstr ""

#. type: item
#: syntax.texi.orig:355 syntax.texi.orig:374
#, no-wrap
msgid "newline"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:357
msgid ">"
msgstr ""

#. type: itemize
#: syntax.texi.orig:360
msgid "This defines four comment-delimiting sequences:"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:362
#, no-wrap
msgid "/*"
msgstr ""

#. type: table
#: syntax.texi.orig:365
msgid "This is a comment-start sequence for ``b'' style because the second character, @samp{*}, has the @samp{b} flag."
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:366
#, no-wrap
msgid "//"
msgstr ""

#. type: table
#: syntax.texi.orig:369
msgid "This is a comment-start sequence for ``a'' style because the second character, @samp{/}, does not have the @samp{b} flag."
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:370
#, no-wrap
msgid "*/"
msgstr ""

#. type: table
#: syntax.texi.orig:373
msgid "This is a comment-end sequence for ``b'' style because the first character, @samp{*}, has the @samp{b} flag."
msgstr ""

#. type: table
#: syntax.texi.orig:377
msgid "This is a comment-end sequence for ``a'' style, because the newline character does not have the @samp{b} flag."
msgstr ""

#. type: itemize
#: syntax.texi.orig:384
msgid "@samp{p} identifies an additional ``prefix character'' for Lisp syntax.  These characters are treated as whitespace when they appear between expressions.  When they appear within an expression, they are handled according to their usual syntax classes."
msgstr ""

#. type: itemize
#: syntax.texi.orig:388
msgid "The function @code{backward-prefix-chars} moves back over these characters, as well as over characters whose primary syntax class is prefix (@samp{'}).  @xref{Motion and Syntax}."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:395
msgid "In this section we describe functions for creating, accessing and altering syntax tables."
msgstr ""

#. type: defun
#: syntax.texi.orig:396
#, no-wrap
msgid "make-syntax-table &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:400
msgid "This function creates a new syntax table.  If @var{table} is non-@code{nil}, the parent of the new syntax table is @var{table}; otherwise, the parent is the standard syntax table."
msgstr ""

#. type: defun
#: syntax.texi.orig:404
msgid "In the new syntax table, all characters are initially given the ``inherit'' (@samp{@@}) syntax class, i.e., their syntax is inherited from the parent table (@pxref{Syntax Class Table})."
msgstr ""

#. type: defun
#: syntax.texi.orig:406
#, no-wrap
msgid "copy-syntax-table &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:411
msgid "This function constructs a copy of @var{table} and returns it.  If @var{table} is omitted or @code{nil}, it returns a copy of the standard syntax table.  Otherwise, an error is signaled if @var{table} is not a syntax table."
msgstr ""

#. type: deffn
#: syntax.texi.orig:413
#, no-wrap
msgid "Command modify-syntax-entry char syntax-descriptor  &optional table"
msgstr ""

#. type: cindex
#: syntax.texi.orig:414
#, no-wrap
msgid "syntax entry, setting"
msgstr ""

#. type: deffn
#: syntax.texi.orig:420
msgid "This function sets the syntax entry for @var{char} according to @var{syntax-descriptor}.  @var{char} must be a character, or a cons cell of the form @code{(@var{min} . @var{max})}; in the latter case, the function sets the syntax entries for all characters in the range between @var{min} and @var{max}, inclusive."
msgstr ""

#. type: deffn
#: syntax.texi.orig:423
msgid "The syntax is changed only for @var{table}, which defaults to the current buffer's syntax table, and not in any other syntax table."
msgstr ""

#. type: deffn
#: syntax.texi.orig:429
msgid "The argument @var{syntax-descriptor} is a syntax descriptor, i.e., a string whose first character is a syntax class designator and whose second and subsequent characters optionally specify a matching character and syntax flags.  @xref{Syntax Descriptors}.  An error is signaled if @var{syntax-descriptor} is not a valid syntax descriptor."
msgstr ""

#. type: deffn
#: syntax.texi.orig:432
msgid "This function always returns @code{nil}.  The old syntax information in the table for this character is discarded."
msgstr ""

#. type: exdent
#: syntax.texi.orig:435
#, no-wrap
msgid "@r{Examples:}"
msgstr ""

#. type: group
#: syntax.texi.orig:440
#, no-wrap
msgid ""
";; @r{Put the space character in class whitespace.}\n"
"(modify-syntax-entry ?\\s \" \")\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: syntax.texi.orig:447
#, no-wrap
msgid ""
";; @r{Make @samp{$} an open parenthesis character,}\n"
";;   @r{with @samp{^} as its matching close.}\n"
"(modify-syntax-entry ?$ \"(^\")\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: syntax.texi.orig:454
#, no-wrap
msgid ""
";; @r{Make @samp{^} a close parenthesis character,}\n"
";;   @r{with @samp{$} as its matching open.}\n"
"(modify-syntax-entry ?^ \")$\")\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: syntax.texi.orig:463
#, no-wrap
msgid ""
";; @r{Make @samp{/} a punctuation character,}\n"
";;   @r{the first character of a start-comment sequence,}\n"
";;   @r{and the second character of an end-comment sequence.}\n"
";;   @r{This is used in C mode.}\n"
"(modify-syntax-entry ?/ \". 14\")\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:467
#, no-wrap
msgid "char-syntax character"
msgstr ""

#. type: defun
#: syntax.texi.orig:472
msgid "This function returns the syntax class of @var{character}, represented by its designator character (@pxref{Syntax Class Table}).  This returns @emph{only} the class, not its matching character or syntax flags."
msgstr ""

#. type: defun
#: syntax.texi.orig:475
msgid "The following examples apply to C mode.  (We use @code{string} to make it easier to see the character returned by @code{char-syntax}.)"
msgstr ""

#. type: group
#: syntax.texi.orig:481
#, no-wrap
msgid ""
";; Space characters have whitespace syntax class.\n"
"(string (char-syntax ?\\s))\n"
"     @result{} \" \"\n"
msgstr ""

#. type: group
#: syntax.texi.orig:489
#, no-wrap
msgid ""
";; Forward slash characters have punctuation syntax.\n"
";; Note that this @code{char-syntax} call does not reveal\n"
";; that it is also part of comment-start and -end sequences.\n"
"(string (char-syntax ?/))\n"
"     @result{} \".\"\n"
msgstr ""

#. type: group
#: syntax.texi.orig:497
#, no-wrap
msgid ""
";; Open parenthesis characters have open parenthesis syntax.\n"
";; Note that this @code{char-syntax} call does not reveal that\n"
";; it has a matching character, @samp{)}.\n"
"(string (char-syntax ?\\())\n"
"     @result{} \"(\"\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:502
#, no-wrap
msgid "set-syntax-table table"
msgstr ""

#. type: defun
#: syntax.texi.orig:505
msgid "This function makes @var{table} the syntax table for the current buffer.  It returns @var{table}."
msgstr ""

#. type: var{#1}
#: syntax.texi.orig:507 syntax.texi.orig:540
#, no-wrap
msgid "syntax-table"
msgstr ""

#. type: defun
#: syntax.texi.orig:510
msgid "This function returns the current syntax table, which is the table for the current buffer."
msgstr ""

#. type: deffn
#: syntax.texi.orig:512
#, no-wrap
msgid "Command describe-syntax &optional buffer"
msgstr ""

#. type: deffn
#: syntax.texi.orig:515
msgid "This command displays the contents of the syntax table of @var{buffer} (by default, the current buffer) in a help buffer."
msgstr ""

#. type: defmac
#: syntax.texi.orig:517
#, no-wrap
msgid "with-syntax-table table body@dots{}"
msgstr ""

#. type: defmac
#: syntax.texi.orig:521
msgid "This macro executes @var{body} using @var{table} as the current syntax table.  It returns the value of the last form in @var{body}, after restoring the old current syntax table."
msgstr ""

#. type: defmac
#: syntax.texi.orig:526
msgid "Since each buffer has its own current syntax table, we should make that more precise: @code{with-syntax-table} temporarily alters the current syntax table of whichever buffer is current at the time the macro execution starts.  Other buffers are not affected."
msgstr ""

#. type: kindex
#: syntax.texi.orig:530
#, no-wrap
msgid "syntax-table @r{(text property)}"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:536
msgid "When the syntax table is not flexible enough to specify the syntax of a language, you can override the syntax table for specific character occurrences in the buffer, by applying a @code{syntax-table} text property.  @xref{Text Properties}, for how to apply text properties."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:538
msgid "The valid values of @code{syntax-table} text property are:"
msgstr ""

#. type: table
#: syntax.texi.orig:544
msgid "If the property value is a syntax table, that table is used instead of the current buffer's syntax table to determine the syntax for the underlying text character."
msgstr ""

#. type: code{#1}
#: syntax.texi.orig:545
#, no-wrap
msgid "(@var{syntax-code} . @var{matching-char})"
msgstr ""

#. type: table
#: syntax.texi.orig:549
msgid "A cons cell of this format is a raw syntax descriptor (@pxref{Syntax Table Internals}), which directly specifies a syntax class for the underlying text character."
msgstr ""

#. type: code{#1}
#: syntax.texi.orig:550
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: syntax.texi.orig:553
msgid "If the property is @code{nil}, the character's syntax is determined from the current syntax table in the usual way."
msgstr ""

#. type: vindex
#: syntax.texi.orig:555 syntax.texi.orig:944
#, no-wrap
msgid "parse-sexp-lookup-properties"
msgstr ""

#. type: defvar
#: syntax.texi.orig:559
msgid "If this is non-@code{nil}, the syntax scanning functions, like @code{forward-sexp}, pay attention to syntax text properties.  Otherwise they use only the current syntax table."
msgstr ""

#. type: defvar
#: syntax.texi.orig:561
#, no-wrap
msgid "syntax-propertize-function"
msgstr ""

#. type: defvar
#: syntax.texi.orig:566
msgid "This variable, if non-@code{nil}, should store a function for applying @code{syntax-table} properties to a specified stretch of text.  It is intended to be used by major modes to install a function which applies @code{syntax-table} properties in some mode-appropriate way."
msgstr ""

#. type: defvar
#: syntax.texi.orig:576
msgid "The function is called by @code{syntax-ppss} (@pxref{Position Parse}), and by Font Lock mode during syntactic fontification (@pxref{Syntactic Font Lock}).  It is called with two arguments, @var{start} and @var{end}, which are the starting and ending positions of the text on which it should act.  It is allowed to call @code{syntax-ppss} on any position before @var{end}.  However, it should not call @code{syntax-ppss-flush-cache}; so, it is not allowed to call @code{syntax-ppss} on some position and later modify the buffer at an earlier position."
msgstr ""

#. type: defvar
#: syntax.texi.orig:578
#, no-wrap
msgid "syntax-propertize-extend-region-functions"
msgstr ""

#. type: defvar
#: syntax.texi.orig:585
msgid "This abnormal hook is run by the syntax parsing code prior to calling @code{syntax-propertize-function}.  Its role is to help locate safe starting and ending buffer positions for passing to @code{syntax-propertize-function}.  For example, a major mode can add a function to this hook to identify multi-line syntactic constructs, and ensure that the boundaries do not fall in the middle of one."
msgstr ""

#. type: defvar
#: syntax.texi.orig:591
msgid "Each function in this hook should accept two arguments, @var{start} and @var{end}.  It should return either a cons cell of two adjusted buffer positions, @code{(@var{new-start} . @var{new-end})}, or @code{nil} if no adjustment is necessary.  The hook functions are run in turn, repeatedly, until they all return @code{nil}."
msgstr ""

#. type: cindex
#: syntax.texi.orig:595
#, no-wrap
msgid "moving across syntax classes"
msgstr ""

#. type: cindex
#: syntax.texi.orig:596
#, no-wrap
msgid "skipping characters of certain syntax"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:600
msgid "This section describes functions for moving across characters that have certain syntax classes."
msgstr ""

#. type: defun
#: syntax.texi.orig:601
#, no-wrap
msgid "skip-syntax-forward syntaxes &optional limit"
msgstr ""

#. type: defun
#: syntax.texi.orig:607
msgid "This function moves point forward across characters having syntax classes mentioned in @var{syntaxes} (a string of syntax class characters).  It stops when it encounters the end of the buffer, or position @var{limit} (if specified), or a character it is not supposed to skip."
msgstr ""

#. type: defun
#: syntax.texi.orig:610 syntax.texi.orig:623
msgid "If @var{syntaxes} starts with @samp{^}, then the function skips characters whose syntax is @emph{not} in @var{syntaxes}."
msgstr ""

#. type: defun
#: syntax.texi.orig:613
msgid "The return value is the distance traveled, which is a nonnegative integer."
msgstr ""

#. type: defun
#: syntax.texi.orig:615
#, no-wrap
msgid "skip-syntax-backward syntaxes &optional limit"
msgstr ""

#. type: defun
#: syntax.texi.orig:620
msgid "This function moves point backward across characters whose syntax classes are mentioned in @var{syntaxes}.  It stops when it encounters the beginning of the buffer, or position @var{limit} (if specified), or a character it is not supposed to skip."
msgstr ""

#. type: defun
#: syntax.texi.orig:626
msgid "The return value indicates the distance traveled.  It is an integer that is zero or less."
msgstr ""

#. type: defun
#: syntax.texi.orig:628
#, no-wrap
msgid "backward-prefix-chars"
msgstr ""

#. type: defun
#: syntax.texi.orig:632
msgid "This function moves point backward over any number of characters with expression prefix syntax.  This includes both characters in the expression prefix syntax class, and characters with the @samp{p} flag."
msgstr ""

#. type: cindex
#: syntax.texi.orig:636
#, no-wrap
msgid "parsing expressions"
msgstr ""

#. type: cindex
#: syntax.texi.orig:637
#, no-wrap
msgid "scanning expressions"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:648
msgid "This section describes functions for parsing and scanning balanced expressions.  We will refer to such expressions as @dfn{sexps}, following the terminology of Lisp, even though these functions can act on languages other than Lisp.  Basically, a sexp is either a balanced parenthetical grouping, a string, or a ``symbol'' (i.e., a sequence of characters whose syntax is either word constituent or symbol constituent).  However, characters in the expression prefix syntax class (@pxref{Syntax Class Table}) are treated as part of the sexp if they appear next to it."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:653
msgid "The syntax table controls the interpretation of characters, so these functions can be used for Lisp expressions when in Lisp mode and for C expressions when in C mode.  @xref{List Motion}, for convenient higher-level functions for moving over balanced expressions."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:660
msgid "A character's syntax controls how it changes the state of the parser, rather than describing the state itself.  For example, a string delimiter character toggles the parser state between ``in-string'' and ``in-code'', but the syntax of characters does not directly say whether they are inside a string.  For example (note that 15 is the syntax code for generic string delimiters),"
msgstr ""

#. type: example
#: syntax.texi.orig:663
#, no-wrap
msgid "(put-text-property 1 9 'syntax-table '(15 . nil))\n"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:669
msgid "does not tell Emacs that the first eight chars of the current buffer are a string, but rather that they are all string delimiters.  As a result, Emacs treats them as four consecutive empty string constants."
msgstr ""

#. type: node
#: syntax.texi.orig:676 syntax.texi.orig:678
#, no-wrap
msgid "Motion via Parsing"
msgstr ""

#. type: menuentry
#: syntax.texi.orig:676
msgid "Motion functions that work by parsing."
msgstr ""

#. type: node
#: syntax.texi.orig:676 syntax.texi.orig:744
#, no-wrap
msgid "Position Parse"
msgstr ""

#. type: menuentry
#: syntax.texi.orig:676
msgid "Determining the syntactic state of a position."
msgstr ""

#. type: subsection
#: syntax.texi.orig:676 syntax.texi.orig:801 syntax.texi.orig:802
#, no-wrap
msgid "Parser State"
msgstr ""

#. type: menuentry
#: syntax.texi.orig:676
msgid "How Emacs represents a syntactic state."
msgstr ""

#. type: subsection
#: syntax.texi.orig:676 syntax.texi.orig:888 syntax.texi.orig:889
#, no-wrap
msgid "Low-Level Parsing"
msgstr ""

#. type: menuentry
#: syntax.texi.orig:676
msgid "Parsing across a specified region."
msgstr ""

#. type: node
#: syntax.texi.orig:676 syntax.texi.orig:926
#, no-wrap
msgid "Control Parsing"
msgstr ""

#. type: menuentry
#: syntax.texi.orig:676
msgid "Parameters that affect parsing."
msgstr ""

#. type: subsection
#: syntax.texi.orig:679
#, no-wrap
msgid "Motion Commands Based on Parsing"
msgstr ""

#. type: cindex
#: syntax.texi.orig:680
#, no-wrap
msgid "motion based on parsing"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:684
msgid "This section describes simple point-motion functions that operate based on parsing expressions."
msgstr ""

#. type: defun
#: syntax.texi.orig:685
#, no-wrap
msgid "scan-lists from count depth"
msgstr ""

#. type: defun
#: syntax.texi.orig:689
msgid "This function scans forward @var{count} balanced parenthetical groupings from position @var{from}.  It returns the position where the scan stops.  If @var{count} is negative, the scan moves backwards."
msgstr ""

#. type: defun
#: syntax.texi.orig:697
msgid "If @var{depth} is nonzero, treat the starting position as being @var{depth} parentheses deep.  The scanner moves forward or backward through the buffer until the depth changes to zero @var{count} times.  Hence, a positive value for @var{depth} has the effect of moving out @var{depth} levels of parenthesis from the starting position, while a negative @var{depth} has the effect of moving deeper by @var{-depth} levels of parenthesis."
msgstr ""

#. type: defun
#: syntax.texi.orig:700 syntax.texi.orig:714
msgid "Scanning ignores comments if @code{parse-sexp-ignore-comments} is non-@code{nil}."
msgstr ""

#. type: defun
#: syntax.texi.orig:705
msgid "If the scan reaches the beginning or end of the accessible part of the buffer before it has scanned over @var{count} parenthetical groupings, the return value is @code{nil} if the depth at that point is zero; if the depth is non-zero, a @code{scan-error} error is signaled."
msgstr ""

#. type: defun
#: syntax.texi.orig:707
#, no-wrap
msgid "scan-sexps from count"
msgstr ""

#. type: defun
#: syntax.texi.orig:711
msgid "This function scans forward @var{count} sexps from position @var{from}.  It returns the position where the scan stops.  If @var{count} is negative, the scan moves backwards."
msgstr ""

#. type: defun
#: syntax.texi.orig:719
msgid "If the scan reaches the beginning or end of (the accessible part of) the buffer while in the middle of a parenthetical grouping, an error is signaled.  If it reaches the beginning or end between groupings but before count is used up, @code{nil} is returned."
msgstr ""

#. type: defun
#: syntax.texi.orig:721
#, no-wrap
msgid "forward-comment count"
msgstr ""

#. type: defun
#: syntax.texi.orig:733
msgid "This function moves point forward across @var{count} complete comments (that is, including the starting delimiter and the terminating delimiter if any), plus any whitespace encountered on the way.  It moves backward if @var{count} is negative.  If it encounters anything other than a comment or whitespace, it stops, leaving point at the place where it stopped.  This includes (for instance) finding the end of a comment when moving forward and expecting the beginning of one.  The function also stops immediately after moving over the specified number of complete comments.  If @var{count} comments are found as expected, with nothing except whitespace between them, it returns @code{t}; otherwise it returns @code{nil}."
msgstr ""

#. type: defun
#: syntax.texi.orig:737
msgid "This function cannot tell whether the ``comments'' it traverses are embedded within a string.  If they look like comments, it treats them as comments."
msgstr ""

#. type: defun
#: syntax.texi.orig:742
msgid "To move forward over all comments and whitespace following point, use @code{(forward-comment (buffer-size))}.  @code{(buffer-size)} is a good argument to use, because the number of comments in the buffer cannot exceed that many."
msgstr ""

#. type: subsection
#: syntax.texi.orig:745
#, no-wrap
msgid "Finding the Parse State for a Position"
msgstr ""

#. type: cindex
#: syntax.texi.orig:746
#, no-wrap
msgid "parse state for a position"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:751
msgid "For syntactic analysis, such as in indentation, often the useful thing is to compute the syntactic state corresponding to a given buffer position.  This function does that conveniently."
msgstr ""

#. type: defun
#: syntax.texi.orig:752
#, no-wrap
msgid "syntax-ppss &optional pos"
msgstr ""

#. type: defun
#: syntax.texi.orig:755
msgid "This function returns the parser state that the parser would reach at position @var{pos} starting from the beginning of the buffer."
msgstr ""

#. type: iftex
#: syntax.texi.orig:757
msgid "See the next section for"
msgstr ""

#. type: ifnottex
#: syntax.texi.orig:760
msgid "@xref{Parser State},"
msgstr ""

#. type: defun
#: syntax.texi.orig:762
msgid "for a description of the parser state."
msgstr ""

#. type: defun
#: syntax.texi.orig:770
msgid "The return value is the same as if you call the low-level parsing function @code{parse-partial-sexp} to parse from the beginning of the buffer to @var{pos} (@pxref{Low-Level Parsing}).  However, @code{syntax-ppss} uses a cache to speed up the computation.  Due to this optimization, the second value (previous complete subexpression)  and sixth value (minimum parenthesis depth) in the returned parser state are not meaningful."
msgstr ""

#. type: defun
#: syntax.texi.orig:780
msgid "This function has a side effect: it adds a buffer-local entry to @code{before-change-functions} (@pxref{Change Hooks}) for @code{syntax-ppss-flush-cache} (see below).  This entry keeps the cache consistent as the buffer is modified.  However, the cache might not be updated if @code{syntax-ppss} is called while @code{before-change-functions} is temporarily let-bound, or if the buffer is modified without running the hook, such as when using @code{inhibit-modification-hooks}.  In those cases, it is necessary to call @code{syntax-ppss-flush-cache} explicitly."
msgstr ""

#. type: defun
#: syntax.texi.orig:782
#, no-wrap
msgid "syntax-ppss-flush-cache beg &rest ignored-args"
msgstr ""

#. type: defun
#: syntax.texi.orig:788
msgid "This function flushes the cache used by @code{syntax-ppss}, starting at position @var{beg}.  The remaining arguments, @var{ignored-args}, are ignored; this function accepts them so that it can be directly used on hooks such as @code{before-change-functions} (@pxref{Change Hooks})."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:792
msgid "Major modes can make @code{syntax-ppss} run faster by specifying where it needs to start parsing."
msgstr ""

#. type: defvar
#: syntax.texi.orig:793
#, no-wrap
msgid "syntax-begin-function"
msgstr ""

#. type: defvar
#: syntax.texi.orig:799
msgid "If this is non-@code{nil}, it should be a function that moves to an earlier buffer position where the parser state is equivalent to @code{nil}---in other words, a position outside of any comment, string, or parenthesis.  @code{syntax-ppss} uses it to further optimize its computations, when the cache gives no help."
msgstr ""

#. type: cindex
#: syntax.texi.orig:803
#, no-wrap
msgid "parser state"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:809
msgid "A @dfn{parser state} is a list of ten elements describing the state of the syntactic parser, after it parses the text between a specified starting point and a specified end point in the buffer.  Parsing functions such as @code{syntax-ppss}"
msgstr ""

#. type: ifnottex
#: syntax.texi.orig:811
msgid "(@pxref{Position Parse})"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:814
msgid "return a parser state as the value.  Some parsing functions accept a parser state as an argument, for resuming parsing."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:816
msgid "Here are the meanings of the elements of the parser state:"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:822
msgid "The depth in parentheses, counting from 0.  @strong{Warning:} this can be negative if there are more close parens than open parens between the parser's starting point and end point."
msgstr ""

#. type: cindex
#: syntax.texi.orig:824
#, no-wrap
msgid "innermost containing parentheses"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:827
msgid "The character position of the start of the innermost parenthetical grouping containing the stopping point; @code{nil} if none."
msgstr ""

#. type: cindex
#: syntax.texi.orig:829
#, no-wrap
msgid "previous complete subexpression"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:832
msgid "The character position of the start of the last complete subexpression terminated; @code{nil} if none."
msgstr ""

#. type: cindex
#: syntax.texi.orig:834
#, no-wrap
msgid "inside string"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:838
msgid "Non-@code{nil} if inside a string.  More precisely, this is the character that will terminate the string, or @code{t} if a generic string delimiter character should terminate it."
msgstr ""

#. type: cindex
#: syntax.texi.orig:840
#, no-wrap
msgid "inside comment"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:844
msgid "@code{t} if inside a non-nestable comment (of any comment style; @pxref{Syntax Flags}); or the comment nesting level if inside a comment that can be nested."
msgstr ""

#. type: cindex
#: syntax.texi.orig:846
#, no-wrap
msgid "quote character"
msgstr ""

#. type: enumerate
#: syntax.texi.orig:848
msgid "@code{t} if the end point is just after a quote character."
msgstr ""

#. type: enumerate
#: syntax.texi.orig:851
msgid "The minimum parenthesis depth encountered during this scan."
msgstr ""

#. type: enumerate
#: syntax.texi.orig:857
msgid "What kind of comment is active: @code{nil} if not in a comment or in a comment of style @samp{a}; 1 for a comment of style @samp{b}; 2 for a comment of style @samp{c}; and @code{syntax-table} for a comment that should be ended by a generic comment delimiter character."
msgstr ""

#. type: enumerate
#: syntax.texi.orig:863
msgid "The string or comment start position.  While inside a comment, this is the position where the comment began; while inside a string, this is the position where the string began.  When outside of strings and comments, this element is @code{nil}."
msgstr ""

#. type: enumerate
#: syntax.texi.orig:868
msgid "Internal data for continuing the parsing.  The meaning of this data is subject to change; it is used if you pass this list as the @var{state} argument to another call."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:874
msgid "Elements 1, 2, and 6 are ignored in a state which you pass as an argument to continue parsing, and elements 8 and 9 are used only in trivial cases.  Those elements are mainly used internally by the parser code."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:877
msgid "One additional piece of useful information is available from a parser state using this function:"
msgstr ""

#. type: defun
#: syntax.texi.orig:878
#, no-wrap
msgid "syntax-ppss-toplevel-pos state"
msgstr ""

#. type: defun
#: syntax.texi.orig:883
msgid "This function extracts, from parser state @var{state}, the last position scanned in the parse which was at top level in grammatical structure.  ``At top level'' means outside of any parentheses, comments, or strings."
msgstr ""

#. type: defun
#: syntax.texi.orig:886
msgid "The value is @code{nil} if @var{state} represents a parse which has arrived at a top level position."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:894
msgid "The most basic way to use the expression parser is to tell it to start at a given position with a certain state, and parse up to a specified end position."
msgstr ""

#. type: defun
#: syntax.texi.orig:895
#, no-wrap
msgid "parse-partial-sexp start limit &optional target-depth stop-before state stop-comment"
msgstr ""

#. type: defun
#: syntax.texi.orig:900
msgid "This function parses a sexp in the current buffer starting at @var{start}, not scanning past @var{limit}.  It stops at position @var{limit} or when certain criteria described below are met, and sets point to the location where parsing stops.  It returns a parser state"
msgstr ""

#. type: ifinfo
#: syntax.texi.orig:902
msgid "(@pxref{Parser State})"
msgstr ""

#. type: defun
#: syntax.texi.orig:904
msgid "describing the status of the parse at the point where it stops."
msgstr ""

#. type: cindex
#: syntax.texi.orig:905
#, no-wrap
msgid "parenthesis depth"
msgstr ""

#. type: defun
#: syntax.texi.orig:909
msgid "If the third argument @var{target-depth} is non-@code{nil}, parsing stops if the depth in parentheses becomes equal to @var{target-depth}.  The depth starts at 0, or at whatever is given in @var{state}."
msgstr ""

#. type: defun
#: syntax.texi.orig:916
msgid "If the fourth argument @var{stop-before} is non-@code{nil}, parsing stops when it comes to any character that starts a sexp.  If @var{stop-comment} is non-@code{nil}, parsing stops when it comes to the start of a comment.  If @var{stop-comment} is the symbol @code{syntax-table}, parsing stops after the start of a comment or a string, or the end of a comment or a string, whichever comes first."
msgstr ""

#. type: defun
#: syntax.texi.orig:924
msgid "If @var{state} is @code{nil}, @var{start} is assumed to be at the top level of parenthesis structure, such as the beginning of a function definition.  Alternatively, you might wish to resume parsing in the middle of the structure.  To do this, you must provide a @var{state} argument that describes the initial status of parsing.  The value returned by a previous call to @code{parse-partial-sexp} will do nicely."
msgstr ""

#. type: subsection
#: syntax.texi.orig:927
#, no-wrap
msgid "Parameters to Control Parsing"
msgstr ""

#. type: cindex
#: syntax.texi.orig:928
#, no-wrap
msgid "parsing, control parameters"
msgstr ""

#. type: defvar
#: syntax.texi.orig:930
#, no-wrap
msgid "multibyte-syntax-as-symbol"
msgstr ""

#. type: defvar
#: syntax.texi.orig:935
msgid "If this variable is non-@code{nil}, @code{scan-sexps} treats all non-@acronym{ASCII} characters as symbol constituents regardless of what the syntax table says about them.  (However, text properties can still override the syntax.)"
msgstr ""

#. type: defopt
#: syntax.texi.orig:937
#, no-wrap
msgid "parse-sexp-ignore-comments"
msgstr ""

#. type: cindex
#: syntax.texi.orig:938
#, no-wrap
msgid "skipping comments"
msgstr ""

#. type: defopt
#: syntax.texi.orig:942
msgid "If the value is non-@code{nil}, then comments are treated as whitespace by the functions in this section and by @code{forward-sexp}, @code{scan-lists} and @code{scan-sexps}."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:947
msgid "The behavior of @code{parse-partial-sexp} is also affected by @code{parse-sexp-lookup-properties} (@pxref{Syntax Properties})."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:950
msgid "You can use @code{forward-comment} to move forward or backward over one comment or several comments."
msgstr ""

#. type: cindex
#: syntax.texi.orig:953
#, no-wrap
msgid "syntax table internals"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:961
msgid "Syntax tables are implemented as char-tables (@pxref{Char-Tables}), but most Lisp programs don't work directly with their elements.  Syntax tables do not store syntax data as syntax descriptors (@pxref{Syntax Descriptors}); they use an internal format, which is documented in this section.  This internal format can also be assigned as syntax properties (@pxref{Syntax Properties})."
msgstr ""

#. type: cindex
#: syntax.texi.orig:962
#, no-wrap
msgid "syntax code"
msgstr ""

#. type: cindex
#: syntax.texi.orig:963
#, no-wrap
msgid "raw syntax descriptor"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:970
msgid "Each entry in a syntax table is a @dfn{raw syntax descriptor}: a cons cell of the form @code{(@var{syntax-code} . @var{matching-char})}.  @var{syntax-code} is an integer which encodes the syntax class and syntax flags, according to the table below.  @var{matching-char}, if non-@code{nil}, specifies a matching character (similar to the second character in a syntax descriptor)."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:973
msgid "Here are the syntax codes corresponding to the various syntax classes:"
msgstr ""

#. type: i{#1}
#: syntax.texi.orig:977
msgid "Code"
msgstr ""

#. type: i{#1}
#: syntax.texi.orig:977
msgid "Class"
msgstr ""

#. type: multitable
#: syntax.texi.orig:977
msgid "@i{Class}"
msgstr ""

#. type: multitable
#: syntax.texi.orig:979
msgid "0"
msgstr ""

#. type: multitable
#: syntax.texi.orig:979
msgid "whitespace"
msgstr ""

#. type: multitable
#: syntax.texi.orig:979
msgid "8"
msgstr ""

#. type: multitable
#: syntax.texi.orig:979
msgid "paired delimiter"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:981 syntax.texi.orig:1008
msgid "1"
msgstr ""

#. type: multitable
#: syntax.texi.orig:981
msgid "punctuation"
msgstr ""

#. type: multitable
#: syntax.texi.orig:981
msgid "9"
msgstr ""

#. type: multitable
#: syntax.texi.orig:981
msgid "escape"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:983 syntax.texi.orig:1010
msgid "2"
msgstr ""

#. type: multitable
#: syntax.texi.orig:983
msgid "word"
msgstr ""

#. type: multitable
#: syntax.texi.orig:983
msgid "10"
msgstr ""

#. type: multitable
#: syntax.texi.orig:983
msgid "character quote"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:985 syntax.texi.orig:1012
msgid "3"
msgstr ""

#. type: multitable
#: syntax.texi.orig:985
msgid "symbol"
msgstr ""

#. type: multitable
#: syntax.texi.orig:985
msgid "11"
msgstr ""

#. type: multitable
#: syntax.texi.orig:985
msgid "comment-start"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:987 syntax.texi.orig:1014
msgid "4"
msgstr ""

#. type: multitable
#: syntax.texi.orig:987
msgid "open parenthesis"
msgstr ""

#. type: multitable
#: syntax.texi.orig:987
msgid "12"
msgstr ""

#. type: multitable
#: syntax.texi.orig:987
msgid "comment-end"
msgstr ""

#. type: multitable
#: syntax.texi.orig:989
msgid "5"
msgstr ""

#. type: multitable
#: syntax.texi.orig:989
msgid "close parenthesis"
msgstr ""

#. type: multitable
#: syntax.texi.orig:989
msgid "13"
msgstr ""

#. type: multitable
#: syntax.texi.orig:989
msgid "inherit"
msgstr ""

#. type: multitable
#: syntax.texi.orig:991
msgid "6"
msgstr ""

#. type: multitable
#: syntax.texi.orig:991
msgid "expression prefix"
msgstr ""

#. type: multitable
#: syntax.texi.orig:991
msgid "14"
msgstr ""

#. type: multitable
#: syntax.texi.orig:991
msgid "generic comment"
msgstr ""

#. type: multitable
#: syntax.texi.orig:993
msgid "7"
msgstr ""

#. type: multitable
#: syntax.texi.orig:993
msgid "string quote"
msgstr ""

#. type: multitable
#: syntax.texi.orig:993
msgid "15"
msgstr ""

#. type: multitable
#: syntax.texi.orig:993
msgid "generic string"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:998
msgid "For example, in the standard syntax table, the entry for @samp{(} is @code{(4 . 41)}.  41 is the character code for @samp{)}."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1002
msgid "Syntax flags are encoded in higher order bits, starting 16 bits from the least significant bit.  This table gives the power of two which corresponds to each syntax flag."
msgstr ""

#. type: i{#1}
#: syntax.texi.orig:1006
msgid "Prefix"
msgstr ""

#. type: i{#1}
#: syntax.texi.orig:1006
msgid "Flag"
msgstr ""

#. type: multitable
#: syntax.texi.orig:1006
msgid "@i{Flag}"
msgstr ""

#. type: code{#1}
#: syntax.texi.orig:1008
msgid "(lsh 1 16)"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:1008
msgid "p"
msgstr ""

#. type: multitable
#: syntax.texi.orig:1008
msgid "@code{(lsh 1 20)}"
msgstr ""

#. type: code{#1}
#: syntax.texi.orig:1010
msgid "(lsh 1 17)"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:1010
msgid "b"
msgstr ""

#. type: multitable
#: syntax.texi.orig:1010
msgid "@code{(lsh 1 21)}"
msgstr ""

#. type: code{#1}
#: syntax.texi.orig:1012
msgid "(lsh 1 18)"
msgstr ""

#. type: samp{#1}
#: syntax.texi.orig:1012
msgid "n"
msgstr ""

#. type: multitable
#: syntax.texi.orig:1012
msgid "@code{(lsh 1 22)}"
msgstr ""

#. type: multitable
#: syntax.texi.orig:1014
msgid "@code{(lsh 1 19)}"
msgstr ""

#. type: defun
#: syntax.texi.orig:1016
#, no-wrap
msgid "string-to-syntax desc"
msgstr ""

#. type: defun
#: syntax.texi.orig:1019
msgid "Given a syntax descriptor @var{desc} (a string), this function returns the corresponding raw syntax descriptor."
msgstr ""

#. type: defun
#: syntax.texi.orig:1021
#, no-wrap
msgid "syntax-after pos"
msgstr ""

#. type: defun
#: syntax.texi.orig:1027
msgid "This function returns the raw syntax descriptor for the character in the buffer after position @var{pos}, taking account of syntax properties as well as the syntax table.  If @var{pos} is outside the buffer's accessible portion (@pxref{Narrowing, accessible portion}), the return value is @code{nil}."
msgstr ""

#. type: defun
#: syntax.texi.orig:1029
#, no-wrap
msgid "syntax-class syntax"
msgstr ""

#. type: defun
#: syntax.texi.orig:1034
msgid "This function returns the syntax code for the raw syntax descriptor @var{syntax}.  More precisely, it takes the raw syntax descriptor's @var{syntax-code} component, masks off the high 16 bits which record the syntax flags, and returns the resulting integer."
msgstr ""

#. type: defun
#: syntax.texi.orig:1037
msgid "If @var{syntax} is @code{nil}, the return value is returns @code{nil}.  This is so that the expression"
msgstr ""

#. type: example
#: syntax.texi.orig:1040
#, no-wrap
msgid "(syntax-class (syntax-after pos))\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1046
msgid "evaluates to @code{nil} if @code{pos} is outside the buffer's accessible portion, without throwing errors or returning an incorrect code."
msgstr ""

#. type: cindex
#: syntax.texi.orig:1050
#, no-wrap
msgid "categories of characters"
msgstr ""

#. type: cindex
#: syntax.texi.orig:1051
#, no-wrap
msgid "character categories"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1058
msgid "@dfn{Categories} provide an alternate way of classifying characters syntactically.  You can define several categories as needed, then independently assign each character to one or more categories.  Unlike syntax classes, categories are not mutually exclusive; it is normal for one character to belong to several categories."
msgstr ""

#. type: cindex
#: syntax.texi.orig:1059
#, no-wrap
msgid "category table"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1065
msgid "Each buffer has a @dfn{category table} which records which categories are defined and also which characters belong to each category.  Each category table defines its own categories, but normally these are initialized by copying from the standard categories table, so that the standard categories are available in all modes."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1069
msgid "Each category has a name, which is an @acronym{ASCII} printing character in the range @w{@samp{ }} to @samp{~}.  You specify the name of a category when you define it with @code{define-category}."
msgstr ""

#. type: cindex
#: syntax.texi.orig:1070
#, no-wrap
msgid "category set"
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1077
msgid "The category table is actually a char-table (@pxref{Char-Tables}).  The element of the category table at index @var{c} is a @dfn{category set}---a bool-vector---that indicates which categories character @var{c} belongs to.  In this category set, if the element at index @var{cat} is @code{t}, that means category @var{cat} is a member of the set, and that character @var{c} belongs to category @var{cat}."
msgstr ""

#. type: Plain text
#: syntax.texi.orig:1080
msgid "For the next three functions, the optional argument @var{table} defaults to the current buffer's category table."
msgstr ""

#. type: defun
#: syntax.texi.orig:1081
#, no-wrap
msgid "define-category char docstring &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1084
msgid "This function defines a new category, with name @var{char} and documentation @var{docstring}, for the category table @var{table}."
msgstr ""

#. type: defun
#: syntax.texi.orig:1088
msgid "Here's an example of defining a new category for characters that have strong right-to-left directionality (@pxref{Bidirectional Display})  and using it in a special category table:"
msgstr ""

#. type: example
#: syntax.texi.orig:1101
#, no-wrap
msgid ""
"(defvar special-category-table-for-bidi\n"
"  (let ((category-table (make-category-table))\n"
"\t(uniprop-table (unicode-property-table-internal 'bidi-class)))\n"
"    (define-category ?R \"Characters of bidi-class R, AL, or RLO\"\n"
"                     category-table)\n"
"    (map-char-table\n"
"     #'(lambda (key val)\n"
"\t (if (memq val '(R AL RLO))\n"
"\t     (modify-category-entry key ?R category-table)))\n"
"     uniprop-table)\n"
"    category-table))\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1104
#, no-wrap
msgid "category-docstring category &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1107
msgid "This function returns the documentation string of category @var{category} in category table @var{table}."
msgstr ""

#. type: example
#: syntax.texi.orig:1113
#, no-wrap
msgid ""
"(category-docstring ?a)\n"
"     @result{} \"ASCII\"\n"
"(category-docstring ?l)\n"
"     @result{} \"Latin\"\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1116
#, no-wrap
msgid "get-unused-category &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1120
msgid "This function returns a category name (a character) which is not currently defined in @var{table}.  If all possible categories are in use in @var{table}, it returns @code{nil}."
msgstr ""

#. type: defun
#: syntax.texi.orig:1122
#, no-wrap
msgid "category-table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1124
msgid "This function returns the current buffer's category table."
msgstr ""

#. type: defun
#: syntax.texi.orig:1126
#, no-wrap
msgid "category-table-p object"
msgstr ""

#. type: defun
#: syntax.texi.orig:1129
msgid "This function returns @code{t} if @var{object} is a category table, otherwise @code{nil}."
msgstr ""

#. type: defun
#: syntax.texi.orig:1131
#, no-wrap
msgid "standard-category-table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1133
msgid "This function returns the standard category table."
msgstr ""

#. type: defun
#: syntax.texi.orig:1135
#, no-wrap
msgid "copy-category-table &optional table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1140
msgid "This function constructs a copy of @var{table} and returns it.  If @var{table} is not supplied (or is @code{nil}), it returns a copy of the standard category table.  Otherwise, an error is signaled if @var{table} is not a category table."
msgstr ""

#. type: defun
#: syntax.texi.orig:1142
#, no-wrap
msgid "set-category-table table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1145
msgid "This function makes @var{table} the category table for the current buffer.  It returns @var{table}."
msgstr ""

#. type: defun
#: syntax.texi.orig:1147
#, no-wrap
msgid "make-category-table"
msgstr ""

#. type: defun
#: syntax.texi.orig:1151
msgid "This creates and returns an empty category table.  In an empty category table, no categories have been allocated, and no characters belong to any categories."
msgstr ""

#. type: defun
#: syntax.texi.orig:1153
#, no-wrap
msgid "make-category-set categories"
msgstr ""

#. type: defun
#: syntax.texi.orig:1159
msgid "This function returns a new category set---a bool-vector---whose initial contents are the categories listed in the string @var{categories}.  The elements of @var{categories} should be category names; the new category set has @code{t} for each of those categories, and @code{nil} for all other categories."
msgstr ""

#. type: example
#: syntax.texi.orig:1163
#, no-wrap
msgid ""
"(make-category-set \"al\")\n"
"     @result{} #&128\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\2\\20\\0\\0\"\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1166
#, no-wrap
msgid "char-category-set char"
msgstr ""

#. type: defun
#: syntax.texi.orig:1172
msgid "This function returns the category set for character @var{char} in the current buffer's category table.  This is the bool-vector which records which categories the character @var{char} belongs to.  The function @code{char-category-set} does not allocate storage, because it returns the same bool-vector that exists in the category table."
msgstr ""

#. type: example
#: syntax.texi.orig:1176
#, no-wrap
msgid ""
"(char-category-set ?a)\n"
"     @result{} #&128\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\2\\20\\0\\0\"\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1179
#, no-wrap
msgid "category-set-mnemonics category-set"
msgstr ""

#. type: defun
#: syntax.texi.orig:1183
msgid "This function converts the category set @var{category-set} into a string containing the characters that designate the categories that are members of the set."
msgstr ""

#. type: example
#: syntax.texi.orig:1187
#, no-wrap
msgid ""
"(category-set-mnemonics (char-category-set ?a))\n"
"     @result{} \"al\"\n"
msgstr ""

#. type: defun
#: syntax.texi.orig:1190
#, no-wrap
msgid "modify-category-entry char category &optional table reset"
msgstr ""

#. type: defun
#: syntax.texi.orig:1197
msgid "This function modifies the category set of @var{char} in category table @var{table} (which defaults to the current buffer's category table).  @var{char} can be a character, or a cons cell of the form @code{(@var{min} . @var{max})}; in the latter case, the function modifies the category sets of all characters in the range between @var{min} and @var{max}, inclusive."
msgstr ""

#. type: defun
#: syntax.texi.orig:1201
msgid "Normally, it modifies a category set by adding @var{category} to it.  But if @var{reset} is non-@code{nil}, then it deletes @var{category} instead."
msgstr ""

#. type: deffn
#: syntax.texi.orig:1203
#, no-wrap
msgid "Command describe-categories &optional buffer-or-name"
msgstr ""

#. type: deffn
#: syntax.texi.orig:1208
msgid "This function describes the category specifications in the current category table.  It inserts the descriptions in a buffer, and then displays that buffer.  If @var{buffer-or-name} is non-@code{nil}, it describes the category table of that buffer instead."
msgstr ""
