# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-07-21 22:14+0900\n"
"PO-Revision-Date: 2016-08-30 00:41+0900\n"
"Last-Translator: Takeshi Ayanokoji <takeshi.ayanokoji@gmail.com>\n"
"Language-Team: Japanese <takeshi.ayanokoji@gmail.com>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: variables.texi.orig:5 variables.texi.orig:6
#, no-wrap
msgid "Variables"
msgstr "Variables"

#. type: cindex
#: variables.texi.orig:7
#, no-wrap
msgid "variable"
msgstr "variable"

#. type: Plain text
#: variables.texi.orig:18
msgid ""
"A @dfn{variable} is a name used in a program to stand for a value.  In Lisp, "
"each variable is represented by a Lisp symbol (@pxref{Symbols}).  The "
"variable name is simply the symbol's name, and the variable's value is "
"stored in the symbol's value cell@footnote{To be precise, under the default "
"@dfn{dynamic scoping} rule, the value cell always holds the variable's "
"current value, but this is not the case under the @dfn{lexical scoping} "
"rule.  @xref{Variable Scoping}, for details.}.  @xref{Symbol Components}.  "
"In Emacs Lisp, the use of a symbol as a variable is independent of its use "
"as a function name."
msgstr "@dfn{変数(variable)}とは、プログラム内で値を表すために使用される名前です。Lispでは、変数はそれぞれLispシンボルとして表されます(@ref{Symbols}を参照してください)。変数名は単にそのシンボルの名前であり、変数の値はそのシンボルの値セル(value cell)に格納されます@footnote{正確に言うと、デフォルトの@dfn{ダイナミックスコープ(dynamic scoping)}のルールでは、値セルは常にその変数のカレント値を保持しますが、@dfn{レキシカルスコープ(lexical scoping)}では異なります。詳細は、@ref{Variable Scoping}を参照してください。}。@ref{Symbol Components}を参照してください。Emacs Lispでは、シンボルを変数として使用することは、同じシンボルを関数名として使用することと関係ありません。"

#. type: Plain text
#: variables.texi.orig:25
msgid ""
"As previously noted in this manual, a Lisp program is represented primarily "
"by Lisp objects, and only secondarily as text.  The textual form of a Lisp "
"program is given by the read syntax of the Lisp objects that constitute the "
"program.  Hence, the textual form of a variable in a Lisp program is written "
"using the read syntax for the symbol representing the variable."
msgstr "このマニュアル中で前に記したとおり、Lispプログラムはまず第1にLispオブジェクトとして表され、副次的にテキストとして表現されます。Lispプログラムのテキスト的な形式は、そのプログラムを構成するLispオブジェクトの入力構文により与えられます。したがって、Lispプログラム内の変数のテキスト的な形式は、その変数を表すシンボルの入力構文を使用して記述されます。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:47 variables.texi.orig:48
#, no-wrap
msgid "Global Variables"
msgstr "Global Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Variable values that exist permanently, everywhere."
msgstr "どの場所でも永続的に存在する変数の値。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:99
#, no-wrap
msgid "Constant Variables"
msgstr "Constant Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Certain \"variables\" have values that never change."
msgstr "変更されることのない値を持つ、ある種の\"変数\"。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:140 variables.texi.orig:141
#, no-wrap
msgid "Local Variables"
msgstr "Local Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Variable values that exist only temporarily."
msgstr "一時的にのみ存在する存在する変数の値。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:289
#, no-wrap
msgid "Void Variables"
msgstr "Void Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Symbols that lack values."
msgstr "値を持たないシンボル。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:385
#, no-wrap
msgid "Defining Variables"
msgstr "Defining Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "A definition says a symbol is used as a variable."
msgstr "シンボルが変数として使用されていることを宣言する定義。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:520
#, no-wrap
msgid "Tips for Defining"
msgstr "Tips for Defining"

#. type: menuentry
#: variables.texi.orig:45
msgid "Things you should think about when you define a variable."
msgstr "変数を定義するときに考慮すべき事項。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:611
#, no-wrap
msgid "Accessing Variables"
msgstr "Accessing Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Examining values of variables whose names are known only at run time."
msgstr "実行時に判明する名前をもつ変数の値を確認する。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:667
#, no-wrap
msgid "Setting Variables"
msgstr "Setting Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Storing new values in variables."
msgstr "変数に新しい値を格納する。"

#. type: node
#: variables.texi.orig:45 variables.texi.orig:769
#, no-wrap
msgid "Variable Scoping"
msgstr "Variable Scoping"

#. type: menuentry
#: variables.texi.orig:45
msgid "How Lisp chooses among local and global values."
msgstr "Lispがローカル値とグローバル値を選択する方法。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1108 variables.texi.orig:1109
#, no-wrap
msgid "Buffer-Local Variables"
msgstr "Buffer-Local Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Variable values in effect only in one buffer."
msgstr "1つのバッファーないだけで効果をもつ変数の値。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1570 variables.texi.orig:1571
#, no-wrap
msgid "File Local Variables"
msgstr "File Local Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Handling local variable lists in files."
msgstr "ファイル内にリストされたローカル変数の処理。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1754 variables.texi.orig:1755
#, no-wrap
msgid "Directory Local Variables"
msgstr "Directory Local Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Local variables common to all files in a directory."
msgstr "ディレクトリー内のすべてのファイルで共通のローカル変数。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1860 variables.texi.orig:1861
#, no-wrap
msgid "Variable Aliases"
msgstr "Variable Aliases"

#. type: menuentry
#: variables.texi.orig:45
msgid "Variables that are aliases for other variables."
msgstr "他の変数のエイリアスとなる変数。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1953 variables.texi.orig:1954
#, no-wrap
msgid "Variables with Restricted Values"
msgstr "Variables with Restricted Values"

#. type: menuentry
#: variables.texi.orig:45
msgid ""
"Non-constant variables whose value can @emph{not} be an arbitrary Lisp "
"object."
msgstr "任意のLispオブジェクトを値とすることが@emph{できない}、定数ではない変数。"

#. type: section
#: variables.texi.orig:45 variables.texi.orig:1989 variables.texi.orig:1990
#, no-wrap
msgid "Generalized Variables"
msgstr "Generalized Variables"

#. type: menuentry
#: variables.texi.orig:45
msgid "Extending the concept of variables."
msgstr "変数の概念の拡張。"

#. type: cindex
#: variables.texi.orig:49
#, no-wrap
msgid "global variable"
msgstr "global variable"

#. type: Plain text
#: variables.texi.orig:56
msgid ""
"The simplest way to use a variable is @dfn{globally}.  This means that the "
"variable has just one value at a time, and this value is in effect (at least "
"for the moment) throughout the Lisp system.  The value remains in effect "
"until you specify a new one.  When a new value replaces the old one, no "
"trace of the old value remains in the variable."
msgstr "変数を使用するための一番シンプルな方法は、@dfn{グローバル(globally)}に使用する方法です。これは、ある時点でその変数はただ1つの値をもち、その値が(少なくともその時点では)Lispシステム全体で効果をもつことを意味します。あらたな値を指定するまで、その値が効果をもちます。新しい値で古い値を置き換えるとき、古い値を追跡する情報は変数内に残りません。"

#. type: Plain text
#: variables.texi.orig:58
msgid "You specify a value for a symbol with @code{setq}.  For example,"
msgstr "シンボルの値は@code{setq}で指定します。たとえば、"

#. type: example
#: variables.texi.orig:61
#, no-wrap
msgid "(setq x '(a b))\n"
msgstr "(setq x '(a b))\n"

#. type: Plain text
#: variables.texi.orig:68
msgid ""
"gives the variable @code{x} the value @code{(a b)}.  Note that @code{setq} "
"is a special form (@pxref{Special Forms}); it does not evaluate its first "
"argument, the name of the variable, but it does evaluate the second "
"argument, the new value."
msgstr "これは、変数@code{x}に値@code{(a b)}を与えます。@code{setq}はスペシャルフォームであることに注意してください。これは1番目の引数(変数の名前)は評価しませんが、2番目の引数(新しい値)は評価します。"

#. type: Plain text
#: variables.texi.orig:71
msgid ""
"Once the variable has a value, you can refer to it by using the symbol "
"itself as an expression.  Thus,"
msgstr "変数が1度値をもつと、そのシンボル自身を式として使用することにより、参照することができます。したがって、"

#. type: group
#: variables.texi.orig:75
#, no-wrap
msgid "x @result{} (a b)\n"
msgstr "x @result{} (a b)\n"

#. type: Plain text
#: variables.texi.orig:80
msgid "assuming the @code{setq} form shown above has already been executed."
msgstr "これは上記の@code{setq}フォームが実行された場合です。"

#. type: Plain text
#: variables.texi.orig:83
msgid "If you do set the same variable again, the new value replaces the old one:"
msgstr "同じ変数を再びセットした場合、新しい値は古い値を置き換えます:"

#. type: group
#: variables.texi.orig:88
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b)\n"
msgstr ""
"x\n"
"     @result{} (a b)\n"

#. type: group
#: variables.texi.orig:92
#, no-wrap
msgid ""
"(setq x 4)\n"
"     @result{} 4\n"
msgstr ""
"(setq x 4)\n"
"     @result{} 4\n"

#. type: group
#: variables.texi.orig:96
#, no-wrap
msgid ""
"x\n"
"     @result{} 4\n"
msgstr ""
"x\n"
"     @result{} 4\n"

#. type: section
#: variables.texi.orig:100
#, no-wrap
msgid "Variables that Never Change"
msgstr "Variables that Never Change"

#. type: cindex
#: variables.texi.orig:101
#, no-wrap
msgid "@code{setting-constant} error"
msgstr "@code{setting-constant} error"

#. type: cindex
#: variables.texi.orig:102
#, no-wrap
msgid "keyword symbol"
msgstr "keyword symbol"

#. type: cindex
#: variables.texi.orig:103
#, no-wrap
msgid "variable with constant value"
msgstr "variable with constant value"

#. type: cindex
#: variables.texi.orig:104 variables.texi.orig:470
#, no-wrap
msgid "constant variables"
msgstr "constant variables"

#. type: cindex
#: variables.texi.orig:105
#, no-wrap
msgid "symbol that evaluates to itself"
msgstr "symbol that evaluates to itself"

#. type: cindex
#: variables.texi.orig:106
#, no-wrap
msgid "symbol with constant value"
msgstr "symbol with constant value"

#. type: Plain text
#: variables.texi.orig:116
msgid ""
"In Emacs Lisp, certain symbols normally evaluate to themselves.  These "
"include @code{nil} and @code{t}, as well as any symbol whose name starts "
"with @samp{:} (these are called @dfn{keywords}).  These symbols cannot be "
"rebound, nor can their values be changed.  Any attempt to set or bind "
"@code{nil} or @code{t} signals a @code{setting-constant} error.  The same is "
"true for a keyword (a symbol whose name starts with @samp{:}), if it is "
"interned in the standard obarray, except that setting such a symbol to "
"itself is not an error."
msgstr "Emacs Lispでは、特定のシンボルは、通常は自分自身に評価されます。これらのシンボルには@code{nil}と@code{t}、同様に名前が@samp{:}で始まる任意のシンボル(これらは@dfn{キーワード}と呼ばれます)が含まれます。これらのシンボルは、リバインドや、値の変更はできません。@code{nil}や@code{t}へのセットやリバインドは、@code{setting-constant}エラーをシグナルします。これはキーワード(名前が@samp{:}で始まるシンボル)についても当てはまります。ただしキーワードが標準のobarrayにinternされている場合、そのようなシンボルを自分自身にセットしてもエラーになりません。"

#. type: group
#: variables.texi.orig:121
#, no-wrap
msgid ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"
msgstr ""
"nil @equiv{} 'nil\n"
"     @result{} nil\n"

#. type: group
#: variables.texi.orig:125
#, no-wrap
msgid ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"
msgstr ""
"(setq nil 500)\n"
"@error{} Attempt to set constant symbol: nil\n"

#. type: defun
#: variables.texi.orig:128
#, no-wrap
msgid "keywordp object"
msgstr "keywordp object"

#. type: defun
#: variables.texi.orig:132
msgid ""
"function returns @code{t} if @var{object} is a symbol whose name starts with "
"@samp{:}, interned in the standard obarray, and returns @code{nil} "
"otherwise."
msgstr "この関数は、@var{object}が@samp{:}で始まる名前のシンボルで、標準のobarrayにinternされているの場合は@code{t}、それ以外は@code{nil}をreturnします。"

#. type: Plain text
#: variables.texi.orig:139
msgid ""
"These constants are fundamentally different from the ``constants'' defined "
"using the @code{defconst} special form (@pxref{Defining Variables}).  A "
"@code{defconst} form serves to inform human readers that you do not intend "
"to change the value of a variable, but Emacs does not raise an error if you "
"actually change it."
msgstr "これらの定数はスペシャルフォーム@code{defconst}(@ref{Defining Variables}を参照してください)を使用して定義された``定数(constant)''とは、根本的に異なります。@code{defconst}フォームは、人間の読み手に値の変更を意図しない変数であることを知らせる役目は果たしますが、実際にそれを変更しても、Emacsはエラーを起こしません。"

#. type: cindex
#: variables.texi.orig:142
#, no-wrap
msgid "binding local variables"
msgstr "binding local variables"

#. type: cindex
#: variables.texi.orig:143
#, no-wrap
msgid "local variables"
msgstr "local variables"

#. type: cindex
#: variables.texi.orig:144
#, no-wrap
msgid "local binding"
msgstr "local binding"

#. type: cindex
#: variables.texi.orig:145
#, no-wrap
msgid "global binding"
msgstr "global binding"

#. type: Plain text
#: variables.texi.orig:153
msgid ""
"Global variables have values that last until explicitly superseded with new "
"values.  Sometimes it is useful to give a variable a @dfn{local value}---a "
"value that takes effect only within a certain part of a Lisp program.  When "
"a variable has a local value, we say that it is @dfn{locally bound} to that "
"value, and that it is a @dfn{local variable}."
msgstr "グローバル変数は、新しい値で明示的に置き換えるまで値が持続します。変数に@dfn{ローカル値(local value)} --- Lispプログラム内の特定の部分で効果をもつを与えると便利なときがあります。変数がローカル値をもつとき、わたしたちは変数がその値に@dfn{ローカルにバインド(locally bound)}と言い、その変数を@dfn{ローカル変数(local variable)}と呼びます。"

#. type: Plain text
#: variables.texi.orig:160
msgid ""
"For example, when a function is called, its argument variables receive local "
"values, which are the actual arguments supplied to the function call; these "
"local bindings take effect within the body of the function.  To take another "
"example, the @code{let} special form explicitly establishes local bindings "
"for specific variables, which take effect within the body of the @code{let} "
"form."
msgstr "たとえば、関数が呼び出されるとき、関数の引数となる変数はローカル値(その関数の呼び出しにおいて実際の引数に与えられた値)を受け取ります。これらのローカルバインディングは、その関数のbody内で効果をもちます。他にも、たとえばスペシャルフォーム@code{let}は特定の変数にたいして明示的にローカルなバインディングを確立し、これは@code{let}フォームのbody内で効果を持ちます。"

#. type: Plain text
#: variables.texi.orig:163
msgid ""
"We also speak of the @dfn{global binding}, which is where (conceptually) the "
"global value is kept."
msgstr "これにたいして@dfn{グローバルなバインディング(global binding)}とは、(概念的には)グローバルな値が保持される場所です。"

#. type: cindex
#: variables.texi.orig:164
#, no-wrap
msgid "shadowing of variables"
msgstr "shadowing of variables"

#. type: Plain text
#: variables.texi.orig:172
msgid ""
"Establishing a local binding saves away the variable's previous value (or "
"lack of one).  We say that the previous value is @dfn{shadowed}.  Both "
"global and local values may be shadowed.  If a local binding is in effect, "
"using @code{setq} on the local variable stores the specified value in the "
"local binding.  When that local binding is no longer in effect, the "
"previously shadowed value (or lack of one) comes back."
msgstr "ローカルバインディングを確立すると、その変数の以前の値は他の場所に保存されます(または失われます)。わたしたちはこれを、以前の値が@dfn{シャドーされた(shadowed)}と言います。シャドーはグローバル変数とローカル変数の両方で発生し得ます。ローカルバインディングが効果を持つとき、ローカル変数に@code{setq}を使用することにより、ローカルバインディングに指定された値を格納します。ローカルバインディングが効果を持たなくなったとき、以前にシャドーされた値が復元されます(または失われます)。"

#. type: cindex
#: variables.texi.orig:173
#, no-wrap
msgid "current binding"
msgstr "current binding"

#. type: Plain text
#: variables.texi.orig:179
msgid ""
"A variable can have more than one local binding at a time (e.g., if there "
"are nested @code{let} forms that bind the variable).  The @dfn{current "
"binding} is the local binding that is actually in effect.  It determines the "
"value returned by evaluating the variable symbol, and it is the binding "
"acted on by @code{setq}."
msgstr "変数は同時に複数のローカルバインディングを持つことができます(たとえばその変数をバインドするネストされた@code{let})。@dfn{カレントバインディング(current binding)}とは、実際に効果を持つローカルバインディングのことです。カレントバインディングは、その変数の評価によりreturnされる値を決定し、@code{setq}により影響を受けるバインディングです。"

#. type: Plain text
#: variables.texi.orig:190
msgid ""
"For most purposes, you can think of the current binding as the ``innermost'' "
"local binding, or the global binding if there is no local binding.  To be "
"more precise, a rule called the @dfn{scoping rule} determines where in a "
"program a local binding takes effect.  The default scoping rule in Emacs "
"Lisp is called @dfn{dynamic scoping}, which simply states that the current "
"binding at any given point in the execution of a program is the most "
"recently-created binding for that variable that still exists.  For details "
"about dynamic scoping, and an alternative scoping rule called @dfn{lexical "
"scoping}, @xref{Variable Scoping}."
msgstr "ほとんどの用途において、``最内(innermost)''のローカルバインディング、ローカルバインディングがないときはグローバルバインディングを、カレントバインディングと考えることができます。より正確に言うと、@dfn{スコープルール(scoping rule)}と呼ばれるルールは、プログラム内でローカルバインディングが効果を持つ任意の与えられた場所を決定します。Emacs Lispのスコープルールは@dfn{ダイナミックスコープ(dynamic scoping)}と呼ばれ、これは単に実行中のプログラム内の与えられた位置でのカレントバインディングを示し、その変数がまだ存在する場合は、その変数にたいしてもっとも最近作成されたバインディングです。ダイナミックスコープについての詳細と、その代替である@dfn{レキシカルスコープ(lexical scoping)}と呼ばれるスコープルールについては、@ref{Variable Scoping}を参照してください。"

#. type: Plain text
#: variables.texi.orig:193
msgid "The special forms @code{let} and @code{let*} exist to create local bindings:"
msgstr "スペシャルフォーム@code{let}および@code{let*}は、ローカルバインディングを作成するために存在します:"

#. type: defspec
#: variables.texi.orig:194
#, no-wrap
msgid "let (bindings@dots{}) forms@dots{}"
msgstr "let (bindings@dots{}) forms@dots{}"

#. type: defspec
#: variables.texi.orig:199
msgid ""
"This special form sets up local bindings for a certain set of variables, as "
"specified by @var{bindings}, and then evaluates all of the @var{forms} in "
"textual order.  Its return value is the value of the last form in "
"@var{forms}."
msgstr "このスペシャルフォームは、@var{bindings}により指定される特定の変数セットにたいするローカルバインディングをセットアップしてから、@var{forms}のすべてをテキスト順に評価します。これは@var{forms}内の最後のフォームの値をreturnします。"

#. type: defspec
#: variables.texi.orig:205
msgid ""
"Each of the @var{bindings} is either @w{(i) a} symbol, in which case that "
"symbol is locally bound to @code{nil}; or @w{(ii) a} list of the form "
"@code{(@var{symbol} @var{value-form})}, in which case @var{symbol} is "
"locally bound to the result of evaluating @var{value-form}.  If "
"@var{value-form} is omitted, @code{nil} is used."
msgstr "@var{bindings}の各バインディングは2つの形式のどちらかです。@w{(i)} シンボルの場合。この場合、そのシンボルは@code{nil}にローカルにバインドされます。@w{(ii)} フォーム@code{(@var{symbol} @var{value-form})}のリストの場合。この場合@var{symbol}は@var{value-form}を評価した結果にローカルにバインドされます。@var{value-form}が省略された場合は、@code{nil}が使用されます。"

#. type: defspec
#: variables.texi.orig:210
msgid ""
"All of the @var{value-form}s in @var{bindings} are evaluated in the order "
"they appear and @emph{before} binding any of the symbols to them.  Here is "
"an example of this: @code{z} is bound to the old value of @code{y}, which is "
"2, not the new value of @code{y}, which is 1."
msgstr "@var{bindings}内のすべての@var{value-form}は、シンボルがそれらにバインドされる@emph{前}に、記述された順番に評価されます。以下は例では、@code{z}は@code{y}の新しい場合(つまり1)にではなく、古い値(つまり2)にバインドされます。"

#. type: group
#: variables.texi.orig:215 variables.texi.orig:237
#, no-wrap
msgid ""
"(setq y 2)\n"
"     @result{} 2\n"
msgstr ""
"(setq y 2)\n"
"     @result{} 2\n"

#. type: group
#: variables.texi.orig:222
#, no-wrap
msgid ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"
msgstr ""
"(let ((y 1)\n"
"      (z y))\n"
"  (list y z))\n"
"     @result{} (1 2)\n"

#. type: defspec
#: variables.texi.orig:226
#, no-wrap
msgid "let* (bindings@dots{}) forms@dots{}"
msgstr "let* (bindings@dots{}) forms@dots{}"

#. type: defspec
#: variables.texi.orig:232
msgid ""
"This special form is like @code{let}, but it binds each variable right after "
"computing its local value, before computing the local value for the next "
"variable.  Therefore, an expression in @var{bindings} can refer to the "
"preceding symbols bound in this @code{let*} form.  Compare the following "
"example with the example above for @code{let}."
msgstr "このスペシャルフォームは@code{let}と似ていますが、次の変数値にたいするローカル値を計算する前に、ローカル値を計算してそれを変数にバインドします。したがて、@var{bindings}内の式は、この@code{let*}フォーム内の前のシンボルのバインドを参照できます。以下の例を、上記@code{let}の例と比較してください。"

#. type: group
#: variables.texi.orig:244
#, no-wrap
msgid ""
"(let* ((y 1)\n"
"       (z y))    ; @r{Use the just-established value of @code{y}.}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"
msgstr ""
"(let* ((y 1)\n"
"       (z y))    ; @r{@code{y}の値に今計算されたばかりの値を使用する。}\n"
"  (list y z))\n"
"     @result{} (1 1)\n"

#. type: Plain text
#: variables.texi.orig:250
msgid "Here is a complete list of the other facilities that create local bindings:"
msgstr "以下は、ローカルバインディングを作成する、他の機能のリストです:"

#. type: itemize
#: variables.texi.orig:254
msgid "Function calls (@pxref{Functions})."
msgstr "関数呼び出し(@ref{Functions}を参照してください)。"

#. type: itemize
#: variables.texi.orig:257
msgid "Macro calls (@pxref{Macros})."
msgstr "マクロ呼び出し(@ref{Macros}を参照してください)。"

#. type: itemize
#: variables.texi.orig:260
msgid "@code{condition-case} (@pxref{Errors})."
msgstr "@code{condition-case} (@ref{Errors}を参照してください)。"

#. type: Plain text
#: variables.texi.orig:267
msgid ""
"Variables can also have buffer-local bindings (@pxref{Buffer-Local "
"Variables}); a few variables have terminal-local bindings (@pxref{Multiple "
"Terminals}).  These kinds of bindings work somewhat like ordinary local "
"bindings, but they are localized depending on ``where'' you are in Emacs."
msgstr "変数はバッファーローカルなバインディングを持つこともできます(@ref{Buffer-Local Variables}を参照してください)。数は多くありませんが、端末ローカル(terminal-local)なバインディングをもつ変数もあります(@ref{Multiple Terminals}を参照してください)これらの種類のバインディングは、通常のローカルバインディングのように機能することもありますが、これらはEmacs内の``どこ''であるかに依存してローカライズされます。"

#. type: defopt
#: variables.texi.orig:268
#, no-wrap
msgid "max-specpdl-size"
msgstr "max-specpdl-size"

#. type: anchor{#1}
#: variables.texi.orig:270
msgid "Definition of max-specpdl-size"
msgstr "Definition of max-specpdl-size"

#. type: cindex
#: variables.texi.orig:270
#, no-wrap
msgid "variable limit error"
msgstr "variable limit error"

#. type: cindex
#: variables.texi.orig:271
#, no-wrap
msgid "evaluation error"
msgstr "evaluation error"

#. type: cindex
#: variables.texi.orig:272
#, no-wrap
msgid "infinite recursion"
msgstr "infinite recursion"

#. type: defopt
#: variables.texi.orig:278
msgid ""
"This variable defines the limit on the total number of local variable "
"bindings and @code{unwind-protect} cleanups (see @ref{Cleanups,, Cleaning Up "
"from Nonlocal Exits}) that are allowed before Emacs signals an error (with "
"data @code{\"Variable binding depth exceeds max-specpdl-size\"})."
msgstr "この変数は、ローカルな変数バインディングと、@code{unwind-protect}にゆるクリーンアップ(@ref{Cleanups,, Cleaning Up from Nonlocal Exits}の総数にたいする制限を定義し、この変数を越えるとEmacsはエラー(データに関するエラー@code{\"Variable binding depth exceeds max-specpdl-size\"})をシグナルします。"

#. type: defopt
#: variables.texi.orig:283
msgid ""
"This limit, with the associated error when it is exceeded, is one way that "
"Lisp avoids infinite recursion on an ill-defined function.  "
"@code{max-lisp-eval-depth} provides another limit on depth of nesting.  "
"@xref{Definition of max-lisp-eval-depth,, Eval}."
msgstr "このリミットは、もし超過したときにエラーが関連付けられている場合には、誤って定義された関数による無限再起を避けるための1つの方法になります。ネストの深さにたいする他の制限としては、@code{max-lisp-eval-depth}があります。@ref{Definition of max-lisp-eval-depth,, Eval}を参照してください。"

#. type: defopt
#: variables.texi.orig:287
msgid ""
"The default value is 1300.  Entry to the Lisp debugger increases the value, "
"if there is little room left, to make sure the debugger itself has room to "
"execute."
msgstr "デフォルト値は1300です。Lispデバッガーのエントリーしたとき、もし残りが少ないときは、デバッガーを実行するための空きを作るために、値は増加されます。"

#. type: section
#: variables.texi.orig:290
#, no-wrap
msgid "When a Variable is ``Void''"
msgstr "When a Variable is ``Void''"

#. type: cindex
#: variables.texi.orig:291
#, no-wrap
msgid "@code{void-variable} error"
msgstr "@code{void-variable} error"

#. type: cindex
#: variables.texi.orig:292
#, no-wrap
msgid "void variable"
msgstr "void variable"

#. type: Plain text
#: variables.texi.orig:296
msgid ""
"We say that a variable is void if its symbol has an unassigned value cell "
"(@pxref{Symbol Components})."
msgstr "シンボルの値セル(@ref{Symbol Components}を参照してください)に値が割り当てられていない場合、その変数はvoid(空)であると言います。"

#. type: Plain text
#: variables.texi.orig:305
msgid ""
"Under Emacs Lisp's default dynamic scoping rule (@pxref{Variable Scoping}), "
"the value cell stores the variable's current (local or global) value.  Note "
"that an unassigned value cell is @emph{not} the same as having @code{nil} in "
"the value cell.  The symbol @code{nil} is a Lisp object and can be the value "
"of a variable, just as any other object can be; but it is still a value.  If "
"a variable is void, trying to evaluate the variable signals a "
"@code{void-variable} error, instead of returning a value."
msgstr "Emacs Lispのデフォルトであるダイナミックスコープルール(@pxref{Variable Scoping})の下では、値セルはその変数のカレント値(ローカルまたはグローバル)を保持します。値が割り当てられていない値セルは、値セルに@code{nil}をもつのとは@emph{異なる}ことに注意してください。シンボル@code{nil}はLispオブジェクトであり、他のオブジェクトと同様に変数の値となることができます。@code{nil}は値なのです。変数がvoidの場合、その変数の評価を試みると、値をreturnするかわりに、@code{void-variable}エラーがシグナルされます。"

#. type: Plain text
#: variables.texi.orig:311
msgid ""
"Under the optional lexical scoping rule, the value cell only holds the "
"variable's global value---the value outside of any lexical binding "
"construct.  When a variable is lexically bound, the local value is "
"determined by the lexical environment; hence, variables can have local "
"values even if their symbols' value cells are unassigned."
msgstr "オプションであるレキシカルスコープルール(lexical scoping rule)の下では、値セル保持できるのは、その変数のグローバル値 --- 任意のレキシカルバインディング構造の外側の値だけです。変数がレキシカルにバインドされている場合、ローカル値はそのレキシカル環境により決定されます。したがって、これらのシンボルの値セルに値が割り当てられていなくても、変数はローカル値を持つことができます。"

#. type: defun
#: variables.texi.orig:312
#, no-wrap
msgid "makunbound symbol"
msgstr "makunbound symbol"

#. type: defun
#: variables.texi.orig:315
msgid ""
"This function empties out the value cell of @var{symbol}, making the "
"variable void.  It returns @var{symbol}."
msgstr "この関数は、@var{symbol}の値セルを空にして、その変数をvoidにします。この関数は@var{symbol}をreturnします。"

#. type: defun
#: variables.texi.orig:321
msgid ""
"If @var{symbol} has a dynamic local binding, @code{makunbound} voids the "
"current binding, and this voidness lasts only as long as the local binding "
"is in effect.  Afterwards, the previously shadowed local or global binding "
"is reexposed; then the variable will no longer be void, unless the reexposed "
"binding is void too."
msgstr "@var{symbol}がダイナミックなローカルバインディングを持つ場合、@code{makunbound}はカレントのバインディングをvoidにし、そのローカルバインディングが効果を持つ限りvoidにします。その後、前にシャドーされたローカル値(またはグローバル値)が再び有効になり、再び有効になった値がvoidでなければ、その変数はvoidでなくなります。"

#. type: defun
#: variables.texi.orig:323 variables.texi.orig:359
msgid "Here are some examples (assuming dynamic binding is in effect):"
msgstr "いくつか例を示します(ダイナミックバインディングが有効だとします):"

#. type: group
#: variables.texi.orig:332
#, no-wrap
msgid ""
"(setq x 1)               ; @r{Put a value in the global binding.}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (makunbound 'x)        ; @r{Void the local binding.}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(setq x 1)               ; @r{グローバルバインディングに値をセットする。}\n"
"     @result{} 1\n"
"(let ((x 2))             ; @r{それをローカルにバインドする。}\n"
"  (makunbound 'x)        ; @r{ローカルバインディングをvoidにする。}\n"
"  x)\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: variables.texi.orig:336
#, no-wrap
msgid ""
"x                        ; @r{The global binding is unchanged.}\n"
"     @result{} 1\n"
"\n"
msgstr ""
"x                        ; @r{グローバルバインディングは変更されない。}\n"
"     @result{} 1\n"
"\n"

#. type: group
#: variables.texi.orig:342
#, no-wrap
msgid ""
"(let ((x 2))             ; @r{Locally bind it.}\n"
"  (let ((x 3))           ; @r{And again.}\n"
"    (makunbound 'x)      ; @r{Void the innermost-local binding.}\n"
"    x))                  ; @r{And refer: it's void.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 2))             ; @r{ローカルにバインドする。}\n"
"  (let ((x 3))           ; @r{もう1度。}\n"
"    (makunbound 'x)      ; @r{最内のローカルバインディングをvoidにする。}\n"
"    x))                  ; @r{それを参照すると、void。}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: group
#: variables.texi.orig:350
#, no-wrap
msgid ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{Void inner binding, then remove it.}\n"
"  x)                     ; @r{Now outer @code{let} binding is visible.}\n"
"     @result{} 2\n"
msgstr ""
"(let ((x 2))\n"
"  (let ((x 3))\n"
"    (makunbound 'x))     ; @r{内側のバインディングをvoidにしてから取り除く。}\n"
"  x)                     ; @r{外側の@code{let}バインディングが有効になる。}\n"
"     @result{} 2\n"

#. type: defun
#: variables.texi.orig:354
#, no-wrap
msgid "boundp variable"
msgstr "boundp variable"

#. type: defun
#: variables.texi.orig:357
msgid ""
"This function returns @code{t} if @var{variable} (a symbol) is not void, and "
"@code{nil} if it is void."
msgstr "この関数は@var{variable}(シンボル)がvoidでなければ@code{t}をreturnし、voidのときは@code{nil}をreturnします。"

#. type: group
#: variables.texi.orig:364
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Starts out void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{最初はvoid。}\n"
"     @result{} nil\n"

#. type: group
#: variables.texi.orig:369
#, no-wrap
msgid ""
"(let ((abracadabra 5))         ; @r{Locally bind it.}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"
msgstr ""
"(let ((abracadabra 5))         ; @r{ローカルにバインドする。}\n"
"  (boundp 'abracadabra))\n"
"     @result{} t\n"

#. type: group
#: variables.texi.orig:373
#, no-wrap
msgid ""
"(boundp 'abracadabra)          ; @r{Still globally void.}\n"
"     @result{} nil\n"
msgstr ""
"(boundp 'abracadabra)          ; @r{グローバルではまだvoid。}\n"
"     @result{} nil\n"

#. type: group
#: variables.texi.orig:377
#, no-wrap
msgid ""
"(setq abracadabra 5)           ; @r{Make it globally nonvoid.}\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)           ; @r{グローバルで非voidにする。}\n"
"     @result{} 5\n"

#. type: group
#: variables.texi.orig:381
#, no-wrap
msgid ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"
msgstr ""
"(boundp 'abracadabra)\n"
"     @result{} t\n"

#. type: section
#: variables.texi.orig:386
#, no-wrap
msgid "Defining Global Variables"
msgstr "Defining Global Variables"

#. type: cindex
#: variables.texi.orig:387
#, no-wrap
msgid "variable definition"
msgstr "variable definition"

#. type: Plain text
#: variables.texi.orig:392
msgid ""
"A @dfn{variable definition} is a construct that announces your intention to "
"use a symbol as a global variable.  It uses the special forms @code{defvar} "
"or @code{defconst}, which are documented below."
msgstr "@dfn{変数定義(variable definition)}とは、そのシンボルをグローバル変数として使用する意図を表明する構成です。これには以下で説明するスペシャルフォーム@code{defvar}や@code{defconst}が使用されます。"

#. type: Plain text
#: variables.texi.orig:399
msgid ""
"A variable definition serves three purposes.  First, it informs people who "
"read the code that the symbol is @emph{intended} to be used a certain way "
"(as a variable).  Second, it informs the Lisp system of this, optionally "
"supplying an initial value and a documentation string.  Third, it provides "
"information to programming tools such as @command{etags}, allowing them to "
"find where the variable was defined."
msgstr "変数宣言は3つの目的をもちます。1番目は、コードを読む人にたいして、そのシンボルが特定の方法(変数として)使用されることを@emph{意図}したものだと知らせることです。2番目は、Lispシステムにたいして、オプションで初期値とドキュメント文字列を与えて、これを知らせることです。3番目は、@command{etags}のようなプログラミングツールにたいして、その変数が定義されている場所を見つけられるように、情報を提供することです。"

#. type: Plain text
#: variables.texi.orig:407
msgid ""
"The difference between @code{defconst} and @code{defvar} is mainly a matter "
"of intent, serving to inform human readers of whether the value should ever "
"change.  Emacs Lisp does not actually prevent you from changing the value of "
"a variable defined with @code{defconst}.  One notable difference between the "
"two forms is that @code{defconst} unconditionally initializes the variable, "
"whereas @code{defvar} initializes it only if it is originally void."
msgstr "@code{defconst}と@code{defvar}の違いは主に、人間の読み手に、値が変更されるかどうかを知らせることにあります。Emacs Lispは実際、@code{defconst}で定義された変数の値の変更を妨げません。この2つのフォームの特筆すべき違いは、@code{defconst}は無条件で変数を初期化し、@code{defvar}は変数が元々voidのときだけ初期化することです。"

#. type: Plain text
#: variables.texi.orig:411
msgid ""
"To define a customizable variable, you should use @code{defcustom} (which "
"calls @code{defvar} as a subroutine).  @xref{Variable Definitions}."
msgstr "マスタマイズ可能な変数を定義する場合は、@code{defcustom}を使用するべきです(これはサブルーチンとして@code{defvar}を呼び出します)。@ref{Variable Definitions}を参照してください。"

#. type: defspec
#: variables.texi.orig:412
#, no-wrap
msgid "defvar symbol [value [doc-string]]"
msgstr "defvar symbol [value [doc-string]]"

#. type: defspec
#: variables.texi.orig:418
msgid ""
"This special form defines @var{symbol} as a variable.  Note that "
"@var{symbol} is not evaluated; the symbol to be defined should appear "
"explicitly in the @code{defvar} form.  The variable is marked as "
"@dfn{special}, meaning that it should always be dynamically bound "
"(@pxref{Variable Scoping})."
msgstr "このスペシャルフォームは、変数として@var{symbol}を定義します。@var{symbol}は評価されないことに注意してください。シンボルは@code{defvar}フォーム内に明示的に表記して定義される必要があります。この変数は@dfn{特別}だとマークされ、これは常にそれがダイナミックにバインドされることを意味します(@ref{Variable Scoping}を参照してください)。"

#. type: defspec
#: variables.texi.orig:425
msgid ""
"If @var{value} is specified, and @var{symbol} is void (i.e., it has no "
"dynamically bound value; @pxref{Void Variables}), then @var{value} is "
"evaluated and @var{symbol} is set to the result.  But if @var{symbol} is not "
"void, @var{value} is not evaluated, and @var{symbol}'s value is left "
"unchanged.  If @var{value} is omitted, the value of @var{symbol} is not "
"changed in any case."
msgstr "@var{value}が指定されていて@var{symbol}がvoid(たとえばこのシンボルがダイナミックにバインドされた値を持たないとき。@ref{Void Variables}を参照してください)、@var{value}が評価されて、その結果が@var{symbol}にセットされます。しかし@var{symbol}がvoidでな場合、@var{value}は評価されず、@var{symbol}の値は変更されません。@var{value}が省略された場合、いかなる場合も@var{symbol}の値は変更されません。"

#. type: defspec
#: variables.texi.orig:430
msgid ""
"If @var{symbol} has a buffer-local binding in the current buffer, "
"@code{defvar} acts on the default value, which is buffer-independent, rather "
"than the buffer-local binding.  It sets the default value if the default "
"value is void.  @xref{Buffer-Local Variables}."
msgstr "@var{symbol}がカレントバッファー内でバッファーローカルなバインディングをもつ場合、@code{defvar}はデフォルト値に作用します。デフォルト値はバッファーローカルなバインディングではなく、バッファーにたいして独立しています。デフォルト値がvoidのときはデフォルト値をセットします。@ref{Buffer-Local Variables}を参照してください。"

#. type: defspec
#: variables.texi.orig:435
msgid ""
"If @var{symbol} is already lexically bound (e.g., if the @code{defvar} form "
"occurs in a @code{let} form with lexical binding enabled), then "
"@code{defvar} sets the dynamic value.  The lexical binding remains in effect "
"until its binding construct exits.  @xref{Variable Scoping}."
msgstr "すでに@var{symbol}がレキシカルにバインドされている場合(たとえばレキシカルバインドが有効な状態で@code{let}フォーム内に@code{defvar}があるような場合)、@code{defvar}はダイナミックな値をセットします。バインディング構造を抜けるまで、レキシカルバインディングは効果をもちます。@ref{Variable Scoping}を参照してください。"

#. type: defspec
#: variables.texi.orig:440
msgid ""
"When you evaluate a top-level @code{defvar} form with @kbd{C-M-x} in Emacs "
"Lisp mode (@code{eval-defun}), a special feature of @code{eval-defun} "
"arranges to set the variable unconditionally, without testing whether its "
"value is void."
msgstr "Emacs Lispモード(@code{eval-defun})でトップレベルの@code{defvar}を評価するとき、@code{eval-defun}の特別な機能は、その値がvoidであるかテストすることなく、その変数を無条件にセットします。"

#. type: defspec
#: variables.texi.orig:444
msgid ""
"If the @var{doc-string} argument is supplied, it specifies the documentation "
"string for the variable (stored in the symbol's "
"@code{variable-documentation} property).  @xref{Documentation}."
msgstr "引数@var{doc-string}が与えられた場合、それは変数にたいするドキュメント文字列を指定します(そのシンボルの@code{variable-documentation}プロパティーに格納されます)。@ref{Documentation}を参照してください。"

#. type: defspec
#: variables.texi.orig:447
msgid ""
"Here are some examples.  This form defines @code{foo} but does not "
"initialize it:"
msgstr "以下にいくつか例を示します。これは@code{foo}を定義しますが、初期化は行いません:"

#. type: group
#: variables.texi.orig:452
#, no-wrap
msgid ""
"(defvar foo)\n"
"     @result{} foo\n"
msgstr ""
"(defvar foo)\n"
"     @result{} foo\n"

#. type: defspec
#: variables.texi.orig:457
msgid ""
"This example initializes the value of @code{bar} to @code{23}, and gives it "
"a documentation string:"
msgstr "この例は@code{bar}の値を@code{23}に初期化して、ドキュメント文字列を与えます:"

#. type: group
#: variables.texi.orig:463
#, no-wrap
msgid ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"
msgstr ""
"(defvar bar 23\n"
"  \"The normal weight of a bar.\")\n"
"     @result{} bar\n"

#. type: defspec
#: variables.texi.orig:468
msgid ""
"The @code{defvar} form returns @var{symbol}, but it is normally used at top "
"level in a file where its value does not matter."
msgstr "@code{defvar}フォームは@var{symbol}をreturnしますが、通常これは値が問題にならないファイル内のトップレベルで使用されます。"

#. type: defspec
#: variables.texi.orig:471
#, no-wrap
msgid "defconst symbol value [doc-string]"
msgstr "defconst symbol value [doc-string]"

#. type: defspec
#: variables.texi.orig:477
msgid ""
"This special form defines @var{symbol} as a value and initializes it.  It "
"informs a person reading your code that @var{symbol} has a standard global "
"value, established here, that should not be changed by the user or by other "
"programs.  Note that @var{symbol} is not evaluated; the symbol to be defined "
"must appear explicitly in the @code{defconst}."
msgstr "このスペシャルフォームは、ある値として@var{symbol}を定義して、それを初期化します。これはコードを読む人に、@var{symbol}がここで設定される標準的なグローバル値をもち、ユーザーや他のプログラムがそれを変更すべきではないことを知らせます。@var{symbol}は評価されないことに注意してください。このシンボルは、@code{defconst}内に明示的に記されなければなりません。"

#. type: defspec
#: variables.texi.orig:482
msgid ""
"The @code{defconst} form, like @code{defvar}, marks the variable as "
"@dfn{special}, meaning that it should always be dynamically bound "
"(@pxref{Variable Scoping}).  In addition, it marks the variable as risky "
"(@pxref{File Local Variables})."
msgstr "@code{defvar}と同様、@code{defconst}は、変数を@dfn{特別} --- この変数が常にダイナミックにバインドされているという意味 --- だとマークします(@ref{Variable Scoping}を参照してください)。加えて、これはその変数を危険であるとマークします(@ref{File Local Variables}を参照してください)。"

#. type: defspec
#: variables.texi.orig:489
msgid ""
"@code{defconst} always evaluates @var{value}, and sets the value of "
"@var{symbol} to the result.  If @var{symbol} does have a buffer-local "
"binding in the current buffer, @code{defconst} sets the default value, not "
"the buffer-local value.  (But you should not be making buffer-local bindings "
"for a symbol that is defined with @code{defconst}.)"
msgstr "@code{defconst}は常に@var{value}を評価して、その結果を@var{symbol}の値にセットします。カレントバッファー内で@var{symbol}がバッファーローカルなバインディングをもつ場合、@code{defconst}はデフォルト値ではなく、バッファーローカルな値をセットします(しかし、@code{defconst}で定義されたシンボルにたいしてバッファーローカルなバインディングを作るべきではありません)。"

#. type: defspec
#: variables.texi.orig:495
msgid ""
"An example of the use of @code{defconst} is Emacs's definition of "
"@code{float-pi}---the mathematical constant @math{pi}, which ought not to be "
"changed by anyone (attempts by the Indiana State Legislature "
"notwithstanding).  As the second form illustrates, however, @code{defconst} "
"is only advisory."
msgstr "@code{defconst}の使い方の例は、Emacsの@code{float-pi} --- (たとえIndiana State Legislatureが何を試みようと)何者かにより変更されるべきではない、数学定数@math{pi}にたいする定義です。しかし2番目の@code{defconst}の例のように、これは単にアドバイス的なものです。"

#. type: group
#: variables.texi.orig:500
#, no-wrap
msgid ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"
msgstr ""
"(defconst float-pi 3.141592653589793 \"The value of Pi.\")\n"
"     @result{} float-pi\n"

#. type: group
#: variables.texi.orig:504
#, no-wrap
msgid ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"
msgstr ""
"(setq float-pi 3)\n"
"     @result{} float-pi\n"

#. type: group
#: variables.texi.orig:508
#, no-wrap
msgid ""
"float-pi\n"
"     @result{} 3\n"
msgstr ""
"float-pi\n"
"     @result{} 3\n"

#. type: Plain text
#: variables.texi.orig:519
msgid ""
"@strong{Warning:} If you use a @code{defconst} or @code{defvar} special form "
"while the variable has a local binding (made with @code{let}, or a function "
"argument), it sets the local binding rather than the global binding.  This "
"is not what you usually want.  To prevent this, use these special forms at "
"top level in a file, where normally no local binding is in effect, and make "
"sure to load the file before making a local binding for the variable."
msgstr "@strong{警告:} 変数がローカルバインディングをもつとき(@code{let}により作成された、または関数の引数の場合)に、スペシャルフォーム@code{defconst}または@code{defvar}を使用すると、これらのフォームはグローバルバインディングではなく、ローカルバインディングをセットします。これは通常、あなたが望むことではないはずです。これを防ぐには、これらのスペシャルフォームをファイル内のトップレベルで使用します。この場所は通常、何のローカルバインディングも効果をもたないので、その変数にたいするローカルバインディングが作成される前にファイルがロードされることが確実だからです。"

#. type: section
#: variables.texi.orig:521
#, no-wrap
msgid "Tips for Defining Variables Robustly"
msgstr "Tips for Defining Variables Robustly"

#. type: Plain text
#: variables.texi.orig:526
msgid ""
"When you define a variable whose value is a function, or a list of "
"functions, use a name that ends in @samp{-function} or @samp{-functions}, "
"respectively."
msgstr "値が関数(または関数のリスト)であるような変数を定義するとき、変数の名前の最後に@samp{-function}(または@samp{-functions})を使います。"

#. type: Plain text
#: variables.texi.orig:529
msgid "There are several other variable name conventions; here is a complete list:"
msgstr "他にも、変数名に関する慣習があります。以下はその完全なリストです:"

#. type: item
#: variables.texi.orig:531
#, no-wrap
msgid "@dots{}-hook"
msgstr "@dots{}-hook"

#. type: table
#: variables.texi.orig:533
msgid "The variable is a normal hook (@pxref{Hooks})."
msgstr "変数はノーマルフックです(@ref{Hooks}を参照してください)。"

#. type: item
#: variables.texi.orig:534
#, no-wrap
msgid "@dots{}-function"
msgstr "@dots{}-function"

#. type: table
#: variables.texi.orig:536
msgid "The value is a function."
msgstr "値は関数です。"

#. type: item
#: variables.texi.orig:537
#, no-wrap
msgid "@dots{}-functions"
msgstr "@dots{}-functions"

#. type: table
#: variables.texi.orig:539
msgid "The value is a list of functions."
msgstr "値は関数のリストです。"

#. type: item
#: variables.texi.orig:540
#, no-wrap
msgid "@dots{}-form"
msgstr "@dots{}-form"

#. type: table
#: variables.texi.orig:542
msgid "The value is a form (an expression)."
msgstr "値はフォーム(式)です。"

#. type: item
#: variables.texi.orig:543
#, no-wrap
msgid "@dots{}-forms"
msgstr "@dots{}-forms"

#. type: table
#: variables.texi.orig:545
msgid "The value is a list of forms (expressions)."
msgstr "値はフォーム(式)のリストです。"

#. type: item
#: variables.texi.orig:546
#, no-wrap
msgid "@dots{}-predicate"
msgstr "@dots{}-predicate"

#. type: table
#: variables.texi.orig:550
msgid ""
"The value is a predicate---a function of one argument that returns "
"non-@code{nil} for ``good'' arguments and @code{nil} for ``bad'' arguments."
msgstr "値は述語(predicate) --- 1つの引数をとる関数 --- で、引数が``正しい(good)''\"場合は非@code{nil}、``正しくない(bad)''場合は@code{nil}をreturnします。"

#. type: item
#: variables.texi.orig:551
#, no-wrap
msgid "@dots{}-flag"
msgstr "@dots{}-flag"

#. type: table
#: variables.texi.orig:555
msgid ""
"The value is significant only as to whether it is @code{nil} or not.  Since "
"such variables often end up acquiring more values over time, this convention "
"is not strongly recommended."
msgstr "@code{nil}か、そうでないかだけが意味をもつような値です。そのような変数は結局、やがては多くの値をもつことが多いので、この慣習を強く推奨はしません。"

#. type: item
#: variables.texi.orig:556
#, no-wrap
msgid "@dots{}-program"
msgstr "@dots{}-program"

#. type: table
#: variables.texi.orig:558
msgid "The value is a program name."
msgstr "値はプログラム名です。"

#. type: item
#: variables.texi.orig:559
#, no-wrap
msgid "@dots{}-command"
msgstr "@dots{}-command"

#. type: table
#: variables.texi.orig:561
msgid "The value is a whole shell command."
msgstr "値は完全なシェルコマンドです。"

#. type: item
#: variables.texi.orig:562
#, no-wrap
msgid "@dots{}-switches"
msgstr "@dots{}-switches"

#. type: table
#: variables.texi.orig:564
msgid "The value specifies options for a command."
msgstr "値はコマンドにたいして指定するオプションです。"

#. type: Plain text
#: variables.texi.orig:568
msgid ""
"When you define a variable, always consider whether you should mark it as "
"``safe'' or ``risky''; see @ref{File Local Variables}."
msgstr "変数を定義するときは、その変数を``安全(safe)''とマークすべきか、それとも``危険(risky)''とマークすべきかを常に考慮してください。@ref{File Local Variables}を参照してください。"

#. type: Plain text
#: variables.texi.orig:572
msgid ""
"When defining and initializing a variable that holds a complicated value "
"(such as a keymap with bindings in it), it's best to put the entire "
"computation of the value into the @code{defvar}, like this:"
msgstr "複雑な値を保持する変数(バインディングをもつkeymapなど)を定義、または初期化するとき、以下のように値の計算をすべて@code{defvar}の中に配置するのが最良です:"

#. type: example
#: variables.texi.orig:580
#, no-wrap
msgid ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"
msgstr ""
"(defvar my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    map)\n"
"  @var{docstring})\n"

#. type: Plain text
#: variables.texi.orig:591
msgid ""
"This method has several benefits.  First, if the user quits while loading "
"the file, the variable is either still uninitialized or initialized "
"properly, never in-between.  If it is still uninitialized, reloading the "
"file will initialize it properly.  Second, reloading the file once the "
"variable is initialized will not alter it; that is important if the user has "
"run hooks to alter part of the contents (such as, to rebind keys).  Third, "
"evaluating the @code{defvar} form with @kbd{C-M-x} will reinitialize the map "
"completely."
msgstr "この方法にはいくつかの利点があります。1つ目は、ファールをロード中にユーザーが中断した場合、変数はまだ初期化されていないか、初期化されているかのどちらかで、その中間ということはありません。まだ初期化されていない場合、ファイルをリロードすれば正しく初期化されます。2つ目は、1度初期化された変数は、ファイルをリロードしても変更されないことです。コンテンツの一部を変更(たとえばキーのリバインド)するフックをユーザーが実行した場合などに、これは重要です。3つ目は、@kbd{C-M-x}で@code{defvar}を評価すると、そのマップは完全に再初期化されることです。"

#. type: Plain text
#: variables.texi.orig:595
msgid ""
"Putting so much code in the @code{defvar} form has one disadvantage: it puts "
"the documentation string far away from the line which names the variable.  "
"Here's a safe way to avoid that:"
msgstr "@code{defvar}フォーム内に多すぎるコードを配置することには不利な点が1つあります。ドキュメント文字列が変数の名前から離れた場所に配置されることです。これを避ける安全な方法は以下の方法です:"

#. type: example
#: variables.texi.orig:604
#, no-wrap
msgid ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"
msgstr ""
"(defvar my-mode-map nil\n"
"  @var{docstring})\n"
"(unless my-mode-map\n"
"  (let ((map (make-sparse-keymap)))\n"
"    (define-key map \"\\C-c\\C-a\" 'my-command)\n"
"    @dots{}\n"
"    (setq my-mode-map map)))\n"

#. type: Plain text
#: variables.texi.orig:610
msgid ""
"This has all the same advantages as putting the initialization inside the "
"@code{defvar}, except that you must type @kbd{C-M-x} twice, once on each "
"form, if you do want to reinitialize the variable."
msgstr "これは初期化を@code{defvar}の内側に配置した場合とまったく同じ利点をもちますが、変数を再度初期化したい場合は、各フォームにたいして1回ずつ、2度@kbd{C-M-x}をタイプしなければならない点が異なります。"

#. type: section
#: variables.texi.orig:612
#, no-wrap
msgid "Accessing Variable Values"
msgstr "Accessing Variable Values"

#. type: Plain text
#: variables.texi.orig:616
msgid ""
"The usual way to reference a variable is to write the symbol which names "
"it.  @xref{Symbol Forms}."
msgstr "変数を参照する通常の方法は、それに名前をつけるシンボルを記述する方法です。The usual way to reference a variable is to write the symbol which names it.  @ref{Symbol Forms}を参照してください。"

#. type: Plain text
#: variables.texi.orig:621
msgid ""
"Occasionally, you may want to reference a variable which is only determined "
"at run time.  In that case, you cannot specify the variable name in the text "
"of the program.  You can use the @code{symbol-value} function to extract the "
"value."
msgstr "時には、実行時にのみ決定される変数を参照したいときがあるかもしれません。そのような場合、プログラム中のテキストで、変数名を指定することはできません。その値を抽出するために、@code{symbol-value}を使うことができます。"

#. type: defun
#: variables.texi.orig:622
#, no-wrap
msgid "symbol-value symbol"
msgstr "symbol-value symbol"

#. type: defun
#: variables.texi.orig:627
msgid ""
"This function returns the value stored in @var{symbol}'s value cell.  This "
"is where the variable's current (dynamic) value is stored.  If the variable "
"has no local binding, this is simply its global value.  If the variable is "
"void, a @code{void-variable} error is signaled."
msgstr "この関数は、@var{symbol}の値セルに格納された値をreturnします。これには、その変数の(ダイナミックな)カレント値が格納された場所です。その変数がローカルバインディングをもたない場合は、単にその変数のグローバル値になります。変数がvoidの場合、@code{void-variable}はエラーをシグナルします。"

#. type: defun
#: variables.texi.orig:632
msgid ""
"If the variable is lexically bound, the value reported by "
"@code{symbol-value} is not necessarily the same as the variable's lexical "
"value, which is determined by the lexical environment rather than the "
"symbol's value cell.  @xref{Variable Scoping}."
msgstr "その変数がレキシカルにバインドされている場合、@code{symbol-value}により報告される値は、その変数のレキシカル値と同じである必要はありません。レキシカル値はそのシンボルの値セルではなく、レキシカル環境により決定されます。@ref{Variable Scoping}を参照してください。"

#. type: group
#: variables.texi.orig:637
#, no-wrap
msgid ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"
msgstr ""
"(setq abracadabra 5)\n"
"     @result{} 5\n"

#. type: group
#: variables.texi.orig:641
#, no-wrap
msgid ""
"(setq foo 9)\n"
"     @result{} 9\n"
msgstr ""
"(setq foo 9)\n"
"     @result{} 9\n"

#. type: group
#: variables.texi.orig:649
#, no-wrap
msgid ""
";; @r{Here the symbol @code{abracadabra}}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"
msgstr ""
";; @r{ここでシンボル@code{abracadabra}は}\n"
";;   @r{値がテストされるシンボル。}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value 'abracadabra))\n"
"     @result{} foo\n"

#. type: group
#: variables.texi.orig:658
#, no-wrap
msgid ""
";; @r{Here, the value of @code{abracadabra},}\n"
";;   @r{which is @code{foo},}\n"
";;   @r{is the symbol whose value is examined.}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"
msgstr ""
";; @r{ここでは、@code{abracadabra}の値、}\n"
";;   @r{つまり@code{foo}が、}\n"
";;   @r{値をテストされるシンボル。}\n"
"(let ((abracadabra 'foo))\n"
"  (symbol-value abracadabra))\n"
"     @result{} 9\n"

#. type: group
#: variables.texi.orig:663
#, no-wrap
msgid ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"
msgstr ""
"(symbol-value 'abracadabra)\n"
"     @result{} 5\n"

#. type: section
#: variables.texi.orig:668
#, no-wrap
msgid "Setting Variable Values"
msgstr "Setting Variable Values"

#. type: Plain text
#: variables.texi.orig:673
msgid ""
"The usual way to change the value of a variable is with the special form "
"@code{setq}.  When you need to compute the choice of variable at run time, "
"use the function @code{set}."
msgstr "ある変数の値を変更する通常の方法は、スペシャルフォーム@code{setq}を使用する方法です。実行時に変数選択を計算する必要がある場合は、関数@code{set}を使用します。"

#. type: defspec
#: variables.texi.orig:674
#, no-wrap
msgid "setq [symbol form]@dots{}"
msgstr "setq [symbol form]@dots{}"

#. type: defspec
#: variables.texi.orig:679
msgid ""
"This special form is the most common method of changing a variable's value.  "
"Each @var{symbol} is given a new value, which is the result of evaluating "
"the corresponding @var{form}.  The current binding of the symbol is changed."
msgstr "このスペシャルフォームは、変数の値を変更するための、もっとも一般的な方法です。@var{symbol}にはそれぞれ、新しい値(対応する@var{form}が評価された結果)を与えられます。そのシンボルのカレントバインディングは変更されます。"

#. type: defspec
#: variables.texi.orig:683
msgid ""
"@code{setq} does not evaluate @var{symbol}; it sets the symbol that you "
"write.  We say that this argument is @dfn{automatically quoted}.  The "
"@samp{q} in @code{setq} stands for ``quoted''."
msgstr "@code{setq}は@var{symbol}を評価せず、記述されたシンボルをセットします。この引数のことを、@dfn{自動的にクォートされた(automatically quoted)}と呼びます。@code{setq}の@samp{q}は、``quoted(クォートされた)''が由来です。"

#. type: defspec
#: variables.texi.orig:685
msgid "The value of the @code{setq} form is the value of the last @var{form}."
msgstr "@code{setq}フォームの値は、最後の@var{form}の値となります。"

#. type: group
#: variables.texi.orig:690
#, no-wrap
msgid ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"
msgstr ""
"(setq x (1+ 2))\n"
"     @result{} 3\n"

#. type: example
#: variables.texi.orig:693
#, no-wrap
msgid ""
"x                   ; @r{@code{x} now has a global value.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{ここで@code{x}はグローバル値をもつ。}\n"
"     @result{} 3\n"

#. type: group
#: variables.texi.orig:698
#, no-wrap
msgid ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{The local binding of @code{x} is set.}\n"
"  x)\n"
"     @result{} 6\n"
msgstr ""
"(let ((x 5))\n"
"  (setq x 6)        ; @r{@code{x}のローカルバインディングをセット。}\n"
"  x)\n"
"     @result{} 6\n"

#. type: example
#: variables.texi.orig:701
#, no-wrap
msgid ""
"x                   ; @r{The global value is unchanged.}\n"
"     @result{} 3\n"
msgstr ""
"x                   ; @r{グローバル値は変更されない。}\n"
"     @result{} 3\n"

#. type: defspec
#: variables.texi.orig:706
msgid ""
"Note that the first @var{form} is evaluated, then the first @var{symbol} is "
"set, then the second @var{form} is evaluated, then the second @var{symbol} "
"is set, and so on:"
msgstr "1番目の@var{form}が評価されてから1番目の@var{symbol}がセットされ、次に2番目の@var{form}が評価されてから@var{symbol}が評価されて、...となることに注意してください:"

#. type: group
#: variables.texi.orig:712
#, no-wrap
msgid ""
"(setq x 10          ; @r{Notice that @code{x} is set before}\n"
"      y (1+ x))     ;   @r{the value of @code{y} is computed.}\n"
"     @result{} 11\n"
msgstr ""
"(setq x 10          ; @r{ここで、@code{x}がセットされるのは}\n"
"      y (1+ x))     ;   @r{@code{y}の計算前であることに注目。}\n"
"     @result{} 11\n"

#. type: defun
#: variables.texi.orig:716
#, no-wrap
msgid "set symbol value"
msgstr "set symbol value"

#. type: defun
#: variables.texi.orig:721
msgid ""
"This function puts @var{value} in the value cell of @var{symbol}.  Since it "
"is a function rather than a special form, the expression written for "
"@var{symbol} is evaluated to obtain the symbol to set.  The return value is "
"@var{value}."
msgstr "この関数は、@var{symbol}の値セルに@var{value}を配置します。これはスペシャルフォームではなく関数なので、シンボルにセットするために、@var{symbol}に記述された式は評価されます。return値は@var{value}です。"

#. type: defun
#: variables.texi.orig:728
msgid ""
"When dynamic variable binding is in effect (the default), @code{set} has the "
"same effect as @code{setq}, apart from the fact that @code{set} evaluates "
"its @var{symbol} argument whereas @code{setq} does not.  But when a variable "
"is lexically bound, @code{set} affects its @emph{dynamic} value, whereas "
"@code{setq} affects its current (lexical) value.  @xref{Variable Scoping}."
msgstr "ダイナミックな変数バインドが有効な場合(デフォルト)、@code{set}は自身の引数@var{symbol}を評価しますが、@code{setq}は評価しないという点を除き、@code{set}は@code{setq}と同じ効果をもちます。しかし、変数がレキシカルバインドの場合、@code{set}は変数の@emph{ダイナミック}な値に影響し、@code{setq}は変数のカレント値(レキシカル値)に影響します。@ref{Variable Scoping}を参照してください。"

#. type: group
#: variables.texi.orig:733
#, no-wrap
msgid ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"
msgstr ""
"(set one 1)\n"
"@error{} Symbol's value as variable is void: one\n"

#. type: group
#: variables.texi.orig:737
#, no-wrap
msgid ""
"(set 'one 1)\n"
"     @result{} 1\n"
msgstr ""
"(set 'one 1)\n"
"     @result{} 1\n"

#. type: group
#: variables.texi.orig:741
#, no-wrap
msgid ""
"(set 'two 'one)\n"
"     @result{} one\n"
msgstr ""
"(set 'two 'one)\n"
"     @result{} one\n"

#. type: group
#: variables.texi.orig:745
#, no-wrap
msgid ""
"(set two 2)         ; @r{@code{two} evaluates to symbol @code{one}.}\n"
"     @result{} 2\n"
msgstr ""
"(set two 2)         ; @r{@code{two}は、シンボル@code{one}に評価される。}\n"
"     @result{} 2\n"

#. type: group
#: variables.texi.orig:753
#, no-wrap
msgid ""
"one                 ; @r{So it is @code{one} that was set.}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{This binding of @code{one} is set,}\n"
"  (set 'one 3)      ;   @r{not the global value.}\n"
"  one)\n"
"     @result{} 3\n"
msgstr ""
"one                 ; @r{したがって@code{one}がセットされる。}\n"
"     @result{} 2\n"
"(let ((one 1))      ; @r{@code{one}のこのバインディングがセットされるのであって}\n"
"  (set 'one 3)      ;   @r{グローバル値はセットされない。}\n"
"  one)\n"
"     @result{} 3\n"

#. type: group
#: variables.texi.orig:757
#, no-wrap
msgid ""
"one\n"
"     @result{} 2\n"
msgstr ""
"one\n"
"     @result{} 2\n"

#. type: defun
#: variables.texi.orig:762
msgid ""
"If @var{symbol} is not actually a symbol, a @code{wrong-type-argument} error "
"is signaled."
msgstr "@var{symbol}が実際のシンボルでない場合、@code{wrong-type-argument}エラーがシグナルされます。"

#. type: example
#: variables.texi.orig:766
#, no-wrap
msgid ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"
msgstr ""
"(set '(x y) 'z)\n"
"@error{} Wrong type argument: symbolp, (x y)\n"

#. type: section
#: variables.texi.orig:770
#, no-wrap
msgid "Scoping Rules for Variable Bindings"
msgstr "Scoping Rules for Variable Bindings"

#. type: cindex
#: variables.texi.orig:771
#, no-wrap
msgid "scoping rule"
msgstr "scoping rule"

#. type: Plain text
#: variables.texi.orig:776
msgid ""
"When you create a local binding for a variable, that binding takes effect "
"only within a limited portion of the program (@pxref{Local Variables}).  "
"This section describes exactly what this means."
msgstr "ある変数にたいするローカルバインディングを作成するとき、そのバインディングはプログラムの限られた一部だけに効果をもちます(@pxref{Local Variables})。このセクションでは、これが正確には何を意味するかについて説明します。"

#. type: cindex
#: variables.texi.orig:777
#, no-wrap
msgid "scope"
msgstr "scope"

#. type: cindex
#: variables.texi.orig:778
#, no-wrap
msgid "extent"
msgstr "extent"

#. type: Plain text
#: variables.texi.orig:783
msgid ""
"Each local binding has a certain @dfn{scope} and @dfn{extent}.  @dfn{Scope} "
"refers to @emph{where} in the textual source code the binding can be "
"accessed.  @dfn{Extent} refers to @emph{when}, as the program is executing, "
"the binding exists."
msgstr "ローカルバインディングはそれぞれ、個別に@dfn{スコープ(scope: 範囲という意味)}と@dfn{エクステント(extent: これも範囲を意味する)}をもちます。@dfn{スコープ}は、そのバインディングにアクセスできるのが、テキストのソースコードの@emph{どこ(where)}であるかを示します。@dfn{エクステント}は、プログラムの実行中に、そのバインディングが存在するのが@emph{いつ(when)}であるかを示します。"

#. type: cindex
#: variables.texi.orig:784
#, no-wrap
msgid "dynamic binding"
msgstr "dynamic binding"

#. type: cindex
#: variables.texi.orig:785
#, no-wrap
msgid "dynamic scope"
msgstr "dynamic scope"

#. type: cindex
#: variables.texi.orig:786
#, no-wrap
msgid "dynamic extent"
msgstr "dynamic extent"

#. type: Plain text
#: variables.texi.orig:793
msgid ""
"By default, the local bindings that Emacs creates are @dfn{dynamic "
"bindings}.  Such a binding has @dfn{dynamic scope}, meaning that any part of "
"the program can potentially access the variable binding.  It also has "
"@dfn{dynamic extent}, meaning that the binding lasts only while the binding "
"construct (such as the body of a @code{let} form) is being executed."
msgstr "デフォルトでは、Emacsが作成したローカルバインディングは、@dfn{ダイナミックバインディング(dynamic binding)}です。このようなバインディングは、@dfn{ダイナミックスコープ(dynamic scope)}をもち、それはプログラムの任意の範囲が、その変数バインディングにアクセスするかもしれないことを意味します。これは@dfn{ダイナミックエクステント(dynamic extent)}ももちます。これはそのバインディング構造(@code{let}フォームのbodyなど)が実行される間だけ、そのバインディングが存続することを意味します。"

#. type: cindex
#: variables.texi.orig:794
#, no-wrap
msgid "lexical binding"
msgstr "lexical binding"

#. type: cindex
#: variables.texi.orig:795
#, no-wrap
msgid "lexical scope"
msgstr "lexical scope"

#. type: cindex
#: variables.texi.orig:796
#, no-wrap
msgid "indefinite extent"
msgstr "indefinite extent"

#. type: Plain text
#: variables.texi.orig:805
msgid ""
"Emacs can optionally create @dfn{lexical bindings}.  A lexical binding has "
"@dfn{lexical scope}, meaning that any reference to the variable must be "
"located textually within the binding construct@footnote{With some "
"exceptions; for instance, a lexical binding can also be accessed from the "
"Lisp debugger.}.  It also has @dfn{indefinite extent}, meaning that under "
"some circumstances the binding can live on even after the binding construct "
"has finished executing, by means of special objects called @dfn{closures}."
msgstr "Emacsはオプションで@dfn{レキシカルバインディング(lexical binding)}を作成することができます。レキシカルバインディングは@dfn{レキシカルスコープ(lexical scope)}をもち、これはその変数にたいする任意の参照が、バインディング構造内にテキスト的に配置されなければならないことを意味します@footnote{これには、いくつか例外があります。たとえば、レキシカルバインディングは、Lispデバッガーからもアクセスできます。}。レキシカルバインディングは@dfn{不定エクステント(indefinite extent)}ももちます。これは、ある状況下において、@dfn{クロージャー(closures)}と呼ばれるスペシャルオブジェクトにより、バインディング構造が実行を終えた後でさえも、存続を続けることを意味します。"

#. type: Plain text
#: variables.texi.orig:809
msgid ""
"The following subsections describe dynamic binding and lexical binding in "
"greater detail, and how to enable lexical binding in Emacs Lisp programs."
msgstr "以降のサブセクションでは、ダイナミックバインディングとレキシカルバインディング、およびEmacs Lispプログラムでレキシカルバインディングを有効にする方法について、より詳細に説明します。"

#. type: subsection
#: variables.texi.orig:815 variables.texi.orig:817 variables.texi.orig:818
#, no-wrap
msgid "Dynamic Binding"
msgstr "Dynamic Binding"

#. type: menuentry
#: variables.texi.orig:815
msgid "The default for binding local variables in Emacs."
msgstr "Emacs内でのローカル変数にたいするデフォルトのバインディング。"

#. type: node
#: variables.texi.orig:815 variables.texi.orig:888
#, no-wrap
msgid "Dynamic Binding Tips"
msgstr "Dynamic Binding Tips"

#. type: menuentry
#: variables.texi.orig:815
msgid "Avoiding problems with dynamic binding."
msgstr "ダイナミックバインディングによる問題を回避する。"

#. type: subsection
#: variables.texi.orig:815 variables.texi.orig:933 variables.texi.orig:934
#, no-wrap
msgid "Lexical Binding"
msgstr "Lexical Binding"

#. type: menuentry
#: variables.texi.orig:815
msgid "A different type of local variable binding."
msgstr "ローカル変数にたいする他の種類のバインディング。"

#. type: subsection
#: variables.texi.orig:815 variables.texi.orig:1042 variables.texi.orig:1043
#, no-wrap
msgid "Using Lexical Binding"
msgstr "Using Lexical Binding"

#. type: menuentry
#: variables.texi.orig:815
msgid "How to enable lexical binding."
msgstr "レキシカルバインディングを有効にする方法。"

#. type: Plain text
#: variables.texi.orig:825
msgid ""
"By default, the local variable bindings made by Emacs are dynamic bindings.  "
"When a variable is dynamically bound, its current binding at any point in "
"the execution of the Lisp program is simply the most recently-created "
"dynamic local binding for that symbol, or the global binding if there is no "
"such local binding."
msgstr "デフォルトでは、Emacsにより作成されるローカル変数のバインディングは、ダイナミックバインディングです。ある変数がダイナミックにバインドされていると、Lispプログラムの実行における任意のポイントでのカレントバインディングは、単にそのシンボルにたいしてもっとも最近作成されたダイナミックなローカルバインディングか、そのようなローカルバインディングが存在しない場合はグローバルバインディングになります。"

#. type: Plain text
#: variables.texi.orig:828
msgid ""
"Dynamic bindings have dynamic scope and extent, as shown by the following "
"example:"
msgstr "以下の例のように、ダイナミックバインディングはダイナミックスコープとダイナミック<エクステントをもちます:"

#. type: group
#: variables.texi.orig:832
#, no-wrap
msgid ""
"(defvar x -99)  ; @r{@code{x} receives an initial value of @minus{}99.}\n"
"\n"
msgstr "(defvar x -99)  ; @r{@code{x}は初期値として@minus{}99を受け取る。}\n\n"

#. type: group
#: variables.texi.orig:835 variables.texi.orig:961
#, no-wrap
msgid ""
"(defun getx ()\n"
"  x)            ; @r{@code{x} is used ``free'' in this function.}\n"
"\n"
msgstr ""
"(defun getx ()\n"
"  x)            ; @r{この関数内では、@code{x}は``自由''に使用される。}\n"
"\n"

#. type: group
#: variables.texi.orig:839
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is dynamically bound.}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はダイナミックにバインドされている。}\n"
"  (getx))\n"
"     @result{} 1\n"
"\n"

#. type: group
#: variables.texi.orig:842 variables.texi.orig:874
#, no-wrap
msgid ""
";; @r{After the @code{let} form finishes, @code{x} reverts to its}\n"
";; @r{previous value, which is @minus{}99.}\n"
"\n"
msgstr ""
";; @r{@code{let}フォームが終了した後、}\n"
";; @r{@code{x}は前の値@minus{}99にリバートされる。}\n"
"\n"

#. type: group
#: variables.texi.orig:845
#, no-wrap
msgid ""
"(getx)\n"
"     @result{} -99\n"
msgstr ""
"(getx)\n"
"     @result{} -99\n"

#. type: Plain text
#: variables.texi.orig:856
msgid ""
"The function @code{getx} refers to @code{x}.  This is a ``free'' reference, "
"in the sense that there is no binding for @code{x} within that @code{defun} "
"construct itself.  When we call @code{getx} from within a @code{let} form in "
"which @code{x} is (dynamically) bound, it retrieves the local value (i.e., "
"1).  But when we call @code{getx} outside the @code{let} form, it retrieves "
"the global value (i.e., @minus{}99)."
msgstr "関数@code{getx}は@code{x}を参照します。@code{defun}構造自体の中に@code{x}にたいするバインディングが存在しないと意味において、これは``自由''な参照です。@code{x}が(ダイナミックに)バインドされている@code{let}フォーム内から@code{getx}を呼び出すと、ローカル値(つまり1)が取得されます。しかし、その後@code{let}フォームの外側から@code{getx}を呼び出すと、グローバル値(つまり@minus{}99)が取得されます。"

#. type: Plain text
#: variables.texi.orig:859
msgid ""
"Here is another example, which illustrates setting a dynamically bound "
"variable using @code{setq}:"
msgstr "以下は、@code{setq}を使用してダイナミックに変数をバインドする、例をです:"

#. type: group
#: variables.texi.orig:863
#, no-wrap
msgid ""
"(defvar x -99)      ; @r{@code{x} receives an initial value of "
"@minus{}99.}\n"
"\n"
msgstr "(defvar x -99)      ; @r{@code{x}は初期値として@minus{}99を受け取る。}\n\n"

#. type: group
#: variables.texi.orig:866
#, no-wrap
msgid ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{Add 1 to @code{x} and return its new value.}\n"
"\n"
msgstr ""
"(defun addx ()\n"
"  (setq x (1+ x)))  ; @r{@code{x}に1追加して、新しい値をreturnする。}\n"
"\n"

#. type: group
#: variables.texi.orig:871
#, no-wrap
msgid ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{The two @code{addx} calls add to @code{x} "
"twice.}\n"
"\n"
msgstr ""
"(let ((x 1))\n"
"  (addx)\n"
"  (addx))\n"
"     @result{} 3           ; @r{@code{addx}を2回呼び出すと、@code{x}に2回追加される。}\n"
"\n"

#. type: group
#: variables.texi.orig:877
#, no-wrap
msgid ""
"(addx)\n"
"     @result{} -98\n"
msgstr ""
"(addx)\n"
"     @result{} -98\n"

#. type: Plain text
#: variables.texi.orig:887
msgid ""
"Dynamic binding is implemented in Emacs Lisp in a simple way.  Each symbol "
"has a value cell, which specifies its current dynamic value (or absence of "
"value).  @xref{Symbol Components}.  When a symbol is given a dynamic local "
"binding, Emacs records the contents of the value cell (or absence thereof) "
"in a stack, and stores the new local value in the value cell.  When the "
"binding construct finishes executing, Emacs pops the old value off the "
"stack, and puts it in the value cell."
msgstr "Emacs Lispでは、ダイナミックバインディングは、シンプルな方法で実装されています。それぞれのシンボルは、シンボルのカレントのダイナミック値(または値の不在)を指定する値セルをもちます。@ref{Symbol Components}を参照してください。あるシンボルがダイナミックなローカル値を与えられたとき、Emacsは値セルの内容(または値の不在)をスタックに記録し、新しいローカル値を値セルに格納します。バインディング構造が実行を終えたとき、Emacsはスタックから古い値をpopして、値セルにそれを置きます。"

#. type: subsection
#: variables.texi.orig:889
#, no-wrap
msgid "Proper Use of Dynamic Binding"
msgstr "Proper Use of Dynamic Binding"

#. type: Plain text
#: variables.texi.orig:896
msgid ""
"Dynamic binding is a powerful feature, as it allows programs to refer to "
"variables that are not defined within their local textual scope.  However, "
"if used without restraint, this can also make programs hard to understand.  "
"There are two clean ways to use this technique:"
msgstr "ダイナミックバインディングは、プログラムにたいしてテキスト的なローカルスコープ内で定義されていない変数を参照することを許す、強力な機能です。しかし、無制限に使用した場合は、プログラムの理解しにくくしてしまうこともあります。このテクニックを使用するために、2つの明解な方法があります:"

#. type: itemize
#: variables.texi.orig:905
msgid ""
"If a variable has no global definition, use it as a local variable only "
"within a binding construct, such as the body of the @code{let} form where "
"the variable was bound.  If this convention is followed consistently "
"throughout a program, the value of the variable will not affect, nor be "
"affected by, any uses of the same variable symbol elsewhere in the program."
msgstr "ある変数がグローバルな定義をもたない場合は、ローカル変数としてバインディング構造内だけ(その変数がバインドされる@code{let}フォームのbodyなどの場所)でそれを使用します。プログラムでこの慣習に一貫してしたがえば、プログラム内の他の場所の同じ変数シンボルの任意の使用が、その変数の値に影響を与えたり、影響を受けることがなくなります。"

#. type: itemize
#: variables.texi.orig:913
msgid ""
"Otherwise, define the variable with @code{defvar}, @code{defconst}, or "
"@code{defcustom}.  @xref{Defining Variables}.  Usually, the definition "
"should be at top-level in an Emacs Lisp file.  As far as possible, it should "
"include a documentation string which explains the meaning and purpose of the "
"variable.  You should also choose the variable's name to avoid name "
"conflicts (@pxref{Coding Conventions})."
msgstr "それ以外では、@code{defvar}、@code{defconst}、@code{defcustom}で変数を定義します。@ref{Defining Variables}を参照してください。この定義は通常、Emacs Lispファイル内のトップレベルにあるべきです。この定義には可能な限り、変数の意味と目的を説明するドキュメント文字列を含めるべきです。名前の衝突を避けるように、変数を命名することも行うべきです(@ref{Coding Conventions}を参照してください)。"

#. type: itemize
#: variables.texi.orig:919
msgid ""
"Then you can bind the variable anywhere in a program, knowing reliably what "
"the effect will be.  Wherever you encounter the variable, it will be easy to "
"refer back to the definition, e.g., via the @kbd{C-h v} command (provided "
"the variable definition has been loaded into Emacs).  @xref{Name Help,,, "
"emacs, The GNU Emacs Manual}."
msgstr "その後は、プログラム内のどこか別の場所で、それが何に影響するか確信をもって、変数をバインドすることができます。その変数にどこで出会っても、(たとえば、変数の定義がEmacsにロードされていれば、@kbd{C-h v}コマンドを通じて)定義を参照するのが簡単になります。@ref{Name Help,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: itemize
#: variables.texi.orig:922
msgid ""
"For example, it is common to use local bindings for customizable variables "
"like @code{case-fold-search}:"
msgstr "たとえば、@code{case-fold-search}のようなカスタマイズ可能な変数にたいしてローカルバインディングを使用するのは一般的です:"

#. type: group
#: variables.texi.orig:929
#, no-wrap
msgid ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search nil))\n"
"    (re-search-forward \"abc\")))\n"
msgstr ""
"(defun search-for-abc ()\n"
"  \"Search for the string \\\"abc\\\", ignoring case differences.\"\n"
"  (let ((case-fold-search nil))\n"
"    (re-search-forward \"abc\")))\n"

#. type: Plain text
#: variables.texi.orig:942
msgid ""
"Lexical binding was introduced to Emacs, as an optional feature, in version "
"24.1.  We expect its importance to increase in the future.  Lexical binding "
"opens up many more opportunities for optimization, so programs using it are "
"likely to run faster in future Emacs versions.  Lexical binding is also more "
"compatible with concurrency, which we want to add to Emacs in the future."
msgstr "Emacsのバージョン24.1から、オプションの機能としてレキシカルバインディングが導入されました。わたしたちは、この機能の重要さが、将来において重要になることを期待します。レキシカルバインディングは最適化の機会をより広げるので、この機能を使用するプログラムはおそらく、将来のEmacsバージョンで高速に実行されるようになるでしょう。レキシカルバインディングは、わたしたちがEmacsに将来追加したいと考える並列性(concurrency)とも互換をもっています。"

#. type: Plain text
#: variables.texi.orig:946
msgid ""
"A lexically-bound variable has @dfn{lexical scope}, meaning that any "
"reference to the variable must be located textually within the binding "
"construct.  Here is an example"
msgstr ""
"レキシカルにバインドされた変数は@dfn{レキシカルスコープ(lexical scope)}をもいます。\n"
"これは、その変数にたいする参照は、そのバインディング構造内にテキスト的に配置されなければならないことを意味します。以下は例です"

#. type: iftex
#: variables.texi.orig:948
msgid "(see the next subsection, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、次のサブセクションを参照してください):"

#. type: ifnottex
#: variables.texi.orig:951
msgid "(@pxref{Using Lexical Binding}, for how to actually enable lexical binding):"
msgstr "(実際にレキシカルバインディングを有功にする方法は、@ref{Using Lexical Binding}を参照してください):"

#. type: group
#: variables.texi.orig:958
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる。}\n"
"  (+ x 3))\n"
"     @result{} 4\n"
"\n"

#. type: group
#: variables.texi.orig:965
#, no-wrap
msgid ""
"(let ((x 1))    ; @r{@code{x} is lexically bound.}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"(let ((x 1))    ; @r{@code{x}はレキシカルにバインドされる。}\n"
"  (getx))\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: variables.texi.orig:975
msgid ""
"Here, the variable @code{x} has no global value.  When it is lexically bound "
"within a @code{let} form, it can be used in the textual confines of that "
"@code{let} form.  But it can @emph{not} be used from within a @code{getx} "
"function called from the @code{let} form, since the function definition of "
"@code{getx} occurs outside the @code{let} form itself."
msgstr "ここでは、@code{x}はグローバル値をもちません。@code{let}フォーム内でレキシカルにバインドされたとき、この変数は@code{let}のテキスト境界内で使用できます。しかし、この@code{let}内から呼び出される@code{getx}関数からは、@code{getx}の関数定義が@code{let}フォームの外側にあるので、使用することが@emph{できません}。"

#. type: cindex
#: variables.texi.orig:976
#, no-wrap
msgid "lexical environment"
msgstr "lexical environment"

#. type: Plain text
#: variables.texi.orig:983
msgid ""
"Here is how lexical binding works.  Each binding construct defines a "
"@dfn{lexical environment}, specifying the symbols that are bound within the "
"construct and their local values.  When the Lisp evaluator wants the current "
"value of a variable, it looks first in the lexical environment; if the "
"variable is not specified in there, it looks in the symbol's value cell, "
"where the dynamic value is stored."
msgstr "レキシカルバインディングが機能する方法を説明します。各バインディング構造は、その構造および構造のローカル値でバインドされるシンボルを指定することにより、@dfn{レキシカル環境(lexical environment)}を定義します。Lispの評価機能(Lisp evaluator)がある変数のカレント値を得たいときは、最初にレキシカル環境内を探します。そこで変数が指定されていなければ、ダイナミック値が格納されるシンボルの値セルを探します。"

#. type: Plain text
#: variables.texi.orig:991
msgid ""
"(Internally, the lexical environment is an alist of symbol-value pairs, with "
"the final element in the alist being the symbol @code{t} rather than a cons "
"cell.  Such an alist can be passed as the second argument to the @code{eval} "
"function, in order to specify a lexical environment in which to evaluate a "
"form.  @xref{Eval}.  Most Emacs Lisp programs, however, should not interact "
"directly with lexical environments in this way; only specialized programs "
"like debuggers.)"
msgstr "(内部的には、レキシカル環境はシンボルと値がペアになったalistで、alistの最後の要素はコンスセルではなく、シンボル@code{t}です。そのようなalistは、フォームを評価するためのレキシカル環境を指定するために、@code{eval}関数の2番目の引数として渡すことができます。@ref{Eval}を参照してください。しかし、ほとんどのEmacs Lispプログラムは、この方法で直接レキシカル環境を使用するべきではありません。デバッガーのような特化されたプログラムだけが使用すべきです。)"

#. type: cindex
#: variables.texi.orig:992
#, no-wrap
msgid "closures, example of using"
msgstr "closures, example of using"

#. type: Plain text
#: variables.texi.orig:998
msgid ""
"Lexical bindings have indefinite extent.  Even after a binding construct has "
"finished executing, its lexical environment can be ``kept around'' in Lisp "
"objects called @dfn{closures}.  A closure is created when you define a named "
"or anonymous function with lexical binding enabled.  @xref{Closures}, for "
"details."
msgstr "レキシカルバインディングは、不定エクステント(indefinite extent)をもちます。バインディング構造が終了した後でも、そのレキシカル環境は@dfn{クロージャー(closures)}と呼ばれるLispオブジェクト内に``保持''されます。クロージャーは、レキシカルバインディングが有効な、名前つきまたは無名(anonymous)の関数が作成されたときに作成されます。詳細は、@ref{Closures}を参照してください。"

#. type: Plain text
#: variables.texi.orig:1002
msgid ""
"When a closure is called as a function, any lexical variable references "
"within its definition use the retained lexical environment.  Here is an "
"example:"
msgstr "クロージャーが関数として呼び出されたとき、その関数の定義内のレキシカル変数にたいする任意の参照は、レキシカル環境を維持するために使用されます。以下は例です:"

#. type: example
#: variables.texi.orig:1006
#, no-wrap
msgid ""
"(defvar my-ticker nil)   ; @r{We will use this dynamically bound}\n"
"                         ; @r{variable to store a closure.}\n"
"\n"
msgstr ""
"(defvar my-ticker nil)   ; @r{クロージャーを格納するために}\n"
"                         ; @r{この変数を使用する。}\n"
"\n"

#. type: example
#: variables.texi.orig:1012
#, no-wrap
msgid ""
"(let ((x 0))             ; @r{@code{x} is lexically bound.}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"
msgstr ""
"(let ((x 0))             ; @r{@code{x}はレキシカルにバインドされる。}\n"
"  (setq my-ticker (lambda ()\n"
"                    (setq x (1+ x)))))\n"
"    @result{} (closure ((x . 0) t) ()\n"
"          (setq x (1+ x)))\n"
"\n"

#. type: example
#: variables.texi.orig:1015
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 1\n"
"\n"

#. type: example
#: variables.texi.orig:1018
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 2\n"
"\n"

#. type: example
#: variables.texi.orig:1021
#, no-wrap
msgid ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"
msgstr ""
"(funcall my-ticker)\n"
"    @result{} 3\n"
"\n"

#. type: example
#: variables.texi.orig:1024
#, no-wrap
msgid ""
"x                        ; @r{Note that @code{x} has no global value.}\n"
"@error{} Symbol's value as variable is void: x\n"
msgstr ""
"x                        ; @r{@code{x}はグローバル値をもたないことに注意。}\n"
"@error{} Symbol's value as variable is void: x\n"

#. type: Plain text
#: variables.texi.orig:1035
msgid ""
"The @code{let} binding defines a lexical environment in which the variable "
"@code{x} is locally bound to 0.  Within this binding construct, we define a "
"lambda expression which increments @code{x} by one and returns the "
"incremented value.  This lambda expression is automatically turned into a "
"closure, in which the lexical environment lives on even after the @code{let} "
"binding construct has exited.  Each time we evaluate the closure, it "
"increments @code{x}, using the binding of @code{x} in that lexical "
"environment."
msgstr "@code{let}バインディングは、内部に変数@code{x}をもつレキシカル環境を定義し、これは0にローカルにバインドされます。このバインディング構造内で、@code{x}を1層化し、増加された値をreturnするクロージャーを定義しています。このラムダ式は自動的にクロージャーになり、たとえ@code{let}構造を抜けた後でも、その内部ではレキシカル環境が存続します。クロージャーを評価するときは毎回、レキシカル環境内の@code{x}のバインディングが使用され、@code{x}が増加されます。"

#. type: Plain text
#: variables.texi.orig:1041
msgid ""
"Note that functions like @code{symbol-value}, @code{boundp}, and @code{set} "
"only retrieve or modify a variable's dynamic binding (i.e., the contents of "
"its symbol's value cell).  Also, the code in the body of a @code{defun} or "
"@code{defmacro} cannot refer to surrounding lexical variables."
msgstr "@code{symbol-value}、@code{boundp}、@code{set}のような関数は、変数のダイナミックバインディング(つまりそのシンボルの値セル)だけを取得(または変更)することに注意してください。@code{defun}(または@code{defmacro})のbody内のコードも、周囲のレキシカル変数は参照できません。"

#. type: Plain text
#: variables.texi.orig:1048
msgid ""
"When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding "
"is enabled if the buffer-local variable @code{lexical-binding} is "
"non-@code{nil}:"
msgstr "Emacs Lispファイルをロードしたり、Lispバッファーを評価するとき、バッファーローカルな変数@code{lexical-binding}が非@code{nil}の場合は、レキシカルバインディングが有効になります:"

#. type: defvar
#: variables.texi.orig:1049
#, no-wrap
msgid "lexical-binding"
msgstr "lexical-binding"

#. type: defvar
#: variables.texi.orig:1058
msgid ""
"If this buffer-local variable is non-@code{nil}, Emacs Lisp files and "
"buffers are evaluated using lexical binding instead of dynamic binding.  "
"(However, special variables are still dynamically bound; see below.)  If "
"@code{nil}, dynamic binding is used for all local variables.  This variable "
"is typically set for a whole Emacs Lisp file, as a file local variable "
"(@pxref{File Local Variables}).  Note that unlike other such variables, this "
"one must be set in the first line of a file."
msgstr "このバッファーローカルな変数が非@code{nil}の場合、Emacs Lispファイルおよびバッファーは、ダイナミックバインディングではなくレキシカルバインディングを使用して評価されます(しかし、特別な変数はダイナミックにバインドされたままです。以下を参照してください)。@code{nil}の場合、すべてのローカル変数にたいしてダイナミックバインディングが使用されます。この変数は通常、ファイルローカル変数として、Emacs Lispファイル全体にたいしてセットされます(@ref{File Local Variables}を参照してください)。他のファイルローカル変数などとは異なり、ファイルの最初の行でセットされなければならないことに注意してください。"

#. type: Plain text
#: variables.texi.orig:1064
msgid ""
"When evaluating Emacs Lisp code directly using an @code{eval} call, lexical "
"binding is enabled if the @var{lexical} argument to @code{eval} is "
"non-@code{nil}.  @xref{Eval}."
msgstr "@code{eval}呼び出しを使用して、Emacs Lispコードを直接評価するとき、@code{eval}の@var{lexical}引数が非@code{nil}の場合は、レキシカルバインディングが有効になります。@ref{Eval}を参照してください。"

#. type: cindex
#: variables.texi.orig:1065
#, no-wrap
msgid "special variables"
msgstr "special variables"

#. type: Plain text
#: variables.texi.orig:1072
msgid ""
"Even when lexical binding is enabled, certain variables will continue to be "
"dynamically bound.  These are called @dfn{special variables}.  Every "
"variable that has been defined with @code{defvar}, @code{defcustom} or "
"@code{defconst} is a special variable (@pxref{Defining Variables}).  All "
"other variables are subject to lexical binding."
msgstr "レキシカルバインディングが有効な場合でも、特定の変数はダイナミックにバインドされたままです。これらは@dfn{スペシャル変数(special variable)}と呼ばれます。@code{defvar}、@code{defcustom}、@code{defconst}で定義されたすべての変数は、スペシャル変数です(@ref{Defining Variables}を参照してください)。その他のすべての変数はレキシカルバインディングの対象になります。"

#. type: defun
#: variables.texi.orig:1073
#, no-wrap
msgid "special-variable-p symbol"
msgstr "special-variable-p symbol"

#. type: defun
#: variables.texi.orig:1078
msgid ""
"This function returns non-@code{nil} if @var{symbol} is a special variable "
"(i.e., it has a @code{defvar}, @code{defcustom}, or @code{defconst} variable "
"definition).  Otherwise, the return value is @code{nil}."
msgstr "この関数は、@var{symbol}がスペシャル変数(つまり変数が@code{defvar}、@code{defcustom}、@code{defconst}による定義をもつ)の場合は非@code{nil}をreturnします。それ以外では、return値は@code{nil}になります。"

#. type: Plain text
#: variables.texi.orig:1084
msgid ""
"The use of a special variable as a formal argument in a function is "
"discouraged.  Doing so gives rise to unspecified behavior when lexical "
"binding mode is enabled (it may use lexical binding sometimes, and dynamic "
"binding other times)."
msgstr "関数内での通常の引数としてスペシャル変数を使用することは、推奨されません。レキシカルバインディングモードが有効なときにこれを行うと、不定な動作が起こります(あるときはレキシカルバインディング、またあるときはダイナミックバインディングのように)。"

#. type: Plain text
#: variables.texi.orig:1091
msgid ""
"Converting an Emacs Lisp program to lexical binding is easy.  First, add a "
"file-local variable setting of @code{lexical-binding} to @code{t} in the "
"header line of the Emacs Lisp source file (@pxref{File Local Variables}).  "
"Second, check that every variable in the program which needs to be "
"dynamically bound has a variable definition, so that it is not inadvertently "
"bound lexically."
msgstr "Emacs Lispプログラムをレキシカルバインディングに変換するのは簡単です。最初にEmacs Lispソースファイルのヘッダー行で@code{lexical-binding}を@code{t}して、ファイルローカル変数を追加します(@ref{File Local Variables}を参照してください)。次に、意図せずレキシカルにバインドしてしまわないように、ダイナミックなバインドをもつ必要がある変数が変数定義をもつことを、各変数ごとにチェックします。"

#. type: cindex
#: variables.texi.orig:1092
#, no-wrap
msgid "free variable"
msgstr "free variable"

#. type: cindex
#: variables.texi.orig:1093
#, no-wrap
msgid "unused lexical variable"
msgstr "unused lexical variable"

#. type: Plain text
#: variables.texi.orig:1102
msgid ""
"A simple way to find out which variables need a variable definition is to "
"byte-compile the source file.  @xref{Byte Compilation}.  If a non-special "
"variable is used outside of a @code{let} form, the byte-compiler will warn "
"about reference or assignment to a ``free variable''.  If a non-special "
"variable is bound but not used within a @code{let} form, the byte-compiler "
"will warn about an ``unused lexical variable''.  The byte-compiler will also "
"issue a warning if you use a special variable as a function argument."
msgstr "どの変数が変数定義をもつ必要があるか見つけるシンプルな方法は、ソースファイルをバイトコンパイルすることです。@ref{Byte Compilation}を参照してください。@code{let}フォームの外で非スペシャル変数が使用されている場合、バイトコンパイラーは``free variable''にたいする参照または割り当てについて警告するでしょう。非スペシャル変数がバインドされているが、@code{let}フォーム内で使用されていない場合、バイトコンパイラーは``unused lexical variable''に関して警告するでしょう。バイトコンパイラーは、スペシャル変数を関数の引数として使用している場合も、問題を警告します。"

#. type: Plain text
#: variables.texi.orig:1107
msgid ""
"(To silence byte-compiler warnings about unused variables, just use a "
"variable name that start with an underscore.  The byte-compiler interprets "
"this as an indication that this is a variable known not to be used.)"
msgstr "(使用されていない変数についての警告を抑制するためには、単に変数名をアンダースコアーで開始します。そうすれば、バイトコンパイラーはこれを、変数が使用されないことを示すと解釈します。)"

#. type: cindex
#: variables.texi.orig:1110
#, no-wrap
msgid "variable, buffer-local"
msgstr "variable, buffer-local"

#. type: cindex
#: variables.texi.orig:1111
#, no-wrap
msgid "buffer-local variables"
msgstr "buffer-local variables"

#. type: Plain text
#: variables.texi.orig:1120
msgid ""
"Global and local variable bindings are found in most programming languages "
"in one form or another.  Emacs, however, also supports additional, unusual "
"kinds of variable binding, such as @dfn{buffer-local} bindings, which apply "
"only in one buffer.  Having different values for a variable in different "
"buffers is an important customization method.  (Variables can also have "
"bindings that are local to each terminal.  @xref{Multiple Terminals}.)"
msgstr "グローバルおよびボーカルな変数バインディングは、1つの形式、または別の形式で、ほとんどのプログラミング言語で見つけることができます。しかしEmacsは、1つのバッファーだけに適用される@dfn{バッファーローカル(buffer-local)}なバインディングの用に、普通にはない種類の変数バインディングもサポートします。ある変数にたいして異なるバッファーごとに別の亜Q体をもつのは、重要なカスタマイズ方法です(変数は端末ごとにローカルなバインディングをもつこともできます。@ref{Multiple Terminals}を参照してください)。"

#. type: node
#: variables.texi.orig:1126 variables.texi.orig:1128
#, no-wrap
msgid "Intro to Buffer-Local"
msgstr "Intro to Buffer-Local"

#. type: menuentry
#: variables.texi.orig:1126
msgid "Introduction and concepts."
msgstr "イントロダクションと概念。"

#. type: node
#: variables.texi.orig:1126 variables.texi.orig:1222
#, no-wrap
msgid "Creating Buffer-Local"
msgstr "Creating Buffer-Local"

#. type: menuentry
#: variables.texi.orig:1126
msgid "Creating and destroying buffer-local bindings."
msgstr "バッファーローカルなバインディングの作成と削除。"

#. type: node
#: variables.texi.orig:1126 variables.texi.orig:1451
#, no-wrap
msgid "Default Value"
msgstr "Default Value"

#. type: menuentry
#: variables.texi.orig:1126
msgid ""
"The default value is seen in buffers that don't have their own buffer-local "
"values."
msgstr "自身ではバッファーローカルな値をもたないバッファーで参照されるデフォルト値。"

#. type: subsection
#: variables.texi.orig:1129
#, no-wrap
msgid "Introduction to Buffer-Local Variables"
msgstr "Introduction to Buffer-Local Variables"

#. type: Plain text
#: variables.texi.orig:1137
msgid ""
"A buffer-local variable has a buffer-local binding associated with a "
"particular buffer.  The binding is in effect when that buffer is current; "
"otherwise, it is not in effect.  If you set the variable while a "
"buffer-local binding is in effect, the new value goes in that binding, so "
"its other bindings are unchanged.  This means that the change is visible "
"only in the buffer where you made it."
msgstr "バッファーローカル変数は、特定のバッファーに関連づけられた、バッファーローカルなバインディングをもちます。このバインディングは、そのバッファーがカレントのときに効果をもち、カレントでないときは効果がありません。バッファーローカルなバインディングが効力をもつときにその変数をセットした場合、そのバインディングは新しい値をもちますが、他のバインディングは変更されません。これは、バッファーローカルなバインディングを作成したバッファーだけで変更が見えることを意味します。"

#. type: Plain text
#: variables.texi.orig:1141
msgid ""
"The variable's ordinary binding, which is not associated with any specific "
"buffer, is called the @dfn{default binding}.  In most cases, this is the "
"global binding."
msgstr "その変数にたいする特定のバッファーに関連づけられていない通常のバインディングは、@dfn{デフォルトバインディング(default binding)}と呼ばれます。ほとんどの場合、これはグローバルバインディングです。"

#. type: Plain text
#: variables.texi.orig:1149
msgid ""
"A variable can have buffer-local bindings in some buffers but not in other "
"buffers.  The default binding is shared by all the buffers that don't have "
"their own bindings for the variable.  (This includes all newly-created "
"buffers.)  If you set the variable in a buffer that does not have a "
"buffer-local binding for it, this sets the default binding, so the new value "
"is visible in all the buffers that see the default binding."
msgstr "変数は、あるバッファーではバッファーローカルなバインディングをもつことができ、他のバッファーではもたないことができます。デフォルトバインディングは、その変数にたいして自身のバインディングをもたない、すべてのバッファーで共有されます(これには、新たに作成されたバッファーが含まれます)。ある変数にたいしてバッファーローカルなバインディングをもたないバッファーでその変数をセットすると、デフォルトバインディングがセットされるので、それはデフォルトバインディングを参照するすべてのバッファーで新しい値を見ることができます。"

#. type: Plain text
#: variables.texi.orig:1156
msgid ""
"The most common use of buffer-local bindings is for major modes to change "
"variables that control the behavior of commands.  For example, C mode and "
"Lisp mode both set the variable @code{paragraph-start} to specify that only "
"blank lines separate paragraphs.  They do this by making the variable "
"buffer-local in the buffer that is being put into C mode or Lisp mode, and "
"then setting it to the new value for that mode.  @xref{Major Modes}."
msgstr "バッファーローカルなバインディングのもっとも一般的な使用は、目はーモードがコマンドの動作を制御するために変数を変更する場合です。たとえばCモードやLispモードは、空行だけがパラグラフの区切りになるように、変数@code{paragraph-start}をセットします。これらのモードは、CモードやLispモードになるようなバッファー内でこの変数をバッファーローカルにすることによりこれを行い、その後そのモードにたいして新しい値をセットします。@ref{Major Modes}を参照してください。"

#. type: Plain text
#: variables.texi.orig:1162
msgid ""
"The usual way to make a buffer-local binding is with "
"@code{make-local-variable}, which is what major mode commands typically "
"use.  This affects just the current buffer; all other buffers (including "
"those yet to be created) will continue to share the default value unless "
"they are explicitly given their own buffer-local bindings."
msgstr "バッファーローカルなバインディングを作成する通常の方法は、@code{make-local-variable}による方法で、これは通常メジャーモードが使用します。これはカレントバッファーだけに効果があります。その他すべてのバッファー(まだ作成されていないバッファーを含む)は、それらのバッファー自身が明示的にバッファーローカルなバインディングを与えられるまで、デフォルト値の共有を続けます。"

#. type: cindex
#: variables.texi.orig:1163
#, no-wrap
msgid "automatically buffer-local"
msgstr "automatically buffer-local"

#. type: Plain text
#: variables.texi.orig:1176
msgid ""
"A more powerful operation is to mark the variable as @dfn{automatically "
"buffer-local} by calling @code{make-variable-buffer-local}.  You can think "
"of this as making the variable local in all buffers, even those yet to be "
"created.  More precisely, the effect is that setting the variable "
"automatically makes the variable local to the current buffer if it is not "
"already so.  All buffers start out by sharing the default value of the "
"variable as usual, but setting the variable creates a buffer-local binding "
"for the current buffer.  The new value is stored in the buffer-local "
"binding, leaving the default binding untouched.  This means that the default "
"value cannot be changed with @code{setq} in any buffer; the only way to "
"change it is with @code{setq-default}."
msgstr "変数を@dfn{自動的にバッファーローカルになる}ようにマークする、より強力な操作は、@code{make-variable-buffer-local}を呼び出すことにより行われます。これは、たとえその変数がまだ作成されていなくても、変数をすべてのバッファーにたいしてローカルにすると考えることができます。より正確には、変数を自動的にセットすることにより、その変数がカレントバッファーにたいしてローカルでなくても、変数をローカルにする効果があります。すべてのバッファーは最初は通常のようにデフォルト値を共有しますが、この変数をセットすることによりカレントバッファーにたいしてバッファーローカルなバインディングを作成します。新たな値はバッファーローカルなバインディングに格納され、デフォルトバインディングは変更されずに残ります。これは、任意のバッファーで@code{setq}によりデフォルト値を変更できないことを意味します。変更する唯一の方法は、@code{setq-default}だけです。"

#. type: Plain text
#: variables.texi.orig:1188
msgid ""
"@strong{Warning:} When a variable has buffer-local bindings in one or more "
"buffers, @code{let} rebinds the binding that's currently in effect.  For "
"instance, if the current buffer has a buffer-local value, @code{let} "
"temporarily rebinds that.  If no buffer-local bindings are in effect, "
"@code{let} rebinds the default value.  If inside the @code{let} you then "
"change to a different current buffer in which a different binding is in "
"effect, you won't see the @code{let} binding any more.  And if you exit the "
"@code{let} while still in the other buffer, you won't see the unbinding "
"occur (though it will occur properly).  Here is an example to illustrate:"
msgstr "@strong{警告:} ある変数が1つ以上のバッファーでバッファーローカルなバインディングをもつとき、@code{let}はそのとき効果をもつ変数のバインディングをリバインドします。たとえばq、カレントバッファーがバッファーローカルな値をもつ場合、@code{let}は一時的にそれをリバインドします。効果をもつバッファーローカルなバインディングが存在しない場合、@code{let}はデフォルト値をリバインドします。@code{let}の内部で、別のバインディングが効力をもつ別のバッファーをカレントバッファーにすると、それ以上@code{let}バインディングを参照できなくなります。他のバッファーにいる間に@code{let}を抜けると、(たとえそれが正しくても)バインディングの解消を見ることはできません。以下にこれを示します:"

#. type: group
#: variables.texi.orig:1194
#, no-wrap
msgid ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"
msgstr ""
"(setq foo 'g)\n"
"(set-buffer \"a\")\n"
"(make-local-variable 'foo)\n"

#. type: example
#: variables.texi.orig:1201
#, no-wrap
msgid ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{let binding in buffer @samp{a}}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{the global value since foo is not local in "
"@samp{b}}\n"
"  @var{body}@dots{})\n"
msgstr ""
"(setq foo 'a)\n"
"(let ((foo 'temp))\n"
"  ;; foo @result{} 'temp  ; @r{バッファー@samp{a}内でのletバインディング}\n"
"  (set-buffer \"b\")\n"
"  ;; foo @result{} 'g     ; @r{fooは@samp{b}にたいしてローカルではないためグローバル値}\n"
"  @var{body}@dots{})\n"

#. type: group
#: variables.texi.orig:1204
#, no-wrap
msgid ""
"foo @result{} 'g        ; @r{exiting restored the local value in buffer "
"@samp{a},}\n"
"                 ; @r{but we don't see that in buffer @samp{b}}\n"
msgstr ""
"foo @result{} 'g        ; @r{exitによりバッファー@samp{a}のローカル値が復元されるが、}\n"
"                 ; @r{バッファー@samp{b}では見ることができない}\n"

#. type: group
#: variables.texi.orig:1208
#, no-wrap
msgid ""
"(set-buffer \"a\") ; @r{verify the local value was restored}\n"
"foo @result{} 'a\n"
msgstr ""
"(set-buffer \"a\") ; @r{ローカル値が復元されたことを確認}\n"
"foo @result{} 'a\n"

#. type: Plain text
#: variables.texi.orig:1214
msgid ""
"Note that references to @code{foo} in @var{body} access the buffer-local "
"binding of buffer @samp{b}."
msgstr "@var{body}内の@code{foo}にたいする参照は、バッファー@samp{b}のバッファーローカルなバインディングにアクセスすることに注意してください。"

#. type: Plain text
#: variables.texi.orig:1218
msgid ""
"When a file specifies local variable values, these become buffer-local "
"values when you visit the file.  @xref{File Variables,,, emacs, The GNU "
"Emacs Manual}."
msgstr "あるファイルがローカル変数の値をセットする場合、これらの変数はファイルをvisitするときバッファーローカルな値になります。@ref{File Variables,,, emacs, The GNU Emacs Manual}を参照してください。"

#. type: Plain text
#: variables.texi.orig:1221
msgid ""
"A buffer-local variable cannot be made terminal-local (@pxref{Multiple "
"Terminals})."
msgstr "バッファーローカル変数を、端末ローカル(terminal-local)にすることはできません(@ref{Multiple Terminals}を参照してください)。"

#. type: subsection
#: variables.texi.orig:1223
#, no-wrap
msgid "Creating and Deleting Buffer-Local Bindings"
msgstr "Creating and Deleting Buffer-Local Bindings"

#. type: deffn
#: variables.texi.orig:1225
#, no-wrap
msgid "Command make-local-variable variable"
msgstr "Command make-local-variable variable"

#. type: deffn
#: variables.texi.orig:1229
msgid ""
"This function creates a buffer-local binding in the current buffer for "
"@var{variable} (a symbol).  Other buffers are not affected.  The value "
"returned is @var{variable}."
msgstr "この関数はカレントバッファー内で、@var{variable}(シンボル)にたいして、バッファーローカルなバインディングを作成します。他のバッファーは影響を受けません。returnされる値は、@var{variable}です。"

#. type: deffn
#: variables.texi.orig:1233
msgid ""
"The buffer-local value of @var{variable} starts out as the same value "
"@var{variable} previously had.  If @var{variable} was void, it remains void."
msgstr "@var{variable}のバッファーローカルな値は最初、以前に@var{variable}がもっていた値と同じ値をもちます。@var{variable}がvoidのときは、voidのままです。"

#. type: group
#: variables.texi.orig:1239
#, no-wrap
msgid ""
";; @r{In buffer @samp{b1}:}\n"
"(setq foo 5)                ; @r{Affects all buffers.}\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b1}で行う:}\n"
"(setq foo 5)                ; @r{すべてのバッファーに影響する。}\n"
"     @result{} 5\n"

#. type: group
#: variables.texi.orig:1243
#, no-wrap
msgid ""
"(make-local-variable 'foo)  ; @r{Now it is local in @samp{b1}.}\n"
"     @result{} foo\n"
msgstr ""
"(make-local-variable 'foo)  ; @r{@samp{b1}内でローカルになった。}\n"
"     @result{} foo\n"

#. type: group
#: variables.texi.orig:1247
#, no-wrap
msgid ""
"foo                         ; @r{That did not change}\n"
"     @result{} 5                   ;   @r{the value.}\n"
msgstr ""
"foo                         ; @r{値は変更されない。}\n"
"     @result{} 5\n"

#. type: group
#: variables.texi.orig:1251
#, no-wrap
msgid ""
"(setq foo 6)                ; @r{Change the value}\n"
"     @result{} 6                   ;   @r{in @samp{b1}.}\n"
msgstr ""
"(setq foo 6)                ; @r{@samp{b1}内で値を変更。}\n"
"     @result{} 6\n"

#. type: group
#: variables.texi.orig:1255
#, no-wrap
msgid ""
"foo\n"
"     @result{} 6\n"
msgstr ""
"foo\n"
"     @result{} 6\n"

#. type: group
#: variables.texi.orig:1262
#, no-wrap
msgid ""
";; @r{In buffer @samp{b2}, the value hasn't changed.}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"
msgstr ""
";; @r{バッファー@samp{b2}では、値は変更されていない。}\n"
"(with-current-buffer \"b2\"\n"
"  foo)\n"
"     @result{} 5\n"

#. type: deffn
#: variables.texi.orig:1270
msgid ""
"Making a variable buffer-local within a @code{let}-binding for that variable "
"does not work reliably, unless the buffer in which you do this is not "
"current either on entry to or exit from the @code{let}.  This is because "
"@code{let} does not distinguish between different kinds of bindings; it "
"knows only which variable the binding was made for."
msgstr "変数を@code{let}バインディングでバッファーローカルにしても、@code{let}への出入り時の両方で、これを行うバッファーがカレントでない場合は、信頼性がありません。これは@code{let}がバインディングの種類を区別しないからです。@code{let}はバインディングを作成される変数だけを知るからです。"

#. type: deffn
#: variables.texi.orig:1274
msgid ""
"If the variable is terminal-local (@pxref{Multiple Terminals}), this "
"function signals an error.  Such variables cannot have buffer-local bindings "
"as well."
msgstr "変数が端末ローカル(@ref{Multiple Terminals}を参照してください)の場合、この関数はエラーをシグナルします。そのような変数は、バッファーローカルなバインディングをもつことができません。"

#. type: deffn
#: variables.texi.orig:1279
msgid ""
"@strong{Warning:} do not use @code{make-local-variable} for a hook "
"variable.  The hook variables are automatically made buffer-local as needed "
"if you use the @var{local} argument to @code{add-hook} or "
"@code{remove-hook}."
msgstr "@strong{警告:} フック変数にたいして@code{make-local-variable}を使用しないでください。フック変数は、@code{add-hook}または@code{remove-hook}の@var{local}引数を使用した場合、必要に応じて自動的にバッファーローカルになります。"

#. type: defmac
#: variables.texi.orig:1281
#, no-wrap
msgid "setq-local variable value"
msgstr "setq-local variable value"

#. type: defmac
#: variables.texi.orig:1286
msgid ""
"This macro creates a buffer-local binding in the current buffer for "
"@var{variable}, and gives it the buffer-local value @var{value}.  It is "
"equivalent to calling @code{make-local-variable} followed by @code{setq}.  "
"@var{variable} should be an unquoted symbol."
msgstr "このマクロはカレントバッファー内で@var{variable}にたいしてバッファーローカルなバインディングを作成して、それにバッファーローカルな値@var{value}を与えます。このマクロは@code{make-local-variable}に続けて@code{setq}を呼び出すのと同じです。@var{variable}はクォートされていないシンボルです。"

#. type: deffn
#: variables.texi.orig:1288
#, no-wrap
msgid "Command make-variable-buffer-local variable"
msgstr "Command make-variable-buffer-local variable"

#. type: deffn
#: variables.texi.orig:1295
msgid ""
"This function marks @var{variable} (a symbol) automatically buffer-local, so "
"that any subsequent attempt to set it will make it local to the current "
"buffer at the time.  Unlike @code{make-local-variable}, with which it is "
"often confused, this cannot be undone, and affects the behavior of the "
"variable in all buffers."
msgstr "このコマンドは、@var{variable}(シンボル)が自動的にバッファーローカルになるようにマークするので、それ以降にその変数へのセットを試みると、その時点でカレントのバッファーにローカルになります。しばしば混乱を招く@code{make-local-variable}とは異なり、これが取り消されることはなく、すべてのバッファー内での変数の挙動に影響します。"

#. type: deffn
#: variables.texi.orig:1301
msgid ""
"A peculiar wrinkle of this feature is that binding the variable (with "
"@code{let} or other binding constructs) does not create a buffer-local "
"binding for it.  Only setting the variable (with @code{set} or @code{setq}), "
"while the variable does not have a @code{let}-style binding that was made in "
"the current buffer, does so."
msgstr "この機能に特有の欠点は、(@code{let}またはその他のバインディング構造による)変数のバインディングが、その変数にたいするバッファーローカルなバインディングを作成しないことです。(@code{set}または@code{setq}による)変数のセットだけは、その変数がカレントバッファーで作成された@code{let}スタイルのバインディングをもたないので、ローカルなバインディングを作成します。"

#. type: deffn
#: variables.texi.orig:1307
msgid ""
"If @var{variable} does not have a default value, then calling this command "
"will give it a default value of @code{nil}.  If @var{variable} already has a "
"default value, that value remains unchanged.  Subsequently calling "
"@code{makunbound} on @var{variable} will result in a void buffer-local value "
"and leave the default value unaffected."
msgstr "@var{variable}がデフォルト値をもたない場合、このコマンドの呼び出しは@code{nil}のデフォルト値を与えます。@var{variable}がすでにデフォルト値をもつ場合、その値は変更されずに残ります。それ以降に@var{variable}にたいして@code{makunbound}を呼び出すと、バッファーローカル値をvoidにして、デフォルト値は影響を受けずに残ります。"

#. type: deffn
#: variables.texi.orig:1309
msgid "The value returned is @var{variable}."
msgstr "return値は@var{variable}です。"

#. type: deffn
#: variables.texi.orig:1315
msgid ""
"@strong{Warning:} Don't assume that you should use "
"@code{make-variable-buffer-local} for user-option variables, simply because "
"users @emph{might} want to customize them differently in different buffers.  "
"Users can make any variable local, when they wish to.  It is better to leave "
"the choice to them."
msgstr "@strong{警告:} ユーザーオプション変数にたいしては、ユーザーは異なるバッファーにたいして異なるカスタマイズを望む@emph{かもしれない}ので、@code{make-variable-buffer-local}を使うべきだと決め込むべきではありません。ユーザーは、望むなら任意の変数をローカルにできます。それらの選択の余地を残すほうがよいでしょう。"

#. type: deffn
#: variables.texi.orig:1321
msgid ""
"The time to use @code{make-variable-buffer-local} is when it is crucial that "
"no two buffers ever share the same binding.  For example, when a variable is "
"used for internal purposes in a Lisp program which depends on having "
"separate values in separate buffers, then using "
"@code{make-variable-buffer-local} can be the best solution."
msgstr "@code{make-variable-buffer-local}を使用すべきときは、複数のバッファーが同じバインディングを共有しないことが自明な場合です。たとえば、バッファーごとに個別な値をもつことに依存するLispプログラム内の内部プロセスにたいして変数が使用されるときは、@code{make-variable-buffer-local}の使用が最善の解決策になるかもしれません。"

#. type: defmac
#: variables.texi.orig:1323
#, no-wrap
msgid "defvar-local variable value &optional docstring"
msgstr "defvar-local variable value &optional docstring"

#. type: defmac
#: variables.texi.orig:1329
msgid ""
"This macro defines @var{variable} as a variable with initial value "
"@var{value} and @var{docstring}, and marks it as automatically "
"buffer-local.  It is equivalent to calling @code{defvar} followed by "
"@code{make-variable-buffer-local}.  @var{variable} should be an unquoted "
"symbol."
msgstr "このマクロは@var{variable}を、初期値@var{value}および@var{docstring}の変数として定義して、それを自動的にバッファーローカルとマークします。これは@code{defvar}の後につづけて@code{make-variable-buffer-local}を呼び出すのと同じです。@var{variable}はクォートされていないシンボルです。"

#. type: defun
#: variables.texi.orig:1331
#, no-wrap
msgid "local-variable-p variable &optional buffer"
msgstr "local-variable-p variable &optional buffer"

#. type: defun
#: variables.texi.orig:1335
msgid ""
"This returns @code{t} if @var{variable} is buffer-local in buffer "
"@var{buffer} (which defaults to the current buffer); otherwise, @code{nil}."
msgstr "これは@var{variable}がバッファー@var{buffer}(デフォルトはカレントバッファー)内でバッファーローカルのときは@code{t}、それ以外は@code{nil}をreturnします。"

#. type: defun
#: variables.texi.orig:1337
#, no-wrap
msgid "local-variable-if-set-p variable &optional buffer"
msgstr "local-variable-if-set-p variable &optional buffer"

#. type: defun
#: variables.texi.orig:1342
msgid ""
"This returns @code{t} if @var{variable} either has a buffer-local value in "
"buffer @var{buffer}, or is automatically buffer-local.  Otherwise, it "
"returns @code{nil}.  If omitted or @code{nil}, @var{buffer} defaults to the "
"current buffer."
msgstr "これは@var{variable}がバッファー@var{buffer}内でバッファーローカル値をもつか、自動的にバッファーローカルになる場合は、@code{t}をreturnします。それ以外は@code{nil}をreturnします。@var{buffer}が省略または@code{nil}の場合のデフォルトは、カレントバッファーです。"

#. type: defun
#: variables.texi.orig:1344
#, no-wrap
msgid "buffer-local-value variable buffer"
msgstr "buffer-local-value variable buffer"

#. type: defun
#: variables.texi.orig:1349
msgid ""
"This function returns the buffer-local binding of @var{variable} (a symbol) "
"in buffer @var{buffer}.  If @var{variable} does not have a buffer-local "
"binding in buffer @var{buffer}, it returns the default value (@pxref{Default "
"Value}) of @var{variable} instead."
msgstr "この関数は、バッファー@var{buffer}内の、@var{variable}(シンボル)のバッファーローカルなバインディングをreturnします。@var{variable}がバッファー@var{buffer}内でバッファーローカルなバインディングをもたない場合は、かわりに@var{variable}のデフォルト値(@ref{Default Value})をreturnします。"

#. type: defun
#: variables.texi.orig:1351
#, no-wrap
msgid "buffer-local-variables &optional buffer"
msgstr "buffer-local-variables &optional buffer"

#. type: defun
#: variables.texi.orig:1359
msgid ""
"This function returns a list describing the buffer-local variables in buffer "
"@var{buffer}.  (If @var{buffer} is omitted, the current buffer is used.)  "
"Normally, each list element has the form @w{@code{(@var{sym} . @var{val})}}, "
"where @var{sym} is a buffer-local variable (a symbol) and @var{val} is its "
"buffer-local value.  But when a variable's buffer-local binding in "
"@var{buffer} is void, its list element is just @var{sym}."
msgstr "この関数はバッファー@var{buffer}内のバッファーローカル変数を表すリストをreturnします(@var{buffer}が省略された場合はカレントバッファーが使用されます)。リストの各要素は通常、@w{@code{(@var{sym} . @var{val})}}という形式をもちます。ここで@var{sym}はバッファーローカル変数(シンボル)、@var{val}はバッファーローカル値です。しかし@var{buffer}内の、ある変数のバッファーローカルなバインディングがvoidのtきは、その変数に対応するリスト要素は単に@var{sym}になります。"

#. type: group
#: variables.texi.orig:1366
#, no-wrap
msgid ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"
msgstr ""
"(make-local-variable 'foobar)\n"
"(makunbound 'foobar)\n"
"(make-local-variable 'bind-me)\n"
"(setq bind-me 69)\n"

#. type: example
#: variables.texi.orig:1373
#, no-wrap
msgid ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{First, built-in variables local in all buffers:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"
msgstr ""
"(setq lcl (buffer-local-variables))\n"
"    ;; @r{最初はすべてのバッファー内でローカルなビルトイン変数:}\n"
"@result{} ((mark-active . nil)\n"
"    (buffer-undo-list . nil)\n"
"    (mode-name . \"Fundamental\")\n"
"    @dots{}\n"

#. type: group
#: variables.texi.orig:1379
#, no-wrap
msgid ""
"    ;; @r{Next, non-built-in buffer-local variables.}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{This one is buffer-local and nonvoid:}\n"
"    (bind-me . 69))\n"
msgstr ""
"    ;; @r{次にビルトインでないバッファーローカル変数。}\n"
"    ;; @r{This one is buffer-local and void:}\n"
"    foobar\n"
"    ;; @r{これはバッファーローカルでvoidではない:}\n"
"    (bind-me . 69))\n"

#. type: defun
#: variables.texi.orig:1384
msgid ""
"Note that storing new values into the @sc{cdr}s of cons cells in this list "
"does @emph{not} change the buffer-local values of the variables."
msgstr "このリスト内のコンスセルの@sc{cdr}に新たな値を格納しても、その変数のバッファーローカル値は変化@emph{しない}ことに注意してください。"

#. type: deffn
#: variables.texi.orig:1386
#, no-wrap
msgid "Command kill-local-variable variable"
msgstr "Command kill-local-variable variable"

#. type: deffn
#: variables.texi.orig:1393
msgid ""
"This function deletes the buffer-local binding (if any) for @var{variable} "
"(a symbol) in the current buffer.  As a result, the default binding of "
"@var{variable} becomes visible in this buffer.  This typically results in a "
"change in the value of @var{variable}, since the default value is usually "
"different from the buffer-local value just eliminated."
msgstr "この関数はカレントバッファー内の@var{variable}(シンボル)にたいするバッファーローカルなバインディング(もしあれば)を削除します。その結果として、このバッファー内で@var{variable}のデフォルトバインディングが可視になります。これは通常、@var{variable}の値を変更します。デフォルト値は削除されたバッファーローカル値とは異なるのが普通だからです。"

#. type: deffn
#: variables.texi.orig:1398
msgid ""
"If you kill the buffer-local binding of a variable that automatically "
"becomes buffer-local when set, this makes the default value visible in the "
"current buffer.  However, if you set the variable again, that will once "
"again create a buffer-local binding for it."
msgstr "セットしたとき自動的にバッファーローカルになる変数のバッファーローカルなバインディングをkillした場合は、これによりカレントバッファーな意でデフォルト値が可視になります。しかし、変数を再度セットすると、その変数にたいするバッファーローカルなバインディングが再作成されます。"

#. type: deffn
#: variables.texi.orig:1400
msgid "@code{kill-local-variable} returns @var{variable}."
msgstr "@code{kill-local-variable}は@var{variable}をreturnします。"

#. type: deffn
#: variables.texi.orig:1404
msgid ""
"This function is a command because it is sometimes useful to kill one "
"buffer-local variable interactively, just as it is useful to create "
"buffer-local variables interactively."
msgstr "この関数はコマンドです。なぜなら、バッファーローカル変数のインタラクティブな作成が有用な場合があるように、あるバッファーローカル変数のインタラクティブなkillが有用な場合があるからです。"

#. type: cindex
#: variables.texi.orig:1406
#, no-wrap
msgid "local variables, killed by major mode"
msgstr "local variables, killed by major mode"

#. type: defun
#: variables.texi.orig:1407
#, no-wrap
msgid "kill-all-local-variables"
msgstr "kill-all-local-variables"

#. type: defun
#: variables.texi.orig:1413
msgid ""
"This function eliminates all the buffer-local variable bindings of the "
"current buffer except for variables marked as ``permanent'' and local hook "
"functions that have a non-@code{nil} @code{permanent-local-hook} property "
"(@pxref{Setting Hooks}).  As a result, the buffer will see the default "
"values of most variables."
msgstr "この関数は、``permanent(永続的)''とマークされた変数、および@code{permanent-local-hook}プロパティーに非@code{nil}をもつローカルフック関数(@ref{Setting Hooks})を除き、カレントバッファーのすべてのバッファーローカルなバインディングを解消します。結果として、そのバッファーはほとんどの変数のデフォルト値を参照するようになります。"

#. type: defun
#: variables.texi.orig:1419
msgid ""
"This function also resets certain other information pertaining to the "
"buffer: it sets the local keymap to @code{nil}, the syntax table to the "
"value of @code{(standard-syntax-table)}, the case table to "
"@code{(standard-case-table)}, and the abbrev table to the value of "
"@code{fundamental-mode-abbrev-table}."
msgstr "この関数は、そのバッファーに関係のあるその他の特定の情報もリセットします。これはローカルキーマップ(local keymap)を@code{nil}、構文テーブル(syntax table)を@code{(standard-syntax-table)}の値、大文字小文字テーブル(case table)を@code{(standard-case-table)}、abbrevテーブル(abbrev table)を@code{fundamental-mode-abbrev-table}の値にセットします。"

#. type: defun
#: variables.texi.orig:1422
msgid ""
"The very first thing this function does is run the normal hook "
"@code{change-major-mode-hook} (see below)."
msgstr "この関数が1番最初に行うのは、ノーマルフック@code{change-major-mode-hook}(以下参照)の実行です。"

#. type: defun
#: variables.texi.orig:1427
msgid ""
"Every major mode command begins by calling this function, which has the "
"effect of switching to Fundamental mode and erasing most of the effects of "
"the previous major mode.  To ensure that this does its job, the variables "
"that major modes set should not be marked permanent."
msgstr "各メジャーモードコマンドは、Fundamentalモードにスイッチする効果をもち、以前のメジャーモードのほとんどの効果を消去する、この関数を呼び出すことにより開始されます。この関数が処理を行うのを確実にするために、メジャーモードがセットする変数はpermanentとマークすべきではありません。"

#. type: defun
#: variables.texi.orig:1429
msgid "@code{kill-all-local-variables} returns @code{nil}."
msgstr "@code{kill-all-local-variables} returns @code{nil}."

#. type: defvar
#: variables.texi.orig:1431
#, no-wrap
msgid "change-major-mode-hook"
msgstr "change-major-mode-hook"

#. type: defvar
#: variables.texi.orig:1437
msgid ""
"The function @code{kill-all-local-variables} runs this normal hook before it "
"does anything else.  This gives major modes a way to arrange for something "
"special to be done if the user switches to a different major mode.  It is "
"also useful for buffer-specific minor modes that should be forgotten if the "
"user changes the major mode."
msgstr "関数@code{kill-all-local-variables}は、何か他のことを行う前に、まずこのノーマルフックを実行します。この関数はメジャーモードにたいして、ユーザーが他のメジャーモードにスイッチした場合に行われる、何か特別なことを準備する方法を与えます。この関数は、ユーザーがメジャーモードを変更した場合に忘れられるべき、バッファー固有のマイナーモードにたいしても有用です。"

#. type: defvar
#: variables.texi.orig:1441
msgid ""
"For best results, make this variable buffer-local, so that it will disappear "
"after doing its job and will not interfere with the subsequent major mode.  "
"@xref{Hooks}."
msgstr "最善の結果を得るために、この変数をバッファーローカルにすれば、処理が終了したときに消えるので、以降のメジャーモードに干渉しなくなります。@ref{Hooks}を参照してください。"

#. type: cindex
#: variables.texi.orig:1443
#, no-wrap
msgid "permanent local variable"
msgstr "permanent local variable"

#. type: Plain text
#: variables.texi.orig:1450
msgid ""
"A buffer-local variable is @dfn{permanent} if the variable name (a symbol) "
"has a @code{permanent-local} property that is non-@code{nil}.  Such "
"variables are unaffected by @code{kill-all-local-variables}, and their local "
"bindings are therefore not cleared by changing major modes.  Permanent "
"locals are appropriate for data pertaining to where the file came from or "
"how to save it, rather than with how to edit the contents."
msgstr "変数名(シンボル)が非@code{nil}の@code{permanent-local}プロパティーをもつ場合、バッファーローカル変数は@dfn{permanent(永続的)}です。そのような変数は@code{kill-all-local-variables}の影響を受けず、したがってメジャーモードの変更によりそれらのローカルバインディングは作成されません。permanentなローカル変数は、ファイルの内容を編集する方法などより、どこから読み込んだファイルか、あるいはどのように保存するかといったことに関連するデータに適しています。"

#. type: subsection
#: variables.texi.orig:1452
#, no-wrap
msgid "The Default Value of a Buffer-Local Variable"
msgstr "The Default Value of a Buffer-Local Variable"

#. type: cindex
#: variables.texi.orig:1453
#, no-wrap
msgid "default value"
msgstr "default value"

#. type: Plain text
#: variables.texi.orig:1459
msgid ""
"The global value of a variable with buffer-local bindings is also called the "
"@dfn{default} value, because it is the value that is in effect whenever "
"neither the current buffer nor the selected frame has its own binding for "
"the variable."
msgstr "バッファーローカルなバインディングをもつ変数のグローバル値も、@dfn{デフォルト値(default)}値と呼ばれます。なぜなら、その変数にたいしてカレントバッファーも選択されたフレームもバインディングをもたない場合には、その値が常に効果をもつからです。"

#. type: Plain text
#: variables.texi.orig:1467
msgid ""
"The functions @code{default-value} and @code{setq-default} access and change "
"a variable's default value regardless of whether the current buffer has a "
"buffer-local binding.  For example, you could use @code{setq-default} to "
"change the default setting of @code{paragraph-start} for most buffers; and "
"this would work even when you are in a C or Lisp mode buffer that has a "
"buffer-local value for this variable."
msgstr "関数@code{default-value}および@code{setq-default}は、カレントバッファーがバッファーローカルなバインディングをもつかどうかに関わらず、その変数のデフォルト値にアクセスまたは変更します。たとえば、ほとんどのバッファーにたいして、@code{paragraph-start}のデフォルトのセッティングを変更するために、@code{setq-default}を使用できます。そして、この変数にたいするバッファーローカルな値をもつCモードやLispモードにいるときでさえ、これは機能します。"

#. type: Plain text
#: variables.texi.orig:1472
msgid ""
"The special forms @code{defvar} and @code{defconst} also set the default "
"value (if they set the variable at all), rather than any buffer-local value."
msgstr "スペシャルフォーム@code{defvar}および@code{defconst}も、バッファーローカルな値ではなく、(もし変数にセットする場合は)デフォルト値をセットします。"

#. type: defun
#: variables.texi.orig:1473
#, no-wrap
msgid "default-value symbol"
msgstr "default-value symbol"

#. type: defun
#: variables.texi.orig:1478
msgid ""
"This function returns @var{symbol}'s default value.  This is the value that "
"is seen in buffers and frames that do not have their own values for this "
"variable.  If @var{symbol} is not buffer-local, this is equivalent to "
"@code{symbol-value} (@pxref{Accessing Variables})."
msgstr "この関数は、@var{symbol}のデフォルト値をreturnします。これは、この変数にたいして独自の値をもたないバッファーやフレームから参照される値です。@var{symbol}がバッファーローカルでない場合、これは@code{symbol-value}(@ref{Accessing Variables}を参照してください)と同じです。"

#. type: defun
#: variables.texi.orig:1481
#, no-wrap
msgid "default-boundp symbol"
msgstr "default-boundp symbol"

#. type: defun
#: variables.texi.orig:1485
msgid ""
"The function @code{default-boundp} tells you whether @var{symbol}'s default "
"value is nonvoid.  If @code{(default-boundp 'foo)} returns @code{nil}, then "
"@code{(default-value 'foo)} would get an error."
msgstr "関数@code{default-boundp}は、@var{symbol}のデフォルト値がvoidでないか報告します。@code{(default-boundp 'foo)}が@code{nil}をreturnした場合、@code{(default-value 'foo)}はエラーになります。"

#. type: defun
#: variables.texi.orig:1488
msgid ""
"@code{default-boundp} is to @code{default-value} as @code{boundp} is to "
"@code{symbol-value}."
msgstr "@code{default-boundp}は@code{default-value}んびたいして、@code{boundp}は@code{symbol-value}にたいする述語です。"

#. type: defspec
#: variables.texi.orig:1490
#, no-wrap
msgid "setq-default [symbol form]@dots{}"
msgstr "setq-default [symbol form]@dots{}"

#. type: defspec
#: variables.texi.orig:1495
msgid ""
"This special form gives each @var{symbol} a new default value, which is the "
"result of evaluating the corresponding @var{form}.  It does not evaluate "
"@var{symbol}, but does evaluate @var{form}.  The value of the "
"@code{setq-default} form is the value of the last @var{form}."
msgstr "このスペシャルフォームは、各@var{symbol}に、対応する@var{form}を評価した結果を新たなデフォルト値として与えます。これは@var{symbol}を評価しませんが、@var{form}は評価します。@code{setq-default}フォームの値は、最後の@var{form}の値です。"

#. type: defspec
#: variables.texi.orig:1502
msgid ""
"If a @var{symbol} is not buffer-local for the current buffer, and is not "
"marked automatically buffer-local, @code{setq-default} has the same effect "
"as @code{setq}.  If @var{symbol} is buffer-local for the current buffer, "
"then this changes the value that other buffers will see (as long as they "
"don't have a buffer-local value), but not the value that the current buffer "
"sees."
msgstr "カレントバッファーにたいして@var{symbol}がバッファーローカルでなく、自動的にバッファーローカルにマークされない場合、@code{setq-default}は@code{setq}と同じ効果をもちます。カレントバッファーにたいして@var{symbol}がバッファーローカルな場合、これは他のバッファーから参照できる値を変更します(それらのバッファーがバッファーローカルな値をもたない限り)が、それはカレントバッファーから参照される値ではありません。"

#. type: group
#: variables.texi.orig:1508
#, no-wrap
msgid ""
";; @r{In buffer @samp{foo}:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"
msgstr ""
";; @r{バッファー@samp{foo}で行う:}\n"
"(make-local-variable 'buffer-local)\n"
"     @result{} buffer-local\n"

#. type: group
#: variables.texi.orig:1512
#, no-wrap
msgid ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"
msgstr ""
"(setq buffer-local 'value-in-foo)\n"
"     @result{} value-in-foo\n"

#. type: group
#: variables.texi.orig:1516
#, no-wrap
msgid ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"
msgstr ""
"(setq-default buffer-local 'new-default)\n"
"     @result{} new-default\n"

#. type: group
#: variables.texi.orig:1520
#, no-wrap
msgid ""
"buffer-local\n"
"     @result{} value-in-foo\n"
msgstr ""
"buffer-local\n"
"     @result{} value-in-foo\n"

#. type: group
#: variables.texi.orig:1524 variables.texi.orig:1534
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} new-default\n"

#. type: group
#: variables.texi.orig:1530
#, no-wrap
msgid ""
";; @r{In (the new) buffer @samp{bar}:}\n"
"buffer-local\n"
"     @result{} new-default\n"
msgstr ""
";; @r{(新しい)バッファー@samp{bar}で行う:}\n"
"buffer-local\n"
"     @result{} new-default\n"

#. type: group
#: variables.texi.orig:1538
#, no-wrap
msgid ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"
msgstr ""
"(setq buffer-local 'another-default)\n"
"     @result{} another-default\n"

#. type: group
#: variables.texi.orig:1542
#, no-wrap
msgid ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: group
#: variables.texi.orig:1550
#, no-wrap
msgid ""
";; @r{Back in buffer @samp{foo}:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"
msgstr ""
";; @r{バッファー@samp{foo}に戻って行う:}\n"
"buffer-local\n"
"     @result{} value-in-foo\n"
"(default-value 'buffer-local)\n"
"     @result{} another-default\n"

#. type: defun
#: variables.texi.orig:1554
#, no-wrap
msgid "set-default symbol value"
msgstr "set-default symbol value"

#. type: defun
#: variables.texi.orig:1557
msgid ""
"This function is like @code{setq-default}, except that @var{symbol} is an "
"ordinary evaluated argument."
msgstr "この関数は@code{setq-default}と似ていますが、@var{symbol}は通常の引数として評価されます。"

#. type: group
#: variables.texi.orig:1562
#, no-wrap
msgid ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"
msgstr ""
"(set-default (car '(a b c)) 23)\n"
"     @result{} 23\n"

#. type: group
#: variables.texi.orig:1566
#, no-wrap
msgid ""
"(default-value 'a)\n"
"     @result{} 23\n"
msgstr ""
"(default-value 'a)\n"
"     @result{} 23\n"

#. type: cindex
#: variables.texi.orig:1572
#, no-wrap
msgid "file local variables"
msgstr "file local variables"

#. type: Plain text
#: variables.texi.orig:1580
msgid ""
"A file can specify local variable values; Emacs uses these to create "
"buffer-local bindings for those variables in the buffer visiting that file.  "
"@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs "
"Manual}, for basic information about file-local variables.  This section "
"describes the functions and variables that affect how file-local variables "
"are processed."
msgstr "ファイルにローカル変数の値を指定できます。そのファイルをvisitしているバッファー内で、これらの変数にたいしてバッファーローカルなバインディングを作成するために、Emacsはこれらを使用します。ファイルローカル変数の基本的な情報については、@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}を参照してください。このセクションはファイルローカル変数が処理される方法に影響する関数と変数を説明します。"

#. type: Plain text
#: variables.texi.orig:1586
msgid ""
"If a file-local variable could specify an arbitrary function or Lisp "
"expression that would be called later, visiting a file could take over your "
"Emacs.  Emacs protects against this by automatically setting only those "
"file-local variables whose specified values are known to be safe.  Other "
"file-local variables are set only if the user agrees."
msgstr "ファイルローカル変数が勝手に関数や、後で呼び出されるLisp式を指定できる場合、ファイルのvisitによりEmacsが乗っ取られてしまうかもしれません。Emacsは、指定された値が安全だと既知のファイルローカル変数だけを自動的にセットすることにより、この危険から保護します。これ以外のファイルローカル変数は、ユーザーが同意した場合のみセットされます。"

#. type: Plain text
#: variables.texi.orig:1591
msgid ""
"For additional safety, @code{read-circle} is temporarily bound to @code{nil} "
"when Emacs reads file-local variables (@pxref{Input Functions}).  This "
"prevents the Lisp reader from recognizing circular and shared Lisp "
"structures (@pxref{Circular Objects})."
msgstr "追加の安全策として、Emacsがファイルローカル変数を読み込むとき、一時的に@code{read-circle}が@code{nil}にバインドされます(@ref{Input Functions}を参照してください)。これはLispリーダー循環および共有されたLisp構造(@ref{Circular Objects}を参照してください)を認識することを防ぎます。"

#. type: defopt
#: variables.texi.orig:1592
#, no-wrap
msgid "enable-local-variables"
msgstr "enable-local-variables"

#. type: defopt
#: variables.texi.orig:1595
msgid ""
"This variable controls whether to process file-local variables.  The "
"possible values are:"
msgstr "この変数はファイルローカル変数を処理するかどうかを制御します。以下の値が利用できます:"

#. type: item
#: variables.texi.orig:1597
#, no-wrap
msgid "@code{t} (the default)"
msgstr "@code{t}(デフォルト)"

#. type: table
#: variables.texi.orig:1599
msgid "Set the safe variables, and query (once) about any unsafe variables."
msgstr "安全な変数をセットして、安全でない変数については問い合わせます(1回)。"

#. type: code{#1}
#: variables.texi.orig:1599
#, no-wrap
msgid ":safe"
msgstr ":safe"

#. type: table
#: variables.texi.orig:1601
msgid "Set only the safe variables and do not query."
msgstr "安全な変数だけをセットして、問い合わせはしません。"

#. type: code{#1}
#: variables.texi.orig:1601
#, no-wrap
msgid ":all"
msgstr ":all"

#. type: table
#: variables.texi.orig:1603
msgid "Set all the variables and do not query."
msgstr "問い合わせをせずに、すべての変数をセットします。"

#. type: code{#1}
#: variables.texi.orig:1603
#, no-wrap
msgid "nil"
msgstr "nil"

#. type: table
#: variables.texi.orig:1605
msgid "Don't set any variables."
msgstr "変数をセットしません。"

#. type: item
#: variables.texi.orig:1605
#, no-wrap
msgid "anything else"
msgstr "その他"

#. type: table
#: variables.texi.orig:1607
msgid "Query (once) about all the variables."
msgstr "すべての変数にたいして問い合わせます(1回)。"

#. type: defvar
#: variables.texi.orig:1610
#, no-wrap
msgid "inhibit-local-variables-regexps"
msgstr "inhibit-local-variables-regexps"

#. type: defvar
#: variables.texi.orig:1615
msgid ""
"This is a list of regular expressions.  If a file has a name matching an "
"element of this list, then it is not scanned for any form of file-local "
"variable.  For examples of why you might want to use this, @pxref{Auto Major "
"Mode}."
msgstr "これは正規表現のリストです。ファイルがこのリストの要素にマッチする名前をもつ場合、任意のファイルローカル変数のフォームはスキャンされません。どんなときにこれを使いたいかの例は、@xref{Auto Major Mode}を参照してください。"

#. type: defun
#: variables.texi.orig:1617
#, no-wrap
msgid "hack-local-variables &optional mode-only"
msgstr "hack-local-variables &optional mode-only"

#. type: defun
#: variables.texi.orig:1624
msgid ""
"This function parses, and binds or evaluates as appropriate, any local "
"variables specified by the contents of the current buffer.  The variable "
"@code{enable-local-variables} has its effect here.  However, this function "
"does not look for the @samp{mode:} local variable in the @w{@samp{-*-}} "
"line.  @code{set-auto-mode} does that, also taking "
"@code{enable-local-variables} into account (@pxref{Auto Major Mode})."
msgstr "この関数は、カレントバッファーの内容により指定された任意のローカル変数として、必要に応じてバインドと評価を行います。変数@code{enable-local-variables}は、ここでも効果をもちます。しかし、この関数は@w{@samp{-*-}}行の、@samp{mode:}ローカル変数を探しません。@code{set-auto-mode}はこれを行い、@code{enable-local-variables}も考慮されます(@ref{Auto Major Mode}を参照してください)。"

#. type: defun
#: variables.texi.orig:1633
msgid ""
"This function works by walking the alist stored in "
"@code{file-local-variables-alist} and applying each local variable in turn.  "
"It calls @code{before-hack-local-variables-hook} and "
"@code{hack-local-variables-hook} before and after applying the variables, "
"respectively.  It only calls the before-hook if the alist is non-@code{nil}; "
"it always calls the other hook.  This function ignores a @samp{mode} element "
"if it specifies the same major mode as the buffer already has."
msgstr "この関数は、@code{file-local-variables-alist}内に格納されたalistを調べて、各ローカル変数を順に適用することにより機能します。この関数は、変数に適用する前(または後)に、@code{before-hack-local-variables-hook}(または@code{hack-local-variables-hook})を呼び出します。alistが非@code{nil}の場合のみ、事前のフック(before-hook)を呼び出し、その他のフックは常に呼び出します。この関数は、そのバッファーがすでにもつメジャーモードと同じメジャーモードが指定された場合には、@samp{mode}要素を無視します。"

#. type: defun
#: variables.texi.orig:1639
msgid ""
"If the optional argument @var{mode-only} is non-@code{nil}, then all this "
"function does is return a symbol specifying the major mode, if the "
"@w{@samp{-*-}} line or the local variables list specifies one, and "
"@code{nil} otherwise.  It does not set the mode nor any other file-local "
"variable."
msgstr "オプションの引数@var{mode-only}が非@code{nil}の場合、この関数が行うのはメジャーモードを指定するシンボルをreturnするのがすべてで、@w{@samp{-*-}}行またはローカル変数リストがメジャーモードを指定していればそのモード、それ以外は@code{nil}をreturnします。この関数はモードや他のファイルローカル変数をセットしません。"

#. type: defvar
#: variables.texi.orig:1641
#, no-wrap
msgid "file-local-variables-alist"
msgstr "file-local-variables-alist"

#. type: defvar
#: variables.texi.orig:1649
msgid ""
"This buffer-local variable holds the alist of file-local variable settings.  "
"Each element of the alist is of the form @w{@code{(@var{var} "
". @var{value})}}, where @var{var} is a symbol of the local variable and "
"@var{value} is its value.  When Emacs visits a file, it first collects all "
"the file-local variables into this alist, and then the "
"@code{hack-local-variables} function applies them one by one."
msgstr "このバッファーローカルな変数は、ファイルローカル変数のセッティングのalistを保持します。alistの各要素は@w{@code{(@var{var} . @var{value})}}という形式で、@var{var}はローカル変数のシンボル、@var{value}はその値です。Emacsがファイルをvisitするとき、最初にすべてのファイルローカル変数をこのalistに収集して、その後に変数1つずつに関数@code{hack-local-variables}を適用します。"

#. type: defvar
#: variables.texi.orig:1651
#, no-wrap
msgid "before-hack-local-variables-hook"
msgstr "before-hack-local-variables-hook"

#. type: defvar
#: variables.texi.orig:1654
msgid ""
"Emacs calls this hook immediately before applying file-local variables "
"stored in @code{file-local-variables-alist}."
msgstr "Emacsは、@code{file-local-variables-alist}に格納されたファイルローカル変数を適用する直前に、このフックを呼び出します。"

#. type: defvar
#: variables.texi.orig:1656
#, no-wrap
msgid "hack-local-variables-hook"
msgstr "hack-local-variables-hook"

#. type: defvar
#: variables.texi.orig:1659
msgid ""
"Emacs calls this hook immediately after it finishes applying file-local "
"variables stored in @code{file-local-variables-alist}."
msgstr "Emacsは、@code{file-local-variables-alist}に格納されたファイルローカル変数を適用し終えた直後に、このフックを呼び出します。"

#. type: cindex
#: variables.texi.orig:1661
#, no-wrap
msgid "safe local variable"
msgstr "safe local variable"

#. type: Plain text
#: variables.texi.orig:1670
msgid ""
"You can specify safe values for a variable with a @code{safe-local-variable} "
"property.  The property has to be a function of one argument; any value is "
"safe if the function returns non-@code{nil} given that value.  Many "
"commonly-encountered file variables have @code{safe-local-variable} "
"properties; these include @code{fill-column}, @code{fill-prefix}, and "
"@code{indent-tabs-mode}.  For boolean-valued variables that are safe, use "
"@code{booleanp} as the property value."
msgstr "ある変数にたいして@code{safe-local-variable}プロパティーにより、安全な値を指定できます。このプロパティーは引数を1つとる関数です。与えられた値にたいして、その関数が非@code{nil}をreturnした場合、その値は安全です。一般的に目にするファイル変数の多くは、@code{safe-local-variable}プロパティーをもちます。これらのファイル変数には、@code{fill-column}、@code{fill-prefix}、@code{indent-tabs-mode}が含まれます。ブーリーン値の変数にたいしては、プロパティーの値に@code{booleanp}を使用します。"

#. type: Plain text
#: variables.texi.orig:1675
msgid ""
"When defining a user option using @code{defcustom}, you can set its "
"@code{safe-local-variable} property by adding the arguments @code{:safe "
"@var{function}} to @code{defcustom} (@pxref{Variable Definitions})."
msgstr "@code{defcustom}を使用してユーザーオプションを定義するとき、@code{defcustom}に引数@code{:safe @var{function}}を追加することにより、@code{safe-local-variable}プロパティーをセットできます(@ref{Variable Definitions}を参照してください)。"

#. type: defopt
#: variables.texi.orig:1676
#, no-wrap
msgid "safe-local-variable-values"
msgstr "safe-local-variable-values"

#. type: defopt
#: variables.texi.orig:1681
msgid ""
"This variable provides another way to mark some variable values as safe.  It "
"is a list of cons cells @code{(@var{var} . @var{val})}, where @var{var} is a "
"variable name and @var{val} is a value which is safe for that variable."
msgstr "この変数は、ある変数の値が安全であることをマークする、別の方法を提供します。これはコンスセル@code{(@var{var} . @var{val})}のリストで、@var{var}は変数名、@var{val}はその変数にたいして安全な値です。"

#. type: defopt
#: variables.texi.orig:1687
msgid ""
"When Emacs asks the user whether or not to obey a set of file-local variable "
"specifications, the user can choose to mark them as safe.  Doing so adds "
"those variable/value pairs to @code{safe-local-variable-values}, and saves "
"it to the user's custom file."
msgstr "Emacsが一連のファイルローカル変数にしたがうかどうかユーザーに尋ねるとき、ユーザーはそれらの変数が安全だとマークすることができます。安全だとマークすると@code{safe-local-variable-values}にこれらのvariable/valueペアーが追加され、ユーザーのカスタムファイルに保存します。"

#. type: defun
#: variables.texi.orig:1689
#, no-wrap
msgid "safe-local-variable-p sym val"
msgstr "safe-local-variable-p sym val"

#. type: defun
#: variables.texi.orig:1692
msgid ""
"This function returns non-@code{nil} if it is safe to give @var{sym} the "
"value @var{val}, based on the above criteria."
msgstr "この関数は、上記の条件に基づき、@var{sym}に値@var{val}を与えても安全な場合は、非@code{nil}をreturnします。"

#. type: Plain text
#: variables.texi.orig:1700
msgid ""
"Some variables are considered @dfn{risky}.  If a variable is risky, it is "
"never entered automatically into @code{safe-local-variable-values}; Emacs "
"always queries before setting a risky variable, unless the user explicitly "
"allows a value by customizing @code{safe-local-variable-values} directly."
msgstr "いくつかの変数は@dfn{危険(risky)}だと判断されます。ある変数が危険な場合、その変数が自動的に@code{safe-local-variable-values}に追加されることはありません。ユーザーが@code{safe-local-variable-values}を直接カスタマイズすることにより、明示的に値を許さない限り、危険な変数をセットする前にEmacsは常に確認を求めます。"

#. type: Plain text
#: variables.texi.orig:1714
msgid ""
"Any variable whose name has a non-@code{nil} @code{risky-local-variable} "
"property is considered risky.  When you define a user option using "
"@code{defcustom}, you can set its @code{risky-local-variable} property by "
"adding the arguments @code{:risky @var{value}} to @code{defcustom} "
"(@pxref{Variable Definitions}).  In addition, any variable whose name ends "
"in any of @samp{-command}, @samp{-frame-alist}, @samp{-function}, "
"@samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form}, @samp{-forms}, "
"@samp{-map}, @samp{-map-alist}, @samp{-mode-alist}, @samp{-program}, or "
"@samp{-predicate} is automatically considered risky.  The variables "
"@samp{font-lock-keywords}, @samp{font-lock-keywords} followed by a digit, "
"and @samp{font-lock-syntactic-keywords} are also considered risky."
msgstr "名前が非@code{nil}の@code{risky-local-variable}プロパティーをもつ任意の変数は、危険だと判断されます。@code{defcustom}を使用してユーザーオプションを定義するとき、@code{defcustom}に引数@code{:risky @var{value}}を追加することにより、ユーザーオプションに@code{risky-local-variable}プロパティーをセットできます。それに加えて名前が@samp{-command}、@samp{-frame-alist}、@samp{-function}、@samp{-functions}、@samp{-hook}、@samp{-hooks}、@samp{-form}、@samp{-forms}、@samp{-map}、@samp{-map-alist}、@samp{-mode-alist}、@samp{-program}、@samp{-predicate}で終わる任意の変数は、自動的に危険だと判断されます。後に数字をともなう変数@samp{font-lock-keywords}および@samp{font-lock-keywords}、さらに@samp{font-lock-syntactic-keywords}も危険だと判断されます。"

#. type: defun
#: variables.texi.orig:1715
#, no-wrap
msgid "risky-local-variable-p sym"
msgstr "risky-local-variable-p sym"

#. type: defun
#: variables.texi.orig:1718
msgid ""
"This function returns non-@code{nil} if @var{sym} is a risky variable, based "
"on the above criteria."
msgstr "この関数は、@var{sym}が上記の条件にもとづき危険な変数の場合は、非非@code{nil}をreturnします。"

#. type: defvar
#: variables.texi.orig:1720
#, no-wrap
msgid "ignored-local-variables"
msgstr "ignored-local-variables"

#. type: defvar
#: variables.texi.orig:1724
msgid ""
"This variable holds a list of variables that should not be given local "
"values by files.  Any value specified for one of these variables is "
"completely ignored."
msgstr "この変数はファイルによりローカル値を与えられるべきではない変数のリストを保持します。これらの変数に指定された任意の値は、完全に無視されます。"

#. type: Plain text
#: variables.texi.orig:1728
msgid ""
"The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs "
"normally asks for confirmation before handling it."
msgstr "@samp{Eval:}``変数''も抜け道になる可能性があるので、Emacsは通常、それを処理する前に確認を求めます。"

#. type: defopt
#: variables.texi.orig:1729
#, no-wrap
msgid "enable-local-eval"
msgstr "enable-local-eval"

#. type: defopt
#: variables.texi.orig:1735
msgid ""
"This variable controls processing of @samp{Eval:} in @samp{-*-} lines or "
"local variables lists in files being visited.  A value of @code{t} means "
"process them unconditionally; @code{nil} means ignore them; anything else "
"means ask the user what to do for each file.  The default value is "
"@code{maybe}."
msgstr "この変数は@samp{-*-}行中、またはvisitされるファイル内のローカル変数リストの、@samp{Eval:}にたいする処理を制御します。値@code{t}は、無条件に実行することを意味します。@code{nil}は、それらを無視することを意味します。それ以外は、各ファイルにたいして何を行うか、ユーザーに確認を求めることを意味します。デフォルト値は、@code{maybe}です。"

#. type: defopt
#: variables.texi.orig:1737
#, no-wrap
msgid "safe-local-eval-forms"
msgstr "safe-local-eval-forms"

#. type: defopt
#: variables.texi.orig:1741
msgid ""
"This variable holds a list of expressions that are safe to evaluate when "
"found in the @samp{Eval:} ``variable'' in a file local variables list."
msgstr "この変数は、ファイルローカル変数リスト内の@samp{Eval:}``変数''の中、評価しても安全な式のリストを保持します。"

#. type: Plain text
#: variables.texi.orig:1749
msgid ""
"If the expression is a function call and the function has a "
"@code{safe-local-eval-function} property, the property value determines "
"whether the expression is safe to evaluate.  The property value can be a "
"predicate to call to test the expression, a list of such predicates (it's "
"safe if any predicate succeeds), or @code{t} (always safe provided the "
"arguments are constant)."
msgstr "その式が関数呼び出しで、その関数が@code{safe-local-eval-function}プロパティーをもつ場合、そのプロパティー値はその式の評価が安全かどうかを決定します。プロパティー値は、その式をテストするための述語(predicate)、そのような述語のリスト(成功した述語があれば安全)、または@code{t}(引数が定数である限り常に安全)を指定できます。"

#. type: Plain text
#: variables.texi.orig:1753
msgid ""
"Text properties are also potential loopholes, since their values could "
"include functions to call.  So Emacs discards all text properties from "
"string values specified for file-local variables."
msgstr "テキストプロパティーは、それらの値に関数呼び出しを含めることができるので、抜け道になる可能性があります。したがって、Emacsはファイルローカル変数にたいして指定された文字列値から、テキストプロパティーを取り除きます。"

#. type: cindex
#: variables.texi.orig:1756
#, no-wrap
msgid "directory local variables"
msgstr "directory local variables"

#. type: Plain text
#: variables.texi.orig:1763
msgid ""
"A directory can specify local variable values common to all files in that "
"directory; Emacs uses these to create buffer-local bindings for those "
"variables in buffers visiting any file in that directory.  This is useful "
"when the files in the directory belong to some @dfn{project} and therefore "
"share the same local variables."
msgstr "ディレクトリーは、そのディレクトリー内のすべてのファイルに共通なローカル変数値を指定することができます。Emacsは、そのディレクトリー内の任意のファイルをvisitしているバッファー内で、それらの変数にたいするバッファーローカルなバインディングを作成するために、これを使用します。これは、そのディレクトリー内のファイルが何らかの@dfn{プロジェクト}に属していて、同じローカル変数を共有するときなどに有用です。"

#. type: Plain text
#: variables.texi.orig:1767
msgid ""
"There are two different methods for specifying directory local variables: by "
"putting them in a special file, or by defining a @dfn{project class} for "
"that directory."
msgstr "ディレクトリーローカル変数を指定するために、2つの異なる方法があります: 1つは特別なファイルにそれを記述する方法、もう1つはそのディレクトリーに@dfn{プロジェクトクラス(project class)}を定義する方法です。"

#. type: defvr
#: variables.texi.orig:1768
#, no-wrap
msgid "Constant dir-locals-file"
msgstr "Constant dir-locals-file"

#. type: defvr
#: variables.texi.orig:1783
msgid ""
"This constant is the name of the file where Emacs expects to find the "
"directory-local variables.  The name of the file is "
"@file{.dir-locals.el}@footnote{ The MS-DOS version of Emacs uses "
"@file{_dir-locals.el} instead, due to limitations of the DOS filesystems.  "
"}.  A file by that name in a directory causes Emacs to apply its settings to "
"any file in that directory or any of its subdirectories (optionally, you can "
"exclude subdirectories; see below).  If some of the subdirectories have "
"their own @file{.dir-locals.el} files, Emacs uses the settings from the "
"deepest file it finds starting from the file's directory and moving up the "
"directory tree.  The file specifies local variables as a specially formatted "
"list; see @ref{Directory Variables, , Per-directory Local Variables, emacs, "
"The GNU Emacs Manual}, for more details."
msgstr "この定数は、Emacsがディレクトリーローカル変数が見つけることができる期待する、ファイルの名前です。ファイル名は、@file{.dir-locals.el}@footnote{MS-DOS版のEmacsは、DOSファイルシステムの制限により、かわりに@file{_dir-locals.el}という名前を使用します。}です。ディレクトリー内でその名前をもつファイルにより、Emacsはディレクトリー内の任意のファイル、または任意のサブディレクトリー(オプションでサブディレクトリーを除外できます。以下を参照してください)にセッティングを適用します。独自に@file{.dir-locals.el}をもつサブディレクトリーがある場合、Emacsはサブディレクトリーで見つかった1番深いファイルのディレクトリーからディレクトリーツリーを上方に移動しながら、1番深いファイルのセッティングを使用します。このファイルは、ローカル変数をフォーマットされたリストとして指定します。詳細は、@ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}を参照してください。"

#. type: defun
#: variables.texi.orig:1785
#, no-wrap
msgid "hack-dir-local-variables"
msgstr "hack-dir-local-variables"

#. type: defun
#: variables.texi.orig:1794
msgid ""
"This function reads the @code{.dir-locals.el} file and stores the "
"directory-local variables in @code{file-local-variables-alist} that is local "
"to the buffer visiting any file in the directory, without applying them.  It "
"also stores the directory-local settings in @code{dir-locals-class-alist}, "
"where it defines a special class for the directory in which "
"@file{.dir-locals.el} file was found.  This function works by calling "
"@code{dir-locals-set-class-variables} and "
"@code{dir-locals-set-directory-class}, described below."
msgstr "この関数は@code{.dir-locals.el}ファイルを読み込み、そのディレクトリー内の任意のファイルをvisitしているバッファーにたいしてローカルな@code{file-local-variables-alist}内に、それらを適用することなくディレクトリーローカル変数を格納します。この関数はディレクトリーローカルなセッティングも@code{dir-locals-class-alist}(@file{.dir-locals.el}ファイルが見つかったディレクトリーにたいする特別なクラスを定義する)内に格納します。この関数は、以下で説明するように、@code{dir-locals-set-class-variables}および@code{dir-locals-set-directory-class}を呼び出すことにより機能します。"

#. type: defun
#: variables.texi.orig:1796
#, no-wrap
msgid "hack-dir-local-variables-non-file-buffer"
msgstr "hack-dir-local-variables-non-file-buffer"

#. type: defun
#: variables.texi.orig:1803
msgid ""
"This function looks for directory-local variables, and immediately applies "
"them in the current buffer.  It is intended to be called in the mode "
"commands for non-file buffers, such as Dired buffers, to let them obey "
"directory-local variable settings.  For non-file buffers, Emacs looks for "
"directory-local variables in @code{default-directory} and its parent "
"directories."
msgstr "この関数はディレクトリーローカル変数を探して、即座にそれらをカレントバッファーに適用します。これはDiredバッファーのような、非ファイルバッファーをディレクトリーローカル変数のセッティングにしたがわせるために、モードコマンド呼び出しの中から呼び出されることを意図したものです。非ファイルバッファーにたいしては、Emacsは@code{default-directory}と、その親ディレクトリーの中から、ディレクトリーローカル変数を探します。"

#. type: defun
#: variables.texi.orig:1805
#, no-wrap
msgid "dir-locals-set-class-variables class variables"
msgstr "dir-locals-set-class-variables class variables"

#. type: defun
#: variables.texi.orig:1820
msgid ""
"This function defines a set of variable settings for the named @var{class}, "
"which is a symbol.  You can later assign the class to one or more "
"directories, and Emacs will apply those variable settings to all files in "
"those directories.  The list in @var{variables} can be of one of the two "
"forms: @code{(@var{major-mode} . @var{alist})} or @code{(@var{directory} "
". @var{list})}.  With the first form, if the file's buffer turns on a mode "
"that is derived from @var{major-mode}, then the all the variables in the "
"associated @var{alist} are applied; @var{alist} should be of the form "
"@code{(@var{name} . @var{value})}.  A special value @code{nil} for "
"@var{major-mode} means the settings are applicable to any mode.  In "
"@var{alist}, you can use a special @var{name}: @code{subdirs}.  If the "
"associated value is @code{nil}, the alist is only applied to files in the "
"relevant directory, not to those in any subdirectories."
msgstr "この関数は、@var{class}という名前がつけられたシンボルにたいして、一連の変数セッティングを定義します。その後このクラスを1つ以上のディレクトリーに割り当てることができ、するとEmacsはこれらの変数セッティングを、それらのディレクトリー内のすべてのファイルに適用します。@var{variables}内のリストは、2つの形式 --- @code{(@var{major-mode} . @var{alist})}または@code{(@var{directory} . @var{list})} --- のうち1つをもつことができます。1番目の形式では、そのファイルのバッファーが@var{major-mode}を継承するモードに切り替わるときに、連想リスト@var{alist}内のすべての変数が適用されます。@var{alist}は、@code{(@var{name} . @var{value})}という形式です。@var{major-mode}にたいする特別な値@code{nil}は、そのセッティングが任意のモードに適用できることを意味します。@var{alist}内では、特別な@var{name}として、@code{subdirs}を使用することができます。連想値が@code{nil}の場合、alistは関連するディレクトリー内のファイルだけに適用され、それらのサブディレクトリーには適用されません。"

#. type: defun
#: variables.texi.orig:1825
msgid ""
"With the second form of @var{variables}, if @var{directory} is the initial "
"substring of the file's directory, then @var{list} is applied recursively by "
"following the above rules; @var{list} should be of one of the two forms "
"accepted by this function in @var{variables}."
msgstr "@var{variables}の2番目の形式では、@var{directory}がそのファイルのディレクトリーの最初のサブディレクトリーの場合、上記のルールにしたがって、@var{list}が再帰的に適用されます。@var{list}は、この関数の@var{variables}で指定できる2つの形式のうち、1つを指定します。"

#. type: defun
#: variables.texi.orig:1827
#, no-wrap
msgid "dir-locals-set-directory-class directory class &optional mtime"
msgstr "dir-locals-set-directory-class directory class &optional mtime"

#. type: defun
#: variables.texi.orig:1833
msgid ""
"This function assigns @var{class} to all the files in @code{directory} and "
"its subdirectories.  Thereafter, all the variable settings specified for "
"@var{class} will be applied to any visited file in @var{directory} and its "
"children.  @var{class} must have been already defined by "
"@code{dir-locals-set-class-variables}."
msgstr "この関数は@code{directory}およびサブディレクトリー内のすべてのファイルに@var{class}を割り当てます。その後、@var{class}にたいして指定されたすべての変数セッティングは、@var{directory}およびその子ディレクトリー内でvisitされた任意のファイルに適用されます。@var{class}は事前に@code{dir-locals-set-class-variables}で定義されていなければなりません。"

#. type: defun
#: variables.texi.orig:1840
msgid ""
"Emacs uses this function internally when it loads directory variables from a "
"@code{.dir-locals.el} file.  In that case, the optional argument @var{mtime} "
"holds the file modification time (as returned by @code{file-attributes}).  "
"Emacs uses this time to check stored local variables are still valid.  If "
"you are assigning a class directly, not via a file, this argument should be "
"@code{nil}."
msgstr "Emacsは、@code{.dir-locals.el}ファイルからディレクトリー変数をロードするとき、内部的にこの関数を使用します。その場合、オプションの引数@var{mtime}は、ファイルの修正日時(modification time。@code{file-attributes}によりreturnされる)を保持します。Emacsは、記憶されたローカル変数がまだ有効化チェックするために、この日時を使用します。ファイルを通じ手ではなく直接クラスを割り当てる場合、この引数は@code{nil}になります。"

#. type: defvar
#: variables.texi.orig:1842
#, no-wrap
msgid "dir-locals-class-alist"
msgstr "dir-locals-class-alist"

#. type: defvar
#: variables.texi.orig:1845
msgid ""
"This alist holds the class symbols and the associated variable settings.  It "
"is updated by @code{dir-locals-set-class-variables}."
msgstr "このalistはクラスシンボル(class symbol)と連想変数セッティング(associated variable settings)を保持します。これは@code{dir-locals-set-class-variables}により更新されます。"

#. type: defvar
#: variables.texi.orig:1847
#, no-wrap
msgid "dir-locals-directory-cache"
msgstr "dir-locals-directory-cache"

#. type: defvar
#: variables.texi.orig:1852
msgid ""
"This alist holds directory names, their assigned class names, and "
"modification times of the associated directory local variables file (if "
"there is one).  The function @code{dir-locals-set-directory-class} updates "
"this list."
msgstr "このalistはディレクトリー名、それらに割り当てられたクラス名、およびこのエントリーに関連するディレクトリーローカル変数ファイルの修正日時を保持します。関数@code{dir-locals-set-directory-class}は、このlistを更新します。"

#. type: defvar
#: variables.texi.orig:1854
#, no-wrap
msgid "enable-dir-local-variables"
msgstr "enable-dir-local-variables"

#. type: defvar
#: variables.texi.orig:1858
msgid ""
"If @code{nil}, directory-local variables are ignored.  This variable may be "
"useful for modes that want to ignore directory-locals while still respecting "
"file-local variables (@pxref{File Local Variables})."
msgstr "@code{nil}の場合、ディレクトリーローカル変数は無視されます。この変数は、ファイルローカル変数(@ref{File Local Variables}を参照してください)にしたがい、ディレクトリーローカル変数は無視したいモードにたいして有用かもしれません。"

#. type: cindex
#: variables.texi.orig:1862
#, no-wrap
msgid "variable aliases"
msgstr "variable aliases"

#. type: cindex
#: variables.texi.orig:1863
#, no-wrap
msgid "alias, for variables"
msgstr "alias, for variables"

#. type: Plain text
#: variables.texi.orig:1872
msgid ""
"It is sometimes useful to make two variables synonyms, so that both "
"variables always have the same value, and changing either one also changes "
"the other.  Whenever you change the name of a variable---either because you "
"realize its old name was not well chosen, or because its meaning has partly "
"changed---it can be useful to keep the old name as an @emph{alias} of the "
"new one for compatibility.  You can do this with @code{defvaralias}."
msgstr "シノニムとして2つの変数を作成するのが有用なときがあります。2つの変数は常に同じ値をもち、、どちらか一方を変更すると、もう一方も変更されます。変数の名前を変更  --- 古い名前はよく考慮して選択されたものではなかった、あるいは変数の意味が部分的に変更された等の理由で --- するとき、互換性のために新しい名前の@emph{エイリアス(alias)}として古い名前を維持するのが有用なときがあるかもしれません。@code{defvaralias}により、これを行うことができます。"

#. type: defun
#: variables.texi.orig:1873
#, no-wrap
msgid "defvaralias new-alias base-variable &optional docstring"
msgstr "defvaralias new-alias base-variable &optional docstring"

#. type: defun
#: variables.texi.orig:1880
msgid ""
"This function defines the symbol @var{new-alias} as a variable alias for "
"symbol @var{base-variable}. This means that retrieving the value of "
"@var{new-alias} returns the value of @var{base-variable}, and changing the "
"value of @var{new-alias} changes the value of @var{base-variable}.  The two "
"aliased variable names always share the same value and the same bindings."
msgstr "この関数はシンボル@var{base-variable}のエイリアスとして、シンボル@var{new-alias}を定義します。これは@var{new-alias}から値を取得すると、@var{base-variable}の値がreturnされ、@var{new-alias}の値を変更すると、@var{base-variable}の値が変更されることを意味します。エイリアスされた2つの変数名は、常に同じ値と同じバインディングを共有します。"

#. type: defun
#: variables.texi.orig:1886
msgid ""
"If the @var{docstring} argument is non-@code{nil}, it specifies the "
"documentation for @var{new-alias}; otherwise, the alias gets the same "
"documentation as @var{base-variable} has, if any, unless @var{base-variable} "
"is itself an alias, in which case @var{new-alias} gets the documentation of "
"the variable at the end of the chain of aliases."
msgstr "@var{docstring}引数が非@code{nil}の場合、それは@var{new-alias}のドキュメント文字列を指定します。それ以外では、エイリアスは(もしあれば)@var{base-variable}と同じドキュメント文字列となります。ただし、それは@var{base-variable}自体がエイリアスではない場合で、エイリアスの場合、@var{new-alias}はエイリアスチェーンの最後の変数のドキュメント文字列になります。"

#. type: defun
#: variables.texi.orig:1888
msgid "This function returns @var{base-variable}."
msgstr "この関数は@var{base-variable}をreturnします。"

#. type: Plain text
#: variables.texi.orig:1894
msgid ""
"Variable aliases are convenient for replacing an old name for a variable "
"with a new name.  @code{make-obsolete-variable} declares that the old name "
"is obsolete and therefore that it may be removed at some stage in the "
"future."
msgstr "変数のエイリアスは、変数にたいする古い名前を新しい名前に置き換える、便利な方法です。@code{make-obsolete-variable}は古い名前を陳腐化(obsolete)していると宣言し。それが将来のある時点で削除されるかもしれないことを宣言します。"

#. type: defun
#: variables.texi.orig:1895
#, no-wrap
msgid "make-obsolete-variable obsolete-name current-name when &optional access-type"
msgstr "make-obsolete-variable obsolete-name current-name when &optional access-type"

#. type: defun
#: variables.texi.orig:1904
msgid ""
"This function makes the byte compiler warn that the variable "
"@var{obsolete-name} is obsolete.  If @var{current-name} is a symbol, it is "
"the variable's new name; then the warning message says to use "
"@var{current-name} instead of @var{obsolete-name}.  If @var{current-name} is "
"a string, this is the message and there is no replacement variable.  "
"@var{when} should be a string indicating when the variable was first made "
"obsolete (usually a version number string)."
msgstr "この関数は、倍とコンパイラーに変数@var{obsolete-name}が陳腐化していると警告させます。@var{current-name}がシンボルの場合、それはこの変数の新たな名前です。その後、@var{obsolete-name}のかわりに@var{current-name}を使用するよう、警告メッセージを伝えます。@var{current-name}が文字列の場合、これはメッセージで、置き換えられる変数はありません。@var{when}は、その変数が最初に陳腐化するのがいつかを示す文字列です(通常はバージョン番号文字列)。"

#. type: defun
#: variables.texi.orig:1908
msgid ""
"The optional argument @var{access-type}, if non-@code{nil}, should should "
"specify the kind of access that will trigger obsolescence warnings; it can "
"be either @code{get} or @code{set}."
msgstr "オプションの引数@var{access-type}は、非@code{nil}の場合は陳腐化の警告を引き起こすアクセスの種類を指定します。@code{get}または@code{set}を指定できます。"

#. type: Plain text
#: variables.texi.orig:1912
msgid ""
"You can make two variables synonyms and declare one obsolete at the same "
"time using the macro @code{define-obsolete-variable-alias}."
msgstr "2つの変数シノニムを作成して、マクロ@code{define-obsolete-variable-alias}を使用することにより同時に1つが陳腐化していると宣言できます。"

#. type: defmac
#: variables.texi.orig:1913
#, no-wrap
msgid ""
"define-obsolete-variable-alias obsolete-name current-name &optional when "
"docstring"
msgstr "define-obsolete-variable-alias obsolete-name current-name &optional when docstring"

#. type: defmac
#: variables.texi.orig:1917
msgid ""
"This macro marks the variable @var{obsolete-name} as obsolete and also makes "
"it an alias for the variable @var{current-name}.  It is equivalent to the "
"following:"
msgstr "このマクロは変数@var{obsolete-name}が陳腐化しているとマークして、それを変数@var{current-name}にたいするエイリアスにします。これは以下と等価です:"

#. type: example
#: variables.texi.orig:1921
#, no-wrap
msgid ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""
"(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})\n"
"(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})\n"

#. type: defun
#: variables.texi.orig:1924
#, no-wrap
msgid "indirect-variable variable"
msgstr "indirect-variable variable"

#. type: defun
#: variables.texi.orig:1928
msgid ""
"This function returns the variable at the end of the chain of aliases of "
"@var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is "
"not defined as an alias, the function returns @var{variable}."
msgstr "この関数は、@var{variable}のエイリアスチェーンの最後の変数をreturnします。@var{variable}がシンボルでない場合、または@var{variable}がエイリアスとして定義されていない場合、この関数は@var{variable}をreturnします。"

#. type: defun
#: variables.texi.orig:1931
msgid ""
"This function signals a @code{cyclic-variable-indirection} error if there is "
"a loop in the chain of symbols."
msgstr "この関数は、シンボルのチェーンがループしているときは、@code{cyclic-variable-indirection}エラーをシグナルします。"

#. type: example
#: variables.texi.orig:1942
#, no-wrap
msgid ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"
msgstr ""
"(defvaralias 'foo 'bar)\n"
"(indirect-variable 'foo)\n"
"     @result{} bar\n"
"(indirect-variable 'bar)\n"
"     @result{} bar\n"
"(setq bar 2)\n"
"bar\n"
"     @result{} 2\n"

#. type: group
#: variables.texi.orig:1945
#, no-wrap
msgid ""
"foo\n"
"     @result{} 2\n"
msgstr ""
"foo\n"
"     @result{} 2\n"

#. type: example
#: variables.texi.orig:1951
#, no-wrap
msgid ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"
msgstr ""
"(setq foo 0)\n"
"bar\n"
"     @result{} 0\n"
"foo\n"
"     @result{} 0\n"

#. type: cindex
#: variables.texi.orig:1955
#, no-wrap
msgid "lisp variables defined in C, restrictions"
msgstr "lisp variables defined in C, restrictions"

#. type: Plain text
#: variables.texi.orig:1966
msgid ""
"Ordinary Lisp variables can be assigned any value that is a valid Lisp "
"object.  However, certain Lisp variables are not defined in Lisp, but in "
"C@.  Most of these variables are defined in the C code using "
"@code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on any "
"value.  However, some variables are defined using @code{DEFVAR_INT} or "
"@code{DEFVAR_BOOL}.  @xref{Defining Lisp variables in C,, Writing Emacs "
"Primitives}, in particular the description of functions of the type "
"@code{syms_of_@var{filename}}, for a brief discussion of the C "
"implementation."
msgstr "通常のLisp変数には、有効なLispオブジェクトである任意の値を割り当てることができます。しかし、LispではなくCで定義されたLisp変数もあります。これらの変数のほとんどは、@code{DEFVAR_LISP}を使用してCコードで定義されています。Lispで定義された変数と同様、これらは任意の値をとることができます。しかし、いくつかの変数は@code{DEFVAR_INT}や@code{DEFVAR_BOOL}を使用して定義されています。C実装の概要的な議論は、@ref{Defining Lisp variables in C,, Writing Emacs Primitives}、特にタイプ@code{syms_of_@var{filename}}の関数の説明を参照してください。"

#. type: Plain text
#: variables.texi.orig:1970
msgid ""
"Variables of type @code{DEFVAR_BOOL} can only take on the values @code{nil} "
"or @code{t}.  Attempting to assign them any other value will set them to "
"@code{t}:"
msgstr "タイプが@code{DEFVAR_BOOL}の変数は、値に@code{nil}か@code{t}しかとることができません。他の値の割り当てを試みると、@code{t}はセットされます:"

#. type: example
#: variables.texi.orig:1975
#, no-wrap
msgid ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"
msgstr ""
"(let ((display-hourglass 5))\n"
"  display-hourglass)\n"
"     @result{} t\n"

#. type: defvar
#: variables.texi.orig:1977
#, no-wrap
msgid "byte-boolean-vars"
msgstr "byte-boolean-vars"

#. type: defvar
#: variables.texi.orig:1979
msgid "This variable holds a list of all variables of type @code{DEFVAR_BOOL}."
msgstr "この変数は、タイプ@code{DEFVAR_BOOL}のすべての変数のリストを保持します。"

#. type: Plain text
#: variables.texi.orig:1983
msgid ""
"Variables of type @code{DEFVAR_INT} can take on only integer values.  "
"Attempting to assign them any other value will result in an error:"
msgstr "タイプが@code{DEFVAR_INT}の変数は、整数値だけをとることができます。他の値の割り当てを試みると、結果はエラーになります:"

#. type: example
#: variables.texi.orig:1987
#, no-wrap
msgid ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"
msgstr ""
"(setq undo-limit 1000.0)\n"
"@error{} Wrong type argument: integerp, 1000.0\n"

#. type: cindex
#: variables.texi.orig:1992
#, no-wrap
msgid "generalized variable"
msgstr "generalized variable"

#. type: cindex
#: variables.texi.orig:1993
#, no-wrap
msgid "place form"
msgstr "place form"

#. type: Plain text
#: variables.texi.orig:1999
msgid ""
"A @dfn{generalized variable} or @dfn{place form} is one of the many places "
"in Lisp memory where values can be stored.  The simplest place form is a "
"regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements "
"of arrays, properties of symbols, and many other locations are also places "
"where Lisp values are stored."
msgstr "@dfn{ジェネリック変数(generalized variable： 汎変数)}または@dfn{place form}は、値が格納されるLispメモリー内の多くの場所のうちの1つです。1番シンプルなplace formは、通常のLisp変数です。しかし、リストの@sc{car}と@sc{cdr}、配列の要素、シンボルのプロパティー、その他多くのロケーション(location)も、Lisp値が格納される場所です。"

#. type: Plain text
#: variables.texi.orig:2005
msgid ""
"Generalized variables are analogous to ``lvalues'' in the C language, where "
"@samp{x = a[i]} gets an element from an array and @samp{a[i] = x} stores an "
"element using the same notation.  Just as certain forms like @code{a[i]} can "
"be lvalues in C, there is a set of forms that can be generalized variables "
"in Lisp."
msgstr "ジェネリック変数は、C言語の``lvalues(左辺値)''と類似しています。C言語のlvalueでは、@samp{x = a[i]}で配列から要素を取得し、同じ表記を使用して、@samp{a[i] = x}で要素を格納します。@code{a[i]}のような特定のフォームが、Cではlvalueになれるように、Lispでジェネリック変数になることができる一連のフォームが存在します。"

#. type: node
#: variables.texi.orig:2009 variables.texi.orig:2011
#, no-wrap
msgid "Setting Generalized Variables"
msgstr "Setting Generalized Variables"

#. type: menuentry
#: variables.texi.orig:2009
msgid "The @code{setf} macro."
msgstr "@code{setf}マクロ。"

#. type: node
#: variables.texi.orig:2009 variables.texi.orig:2102
#, no-wrap
msgid "Adding Generalized Variables"
msgstr "Adding Generalized Variables"

#. type: menuentry
#: variables.texi.orig:2009
msgid "Defining new @code{setf} forms."
msgstr "新たな@code{setf}フォームの定義。"

#. type: subsection
#: variables.texi.orig:2012
#, no-wrap
msgid "The @code{setf} Macro"
msgstr "The @code{setf} Macro"

#. type: Plain text
#: variables.texi.orig:2021
msgid ""
"The @code{setf} macro is the most basic way to operate on generalized "
"variables.  The @code{setf} form is like @code{setq}, except that it accepts "
"arbitrary place forms on the left side rather than just symbols.  For "
"example, @code{(setf (car a) b)} sets the car of @code{a} to @code{b}, doing "
"the same operation as @code{(setcar a b)}, but without having to remember "
"two separate functions for setting and accessing every type of place."
msgstr "@code{setf}マクロは、ジェネリック変数を操作する、もっとも基本的な方法です。@code{setf}フォームは@code{setq}と似ていますが、シンボルだけでなく、左辺の任意のplace formを受け入れます。たとえば@code{(setf (car a) b)}は@code{a}のcarを@code{b}にセットして、@code{(setcar a b)}と同じ操作を行いますが、すべてのplaceのタイプにセットおよびアクセスするために2つの別個の関数を覚える必要はありません。"

#. type: defmac
#: variables.texi.orig:2022
#, no-wrap
msgid "setf [place form]@dots{}"
msgstr "setf [place form]@dots{}"

#. type: defmac
#: variables.texi.orig:2028
msgid ""
"This macro evaluates @var{form} and stores it in @var{place}, which must be "
"a valid generalized variable form.  If there are several @var{place} and "
"@var{form} pairs, the assignments are done sequentially just as with "
"@code{setq}.  @code{setf} returns the value of the last @var{form}."
msgstr "このマクロは@var{form}を評価して、それを@var{place}に格納します。@var{place}は有効なジェネリック変数フォームでなければなりません。複数の@var{place}/@var{form}ペアーがある場合、割り当ては@code{setq}のときと同様です。@code{setf}は最後の@var{form}の値をreturnします。"

#. type: Plain text
#: variables.texi.orig:2032
msgid ""
"The following Lisp forms will work as generalized variables, and so may "
"appear in the @var{place} argument of @code{setf}:"
msgstr "以下のLispフォームはジェネリック変数として機能するので、@code{setf}の@var{place}引数にすることができます:"

#. type: itemize
#: variables.texi.orig:2042
msgid ""
"A symbol naming a variable.  In other words, @code{(setf x y)} is exactly "
"equivalent to @code{(setq x y)}, and @code{setq} itself is strictly speaking "
"redundant given that @code{setf} exists.  Many programmers continue to "
"prefer @code{setq} for setting simple variables, though, purely for "
"stylistic or historical reasons.  The macro @code{(setf x y)} actually "
"expands to @code{(setq x y)}, so there is no performance penalty for using "
"it in compiled code."
msgstr "変数を命名するシンボル。他の言い方をすると、@code{(setf x y)}は完全に@code{(setq x y)}と等しく、厳密に言うと@code{setq}自体は@code{setf}が存在するので冗長です。これは純粋にスタイルと歴史的な理由によりますが、多くのプログラマーは依然として単純な変数へのセットには@code{setq}の方を好みます。マクロ@code{(setf x y)}は、実際には@code{(setq x y)}に展開されるので、コンパイルされたコードでこれを使用することにパフォーマンス的な不利はありません。"

#. type: itemize
#: variables.texi.orig:2045
msgid "A call to any of the following standard Lisp functions:"
msgstr "以下の標準的なLisp関数の呼び出し:"

#. type: smallexample
#: variables.texi.orig:2053
#, no-wrap
msgid ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"
msgstr ""
"aref      cddr      symbol-function\n"
"car       elt       symbol-plist\n"
"caar      get       symbol-value\n"
"cadr      gethash\n"
"cdr       nth\n"
"cdar      nthcdr\n"

#. type: itemize
#: variables.texi.orig:2057
msgid "A call to any of the following Emacs-specific functions:"
msgstr "以下のEmacs特有な関数の呼び出し:"

#. type: smallexample
#: variables.texi.orig:2069
#, no-wrap
msgid ""
"default-value                 process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter\n"
msgstr ""
"default-value                 process-get\n"
"frame-parameter               process-sentinel\n"
"terminal-parameter            window-buffer\n"
"keymap-parent                 window-display-table\n"
"match-data                    window-dedicated-p\n"
"overlay-get                   window-hscroll\n"
"overlay-start                 window-parameter\n"
"overlay-end                   window-point\n"
"process-buffer                window-start\n"
"process-filter\n"

#. type: Plain text
#: variables.texi.orig:2075
msgid ""
"@code{setf} signals an error if you pass a @var{place} form that it does not "
"know how to handle."
msgstr "どのように処理すれば良いか知られていない@var{place}フォームを渡した場合、@code{setf}はエラーをシグナルします。"

#. type: Plain text
#: variables.texi.orig:2082
msgid ""
"Note that for @code{nthcdr}, the list argument of the function must itself "
"be a valid @var{place} form.  For example, @code{(setf (nthcdr 0 foo) 7)} "
"will set @code{foo} itself to 7."
msgstr "@code{nthcdr}の場合、関数のリスト引数は、それ自体が有効な@var{place}フォームでなければならないことに注意してください。たとえば、@code{(setf (nthcdr 0 foo) 7)}は、@code{foo}自体に7をセットするでしょう。"

#. type: Plain text
#: variables.texi.orig:2096
msgid ""
"The macros @code{push} (@pxref{List Variables}) and @code{pop} (@pxref{List "
"Elements}) can manipulate generalized variables, not just lists.  @code{(pop "
"@var{place})} removes and returns the first element of the list stored in "
"@var{place}.  It is analogous to @code{(prog1 (car @var{place}) (setf "
"@var{place} (cdr @var{place})))}, except that it takes care to evaluate all "
"subforms only once.  @code{(push @var{x} @var{place})} inserts @var{x} at "
"the front of the list stored in @var{place}.  It is analogous to @code{(setf "
"@var{place} (cons @var{x} @var{place}))}, except for evaluation of the "
"subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr} place "
"can be used to insert or delete at any position in a list."
msgstr "マクロ@code{push}(@ref{List Variables}を参照してください)、および@code{pop}(@ref{List Elements}を参照してください)は、リストだけでなくジェネリック変数を操作できます。@code{(pop @var{place})}は、@var{place}内に格納されたリストの最初の要素を削除してreturnします。これは@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}と類似していますが、すべてのサブフォームを1度だけ評価します。@code{(push @var{x} @var{place})}は、@var{place}内に格納されたリストの1番前に、@var{x}を挿入します。これは@code{(setf @var{place} (cons @var{x} @var{place}))}と類似していますが、サブフォームの評価を除きます。@code{nthcdr} placeへの@code{push}および@code{pop}は、リスト内の任意の位置での挿入および削除に使用できることに注意してください。"

#. type: Plain text
#: variables.texi.orig:2100
msgid ""
"The @file{cl-lib} library defines various extensions for generalized "
"variables, including additional @code{setf} places.  @xref{Generalized "
"Variables,,, cl, Common Lisp Extensions}."
msgstr "@file{cl-lib}ライブラリーは、追加の@code{setf} placeを含む、ジェネリック変数ニタイスルサマザマナ拡張を定義します。@ref{Generalized Variables,,, cl, Common Lisp Extensions}を参照してください。"

#. type: subsection
#: variables.texi.orig:2103
#, no-wrap
msgid "Defining new @code{setf} forms"
msgstr "Defining new @code{setf} forms"

#. type: Plain text
#: variables.texi.orig:2107
msgid ""
"This section describes how to define new forms that @code{setf} can operate "
"on."
msgstr "このセクションでは、@code{setf}が操作できる新たなフォームを定義する方法を説明します。"

#. type: defmac
#: variables.texi.orig:2108
#, no-wrap
msgid "gv-define-simple-setter name setter &optional fix-return"
msgstr "gv-define-simple-setter name setter &optional fix-return"

#. type: defmac
#: variables.texi.orig:2114
msgid ""
"This macro enables you to easily define @code{setf} methods for simple "
"cases.  @var{name} is the name of a function, macro, or special form.  You "
"can use this macro whenever @var{name} has a directly corresponding "
"@var{setter} function that updates it, e.g., @code{(gv-define-simple-setter "
"car setcar)}."
msgstr "このマクロは、単純なケースにたいして@code{setf}メソッドを簡単に定義することを可能にします。@var{name}は、関数、マクロ、スペシャルフォームの名前です。@var{name}が、それを更新するための対応する@var{setter}関数をもつときは、このマクロを使用できます(たとえば@code{(gv-define-simple-setter car setcar)})。"

#. type: defmac
#: variables.texi.orig:2116
msgid "This macro translates a call of the form"
msgstr "このマクロをフォーム以下の呼び出しを"

#. type: example
#: variables.texi.orig:2119
#, no-wrap
msgid "(setf (@var{name} @var{args}@dots{}) @var{value})\n"
msgstr "(setf (@var{name} @var{args}@dots{}) @var{value})\n"

#. type: defmac
#: variables.texi.orig:2122
msgid "into"
msgstr "以下のように変換します。"

#. type: example
#: variables.texi.orig:2124
#, no-wrap
msgid "(@var{setter} @var{args}@dots{} @var{value})\n"
msgstr "(@var{setter} @var{args}@dots{} @var{value})\n"

#. type: defmac
#: variables.texi.orig:2133
msgid ""
"Such a @code{setf} call is documented to return @var{value}.  This is no "
"problem with, e.g., @code{car} and @code{setcar}, because @code{setcar} "
"returns the value that it set.  If your @var{setter} function does not "
"return @var{value}, use a non-@code{nil} value for the @var{fix-return} "
"argument of @code{gv-define-simple-setter}.  This expands into something "
"equivalent to"
msgstr "@code{setf}のような呼び出しは、@var{value}をreturnするようにドキュメントされます。これに問題はありません。たとえば@code{car}と@code{setcar}では、@code{setcar}はそれがセットする値をreturnするからです。@var{setter}関数が@var{value}をreturnしない場合は、@code{gv-define-simple-setter}の@var{fix-return}引数に、非@code{nil}値を使用してください。これは以下のようなものに展開されます"

#. type: example
#: variables.texi.orig:2137
#, no-wrap
msgid ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"
msgstr ""
"(let ((temp @var{value}))\n"
"  (@var{setter} @var{args}@dots{} temp)\n"
"  temp)\n"

#. type: defmac
#: variables.texi.orig:2139
msgid "so ensuring that it returns the correct result."
msgstr "これで正しい結果がreturnされることが保証されます。"

#. type: defmac
#: variables.texi.orig:2142
#, no-wrap
msgid "gv-define-setter name arglist &rest body"
msgstr "gv-define-setter name arglist &rest body"

#. type: defmac
#: variables.texi.orig:2147
msgid ""
"This macro allows for more complex @code{setf} expansions than the previous "
"form.  You may need to use this form, for example, if there is no simple "
"setter function to call, or if there is one but it requires different "
"arguments to the place form."
msgstr "このマクロは、上述のフォームより複雑な@code{setf}展開を可能にします。たとえば、呼び出すべきシンプルなsetter関数が存在しないときや、もしそれが存在してもplace formとは異なる引数を要求する場合には、このフォームを使う必要があるかもしれません。"

#. type: defmac
#: variables.texi.orig:2155
msgid ""
"This macro expands the form @code{(setf (@var{name} @var{args}@dots{}) "
"@var{value})} by first binding the @code{setf} argument forms "
"@code{(@var{value} @var{args}@dots{})} according to @var{arglist}, and then "
"executing @var{body}.  @var{body} should return a Lisp form that does the "
"assignment, and finally returns the value that was set.  An example of using "
"this macro is:"
msgstr "このマクロは最初に@code{setf}引数フォーム@code{(@var{value} @var{args}@dots{})}を@var{arglist}にバインドして、その後@var{body}を実行することにより、フォーム@code{(setf (@var{name} @var{args}@dots{}) @var{value})}を展開します。@var{body}は割り当てを行うLispフォームをreturnし、最後にセットされた値をreturnするべきです。以下はこのマクロの使用例です:"

#. type: example
#: variables.texi.orig:2158
#, no-wrap
msgid "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"
msgstr "(gv-define-setter caar (val x) `(setcar (car ,x) ,val))\n"

#. type: findex
#: variables.texi.orig:2161
#, no-wrap
msgid "gv-define-expander"
msgstr "gv-define-expander"

#. type: findex
#: variables.texi.orig:2162
#, no-wrap
msgid "gv-letplace"
msgstr "gv-letplace"

#. type: Plain text
#: variables.texi.orig:2169
msgid ""
"For more control over the expansion, see the macro "
"@code{gv-define-expander}.  The macro @code{gv-letplace} can be useful in "
"defining macros that perform similarly to @code{setf}; for example, the "
"@code{incf} macro of Common Lisp.  Consult the source file @file{gv.el} for "
"more details."
msgstr "展開をさらに制御するには、マクロ@code{gv-define-expander}を参照してください。マクロ@code{gv-letplace}は、@code{setf}のように処理を行うマクロを定義するのに有用です。詳細は、@file{gv.el}のソースファイルを参照してください。"

#. type: cindex
#: variables.texi.orig:2170
#, no-wrap
msgid "CL note---no @code{setf} functions"
msgstr "CL note---no @code{setf} functions"

#. type: quotation
#: variables.texi.orig:2181
msgid ""
"@b{Common Lisp note:} Common Lisp defines another way to specify the "
"@code{setf} behavior of a function, namely ``@code{setf} functions'', whose "
"names are lists @code{(setf @var{name})} rather than symbols.  For example, "
"@code{(defun (setf foo) @dots{})} defines the function that is used when "
"@code{setf} is applied to @code{foo}.  Emacs does not support this.  It is a "
"compile-time error to use @code{setf} on a form that has not already had an "
"appropriate expansion defined.  In Common Lisp, this is not an error since "
"the function @code{(setf @var{func})} might be defined later."
msgstr "@b{Common Lispに関する注意:} Common Lispは関数の@code{setf}、すなわち``@code{setf}関数''の挙動を指定するための別の方法を定義します。@code{setf}関数の名前はシンボルではなく。リスト@code{(setf @var{name})}です。たとえば@code{(defun (setf foo) @dots{})}は、@code{setf}が@code{foo}に適用されるときに使用される関数を定義します。Emacsはこれをサポートしません。適切な展開が定義されていないフォームに@code{setf}を使用すると、コンパイル時にエラーとなります。Common Lispでは、関数@code{(setf @var{func})}が後で定義されるので、エラーにはなりません。"
