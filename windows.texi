@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2015 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Windows
@chapter Windows

このチャプターでは、Emacsのウィンドウに関連する関数と変数について説明します。Emacsが利用可能なスクリーン領域にウィンドウが割り当てられる方法については、@ref{Frames}を参照してください。ウィンドウ内にテキストが表示される方法についての情報は、@ref{Display}を参照してください。

@menu
* Basic Windows::            ウィンドウ使用についての基本情報。
* Windows and Frames::       ウィンドウとそれらが表示されるフレームとの関連。
* Window Sizes::             ウィンドウのサイズへのアクセス。
* Resizing Windows::         ウィンドウのサイズの変更。
* Splitting Windows::        新たなウィンドウの作成。
* Deleting Windows::         フレームからのウィンドウの削除。
* Recombining Windows::      ウィンドウの分割や削除時のフレームレイアウトの保存。
* Selecting Windows::        選択されたウィンドウとは、編集を行っているウィンドウである。
* Cyclic Window Ordering::   既存のウィンドウ間の移動。
* Buffers and Windows::      それぞれのウィンドウは、バッファーのコンテンツを表示する。
* Switching Buffers::        バッファー切り替えのための、より高レベルな関数。
* Choosing Window::          バッファーを表示するウィンドウの選択方法。
* Display Action Functions::  @code{display-buffer}用のサブルーチン。
* Choosing Window Options::  バッファー表示方法に影響する拡張オプション。
* Window History::           それぞれのウィンドウは、表示されていたバッファーを記憶する。
* Dedicated Windows::        特定のウィンドウ内で他のバッファーの表示を無効にする。
* Quitting Windows::         以前に表示していたバッファーの状態をリストアする方法。
* Window Point::             それぞれのウィンドウは、自身の位置とポイントをもつ。
* Window Start and End::     ウィンドウ内でスクリーン表示されるテキストを表すバッファー位置。
* Textual Scrolling::        ウィンドウを通じたテキストの上下移動。
* Vertical Scrolling::       ウィンドウ上のコンテンツの上下移動。
* Horizontal Scrolling::     ウィンドウ上のコンテンツの横移動。
* Coordinates and Windows::  座標からウィンドウへの変換。
* Window Configurations::    スクリーンの情報の保存とリストア。
* Window Parameters::        ウィンドウへの追加情報の割り当て。
* Window Hooks::             スクロール、ウィンドウのサイズ変更、ある特定のしきい値を超えたときに行われる再表示、ウィンドウ設定の変更にたいするフック。
@end menu


@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window

@dfn{ウィンドウ(window)}とは、任意のバッファーを表示するために使用される、スクリーンの領域です。Emacs
Lispでは、ウィンドウはスペシャルLispオブジェクトとして表現されます。

@cindex multiple windows
  ウィンドウは、フレームへとグループ化されます(@ref{Frames}を参照)。それぞれのフレームは、最低でも1つのウィンドウを含みます。ユーザーは、複数のバッファーを1度に閲覧するために、それを複数のオーバーラップしないウィンドウに分割することができます。Lispプログラムは、さまざまな目的にたいして、複数のウィンドウを使用できます。たとえばRmailでは、1つのウィンドウでメッセージタイトル、もう一方のウィンドウで選択したメッセージのコンテンツを閲覧できます。

@cindex terminal screen
@cindex screen of terminal
  Emacsは、グラフィカルなデスクトップ環境や、X Window
Systemのようなウィンドウシステムとは異なる意味で、``ウィンドウ(window)''という単語を使用します。EmacsがX上で実行されているときは、XのグラフィカルなXウィンドウは、Emacsでの(1つ以上のEmacsウィンドウを含んだ)フレームになります。Emacsがテキスト端末上で実行されているときは、フレームが端末スクリーン全体を占有します。

@cindex tiled windows
  Xのウィンドウとは異なり、Emacsのウィンドウは@dfn{タイル表示(tiled)}され、フレームの領域内でオーバーラップされることは決してありません。あるウィンドウが作成、リサイズ、削除されるとき、変更されたウィンドウスペースの変更は各ウィンドウの調整により取得・譲与されるので、そのフレームの総領域に変化はありません。

@defun windowp object
この関数は、@var{object}がウィンドウ(バッファーの表示有無に関わらず)なら@code{t}、それ以外は@code{nil}をリターンする。
@end defun

@cindex live windows
@dfn{生きたウィンドウ(live window)}とは、あるフレーム内で実際にバッファーを表示しているウィンドウのことです。

@defun window-live-p object
この関数は、@var{object}が生きたウィンドウなら@code{t}、それ以外は@code{nil}をリターンする。生きたウィンドウとは、バッファーを表示するウィンドウのこと。
@end defun

@cindex internal windows
各フレーム内のウィンドウは、@dfn{ウィンドウツリー(window tree)}内へと組織化されます。@ref{Windows and
Frames}を参照してください。それぞれのウィンドウツリーのリーフノード(leaf
nodes)は、実際にバッファーを表示している生きたウィンドウです。ウィンドウツリーの内部ノード(internal
node)は@dfn{内部ウィンドウ(internal windows)}と呼ばれ、これらは生きたウィンドウではありません。

@cindex valid windows
   @dfn{有効なウィンドウ(valid
window)}とは、生きたウィンドウか、内部ウィンドウのいずれかです。有効なウィンドウにたいしては、それを@dfn{削除(delete)}、すなわちそのウィンドウのフレームから削除することができます(@ref{Deleting
Windows}を参照)。その場合、それは有効なウィンドウではなくなりますが、それを表すLispオブジェクトは依然として他のLispオブジェクトから参照されたままかもしれません。削除されたウィンドウは、保存されたウィンドウ設定(window
configuration)をリストアすることにより、再び有効になるかもしれません(@ref{Window Configurations}を参照)。

   @code{window-valid-p}により、削除されたウィンドウから有効なウィンドウを区別できます。

@defun window-valid-p object
この関数は、@var{object}が生きたウィンドウ、またはウィンドウツリー内の内部ウィンドウの場合は、@code{t}をリターンする。それ以外(@var{object}が削除されたウィンドウの場合も含む)は、@code{nil}をリターンする。
@end defun

@cindex selected window
@cindex window selected within a frame
  それぞれのフレーム内において、常にただ1つのEmacsウィンドウが@dfn{そのフレームで選択されている(selected within the
frame)}もとして指定されます。選択されたフレームにたいしては、そのウィンドウは@dfn{選択されたウィンドウ(selected
window)}と呼ばれます。選択されたウィンドウは、編集のほとんどが行われるウィンドウであり、選択されたウィンドウに表示されるカーソルがあるウィンドウです(@ref{Cursor
Parameters}を参照)。選択されたウィンドウのバッファーは通常は、@code{set-buffer}が使用された場合を除き、カレントバッファーでもあります(@ref{Current
Buffer}を参照)。選択されていないフレームでは、そのフレームが選択されたときは、そのフレームで選択されていたウィンドウが選択されたウィンドウになります。@ref{Selecting
Windows}を参照してください。

@defun selected-window
この関数は、選択されたウィンドウをリターンする(これは常に生きたウィンドウである)。
@end defun

@node Windows and Frames
@section Windows and Frames

ウィンドウはそれぞれ、正確に1つのフレームに属します(@ref{Frames}を参照)。

@defun window-frame &optional window
この関数は、ウィンドウ@var{window}が属するフレームをリターンする。@var{window}が@code{nil}の場合のデフォルトは、選択されたウィンドウである。
@end defun

@defun window-list &optional frame minibuffer window
この関数は、フレーム@var{frame}に属する、生きたウィンドウのリストをリターンする。@var{frame}が省略、または@code{nil}の場合のデフォルトは、選択されたフレームである。

オプション引数@var{minibuffer}は、リターンされるリストにミニバッファーウィンドウを含めるべきかどうかを指定する。@var{minibuffer}が@code{t}の場合は、ミニバッファーウィンドウが含まれる。@var{minibuffer}が@code{nil}、または省略された場合は、ミニバッファーウィンドウがアクティブのときだけ含まれる。@var{minibuffer}が@code{nil}と@code{t}以外の場合、ミニバッファーウィンドウは含まれない。

オプション引数@var{window}が非@code{nil}の場合、それは指定されたフレーム上の生きたウィンドウであること。その場合は、@var{window}がリターンされるリストの最初の要素になる。@var{window}が省略、または@code{nil}の場合は、そのフレームの選択されたウィンドウが最初の要素になる。
@end defun

@cindex window tree
@cindex root window
  同一フレーム内のウィンドウは、リーフノード(leaf nodes)が生きたウィンドウであるような、@dfn{ウィンドウツリー(window
tree)}内に組織化されます。ウィンドウツリーの内部ノード(internal
nodes)は生きたウィンドウではありません。これらのウィンドウは、生きたウィンドウ間の関係を組織化するという目的のために存在します。ウィンドウツリーのルートノード(root
node)は、@dfn{ルートウィンドウ(root
window)}と呼ばれます。ルートノードは生きたウィンドウ(そのフレームにウィンドウが1つだけの場合)、または内部ウィンドウのいずれかです。

  ミニバッファーウィンドウ(@ref{Minibuffer
Windows}を参照)は、そのフレームがミニバッファーだけのフレームでない限り、そのフレームのウィンドウツリーの一部にはなりません。にもかかわらず、このセクションのほとんどの関数は、引数としてミニバッファーウィンドウを受け付けます。さらにこのセクションの最後に説明する関数@code{window-tree}は、実際のウィンドウツリーと並列してミニバッファーウィンドウをリストします。

@defun frame-root-window &optional frame-or-window
この関数は、@var{frame-or-window}にたいするルートウィンドウをリターンする。引数@var{frame-or-window}は、ウィンドウかフレームのいずれかであること。これが省略、または@code{nil}の場合のデフォルトは、選択されたフレームである。@var{frame-or-window}がウィンドウの場合、リターン値はそのウィンドウのフレームのルートウィンドウである。
@end defun

@cindex parent window
@cindex child window
@cindex sibling window
  ウィンドウが分割(split)されているときは、以前は1つだった2つの生きたウィンドウが存在します。これらのうちの一方は、元のウィンドウと同じLispウィンドウオブジェクトとして表され、もう一方は新たに作成されたLispウィンドウオブジェクトとして表されます。これらの生きたウィンドウは両方とも、単一の内部ウィンドウの@dfn{子ウィンドウ(child
windows)}として、ウィンドウツリーのリーフノードになります。もし必要なら、Emacsはこの内部ウィンドウを自動的に作成します。この内部ウィンドウは@dfn{親ウィンドウ(parent
window)}とも呼ばれ、ウィンドウツリー内の適切な位置に配置されます。同じ親を共有するウィンドウセットは、@dfn{兄弟(sibling)}と呼ばれます。

@cindex parent window
@defun window-parent &optional window
この関数は、@var{window}の親ウィンドウ(parent
window)をリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。@var{window}が親をもたない(ミニバッファーウィンドウやそのフレームのルートウィンドウ)場合、リターン値は@code{nil}である。
@end defun

  内部ウィンドウはそれぞれ、常に最低でも2つの子ウィンドウをもちます。ウィンドウ削除によりこの数値が1になった場合、Emacsは自動的に内部ウィンドウを削除して、その残った単一の子ウィンドウがウィンドウツリー内のその位置に配置されます。

  子ウィンドウはそれぞれ生きたウィンドウ、または(次に自身の子ウィンドウをもつであろう)内部ウィンドウのいずれかです。したがって、各内部ウィンドウは、最終的にはその内部ウィンドウの子孫であるような生きたウィンドウにより占有される領域を結合した、特定の矩形@dfn{スクリーン領域(screen
area)}を占有すると考えることができます。

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
  内部ウィンドウそれぞれにたいして、近接する子たちのスクリーン領域は、垂直(vertically)または水平(horizontally)のいずれかにより整列されます(両方で整列されることはない)。子ウィンドウが他の子ウィンドウと上下に整列される場合、それらは@dfn{垂直コンビネーション(vertical
combination)}、左右に整列される場合は@dfn{水平コンビネーション(horizontal
combination)}を形成すると表現されます。以下の例で考えてみましょう:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
このフレームのルートウィンドウは、内部ウィンドウ@var{W1}です。これの子ウィンドウは、生きたウィンドウ@var{W2}と内部ウィンドウ@var{W3}からなる水平コンビネーションを形成します。@var{W3}の子ウィンドウは、生きたウィンドウ@var{W4}と@var{W5}からなる垂直コンビネーションを形成します。したがって、このウィンドウツリー内の生きたウィンドウは@var{W2}、@var{W4}、および@var{W5}です。

  以下の関数は、内部ウィンドウの子ウィンドウ、および子ウィンドウの兄弟を取得するのに使用できます。

@defun window-top-child &optional window
この関数は、内部ウィンドウ@var{window}の子ウィンドウが垂直コンビネーションを形成する場合は、@var{window}の一番上の子ウィンドウをリターンする。他のタイプのウィンドウにたいするリターン値は@code{nil}である。
@end defun

@defun window-left-child &optional window
この関数は、内部ウィンドウ@var{window}の子ウィンドウが水平コンビネーションを形成する場合は、@var{window}の一番左の子ウィンドウをリターンする。他のタイプのウィンドウにたいするリターン値は@code{nil}である。
@end defun

@defun window-child window
この関数は、内部ウィンドウ@var{window}の最初の子ウィンドウをリターンする。これは、垂直コンビネーションにたいしては一番上、水平コンビネーションにたいしては一番左の子ウィンドウである。@var{window}が生きたウィンドウの場合、リターン値は@code{nil}である。
@end defun

@defun window-combined-p &optional window horizontal
この関数は、@var{window}が垂直コンビネーションの一部である場合のみ、非@code{nil}をリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。

オプション引数@var{horizontal}が非@code{nil}ならば、@var{window}が水平コンビネーションの一部である場合のみ非@code{nil}をリターンすることを意味する。
@end defun

@defun window-next-sibling &optional window
この関数は、ウィンドウ@var{window}の次の兄弟をリターンする。省略または@code{nil}の場合、@var{window}のデフォルトは選択されたウィンドウになる。@var{window}が、その親の最後の子の場合、リターン値は@code{nil}である。
@end defun

@defun window-prev-sibling &optional window
この関数は、ウィンドウ@var{window}の前の兄弟をリターンする。省略または@code{nil}の場合、@var{window}のデフォルトは選択されたウィンドウになる。@var{window}が、その親の最初の子の場合、リターン値は@code{nil}である。
@end defun

関数@code{window-next-sibling}および@code{window-prev-sibling}を、ウィンドウのサイクル順(@ref{Cyclic
Window
Ordering}を参照)において次、または前のウィンドウをリターンする関数@code{next-window}および@code{previous-window}と混同しないでください。

  任意のフレーム上の最初の生きたウィンドウや、与えられたウィンドウにもっとも近いウィンドウを探すために、以下の関数を使用できます。

@defun frame-first-window &optional frame-or-window
この関数は、@var{frame-or-window}により指定されたフレームの、左上隅の生きたウィンドウをリターンする。引数@var{frame-or-window}では、ウィンドウか生きたフレームを示さなければならず、デフォルトは選択されたフレームである。@var{frame-or-window}がウィンドウを指定する場合、この関数はそのウィンドウのフレームの最初のウィンドウをリターンする。前の例のフレームが@code{(frame-first-window)}に指定されたとするならば、@var{W2}がリターンされる。
@end defun

@cindex window in direction
@defun window-in-direction direction &optional window ignore sign wrap mini
この関数は、ウィンドウ@var{window}内の位置@code{window-point}から、方向@var{direction}にあるもっとも近い生きたウィンドウをリターンする。引数@var{direction}は@code{above}、@code{below}、@code{left}、@code{right}のいずれかでなければならない。オプション引数@var{window}は生きたウィンドウを示さなければならず、デフォルトは選択されたウィンドウである。

この関数は、パラメーター@code{no-other-window}が非@code{nil}のウィンドウをリターンしない(@ref{Window
Parameters}を参照)。もっとも近いウィンドウの@code{no-other-window}パラメーターが非@code{nil}の場合、この関数は指定された方向で@code{no-other-window}パラメーターが@code{nil}の、他のウィンドウを探す。オプション引数@var{ignore}が非@code{nil}の場合は、たとえ@code{no-other-window}パラメーターが非@code{nil}のウィンドウでも、リターンされ得る。

オプション引数@var{sign}が負の数値の場合、それは参照位置として@code{window-point}のかわりに、@var{window}の右端、または下端を使用することを意味する。@var{sign}が正の数値の場合、それは参照位置として@var{window}の左端、または上端を使用することを意味する。

オプション引数@var{wrap}が非@code{nil}の場合、それはフレームのボーダー(borders:
枠線)を@var{direction}がラップアラウンド(wrap around:
最後に達したら最初に戻る)することを意味する。たとえば、@var{window}はフレームの最上にあり、@var{direction}が@code{above}の場合、フレームにミニバッファーがあればミニバッファーウィンドウ、それ以外はフレーム最下のウィンドウウィンドウリターンする。

オプション引数@var{mini}が@code{nil}の場合、それはミニバッファーがカレントでアクティブな場合のみ、ミニバッファーウィンドウをリターンすることを意味する。@var{mini}が非@code{nil}ならば、たとえ非アクティブなときでもミニバッファーウィンドウをリターンする。しかし、@var{wrap}が非@code{nil}の場合は、常に@var{mini}が@code{nil}であるかのように動作する。

適切なウィンドウが見つからない場合、この関数は@code{nil}をリターンする。
@end defun

以下の関数により、任意のフレームのウィンドウツリー全体を取得できます:

@defun window-tree &optional frame
この関数は、フレーム@var{frame}にたいするウィンドウツリーを表すリストをリターンする。@var{frame}が省略、または@code{nil}の場合のデフォルトは、選択されたフレームである。

リターン値は、@code{(@var{root}
@var{mini})}という形式のリストである。ここで@var{root}はそのフレームのウィンドウツリーのルートウィンドウ、@var{mini}はそのフレームのミニバッファーウィンドウを表す。

ルートウィンドウが生きている場合、@var{root}はそのウィンドウ自身である。それ以外では、@var{root}はリスト@code{(@var{dir}
@var{edges} @var{w1} @var{w2}
...)}である。ここで@var{dir}は水平コンビネーションなら@code{nil}、垂直コンビネーションなら@code{t}となり、@var{edges}はそのコンビネーションのサイズと位置を与え、残りの要素は子ウィンドウである。子ウィンドウはそれぞれ、同じようにウィンドウオブジェクト(生きたウィンドウにたいして)、または上記フォーマットと同じ形式のリスト(内部ウィンドウにたいして)かもしれない。@var{edges}要素は@code{window-edges}がリターンする値のような、リスト@code{(@var{left}
@var{top} @var{right} @var{bottom})}である(@ref{Coordinates and Windows}を参照)。
@end defun


@node Window Sizes
@section Window Sizes
@cindex window size
@cindex size of window

  以下の図は、生きたウィンドウの構造を示しています:

@smallexample
@group
        ____________________________________________
       |______________ Header Line ______________|RD| ^
     ^ |LS|LF|LM|                       |RM|RF|RS|  | |
     | |  |  |  |                       |  |  |  |  | |
Window |  |  |  |       Text Area       |  |  |  |  | Window
Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
Height |  |  |  |                       |  |  |  |  | Height
     | |  |  |  |<- Window Body Width ->|  |  |  |  | |
     v |__|__|__|_______________________|__|__|__|  | |
       |_______________ Mode Line _______________|__| |
       |_____________ Bottom Divider _______________| v
        <---------- Window Total Width ------------>

@end group
@end smallexample

@cindex window body
@cindex text area of a window
@cindex body of a window
  ウィンドウの中央は@dfn{テキストエリア(text area: テキスト領域)}、または@dfn{ボディー(body:
本体、本文)}と呼ばれる、バッファーテキストが表示される場所です。テキストエリアは、一連のオプションエリアで囲まれている可能性があります。左右には、内側から外側に向かって、図中にLMとRMで示される左右のマージン(@ref{Display
Margins}を参照)、LFとRFで示される左右のフリンジ(@ref{Fringes}を参照)、そしてLSとRSはスクロールバー(@ref{Scroll
Bars}を参照)で、常に表示されるのはいずれか一方だけです。そしてRDはディバイダー(@ref{Window
Dividers}を参照)を示しています。ウィンドウの上端はヘッダーライン(@ref{Header
Lines}を参照)、下端にはモードライン(@ref{Mode Line Format}を参照)と、その下に下端ディバイダー(@ref{Window
Dividers}を参照)があります。

  Emacsは、ウィンドウの高さと幅を求めるために、さまざまな関数を提供します。これらの関数がリターンする値の多くは、ピクセル単位か、行単位と列単位のいずれかにより指定できます。グラフィカルなディスプレイでは、後者は実際には@code{frame-char-height}および@code{frame-char-width}によりリターンされる、そのフレームのデフォルトフォントが指定する、``デフォルト文字''の高さと幅に対応します。したがって、あるウィンドウが異なるフォントやサイズでテキストを表示していると、そのウィンドウにたいして報告される行高さと列幅は、実際にウィンドウ内で表示されるテキスト行数と列数とは、異なるかもしれません。

@cindex window height
@cindex height of a window
@cindex total height of a window
  ウィンドウの@dfn{トータル高さ(total
height)}とは、そのウィンドウのボディー、ヘッダーライン、モードライン、(もしあれば)下端ディバイダーを構成する行数のことです。フレームにはエコーエリア、メニューバー、ツールバーが含まれるかもしれないので、フレームの高さはそのフレームのルートウィンドウ(@ref{Windows
and Frames}を参照)の高さとは異なることに注意してください(@ref{Size and Position}を参照)。

@defun window-total-height &optional window round
この関数は、ウィンドウ@var{window}のトータル高さを、行でリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。@var{window}が内部ウィンドウの場合、リターン値はそのウィンドウの子孫となるウィンドウにより占有されるトータル高さになる。

  ウィンドウのピクセル高さが、そのウィンドウがあるフレームのデフォルト文字高さの整数倍でない場合は、そのウィンドウが占有する行数が内部で丸められる。これは、そのウィンドウが親ウィンドウの場合は、すべての子ウィンドウのトータル高さの合計が、親ウィンドウのトータル高さと内部的に等しくなるような方法により行われる。これは、たとえ2つのウィンドウのピクセル高さが等しくでも、内部的なトータル高さは1行分異なるかもしれないことを意味する。さらにこれは、そのウィンドウが垂直コンビネーションされていて、かつ右の兄弟をもつ場合、その兄弟の上端行は、このウィンドウの上端行とトータル高さから計算されるかもしれないことも意味する(@ref{Coordinates
and Windows}を参照)。

  オプション引数@var{round}が@code{ceiling}の場合、この関数は@var{window}のピクセル高さを、そのフレームの文字高さで除した数より大であるような最小の整数、@code{floor}の場合は除した数より小であるような最大の整数、それ以外の@var{round}にたいしては、@var{windows}のトータル高さの内部値をリターンする。
@end defun

@cindex window width
@cindex width of a window
@cindex total width of a window
@dfn{トータル幅(total
width)}とは、そのウィンドウのボディーを構成する列数、マージン、フリンジ、スクロールバー、(もしあれば)右ディバイダーです。

@defun window-total-width &optional window round
この関数は、ウィンドウ@var{window}のトータル幅を列でリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。@var{window}が内部ウィンドウの場合、リターン値はその子孫のウィンドウが占有するトータル幅になる。

  ウィンドウのピクセル幅が、そのウィンドウがあるフレームのデフォルト文字幅の整数倍でない場合は、そのウィンドウが占有する列数が内部で丸められる。これは、そのウィンドウが親ウィンドウの場合は、すべての子ウィンドウのトータル幅の合計が、親ウィンドウのトータル幅と内部的に等しくなるような方法により行われる。これは、たとえ2つのウィンドウのピクセル幅が等しくでも、内部的なトータル幅は1列分異なるかもしれないことを意味する。さらにこれは、そのウィンドウが水平コンビネーションされていて、かつ右の兄弟をもつ場合、その兄弟の左端行は、このウィンドウの左端行とトータル幅から計算されるかもしれないことも意味する(@ref{Coordinates
and Windows}を参照)。オプション引数@var{round}は、@code{window-total-height}の場合と同様に振る舞う。
@end defun

@defun window-total-size &optional window horizontal round
この関数は、ウィンドウ@var{window}のトータル高さを行で、またはトータル幅を列でリターンする。@var{horizontal}が省略、または@code{nil}の場合は@var{window}にたいして@code{window-total-height}を呼び出すのと等価であり、それ以外では@var{window}にたいして@code{window-total-width}を呼び出すのと等価である。オプション引数@var{round}は、@code{window-total-height}の場合と同様に振る舞う。
@end defun

以下の2つの関数は、ウィンドウのトータルサイズをピクセル単位でリターンさせるために使用できます。

@cindex window pixel height
@cindex pixel height of a window
@cindex total pixel height of a window

@defun window-pixel-height &optional window
この関数は、ウィンドウ@var{window}のトータル高さを、ピクセルでリターンする。@var{window}は有効なウィンドウでなければならず、デフォルトは選択されたウィンドウである。

リターン値には、(もしあれば)モードライン、ヘッダーライン、下端ディバイダーが含まれる。@var{window}が内部ウィンドウの場合、そのピクセル高さは子ウィンドウたちによりスパンされるスクリーン領域のピクセル高さになる。
@end defun

@cindex window pixel height
@cindex pixel height of a window
@cindex total pixel height of a window

@defun window-pixel-width &optional Lisp_Object &optional window
この関数は、ウィンドウ@var{window}の幅をピクセルでリターンする。@var{window}は有効なウィンドウでなければならず、デフォルトは選択されたウィンドウである。

リターン値には、フリンジ、@var{window}のマージン、同様に@var{window}に属する垂直ディバイダーとスクロールバーが含まれる。@var{window}が内部ウィンドウの場合、そのピクセル幅は子ウィンドウたちによりスパンされるスクリーン領域の幅になる。
@end defun

@cindex full-width window
@cindex full-height window
  以下の関数は、与えられたウィンドウに隣接するウィンドウがあるかどうかを判断するために使用できます。

@defun window-full-height-p &optional window
この関数は、フレーム内で@var{window}の上下に他のウィンドウがなければ非@code{nil}をリターンする(トータル高さがそのフレーム上のルートウィンドウと等しい)。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。
@end defun

@defun window-full-width-p &optional window
この関数は、フレーム内で@var{window}の左右に他のウィンドウがなければ非@code{nil}をリターンする(トータル幅がそのフレーム上のルートウィンドウと等しい)。@var{window}が省略、または@code{nil}の場合のデフォルトは、選択されたウィンドウである。
@end defun

@cindex window body height
@cindex body height of a window
@cindex window body width
ウィンドウの@dfn{ボディー高さ(body height)}とは、モードライン、ヘッダーライン、下端ディバイダーを含まないテキスト領域の高さです。

@defun window-body-height &optional window pixelwise
この関数は、ウィンドウ@var{window}のボディーの高さを、行でリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは選択されたウィンドウで、それ以外では生きたウィンドウでなければならない。

オプション引数@var{pixelwise}が非@code{nil}の場合、この関数はピクセルで計算@var{window}のボディー高さをリターンする。

@var{pixelwise}が@code{nil}の場合は、必要ならリターン値はもっとも近い整数に切り下げられる。これは、テキスト領域の下端行が部分的に可視の場合、その行は計数されないこと、さらに任意のウィンドウのボディー高さは、@code{window-total-height}によりリターンされるそのウィンドウのトータル高さ決して超過し得ないことをも意味する。
@end defun

@cindex body width of a window
@cindex body size of a window
@cindex window body size
ウィンドウの@dfn{ボディー幅(body width)}とは、スクロールバー、フリンジ、マージン、右ディバイダーを含まないテキスト領域の幅です。

@defun window-body-width &optional window pixelwise
この関数は、ウィンドウ@var{window}のボディーの幅を、列でリターンする。@var{window}が省略、または@code{nil}の場合のデフォルトは選択されたウィンドウであり、それ以外では生きたウィンドウでなければならない

オプション引数@var{pixelwise}が非@code{nil}の場合、この関数は@var{window}のボディーの幅をピクセル単位でリターンする。

@var{pixelwise}が@code{nil}の場合、リターン値は必要ならもっとも近い整数に切り下げられる。これはテキスト領域の右端の列が部分的に可視な場合は、その列は計数されないことを意味する。さらにこれは、ウィンドウのボディーの幅が、@code{window-total-width}によりリターンされるウィンドウのトータル幅を決して超過し得ないことをも意味する。
@end defun

@defun window-body-size &optional window horizontal pixelwise
この関数は、@var{window}のボディーの高さ、または幅をリターンする。@var{horizontal}が省略、または@code{nil}の場合は、@var{window}にたいして@code{window-body-height}、それ以外の場合は、@code{window-body-width}を呼び出すのと同じである。いずれの場合も、オプション引数@var{pixelwise}は、呼び出された関数に渡される。
@end defun

  以前のバージョンのEmacsとの互換性のため、@code{window-height}は@code{window-total-height}、@code{window-width}は@code{window-body-width}にたいするエイリアスです。これらのエイリアス時代遅れと考えられております、将来的には削除されるでしょう。

   ウィンドウのモードラインとヘッダーラインのピクセル高さは、以下の関数により取得できる。それらのリターン値は、そのウィンドウが以前に表示されていない場合を除き、通常は加算される。その場合、リターン値はそのウィンドウのフレームにたいして使用を予想されるフォントが元になる。

@defun window-mode-line-height &optional window
この関数は、@var{window}モードラインの高さをピクセルでリターンする。@var{window}は生きたウィンドウでなければならず、デフォルトは選択されたウィンドウである。@var{window}にモードラインがない場合、リターン値は0である。
@end defun

@defun window-header-line-height &optional window
この関数は、@var{window}のヘッダーラインの高さをピクセルでリターンする。@var{window}は生きたウィンドウでなければならず、デフォルトは選択されたウィンドウである。@var{window}にヘッダーラインがない場合のリターン値は0である。
@end defun

ウィンドウディバイダー(@ref{Window
Dividers}を参照)、フリンジ(@ref{Fringes}を参照)、スクロールバー(@ref{Scroll
Bars}を参照)、ディスプレイマージン(@ref{Display
Margins}を参照)を取得する関数については、対応するセクションで説明されています。

@cindex fixed-size window
@vindex window-min-height
@vindex window-min-width
  ウィンドウのサイズを変更(@ref{Resizing
Windows}を参照)したり、ウィンドウを分割(split)するコマンド(@ref{Splitting
Windows}を参照)は、指定できるウィンドウの最小の高さと幅を指定する変数@code{window-min-height}および@code{window-min-width}にしたがう。これらのコマンドは、ウィンドウのサイズが@dfn{fixed(固定)}になる変数@code{window-size-fixed}にもしたがう。

@defopt window-min-height
このオプションは、任意のウィンドウの最小のトータル高さを行で指定する。この値は最低でも1つのテキスト行、同様にモードライン、ヘッダーライン、(もしあれば)下端ディバイダーに対応する必要がある。
@end defopt

@defopt window-min-width
このオプションは、すべてのウィンドウの最小のトータル幅を列で指定する。この値は、2つのテキスト列、同様に(もしあれば)マージン、フリンジ、スクロールバー、右ディバイダーに対応する必要がある。
@end defopt

@defvar window-size-fixed
このバッファーローカル変数が非@code{nil}の場合、そのバッファーを表示するすべてのウィンドウのサイズが、通常は変更できなくなる。ウィンドウ削除やそのフレームのサイズ変更により、それ以外に方法がなければ、依然としてウィンドウのサイズは変更されるかもしれない。

値が@code{height}の場合は、そのウィンドウの高さだけが固定される。値が@code{width}の場合は、そのウィンドウの幅だけが固定される。その他の非@code{nil}値では、幅と高さの両方が固定される。

この変数が@code{nil}場合でも、そのバッファーを表示している任意のウィンドウを任意の方向にリサイズできるとはいえない。これを決定するには、関数@code{window-resizable}を使用する。@ref{Resizing
Windows}を参照のこと。
@end defvar

以降の関数は、ある特定の大きさのウィンドウにたいして、それの@code{window-min-height}と@code{window-min-width}と@code{window-size-fixed}の値と、領域のサイズを示す。

@defun window-min-size &optional window horizontal ignore pixelwise
この関数は、@var{window}の最小のサイズをリターンする。@var{window}は有効なウィンドウでなければならず、デフォルトは選択されたウィンドウ。オプション引数@var{horizontal}が非@code{nil}の場合は、@var{window}の最小の列数、それ以外は@var{window}の最小の行数をリターンすることを意味する。

このリターン値により、@var{window}のサイズが実際にその値にセットされた場合に、@var{window}のすべてのコンポーネントが完全に可視にとどまることが保証される。@var{horizontal}が@code{nil}の場合は、モードライン、ヘッダーライン、および下端ディバイダーが含まれる。@var{horizontal}が非@code{nil}の場合は、もしあればフリンジ、スクロールバー、右ディバイダーが含まれる。しかしこれには、マージン用に予約済みのスペースは含まれない。

オプション引数@var{ignore}が非@code{nil}の場合は、@code{window-min-height}または@code{window-min-width}によりセットされる固定サイズのウィンドウに強いられる制限を無視することを意味する。@var{ignore}が@code{safe}の場合は、生きたウィンドウは可能な限り小さな@code{window-safe-min-height}の行と、@code{window-safe-min-width}の列を得る。@var{ignore}にウィンドウが指定された場合は、そのウィンドウにたいする制限だけを無視する。その他の非@code{nil}値では、すべてのウィンドウにたいする上記制限のすべてが無視されることを意味する。

オプション引数@var{pixelwise}が非@code{nil}の場合は、@var{window}の最小サイズがピクセルで計数されてリターンされることを意味する。
@end defun

@node Resizing Windows
@section Resizing Windows
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

  このセクションでは、フレームのサイズを変更せずにウィンドウのサイズを変更する関数について説明します。生きたウィンドウはオーバーラップしないので、これらの関数は2つ以上のウィンドウを含む関数上でのみ意味があります(ウィンドウのリサイズにより隣接するウィンドウのサイズも変更される)。フレーム上に単一のウィンドウしか存在しない場合には、フレームの変更以外によりウィンドウのサイズ変更はできません(@ref{Size
and Position}を参照)。

  注記した場合を除き、これらの関数は引数として内部ウィンドウも受け付けます。内部ウィンドウのリサイズにより、同じスペースにフィットするよう、子ウィンドウもリサイズされます。

@defun window-resizable window delta &optional horizontal ignore pixelwise
この関数は、@var{window}のサイズが@var{delta}行により垂直に変更され得る場合は、@var{delta}をリターンする。オプション引数@var{horizontal}が非@code{nil}の場合は、@var{window}が@var{delta}列単位に水平方向にリサイズ可能ならば、かわりに@var{delta}をリターンする。これは、実際にはウィンドウのサイズを変更しない。

@var{window}が@code{nil}の場合のデフォルトは選択されたウィンドウ。

@var{delta}が正の値の場合は、そのウィンドウが行または列の単位で拡張可能かどうかをチェックすることを意味し、@var{delta}が負の値の場合は、そのウィンドウが行または列の単位で縮小可能かどうかをチェックすることを意味する。@var{delta}が非0の場合のリターン値0は、そのウィンドウがリサイズ可能であることを意味する。

通常、変数@code{window-min-height}と@code{window-min-width}は許容される最小のウィンドウサイズを指定する(@ref{Window
Sizes}を参照)。しかし、オプション引数@var{ignore}が非@code{nil}の場合、この関数は@code{window-size-fixed}と同様に@code{window-min-height}と@code{window-min-width}を無視する。そのかわりに、ヘッダーライン、モードライン、(もしあれば)下端ディバイダーに加えて1行分の高さのテキストエリアから構成されるウィンドウを、最小高さのウィンドウとし、フリンジ、マージン、スクロールバー、(もしあれば)右ディバイダーに加えて1列分の幅のテキストエリアから構成されるウィンドウを、最小幅のウィンドウと判断する。

オプション引数@var{pixelwise}が非@code{nil}の場合、@var{delta}はピクセル単位として解釈される。
@end defun

@defun window-resize window delta &optional horizontal ignore pixelwise
この関数は、@var{window}を@var{delta}増加することによりリサイズする。@var{horizontal}が@code{nil}の場合は高さを@var{delta}行、それ以外は幅を@var{delta}行変更する。正の@var{delta}はウィンドウの拡大、負の@var{delta}は縮小を意味する。

@var{window}が@code{nil}の場合のデフォルトは、選択されたウィンドウである。要求されたようにウィンドウをリサイズできない場合は、エラーをシグナルする。

オプション引数@var{ignore}は、上述の関数@code{window-resizable}の場合と同じ意味をもつ。

オプション引数@var{pixelwise}が非@code{nil}の場合、@var{delta}はピクセル単位として解釈される。 

この関数はどのウィンドウのエッジを変更するかの選択は、オプション@code{window-combination-resize}の値と、関連するウィンドウのコンビネーションリミット(combination
limits: 組み合わせ制限)に依存し、両方のエッジを変更するような場合もいくつかある。@ref{Recombining
Windows}を参照のこと。ウィンドウの下端または右端のエッジを移動することだけでリサイズするには、関数@code{adjust-window-trailing-edge}を使用すること。
@end defun

@c The commands enlarge-window, enlarge-window-horizontally,
@c shrink-window, and shrink-window-horizontally are documented in the
@c Emacs manual.  They are not preferred for calling from Lisp.

@defun adjust-window-trailing-edge window delta &optional horizontal pixelwise
この関数は、@var{window}の下端エッジを@var{delta}行分移動する。オプション引数@var{horizontal}が非@code{nil}の場合は、かわりに右端エッジを@var{delta}列分移動する。@var{window}が@code{nil}の場合のデフォルトは、選択されたウィンドウである。

オプション引数@var{pixelwise}が非@code{nil}の場合、@var{delta}はピクセル単位として解釈される。

正の@var{delta}はエッジを下方もしくは右方へ移動し、負の@var{delta}はエッジを上方もしくは左方へ移動する。@var{delta}で指定された範囲までエッジを移動できない場合、この関数はエラーをシグナルすることなく、可能な限りエッジを移動する。

この関数は、移動されたエッジに隣接するウィンドウのリサイズを試みる。何らかの理由(隣接するウィンドウが固定サイズの場合等)により、それが不可能な場合は、他のウィンドウをリサイズするかもしれない。
@end defun

@cindex pixelwise, resizing windows
@defopt window-resize-pixelwise
このオプションの値が非@code{nil}の場合、Emacsはウィンドウをピクセル単位でリサイズする。現在のところ、これは@code{split-window}(@ref{Splitting
Windows}を参照)、@code{maximize-window}、@code{minimize-window}、@code{fit-window-to-buffer}、@code{shrink-window-if-larger-than-buffer}(すべて以下に記述)、および@code{fit-frame-to-buffer}(@ref{Size
and Position}を参照)のような関数に影響を与える。

あるフレームのピクセルサイズがそのフレームの文字サイズの整数倍でないときは、たとえこのオプションが@code{nil}であっても、少なくとも1つのウィンドウがピクセル単位でリサイズされるであろうことに注意されたい。デフォルト値は@code{nil}である。
@end defopt

  以下のコマンドは、より具体的な方法でウィンドウをリサイズします。これらがインタラクティブに呼び出されたときは、選択されたウィンドウにたいして作用します。

@deffn Command fit-window-to-buffer &optional window max-height min-height max-width min-width
このコマンドは、@var{window}の高さまたは幅を、ウィンドウ内のテキストにフィットするように調整する。@var{window}がリサイズできた場合は非@code{nil}、それ以外は@code{nil}をリターンする。@var{window}が省略または@code{nil}の場合のデフォルトは選択されたウィンドウ、それ以外の場合は生きたウィンドウであること。

@var{window}が垂直コンビネーションの一部の場合、この関数は@var{window}の高さを調整する。新たな高さは、そのウィンドウのバッファーのアクセス可能な範囲の実際の高さから計算される。オプション引数@var{max-height}が非@code{nil}の場合、それはこの関数が@var{window}に与えることができる、最大のトータル高さを指定する。オプション引数@var{min-height}が非@code{nil}の場合、それは与えることができる最小のトータル高さを指定し、それは変数@code{window-min-height}をオーバーライドする。@var{max-height}と@var{min-height}はどちらも、(もしあれば)モードライン、ヘッダーライン、下端ディバイダーを含む行数で指定する。

@var{window}が水平コンビネーションの一部で、かつオプション@code{fit-window-to-buffer-horizontally}(以下参照)の値が非@code{nil}の場合、この関数は@var{window}の幅を調整する。新たな幅は、@var{window}のカレントのスタート位置以降の、バッファーの最長の行から計算される。オプション引数@var{max-width}は最大幅を指定し、デフォルトは@var{window}のフレーム幅である。オプション引数@var{min-width}は最小幅を指定し、デフォルトは@code{window-min-width}である。@var{max-width}と@var{min-width}はどちらも、(もしあれば)フリンジ、マージン、スクロールバーを含む列数で指定する。

オプション@code{fit-frame-to-buffer}(以下参照)が非@code{nil}の場合、この関数は@code{fit-frame-to-buffer}(@pxref{Size
and
Position})を呼び出すことにより、@var{window}のコンテンツにフィットするように、@var{window}のフレームのリサイズを試みるだろう。
@end deffn

@defopt fit-window-to-buffer-horizontally
これが非@code{nil}の場合、@code{fit-window-to-buffer}はウィンドウを水平方向にリサイズできる。これが@code{nil}(デフォルト)の場合、@code{fit-window-to-buffer}はウィンドウウィンドウ決して水平方向にリサイズしない。これが@code{only}の場合は、ウィンドウを水平方向だけにリサイズできる。その他の値では、@code{fit-window-to-buffer}がウィンドウをどちらの方向にもリサイズできることを意味する。
@end defopt

@defopt fit-frame-to-buffer
このオプションが非@code{nil}の場合、@code{fit-window-to-buffer}はフレームをフレームのコンテンツにフィットさせることができる。フレームは、フレームのルートウィンドウが生きたウィンドウで、かつこのオプションが非@code{nil}の場合のみ、フィットされる。これが@code{horizontally}の場合、フレームは水平方向にのみフィットされる。これが@code{vertically}の場合、フレームは垂直方向にのみフィットされる。その他の非@code{nil}値は、フレームがどちらの方向にもフィットできることを意味する。
@end defopt

@deffn Command shrink-window-if-larger-than-buffer &optional window
このコマンドは、@var{window}にたいしてそのバッファーを完全に表示できるが、@code{window-min-height}以上の行を表示できるまで、可能な限り@var{window}の高さを縮小する。リターン値は、そのウィンドウがリサイズされれば非@code{nil}、それ以外は非@code{nil}。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。それ以外では、生きたウィンドウであること。

このコマンドは、そのウィンドウがバッファーのすべてを表示するにはすでに高さが低すぎる場合、バッファーのどこかがスクリーンからスクロールオフされている場合、またはそのウィンドウがフレーム内で唯一の生きたウィンドウの場合は何も行わない。

このコマンドは、自身の処理を行うために、@code{fit-window-to-buffer}(上記参照)を呼び出す。
@end deffn


@cindex balancing window sizes
@deffn Command balance-windows &optional window-or-frame
この関数は、各ウィンドウにたいして完全な幅、および/または完全な高さを与えるような方法により、各ウィンドウのバランスをとる。@var{window-or-frame}にフレームを指定した場合は、そのフレーム上のすべてのウィンドウのバランスをとる。@var{window-or-frame}にウィンドウを指定した場合は、そのウィンドウとウィンドウのsiblings(兄弟)にたいしてのみのバランスをとる(@ref{Windows
and Frames}を参照)。
@end deffn

@deffn Command balance-windows-area
この関数は、選択されたフレーム上のすべてのウィンドウにたいして、おおよそ同じスクリーンエリアを与えようと試みる。完全な幅、または高さをもつウィンドウにたいしては、他のウィンドウと比較して、より多くのスペースは与えられない。
@end deffn

@cindex maximizing windows
@deffn Command maximize-window &optional window
この関数は、@var{window}にたいして、そのフレームをリサイズしたり、他のウィンドウを削除することなく、水平垂直の両方向において、可能な限り大きくなるように試みる。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。
@end deffn

@cindex minimizing windows
@deffn Command minimize-window &optional window
この関数は、@var{window}にたいして、そのフレームをリサイズしたり、そのウィンドウを削除することなく、水平垂直の両方向において、可能な限り小さくなるように試みる。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。
@end deffn


@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

このセクションでは、既存のウィンドウを@dfn{分割(split: スプリット}することにより、新たにウィンドウを作成する関数について説明します。

@defun split-window &optional window size side pixelwise
この関数は、ウィンドウ@var{window}の隣に、新たに生きたウィンドウを作成する。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。そのウィンドウは``分割(split)''されて、サイズは縮小される。そのスペースは、リターンされる新たなウィンドウにより吸収される。

オプションの第2引数@var{size}は、@var{window}および/または新たなウィンドウのサイズを決定する。これが省略または@code{nil}の場合は、両方のウィンドウに同じサイズが割り当てられる。行数が奇数の場合、余りの1行は新たなウィンドウに割り当てられる。@var{size}が正の数値の場合、@var{window}に@var{size}の行数(@var{side}の値によっては列数)が与えられる。@var{size}が負の数値の場合、新たなウィンドウに@minus{}@var{size}の行数(または列数)が与えられる。

@var{size}が@code{nil}の場合、この関数は変数@code{window-min-height}と@code{window-min-width}にしたがう(@ref{Window
Sizes}を参照)。つまり、分割によりこれらの変数の指定より小さいウィンドウが作成されるようなときは、エラーをシグナルする。しかし、@var{size}にたいして非@code{nil}値を指定すれば、これらの変数は無視される。その場合、許容される最小のウィンドウは、テキストエリアの高さが1行、および/または幅が2列のウィンドウであるとされる。

したがって、@var{size}が指定された場合、生成されるウィンドウがモードラインやスクロールバー等すべてのエリアを含むのに十分な大きさがあるかどうかチェックするのは、呼び出し側の責任である。これに関して、必要最小限の@var{window}を決定するために、関数@code{window-min-size}(@ref{Window
Sizes}を参照)を使用できる。新たなウィンドウは通常、モードラインやスクロールバー等のエリアを@var{window}から``継承''するので、この関数は新たなウィンドウの最小サイズも良好に推定する。呼び出し側は、次回の再表示前にこれに応じて継承されたエリアを削除する場合のみ、より小さなサイズを指定すること。

オプションの第3引数@var{side}は、新たなウィンドウの位置を@var{window}から相対的に指定する。@code{nil}または@code{below}の場合、新たなウィンドウは@var{window}の下に、@code{above}の場合は@var{window}の上に配される。どちらの場合も、@var{size}はウィンドウのトータル高さを行数で指定する。

@var{side}が@code{t}または@code{right}の場合、新たなウィンドウは@var{window}の右に、@var{side}が@code{left}の場合は@var{window}の左に配される。どちらの場合も、@var{size}はウィンドウのトータル幅を列数で指定する。

オプションの第4引数@var{pixelwise}が非@code{nil}の場合は、@var{size}を行や列ではなくピクセル単位で解釈することを意味する。

@var{window}が生きたウィンドウの場合、新たなウィンドウはマージンやスクロールバーを含む、さまざまなプロパティを継承する。@var{window}が内部ウィンドウ(internal
window)の場合、新たなウィンドウは@var{window}のフレームのプロパティを継承する。

変数@code{ignore-window-parameters}が@code{nil}の場合に限り、この関数の挙動は@var{window}なパラメーターにより変更されるかもしれない。ウィンドウパラメーター@code{split-window}の値が@code{t}の場合、この関数はその他すべてのウィンドウパラメーターを無視する。それ以外では、ウィンドウパラメーター@code{split-window}の値が関数の場合は、@code{split-window}の通常アクションのかわりに、引数@var{window}、@var{size}、@var{side}でその関数が呼び出される。値が関数以外の場合、この関数は(もしあれば)ウィンドウパラメーター@code{window-atom}または@code{window-side}にしたがう。@ref{Window
Parameters}を参照のこと。
@end defun

  例として、@ref{Windows and Frames}で議論したウィンドウ構成(window
configuration)を得るための、一連の@code{split-window}呼び出しを以下に挙げます。この例では、生きたウィンドウの分割と、内部ウィンドウの分割も示します。最初は@var{W4}で表される、単一のウィンドウ(生きたルートウィンドウ)を含むフレームから開始します。@code{(split-window
W4)}を呼び出すことにより、以下のウィンドウ構成が得られます。

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

@noindent
@code{split-window}呼び出しにより、@var{W5}で示す生きたウィンドウが新たに作成されました。@var{W3}で示される内部ウィンドウも新たに作成され、これはルートウィンドウかつ@var{W4}と@var{W5}の親ウィンドウになります。

  次は、引数として内部ウィンドウ@var{W3}を渡して、@code{(split-window W3 nil 'left)}を呼び出します。

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|
@end group
@end smallexample

@noindent
内部ウィンドウ@var{W3}の左に、生きたウィンドウ@var{W2}が新たに作成されました。そして、内部ウィンドウ@var{W1}が新たに作成され、これが新たにルートウィンドウになります。

   インタラクティブな使用にたいして、Emacsは選択されたウィンドウを常に分割するコマンドを2つ提供します。これらは内部で@code{split-window}を呼び出します。

@deffn Command split-window-right &optional size
この関数は、選択されたウィンドウが左となるような、横並びの2つのウィンドウに分割する。@var{size}が正ならば左のウィンドウが@var{size}列、負ならば右のウィンドウが@minus{}@var{size}列を与えられる。
@end deffn

@deffn Command split-window-below &optional size
この関数は、選択されたウィンドウが上となるような、縦並びの2つのウィンドウに分割する。@var{size}が正ならば上のウィンドウが@var{size}行、負ならば下のウィンドウが@minus{}@var{size}行を与えられる。
@end deffn

@defopt split-window-keep-point
この変数の値が非@code{nil}(デフォルト)なら、 @code{split-window-below}は上述のように振る舞う。

@code{nil}の場合、@code{split-window-below}は再表示が最小となるように、2つのウィンドウの各ポイントを調節する(これは低速な端末で有用である)。これは何であれ、以前ポイントがあったスクリーン行(screen
line)を含むウィンドウを選択する。これは低レベル@code{split-window}関数ではなく、@code{split-window-below}だけに影響することに注意。
@end defopt

@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

  ウィンドウを@dfn{削除(delete)}することにより、フレームのウィンドウツリーからウィンドウが取り除かれます。それが生きたウィンドウの場合は、スクリーンに表示されなくなります。内部ウィンドウの場合は、その子ウィンドウも削除されます。

  ウィンドウを削除した後でも、それへの参照が残っている限り、Lispオブジェクトとして存在し続けます。ウィンドウ構成(window
configuration)をリストアすることにより、ウィンドウの削除は取り消すことができます(@ref{Window
Configurations}を参照)。

@deffn Command delete-window &optional window
この関数は、表示から@var{window}を削除して、@code{nil}をリターンする。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。そのウィンドウを削除するとウィンドウツリーにウィンドウが存在しなくなるような場合(それがフレーム内で唯一の生きたウィンドウである場合等)は、エラーをシグナルする。

デフォルトでは、@var{window}が占めていたスペースは、(もしあれば)隣接する兄弟ウィンドウのうちの1つに与えられる。しかし、変数@code{window-combination-resize}が非@code{nil}の場合、そのスペースはウィンドウコンビネーション内の残りのすべてのウィンドウに比例的に分配される。@xref{Recombining
Windows}を参照のこと。

変数@code{ignore-window-parameters}が@code{nil}の場合に限り、この関数の振る舞いは@var{window}のウィンドウパラメーターにより変更される可能性がある。ウィンドウパラメーター@code{delete-window}の値が@code{t}の場合、この関数はその他すべてのウィンドウパラメーターを無視する。ウィンドウパラメーター@code{delete-window}が関数の場合は、通常の@code{delete-window}のかわりに、引数@var{window}でその関数が呼び出される。それ以外では、この関数は(もしあれば)ウィンドウパラメーター@code{window-atom}または@code{window-side}にしたがう。@ref{Window
Parameters}を参照のこと。
@end deffn

@deffn Command delete-other-windows &optional window
この関数は、必要に応じて他のウィンドウを削除することにより、@var{window}でフレームを充填する。@var{window}が省略または@code{nil}の場合のデフォルトは、選択されたウィンドウである。リターン値は@code{nil}。

変数@code{ignore-window-parameters}が@code{nil}の場合に限り、この関数の振る舞いは変更される可能性がある。ウィンドウパラメーター@code{delete-other-windows}の値が@code{t}の場合、この関数は他のすべてのウィンドウパラメーターを無視する。ウィンドウパラメーター@code{delete-other-windows}の値が関数の場合は、@code{delete-other-windows}の通常の動作のかわりに、引数@var{window}でその関数が呼び出される。それ以外では、この関数は(もしあれば)ウィンドウパラメーター@code{window-atom}または@code{window-side}にしたがう。@ref{Window
Parameters}を参照のこと。
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
この関数は、@var{buffer-or-name}を表示しているすべてのウィンドウにたいして@code{delete-window}を呼び出すことにより、それらを削除する。@var{buffer-or-name}はバッファー、またはバッファー名であること。省略または@code{nil}の場合のデフォルトはカレントバッファーである。指定されたバッファーを表示するウィンドウが存在しない場合、この関数は何も行わない。ミニバッファーが指定された場合は、エラーをシグナルする。

そのバッファーの表示専用のウィンドウがあり、フレーム上でそれが唯一のウィンドウの場合、それが端末上で唯一のフレームでなければ、この関数はそのフレームも削除する。

オプション引数@var{frame}は、操作を行うフレームがどれかを指定する:

@itemize @bullet
@item @code{nil}
すべてのフレームを処理することを意味する。
@item @code{t}
選択されたフレームを処理することを意味する。
@item @code{visible}
可視なすべてのフレームを処理することを意味する。
@item @code{0}
可視またはアイコン化されたすべてのフレームを処理することを意味する。
@item フレーム
そのフレームを処理することを意味する。
@end itemize

この引数の意味は、すべての生きたウィンドウを走査する他の関数(@ref{Cyclic Window
Ordering}を参照)における場合とは異なることに注意。特に、ここでの@code{t}と@code{nil}のもつ意味は、これら他の関数の場合とは逆である。
@end deffn


@node Recombining Windows
@section Recombining Windows
@cindex recombining windows
@cindex windows, recombining

When deleting the last sibling of a window @var{W}, its parent window is
deleted too, with @var{W} replacing it in the window tree.  This means that
@var{W} must be recombined with its parent's siblings to form a new window
combination (@pxref{Windows and Frames}).  In some occasions, deleting a
live window may even entail the deletion of two internal windows.

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||____W6_____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Deleting @var{W5} in this configuration normally causes the deletion of
@var{W3} and @var{W4}.  The remaining live windows @var{W2}, @var{W6} and
@var{W7} are recombined to form a new horizontal combination with parent
@var{W1}.

   Sometimes, however, it makes sense to not delete a parent window like
@var{W4}.  In particular, a parent window should not be removed when it was
used to preserve a combination embedded in a combination of the same type.
Such embeddings make sense to assure that when you split a window and
subsequently delete the new window, Emacs reestablishes the layout of the
associated frame as it existed before the splitting.

   Consider a scenario starting with two live windows @var{W2} and @var{W3} and
their parent @var{W1}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Split @var{W2} to make a new window @var{W4} as follows.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Now, when enlarging a window vertically, Emacs tries to obtain the
corresponding space from its lower sibling, provided such a window exists.
In our scenario, enlarging @var{W4} will steal space from @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Deleting @var{W4} will now give its entire space to @var{W2}, including the
space earlier stolen from @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
This can be counterintuitive, in particular if @var{W4} were used for
displaying a buffer only temporarily (@pxref{Temporary Displays}), and you
want to continue working with the initial layout.

The behavior can be fixed by making a new parent window when splitting
@var{W2}.  The variable described next allows to do that.

@defopt window-combination-limit
This variable controls whether splitting a window shall make a new parent
window.  The following values are recognized:

@table @code
@item nil
This means that the new live window is allowed to share the existing parent
window, if one exists, provided the split occurs in the same direction as
the existing window combination (otherwise, a new internal window is created
anyway).

@item window-size
In this case @code{display-buffer} makes a new parent window if it is passed
a @code{window-height} or @code{window-width} entry in the @var{alist}
argument (@pxref{Display Action Functions}).

@item temp-buffer
This value causes the creation of a new parent window when a window is split
for showing a temporary buffer (@pxref{Temporary Displays}) only.

@item display-buffer
This means that when @code{display-buffer} (@pxref{Choosing Window})  splits
a window it always makes a new parent window.

@item t
In this case a new parent window is always created when splitting a window.
Thus, if the value of this variable is at all times @code{t}, then at all
times every window tree is a binary tree (a tree where each window except
the root window has exactly one sibling).
@end table

The default is @code{nil}.  Other values are reserved for future use.

If, as a consequence of this variable's setting, @code{split-window} makes a
new parent window, it also calls @code{set-window-combination-limit} (see
below) on the newly-created internal window.  This affects how the window
tree is rearranged when the child windows are deleted (see below).
@end defopt

  If @code{window-combination-limit} is @code{t}, splitting @var{W2} in the
initial configuration of our scenario would have produced this:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||                                  |||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
A new internal window @var{W5} has been created; its children are @var{W2}
and the new live window @var{W4}.  Now, @var{W2} is the only sibling of
@var{W4}, so enlarging @var{W4} will try to shrink @var{W2}, leaving
@var{W3} unaffected.  Observe that @var{W5} represents a vertical
combination of two windows embedded in the vertical combination @var{W1}.

@cindex window combination limit
@defun set-window-combination-limit window limit
This function sets the @dfn{combination limit} of the window @var{window} to
@var{limit}.  This value can be retrieved via the function
@code{window-combination-limit}.  See below for its effects; note that it is
only meaningful for internal windows.  The @code{split-window} function
automatically calls this function, passing it @code{t} as @var{limit},
provided the value of the variable @code{window-combination-limit} is
@code{t} when it is called.
@end defun

@defun window-combination-limit window
This function returns the combination limit for @var{window}.

The combination limit is meaningful only for an internal window.  If it is
@code{nil}, then Emacs is allowed to automatically delete @var{window}, in
response to a window deletion, in order to group the child windows of
@var{window} with its sibling windows to form a new window combination.  If
the combination limit is @code{t}, the child windows of @var{window} are
never automatically recombined with its siblings.

If, in the configuration shown at the beginning of this section, the
combination limit of @var{W4} (the parent window of @var{W6} and @var{W7})
is @code{t}, deleting @var{W5} will not implicitly delete @var{W4} too.
@end defun

Alternatively, the problems sketched above can be avoided by always resizing
all windows in the same combination whenever one of its windows is split or
deleted.  This also permits to split windows that would be otherwise too
small for such an operation.

@defopt window-combination-resize
If this variable is @code{nil}, @code{split-window} can only split a window
(denoted by @var{window}) if @var{window}'s screen area is large enough to
accommodate both itself and the new window.

If this variable is @code{t}, @code{split-window} tries to resize all
windows that are part of the same combination as @var{window}, in order to
accommodate the new window.  In particular, this may allow
@code{split-window} to succeed even if @var{window} is a fixed-size window
or too small to ordinarily split.  Furthermore, subsequently resizing or
deleting @var{window} may resize all other windows in its combination.

The default is @code{nil}.  Other values are reserved for future use.  The
value of this variable is ignored when @code{window-combination-limit} is
non-@code{nil}.
@end defopt

  To illustrate the effect of @code{window-combination-resize}, consider the
following frame layout.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
If @code{window-combination-resize} is @code{nil}, splitting window @var{W3}
leaves the size of @var{W2} unchanged:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
If @code{window-combination-resize} is @code{t}, splitting @var{W3} instead
leaves all three live windows with approximately the same height:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Deleting any of the live windows @var{W2}, @var{W3} or @var{W4} will
distribute its space proportionally among the two remaining live windows.


@node Selecting Windows
@section Selecting Windows
@cindex selecting a window

@defun select-window window &optional norecord
This function makes @var{window} the selected window and the window selected
within its frame (@pxref{Basic Windows}) and selects that frame.  It also
makes @var{window}'s buffer (@pxref{Buffers and Windows}) current and sets
that buffer's value of @code{point} to the value of @code{window-point}
(@pxref{Window Point}) in @var{window}.  @var{window} must be a live
window.  The return value is @var{window}.

By default, this function also moves @var{window}'s buffer to the front of
the buffer list (@pxref{Buffer List}), and makes @var{window} the most
recently selected window.  However, if the optional argument @var{norecord}
is non-@code{nil}, these additional actions are omitted.

This function runs @code{buffer-list-update-hook} (@pxref{Buffer List})
unless @var{norecord} is non-@code{nil}.  Note that applications and
internal routines often temporarily select a window in order to simplify
coding.  As a rule, such selections (including those made by the macros
@code{save-selected-window} and @code{with-selected-window} below) are not
recorded thus avoiding to pollute @code{buffer-list-update-hook}.
Selections that ``really count'' are those causing a visible change in the
next redisplay of @var{window}'s frame and should be always recorded.  This
also means that to run a function each time a window gets selected, putting
it on @code{buffer-list-update-hook} should be the right choice.
@end defun

@cindex most recently selected windows
  The sequence of calls to @code{select-window} with a non-@code{nil}
@var{norecord} argument determines an ordering of windows by their selection
time.  The function @code{get-lru-window} can be used to retrieve the least
recently selected live window (@pxref{Cyclic Window Ordering}).

@defmac save-selected-window forms@dots{}
This macro records the selected frame, as well as the selected window of
each frame, executes @var{forms} in sequence, then restores the earlier
selected frame and windows.  It also saves and restores the current buffer.
It returns the value of the last form in @var{forms}.

This macro does not save or restore anything about the sizes, arrangement or
contents of windows; therefore, if @var{forms} change them, the change
persists.  If the previously selected window of some frame is no longer live
at the time of exit from @var{forms}, that frame's selected window is left
alone.  If the previously selected window is no longer live, then whatever
window is selected at the end of @var{forms} remains selected.  The current
buffer is restored if and only if it is still live when exiting @var{forms}.

This macro changes neither the ordering of recently selected windows nor the
buffer list.
@end defmac

@defmac with-selected-window window forms@dots{}
This macro selects @var{window}, executes @var{forms} in sequence, then
restores the previously selected window and current buffer.  The ordering of
recently selected windows and the buffer list remain unchanged unless you
deliberately change them within @var{forms}; for example, by calling
@code{select-window} with argument @var{norecord} @code{nil}.

This macro does not change the order of recently selected windows or the
buffer list.
@end defmac

@defun frame-selected-window &optional frame
This function returns the window on @var{frame} that is selected within that
frame.  @var{frame} should be a live frame; if omitted or @code{nil}, it
defaults to the selected frame.
@end defun

@defun set-frame-selected-window frame window &optional norecord
This function makes @var{window} the window selected within the frame
@var{frame}.  @var{frame} should be a live frame; if @code{nil}, it defaults
to the selected frame.  @var{window} should be a live window; if @code{nil},
it defaults to the selected window.

If @var{frame} is the selected frame, this makes @var{window} the selected
window.

If the optional argument @var{norecord} is non-@code{nil}, this function
does not alter the list of most recently selected windows, nor the buffer
list.
@end defun

@node Cyclic Window Ordering
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

  When you use the command @kbd{C-x o} (@code{other-window}) to select some
other window, it moves through live windows in a specific order.  For any
given configuration of windows, this order never varies.  It is called the
@dfn{cyclic ordering of windows}.

  The ordering is determined by a depth-first traversal of the frame's window
tree, retrieving the live windows which are the leaf nodes of the tree
(@pxref{Windows and Frames}).  If the minibuffer is active, the minibuffer
window is included too.  The ordering is cyclic, so the last window in the
sequence is followed by the first one.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
This function returns a live window, the one following @var{window} in the
cyclic ordering of windows.  @var{window} should be a live window; if
omitted or @code{nil}, it defaults to the selected window.

The optional argument @var{minibuf} specifies whether minibuffer windows
should be included in the cyclic ordering.  Normally, when @var{minibuf} is
@code{nil}, a minibuffer window is included only if it is currently
``active''; this matches the behavior of @kbd{C-x o}.  (Note that a
minibuffer window is active as long as its minibuffer is in use; see
@ref{Minibuffers}).

If @var{minibuf} is @code{t}, the cyclic ordering includes all minibuffer
windows.  If @var{minibuf} is neither @code{t} nor @code{nil}, minibuffer
windows are not included even if they are active.

The optional argument @var{all-frames} specifies which frames to consider:

@itemize @bullet
@item @code{nil}
means to consider windows on @var{window}'s frame.  If the minibuffer window
is considered (as specified by the @var{minibuf} argument), then frames that
share the minibuffer window are considered too.

@item @code{t}
means to consider windows on all existing frames.

@item @code{visible}
means to consider windows on all visible frames.

@item 0
means to consider windows on all visible or iconified frames.

@item フレーム
means to consider windows on that specific frame.

@item Anything else
means to consider windows on @var{window}'s frame, and no others.
@end itemize

If more than one frame is considered, the cyclic ordering is obtained by
appending the orderings for those frames, in the same order as the list of
all live frames (@pxref{Finding All Frames}).
@end defun

@defun previous-window &optional window minibuf all-frames
This function returns a live window, the one preceding @var{window} in the
cyclic ordering of windows.  The other arguments are handled like in
@code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
This function selects a live window, one @var{count} places from the
selected window in the cyclic ordering of windows.  If @var{count} is a
positive number, it skips @var{count} windows forwards; if @var{count} is
negative, it skips @minus{}@var{count} windows backwards; if @var{count} is
zero, that simply re-selects the selected window.  When called
interactively, @var{count} is the numeric prefix argument.

The optional argument @var{all-frames} has the same meaning as in
@code{next-window}, like a @code{nil} @var{minibuf} argument to
@code{next-window}.

This function does not select a window that has a non-@code{nil}
@code{no-other-window} window parameter (@pxref{Window Parameters}).
@end deffn

@defun walk-windows fun &optional minibuf all-frames
This function calls the function @var{fun} once for each live window, with
the window as the argument.

It follows the cyclic ordering of windows.  The optional arguments
@var{minibuf} and @var{all-frames} specify the set of windows included;
these have the same arguments as in @code{next-window}.  If @var{all-frames}
specifies a frame, the first window walked is the first window on that frame
(the one returned by @code{frame-first-window}), not necessarily the
selected window.

If @var{fun} changes the window configuration by splitting or deleting
windows, that does not alter the set of windows walked, which is determined
prior to calling @var{fun} for the first time.
@end defun

@defun one-window-p &optional no-mini all-frames
This function returns @code{t} if the selected window is the only live
window, and @code{nil} otherwise.

If the minibuffer window is active, it is normally considered (so that this
function returns @code{nil}).  However, if the optional argument
@var{no-mini} is non-@code{nil}, the minibuffer window is ignored even if
active.  The optional argument @var{all-frames} has the same meaning as for
@code{next-window}.
@end defun

@cindex finding windows
  The following functions return a window which satisfies some criterion,
without selecting it:

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated not-selected
This function returns a live window which is heuristically the ``least
recently used'' window.  The optional argument @var{all-frames} has the same
meaning as in @code{next-window}.

If any full-width windows are present, only those windows are considered.  A
minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.  The selected window is never
returned, unless it is the only candidate.  However, if the optional
argument @var{not-selected} is non-@code{nil}, this function returns
@code{nil} in that case.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated not-selected
This function returns the window with the largest area (height times
width).  The optional argument @var{all-frames} specifies the windows to
search, and has the same meaning as in @code{next-window}.

A minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.  The selected window is not a
candidate if the optional argument @var{not-selected} is non-@code{nil}.  If
the optional argument @var{not-selected} is non-@code{nil} and the selected
window is the only candidate, this function returns @code{nil}.

If there are two candidate windows of the same size, this function prefers
the one that comes first in the cyclic ordering of windows, starting from
the selected window.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
This function calls the function @var{predicate} for each of the windows in
the cyclic order of windows in turn, passing it the window as an argument.
If the predicate returns non-@code{nil} for any window, this function stops
and returns that window.  If no such window is found, the return value is
@var{default} (which defaults to @code{nil}).

The optional arguments @var{minibuf} and @var{all-frames} specify the
windows to search, and have the same meanings as in @code{next-window}.
@end defun


@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  This section describes low-level functions for examining and setting the
contents of windows.  @xref{Switching Buffers}, for higher-level functions
for displaying a specific buffer in a window.

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  If
@var{window} is omitted or @code{nil} it defaults to the selected window.
If @var{window} is an internal window, this function returns @code{nil}.
@end defun

@defun set-window-buffer window buffer-or-name &optional keep-margins
This function makes @var{window} display @var{buffer-or-name}.  @var{window}
should be a live window; if @code{nil}, it defaults to the selected window.
@var{buffer-or-name} should be a buffer, or the name of an existing buffer.
This function does not change which window is selected, nor does it directly
change which buffer is current (@pxref{Current Buffer}).  Its return value
is @code{nil}.

If @var{window} is @dfn{strongly dedicated} to a buffer and
@var{buffer-or-name} does not specify that buffer, this function signals an
error.  @xref{Dedicated Windows}.

By default, this function resets @var{window}'s position, display margins,
fringe widths, and scroll bar settings, based on the local variables in the
specified buffer.  However, if the optional argument @var{keep-margins} is
non-@code{nil}, it leaves the display margins and fringe widths unchanged.

When writing an application, you should normally use the higher-level
functions described in @ref{Switching Buffers}, instead of calling
@code{set-window-buffer} directly.

This runs @code{window-scroll-functions}, followed by
@code{window-configuration-change-hook}.  @xref{Window Hooks}.
@end defun

@defvar buffer-display-count
This buffer-local variable records the number of times a buffer has been
displayed in a window.  It is incremented each time @code{set-window-buffer}
is called for the buffer.
@end defvar

@defvar buffer-display-time
This buffer-local variable records the time at which a buffer was last
displayed in a window.  The value is @code{nil} if the buffer has never been
displayed.  It is updated each time @code{set-window-buffer} is called for
the buffer, with the value returned by @code{current-time} (@pxref{Time of
Day}).
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
This function returns the first window displaying @var{buffer-or-name} in
the cyclic ordering of windows, starting from the selected window
(@pxref{Cyclic Window Ordering}).  If no such window exists, the return
value is @code{nil}.

@var{buffer-or-name} should be a buffer or the name of a buffer; if omitted
or @code{nil}, it defaults to the current buffer.  The optional argument
@var{all-frames} specifies which windows to consider:

@itemize @bullet
@item
@code{t} means consider windows on all existing frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@item
Any other value means consider windows on the selected frame.
@end itemize

Note that these meanings differ slightly from those of the @var{all-frames}
argument to @code{next-window} (@pxref{Cyclic Window Ordering}).  This
function may be changed in a future version of Emacs to eliminate this
discrepancy.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
This function returns a list of all windows currently displaying
@var{buffer-or-name}.  @var{buffer-or-name} should be a buffer or the name
of an existing buffer.  If omitted or @code{nil}, it defaults to the current
buffer.

The arguments @var{minibuf} and @var{all-frames} have the same meanings as
in the function @code{next-window} (@pxref{Cyclic Window Ordering}).  Note
that the @var{all-frames} argument does @emph{not} behave exactly like in
@code{get-buffer-window}.
@end defun

@deffn Command replace-buffer-in-windows &optional buffer-or-name
This command replaces @var{buffer-or-name} with some other buffer, in all
windows displaying it.  @var{buffer-or-name} should be a buffer, or the name
of an existing buffer; if omitted or @code{nil}, it defaults to the current
buffer.

The replacement buffer in each window is chosen via
@code{switch-to-prev-buffer} (@pxref{Window History}).  Any dedicated window
displaying @var{buffer-or-name} is deleted if possible (@pxref{Dedicated
Windows}).  If such a window is the only window on its frame and there are
other frames on the same terminal, the frame is deleted as well.  If the
dedicated window is the only window on the only frame on its terminal, the
buffer is replaced anyway.
@end deffn


@node Switching Buffers
@section Switching to a Buffer in a Window
@cindex switching to a buffer
@cindex displaying a buffer

This section describes high-level functions for switching to a specified
buffer in some window.  In general, ``switching to a buffer'' means to (1)
show the buffer in some window, (2) make that window the selected window
(and its frame the selected frame), and (3) make the buffer the current
buffer.

  Do @emph{not} use these functions to make a buffer temporarily current just
so a Lisp program can access or modify it.  They have side-effects, such as
changing window histories (@pxref{Window History}), which will surprise the
user if used that way.  If you want to make a buffer current to modify it in
Lisp, use @code{with-current-buffer}, @code{save-current-buffer}, or
@code{set-buffer}.  @xref{Current Buffer}.

@deffn Command switch-to-buffer buffer-or-name &optional norecord force-same-window
This command attempts to display @var{buffer-or-name} in the selected window
and make it the current buffer.  It is often used interactively (as the
binding of @kbd{C-x b}), as well as in Lisp programs.  The return value is
the buffer switched to.

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer returned by
@code{other-buffer} (@pxref{Buffer List}).  If @var{buffer-or-name} is a
string that is not the name of any existing buffer, this function creates a
new buffer with that name; the new buffer's major mode is determined by the
variable @code{major-mode} (@pxref{Major Modes}).

Normally, the specified buffer is put at the front of the buffer list---both
the global buffer list and the selected frame's buffer list (@pxref{Buffer
List}).  However, this is not done if the optional argument @var{norecord}
is non-@code{nil}.

Sometimes, @code{switch-to-buffer} may be unable to display the buffer in
the selected window.  This happens if the selected window is a minibuffer
window, or if the selected window is strongly dedicated to its buffer
(@pxref{Dedicated Windows}).  In that case, the command normally tries to
display the buffer in some other window, by invoking @code{pop-to-buffer}
(see below).  However, if the optional argument @var{force-same-window} is
non-@code{nil}, it signals an error instead.
@end deffn

By default, @code{switch-to-buffer} shows the buffer at its position of
@code{point}.  This behavior can be tuned using the following option.

@defopt switch-to-buffer-preserve-window-point
If this variable is @code{nil}, @code{switch-to-buffer} displays the buffer
specified by @var{buffer-or-name} at the position of that buffer's
@code{point}.  If this variable is @code{already-displayed}, it tries to
display the buffer at its previous position in the selected window, provided
the buffer is currently displayed in some other window on any visible or
iconified frame.  If this variable is @code{t}, @code{switch-to-buffer}
unconditionally tries to display the buffer at its previous position in the
selected window.

This variable is ignored if the buffer is already displayed in the selected
window or never appeared in it before, or if @code{switch-to-buffer} calls
@code{pop-to-buffer} to display the buffer.
@end defopt

The next two commands are similar to @code{switch-to-buffer}, except for the
described features.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
This function displays the buffer specified by @var{buffer-or-name} in some
window other than the selected window.  It uses the function
@code{pop-to-buffer} internally (see below).

If the selected window already displays the specified buffer, it continues
to do so, but another window is nonetheless found to display it as well.

The @var{buffer-or-name} and @var{norecord} arguments have the same meanings
as in @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
This function displays the buffer specified by @var{buffer-or-name} in a new
frame.  It uses the function @code{pop-to-buffer} internally (see below).

If the specified buffer is already displayed in another window, in any frame
on the current terminal, this switches to that window instead of creating a
new frame.  However, the selected window is never used for this.

The @var{buffer-or-name} and @var{norecord} arguments have the same meanings
as in @code{switch-to-buffer}.
@end deffn

The above commands use the function @code{pop-to-buffer}, which flexibly
displays a buffer in some window and selects that window for editing.  In
turn, @code{pop-to-buffer} uses @code{display-buffer} for displaying the
buffer.  Hence, all the variables affecting @code{display-buffer} will
affect it as well.  @xref{Choosing Window}, for the documentation of
@code{display-buffer}.

@deffn Command pop-to-buffer buffer-or-name &optional action norecord
This function makes @var{buffer-or-name} the current buffer and displays it
in some window, preferably not the window previously selected.  It then
selects the displaying window.  If that window is on a different graphical
frame, that frame is given input focus if possible (@pxref{Input Focus}).
The return value is the buffer that was switched to.

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer returned by
@code{other-buffer} (@pxref{Buffer List}).  If @var{buffer-or-name} is a
string that is not the name of any existing buffer, this function creates a
new buffer with that name; the new buffer's major mode is determined by the
variable @code{major-mode} (@pxref{Major Modes}).

If @var{action} is non-@code{nil}, it should be a display action to pass to
@code{display-buffer} (@pxref{Choosing Window}).  Alternatively, a
non-@code{nil}, non-list value means to pop to a window other than the
selected one---even if the buffer is already displayed in the selected
window.

Like @code{switch-to-buffer}, this function updates the buffer list unless
@var{norecord} is non-@code{nil}.
@end deffn


@node Choosing Window
@section Choosing a Window for Display

  The command @code{display-buffer} flexibly chooses a window for display, and
displays a specified buffer in that window.  It can be called interactively,
via the key binding @kbd{C-x 4 C-o}.  It is also used as a subroutine by
many functions and commands, including @code{switch-to-buffer} and
@code{pop-to-buffer} (@pxref{Switching Buffers}).

@cindex display action
@cindex action function, for @code{display-buffer}
@cindex action alist, for @code{display-buffer}
  This command performs several complex steps to find a window to display in.
These steps are described by means of @dfn{display actions}, which have the
form @code{(@var{function} . @var{alist})}.  Here, @var{function} is either
a function or a list of functions, which we refer to as @dfn{action
functions}; @var{alist} is an association list, which we refer to as
@dfn{action alists}.

  An action function accepts two arguments: the buffer to display and an
action alist.  It attempts to display the buffer in some window, picking or
creating a window according to its own criteria.  If successful, it returns
the window; otherwise, it returns @code{nil}.  @xref{Display Action
Functions}, for a list of predefined action functions.

  @code{display-buffer} works by combining display actions from several
sources, and calling the action functions in turn, until one of them manages
to display the buffer and returns a non-@code{nil} value.

@deffn Command display-buffer buffer-or-name &optional action frame
This command makes @var{buffer-or-name} appear in some window, without
selecting the window or making the buffer current.  The argument
@var{buffer-or-name} must be a buffer or the name of an existing buffer.
The return value is the window chosen to display the buffer.

The optional argument @var{action}, if non-@code{nil}, should normally be a
display action (described above).  @code{display-buffer} builds a list of
action functions and an action alist, by consolidating display actions from
the following sources (in order):

@itemize
@item
The variable @code{display-buffer-overriding-action}.

@item
The user option @code{display-buffer-alist}.

@item
The @var{action} argument.

@item
The user option @code{display-buffer-base-action}.

@item
The constant @code{display-buffer-fallback-action}.
@end itemize

@noindent
Each action function is called in turn, passing the buffer as the first
argument and the combined action alist as the second argument, until one of
the functions returns non-@code{nil}.  The caller can pass
@code{(allow-no-window . t)} as an element of the action alist to indicate
its readiness to handle the case of not displaying the buffer in a window.

The argument @var{action} can also have a non-@code{nil}, non-list value.
This has the special meaning that the buffer should be displayed in a window
other than the selected one, even if the selected window is already
displaying it.  If called interactively with a prefix argument, @var{action}
is @code{t}.

The optional argument @var{frame}, if non-@code{nil}, specifies which frames
to check when deciding whether the buffer is already displayed.  It is
equivalent to adding an element @code{(reusable-frames . @var{frame})} to
the action alist of @var{action}.  @xref{Display Action Functions}.
@end deffn

@defvar display-buffer-overriding-action
The value of this variable should be a display action, which is treated with
the highest priority by @code{display-buffer}.  The default value is empty,
i.e., @code{(nil . nil)}.
@end defvar

@defopt display-buffer-alist
The value of this option is an alist mapping conditions to display actions.
Each condition may be either a regular expression matching a buffer name or
a function that takes two arguments: a buffer name and the @var{action}
argument passed to @code{display-buffer}.  If the name of the buffer passed
to @code{display-buffer} either matches a regular expression in this alist
or the function specified by a condition returns non-@code{nil}, then
@code{display-buffer} uses the corresponding display action to display the
buffer.
@end defopt

@defopt display-buffer-base-action
The value of this option should be a display action.  This option can be
used to define a ``standard'' display action for calls to
@code{display-buffer}.
@end defopt

@defvr Constant display-buffer-fallback-action
This display action specifies the fallback behavior for
@code{display-buffer} if no other display actions are given.
@end defvr


@node Display Action Functions
@section Action Functions for @code{display-buffer}

The following basic action functions are defined in Emacs.  Each of these
functions takes two arguments: @var{buffer}, the buffer to display, and
@var{alist}, an action alist.  Each action function returns the window if it
succeeds, and @code{nil} if it fails.

@defun display-buffer-same-window buffer alist
This function tries to display @var{buffer} in the selected window.  It
fails if the selected window is a minibuffer window or is dedicated to
another buffer (@pxref{Dedicated Windows}).  It also fails if @var{alist}
has a non-@code{nil} @code{inhibit-same-window} entry.
@end defun

@defun display-buffer-reuse-window buffer alist
This function tries to ``display'' @var{buffer} by finding a window that is
already displaying it.

If @var{alist} has a non-@code{nil} @code{inhibit-same-window} entry, the
selected window is not eligible for reuse.  If @var{alist} contains a
@code{reusable-frames} entry, its value determines which frames to search
for a reusable window:

@itemize @bullet
@item
@code{nil} means consider windows on the selected frame.  (Actually, the
last non-minibuffer frame.)
@item
@code{t} means consider windows on all frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

Note that these meanings differ slightly from those of the @var{all-frames}
argument to @code{next-window} (@pxref{Cyclic Window Ordering}).

If @var{alist} contains no @code{reusable-frames} entry, this function
normally searches just the selected frame; however, if the variable
@code{pop-up-frames} is non-@code{nil}, it searches all frames on the
current terminal.  @xref{Choosing Window Options}.

If this function chooses a window on another frame, it makes that frame
visible and, unless @var{alist} contains an @code{inhibit-switch-frame}
entry (@pxref{Choosing Window Options}), raises that frame if necessary.
@end defun

@defun display-buffer-pop-up-frame buffer alist
This function creates a new frame, and displays the buffer in that frame's
window.  It actually performs the frame creation by calling the function
specified in @code{pop-up-frame-function} (@pxref{Choosing Window
Options}).  If @var{alist} contains a @code{pop-up-frame-parameters} entry,
the associated value is added to the newly created frame's parameters.
@end defun

@defun display-buffer-pop-up-window buffer alist
This function tries to display @var{buffer} by splitting the largest or
least recently-used window (typically one on the selected frame).  It
actually performs the split by calling the function specified in
@code{split-window-preferred-function} (@pxref{Choosing Window Options}).

The size of the new window can be adjusted by supplying @code{window-height}
and @code{window-width} entries in @var{alist}.  To adjust the window's
height, use an entry whose @sc{car} is @code{window-height} and whose
@sc{cdr} is one of:

@itemize @bullet
@item
@code{nil} means to leave the height of the new window alone.

@item
A number specifies the desired height of the new window.  An integer
specifies the number of lines of the window.  A floating-point number gives
the fraction of the window's height with respect to the height of the
frame's root window.

@item
If the @sc{cdr} specifies a function, that function is called with one
argument: the new window.  The function is supposed to adjust the height of
the window; its return value is ignored.  Suitable functions are
@code{shrink-window-if-larger-than-buffer} and @code{fit-window-to-buffer},
see @ref{Resizing Windows}.
@end itemize

To adjust the window's width, use an entry whose @sc{car} is
@code{window-width} and whose @sc{cdr} is one of:

@itemize @bullet
@item
@code{nil} means to leave the width of the new window alone.

@item
A number specifies the desired width of the new window.  An integer
specifies the number of columns of the window.  A floating-point number
gives the fraction of the window's width with respect to the width of the
frame's root window.

@item
If the @sc{cdr} specifies a function, that function is called with one
argument: the new window.  The function is supposed to adjust the width of
the window; its return value is ignored.
@end itemize

This function can fail if no window splitting can be performed for some
reason (e.g., if the selected frame has an @code{unsplittable} frame
parameter; @pxref{Buffer Parameters}).
@end defun

@defun display-buffer-below-selected buffer alist
This function tries to display @var{buffer} in a window below the selected
window.  This means to either split the selected window or use the window
below the selected one.  If it does create a new window, it will also adjust
its size provided @var{alist} contains a suitable @code{window-height} or
@code{window-width} entry, see above.
@end defun

@defun display-buffer-in-previous-window buffer alist
This function tries to display @var{buffer} in a window previously showing
it.  If @var{alist} has a non-@code{nil} @code{inhibit-same-window} entry,
the selected window is not eligible for reuse.  If @var{alist} contains a
@code{reusable-frames} entry, its value determines which frames to search
for a suitable window as with @code{display-buffer-reuse-window}.

If @var{alist} has a @code{previous-window} entry, the window specified by
that entry will override any other window found by the methods above, even
if that window never showed @var{buffer} before.
@end defun

@defun display-buffer-at-bottom buffer alist
This function tries to display @var{buffer} in a window at the bottom of the
selected frame.

This either splits the window at the bottom of the frame or the frame's root
window, or reuses an existing window at the bottom of the selected frame.
@end defun

@defun display-buffer-use-some-window buffer alist
This function tries to display @var{buffer} by choosing an existing window
and displaying the buffer in that window.  It can fail if all windows are
dedicated to another buffer (@pxref{Dedicated Windows}).
@end defun

@defun display-buffer-no-window buffer alist
If @var{alist} has a non-@code{nil} @code{allow-no-window} entry, then this
function does not display @code{buffer}.  This allows to override the
default action and avoid displaying the buffer.  It is assumed that when the
caller specifies a non-@code{nil} @code{allow-no-window} value it can handle
a @code{nil} value returned from @code{display-buffer} in this case.
@end defun

To illustrate the use of action functions, consider the following example.

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-reuse-window
    display-buffer-pop-up-window
    display-buffer-pop-up-frame)
   (reusable-frames . 0)
   (window-height . 10) (window-width . 40)))
@end group
@end example

@noindent
Evaluating the form above will cause @code{display-buffer} to proceed as
follows: If a buffer called *foo* already appears on a visible or iconified
frame, it will reuse its window.  Otherwise, it will try to pop up a new
window or, if that is impossible, a new frame and show the buffer there.  If
all these steps fail, it will proceed using whatever
@code{display-buffer-base-action} and @code{display-buffer-fallback-action}
prescribe.

   Furthermore, @code{display-buffer} will try to adjust a reused window
(provided *foo* was put by @code{display-buffer} there before) or a
popped-up window as follows: If the window is part of a vertical
combination, it will set its height to ten lines.  Note that if, instead of
the number ``10'', we specified the function @code{fit-window-to-buffer},
@code{display-buffer} would come up with a one-line window to fit the empty
buffer.  If the window is part of a horizontal combination, it sets its
width to 40 columns.  Whether a new window is vertically or horizontally
combined depends on the shape of the window split and the values of
@code{split-window-preferred-function}, @code{split-height-threshold} and
@code{split-width-threshold} (@pxref{Choosing Window Options}).

   Now suppose we combine this call with a preexisting setup for
`display-buffer-alist' as follows.

@example
@group
(let ((display-buffer-alist
       (cons
        '("\\*foo\\*"
          (display-buffer-reuse-window display-buffer-below-selected)
          (reusable-frames)
          (window-height . 5))
        display-buffer-alist)))
  (display-buffer
   (get-buffer-create "*foo*")
   '((display-buffer-reuse-window
      display-buffer-pop-up-window
      display-buffer-pop-up-frame)
     (reusable-frames . 0)
     (window-height . 10) (window-width . 40))))
@end group
@end example

@noindent
This form will have @code{display-buffer} first try reusing a window that
shows *foo* on the selected frame.  If there's no such window, it will try
to split the selected window or, if that is impossible, use the window below
the selected window.

   If there's no window below the selected one, or the window below the
selected one is dedicated to its buffer, @code{display-buffer} will proceed
as described in the previous example.  Note, however, that when it tries to
adjust the height of any reused or popped-up window, it will in any case try
to set its number of lines to ``5'' since that value overrides the
corresponding specification in the @var{action} argument of
@code{display-buffer}.


@node Choosing Window Options
@section Additional Options for Displaying Buffers

The behavior of the standard display actions of @code{display-buffer}
(@pxref{Choosing Window}) can be modified by a variety of user options.

@defopt pop-up-windows
If the value of this variable is non-@code{nil}, @code{display-buffer} is
allowed to split an existing window to make a new window for displaying in.
This is the default.

This variable is provided mainly for backward compatibility.  It is obeyed
by @code{display-buffer} via a special mechanism in
@code{display-buffer-fallback-action}, which only calls the action function
@code{display-buffer-pop-up-window} (@pxref{Display Action Functions}) when
the value is @code{nil}.  It is not consulted by
@code{display-buffer-pop-up-window} itself, which the user may specify
directly in @code{display-buffer-alist} etc.
@end defopt

@defopt split-window-preferred-function
This variable specifies a function for splitting a window, in order to make
a new window for displaying a buffer.  It is used by the
@code{display-buffer-pop-up-window} action function to actually split the
window (@pxref{Display Action Functions}).

The default value is @code{split-window-sensibly}, which is documented
below.  The value must be a function that takes one argument, a window, and
return either a new window (which will be used to display the desired
buffer) or @code{nil} (which means the splitting failed).
@end defopt

@defun split-window-sensibly window
This function tries to split @var{window}, and return the newly created
window.  If @var{window} cannot be split, it returns @code{nil}.

This function obeys the usual rules that determine when a window may be
split (@pxref{Splitting Windows}).  It first tries to split by placing the
new window below, subject to the restriction imposed by
@code{split-height-threshold} (see below), in addition to any other
restrictions.  If that fails, it tries to split by placing the new window to
the right, subject to @code{split-width-threshold} (see below).  If that
fails, and the window is the only window on its frame, this function again
tries to split and place the new window below, disregarding
@code{split-height-threshold}.  If this fails as well, this function gives
up and returns @code{nil}.
@end defun

@defopt split-height-threshold
This variable, used by @code{split-window-sensibly}, specifies whether to
split the window placing the new window below.  If it is an integer, that
means to split only if the original window has at least that many lines.  If
it is @code{nil}, that means not to split this way.
@end defopt

@defopt split-width-threshold
This variable, used by @code{split-window-sensibly}, specifies whether to
split the window placing the new window to the right.  If the value is an
integer, that means to split only if the original window has at least that
many columns.  If the value is @code{nil}, that means not to split this way.
@end defopt

@defopt pop-up-frames
If the value of this variable is non-@code{nil}, that means
@code{display-buffer} may display buffers by making new frames.  The default
is @code{nil}.

A non-@code{nil} value also means that when @code{display-buffer} is looking
for a window already displaying @var{buffer-or-name}, it can search any
visible or iconified frame, not just the selected frame.

This variable is provided mainly for backward compatibility.  It is obeyed
by @code{display-buffer} via a special mechanism in
@code{display-buffer-fallback-action}, which calls the action function
@code{display-buffer-pop-up-frame} (@pxref{Display Action Functions})  if
the value is non-@code{nil}.  (This is done before attempting to split a
window.)  This variable is not consulted by
@code{display-buffer-pop-up-frame} itself, which the user may specify
directly in @code{display-buffer-alist} etc.
@end defopt

@defopt pop-up-frame-function
This variable specifies a function for creating a new frame, in order to
make a new window for displaying a buffer.  It is used by the
@code{display-buffer-pop-up-frame} action function (@pxref{Display Action
Functions}).

The value should be a function that takes no arguments and returns a frame,
or @code{nil} if no frame could be created.  The default value is a function
that creates a frame using the parameters specified by
@code{pop-up-frame-alist} (see below).
@end defopt

@defopt pop-up-frame-alist
This variable holds an alist of frame parameters (@pxref{Frame Parameters}),
which is used by the default function in @code{pop-up-frame-function} to
make a new frame.  The default is @code{nil}.
@end defopt

@defopt same-window-buffer-names
A list of buffer names for buffers that should be displayed in the selected
window.  If a buffer's name is in this list, @code{display-buffer} handles
the buffer by showing it in the selected window.
@end defopt

@defopt same-window-regexps
A list of regular expressions that specify buffers that should be displayed
in the selected window.  If the buffer's name matches any of the regular
expressions in this list, @code{display-buffer} handles the buffer by
showing it in the selected window.
@end defopt

@defun same-window-p buffer-name
This function returns @code{t} if displaying a buffer named
@var{buffer-name} with @code{display-buffer} would put it in the selected
window.
@end defun

@node Window History
@section Window History
@cindex window history

Each window remembers in a list the buffers it has previously displayed, and
the order in which these buffers were removed from it.  This history is
used, for example, by @code{replace-buffer-in-windows} (@pxref{Buffers and
Windows}).  The list is automatically maintained by Emacs, but you can use
the following functions to explicitly inspect or alter it:

@defun window-prev-buffers &optional window
This function returns a list specifying the previous contents of
@var{window}.  The optional argument @var{window} should be a live window
and defaults to the selected one.

Each list element has the form @code{(@var{buffer} @var{window-start}
@var{window-pos})}, where @var{buffer} is a buffer previously shown in the
window, @var{window-start} is the window start position (@pxref{Window Start
and End}) when that buffer was last shown, and @var{window-pos} is the point
position (@pxref{Window Point}) when that buffer was last shown in
@var{window}.

The list is ordered so that earlier elements correspond to more
recently-shown buffers, and the first element usually corresponds to the
buffer most recently removed from the window.
@end defun

@defun set-window-prev-buffers window prev-buffers
This function sets @var{window}'s previous buffers to the value of
@var{prev-buffers}.  The argument @var{window} must be a live window and
defaults to the selected one.  The argument @var{prev-buffers} should be a
list of the same form as that returned by @code{window-prev-buffers}.
@end defun

In addition, each buffer maintains a list of @dfn{next buffers}, which is a
list of buffers re-shown by @code{switch-to-prev-buffer} (see below).  This
list is mainly used by @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} for choosing buffers to switch to.

@defun window-next-buffers &optional window
This function returns the list of buffers recently re-shown in @var{window}
via @code{switch-to-prev-buffer}.  The @var{window} argument must denote a
live window or @code{nil} (meaning the selected window).
@end defun

@defun set-window-next-buffers window next-buffers
This function sets the next buffer list of @var{window} to
@var{next-buffers}.  The @var{window} argument should be a live window or
@code{nil} (meaning the selected window).  The argument @var{next-buffers}
should be a list of buffers.
@end defun

The following commands can be used to cycle through the global buffer list,
much like @code{bury-buffer} and @code{unbury-buffer}.  However, they cycle
according to the specified window's history list, rather than the global
buffer list.  In addition, they restore window-specific window start and
point positions, and may show a buffer even if it is already shown in
another window.  The @code{switch-to-prev-buffer} command, in particular, is
used by @code{replace-buffer-in-windows}, @code{bury-buffer} and
@code{quit-window} to find a replacement buffer for a window.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
This command displays the previous buffer in @var{window}.  The argument
@var{window} should be a live window or @code{nil} (meaning the selected
window).  If the optional argument @var{bury-or-kill} is non-@code{nil},
this means that the buffer currently shown in @var{window} is about to be
buried or killed and consequently should not be switched to in future
invocations of this command.

The previous buffer is usually the buffer shown before the buffer currently
shown in @var{window}.  However, a buffer that has been buried or killed, or
has been already shown by a recent invocation of
@code{switch-to-prev-buffer}, does not qualify as previous buffer.

If repeated invocations of this command have already shown all buffers
previously shown in @var{window}, further invocations will show buffers from
the buffer list of the frame @var{window} appears on (@pxref{Buffer List}),
trying to skip buffers that are already shown in another window on that
frame.
@end deffn

@deffn Command switch-to-next-buffer &optional window
This command switches to the next buffer in @var{window}, thus undoing the
effect of the last @code{switch-to-prev-buffer} command in @var{window}.
The argument @var{window} must be a live window and defaults to the selected
one.

If there is no recent invocation of @code{switch-to-prev-buffer} that can be
undone, this function tries to show a buffer from the buffer list of the
frame @var{window} appears on (@pxref{Buffer List}).
@end deffn

By default @code{switch-to-prev-buffer} and @code{switch-to-next-buffer} can
switch to a buffer that is already shown in another window on the same
frame.  The following option can be used to override this behavior.

@defopt switch-to-visible-buffer
If this variable is non-@code{nil}, @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} may switch to a buffer that is already visible
on the same frame, provided the buffer was shown in the relevant window
before.  If it is @code{nil}, @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} always try to avoid switching to a buffer that
is already visible in another window on the same frame.  The default is
@code{t}.
@end defopt


@node Dedicated Windows
@section Dedicated Windows
@cindex dedicated window

Functions for displaying a buffer can be told to not use specific windows by
marking these windows as @dfn{dedicated} to their buffers.
@code{display-buffer} (@pxref{Choosing Window}) never uses a dedicated
window for displaying another buffer in it.  @code{get-lru-window} and
@code{get-largest-window} (@pxref{Cyclic Window Ordering}) do not consider
dedicated windows as candidates when their @var{dedicated} argument is
non-@code{nil}.  The behavior of @code{set-window-buffer} (@pxref{Buffers
and Windows}) with respect to dedicated windows is slightly different, see
below.

   Functions supposed to remove a buffer from a window or a window from a frame
can behave specially when a window they operate on is dedicated.  We will
distinguish three basic cases, namely where (1) the window is not the only
window on its frame, (2) the window is the only window on its frame but
there are other frames on the same terminal left, and (3)  the window is the
only window on the only frame on the same terminal.

@c FIXME: Does replace-buffer-in-windows _delete_ a window in case (1)?
   In particular, @code{delete-windows-on} (@pxref{Deleting Windows})  handles
case (2) by deleting the associated frame and case (3) by showing another
buffer in that frame's only window.  The function
@code{replace-buffer-in-windows} (@pxref{Buffers and Windows}) which is
called when a buffer gets killed, deletes the window in case (1) and behaves
like @code{delete-windows-on} otherwise.

   When @code{bury-buffer} (@pxref{Buffer List}) operates on the selected
window (which shows the buffer that shall be buried), it handles case (2) by
calling @code{frame-auto-hide-function} (@pxref{Quitting Windows}) to deal
with the selected frame.  The other two cases are handled as with
@code{replace-buffer-in-windows}.

@defun window-dedicated-p &optional window
This function returns non-@code{nil} if @var{window} is dedicated to its
buffer and @code{nil} otherwise.  More precisely, the return value is the
value assigned by the last call of @code{set-window-dedicated-p} for
@var{window}, or @code{nil} if that function was never called with
@var{window} as its argument.  The default for @var{window} is the selected
window.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated to its buffer if @var{flag} is
non-@code{nil}, and non-dedicated otherwise.

As a special case, if @var{flag} is @code{t}, @var{window} becomes
@dfn{strongly} dedicated to its buffer.  @code{set-window-buffer} signals an
error when the window it acts upon is strongly dedicated to its buffer and
does not already display the buffer it is asked to display.  Other functions
do not treat @code{t} differently from any non-@code{nil} value.
@end defun


@node Quitting Windows
@section Quitting Windows

When you want to get rid of a window used for displaying a buffer, you can
call @code{delete-window} or @code{delete-windows-on} (@pxref{Deleting
Windows}) to remove that window from its frame.  If the buffer is shown on a
separate frame, you might want to call @code{delete-frame} (@pxref{Deleting
Frames}) instead.  If, on the other hand, a window has been reused for
displaying the buffer, you might prefer showing the buffer previously shown
in that window, by calling the function @code{switch-to-prev-buffer}
(@pxref{Window History}).  Finally, you might want to either bury
(@pxref{Buffer List}) or kill (@pxref{Killing Buffers}) the window's buffer.

   The following command uses information on how the window for displaying the
buffer was obtained in the first place, thus attempting to automate the
above decisions for you.

@deffn Command quit-window &optional kill window
This command quits @var{window} and buries its buffer.  The argument
@var{window} must be a live window and defaults to the selected one.  With
prefix argument @var{kill} non-@code{nil}, it kills the buffer instead of
burying it.  It calls the function @code{quit-restore-window} described next
to deal with the window and its buffer.
@end deffn

@defun quit-restore-window &optional window bury-or-kill
This function tries to restore the state of @var{window} that existed before
its buffer was displayed in it.  The optional argument @var{window} must be
a live window and defaults to the selected one.

If @var{window} was created specially for displaying its buffer, this
function deletes @var{window} provided its frame contains at least one other
live window.  If @var{window} is the only window on its frame and there are
other frames on the frame's terminal, the value of the optional argument
@var{bury-or-kill} determines how to proceed with the window.  If
@var{bury-or-kill} equals @code{kill}, the frame is deleted
unconditionally.  Otherwise, the fate of the frame is determined by calling
@code{frame-auto-hide-function} (see below) with that frame as sole
argument.

Otherwise, this function tries to redisplay the buffer previously shown in
@var{window}.  It also tries to restore the window start (@pxref{Window
Start and End}) and point (@pxref{Window Point})  positions of the
previously shown buffer.  If, in addition, @var{window}'s buffer was
temporarily resized, this function will also try to restore the original
height of @var{window}.

The cases described so far require that the buffer shown in @var{window} is
still the buffer displayed by the last buffer display function for this
window.  If another buffer has been shown in the meantime, or the buffer
previously shown no longer exists, this function calls
@code{switch-to-prev-buffer} (@pxref{Window History}) to show some other
buffer instead.

The optional argument @var{bury-or-kill} specifies how to deal with
@var{window}'s buffer.  The following values are handled:

@table @code
@item nil
This means to not deal with the buffer in any particular way.  As a
consequence, if @var{window} is not deleted, invoking
@code{switch-to-prev-buffer} will usually show the buffer again.

@item append
This means that if @var{window} is not deleted, its buffer is moved to the
end of @var{window}'s list of previous buffers, so it's less likely that a
future invocation of @code{switch-to-prev-buffer} will switch to it.  Also,
it moves the buffer to the end of the frame's buffer list.

@item bury
This means that if @var{window} is not deleted, its buffer is removed from
@var{window}'s list of previous buffers.  Also, it moves the buffer to the
end of the frame's buffer list.  This value provides the most reliable
remedy to not have @code{switch-to-prev-buffer} switch to this buffer again
without killing the buffer.

@item kill
This means to kill @var{window}'s buffer.
@end table

@code{quit-restore-window} bases its decisions on information stored in
@var{window}'s @code{quit-restore} window parameter (@pxref{Window
Parameters}), and resets that parameter to @code{nil} after it's done.
@end defun

The following option specifies how to deal with a frame containing just one
window that should be either quit, or whose buffer should be buried.

@defopt frame-auto-hide-function
The function specified by this option is called to automatically hide
frames.  This function is called with one argument---a frame.

The function specified here is called by @code{bury-buffer} (@pxref{Buffer
List}) when the selected window is dedicated and shows the buffer to bury.
It is also called by @code{quit-restore-window} (see above) when the frame
of the window to quit has been specially created for displaying that
window's buffer and the buffer is not killed.

The default is to call @code{iconify-frame} (@pxref{Visibility of Frames}).
Alternatively, you may specify either @code{delete-frame} (@pxref{Deleting
Frames}) to remove the frame from its display, @code{ignore} to leave the
frame unchanged, or any other function that can take a frame as its sole
argument.

Note that the function specified by this option is called only if the
specified frame contains just one live window and there is at least one
other frame on the same terminal.
@end defopt


@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point (@pxref{Point}), independent of the
value of point in other windows displaying the same buffer.  This makes it
useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the window's
value of point.  Conversely, deselecting a window sets the window's value of
point from that of the buffer.  Thus, when you switch between windows that
display a given buffer, the point value for the selected window is in effect
in the buffer, while the point values for the other windows are stored in
those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   As far as the user is concerned, point is where the cursor is, and when the
user switches to another buffer, the cursor jumps to the position of point
in that buffer.

@defun window-point &optional window
This function returns the current position of point in @var{window}.  For a
nonselected window, this is the value point would have (in that window's
buffer) if that window were selected.  The default for @var{window} is the
selected window.

When @var{window} is the selected window, the value returned is the value of
point in that window's buffer.  Strictly speaking, it would be more correct
to return the ``top-level'' value of point, outside of any
@code{save-excursion} forms.  But that value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position @var{position} in
@var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, this simply does @code{goto-char} in
@var{window}'s buffer.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker Insertion
Types}) of @code{window-point}.  The default is @code{nil}, so
@code{window-point} will stay behind text inserted there.
@end defvar

@node Window Start and End
@section The Window Start and End Positions
@cindex window start position
@cindex display-start position

  Each window maintains a marker used to keep track of a buffer position that
specifies where in the buffer display should start.  This position is called
the @dfn{display-start} position of the window (or just the @dfn{start}).
The character after this position is the one that appears at the upper left
corner of the window.  It is usually, but not inevitably, at the beginning
of a text line.

  After switching windows or buffers, and in some other cases, if the window
start is in the middle of a line, Emacs adjusts the window start to the
start of a line.  This prevents certain operations from leaving the window
start at a meaningless point within a line.  This feature may interfere with
testing some Lisp code by executing it using the commands of Lisp mode,
because they trigger this readjustment.  To test such code, put it into a
command and bind the command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window @var{window}.  If
@var{window} is @code{nil}, the selected window is used.

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used for
the same buffer, or to @code{point-min} if the buffer doesn't have any.

Redisplay updates the window-start position (if you have not specified it
explicitly since the previous redisplay)---to make sure point appears on the
screen.  Nothing except redisplay automatically changes the window-start
position; if you move point, do not expect the window-start position to
change in response until after the next redisplay.
@end defun

@cindex window end position
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the value
that @code{window-end} returns.  The value is updated only when Emacs
redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.  In
that case, this function returns @code{nil}.

If @var{update} is non-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position is
still valid, @code{window-end} returns that value; otherwise it computes the
correct value by scanning the buffer text.

Even if @var{update} is non-@code{nil}, @code{window-end} does not attempt
to scroll the display if point has moved off the screen, the way real
redisplay would do.  It does not alter the @code{window-start} value.  In
effect, it reports where the displayed text will end if scrolling is not
required.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they change the display-start position (that
is, scroll the window) whenever necessary to make point visible.  However,
if you specify the start position with this function using @code{nil} for
@var{noforce}, it means you want display to start at @var{position} even if
that would put the location of point off the screen.  If this does place
point off screen, the display routines move point to the left margin on the
middle line in the window.

For example, if point @w{is 1} and you set the start of the window @w{to
37}, the start of the next line, point will be ``above'' the top of the
window.  The display routines will automatically move point if it is still 1
when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If @var{noforce} is non-@code{nil}, and @var{position} would place point off
screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns non-@code{nil} if @var{position} is within the range
of text currently visible on the screen in @var{window}.  It returns
@code{nil} if @var{position} is scrolled vertically out of view.  Locations
that are partially obscured are not considered visible unless
@var{partially} is non-@code{nil}.  The argument @var{position} defaults to
the current position of point in @var{window}; @var{window}, to the selected
window.  If @var{position} is @code{t}, that means to check the last visible
position in @var{window}.

This function considers only vertical scrolling.  If @var{position} is out
of view only because @var{window} has been scrolled horizontally,
@code{pos-visible-in-window-p} returns non-@code{nil} anyway.
@xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
non-@code{nil}, and the character following @var{position} is fully visible,
it returns a list of the form @code{(@var{x} @var{y})}, where @var{x} and
@var{y} are the pixel coordinates relative to the top left corner of the
window; otherwise it returns an extended list of the form @code{(@var{x}
@var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})}, where @var{rtop} and
@var{rbot} specify the number of off-window pixels at the top and bottom of
the row at @var{position}, @var{rowh} specifies the visible height of that
row, and @var{vpos} specifies the vertical position (zero-based row number)
of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in @var{window}.
If @var{line} is one of @code{header-line} or @code{mode-line},
@code{window-line-height} returns information about the corresponding line
of the window.  Otherwise, @var{line} is a text line number starting from
0.  A negative number counts from the end of the window.  The default for
@var{line} is the current line in @var{window}; the default for @var{window}
is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used to
obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns a list
@code{(@var{height} @var{vpos} @var{ypos} @var{offbot})}, where @var{height}
is the height in pixels of the visible part of the line, @var{vpos} and
@var{ypos} are the vertical position in lines and pixels of the line
relative to the top of the first text line, and @var{offbot} is the number
of off-window pixels at the bottom of the text line.  If there are
off-window pixels at the top of the (first)  text line, @var{ypos} is
negative.
@end defun

@node Textual Scrolling
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a window.
It works by changing the window's display-start location.  It may also
change the value of @code{window-point} to keep point on the screen
(@pxref{Window Point}).

  The basic textual scrolling functions are @code{scroll-up} (which scrolls
forward) and @code{scroll-down} (which scrolls backward).  In these function
names, ``up'' and ``down'' refer to the direction of motion of the buffer
text relative to the window.  Imagine that the text is written on a long
roll of paper and that the scrolling commands move the paper up and down.
Thus, if you are looking at the middle of a buffer and repeatedly call
@code{scroll-down}, you will eventually see the beginning of the buffer.

  Unfortunately, this sometimes causes confusion, because some people tend to
think in terms of the opposite convention: they imagine the window moving
over text that remains in place, so that ``down'' commands take you to the
end of the buffer.  This convention is consistent with fact that such a
command is bound to a key named @key{PageDown} on modern keyboards.
@ignore
We have not switched to this convention as that is likely to break
existing Emacs Lisp code.
@end ignore

  Textual scrolling functions (aside from @code{scroll-other-window})  have
unpredictable results if the current buffer is not the one displayed in the
selected window.  @xref{Current Buffer}.

  If the window contains a row taller than the height of the window (for
example in the presence of a large image), the scroll functions will adjust
the window's vertical scroll position to scroll the partially visible row.
Lisp callers can disable this feature by binding the variable
@code{auto-window-vscroll} to @code{nil} (@pxref{Vertical Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls forward by @var{count} lines in the selected window.

If @var{count} is negative, it scrolls backward instead.  If @var{count} is
@code{nil} (or omitted), the distance scrolled is
@code{next-screen-context-lines} lines less than the height of the window's
text area.

If the selected window cannot be scrolled any further, this function signals
an error.  Otherwise, it returns @code{nil}.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls backward by @var{count} lines in the selected window.

If @var{count} is negative, it scrolls forward instead.  In other respects,
it behaves the same way as @code{scroll-up} does.
@end deffn

@deffn Command scroll-up-command &optional count
This behaves like @code{scroll-up}, except that if the selected window
cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the end of
the buffer instead.  If point is already there, it signals an error.
@end deffn

@deffn Command scroll-down-command &optional count
This behaves like @code{scroll-down}, except that if the selected window
cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the
beginning of the buffer instead.  If point is already there, it signals an
error.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count} lines.
Negative values of @var{count}, or @code{nil}, are handled as in
@code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't already
displayed, @code{scroll-other-window} displays it in some window.

When the selected window is the minibuffer, the next window is normally the
leftmost one immediately above it.  You can specify a different window to
scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any other
window is selected.  When it is non-@code{nil} and the minibuffer is
selected, it takes precedence over @code{other-window-scroll-buffer}.
@xref{Definition of minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected window
is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the line
reappears after the echo area momentarily displays the message @samp{End of
buffer}.
@end deffn

@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number of
lines between point and the top or bottom of a window.  Whenever point gets
within this many lines of the top or bottom of the window, redisplay scrolls
the text automatically (if possible) to move point out of the margin, closer
to the center of the window.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point moves
off the screen (or into the scroll margin).  If the value is a positive
integer @var{n}, then redisplay scrolls the text up to @var{n} lines in
either direction, if that will bring point back into proper view.  This
behavior is called @dfn{conservative scrolling}.  Otherwise, scrolling
happens in the usual way, under the control of other variables such as
@code{scroll-up-aggressively} and @code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling never
happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction @var{f}
between 0 and 1.  If it is a fraction, that specifies where on the screen to
put point when scrolling down.  More precisely, when a window scrolls down
because point is above the window start, the new start position is chosen to
put point @var{f} part of the window height from the top.  The larger
@var{f}, the more aggressive the scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far point
should be placed from the bottom of the window; thus, as with
@code{scroll-up-aggressively}, a larger value scrolls more aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.  The
difference is that if its value is @var{n}, that permits scrolling only by
precisely @var{n} lines, not a smaller number.  This feature does not work
with @code{scroll-margin}.  The default value is zero.
@end defopt

@cindex @code{scroll-command} property
@defopt scroll-preserve-screen-position
If this option is @code{t}, whenever a scrolling command moves point
off-window, Emacs tries to adjust point to keep the cursor at its old
vertical position in the window, rather than the window edge.

If the value is non-@code{nil} and not @code{t}, Emacs adjusts point to keep
the cursor at the same vertical position, even if the scrolling command
didn't move point off-window.

This option affects all scroll commands that have a non-@code{nil}
@code{scroll-command} symbol property.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to retain
when scrolling by full screens.  For example, @code{scroll-up} with an
argument of @code{nil} scrolls so that this many lines at the bottom of the
window appear instead at the top.  The default value is @code{2}.
@end defopt

@defopt scroll-error-top-bottom
If this option is @code{nil} (the default), @code{scroll-up-command} and
@code{scroll-down-command} simply signal an error when no more scrolling is
possible.

If the value is @code{t}, these commands instead move point to the beginning
or end of the buffer (depending on scrolling direction); only if point is
already on that position do they signal an error.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does not
``move point'' with respect to the text.

If @var{count} is a non-negative number, that puts the line containing point
@var{count} lines down from the top of the window.  If @var{count} is a
negative number, then it counts upward from the bottom of the window, so
that @minus{}1 stands for the last usable line in the window.

If @var{count} is @code{nil} (or a non-@code{nil} list), @code{recenter}
puts the line containing point in the middle of the window.  If @var{count}
is @code{nil}, this function may redraw the frame, according to the value of
@code{recenter-redisplay}.

When @code{recenter} is called interactively, @var{count} is the raw prefix
argument.  Thus, typing @kbd{C-u} as the prefix sets the @var{count} to a
non-@code{nil} list, while typing @kbd{C-u 4} sets @var{count} to 4, which
positions the current line four lines from the top.

With an argument of zero, @code{recenter} positions the current line at the
top of the window.  The command @code{recenter-top-bottom} offers a more
convenient way to achieve this.
@end deffn

@defopt recenter-redisplay
If this variable is non-@code{nil}, calling @code{recenter} with a
@code{nil} argument redraws the frame.  The default value is @code{tty},
which means only redraw the frame if it is a tty frame.
@end defopt

@deffn Command recenter-top-bottom &optional count
This command, which is the default binding for @kbd{C-l}, acts like
@code{recenter}, except if called with no argument.  In that case,
successive calls place point according to the cycling order defined by the
variable @code{recenter-positions}.
@end deffn

@defopt recenter-positions
This variable controls how @code{recenter-top-bottom} behaves when called
with no argument.  The default value is @code{(middle top bottom)}, which
means that successive calls of @code{recenter-top-bottom} with no argument
cycle between placing point at the middle, top, and bottom of the window.
@end defopt


@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window up or
down by a specified multiple or fraction of a line.  Each window has a
@dfn{vertical scroll position}, which is a number, never less than zero.  It
specifies how far to raise the contents of the window.  Raising the window
contents generally makes all or part of some lines disappear off the top,
and all or part of some other lines appear at the bottom.  The usual value
is zero.

   The vertical scroll position is measured in units of the normal line height,
which is the height of the default font.  Thus, if the value is .5, that
means the window contents are scrolled up half the normal line height.  If
it is 3.3, that means the window contents are scrolled up somewhat over
three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many lines,
depends on what the lines contain.  A value of .5 could scroll a line whose
height is very short off the screen, while a value of 3.3 could scroll just
part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of @var{window}.
The default for @var{window} is the selected window.  If @var{pixels-p} is
non-@code{nil}, the return value is measured in pixels, rather than in units
of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to @var{lines}.
If @var{window} is @code{nil}, the selected window is used.  The argument
@var{lines} should be zero or positive; if not, it is taken as zero.


The actual vertical scroll position must always correspond to an integral
number of pixels, so the value you specify is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is non-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is non-@code{nil}, the @code{line-move}, @code{scroll-up},
and @code{scroll-down} functions will automatically modify the vertical
scroll position to scroll through display rows that are taller than the
height of the window, for example in the presence of large images.
@end defvar

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left or
right by a specified multiple of the normal character width.  Each window
has a @dfn{horizontal scroll position}, which is a number, never less than
zero.  It specifies how far to shift the contents left.  Shifting the window
contents left generally makes all or part of some characters disappear off
the left, and all or part of some other characters appear at the right.  The
usual value is zero.

  The horizontal scroll position is measured in units of the normal character
width, which is the width of space in the default font.  Thus, if the value
is 5, that means the window contents are scrolled left by 5 times the normal
character width.  How many characters actually disappear off to the left
depends on their width, and could vary from line to line.

  Because we read from side to side in the ``inner loop'', and from top to
bottom in the ``outer loop'', the effect of horizontal scrolling is not like
that of textual or vertical scrolling.  Textual scrolling involves selection
of a portion of text to display, and vertical scrolling moves the window
contents contiguously; but horizontal scrolling causes part of @emph{each
line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost column is
at the left edge of the window.  In this state, scrolling to the right is
meaningless, since there is no data to the left of the edge to be revealed
by it; so this is not allowed.  Scrolling to the left is allowed; it scrolls
the first columns of text off the edge of the window and can reveal
additional columns on the right that were truncated before.  Once a window
has a nonzero amount of leftward horizontal scrolling, you can scroll it
back to the right, but only so far as to reduce the net horizontal scroll to
zero.  There is no limit to how far left you can scroll, but eventually all
the text will disappear off the left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters the
horizontal scrolling of a window as necessary to ensure that point is always
visible.  However, you can still set the horizontal scrolling value
explicitly.  The value you specify serves as a lower bound for automatic
scrolling, i.e., automatic scrolling will not scroll a window to a column
less than the specified one.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the left
(or to the right if @var{count} is negative).  The default for @var{count}
is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll any
farther right have no effect.

If @var{set-minimum} is non-@code{nil}, the new scroll amount becomes the
lower bound for automatic scrolling; that is, automatic scrolling will not
scroll a window to a column less than the value returned by this function.
Interactive calls pass non-@code{nil} for @var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the right
(or to the left if @var{count} is negative).  The default for @var{count} is
the window width, minus 2.  Aside from the direction of scrolling, this
works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window} is
scrolled left past the left margin.  The default for @var{window} is the
selected window.

The return value is never negative.  It is zero when no horizontal scrolling
has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns from
the left margin.  The argument @var{columns} should be zero or positive; if
not, it is taken as zero.  Fractional values of @var{columns} are not
supported at present.

Note that @code{set-window-hscroll} may appear not to work if you test it by
evaluating a call with @kbd{M-:} in a simple way.  What happens is that the
function sets the horizontal scroll value and returns, but then redisplay
adjusts the horizontal scrolling to make point visible, and this overrides
what the function did.  You can observe the function's effect if you call it
while point is sufficiently far from the left margin that it will remain
visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position} is off
the screen due to horizontal scrolling:

@c FIXME: Maybe hscroll-on-screen-p is a better name?
@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example

@node Coordinates and Windows
@section Coordinates and Windows
@cindex frame-relative coordinate
@cindex coordinate, relative to frame
@cindex window position

  This section describes functions that report the position of a window.  Most
of these functions report positions relative to the window's frame.  In this
case, the coordinate origin @samp{(0,0)} lies near the upper left corner of
the frame.  For technical reasons, on graphical displays the origin is not
located at the exact corner of the graphical window as it appears on the
screen.  If Emacs is built with the GTK+ toolkit, the origin is at the upper
left corner of the frame area used for displaying Emacs windows, below the
title-bar, GTK+ menu bar, and tool bar (since these are drawn by the window
manager and/or GTK+, not by Emacs).  But if Emacs is not built with GTK+,
the origin is at the upper left corner of the tool bar (since in this case
Emacs itself draws the tool bar).  In both cases, the X and Y coordinates
increase rightward and downward respectively.

  Except where noted, X and Y coordinates are reported in integer character
units, i.e., numbers of lines and columns respectively.  On a graphical
display, each ``line'' and ``column'' corresponds to the height and width of
a default character specified by the frame's default font.

@defun window-edges &optional window
This function returns a list of the edge coordinates of @var{window}.  If
@var{window} is omitted or @code{nil}, it defaults to the selected window.

The return value has the form @code{(@var{left} @var{top} @var{right}
@var{bottom})}.  These list elements are, respectively, the X coordinate of
the leftmost column occupied by the window, the Y coordinate of the topmost
row, the X coordinate one column to the right of the rightmost column, and
the Y coordinate one row down from the bottommost row.

Note that these are the actual outer edges of the window, including any
header line, mode line, scroll bar, fringes, window divider and display
margins.  On a text terminal, if the window has a neighbor on its right, its
right edge includes the separator line between the window and its neighbor.
@end defun

@defun window-inside-edges &optional window
This function is similar to @code{window-edges}, but the returned edge
values are for the text area of the window.  They exclude any header line,
mode line, scroll bar, fringes, window divider, display margins, and
vertical separator.
@end defun

@defun window-top-line &optional window
This function returns the Y coordinate of the topmost row of @var{window},
equivalent to the @var{top} entry in the list returned by
@code{window-edges}.
@end defun

@defun window-left-column &optional window
This function returns the X coordinate of the leftmost column of
@var{window}, equivalent to the @var{left} entry in the list returned by
@code{window-edges}.
@end defun

  The following functions can be used to relate a set of frame-relative
coordinates to a window:

@defun window-at x y &optional frame
This function returns the live window at the frame-relative coordinates
@var{x} and @var{y}, on frame @var{frame}.  If there is no window at that
position, the return value is @code{nil}.  If @var{frame} is omitted or
@code{nil}, it defaults to the selected frame.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a window @var{window} occupies the
frame-relative coordinates @var{coordinates}, and if so, which part of the
window that is.  @var{window} should be a live window.  @var{coordinates}
should be a cons cell of the form @code{(@var{x} . @var{y})}, where @var{x}
and @var{y} are frame-relative coordinates.

If there is no window at the specified position, the return value is
@code{nil} .  Otherwise, the return value is one of the following:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the specified
position, counting from 0 at the top left corner of the window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item right-divider
The coordinates are in the divider separating @var{window} from a window on
the right.

@item right-divider
The coordinates are in the divider separating @var{window} from a window
beneath.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't have a
scroll bar; positions in a scroll bar are considered outside the window for
these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun

  The following functions return window positions in pixels, rather than
character units.  Though mostly useful on graphical displays, they can also
be called on text terminals, where the screen area of each text character is
taken to be ``one pixel''.

@defun window-pixel-edges &optional window
This function returns a list of pixel coordinates for the edges of
@var{window}.  If @var{window} is omitted or @code{nil}, it defaults to the
selected window.

The return value has the form @code{(@var{left} @var{top} @var{right}
@var{bottom})}.  The list elements are, respectively, the X pixel coordinate
of the left window edge, the Y pixel coordinate of the top edge, one more
than the X pixel coordinate of the right edge, and one more than the Y pixel
coordinate of the bottom edge.
@end defun

@defun window-inside-pixel-edges &optional window
This function is like @code{window-pixel-edges}, except that it returns the
pixel coordinates for the edges of the window's text area, rather than the
pixel coordinates for the edges of the window itself.  @var{window} must
specify a live window.
@end defun

  The following functions return window positions in pixels, relative to the
display screen rather than the frame:

@defun window-absolute-pixel-edges &optional window
This function is like @code{window-pixel-edges}, except that it returns the
edge pixel coordinates relative to the top left corner of the display
screen.
@end defun

@defun window-inside-absolute-pixel-edges &optional window
This function is like @code{window-inside-pixel-edges}, except that it
returns the edge pixel coordinates relative to the top left corner of the
display screen.  @var{window} must specify a live window.
@end defun

@defun window-pixel-left &optional window
This function returns the left pixel edge of window @var{window}.
@var{window} must be a valid window and defaults to the selected one.
@end defun

@defun window-pixel-top &optional window
This function returns the top pixel edge of window @var{window}.
@var{window} must be a valid window and defaults to the selected one.
@end defun


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

A @dfn{window configuration} records the entire layout of one frame---all
windows, their sizes, which buffers they contain, how those buffers are
scrolled, and their values of point and the mark; also their fringes,
margins, and scroll bar settings.  It also includes the value of
@code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window for
the current buffer.

  You can bring back an entire frame layout by restoring a previously saved
window configuration.  If you want to record the layout of all frames
instead of just one, use a frame configuration instead of a window
configuration.  @xref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current window
configuration.  The default for @var{frame} is the selected frame.  The
variable @code{window-persistent-parameters} specifies which window
parameters (if any) are saved by this function.  @xref{Window Parameters}.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as specified
by @var{configuration}, for the frame that @var{configuration} was created
for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether that
frame is selected or not.  This always counts as a window size change and
triggers execution of the @code{window-size-change-functions} (@pxref{Window
Hooks}), because @code{set-window-configuration} doesn't know how to tell
whether the new configuration actually differs from the old one.

If the frame from which @var{configuration} was saved is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}.  In this case,
the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect as
@code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-below nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defmac save-window-excursion forms@dots{}
This macro records the window configuration of the selected frame, executes
@var{forms} in sequence, then restores the earlier window configuration.
The return value is the value of the final form in @var{forms}.

Most Lisp code should not use this macro; @code{save-selected-window} is
typically sufficient.  In particular, this macro cannot reliably prevent the
code in @var{forms} from opening new windows, because new windows might be
opened in other frames (@pxref{Choosing Window}), and
@code{save-window-excursion} only saves and restores the window
configuration on the current frame.

Do not use this macro in @code{window-size-change-functions}; exiting the
macro triggers execution of @code{window-size-change-functions}, leading to
an endless loop.
@end defmac

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the structure of
windows, but ignores the values of point and mark and the saved scrolling
positions---it can return @code{t} even if those aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point or mark.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make sense,
but are not implemented because we did not need them.  See the file
@file{winner.el} for some more operations on windows configurations.

  The objects returned by @code{current-window-configuration} die together
with the Emacs process.  In order to store a window configuration on disk
and read it back in another Emacs session, you can use the functions
described next.  These functions are also useful to clone the state of a
frame into an arbitrary live window (@code{set-window-configuration}
effectively clones the windows of a frame into the root window of that very
frame only).

@cindex window state
@defun window-state-get &optional window writable
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} must be a valid window and defaults to the root window
of the selected frame.

If the optional argument @var{writable} is non-@code{nil}, this means to not
use markers for sampling positions like @code{window-point} or
@code{window-start}.  This argument should be non-@code{nil} when the state
will be written to disk and read back in another session.

Together, the argument @var{writable} and the variable
@code{window-persistent-parameters} specify which window parameters are
saved by this function.  @xref{Window Parameters}.
@end defun

The value returned by @code{window-state-get} can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use the
following function to restore the state of the window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.  The
argument @var{state} should be the state of a window returned by an earlier
invocation of @code{window-state-get}, see above.  The optional argument
@var{window} can be either a live window or an internal window
(@pxref{Windows and Frames}) and defaults to the selected one.  If
@var{window} is not live, it is replaced by a live window before putting
@var{state} into it.

If the optional argument @var{ignore} is non-@code{nil}, it means to ignore
minimum window sizes and fixed-size restrictions.  If @var{ignore} is
@code{safe}, this means windows can get as small as one line and/or two
columns.
@end defun


@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes how window parameters can be used to associate
additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The default
for @var{window} is the selected window.  If @var{window} has no setting for
@var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.  The
default for @var{window} is the selected window.  The return value is either
@code{nil}, or an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to @var{value}
and returns @var{value}.  The default for @var{window} is the selected
window.
@end defun

By default, the functions that save and restore window configurations or the
states of windows (@pxref{Window Configurations}) do not care about window
parameters.  This means that when you change the value of a parameter within
the body of a @code{save-window-excursion}, the previous value is not
restored when that macro exits.  It also means that when you restore via
@code{window-state-put} a window state saved earlier by
@code{window-state-get}, all cloned windows have their parameters reset to
@code{nil}.  The following variable allows you to override the standard
behavior:

@defvar window-persistent-parameters
This variable is an alist specifying which parameters get saved by
@code{current-window-configuration} and @code{window-state-get}, and
subsequently restored by @code{set-window-configuration} and
@code{window-state-put}.  @xref{Window Configurations}.

The @sc{car} of each entry of this alist is a symbol specifying the
parameter.  The @sc{cdr} should be one of the following:

@table @asis
@item @code{nil}
This value means the parameter is saved neither by @code{window-state-get}
nor by @code{current-window-configuration}.

@item @code{t}
This value specifies that the parameter is saved by
@code{current-window-configuration} and (provided its @var{writable}
argument is @code{nil}) by @code{window-state-get}.

@item @code{writable}
This means that the parameter is saved unconditionally by both
@code{current-window-configuration} and @code{window-state-get}.  This value
should not be used for parameters whose values do not have a read syntax.
Otherwise, invoking @code{window-state-put} in another session may fail with
an @code{invalid-read-syntax} error.
@end table
@end defvar

Some functions (notably @code{delete-window}, @code{delete-other-windows}
and @code{split-window}), may behave specially when their @var{window}
argument has a parameter set.  You can override such special behavior by
binding the following variable to a non-@code{nil} value:

@defvar ignore-window-parameters
If this variable is non-@code{nil}, some standard functions do not process
window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows}, and
@code{other-window}.

An application can bind this variable to a non-@code{nil} value around calls
to these functions.  If it does so, the application is fully responsible for
correctly assigning the parameters of all involved windows when exiting that
function.
@end defvar

The following parameters are currently used by the window management code:

@table @asis
@item @code{delete-window}
This parameter affects the execution of @code{delete-window}
(@pxref{Deleting Windows}).

@item @code{delete-other-windows}
This parameter affects the execution of @code{delete-other-windows}
(@pxref{Deleting Windows}).

@item @code{split-window}
This parameter affects the execution of @code{split-window}
(@pxref{Splitting Windows}).

@item @code{other-window}
This parameter affects the execution of @code{other-window} (@pxref{Cyclic
Window Ordering}).

@item @code{no-other-window}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item @code{clone-of}
This parameter specifies the window that this one has been cloned from.  It
is installed by @code{window-state-get} (@pxref{Window Configurations}).

@item @code{quit-restore}
This parameter is installed by the buffer display functions (@pxref{Choosing
Window}) and consulted by @code{quit-restore-window} (@pxref{Quitting
Windows}).  It contains four elements:

The first element is one of the symbols @code{window}, meaning that the
window has been specially created by @code{display-buffer}; @code{frame}, a
separate frame has been created; @code{same}, the window has displayed the
same buffer before; or @code{other}, the window showed another buffer
before.

The second element is either one of the symbols @code{window} or
@code{frame}, or a list whose elements are the buffer shown in the window
before, that buffer's window start and window point positions, and the
window's height at that time.

The third element is the window selected at the time the parameter was
created.  The function @code{quit-restore-window} tries to reselect that
window when it deletes the window passed to it as argument.

The fourth element is the buffer whose display caused the creation of this
parameter.  @code{quit-restore-window} deletes the specified window only if
it still shows that buffer.
@end table

There are additional parameters @code{window-atom} and @code{window-side};
these are reserved and should not be used by applications.


@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a window
displays a different part of its buffer or a different buffer.  There are
three actions that can change this: scrolling the window, switching buffers
in the window, and changing the size of the window.  The first two actions
run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in the
window also runs these functions.

This variable is not a normal hook, because each function is called with two
arguments: the window, and its new display-start position.

These functions must take care when using @code{window-end} (@pxref{Window
Start and End}); if you need an up-to-date value, you must use the
@var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window is
scrolled.  It's not designed for that, and such use probably won't work.
@end defvar

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called just once per
redisplay, and just once for each frame on which size changes have occurred.

Each function receives the frame as its sole argument.  There is no direct
way to find out which windows on that frame have changed size, or precisely
how.  However, if a size-change function records, at each call, the existing
windows and their sizes, it can also compare the present sizes and the
previous sizes.

Creating or deleting windows counts as a size change, and therefore causes
these functions to be called.  Changing the frame size also counts, because
it changes the sizes of the existing windows.

You may use @code{save-selected-window} in these functions (@pxref{Selecting
Windows}).  However, do not use @code{save-window-excursion} (@pxref{Window
Configurations}); exiting that macro counts as a size change, which would
cause these functions to be called over and over.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time you change the window configuration of
an existing frame.  This includes splitting or deleting windows, changing
the sizes of windows, or displaying a different buffer in a window.

The buffer-local part of this hook is run once for each window on the
affected frame, with the relevant window selected and its buffer current.
The global part is run once for the modified frame, with that frame
selected.
@end defvar

  In addition, you can use @code{jit-lock-register} to register a Font Lock
fontification function, which will be called whenever parts of a buffer are
(re)fontified because a window was scrolled or its size changed.
@xref{Other Font Lock Variables}.
